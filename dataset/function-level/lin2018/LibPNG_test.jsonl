{"project": "LibPNG", "target": 0, "func": "static void\ngp_rgba8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = pp[0];\n   p->g = pp[1];\n   p->b = pp[2];\n   p->a = pp[3];\n}\n", "bug_type": null, "idx": 0}
{"project": "LibPNG", "target": 0, "func": "void PNGCBAPI\ncount_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data)\n{\n   if (png_ptr != NULL && row_info != NULL)\n      ++filters_used[*(data - 1)];\n}\n", "bug_type": null, "idx": 1}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_row(png_const_structp pp, png_byte std[STANDARD_ROWMAX],\n   png_uint_32 id, png_uint_32 y)\n{\n   if (WIDTH_FROM_ID(id) == 0)\n      transform_row(pp, std, COL_FROM_ID(id), DEPTH_FROM_ID(id), y);\n   else\n      size_row(std, WIDTH_FROM_ID(id) * bit_size(pp, COL_FROM_ID(id),\n         DEPTH_FROM_ID(id)), y);\n}\n", "bug_type": null, "idx": 2}
{"project": "LibPNG", "target": 0, "func": "LRESULT CALLBACK rpng2_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP)\n{\n    HDC         hdc;\n    PAINTSTRUCT ps;\n    int rc;\n    switch (iMsg) {\n        case WM_CREATE:\n            \n            return 0;\n        case WM_PAINT:\n            hdc = BeginPaint(hwnd, &ps);\n            rc = StretchDIBits(hdc, 0, 0, rpng2_info.width, rpng2_info.height,\n                                    0, 0, rpng2_info.width, rpng2_info.height,\n                                    wimage_data, (BITMAPINFO *)bmih,\n                                    0, SRCCOPY);\n            EndPaint(hwnd, &ps);\n            return 0;\n        \n        case WM_CHAR:\n            switch (wP) {       \n                case 'q':\n                case 'Q':\n                case 0x1B:      \n                    PostQuitMessage(0);\n            }\n            return 0;\n        case WM_LBUTTONDOWN:    \n        case WM_DESTROY:\n            PostQuitMessage(0);\n            return 0;\n    }\n    return DefWindowProc(hwnd, iMsg, wP, lP);\n}\n", "bug_type": null, "idx": 3}
{"project": "LibPNG", "target": 0, "func": "static int\nnext_format(png_bytep colour_type, png_bytep bit_depth,\n   unsigned int* palette_number, int no_low_depth_gray)\n{\n   if (*bit_depth == 0)\n   {\n      *colour_type = 0;\n      if (no_low_depth_gray)\n         *bit_depth = 8;\n      else\n         *bit_depth = 1;\n      *palette_number = 0;\n      return 1;\n   }\n   if (*colour_type == 3)\n   {\n      \n      if (++*palette_number < PALETTE_COUNT(*bit_depth))\n         return 1;\n      *palette_number = 0;\n   }\n   *bit_depth = (png_byte)(*bit_depth << 1);\n   \n   if (*bit_depth <= 8\n#ifdef DO_16BIT\n         || (*colour_type != 3 && *bit_depth <= 16)\n#endif\n      )\n      return 1;\n   \n   switch (*colour_type)\n   {\n      case 0:\n         *colour_type = 2;\n         *bit_depth = 8;\n         return 1;\n      case 2:\n         *colour_type = 3;\n         *bit_depth = 1;\n         return 1;\n      case 3:\n         *colour_type = 4;\n         *bit_depth = 8;\n         return 1;\n      case 4:\n         *colour_type = 6;\n         *bit_depth = 8;\n         return 1;\n      default:\n         return 0;\n   }\n}\n", "bug_type": null, "idx": 4}
{"project": "LibPNG", "target": 0, "func": "static unsigned int\nrandom_mod(unsigned int max)\n{\n   unsigned int x;\n   RANDOMIZE(x);\n   return x % max; \n}\n", "bug_type": null, "idx": 5}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_scale_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(colour_type)\n   this->next = *that;\n   *that = this;\n   return bit_depth > 8;\n}\n", "bug_type": null, "idx": 6}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_from_formats(Transform *result, Image *in_image,\n   const Image *out_image, png_const_colorp background, int via_linear)\n{\n   png_uint_32 in_format, out_format;\n   png_uint_32 in_base, out_base;\n   memset(result, 0, sizeof *result);\n   \n   result->in_image = in_image;\n   result->out_image = out_image;\n   in_format = in_image->image.format;\n   out_format = out_image->image.format;\n   if (in_format & PNG_FORMAT_FLAG_LINEAR)\n      result->in_opaque = 65535;\n   else\n      result->in_opaque = 255;\n   result->output_8bit = (out_format & PNG_FORMAT_FLAG_LINEAR) == 0;\n   result->is_palette = 0; \n   result->accumulate = (in_image->opts & ACCUMULATE) != 0;\n   \n   result->in_gp = get_pixel(in_format);\n   result->out_gp = get_pixel(out_format);\n   \n   in_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;\n   in_base = in_format & BASE_FORMATS;\n   out_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;\n   out_base = out_format & BASE_FORMATS;\n   if (via_linear)\n   {\n      \n      if (out_format & (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLORMAP))\n      {\n         fprintf(stderr, \"internal transform via linear error 0x%x->0x%x\\n\",\n            in_format, out_format);\n         exit(1);\n      }\n      result->transform = gpc_fn[in_base][out_base | PNG_FORMAT_FLAG_LINEAR];\n      result->from_linear = gpc_fn[out_base | PNG_FORMAT_FLAG_LINEAR][out_base];\n      result->error_ptr = gpc_error_via_linear[in_format][out_format];\n   }\n   else if (~in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)\n   {\n      \n\n\n\n      result->transform = gpc_fn[in_base][out_base];\n      result->from_linear = NULL;\n      result->error_ptr = gpc_error_to_colormap[in_base][out_base];\n   }\n   else\n   {\n      \n\n\n\n\n\n      if (in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)\n         result->transform = gpc_fn_colormapped[in_base][out_base];\n      else\n         result->transform = gpc_fn[in_base][out_base];\n      result->from_linear = NULL;\n      result->error_ptr = gpc_error[in_format][out_format];\n   }\n   \n\n\n\n   result->background = NULL; \n   \n   if (in_format & ~out_format & PNG_FORMAT_FLAG_ALPHA)\n   {\n      \n\n\n\n\n\n\n      result->background = &result->background_color;\n      if (out_format & PNG_FORMAT_FLAG_LINEAR || via_linear)\n      {\n         if (out_format & PNG_FORMAT_FLAG_COLORMAP)\n         {\n            result->background_color.ir =\n               result->background_color.ig =\n               result->background_color.ib = 0;\n            result->background_color.dr =\n               result->background_color.dg =\n               result->background_color.db = 0;\n         }\n         else\n         {\n            result->background_color.ir =\n               result->background_color.ig =\n               result->background_color.ib = BUFFER_INIT8 * 257;\n            result->background_color.dr =\n               result->background_color.dg =\n               result->background_color.db = 0;\n         }\n      }\n      else \n      {\n         if (background != NULL)\n         {\n            if (out_format & PNG_FORMAT_FLAG_COLOR)\n            {\n               result->background_color.ir = background->red;\n               result->background_color.ig = background->green;\n               result->background_color.ib = background->blue;\n               \n\n\n               result->background_color.dr = sRGB_to_d[background->red];\n               result->background_color.dg = sRGB_to_d[background->green];\n               result->background_color.db = sRGB_to_d[background->blue];\n            }\n            else \n            {\n               result->background_color.ir =\n                  result->background_color.ig =\n                  result->background_color.ib = background->green;\n               \n\n\n               result->background_color.dr =\n                  result->background_color.dg =\n                  result->background_color.db = sRGB_to_d[background->green];\n            }\n         }\n         else if ((out_format & PNG_FORMAT_FLAG_COLORMAP) == 0)\n         {\n            result->background_color.ir =\n               result->background_color.ig =\n               result->background_color.ib = BUFFER_INIT8;\n            \n\n\n            result->background_color.dr =\n               result->background_color.dg =\n               result->background_color.db = sRGB_to_d[BUFFER_INIT8];\n         }\n         \n\n\n\n         else\n            result->background = NULL;\n      }\n   }\n   if (result->background == NULL)\n   {\n      result->background_color.ir =\n         result->background_color.ig =\n         result->background_color.ib = -1; \n      result->background_color.dr =\n         result->background_color.dg =\n         result->background_color.db = 1E30; \n   }\n   \n   result->error[0] = result->error_ptr[0];\n   result->error[1] = result->error_ptr[1];\n   result->error[2] = result->error_ptr[2];\n   result->error[3] = result->error_ptr[3];\n}\n", "bug_type": null, "idx": 7}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n\n{\n   png_bytep chunkdata;\n   png_bytep entry_start;\n   png_sPLT_t new_palette;\n#ifdef PNG_NO_POINTER_INDEXING\n   png_sPLT_entryp pp;\n#endif\n   int data_length, entry_size, i;\n   png_uint_32 skip = 0;\n   png_size_t slength;\n\n   png_debug(1, \"in png_handle_sPLT\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sPLT\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sPLT after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > (png_uint_32)65535L)\n   {\n      png_warning(png_ptr, \"sPLT chunk too large to fit in memory\");\n      skip = length - (png_uint_32)65535L;\n      length = (png_uint_32)65535L;\n   }\n#endif\n\n   chunkdata = (png_bytep)png_malloc(png_ptr, length + 1);\n   slength = (png_size_t)length;\n   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);\n\n   if (png_crc_finish(png_ptr, skip))\n   {\n      png_free(png_ptr, chunkdata);\n      return;\n   }\n\n   chunkdata[slength] = 0x00;\n\n   for (entry_start = chunkdata; *entry_start; entry_start++)\n       ;\n   ++entry_start;\n\n   \n   if (entry_start > chunkdata + slength - 2)\n   {\n      png_free(png_ptr, chunkdata);\n      png_warning(png_ptr, \"malformed sPLT chunk\");\n      return;\n   }\n\n   new_palette.depth = *entry_start++;\n   entry_size = (new_palette.depth == 8 ? 6 : 10);\n   data_length = (slength - (entry_start - chunkdata));\n\n   \n   if (data_length % entry_size)\n   {\n      png_free(png_ptr, chunkdata);\n      png_warning(png_ptr, \"sPLT chunk has bad length\");\n      return;\n   }\n\n   new_palette.nentries = (png_int_32) ( data_length / entry_size);\n   if ((png_uint_32) new_palette.nentries > (png_uint_32) (PNG_SIZE_MAX /\n       png_sizeof(png_sPLT_entry)))\n   {\n       png_warning(png_ptr, \"sPLT chunk too long\");\n       return;\n   }\n   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(\n       png_ptr, new_palette.nentries * png_sizeof(png_sPLT_entry));\n   if (new_palette.entries == NULL)\n   {\n       png_warning(png_ptr, \"sPLT chunk requires too much memory\");\n       return;\n   }\n\n#ifndef PNG_NO_POINTER_INDEXING\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n      png_sPLT_entryp pp = new_palette.entries + i;\n\n      if (new_palette.depth == 8)\n      {\n          pp->red = *entry_start++;\n          pp->green = *entry_start++;\n          pp->blue = *entry_start++;\n          pp->alpha = *entry_start++;\n      }\n      else\n      {\n          pp->red   = png_get_uint_16(entry_start); entry_start += 2;\n          pp->green = png_get_uint_16(entry_start); entry_start += 2;\n          pp->blue  = png_get_uint_16(entry_start); entry_start += 2;\n          pp->alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n#else\n   pp = new_palette.entries;\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n\n      if (new_palette.depth == 8)\n      {\n          pp[i].red   = *entry_start++;\n          pp[i].green = *entry_start++;\n          pp[i].blue  = *entry_start++;\n          pp[i].alpha = *entry_start++;\n      }\n      else\n      {\n          pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;\n          pp[i].green = png_get_uint_16(entry_start); entry_start += 2;\n          pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;\n          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n#endif\n\n   \n   new_palette.name = (png_charp)chunkdata;\n\n   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);\n\n   png_free(png_ptr, chunkdata);\n   png_free(png_ptr, new_palette.entries);\n}\n#endif ", "bug_type": "cve-2004-0599-1", "idx": 8}
{"project": "LibPNG", "target": 0, "func": "static png_bytep\nstore_image_row(PNG_CONST png_store* ps, png_const_structp pp, int nImage,\n   png_uint_32 y)\n{\n   png_size_t coffset = (nImage * ps->image_h + y) * (ps->cb_row + 5) + 2;\n   if (ps->image == NULL)\n      png_error(pp, \"no allocated image\");\n   if (coffset + ps->cb_row + 3 > ps->cb_image)\n      png_error(pp, \"image too small\");\n   return ps->image + coffset;\n}\n", "bug_type": null, "idx": 9}
{"project": "LibPNG", "target": 0, "func": "static int\nnpasses_from_interlace_type(png_const_structp pp, int interlace_type)\n{\n   switch (interlace_type)\n   {\n   default:\n      png_error(pp, \"invalid interlace type\");\n   case PNG_INTERLACE_NONE:\n      return 1;\n   case PNG_INTERLACE_ADAM7:\n      return PNG_INTERLACE_ADAM7_PASSES;\n   }\n}\n", "bug_type": null, "idx": 10}
{"project": "LibPNG", "target": 0, "func": "static void\nallocate(struct file *file, int allocate_idat)\n{\n   struct control *control = png_voidcast(struct control*, file->alloc_ptr);\n   if (allocate_idat)\n   {\n      assert(file->idat == NULL);\n      IDAT_init(&control->idat, file);\n   }\n   else \n   {\n      assert(file->chunk == NULL);\n      chunk_init(&control->chunk, file);\n   }\n}\n", "bug_type": null, "idx": 11}
{"project": "LibPNG", "target": 1, "func": "\npng_charp \npng_decompress_chunk(png_structp png_ptr, int comp_type,\n                              png_charp chunkdata, png_size_t chunklength,\n                              png_size_t prefix_size, png_size_t *newlength)\n{\n   static char msg[] = \"Error decoding compressed text\";\n   png_charp text;\n   png_size_t text_size;\n\n   if (comp_type == PNG_COMPRESSION_TYPE_BASE)\n   {\n      int ret = Z_OK;\n      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);\n      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n      text_size = 0;\n      text = NULL;\n\n      while (png_ptr->zstream.avail_in)\n      {\n         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END)\n         {\n            if (png_ptr->zstream.msg != NULL)\n               png_warning(png_ptr, png_ptr->zstream.msg);\n            else\n               png_warning(png_ptr, msg);\n            inflateReset(&png_ptr->zstream);\n            png_ptr->zstream.avail_in = 0;\n\n            if (text ==  NULL)\n            {\n               text_size = prefix_size + png_sizeof(msg) + 1;\n               text = (png_charp)png_malloc_warn(png_ptr, text_size);\n               if (text ==  NULL)\n                 {\n                    png_free(png_ptr,chunkdata);\n                    png_error(png_ptr,\"Not enough memory to decompress chunk\");\n                 }\n               png_memcpy(text, chunkdata, prefix_size);\n            }\n\n            text[text_size - 1] = 0x00;\n\n            \n            text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);\n            text_size = png_sizeof(msg) > text_size ? text_size :\n               png_sizeof(msg);\n            png_memcpy(text + prefix_size, msg, text_size + 1);\n            break;\n         }\n         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)\n         {\n            if (text == NULL)\n            {\n               text_size = prefix_size +\n                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);\n               if (text ==  NULL)\n                 {\n                    png_free(png_ptr,chunkdata);\n                    png_error(png_ptr,\"Not enough memory to decompress chunk.\");\n                 }\n               png_memcpy(text + prefix_size, png_ptr->zbuf,\n                    text_size - prefix_size);\n               png_memcpy(text, chunkdata, prefix_size);\n               *(text + text_size) = 0x00;\n            }\n            else\n            {\n               png_charp tmp;\n\n               tmp = text;\n               text = (png_charp)png_malloc_warn(png_ptr,\n                  (png_uint_32)(text_size +\n                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));\n               if (text == NULL)\n               {\n                  png_free(png_ptr, tmp);\n                  png_free(png_ptr, chunkdata);\n                  png_error(png_ptr,\"Not enough memory to decompress chunk..\");\n               }\n               png_memcpy(text, tmp, text_size);\n               png_free(png_ptr, tmp);\n               png_memcpy(text + text_size, png_ptr->zbuf,\n                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));\n               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n               *(text + text_size) = 0x00;\n            }\n            if (ret == Z_STREAM_END)\n               break;\n            else\n            {\n               png_ptr->zstream.next_out = png_ptr->zbuf;\n               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n            }\n         }\n      }\n      if (ret != Z_STREAM_END)\n      {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n         char umsg[50];\n\n         if (ret == Z_BUF_ERROR)\n            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         else if (ret == Z_DATA_ERROR)\n            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         else\n            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         png_warning(png_ptr, umsg);\n#else\n         png_warning(png_ptr,\n            \"Incomplete compressed datastream in chunk other than IDAT\");\n#endif\n         text_size=prefix_size;\n         if (text ==  NULL)\n         {\n            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);\n            if (text == NULL)\n              {\n                png_free(png_ptr, chunkdata);\n                png_error(png_ptr,\"Not enough memory for text.\");\n              }\n            png_memcpy(text, chunkdata, prefix_size);\n         }\n         *(text + text_size) = 0x00;\n      }\n\n      inflateReset(&png_ptr->zstream);\n      png_ptr->zstream.avail_in = 0;\n\n      png_free(png_ptr, chunkdata);\n      chunkdata = text;\n      *newlength=text_size;\n   }\n   else \n   {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n      char umsg[50];\n\n      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);\n      png_warning(png_ptr, umsg);\n#else\n      png_warning(png_ptr, \"Unknown zTXt compression type\");\n#endif\n\n      *(chunkdata + prefix_size) = 0x00;\n      *newlength=prefix_size;\n   }\n\n   return chunkdata;\n}\n#endif", "bug_type": "cve-2010-0205", "idx": 12}
{"project": "LibPNG", "target": 1, "func": "\nvoid PNGAPI\npng_set_iCCP(png_structp png_ptr, png_infop info_ptr,\n             png_charp name, int compression_type,\n             png_charp profile, png_uint_32 proflen)\n{\n   png_charp new_iccp_name;\n   png_charp new_iccp_profile;\n\n   png_debug1(1, \"in %s storage function\\n\", \"iCCP\");\n   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)\n      return;\n\n   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, png_strlen(name)+1);\n   if (new_iccp_name == NULL)\n   {\n      png_warning(png_ptr, \"Insufficient memory to process iCCP chunk.\");\n      return;\n   }\n   png_strcpy(new_iccp_name, name);\n   new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen);\n   if (new_iccp_profile == NULL)\n   {\n      png_free (png_ptr, new_iccp_name);\n      png_warning(png_ptr, \"Insufficient memory to process iCCP profile.\");\n      return;\n   }\n   png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);\n\n   info_ptr->iccp_proflen = proflen;\n   info_ptr->iccp_name = new_iccp_name;\n   info_ptr->iccp_profile = new_iccp_profile;\n   \n\n   info_ptr->iccp_compression = (png_byte)compression_type;\n#ifdef PNG_FREE_ME_SUPPORTED\n   info_ptr->free_me |= PNG_FREE_ICCP;\n#endif\n   info_ptr->valid |= PNG_INFO_iCCP;\n}\n#endif", "bug_type": "cve-2007-5267", "idx": 13}
{"project": "LibPNG", "target": 0, "func": "static void rpng2_x_finish_display(void)\n{\n    Trace((stderr, \"beginning rpng2_x_finish_display()\\n\"))\n    \n\n\n    rpng2_info.state = kDone;\n    printf(\n      \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\");\n    fflush(stdout);\n}\n", "bug_type": null, "idx": 14}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32 png_log16bit(png_uint_32 x)\n{\n   if (x > 0)\n      return (png_uint_32)floor(.5-log(x/65535.)*L2INV);\n   return 0xffffffff;\n}\n", "bug_type": null, "idx": 15}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_expand_gray_1_2_4_to_8_mod(\n    PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   image_transform_png_set_expand_mod(this, that, pp, display);\n}\n", "bug_type": null, "idx": 16}
{"project": "LibPNG", "target": 0, "func": "\nint readpng2_decode_data(mainprog_info *mainprog_ptr, uch *rawbuf, ulg length)\n{\n    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;\n    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;\n    \n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->png_ptr = NULL;\n        mainprog_ptr->info_ptr = NULL;\n        return 2;\n    }\n    \n    png_process_data(png_ptr, info_ptr, rawbuf, length);\n    return 0;\n}\n", "bug_type": null, "idx": 17}
{"project": "LibPNG", "target": 0, "func": "static void\nrandomize(void *pv, size_t size)\n{\n   static png_uint_32 random_seed[2] = {0x56789abc, 0xd};\n   make_random_bytes(random_seed, pv, size);\n}\n", "bug_type": null, "idx": 18}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_gb16(Pixel *out, const Pixel *in, const Background *back)\n{\n   if (in->a <= 0)\n      out->r = out->g = out->b = back->ig;\n   else if (in->a >= 65535)\n      out->r = out->g = out->b = isRGB(in->g);\n   else\n   {\n      double a = in->a / 65535.;\n      double a1 = 1-a;\n      a /= 65535;\n      out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1);\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 19}
{"project": "LibPNG", "target": 0, "func": "static void\nrow_copy(png_bytep toBuffer, png_const_bytep fromBuffer, unsigned int bitWidth)\n{\n   memcpy(toBuffer, fromBuffer, bitWidth >> 3);\n   if ((bitWidth & 7) != 0)\n   {\n      unsigned int mask;\n      toBuffer += bitWidth >> 3;\n      fromBuffer += bitWidth >> 3;\n      \n\n\n      mask = 0xff >> (bitWidth & 7);\n      *toBuffer = (png_byte)((*toBuffer & mask) | (*fromBuffer & ~mask));\n   }\n}\n", "bug_type": null, "idx": 20}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_test_counter(png_uint_32 counter, unsigned int max)\n{\n   \n\n\n   image_transform *next = image_transform_first;\n   while (next != &image_transform_end)\n   {\n      \n      counter >>= 1;\n      \n      if (max > 1 && next->local_use < max)\n         return 1;\n      next = next->list;\n   }\n   return max <= 1 && counter == 0;\n}\n", "bug_type": null, "idx": 21}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_charp buffer, ep;\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n   double width, height;\n   png_charp vp;\n#else\n#ifdef PNG_FIXED_POINT_SUPPORTED\n   png_charp swidth, sheight;\n#endif\n#endif\n   png_size_t slength;\n\n   png_debug(1, \"in png_handle_sCAL\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sCAL\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sCAL after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))\n   {\n      png_warning(png_ptr, \"Duplicate sCAL chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading sCAL chunk data (%lu bytes)\\n\",\n      length + 1);\n   buffer = (png_charp)png_malloc_warn(png_ptr, length + 1);\n   if (buffer == NULL)\n     {\n       png_warning(png_ptr, \"Out of memory while processing sCAL chunk\");\n       return;\n     }\n   slength = (png_size_t)length;\n   png_crc_read(png_ptr, (png_bytep)buffer, slength);\n\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_free(png_ptr, buffer);\n      return;\n   }\n\n   buffer[slength] = 0x00; \n\n   ep = buffer + 1;        \n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n   width = strtod(ep, &vp);\n   if (*vp)\n   {\n       png_warning(png_ptr, \"malformed width string in sCAL chunk\");\n       return;\n   }\n#else\n#ifdef PNG_FIXED_POINT_SUPPORTED\n   swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);\n   if (swidth == NULL)\n     {\n       png_warning(png_ptr, \"Out of memory while processing sCAL chunk width\");\n       return;\n     }\n   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));\n#endif\n#endif\n\n   for (ep = buffer; *ep; ep++)\n       ;\n   ep++;\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n   height = strtod(ep, &vp);\n   if (*vp)\n   {\n       png_warning(png_ptr, \"malformed height string in sCAL chunk\");\n       return;\n   }\n#else\n#ifdef PNG_FIXED_POINT_SUPPORTED\n   sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);\n   if (swidth == NULL)\n     {\n       png_warning(png_ptr, \"Out of memory while processing sCAL chunk height\");\n       return;\n     }\n   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));\n#endif\n#endif\n\n   if (buffer + slength < ep\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n      || width <= 0. || height <= 0.\n#endif\n      )\n   {\n      png_warning(png_ptr, \"Invalid sCAL data\");\n      png_free(png_ptr, buffer);\n#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)\n      png_free(png_ptr, swidth);\n      png_free(png_ptr, sheight);\n#endif\n      return;\n   }\n\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n   png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height);\n#else\n#ifdef PNG_FIXED_POINT_SUPPORTED\n   png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight);\n#endif\n#endif\n\n   png_free(png_ptr, buffer);\n#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)\n   png_free(png_ptr, swidth);\n   png_free(png_ptr, sheight);\n#endif\n}\n#endif", "bug_type": "cve-2007-5269-2", "idx": 22}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_read_imp(png_modifier *pm, png_bytep pb, png_size_t st)\n{\n   while (st > 0)\n   {\n      size_t cb;\n      png_uint_32 len, chunk;\n      png_modification *mod;\n      if (pm->buffer_position >= pm->buffer_count) switch (pm->state)\n      {\n         static png_byte sign[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n         case modifier_start:\n            store_read_imp(&pm->this, pm->buffer, 8); \n            pm->buffer_count = 8;\n            pm->buffer_position = 0;\n            if (memcmp(pm->buffer, sign, 8) != 0)\n               png_error(pm->this.pread, \"invalid PNG file signature\");\n            pm->state = modifier_signature;\n            break;\n         case modifier_signature:\n            store_read_imp(&pm->this, pm->buffer, 13+12); \n            pm->buffer_count = 13+12;\n            pm->buffer_position = 0;\n            if (png_get_uint_32(pm->buffer) != 13 ||\n                png_get_uint_32(pm->buffer+4) != CHUNK_IHDR)\n               png_error(pm->this.pread, \"invalid IHDR\");\n            \n            mod = pm->modifications;\n            while (mod != NULL)\n            {\n               if (mod->chunk == CHUNK_IHDR && mod->modify_fn &&\n                   (*mod->modify_fn)(pm, mod, 0))\n                  {\n                  mod->modified = 1;\n                  modifier_setbuffer(pm);\n                  }\n               \n               mod = mod->next;\n            }\n            \n            pm->bit_depth = pm->buffer[8+8];\n            pm->colour_type = pm->buffer[8+8+1];\n            pm->state = modifier_IHDR;\n            pm->flush = 0;\n            break;\n         case modifier_IHDR:\n         default:\n            \n\n\n\n            if ((cb = pm->flush) > 0)\n            {\n               if (cb > st) cb = st;\n               pm->flush -= cb;\n               store_read_imp(&pm->this, pb, cb);\n               pb += cb;\n               st -= cb;\n               if (st == 0) return;\n            }\n            \n\n\n            if (pm->pending_chunk != 0)\n            {\n               png_save_uint_32(pm->buffer, pm->pending_len);\n               png_save_uint_32(pm->buffer+4, pm->pending_chunk);\n               pm->pending_len = 0;\n               pm->pending_chunk = 0;\n            }\n            else\n               store_read_imp(&pm->this, pm->buffer, 8);\n            pm->buffer_count = 8;\n            pm->buffer_position = 0;\n            \n            len = png_get_uint_32(pm->buffer);\n            chunk = png_get_uint_32(pm->buffer+4);\n            \n\n\n            if (chunk == CHUNK_PLTE || chunk == CHUNK_IDAT ||\n                chunk == CHUNK_IEND)\n            {\n               mod = pm->modifications;\n               while (mod != NULL)\n               {\n                  if ((mod->add == chunk ||\n                      (mod->add == CHUNK_PLTE && chunk == CHUNK_IDAT)) &&\n                      mod->modify_fn != NULL && !mod->modified && !mod->added)\n                  {\n                     \n\n\n                     mod->added = 1;\n                     if ((*mod->modify_fn)(pm, mod, 1 ))\n                     {\n                        \n                        if (pm->buffer_count > 0)\n                           modifier_setbuffer(pm);\n                        else\n                           {\n                           pm->buffer_position = 0;\n                           mod->removed = 1;\n                           }\n                        \n\n\n                        pm->pending_len = len;\n                        pm->pending_chunk = chunk;\n                        break; \n                     }\n                  }\n                  mod = mod->next;\n               }\n               \n\n\n\n               if (mod != NULL)\n                  break; \n            }\n            \n\n\n\n            if (len+12 <= sizeof pm->buffer)\n            {\n               store_read_imp(&pm->this, pm->buffer+pm->buffer_count,\n                   len+12-pm->buffer_count);\n               pm->buffer_count = len+12;\n               \n               mod = pm->modifications;\n               while (mod != NULL)\n               {\n                  if (mod->chunk == chunk)\n                  {\n                     if (mod->modify_fn == NULL)\n                     {\n                        \n                        pm->buffer_count = pm->buffer_position = 0;\n                        mod->removed = 1;\n                        break; \n                     }\n                     else if ((*mod->modify_fn)(pm, mod, 0))\n                     {\n                        mod->modified = 1;\n                        \n                        if (pm->buffer_count == 0)\n                        {\n                           pm->buffer_position = 0;\n                           break;\n                        }\n                        modifier_setbuffer(pm);\n                     }\n                  }\n                  mod = mod->next;\n               }\n            }\n            else\n               pm->flush = len+12 - pm->buffer_count; \n            \n            break;\n      }\n      \n\n\n      cb = pm->buffer_count - pm->buffer_position;\n      if (cb > st)\n         cb = st;\n      memcpy(pb, pm->buffer + pm->buffer_position, cb);\n      st -= cb;\n      pb += cb;\n      pm->buffer_position += cb;\n   }\n}\n", "bug_type": null, "idx": 23}
{"project": "LibPNG", "target": 0, "func": "void PNGAPI\npng_set_read_fn(png_structrp png_ptr, png_voidp io_ptr,\n   png_rw_ptr read_data_fn)\n{\n   if (png_ptr == NULL)\n      return;\n   png_ptr->io_ptr = io_ptr;\n   if (read_data_fn != NULL)\n      png_ptr->read_data_fn = read_data_fn;\n   else\n      png_ptr->read_data_fn = png_default_read_data;\n   png_ptr->read_data_fn = read_data_fn;\n   \n   if (png_ptr->write_data_fn != NULL)\n   {\n      png_ptr->write_data_fn = NULL;\n      png_warning(png_ptr,\n          \"Can't set both read_data_fn and write_data_fn in the\"\n          \" same structure\");\n   }\n   png_ptr->output_flush_fn = NULL;\n#endif\n}\n", "bug_type": null, "idx": 24}
{"project": "LibPNG", "target": 1, "func": "\n\n\n\nvoid \npng_do_expand_palette(png_row_infop row_info, png_bytep row,\n   png_const_colorp palette, png_const_bytep trans_alpha, int num_trans)\n{\n   int shift, value;\n   png_bytep sp, dp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_expand_palette\");\n\n   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (row_info->bit_depth < 8)\n      {\n         switch (row_info->bit_depth)\n         {\n            case 1:\n            {\n               sp = row + (png_size_t)((row_width - 1) >> 3);\n               dp = row + (png_size_t)row_width - 1;\n               shift = 7 - (int)((row_width + 7) & 0x07);\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((*sp >> shift) & 0x01)\n                     *dp = 1;\n\n                  else\n                     *dp = 0;\n\n                  if (shift == 7)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift++;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 2:\n            {\n               sp = row + (png_size_t)((row_width - 1) >> 2);\n               dp = row + (png_size_t)row_width - 1;\n               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x03;\n                  *dp = (png_byte)value;\n                  if (shift == 6)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift += 2;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 4:\n            {\n               sp = row + (png_size_t)((row_width - 1) >> 1);\n               dp = row + (png_size_t)row_width - 1;\n               shift = (int)((row_width & 0x01) << 2);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x0f;\n                  *dp = (png_byte)value;\n                  if (shift == 4)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift += 4;\n\n                  dp--;\n               }\n               break;\n            }\n\n            default:\n               break;\n         }\n         row_info->bit_depth = 8;\n         row_info->pixel_depth = 8;\n         row_info->rowbytes = row_width;\n      }\n\n      if (row_info->bit_depth == 8)\n      {\n         {\n            if (num_trans > 0)\n            {\n               sp = row + (png_size_t)row_width - 1;\n               dp = row + (png_size_t)(row_width << 2) - 1;\n\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((int)(*sp) >= num_trans)\n                     *dp-- = 0xff;\n\n                  else\n                     *dp-- = trans_alpha[*sp];\n\n                  *dp-- = palette[*sp].blue;\n                  *dp-- = palette[*sp].green;\n                  *dp-- = palette[*sp].red;\n                  sp--;\n               }\n               row_info->bit_depth = 8;\n               row_info->pixel_depth = 32;\n               row_info->rowbytes = row_width * 4;\n               row_info->color_type = 6;\n               row_info->channels = 4;\n            }\n\n            else\n            {\n               sp = row + (png_size_t)row_width - 1;\n               dp = row + (png_size_t)(row_width * 3) - 1;\n\n               for (i = 0; i < row_width; i++)\n               {\n                  *dp-- = palette[*sp].blue;\n                  *dp-- = palette[*sp].green;\n                  *dp-- = palette[*sp].red;\n                  sp--;\n               }\n\n               row_info->bit_depth = 8;\n               row_info->pixel_depth = 24;\n               row_info->rowbytes = row_width * 3;\n               row_info->color_type = 2;\n               row_info->channels = 3;\n            }\n         }\n      }\n   }\n}", "bug_type": "cve-2013-6954", "idx": 25}
{"project": "LibPNG", "target": 0, "func": " */\nstatic int output_quantization_factor(PNG_CONST png_modifier *pm, int in_depth,\n   int out_depth)\n{\n   if (out_depth == 16 && in_depth != 16 &&\n      pm->calculations_use_input_precision)\n      return 257;\n   else\n      return 1;\n}\n", "bug_type": null, "idx": 26}
{"project": "LibPNG", "target": 0, "func": "static void\nresetimage(Image *image)\n{\n   if (image->input_file != NULL)\n      rewind(image->input_file);\n}\n", "bug_type": null, "idx": 27}
{"project": "LibPNG", "target": 0, "func": "static void\nchrm_modification_init(chrm_modification *me, png_modifier *pm,\n   PNG_CONST color_encoding *encoding)\n{\n   CIE_color white = white_point(encoding);\n   \n   me->encoding = encoding;\n   \n   me->wx = fix(chromaticity_x(white));\n   me->wy = fix(chromaticity_y(white));\n   me->rx = fix(chromaticity_x(encoding->red));\n   me->ry = fix(chromaticity_y(encoding->red));\n   me->gx = fix(chromaticity_x(encoding->green));\n   me->gy = fix(chromaticity_y(encoding->green));\n   me->bx = fix(chromaticity_x(encoding->blue));\n   me->by = fix(chromaticity_y(encoding->blue));\n   modification_init(&me->this);\n   me->this.chunk = CHUNK_cHRM;\n   me->this.modify_fn = chrm_modify;\n   me->this.add = CHUNK_PLTE;\n   me->this.next = pm->modifications;\n   pm->modifications = &me->this;\n}\n", "bug_type": null, "idx": 28}
{"project": "LibPNG", "target": 0, "func": "static void\nmodification_init(png_modification *pmm)\n{\n   memset(pmm, 0, sizeof *pmm);\n   pmm->next = NULL;\n   pmm->chunk = 0;\n   pmm->modify_fn = NULL;\n   pmm->add = 0;\n   modification_reset(pmm);\n}\n", "bug_type": null, "idx": 29}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_text_validate(standard_display *dp, png_const_structp pp,\n   png_infop pi, int check_end)\n{\n   png_textp tp = NULL;\n   png_uint_32 num_text = png_get_text(pp, pi, &tp, NULL);\n   if (num_text == 2 && tp != NULL)\n   {\n      standard_check_text(pp, tp, \"image name\", dp->ps->current->name);\n      \n\n\n\n      if (check_end)\n         standard_check_text(pp, tp+1, \"end marker\", \"end\");\n   }\n   else\n   {\n      char msg[64];\n      sprintf(msg, \"expected two text items, got %lu\",\n         (unsigned long)num_text);\n      png_error(pp, msg);\n   }\n}\n", "bug_type": null, "idx": 30}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL FillBitmap (\n        BYTE *pDiData, int cxWinSize, int cyWinSize,\n        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,\n        BOOL bStretched)\n{\n    BYTE *pStretchedImage;\n    BYTE *pImg;\n    BYTE *src, *dst;\n    BYTE r, g, b, a;\n    const int cDIChannels = 3;\n    WORD wImgRowBytes;\n    WORD wDIRowBytes;\n    int cxNewSize, cyNewSize;\n    int cxImgPos, cyImgPos;\n    int xImg, yImg;\n    int xWin, yWin;\n    int xOld, yOld;\n    int xNew, yNew;\n    if (bStretched)\n    {\n        cxNewSize = cxWinSize - 2 * MARGIN;\n        cyNewSize = cyWinSize - 2 * MARGIN;\n        \n        \n\n\n\n        if ((cyNewSize * cxImgSize) > (cyImgSize * cxNewSize))\n        {\n            cyNewSize = cxNewSize * cyImgSize / cxImgSize;\n            cxImgPos = MARGIN;\n            cyImgPos = (cyWinSize - cyNewSize) / 2;\n        }\n        else\n        {\n            cxNewSize = cyNewSize * cxImgSize / cyImgSize;\n            cyImgPos = MARGIN;\n            cxImgPos = (cxWinSize - cxNewSize) / 2;\n        }\n        pStretchedImage = malloc (cImgChannels * cxNewSize * cyNewSize);\n        pImg = pStretchedImage;\n        for (yNew = 0; yNew < cyNewSize; yNew++)\n        {\n            yOld = yNew * cyImgSize / cyNewSize;\n            for (xNew = 0; xNew < cxNewSize; xNew++)\n            {\n                xOld = xNew * cxImgSize / cxNewSize;\n                r = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 0);\n                g = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 1);\n                b = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 2);\n                *pImg++ = r;\n                *pImg++ = g;\n                *pImg++ = b;\n                if (cImgChannels == 4)\n                {\n                    a = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld)\n                        + 3);\n                    *pImg++ = a;\n                }\n            }\n        }\n        \n        wImgRowBytes = cImgChannels * cxNewSize;\n        wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;\n        \n        for (yImg = 0, yWin = cyImgPos; yImg < cyNewSize; yImg++, yWin++)\n        {\n            if (yWin >= cyWinSize - cyImgPos)\n                break;\n            src = pStretchedImage + yImg * wImgRowBytes;\n            dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels;\n            for (xImg = 0, xWin = cxImgPos; xImg < cxNewSize; xImg++, xWin++)\n            {\n                if (xWin >= cxWinSize - cxImgPos)\n                    break;\n                r = *src++;\n                g = *src++;\n                b = *src++;\n                *dst++ = b; \n                *dst++ = g;\n                *dst++ = r;\n                if (cImgChannels == 4)\n                {\n                    a = *src++;\n                }\n            }\n        }\n        \n        if (pStretchedImage != NULL)\n        {\n            free (pStretchedImage);\n            pStretchedImage = NULL;\n        }\n    }\n    \n    else\n    {\n        \n        cxImgPos = (cxWinSize - cxImgSize) / 2;\n        cyImgPos = (cyWinSize - cyImgSize) / 2;\n        \n        if (cxImgPos < MARGIN)\n            cxImgPos = MARGIN;\n        if (cyImgPos < MARGIN)\n            cyImgPos = MARGIN;\n        \n        wImgRowBytes = cImgChannels * cxImgSize;\n        wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;\n        \n        for (yImg = 0, yWin = cyImgPos; yImg < cyImgSize; yImg++, yWin++)\n        {\n            if (yWin >= cyWinSize - MARGIN)\n                break;\n            src = pbImage + yImg * wImgRowBytes;\n            dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels;\n            for (xImg = 0, xWin = cxImgPos; xImg < cxImgSize; xImg++, xWin++)\n            {\n                if (xWin >= cxWinSize - MARGIN)\n                    break;\n                r = *src++;\n                g = *src++;\n                b = *src++;\n                *dst++ = b; \n                *dst++ = g;\n                *dst++ = r;\n                if (cImgChannels == 4)\n                {\n                    a = *src++;\n                }\n            }\n        }\n    }\n    return TRUE;\n}\n", "bug_type": null, "idx": 31}
{"project": "LibPNG", "target": 0, "func": "static png_byte\nisRGB(int fixed_linear)\n{\n   return sRGB(fixed_linear / 65535.);\n}\n", "bug_type": null, "idx": 32}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_tRNS_to_alpha_set(PNG_CONST image_transform *this,\n   transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_tRNS_to_alpha(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 33}
{"project": "LibPNG", "target": 0, "func": "BOOL CALLBACK AboutDlgProc (HWND hDlg, UINT message,\n                            WPARAM wParam, LPARAM lParam)\n{\n     switch (message)\n     {\n     case WM_INITDIALOG :\n          ShowWindow (hDlg, SW_HIDE);\n          CenterAbout (hDlg, GetWindow (hDlg, GW_OWNER));\n          ShowWindow (hDlg, SW_SHOW);\n          return TRUE ;\n     case WM_COMMAND :\n          switch (LOWORD (wParam))\n          {\n          case IDOK :\n          case IDCANCEL :\n               EndDialog (hDlg, 0) ;\n               return TRUE ;\n          }\n          break ;\n     }\n     return FALSE ;\n}\n", "bug_type": null, "idx": 34}
{"project": "LibPNG", "target": 0, "func": "static void\ncheck_param_count(int nparams, int expect)\n{\n   if (nparams != expect)\n   {\n      fprintf(stderr, \"bad parameter count (internal error)\\n\");\n      exit(1);\n   }\n}\n", "bug_type": null, "idx": 35}
{"project": "LibPNG", "target": 0, "func": "static int\nuarb_mult32(uarb acc, int a_digits, uarb num, int n_digits, png_uint_32 val)\n   \n\n\n{\n   if (n_digits > 0 && val > 0)\n   {\n      a_digits = uarb_mult_digit(acc, a_digits, num, n_digits,\n         (png_uint_16)(val & 0xffff));\n      \n      assert(a_digits > 0);\n      val >>= 16;\n      if (val > 0)\n         a_digits = uarb_mult_digit(acc+1, a_digits-1, num, n_digits,\n            (png_uint_16)val) + 1;\n   }\n", "bug_type": null, "idx": 36}
{"project": "LibPNG", "target": 0, "func": "static int\ncheckopaque(Image *image)\n{\n   if (image->image.opaque != NULL)\n   {\n      png_image_free(&image->image);\n      return logerror(image, image->file_name, \": opaque not NULL\", \"\");\n   }\n   else if (image->image.warning_or_error != 0 && (image->opts & STRICT) != 0)\n      return logerror(image, image->file_name, \" --strict\", \"\");\n   else\n      return 1;\n}\n", "bug_type": null, "idx": 37}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_size_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,\n    png_byte PNG_CONST bit_depth, int PNG_CONST interlace_type,\n    png_uint_32 PNG_CONST w, png_uint_32 PNG_CONST h,\n    int PNG_CONST do_interlace)\n{\n   context(ps, fault);\n   \n\n\n\n   check_interlace_type(interlace_type);\n   Try\n   {\n      png_infop pi;\n      png_structp pp;\n      unsigned int pixel_size;\n      \n      char name[FILE_NAME_SIZE];\n      PNG_CONST png_uint_32 id = FILEID(colour_type, bit_depth, 0,\n         interlace_type, w, h, do_interlace);\n      standard_name_from_id(name, sizeof name, 0, id);\n      pp = set_store_for_write(ps, &pi, name);\n      \n\n\n\n      if (pp == NULL)\n         Throw ps;\n      png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,\n         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n#ifdef PNG_TEXT_SUPPORTED\n      {\n         static char key[] = \"image name\"; \n         size_t pos;\n         png_text text;\n         char copy[FILE_NAME_SIZE];\n         \n\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         \n         pos = safecat(copy, sizeof copy, 0, ps->wname);\n         text.text = copy;\n         text.text_length = pos;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n         png_set_text(pp, pi, &text, 1);\n      }\n#endif\n      if (colour_type == 3) \n         init_standard_palette(ps, pp, pi, 1U << bit_depth, 0);\n      png_write_info(pp, pi);\n      \n\n\n\n      pixel_size = bit_size(pp, colour_type, bit_depth);\n      if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)\n         png_error(pp, \"row size incorrect\");\n      else\n      {\n         int npasses = npasses_from_interlace_type(pp, interlace_type);\n         png_uint_32 y;\n         int pass;\n#        ifdef PNG_WRITE_FILTER_SUPPORTED\n            int nfilter = PNG_FILTER_VALUE_LAST;\n#        endif\n         png_byte image[16][SIZE_ROWMAX];\n         \n\n\n         memset(image, 0xff, sizeof image);\n         if (!do_interlace && npasses != png_set_interlace_handling(pp))\n            png_error(pp, \"write: png_set_interlace_handling failed\");\n         \n         for (y=0; y<h; ++y)\n            size_row(image[y], w * pixel_size, y);\n         for (pass=0; pass<npasses; ++pass)\n         {\n            \n            PNG_CONST png_uint_32 wPass = PNG_PASS_COLS(w, pass);\n            \n\n\n\n            for (y=0; y<h; ++y)\n            {\n               png_const_bytep row = image[y];\n               png_byte tempRow[SIZE_ROWMAX];\n               \n\n\n\n               if (do_interlace && interlace_type == PNG_INTERLACE_ADAM7)\n               {\n                  \n\n\n\n\n\n                  if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0)\n                  {\n                     \n\n\n                     memset(tempRow, 0xff, sizeof tempRow);\n                     interlace_row(tempRow, row, pixel_size, w, pass);\n                     row = tempRow;\n                  }\n                  else\n                     continue;\n               }\n#           ifdef PNG_WRITE_FILTER_SUPPORTED\n               \n\n\n\n\n\n\n\n\n\n               png_set_filter(pp, 0,\n                  nfilter >= PNG_FILTER_VALUE_LAST ? PNG_ALL_FILTERS : nfilter);\n               if (nfilter-- == 0)\n                  nfilter = PNG_FILTER_VALUE_LAST-1;\n#           endif\n               png_write_row(pp, row);\n            }\n         }\n      }\n#ifdef PNG_TEXT_SUPPORTED\n      {\n         static char key[] = \"end marker\";\n         static char comment[] = \"end\";\n         png_text text;\n         \n\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         text.text = comment;\n         text.text_length = (sizeof comment)-1;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n         png_set_text(pp, pi, &text, 1);\n      }\n#endif\n      png_write_end(pp, pi);\n      \n      store_storefile(ps, id);\n      store_write_reset(ps);\n   }\n   Catch(fault)\n   {\n      \n\n\n\n      store_write_reset(fault);\n   }\n}\n", "bug_type": null, "idx": 38}
{"project": "LibPNG", "target": 0, "func": "static int\nwrite_one_file(Image *output, Image *image, int convert_to_8bit)\n{\n   if (image->opts & FAST_WRITE)\n      image->image.flags |= PNG_IMAGE_FLAG_FAST;\n   if (image->opts & USE_STDIO)\n   {\n      FILE *f = tmpfile();\n      if (f != NULL)\n      {\n         if (png_image_write_to_stdio(&image->image, f, convert_to_8bit,\n            image->buffer+16, (png_int_32)image->stride, image->colormap))\n         {\n            if (fflush(f) == 0)\n            {\n               rewind(f);\n               initimage(output, image->opts, \"tmpfile\", image->stride_extra);\n               output->input_file = f;\n               if (!checkopaque(image))\n                  return 0;\n            }\n            else\n               return logclose(image, f, \"tmpfile\", \": flush: \");\n         }\n         else\n         {\n            fclose(f);\n            return logerror(image, \"tmpfile\", \": write failed\", \"\");\n         }\n      }\n      else\n         return logerror(image, \"tmpfile\", \": open: \", strerror(errno));\n   }\n   else\n   {\n      static int counter = 0;\n      char name[32];\n      sprintf(name, \"%s%d.png\", tmpf, ++counter);\n      if (png_image_write_to_file(&image->image, name, convert_to_8bit,\n         image->buffer+16, (png_int_32)image->stride, image->colormap))\n      {\n         initimage(output, image->opts, output->tmpfile_name,\n            image->stride_extra);\n         \n         strcpy(output->tmpfile_name, name);\n         if (!checkopaque(image))\n            return 0;\n      }\n      else\n         return logerror(image, name, \": write failed\", \"\");\n   }\n   \n\n\n\n\n\n\n   if (read_file(output, image->image.format | FORMAT_NO_CHANGE, NULL))\n   {\n      png_uint_32 original_format = image->image.format;\n      if (convert_to_8bit)\n         original_format &= ~PNG_FORMAT_FLAG_LINEAR;\n      if ((output->image.format & BASE_FORMATS) !=\n         (original_format & BASE_FORMATS))\n         return logerror(image, image->file_name, \": format changed on read: \",\n            output->file_name);\n      return compare_two_images(image, output, 0, NULL);\n   }\n   else\n      return logerror(output, output->tmpfile_name,\n         \": read of new file failed\", \"\");\n}\n", "bug_type": null, "idx": 39}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\npng_col_from_pass_col(png_uint_32 xIn, int pass)\n{\n   \n   switch (pass)\n   {\ncase 0: return xIn * 8;\ncase 1: return xIn * 8 + 4;\ncase 2: return xIn * 4;\ncase 3: return xIn * 4 + 2;\ncase 4: return xIn * 2;\ncase 5: return xIn * 2 + 1;\ncase 6: return xIn;\ndefault: break;\n   }\n   return 0xff; \n}\n", "bug_type": null, "idx": 40}
{"project": "LibPNG", "target": 0, "func": "void readpng2_cleanup(mainprog_info *mainprog_ptr)\n{\n    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;\n    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;\n    if (png_ptr && info_ptr)\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n    mainprog_ptr->png_ptr = NULL;\n    mainprog_ptr->info_ptr = NULL;\n}\n", "bug_type": null, "idx": 41}
{"project": "LibPNG", "target": 0, "func": " */\nvoid get_token(FILE *pnm_file, char *token)\n{\n  int i = 0;\n  int ret;\n  \n  do\n  {\n    ret = fgetc(pnm_file);\n    if (ret == '#') {\n      \n      do\n      {\n        ret = fgetc(pnm_file);\n      }\n      while ((ret != '\\n') && (ret != '\\r') && (ret != EOF));\n    }\n    if (ret == EOF) break;\n    token[i] = (unsigned char) ret;\n  }\n  while ((token[i] == '\\n') || (token[i] == '\\r') || (token[i] == ' '));\n  \n  do\n  {\n    ret = fgetc(pnm_file);\n    if (ret == EOF) break;\n    i++;\n    token[i] = (unsigned char) ret;\n  }\n  while ((token[i] != '\\n') && (token[i] != '\\r') && (token[i] != ' '));\n  token[i] = '\\0';\n  return;\n}\n", "bug_type": null, "idx": 42}
{"project": "LibPNG", "target": 0, "func": "static void\nprint_opts(png_uint_32 opts)\n{\n   if (opts & READ_FILE)\n      printf(\" --file\");\n   if (opts & USE_STDIO)\n      printf(\" --stdio\");\n   if (opts & STRICT)\n      printf(\" --strict\");\n   if (opts & VERBOSE)\n      printf(\" --verbose\");\n   if (opts & KEEP_TMPFILES)\n      printf(\" --preserve\");\n   if (opts & KEEP_GOING)\n      printf(\" --keep-going\");\n   if (opts & ACCUMULATE)\n      printf(\" --accumulate\");\n   if (!(opts & FAST_WRITE)) \n      printf(\" --slow\");\n   if (opts & sRGB_16BIT)\n      printf(\" --sRGB-16bit\");\n}\n", "bug_type": null, "idx": 43}
{"project": "LibPNG", "target": 0, "func": "static void\ntype_name(png_uint_32 type, FILE *out)\n{\n   putc(type_char(type >> 24), out);\n   putc(type_char(type >> 16), out);\n   putc(type_char(type >>  8), out);\n   putc(type_char(type      ), out);\n}\n", "bug_type": null, "idx": 44}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_do_expand_palette(png_row_infop row_info, png_bytep row,\n   png_const_colorp palette, png_const_bytep trans_alpha, int num_trans)\n{\n   int shift, value;\n   png_bytep sp, dp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_expand_palette\");\n\n   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (row_info->bit_depth < 8)\n      {\n         switch (row_info->bit_depth)\n         {\n            case 1:\n            {\n               sp = row + (png_size_t)((row_width - 1) >> 3);\n               dp = row + (png_size_t)row_width - 1;\n               shift = 7 - (int)((row_width + 7) & 0x07);\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((*sp >> shift) & 0x01)\n                     *dp = 1;\n\n                  else\n                     *dp = 0;\n\n                  if (shift == 7)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift++;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 2:\n            {\n               sp = row + (png_size_t)((row_width - 1) >> 2);\n               dp = row + (png_size_t)row_width - 1;\n               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x03;\n                  *dp = (png_byte)value;\n                  if (shift == 6)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift += 2;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 4:\n            {\n               sp = row + (png_size_t)((row_width - 1) >> 1);\n               dp = row + (png_size_t)row_width - 1;\n               shift = (int)((row_width & 0x01) << 2);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x0f;\n                  *dp = (png_byte)value;\n                  if (shift == 4)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift += 4;\n\n                  dp--;\n               }\n               break;\n            }\n\n            default:\n               break;\n         }\n         row_info->bit_depth = 8;\n         row_info->pixel_depth = 8;\n         row_info->rowbytes = row_width;\n      }\n\n      else if (row_info->bit_depth == 8)\n      {\n         {\n            if (trans_alpha != NULL)\n            {\n               sp = row + (png_size_t)row_width - 1;\n               dp = row + (png_size_t)(row_width << 2) - 1;\n\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((int)(*sp) >= num_trans)\n                     *dp-- = 0xff;\n\n                  else\n                     *dp-- = trans_alpha[*sp];\n\n                  *dp-- = palette[*sp].blue;\n                  *dp-- = palette[*sp].green;\n                  *dp-- = palette[*sp].red;\n                  sp--;\n               }\n               row_info->bit_depth = 8;\n               row_info->pixel_depth = 32;\n               row_info->rowbytes = row_width * 4;\n               row_info->color_type = 6;\n               row_info->channels = 4;\n            }\n\n            else\n            {\n               sp = row + (png_size_t)row_width - 1;\n               dp = row + (png_size_t)(row_width * 3) - 1;\n\n               for (i = 0; i < row_width; i++)\n               {\n                  *dp-- = palette[*sp].blue;\n                  *dp-- = palette[*sp].green;\n                  *dp-- = palette[*sp].red;\n                  sp--;\n               }\n\n               row_info->bit_depth = 8;\n               row_info->pixel_depth = 24;\n               row_info->rowbytes = row_width * 3;\n               row_info->color_type = 2;\n               row_info->channels = 3;\n            }\n         }\n      }\n   }\n}", "bug_type": "cve-2011-0408-1", "idx": 45}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_disable(PNG_CONST char *name)\n{\n   image_transform *list = image_transform_first;\n   while (list != &image_transform_end)\n   {\n      if (strcmp(list->name, name) == 0)\n      {\n         list->enable = 0;\n         return;\n      }\n      list = list->list;\n   }\n   fprintf(stderr, \"pngvalid: --transform-disable=%s: unknown transform\\n\",\n      name);\n   exit(99);\n}\n", "bug_type": null, "idx": 46}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_init(png_modifier *pm)\n{\n   memset(pm, 0, sizeof *pm);\n   store_init(&pm->this);\n   pm->modifications = NULL;\n   pm->state = modifier_start;\n   pm->sbitlow = 1U;\n   pm->ngammas = 0;\n   pm->ngamma_tests = 0;\n   pm->gammas = 0;\n   pm->current_gamma = 0;\n   pm->encodings = 0;\n   pm->nencodings = 0;\n   pm->current_encoding = 0;\n   pm->encoding_counter = 0;\n   pm->encoding_ignored = 0;\n   pm->repeat = 0;\n   pm->test_uses_encoding = 0;\n   pm->maxout8 = pm->maxpc8 = pm->maxabs8 = pm->maxcalc8 = 0;\n   pm->maxout16 = pm->maxpc16 = pm->maxabs16 = pm->maxcalc16 = 0;\n   pm->maxcalcG = 0;\n   pm->limit = 4E-3;\n   pm->log8 = pm->log16 = 0; \n   pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = 0;\n   pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0;\n   pm->error_indexed = 0;\n   pm->use_update_info = 0;\n   pm->interlace_type = PNG_INTERLACE_NONE;\n   pm->test_standard = 0;\n   pm->test_size = 0;\n   pm->test_transform = 0;\n   pm->use_input_precision = 0;\n   pm->use_input_precision_sbit = 0;\n   pm->use_input_precision_16to8 = 0;\n   pm->calculations_use_input_precision = 0;\n   pm->assume_16_bit_calculations = 0;\n   pm->test_gamma_threshold = 0;\n   pm->test_gamma_transform = 0;\n   pm->test_gamma_sbit = 0;\n   pm->test_gamma_scale16 = 0;\n   pm->test_gamma_background = 0;\n   pm->test_gamma_alpha_mode = 0;\n   pm->test_gamma_expand16 = 0;\n   pm->test_exhaustive = 0;\n   pm->log = 0;\n   \n}\n", "bug_type": null, "idx": 47}
{"project": "LibPNG", "target": 0, "func": "static int\nfind(const char *name)\n{\n   int i = NINFO;\n   while (--i >= 0)\n   {\n      if (memcmp(chunk_info[i].name, name, 4) == 0)\n         break;\n   }\n   return i;\n}\n", "bug_type": null, "idx": 48}
{"project": "LibPNG", "target": 0, "func": "static void\nsize_row(png_byte buffer[SIZE_ROWMAX], png_uint_32 bit_width, png_uint_32 y)\n{\n   \n   y = ((y & 1) << 7) + ((y & 2) << 6) + ((y & 4) << 5) + ((y & 8) << 4);\n   \n   y ^= 0xA5;\n   while (bit_width >= 8)\n      *buffer++ = (png_byte)y++, bit_width -= 8;\n   \n\n\n   if (bit_width > 0)\n   {\n      png_uint_32 mask = (1U<<(8-bit_width))-1;\n      *buffer = (png_byte)((*buffer & mask) | (y & ~mask));\n   }\n}\n", "bug_type": null, "idx": 49}
{"project": "LibPNG", "target": 0, "func": "static void\nbuffer_destroy_list(struct buffer_list *list)\n{\n   if (list != NULL)\n   {\n      struct buffer_list *next = list->next;\n      DELETE(list);\n      buffer_destroy_list(next);\n   }\n}\n", "bug_type": null, "idx": 50}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_b16g(Pixel *out, const Pixel *in, const Background *back)\n{\n   if (in->a <= 0)\n      out->r = out->g = out->b = back->ig;\n   else\n   {\n      double a = in->a/65535.;\n      double a1 = 1-a;\n      a /= 65535;\n      out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1);\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 51}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_ag16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = p->g = p->b = pp[1];\n   p->a = pp[0];\n}\n", "bug_type": null, "idx": 52}
{"project": "LibPNG", "target": 1, "func": "\nvoid\npng_formatted_warning(png_structp png_ptr, png_warning_parameters p,\n   png_const_charp message)\n{\n   \n\n\n   size_t i;\n   char msg[128];\n\n   for (i=0; i<(sizeof msg)-1 && *message != '\\0'; ++i)\n   {\n      if (*message == '@')\n      {\n         int parameter = -1;\n         switch (*++message)\n         {\n            case '1':\n               parameter = 0;\n               break;\n\n            case '2':\n               parameter = 1;\n               break;\n\n            case '\\0':\n               continue; \n\n            default:\n               break;\n         }\n\n         if (parameter >= 0 && parameter < PNG_WARNING_PARAMETER_COUNT)\n         {\n            \n            png_const_charp parm = p[parameter];\n            png_const_charp pend = p[parameter] + (sizeof p[parameter]);\n\n            \n\n\n\n            for (; i<(sizeof msg)-1 && parm != '\\0' && parm < pend; ++i)\n               msg[i] = *parm++;\n\n            ++message;\n            continue;\n         }\n\n         \n\n\n      }\n\n      \n\n\n      msg[i] = *message++;\n   }\n\n   \n   msg[i] = '\\0';\n\n   \n   png_warning(png_ptr, msg);\n}\n#endif \n", "bug_type": "cve-2011-3464", "idx": 53}
{"project": "LibPNG", "target": 0, "func": "static int\nfile_end(struct file *file)\n{\n   int rc;\n   \n\n\n   if (file->idat != NULL)\n      IDAT_end(&file->idat);\n   if (file->chunk != NULL)\n      chunk_end(&file->chunk);\n   rc = file->status_code;\n   if (file->file != NULL)\n      (void)fclose(file->file);\n   if (file->out != NULL)\n   {\n      \n\n\n      if (ferror(file->out) | fflush(file->out) | fclose(file->out))\n      {\n         perror(file->out_name);\n         emit_error(file, READ_ERROR_CODE, \"output write error\");\n         rc |= WRITE_ERROR;\n      }\n   }\n   \n   file->global->status_code |= rc;\n   CLEAR(*file);\n   return rc; \n}\n", "bug_type": null, "idx": 54}
{"project": "LibPNG", "target": 0, "func": "static void readpng2_end_callback(png_structp png_ptr, png_infop info_ptr)\n{\n    mainprog_info  *mainprog_ptr;\n    \n    mainprog_ptr = png_get_progressive_ptr(png_ptr);\n    \n\n\n\n\n\n    (*mainprog_ptr->mainprog_finish_display)();\n    \n    return;\n}\n", "bug_type": null, "idx": 55}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_palette_validate(standard_display *dp, png_const_structp pp,\n   png_infop pi)\n{\n   int npalette;\n   store_palette palette;\n   if (read_palette(palette, &npalette, pp, pi) != dp->is_transparent)\n      png_error(pp, \"validate: palette transparency changed\");\n   if (npalette != dp->npalette)\n   {\n      size_t pos = 0;\n      char msg[64];\n      pos = safecat(msg, sizeof msg, pos, \"validate: palette size changed: \");\n      pos = safecatn(msg, sizeof msg, pos, dp->npalette);\n      pos = safecat(msg, sizeof msg, pos, \" -> \");\n      pos = safecatn(msg, sizeof msg, pos, npalette);\n      png_error(pp, msg);\n   }\n   {\n      int i = npalette; \n      while (--i >= 0)\n         if (palette[i].red != dp->palette[i].red ||\n            palette[i].green != dp->palette[i].green ||\n            palette[i].blue != dp->palette[i].blue ||\n            palette[i].alpha != dp->palette[i].alpha)\n            png_error(pp, \"validate: PLTE or tRNS chunk changed\");\n   }\n}\n", "bug_type": null, "idx": 56}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_random_bytes(png_uint_32* seed, void* pv, size_t size)\n{\n   png_uint_32 u0 = seed[0], u1 = seed[1];\n   png_bytep bytes = voidcast(png_bytep, pv);\n   \n\n\n   size_t i;\n   for (i=0; i<size; ++i)\n   {\n      \n      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;\n      u1 <<= 8;\n      u1 |= u0 >> 24;\n      u0 <<= 8;\n      u0 |= u;\n      *bytes++ = (png_byte)u;\n   }\n   seed[0] = u0;\n   seed[1] = u1;\n}\n", "bug_type": null, "idx": 57}
{"project": "LibPNG", "target": 0, "func": "int main(int argc, const char **argv)\n{\n   \n\n\n\n\n\n   volatile int result = 1;\n   if (argc == 4)\n   {\n      long x = atol(argv[1]);\n      long y = atol(argv[2]);\n      FILE *f = fopen(argv[3], \"rb\");\n      volatile png_bytep row = NULL;\n      if (f != NULL)\n      {\n         \n\n\n\n\n\n         png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,\n            NULL, NULL, NULL);\n         if (png_ptr != NULL)\n         {\n            png_infop info_ptr = png_create_info_struct(png_ptr);\n            if (info_ptr != NULL)\n            {\n               \n\n\n               \n               if (setjmp(png_jmpbuf(png_ptr)) == 0)\n               {\n                  png_uint_32 width, height;\n                  int bit_depth, color_type, interlace_method,\n                     compression_method, filter_method;\n                  png_bytep row_tmp;\n                  \n\n\n\n\n\n                  png_init_io(png_ptr, f);\n                  \n\n\n                  png_read_info(png_ptr, info_ptr);\n                  \n\n\n\n\n                  row = png_malloc(png_ptr, png_get_rowbytes(png_ptr,\n                     info_ptr));\n                  \n\n\n                  row_tmp = row;\n                  \n\n\n\n                  if (png_get_IHDR(png_ptr, info_ptr, &width, &height,\n                     &bit_depth, &color_type, &interlace_method,\n                     &compression_method, &filter_method))\n                  {\n                     int passes, pass;\n                     \n\n\n\n\n                     switch (interlace_method)\n                     {\n                        case PNG_INTERLACE_NONE:\n                           passes = 1;\n                           break;\n                        case PNG_INTERLACE_ADAM7:\n                           passes = PNG_INTERLACE_ADAM7_PASSES;\n                           break;\n                        default:\n                           png_error(png_ptr, \"pngpixel: unknown interlace\");\n                     }\n                     \n                     png_start_read_image(png_ptr);\n                     for (pass=0; pass<passes; ++pass)\n                     {\n                        png_uint_32 ystart, xstart, ystep, xstep;\n                        png_uint_32 py;\n                        if (interlace_method == PNG_INTERLACE_ADAM7)\n                        {\n                           \n\n\n\n\n\n\n                           if (PNG_PASS_COLS(width, pass) == 0)\n                              continue;\n                           \n\n\n\n                           xstart = PNG_PASS_START_COL(pass);\n                           ystart = PNG_PASS_START_ROW(pass);\n                           xstep = PNG_PASS_COL_OFFSET(pass);\n                           ystep = PNG_PASS_ROW_OFFSET(pass);\n                        }\n                        else\n                        {\n                           ystart = xstart = 0;\n                           ystep = xstep = 1;\n                        }\n                        \n\n\n\n                        for (py = ystart; py < height; py += ystep)\n                        {\n                           png_uint_32 px, ppx;\n                           \n\n\n\n\n\n\n\n\n\n                           png_read_row(png_ptr, row_tmp, NULL);\n                           \n\n\n\n                           if (y == py) for (px = xstart, ppx = 0;\n                              px < width; px += xstep, ++ppx) if (x == px)\n                           {\n                              \n\n\n                              print_pixel(png_ptr, info_ptr, row_tmp, ppx);\n                              \n\n\n                              goto pass_loop_end;\n                           } \n                        } \n                     } \n                     \n                  pass_loop_end:\n                     row = NULL;\n                     png_free(png_ptr, row_tmp);\n                  }\n                  else\n                     png_error(png_ptr, \"pngpixel: png_get_IHDR failed\");\n               }\n               else\n               {\n                  \n\n\n\n                  if (row != NULL)\n                  {\n                     \n\n\n\n\n                     png_bytep row_tmp = row;\n                     row = NULL;\n                     png_free(png_ptr, row_tmp);\n                  }\n               }\n               png_destroy_info_struct(png_ptr, &info_ptr);\n            }\n            else\n               fprintf(stderr, \"pngpixel: out of memory allocating png_info\\n\");\n            png_destroy_read_struct(&png_ptr, NULL, NULL);\n         }\n         else\n            fprintf(stderr, \"pngpixel: out of memory allocating png_struct\\n\");\n      }\n      else\n         fprintf(stderr, \"pngpixel: %s: could not open file\\n\", argv[3]);\n   }\n   else\n      \n      fprintf(stderr, \"pngpixel: usage: pngpixel x y png-file\\n\");\n   return result;\n}\n", "bug_type": null, "idx": 58}
{"project": "LibPNG", "target": 0, "func": "static struct file *\nget_control(png_const_structrp png_ptr)\n{\n   \n\n\n   struct control *control = png_voidcast(struct control*,\n      png_get_error_ptr(png_ptr));\n   return &control->file;\n}\n", "bug_type": null, "idx": 59}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_ini_end(PNG_CONST image_transform *this,\n   transform_display *that)\n{\n   UNUSED(this)\n   UNUSED(that)\n}\n", "bug_type": null, "idx": 60}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage)\n{\n   png_const_bytep image = ps->image;\n   if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)\n      png_error(pp, \"image overwrite\");\n   else\n   {\n      png_size_t cbRow = ps->cb_row;\n      png_uint_32 rows = ps->image_h;\n      image += iImage * (cbRow+5) * ps->image_h;\n      image += 2; \n      while (rows-- > 0)\n      {\n         if (image[-2] != 190 || image[-1] != 239)\n            png_error(pp, \"row start overwritten\");\n         if (image[cbRow] != 222 || image[cbRow+1] != 173 ||\n            image[cbRow+2] != 17)\n            png_error(pp, \"row end overwritten\");\n         image += cbRow+5;\n      }\n   }\n}\n", "bug_type": null, "idx": 61}
{"project": "LibPNG", "target": 0, "func": "  */\nstatic int fail(png_modifier *pm)\n{\n   return !pm->log && !pm->this.verbose && (pm->this.nerrors > 0 ||\n       (pm->this.treat_warnings_as_errors && pm->this.nwarnings > 0));\n}\n", "bug_type": null, "idx": 62}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\ntransform_height(png_const_structp pp, png_byte colour_type, png_byte bit_depth)\n{\n   switch (bit_size(pp, colour_type, bit_depth))\n   {\n      case 1:\n      case 2:\n      case 4:\n         return 1;   \n      case 8:\n         return 2;   \n      case 16:\n         return 512; \n      case 24:\n      case 32:\n         return 512; \n      case 48:\n      case 64:\n         return 2048;\n#        define TRANSFORM_HEIGHTMAX 2048\n      default:\n         return 0;   \n   }\n}\n", "bug_type": null, "idx": 63}
{"project": "LibPNG", "target": 0, "func": "static png_byte\ncomponent_loc(png_byte loc[4], png_uint_32 format)\n{\n   \n\n\n\n\n\n\n\n\n\n\n\n   png_byte channels;\n   if (format & PNG_FORMAT_FLAG_COLOR)\n   {\n      channels = 3;\n      loc[2] = 1;\n#     ifdef PNG_FORMAT_BGR_SUPPORTED\n         if (format & PNG_FORMAT_FLAG_BGR)\n         {\n            loc[1] = 2;\n            loc[3] = 0;\n         }\n         else\n#     endif\n      {\n         loc[1] = 0;\n         loc[3] = 2;\n      }\n   }\n   else\n   {\n      channels = 1;\n      loc[1] = loc[2] = loc[3] = 0;\n   }\n   if (format & PNG_FORMAT_FLAG_ALPHA)\n   {\n#     ifdef PNG_FORMAT_AFIRST_SUPPORTED\n         if (format & PNG_FORMAT_FLAG_AFIRST)\n         {\n            loc[0] = 0;\n            ++loc[1];\n            ++loc[2];\n            ++loc[3];\n         }\n         else\n#     endif\n         loc[0] = channels;\n      ++channels;\n   }\n   else\n      loc[0] = 4; \n   return channels;\n}\n", "bug_type": null, "idx": 64}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_ga8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = p->g = p->b = pp[0];\n   p->a = pp[1];\n}\n", "bug_type": null, "idx": 65}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_info_imp(standard_display *dp, png_structp pp, png_infop pi,\n    int nImages)\n{\n   \n\n\n   standard_info_part1(dp, pp, pi);\n   \n\n\n   if (dp->use_update_info)\n   {\n      \n      int i = dp->use_update_info;\n      while (i-- > 0)\n         png_read_update_info(pp, pi);\n   }\n   else\n      png_start_read_image(pp);\n   \n\n\n   standard_info_part2(dp, pp, pi, nImages);\n}\n", "bug_type": null, "idx": 66}
{"project": "LibPNG", "target": 0, "func": "static void\ndeinterlace_row(png_bytep buffer, png_const_bytep row,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   \n\n\n\n\n   png_uint_32 xin, xout, xstep;\n   xout = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xin=0; xout<w; xout+=xstep)\n   {\n      pixel_copy(buffer, xout, row, xin, pixel_size);\n      ++xin;\n   }\n}\n", "bug_type": null, "idx": 67}
{"project": "LibPNG", "target": 0, "func": "static int\nsrgb_modify(png_modifier *pm, png_modification *me, int add)\n{\n   UNUSED(add)\n   \n   png_save_uint_32(pm->buffer, 1);\n   png_save_uint_32(pm->buffer+4, CHUNK_sRGB);\n   pm->buffer[8] = ((srgb_modification*)me)->intent;\n   return 1;\n}\n", "bug_type": null, "idx": 68}
{"project": "LibPNG", "target": 0, "func": "static int\nis_combo(int transforms)\n{\n   return transforms & (transforms-1); \n}\n", "bug_type": null, "idx": 69}
{"project": "LibPNG", "target": 0, "func": " */\npng_uint_32 get_value (FILE *pnm_file, int depth)\n{\n  static png_uint_32 mask = 0;\n  png_byte token[16];\n  unsigned long ul_ret_value;\n  png_uint_32 ret_value;\n  int i = 0;\n  if (mask == 0)\n    for (i = 0; i < depth; i++)\n      mask = (mask << 1) | 0x01;\n  get_token (pnm_file, (char *) token);\n  sscanf ((const char *) token, \"%lu\", &ul_ret_value);\n  ret_value = (png_uint_32) ul_ret_value;\n  ret_value &= mask;\n  if (depth < 8)\n    for (i = 0; i < (8 / depth); i++)\n      ret_value = (ret_value << depth) || ret_value;\n  return ret_value;\n}\n", "bug_type": null, "idx": 70}
{"project": "LibPNG", "target": 0, "func": "static int\nfirst_transform(int transforms)\n{\n   return transforms & -transforms; \n}\n", "bug_type": null, "idx": 71}
{"project": "LibPNG", "target": 0, "func": "\nuch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)\n{\n    double  gamma;\n    png_uint_32  i, rowbytes;\n    png_bytepp  row_pointers = NULL;\n    \n\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        free(image_data);\n        image_data = NULL;\n        free(row_pointers);\n        row_pointers = NULL;\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return NULL;\n    }\n    \n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_expand(png_ptr);\n    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\n        png_set_expand(png_ptr);\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\n        png_set_expand(png_ptr);\n#ifdef PNG_READ_16_TO_8_SUPPORTED\n    if (bit_depth == 16)\n#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n        png_set_scale_16(png_ptr);\n#  else\n        png_set_strip_16(png_ptr);\n#  endif\n#endif\n    if (color_type == PNG_COLOR_TYPE_GRAY ||\n        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        png_set_gray_to_rgb(png_ptr);\n    \n\n\n    if (png_get_gAMA(png_ptr, info_ptr, &gamma))\n        png_set_gamma(png_ptr, display_exponent, gamma);\n    \n\n    png_read_update_info(png_ptr, info_ptr);\n    *pRowbytes = rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n    *pChannels = (int)png_get_channels(png_ptr, info_ptr);\n    if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return NULL;\n    }\n    if ((row_pointers = (png_bytepp)malloc(height*sizeof(png_bytep))) == NULL) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        free(image_data);\n        image_data = NULL;\n        return NULL;\n    }\n    Trace((stderr, \"readpng_get_image:  channels = %d, rowbytes = %ld, height = %ld\\n\",\n        *pChannels, rowbytes, height));\n    \n    for (i = 0;  i < height;  ++i)\n        row_pointers[i] = image_data + i*rowbytes;\n    \n    png_read_image(png_ptr, row_pointers);\n    \n\n    free(row_pointers);\n    row_pointers = NULL;\n    png_read_end(png_ptr, NULL);\n    return image_data;\n}\n", "bug_type": null, "idx": 72}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_gamma_test(png_modifier *pm, int summary)\n{\n   \n   \n   unsigned int calculations_use_input_precision =\n      pm->calculations_use_input_precision;\n#  ifdef PNG_READ_BACKGROUND_SUPPORTED\n      double maxout8 = pm->maxout8;\n#  endif\n   \n   if (!pm->this.speed && pm->test_gamma_threshold)\n   {\n      perform_gamma_threshold_tests(pm);\n      if (fail(pm))\n         return;\n   }\n   \n   if (pm->test_gamma_transform)\n   {\n      if (summary)\n      {\n         fflush(stderr);\n         printf(\"Gamma correction error summary\\n\\n\");\n         printf(\"The printed value is the maximum error in the pixel values\\n\");\n         printf(\"calculated by the libpng gamma correction code.  The error\\n\");\n         printf(\"is calculated as the difference between the output pixel\\n\");\n         printf(\"value (always an integer) and the ideal value from the\\n\");\n         printf(\"libpng specification (typically not an integer).\\n\\n\");\n         printf(\"Expect this value to be less than .5 for 8 bit formats,\\n\");\n         printf(\"less than 1 for formats with fewer than 8 bits and a small\\n\");\n         printf(\"number (typically less than 5) for the 16 bit formats.\\n\");\n         printf(\"For performance reasons the value for 16 bit formats\\n\");\n         printf(\"increases when the image file includes an sBIT chunk.\\n\");\n         fflush(stdout);\n      }\n      init_gamma_errors(pm);\n      \n\n\n      if (pm->test_gamma_expand16)\n         pm->calculations_use_input_precision = 1;\n      perform_gamma_transform_tests(pm);\n      if (!calculations_use_input_precision)\n         pm->calculations_use_input_precision = 0;\n      if (summary)\n         summarize_gamma_errors(pm, 0, 1, 1);\n      if (fail(pm))\n         return;\n   }\n   \n   if (pm->test_gamma_sbit)\n   {\n      init_gamma_errors(pm);\n      perform_gamma_sbit_tests(pm);\n      if (summary)\n         summarize_gamma_errors(pm, \"sBIT\", pm->sbitlow < 8U, 1);\n      if (fail(pm))\n         return;\n   }\n#ifdef DO_16BIT \n   if (pm->test_gamma_scale16)\n   {\n      \n      init_gamma_errors(pm);\n      perform_gamma_scale16_tests(pm);\n      if (summary)\n      {\n         fflush(stderr);\n         printf(\"\\nGamma correction with 16 to 8 bit reduction:\\n\");\n         printf(\" 16 bit gray:  %.5f\\n\", pm->error_gray_16);\n         printf(\" 16 bit color: %.5f\\n\", pm->error_color_16);\n         fflush(stdout);\n      }\n      if (fail(pm))\n         return;\n   }\n#endif\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n   if (pm->test_gamma_background)\n   {\n      init_gamma_errors(pm);\n      \n\n\n      if (pm->test_gamma_expand16)\n      {\n         pm->calculations_use_input_precision = 1;\n         pm->maxout8 = .499; \n      }\n      perform_gamma_composition_tests(pm, PNG_BACKGROUND_GAMMA_UNIQUE,\n         pm->test_gamma_expand16);\n      if (!calculations_use_input_precision)\n         pm->calculations_use_input_precision = 0;\n      pm->maxout8 = maxout8;\n      if (summary)\n         summarize_gamma_errors(pm, \"background\", 1, 0);\n      if (fail(pm))\n         return;\n   }\n#endif\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n   if (pm->test_gamma_alpha_mode)\n   {\n      int do_background;\n      init_gamma_errors(pm);\n      \n\n\n      if (pm->test_gamma_expand16)\n         pm->calculations_use_input_precision = 1;\n      for (do_background = ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD;\n         do_background <= ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN && !fail(pm);\n         ++do_background)\n         perform_gamma_composition_tests(pm, do_background,\n            pm->test_gamma_expand16);\n      if (!calculations_use_input_precision)\n         pm->calculations_use_input_precision = 0;\n      if (summary)\n         summarize_gamma_errors(pm, \"alpha mode\", 1, 0);\n      if (fail(pm))\n         return;\n   }\n#endif\n}\n", "bug_type": null, "idx": 73}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_gray_to_rgb_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_gray_to_rgb(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 74}
{"project": "LibPNG", "target": 0, "func": "static int\nbuffer_from_file(struct buffer *buffer, FILE *fp)\n{\n   struct buffer_list *last = &buffer->first;\n   size_t count = 0;\n   for (;;)\n   {\n      size_t r = fread(last->buffer+count, 1,\n         (sizeof last->buffer)-count, fp);\n      if (r > 0)\n      {\n         count += r;\n         if (count >= sizeof last->buffer)\n         {\n            assert(count == sizeof last->buffer);\n            count = 0;\n            if (last->next == NULL)\n            {\n               last = buffer_extend(last);\n               if (last == NULL)\n                  return MEMORY;\n            }\n            else\n               last = last->next;\n         }\n      }\n      else \n      {\n         if (feof(fp))\n         {\n            buffer->last = last;\n            buffer->end_count = count;\n            return 0; \n         }\n         \n         return errno == 0 ? ERANGE : errno;\n      }\n   }\n}\n", "bug_type": null, "idx": 75}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL InitBitmap (BYTE *pDiData, int cxWinSize, int cyWinSize)\n{\n    BYTE *dst;\n    int x, y, col;\n    \n    dst = pDiData;\n    for (y = 0; y < cyWinSize; y++)\n    {\n        col = 0;\n        for (x = 0; x < cxWinSize; x++)\n        {\n            \n            *dst++ = 127;\n            *dst++ = 127;\n            *dst++ = 127;\n            col += 3;\n        }\n        \n        while ((col % 4) != 0)\n        {\n            dst++;\n            col++;\n        }\n    }\n    return TRUE;\n}\n", "bug_type": null, "idx": 76}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_expand_16_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   \n\n\n   if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n      image_pixel_convert_PLTE(that);\n   if (that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n   if (that->bit_depth < 16)\n      that->sample_depth = that->bit_depth = 16;\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 77}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_size_images(png_store *ps)\n{\n   \n   safecat(ps->test, sizeof ps->test, 0, \"make size images\");\n   \n\n   make_size(ps, 0, 0, WRITE_BDHI);\n   make_size(ps, 2, 3, WRITE_BDHI);\n   make_size(ps, 3, 0, 3 );\n   make_size(ps, 4, 3, WRITE_BDHI);\n   make_size(ps, 6, 3, WRITE_BDHI);\n}\n", "bug_type": null, "idx": 78}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_palette_to_rgb_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(bit_depth)\n   this->next = *that;\n   *that = this;\n   return colour_type == PNG_COLOR_TYPE_PALETTE;\n}\n", "bug_type": null, "idx": 79}
{"project": "LibPNG", "target": 0, "func": "static int\ncompare_two_images(Image *a, Image *b, int via_linear,\n   png_const_colorp background)\n{\n   ptrdiff_t stridea = a->stride;\n   ptrdiff_t strideb = b->stride;\n   png_const_bytep rowa = a->buffer+16;\n   png_const_bytep rowb = b->buffer+16;\n   const png_uint_32 width = a->image.width;\n   const png_uint_32 height = a->image.height;\n   const png_uint_32 formata = a->image.format;\n   const png_uint_32 formatb = b->image.format;\n   const unsigned int a_sample = PNG_IMAGE_SAMPLE_SIZE(formata);\n   const unsigned int b_sample = PNG_IMAGE_SAMPLE_SIZE(formatb);\n   int alpha_added, alpha_removed;\n   int bchannels;\n   int btoa[4];\n   png_uint_32 y;\n   Transform tr;\n   \n   if (width != b->image.width || height != b->image.height)\n      return logerror(a, a->file_name, \": width x height changed: \",\n         b->file_name);\n   \n   transform_from_formats(&tr, a, b, background, via_linear);\n   \n   if (!(formata & PNG_FORMAT_FLAG_COLORMAP) &&\n      (formata & PNG_FORMAT_FLAG_LINEAR))\n      stridea *= 2;\n   if (!(formatb & PNG_FORMAT_FLAG_COLORMAP) &&\n      (formatb & PNG_FORMAT_FLAG_LINEAR))\n      strideb *= 2;\n   if (stridea < 0) rowa += (height-1) * (-stridea);\n   if (strideb < 0) rowb += (height-1) * (-strideb);\n   \n\n\n\n\n   if (formata & formatb & PNG_FORMAT_FLAG_COLORMAP)\n   {\n      \n      png_const_bytep ppa, ppb;\n      int match;\n      png_byte in_use[256], amax = 0, bmax = 0;\n      memset(in_use, 0, sizeof in_use);\n      ppa = rowa;\n      ppb = rowb;\n      \n\n\n\n      for (y=0, match=1; y<height && match; ++y, ppa += stridea, ppb += strideb)\n      {\n         png_uint_32 x;\n         for (x=0; x<width; ++x)\n         {\n            png_byte bval = ppb[x];\n            png_byte aval = ppa[x];\n            if (bval > bmax)\n               bmax = bval;\n            if (bval != aval)\n               match = 0;\n            in_use[aval] = 1;\n            if (aval > amax)\n               amax = aval;\n         }\n      }\n      \n      if (match)\n      {\n         \n\n\n         png_const_bytep a_cmap = (png_const_bytep)a->colormap;\n         png_const_bytep b_cmap = (png_const_bytep)b->colormap;\n         int result = 1; \n         \n         tr.is_palette = 1;\n         for (y=0; y<256; ++y, a_cmap += a_sample, b_cmap += b_sample)\n            if (in_use[y])\n         {\n            \n\n\n\n\n            if (y >= a->image.colormap_entries)\n            {\n               if ((a->opts & ACCUMULATE) == 0)\n               {\n                  char pindex[9];\n                  sprintf(pindex, \"%lu[%lu]\", (unsigned long)y,\n                     (unsigned long)a->image.colormap_entries);\n                  logerror(a, a->file_name, \": bad pixel index: \", pindex);\n               }\n               result = 0;\n            }\n            else if (y >= b->image.colormap_entries)\n            {\n               if ((a->opts & ACCUMULATE) == 0)\n                  {\n                  char pindex[9];\n                  sprintf(pindex, \"%lu[%lu]\", (unsigned long)y,\n                     (unsigned long)b->image.colormap_entries);\n                  logerror(b, b->file_name, \": bad pixel index: \", pindex);\n                  }\n               result = 0;\n            }\n            \n            else if (!cmppixel(&tr, a_cmap, b_cmap, 0, y))\n               result = 0;\n         }\n         \n         if (a->opts & ACCUMULATE)\n         {\n            tr.error_ptr[0] = tr.error[0];\n            tr.error_ptr[1] = tr.error[1];\n            tr.error_ptr[2] = tr.error[2];\n            tr.error_ptr[3] = tr.error[3];\n            result = 1; \n         }\n         return result;\n      }\n      \n\n\n\n      else if ((a->opts & ACCUMULATE) == 0)\n      {\n         \n\n\n         if (amax >= a->image.colormap_entries)\n         {\n            char pindex[9];\n            sprintf(pindex, \"%d[%lu]\", amax,\n               (unsigned long)a->image.colormap_entries);\n            return logerror(a, a->file_name, \": bad pixel index: \", pindex);\n         }\n         else if (bmax >= b->image.colormap_entries)\n         {\n            char pindex[9];\n            sprintf(pindex, \"%d[%lu]\", bmax,\n               (unsigned long)b->image.colormap_entries);\n            return logerror(b, b->file_name, \": bad pixel index: \", pindex);\n         }\n      }\n   }\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   if (!(((formata ^ formatb) & PNG_FORMAT_FLAG_LINEAR) |\n      (formata & (formatb ^ PNG_FORMAT_FLAG_COLOR) & PNG_FORMAT_FLAG_COLOR)))\n   {\n      \n      const png_uint_32 alpha_changed = (formata ^ formatb) &\n         PNG_FORMAT_FLAG_ALPHA;\n      \n\n\n      alpha_removed = (formata & alpha_changed) != 0;\n      \n      alpha_added = (formatb & alpha_changed) != 0;\n      \n\n\n\n\n      {\n         int i;\n         png_byte aloc[4];\n         png_byte bloc[4];\n         \n\n\n\n\n\n         (void)component_loc(aloc, formata);\n         bchannels = component_loc(bloc, formatb);\n         \n         for (i=0; i<4; ++i) if (bloc[i] < 4)\n            btoa[bloc[i]] = aloc[i]; \n         if (alpha_added)\n            alpha_added = bloc[0]; \n         else\n            alpha_added = 4; \n         if (alpha_removed)\n            alpha_removed = aloc[0]; \n         else\n            alpha_removed = 4;\n      }\n   }\n   else\n   {\n      \n\n\n      bchannels = 0;\n      alpha_removed = alpha_added = 4;\n      btoa[3] = btoa[2] = btoa[1] = btoa[0] = 4; \n   }\n   for (y=0; y<height; ++y, rowa += stridea, rowb += strideb)\n   {\n      png_const_bytep ppa, ppb;\n      png_uint_32 x;\n      for (x=0, ppa=rowa, ppb=rowb; x<width; ++x)\n      {\n         png_const_bytep psa, psb;\n         if (formata & PNG_FORMAT_FLAG_COLORMAP)\n            psa = (png_const_bytep)a->colormap + a_sample * *ppa++;\n         else\n            psa = ppa, ppa += a_sample;\n         if (formatb & PNG_FORMAT_FLAG_COLORMAP)\n            psb = (png_const_bytep)b->colormap + b_sample * *ppb++;\n         else\n            psb = ppb, ppb += b_sample;\n         \n         if (bchannels)\n         {\n            \n\n\n\n\n\n            if (formatb & PNG_FORMAT_FLAG_LINEAR) \n            {\n               png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);\n               png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);\n               switch (bchannels)\n               {\n                  case 4:\n                     if (pua[btoa[3]] != pub[3]) break;\n                  case 3:\n                     if (pua[btoa[2]] != pub[2]) break;\n                  case 2:\n                     if (pua[btoa[1]] != pub[1]) break;\n                  case 1:\n                     if (pua[btoa[0]] != pub[0]) break;\n                     if (alpha_added != 4 && pub[alpha_added] != 65535) break;\n                     continue; \n                  default:\n                     break; \n               }\n            }\n            else if (alpha_removed == 4 || psa[alpha_removed] == 255)\n            {\n               switch (bchannels)\n               {\n                  case 4:\n                     if (psa[btoa[3]] != psb[3]) break;\n                  case 3:\n                     if (psa[btoa[2]] != psb[2]) break;\n                  case 2:\n                     if (psa[btoa[1]] != psb[1]) break;\n                  case 1:\n                     if (psa[btoa[0]] != psb[0]) break;\n                     if (alpha_added != 4 && psb[alpha_added] != 255) break;\n                     continue; \n                  default:\n                     break; \n               }\n            }\n         }\n         \n\n\n         if (!cmppixel(&tr, psa, psb, x, y) && (a->opts & KEEP_GOING) == 0)\n            return 0; \n      }\n   }\n   \n   if (a->opts & ACCUMULATE)\n   {\n      tr.error_ptr[0] = tr.error[0];\n      tr.error_ptr[1] = tr.error[1];\n      tr.error_ptr[2] = tr.error[2];\n      tr.error_ptr[3] = tr.error[3];\n   }\n   return 1;\n}\n", "bug_type": null, "idx": 80}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL DisplayImage (HWND hwnd, BYTE **ppDib,\n        BYTE **ppDiData, int cxWinSize, int cyWinSize,\n        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,\n        BOOL bStretched)\n{\n    BYTE                       *pDib = *ppDib;\n    BYTE                       *pDiData = *ppDiData;\n    \n    BITMAPINFOHEADER           *pbmih;\n    WORD                        wDIRowBytes;\n    png_color                   bkgBlack = {0, 0, 0};\n    png_color                   bkgGray  = {127, 127, 127};\n    png_color                   bkgWhite = {255, 255, 255};\n    \n    wDIRowBytes = (WORD) ((3 * cxWinSize + 3L) >> 2) << 2;\n    if (pDib)\n    {\n        free (pDib);\n        pDib = NULL;\n    }\n    if (!(pDib = (BYTE *) malloc (sizeof(BITMAPINFOHEADER) +\n        wDIRowBytes * cyWinSize)))\n    {\n        MessageBox (hwnd, TEXT (\"Error in displaying the PNG image\"),\n            szProgName, MB_ICONEXCLAMATION | MB_OK);\n        *ppDib = pDib = NULL;\n        return FALSE;\n    }\n    *ppDib = pDib;\n    memset (pDib, 0, sizeof(BITMAPINFOHEADER));\n    \n    pbmih = (BITMAPINFOHEADER *) pDib;\n    pbmih->biSize = sizeof(BITMAPINFOHEADER);\n    pbmih->biWidth = cxWinSize;\n    pbmih->biHeight = -((long) cyWinSize);\n    pbmih->biPlanes = 1;\n    pbmih->biBitCount = 24;\n    pbmih->biCompression = 0;\n    pDiData = pDib + sizeof(BITMAPINFOHEADER);\n    *ppDiData = pDiData;\n    \n    InitBitmap (pDiData, cxWinSize, cyWinSize);\n    \n    if (pbImage)\n    {\n        FillBitmap (\n            pDiData, cxWinSize, cyWinSize,\n            pbImage, cxImgSize, cyImgSize, cImgChannels,\n            bStretched);\n    }\n    return TRUE;\n}\n", "bug_type": null, "idx": 81}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_one_test(FILE *fp, int argc, const char **argv,\n   png_uint_32 *default_flags, display *d, int set_callback)\n{\n   int def;\n   png_uint_32 flags[2][4];\n   rewind(fp);\n   clear_keep();\n   memcpy(flags[0], default_flags, sizeof flags[0]);\n   def = check(fp, argc, argv, flags[1], d, set_callback);\n   \n\n\n\n\n   check_error(d, (flags[0][0]|flags[0][2]) & (flags[0][1]|flags[0][3]),\n      \"chunk handled inconsistently in count tests\");\n   check_error(d, (flags[1][0]|flags[1][2]) & (flags[1][1]|flags[1][3]),\n      \"chunk handled inconsistently in option tests\");\n   \n\n\n\n\n   {\n      png_uint_32 test;\n      test = flags[1][0] & ~flags[0][0];\n      check_error(d, test, \"new known chunk before IDAT\");\n      test = flags[1][1] & ~(flags[0][0] | flags[0][1]);\n      check_error(d, test, \"new unknown chunk before IDAT\");\n      test = flags[1][2] & ~flags[0][2];\n      check_error(d, test, \"new known chunk after IDAT\");\n      test = flags[1][3] & ~(flags[0][2] | flags[0][3]);\n      check_error(d, test, \"new unknown chunk after IDAT\");\n   }\n   \n\n\n\n   check_handling(d, def, flags[0][0] | flags[0][1], flags[1][0], flags[1][1],\n      \"before IDAT\", set_callback);\n   check_handling(d, def, flags[0][2] | flags[0][3], flags[1][2], flags[1][3],\n      \"after IDAT\", set_callback);\n}\n", "bug_type": null, "idx": 82}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_freebuffer(png_store_buffer* psb)\n{\n   if (psb->prev)\n   {\n      store_freebuffer(psb->prev);\n      free(psb->prev);\n      psb->prev = NULL;\n   }\n}\n", "bug_type": null, "idx": 83}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_range_check(png_const_structp pp, unsigned int r, unsigned int g,\n   unsigned int b, unsigned int a, unsigned int in_digitized, double in,\n   unsigned int out, png_byte sample_depth, double err, double limit,\n   PNG_CONST char *name, double digitization_error)\n{\n   \n\n\n\n\n\n   unsigned int max = (1U<<sample_depth)-1;\n   double in_min = ceil((in-err)*max - digitization_error);\n   double in_max = floor((in+err)*max + digitization_error);\n   if (err > limit || !(out >= in_min && out <= in_max))\n   {\n      char message[256];\n      size_t pos;\n      pos = safecat(message, sizeof message, 0, name);\n      pos = safecat(message, sizeof message, pos, \" output value error: rgba(\");\n      pos = safecatn(message, sizeof message, pos, r);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, g);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, b);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, a);\n      pos = safecat(message, sizeof message, pos, \"): \");\n      pos = safecatn(message, sizeof message, pos, out);\n      pos = safecat(message, sizeof message, pos, \" expected: \");\n      pos = safecatn(message, sizeof message, pos, in_digitized);\n      pos = safecat(message, sizeof message, pos, \" (\");\n      pos = safecatd(message, sizeof message, pos, (in-err)*max, 3);\n      pos = safecat(message, sizeof message, pos, \"..\");\n      pos = safecatd(message, sizeof message, pos, (in+err)*max, 3);\n      pos = safecat(message, sizeof message, pos, \")\");\n      png_error(pp, message);\n   }\n}\n", "bug_type": null, "idx": 84}
{"project": "LibPNG", "target": 0, "func": "static int\ntest_one_file(const char *file_name, format_list *formats, png_uint_32 opts,\n   int stride_extra, int log_pass)\n{\n   int result;\n   Image image;\n   newimage(&image);\n   initimage(&image, opts, file_name, stride_extra);\n   result = read_one_file(&image);\n   if (result)\n      result = testimage(&image, opts, formats);\n   freeimage(&image);\n   \n   fflush(stderr);\n   if (log_pass)\n   {\n      if (result)\n         printf(\"PASS:\");\n      else\n         printf(\"FAIL:\");\n#     ifndef PNG_SIMPLIFIED_WRITE_SUPPORTED\n         printf(\" (no write)\");\n#     endif\n      print_opts(opts);\n      printf(\" %s\\n\", file_name);\n      \n      fflush(stdout);\n   }\n   else if (!result)\n      exit(1);\n   return result;\n}\n", "bug_type": null, "idx": 85}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_size_test(png_modifier *pm)\n{\n   \n\n\n   if (!test_size(pm, 0, 0, READ_BDHI))\n      return;\n   if (!test_size(pm, 2, 3, READ_BDHI))\n      return;\n   \n\n\n#if 0\n   if (!test_size(pm, 3, 0, 3))\n      return;\n#endif\n   if (!test_size(pm, 4, 3, READ_BDHI))\n      return;\n   if (!test_size(pm, 6, 3, READ_BDHI))\n      return;\n}\n", "bug_type": null, "idx": 86}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_standard_test(png_modifier *pm)\n{\n   \n\n\n   if (!test_standard(pm, 0, 0, READ_BDHI))\n      return;\n   if (!test_standard(pm, 2, 3, READ_BDHI))\n      return;\n   if (!test_standard(pm, 3, 0, 3))\n      return;\n   if (!test_standard(pm, 4, 3, READ_BDHI))\n      return;\n   if (!test_standard(pm, 6, 3, READ_BDHI))\n      return;\n}\n", "bug_type": null, "idx": 87}
{"project": "LibPNG", "target": 0, "func": "static void\nsbit_modification_init(sbit_modification *me, png_modifier *pm, png_byte sbit)\n{\n   modification_init(&me->this);\n   me->this.chunk = CHUNK_sBIT;\n   me->this.modify_fn = sbit_modify;\n   me->this.add = CHUNK_PLTE;\n   me->sbit = sbit;\n   me->this.next = pm->modifications;\n   pm->modifications = &me->this;\n}\n", "bug_type": null, "idx": 88}
{"project": "LibPNG", "target": 1, "func": "\nint \npng_set_text_2(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_textp text_ptr, int num_text)\n{\n   int i;\n\n   png_debug1(1, \"in %lx storage function\", png_ptr == NULL ? \"unexpected\" :\n      (unsigned long)png_ptr->chunk_name);\n\n   if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL)\n      return(0);\n\n   \n\n\n\n\n   if (num_text > info_ptr->max_text - info_ptr->num_text)\n   {\n      int old_num_text = info_ptr->num_text;\n      int max_text;\n      png_textp new_text = NULL;\n\n      \n      max_text = old_num_text;\n      if (num_text <= INT_MAX - max_text)\n      {\n         max_text += num_text;\n\n         \n         if (max_text < INT_MAX-8)\n            max_text = (max_text + 8) & ~0x7;\n\n         else\n            max_text = INT_MAX;\n\n         \n\n\n         new_text = png_voidcast(png_textp,png_realloc_array(png_ptr,\n            info_ptr->text, old_num_text, max_text-old_num_text,\n            sizeof *new_text));\n      }\n\n      if (new_text == NULL)\n      {\n         png_chunk_report(png_ptr, \"too many text chunks\",\n            PNG_CHUNK_WRITE_ERROR);\n         return 1;\n      }\n\n      png_free(png_ptr, info_ptr->text);\n\n      info_ptr->text = new_text;\n      info_ptr->free_me |= PNG_FREE_TEXT;\n      info_ptr->max_text = max_text;\n      \n\n      png_debug1(3, \"allocated %d entries for info_ptr->text\", max_text);\n   }\n\n   for (i = 0; i < num_text; i++)\n   {\n      size_t text_length, key_len;\n      size_t lang_len, lang_key_len;\n      png_textp textp = &(info_ptr->text[info_ptr->num_text]);\n\n      if (text_ptr[i].key == NULL)\n          continue;\n\n      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||\n          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)\n      {\n         png_chunk_report(png_ptr, \"text compression mode is out of range\",\n            PNG_CHUNK_WRITE_ERROR);\n         continue;\n      }\n\n      key_len = strlen(text_ptr[i].key);\n\n      if (text_ptr[i].compression <= 0)\n      {\n         lang_len = 0;\n         lang_key_len = 0;\n      }\n\n      else\n#  ifdef PNG_iTXt_SUPPORTED\n      {\n         \n\n         if (text_ptr[i].lang != NULL)\n            lang_len = strlen(text_ptr[i].lang);\n\n         else\n            lang_len = 0;\n\n         if (text_ptr[i].lang_key != NULL)\n            lang_key_len = strlen(text_ptr[i].lang_key);\n\n         else\n            lang_key_len = 0;\n      }\n#  else \n      {\n         png_chunk_report(png_ptr, \"iTXt chunk not supported\",\n            PNG_CHUNK_WRITE_ERROR);\n         continue;\n      }\n#  endif\n\n      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')\n      {\n         text_length = 0;\n#  ifdef PNG_iTXt_SUPPORTED\n         if (text_ptr[i].compression > 0)\n            textp->compression = PNG_ITXT_COMPRESSION_NONE;\n\n         else\n#  endif\n            textp->compression = PNG_TEXT_COMPRESSION_NONE;\n      }\n\n      else\n      {\n         text_length = strlen(text_ptr[i].text);\n         textp->compression = text_ptr[i].compression;\n      }\n\n      textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr,\n          key_len + text_length + lang_len + lang_key_len + 4));\n\n      if (textp->key == NULL)\n      {\n         png_chunk_report(png_ptr, \"text chunk: out of memory\",\n               PNG_CHUNK_WRITE_ERROR);\n         return 1;\n      }\n\n      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",\n          (unsigned long)(png_uint_32)\n          (key_len + lang_len + lang_key_len + text_length + 4),\n          textp->key);\n\n      memcpy(textp->key, text_ptr[i].key, key_len);\n      *(textp->key + key_len) = '\\0';\n\n      if (text_ptr[i].compression > 0)\n      {\n         textp->lang = textp->key + key_len + 1;\n         memcpy(textp->lang, text_ptr[i].lang, lang_len);\n         *(textp->lang + lang_len) = '\\0';\n         textp->lang_key = textp->lang + lang_len + 1;\n         memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);\n         *(textp->lang_key + lang_key_len) = '\\0';\n         textp->text = textp->lang_key + lang_key_len + 1;\n      }\n\n      else\n      {\n         textp->lang=NULL;\n         textp->lang_key=NULL;\n         textp->text = textp->key + key_len + 1;\n      }\n\n      if (text_length != 0)\n         memcpy(textp->text, text_ptr[i].text, text_length);\n\n      *(textp->text + text_length) = '\\0';\n\n#  ifdef PNG_iTXt_SUPPORTED\n      if (textp->compression > 0)\n      {\n         textp->text_length = 0;\n         textp->itxt_length = text_length;\n      }\n\n      else\n#  endif\n      {\n         textp->text_length = text_length;\n         textp->itxt_length = 0;\n      }\n\n      info_ptr->num_text++;\n      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);\n   }\n\n   return(0);\n}\n#endif", "bug_type": "cve-2016-10087", "idx": 89}
{"project": "LibPNG", "target": 0, "func": "static store_palette_entry *\nstore_write_palette(png_store *ps, int npalette)\n{\n   if (ps->pwrite == NULL)\n      store_log(ps, NULL, \"attempt to write palette without write stream\", 1);\n   if (ps->palette != NULL)\n      png_error(ps->pwrite, \"multiple store_write_palette calls\");\n   \n   if (npalette > 0)\n   {\n      ps->palette = voidcast(store_palette_entry*, malloc(npalette *\n         sizeof *ps->palette));\n      if (ps->palette == NULL)\n         png_error(ps->pwrite, \"store new palette: OOM\");\n      ps->npalette = npalette;\n   }\n   return ps->palette;\n}\n", "bug_type": null, "idx": 90}
{"project": "LibPNG", "target": 0, "func": "int main(int argc, char **argv)\n{\n#ifndef DOS_OS2_W32\n    FILE *keybd;\n#endif\n#ifdef sgi\n    FILE *tmpfile;      \n    char tmpline[80];\n#endif\n    char *inname = NULL, outname[256];\n    char *p, pnmchar, pnmline[256];\n    char *bgstr, *textbuf = NULL;\n    ulg rowbytes;\n    int rc, len = 0;\n    int error = 0;\n    int text = FALSE;\n    int maxval;\n    double LUT_exponent;                \n    double CRT_exponent = 2.2;          \n    double default_display_exponent;    \n    double default_gamma = 0.0;\n    wpng_info.infile = NULL;\n    wpng_info.outfile = NULL;\n    wpng_info.image_data = NULL;\n    wpng_info.row_pointers = NULL;\n    wpng_info.filter = FALSE;\n    wpng_info.interlaced = FALSE;\n    wpng_info.have_bg = FALSE;\n    wpng_info.have_time = FALSE;\n    wpng_info.have_text = 0;\n    wpng_info.gamma = 0.0;\n    \n\n\n\n\n\n\n\n#if defined(NeXT)\n    \n    LUT_exponent = 1.0 / 2.2;\n    \n\n\n\n#elif defined(sgi)\n    LUT_exponent = 1.0 / 1.7;\n    \n\n    tmpfile = fopen(\"/etc/config/system.glGammaVal\", \"r\");\n    if (tmpfile) {\n        double sgi_gamma;\n        fgets(tmpline, 80, tmpfile);\n        fclose(tmpfile);\n        sgi_gamma = atof(tmpline);\n        if (sgi_gamma > 0.0)\n            LUT_exponent = 1.0 / sgi_gamma;\n    }\n#elif defined(Macintosh)\n    LUT_exponent = 1.8 / 2.61;\n    \n\n\n\n#else\n    LUT_exponent = 1.0;   \n#endif\n    \n    default_display_exponent = LUT_exponent * CRT_exponent;\n    \n\n\n\n    if ((p = getenv(\"SCREEN_GAMMA\")) != NULL) {\n        double exponent = atof(p);\n        if (exponent > 0.0)\n            default_gamma = 1.0 / exponent;\n    }\n    if (default_gamma == 0.0)\n        default_gamma = 1.0 / default_display_exponent;\n    \n    while (*++argv && !error) {\n        if (!strncmp(*argv, \"-i\", 2)) {\n            wpng_info.interlaced = TRUE;\n        } else if (!strncmp(*argv, \"-time\", 3)) {\n            wpng_info.modtime = time(NULL);\n            wpng_info.have_time = TRUE;\n        } else if (!strncmp(*argv, \"-text\", 3)) {\n            text = TRUE;\n        } else if (!strncmp(*argv, \"-gamma\", 2)) {\n            if (!*++argv)\n                ++error;\n            else {\n                wpng_info.gamma = atof(*argv);\n                if (wpng_info.gamma <= 0.0)\n                    ++error;\n                else if (wpng_info.gamma > 1.01)\n                    fprintf(stderr, PROGNAME\n                      \" warning:  file gammas are usually less than 1.0\\n\");\n            }\n        } else if (!strncmp(*argv, \"-bgcolor\", 4)) {\n            if (!*++argv)\n                ++error;\n            else {\n                bgstr = *argv;\n                if (strlen(bgstr) != 7 || bgstr[0] != '#')\n                    ++error;\n                else {\n                    unsigned r, g, b;  \n                    sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);\n                    wpng_info.bg_red   = (uch)r;\n                    wpng_info.bg_green = (uch)g;\n                    wpng_info.bg_blue  = (uch)b;\n                    wpng_info.have_bg = TRUE;\n                }\n            }\n        } else {\n            if (**argv != '-') {\n                inname = *argv;\n                if (argv[1])   \n                    ++error;\n            } else\n                ++error;   \n        }\n    }\n    \n    if (!inname) {\n        if (isatty(0)) {\n            fprintf(stderr, PROGNAME\n              \":  must give input filename or provide image data via stdin\\n\");\n            ++error;\n        } else {\n#ifdef DOS_OS2_W32\n            \n            setmode(fileno(stdin), O_BINARY);\n            setmode(fileno(stdout), O_BINARY);\n#endif\n            if ((wpng_info.infile = fdopen(fileno(stdin), \"rb\")) == NULL) {\n                fprintf(stderr, PROGNAME\n                  \":  unable to reopen stdin in binary mode\\n\");\n                ++error;\n            } else\n            if ((wpng_info.outfile = fdopen(fileno(stdout), \"wb\")) == NULL) {\n                fprintf(stderr, PROGNAME\n                  \":  unable to reopen stdout in binary mode\\n\");\n                fclose(wpng_info.infile);\n                ++error;\n            } else\n                wpng_info.filter = TRUE;\n        }\n    } else if ((len = strlen(inname)) > 250) {\n        fprintf(stderr, PROGNAME \":  input filename is too long [%d chars]\\n\",\n          len);\n        ++error;\n    } else if (!(wpng_info.infile = fopen(inname, \"rb\"))) {\n        fprintf(stderr, PROGNAME \":  can't open input file [%s]\\n\", inname);\n        ++error;\n    }\n    if (!error) {\n        fgets(pnmline, 256, wpng_info.infile);\n        if (pnmline[0] != 'P' || ((pnmchar = pnmline[1]) != '5' &&\n            pnmchar != '6' && pnmchar != '8'))\n        {\n            fprintf(stderr, PROGNAME\n              \":  input file [%s] is not a binary PGM, PPM or PAM file\\n\",\n              inname);\n            ++error;\n        } else {\n            wpng_info.pnmtype = (int)(pnmchar - '0');\n            if (wpng_info.pnmtype != 8)\n                wpng_info.have_bg = FALSE;  \n            do {\n                fgets(pnmline, 256, wpng_info.infile);  \n            } while (pnmline[0] == '#');\n            sscanf(pnmline, \"%ld %ld\", &wpng_info.width, &wpng_info.height);\n            do {\n                fgets(pnmline, 256, wpng_info.infile);  \n            } while (pnmline[0] == '#');\n            sscanf(pnmline, \"%d\", &maxval);\n            if (wpng_info.width <= 0L || wpng_info.height <= 0L ||\n                maxval != 255)\n            {\n                fprintf(stderr, PROGNAME\n                  \":  only positive width/height, maxval == 255 allowed \\n\");\n                ++error;\n            }\n            wpng_info.sample_depth = 8;  \n            if (!wpng_info.filter) {\n                \n                if ((p = strrchr(inname, '.')) == NULL ||\n                    (p - inname) != (len - 4))\n                {\n                    strcpy(outname, inname);\n                    strcpy(outname+len, \".png\");\n                } else {\n                    len -= 4;\n                    strncpy(outname, inname, len);\n                    strcpy(outname+len, \".png\");\n                }\n                \n                if ((wpng_info.outfile = fopen(outname, \"rb\")) != NULL) {\n                    fprintf(stderr, PROGNAME \":  output file exists [%s]\\n\",\n                      outname);\n                    fclose(wpng_info.outfile);\n                    ++error;\n                } else if (!(wpng_info.outfile = fopen(outname, \"wb\"))) {\n                    fprintf(stderr, PROGNAME \":  can't open output file [%s]\\n\",\n                      outname);\n                    ++error;\n                }\n            }\n        }\n        if (error) {\n            fclose(wpng_info.infile);\n            wpng_info.infile = NULL;\n            if (wpng_info.filter) {\n                fclose(wpng_info.outfile);\n                wpng_info.outfile = NULL;\n            }\n        }\n    }\n    \n    if (error) {\n        fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, APPNAME);\n        writepng_version_info();\n        fprintf(stderr, \"\\n\"\n\"Usage:  %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] pnmfile\\n\"\n\"or: ... | %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] | ...\\n\"\n         \"    exp \\ttransfer-function exponent (``gamma'') of the image in\\n\"\n         \"\\t\\t  floating-point format (e.g., ``%.5f''); if image looks\\n\"\n         \"\\t\\t  correct on given display system, image gamma is equal to\\n\"\n         \"\\t\\t  inverse of display-system exponent, i.e., 1 / (LUT * CRT)\\n\"\n         \"\\t\\t  (where LUT = lookup-table exponent and CRT = CRT exponent;\\n\"\n         \"\\t\\t  first varies, second is usually 2.2, all are positive)\\n\"\n         \"    bg  \\tdesired background color for alpha-channel images, in\\n\"\n         \"\\t\\t  7-character hex RGB format (e.g., ``#ff7700'' for orange:\\n\"\n         \"\\t\\t  same as HTML colors)\\n\"\n         \"    -text\\tprompt interactively for text info (tEXt chunks)\\n\"\n         \"    -time\\tinclude a tIME chunk (last modification time)\\n\"\n         \"    -interlace\\twrite interlaced PNG image\\n\"\n         \"\\n\"\n\"pnmfile or stdin must be a binary PGM (`P5'), PPM (`P6') or (extremely\\n\"\n\"unofficial and unsupported!) PAM (`P8') file.  Currently it is required\\n\"\n\"to have maxval == 255 (i.e., no scaling).  If pnmfile is specified, it\\n\"\n\"is converted to the corresponding PNG file with the same base name but a\\n\"\n\"``.png'' extension; files read from stdin are converted and sent to stdout.\\n\"\n\"The conversion is progressive (low memory usage) unless interlacing is\\n\"\n\"requested; in that case the whole image will be buffered in memory and\\n\"\n\"written in one call.\\n\"\n         \"\\n\", PROGNAME, PROGNAME, default_gamma);\n        exit(1);\n    }\n    \n\n\n    if (text &&\n#ifndef DOS_OS2_W32\n        (keybd = fdopen(fileno(stderr), \"r\")) != NULL &&\n#endif\n        (textbuf = (char *)malloc((5 + 9)*75)) != NULL)\n    {\n        int i, valid, result;\n        fprintf(stderr,\n          \"Enter text info (no more than 72 characters per line);\\n\");\n        fprintf(stderr, \"to skip a field, hit the <Enter> key.\\n\");\n        \n        do {\n            valid = TRUE;\n            p = textbuf + TEXT_TITLE_OFFSET;\n            fprintf(stderr, \"  Title: \");\n            fflush(stderr);\n            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {\n                if (p[len-1] == '\\n')\n                    p[--len] = '\\0';\n                wpng_info.title = p;\n                wpng_info.have_text |= TEXT_TITLE;\n                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {\n                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"\n                      \" %u is %sdiscouraged by the PNG\\n    specification \"\n                      \"[first occurrence was at character position #%d]\\n\",\n                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",\n                      result+1);\n                    fflush(stderr);\n#ifdef FORBID_LATIN1_CTRL\n                    wpng_info.have_text &= ~TEXT_TITLE;\n                    valid = FALSE;\n#else\n                    if (p[result] == 27) {    \n                        wpng_info.have_text &= ~TEXT_TITLE;\n                        valid = FALSE;\n                    }\n#endif\n                }\n            }\n        } while (!valid);\n        do {\n            valid = TRUE;\n            p = textbuf + TEXT_AUTHOR_OFFSET;\n            fprintf(stderr, \"  Author: \");\n            fflush(stderr);\n            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {\n                if (p[len-1] == '\\n')\n                    p[--len] = '\\0';\n                wpng_info.author = p;\n                wpng_info.have_text |= TEXT_AUTHOR;\n                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {\n                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"\n                      \" %u is %sdiscouraged by the PNG\\n    specification \"\n                      \"[first occurrence was at character position #%d]\\n\",\n                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",\n                      result+1);\n                    fflush(stderr);\n#ifdef FORBID_LATIN1_CTRL\n                    wpng_info.have_text &= ~TEXT_AUTHOR;\n                    valid = FALSE;\n#else\n                    if (p[result] == 27) {    \n                        wpng_info.have_text &= ~TEXT_AUTHOR;\n                        valid = FALSE;\n                    }\n#endif\n                }\n            }\n        } while (!valid);\n        do {\n            valid = TRUE;\n            p = textbuf + TEXT_DESC_OFFSET;\n            fprintf(stderr, \"  Description (up to 9 lines):\\n\");\n            for (i = 1;  i < 10;  ++i) {\n                fprintf(stderr, \"    [%d] \", i);\n                fflush(stderr);\n                if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1)\n                    p += len;   \n                else\n                    break;\n            }\n            if ((len = p - (textbuf + TEXT_DESC_OFFSET)) > 1) {\n                if (p[-1] == '\\n') {\n                    p[-1] = '\\0';\n                    --len;\n                }\n                wpng_info.desc = textbuf + TEXT_DESC_OFFSET;\n                wpng_info.have_text |= TEXT_DESC;\n                p = textbuf + TEXT_DESC_OFFSET;\n                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {\n                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"\n                      \" %u is %sdiscouraged by the PNG\\n    specification \"\n                      \"[first occurrence was at character position #%d]\\n\",\n                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",\n                      result+1);\n                    fflush(stderr);\n#ifdef FORBID_LATIN1_CTRL\n                    wpng_info.have_text &= ~TEXT_DESC;\n                    valid = FALSE;\n#else\n                    if (p[result] == 27) {    \n                        wpng_info.have_text &= ~TEXT_DESC;\n                        valid = FALSE;\n                    }\n#endif\n                }\n            }\n        } while (!valid);\n        do {\n            valid = TRUE;\n            p = textbuf + TEXT_COPY_OFFSET;\n            fprintf(stderr, \"  Copyright: \");\n            fflush(stderr);\n            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {\n                if (p[len-1] == '\\n')\n                    p[--len] = '\\0';\n                wpng_info.copyright = p;\n                wpng_info.have_text |= TEXT_COPY;\n                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {\n                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"\n                      \" %u is %sdiscouraged by the PNG\\n    specification \"\n                      \"[first occurrence was at character position #%d]\\n\",\n                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",\n                      result+1);\n                    fflush(stderr);\n#ifdef FORBID_LATIN1_CTRL\n                    wpng_info.have_text &= ~TEXT_COPY;\n                    valid = FALSE;\n#else\n                    if (p[result] == 27) {    \n                        wpng_info.have_text &= ~TEXT_COPY;\n                        valid = FALSE;\n                    }\n#endif\n                }\n            }\n        } while (!valid);\n        do {\n            valid = TRUE;\n            p = textbuf + TEXT_EMAIL_OFFSET;\n            fprintf(stderr, \"  E-mail: \");\n            fflush(stderr);\n            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {\n                if (p[len-1] == '\\n')\n                    p[--len] = '\\0';\n                wpng_info.email = p;\n                wpng_info.have_text |= TEXT_EMAIL;\n                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {\n                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"\n                      \" %u is %sdiscouraged by the PNG\\n    specification \"\n                      \"[first occurrence was at character position #%d]\\n\",\n                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",\n                      result+1);\n                    fflush(stderr);\n#ifdef FORBID_LATIN1_CTRL\n                    wpng_info.have_text &= ~TEXT_EMAIL;\n                    valid = FALSE;\n#else\n                    if (p[result] == 27) {    \n                        wpng_info.have_text &= ~TEXT_EMAIL;\n                        valid = FALSE;\n                    }\n#endif\n                }\n            }\n        } while (!valid);\n        do {\n            valid = TRUE;\n            p = textbuf + TEXT_URL_OFFSET;\n            fprintf(stderr, \"  URL: \");\n            fflush(stderr);\n            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {\n                if (p[len-1] == '\\n')\n                    p[--len] = '\\0';\n                wpng_info.url = p;\n                wpng_info.have_text |= TEXT_URL;\n                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {\n                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"\n                      \" %u is %sdiscouraged by the PNG\\n    specification \"\n                      \"[first occurrence was at character position #%d]\\n\",\n                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",\n                      result+1);\n                    fflush(stderr);\n#ifdef FORBID_LATIN1_CTRL\n                    wpng_info.have_text &= ~TEXT_URL;\n                    valid = FALSE;\n#else\n                    if (p[result] == 27) {    \n                        wpng_info.have_text &= ~TEXT_URL;\n                        valid = FALSE;\n                    }\n#endif\n                }\n            }\n        } while (!valid);\n#ifndef DOS_OS2_W32\n        fclose(keybd);\n#endif\n    } else if (text) {\n        fprintf(stderr, PROGNAME \":  unable to allocate memory for text\\n\");\n        text = FALSE;\n        wpng_info.have_text = 0;\n    }\n    \n    if ((rc = writepng_init(&wpng_info)) != 0) {\n        switch (rc) {\n            case 2:\n                fprintf(stderr, PROGNAME\n                  \":  libpng initialization problem (longjmp)\\n\");\n                break;\n            case 4:\n                fprintf(stderr, PROGNAME \":  insufficient memory\\n\");\n                break;\n            case 11:\n                fprintf(stderr, PROGNAME\n                  \":  internal logic error (unexpected PNM type)\\n\");\n                break;\n            default:\n                fprintf(stderr, PROGNAME\n                  \":  unknown writepng_init() error\\n\");\n                break;\n        }\n        exit(rc);\n    }\n    \n\n    if (text && textbuf) {\n        free(textbuf);\n        textbuf = NULL;\n    }\n    \n\n\n    if (wpng_info.pnmtype == 5)\n        rowbytes = wpng_info.width;\n    else if (wpng_info.pnmtype == 6)\n        rowbytes = wpng_info.width * 3;\n    else \n        rowbytes = wpng_info.width * 4;\n    \n\n    fprintf(stderr, \"Encoding image data...\\n\");\n    fflush(stderr);\n    if (wpng_info.interlaced) {\n        long i;\n        ulg bytes;\n        ulg image_bytes = rowbytes * wpng_info.height;   \n        wpng_info.image_data = (uch *)malloc(image_bytes);\n        wpng_info.row_pointers = (uch **)malloc(wpng_info.height*sizeof(uch *));\n        if (wpng_info.image_data == NULL || wpng_info.row_pointers == NULL) {\n            fprintf(stderr, PROGNAME \":  insufficient memory for image data\\n\");\n            writepng_cleanup(&wpng_info);\n            wpng_cleanup();\n            exit(5);\n        }\n        for (i = 0;  i < wpng_info.height;  ++i)\n            wpng_info.row_pointers[i] = wpng_info.image_data + i*rowbytes;\n        bytes = fread(wpng_info.image_data, 1, image_bytes, wpng_info.infile);\n        if (bytes != image_bytes) {\n            fprintf(stderr, PROGNAME \":  expected %lu bytes, got %lu bytes\\n\",\n              image_bytes, bytes);\n            fprintf(stderr, \"  (continuing anyway)\\n\");\n        }\n        if (writepng_encode_image(&wpng_info) != 0) {\n            fprintf(stderr, PROGNAME\n              \":  libpng problem (longjmp) while writing image data\\n\");\n            writepng_cleanup(&wpng_info);\n            wpng_cleanup();\n            exit(2);\n        }\n    } else  {\n        long j;\n        ulg bytes;\n        wpng_info.image_data = (uch *)malloc(rowbytes);\n        if (wpng_info.image_data == NULL) {\n            fprintf(stderr, PROGNAME \":  insufficient memory for row data\\n\");\n            writepng_cleanup(&wpng_info);\n            wpng_cleanup();\n            exit(5);\n        }\n        error = 0;\n        for (j = wpng_info.height;  j > 0L;  --j) {\n            bytes = fread(wpng_info.image_data, 1, rowbytes, wpng_info.infile);\n            if (bytes != rowbytes) {\n                fprintf(stderr, PROGNAME\n                  \":  expected %lu bytes, got %lu bytes (row %ld)\\n\", rowbytes,\n                  bytes, wpng_info.height-j);\n                ++error;\n                break;\n            }\n            if (writepng_encode_row(&wpng_info) != 0) {\n                fprintf(stderr, PROGNAME\n                  \":  libpng problem (longjmp) while writing row %ld\\n\",\n                  wpng_info.height-j);\n                ++error;\n                break;\n            }\n        }\n        if (error) {\n            writepng_cleanup(&wpng_info);\n            wpng_cleanup();\n            exit(2);\n        }\n        if (writepng_encode_finish(&wpng_info) != 0) {\n            fprintf(stderr, PROGNAME \":  error on final libpng call\\n\");\n            writepng_cleanup(&wpng_info);\n            wpng_cleanup();\n            exit(2);\n        }\n    }\n    \n    fprintf(stderr, \"Done.\\n\");\n    fflush(stderr);\n    writepng_cleanup(&wpng_info);\n    wpng_cleanup();\n    return 0;\n}\n", "bug_type": null, "idx": 91}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_delete(png_store *ps)\n{\n   store_write_reset(ps);\n   store_read_reset(ps);\n   store_freefile(&ps->saved);\n   store_image_free(ps, NULL);\n}\n", "bug_type": null, "idx": 92}
{"project": "LibPNG", "target": 0, "func": "static void\nclean_display(display *d)\n{\n   png_destroy_read_struct(&d->png_ptr, &d->info_ptr, &d->end_ptr);\n   \n   if (d->png_ptr != NULL || d->info_ptr != NULL || d->end_ptr != NULL)\n   {\n      fprintf(stderr, \"%s(%s): png_destroy_read_struct error\\n\", d->file,\n         d->test);\n      exit(1);\n   }\n}\n", "bug_type": null, "idx": 93}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nmodifier_read(png_structp ppIn, png_bytep pb, png_size_t st)\n{\n   png_const_structp pp = ppIn;\n   png_modifier *pm = voidcast(png_modifier*, png_get_io_ptr(pp));\n   if (pm == NULL || pm->this.pread != pp)\n      png_error(pp, \"bad modifier_read call\");\n   modifier_read_imp(pm, pb, st);\n}\n", "bug_type": null, "idx": 94}
{"project": "LibPNG", "target": 0, "func": "static void\nuarb_printx(uarb num, int digits, FILE *out)\n   \n{\n   while (digits > 0)\n      if (num[--digits] > 0)\n      {\n         fprintf(out, \"0x%x\", num[digits]);\n         while (digits > 0)\n            fprintf(out, \"%.4x\", num[--digits]);\n      }\n      else if (digits == 0) \n         fputs(\"0x0\", out);\n}\n", "bug_type": null, "idx": 95}
