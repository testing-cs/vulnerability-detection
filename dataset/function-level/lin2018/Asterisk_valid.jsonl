{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_mailbox(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_name = 0;\n\tint has_new_messages = 0;\n\tint has_old_messages = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"name\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_name = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Mailbox field name failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"new_messages\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_new_messages = 1;\n\t\t\tprop_is_valid = ast_ari_validate_int(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Mailbox field new_messages failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"old_messages\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_old_messages = 1;\n\t\t\tprop_is_valid = ast_ari_validate_int(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Mailbox field old_messages failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI Mailbox has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_name) {\n\t\tast_log(LOG_ERROR, \"ARI Mailbox missing required field name\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_new_messages) {\n\t\tast_log(LOG_ERROR, \"ARI Mailbox missing required field new_messages\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_old_messages) {\n\t\tast_log(LOG_ERROR, \"ARI Mailbox missing required field old_messages\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 0}
{"project": "Asterisk", "target": 0, "func": "struct ast_uuid *ast_uuid_copy(const struct ast_uuid *src)\n{\n\tstruct ast_uuid *dst = ast_malloc(sizeof(*dst));\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tuuid_copy(dst->uu, src->uu);\n\treturn dst;\n}\n", "bug_type": null, "idx": 1}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int check_header(struct ast_filestream *fs)\n{\n\tAU_HEADER(header);\n\tuint32_t magic;\n\tuint32_t hdr_size;\n\tuint32_t data_size;\n\tuint32_t encoding;\n\tuint32_t sample_rate;\n\tuint32_t channels;\n\tstruct au_desc *desc = fs->_private;\n\tFILE *f = fs->f;\n\tif (fread(header, 1, MIN_AU_HEADER_SIZE, f) != MIN_AU_HEADER_SIZE) {\n\t\tast_log(LOG_WARNING, \"Read failed (header)\\n\");\n\t\treturn -1;\n\t}\n\tmagic = ltohl(header[AU_HDR_MAGIC_OFF]);\n\tif (magic != (uint32_t) AU_MAGIC) {\n\t\tast_log(LOG_WARNING, \"Bad magic: 0x%x\\n\", magic);\n\t}\n\thdr_size = ltohl(header[AU_HDR_HDR_SIZE_OFF]);\n\tif (hdr_size < MIN_AU_HEADER_SIZE) {\n\t\thdr_size = MIN_AU_HEADER_SIZE;\n\t}\n\n\tencoding = ltohl(header[AU_HDR_ENCODING_OFF]);\n\tif (encoding != AU_ENC_8BIT_ULAW) {\n\t\tast_log(LOG_WARNING, \"Unexpected format: %u. Only 8bit ULAW allowed (%d)\\n\", encoding, AU_ENC_8BIT_ULAW);\n\t\treturn -1;\n\t}\n\tsample_rate = ltohl(header[AU_HDR_SAMPLE_RATE_OFF]);\n\tif (sample_rate != DEFAULT_SAMPLE_RATE) {\n\t\tast_log(LOG_WARNING, \"Sample rate can only be 8000 not %u\\n\", sample_rate);\n\t\treturn -1;\n\t}\n\tchannels = ltohl(header[AU_HDR_CHANNELS_OFF]);\n\tif (channels != 1) {\n\t\tast_log(LOG_WARNING, \"Not in mono: channels=%u\\n\", channels);\n\t\treturn -1;\n\t}\n\t\n\tfseek(f, 0, SEEK_END);\n\tdata_size = ftell(f) - hdr_size;\n\tif (fseek(f, hdr_size, SEEK_SET) == -1 ) {\n\t\tast_log(LOG_WARNING, \"Failed to skip to data: %u\\n\", hdr_size);\n\t\treturn -1;\n\t}\n\t\n\tdesc->hdr_size = hdr_size;\n\treturn data_size;\n}\n", "bug_type": null, "idx": 2}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *sorcery_memory_cache_show(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct sorcery_memory_cache *cache;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"sorcery memory cache show\";\n\t\te->usage =\n\t\t    \"Usage: sorcery memory cache show <name>\\n\"\n\t\t    \"       Show sorcery memory cache configuration and statistics.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tif (a->pos == 4) {\n\t\t\treturn sorcery_memory_cache_complete_name(a->word, a->n);\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (a->argc != 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tcache = ao2_find(caches, a->argv[4], OBJ_SEARCH_KEY);\n\tif (!cache) {\n\t\tast_cli(a->fd, \"Specified sorcery memory cache '%s' does not exist\\n\", a->argv[4]);\n\t\treturn CLI_FAILURE;\n\t}\n\tast_cli(a->fd, \"Sorcery memory cache: %s\\n\", cache->name);\n\tast_cli(a->fd, \"Number of objects within cache: %d\\n\", ao2_container_count(cache->objects));\n\tif (cache->maximum_objects) {\n\t\tast_cli(a->fd, \"Maximum allowed objects: %d\\n\", cache->maximum_objects);\n\t} else {\n\t\tast_cli(a->fd, \"There is no limit on the maximum number of objects in the cache\\n\");\n\t}\n\tif (cache->object_lifetime_maximum) {\n\t\tast_cli(a->fd, \"Number of seconds before object expires: %d\\n\", cache->object_lifetime_maximum);\n\t} else {\n\t\tast_cli(a->fd, \"Object expiration is not enabled - cached objects will not expire\\n\");\n\t}\n\tif (cache->object_lifetime_stale) {\n\t\tast_cli(a->fd, \"Number of seconds before object becomes stale: %d\\n\", cache->object_lifetime_stale);\n\t} else {\n\t\tast_cli(a->fd, \"Object staleness is not enabled - cached objects will not go stale\\n\");\n\t}\n\tast_cli(a->fd, \"Expire all objects on reload: %s\\n\", AST_CLI_ONOFF(cache->expire_on_reload));\n\tao2_ref(cache, -1);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 3}
{"project": "Asterisk", "target": 0, "func": " */\nstatic pj_bool_t idle_monitor_on_rx_request(pjsip_rx_data *rdata)\n{\n\tstruct ao2_container *transports;\n\tstruct monitored_transport *idle_trans;\n\ttransports = ao2_global_obj_ref(monitored_transports);\n\tif (!transports) {\n\t\treturn PJ_FALSE;\n\t}\n\tidle_trans = ao2_find(transports, rdata->tp_info.transport->obj_name, OBJ_SEARCH_KEY);\n\tao2_ref(transports, -1);\n\tif (!idle_trans) {\n\t\treturn PJ_FALSE;\n\t}\n\tidle_trans->sip_received = 1;\n\tao2_ref(idle_trans, -1);\n\treturn PJ_FALSE;\n}\n", "bug_type": null, "idx": 4}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_variable *test_sorcery_transform(struct ast_variable *set)\n{\n\tstruct ast_variable *field, *transformed = NULL;\n\tfor (field = set; field; field = field->next) {\n\t\tstruct ast_variable *transformed_field;\n\t\tif (!strcmp(field->name, \"joe\")) {\n\t\t\ttransformed_field = ast_variable_new(field->name, \"5000\", \"\");\n\t\t} else {\n\t\t\ttransformed_field = ast_variable_new(field->name, field->value, \"\");\n\t\t}\n\t\tif (!transformed_field) {\n\t\t\tast_variables_destroy(transformed);\n\t\t\treturn NULL;\n\t\t}\n\t\ttransformed_field->next = transformed;\n\t\ttransformed = transformed_field;\n\t}\n\treturn transformed;\n}\n", "bug_type": null, "idx": 5}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245EncryptionCapability (OOCTXT* pctxt, H245EncryptionCapability* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };\n   int stat = ASN_OK;\n   H245MediaEncryptionAlgorithm* pdata;\n   ASN1UINT count = 0;\n   ASN1UINT xx1;\n   \n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeLength (pctxt, &count);\n   if (stat != ASN_OK) return stat;\n   \n   dListInit (pvalue);\n   for (xx1 = 0; xx1 < count; xx1++) {\n      invokeStartElement (pctxt, \"elem\", xx1);\n      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MediaEncryptionAlgorithm);\n      stat = asn1PD_H245MediaEncryptionAlgorithm (pctxt, pdata);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"elem\", xx1);\n      dListAppendNode (pctxt, pvalue, pdata);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 6}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_frame *audio_audiohook_write_list(struct ast_channel *chan, struct ast_audiohook_list *audiohook_list, enum ast_audiohook_direction direction, struct ast_frame *frame)\n{\n\tstruct ast_frame *start_frame = frame, *middle_frame = frame, *end_frame = frame;\n\tstruct ast_audiohook *audiohook = NULL;\n\tint samples;\n\tint middle_frame_manipulated = 0;\n\tint removed = 0;\n\tint internal_sample_rate;\n\t\n\tif (!(middle_frame = audiohook_list_translate_to_slin(audiohook_list, direction, start_frame))) {\n\t\treturn frame;\n\t}\n\t\n\tif (!middle_frame->data.ptr) {\n\t\tast_frfree(middle_frame);\n\t\treturn start_frame;\n\t}\n\tsamples = middle_frame->samples;\n\t\n\tinternal_sample_rate = audiohook_list->list_internal_samp_rate;\n\t\n\t\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&audiohook_list->spy_list, audiohook, list) {\n\t\tast_audiohook_lock(audiohook);\n\t\tif (audiohook->status != AST_AUDIOHOOK_STATUS_RUNNING) {\n\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\tremoved = 1;\n\t\t\tast_audiohook_update_status(audiohook, AST_AUDIOHOOK_STATUS_DONE);\n\t\t\tast_audiohook_unlock(audiohook);\n\t\t\tif (ast_channel_is_bridged(chan)) {\n\t\t\t\tast_channel_set_unbridged_nolock(chan, 1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\taudiohook_list_set_hook_rate(audiohook_list, audiohook, &internal_sample_rate);\n\t\tast_audiohook_write_frame(audiohook, direction, middle_frame);\n\t\tast_audiohook_unlock(audiohook);\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\t\n\tif (!AST_LIST_EMPTY(&audiohook_list->whisper_list)) {\n\t\tint i = 0;\n\t\tshort read_buf[samples], combine_buf[samples], *data1 = NULL, *data2 = NULL;\n\t\tmemset(&combine_buf, 0, sizeof(combine_buf));\n\t\tAST_LIST_TRAVERSE_SAFE_BEGIN(&audiohook_list->whisper_list, audiohook, list) {\n\t\t\tstruct ast_slinfactory *factory = (direction == AST_AUDIOHOOK_DIRECTION_READ ? &audiohook->read_factory : &audiohook->write_factory);\n\t\t\tast_audiohook_lock(audiohook);\n\t\t\tif (audiohook->status != AST_AUDIOHOOK_STATUS_RUNNING) {\n\t\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\t\tremoved = 1;\n\t\t\t\tast_audiohook_update_status(audiohook, AST_AUDIOHOOK_STATUS_DONE);\n\t\t\t\tast_audiohook_unlock(audiohook);\n\t\t\t\tif (ast_channel_is_bridged(chan)) {\n\t\t\t\t\tast_channel_set_unbridged_nolock(chan, 1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taudiohook_list_set_hook_rate(audiohook_list, audiohook, &internal_sample_rate);\n\t\t\tif (ast_slinfactory_available(factory) >= samples && ast_slinfactory_read(factory, read_buf, samples)) {\n\t\t\t\t\n\t\t\t\tfor (i = 0, data1 = combine_buf, data2 = read_buf; i < samples; i++, data1++, data2++) {\n\t\t\t\t\tast_slinear_saturated_add(data1, data2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_audiohook_unlock(audiohook);\n\t\t}\n\t\tAST_LIST_TRAVERSE_SAFE_END;\n\t\t\n\t\tfor (i = 0, data1 = middle_frame->data.ptr, data2 = combine_buf; i < samples; i++, data1++, data2++) {\n\t\t\tast_slinear_saturated_add(data1, data2);\n\t\t}\n\t\tmiddle_frame_manipulated = 1;\n\t}\n\t\n\tif (!AST_LIST_EMPTY(&audiohook_list->manipulate_list)) {\n\t\tAST_LIST_TRAVERSE_SAFE_BEGIN(&audiohook_list->manipulate_list, audiohook, list) {\n\t\t\tast_audiohook_lock(audiohook);\n\t\t\tif (audiohook->status != AST_AUDIOHOOK_STATUS_RUNNING) {\n\t\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\t\tremoved = 1;\n\t\t\t\tast_audiohook_update_status(audiohook, AST_AUDIOHOOK_STATUS_DONE);\n\t\t\t\tast_audiohook_unlock(audiohook);\n\t\t\t\t\n\t\t\t\taudiohook->manipulate_callback(audiohook, chan, NULL, direction);\n\t\t\t\tif (ast_channel_is_bridged(chan)) {\n\t\t\t\t\tast_channel_set_unbridged_nolock(chan, 1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taudiohook_list_set_hook_rate(audiohook_list, audiohook, &internal_sample_rate);\n\t\t\t\n\t\t\tif (!audiohook->manipulate_callback(audiohook, chan, middle_frame, direction)) {\n\t\t\t\t\n\t\t\t\tmiddle_frame_manipulated = 1;\n\t\t\t}\n\t\t\tast_audiohook_unlock(audiohook);\n\t\t}\n\t\tAST_LIST_TRAVERSE_SAFE_END;\n\t}\n\t\n\tif (middle_frame_manipulated) {\n\t\tif (!(end_frame = audiohook_list_translate_to_native(audiohook_list, direction, middle_frame, start_frame->subclass.format))) {\n\t\t\t\n\t\t\tend_frame = start_frame;\n\t\t}\n\t} else {\n\t\tend_frame = start_frame;\n\t}\n\t\n\tif (middle_frame != end_frame) {\n\t\tast_frfree(middle_frame);\n\t\tmiddle_frame = NULL;\n\t}\n\t\n\tif (removed) {\n\t\taudiohook_list_set_samplerate_compatibility(audiohook_list);\n\t} else {\n\t\t\n\t\taudiohook_list->list_internal_samp_rate = internal_sample_rate;\n\t}\n\treturn end_frame;\n}\n", "bug_type": null, "idx": 7}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int write_escalates(const struct ast_custom_function *acf) {\n\treturn acf->write_escalates;\n}\n", "bug_type": null, "idx": 8}
{"project": "Asterisk", "target": 0, "func": "static void *pri_dchannel(void *vpri)\n{\n\tstruct sig_pri_span *pri = vpri;\n\tpri_event *e;\n\tstruct pollfd fds[SIG_PRI_NUM_DCHANS];\n\tint res;\n\tint x;\n\tstruct timeval tv, lowest, *next;\n\tint doidling=0;\n\tchar *cc;\n\ttime_t t;\n\tint i, which=-1;\n\tint numdchans;\n\tstruct timeval lastidle = { 0, 0 };\n\tpthread_t p;\n\tstruct ast_channel *idle;\n\tchar idlen[128];\n\tint nextidle = -1;\n\tint haveidles;\n\tint activeidles;\n\tunsigned int len;\n\tgettimeofday(&lastidle, NULL);\n\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n\tif (!ast_strlen_zero(pri->idledial) && !ast_strlen_zero(pri->idleext)) {\n\t\t\n\t\tcc = strchr(pri->idleext, '@');\n\t\tif (cc) {\n\t\t\t*cc = '\\0';\n\t\t\tcc++;\n\t\t\tast_copy_string(pri->idlecontext, cc, sizeof(pri->idlecontext));\n#if 0\n\t\t\t\n\t\t\tif (!ast_exists_extension(NULL, pri->idlecontext, pri->idleext, 1, NULL))\n\t\t\t\tast_log(LOG_WARNING, \"Extension '%s @ %s' does not exist\\n\", pri->idleext, pri->idlecontext);\n\t\t\telse\n#endif\n\t\t\t\tdoidling = 1;\n\t\t} else\n\t\t\tast_log(LOG_WARNING, \"Idle dial string '%s' lacks '@context'\\n\", pri->idleext);\n\t}\n\tfor (;;) {\n\t\tast_callid callid = 0;\n\t\tfor (i = 0; i < SIG_PRI_NUM_DCHANS; i++) {\n\t\t\tif (!pri->dchans[i])\n\t\t\t\tbreak;\n\t\t\tfds[i].fd = pri->fds[i];\n\t\t\tfds[i].events = POLLIN | POLLPRI;\n\t\t\tfds[i].revents = 0;\n\t\t}\n\t\tnumdchans = i;\n\t\ttime(&t);\n\t\tast_mutex_lock(&pri->lock);\n\t\tif (pri->switchtype != PRI_SWITCH_GR303_TMC && (pri->sig != SIG_BRI_PTMP) && (pri->resetinterval > 0)) {\n\t\t\tif (pri->resetting && pri_is_up(pri)) {\n\t\t\t\tif (pri->resetpos < 0) {\n\t\t\t\t\tpri_check_restart(pri);\n\t\t\t\t\tif (pri->resetting) {\n\t\t\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!pri->resetting\t&& (t - pri->lastreset) >= pri->resetinterval) {\n\t\t\t\t\tpri->resetting = 1;\n\t\t\t\t\tpri->resetpos = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (doidling && pri_is_up(pri)) {\n\t\t\tnextidle = -1;\n\t\t\thaveidles = 0;\n\t\t\tactiveidles = 0;\n\t\t\tfor (x = pri->numchans; x >= 0; x--) {\n\t\t\t\tif (pri->pvts[x] && !pri->pvts[x]->no_b_channel) {\n\t\t\t\t\tif (sig_pri_is_chan_available(pri->pvts[x])) {\n\t\t\t\t\t\tif (haveidles < pri->minunused) {\n\t\t\t\t\t\t\thaveidles++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnextidle = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (pri->pvts[x]->owner && pri->pvts[x]->isidlecall) {\n\t\t\t\t\t\tactiveidles++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextidle > -1) {\n\t\t\t\tif (ast_tvdiff_ms(ast_tvnow(), lastidle) > 1000) {\n\t\t\t\t\t\n\t\t\t\t\tsnprintf(idlen, sizeof(idlen), \"%d/%s\", pri->pvts[nextidle]->channel, pri->idledial);\n\t\t\t\t\tpri->pvts[nextidle]->allocated = 1;\n\t\t\t\t\t\n\t\t\t\t\tast_mutex_unlock(&pri->lock);\n\t\t\t\t\t\n\t\t\t\t\tsig_pri_lock_private(pri->pvts[nextidle]);\n\t\t\t\t\tsig_pri_unlock_private(pri->pvts[nextidle]);\n\t\t\t\t\tidle = sig_pri_request(pri->pvts[nextidle], SIG_PRI_ULAW, NULL, NULL, 0);\n\t\t\t\t\tast_mutex_lock(&pri->lock);\n\t\t\t\t\tif (idle) {\n\t\t\t\t\t\tpri->pvts[nextidle]->isidlecall = 1;\n\t\t\t\t\t\tif (ast_pthread_create_background(&p, NULL, do_idle_thread, pri->pvts[nextidle])) {\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Unable to start new thread for idle channel '%s'\\n\", ast_channel_name(idle));\n\t\t\t\t\t\t\tast_mutex_unlock(&pri->lock);\n\t\t\t\t\t\t\tast_hangup(idle);\n\t\t\t\t\t\t\tast_mutex_lock(&pri->lock);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpri->pvts[nextidle]->allocated = 0;\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Unable to request channel 'DAHDI/%s' for idle call\\n\", idlen);\n\t\t\t\t\t}\n\t\t\t\t\tgettimeofday(&lastidle, NULL);\n\t\t\t\t}\n\t\t\t} else if ((haveidles < pri->minunused) &&\n\t\t\t\t(activeidles > pri->minidle)) {\n\t\t\t\t\n\t\t\t\tfor (x = pri->numchans; x >= 0; x--) {\n\t\t\t\t\t\n\t\t\t\t\tif (pri->pvts[x] && pri->pvts[x]->owner && pri->pvts[x]->isidlecall) {\n\t\t\t\t\t\tast_channel_softhangup_internal_flag_add(pri->pvts[x]->owner, AST_SOFTHANGUP_DEV);\n\t\t\t\t\t\thaveidles++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((haveidles >= pri->minunused) ||\n\t\t\t\t\t\t\t(activeidles <= pri->minidle))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (doidling || pri->resetting) {\n\t\t\t\n\t\t\tlowest = ast_tv(1, 0);\n\t\t} else {\n\t\t\t\n\t\t\tlowest = ast_tv(60, 0);\n\t\t}\n\t\tfor (i = 0; i < SIG_PRI_NUM_DCHANS; i++) {\n\t\t\tif (!pri->dchans[i]) {\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext = pri_schedule_next(pri->dchans[i]);\n\t\t\tif (next) {\n\t\t\t\t\n\t\t\t\ttv = ast_tvsub(*next, ast_tvnow());\n\t\t\t\tif (tv.tv_sec < 0) {\n\t\t\t\t\t\n\t\t\t\t\tlowest = ast_tv(0, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ast_tvcmp(tv, lowest) < 0) {\n\t\t\t\t\tlowest = tv;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&pri->lock);\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n\t\tpthread_testcancel();\n\t\te = NULL;\n\t\tres = poll(fds, numdchans, lowest.tv_sec * 1000 + lowest.tv_usec / 1000);\n\t\tpthread_testcancel();\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n\t\tast_mutex_lock(&pri->lock);\n\t\tif (!res) {\n\t\t\tfor (which = 0; which < SIG_PRI_NUM_DCHANS; which++) {\n\t\t\t\tif (!pri->dchans[which])\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\te = pri_schedule_run(pri->dchans[which]);\n\t\t\t\tif (e)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (res > -1) {\n\t\t\tfor (which = 0; which < SIG_PRI_NUM_DCHANS; which++) {\n\t\t\t\tif (!pri->dchans[which])\n\t\t\t\t\tbreak;\n\t\t\t\tif (fds[which].revents & POLLPRI) {\n\t\t\t\t\tsig_pri_handle_dchan_exception(pri, which);\n\t\t\t\t} else if (fds[which].revents & POLLIN) {\n\t\t\t\t\te = pri_check_event(pri->dchans[which]);\n\t\t\t\t}\n\t\t\t\tif (e)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((errno != 0) && (errno != EINTR)) {\n\t\t\t\t\tast_log(LOG_NOTICE, \"pri_check_event returned error %d (%s)\\n\",\n\t\t\t\t\t\terrno, strerror(errno));\n\t\t\t\t}\n\t\t\t\tif (errno == ENODEV) {\n\t\t\t\t\tpri_destroy_later(pri);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (errno != EINTR)\n\t\t\tast_log(LOG_WARNING, \"pri_event returned error %d (%s)\\n\", errno, strerror(errno));\n\t\tif (e) {\n\t\t\tint chanpos = -1;\n\t\t\tchar cause_str[35];\n\t\t\tif (pri->debug) {\n\t\t\t\tast_verbose(\"Span %d: Processing event %s(%d)\\n\",\n\t\t\t\t\tpri->span, pri_event2str(e->e), e->e);\n\t\t\t}\n\t\t\tif (e->e != PRI_EVENT_DCHAN_DOWN) {\n\t\t\t\tif (!(pri->dchanavail[which] & DCHAN_UP)) {\n\t\t\t\t\tast_verb(2, \"%s D-Channel on span %d up\\n\", pri_order(which), pri->span);\n\t\t\t\t}\n\t\t\t\tpri->dchanavail[which] |= DCHAN_UP;\n\t\t\t} else {\n\t\t\t\tif (pri->dchanavail[which] & DCHAN_UP) {\n\t\t\t\t\tast_verb(2, \"%s D-Channel on span %d down\\n\", pri_order(which), pri->span);\n\t\t\t\t}\n\t\t\t\tpri->dchanavail[which] &= ~DCHAN_UP;\n\t\t\t}\n\t\t\tif ((e->e != PRI_EVENT_DCHAN_UP) && (e->e != PRI_EVENT_DCHAN_DOWN) && (pri->pri != pri->dchans[which]))\n\t\t\t\t\n\t\t\t\tpri->pri = pri->dchans[which];\n\t\t\tswitch (e->e) {\n\t\t\tcase PRI_EVENT_DCHAN_UP:\n\t\t\t\tpri->no_d_channels = 0;\n\t\t\t\tif (!pri->pri) {\n\t\t\t\t\tpri_find_dchan(pri);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttime(&pri->lastreset);\n\t\t\t\t\n\t\t\t\tif (pri->resetinterval > -1) {\n\t\t\t\t\tpri->lastreset -= pri->resetinterval;\n\t\t\t\t\tpri->lastreset += 5;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpri->resetting = 0;\n\t\t\t\tfor (i = 0; i < pri->numchans; i++) {\n\t\t\t\t\tif (pri->pvts[i]) {\n\t\t\t\t\t\tsig_pri_set_alarm(pri->pvts[i], 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_DCHAN_DOWN:\n\t\t\t\tpri_find_dchan(pri);\n\t\t\t\tif (!pri_is_up(pri)) {\n\t\t\t\t\tif (pri->sig == SIG_BRI_PTMP) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpri->resetting = 0;\n\t\t\t\t\tfor (i = 0; i < pri->numchans; i++) {\n\t\t\t\t\t\tstruct sig_pri_chan *p = pri->pvts[i];\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\tif (pri_get_timer(p->pri->pri, PRI_TIMER_T309) < 0) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (p->call) {\n\t\t\t\t\t\t\t\t\tpri_destroycall(p->pri->pri, p->call);\n\t\t\t\t\t\t\t\t\tp->call = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (p->owner)\n\t\t\t\t\t\t\t\t\tast_channel_softhangup_internal_flag_add(p->owner, AST_SOFTHANGUP_DEV);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsig_pri_set_alarm(p, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_RESTART:\n\t\t\t\tif (e->restart.channel > -1 && PRI_CHANNEL(e->restart.channel) != 0xFF) {\n\t\t\t\t\tchanpos = pri_find_principle(pri, e->restart.channel, NULL);\n\t\t\t\t\tif (chanpos < 0)\n\t\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"Span %d: Restart requested on odd/unavailable channel number %d/%d\\n\",\n\t\t\t\t\t\t\tpri->span, PRI_SPAN(e->restart.channel),\n\t\t\t\t\t\t\tPRI_CHANNEL(e->restart.channel));\n\t\t\t\t\telse {\n\t\t\t\t\t\tint skipit = 0;\n#if defined(HAVE_PRI_SERVICE_MESSAGES)\n\t\t\t\t\t\tunsigned why;\n\t\t\t\t\t\twhy = pri->pvts[chanpos]->service_status;\n\t\t\t\t\t\tif (why) {\n\t\t\t\t\t\t\tast_log(LOG_NOTICE,\n\t\t\t\t\t\t\t\t\"Span %d: Channel %d/%d out-of-service (reason: %s), ignoring RESTART\\n\",\n\t\t\t\t\t\t\t\tpri->span, PRI_SPAN(e->restart.channel),\n\t\t\t\t\t\t\t\tPRI_CHANNEL(e->restart.channel),\n\t\t\t\t\t\t\t\t(why & SRVST_FAREND) ? (why & SRVST_NEAREND) ? \"both ends\" : \"far end\" : \"near end\");\n\t\t\t\t\t\t\tskipit = 1;\n\t\t\t\t\t\t}\n#endif\t\n\t\t\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\t\t\tif (!skipit) {\n\t\t\t\t\t\t\tast_verb(3, \"Span %d: Channel %d/%d restarted\\n\", pri->span,\n\t\t\t\t\t\t\t\tPRI_SPAN(e->restart.channel),\n\t\t\t\t\t\t\t\tPRI_CHANNEL(e->restart.channel));\n\t\t\t\t\t\t\tif (pri->pvts[chanpos]->call) {\n\t\t\t\t\t\t\t\tpri_destroycall(pri->pri, pri->pvts[chanpos]->call);\n\t\t\t\t\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tsig_pri_queue_hangup(pri, chanpos);\n\t\t\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tast_verb(3, \"Restart requested on entire span %d\\n\", pri->span);\n\t\t\t\t\tfor (x = 0; x < pri->numchans; x++)\n\t\t\t\t\t\tif (pri->pvts[x]) {\n\t\t\t\t\t\t\tsig_pri_lock_private(pri->pvts[x]);\n\t\t\t\t\t\t\tif (pri->pvts[x]->call) {\n\t\t\t\t\t\t\t\tpri_destroycall(pri->pri, pri->pvts[x]->call);\n\t\t\t\t\t\t\t\tpri->pvts[x]->call = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tsig_pri_queue_hangup(pri, x);\n\t\t\t\t\t\t\tsig_pri_unlock_private(pri->pvts[x]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_KEYPAD_DIGIT:\n\t\t\t\tif (sig_pri_is_cis_call(e->digit.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->digit.subcmds,\n\t\t\t\t\t\te->digit.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_principle_by_call(pri, e->digit.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\"Span %d: Received keypad digits for unknown call.\\n\", pri->span);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->digit.subcmds,\n\t\t\t\t\te->digit.call);\n\t\t\t\t\n\t\t\t\tif ((pri->overlapdial & DAHDI_OVERLAPDIAL_INCOMING)\n\t\t\t\t\t&& pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\n\t\t\t\t\tint digitlen = strlen(e->digit.digits);\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = 0; i < digitlen; i++) {\n\t\t\t\t\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = e->digit.digits[i], };\n\t\t\t\t\t\tpri_queue_frame(pri, chanpos, &f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_INFO_RECEIVED:\n\t\t\t\tif (sig_pri_is_cis_call(e->ring.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->ring.subcmds,\n\t\t\t\t\t\te->ring.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_principle_by_call(pri, e->ring.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\"Span %d: Received INFORMATION for unknown call.\\n\", pri->span);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->ring.subcmds, e->ring.call);\n\t\t\t\t\n\t\t\t\tif ((pri->overlapdial & DAHDI_OVERLAPDIAL_INCOMING)\n\t\t\t\t\t&& pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\n\t\t\t\t\tint digitlen = strlen(e->ring.callednum);\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = 0; i < digitlen; i++) {\n\t\t\t\t\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = e->ring.callednum[i], };\n\t\t\t\t\t\tpri_queue_frame(pri, chanpos, &f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n#if defined(HAVE_PRI_SERVICE_MESSAGES)\n\t\t\tcase PRI_EVENT_SERVICE:\n\t\t\t\tchanpos = pri_find_principle(pri, e->service.channel, NULL);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Received service change status %d on unconfigured channel %d/%d span %d\\n\",\n\t\t\t\t\t\te->service_ack.changestatus, PRI_SPAN(e->service_ack.channel), PRI_CHANNEL(e->service_ack.channel), pri->span);\n\t\t\t\t} else {\n\t\t\t\t\tchar db_chan_name[20];\n\t\t\t\t\tchar db_answer[15];\n\t\t\t\t\tint ch;\n\t\t\t\t\tunsigned *why;\n\t\t\t\t\tch = pri->pvts[chanpos]->channel;\n\t\t\t\t\tsnprintf(db_chan_name, sizeof(db_chan_name), \"%s/%d:%d\", dahdi_db, pri->span, ch);\n\t\t\t\t\twhy = &pri->pvts[chanpos]->service_status;\n\t\t\t\t\tswitch (e->service.changestatus) {\n\t\t\t\t\tcase 0: \n\t\t\t\t\t\t\n\t\t\t\t\t\tast_db_del(db_chan_name, SRVST_DBKEY);\n\t\t\t\t\t\t*why &= ~SRVST_FAREND;\n\t\t\t\t\t\tif (*why) {\n\t\t\t\t\t\t\tsnprintf(db_answer, sizeof(db_answer), \"%s:%u\",\n\t\t\t\t\t\t\t\tSRVST_TYPE_OOS, *why);\n\t\t\t\t\t\t\tast_db_put(db_chan_name, SRVST_DBKEY, db_answer);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: \n\t\t\t\t\t\t\n\t\t\t\t\t\tast_db_del(db_chan_name, SRVST_DBKEY);\n\t\t\t\t\t\t*why |= SRVST_FAREND;\n\t\t\t\t\t\tsnprintf(db_answer, sizeof(db_answer), \"%s:%u\", SRVST_TYPE_OOS,\n\t\t\t\t\t\t\t*why);\n\t\t\t\t\t\tast_db_put(db_chan_name, SRVST_DBKEY, db_answer);\n\t\t\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tast_log(LOG_ERROR, \"Huh?  changestatus is: %d\\n\", e->service.changestatus);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tast_log(LOG_NOTICE, \"Channel %d/%d span %d (logical: %d) received a change of service message, status '%d'\\n\",\n\t\t\t\t\t\tPRI_SPAN(e->service.channel), PRI_CHANNEL(e->service.channel), pri->span, ch, e->service.changestatus);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_SERVICE_ACK:\n\t\t\t\tchanpos = pri_find_principle(pri, e->service_ack.channel, NULL);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Received service acknowledge change status '%d' on unconfigured channel %d/%d span %d\\n\",\n\t\t\t\t\t\te->service_ack.changestatus, PRI_SPAN(e->service_ack.channel), PRI_CHANNEL(e->service_ack.channel), pri->span);\n\t\t\t\t} else {\n\t\t\t\t\tast_debug(2, \"Channel %d/%d span %d received a change os service acknowledgement message, status '%d'\\n\",\n\t\t\t\t\t\tPRI_SPAN(e->service_ack.channel), PRI_CHANNEL(e->service_ack.channel), pri->span, e->service_ack.changestatus);\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\t\n\t\t\tcase PRI_EVENT_RING:\n\t\t\t\tsig_pri_handle_setup(pri, e);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_RINGING:\n\t\t\t\tif (sig_pri_is_cis_call(e->ringing.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->ringing.subcmds,\n\t\t\t\t\t\te->ringing.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_fixup_principle(pri, e->ringing.channel,\n\t\t\t\t\te->ringing.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->ringing.subcmds,\n\t\t\t\t\te->ringing.call);\n\t\t\t\tsig_pri_cc_generic_check(pri, chanpos, AST_CC_CCNR);\n\t\t\t\tsig_pri_set_echocanceller(pri->pvts[chanpos], 1);\n\t\t\t\tsig_pri_lock_owner(pri, chanpos);\n\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\tast_setstate(pri->pvts[chanpos]->owner, AST_STATE_RINGING);\n\t\t\t\t\tast_channel_unlock(pri->pvts[chanpos]->owner);\n\t\t\t\t}\n\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_RINGING);\n\t\t\t\tif (pri->pvts[chanpos]->call_level < SIG_PRI_CALL_LEVEL_ALERTING) {\n\t\t\t\t\tpri->pvts[chanpos]->call_level = SIG_PRI_CALL_LEVEL_ALERTING;\n\t\t\t\t}\n\t\t\t\tif (!pri->pvts[chanpos]->progress\n\t\t\t\t\t&& !pri->pvts[chanpos]->no_b_channel\n#ifdef PRI_PROGRESS_MASK\n\t\t\t\t\t&& (e->ringing.progressmask\n\t\t\t\t\t\t& (PRI_PROG_CALL_NOT_E2E_ISDN | PRI_PROG_INBAND_AVAILABLE))\n#else\n\t\t\t\t\t&& e->ringing.progress == 8\n#endif\n\t\t\t\t\t) {\n\t\t\t\t\t\n\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_PROGRESS);\n\t\t\t\t\tpri->pvts[chanpos]->progress = 1;\n\t\t\t\t\tsig_pri_set_dialing(pri->pvts[chanpos], 0);\n\t\t\t\t\tsig_pri_open_media(pri->pvts[chanpos]);\n\t\t\t\t}\n#ifdef SUPPORT_USERUSER\n\t\t\t\tif (!ast_strlen_zero(e->ringing.useruserinfo)) {\n\t\t\t\t\tstruct ast_channel *owner;\n\t\t\t\t\tsig_pri_lock_owner(pri, chanpos);\n\t\t\t\t\towner = pri->pvts[chanpos]->owner;\n\t\t\t\t\tif (owner) {\n\t\t\t\t\t\tpbx_builtin_setvar_helper(owner, \"USERUSERINFO\",\n\t\t\t\t\t\t\te->ringing.useruserinfo);\n\t\t\t\t\t\tast_channel_unlock(owner);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_PROGRESS:\n\t\t\t\tif (sig_pri_is_cis_call(e->proceeding.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->proceeding.subcmds,\n\t\t\t\t\t\te->proceeding.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_fixup_principle(pri, e->proceeding.channel,\n\t\t\t\t\te->proceeding.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->proceeding.subcmds,\n\t\t\t\t\te->proceeding.call);\n\t\t\t\tif (e->proceeding.cause > -1) {\n\t\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\tsnprintf(cause_str, sizeof(cause_str), \"PRI PRI_EVENT_PROGRESS (%d)\", e->proceeding.cause);\n\t\t\t\t\t\tpri_queue_pvt_cause_data(pri, chanpos, cause_str, e->proceeding.cause);\n\t\t\t\t\t}\n\t\t\t\t\tast_verb(3, \"PROGRESS with cause code %d received\\n\", e->proceeding.cause);\n\t\t\t\t\t\n\t\t\t\t\tif (e->proceeding.cause == AST_CAUSE_USER_BUSY) {\n\t\t\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\t\tast_verb(3, \"PROGRESS with 'user busy' received, signaling AST_CONTROL_BUSY instead of AST_CONTROL_PROGRESS\\n\");\n\t\t\t\t\t\t\tast_channel_hangupcause_set(pri->pvts[chanpos]->owner, e->proceeding.cause);\n\t\t\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_BUSY);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!pri->pvts[chanpos]->progress\n\t\t\t\t\t&& !pri->pvts[chanpos]->no_b_channel\n#ifdef PRI_PROGRESS_MASK\n\t\t\t\t\t&& (e->proceeding.progressmask\n\t\t\t\t\t\t& (PRI_PROG_CALL_NOT_E2E_ISDN | PRI_PROG_INBAND_AVAILABLE))\n#else\n\t\t\t\t\t&& e->proceeding.progress == 8\n#endif\n\t\t\t\t\t) {\n\t\t\t\t\t\n\t\t\t\t\tast_debug(1,\n\t\t\t\t\t\t\"Queuing frame from PRI_EVENT_PROGRESS on channel %d/%d span %d\\n\",\n\t\t\t\t\t\tpri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset,\n\t\t\t\t\t\tpri->span);\n\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_PROGRESS);\n\t\t\t\t\tpri->pvts[chanpos]->progress = 1;\n\t\t\t\t\tsig_pri_set_dialing(pri->pvts[chanpos], 0);\n\t\t\t\t\tsig_pri_open_media(pri->pvts[chanpos]);\n\t\t\t\t}\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_PROCEEDING:\n\t\t\t\tif (sig_pri_is_cis_call(e->proceeding.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->proceeding.subcmds,\n\t\t\t\t\t\te->proceeding.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_fixup_principle(pri, e->proceeding.channel,\n\t\t\t\t\te->proceeding.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->proceeding.subcmds,\n\t\t\t\t\te->proceeding.call);\n\t\t\t\tif (pri->pvts[chanpos]->call_level < SIG_PRI_CALL_LEVEL_PROCEEDING) {\n\t\t\t\t\tpri->pvts[chanpos]->call_level = SIG_PRI_CALL_LEVEL_PROCEEDING;\n\t\t\t\t\tast_debug(1,\n\t\t\t\t\t\t\"Queuing frame from PRI_EVENT_PROCEEDING on channel %d/%d span %d\\n\",\n\t\t\t\t\t\tpri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset,\n\t\t\t\t\t\tpri->span);\n\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_PROCEEDING);\n\t\t\t\t}\n\t\t\t\tif (!pri->pvts[chanpos]->progress\n\t\t\t\t\t&& !pri->pvts[chanpos]->no_b_channel\n#ifdef PRI_PROGRESS_MASK\n\t\t\t\t\t\n\t\t\t\t\t&& (e->proceeding.progressmask & PRI_PROG_INBAND_AVAILABLE)\n#else\n\t\t\t\t\t&& e->proceeding.progress == 8\n#endif\n\t\t\t\t\t) {\n\t\t\t\t\t\n\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_PROGRESS);\n\t\t\t\t\tpri->pvts[chanpos]->progress = 1;\n\t\t\t\t\tsig_pri_set_dialing(pri->pvts[chanpos], 0);\n\t\t\t\t\tsig_pri_open_media(pri->pvts[chanpos]);\n\t\t\t\t} else if (pri->inband_on_proceeding) {\n\t\t\t\t\t\n\t\t\t\t\tsig_pri_set_dialing(pri->pvts[chanpos], 0);\n\t\t\t\t}\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_FACILITY:\n\t\t\t\tif (!e->facility.call || sig_pri_is_cis_call(e->facility.channel)) {\n\t\t\t\t\t\n#if defined(HAVE_PRI_CALL_REROUTING)\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->facility.subcmds,\n\t\t\t\t\t\te->facility.subcall);\n#else\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->facility.subcmds,\n\t\t\t\t\t\te->facility.call);\n#endif\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_principle_by_call(pri, e->facility.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Span %d: Received facility for unknown call.\\n\",\n\t\t\t\t\t\tpri->span);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n#if defined(HAVE_PRI_CALL_REROUTING)\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->facility.subcmds,\n\t\t\t\t\te->facility.subcall);\n#else\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->facility.subcmds,\n\t\t\t\t\te->facility.call);\n#endif\t\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_ANSWER:\n\t\t\t\tif (sig_pri_is_cis_call(e->answer.channel)) {\n#if defined(HAVE_PRI_CALL_WAITING)\n\t\t\t\t\t\n\t\t\t\t\tpri_connect_ack(pri->pri, e->answer.call, 0);\n#endif\t\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->answer.subcmds,\n\t\t\t\t\t\te->answer.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_fixup_principle(pri, e->answer.channel, e->answer.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#if defined(HAVE_PRI_CALL_WAITING)\n\t\t\t\tif (pri->pvts[chanpos]->is_call_waiting) {\n\t\t\t\t\tif (pri->pvts[chanpos]->no_b_channel) {\n\t\t\t\t\t\tint new_chanpos;\n\t\t\t\t\t\t\n\t\t\t\t\t\tnew_chanpos = pri_find_empty_chan(pri, 1);\n\t\t\t\t\t\tif (0 <= new_chanpos) {\n\t\t\t\t\t\t\tnew_chanpos = pri_fixup_principle(pri, new_chanpos,\n\t\t\t\t\t\t\t\te->answer.call);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (new_chanpos < 0) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tast_verb(3,\n\t\t\t\t\t\t\t\t\"Span %d: Channel not available for call waiting call.\\n\",\n\t\t\t\t\t\t\t\tpri->span);\n\t\t\t\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->answer.subcmds,\n\t\t\t\t\t\t\t\te->answer.call);\n\t\t\t\t\t\t\tsig_pri_cc_generic_check(pri, chanpos, AST_CC_CCBS);\n\t\t\t\t\t\t\tsig_pri_lock_owner(pri, chanpos);\n\t\t\t\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\t\t\tast_channel_hangupcause_set(pri->pvts[chanpos]->owner, PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION);\n\t\t\t\t\t\t\t\tswitch (ast_channel_state(pri->pvts[chanpos]->owner)) {\n\t\t\t\t\t\t\t\tcase AST_STATE_BUSY:\n\t\t\t\t\t\t\t\tcase AST_STATE_UP:\n\t\t\t\t\t\t\t\t\tast_softhangup_nolock(pri->pvts[chanpos]->owner, AST_SOFTHANGUP_DEV);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_CONGESTION);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tast_channel_unlock(pri->pvts[chanpos]->owner);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpri->pvts[chanpos]->is_call_waiting = 0;\n\t\t\t\t\t\t\t\tast_atomic_fetchadd_int(&pri->num_call_waiting_calls, -1);\n\t\t\t\t\t\t\t\tpri_hangup(pri->pri, e->answer.call, PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION);\n\t\t\t\t\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanpos = new_chanpos;\n\t\t\t\t\t}\n\t\t\t\t\tpri_connect_ack(pri->pri, e->answer.call, PVT_TO_CHANNEL(pri->pvts[chanpos]));\n\t\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tpri_connect_ack(pri->pri, e->answer.call, 0);\n\t\t\t\t}\n#endif\t\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n#if defined(HAVE_PRI_CALL_WAITING)\n\t\t\t\tif (pri->pvts[chanpos]->is_call_waiting) {\n\t\t\t\t\tpri->pvts[chanpos]->is_call_waiting = 0;\n\t\t\t\t\tast_atomic_fetchadd_int(&pri->num_call_waiting_calls, -1);\n\t\t\t\t}\n#endif\t\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->answer.subcmds,\n\t\t\t\t\te->answer.call);\n\t\t\t\tif (!ast_strlen_zero(pri->pvts[chanpos]->deferred_digits)) {\n\t\t\t\t\t\n\t\t\t\t\tast_verb(3,\n\t\t\t\t\t\t\"Span %d: Channel %d/%d dialing deferred digit string: %s\\n\",\n\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\tpri->pvts[chanpos]->prioffset,\n\t\t\t\t\t\tpri->pvts[chanpos]->deferred_digits);\n\t\t\t\t\tif (pri->pvts[chanpos]->call_level < SIG_PRI_CALL_LEVEL_DEFER_DIAL) {\n\t\t\t\t\t\tpri->pvts[chanpos]->call_level = SIG_PRI_CALL_LEVEL_DEFER_DIAL;\n\t\t\t\t\t}\n\t\t\t\t\tsig_pri_dial_digits(pri->pvts[chanpos],\n\t\t\t\t\t\tpri->pvts[chanpos]->deferred_digits);\n\t\t\t\t} else {\n\t\t\t\t\tif (pri->pvts[chanpos]->call_level < SIG_PRI_CALL_LEVEL_CONNECT) {\n\t\t\t\t\t\tpri->pvts[chanpos]->call_level = SIG_PRI_CALL_LEVEL_CONNECT;\n\t\t\t\t\t}\n\t\t\t\t\tsig_pri_open_media(pri->pvts[chanpos]);\n\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_ANSWER);\n\t\t\t\t\tsig_pri_set_dialing(pri->pvts[chanpos], 0);\n\t\t\t\t\t\n\t\t\t\t\tsig_pri_set_echocanceller(pri->pvts[chanpos], 1);\n\t\t\t\t}\n#ifdef SUPPORT_USERUSER\n\t\t\t\tif (!ast_strlen_zero(e->answer.useruserinfo)) {\n\t\t\t\t\tstruct ast_channel *owner;\n\t\t\t\t\tsig_pri_lock_owner(pri, chanpos);\n\t\t\t\t\towner = pri->pvts[chanpos]->owner;\n\t\t\t\t\tif (owner) {\n\t\t\t\t\t\tpbx_builtin_setvar_helper(owner, \"USERUSERINFO\",\n\t\t\t\t\t\t\te->answer.useruserinfo);\n\t\t\t\t\t\tast_channel_unlock(owner);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n#if defined(HAVE_PRI_CALL_WAITING)\n\t\t\tcase PRI_EVENT_CONNECT_ACK:\n\t\t\t\tif (sig_pri_is_cis_call(e->connect_ack.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->connect_ack.subcmds,\n\t\t\t\t\t\te->connect_ack.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_fixup_principle(pri, e->connect_ack.channel,\n\t\t\t\t\te->connect_ack.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->connect_ack.subcmds,\n\t\t\t\t\te->connect_ack.call);\n\t\t\t\tsig_pri_open_media(pri->pvts[chanpos]);\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\tbreak;\n#endif\t\n\t\t\tcase PRI_EVENT_HANGUP:\n\t\t\t\tif (sig_pri_is_cis_call(e->hangup.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->hangup.subcmds,\n\t\t\t\t\t\te->hangup.call);\n\t\t\t\t\tpri_hangup(pri->pri, e->hangup.call, e->hangup.cause);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_principle_by_call(pri, e->hangup.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\t\n\t\t\t\t\tpri_hangup(pri->pri, e->hangup.call, e->hangup.cause);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->hangup.subcmds,\n\t\t\t\t\te->hangup.call);\n\t\t\t\tswitch (e->hangup.cause) {\n\t\t\t\tcase PRI_CAUSE_INVALID_CALL_REFERENCE:\n\t\t\t\t\t\n\t\t\t\t\tpri_hangup(pri->pri, e->hangup.call, e->hangup.cause);\n\t\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!pri->pvts[chanpos]->alreadyhungup) {\n\t\t\t\t\t\n\t\t\t\t\tpri->pvts[chanpos]->alreadyhungup = 1;\n\t\t\t\t\tswitch (e->hangup.cause) {\n\t\t\t\t\tcase PRI_CAUSE_USER_BUSY:\n\t\t\t\t\tcase PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION:\n\t\t\t\t\t\tsig_pri_cc_generic_check(pri, chanpos, AST_CC_CCBS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\tsnprintf(cause_str, sizeof(cause_str), \"PRI PRI_EVENT_HANGUP (%d)\", e->hangup.cause);\n\t\t\t\t\t\tpri_queue_pvt_cause_data(pri, chanpos, cause_str, e->hangup.cause);\n\t\t\t\t\t}\n\t\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\tint do_hangup = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tast_channel_hangupcause_set(pri->pvts[chanpos]->owner, e->hangup.cause);\n\t\t\t\t\t\tswitch (ast_channel_state(pri->pvts[chanpos]->owner)) {\n\t\t\t\t\t\tcase AST_STATE_BUSY:\n\t\t\t\t\t\tcase AST_STATE_UP:\n\t\t\t\t\t\t\tdo_hangup = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif (!pri->pvts[chanpos]->outgoing) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tdo_hangup = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswitch (e->hangup.cause) {\n\t\t\t\t\t\t\tcase PRI_CAUSE_USER_BUSY:\n\t\t\t\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_BUSY);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PRI_CAUSE_CALL_REJECTED:\n\t\t\t\t\t\t\tcase PRI_CAUSE_NETWORK_OUT_OF_ORDER:\n\t\t\t\t\t\t\tcase PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION:\n\t\t\t\t\t\t\tcase PRI_CAUSE_SWITCH_CONGESTION:\n\t\t\t\t\t\t\tcase PRI_CAUSE_DESTINATION_OUT_OF_ORDER:\n\t\t\t\t\t\t\tcase PRI_CAUSE_NORMAL_TEMPORARY_FAILURE:\n\t\t\t\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_CONGESTION);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tdo_hangup = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (do_hangup) {\n\t\t\t\t\t\t\tsig_pri_queue_hangup(pri, chanpos);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tpri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);\n\t\t\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tast_verb(3, \"Span %d: Channel %d/%d got hangup, cause %d\\n\",\n\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\tpri->pvts[chanpos]->prioffset, e->hangup.cause);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tpri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);\n\t\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\t}\n\t\t\t\tif (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL\n\t\t\t\t\t&& pri->sig != SIG_BRI_PTMP && !pri->resetting\n\t\t\t\t\t&& pri->force_restart_unavailable_chans\n\t\t\t\t\t&& pri->pvts[chanpos]->resetting == SIG_PRI_RESET_IDLE) {\n\t\t\t\t\tast_verb(3,\n\t\t\t\t\t\t\"Span %d: Forcing restart of channel %d/%d since channel reported in use\\n\",\n\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\tpri->pvts[chanpos]->resetting = SIG_PRI_RESET_ACTIVE;\n\t\t\t\t\tpri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));\n\t\t\t\t}\n\t\t\t\tif (e->hangup.aoc_units > -1)\n\t\t\t\t\tast_verb(3, \"Channel %d/%d, span %d received AOC-E charging %d unit%s\\n\",\n\t\t\t\t\t\tpri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? \"\" : \"s\");\n#ifdef SUPPORT_USERUSER\n\t\t\t\tif (!ast_strlen_zero(e->hangup.useruserinfo)) {\n\t\t\t\t\tstruct ast_channel *owner;\n\t\t\t\t\tsig_pri_lock_owner(pri, chanpos);\n\t\t\t\t\towner = pri->pvts[chanpos]->owner;\n\t\t\t\t\tif (owner) {\n\t\t\t\t\t\tpbx_builtin_setvar_helper(owner, \"USERUSERINFO\",\n\t\t\t\t\t\t\te->hangup.useruserinfo);\n\t\t\t\t\t\tast_channel_unlock(owner);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_HANGUP_REQ:\n\t\t\t\tif (sig_pri_is_cis_call(e->hangup.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->hangup.subcmds,\n\t\t\t\t\t\te->hangup.call);\n\t\t\t\t\tpri_hangup(pri->pri, e->hangup.call, e->hangup.cause);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_principle_by_call(pri, e->hangup.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\t\n\t\t\t\t\tpri_hangup(pri->pri, e->hangup.call, e->hangup.cause);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->hangup.subcmds,\n\t\t\t\t\te->hangup.call);\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\t\tif (e->hangup.call_active && e->hangup.call_held\n\t\t\t\t\t&& pri->hold_disconnect_transfer) {\n\t\t\t\t\t\n\t\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\t\tif (!sig_pri_attempt_transfer(pri, e->hangup.call_held, 1,\n\t\t\t\t\t\te->hangup.call_active, 0, NULL)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\t}\n#endif\t\n\t\t\t\tswitch (e->hangup.cause) {\n\t\t\t\tcase PRI_CAUSE_USER_BUSY:\n\t\t\t\tcase PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION:\n\t\t\t\t\tsig_pri_cc_generic_check(pri, chanpos, AST_CC_CCBS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PRI_CAUSE_INVALID_CALL_REFERENCE:\n\t\t\t\t\t\n\t\t\t\t\tpri_hangup(pri->pri, e->hangup.call, e->hangup.cause);\n\t\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\tsnprintf(cause_str, sizeof(cause_str), \"PRI PRI_EVENT_HANGUP_REQ (%d)\", e->hangup.cause);\n\t\t\t\t\tpri_queue_pvt_cause_data(pri, chanpos, cause_str, e->hangup.cause);\n\t\t\t\t}\n\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\tint do_hangup = 0;\n\t\t\t\t\tast_channel_hangupcause_set(pri->pvts[chanpos]->owner, e->hangup.cause);\n\t\t\t\t\tswitch (ast_channel_state(pri->pvts[chanpos]->owner)) {\n\t\t\t\t\tcase AST_STATE_BUSY:\n\t\t\t\t\tcase AST_STATE_UP:\n\t\t\t\t\t\tdo_hangup = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (!pri->pvts[chanpos]->outgoing) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdo_hangup = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (e->hangup.cause) {\n\t\t\t\t\t\tcase PRI_CAUSE_USER_BUSY:\n\t\t\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_BUSY);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PRI_CAUSE_CALL_REJECTED:\n\t\t\t\t\t\tcase PRI_CAUSE_NETWORK_OUT_OF_ORDER:\n\t\t\t\t\t\tcase PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION:\n\t\t\t\t\t\tcase PRI_CAUSE_SWITCH_CONGESTION:\n\t\t\t\t\t\tcase PRI_CAUSE_DESTINATION_OUT_OF_ORDER:\n\t\t\t\t\t\tcase PRI_CAUSE_NORMAL_TEMPORARY_FAILURE:\n\t\t\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_CONGESTION);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdo_hangup = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (do_hangup) {\n#if defined(HAVE_PRI_AOC_EVENTS)\n\t\t\t\t\t\tif (!pri->pvts[chanpos]->holding_aoce\n\t\t\t\t\t\t\t&& pri->aoce_delayhangup\n\t\t\t\t\t\t\t&& ast_channel_is_bridged(pri->pvts[chanpos]->owner)) {\n\t\t\t\t\t\t\tsig_pri_send_aoce_termination_request(pri, chanpos,\n\t\t\t\t\t\t\t\tpri_get_timer(pri->pri, PRI_TIMER_T305) / 2);\n\t\t\t\t\t\t} else\n#endif\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsig_pri_queue_hangup(pri, chanpos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tast_verb(3, \"Span %d: Channel %d/%d got hangup request, cause %d\\n\",\n\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\tpri->pvts[chanpos]->prioffset, e->hangup.cause);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tpri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);\n\t\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\t}\n\t\t\t\tif (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL\n\t\t\t\t\t&& pri->sig != SIG_BRI_PTMP && !pri->resetting\n\t\t\t\t\t&& pri->force_restart_unavailable_chans\n\t\t\t\t\t&& pri->pvts[chanpos]->resetting == SIG_PRI_RESET_IDLE) {\n\t\t\t\t\tast_verb(3,\n\t\t\t\t\t\t\"Span %d: Forcing restart of channel %d/%d since channel reported in use\\n\",\n\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\tpri->pvts[chanpos]->resetting = SIG_PRI_RESET_ACTIVE;\n\t\t\t\t\tpri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));\n\t\t\t\t}\n#ifdef SUPPORT_USERUSER\n\t\t\t\tif (!ast_strlen_zero(e->hangup.useruserinfo)) {\n\t\t\t\t\tstruct ast_channel *owner;\n\t\t\t\t\tsig_pri_lock_owner(pri, chanpos);\n\t\t\t\t\towner = pri->pvts[chanpos]->owner;\n\t\t\t\t\tif (owner) {\n\t\t\t\t\t\tpbx_builtin_setvar_helper(owner, \"USERUSERINFO\",\n\t\t\t\t\t\t\te->hangup.useruserinfo);\n\t\t\t\t\t\tast_channel_unlock(owner);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_HANGUP_ACK:\n\t\t\t\tif (sig_pri_is_cis_call(e->hangup.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->hangup.subcmds,\n\t\t\t\t\t\te->hangup.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_principle_by_call(pri, e->hangup.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tpri->pvts[chanpos]->call = NULL;\n\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\tast_verb(3, \"Span %d: Channel %d/%d got hangup ACK\\n\", pri->span,\n\t\t\t\t\t\tpri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset);\n\t\t\t\t}\n#ifdef SUPPORT_USERUSER\n\t\t\t\tif (!ast_strlen_zero(e->hangup.useruserinfo)) {\n\t\t\t\t\tstruct ast_channel *owner;\n\t\t\t\t\tsig_pri_lock_owner(pri, chanpos);\n\t\t\t\t\towner = pri->pvts[chanpos]->owner;\n\t\t\t\t\tif (owner) {\n\t\t\t\t\t\tpbx_builtin_setvar_helper(owner, \"USERUSERINFO\",\n\t\t\t\t\t\t\te->hangup.useruserinfo);\n\t\t\t\t\t\tast_channel_unlock(owner);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tsig_pri_span_devstate_changed(pri);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_CONFIG_ERR:\n\t\t\t\tast_log(LOG_WARNING, \"PRI Error on span %d: %s\\n\", pri->span, e->err.err);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_RESTART_ACK:\n\t\t\t\tchanpos = pri_find_principle(pri, e->restartack.channel, NULL);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\t\n\t\t\t\t\tfor (x = 0; x < pri->numchans; x++) {\n\t\t\t\t\t\tif (pri->pvts[x]\n\t\t\t\t\t\t\t&& pri->pvts[x]->resetting != SIG_PRI_RESET_IDLE) {\n\t\t\t\t\t\t\tchanpos = x;\n\t\t\t\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\t\t\t\tast_debug(1,\n\t\t\t\t\t\t\t\t\"Span %d: Assuming restart ack is for channel %d/%d\\n\",\n\t\t\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\t\t\"Span %d: Got restart ack on channel %d/%d with owner\\n\",\n\t\t\t\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\t\t\t\tast_channel_softhangup_internal_flag_add(pri->pvts[chanpos]->owner, AST_SOFTHANGUP_DEV);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpri->pvts[chanpos]->resetting = SIG_PRI_RESET_IDLE;\n\t\t\t\t\t\t\tast_verb(3,\n\t\t\t\t\t\t\t\t\"Span %d: Channel %d/%d successfully restarted\\n\",\n\t\t\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\t\t\t\tif (pri->resetting)\n\t\t\t\t\t\t\t\tpri_check_restart(pri);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"Span %d: Restart ACK on strange channel %d/%d\\n\",\n\t\t\t\t\t\t\tpri->span, PRI_SPAN(e->restartack.channel),\n\t\t\t\t\t\t\tPRI_CHANNEL(e->restartack.channel));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\t\tif (pri->pvts[chanpos]->resetting == SIG_PRI_RESET_IDLE) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tast_debug(1,\n\t\t\t\t\t\t\t\"Span %d: Unexpected or late restart ack on channel %d/%d (Ignoring)\\n\",\n\t\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (pri->pvts[chanpos]->owner) {\n\t\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"Span %d: Got restart ack on channel %d/%d with owner\\n\",\n\t\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\t\tast_channel_softhangup_internal_flag_add(pri->pvts[chanpos]->owner, AST_SOFTHANGUP_DEV);\n\t\t\t\t\t}\n\t\t\t\t\tpri->pvts[chanpos]->resetting = SIG_PRI_RESET_IDLE;\n\t\t\t\t\tast_verb(3,\n\t\t\t\t\t\t\"Span %d: Channel %d/%d successfully restarted\\n\",\n\t\t\t\t\t\tpri->span, pri->pvts[chanpos]->logicalspan,\n\t\t\t\t\t\tpri->pvts[chanpos]->prioffset);\n\t\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\t\tif (pri->resetting)\n\t\t\t\t\t\tpri_check_restart(pri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_SETUP_ACK:\n\t\t\t\tif (sig_pri_is_cis_call(e->setup_ack.channel)) {\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->setup_ack.subcmds,\n\t\t\t\t\t\te->setup_ack.call);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchanpos = pri_find_fixup_principle(pri, e->setup_ack.channel,\n\t\t\t\t\te->setup_ack.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->setup_ack.subcmds,\n\t\t\t\t\te->setup_ack.call);\n\t\t\t\tif (pri->pvts[chanpos]->call_level < SIG_PRI_CALL_LEVEL_OVERLAP) {\n\t\t\t\t\tpri->pvts[chanpos]->call_level = SIG_PRI_CALL_LEVEL_OVERLAP;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlen = strlen(pri->pvts[chanpos]->dialdest);\n\t\t\t\tfor (x = 0; x < len; ++x) {\n\t\t\t\t\tast_debug(1, \"Sending pending digit '%c'\\n\", pri->pvts[chanpos]->dialdest[x]);\n\t\t\t\t\tpri_information(pri->pri, pri->pvts[chanpos]->call,\n\t\t\t\t\t\tpri->pvts[chanpos]->dialdest[x]);\n\t\t\t\t}\n\t\t\t\tif (!pri->pvts[chanpos]->progress\n\t\t\t\t\t&& (pri->overlapdial & DAHDI_OVERLAPDIAL_OUTGOING)\n\t\t\t\t\t&& !pri->pvts[chanpos]->digital\n\t\t\t\t\t&& !pri->pvts[chanpos]->no_b_channel\n#if defined(HAVE_PRI_SETUP_ACK_INBAND)\n\t\t\t\t\t\n\t\t\t\t\t&& ((e->setup_ack.progressmask & PRI_PROG_INBAND_AVAILABLE)\n\t\t\t\t\t\t|| pri->inband_on_setup_ack\n\t\t\t\t\t\t|| pri->pvts[chanpos]->no_dialed_digits)\n#endif\t\n\t\t\t\t\t) {\n\t\t\t\t\t\n\t\t\t\t\tpri_queue_control(pri, chanpos, AST_CONTROL_PROGRESS);\n\t\t\t\t\tpri->pvts[chanpos]->progress = 1;\n\t\t\t\t\tsig_pri_set_dialing(pri->pvts[chanpos], 0);\n\t\t\t\t\tsig_pri_open_media(pri->pvts[chanpos]);\n\t\t\t\t}\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n\t\t\tcase PRI_EVENT_NOTIFY:\n\t\t\t\tif (sig_pri_is_cis_call(e->notify.channel)) {\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->notify.subcmds,\n\t\t\t\t\t\te->notify.call);\n#else\n\t\t\t\t\tsig_pri_handle_cis_subcmds(pri, e->e, e->notify.subcmds, NULL);\n#endif\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\t\tchanpos = pri_find_principle_by_call(pri, e->notify.call);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Span %d: Received NOTIFY for unknown call.\\n\",\n\t\t\t\t\t\tpri->span);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#else\n\t\t\t\t\n\t\t\t\tchanpos = pri_find_principle(pri, e->notify.channel, NULL);\n\t\t\t\tif (chanpos < 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Received NOTIFY on unconfigured channel %d/%d span %d\\n\",\n\t\t\t\t\t\tPRI_SPAN(e->notify.channel), PRI_CHANNEL(e->notify.channel), pri->span);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\t\n\t\t\t\tsig_pri_lock_private(pri->pvts[chanpos]);\n\t\t\t\tcallid = func_pri_dchannel_chanpos_callid(pri, chanpos);\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->notify.subcmds,\n\t\t\t\t\te->notify.call);\n#else\n\t\t\t\tsig_pri_handle_subcmds(pri, chanpos, e->e, e->notify.subcmds, NULL);\n#endif\t\n\t\t\t\tswitch (e->notify.info) {\n\t\t\t\tcase PRI_NOTIFY_REMOTE_HOLD:\n\t\t\t\t\tif (!pri->discardremoteholdretrieval) {\n\t\t\t\t\t\tsig_pri_queue_hold(pri, chanpos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PRI_NOTIFY_REMOTE_RETRIEVAL:\n\t\t\t\t\tif (!pri->discardremoteholdretrieval) {\n\t\t\t\t\t\tsig_pri_queue_unhold(pri, chanpos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsig_pri_unlock_private(pri->pvts[chanpos]);\n\t\t\t\tbreak;\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\tcase PRI_EVENT_HOLD:\n\t\t\t\t\n\t\t\t\tif (sig_pri_handle_hold(pri, e)) {\n\t\t\t\t\tpri_hold_rej(pri->pri, e->hold.call,\n\t\t\t\t\t\tPRI_CAUSE_RESOURCE_UNAVAIL_UNSPECIFIED);\n\t\t\t\t} else {\n\t\t\t\t\tpri_hold_ack(pri->pri, e->hold.call);\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\t\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\tcase PRI_EVENT_HOLD_ACK:\n\t\t\t\t\n\t\t\t\tsig_pri_handle_hold_ack(pri, e);\n\t\t\t\tbreak;\n#endif\t\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\tcase PRI_EVENT_HOLD_REJ:\n\t\t\t\t\n\t\t\t\tsig_pri_handle_hold_rej(pri, e);\n\t\t\t\tbreak;\n#endif\t\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\tcase PRI_EVENT_RETRIEVE:\n\t\t\t\t\n\t\t\t\tsig_pri_handle_retrieve(pri, e);\n\t\t\t\tbreak;\n#endif\t\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\tcase PRI_EVENT_RETRIEVE_ACK:\n\t\t\t\t\n\t\t\t\tsig_pri_handle_retrieve_ack(pri, e);\n\t\t\t\tbreak;\n#endif\t\n#if defined(HAVE_PRI_CALL_HOLD)\n\t\t\tcase PRI_EVENT_RETRIEVE_REJ:\n\t\t\t\t\n\t\t\t\tsig_pri_handle_retrieve_rej(pri, e);\n\t\t\t\tbreak;\n#endif\t\n\t\t\tdefault:\n\t\t\t\tast_debug(1, \"Span: %d Unhandled event: %s(%d)\\n\",\n\t\t\t\t\tpri->span, pri_event2str(e->e), e->e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (callid) {\n\t\t\t\tast_callid_threadassoc_remove();\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&pri->lock);\n\t}\n\t\n\treturn NULL;\n}\n", "bug_type": null, "idx": 9}
{"project": "Asterisk", "target": 0, "func": "static int handle_negotiated_sdp(struct ast_sip_session *session, const pjmedia_sdp_session *local, const pjmedia_sdp_session *remote)\n{\n\tint i;\n\tstruct ast_stream_topology *topology;\n\tunsigned int changed = 0;\n\t\n\tif (!session->pending_media_state->topology) {\n\t\tast_debug(1, \"Pending topology was NULL for channel '%s'\\n\",\n\t\t\tsession->channel ? ast_channel_name(session->channel) : \"unknown\");\n\t\treturn 0;\n\t}\n\t\n\tif (ast_stream_topology_get_count(session->pending_media_state->topology) != local->media_count\n\t\t|| AST_VECTOR_SIZE(&session->pending_media_state->sessions) != local->media_count) {\n\t\tast_log(LOG_WARNING, \"Local SDP for channel '%s' contains %d media streams while we expected it to contain %u\\n\",\n\t\t\tsession->channel ? ast_channel_name(session->channel) : \"unknown\",\n\t\t\tast_stream_topology_get_count(session->pending_media_state->topology), local->media_count);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < local->media_count; ++i) {\n\t\tstruct ast_sip_session_media *session_media;\n\t\tstruct ast_stream *stream;\n\t\tif (!remote->media[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tsession_media = AST_VECTOR_GET(&session->pending_media_state->sessions, i);\n\t\tstream = ast_stream_topology_get_stream(session->pending_media_state->topology, i);\n\t\t\n\t\tif (ast_stream_get_state(stream) == AST_STREAM_STATE_REMOVED) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tif (handle_negotiated_sdp_session_media(session_media, session, local, remote, i, stream)) {\n\t\t\treturn -1;\n\t\t}\n\t\tchanged |= session_media->changed;\n\t\tsession_media->changed = 0;\n\t}\n\t\n\tast_channel_lock(session->channel);\n\t\n\tfor (i = 0; i < local->media_count; ++i) {\n\t\tstruct ast_sip_session_media *session_media;\n\t\tstruct ast_stream *stream;\n\t\tif (!remote->media[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tsession_media = AST_VECTOR_GET(&session->pending_media_state->sessions, i);\n\t\tstream = ast_stream_topology_get_stream(session->pending_media_state->topology, i);\n\t\tif (ast_stream_get_state(stream) == AST_STREAM_STATE_REMOVED\n\t\t\t&& session_media->handler) {\n\t\t\t\n\t\t\tsession_media_set_handler(session_media, NULL);\n\t\t}\n\t}\n\t\n\ttopology = ast_stream_topology_clone(session->pending_media_state->topology);\n\tif (topology) {\n\t\tast_channel_set_stream_topology(session->channel, topology);\n\t}\n\t\n\tfor (i = 0; i < AST_VECTOR_SIZE(&session->active_media_state->read_callbacks); ++i) {\n\t\tast_channel_internal_fd_clear(session->channel, i + AST_EXTENDED_FDS);\n\t}\n\t\n\tfor (i = 0; i < AST_VECTOR_SIZE(&session->pending_media_state->read_callbacks); ++i) {\n\t\tstruct ast_sip_session_media_read_callback_state *callback_state;\n\t\tcallback_state = AST_VECTOR_GET_ADDR(&session->pending_media_state->read_callbacks, i);\n\t\tast_channel_internal_fd_set(session->channel, i + AST_EXTENDED_FDS, callback_state->fd);\n\t}\n\t\n\tSWAP(session->active_media_state, session->pending_media_state);\n\tast_sip_session_media_state_reset(session->pending_media_state);\n\tast_channel_unlock(session->channel);\n\tif (changed) {\n\t\tstruct ast_frame f = { AST_FRAME_CONTROL, .subclass.integer = AST_CONTROL_STREAM_TOPOLOGY_SOURCE_CHANGED };\n\t\tast_queue_frame(session->channel, &f);\n\t} else {\n\t\tast_queue_frame(session->channel, &ast_null_frame);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 10}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *stasis_app_mailboxes_to_json()\n{\n\tstruct ast_json *array = ast_json_array_create();\n\tstruct ao2_container *mailboxes;\n\tstruct ao2_iterator iter;\n\tconst struct ast_mwi_mailbox_object *mailbox;\n\tif (!array) {\n\t\treturn NULL;\n\t}\n\tmailboxes = ast_mwi_mailbox_get_all();\n\tif (!mailboxes) {\n\t\tast_json_unref(array);\n\t\treturn NULL;\n\t}\n\titer = ao2_iterator_init(mailboxes, 0);\n\tfor (; (mailbox = ao2_iterator_next(&iter)); ast_mwi_mailbox_unref(mailbox)) {\n\t\tstruct ast_json *appending = mailbox_to_json(mailbox);\n\t\tif (!appending || ast_json_array_append(array, appending)) {\n\t\t\t\n\t\t\tast_json_unref(array);\n\t\t\tarray = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tao2_iterator_destroy(&iter);\n\treturn array;\n}\n", "bug_type": null, "idx": 11}
{"project": "Asterisk", "target": 0, "func": "void stasis_app_bridge_playback_channel_remove(char *bridge_id,\n\tstruct stasis_app_control *control)\n{\n\tstruct stasis_app_bridge_channel_wrapper *wrapper;\n\twrapper = ao2_find(app_bridges_playback, bridge_id, OBJ_SEARCH_KEY | OBJ_UNLINK);\n\tif (wrapper) {\n\t\t\n\t\tao2_unlink(app_controls, control);\n\t\tao2_ref(wrapper, -1);\n\t}\n}\n", "bug_type": null, "idx": 12}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_cli_formatter_entry *endpoint_formatter;\nstatic void load_all_endpoints(void)\n{\n\tstruct ao2_container *endpoints;\n\tendpoints = ast_sorcery_retrieve_by_fields(sip_sorcery, \"endpoint\", AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);\n\tao2_cleanup(endpoints);\n}\n", "bug_type": null, "idx": 13}
{"project": "Asterisk", "target": 0, "func": "#define DIALED_CAUSES_BUCKETS 37\nstruct ast_channel *__ast_channel_internal_alloc(void (*destructor)(void *obj), const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *file, int line, const char *function)\n{\n\tstruct ast_channel *tmp;\n\ttmp = __ao2_alloc(sizeof(*tmp), destructor,\n\t\tAO2_ALLOC_OPT_LOCK_MUTEX, \"\", file, line, function);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\tif ((ast_string_field_init(tmp, 128))) {\n\t\treturn ast_channel_unref(tmp);\n\t}\n\tif (!(tmp->dialed_causes = ao2_container_alloc(DIALED_CAUSES_BUCKETS, pvt_cause_hash_fn, pvt_cause_cmp_fn))) {\n\t\treturn ast_channel_unref(tmp);\n\t}\n\t\n\ttmp->uniqueid.creation_time = time(NULL);\n\ttmp->uniqueid.creation_unique = ast_atomic_fetchadd_int(&uniqueint, 1);\n\t\n\tif (assignedids && !ast_strlen_zero(assignedids->uniqueid)) {\n\t\tast_copy_string(tmp->uniqueid.unique_id, assignedids->uniqueid, sizeof(tmp->uniqueid.unique_id));\n\t} else if (ast_strlen_zero(ast_config_AST_SYSTEM_NAME)) {\n\t\tsnprintf(tmp->uniqueid.unique_id, sizeof(tmp->uniqueid.unique_id), \"%li.%d\",\n\t\t\t(long)(tmp->uniqueid.creation_time),\n\t\t\ttmp->uniqueid.creation_unique);\n\t} else {\n\t\tsnprintf(tmp->uniqueid.unique_id, sizeof(tmp->uniqueid.unique_id), \"%s-%li.%d\",\n\t\t\tast_config_AST_SYSTEM_NAME,\n\t\t\t(long)(tmp->uniqueid.creation_time),\n\t\t\ttmp->uniqueid.creation_unique);\n\t}\n\t\n\tif (requestor) {\n\t\ttmp->linkedid = requestor->linkedid;\n\t} else {\n\t\ttmp->linkedid = tmp->uniqueid;\n\t}\n\tAST_VECTOR_INIT(&tmp->fds, AST_MAX_FDS);\n\treturn tmp;\n}\n", "bug_type": null, "idx": 14}
{"project": "Asterisk", "target": 0, "func": "static void cli_display_parking_lot(int fd, const char *name)\n{\n\tRAII_VAR(struct parking_lot *, lot, NULL, ao2_cleanup);\n\tlot = parking_lot_find_by_name(name);\n\t\n\tif (!lot) {\n\t\tast_cli(fd, \"Could not find parking lot '%s'\\n\\n\", name);\n\t\treturn;\n\t}\n\tdisplay_parking_lot(lot, fd);\n\tast_cli(fd, \"Parked Calls\\n------------\\n\");\n\tif (!ao2_container_count(lot->parked_users)) {\n\t\tast_cli(fd, \"  (none)\\n\");\n\t\tast_cli(fd, \"\\n\\n\");\n\t\treturn;\n\t}\n\tao2_callback(lot->parked_users, OBJ_MULTIPLE | OBJ_NODATA, display_parked_users_cb, &fd);\n\tast_cli(fd, \"\\n\");\n}\n", "bug_type": null, "idx": 15}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_device_states_update(struct ast_variable *headers,\n\tstruct ast_ari_device_states_update_args *args,\n\tstruct ast_ari_response *response)\n{\n\tswitch (stasis_app_device_state_update(\n\t\t\targs->device_name, args->device_state)) {\n\tcase STASIS_DEVICE_STATE_NOT_CONTROLLED:\n\t\tast_ari_response_error(response, 409,\n\t\t\t\"Conflict\", \"Uncontrolled device specified\");\n\t\treturn;\n\tcase STASIS_DEVICE_STATE_MISSING:\n\t\tast_ari_response_error(response, 404,\n\t\t\t\"Not Found\", \"Device name is missing\");\n\t\treturn;\n\tcase STASIS_DEVICE_STATE_UNKNOWN:\n\t\tast_ari_response_error(response, 500, \"Internal Server Error\",\n\t\t\t\t       \"Unknown device\");\n\t\treturn;\n\tcase STASIS_DEVICE_STATE_OK:\n\tcase STASIS_DEVICE_STATE_SUBSCRIBERS: \n\t\tast_ari_response_no_content(response);\n\t}\n}\n", "bug_type": null, "idx": 16}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/rtp_engine.h\"\nstatic int validate_o_line(struct ast_test *test, const struct ast_sdp_o_line *o_line,\n\tconst char *sdpowner, const char *address_type, const char *address)\n{\n\tif (!o_line) {\n\t\treturn -1;\n\t}\n\tif (strcmp(o_line->username, sdpowner)) {\n\t\tast_test_status_update(test, \"Expected o-line SDP owner %s but got %s\\n\",\n\t\t\tsdpowner, o_line->username);\n\t\treturn -1;\n\t}\n\tif (strcmp(o_line->address_type, address_type)) {\n\t\tast_test_status_update(test, \"Expected o-line SDP address type %s but got %s\\n\",\n\t\t\taddress_type, o_line->address_type);\n\t\treturn -1;\n\t}\n\tif (strcmp(o_line->address, address)) {\n\t\tast_test_status_update(test, \"Expected o-line SDP address %s but got %s\\n\",\n\t\t\taddress, o_line->address);\n\t\treturn -1;\n\t}\n\tast_test_status_update(test, \"SDP o-line is as expected!\\n\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 17}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225_SeqOfH225GenericData (OOCTXT* pctxt, H225_SeqOfH225GenericData* pvalue)\n{\n   int stat = ASN_OK;\n   H225GenericData* pdata;\n   ASN1UINT count = 0;\n   ASN1UINT xx1;\n   int lstat;\n   dListInit (pvalue);\n   for (;;) {\n      \n      lstat = decodeLength (pctxt, &count);\n      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {\n         return lstat;\n      }\n      \n      for (xx1 = 0; xx1 < count; xx1++) {\n         invokeStartElement (pctxt, \"elem\", xx1);\n         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225GenericData);\n         stat = asn1PD_H225GenericData (pctxt, pdata);\n         if (stat != ASN_OK) return stat;\n         invokeEndElement (pctxt, \"elem\", xx1);\n         dListAppendNode (pctxt, pvalue, pdata);\n      }\n      if(lstat == ASN_OK) break;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 18}
{"project": "Asterisk", "target": 0, "func": "static int handle_saydate(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])\n{\n\tint res, num;\n\tif (argc != 4)\n\t\treturn RESULT_SHOWUSAGE;\n\tif (sscanf(argv[2], \"%30d\", &num) != 1)\n\t\treturn RESULT_SHOWUSAGE;\n\tres = ast_say_date(chan, num, argv[3], ast_channel_language(chan));\n\tif (res == 1)\n\t\treturn RESULT_SUCCESS;\n\tast_agi_send(agi->fd, chan, \"200 result=%d\\n\", res);\n\treturn (res >= 0) ? RESULT_SUCCESS : RESULT_FAILURE;\n}\n", "bug_type": null, "idx": 19}
{"project": "Asterisk", "target": 0, "func": "#endif\t\nstatic void print_facility(const struct FacParm *fac, const struct misdn_bchannel *bc)\n{\n#if defined(AST_MISDN_ENHANCEMENTS)\n\tunsigned Index;\n#endif\t\n\tswitch (fac->Function) {\n#if defined(AST_MISDN_ENHANCEMENTS)\n\tcase Fac_ActivationDiversion:\n\t\tchan_misdn_log(1, bc->port, \" --> ActivationDiversion: InvokeID:%d\\n\",\n\t\t\tfac->u.ActivationDiversion.InvokeID);\n\t\tswitch (fac->u.ActivationDiversion.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: Procedure:%d BasicService:%d\\n\",\n\t\t\t\tfac->u.ActivationDiversion.Component.Invoke.Procedure,\n\t\t\t\tfac->u.ActivationDiversion.Component.Invoke.BasicService);\n\t\t\tchan_misdn_log(1, bc->port, \" -->   ForwardedTo:\\n\");\n\t\t\tprint_facility_Address(3, &fac->u.ActivationDiversion.Component.Invoke.ForwardedTo, bc);\n\t\t\tchan_misdn_log(1, bc->port, \" -->   ServedUserNr:\\n\");\n\t\t\tprint_facility_ServedUserNr(3, &fac->u.ActivationDiversion.Component.Invoke.ServedUser, bc);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_DeactivationDiversion:\n\t\tchan_misdn_log(1, bc->port, \" --> DeactivationDiversion: InvokeID:%d\\n\",\n\t\t\tfac->u.DeactivationDiversion.InvokeID);\n\t\tswitch (fac->u.DeactivationDiversion.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: Procedure:%d BasicService:%d\\n\",\n\t\t\t\tfac->u.DeactivationDiversion.Component.Invoke.Procedure,\n\t\t\t\tfac->u.DeactivationDiversion.Component.Invoke.BasicService);\n\t\t\tchan_misdn_log(1, bc->port, \" -->   ServedUserNr:\\n\");\n\t\t\tprint_facility_ServedUserNr(3, &fac->u.DeactivationDiversion.Component.Invoke.ServedUser, bc);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_ActivationStatusNotificationDiv:\n\t\tchan_misdn_log(1, bc->port, \" --> ActivationStatusNotificationDiv: InvokeID:%d Procedure:%d BasicService:%d\\n\",\n\t\t\tfac->u.ActivationStatusNotificationDiv.InvokeID,\n\t\t\tfac->u.ActivationStatusNotificationDiv.Procedure,\n\t\t\tfac->u.ActivationStatusNotificationDiv.BasicService);\n\t\tchan_misdn_log(1, bc->port, \" -->  ForwardedTo:\\n\");\n\t\tprint_facility_Address(2, &fac->u.ActivationStatusNotificationDiv.ForwardedTo, bc);\n\t\tchan_misdn_log(1, bc->port, \" -->  ServedUserNr:\\n\");\n\t\tprint_facility_ServedUserNr(2, &fac->u.ActivationStatusNotificationDiv.ServedUser, bc);\n\t\tbreak;\n\tcase Fac_DeactivationStatusNotificationDiv:\n\t\tchan_misdn_log(1, bc->port, \" --> DeactivationStatusNotificationDiv: InvokeID:%d Procedure:%d BasicService:%d\\n\",\n\t\t\tfac->u.DeactivationStatusNotificationDiv.InvokeID,\n\t\t\tfac->u.DeactivationStatusNotificationDiv.Procedure,\n\t\t\tfac->u.DeactivationStatusNotificationDiv.BasicService);\n\t\tchan_misdn_log(1, bc->port, \" -->  ServedUserNr:\\n\");\n\t\tprint_facility_ServedUserNr(2, &fac->u.DeactivationStatusNotificationDiv.ServedUser, bc);\n\t\tbreak;\n\tcase Fac_InterrogationDiversion:\n\t\tchan_misdn_log(1, bc->port, \" --> InterrogationDiversion: InvokeID:%d\\n\",\n\t\t\tfac->u.InterrogationDiversion.InvokeID);\n\t\tswitch (fac->u.InterrogationDiversion.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: Procedure:%d BasicService:%d\\n\",\n\t\t\t\tfac->u.InterrogationDiversion.Component.Invoke.Procedure,\n\t\t\t\tfac->u.InterrogationDiversion.Component.Invoke.BasicService);\n\t\t\tchan_misdn_log(1, bc->port, \" -->   ServedUserNr:\\n\");\n\t\t\tprint_facility_ServedUserNr(3, &fac->u.InterrogationDiversion.Component.Invoke.ServedUser, bc);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result:\\n\");\n\t\t\tif (fac->u.InterrogationDiversion.Component.Result.NumRecords) {\n\t\t\t\tfor (Index = 0; Index < fac->u.InterrogationDiversion.Component.Result.NumRecords; ++Index) {\n\t\t\t\t\tchan_misdn_log(1, bc->port, \" -->   IntResult[%d]:\\n\", Index);\n\t\t\t\t\tprint_facility_IntResult(3, &fac->u.InterrogationDiversion.Component.Result.List[Index], bc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_DiversionInformation:\n\t\tchan_misdn_log(1, bc->port, \" --> DiversionInformation: InvokeID:%d Reason:%d BasicService:%d\\n\",\n\t\t\tfac->u.DiversionInformation.InvokeID,\n\t\t\tfac->u.DiversionInformation.DiversionReason,\n\t\t\tfac->u.DiversionInformation.BasicService);\n\t\tif (fac->u.DiversionInformation.ServedUserSubaddress.Length) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  ServedUserSubaddress:\\n\");\n\t\t\tprint_facility_Subaddress(2, &fac->u.DiversionInformation.ServedUserSubaddress, bc);\n\t\t}\n\t\tif (fac->u.DiversionInformation.CallingAddressPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  CallingAddress:\\n\");\n\t\t\tprint_facility_PresentedAddressScreened(2, &fac->u.DiversionInformation.CallingAddress, bc);\n\t\t}\n\t\tif (fac->u.DiversionInformation.OriginalCalledPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  OriginalCalledNr:\\n\");\n\t\t\tprint_facility_PresentedNumberUnscreened(2, &fac->u.DiversionInformation.OriginalCalled, bc);\n\t\t}\n\t\tif (fac->u.DiversionInformation.LastDivertingPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  LastDivertingNr:\\n\");\n\t\t\tprint_facility_PresentedNumberUnscreened(2, &fac->u.DiversionInformation.LastDiverting, bc);\n\t\t}\n\t\tif (fac->u.DiversionInformation.LastDivertingReasonPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  LastDivertingReason:%d\\n\", fac->u.DiversionInformation.LastDivertingReason);\n\t\t}\n\t\tif (fac->u.DiversionInformation.UserInfo.Length) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  UserInfo Length:%d\\n\", fac->u.DiversionInformation.UserInfo.Length);\n\t\t}\n\t\tbreak;\n\tcase Fac_CallDeflection:\n\t\tchan_misdn_log(1, bc->port, \" --> CallDeflection: InvokeID:%d\\n\",\n\t\t\tfac->u.CallDeflection.InvokeID);\n\t\tswitch (fac->u.CallDeflection.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke:\\n\");\n\t\t\tif (fac->u.CallDeflection.Component.Invoke.PresentationAllowedToDivertedToUserPresent) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   PresentationAllowed:%d\\n\",\n\t\t\t\t\tfac->u.CallDeflection.Component.Invoke.PresentationAllowedToDivertedToUser);\n\t\t\t}\n\t\t\tchan_misdn_log(1, bc->port, \" -->   DeflectionAddress:\\n\");\n\t\t\tprint_facility_Address(3, &fac->u.CallDeflection.Component.Invoke.Deflection, bc);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CallRerouteing:\n\t\tchan_misdn_log(1, bc->port, \" --> CallRerouteing: InvokeID:%d\\n\",\n\t\t\tfac->u.CallRerouteing.InvokeID);\n\t\tswitch (fac->u.CallRerouteing.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: Reason:%d Counter:%d\\n\",\n\t\t\t\tfac->u.CallRerouteing.Component.Invoke.ReroutingReason,\n\t\t\t\tfac->u.CallRerouteing.Component.Invoke.ReroutingCounter);\n\t\t\tchan_misdn_log(1, bc->port, \" -->   CalledAddress:\\n\");\n\t\t\tprint_facility_Address(3, &fac->u.CallRerouteing.Component.Invoke.CalledAddress, bc);\n\t\t\tprint_facility_Q931_Bc_Hlc_Llc_Uu(2, &fac->u.CallRerouteing.Component.Invoke.Q931ie, bc);\n\t\t\tchan_misdn_log(1, bc->port, \" -->   LastReroutingNr:\\n\");\n\t\t\tprint_facility_PresentedNumberUnscreened(3, &fac->u.CallRerouteing.Component.Invoke.LastRerouting, bc);\n\t\t\tchan_misdn_log(1, bc->port, \" -->   SubscriptionOption:%d\\n\",\n\t\t\t\tfac->u.CallRerouteing.Component.Invoke.SubscriptionOption);\n\t\t\tif (fac->u.CallRerouteing.Component.Invoke.CallingPartySubaddress.Length) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   CallingParty:\\n\");\n\t\t\t\tprint_facility_Subaddress(3, &fac->u.CallRerouteing.Component.Invoke.CallingPartySubaddress, bc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_InterrogateServedUserNumbers:\n\t\tchan_misdn_log(1, bc->port, \" --> InterrogateServedUserNumbers: InvokeID:%d\\n\",\n\t\t\tfac->u.InterrogateServedUserNumbers.InvokeID);\n\t\tswitch (fac->u.InterrogateServedUserNumbers.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke\\n\");\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result:\\n\");\n\t\t\tif (fac->u.InterrogateServedUserNumbers.Component.Result.NumRecords) {\n\t\t\t\tfor (Index = 0; Index < fac->u.InterrogateServedUserNumbers.Component.Result.NumRecords; ++Index) {\n\t\t\t\t\tchan_misdn_log(1, bc->port, \" -->   ServedUserNr[%d]:\\n\", Index);\n\t\t\t\t\tprint_facility_PartyNumber(3, &fac->u.InterrogateServedUserNumbers.Component.Result.List[Index], bc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_DivertingLegInformation1:\n\t\tchan_misdn_log(1, bc->port, \" --> DivertingLegInformation1: InvokeID:%d Reason:%d SubscriptionOption:%d\\n\",\n\t\t\tfac->u.DivertingLegInformation1.InvokeID,\n\t\t\tfac->u.DivertingLegInformation1.DiversionReason,\n\t\t\tfac->u.DivertingLegInformation1.SubscriptionOption);\n\t\tif (fac->u.DivertingLegInformation1.DivertedToPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  DivertedToNr:\\n\");\n\t\t\tprint_facility_PresentedNumberUnscreened(2, &fac->u.DivertingLegInformation1.DivertedTo, bc);\n\t\t}\n\t\tbreak;\n\tcase Fac_DivertingLegInformation2:\n\t\tchan_misdn_log(1, bc->port, \" --> DivertingLegInformation2: InvokeID:%d Reason:%d Count:%d\\n\",\n\t\t\tfac->u.DivertingLegInformation2.InvokeID,\n\t\t\tfac->u.DivertingLegInformation2.DiversionReason,\n\t\t\tfac->u.DivertingLegInformation2.DiversionCounter);\n\t\tif (fac->u.DivertingLegInformation2.DivertingPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  DivertingNr:\\n\");\n\t\t\tprint_facility_PresentedNumberUnscreened(2, &fac->u.DivertingLegInformation2.Diverting, bc);\n\t\t}\n\t\tif (fac->u.DivertingLegInformation2.OriginalCalledPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  OriginalCalledNr:\\n\");\n\t\t\tprint_facility_PresentedNumberUnscreened(2, &fac->u.DivertingLegInformation2.OriginalCalled, bc);\n\t\t}\n\t\tbreak;\n\tcase Fac_DivertingLegInformation3:\n\t\tchan_misdn_log(1, bc->port, \" --> DivertingLegInformation3: InvokeID:%d PresentationAllowed:%d\\n\",\n\t\t\tfac->u.DivertingLegInformation3.InvokeID,\n\t\t\tfac->u.DivertingLegInformation3.PresentationAllowedIndicator);\n\t\tbreak;\n#else\t\n\tcase Fac_CD:\n\t\tchan_misdn_log(1, bc->port, \" --> calldeflect to: %s, presentable: %s\\n\", fac->u.CDeflection.DeflectedToNumber,\n\t\t\tfac->u.CDeflection.PresentationAllowed ? \"yes\" : \"no\");\n\t\tbreak;\n#endif\t\n\tcase Fac_AOCDCurrency:\n\t\tif (fac->u.AOCDcur.chargeNotAvailable) {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD currency: charge not available\\n\");\n\t\t} else if (fac->u.AOCDcur.freeOfCharge) {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD currency: free of charge\\n\");\n\t\t} else if (fac->u.AOCDchu.billingId >= 0) {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD currency: currency:%s amount:%d multiplier:%d typeOfChargingInfo:%s billingId:%d\\n\",\n\t\t\t\tfac->u.AOCDcur.currency, fac->u.AOCDcur.currencyAmount, fac->u.AOCDcur.multiplier,\n\t\t\t\t(fac->u.AOCDcur.typeOfChargingInfo == 0) ? \"subTotal\" : \"total\", fac->u.AOCDcur.billingId);\n\t\t} else {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD currency: currency:%s amount:%d multiplier:%d typeOfChargingInfo:%s\\n\",\n\t\t\t\tfac->u.AOCDcur.currency, fac->u.AOCDcur.currencyAmount, fac->u.AOCDcur.multiplier,\n\t\t\t\t(fac->u.AOCDcur.typeOfChargingInfo == 0) ? \"subTotal\" : \"total\");\n\t\t}\n\t\tbreak;\n\tcase Fac_AOCDChargingUnit:\n\t\tif (fac->u.AOCDchu.chargeNotAvailable) {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD charging unit: charge not available\\n\");\n\t\t} else if (fac->u.AOCDchu.freeOfCharge) {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD charging unit: free of charge\\n\");\n\t\t} else if (fac->u.AOCDchu.billingId >= 0) {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD charging unit: recordedUnits:%d typeOfChargingInfo:%s billingId:%d\\n\",\n\t\t\t\tfac->u.AOCDchu.recordedUnits, (fac->u.AOCDchu.typeOfChargingInfo == 0) ? \"subTotal\" : \"total\", fac->u.AOCDchu.billingId);\n\t\t} else {\n\t\t\tchan_misdn_log(1, bc->port, \" --> AOCD charging unit: recordedUnits:%d typeOfChargingInfo:%s\\n\",\n\t\t\t\tfac->u.AOCDchu.recordedUnits, (fac->u.AOCDchu.typeOfChargingInfo == 0) ? \"subTotal\" : \"total\");\n\t\t}\n\t\tbreak;\n#if defined(AST_MISDN_ENHANCEMENTS)\n\tcase Fac_ERROR:\n\t\tchan_misdn_log(1, bc->port, \" --> ERROR: InvokeID:%d, Code:0x%02x\\n\",\n\t\t\tfac->u.ERROR.invokeId, fac->u.ERROR.errorValue);\n\t\tbreak;\n\tcase Fac_RESULT:\n\t\tchan_misdn_log(1, bc->port, \" --> RESULT: InvokeID:%d\\n\",\n\t\t\tfac->u.RESULT.InvokeID);\n\t\tbreak;\n\tcase Fac_REJECT:\n\t\tif (fac->u.REJECT.InvokeIDPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" --> REJECT: InvokeID:%d, Code:0x%02x\\n\",\n\t\t\t\tfac->u.REJECT.InvokeID, fac->u.REJECT.Code);\n\t\t} else {\n\t\t\tchan_misdn_log(1, bc->port, \" --> REJECT: Code:0x%02x\\n\",\n\t\t\t\tfac->u.REJECT.Code);\n\t\t}\n\t\tbreak;\n\tcase Fac_EctExecute:\n\t\tchan_misdn_log(1, bc->port, \" --> EctExecute: InvokeID:%d\\n\",\n\t\t\tfac->u.EctExecute.InvokeID);\n\t\tbreak;\n\tcase Fac_ExplicitEctExecute:\n\t\tchan_misdn_log(1, bc->port, \" --> ExplicitEctExecute: InvokeID:%d LinkID:%d\\n\",\n\t\t\tfac->u.ExplicitEctExecute.InvokeID,\n\t\t\tfac->u.ExplicitEctExecute.LinkID);\n\t\tbreak;\n\tcase Fac_RequestSubaddress:\n\t\tchan_misdn_log(1, bc->port, \" --> RequestSubaddress: InvokeID:%d\\n\",\n\t\t\tfac->u.RequestSubaddress.InvokeID);\n\t\tbreak;\n\tcase Fac_SubaddressTransfer:\n\t\tchan_misdn_log(1, bc->port, \" --> SubaddressTransfer: InvokeID:%d\\n\",\n\t\t\tfac->u.SubaddressTransfer.InvokeID);\n\t\tprint_facility_Subaddress(1, &fac->u.SubaddressTransfer.Subaddress, bc);\n\t\tbreak;\n\tcase Fac_EctLinkIdRequest:\n\t\tchan_misdn_log(1, bc->port, \" --> EctLinkIdRequest: InvokeID:%d\\n\",\n\t\t\tfac->u.EctLinkIdRequest.InvokeID);\n\t\tswitch (fac->u.EctLinkIdRequest.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke\\n\");\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: LinkID:%d\\n\",\n\t\t\t\tfac->u.EctLinkIdRequest.Component.Result.LinkID);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_EctInform:\n\t\tchan_misdn_log(1, bc->port, \" --> EctInform: InvokeID:%d Status:%d\\n\",\n\t\t\tfac->u.EctInform.InvokeID,\n\t\t\tfac->u.EctInform.Status);\n\t\tif (fac->u.EctInform.RedirectionPresent) {\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Redirection Number\\n\");\n\t\t\tprint_facility_PresentedNumberUnscreened(2, &fac->u.EctInform.Redirection, bc);\n\t\t}\n\t\tbreak;\n\tcase Fac_EctLoopTest:\n\t\tchan_misdn_log(1, bc->port, \" --> EctLoopTest: InvokeID:%d\\n\",\n\t\t\tfac->u.EctLoopTest.InvokeID);\n\t\tswitch (fac->u.EctLoopTest.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: CallTransferID:%d\\n\",\n\t\t\t\tfac->u.EctLoopTest.Component.Invoke.CallTransferID);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: LoopResult:%d\\n\",\n\t\t\t\tfac->u.EctLoopTest.Component.Result.LoopResult);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_StatusRequest:\n\t\tchan_misdn_log(1, bc->port, \" --> StatusRequest: InvokeID:%d\\n\",\n\t\t\tfac->u.StatusRequest.InvokeID);\n\t\tswitch (fac->u.StatusRequest.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: Compatibility:%d\\n\",\n\t\t\t\tfac->u.StatusRequest.Component.Invoke.CompatibilityMode);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: Status:%d\\n\",\n\t\t\t\tfac->u.StatusRequest.Component.Result.Status);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CallInfoRetain:\n\t\tchan_misdn_log(1, bc->port, \" --> CallInfoRetain: InvokeID:%d, LinkageID:%d\\n\",\n\t\t\tfac->u.CallInfoRetain.InvokeID, fac->u.CallInfoRetain.CallLinkageID);\n\t\tbreak;\n\tcase Fac_CCBSDeactivate:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSDeactivate: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBSDeactivate.InvokeID);\n\t\tswitch (fac->u.CCBSDeactivate.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: CCBSReference:%d\\n\",\n\t\t\t\tfac->u.CCBSDeactivate.Component.Invoke.CCBSReference);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CCBSErase:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSErase: InvokeID:%d, CCBSReference:%d RecallMode:%d, Reason:%d\\n\",\n\t\t\tfac->u.CCBSErase.InvokeID, fac->u.CCBSErase.CCBSReference,\n\t\t\tfac->u.CCBSErase.RecallMode, fac->u.CCBSErase.Reason);\n\t\tchan_misdn_log(1, bc->port, \" -->  AddressOfB\\n\");\n\t\tprint_facility_Address(2, &fac->u.CCBSErase.AddressOfB, bc);\n\t\tprint_facility_Q931_Bc_Hlc_Llc(1, &fac->u.CCBSErase.Q931ie, bc);\n\t\tbreak;\n\tcase Fac_CCBSRemoteUserFree:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSRemoteUserFree: InvokeID:%d, CCBSReference:%d RecallMode:%d\\n\",\n\t\t\tfac->u.CCBSRemoteUserFree.InvokeID, fac->u.CCBSRemoteUserFree.CCBSReference,\n\t\t\tfac->u.CCBSRemoteUserFree.RecallMode);\n\t\tchan_misdn_log(1, bc->port, \" -->  AddressOfB\\n\");\n\t\tprint_facility_Address(2, &fac->u.CCBSRemoteUserFree.AddressOfB, bc);\n\t\tprint_facility_Q931_Bc_Hlc_Llc(1, &fac->u.CCBSRemoteUserFree.Q931ie, bc);\n\t\tbreak;\n\tcase Fac_CCBSCall:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSCall: InvokeID:%d, CCBSReference:%d\\n\",\n\t\t\tfac->u.CCBSCall.InvokeID, fac->u.CCBSCall.CCBSReference);\n\t\tbreak;\n\tcase Fac_CCBSStatusRequest:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSStatusRequest: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBSStatusRequest.InvokeID);\n\t\tswitch (fac->u.CCBSStatusRequest.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: CCBSReference:%d RecallMode:%d\\n\",\n\t\t\t\tfac->u.CCBSStatusRequest.Component.Invoke.CCBSReference,\n\t\t\t\tfac->u.CCBSStatusRequest.Component.Invoke.RecallMode);\n\t\t\tprint_facility_Q931_Bc_Hlc_Llc(2, &fac->u.CCBSStatusRequest.Component.Invoke.Q931ie, bc);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: Free:%d\\n\",\n\t\t\t\tfac->u.CCBSStatusRequest.Component.Result.Free);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CCBSBFree:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSBFree: InvokeID:%d, CCBSReference:%d RecallMode:%d\\n\",\n\t\t\tfac->u.CCBSBFree.InvokeID, fac->u.CCBSBFree.CCBSReference,\n\t\t\tfac->u.CCBSBFree.RecallMode);\n\t\tchan_misdn_log(1, bc->port, \" -->  AddressOfB\\n\");\n\t\tprint_facility_Address(2, &fac->u.CCBSBFree.AddressOfB, bc);\n\t\tprint_facility_Q931_Bc_Hlc_Llc(1, &fac->u.CCBSBFree.Q931ie, bc);\n\t\tbreak;\n\tcase Fac_EraseCallLinkageID:\n\t\tchan_misdn_log(1, bc->port, \" --> EraseCallLinkageID: InvokeID:%d, LinkageID:%d\\n\",\n\t\t\tfac->u.EraseCallLinkageID.InvokeID, fac->u.EraseCallLinkageID.CallLinkageID);\n\t\tbreak;\n\tcase Fac_CCBSStopAlerting:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSStopAlerting: InvokeID:%d, CCBSReference:%d\\n\",\n\t\t\tfac->u.CCBSStopAlerting.InvokeID, fac->u.CCBSStopAlerting.CCBSReference);\n\t\tbreak;\n\tcase Fac_CCBSRequest:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSRequest: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBSRequest.InvokeID);\n\t\tswitch (fac->u.CCBSRequest.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: LinkageID:%d\\n\",\n\t\t\t\tfac->u.CCBSRequest.Component.Invoke.CallLinkageID);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: CCBSReference:%d RecallMode:%d\\n\",\n\t\t\t\tfac->u.CCBSRequest.Component.Result.CCBSReference,\n\t\t\t\tfac->u.CCBSRequest.Component.Result.RecallMode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CCBSInterrogate:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBSInterrogate: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBSInterrogate.InvokeID);\n\t\tswitch (fac->u.CCBSInterrogate.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke\\n\");\n\t\t\tif (fac->u.CCBSInterrogate.Component.Invoke.CCBSReferencePresent) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   CCBSReference:%d\\n\",\n\t\t\t\t\tfac->u.CCBSInterrogate.Component.Invoke.CCBSReference);\n\t\t\t}\n\t\t\tif (fac->u.CCBSInterrogate.Component.Invoke.AParty.LengthOfNumber) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   AParty\\n\");\n\t\t\t\tprint_facility_PartyNumber(3, &fac->u.CCBSInterrogate.Component.Invoke.AParty, bc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: RecallMode:%d\\n\",\n\t\t\t\tfac->u.CCBSInterrogate.Component.Result.RecallMode);\n\t\t\tif (fac->u.CCBSInterrogate.Component.Result.NumRecords) {\n\t\t\t\tfor (Index = 0; Index < fac->u.CCBSInterrogate.Component.Result.NumRecords; ++Index) {\n\t\t\t\t\tchan_misdn_log(1, bc->port, \" -->   CallDetails[%d]:\\n\", Index);\n\t\t\t\t\tprint_facility_CallInformation(3, &fac->u.CCBSInterrogate.Component.Result.CallDetails[Index], bc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CCNRRequest:\n\t\tchan_misdn_log(1, bc->port, \" --> CCNRRequest: InvokeID:%d\\n\",\n\t\t\tfac->u.CCNRRequest.InvokeID);\n\t\tswitch (fac->u.CCNRRequest.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke: LinkageID:%d\\n\",\n\t\t\t\tfac->u.CCNRRequest.Component.Invoke.CallLinkageID);\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: CCBSReference:%d RecallMode:%d\\n\",\n\t\t\t\tfac->u.CCNRRequest.Component.Result.CCBSReference,\n\t\t\t\tfac->u.CCNRRequest.Component.Result.RecallMode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CCNRInterrogate:\n\t\tchan_misdn_log(1, bc->port, \" --> CCNRInterrogate: InvokeID:%d\\n\",\n\t\t\tfac->u.CCNRInterrogate.InvokeID);\n\t\tswitch (fac->u.CCNRInterrogate.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke\\n\");\n\t\t\tif (fac->u.CCNRInterrogate.Component.Invoke.CCBSReferencePresent) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   CCBSReference:%d\\n\",\n\t\t\t\t\tfac->u.CCNRInterrogate.Component.Invoke.CCBSReference);\n\t\t\t}\n\t\t\tif (fac->u.CCNRInterrogate.Component.Invoke.AParty.LengthOfNumber) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   AParty\\n\");\n\t\t\t\tprint_facility_PartyNumber(3, &fac->u.CCNRInterrogate.Component.Invoke.AParty, bc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: RecallMode:%d\\n\",\n\t\t\t\tfac->u.CCNRInterrogate.Component.Result.RecallMode);\n\t\t\tif (fac->u.CCNRInterrogate.Component.Result.NumRecords) {\n\t\t\t\tfor (Index = 0; Index < fac->u.CCNRInterrogate.Component.Result.NumRecords; ++Index) {\n\t\t\t\t\tchan_misdn_log(1, bc->port, \" -->   CallDetails[%d]:\\n\", Index);\n\t\t\t\t\tprint_facility_CallInformation(3, &fac->u.CCNRInterrogate.Component.Result.CallDetails[Index], bc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CCBS_T_Call:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBS_T_Call: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBS_T_Call.InvokeID);\n\t\tbreak;\n\tcase Fac_CCBS_T_Suspend:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBS_T_Suspend: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBS_T_Suspend.InvokeID);\n\t\tbreak;\n\tcase Fac_CCBS_T_Resume:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBS_T_Resume: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBS_T_Resume.InvokeID);\n\t\tbreak;\n\tcase Fac_CCBS_T_RemoteUserFree:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBS_T_RemoteUserFree: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBS_T_RemoteUserFree.InvokeID);\n\t\tbreak;\n\tcase Fac_CCBS_T_Available:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBS_T_Available: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBS_T_Available.InvokeID);\n\t\tbreak;\n\tcase Fac_CCBS_T_Request:\n\t\tchan_misdn_log(1, bc->port, \" --> CCBS_T_Request: InvokeID:%d\\n\",\n\t\t\tfac->u.CCBS_T_Request.InvokeID);\n\t\tswitch (fac->u.CCBS_T_Request.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke\\n\");\n\t\t\tchan_misdn_log(1, bc->port, \" -->   DestinationAddress:\\n\");\n\t\t\tprint_facility_Address(3, &fac->u.CCBS_T_Request.Component.Invoke.Destination, bc);\n\t\t\tprint_facility_Q931_Bc_Hlc_Llc(2, &fac->u.CCBS_T_Request.Component.Invoke.Q931ie, bc);\n\t\t\tif (fac->u.CCBS_T_Request.Component.Invoke.RetentionSupported) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   RetentionSupported:1\\n\");\n\t\t\t}\n\t\t\tif (fac->u.CCBS_T_Request.Component.Invoke.PresentationAllowedIndicatorPresent) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   PresentationAllowed:%d\\n\",\n\t\t\t\t\tfac->u.CCBS_T_Request.Component.Invoke.PresentationAllowedIndicator);\n\t\t\t}\n\t\t\tif (fac->u.CCBS_T_Request.Component.Invoke.Originating.Party.LengthOfNumber) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   OriginatingAddress:\\n\");\n\t\t\t\tprint_facility_Address(3, &fac->u.CCBS_T_Request.Component.Invoke.Originating, bc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: RetentionSupported:%d\\n\",\n\t\t\t\tfac->u.CCBS_T_Request.Component.Result.RetentionSupported);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Fac_CCNR_T_Request:\n\t\tchan_misdn_log(1, bc->port, \" --> CCNR_T_Request: InvokeID:%d\\n\",\n\t\t\tfac->u.CCNR_T_Request.InvokeID);\n\t\tswitch (fac->u.CCNR_T_Request.ComponentType) {\n\t\tcase FacComponent_Invoke:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Invoke\\n\");\n\t\t\tchan_misdn_log(1, bc->port, \" -->   DestinationAddress:\\n\");\n\t\t\tprint_facility_Address(3, &fac->u.CCNR_T_Request.Component.Invoke.Destination, bc);\n\t\t\tprint_facility_Q931_Bc_Hlc_Llc(2, &fac->u.CCNR_T_Request.Component.Invoke.Q931ie, bc);\n\t\t\tif (fac->u.CCNR_T_Request.Component.Invoke.RetentionSupported) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   RetentionSupported:1\\n\");\n\t\t\t}\n\t\t\tif (fac->u.CCNR_T_Request.Component.Invoke.PresentationAllowedIndicatorPresent) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   PresentationAllowed:%d\\n\",\n\t\t\t\t\tfac->u.CCNR_T_Request.Component.Invoke.PresentationAllowedIndicator);\n\t\t\t}\n\t\t\tif (fac->u.CCNR_T_Request.Component.Invoke.Originating.Party.LengthOfNumber) {\n\t\t\t\tchan_misdn_log(1, bc->port, \" -->   OriginatingAddress:\\n\");\n\t\t\t\tprint_facility_Address(3, &fac->u.CCNR_T_Request.Component.Invoke.Originating, bc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FacComponent_Result:\n\t\t\tchan_misdn_log(1, bc->port, \" -->  Result: RetentionSupported:%d\\n\",\n\t\t\t\tfac->u.CCNR_T_Request.Component.Result.RetentionSupported);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif\t\n\tcase Fac_None:\n\t\t\n\t\tbreak;\n\tdefault:\n\t\tchan_misdn_log(1, bc->port, \" --> unknown facility\\n\");\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 20}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void table_configs_free(void)\n{\n\tstruct ldap_table_config *c;\n\twhile ((c = AST_LIST_REMOVE_HEAD(&table_configs, entry))) {\n\t\tif (c->table_name) {\n\t\t\tast_free(c->table_name);\n\t\t}\n\t\tif (c->additional_filter) {\n\t\t\tast_free(c->additional_filter);\n\t\t}\n\t\tif (c->attributes) {\n\t\t\tast_variables_destroy(c->attributes);\n\t\t}\n\t\tast_free(c);\n\t}\n\tbase_table_config = NULL;\n\tstatic_table_config = NULL;\n}\n", "bug_type": null, "idx": 21}
{"project": "Asterisk", "target": 0, "func": "const char *ast_channel_get_role_option(struct ast_channel *channel, const char *role_name, const char *option)\n{\n\tstruct bridge_role *role;\n\tstruct bridge_role_option *role_option;\n\trole = get_role_from_channel(channel, role_name);\n\tif (!role) {\n\t\treturn NULL;\n\t}\n\trole_option = get_role_option(role, option);\n\treturn role_option ? role_option->value : NULL;\n}\n", "bug_type": null, "idx": 22}
{"project": "Asterisk", "target": 0, "func": "static int usage(const char *argv0)\n{\n\tfprintf(stderr, \"Usage: %s [--enable <option>] [--disable <option>]\\n\", argv0);\n\tfprintf(stderr, \"   [--enable-category <category>] [--enable-all]\\n\");\n\tfprintf(stderr, \"   [--disable-category <category>] [--disable-all] [...]\\n\");\n\tfprintf(stderr, \"   [<config-file> [...]]\\n\");\n\tfprintf(stderr, \"Usage: %s { --check-deps | --list-options\\n\", argv0);\n\tfprintf(stderr, \"   | --list-category <category> | --category-list | --help }\\n\");\n\tfprintf(stderr, \"   [<config-file> [...]]\\n\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 23}
{"project": "Asterisk", "target": 0, "func": "#define mohclass_unref(class,string) _mohclass_unref(class, string, __FILE__,__LINE__,__PRETTY_FUNCTION__)\nstatic struct mohclass *_mohclass_unref(struct mohclass *class, const char *tag, const char *file, int line, const char *funcname)\n{\n\tstruct mohclass *dup = ao2_callback(mohclasses, OBJ_POINTER, ao2_match_by_addr, class);\n\tif (dup) {\n\t\tif (__ao2_ref(dup, -1, tag, file, line, funcname) == 2) {\n\t\t\tast_log(LOG_WARNING, \"Attempt to unref mohclass %p (%s) when only 1 ref remained, and class is still in a container! (at %s:%d (%s))\\n\",\n\t\t\t\tclass, class->name, file, line, funcname);\n\t\t} else {\n\t\t\tao2_ref(class, -1);\n\t\t}\n\t} else {\n\t\t__ao2_ref(class, -1, tag, file, line, funcname);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 24}
{"project": "Asterisk", "target": 0, "func": "\nstatic int unistim_sendtext(struct ast_channel *ast, const char *text)\n{\n\tstruct unistimsession *pte = channel_to_session(ast);\n\tint size;\n\tchar tmp[TEXT_LENGTH_MAX + 1];\n\tif (unistimdebug) {\n\t\tast_verb(0, \"unistim_sendtext called\\n\");\n\t}\n\tif (!text) {\n\t\tast_log(LOG_WARNING, \"unistim_sendtext called with a null text\\n\");\n\t\treturn -1;\n\t}\n\tif (!pte) {\n\t\treturn -1;\n\t}\n\tsize = strlen(text);\n\tif (text[0] == '@') {\n\t\tint pos = 0, i = 1, tok = 0, sz = 0;\n\t\tchar label[11];\n\t\tchar number[16];\n\t\tchar icon = '\\0';\n\t\tchar cur = '\\0';\n\t\tmemset(label, 0, 11);\n\t\tmemset(number, 0, 16);\n\t\twhile (text[i]) {\n\t\t\tcur = text[i++];\n\t\t\tswitch (tok) {\n\t\t\tcase 0:\n\t\t\t\tif ((cur < '0') && (cur > '5')) {\n\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"sendtext failed : position must be a number beetween 0 and 5\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tpos = cur - '0';\n\t\t\t\ttok = 1;\n\t\t\t\tcontinue;\n\t\t\tcase 1:\n\t\t\t\tif (cur != '@') {\n\t\t\t\t\tast_log(LOG_WARNING, \"sendtext failed : invalid position\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ttok = 2;\n\t\t\t\tcontinue;\n\t\t\tcase 2:\n\t\t\t\tif ((cur < '3') && (cur > '6')) {\n\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"sendtext failed : icon must be a number beetween 32 and 63 (first digit invalid)\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ticon = (cur - '0') * 10;\n\t\t\t\ttok = 3;\n\t\t\t\tcontinue;\n\t\t\tcase 3:\n\t\t\t\tif ((cur < '0') && (cur > '9')) {\n\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"sendtext failed : icon must be a number beetween 32 and 63 (second digit invalid)\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ticon += (cur - '0');\n\t\t\t\ttok = 4;\n\t\t\t\tcontinue;\n\t\t\tcase 4:\n\t\t\t\tif (cur != '@') {\n\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"sendtext failed : icon must be a number beetween 32 and 63 (too many digits)\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ttok = 5;\n\t\t\t\tcontinue;\n\t\t\tcase 5:\n\t\t\t\tif (cur == '@') {\n\t\t\t\t\ttok = 6;\n\t\t\t\t\tsz = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sz > 10) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlabel[sz] = cur;\n\t\t\t\tsz++;\n\t\t\t\tcontinue;\n\t\t\tcase 6:\n\t\t\t\tif (sz > 15) {\n\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"sendtext failed : extension too long = %d (15 car max)\\n\",\n\t\t\t\t\t\t\tsz);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tnumber[sz] = cur;\n\t\t\t\tsz++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (tok != 6) {\n\t\t\tast_log(LOG_WARNING, \"sendtext failed : incomplet command\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (!pte->device) {\n\t\t\tast_log(LOG_WARNING, \"sendtext failed : no device ?\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tstrcpy(pte->device->softkeylabel[pos], label);\n\t\tstrcpy(pte->device->softkeynumber[pos], number);\n\t\tpte->device->softkeyicon[pos] = icon;\n\t\tsend_favorite(pos, icon, pte, label);\n\t\treturn 0;\n\t}\n\tif (size <= TEXT_LENGTH_MAX * 2) {\n\t\tif (pte->device->height == 1) {\n\t\t\tsend_text(TEXT_LINE0, TEXT_NORMAL, pte, text);\n\t\t} else {\n\t\t\tsend_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext(\"Message :\", pte));\n\t\t\tsend_text(TEXT_LINE1, TEXT_NORMAL, pte, text);\n\t\t}\n\t\tif (size <= TEXT_LENGTH_MAX) {\n\t\t\tsend_text(TEXT_LINE2, TEXT_NORMAL, pte, \"\");\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(tmp, text + TEXT_LENGTH_MAX, TEXT_LENGTH_MAX);\n\t\ttmp[sizeof(tmp) - 1] = '\\0';\n\t\tsend_text(TEXT_LINE2, TEXT_NORMAL, pte, tmp);\n\t\treturn 0;\n\t}\n\tsend_text(TEXT_LINE0, TEXT_NORMAL, pte, text);\n\tmemcpy(tmp, text + TEXT_LENGTH_MAX, TEXT_LENGTH_MAX);\n\ttmp[sizeof(tmp) - 1] = '\\0';\n\tsend_text(TEXT_LINE1, TEXT_NORMAL, pte, tmp);\n\tmemcpy(tmp, text + TEXT_LENGTH_MAX * 2, TEXT_LENGTH_MAX);\n\ttmp[sizeof(tmp) - 1] = '\\0';\n\tsend_text(TEXT_LINE2, TEXT_NORMAL, pte, tmp);\n\treturn 0;\n}\n", "bug_type": null, "idx": 25}
{"project": "Asterisk", "target": 0, "func": " */\nstatic LDAPMod **massage_mods_for_entry(LDAPMessage *entry, LDAPMod **mods)\n{\n\tsize_t k, i, remove_count;\n\tLDAPMod **copies;\n\tfor (i = remove_count = 0; mods[i]; i++) {\n\t\tif (mods[i]->mod_op == LDAP_MOD_DELETE\n\t\t\t&& !ldap_entry_has_attribute(entry, mods[i]->mod_type)) {\n\t\t\tremove_count++;\n\t\t}\n\t}\n\tif (!remove_count) {\n\t\treturn NULL;\n\t}\n\tcopies = ldap_memcalloc(i - remove_count + 1, sizeof(LDAPMod *));\n\tif (!copies) {\n\t\tast_log(LOG_ERROR, \"Memory allocation failure massaging LDAP modification\\n\");\n\t\treturn NULL;\n\t}\n\tfor (i = k = 0; mods[i]; i++) {\n\t\tif (mods[i]->mod_op != LDAP_MOD_DELETE\n\t\t\t|| ldap_entry_has_attribute(entry, mods[i]->mod_type)) {\n\t\t\tcopies[k] = ldap_mod_duplicate(mods[i]);\n\t\t\tif (!copies[k]) {\n\t\t\t\tast_log(LOG_ERROR, \"Memory allocation failure massaging LDAP modification\\n\");\n\t\t\t\tldap_mods_free(copies, 1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tk++;\n\t\t} else {\n\t\t\tast_debug(3, \"Skipping %s deletion because it doesn't exist\\n\",\n\t\t\t\t\tmods[i]->mod_type);\n\t\t}\n\t}\n\treturn copies;\n}\n", "bug_type": null, "idx": 26}
{"project": "Asterisk", "target": 0, "func": "static void _fill_defaults (void)\n{\n\tint i;\n\tfor (i = 0; i < NUM_PORT_ELEMENTS; ++i) {\n\t\tif (!port_cfg[0][i].any && strcasecmp(port_spec[i].def, NO_DEFAULT))\n\t\t\t_parse(&(port_cfg[0][i]), (char *)port_spec[i].def, port_spec[i].type, port_spec[i].boolint_def);\n\t}\n\tfor (i = 0; i < NUM_GEN_ELEMENTS; ++i) {\n\t\tif (!general_cfg[i].any && strcasecmp(gen_spec[i].def, NO_DEFAULT))\n\t\t\t_parse(&(general_cfg[i]), (char *)gen_spec[i].def, gen_spec[i].type, gen_spec[i].boolint_def);\n\t}\n}\n", "bug_type": null, "idx": 27}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_mutex_lock(&config_lock);\n\tao2_callback(databases, OBJ_MULTIPLE | OBJ_NODATA | OBJ_UNLINK, stop_batch_cb, NULL);\n\tao2_ref(databases, -1);\n\tdatabases = NULL;\n\tast_config_engine_deregister(&sqlite3_config_engine);\n\tast_mutex_unlock(&config_lock);\n\treturn 0;\n}\n", "bug_type": null, "idx": 28}
{"project": "Asterisk", "target": 0, "func": "enum ast_presence_state ast_presence_state_val(const char *val)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_LEN(state2string); i++) {\n\t\tif (!strcasecmp(val, state2string[i].string)) {\n\t\t\treturn state2string[i].state;\n\t\t}\n\t}\n\treturn AST_PRESENCE_INVALID;\n}\n", "bug_type": null, "idx": 29}
{"project": "Asterisk", "target": 0, "func": "char *ast_sip_cli_traverse_objects(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tRAII_VAR(struct ao2_container *, container, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_sip_cli_formatter_entry *, formatter_entry, NULL, ao2_cleanup);\n\tRAII_VAR(void *, object, NULL, ao2_cleanup);\n\tint is_container = 0;\n\tconst char *cmd1;\n\tconst char *cmd2;\n\tconst char *object_id;\n\tchar formatter_type[64];\n\tconst char *regex;\n\tstruct ast_sip_cli_context context = {\n\t\t.indent_level = 0,\n\t\t.show_details = 0,\n\t\t.show_details_only_level_0 = 0,\n\t\t.recurse = 0,\n\t};\n\tif (cmd == CLI_INIT) {\n\t\treturn NULL;\n\t}\n\tcmd1 = e->cmda[1];\n\tcmd2 = e->cmda[2];\n\tobject_id = a->argv[3];\n\tif (!ast_ends_with(cmd2, \"s\")) {\n\t\tast_copy_string(formatter_type, cmd2, sizeof(formatter_type));\n\t\tis_container = 0;\n\t} else if (ast_ends_with(cmd2, \"ies\")) {\n\t\t\n\t\tint l = strlen(cmd2);\n\t\tsnprintf(formatter_type, 64, \"%*.*sy\", l - 3, l - 3, cmd2);\n\t\tis_container = 1;\n\t} else {\n\t\t\n\t\tast_copy_string(formatter_type, cmd2, strlen(cmd2));\n\t\tis_container = 1;\n\t}\n\tif (!strcmp(cmd1, \"show\")) {\n\t\tcontext.show_details_only_level_0 = !is_container;\n\t\tcontext.recurse = 1;\n\t} else {\n\t\tis_container = 1;\n\t}\n\tif (cmd != CLI_GENERATE\n\t\t&& is_container\n\t\t&& a->argc >= 4\n\t\t&& strcmp(object_id, \"like\") == 0) {\n\t\tif (ast_strlen_zero(a->argv[4])) {\n\t\t\treturn CLI_SHOWUSAGE;\n\t\t}\n\t\tregex = a->argv[4];\n\t} else {\n\t\tregex = \"\";\n\t}\n\tif (cmd == CLI_GENERATE\n\t\t&& (is_container\n\t\t\t|| a->argc > 4\n\t\t\t|| (a->argc == 4 && ast_strlen_zero(a->word)))) {\n\t\treturn CLI_SUCCESS;\n\t}\n\tcontext.output_buffer = ast_str_create(256);\n\tif (!context.output_buffer) {\n\t\treturn CLI_FAILURE;\n\t}\n\tformatter_entry = ast_sip_lookup_cli_formatter(formatter_type);\n\tif (!formatter_entry) {\n\t\tast_log(LOG_ERROR, \"No formatter registered for object type %s.\\n\",\n\t\t\tformatter_type);\n\t\tast_free(context.output_buffer);\n\t\treturn CLI_FAILURE;\n\t}\n\tast_str_append(&context.output_buffer, 0, \"\\n\");\n\tformatter_entry->print_header(NULL, &context, 0);\n\tast_str_append(&context.output_buffer, 0,\n\t\t\"==========================================================================================\\n\\n\");\n\tif (is_container || cmd == CLI_GENERATE) {\n\t\tcontainer = formatter_entry->get_container(regex);\n\t\tif (!container) {\n\t\t\tast_cli(a->fd, \"No container returned for object type %s.\\n\",\n\t\t\t\tformatter_type);\n\t\t\tast_free(context.output_buffer);\n\t\t\treturn CLI_FAILURE;\n\t\t}\n\t}\n\tif (cmd == CLI_GENERATE) {\n\t\tast_free(context.output_buffer);\n\t\treturn complete_show_sorcery_object(container, formatter_entry, a->word, a->n);\n\t}\n\tif (is_container) {\n\t\tif (!ao2_container_count(container)) {\n\t\t\tast_free(context.output_buffer);\n\t\t\tast_cli(a->fd, \"No objects found.\\n\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t\tao2_callback(container, OBJ_NODATA, formatter_entry->print_body, &context);\n\t\tast_str_append(&context.output_buffer, 0, \"\\nObjects found: %d\\n\", ao2_container_count(container));\n\t} else {\n\t\tif (ast_strlen_zero(object_id)) {\n\t\t\tast_free(context.output_buffer);\n\t\t\tast_cli(a->fd, \"No object specified.\\n\");\n\t\t\treturn CLI_FAILURE;\n\t\t}\n\t\tobject = formatter_entry->retrieve_by_id(object_id);\n\t\tif (!object) {\n\t\t\tast_free(context.output_buffer);\n\t\t\tast_cli(a->fd, \"Unable to find object %s.\\n\\n\", object_id);\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t\tformatter_entry->print_body(object, &context, 0);\n\t}\n\tast_str_append(&context.output_buffer, 0, \"\\n\");\n\tdump_str_and_free(a->fd, context.output_buffer);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 30}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_appl_set(struct ast_channel *chan, const char *value)\n{\n\tchan->appl = value;\n}\n", "bug_type": null, "idx": 31}
{"project": "Asterisk", "target": 0, "func": "int ast_cc_monitor_party_b_free(int core_id)\n{\n\tint res;\n\tstruct cc_core_instance *core_instance = find_cc_core_instance(core_id);\n\tif (!core_instance) {\n\t\treturn -1;\n\t}\n\tres = ast_taskprocessor_push(cc_core_taskprocessor, cc_party_b_free, core_instance);\n\tif (res) {\n\t\tcc_unref(core_instance, \"Unref core instance. ast_taskprocessor_push failed\");\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 32}
{"project": "Asterisk", "target": 0, "func": "\nstatic int lintoalaw_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tint i = f->samples;\n\tchar *dst = pvt->outbuf.c + pvt->samples;\n\tint16_t *src = f->data.ptr;\n\tpvt->samples += i;\n\tpvt->datalen += i;\t\n\twhile (i--) \n\t\t*dst++ = AST_LIN2A(*src++);\n\treturn 0;\n}\n", "bug_type": null, "idx": 33}
{"project": "Asterisk", "target": 0, "func": "static struct ast_channel *oss_request(const char *type, struct ast_format_cap *cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause)\n{\n\tstruct ast_channel *c;\n\tstruct chan_oss_pvt *o;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(name);\n\t\tAST_APP_ARG(flags);\n\t);\n\tchar *parse = ast_strdupa(data);\n\tAST_NONSTANDARD_APP_ARGS(args, parse, '/');\n\to = find_desc(args.name);\n\tast_log(LOG_WARNING, \"oss_request ty <%s> data 0x%p <%s>\\n\", type, data, data);\n\tif (o == NULL) {\n\t\tast_log(LOG_NOTICE, \"Device %s not found\\n\", args.name);\n\t\t\n\t\treturn NULL;\n\t}\n\tif (ast_format_cap_iscompatible_format(cap, ast_format_slin) == AST_FORMAT_CMP_NOT_EQUAL) {\n\t\tstruct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\t\tast_log(LOG_NOTICE, \"Format %s unsupported\\n\", ast_format_cap_get_names(cap, &codec_buf));\n\t\treturn NULL;\n\t}\n\tif (o->owner) {\n\t\tast_log(LOG_NOTICE, \"Already have a call (chan %p) on the OSS channel\\n\", o->owner);\n\t\t*cause = AST_CAUSE_BUSY;\n\t\treturn NULL;\n\t}\n\tc = oss_new(o, NULL, NULL, AST_STATE_DOWN, assignedids, requestor);\n\tif (c == NULL) {\n\t\tast_log(LOG_WARNING, \"Unable to create new OSS channel\\n\");\n\t\treturn NULL;\n\t}\n\treturn c;\n}\n", "bug_type": null, "idx": 34}
{"project": "Asterisk", "target": 0, "func": "static void command_queue_prestart_destroy(void *obj)\n{\n\t\n\tao2_cleanup(obj);\n}\n", "bug_type": null, "idx": 35}
{"project": "Asterisk", "target": 0, "func": " */\nstatic const char *get_soxmix_format(const char *format)\n{\n\tconst char *res = format;\n\tif (!strcasecmp(format,\"ulaw\"))\n\t\tres = \"ul\";\n\tif (!strcasecmp(format,\"alaw\"))\n\t\tres = \"al\";\n\treturn res;\n}\n", "bug_type": null, "idx": 36}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_format_def_unregister(siren7_f.name);\n}\n", "bug_type": null, "idx": 37}
{"project": "Asterisk", "target": 0, "func": "static int reload(void)\n{\n\tif (AST_RWLIST_WRLOCK(&sinks)) {\n\t\tast_log(LOG_ERROR, \"Unable to lock sink list.  Load failed.\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tfree_config();\n\tload_config();\n\tAST_RWLIST_UNLOCK(&sinks);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 38}
{"project": "Asterisk", "target": 0, "func": "int ooCloseH225Connection (OOH323CallData *call)\n{\n   if (0 != call->pH225Channel)\n   {\n      if(call->pH225Channel->sock != 0)\n         ooSocketClose (call->pH225Channel->sock);\n      if (call->pH225Channel->outQueue.count > 0)\n      {\n         dListFreeAll (call->pctxt, &(call->pH225Channel->outQueue));\n      }\n      memFreePtr (call->pctxt, call->pH225Channel);\n      call->pH225Channel = NULL;\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 39}
{"project": "Asterisk", "target": 0, "func": "static int jb_put_first_adaptive(void *jb, struct ast_frame *fin, long now)\n{\n\treturn jb_put_adaptive(jb, fin, now);\n}\n", "bug_type": null, "idx": 40}
{"project": "Asterisk", "target": 0, "func": "};\nstatic enum ast_format_cmp_res test_law_cmp(const struct ast_format *format1, const struct ast_format *format2)\n{\n\tast_log(LOG_ERROR, \"Comparing format1 %p and format2 %p\\n\", format1, format2);\n\treturn format1 == format2 ? AST_FORMAT_CMP_EQUAL : AST_FORMAT_CMP_NOT_EQUAL;\n}\n", "bug_type": null, "idx": 41}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_network_puts_mutable(const char *string, int level, int sublevel)\n{\n\tint x;\n\tfor (x = 0; x < AST_MAX_CONNECTS; ++x) {\n\t\tif (consoles[x].fd < 0\n\t\t\t|| consoles[x].mute\n\t\t\t|| consoles[x].levels[level]\n\t\t\t|| (level == __LOG_VERBOSE && consoles[x].option_verbose < sublevel)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfdprint(consoles[x].p[1], string);\n\t}\n}\n", "bug_type": null, "idx": 42}
{"project": "Asterisk", "target": 0, "func": "const char *ast_var_name(const struct ast_var_t *var)\n{\n\tconst char *name;\n\tif (var == NULL || (name = var->name) == NULL)\n\t\treturn NULL;\n\t\n\tif (name[0] == '_') {\n\t\tname++;\n\t\tif (name[0] == '_')\n\t\t\tname++;\n\t}\n\treturn name;\n}\n", "bug_type": null, "idx": 43}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tint res;\n\tres = ast_unregister_translator(&lintoulaw);\n\tres |= ast_unregister_translator(&ulawtolin);\n\tres |= ast_unregister_translator(&testlawtolin);\n\tres |= ast_unregister_translator(&lintotestlaw);\n\treturn res;\n}\n", "bug_type": null, "idx": 44}
{"project": "Asterisk", "target": 0, "func": "ari_validator ast_ari_validate_channel_fn(void)\n{\n\treturn ast_ari_validate_channel;\n}\n", "bug_type": null, "idx": 45}
{"project": "Asterisk", "target": 0, "func": "static int display_parking_lot_cb(void *obj, void *arg, int flags)\n{\n\tint *fd = arg;\n\tstruct parking_lot *lot = obj;\n\tdisplay_parking_lot(lot, *fd);\n\treturn 0;\n}\n", "bug_type": null, "idx": 46}
{"project": "Asterisk", "target": 0, "func": " * \\brief Find named template */\nstatic struct minivm_template *message_template_find(const char *name)\n{\n\tstruct minivm_template *this, *res = NULL;\n\tif (ast_strlen_zero(name))\n\t\treturn NULL;\n\tAST_LIST_LOCK(&message_templates);\n\tAST_LIST_TRAVERSE(&message_templates, this, list) {\n\t\tif (!strcasecmp(this->name, name)) {\n\t\t\tres = this;\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(&message_templates);\n\treturn res;\n}\n", "bug_type": null, "idx": 47}
{"project": "Asterisk", "target": 0, "func": "static void cc_generic_agent_respond(struct ast_cc_agent *agent, enum ast_cc_agent_response_reason reason)\n{\n\t\n\treturn;\n}\n", "bug_type": null, "idx": 48}
{"project": "Asterisk", "target": 0, "func": "static int launch_monitor_thread(struct ast_channel *chan, const char *filename,\n\t\t\t\t  unsigned int flags, int readvol, int writevol,\n\t\t\t\t  const char *post_process, const char *filename_write,\n\t\t\t\t  char *filename_read, const char *uid_channel_var,\n\t\t\t\t  const char *recipients, const char *beep_id)\n{\n\tpthread_t thread;\n\tstruct mixmonitor *mixmonitor;\n\tchar postprocess2[1024] = \"\";\n\tchar *datastore_id = NULL;\n\tpostprocess2[0] = 0;\n\t\n\tif (!ast_strlen_zero(post_process)) {\n\t\tchar *p1, *p2;\n\t\tp1 = ast_strdupa(post_process);\n\t\tfor (p2 = p1; *p2; p2++) {\n\t\t\tif (*p2 == '^' && *(p2+1) == '{') {\n\t\t\t\t*p2 = '$';\n\t\t\t}\n\t\t}\n\t\tast_channel_lock(chan);\n\t\tpbx_substitute_variables_helper(chan, p1, postprocess2, sizeof(postprocess2) - 1);\n\t\tast_channel_unlock(chan);\n\t}\n\t\n\tif (!(mixmonitor = ast_calloc(1, sizeof(*mixmonitor)))) {\n\t\treturn -1;\n\t}\n\t\n\tif (ast_string_field_init(mixmonitor, 512)) {\n\t\tmixmonitor_free(mixmonitor);\n\t\treturn -1;\n\t}\n\t\n\tif (ast_audiohook_init(&mixmonitor->audiohook, AST_AUDIOHOOK_TYPE_SPY, mixmonitor_spy_type, 0)) {\n\t\tmixmonitor_free(mixmonitor);\n\t\treturn -1;\n\t}\n\t\n\tmixmonitor->flags = flags;\n\tif (!(mixmonitor->autochan = ast_autochan_setup(chan))) {\n\t\tmixmonitor_free(mixmonitor);\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(filename)) {\n\t\tmixmonitor->filename = ast_strdup(filename);\n\t}\n\tif (!ast_strlen_zero(filename_write)) {\n\t\tmixmonitor->filename_write = ast_strdup(filename_write);\n\t}\n\tif (!ast_strlen_zero(filename_read)) {\n\t\tmixmonitor->filename_read = ast_strdup(filename_read);\n\t}\n\tif (setup_mixmonitor_ds(mixmonitor, chan, &datastore_id, beep_id)) {\n\t\tast_autochan_destroy(mixmonitor->autochan);\n\t\tmixmonitor_free(mixmonitor);\n\t\tast_free(datastore_id);\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(uid_channel_var)) {\n\t\tif (datastore_id) {\n\t\t\tpbx_builtin_setvar_helper(chan, uid_channel_var, datastore_id);\n\t\t}\n\t}\n\tast_free(datastore_id);\n\tmixmonitor->name = ast_strdup(ast_channel_name(chan));\n\tif (!ast_strlen_zero(postprocess2)) {\n\t\tmixmonitor->post_process = ast_strdup(postprocess2);\n\t}\n\tif (!ast_strlen_zero(recipients)) {\n\t\tchar callerid[256];\n\t\tstruct ast_party_connected_line *connected;\n\t\tast_channel_lock(chan);\n\t\t\n\t\tconnected = ast_channel_connected(chan);\n\t\tast_debug(3, \"Connected Line CID = %d - %s : %d - %s\\n\", connected->id.name.valid,\n\t\t\tconnected->id.name.str, connected->id.number.valid,\n\t\t\tconnected->id.number.str);\n\t\tast_callerid_merge(callerid, sizeof(callerid),\n\t\t\tS_COR(connected->id.name.valid, connected->id.name.str, NULL),\n\t\t\tS_COR(connected->id.number.valid, connected->id.number.str, NULL),\n\t\t\t\"Unknown\");\n\t\tast_string_field_set(mixmonitor, call_context, ast_channel_context(chan));\n\t\tast_string_field_set(mixmonitor, call_macrocontext, ast_channel_macrocontext(chan));\n\t\tast_string_field_set(mixmonitor, call_extension, ast_channel_exten(chan));\n\t\tast_string_field_set(mixmonitor, call_callerchan, ast_channel_name(chan));\n\t\tast_string_field_set(mixmonitor, call_callerid, callerid);\n\t\tmixmonitor->call_priority = ast_channel_priority(chan);\n\t\tast_channel_unlock(chan);\n\t\tadd_vm_recipients_from_string(mixmonitor, recipients);\n\t}\n\tast_set_flag(&mixmonitor->audiohook, AST_AUDIOHOOK_TRIGGER_SYNC);\n\tif (readvol)\n\t\tmixmonitor->audiohook.options.read_volume = readvol;\n\tif (writevol)\n\t\tmixmonitor->audiohook.options.write_volume = writevol;\n\tif (startmon(chan, &mixmonitor->audiohook)) {\n\t\tast_log(LOG_WARNING, \"Unable to add '%s' spy to channel '%s'\\n\",\n\t\t\tmixmonitor_spy_type, ast_channel_name(chan));\n\t\tast_audiohook_destroy(&mixmonitor->audiohook);\n\t\tmixmonitor_free(mixmonitor);\n\t\treturn -1;\n\t}\n\t\n\tmixmonitor->callid = ast_read_threadstorage_callid();\n\treturn ast_pthread_create_detached_background(&thread, NULL, mixmonitor_thread, mixmonitor);\n}\n", "bug_type": null, "idx": 49}
{"project": "Asterisk", "target": 0, "func": "static char *dundi_show_trans(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n#define FORMAT2 \"%-22.22s %-5.5s %-5.5s %-3.3s %-3.3s %-3.3s\\n\"\n#define FORMAT \"%-16.16s:%5d %-5.5d %-5.5d %-3.3d %-3.3d %-3.3d\\n\"\n\tstruct dundi_transaction *trans;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"dundi show trans\";\n\t\te->usage =\n\t\t\t\"Usage: dundi show trans\\n\"\n\t\t\t\"       Lists all known DUNDi transactions.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tAST_LIST_LOCK(&peers);\n\tast_cli(a->fd, FORMAT2, \"Remote\", \"Src\", \"Dst\", \"Tx\", \"Rx\", \"Ack\");\n\tAST_LIST_TRAVERSE(&alltrans, trans, all) {\n\t\tast_cli(a->fd, FORMAT, ast_inet_ntoa(trans->addr.sin_addr),\n\t\t\tntohs(trans->addr.sin_port), trans->strans, trans->dtrans, trans->oseqno, trans->iseqno, trans->aseqno);\n\t}\n\tAST_LIST_UNLOCK(&peers);\n\treturn CLI_SUCCESS;\n#undef FORMAT\n#undef FORMAT2\n}\n", "bug_type": null, "idx": 50}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_add_channel(struct ast_bridge *bridge, struct ast_channel *chan,\n\tstruct ast_bridge_features *features, int play_tone, const char *xfersound)\n{\n\tRAII_VAR(struct ast_bridge *, chan_bridge, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_channel *, yanked_chan, NULL, ao2_cleanup);\n\tast_channel_lock(chan);\n\tchan_bridge = ast_channel_get_bridge(chan);\n\tast_channel_unlock(chan);\n\tif (chan_bridge) {\n\t\tstruct ast_bridge_channel *bridge_channel;\n\t\t\n\t\tast_bridge_features_destroy(features);\n\t\tast_bridge_lock_both(bridge, chan_bridge);\n\t\tbridge_channel = bridge_find_channel(chan_bridge, chan);\n\t\tif (bridge_move_locked(bridge, chan_bridge, chan, NULL, 1)) {\n\t\t\tast_bridge_unlock(chan_bridge);\n\t\t\tast_bridge_unlock(bridge);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tast_assert(bridge_channel != NULL);\n\t\t\n\t\tbridge_dissolve_check_stolen(chan_bridge, bridge_channel);\n\t\tast_bridge_unlock(chan_bridge);\n\t\tast_bridge_unlock(bridge);\n\t} else {\n\t\t\n\t\tyanked_chan = ast_channel_yank(chan);\n\t\tif (!yanked_chan) {\n\t\t\tast_log(LOG_WARNING, \"Could not gain control of channel %s\\n\", ast_channel_name(chan));\n\t\t\tast_bridge_features_destroy(features);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ast_channel_state(yanked_chan) != AST_STATE_UP) {\n\t\t\tast_answer(yanked_chan);\n\t\t}\n\t\tast_channel_ref(yanked_chan);\n\t\tif (ast_bridge_impart(bridge, yanked_chan, NULL, features,\n\t\t\tAST_BRIDGE_IMPART_CHAN_INDEPENDENT)) {\n\t\t\t\n\t\t\tif (ast_channel_pbx(yanked_chan)) {\n\t\t\t\tast_channel_unref(yanked_chan);\n\t\t\t} else {\n\t\t\t\tast_hangup(yanked_chan);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (play_tone && !ast_strlen_zero(xfersound)) {\n\t\tstruct ast_channel *play_chan = yanked_chan ?: chan;\n\t\tRAII_VAR(struct ast_bridge_channel *, play_bridge_channel, NULL, ao2_cleanup);\n\t\tast_channel_lock(play_chan);\n\t\tplay_bridge_channel = ast_channel_get_bridge_channel(play_chan);\n\t\tast_channel_unlock(play_chan);\n\t\tif (!play_bridge_channel) {\n\t\t\tast_log(LOG_WARNING, \"Unable to play tone for channel %s. No longer in a bridge.\\n\",\n\t\t\t\tast_channel_name(play_chan));\n\t\t} else {\n\t\t\tast_bridge_channel_queue_playfile(play_bridge_channel, NULL, xfersound, NULL);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 51}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(named_lock_test);\n\treturn 0;\n}\n", "bug_type": null, "idx": 52}
{"project": "Asterisk", "target": 0, "func": "static void test_sub(struct ast_event *event)\n{\n\tstruct ast_event *event_dup = ao2_dup_event(event);\n\tconst char *chan_name;\n\tSCOPED_MUTEX(mid_test_lock, &mid_test_sync_lock);\n\tif (!event_dup) {\n\t\treturn;\n\t}\n\tchan_name = ast_event_get_ie_str(event_dup, AST_EVENT_IE_CEL_CHANNAME);\n\tif (chan_name && strncmp(chan_name, CHANNEL_TECH_NAME, 14)) {\n\t\treturn;\n\t}\n\t\n\tao2_link(cel_received_events, event_dup);\n\tif (do_mid_test_sync) {\n\t\tint expected = ao2_container_count(cel_expected_events);\n\t\tint received = ao2_container_count(cel_received_events);\n\t\tif (expected <= received) {\n\t\t\t{\n\t\t\tSCOPED_MUTEX(lock, &sync_lock);\n\t\t\tast_cond_signal(&sync_out);\n\t\t\tdo_mid_test_sync = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 53}
{"project": "Asterisk", "target": 0, "func": "static void cc_cli_print_monitor_stats(struct ast_cc_monitor *monitor, int fd, int parent_id)\n{\n\tstruct ast_cc_monitor *child_monitor_iter = monitor;\n\tif (!monitor) {\n\t\treturn;\n\t}\n\tast_cli(fd, \"\\t\\t|-->%s\", monitor->interface->device_name);\n\tif (monitor->interface->monitor_class == AST_CC_DEVICE_MONITOR) {\n\t\tast_cli(fd, \"(%s)\", cc_service_to_string(monitor->service_offered));\n\t}\n\tast_cli(fd, \"\\n\");\n\twhile ((child_monitor_iter = AST_LIST_NEXT(child_monitor_iter, next))) {\n\t\tif (child_monitor_iter->parent_id == monitor->id) {\n\t\t\tcc_cli_print_monitor_stats(child_monitor_iter, fd, child_monitor_iter->id);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 54}
{"project": "Asterisk", "target": 0, "func": "enum stasis_app_recording_state stasis_app_recording_get_state(\n\tstruct stasis_app_recording *recording)\n{\n\treturn recording->state;\n}\n", "bug_type": null, "idx": 55}
{"project": "Asterisk", "target": 0, "func": "const char *ast_msg_get_to(const struct ast_msg *msg)\n{\n\treturn msg->to;\n}\n", "bug_type": null, "idx": 56}
{"project": "Asterisk", "target": 0, "func": "\nstatic int siren7_clone(const struct ast_format *src, struct ast_format *dst)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 57}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int remove_auth(void)\n{\n\tstruct ast_sip_auth **pointing;\n\tpointing = ast_threadstorage_get(&auth_store, sizeof(pointing));\n\tif (!pointing) {\n\t\treturn -1;\n\t}\n\t*pointing = NULL;\n\treturn 0;\n}\n", "bug_type": null, "idx": 58}
{"project": "Asterisk", "target": 0, "func": "\nstatic int message_subscription_compare_cb(void *obj, void *arg, int flags)\n{\n\tconst struct message_subscription *object_left = obj;\n\tconst struct message_subscription *object_right = arg;\n\tconst char *right_key = arg;\n\tint cmp;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_OBJECT:\n\t\tright_key = object_right->token;\n\t\t\n\tcase OBJ_SEARCH_KEY:\n\t\tcmp = strcmp(object_left->token, right_key);\n\t\tbreak;\n\tcase OBJ_SEARCH_PARTIAL_KEY:\n\t\t\n\t\tcmp = strncmp(object_left->token, right_key, strlen(right_key));\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tcmp = 0;\n\t\tbreak;\n\t}\n\tif (cmp) {\n\t\treturn 0;\n\t}\n\t\n\treturn CMP_MATCH;\n}\n", "bug_type": null, "idx": 59}
{"project": "Asterisk", "target": 0, "func": "static int phone_digit_end(struct ast_channel *ast, char digit, unsigned int duration)\n{\n\tstruct phone_pvt *p;\n\tint outdigit;\n\tp = ast_channel_tech_pvt(ast);\n\tast_debug(1, \"Dialed %c\\n\", digit);\n\tswitch(digit) {\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t\toutdigit = digit - '0';\n\t\tbreak;\n\tcase '*':\n\t\toutdigit = 11;\n\t\tbreak;\n\tcase '#':\n\t\toutdigit = 12;\n\t\tbreak;\n\tcase 'f':\t\n\tcase 'F':\n\t\tioctl(p->fd, IXJCTL_PSTN_SET_STATE, PSTN_ON_HOOK);\n\t\tusleep(320000);\n\t\tioctl(p->fd, IXJCTL_PSTN_SET_STATE, PSTN_OFF_HOOK);\n\t\tao2_cleanup(p->lastformat);\n\t\tp->lastformat = NULL;\n\t\treturn 0;\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Unknown digit '%c'\\n\", digit);\n\t\treturn -1;\n\t}\n\tast_debug(1, \"Dialed %d\\n\", outdigit);\n\tioctl(p->fd, PHONE_PLAY_TONE, outdigit);\n\tao2_cleanup(p->lastformat);\n\tp->lastformat = NULL;\n\treturn 0;\n}\n", "bug_type": null, "idx": 60}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_audiohook_volume_set(struct ast_channel *chan, enum ast_audiohook_direction direction, int volume)\n{\n\tstruct audiohook_volume *audiohook_volume = NULL;\n\t\n\tif (!(audiohook_volume = audiohook_volume_get(chan, (volume ? 1 : 0)))) {\n\t\treturn -1;\n\t}\n\t\n\tif (direction == AST_AUDIOHOOK_DIRECTION_READ || direction == AST_AUDIOHOOK_DIRECTION_BOTH) {\n\t\taudiohook_volume->read_adjustment = volume;\n\t}\n\tif (direction == AST_AUDIOHOOK_DIRECTION_WRITE || direction == AST_AUDIOHOOK_DIRECTION_BOTH) {\n\t\taudiohook_volume->write_adjustment = volume;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 61}
{"project": "Asterisk", "target": 0, "func": "\nstatic int getproviderstate(const char *provider, const char *address)\n{\n\tstruct devstate_prov *devprov;\n\tint res = AST_DEVICE_INVALID;\n\tAST_RWLIST_RDLOCK(&devstate_provs);\n\tAST_RWLIST_TRAVERSE(&devstate_provs, devprov, list) {\n\t\tast_debug(5, \"Checking provider %s with %s\\n\", devprov->label, provider);\n\t\tif (!strcasecmp(devprov->label, provider)) {\n\t\t\tres = devprov->callback(address);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&devstate_provs);\n\treturn res;\n}\n", "bug_type": null, "idx": 62}
{"project": "Asterisk", "target": 0, "func": "int\nhistory_search(const char *str, int direction)\n{\n\treturn (_history_search_gen(str, direction, -1));\n}\n", "bug_type": null, "idx": 63}
{"project": "Asterisk", "target": 0, "func": "static inline void goertzel_reset(goertzel_state_t *s)\n{\n\ts->v2 = s->v3 = s->chunky = 0;\n}\n", "bug_type": null, "idx": 64}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tast_cli_register_multiple(cli_locales, ARRAY_LEN(cli_locales));\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 65}
{"project": "Asterisk", "target": 0, "func": "static void sla_ringing_trunk_destroy(struct sla_ringing_trunk *ringing_trunk);\nstatic void sla_stop_ringing_trunk(struct sla_ringing_trunk *ringing_trunk)\n{\n\tchar buf[80];\n\tstruct sla_station_ref *station_ref;\n\tsnprintf(buf, sizeof(buf), \"SLA_%s,K\", ringing_trunk->trunk->name);\n\tadmin_exec(NULL, buf);\n\tsla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);\n\twhile ((station_ref = AST_LIST_REMOVE_HEAD(&ringing_trunk->timed_out_stations, entry))) {\n\t\tao2_ref(station_ref, -1);\n\t}\n\tsla_ringing_trunk_destroy(ringing_trunk);\n}\n", "bug_type": null, "idx": 66}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225DataRate (OOCTXT* pctxt, H225DataRate* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.channelMultiplierPresent = optbit;\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"channelRate\", -1);\n   stat = asn1PD_H225BandWidth (pctxt, &pvalue->channelRate);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"channelRate\", -1);\n   \n   if (pvalue->m.channelMultiplierPresent) {\n      invokeStartElement (pctxt, \"channelMultiplier\", -1);\n      stat = decodeConsUInt16 (pctxt, &pvalue->channelMultiplier, 1U, 256U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->channelMultiplier);\n      invokeEndElement (pctxt, \"channelMultiplier\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 67}
{"project": "Asterisk", "target": 0, "func": "static void websocket_client_args_destroy(void *obj)\n{\n\tstruct ast_tcptls_session_args *args = obj;\n\tif (args->tls_cfg) {\n\t\tast_free(args->tls_cfg->certfile);\n\t\tast_free(args->tls_cfg->pvtfile);\n\t\tast_free(args->tls_cfg->cipher);\n\t\tast_free(args->tls_cfg->cafile);\n\t\tast_free(args->tls_cfg->capath);\n\t\tast_ssl_teardown(args->tls_cfg);\n\t}\n\tast_free(args->tls_cfg);\n}\n", "bug_type": null, "idx": 68}
{"project": "Asterisk", "target": 0, "func": "void ooTimerComputeExpireTime (OOTimer* pTimer)\n{\n   struct timeval tv;\n   ooGetTimeOfDay (&tv, 0);\n   \n   pTimer->expireTime.tv_usec = tv.tv_usec + pTimer->timeout.tv_usec;\n   pTimer->expireTime.tv_sec  = tv.tv_sec  + pTimer->timeout.tv_sec;\n   while (pTimer->expireTime.tv_usec >= MICROSEC) {\n      pTimer->expireTime.tv_usec -= MICROSEC;\n      pTimer->expireTime.tv_sec++;\n   }\n}\n", "bug_type": null, "idx": 69}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_session_remove_datastore(struct ast_sip_session *session, const char *name)\n{\n\tao2_callback(session->datastores, OBJ_KEY | OBJ_UNLINK | OBJ_NODATA, NULL, (void *) name);\n}\n", "bug_type": null, "idx": 70}
{"project": "Asterisk", "target": 0, "func": "\nstatic void get_timerange(struct ast_timing *i, char *times)\n{\n\tchar *endpart, *part;\n\tint x;\n\tint st_h, st_m;\n\tint endh, endm;\n\tint minute_start, minute_end;\n\t\n\tmemset(i->minmask, 0, sizeof(i->minmask));\n\t\n\t\n\tif (ast_strlen_zero(times) || !strcmp(times, \"*\")) {\n\t\t\n\t\tfor (x = 0; x < 48; x++) {\n\t\t\ti->minmask[x] = 0x3fffffff; \n\t\t}\n\t\treturn;\n\t}\n\t\n\twhile ((part = strsep(&times, \"&\"))) {\n\t\tif (!(endpart = strchr(part, '-'))) {\n\t\t\tif (sscanf(part, \"%2d:%2d\", &st_h, &st_m) != 2 || st_h < 0 || st_h > 23 || st_m < 0 || st_m > 59) {\n\t\t\t\tast_log(LOG_WARNING, \"%s isn't a valid time.\\n\", part);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti->minmask[st_h * 2 + (st_m >= 30 ? 1 : 0)] |= (1 << (st_m % 30));\n\t\t\tcontinue;\n\t\t}\n\t\t*endpart++ = '\\0';\n\t\t\n\t\twhile (*endpart && !isdigit(*endpart)) {\n\t\t\tendpart++;\n\t\t}\n\t\tif (!*endpart) {\n\t\t\tast_log(LOG_WARNING, \"Invalid time range starting with '%s-'.\\n\", part);\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf(part, \"%2d:%2d\", &st_h, &st_m) != 2 || st_h < 0 || st_h > 23 || st_m < 0 || st_m > 59) {\n\t\t\tast_log(LOG_WARNING, \"'%s' isn't a valid start time.\\n\", part);\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf(endpart, \"%2d:%2d\", &endh, &endm) != 2 || endh < 0 || endh > 23 || endm < 0 || endm > 59) {\n\t\t\tast_log(LOG_WARNING, \"'%s' isn't a valid end time.\\n\", endpart);\n\t\t\tcontinue;\n\t\t}\n\t\tminute_start = st_h * 60 + st_m;\n\t\tminute_end = endh * 60 + endm;\n\t\t\n\t\tfor (x = minute_start; x != minute_end; x = (x + 1) % (24 * 60)) {\n\t\t\ti->minmask[x / 30] |= (1 << (x % 30));\n\t\t}\n\t\t\n\t\ti->minmask[x / 30] |= (1 << (x % 30));\n\t}\n\t\n\treturn;\n}\n", "bug_type": null, "idx": 71}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *xmpp_cli_list_pubsub_nodes(struct ast_cli_entry *e, int cmd, struct\n\t\t\t\t\tast_cli_args *a)\n{\n\tRAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);\n\tRAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);\n\tconst char *name = NULL, *collection = NULL;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"xmpp list nodes\";\n\t\te->usage =\n\t\t\t\"Usage: xmpp list nodes <connection> [collection]\\n\"\n\t\t\t\"       Lists the user's nodes on the respective connection\\n\"\n\t\t\t\"       ([connection] as configured in xmpp.conf.)\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc > 5 || a->argc < 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t} else if (a->argc == 4 || a->argc == 5) {\n\t\tname = a->argv[3];\n\t}\n\tif (a->argc == 5) {\n\t\tcollection = a->argv[4];\n\t}\n\tif (!cfg || !cfg->clients || !(clientcfg = xmpp_config_find(cfg->clients, name))) {\n\t\tast_cli(a->fd, \"Unable to find client '%s'!\\n\", name);\n\t\treturn CLI_FAILURE;\n\t}\n\tast_cli(a->fd, \"Listing pubsub nodes.\\n\");\n\txmpp_pubsub_request_nodes(clientcfg->client, collection);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 72}
{"project": "Asterisk", "target": 0, "func": "static int pbx_builtin_gotoif(struct ast_channel *chan, const char *data)\n{\n\tchar *condition, *branch1, *branch2, *branch;\n\tchar *stringp;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"Ignoring, since there is no variable to check\\n\");\n\t\treturn 0;\n\t}\n\tstringp = ast_strdupa(data);\n\tcondition = strsep(&stringp,\"?\");\n\tbranch1 = strsep(&stringp,\":\");\n\tbranch2 = strsep(&stringp,\"\");\n\tbranch = pbx_checkcondition(condition) ? branch1 : branch2;\n\tif (ast_strlen_zero(branch)) {\n\t\tast_debug(1, \"Not taking any branch\\n\");\n\t\treturn 0;\n\t}\n\treturn pbx_builtin_goto(chan, branch);\n}\n", "bug_type": null, "idx": 73}
{"project": "Asterisk", "target": 0, "func": "struct stasis_caching_topic *stasis_caching_unsubscribe(struct stasis_caching_topic *caching_topic)\n{\n\tif (!caching_topic) {\n\t\treturn NULL;\n\t}\n\t\n\tao2_ref(caching_topic, +1);\n\tif (stasis_subscription_is_subscribed(caching_topic->sub)) {\n\t\t\n\t\tao2_ref(caching_topic->sub, +1);\n\t\tstasis_unsubscribe(caching_topic->sub);\n\t} else {\n\t\tast_log(LOG_ERROR, \"stasis_caching_topic unsubscribed multiple times\\n\");\n\t}\n\tao2_cleanup(caching_topic);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 74}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_sched_task_get_next_run_by_name(const char *name)\n{\n\tRAII_VAR(struct ast_sip_sched_task *, schtd, NULL, ao2_cleanup);\n\tif (ast_strlen_zero(name)) {\n\t\treturn -1;\n\t}\n\tschtd = ao2_find(tasks, name, OBJ_SEARCH_KEY | OBJ_NOLOCK);\n\tif (!schtd) {\n\t\treturn -1;\n\t}\n\treturn ast_sip_sched_task_get_next_run(schtd);\n}\n", "bug_type": null, "idx": 75}
{"project": "Asterisk", "target": 0, "func": "static inline int dahdi_confmute(struct dahdi_pvt *p, int muted);\nstatic void my_handle_dtmf(void *pvt, struct ast_channel *ast, enum analog_sub analog_index, struct ast_frame **dest)\n{\n\tstruct ast_frame *f = *dest;\n\tstruct dahdi_pvt *p = pvt;\n\tint idx = analogsub_to_dahdisub(analog_index);\n\tast_debug(1, \"%s DTMF digit: 0x%02X '%c' on %s\\n\",\n\t\tf->frametype == AST_FRAME_DTMF_BEGIN ? \"Begin\" : \"End\",\n\t\t(unsigned)f->subclass.integer, f->subclass.integer, ast_channel_name(ast));\n\tif (f->subclass.integer == 'f') {\n\t\tif (f->frametype == AST_FRAME_DTMF_END) {\n\t\t\t\n\t\t\tif ((p->callprogress & CALLPROGRESS_FAX) && !p->faxhandled) {\n\t\t\t\t\n\t\t\t\tif (p->usefaxbuffers && !p->bufferoverrideinuse) {\n\t\t\t\t\tstruct dahdi_bufferinfo bi = {\n\t\t\t\t\t\t.txbufpolicy = p->faxbuf_policy,\n\t\t\t\t\t\t.bufsize = p->bufsize,\n\t\t\t\t\t\t.numbufs = p->faxbuf_no\n\t\t\t\t\t};\n\t\t\t\t\tint res;\n\t\t\t\t\tif ((res = ioctl(p->subs[idx].dfd, DAHDI_SET_BUFINFO, &bi)) < 0) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Channel '%s' unable to set buffer policy, reason: %s\\n\", ast_channel_name(ast), strerror(errno));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp->bufferoverrideinuse = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp->faxhandled = 1;\n\t\t\t\tif (p->dsp) {\n\t\t\t\t\tp->dsp_features &= ~DSP_FEATURE_FAX_DETECT;\n\t\t\t\t\tast_dsp_set_features(p->dsp, p->dsp_features);\n\t\t\t\t\tast_debug(1, \"Disabling FAX tone detection on %s after tone received\\n\", ast_channel_name(ast));\n\t\t\t\t}\n\t\t\t\tif (strcmp(ast_channel_exten(ast), \"fax\")) {\n\t\t\t\t\tconst char *target_context = S_OR(ast_channel_macrocontext(ast), ast_channel_context(ast));\n\t\t\t\t\t\n\t\t\t\t\tast_mutex_unlock(&p->lock);\n\t\t\t\t\tast_channel_unlock(ast);\n\t\t\t\t\tif (ast_exists_extension(ast, target_context, \"fax\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(ast)->id.number.valid, ast_channel_caller(ast)->id.number.str, NULL))) {\n\t\t\t\t\t\tast_verb(3, \"Redirecting %s to fax extension\\n\", ast_channel_name(ast));\n\t\t\t\t\t\t\n\t\t\t\t\t\tpbx_builtin_setvar_helper(ast, \"FAXEXTEN\", ast_channel_exten(ast));\n\t\t\t\t\t\tif (ast_async_goto(ast, target_context, \"fax\", 1))\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Failed to async goto '%s' into fax of '%s'\\n\", ast_channel_name(ast), target_context);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_log(LOG_NOTICE, \"Fax detected, but no fax extension\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tast_channel_lock(ast);\n\t\t\t\t\tast_mutex_lock(&p->lock);\n\t\t\t\t} else {\n\t\t\t\t\tast_debug(1, \"Already in a fax extension, not redirecting\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_debug(1, \"Fax already handled\\n\");\n\t\t\t}\n\t\t\tdahdi_confmute(p, 0);\n\t\t}\n\t\tp->subs[idx].f.frametype = AST_FRAME_NULL;\n\t\tp->subs[idx].f.subclass.integer = 0;\n\t\t*dest = &p->subs[idx].f;\n\t}\n}\n", "bug_type": null, "idx": 76}
{"project": "Asterisk", "target": 0, "func": "\nstruct video_desc *get_video_desc(struct ast_channel *c)\n{\n\tstruct chan_oss_pvt *o = c ? ast_channel_tech_pvt(c) : find_desc(oss_active);\n\treturn o ? o->env : NULL;\n}\n", "bug_type": null, "idx": 77}
{"project": "Asterisk", "target": 0, "func": "\nstatic int media_index_update(struct ast_media_index *index,\n\tconst char *variant,\n\tconst char *subdir)\n{\n\tstruct dirent* dent;\n\tDIR* srcdir;\n\tRAII_VAR(struct ast_str *, index_dir, ast_str_create(64), ast_free);\n\tRAII_VAR(struct ast_str *, statfile, ast_str_create(64), ast_free);\n\tint res = 0;\n\tif (!index_dir) {\n\t\treturn 0;\n\t}\n\tast_str_set(&index_dir, 0, \"%s\", index->base_dir);\n\tif (!ast_strlen_zero(variant)) {\n\t\tast_str_append(&index_dir, 0, \"/%s\", variant);\n\t}\n\tif (!ast_strlen_zero(subdir)) {\n\t\tast_str_append(&index_dir, 0, \"/%s\", subdir);\n\t}\n\tsrcdir = opendir(ast_str_buffer(index_dir));\n\tif (srcdir == NULL) {\n\t\tast_log(LOG_ERROR, \"Failed to open %s: %s\\n\", ast_str_buffer(index_dir), strerror(errno));\n\t\treturn -1;\n\t}\n\twhile((dent = readdir(srcdir)) != NULL) {\n\t\tstruct stat st;\n\t\tif(!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tast_str_reset(statfile);\n\t\tast_str_set(&statfile, 0, \"%s/%s\", ast_str_buffer(index_dir), dent->d_name);\n\t\tif (stat(ast_str_buffer(statfile), &st) < 0) {\n\t\t\tast_log(LOG_WARNING, \"Failed to stat %s: %s\\n\", ast_str_buffer(statfile), strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tif (ast_strlen_zero(subdir)) {\n\t\t\t\tres = media_index_update(index, variant, dent->d_name);\n\t\t\t} else {\n\t\t\t\tRAII_VAR(struct ast_str *, new_subdir, ast_str_create(64), ast_free);\n\t\t\t\tast_str_set(&new_subdir, 0, \"%s/%s\", subdir, dent->d_name);\n\t\t\t\tres = media_index_update(index, variant, ast_str_buffer(new_subdir));\n\t\t\t}\n\t\t\tif (res) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISREG(st.st_mode)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (process_file(index, variant, subdir, dent->d_name)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclosedir(srcdir);\n\treturn res;\n}\n", "bug_type": null, "idx": 78}
{"project": "Asterisk", "target": 0, "func": "static int app_control_moh_stop(struct stasis_app_control *control,\n\tstruct ast_channel *chan, void *data)\n{\n\tast_moh_stop(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 79}
{"project": "Asterisk", "target": 0, "func": "int ast_cancel_shutdown(void)\n{\n\tint shutdown_aborted = 0;\n\tast_mutex_lock(&safe_system_lock);\n\tif (shuttingdown >= SHUTDOWN_FAST) {\n\t\tshuttingdown = NOT_SHUTTING_DOWN;\n\t\tshutdown_pending = 0;\n\t\tshutdown_aborted = 1;\n\t}\n\tast_mutex_unlock(&safe_system_lock);\n\treturn shutdown_aborted;\n}\n", "bug_type": null, "idx": 80}
{"project": "Asterisk", "target": 0, "func": "static pj_status_t add_response_headers(pjsip_tx_data *tdata)\n{\n\tadd_headers_to_message(&response_headers, tdata);\n\treturn PJ_SUCCESS;\n}\n", "bug_type": null, "idx": 81}
{"project": "Asterisk", "target": 0, "func": "const char* ooGetQ931CauseValueText(int val)\n{\n   switch(val)\n   {\n      case Q931UnallocatedNumber:   \n         return \"Q931UnallocatedNumber\";\n      case Q931NoRouteToNetwork:\n         return \"Q931NoRouteToNetwork\";\n      case Q931NoRouteToDestination:\n         return \"Q931NoRouteToDestination\";\n      case Q931ChannelUnacceptable: \n         return \"Q931ChannelUnacceptable\";\n      case Q931NormalCallClearing:\n         return \"Q931NormalCallClearing\";\n      case Q931UserBusy:\n         return \"Q931UserBusy\";\n      case Q931NoResponse:\n         return \"Q931NoResponse\";\n      case Q931NoAnswer:\n         return \"Q931NoAnswer\";\n      case Q931SubscriberAbsent:\n         return \"Q931SubscriberAbsent\";\n      case Q931CallRejected:\n         return \"Q931CallRejected\";\n      case Q931NumberChanged:\n         return \"Q931NumberChanged\";\n      case Q931Redirection:\n         return \"Q931Redirection\";\n      case Q931DestinationOutOfOrder:\n         return \"Q931DestinationOutOfOrder\";\n      case Q931InvalidNumberFormat:\n         return \"Q931InvalidNumberFormat\";\n      case Q931NormalUnspecified:\n         return \"Q931NormalUnspecified\";\n      case Q931StatusEnquiryResponse:\n         return \"Q931StatusEnquiryResponse\";\n      case Q931NoCircuitChannelAvailable:\n         return \"Q931NoCircuitChannelAvailable\";\n      case Q931NetworkOutOfOrder:\n         return \"Q931NetworkOutOfOrder\";\n      case Q931TemporaryFailure:\n         return \"Q931TemporaryFailure\";\n      case Q931Congestion:\n         return \"Q931Congestion\";\n      case Q931RequestedCircuitUnAvailable:\n         return \"Q931RequestedCircuitUnavailable\";\n      case Q931ResourcesUnavailable:\n         return \"Q931ResourcesUnavailable\";\n      case Q931IncompatibleDestination:\n         return \"Q931IncompatibleDestination\";\n      case Q931ProtocolErrorUnspecified:\n         return \"Q931ProtocolErrorUnspecified\";\n      case Q931RecoveryOnTimerExpiry:\n         return \"Q931RecoveryOnTimerExpiry\";\n      case Q931InvalidCallReference:\n         return \"Q931InvaliedCallReference\";\n      default:\n         return \"Unsupported Cause Type\";\n   }\n   return \"Unsupported Cause Type\";\n}\n", "bug_type": null, "idx": 82}
{"project": "Asterisk", "target": 0, "func": "void ast_taskprocessor_build_name(char *buf, unsigned int size, const char *format, ...)\n{\n\tva_list ap;\n\tint user_size;\n#define SEQ_STR_SIZE (1 + 8 + 1)\t\n\tast_assert(buf != NULL);\n\tast_assert(SEQ_STR_SIZE <= size);\n\tva_start(ap, format);\n\tuser_size = vsnprintf(buf, size - (SEQ_STR_SIZE - 1), format, ap);\n\tva_end(ap);\n\tif (user_size < 0) {\n\t\t\n\t\tuser_size = 0;\n\t} else if (size < user_size + SEQ_STR_SIZE) {\n\t\t\n\t\tuser_size = size - SEQ_STR_SIZE;\n\t}\n\t\n\tsnprintf(buf + user_size, SEQ_STR_SIZE, \"-%08x\", ast_taskprocessor_seq_num());\n}\n", "bug_type": null, "idx": 83}
{"project": "Asterisk", "target": 0, "func": "const struct ast_sw *ast_walk_context_switches(const struct ast_context *con,\n\tconst struct ast_sw *sw)\n{\n\tif (sw) {\n\t\tint idx;\n\t\tint next = 0;\n\t\tfor (idx = 0; idx < ast_context_switches_count(con); idx++) {\n\t\t\tconst struct ast_sw *s = ast_context_switches_get(con, idx);\n\t\t\tif (next) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (sw == s) {\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\tif (!ast_context_switches_count(con)) {\n\t\treturn NULL;\n\t}\n\treturn ast_context_switches_get(con, 0);\n}\n", "bug_type": null, "idx": 84}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void registration_deleted_observer(const void *obj)\n{\n\tconst struct sip_outbound_registration *registration = obj;\n\tstruct ao2_container *states;\n\tstates = ao2_global_obj_ref(current_states);\n\tif (!states) {\n\t\t\n\t\treturn;\n\t}\n\tao2_find(states, ast_sorcery_object_get_id(registration), OBJ_UNLINK | OBJ_NODATA | OBJ_SEARCH_KEY);\n\tao2_ref(states, -1);\n}\n", "bug_type": null, "idx": 85}
{"project": "Asterisk", "target": 0, "func": "struct ast_generator *ast_channel_generator(const struct ast_channel *chan)\n{\n\treturn chan->generator;\n}\n", "bug_type": null, "idx": 86}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int speex32_samples(struct ast_frame *frame)\n{\n\treturn 4 * speex_samples(frame->data.ptr, frame->datalen);\n}\n", "bug_type": null, "idx": 87}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function regex_function = {\n\t.name = \"REGEX\",\n\t.read = regex,\n};\n", "bug_type": null, "idx": 88}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_frame *g726_read(struct ast_filestream *s, int *whennext)\n{\n\tsize_t res;\n\tstruct g726_desc *fs = (struct g726_desc *)s->_private;\n\t\n\tAST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, frame_size[fs->rate]);\n\ts->fr.samples = 8 * FRAME_TIME;\n\tif ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {\n\t\tif (res) {\n\t\t\tast_log(LOG_WARNING, \"Short read of %s data (expected %d bytes, read %zu): %s\\n\",\n\t\t\t\t\tast_format_get_name(s->fr.subclass.format), s->fr.datalen, res,\n\t\t\t\t\tstrerror(errno));\n\t\t}\n\t\treturn NULL;\n\t}\n\t*whennext = s->fr.samples;\n\treturn &s->fr;\n}\n", "bug_type": null, "idx": 89}
{"project": "Asterisk", "target": 0, "func": "static enum attended_transfer_state blond_nonfinal_exit(struct attended_transfer_properties *props,\n\t\tenum attended_transfer_stimulus stimulus)\n{\n\tswitch (stimulus) {\n\tcase STIMULUS_TRANSFEREE_HANGUP:\n\t\treturn TRANSFER_FAIL;\n\tcase STIMULUS_RECALL_TARGET_ANSWER:\n\t\treturn TRANSFER_RESUME;\n\tcase STIMULUS_TIMEOUT:\n\t\tast_softhangup(props->recall_target, AST_SOFTHANGUP_EXPLICIT);\n\tcase STIMULUS_RECALL_TARGET_HANGUP:\n\t\tprops->recall_target = ast_channel_unref(props->recall_target);\n\t\treturn TRANSFER_RECALLING;\n\tcase STIMULUS_NONE:\n\tcase STIMULUS_DTMF_ATXFER_ABORT:\n\tcase STIMULUS_DTMF_ATXFER_COMPLETE:\n\tcase STIMULUS_DTMF_ATXFER_THREEWAY:\n\tcase STIMULUS_DTMF_ATXFER_SWAP:\n\tcase STIMULUS_TRANSFERER_HANGUP:\n\tcase STIMULUS_TRANSFER_TARGET_HANGUP:\n\tcase STIMULUS_TRANSFER_TARGET_ANSWER:\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Unexpected stimulus '%s' received in attended transfer state '%s'\\n\",\n\t\t\t\tstimulus_strs[stimulus], state_properties[props->state].state_name);\n\t\treturn props->state;\n\t}\n}\n", "bug_type": null, "idx": 90}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic void dll_tests(void)\n{\n\tstruct test_container *tc;\n\tstruct test1 *a;\n\tstruct test1 *b;\n\tstruct test1 *c;\n\tstruct test1 *d;\n\tstruct test1 *e;\n\tast_debug(1,\"Test AST_DLLIST_INSERT_HEAD, AST_DLLIST_TRAVERSE, AST_DLLIST_TRAVERSE_BACKWARDS_SAFE_BEGIN, AST_DLLIST_TRAVERSE_BACKWARDS_SAFE_END\\n\");\n\ttc = make_cont();\n\ta = make_test1(\"A\");\n\tb = make_test1(\"B\");\n\tc = make_test1(\"C\");\n\td = make_test1(\"D\");\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, d, list);\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, c, list);\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, b, list);\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, a, list);\n\tprint_list(tc, \"A <=> B <=> C <=> D\");\n\tdestroy_test_container(tc);\n\ttc = make_cont();\n\tif (AST_DLLIST_EMPTY(&tc->entries))\n\t\tast_debug(1,\"Test AST_DLLIST_EMPTY....OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_EMPTY....PROBLEM!!\\n\");\n\ta = make_test1(\"A\");\n\tb = make_test1(\"B\");\n\tc = make_test1(\"C\");\n\td = make_test1(\"D\");\n\tast_debug(1,\"Test AST_DLLIST_INSERT_TAIL\\n\");\n\tAST_DLLIST_INSERT_TAIL(&tc->entries, a, list);\n\tAST_DLLIST_INSERT_TAIL(&tc->entries, b, list);\n\tAST_DLLIST_INSERT_TAIL(&tc->entries, c, list);\n\tAST_DLLIST_INSERT_TAIL(&tc->entries, d, list);\n\tprint_list(tc, \"A <=> B <=> C <=> D\");\n\tif (AST_DLLIST_FIRST(&tc->entries) == a)\n\t\tast_debug(1,\"Test AST_DLLIST_FIRST....OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_FIRST....PROBLEM\\n\");\n\tif (AST_DLLIST_LAST(&tc->entries) == d)\n\t\tast_debug(1,\"Test AST_DLLIST_LAST....OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_LAST....PROBLEM\\n\");\n\tif (AST_DLLIST_NEXT(a,list) == b)\n\t\tast_debug(1,\"Test AST_DLLIST_NEXT....OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_NEXT....PROBLEM\\n\");\n\tif (AST_DLLIST_PREV(d,list) == c)\n\t\tast_debug(1,\"Test AST_DLLIST_PREV....OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_PREV....PROBLEM\\n\");\n\tdestroy_test_container(tc);\n\ttc = make_cont();\n\ta = make_test1(\"A\");\n\tb = make_test1(\"B\");\n\tc = make_test1(\"C\");\n\td = make_test1(\"D\");\n\tast_debug(1,\"Test AST_DLLIST_INSERT_AFTER, AST_DLLIST_TRAVERSE_BACKWARDS\\n\");\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, a, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, a, b, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, b, c, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, c, d, list);\n\tprint_list_backwards(tc, \"D <=> C <=> B <=> A\");\n\tast_debug(1,\"Test AST_DLLIST_REMOVE_HEAD\\n\");\n\tAST_DLLIST_REMOVE_HEAD(&tc->entries, list);\n\tprint_list_backwards(tc, \"D <=> C <=> B\");\n\tast_debug(1,\"Test AST_DLLIST_REMOVE_HEAD\\n\");\n\tAST_DLLIST_REMOVE_HEAD(&tc->entries, list);\n\tprint_list_backwards(tc, \"D <=> C\");\n\tast_debug(1,\"Test AST_DLLIST_REMOVE_HEAD\\n\");\n\tAST_DLLIST_REMOVE_HEAD(&tc->entries, list);\n\tprint_list_backwards(tc, \"D\");\n\tAST_DLLIST_REMOVE_HEAD(&tc->entries, list);\n\tif (AST_DLLIST_EMPTY(&tc->entries))\n\t\tast_debug(1,\"Test AST_DLLIST_REMOVE_HEAD....OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_REMOVE_HEAD....PROBLEM!!\\n\");\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, a, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, a, b, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, b, c, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, c, d, list);\n\tast_debug(1,\"Test AST_DLLIST_REMOVE\\n\");\n\tAST_DLLIST_REMOVE(&tc->entries, c, list);\n\tprint_list(tc, \"A <=> B <=> D\");\n\tAST_DLLIST_REMOVE(&tc->entries, a, list);\n\tprint_list(tc, \"B <=> D\");\n\tAST_DLLIST_REMOVE(&tc->entries, d, list);\n\tprint_list(tc, \"B\");\n\tAST_DLLIST_REMOVE(&tc->entries, b, list);\n\tif (AST_DLLIST_EMPTY(&tc->entries))\n\t\tast_debug(1,\"Test AST_DLLIST_REMOVE....OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_REMOVE....PROBLEM!!\\n\");\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, a, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, a, b, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, b, c, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, c, d, list);\n\tAST_DLLIST_TRAVERSE_SAFE_BEGIN(&tc->entries, e, list) {\n\t\tAST_DLLIST_REMOVE_CURRENT(list);\n\t}\n\tAST_DLLIST_TRAVERSE_SAFE_END;\n\tif (AST_DLLIST_EMPTY(&tc->entries))\n\t\tast_debug(1,\"Test AST_DLLIST_REMOVE_CURRENT... OK\\n\");\n\telse\n\t\tast_log(LOG_ERROR,\"Test AST_DLLIST_REMOVE_CURRENT... PROBLEM\\n\");\n\tast_debug(1,\"Test AST_DLLIST_MOVE_CURRENT, AST_DLLIST_INSERT_BEFORE_CURRENT\\n\");\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, a, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, a, b, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, b, c, list);\n\tAST_DLLIST_TRAVERSE_SAFE_BEGIN(&tc->entries, e, list) {\n\t\tif (e == a) {\n\t\t\tAST_DLLIST_INSERT_BEFORE_CURRENT(d, list);  \n\t\t}\n\t\tif (e == b) {\n\t\t\tAST_DLLIST_MOVE_CURRENT(&tc->entries, list); \n\t\t}\n\t}\n\tAST_DLLIST_TRAVERSE_SAFE_END;\n\tprint_list(tc, \"D <=> A <=> C <=> B\");\n\tdestroy_test_container(tc);\n\ttc = make_cont();\n\ta = make_test1(\"A\");\n\tb = make_test1(\"B\");\n\tc = make_test1(\"C\");\n\td = make_test1(\"D\");\n\tast_debug(1,\"Test: AST_DLLIST_MOVE_CURRENT_BACKWARDS and AST_DLLIST_INSERT_BEFORE_CURRENT_BACKWARDS\\n\");\n\tAST_DLLIST_INSERT_HEAD(&tc->entries, a, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, a, b, list);\n\tAST_DLLIST_INSERT_AFTER(&tc->entries, b, c, list);\n\tAST_DLLIST_TRAVERSE_BACKWARDS_SAFE_BEGIN(&tc->entries, e, list) {\n\t\tif (e == c && AST_DLLIST_FIRST(&tc->entries) != c) {\n\t\t\tAST_DLLIST_MOVE_CURRENT_BACKWARDS(&tc->entries, list); \n\t\t\tprint_list(tc, \"C <=> A <=> B\");\n\t\t}\n\t\tif (e == b) {\n\t\t\tAST_DLLIST_REMOVE_CURRENT(list);  \n\t\t\tast_free(b);\n\t\t\tprint_list(tc, \"C <=> A\");\n\t\t}\n\t\tif (e == a) {\n\t\t\tAST_DLLIST_INSERT_BEFORE_CURRENT_BACKWARDS(d, list); \n\t\t\tprint_list(tc, \"C <=> A <=> D\");\n\t\t}\n\t}\n\tAST_DLLIST_TRAVERSE_SAFE_END;\n\tprint_list(tc, \"C <=> A <=> D\");\n\tdestroy_test_container(tc);\n}\n", "bug_type": null, "idx": 91}
{"project": "Asterisk", "target": 0, "func": "static char *handle_restart_now(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"core restart now\";\n\t\te->usage =\n\t\t\t\"Usage: core restart now\\n\"\n\t\t\t\"       Causes Asterisk to hangup all calls and exec() itself performing a cold\\n\"\n\t\t\t\"       restart.\\n\";\n\t\tast_cli_allow_at_shutdown(e);\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != e->args)\n\t\treturn CLI_SHOWUSAGE;\n\tquit_handler(0, SHUTDOWN_NORMAL, 1 );\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 92}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *ast_json_name_number(const char *name, const char *number)\n{\n\treturn ast_json_pack(\"{s: s, s: s}\",\n\t\t\"name\", AST_JSON_UTF8_VALIDATE(name),\n\t\t\"number\", AST_JSON_UTF8_VALIDATE(number));\n}\n", "bug_type": null, "idx": 93}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function file_count_line_function = {\n\t.name = \"FILE_COUNT_LINE\",\n\t.read2 = file_count_line,\n\t.read_max = 12,\n};\n", "bug_type": null, "idx": 94}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245CertSelectionCriteria (OOCTXT* pctxt, H245CertSelectionCriteria* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };\n   int stat = ASN_OK;\n   DListNode* pnode;\n   ASN1UINT xx1;\n   \n   addSizeConstraint (pctxt, &lsize1);\n   stat = encodeLength (pctxt, pvalue->count);\n   if (stat < 0) return stat;\n   \n   pnode = pvalue->head;\n   for (xx1 = 0; xx1 < pvalue->count; xx1++) {\n      stat = asn1PE_H245Criteria (pctxt, ((H245Criteria*)pnode->data));\n      if (stat != ASN_OK) return stat;\n      pnode = pnode->next;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 95}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void handler(const char *name,\n\t\t    int response_code,\n\t\t    struct ast_variable *get_params,\n\t\t    struct ast_variable *path_vars,\n\t\t    struct ast_variable *headers,\n\t\t    struct ast_json *body,\n\t\t    struct ast_ari_response *response)\n{\n\tstruct ast_json *message = ast_json_pack(\"{s: s, s: {}, s: {}, s: {}}\",\n\t\t\t\t\t\t \"name\", name,\n\t\t\t\t\t\t \"get_params\",\n\t\t\t\t\t\t \"path_vars\",\n\t\t\t\t\t\t \"headers\");\n\tstruct ast_json *get_params_obj = ast_json_object_get(message, \"get_params\");\n\tstruct ast_json *path_vars_obj = ast_json_object_get(message, \"path_vars\");\n\tstruct ast_json *headers_obj = ast_json_object_get(message, \"headers\");\n\tfor (; get_params != NULL; get_params = get_params->next) {\n\t\tast_json_object_set(get_params_obj, get_params->name, ast_json_string_create(get_params->value));\n\t}\n\tfor (; path_vars != NULL; path_vars = path_vars->next) {\n\t\tast_json_object_set(path_vars_obj, path_vars->name, ast_json_string_create(path_vars->value));\n\t}\n\tfor (; headers != NULL; headers = headers->next) {\n\t\tast_json_object_set(headers_obj, headers->name, ast_json_string_create(headers->value));\n\t}\n\t++invocation_count;\n\tresponse->response_code = response_code;\n\tresponse->message = message;\n}\n", "bug_type": null, "idx": 96}
{"project": "Asterisk", "target": 0, "func": "static enum stasis_app_control_channel_result check_rule_recording(\n\tconst struct stasis_app_control *control)\n{\n\treturn STASIS_APP_CHANNEL_RECORDING;\n}\n", "bug_type": null, "idx": 97}
{"project": "Asterisk", "target": 0, "func": "static int show_users_cb(void *obj, void *arg, int flags)\n{\n\tstruct ast_ari_conf_user *user = obj;\n\tstruct ast_cli_args *a = arg;\n\tast_cli(a->fd, \"%-4s  %s\\n\",\n\t\tAST_CLI_YESNO(user->read_only),\n\t\tuser->username);\n\treturn 0;\n}\n", "bug_type": null, "idx": 98}
{"project": "Asterisk", "target": 0, "func": "};\nint ast_tone_zone_part_parse(const char *s, struct ast_tone_zone_part *tone_data)\n{\n\tif (sscanf(s, \"%30u+%30u/%30u\", &tone_data->freq1, &tone_data->freq2,\n\t\t\t&tone_data->time) == 3) {\n\t\t\n\t} else if (sscanf(s, \"%30u+%30u\", &tone_data->freq1, &tone_data->freq2) == 2) {\n\t\t\n\t\ttone_data->time = 0;\n\t} else if (sscanf(s, \"%30u*%30u/%30u\", &tone_data->freq1, &tone_data->freq2,\n\t\t\t&tone_data->time) == 3) {\n\t\t\n\t\ttone_data->modulate = 1;\n\t} else if (sscanf(s, \"%30u*%30u\", &tone_data->freq1, &tone_data->freq2) == 2) {\n\t\t\n\t\ttone_data->time = 0;\n\t\ttone_data->modulate = 1;\n\t} else if (sscanf(s, \"%30u/%30u\", &tone_data->freq1, &tone_data->time) == 2) {\n\t\t\n\t\ttone_data->freq2 = 0;\n\t} else if (sscanf(s, \"%30u\", &tone_data->freq1) == 1) {\n\t\t\n\t\ttone_data->freq2 = 0;\n\t\ttone_data->time = 0;\n\t} else if (sscanf(s, \"M%30u+M%30u/%30u\", &tone_data->freq1, &tone_data->freq2,\n\t\t\t&tone_data->time) == 3) {\n\t\t\n\t\ttone_data->midinote = 1;\n\t} else if (sscanf(s, \"M%30u+M%30u\", &tone_data->freq1, &tone_data->freq2) == 2) {\n\t\t\n\t\ttone_data->time = 0;\n\t\ttone_data->midinote = 1;\n\t} else if (sscanf(s, \"M%30u*M%30u/%30u\", &tone_data->freq1, &tone_data->freq2,\n\t\t\t&tone_data->time) == 3) {\n\t\t\n\t\ttone_data->modulate = 1;\n\t\ttone_data->midinote = 1;\n\t} else if (sscanf(s, \"M%30u*M%30u\", &tone_data->freq1, &tone_data->freq2) == 2) {\n\t\t\n\t\ttone_data->time = 0;\n\t\ttone_data->modulate = 1;\n\t\ttone_data->midinote = 1;\n\t} else if (sscanf(s, \"M%30u/%30u\", &tone_data->freq1, &tone_data->time) == 2) {\n\t\t\n\t\ttone_data->freq2 = -1;\n\t\ttone_data->midinote = 1;\n\t} else if (sscanf(s, \"M%30u\", &tone_data->freq1) == 1) {\n\t\t\n\t\ttone_data->freq2 = -1;\n\t\ttone_data->time = 0;\n\t\ttone_data->midinote = 1;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 99}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void lua_create_hangup_function(lua_State *L)\n{\n\tlua_pushcfunction(L, &lua_check_hangup);\n\tlua_setglobal(L, \"check_hangup\");\n}\n", "bug_type": null, "idx": 100}
{"project": "Asterisk", "target": 0, "func": "static int speex_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tstruct ast_datastore *datastore = NULL;\n\tstruct speex_info *si = NULL;\n\tstruct speex_direction_info **sdi = NULL;\n\tint is_new = 0;\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\tif (strcasecmp(data, \"rx\") && strcasecmp(data, \"tx\")) {\n\t\tast_log(LOG_ERROR, \"Invalid argument provided to the %s function\\n\", cmd);\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\tif (!(datastore = ast_channel_datastore_find(chan, &speex_datastore, NULL))) {\n\t\tast_channel_unlock(chan);\n\t\tif (!(datastore = ast_datastore_alloc(&speex_datastore, NULL))) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(si = ast_calloc(1, sizeof(*si)))) {\n\t\t\tast_datastore_free(datastore);\n\t\t\treturn 0;\n\t\t}\n\t\tast_audiohook_init(&si->audiohook, AST_AUDIOHOOK_TYPE_MANIPULATE, \"speex\", AST_AUDIOHOOK_MANIPULATE_ALL_RATES);\n\t\tsi->audiohook.manipulate_callback = speex_callback;\n\t\tsi->lastrate = 8000;\n\t\tis_new = 1;\n\t} else {\n\t\tast_channel_unlock(chan);\n\t\tsi = datastore->data;\n\t}\n\tif (!strcasecmp(data, \"rx\")) {\n\t\tsdi = &si->rx;\n\t} else {\n\t\tsdi = &si->tx;\n\t}\n\tif (!*sdi) {\n\t\tif (!(*sdi = ast_calloc(1, sizeof(**sdi)))) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t(*sdi)->samples = -1;\n\t}\n\tif (!strcasecmp(cmd, \"agc\")) {\n\t\tif (!sscanf(value, \"%30f\", &(*sdi)->agclevel))\n\t\t\t(*sdi)->agclevel = ast_true(value) ? DEFAULT_AGC_LEVEL : 0.0;\n\t\tif ((*sdi)->agclevel > 32768.0) {\n\t\t\tast_log(LOG_WARNING, \"AGC(%s)=%.01f is greater than 32768... setting to 32768 instead\\n\", \n\t\t\t\t\t((*sdi == si->rx) ? \"rx\" : \"tx\"), (*sdi)->agclevel);\n\t\t\t(*sdi)->agclevel = 32768.0;\n\t\t}\n\t\t(*sdi)->agc = !!((*sdi)->agclevel);\n\t\tif ((*sdi)->state) {\n\t\t\tspeex_preprocess_ctl((*sdi)->state, SPEEX_PREPROCESS_SET_AGC, &(*sdi)->agc);\n\t\t\tif ((*sdi)->agc) {\n\t\t\t\tspeex_preprocess_ctl((*sdi)->state, SPEEX_PREPROCESS_SET_AGC_LEVEL, &(*sdi)->agclevel);\n\t\t\t}\n\t\t}\n\t} else if (!strcasecmp(cmd, \"denoise\")) {\n\t\t(*sdi)->denoise = (ast_true(value) != 0);\n\t\tif ((*sdi)->state) {\n\t\t\tspeex_preprocess_ctl((*sdi)->state, SPEEX_PREPROCESS_SET_DENOISE, &(*sdi)->denoise);\n\t\t}\n\t}\n\tif (!(*sdi)->agc && !(*sdi)->denoise) {\n\t\tif ((*sdi)->state)\n\t\t\tspeex_preprocess_state_destroy((*sdi)->state);\n\t\tast_free(*sdi);\n\t\t*sdi = NULL;\n\t}\n\tif (!si->rx && !si->tx) {\n\t\tif (is_new) {\n\t\t\tis_new = 0;\n\t\t} else {\n\t\t\tast_channel_lock(chan);\n\t\t\tast_channel_datastore_remove(chan, datastore);\n\t\t\tast_channel_unlock(chan);\n\t\t\tast_audiohook_remove(chan, &si->audiohook);\n\t\t\tast_audiohook_detach(&si->audiohook);\n\t\t}\n\t\tast_datastore_free(datastore);\n\t}\n\tif (is_new) { \n\t\tdatastore->data = si;\n\t\tast_channel_lock(chan);\n\t\tast_channel_datastore_add(chan, datastore);\n\t\tast_channel_unlock(chan);\n\t\tast_audiohook_attach(chan, &si->audiohook);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 101}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res = 0;\n\tCHECK_ARI_MODULE_LOADED();\n\tstasis_app_ref();\n\tres |= ast_ari_add_handler(&sounds);\n\tif (res) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 102}
{"project": "Asterisk", "target": 0, "func": "DEFINE_SQL_STATEMENT(create_astdb_stmt, \"CREATE TABLE IF NOT EXISTS astdb(key VARCHAR(256), value VARCHAR(256), PRIMARY KEY(key))\")\nstatic int db_execute_transaction_sql(const char *sql)\n{\n\tchar *errmsg = NULL;\n\tint res =0;\n\tsqlite3_exec(astdb, sql, NULL, NULL, &errmsg);\n\tif (errmsg) {\n\t\tfprintf(stderr, \"Error executing SQL: %s\\n\", errmsg);\n\t\tsqlite3_free(errmsg);\n\t\tres = -1;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 103}
{"project": "Asterisk", "target": 0, "func": "static int jb_is_late_fixed(void *jb, long ts)\n{\n\treturn fixed_jb_is_late(jb, ts);\n}\n", "bug_type": null, "idx": 104}
{"project": "Asterisk", "target": 0, "func": "int AST_OPTIONAL_API_NAME(ast_smdi_mwi_unset)(struct ast_smdi_interface *iface, const char *mailbox)\n{\n\treturn smdi_toggle_mwi(iface, mailbox, 0);\n}\n", "bug_type": null, "idx": 105}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\treturn ast_custom_function_unregister(&pjsip_endpoint_function);\n}\n", "bug_type": null, "idx": 106}
{"project": "Asterisk", "target": 0, "func": "static struct ast_sip_transport_state *find_temporary_state(struct ast_sip_transport *transport)\n{\n\tstruct ast_sip_transport_state **state;\n\tstate = ast_threadstorage_get(&temp_state_store, sizeof(state));\n\tif (state && *state) {\n\t\tao2_ref(*state, +1);\n\t\treturn *state;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 107}
{"project": "Asterisk", "target": 0, "func": "static int h264_dec_init(AVCodecContext *dec_ctx)\n{\n\tdec_ctx->flags |= CODEC_FLAG_TRUNCATED;\n\treturn 0;\n}\n", "bug_type": null, "idx": 108}
{"project": "Asterisk", "target": 0, "func": "\nstatic int sanity_check(void)\n{\n\tunsigned int insane = 0;\n\tstruct category *cat;\n\tstruct member *mem;\n\tstruct reference *dep;\n\tstruct reference *use;\n\tstruct dep_file *dep_file;\n\tunsigned int dep_header_printed;\n\tunsigned int group_header_printed;\n\tAST_LIST_TRAVERSE(&deps_file, dep_file, list) {\n\t\tif (!((dep_file->previously_met == DEP_FILE_MET) &&\n\t\t      (dep_file->met == DEP_FILE_UNMET))) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdep_header_printed = 0;\n\t\tgroup_header_printed = 0;\n\t\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n\t\t\t\tif (mem->is_separator) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!mem->enabled) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tAST_LIST_TRAVERSE(&mem->deps, dep, list) {\n\t\t\t\t\tif (strcasecmp(dep->name, dep_file->name)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!group_header_printed) {\n\t\t\t\t\t\tif (!dep_header_printed) {\n\t\t\t\t\t\t\tprint_sanity_dep_header(dep_file, &dep_header_printed);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"\\n\"\n\t\t\t\t\t\t\t\"  The following modules will no longer be available:\\n\");\n\t\t\t\t\t\tgroup_header_printed = 1;\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"          %s\\n\", mem->name);\n\t\t\t\t\tinsane = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgroup_header_printed = 0;\n\t\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n\t\t\t\tif (mem->is_separator) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!mem->enabled) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tAST_LIST_TRAVERSE(&mem->uses, use, list) {\n\t\t\t\t\tif (strcasecmp(use->name, dep_file->name)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!group_header_printed) {\n\t\t\t\t\t\tif (!dep_header_printed) {\n\t\t\t\t\t\t\tprint_sanity_dep_header(dep_file, &dep_header_printed);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"\\n\"\n\t\t\t\t\t\t\t\"  The functionality of the following modules will\\n\"\n\t\t\t\t\t\t\t\"  be affected:\\n\");\n\t\t\t\t\t\tgroup_header_printed = 1;\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"          %s\\n\", mem->name);\n\t\t\t\t\tinsane = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dep_header_printed) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"***********************************************************\\n\");\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n\t\t\tif (mem->is_separator) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((mem->depsfailed || mem->conflictsfailed) && mem->enabled) {\n\t\t\t\tfprintf(stderr, \"\\n\"\n\t\t\t\t\t\"***********************************************************\\n\"\n\t\t\t\t\t\"  The existing menuselect.makeopts file did not specify    \\n\"\n\t\t\t\t\t\"  that '%s' should not be included.  However, either some  \\n\"\n\t\t\t\t\t\"  dependencies for this module were not found or a         \\n\"\n\t\t\t\t\t\"  conflict exists.                                         \\n\"\n\t\t\t\t\t\"                                                           \\n\"\n\t\t\t\t\t\"  Either run 'make menuselect' or remove the existing      \\n\"\n\t\t\t\t\t\"  menuselect.makeopts file to resolve this issue.          \\n\"\n\t\t\t\t\t\"***********************************************************\\n\"\n\t\t\t\t\t\"\\n\", mem->name);\n\t\t\t\tinsane = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn insane ? -1 : 0;\n}\n", "bug_type": null, "idx": 109}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\twav_f.format = ast_format_slin;\n\twav16_f.format = ast_format_slin16;\n\tif (ast_format_def_register(&wav_f)\n\t\t|| ast_format_def_register(&wav16_f)) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 110}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(str_to_ulong)\n{\n\tconst char *invalid = \"abc\";\n\tconst char *invalid_partial = \"7abc\";\n\tconst char *negative = \"-7\";\n\tconst char *negative_spaces = \"  -7\";\n\tconst char *out_of_range = \"99999999999999999999\";\n\tconst char *spaces = \"  \";\n\tconst char *valid = \"7\";\n\tconst char *valid_spaces = \"  7\";\n\tunsigned long val;\n\tchar str[64];\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = __func__;\n\t\tinfo->category = CATEGORY;\n\t\tinfo->summary = \"convert a string to an unsigned long\";\n\t\tinfo->description = info->summary;\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tast_test_validate(test, ast_str_to_ulong(NULL, &val));\n\tast_test_validate(test, ast_str_to_ulong(invalid, &val));\n\tast_test_validate(test, ast_str_to_ulong(invalid_partial, &val));\n\tast_test_validate(test, ast_str_to_ulong(negative, &val));\n\tast_test_validate(test, ast_str_to_ulong(negative_spaces, &val));\n\tast_test_validate(test, ast_str_to_ulong(out_of_range, &val));\n\tast_test_validate(test, ast_str_to_ulong(spaces, &val));\n\tast_test_validate(test, !ast_str_to_ulong(valid, &val));\n\tast_test_validate(test, !ast_str_to_ulong(valid_spaces, &val));\n\tast_test_validate(test, snprintf(str, sizeof(str), \"%lu\", ULONG_MAX) > 0);\n\tast_test_validate(test, !ast_str_to_ulong(str, &val));\n\tast_test_validate(test, val == ULONG_MAX);\n\treturn AST_TEST_PASS;\n}\n", "bug_type": null, "idx": 111}
{"project": "Asterisk", "target": 0, "func": "static int test_sip_rtpqos_1_write(struct ast_rtp_instance *instance, struct ast_frame *frame)\n{\n\t\n\treturn 0;\n}\n", "bug_type": null, "idx": 112}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245NewATMVCCommand_aal (OOCTXT* pctxt, H245NewATMVCCommand_aal* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 2);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 1);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NewATMVCCommand_aal_aal1 (pctxt, pvalue->u.aal1);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245NewATMVCCommand_aal_aal5 (pctxt, pvalue->u.aal5);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 3);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 113}
{"project": "Asterisk", "target": 0, "func": "void ast_dial_set_user_data(struct ast_dial *dial, void *user_data)\n{\n\tdial->user_data = user_data;\n}\n", "bug_type": null, "idx": 114}
{"project": "Asterisk", "target": 0, "func": "static int cc_status_request(void *data)\n{\n\tstruct cc_core_instance *core_instance= data;\n\tint res;\n\tres = core_instance->agent->callbacks->status_request(core_instance->agent);\n\tcc_unref(core_instance, \"Status request finished. Unref core instance\");\n\treturn res;\n}\n", "bug_type": null, "idx": 115}
{"project": "Asterisk", "target": 0, "func": "void ast_rtp_codecs_payloads_set_m_type(struct ast_rtp_codecs *codecs, struct ast_rtp_instance *instance, int payload)\n{\n\tstruct ast_rtp_payload_type *new_type;\n\tif (payload < 0 || payload >= AST_RTP_MAX_PT) {\n\t\treturn;\n\t}\n\tast_rwlock_rdlock(&static_RTP_PT_lock);\n\tnew_type = ao2_bump(static_RTP_PT[payload]);\n\tast_rwlock_unlock(&static_RTP_PT_lock);\n\tif (!new_type) {\n\t\tast_debug(1, \"Don't have a default tx payload type %d format for m type on %p\\n\",\n\t\t\tpayload, codecs);\n\t\treturn;\n\t}\n\tast_debug(1, \"Setting tx payload type %d based on m type on %p\\n\",\n\t\tpayload, codecs);\n\tast_rwlock_wrlock(&codecs->codecs_lock);\n\tif (!payload_mapping_tx_is_present(codecs, new_type)) {\n\t\tif (payload < AST_VECTOR_SIZE(&codecs->payload_mapping_tx)) {\n\t\t\tao2_t_cleanup(AST_VECTOR_GET(&codecs->payload_mapping_tx, payload),\n\t\t\t\t\"cleaning up replaced tx payload type\");\n\t\t}\n\t\tAST_VECTOR_REPLACE(&codecs->payload_mapping_tx, payload, new_type);\n\t\tif (instance && instance->engine && instance->engine->payload_set) {\n\t\t\tao2_lock(instance);\n\t\t\tinstance->engine->payload_set(instance, payload, new_type->asterisk_format, new_type->format, new_type->rtp_code);\n\t\t\tao2_unlock(instance);\n\t\t}\n\t} else {\n\t\tao2_ref(new_type, -1);\n\t}\n\tast_rwlock_unlock(&codecs->codecs_lock);\n}\n", "bug_type": null, "idx": 116}
{"project": "Asterisk", "target": 0, "func": "\nvi_to_end_word(EditLine *el, int c)\n{\n\tif (el->el_line.cursor == el->el_line.lastchar)\n\t\treturn (CC_ERROR);\n\tel->el_line.cursor = cv__endword(el->el_line.cursor,\n\t    el->el_line.lastchar, el->el_state.argument);\n\tif (el->el_chared.c_vcmd.action & DELETE) {\n\t\tel->el_line.cursor++;\n\t\tcv_delfini(el);\n\t\treturn (CC_REFRESH);\n\t}\n\treturn (CC_CURSOR);\n}\n", "bug_type": null, "idx": 117}
{"project": "Asterisk", "target": 0, "func": "void stasis_log_bad_type_access(const char *name)\n{\n#ifdef AST_DEVMODE\n\tast_log(LOG_ERROR, \"Use of %s() before init/after destruction\\n\", name);\n#endif\n}\n", "bug_type": null, "idx": 118}
{"project": "Asterisk", "target": 0, "func": "static inline float tdd_getcarrier(float *cr, float *ci, int bit)\n{\n\t\n\tfloat t;\n\tt = *cr * dr[bit] - *ci * di[bit];\n\t*ci = *cr * di[bit] + *ci * dr[bit];\n\t*cr = t;\n\tt = 2.0 - (*cr * *cr + *ci * *ci);\n\t*cr *= t;\n\t*ci *= t;\n\treturn *cr;\n}\n", "bug_type": null, "idx": 119}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_is_t38_active_nolock(struct ast_channel *chan)\n{\n\treturn chan->is_t38_active;\n}\n", "bug_type": null, "idx": 120}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_config(int reload)\n{\n\tload_config_meetme(reload);\n\treturn sla_load_config(reload);\n}\n", "bug_type": null, "idx": 121}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_requires_authentication(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata)\n{\n\tif (!registered_authenticator) {\n\t\tast_log(LOG_WARNING, \"No SIP authenticator registered. Assuming authentication is not required\\n\");\n\t\treturn 0;\n\t}\n\treturn registered_authenticator->requires_authentication(endpoint, rdata);\n}\n", "bug_type": null, "idx": 122}
{"project": "Asterisk", "target": 0, "func": " */\nconst char *ast_get_context_registrar(struct ast_context *c)\n{\n\treturn c ? c->registrar : NULL;\n}\n", "bug_type": null, "idx": 123}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MultiplexFormat (OOCTXT* pctxt, H245MultiplexFormat* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 3);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 2);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245H222Capability (pctxt, pvalue->u.h222Capability);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245H223Capability (pctxt, pvalue->u.h223Capability);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 4);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 124}
{"project": "Asterisk", "target": 0, "func": "#if defined(HAVE_SS7)\nstatic char *handle_ss7_show_channels(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint linkset;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"ss7 show channels\";\n\t\te->usage =\n\t\t\t\"Usage: ss7 show channels\\n\"\n\t\t\t\"       Displays SS7 channel information at a glance.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tsig_ss7_cli_show_channels_header(a->fd);\n\tfor (linkset = 0; linkset < NUM_SPANS; ++linkset) {\n\t\tif (linksets[linkset].ss7.ss7) {\n\t\t\tsig_ss7_cli_show_channels(a->fd, &linksets[linkset].ss7);\n\t\t}\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 125}
{"project": "Asterisk", "target": 0, "func": "static char *complete_userno(struct ast_conference *cnf, const char *word, int state)\n{\n\tchar usrno[50];\n\tstruct ao2_iterator iter;\n\tstruct ast_conf_user *usr;\n\tchar *ret = NULL;\n\tint which = 0;\n\tint len = strlen(word);\n\titer = ao2_iterator_init(cnf->usercontainer, 0);\n\tfor (; (usr = ao2_iterator_next(&iter)); ao2_ref(usr, -1)) {\n\t\tsnprintf(usrno, sizeof(usrno), \"%d\", usr->user_no);\n\t\tif (!strncmp(word, usrno, len) && ++which > state) {\n\t\t\tao2_ref(usr, -1);\n\t\t\tret = ast_strdup(usrno);\n\t\t\tbreak;\n\t\t}\n\t}\n\tao2_iterator_destroy(&iter);\n\treturn ret;\n}\n", "bug_type": null, "idx": 126}
{"project": "Asterisk", "target": 0, "func": "\nstatic int jingle_add_payloads_to_description(struct jingle_session *session, struct ast_rtp_instance *rtp, iks *description, iks **payloads, enum ast_media_type type)\n{\n\tint x = 0, i = 0, res = 0;\n\tfor (x = 0; (x < ast_format_cap_count(session->jointcap)) && (i < (session->maxpayloads - 2)); x++) {\n\t\tstruct ast_format *format = ast_format_cap_get_format(session->jointcap, x);\n\t\tint rtp_code;\n\t\tiks *payload;\n\t\tchar tmp[32];\n\t\tif (ast_format_get_type(format) != type) {\n\t\t\tao2_ref(format, -1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (((rtp_code = ast_rtp_codecs_payload_code(ast_rtp_instance_get_codecs(rtp), 1, format, 0)) == -1) ||\n\t\t    (!(payload = iks_new(\"payload-type\")))) {\n\t\t\tao2_ref(format, -1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (session->transport == JINGLE_TRANSPORT_GOOGLE_V1) {\n\t\t\tiks_insert_attrib(payload, \"xmlns\", GOOGLE_PHONE_NS);\n\t\t}\n\t\tsnprintf(tmp, sizeof(tmp), \"%d\", rtp_code);\n\t\tiks_insert_attrib(payload, \"id\", tmp);\n\t\tiks_insert_attrib(payload, \"name\", ast_rtp_lookup_mime_subtype2(1, format, 0, 0));\n\t\tiks_insert_attrib(payload, \"channels\", \"1\");\n\t\tif ((ast_format_cmp(format, ast_format_g722) == AST_FORMAT_CMP_EQUAL) &&\n\t\t\t((session->transport == JINGLE_TRANSPORT_GOOGLE_V1) || (session->transport == JINGLE_TRANSPORT_GOOGLE_V2))) {\n\t\t\tiks_insert_attrib(payload, \"clockrate\", \"16000\");\n\t\t} else {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%u\", ast_rtp_lookup_sample_rate2(1, format, 0));\n\t\t\tiks_insert_attrib(payload, \"clockrate\", tmp);\n\t\t}\n\t\tif ((type == AST_MEDIA_TYPE_VIDEO) && (session->transport == JINGLE_TRANSPORT_GOOGLE_V2)) {\n\t\t\tiks *parameter;\n\t\t\t\n\t\t\tif ((parameter = iks_new(\"parameter\"))) {\n\t\t\t\tiks_insert_attrib(parameter, \"name\", \"width\");\n\t\t\t\tiks_insert_attrib(parameter, \"value\", \"640\");\n\t\t\t\tiks_insert_node(payload, parameter);\n\t\t\t}\n\t\t\tif ((parameter = iks_new(\"parameter\"))) {\n\t\t\t\tiks_insert_attrib(parameter, \"name\", \"height\");\n\t\t\t\tiks_insert_attrib(parameter, \"value\", \"480\");\n\t\t\t\tiks_insert_node(payload, parameter);\n\t\t\t}\n\t\t\tif ((parameter = iks_new(\"parameter\"))) {\n\t\t\t\tiks_insert_attrib(parameter, \"name\", \"framerate\");\n\t\t\t\tiks_insert_attrib(parameter, \"value\", \"30\");\n\t\t\t\tiks_insert_node(payload, parameter);\n\t\t\t}\n\t\t}\n\t\tiks_insert_node(description, payload);\n\t\tpayloads[i++] = payload;\n\t\tao2_ref(format, -1);\n\t}\n\t\n\tif ((type == AST_MEDIA_TYPE_AUDIO) && (i < session->maxpayloads)) {\n\t\tiks *payload;\n\t\tif ((payload = iks_new(\"payload-type\"))) {\n\t\t\tif (session->transport == JINGLE_TRANSPORT_GOOGLE_V1) {\n\t\t\t\tiks_insert_attrib(payload, \"xmlns\", GOOGLE_PHONE_NS);\n\t\t\t}\n\t\t\tiks_insert_attrib(payload, \"id\", \"101\");\n\t\t\tiks_insert_attrib(payload, \"name\", \"telephone-event\");\n\t\t\tiks_insert_attrib(payload, \"channels\", \"1\");\n\t\t\tiks_insert_attrib(payload, \"clockrate\", \"8000\");\n\t\t\tiks_insert_node(description, payload);\n\t\t\tpayloads[i++] = payload;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 127}
{"project": "Asterisk", "target": 0, "func": "\nstatic char *handle_cli_core_show_channeltype(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct chanlist *cl = NULL;\n\tstruct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"core show channeltype\";\n\t\te->usage =\n\t\t\t\"Usage: core show channeltype <name>\\n\"\n\t\t\t\"\tShow details about the specified channel type, <name>.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn complete_channeltypes(a);\n\t}\n\tif (a->argc != 4)\n\t\treturn CLI_SHOWUSAGE;\n\tAST_RWLIST_RDLOCK(&backends);\n\tAST_RWLIST_TRAVERSE(&backends, cl, list) {\n\t\tif (!strncasecmp(cl->tech->type, a->argv[3], strlen(cl->tech->type)))\n\t\t\tbreak;\n\t}\n\tif (!cl) {\n\t\tast_cli(a->fd, \"\\n%s is not a registered channel driver.\\n\", a->argv[3]);\n\t\tAST_RWLIST_UNLOCK(&backends);\n\t\treturn CLI_FAILURE;\n\t}\n\tast_cli(a->fd,\n\t\t\"-- Info about channel driver: %s --\\n\"\n\t\t\"  Device State: %s\\n\"\n\t\t\"Presence State: %s\\n\"\n\t\t\"    Indication: %s\\n\"\n\t\t\"     Transfer : %s\\n\"\n\t\t\"  Capabilities: %s\\n\"\n\t\t\"   Digit Begin: %s\\n\"\n\t\t\"     Digit End: %s\\n\"\n\t\t\"    Send HTML : %s\\n\"\n\t\t\" Image Support: %s\\n\"\n\t\t\"  Text Support: %s\\n\",\n\t\tcl->tech->type,\n\t\t(cl->tech->devicestate) ? \"yes\" : \"no\",\n\t\t(cl->tech->presencestate) ? \"yes\" : \"no\",\n\t\t(cl->tech->indicate) ? \"yes\" : \"no\",\n\t\t(cl->tech->transfer) ? \"yes\" : \"no\",\n\t\tast_format_cap_get_names(cl->tech->capabilities, &codec_buf),\n\t\t(cl->tech->send_digit_begin) ? \"yes\" : \"no\",\n\t\t(cl->tech->send_digit_end) ? \"yes\" : \"no\",\n\t\t(cl->tech->send_html) ? \"yes\" : \"no\",\n\t\t(cl->tech->send_image) ? \"yes\" : \"no\",\n\t\t(cl->tech->send_text) ? \"yes\" : \"no\"\n\t);\n\tAST_RWLIST_UNLOCK(&backends);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 128}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_session_unsuspend(struct ast_sip_session *session)\n{\n\tstruct ast_sip_session_suspender *suspender = session->suspended;\n\tif (!suspender) {\n\t\t\n\t\treturn;\n\t}\n\tsession->suspended = NULL;\n\t\n\tao2_lock(suspender);\n\tsuspender->complete = 1;\n\tast_cond_signal(&suspender->cond_complete);\n\tao2_unlock(suspender);\n\tao2_ref(suspender, -1);\n\tast_taskprocessor_unsuspend(session->serializer);\n}\n", "bug_type": null, "idx": 129}
{"project": "Asterisk", "target": 0, "func": "int ast_extension_state_del(int id, ast_state_cb_type change_cb)\n{\n\tstruct ast_state_cb *p_cur;\n\tint ret = -1;\n\tif (!id) {\t\n\t\tif (!change_cb) {\n\t\t\treturn ret;\n\t\t}\n\t\tp_cur = ao2_find(statecbs, change_cb, OBJ_UNLINK);\n\t\tif (p_cur) {\n\t\t\tret = 0;\n\t\t\tao2_ref(p_cur, -1);\n\t\t}\n\t} else { \n\t\tstruct ast_hint *hint;\n\t\tao2_lock(hints);\n\t\thint = ao2_callback(hints, 0, find_hint_by_cb_id, &id);\n\t\tif (hint) {\n\t\t\tp_cur = ao2_find(hint->callbacks, &id, OBJ_UNLINK);\n\t\t\tif (p_cur) {\n\t\t\t\tret = 0;\n\t\t\t\tao2_ref(p_cur, -1);\n\t\t\t}\n\t\t\tao2_ref(hint, -1);\n\t\t}\n\t\tao2_unlock(hints);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 130}
{"project": "Asterisk", "target": 0, "func": "static int extenspy_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *ptr, *exten = NULL;\n\tchar *mygroup = NULL;\n\tchar *recbase = NULL;\n\tint fd = 0;\n\tstruct ast_flags flags;\n\tstruct spy_dtmf_options user_options = {\n\t\t.cycle = '*',\n\t\t.volume = '#',\n\t\t.exit = '\\0',\n\t};\n\tRAII_VAR(struct ast_format *, oldwf, NULL, ao2_cleanup);\n\tint volfactor = 0;\n\tint res;\n\tchar *mailbox = NULL;\n\tchar *name_context = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(context);\n\t\tAST_APP_ARG(options);\n\t);\n\tchar *parse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (!ast_strlen_zero(args.context) && (ptr = strchr(args.context, '@'))) {\n\t\texten = args.context;\n\t\t*ptr++ = '\\0';\n\t\targs.context = ptr;\n\t}\n\tif (ast_strlen_zero(args.context))\n\t\targs.context = ast_strdupa(ast_channel_context(chan));\n\tif (args.options) {\n\t\tchar *opts[OPT_ARG_ARRAY_SIZE];\n\t\tchar tmp;\n\t\tast_app_parse_options(spy_opts, &flags, opts, args.options);\n\t\tif (ast_test_flag(&flags, OPTION_GROUP))\n\t\t\tmygroup = opts[OPT_ARG_GROUP];\n\t\tif (ast_test_flag(&flags, OPTION_RECORD) &&\n\t\t\t!(recbase = opts[OPT_ARG_RECORD]))\n\t\t\trecbase = \"chanspy\";\n\t\tif (ast_test_flag(&flags, OPTION_DTMF_EXIT) && opts[OPT_ARG_EXIT]) {\n\t\t\ttmp = opts[OPT_ARG_EXIT][0];\n\t\t\tif (strchr(\"0123456789*#\", tmp) && tmp != '\\0') {\n\t\t\t\tuser_options.exit = tmp;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_NOTICE, \"Argument for option 'x' must be a valid DTMF digit.\\n\");\n\t\t\t}\n\t\t}\n\t\tif (ast_test_flag(&flags, OPTION_DTMF_CYCLE) && opts[OPT_ARG_CYCLE]) {\n\t\t\ttmp = opts[OPT_ARG_CYCLE][0];\n\t\t\tif (strchr(\"0123456789*#\", tmp) && tmp != '\\0') {\n\t\t\t\tuser_options.cycle = tmp;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_NOTICE, \"Argument for option 'c' must be a valid DTMF digit.\\n\");\n\t\t\t}\n\t\t}\n\t\tif (ast_test_flag(&flags, OPTION_VOLUME) && opts[OPT_ARG_VOLUME]) {\n\t\t\tint vol;\n\t\t\tif ((sscanf(opts[OPT_ARG_VOLUME], \"%30d\", &vol) != 1) || (vol > 4) || (vol < -4))\n\t\t\t\tast_log(LOG_NOTICE, \"Volume factor must be a number between -4 and 4\\n\");\n\t\t\telse\n\t\t\t\tvolfactor = vol;\n\t\t}\n\t\tif (ast_test_flag(&flags, OPTION_PRIVATE))\n\t\t\tast_set_flag(&flags, OPTION_WHISPER);\n\t\tif (ast_test_flag(&flags, OPTION_NAME)) {\n\t\t\tif (!ast_strlen_zero(opts[OPT_ARG_NAME])) {\n\t\t\t\tchar *delimiter;\n\t\t\t\tif ((delimiter = strchr(opts[OPT_ARG_NAME], '@'))) {\n\t\t\t\t\tmailbox = opts[OPT_ARG_NAME];\n\t\t\t\t\t*delimiter++ = '\\0';\n\t\t\t\t\tname_context = delimiter;\n\t\t\t\t} else {\n\t\t\t\t\tmailbox = opts[OPT_ARG_NAME];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t\n\t\tast_clear_flag(&flags, AST_FLAGS_ALL);\n\t}\n\toldwf = ao2_bump(ast_channel_writeformat(chan));\n\tif (ast_set_write_format(chan, ast_format_slin) < 0) {\n\t\tast_log(LOG_ERROR, \"Could Not Set Write Format.\\n\");\n\t\treturn -1;\n\t}\n\tif (recbase) {\n\t\tchar filename[PATH_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s.%d.raw\", ast_config_AST_MONITOR_DIR, recbase, (int) time(NULL));\n\t\tif ((fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, AST_FILE_MODE)) <= 0) {\n\t\t\tast_log(LOG_WARNING, \"Cannot open '%s' for recording\\n\", filename);\n\t\t\tfd = 0;\n\t\t}\n\t}\n\tres = common_exec(chan, &flags, volfactor, fd, &user_options, mygroup, NULL, NULL, exten, args.context, mailbox, name_context);\n\tif (fd)\n\t\tclose(fd);\n\tif (oldwf && ast_set_write_format(chan, oldwf) < 0)\n\t\tast_log(LOG_ERROR, \"Could Not Set Write Format.\\n\");\n\treturn res;\n}\n", "bug_type": null, "idx": 131}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void generate_uuid(struct ast_uuid *uuid)\n{\n\t\n\t\n\tif (!has_dev_urandom) {\n\t\tast_mutex_lock(&uuid_lock);\n\t}\n\tuuid_generate_random(uuid->uu);\n\tif (!has_dev_urandom) {\n\t\tast_mutex_unlock(&uuid_lock);\n\t}\n}\n", "bug_type": null, "idx": 132}
{"project": "Asterisk", "target": 0, "func": "static int realtime_matchmore(struct ast_channel *chan, const char *context, const char *exten, int priority, const char *callerid, const char *data)\n{\n\tstruct ast_variable *var = realtime_common(context, exten, priority, data, MODE_MATCHMORE);\n\tif (var) {\n\t\tast_variables_destroy(var);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 133}
{"project": "Asterisk", "target": 0, "func": "\nstatic int drc_sample(int sample, float drc)\n{\n\tfloat neg;\n\tfloat shallow, steep;\n\tfloat max = SHRT_MAX;\n\tneg = (sample < 0 ? -1 : 1);\n\tsteep = drc*sample;\n\tshallow = neg*(max-max/drc)+(float)sample/drc;\n\tif (fabsf(steep) < fabsf(shallow)) {\n\t\tsample = steep;\n\t}\n\telse {\n\t\tsample = shallow;\n\t}\n\treturn sample;\n}\n", "bug_type": null, "idx": 134}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int distribute(void *data)\n{\n\tstatic pjsip_process_rdata_param param = {\n\t\t.start_mod = &distributor_mod,\n\t\t.idx_after_start = 1,\n\t};\n\tpj_bool_t handled = PJ_FALSE;\n\tpjsip_rx_data *rdata = data;\n\tint is_request = rdata->msg_info.msg->type == PJSIP_REQUEST_MSG;\n\tint is_ack = is_request ? rdata->msg_info.msg->line.req.method.id == PJSIP_ACK_METHOD : 0;\n\tstruct ast_sip_endpoint *endpoint;\n\tpjsip_endpt_process_rx_data(ast_sip_get_pjsip_endpoint(), rdata, &param, &handled);\n\tif (!handled && is_request && !is_ack) {\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 501, NULL, NULL, NULL);\n\t}\n\t\n\tendpoint = rdata->endpt_info.mod_data[endpoint_mod.id];\n\tao2_cleanup(endpoint);\n\tpjsip_rx_data_free_cloned(rdata);\n\treturn 0;\n}\n", "bug_type": null, "idx": 135}
{"project": "Asterisk", "target": 0, "func": "const void *ast_sdp_translator_from_sdp(struct ast_sdp_translator *translator,\n\tconst struct ast_sdp *ast_sdp)\n{\n\treturn translator->ops->from_sdp(ast_sdp, translator->translator_priv);\n}\n", "bug_type": null, "idx": 136}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_response_no_content(struct ast_ari_response *response)\n{\n\tresponse->message = ast_json_null();\n\tresponse->response_code = 204;\n\tresponse->response_text = \"No Content\";\n}\n", "bug_type": null, "idx": 137}
{"project": "Asterisk", "target": 0, "func": "struct pval *find_context(char *name)\n{\n\treturn_on_context_match = 1;\n\tcount_labels = 0;\n\tmatch_context = name;\n\tmatch_exten = \"*\";  \n\tmatch_label = \"*\";\n\treturn match_pval(current_db);\n}\n", "bug_type": null, "idx": 138}
{"project": "Asterisk", "target": 0, "func": "\nstatic void refer_attended_destroy(void *obj)\n{\n\tstruct refer_attended *attended = obj;\n\tao2_cleanup(attended->transferer);\n\tast_channel_cleanup(attended->transferer_chan);\n\tao2_cleanup(attended->transferer_second);\n\tao2_cleanup(attended->progress);\n}\n", "bug_type": null, "idx": 139}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ami_contact_cb(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_contact *contact = obj;\n\tao2_ref(contact, +1);\n\tif (ast_sip_push_task(NULL, qualify_contact_task, contact)) {\n\t\tao2_ref(contact, -1);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 140}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void check_month(pval *MON)\n{\n\tchar *mon;\n\tchar *c;\n\t\n\tint s, e;\n\tmon = ast_strdupa(MON->u1.str);\n\t\n\tif (ast_strlen_zero(mon) || !strcmp(mon, \"*\")) \n\t\treturn ;\n\t\n\tc = strchr(mon, '-');\n\tif (c) {\n\t\t*c = '\\0';\n\t\tc++;\n\t}\n\t\n\ts = 0;\n\twhile ((s < 12) && strcasecmp(mon, months[s])) s++;\n\tif (s >= 12) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The start month (%s) must be a one of: 'jan', 'feb', ..., 'dec'!\\n\",\n\t\t\t\tMON->filename, MON->startline, MON->endline, mon);\n\t\twarns++;\n\t}\n\tif (c) {\n\t\te = 0;\n\t\twhile ((e < 12) && strcasecmp(mon, months[e])) e++;\n\t\tif (e >= 12) {\n\t\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The end month (%s) must be a one of: 'jan', 'feb', ..., 'dec'!\\n\",\n\t\t\t\t\tMON->filename, MON->startline, MON->endline, c);\n\t\t\twarns++;\n\t\t}\n\t} else\n\t\te = s;\n}\n", "bug_type": null, "idx": 141}
{"project": "Asterisk", "target": 0, "func": "static void consumer_reset(struct consumer *consumer)\n{\n\tconsumer->already_out = 0;\n\tconsumer->event_count = 0;\n\tconsumer->state = AST_DEVICE_TOTAL;\n\tconsumer->aggregate_state = AST_DEVICE_TOTAL;\n}\n", "bug_type": null, "idx": 142}
{"project": "Asterisk", "target": 0, "func": "void *ast_stream_get_data(struct ast_stream *stream, enum ast_stream_data_slot slot)\n{\n\tast_assert(stream != NULL);\n\treturn stream->data[slot];\n}\n", "bug_type": null, "idx": 143}
{"project": "Asterisk", "target": 0, "func": "static void *channel_cc_params_copy(void *data)\n{\n\tconst struct ast_cc_config_params *src = data;\n\tstruct ast_cc_config_params *dest = ast_cc_config_params_init();\n\tif (!dest) {\n\t\treturn NULL;\n\t}\n\tast_cc_copy_config_params(dest, src);\n\treturn dest;\n}\n", "bug_type": null, "idx": 144}
{"project": "Asterisk", "target": 0, "func": "int option_matches( struct argdesc *should, pval *is, struct argapp *app)\n{\n\tstruct argchoice *ac;\n\tchar *opcop;\n\tswitch (should->dtype) {\n\tcase ARGD_STRING:\n\t\tif (is_empty(is->u1.str) && should->type == ARGD_REQUIRED)\n\t\t\treturn 0;\n\t\tif (is->u1.str && strlen(is->u1.str) > 0) \n\t\t\treturn 1;\n\t\tbreak;\n\tcase ARGD_INT:\n\t\tif (is_int(is->u1.str))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ARGD_FLOAT:\n\t\tif (is_float(is->u1.str))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ARGD_ENUM:\n\t\tif( !is->u1.str || strlen(is->u1.str) == 0 )\n\t\t\treturn 1; \n\t\tfor (ac=should->choices; ac; ac=ac->next) {\n\t\t\tif (strcmp(ac->name,is->u1.str) == 0)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t\tbreak;\n\tcase ARGD_OPTIONSET:\n\t\topcop = ast_strdupa(is->u1.str);\n\t\tfor (ac=app->opts; ac; ac=ac->next) {\n\t\t\tif (strlen(ac->name)>1  && strchr(ac->name,'(') == 0 && strcmp(ac->name,is->u1.str) == 0) \n\t\t\t\treturn 1;\n\t\t}\n\t\tfor (ac=app->opts; ac; ac=ac->next) {\n\t\t\tif (strlen(ac->name)==1  ||  strchr(ac->name,'(')) {\n\t\t\t\tchar *p = strchr(opcop,ac->name[0]);  \n\t\t\t\tif (p) {\n\t\t\t\t\t*p = '+';\n\t\t\t\t\tif (ac->name[1] == '(') {\n\t\t\t\t\t\tif (*(p+1) == '(') {\n\t\t\t\t\t\t\tchar *q = p+1;\n\t\t\t\t\t\t\twhile (*q && *q != ')') {\n\t\t\t\t\t\t\t\t*q++ = '+';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*q = '+';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t\tbreak;\n\tcase ARGD_VARARG:\n\t\treturn 1; \n\t\tbreak;\n\t}\n\treturn 1; \n}\n", "bug_type": null, "idx": 145}
{"project": "Asterisk", "target": 0, "func": "\nvi_command_mode(EditLine *el, int c)\n{\n\tint size;\n\t\n\tel->el_chared.c_vcmd.ins = 0;\n\tel->el_chared.c_vcmd.action = NOP;\n\tel->el_chared.c_vcmd.pos = 0;\n\tel->el_state.doingarg = 0;\n\tsize = el->el_chared.c_undo.ptr - el->el_line.cursor;\n\tif (size < 0)\n\t\tsize = -size;\n\tif (el->el_chared.c_undo.action == (INSERT | DELETE) ||\n\t    el->el_chared.c_undo.action == DELETE)\n\t\tel->el_chared.c_undo.dsize = size;\n\telse\n\t\tel->el_chared.c_undo.isize = size;\n\tel->el_state.inputmode = MODE_INSERT;\n\tel->el_map.current = el->el_map.alt;\n#ifdef VI_MOVE\n\tif (el->el_line.cursor > el->el_line.buffer)\n\t\tel->el_line.cursor--;\n#endif\n\treturn (CC_CURSOR);\n}\n", "bug_type": null, "idx": 146}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int analog_attempt_transfer(struct analog_pvt *p)\n{\n\tstruct ast_channel *owner_real;\n\tstruct ast_channel *owner_3way;\n\tenum ast_transfer_result xfer_res;\n\tint res = 0;\n\towner_real = ast_channel_ref(p->subs[ANALOG_SUB_REAL].owner);\n\towner_3way = ast_channel_ref(p->subs[ANALOG_SUB_THREEWAY].owner);\n\tast_verb(3, \"TRANSFERRING %s to %s\\n\",\n\t\tast_channel_name(owner_3way), ast_channel_name(owner_real));\n\tast_channel_unlock(owner_real);\n\tast_channel_unlock(owner_3way);\n\tanalog_unlock_private(p);\n\txfer_res = ast_bridge_transfer_attended(owner_3way, owner_real);\n\tif (xfer_res != AST_BRIDGE_TRANSFER_SUCCESS) {\n\t\tast_softhangup(owner_3way, AST_SOFTHANGUP_DEV);\n\t\tres = -1;\n\t}\n\t\n\tast_channel_lock(owner_real);\n\tanalog_lock_private(p);\n\tast_channel_unref(owner_real);\n\tast_channel_unref(owner_3way);\n\treturn res;\n}\n", "bug_type": null, "idx": 147}
{"project": "Asterisk", "target": 0, "func": "protected void\ntty_bind_char(EditLine *el, int force)\n{\n\tunsigned char *t_n = el->el_tty.t_c[ED_IO];\n\tunsigned char *t_o = el->el_tty.t_ed.c_cc;\n\tunsigned char new[2], old[2];\n\tconst ttymap_t *tp;\n\tel_action_t *map, *alt;\n\tconst el_action_t *dmap, *dalt;\n\tnew[1] = old[1] = '\\0';\n\tmap = el->el_map.key;\n\talt = el->el_map.alt;\n\tif (el->el_map.type == MAP_VI) {\n\t\tdmap = el->el_map.vii;\n\t\tdalt = el->el_map.vic;\n\t} else {\n\t\tdmap = el->el_map.emacs;\n\t\tdalt = NULL;\n\t}\n\tfor (tp = tty_map; tp->nch != -1; tp++) {\n\t\tnew[0] = t_n[tp->nch];\n\t\told[0] = t_o[tp->och];\n\t\tif (new[0] == old[0] && !force)\n\t\t\tcontinue;\n\t\t\n\t\tkey_clear(el, map, (char *)old);\n\t\tmap[old[0]] = dmap[old[0]];\n\t\tkey_clear(el, map, (char *)new);\n\t\t\n\t\tmap[new[0]] = tp->bind[el->el_map.type];\n\t\tif (dalt) {\n\t\t\tkey_clear(el, alt, (char *)old);\n\t\t\talt[old[0]] = dalt[old[0]];\n\t\t\tkey_clear(el, alt, (char *)new);\n\t\t\talt[new[0]] = tp->bind[el->el_map.type + 1];\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 148}
{"project": "Asterisk", "target": 0, "func": "\nstatic void enc_ie_channel_id(unsigned char **ntmode, msg_t *msg, int exclusive, int channel, int nt, struct misdn_bchannel *bc)\n{\n\tunsigned char *p;\n\tQ931_info_t *qi = (Q931_info_t *)(msg->data + mISDN_HEADER_LEN);\n\tint l;\n\tstruct misdn_stack *stack=get_stack_by_bc(bc);\n\tint pri = stack->pri;\n\tif (exclusive<0 || exclusive>1)\n\t{\n\t\tprintf(\"%s: ERROR: exclusive(%d) is out of range.\\n\", __FUNCTION__, exclusive);\n\t\treturn;\n\t}\n\tif ((channel<0 || channel>0xff)\n\t    || (!pri && (channel>2 && channel<0xff))\n\t    || (pri && (channel>31 && channel<0xff))\n\t    || (pri && channel==16))\n\t{\n\t\tprintf(\"%s: ERROR: channel(%d) is out of range.\\n\", __FUNCTION__, channel);\n\t\treturn;\n\t}\n\t\n\tif (!pri)\n\t{\n\t\t\n\t\tl = 1;\n\t\tp = msg_put(msg, l+2);\n\t\tif (nt)\n\t\t\t*ntmode = p+1;\n\t\telse\n\t\t\tqi->QI_ELEMENT(channel_id) = p - (unsigned char *)qi - sizeof(Q931_info_t);\n\t\tp[0] = IE_CHANNEL_ID;\n\t\tp[1] = l;\n\t\tif (channel == 0xff)\n\t\t\tchannel = 3;\n\t\tp[2] = 0x80 + (exclusive<<3) + channel;\n\t\t\n\t} else\n\t{\n\t\t\n\t\tif (channel == 0) \n\t\t\treturn; \n\n\t\tif (channel == 0xff) \n\t\t{\n\t\t\tl = 1;\n\t\t\tp = msg_put(msg, l+2);\n\t\t\tif (nt)\n\t\t\t\t*ntmode = p+1;\n\t\t\telse\n\t\t\t\tqi->QI_ELEMENT(channel_id) = p - (unsigned char *)qi - sizeof(Q931_info_t);\n\t\t\tp[0] = IE_CHANNEL_ID;\n\t\t\tp[1] = l;\n\t\t\tp[2] = 0x80 + 0x20 + 0x03;\n\n\t\t\treturn; \n\t\t}\n\t\tl = 3;\n\t\tp = msg_put(msg, l+2);\n\t\tif (nt)\n\t\t\t*ntmode = p+1;\n\t\telse\n\t\t\tqi->QI_ELEMENT(channel_id) = p - (unsigned char *)qi - sizeof(Q931_info_t);\n\t\tp[0] = IE_CHANNEL_ID;\n\t\tp[1] = l;\n\t\tp[2] = 0x80 + 0x20 + (exclusive<<3) + 0x01;\n\t\tp[3] = 0x80 + 3; \n\t\tp[4] = 0x80 + channel;\n\n\t}\n}\n", "bug_type": null, "idx": 149}
{"project": "Asterisk", "target": 0, "func": "static void dump_string(char *output, int maxlen, void *value, int len)\n{\n\tmaxlen--;\n\tif (maxlen > len)\n\t\tmaxlen = len;\n\tstrncpy(output, value, maxlen);\n\toutput[maxlen] = '\\0';\n}\n", "bug_type": null, "idx": 150}
{"project": "Asterisk", "target": 0, "func": "static int unistim_write(struct ast_channel *ast, struct ast_frame *frame)\n{\n\tstruct unistim_subchannel *sub = ast_channel_tech_pvt(ast);\n\tint res = 0;\n\tif (frame->frametype != AST_FRAME_VOICE) {\n\t\tif (frame->frametype == AST_FRAME_IMAGE) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Can't send %u type frames with unistim_write\\n\",\n\t\t\t\t\tframe->frametype);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (ast_format_cap_iscompatible_format(ast_channel_nativeformats(ast), frame->subclass.format) == AST_FORMAT_CMP_NOT_EQUAL) {\n\t\t\tstruct ast_str *cap_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\"Asked to transmit frame type %s, while native formats is %s (read/write = (%s/%s)\\n\",\n\t\t\t\t\tast_format_get_name(frame->subclass.format),\n\t\t\t\t\tast_format_cap_get_names(ast_channel_nativeformats(ast), &cap_buf),\n\t\t\t\t\tast_format_get_name(ast_channel_readformat(ast)),\n\t\t\t\t\tast_format_get_name(ast_channel_writeformat(ast)));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (sub) {\n\t\tast_mutex_lock(&sub->lock);\n\t\tif (sub->rtp) {\n\t\t\tres = ast_rtp_instance_write(sub->rtp, frame);\n\t\t}\n\t\tast_mutex_unlock(&sub->lock);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 151}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_ooh323_show_peer(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tchar ip_port[64];\n\tstruct ooh323_peer *prev = NULL, *peer = NULL;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"ooh323 show peer\";\n\t\te->usage =\n\t\t\t\"Usage: ooh323 show peer <name>\\n\"\n\t\t\t\"\t\t List details of specific OOH323 peer.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4)\n\t\treturn CLI_SHOWUSAGE;\n\tast_mutex_lock(&peerl.lock);\n\tpeer = peerl.peers;\n\twhile (peer) {\n\t\tast_mutex_lock(&peer->lock);\n\t\tif (!strcmp(peer->name, a->argv[3])) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = peer;\n\t\t\tpeer = peer->next;\n\t\t\tast_mutex_unlock(&prev->lock);\n\t\t}\n\t}\n\tif (peer) {\n\t\tsprintf(ip_port, \"%s:%hu\", peer->ip, peer->port);\n\t\tast_cli(a->fd, \"%-15.15s%s\\n\", \"Name: \", peer->name);\n\t\tast_cli(a->fd, \"%s:%s,%s\\n\", \"FastStart/H.245 Tunneling\", peer->faststart?\"yes\":\"no\",\n\t\t\t\t\tpeer->h245tunneling?\"yes\":\"no\");\n\t\tast_cli(a->fd, \"%-15s%s\\n\", \"DirectRTP\", peer->directrtp ? \"yes\" : \"no\");\n\t\tast_cli(a->fd, \"%-15s%s\\n\", \"EarlyDirectRTP\", peer->earlydirect ? \"yes\" : \"no\");\n\t\tast_cli(a->fd, \"%-15.15s\", \"DTMF Mode: \");\n\t\tif (peer->dtmfmode & H323_DTMF_CISCO) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"cisco\");\n\t\t\tast_cli(a->fd, \"%-15.15s%d\\n\", \"DTMF Codec: \", peer->dtmfcodec);\n\t\t} else if (peer->dtmfmode & H323_DTMF_RFC2833) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"rfc2833\");\n\t\t\tast_cli(a->fd, \"%-15.15s%d\\n\", \"DTMF Codec: \", peer->dtmfcodec);\n\t\t} else if (peer->dtmfmode & H323_DTMF_Q931) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"q931keypad\");\n\t\t} else if (peer->dtmfmode & H323_DTMF_H245ALPHANUMERIC) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"h245alphanumeric\");\n\t\t} else if (peer->dtmfmode & H323_DTMF_H245SIGNAL) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"h245signal\");\n\t\t} else if (peer->dtmfmode & H323_DTMF_INBAND && peer->dtmfmode & H323_DTMF_INBANDRELAX) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"inband-relaxed\");\n\t\t} else if (peer->dtmfmode & H323_DTMF_INBAND) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"inband\");\n\t\t} else {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"unknown\");\n\t\t}\n\t\tast_cli(a->fd,\"%-15s\", \"T.38 Mode: \");\n\t\tif (peer->t38support == T38_DISABLED) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"disabled\");\n\t\t} else if (peer->t38support == T38_FAXGW) {\n\t\t\tast_cli(a->fd, \"%s\\n\", \"faxgw/chan_sip compatible\");\n\t\t}\n\t\tif (peer->faxdetect == (FAXDETECT_CNG | FAXDETECT_T38)) {\n\t\t\tast_cli(a->fd,\"%-20s%s\\n\", \"FAX Detect:\", \"Yes\");\n\t\t} else if (peer->faxdetect & FAXDETECT_CNG) {\n\t\t\tast_cli(a->fd,\"%-20s%s\\n\", \"FAX Detect:\", \"Cng\");\n\t\t} else if (peer->faxdetect & FAXDETECT_T38) {\n\t\t\tast_cli(a->fd,\"%-20s%s\\n\", \"FAX Detect:\", \"T.38\");\n\t\t} else {\n\t\t\tast_cli(a->fd,\"%-20s%s\\n\", \"FAX Detect:\", \"No\");\n\t\t}\n\t\tast_cli(a->fd, \"%-15.15s%s\\n\", \"AccountCode: \", peer->accountcode);\n\t\tast_cli(a->fd, \"%-15.15s%s\\n\", \"AMA flags: \", ast_channel_amaflags2string(peer->amaflags));\n\t\tast_cli(a->fd, \"%-15.15s%s\\n\", \"IP:Port: \", ip_port);\n\t\tast_cli(a->fd, \"%-15.15s%u\\n\", \"OutgoingLimit: \", peer->outgoinglimit);\n\t\tast_cli(a->fd, \"%-15.15s%d\\n\", \"rtptimeout: \", peer->rtptimeout);\n\t\tast_cli(a->fd, \"%-15.15s%s\\n\", \"nat: \", peer->nat?\"yes\":\"no\");\n\t\tif (peer->rtpmaskstr[0]) {\n\t\t\tast_cli(a->fd, \"%-15.15s%s\\n\", \"rtpmask: \", peer->rtpmaskstr);\n\t\t}\n\t\tif (peer->rtdrcount && peer->rtdrinterval) {\n\t\t\tast_cli(a->fd, \"%-15.15s%d,%d\\n\", \"RoundTrip: \", peer->rtdrcount, peer->rtdrinterval);\n\t\t}\n\t\tast_mutex_unlock(&peer->lock);\n\t} else {\n\t\tast_cli(a->fd, \"Peer %s not found\\n\", a->argv[3]);\n\t\tast_cli(a->fd, \"\\n\");\n\t}\n\tast_mutex_unlock(&peerl.lock);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 152}
{"project": "Asterisk", "target": 0, "func": "static enum ast_transfer_result try_parking(struct ast_channel *transferer,\n\tconst char *context, const char *exten, transfer_channel_cb new_channel_cb,\n\tstruct transfer_channel_data *user_data_wrapper)\n{\n\tRAII_VAR(struct ast_bridge_channel *, transferer_bridge_channel, NULL, ao2_cleanup);\n\tif (!ast_parking_provider_registered()) {\n\t\treturn AST_BRIDGE_TRANSFER_FAIL;\n\t}\n\tast_channel_lock(transferer);\n\ttransferer_bridge_channel = ast_channel_get_bridge_channel(transferer);\n\tast_channel_unlock(transferer);\n\tif (!transferer_bridge_channel) {\n\t\treturn AST_BRIDGE_TRANSFER_FAIL;\n\t}\n\tif (ast_parking_blind_transfer_park(transferer_bridge_channel,\n\t\tcontext, exten, new_channel_cb, user_data_wrapper)) {\n\t\treturn AST_BRIDGE_TRANSFER_FAIL;\n\t}\n\treturn AST_BRIDGE_TRANSFER_SUCCESS;\n}\n", "bug_type": null, "idx": 153}
{"project": "Asterisk", "target": 0, "func": "static struct log_mappings *default_log_mappings;\nstatic struct log_mappings *get_log_mappings(void)\n{\n\tstruct log_mappings *mappings;\n\tmappings = ast_sorcery_retrieve_by_id(pjproject_sorcery, \"log_mappings\", \"log_mappings\");\n\tif (!mappings) {\n\t\treturn ao2_bump(default_log_mappings);\n\t}\n\treturn mappings;\n}\n", "bug_type": null, "idx": 154}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void update_connected_line_from_peer(struct ast_channel *chan, struct ast_channel *peer, int is_caller)\n{\n\tstruct ast_party_connected_line connected_caller;\n\tast_party_connected_line_init(&connected_caller);\n\tast_channel_lock(peer);\n\tast_connected_line_copy_from_caller(&connected_caller, ast_channel_caller(peer));\n\tast_channel_unlock(peer);\n\tconnected_caller.source = AST_CONNECTED_LINE_UPDATE_SOURCE_ANSWER;\n\tif (ast_channel_connected_line_sub(peer, chan, &connected_caller, 0)\n\t\t&& ast_channel_connected_line_macro(peer, chan, &connected_caller, is_caller, 0)) {\n\t\tast_channel_update_connected_line(chan, &connected_caller, NULL);\n\t}\n\tast_party_connected_line_free(&connected_caller);\n}\n", "bug_type": null, "idx": 155}
{"project": "Asterisk", "target": 0, "func": "enum stasis_app_subscribe_res stasis_app_subscribe_channel(const char *app_name,\n\tstruct ast_channel *chan)\n{\n\tRAII_VAR(struct stasis_app *, app, find_app_by_name(app_name), ao2_cleanup);\n\tint res;\n\tif (!app) {\n\t\treturn STASIS_ASR_APP_NOT_FOUND;\n\t}\n\tast_debug(3, \"%s: Subscribing to %s\\n\", app_name, ast_channel_uniqueid(chan));\n\tres = app_subscribe_channel(app, chan);\n\tif (res != 0) {\n\t\tast_log(LOG_ERROR, \"Error subscribing app '%s' to channel '%s'\\n\",\n\t\t\tapp_name, ast_channel_uniqueid(chan));\n\t\treturn STASIS_ASR_INTERNAL_ERROR;\n\t}\n\treturn STASIS_ASR_OK;\n}\n", "bug_type": null, "idx": 156}
{"project": "Asterisk", "target": 0, "func": "static void rtp_rtcp_report_dtor(void *obj)\n{\n\tint i;\n\tstruct ast_rtp_rtcp_report *rtcp_report = obj;\n\tfor (i = 0; i < rtcp_report->reception_report_count; i++) {\n\t\tast_free(rtcp_report->report_block[i]);\n\t}\n}\n", "bug_type": null, "idx": 157}
{"project": "Asterisk", "target": 0, "func": "static char *app = \"WaitForRing\";\nstatic int waitforring_exec(struct ast_channel *chan, const char *data)\n{\n\tstruct ast_frame *f;\n\tstruct ast_silence_generator *silgen = NULL;\n\tint res = 0;\n\tdouble s;\n\tint timeout_ms;\n\tint ms;\n\tstruct timeval start = ast_tvnow();\n\tif (!data || (sscanf(data, \"%30lg\", &s) != 1)) {\n\t\tast_log(LOG_WARNING, \"WaitForRing requires an argument (minimum seconds)\\n\");\n\t\treturn 0;\n\t}\n\tif (s < 0.0) {\n\t\tast_log(LOG_WARNING, \"Invalid timeout provided for WaitForRing (%lg)\\n\", s);\n\t\treturn 0;\n\t}\n\tif (ast_opt_transmit_silence) {\n\t\tsilgen = ast_channel_start_silence_generator(chan);\n\t}\n\ttimeout_ms = s * 1000.0;\n\twhile ((ms = ast_remaining_ms(start, timeout_ms))) {\n\t\tms = ast_waitfor(chan, ms);\n\t\tif (ms < 0) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ms > 0) {\n\t\t\tf = ast_read(chan);\n\t\t\tif (!f) {\n\t\t\t\tres = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((f->frametype == AST_FRAME_CONTROL) && (f->subclass.integer == AST_CONTROL_RING)) {\n\t\t\t\tast_verb(3, \"Got a ring but still waiting for timeout\\n\");\n\t\t\t}\n\t\t\tast_frfree(f);\n\t\t}\n\t}\n\t\n\tif (!res) {\n\t\tfor (;;) {\n\t\t\tint wait_res = ast_waitfor(chan, -1);\n\t\t\tif (wait_res < 0) {\n\t\t\t\tres = -1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tf = ast_read(chan);\n\t\t\t\tif (!f) {\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((f->frametype == AST_FRAME_CONTROL) && (f->subclass.integer == AST_CONTROL_RING)) {\n\t\t\t\t\tast_verb(3, \"Got a ring after the timeout\\n\");\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tast_frfree(f);\n\t\t\t}\n\t\t}\n\t}\n\tif (silgen) {\n\t\tast_channel_stop_silence_generator(chan, silgen);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 158}
{"project": "Asterisk", "target": 0, "func": "ari_validator ast_ari_validate_channel_hangup_request_fn(void)\n{\n\treturn ast_ari_validate_channel_hangup_request;\n}\n", "bug_type": null, "idx": 159}
{"project": "Asterisk", "target": 0, "func": "static int add_supported(pjsip_tx_data *tdata)\n{\n\tpjsip_supported_hdr *hdr;\n\thdr = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_SUPPORTED, NULL);\n\tif (!hdr) {\n\t\t\n\t\thdr = pjsip_supported_hdr_create(tdata->pool);\n\t\tif (!hdr) {\n\t\t\treturn -1;\n\t\t}\n\t\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr *)hdr);\n\t}\n\t\n\tpj_strassign(&hdr->values[hdr->count++], &PATH_SUPPORTED_NAME);\n\treturn 0;\n}\n", "bug_type": null, "idx": 160}
{"project": "Asterisk", "target": 0, "func": "protected int\nsig_init(EditLine *el)\n{\n\tint i;\n\tsigset_t nset, oset;\n\t(void) sigemptyset(&nset);\n#define\t_DO(a) (void) sigaddset(&nset, a);\n\tALLSIGS\n#undef\t_DO\n\t    (void) sigprocmask(SIG_BLOCK, &nset, &oset);\n#define\tSIGSIZE (sizeof(sighdl) / sizeof(sighdl[0]) * sizeof(sig_t))\n\tel->el_signal = (sig_t *) el_malloc(SIGSIZE);\n\tif (el->el_signal == NULL)\n\t\treturn (-1);\n\tfor (i = 0; sighdl[i] != -1; i++)\n\t\tel->el_signal[i] = SIG_ERR;\n\t(void) sigprocmask(SIG_SETMASK, &oset, NULL);\n\treturn (0);\n}\n", "bug_type": null, "idx": 161}
{"project": "Asterisk", "target": 0, "func": "private void\nmap_init_nls(EditLine *el)\n{\n\tint i;\n\tel_action_t *map = el->el_map.key;\n\tfor (i = 0200; i <= 0377; i++)\n\t\tif (isprint(i))\n\t\t\tmap[i] = ED_INSERT;\n}\n", "bug_type": null, "idx": 162}
{"project": "Asterisk", "target": 0, "func": "extern ast_mutex_t newCallLock;\nOOH323CallData* ooCreateCall(char* type, char*callToken)\n{\n   OOH323CallData *call=NULL;\n   OOCTXT *pctxt=NULL;\n   OOCTXT *msgctxt=NULL;\n   pctxt = newContext();\n   if(!pctxt)\n   {\n      OOTRACEERR1(\"ERROR:Failed to create OOCTXT for new call\\n\");\n      return NULL;\n   }\n   msgctxt = newContext();\n   if(!msgctxt)\n   {\n      OOTRACEERR1(\"ERROR:Failed to create OOCTXT for new call\\n\");\n      return NULL;\n   }\n   ast_mutex_lock(&newCallLock);\n   \n   call = (OOH323CallData*)memAlloc(pctxt, sizeof(OOH323CallData));\n   ast_mutex_unlock(&newCallLock);\n   if(!call)\n   {\n      OOTRACEERR1(\"ERROR:Memory - ooCreateCall - call\\n\");\n      return NULL;\n   } \n   memset(call, 0, sizeof(OOH323CallData));\n   ast_cond_init(&call->gkWait, NULL);\n   ast_mutex_init(&call->GkLock);\n   ast_mutex_init(&call->Lock);\n   call->pctxt = pctxt;\n   call->msgctxt = msgctxt;\n   call->callMode = gH323ep.callMode;\n   sprintf(call->callToken, \"%s\", callToken);\n   sprintf(call->callType, \"%s\", type);\n   call->callReference = 0;\n   if(gH323ep.callerid) {\n     strncpy(call->ourCallerId, gH323ep.callerid, sizeof(call->ourCallerId)-1);\n     call->ourCallerId[sizeof(call->ourCallerId)-1] = '\\0';\n   }\n   else {\n      call->ourCallerId[0] = '\\0';\n   }\n   memset(&call->callIdentifier, 0, sizeof(H225CallIdentifier));\n   memset(&call->confIdentifier, 0, sizeof(H225ConferenceIdentifier));\n   call->flags = 0;\n   if (OO_TESTFLAG(gH323ep.flags, OO_M_TUNNELING))\n      OO_SETFLAG (call->flags, OO_M_TUNNELING);\n   if(gH323ep.gkClient)\n   {\n      if(OO_TESTFLAG(gH323ep.flags, OO_M_GKROUTED))\n      {\n         OO_SETFLAG(call->flags, OO_M_GKROUTED);\n      }\n   }\n   if (OO_TESTFLAG(gH323ep.flags, OO_M_FASTSTART))\n      OO_SETFLAG (call->flags, OO_M_FASTSTART);\n   if (OO_TESTFLAG(gH323ep.flags, OO_M_MEDIAWAITFORCONN))\n      OO_SETFLAG (call->flags, OO_M_MEDIAWAITFORCONN);\n   call->fsSent = FALSE;\n \n   OO_SETFLAG(call->flags, OO_M_AUDIOSESSION);\n   call->callState = OO_CALL_CREATED;\n   call->callEndReason = OO_REASON_UNKNOWN;\n   call->pCallFwdData = NULL;\n   if(!strcmp(call->callType, \"incoming\"))\n   {\n      call->callingPartyNumber = NULL;\n   }\n   else{      \n      if(ooUtilsIsStrEmpty(gH323ep.callingPartyNumber))\n      {\n         call->callingPartyNumber = NULL;\n      }\n      else{\n         call->callingPartyNumber = (char*) memAlloc(call->pctxt, \n                                         strlen(gH323ep.callingPartyNumber)+1);\n         if(call->callingPartyNumber)\n         {\n            strcpy(call->callingPartyNumber, gH323ep.callingPartyNumber);\n         }\n         else{\n            OOTRACEERR3(\"Error:Memory - ooCreateCall - callingPartyNumber\"\n                        \".(%s, %s)\\n\", call->callType, call->callToken);\n            freeContext(pctxt);\n            return NULL;\n         }\n      }\n   }\n   call->calledPartyNumber = NULL;\n   call->h245ConnectionAttempts = 0;\n   call->h245SessionState = OO_H245SESSION_IDLE;\n   call->dtmfmode = gH323ep.dtmfmode;\n   call->mediaInfo = NULL;\n   strcpy(call->localIP, gH323ep.signallingIP);\n   call->pH225Channel = NULL;\n   call->pH245Channel = NULL;\n   call->h245listener = NULL;\n   call->h245listenport = NULL;\n   call->remoteIP[0] = '\\0';\n   call->remotePort = 0;\n   call->remoteH245Port = 0;\n   call->remoteDisplayName = NULL;\n   call->remoteAliases = NULL;\n   call->ourAliases = NULL;\n   call->masterSlaveState = OO_MasterSlave_Idle;\n   call->statusDeterminationNumber = 0;\n   call->localTermCapState = OO_LocalTermCapExchange_Idle;\n   call->remoteTermCapState = OO_RemoteTermCapExchange_Idle; \n   call->ourCaps = NULL;\n   call->remoteCaps = NULL;\n   call->jointCaps = NULL;\n   dListInit(&call->remoteFastStartOLCs);\n   call->remoteTermCapSeqNo =0;\n   call->localTermCapSeqNo = 0;\n   memcpy(&call->capPrefs, &gH323ep.capPrefs, sizeof(OOCapPrefs));    \n   call->logicalChans = NULL;\n   call->noOfLogicalChannels = 0;\n   call->logicalChanNoBase = 1001;\n   call->logicalChanNoMax = 1100;\n   call->logicalChanNoCur = 1001;\n   call->nextSessionID = 4; \n   dListInit(&call->timerList);\n   call->msdRetries = 0;\n   call->pFastStartRes = NULL;\n   call->usrData = NULL;\n   OOTRACEINFO3(\"Created a new call (%s, %s)\\n\", call->callType, \n                 call->callToken);\n   \n   ooAddCallToList (call);\n   if(gH323ep.h323Callbacks.onNewCallCreated)\n     gH323ep.h323Callbacks.onNewCallCreated(call);\n   return call;\n}\n", "bug_type": null, "idx": 163}
{"project": "Asterisk", "target": 0, "func": "static void unistim_set_owner(struct unistim_subchannel *sub, struct ast_channel *chan)\n{\n\tsub->owner = chan;\n\tif (sub->rtp) {\n\t\tast_rtp_instance_set_channel_id(sub->rtp, sub->owner ? ast_channel_uniqueid(sub->owner) : \"\");\n\t}\n}\n", "bug_type": null, "idx": 164}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void bridge_channel_handle_feature_timeout(struct ast_bridge_channel *bridge_channel)\n{\n\tif (!bridge_channel->dtmf_hook_state.collected[0]\n\t\t|| 0 < ast_tvdiff_ms(bridge_channel->dtmf_hook_state.interdigit_timeout,\n\t\t\tast_tvnow())) {\n\t\t\n\t\treturn;\n\t}\n\tast_bridge_channel_feature_digit(bridge_channel, 0);\n}\n", "bug_type": null, "idx": 165}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tstruct ao2_container *transports;\n\tCHECK_PJSIP_MODULE_LOADED();\n\ttransports = ao2_container_alloc(TRANSPORTS_BUCKETS, monitored_transport_hash_fn,\n\t\tmonitored_transport_cmp_fn);\n\tif (!transports) {\n\t\tast_log(LOG_ERROR, \"Could not create container for transports to perform keepalive on.\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tao2_global_obj_replace_unref(monitored_transports, transports);\n\tao2_ref(transports, -1);\n\tsched = ast_sched_context_create();\n\tif (!sched) {\n\t\tast_log(LOG_ERROR, \"Failed to create keepalive scheduler context.\\n\");\n\t\tao2_global_obj_release(monitored_transports);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (ast_sched_start_thread(sched)) {\n\t\tast_log(LOG_ERROR, \"Failed to start keepalive scheduler thread\\n\");\n\t\tast_sched_context_destroy(sched);\n\t\tsched = NULL;\n\t\tao2_global_obj_release(monitored_transports);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_sip_register_service(&idle_monitor_module);\n\tast_sip_transport_state_register(&monitored_transport_reg);\n\tast_sorcery_observer_add(ast_sip_get_sorcery(), \"global\", &keepalive_global_observer);\n\tast_sorcery_reload_object(ast_sip_get_sorcery(), \"global\");\n\tast_module_shutdown_ref(ast_module_info->self);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 166}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void cleanup(void)\n{\n\tao2_callback(apps_registry, OBJ_MULTIPLE | OBJ_NODATA | OBJ_UNLINK,\n\t\tcleanup_cb, NULL);\n}\n", "bug_type": null, "idx": 167}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tchar *error;\n\tchar filename[PATH_MAX];\n\tint res;\n\tchar *sql;\n\tif (load_config(0)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\t\n\tsnprintf(filename, sizeof(filename), \"%s/master.db\", ast_config_AST_LOG_DIR);\n\tres = sqlite3_open(filename, &db);\n\tif (res != SQLITE_OK) {\n\t\tast_log(LOG_ERROR, \"Could not open database %s.\\n\", filename);\n\t\tfree_config();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tsqlite3_busy_timeout(db, busy_timeout);\n\t\n\tsql = sqlite3_mprintf(\"SELECT COUNT(*) FROM %q;\", table);\n\tres = sqlite3_exec(db, sql, NULL, NULL, NULL);\n\tsqlite3_free(sql);\n\tif (res != SQLITE_OK) {\n\t\t\n\t\tsql = sqlite3_mprintf(\"CREATE TABLE %q (AcctId INTEGER PRIMARY KEY, %s)\", table, columns);\n\t\tres = sqlite3_exec(db, sql, NULL, NULL, &error);\n\t\tsqlite3_free(sql);\n\t\tif (res != SQLITE_OK) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create table '%s': %s.\\n\", table, error);\n\t\t\tsqlite3_free(error);\n\t\t\tfree_config();\n\t\t\treturn AST_MODULE_LOAD_DECLINE;\n\t\t}\n\t}\n\tif (ast_cel_backend_register(SQLITE_BACKEND_NAME, write_cel)) {\n\t\tast_log(LOG_ERROR, \"Unable to register custom SQLite3 CEL handling\\n\");\n\t\tfree_config();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 168}
{"project": "Asterisk", "target": 0, "func": "word gsm_asl P2((a,n), word a, int n)\n{\n\tif (n >= 16) return 0;\n\tif (n <= -16) return -(a < 0);\n\tif (n < 0) return gsm_asr(a, -n);\n\treturn a << n;\n}\n", "bug_type": null, "idx": 169}
{"project": "Asterisk", "target": 0, "func": "static int ast_unlock_context(struct ast_context *con)\n{\n\treturn ast_rwlock_unlock(&con->lock);\n}\n", "bug_type": null, "idx": 170}
{"project": "Asterisk", "target": 0, "func": "static struct ast_applicationmap_item *applicationmap_item_alloc(const char *name,\n\t\tconst char *app, const char *app_data, const char *moh_class, const char *dtmf,\n\t\tunsigned int activate_on_self)\n{\n\tstruct ast_applicationmap_item *item;\n\titem = ao2_alloc(sizeof(*item), ast_applicationmap_item_destructor);\n\tif (!item || ast_string_field_init(item, 64)) {\n\t\treturn NULL;\n\t}\n\tast_string_field_set(item, name, name);\n\tast_string_field_set(item, app, app);\n\tast_string_field_set(item, app_data, app_data);\n\tast_string_field_set(item, moh_class, moh_class);\n\tast_copy_string(item->dtmf, dtmf, sizeof(item->dtmf));\n\titem->activate_on_self = activate_on_self;\n\treturn item;\n}\n", "bug_type": null, "idx": 171}
{"project": "Asterisk", "target": 0, "func": "\nstatic int unload_module(void)\n{\n\tast_fax_tech_unregister(&spandsp_fax_tech);\n\tast_mutex_destroy(&spandsp_global_stats.lock);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 172}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel *ast_request(const char *type, struct ast_format_cap *request_cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *addr, int *cause)\n{\n\treturn request_channel(type, request_cap, NULL, assignedids, requestor, addr, cause);\n}\n", "bug_type": null, "idx": 173}
{"project": "Asterisk", "target": 0, "func": "struct ao2_container *ast_sip_location_retrieve_aor_contacts_filtered(const struct ast_sip_aor *aor,\n\tunsigned int flags)\n{\n\tstruct ao2_container *contacts;\n\t\n\tao2_lock((void*)aor);\n\tcontacts = ast_sip_location_retrieve_aor_contacts_nolock_filtered(aor, flags);\n\tao2_unlock((void*)aor);\n\treturn contacts;\n}\n", "bug_type": null, "idx": 174}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245CompressionType (OOCTXT* pctxt, H245CompressionType* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 1);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 0);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245V42bis (pctxt, pvalue->u.v42bis);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 2);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 175}
{"project": "Asterisk", "target": 0, "func": "static int acf_cc_write(struct ast_channel *chan, const char *cmd, char *data,\n\t\tconst char *value)\n{\n\tstruct ast_cc_config_params *cc_params;\n\tint res;\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\tif (!(cc_params = ast_channel_get_cc_config_params(chan))) {\n\t\tast_channel_unlock(chan);\n\t\treturn -1;\n\t}\n\tres = ast_cc_set_param(cc_params, data, value);\n\tast_channel_unlock(chan);\n\treturn res;\n}\n", "bug_type": null, "idx": 176}
{"project": "Asterisk", "target": 0, "func": "\nstatic int apply_general_options(struct ast_variable *var)\n{\n\tint error = 0;\n\twhile (var) {\n\t\t\n\t\tif (!strcmp(var->name, \"mailcmd\")) {\n\t\t\tast_copy_string(global_mailcmd, var->value, sizeof(global_mailcmd)); \n\t\t} else if (!strcmp(var->name, \"maxgreet\")) {\n\t\t\tglobal_maxgreet = atoi(var->value);\n\t\t} else if (!strcmp(var->name, \"maxsilence\")) {\n\t\t\tglobal_maxsilence = atoi(var->value);\n\t\t\tif (global_maxsilence > 0)\n\t\t\t\tglobal_maxsilence *= 1000;\n\t\t} else if (!strcmp(var->name, \"logfile\")) {\n\t\t\tif (!ast_strlen_zero(var->value) ) {\n\t\t\t\tif(*(var->value) == '/')\n\t\t\t\t\tast_copy_string(global_logfile, var->value, sizeof(global_logfile));\n\t\t\t\telse\n\t\t\t\t\tsnprintf(global_logfile, sizeof(global_logfile), \"%s/%s\", ast_config_AST_LOG_DIR, var->value);\n\t\t\t}\n\t\t} else if (!strcmp(var->name, \"externnotify\")) {\n\t\t\t\n\t\t\tast_copy_string(global_externnotify, var->value, sizeof(global_externnotify));\n\t\t} else if (!strcmp(var->name, \"silencetreshold\")) {\n\t\t\t\n\t\t\tglobal_silencethreshold = atoi(var->value);\n\t\t} else if (!strcmp(var->name, \"maxmessage\")) {\n\t\t\tint x;\n\t\t\tif (sscanf(var->value, \"%30d\", &x) == 1) {\n\t\t\t\tglobal_vmmaxmessage = x;\n\t\t\t} else {\n\t\t\t\terror ++;\n\t\t\t\tast_log(LOG_WARNING, \"Invalid max message time length\\n\");\n\t\t\t}\n\t\t} else if (!strcmp(var->name, \"minmessage\")) {\n\t\t\tint x;\n\t\t\tif (sscanf(var->value, \"%30d\", &x) == 1) {\n\t\t\t\tglobal_vmminmessage = x;\n\t\t\t\tif (global_maxsilence <= global_vmminmessage)\n\t\t\t\t\tast_log(LOG_WARNING, \"maxsilence should be less than minmessage or you may get empty messages\\n\");\n\t\t\t} else {\n\t\t\t\terror ++;\n\t\t\t\tast_log(LOG_WARNING, \"Invalid min message time length\\n\");\n\t\t\t}\n\t\t} else if (!strcmp(var->name, \"format\")) {\n\t\t\tast_copy_string(default_vmformat, var->value, sizeof(default_vmformat));\n\t\t} else if (!strcmp(var->name, \"review\")) {\n\t\t\tast_set2_flag((&globalflags), ast_true(var->value), MVM_REVIEW);\t\n\t\t} else if (!strcmp(var->name, \"operator\")) {\n\t\t\tast_set2_flag((&globalflags), ast_true(var->value), MVM_OPERATOR);\t\n\t\t}\n\t\tvar = var->next;\n\t}\n\treturn error;\n}\n", "bug_type": null, "idx": 177}
{"project": "Asterisk", "target": 0, "func": "int AST_OPTIONAL_API_NAME(ast_aes_set_decrypt_key)(const unsigned char *key, ast_aes_decrypt_key *ctx)\n{\n\treturn AES_set_decrypt_key(key, 128, ctx);\n}\n", "bug_type": null, "idx": 178}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int osp_uuid2str(\n\tunsigned char* uuid,\n\tchar* buffer,\n\tunsigned int bufsize)\n{\n\tint res;\n\tif ((uuid != NULL) && (bufsize > OSP_SIZE_UUIDSTR)) {\n\t\tsnprintf(buffer, bufsize, \"%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-\"\n\t\t\t\t\t  \"%02hhx%02hhx-%02hhx%02hhx-\"\n\t\t\t\t\t  \"%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\",\n\t\t\tuuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],\n\t\t\tuuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]);\n\t\tres = OSP_OK;\n\t} else {\n\t\tast_log(LOG_ERROR, \"Invalid parameters\\n\");\n\t\tres = OSP_ERROR;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 179}
{"project": "Asterisk", "target": 0, "func": "static int regex_filter_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct asterisk_publication_config *config = obj;\n\tint res = -1;\n\tif (ast_strlen_zero(var->value)) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(var->name, \"device_state_filter\")) {\n\t\tif (!(res = build_regex(&config->device_state_regex, var->value))) {\n\t\t\tconfig->device_state_filter = 1;\n\t\t}\n\t} else if (!strcmp(var->name, \"mailbox_state_filter\")) {\n\t\tif (!(res = build_regex(&config->mailbox_state_regex, var->value))) {\n\t\t\tconfig->mailbox_state_filter = 1;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 180}
{"project": "Asterisk", "target": 0, "func": "\nvoid ast_multi_object_blob_single_channel_publish(struct ast_channel *chan,\n\tstruct stasis_message_type *type, struct ast_json *blob)\n{\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_channel_snapshot *, channel_snapshot, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_multi_object_blob *, multi, NULL, ao2_cleanup);\n\tif (!type) {\n\t\treturn;\n\t}\n\tmulti = ast_multi_object_blob_create(blob);\n\tif (!multi) {\n\t\treturn;\n\t}\n\tchannel_snapshot = ast_channel_snapshot_create(chan);\n\tao2_ref(channel_snapshot, +1);\n\tast_multi_object_blob_add(multi, STASIS_UMOS_CHANNEL, channel_snapshot);\n\tmessage = stasis_message_create(type, multi);\n\tif (message) {\n\t\t\n\t\tstasis_publish(ast_channel_topic(chan), message);\n\t}\n}\n", "bug_type": null, "idx": 181}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_confbridge_show_user_profile(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct user_profile u_profile;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"confbridge show profile user\";\n\t\te->usage =\n\t\t\t\"Usage: confbridge show profile user [<profile name>]\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tif (a->pos == 4) {\n\t\t\treturn complete_user_profile_name(a->line, a->word, a->pos, a->n);\n\t\t}\n\t\treturn NULL;\n\t}\n\tif (a->argc != 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (!(conf_find_user_profile(NULL, a->argv[4], &u_profile))) {\n\t\tast_cli(a->fd, \"No conference user profile named '%s' found!\\n\", a->argv[4]);\n\t\treturn CLI_SUCCESS;\n\t}\n\tast_cli(a->fd,\"--------------------------------------------\\n\");\n\tast_cli(a->fd,\"Name:                    %s\\n\",\n\t\tu_profile.name);\n\tast_cli(a->fd,\"Admin:                   %s\\n\",\n\t\tu_profile.flags & USER_OPT_ADMIN ?\n\t\t\"true\" : \"false\");\n\tast_cli(a->fd,\"Marked User:             %s\\n\",\n\t\tu_profile.flags & USER_OPT_MARKEDUSER ?\n\t\t\"true\" : \"false\");\n\tast_cli(a->fd,\"Start Muted:             %s\\n\",\n\t\tu_profile.flags & USER_OPT_STARTMUTED?\n\t\t\"true\" : \"false\");\n\tast_cli(a->fd,\"MOH When Empty:          %s\\n\",\n\t\tu_profile.flags & USER_OPT_MUSICONHOLD ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"MOH Class:               %s\\n\",\n\t\tast_strlen_zero(u_profile.moh_class) ?\n\t\t\"default\" : u_profile.moh_class);\n\tast_cli(a->fd,\"Announcement:            %s\\n\",\n\t\tu_profile.announcement);\n\tast_cli(a->fd,\"Quiet:                   %s\\n\",\n\t\tu_profile.flags & USER_OPT_QUIET ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"Wait Marked:             %s\\n\",\n\t\tu_profile.flags & USER_OPT_WAITMARKED ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"END Marked:              %s\\n\",\n\t\tu_profile.flags & USER_OPT_ENDMARKED ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"Drop_silence:            %s\\n\",\n\t\tu_profile.flags & USER_OPT_DROP_SILENCE ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"Silence Threshold:       %ums\\n\",\n\t\tu_profile.silence_threshold);\n\tast_cli(a->fd,\"Talking Threshold:       %ums\\n\",\n\t\tu_profile.talking_threshold);\n\tast_cli(a->fd,\"Denoise:                 %s\\n\",\n\t\tu_profile.flags & USER_OPT_DENOISE ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"Jitterbuffer:            %s\\n\",\n\t\tu_profile.flags & USER_OPT_JITTERBUFFER ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"Talk Detect Events:      %s\\n\",\n\t\tu_profile.flags & USER_OPT_TALKER_DETECT ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"DTMF Pass Through:       %s\\n\",\n\t\tu_profile.flags & USER_OPT_DTMF_PASS ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"PIN:                     %s\\n\",\n\t\tast_strlen_zero(u_profile.pin) ?\n\t\t\"None\" : u_profile.pin);\n\tast_cli(a->fd,\"Announce User Count:     %s\\n\",\n\t\tu_profile.flags & USER_OPT_ANNOUNCEUSERCOUNT ?\n\t\t\"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"Announce join/leave:     %s\\n\",\n\t\tu_profile.flags & (USER_OPT_ANNOUNCE_JOIN_LEAVE | USER_OPT_ANNOUNCE_JOIN_LEAVE_REVIEW) ?\n\t\tu_profile.flags & USER_OPT_ANNOUNCE_JOIN_LEAVE_REVIEW ?\n\t\t\"enabled (with review)\" : \"enabled\" : \"disabled\");\n\tast_cli(a->fd,\"Announce User Count all: %s\\n\",\n\t\tu_profile.flags & USER_OPT_ANNOUNCEUSERCOUNTALL ?\n\t\t\"enabled\" : \"disabled\");\n\t\tast_cli(a->fd,\"\\n\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 182}
{"project": "Asterisk", "target": 0, "func": "static int check_shot(struct blip *shot)\n{\n\tstruct blip *cur;\n\tAST_LIST_TRAVERSE(&blips, cur, entry) {\n\t\tif ((cur->type == BLIP_ALIEN || cur->type == BLIP_UFO) && cur->x == shot->x && cur->y == shot->y){\n\t\t\tif (cur->type == BLIP_UFO) {\n\t\t\t\tscore += 80;\n\t\t\t}\n\t\t\tscore += 20;\n\t\t\tremove_blip(cur);\n\t\t\tremove_blip(shot);\n\t\t\trespawn += 1;\n\t\t\tif (!num_aliens) {\n\t\t\t\tif(alien_sleeptime < 101) {\n\t\t\t\t\tgame_over(1);\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\talien_sleeptime = alien_sleeptime - 100;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cur->type == BLIP_BARRIER) {\n\t\t\tif (shot->x == cur->x && shot->y == cur->y) {\n\t\t\t\tremove_blip(cur);\n\t\t\t\tremove_blip(shot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 183}
{"project": "Asterisk", "target": 0, "func": "int ast_event_append_ie_uint(struct ast_event **event, enum ast_event_ie_type ie_type,\n\tuint32_t data)\n{\n\tdata = htonl(data);\n\treturn ast_event_append_ie_raw(event, ie_type, &data, sizeof(data));\n}\n", "bug_type": null, "idx": 184}
{"project": "Asterisk", "target": 0, "func": "static int listfilter_read2(struct ast_channel *chan, const char *cmd, char *parse, struct ast_str **buf, ssize_t len)\n{\n\treturn listfilter(chan, cmd, parse, NULL, buf, len);\n}\n", "bug_type": null, "idx": 185}
{"project": "Asterisk", "target": 0, "func": "static ASN1BOOL isFixedSize (Asn1SizeCnst* pSizeList);\nASN1BOOL alignCharStr \n(OOCTXT* pctxt, ASN1UINT len, ASN1UINT nbits, Asn1SizeCnst* pSize)\n{\n   if (TRUE) {\n      ASN1UINT lower, upper;\n      ASN1BOOL doAlign = (len > 0), extendable;\n      pSize = checkSize (pSize, len, &extendable);\n      if (0 != pSize) {\n         lower = pSize->lower;\n         upper = pSize->upper;\n      }\n      else {\n         lower = 0;\n         upper = ASN1UINT_MAX;\n      }\n      if (!extendable && upper < 65536) {\n         ASN1UINT bitRange = upper * nbits;\n         if (upper == lower) {\n            \n            if (bitRange <= 16) doAlign = FALSE;\n         }\n         else {\n            \n            if (bitRange < 16) doAlign = FALSE;\n         }\n      }\n      return doAlign;\n   }\n   else\n      return FALSE;\n}\n", "bug_type": null, "idx": 186}
{"project": "Asterisk", "target": 0, "func": "static int hook_write(struct ast_channel *chan, const char *cmd, char *data,\n\t\tconst char *value)\n{\n\tint res;\n\tif (!chan) {\n\t\treturn -1;\n\t}\n\tif (ast_false(value)) {\n\t\tres = hook_off(chan, data);\n\t} else if (ast_true(value)) {\n\t\tres = hook_re_enable(chan, data);\n\t} else {\n\t\tast_log(LOG_WARNING, \"Invalid value for PERIODIC_HOOK function: '%s'\\n\", value);\n\t\tres = -1;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 187}
{"project": "Asterisk", "target": 0, "func": "static void cel_attended_transfer_cb(\n\tvoid *data, struct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tstruct ast_attended_transfer_message *xfer = stasis_message_data(message);\n\tstruct ast_json *extra = NULL;\n\tstruct ast_bridge_snapshot *bridge1, *bridge2;\n\tstruct ast_channel_snapshot *channel1, *channel2;\n\t\n\tif (!xfer->to_transferee.bridge_snapshot) {\n\t\tbridge1 = xfer->to_transfer_target.bridge_snapshot;\n\t\tbridge2 = xfer->to_transferee.bridge_snapshot;\n\t\tchannel1 = xfer->to_transfer_target.channel_snapshot;\n\t\tchannel2 = xfer->to_transferee.channel_snapshot;\n\t} else {\n\t\tbridge1 = xfer->to_transferee.bridge_snapshot;\n\t\tbridge2 = xfer->to_transfer_target.bridge_snapshot;\n\t\tchannel1 = xfer->to_transferee.channel_snapshot;\n\t\tchannel2 = xfer->to_transfer_target.channel_snapshot;\n\t}\n\tswitch (xfer->dest_type) {\n\tcase AST_ATTENDED_TRANSFER_DEST_FAIL:\n\t\treturn;\n\t\t\n\tcase AST_ATTENDED_TRANSFER_DEST_BRIDGE_MERGE:\n\tcase AST_ATTENDED_TRANSFER_DEST_LINK:\n\tcase AST_ATTENDED_TRANSFER_DEST_THREEWAY:\n\t\textra = ast_json_pack(\"{s: s, s: s, s: s, s: s, s: s, s: s, s: s, s: s}\",\n\t\t\t\"bridge1_id\", bridge1->uniqueid,\n\t\t\t\"channel2_name\", channel2->name,\n\t\t\t\"channel2_uniqueid\", channel2->uniqueid,\n\t\t\t\"bridge2_id\", bridge2->uniqueid,\n\t\t\t\"transferee_channel_name\", xfer->transferee ? xfer->transferee->name : \"N/A\",\n\t\t\t\"transferee_channel_uniqueid\", xfer->transferee ? xfer->transferee->uniqueid : \"N/A\",\n\t\t\t\"transfer_target_channel_name\", xfer->target ? xfer->target->name : \"N/A\",\n\t\t\t\"transfer_target_channel_uniqueid\", xfer->target ? xfer->target->uniqueid : \"N/A\");\n\t\tif (!extra) {\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase AST_ATTENDED_TRANSFER_DEST_APP:\n\tcase AST_ATTENDED_TRANSFER_DEST_LOCAL_APP:\n\t\textra = ast_json_pack(\"{s: s, s: s, s: s, s: s, s: s, s: s, s: s, s: s}\",\n\t\t\t\"bridge1_id\", bridge1->uniqueid,\n\t\t\t\"channel2_name\", channel2->name,\n\t\t\t\"channel2_uniqueid\", channel2->uniqueid,\n\t\t\t\"app\", xfer->dest.app,\n\t\t\t\"transferee_channel_name\", xfer->transferee ? xfer->transferee->name : \"N/A\",\n\t\t\t\"transferee_channel_uniqueid\", xfer->transferee ? xfer->transferee->uniqueid : \"N/A\",\n\t\t\t\"transfer_target_channel_name\", xfer->target ? xfer->target->name : \"N/A\",\n\t\t\t\"transfer_target_channel_uniqueid\", xfer->target ? xfer->target->uniqueid : \"N/A\");\n\t\tif (!extra) {\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\tcel_report_event(channel1, AST_CEL_ATTENDEDTRANSFER, NULL, extra, NULL);\n\tast_json_unref(extra);\n}\n", "bug_type": null, "idx": 188}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *complete_config_module(const char *word, int pos, int state)\n{\n\tchar *c = NULL;\n\tsize_t wordlen = strlen(word);\n\tint which = 0;\n\tstruct ao2_iterator i;\n\tstruct ast_xml_doc_item *cur;\n\tif (pos != 3) {\n\t\treturn NULL;\n\t}\n\ti = ao2_iterator_init(xmldocs, 0);\n\twhile ((cur = ao2_iterator_next(&i))) {\n\t\tif (!strncasecmp(word, cur->name, wordlen) && ++which > state) {\n\t\t\tc = ast_strdup(cur->name);\n\t\t\tao2_ref(cur, -1);\n\t\t\tbreak;\n\t\t}\n\t\tao2_ref(cur, -1);\n\t}\n\tao2_iterator_destroy(&i);\n\treturn c;\n}\n", "bug_type": null, "idx": 189}
{"project": "Asterisk", "target": 0, "func": "static void parker_parked_call_message_response(struct ast_parked_call_payload *message, struct parked_subscription_data *data,\n\tstruct stasis_subscription *sub)\n{\n\tconst char *parkee_to_act_on = data->parkee_uuid;\n\tchar saynum_buf[16];\n\tstruct ast_channel_snapshot *parkee_snapshot = message->parkee;\n\tRAII_VAR(struct ast_channel *, parker, NULL, ast_channel_cleanup);\n\tRAII_VAR(struct ast_bridge_channel *, bridge_channel, NULL, ao2_cleanup);\n\tif (strcmp(parkee_to_act_on, parkee_snapshot->uniqueid)) {\n\t\treturn;\n\t}\n\tif (message->event_type != PARKED_CALL && message->event_type != PARKED_CALL_FAILED) {\n\t\t\n\t\treturn;\n\t}\n\tparker = ast_channel_get_by_name(data->parker_uuid);\n\tif (!parker) {\n\t\treturn;\n\t}\n\tast_channel_lock(parker);\n\tbridge_channel = ast_channel_get_bridge_channel(parker);\n\tast_channel_unlock(parker);\n\tif (!bridge_channel) {\n\t\treturn;\n\t}\n\t\n\tif (message->event_type == PARKED_CALL) {\n\t\t\n\t\tsnprintf(saynum_buf, sizeof(saynum_buf), \"%d %u\", data->hangup_after, message->parkingspace);\n\t\tif (!data->transfer_data) {\n\t\t\tast_bridge_channel_queue_playfile(bridge_channel, say_parking_space, saynum_buf, NULL);\n\t\t} else {\n\t\t\tast_bridge_channel_queue_playfile_sync(bridge_channel, say_parking_space, saynum_buf, NULL);\n\t\t\tdata->transfer_data->completed = 1;\n\t\t}\n\t\twipe_subscription_datastore(parker);\n\t} else if (message->event_type == PARKED_CALL_FAILED) {\n\t\tif (!data->transfer_data) {\n\t\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, \"pbx-parkingfailed\", NULL);\n\t\t} else {\n\t\t\tast_bridge_channel_queue_playfile_sync(bridge_channel, NULL, \"pbx-parkingfailed\", NULL);\n\t\t\tdata->transfer_data->completed = 1;\n\t\t}\n\t\twipe_subscription_datastore(parker);\n\t}\n}\n", "bug_type": null, "idx": 190}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_dnsmgr_changed(struct ast_dnsmgr_entry *entry)\n{\n\tint changed;\n\tast_mutex_lock(&entry->lock);\n\tchanged = entry->changed;\n\tentry->changed = 0;\n\tast_mutex_unlock(&entry->lock);\n\treturn changed;\n}\n", "bug_type": null, "idx": 191}
{"project": "Asterisk", "target": 0, "func": "static struct ast_channel_tech *cur_tech;\nstatic int phone_indicate(struct ast_channel *chan, int condition, const void *data, size_t datalen)\n{\n\tstruct phone_pvt *p = ast_channel_tech_pvt(chan);\n\tint res=-1;\n\tast_debug(1, \"Requested indication %d on channel %s\\n\", condition, ast_channel_name(chan));\n\tswitch(condition) {\n\tcase AST_CONTROL_FLASH:\n\t\tioctl(p->fd, IXJCTL_PSTN_SET_STATE, PSTN_ON_HOOK);\n\t\tusleep(320000);\n\t\tioctl(p->fd, IXJCTL_PSTN_SET_STATE, PSTN_OFF_HOOK);\n\t\tao2_cleanup(p->lastformat);\n\t\tp->lastformat = NULL;\n\t\tres = 0;\n\t\tbreak;\n\tcase AST_CONTROL_HOLD:\n\t\tast_moh_start(chan, data, NULL);\n\t\tbreak;\n\tcase AST_CONTROL_UNHOLD:\n\t\tast_moh_stop(chan);\n\t\tbreak;\n\tcase AST_CONTROL_SRCUPDATE:\n\t\tres = 0;\n\t\tbreak;\n\tcase AST_CONTROL_PVT_CAUSE_CODE:\n\t\tbreak;\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Condition %d is not supported on channel %s\\n\", condition, ast_channel_name(chan));\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 192}
{"project": "Asterisk", "target": 0, "func": ";\nint main( int argcount, char *args[])\n{\n   int i, k[2], maxk, stdin_in_use=FALSE;\n   short *leftsample, *rightsample, *stereosample;\n   FILE *channel[2];\n   char *filename[2], *tempname;\n   version = Version;\n   usage = Usage;\n   channel[0] = NULL;\n   channel[1] = NULL;\n   parseargs( argcount, args, NOFILES | NOCOMPLAIN);\n   for (i = 0; i < 2; i++)\n     {\n       filename[i] = parsefilearg( argcount, args);\n       if (filename[i] == NULL)\n\t argerrornum( NULL, ME_NOTENOUGHFILES);\n       if (strcmp (filename[i], \"-\") == 0)\n\t {\n\t   if (stdin_in_use)\n\t     argerrortxt( filename[i] + 1,\n\t\t\t  \"Cannot use <stdin> for both input files\");\n\t   filename[i] = \"<stdin>\";\n\t   channel[i] = stdin;\n\t   stdin_in_use = TRUE;\n\t }\n       else\n\t {\n\t   channel[i] = fopen(filename[i], \"rb\");\n\t }\n       if (channel[i] == NULL)\n\t   fatalerror( \"Error opening input file '%s': %s\\n\", filename[i],strerror(errno));\n       else\n\t inform(\"Using file '%s' as input\\n\", filename[i]);\n     }\n   for (i = 0; i < 2; i++)\n     {\n       assert ( channel[i] != NULL);\n       readwavheader( channel[i]);\n       if (iswav && channels != 1)\n\t inform(\"Warning: '%s' is no mono file\\n\", filename[i]);\n     }\n   outfilename = parsefilearg( argcount, args);\n   if (outfilename == NULL) argerrornum( NULL, ME_NOOUTFILE);\n   if (strcmp (outfilename, \"-\") == 0)\n     {\n       outfilename = \"<stdout>\";\n       out = stdout;\n     }\n   else\n     {\n       out = fopen(outfilename, \"wb\");\n     }\n   if (out == NULL)\n     fatalerror( \"Error opening output file '%s': %s\\n\", outfilename,strerror(errno));\n   else\n     inform(\"Using file '%s' as output\\n\", outfilename);\n   if ((tempname = parsefilearg( argcount, args)) != NULL)\n     argerrornum( tempname, ME_TOOMANYFILES);\n   checknoargs(argcount, args);      \n   leftsample = malloc( sizeof(*leftsample) * BUFFSIZE);\n   rightsample = malloc( sizeof(*leftsample) * BUFFSIZE);\n   stereosample = malloc( sizeof(*leftsample) * 2 * BUFFSIZE);\n   if (leftsample == NULL || rightsample == NULL || stereosample == NULL)\n     fatalperror (\"\");\n   channels = 2;   \n   if (wavout)\n     {\n       if ((strcmp(outfilename,\"<stdout>\")!=0) && (fseek( out, 0, SEEK_SET) != 0)) \n    \t fatalerror(\"Couldn't navigate output file '%s': %s\\n\",outfilename, strerror(errno));\n       makewavheader();\n     }\n   startstopwatch();\n   while (TRUE)\n   {\n      maxk = 0;\n      for (i = 0; i < 2; i++)\n\t{\n\t  k[i] = fread(i==0? leftsample : rightsample,\n\t\t       sizeof(*leftsample),\n\t\t       BUFFSIZE,\n\t\t       channel[i]);\n\t  if (k[i] == -1)\n\t    fatalerror(\"Error reading file '%s': %s\\n\", filename[i],strerror(errno));\n\t  if (k[i] > maxk)\n\t    maxk = k[i];\n\t}\n      if (maxk == 0)\n\tmyexit (0);\n      \n      for (i = 0; i < k[0]; i++)\n\tstereosample[2 * i] = leftsample[i];\n      \n      for (; i < maxk; i++)\n\tstereosample[2 * i] = 0;\n      \n      for (i = 0; i < k[1]; i++)\n\tstereosample[2 * i + 1] = rightsample[i];\n      \n      for (; i < maxk; i++)\n\tstereosample[2 * i + 1] = 0;\n      if (!fwrite(stereosample, sizeof(*leftsample), 2 * maxk, out)) {\n\t      fatalerror(\"Error writing to file '%s': %s\\n\",\n\t\t\t outfilename, strerror(errno));\n      }\n   }\n   \n   free(leftsample);\n   free(rightsample);\n   free(stereosample);\n}\n", "bug_type": null, "idx": 193}
{"project": "Asterisk", "target": 0, "func": "int ooSendH245UserInputIndication_alphanumeric\n   (OOH323CallData *call, const char *data)\n{\n   int ret=0;\n   H245IndicationMessage* indication=NULL;\n   H245Message *ph245msg=NULL;\n   \n   OOCTXT *pctxt=call->msgctxt;\n   ret = ooCreateH245Message\n      (call, &ph245msg, T_H245MultimediaSystemControlMessage_indication);\n   if (ret != OO_OK) {\n      OOTRACEERR3(\"Error:H245 message creation failed for - H245UserInput\"\n                  \"Indication_alphanumeric (%s, %s)\\n\",call->callType, \n                  call->callToken);\n      return OO_FAILED;\n   }\n   ph245msg->msgType = OOUserInputIndication;\n   indication = ph245msg->h245Msg.u.indication;\n   indication->t = T_H245IndicationMessage_userInput;\n   indication->u.userInput = \n      (H245UserInputIndication*)\n      memAllocZ (pctxt, sizeof(H245UserInputIndication));\n   if(!indication->u.userInput)\n   {\n      OOTRACEERR3(\"Error: Memory - ooH245UserInputIndication_alphanumeric - \"\n                  \" userInput (%s, %s)\\n\", call->callType, call->callToken);\n      ooFreeH245Message(call, ph245msg);\n      return OO_FAILED;\n   }\n   indication->u.userInput->t = T_H245UserInputIndication_alphanumeric;\n   indication->u.userInput->u.alphanumeric = (ASN1GeneralString)\n                                              memAlloc(pctxt, strlen(data)+1);\n   if(!indication->u.userInput->u.alphanumeric)\n   {\n      OOTRACEERR3(\"Error: Memory - ooH245UserInputIndication-alphanumeric - \"\n                  \"alphanumeric (%s, %s).\\n\", call->callType, call->callToken);\n      ooFreeH245Message(call, ph245msg);\n      return OO_FAILED;\n   }\n   strcpy(*(char**)&indication->u.userInput->u.alphanumeric, data);\n   OOTRACEDBGA3 (\"Built UserInputIndication_alphanumeric (%s, %s)\\n\", \n                 call->callType, call->callToken);\n   ret = ooSendH245Msg (call, ph245msg);\n   if (ret != OO_OK) {\n      OOTRACEERR3 \n         (\"Error:Failed to enqueue UserInputIndication_alphanumeric \"\n          \"message to outbound queue.(%s, %s)\\n\", call->callType, \n          call->callToken);\n   }\n   ooFreeH245Message (call, ph245msg);\n   return ret;\n}\n", "bug_type": null, "idx": 194}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res;\n\tres = ast_register_application_xml(app_originate, originate_exec);\n\treturn res ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 195}
{"project": "Asterisk", "target": 0, "func": "static int cli_endpoint_print_body(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\tRAII_VAR(struct ast_endpoint_snapshot *, endpoint_snapshot, ast_sip_get_endpoint_snapshot(endpoint), ao2_cleanup);\n\tstruct ast_sip_cli_context *context = arg;\n\tconst char *id = ast_sorcery_object_get_id(endpoint);\n\tchar *print_name = NULL;\n\tint print_name_len;\n\tchar *number = S_COR(endpoint->id.self.number.valid,\n\t\tendpoint->id.self.number.str, NULL);\n\tint indent;\n\tint flexwidth;\n\tast_assert(context->output_buffer != NULL);\n\tif (number) {\n\t\tprint_name_len = strlen(id) + strlen(number) + 2;\n\t\tprint_name = ast_alloca(print_name_len);\n\t\tsnprintf(print_name, print_name_len, \"%s/%s\", id, number);\n\t}\n\tindent = CLI_INDENT_TO_SPACES(context->indent_level);\n\tflexwidth = CLI_LAST_TABSTOP - indent - 2;\n\tast_str_append(&context->output_buffer, 0, \"%*s:  %-*.*s  %-12.12s  %d of %.0f\\n\",\n\t\tindent, \"Endpoint\",\n\t\tflexwidth, flexwidth, print_name ? print_name : id,\n\t\tast_sip_get_device_state(endpoint),\n\t\tendpoint_snapshot->num_channels,\n\t\t(double) endpoint->devicestate_busy_at ? endpoint->devicestate_busy_at :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tINFINITY\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\tif (context->recurse) {\n\t\tcontext->indent_level++;\n\t\tcontext->auth_direction = \"Out\";\n\t\tcli_endpoint_print_child_body(\"auth\", &endpoint->outbound_auths, context);\n\t\tcontext->auth_direction = \"In\";\n\t\tcli_endpoint_print_child_body(\"auth\", &endpoint->inbound_auths, context);\n\t\tcli_endpoint_print_child_body(\"aor\", endpoint->aors, context);\n\t\tcli_endpoint_print_child_body(\"transport\", endpoint, context);\n\t\tcli_endpoint_print_child_body(\"identify\", endpoint, context);\n\t\tcli_endpoint_print_child_body(\"channel\", endpoint, context);\n\t\tcontext->indent_level--;\n\t\tif (context->indent_level == 0) {\n\t\t\tast_str_append(&context->output_buffer, 0, \"\\n\");\n\t\t}\n\t}\n\tif (context->show_details || (context->show_details_only_level_0 && context->indent_level == 0)) {\n\t\tast_str_append(&context->output_buffer, 0, \"\\n\");\n\t\tast_sip_cli_print_sorcery_objectset(endpoint, context, 0);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 196}
{"project": "Asterisk", "target": 0, "func": "static void free_category(struct category *cat)\n{\n\tstruct member *mem;\n\txmlFree((void *) cat->name);\n\txmlFree((void *) cat->displayname);\n\txmlFree((void *) cat->remove_on_change);\n\txmlFree((void *) cat->touch_on_change);\n\twhile ((mem = AST_LIST_REMOVE_HEAD(&cat->members, list))) {\n\t\tfree_member(mem);\n\t}\n\tfree(cat);\n}\n", "bug_type": null, "idx": 197}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MultiplexElement (OOCTXT* pctxt, H245MultiplexElement* pvalue)\n{\n   int stat = ASN_OK;\n   \n   stat = asn1PE_H245MultiplexElement_type (pctxt, &pvalue->type);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H245MultiplexElement_repeatCount (pctxt, &pvalue->repeatCount);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 198}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245RequestMessage (OOCTXT* pctxt, H245RequestMessage* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 11);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 10);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245MasterSlaveDetermination (pctxt, pvalue->u.masterSlaveDetermination);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245TerminalCapabilitySet (pctxt, pvalue->u.terminalCapabilitySet);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = asn1PE_H245OpenLogicalChannel (pctxt, pvalue->u.openLogicalChannel);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 5:\n            stat = asn1PE_H245CloseLogicalChannel (pctxt, pvalue->u.closeLogicalChannel);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 6:\n            stat = asn1PE_H245RequestChannelClose (pctxt, pvalue->u.requestChannelClose);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 7:\n            stat = asn1PE_H245MultiplexEntrySend (pctxt, pvalue->u.multiplexEntrySend);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 8:\n            stat = asn1PE_H245RequestMultiplexEntry (pctxt, pvalue->u.requestMultiplexEntry);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 9:\n            stat = asn1PE_H245RequestMode (pctxt, pvalue->u.requestMode);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 10:\n            stat = asn1PE_H245RoundTripDelayRequest (pctxt, pvalue->u.roundTripDelayRequest);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 11:\n            stat = asn1PE_H245MaintenanceLoopRequest (pctxt, pvalue->u.maintenanceLoopRequest);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 12);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 12:\n            stat = asn1PE_H245CommunicationModeRequest (&lctxt, pvalue->u.communicationModeRequest);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 13:\n            stat = asn1PE_H245ConferenceRequest (&lctxt, pvalue->u.conferenceRequest);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 14:\n            stat = asn1PE_H245MultilinkRequest (&lctxt, pvalue->u.multilinkRequest);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 15:\n            stat = asn1PE_H245LogicalChannelRateRequest (&lctxt, pvalue->u.logicalChannelRateRequest);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 199}
{"project": "Asterisk", "target": 0, "func": "static rc_handle *rh = NULL;\nstatic int build_radius_record(VALUE_PAIR **tosend, struct ast_cdr *cdr)\n{\n\tint recordtype = PW_STATUS_STOP;\n\tstruct ast_tm tm;\n\tchar timestr[128];\n\tchar *tmp;\n\tif (!rc_avpair_add(rh, tosend, PW_ACCT_STATUS_TYPE, &recordtype, 0, 0))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_ACCT_CODE, &cdr->accountcode, strlen(cdr->accountcode), VENDOR_CODE))\n\t\treturn -1;\n \t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_SRC, &cdr->src, strlen(cdr->src), VENDOR_CODE))\n\t\treturn -1;\n \t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_DST, &cdr->dst, strlen(cdr->dst), VENDOR_CODE))\n\t\treturn -1;\n \t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_DST_CTX, &cdr->dcontext, strlen(cdr->dcontext), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_CLID, &cdr->clid, strlen(cdr->clid), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_CHAN, &cdr->channel, strlen(cdr->channel), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_DST_CHAN, &cdr->dstchannel, strlen(cdr->dstchannel), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_LAST_APP, &cdr->lastapp, strlen(cdr->lastapp), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_LAST_DATA, &cdr->lastdata, strlen(cdr->lastdata), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tast_strftime(timestr, sizeof(timestr), DATE_FORMAT,\n\t\tast_localtime(&cdr->start, &tm,\n\t\t\tast_test_flag(&global_flags, RADIUS_FLAG_USEGMTIME) ? \"GMT\" : NULL));\n\tif (!rc_avpair_add(rh, tosend, PW_AST_START_TIME, timestr, strlen(timestr), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tast_strftime(timestr, sizeof(timestr), DATE_FORMAT,\n\t\tast_localtime(&cdr->answer, &tm,\n\t\t\tast_test_flag(&global_flags, RADIUS_FLAG_USEGMTIME) ? \"GMT\" : NULL));\n\tif (!rc_avpair_add(rh, tosend, PW_AST_ANSWER_TIME, timestr, strlen(timestr), VENDOR_CODE))\n\t\treturn -1;\n\t\n\tast_strftime(timestr, sizeof(timestr), DATE_FORMAT,\n\t\tast_localtime(&cdr->end, &tm,\n\t\t\tast_test_flag(&global_flags, RADIUS_FLAG_USEGMTIME) ? \"GMT\" : NULL));\n\tif (!rc_avpair_add(rh, tosend, PW_AST_END_TIME, timestr, strlen(timestr), VENDOR_CODE))\n\t\treturn -1;\n \t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_DURATION, &cdr->duration, 0, VENDOR_CODE))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_AST_BILL_SEC, &cdr->billsec, 0, VENDOR_CODE))\n\t\treturn -1;\n\t\n\ttmp = ast_strdupa(ast_cdr_disp2str(cdr->disposition));\n\tif (!rc_avpair_add(rh, tosend, PW_AST_DISPOSITION, tmp, strlen(tmp), VENDOR_CODE))\n\t\treturn -1;\n\t\n\ttmp = ast_strdupa(ast_channel_amaflags2string(cdr->amaflags));\n\tif (!rc_avpair_add(rh, tosend, PW_AST_AMA_FLAGS, tmp, strlen(tmp), VENDOR_CODE))\n\t\treturn -1;\n\tif (ast_test_flag(&global_flags, RADIUS_FLAG_LOGUNIQUEID)) {\n\t\t\n\t\tif (!rc_avpair_add(rh, tosend, PW_AST_UNIQUE_ID, &cdr->uniqueid, strlen(cdr->uniqueid), VENDOR_CODE))\n\t\t\treturn -1;\n\t}\n\tif (ast_test_flag(&global_flags, RADIUS_FLAG_LOGUSERFIELD)) {\n\t\t\n\t\tif (!rc_avpair_add(rh, tosend, PW_AST_USER_FIELD, &cdr->userfield, strlen(cdr->userfield), VENDOR_CODE))\n\t\t\treturn -1;\n\t}\n\t\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_USER_NAME, &cdr->channel, strlen(cdr->channel), 0))\n\t\treturn -1;\n\t\n\tif (!rc_avpair_add(rh, tosend, PW_ACCT_SESSION_ID, &cdr->uniqueid, strlen(cdr->uniqueid), 0))\n\t\treturn -1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 200}
{"project": "Asterisk", "target": 0, "func": " */\nstatic pjsip_require_hdr *create_require_eventlist(pj_pool_t *pool)\n{\n\tpjsip_require_hdr *require;\n\trequire = pjsip_require_hdr_create(pool);\n\tpj_strdup2(pool, &require->values[0], \"eventlist\");\n\trequire->count = 1;\n\treturn require;\n}\n", "bug_type": null, "idx": 201}
{"project": "Asterisk", "target": 0, "func": "int ast_sorcery_create(const struct ast_sorcery *sorcery, void *object)\n{\n\tconst struct ast_sorcery_object_details *details = object;\n\tRAII_VAR(struct ast_sorcery_object_type *, object_type, ao2_find(sorcery->types, details->object->type, OBJ_KEY), ao2_cleanup);\n\tstruct ast_sorcery_object_wizard *object_wizard = NULL;\n\tstruct ast_sorcery_object_wizard *found_wizard;\n\tint i;\n\tstruct sorcery_details sdetails = {\n\t\t.sorcery = sorcery,\n\t\t.obj = object,\n\t};\n\tif (!object_type) {\n\t\treturn -1;\n\t}\n\tAST_VECTOR_RW_RDLOCK(&object_type->wizards);\n\tfor (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {\n\t\tfound_wizard = AST_VECTOR_GET(&object_type->wizards, i);\n\t\tif (!found_wizard->caching\n\t\t\t&& sorcery_wizard_create(found_wizard, &sdetails) == CMP_MATCH) {\n\t\t\tobject_wizard = found_wizard;\n\t\t}\n\t}\n\tif (object_wizard) {\n\t\tfor (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {\n\t\t\tfound_wizard = AST_VECTOR_GET(&object_type->wizards, i);\n\t\t\tif (found_wizard->caching) {\n\t\t\t\tsorcery_wizard_create(found_wizard, &sdetails);\n\t\t\t}\n\t\t}\n\t\tif (ao2_container_count(object_type->observers)) {\n\t\t\tstruct sorcery_observer_invocation *invocation;\n\t\t\tinvocation = sorcery_observer_invocation_alloc(object_type, object);\n\t\t\tif (invocation\n\t\t\t\t&& ast_taskprocessor_push(object_type->serializer, sorcery_observers_notify_create,\n\t\t\t\t\tinvocation)) {\n\t\t\t\tao2_cleanup(invocation);\n\t\t\t}\n\t\t}\n\t}\n\tAST_VECTOR_RW_UNLOCK(&object_type->wizards);\n\treturn object_wizard ? 0 : -1;\n}\n", "bug_type": null, "idx": 202}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_cli_formatter_entry *ast_sip_lookup_cli_formatter(const char *name)\n{\n\treturn ao2_find(formatter_registry, name, OBJ_SEARCH_KEY | OBJ_NOLOCK);\n}\n", "bug_type": null, "idx": 203}
{"project": "Asterisk", "target": 0, "func": "int ast_adsi_query_cpeid(unsigned char *buf)\n{\n\tint res = 0;\n\tast_rwlock_rdlock(&func_lock);\n\tif (installed_funcs && installed_funcs->query_cpeid) {\n\t\tres = installed_funcs->query_cpeid(buf);\n\t}\n\tast_rwlock_unlock(&func_lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 204}
{"project": "Asterisk", "target": 0, "func": " */\nvoid __ast_mm_init_phase_2(void)\n{\n\tchar filename[PATH_MAX];\n\tast_cli_register_multiple(cli_memory, ARRAY_LEN(cli_memory));\n\tsnprintf(filename, sizeof(filename), \"%s/mmlog\", ast_config_AST_LOG_DIR);\n\tast_verb(1, \"Asterisk Malloc Debugger Started (see %s))\\n\", filename);\n\tmmlog = fopen(filename, \"a+\");\n\tif (mmlog) {\n\t\tfprintf(mmlog, \"%ld - New session\\n\", (long) time(NULL));\n\t\tfflush(mmlog);\n\t} else {\n\t\tast_log(LOG_ERROR, \"Could not open malloc debug log file: %s\\n\", filename);\n\t}\n\tast_register_cleanup(mm_atexit_ast);\n}\n", "bug_type": null, "idx": 205}
{"project": "Asterisk", "target": 0, "func": "\ned_tty_dsusp(EditLine *el, int c)\n{\n\treturn (CC_NORM);\n}\n", "bug_type": null, "idx": 206}
{"project": "Asterisk", "target": 0, "func": "\nstatic int ip_identify_match_host_lookup(struct ip_identify_match *identify, const char *host)\n{\n\tstruct ast_sockaddr *addrs;\n\tint num_addrs = 0, error = 0, i;\n\tint results = 0;\n\tnum_addrs = ast_sockaddr_resolve(&addrs, host, PARSE_PORT_FORBID, AST_AF_UNSPEC);\n\tif (!num_addrs) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < num_addrs; ++i) {\n\t\t\n\t\tif (identify->matches && (ast_apply_ha(identify->matches, &addrs[i]) != AST_SENSE_ALLOW)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tidentify->matches = ast_append_ha(\"d\", ast_sockaddr_stringify_addr(&addrs[i]), identify->matches, &error);\n\t\tif (!identify->matches || error) {\n\t\t\tresults = -1;\n\t\t\tbreak;\n\t\t}\n\t\tresults += 1;\n\t}\n\tast_free(addrs);\n\treturn results;\n}\n", "bug_type": null, "idx": 207}
{"project": "Asterisk", "target": 0, "func": "void ast_tonepair_stop(struct ast_channel *chan)\n{\n\tast_deactivate_generator(chan);\n}\n", "bug_type": null, "idx": 208}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_message(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_type = 0;\n\tconst char *discriminator;\n\tdiscriminator = ast_json_string_get(ast_json_object_get(json, \"type\"));\n\tif (!discriminator) {\n\t\tast_log(LOG_ERROR, \"ARI Message missing required field type\\n\");\n\t\treturn 0;\n\t}\n\tif (strcmp(\"Message\", discriminator) == 0) {\n\t\t\n\t} else\n\tif (strcmp(\"ApplicationReplaced\", discriminator) == 0) {\n\t\treturn ast_ari_validate_application_replaced(json);\n\t} else\n\tif (strcmp(\"BridgeAttendedTransfer\", discriminator) == 0) {\n\t\treturn ast_ari_validate_bridge_attended_transfer(json);\n\t} else\n\tif (strcmp(\"BridgeBlindTransfer\", discriminator) == 0) {\n\t\treturn ast_ari_validate_bridge_blind_transfer(json);\n\t} else\n\tif (strcmp(\"BridgeCreated\", discriminator) == 0) {\n\t\treturn ast_ari_validate_bridge_created(json);\n\t} else\n\tif (strcmp(\"BridgeDestroyed\", discriminator) == 0) {\n\t\treturn ast_ari_validate_bridge_destroyed(json);\n\t} else\n\tif (strcmp(\"BridgeMerged\", discriminator) == 0) {\n\t\treturn ast_ari_validate_bridge_merged(json);\n\t} else\n\tif (strcmp(\"BridgeVideoSourceChanged\", discriminator) == 0) {\n\t\treturn ast_ari_validate_bridge_video_source_changed(json);\n\t} else\n\tif (strcmp(\"ChannelCallerId\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_caller_id(json);\n\t} else\n\tif (strcmp(\"ChannelConnectedLine\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_connected_line(json);\n\t} else\n\tif (strcmp(\"ChannelCreated\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_created(json);\n\t} else\n\tif (strcmp(\"ChannelDestroyed\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_destroyed(json);\n\t} else\n\tif (strcmp(\"ChannelDialplan\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_dialplan(json);\n\t} else\n\tif (strcmp(\"ChannelDtmfReceived\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_dtmf_received(json);\n\t} else\n\tif (strcmp(\"ChannelEnteredBridge\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_entered_bridge(json);\n\t} else\n\tif (strcmp(\"ChannelHangupRequest\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_hangup_request(json);\n\t} else\n\tif (strcmp(\"ChannelHold\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_hold(json);\n\t} else\n\tif (strcmp(\"ChannelLeftBridge\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_left_bridge(json);\n\t} else\n\tif (strcmp(\"ChannelStateChange\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_state_change(json);\n\t} else\n\tif (strcmp(\"ChannelTalkingFinished\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_talking_finished(json);\n\t} else\n\tif (strcmp(\"ChannelTalkingStarted\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_talking_started(json);\n\t} else\n\tif (strcmp(\"ChannelUnhold\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_unhold(json);\n\t} else\n\tif (strcmp(\"ChannelUserevent\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_userevent(json);\n\t} else\n\tif (strcmp(\"ChannelVarset\", discriminator) == 0) {\n\t\treturn ast_ari_validate_channel_varset(json);\n\t} else\n\tif (strcmp(\"ContactStatusChange\", discriminator) == 0) {\n\t\treturn ast_ari_validate_contact_status_change(json);\n\t} else\n\tif (strcmp(\"DeviceStateChanged\", discriminator) == 0) {\n\t\treturn ast_ari_validate_device_state_changed(json);\n\t} else\n\tif (strcmp(\"Dial\", discriminator) == 0) {\n\t\treturn ast_ari_validate_dial(json);\n\t} else\n\tif (strcmp(\"EndpointStateChange\", discriminator) == 0) {\n\t\treturn ast_ari_validate_endpoint_state_change(json);\n\t} else\n\tif (strcmp(\"Event\", discriminator) == 0) {\n\t\treturn ast_ari_validate_event(json);\n\t} else\n\tif (strcmp(\"MissingParams\", discriminator) == 0) {\n\t\treturn ast_ari_validate_missing_params(json);\n\t} else\n\tif (strcmp(\"PeerStatusChange\", discriminator) == 0) {\n\t\treturn ast_ari_validate_peer_status_change(json);\n\t} else\n\tif (strcmp(\"PlaybackContinuing\", discriminator) == 0) {\n\t\treturn ast_ari_validate_playback_continuing(json);\n\t} else\n\tif (strcmp(\"PlaybackFinished\", discriminator) == 0) {\n\t\treturn ast_ari_validate_playback_finished(json);\n\t} else\n\tif (strcmp(\"PlaybackStarted\", discriminator) == 0) {\n\t\treturn ast_ari_validate_playback_started(json);\n\t} else\n\tif (strcmp(\"RecordingFailed\", discriminator) == 0) {\n\t\treturn ast_ari_validate_recording_failed(json);\n\t} else\n\tif (strcmp(\"RecordingFinished\", discriminator) == 0) {\n\t\treturn ast_ari_validate_recording_finished(json);\n\t} else\n\tif (strcmp(\"RecordingStarted\", discriminator) == 0) {\n\t\treturn ast_ari_validate_recording_started(json);\n\t} else\n\tif (strcmp(\"StasisEnd\", discriminator) == 0) {\n\t\treturn ast_ari_validate_stasis_end(json);\n\t} else\n\tif (strcmp(\"StasisStart\", discriminator) == 0) {\n\t\treturn ast_ari_validate_stasis_start(json);\n\t} else\n\tif (strcmp(\"TextMessageReceived\", discriminator) == 0) {\n\t\treturn ast_ari_validate_text_message_received(json);\n\t} else\n\t{\n\t\tast_log(LOG_ERROR, \"ARI Message has undocumented subtype %s\\n\",\n\t\t\tdiscriminator);\n\t\tres = 0;\n\t}\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"asterisk_id\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Message field asterisk_id failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"type\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_type = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Message field type failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI Message has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_type) {\n\t\tast_log(LOG_ERROR, \"ARI Message missing required field type\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 209}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H235ChallengeString (OOCTXT* pctxt, H235ChallengeString* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 8, 128, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeOctetString (pctxt,\n                          &pvalue->numocts,\n                          pvalue->data,\n                          sizeof(pvalue->data));\n   if (stat != ASN_OK) return stat;\n   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);\n   return (stat);\n}\n", "bug_type": null, "idx": 210}
{"project": "Asterisk", "target": 0, "func": "static void sla_queue_event_full(enum sla_event_type type, \n\tstruct sla_trunk_ref *trunk_ref, struct sla_station *station, int lock)\n{\n\tstruct sla_event *event;\n\tif (sla.thread == AST_PTHREADT_NULL) {\n\t\tao2_ref(station, -1);\n\t\tao2_ref(trunk_ref, -1);\n\t\treturn;\n\t}\n\tif (!(event = ast_calloc(1, sizeof(*event)))) {\n\t\tao2_ref(station, -1);\n\t\tao2_ref(trunk_ref, -1);\n\t\treturn;\n\t}\n\tevent->type = type;\n\tevent->trunk_ref = trunk_ref;\n\tevent->station = station;\n\tif (!lock) {\n\t\tAST_LIST_INSERT_TAIL(&sla.event_q, event, entry);\n\t\treturn;\n\t}\n\tast_mutex_lock(&sla.lock);\n\tAST_LIST_INSERT_TAIL(&sla.event_q, event, entry);\n\tast_cond_signal(&sla.cond);\n\tast_mutex_unlock(&sla.lock);\n}\n", "bug_type": null, "idx": 211}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int sig_ss7_is_chan_available(struct sig_ss7_chan *pvt)\n{\n\tif (pvt->inservice && !pvt->inalarm && !pvt->owner && !pvt->ss7call\n\t\t&& pvt->call_level == SIG_SS7_CALL_LEVEL_IDLE\n\t\t&& !pvt->locallyblocked && !pvt->remotelyblocked) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 212}
{"project": "Asterisk", "target": 0, "func": "static pj_bool_t authenticate(pjsip_rx_data *rdata)\n{\n\tRAII_VAR(struct ast_sip_endpoint *, endpoint, ast_pjsip_rdata_get_endpoint(rdata), ao2_cleanup);\n\tint is_ack = rdata->msg_info.msg->line.req.method.id == PJSIP_ACK_METHOD;\n\tast_assert(endpoint != NULL);\n\tif (endpoint!=artificial_endpoint) {\n\t\tif (apply_endpoint_acl(rdata, endpoint) || apply_endpoint_contact_acl(rdata, endpoint)) {\n\t\t\tif (!is_ack) {\n\t\t\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);\n\t\t\t}\n\t\t\treturn PJ_TRUE;\n\t\t}\n\t}\n\tif (!is_ack && ast_sip_requires_authentication(endpoint, rdata)) {\n\t\tpjsip_tx_data *tdata;\n\t\tstruct unidentified_request *unid;\n\t\tpjsip_endpt_create_response(ast_sip_get_pjsip_endpoint(), rdata, 401, NULL, &tdata);\n\t\tswitch (ast_sip_check_authentication(endpoint, rdata, tdata)) {\n\t\tcase AST_SIP_AUTHENTICATION_CHALLENGE:\n\t\t\t\n\t\t\tast_sip_report_auth_challenge_sent(endpoint, rdata, tdata);\n\t\t\tpjsip_endpt_send_response2(ast_sip_get_pjsip_endpoint(), rdata, tdata, NULL, NULL);\n\t\t\treturn PJ_TRUE;\n\t\tcase AST_SIP_AUTHENTICATION_SUCCESS:\n\t\t\t\n\t\t\tif ((unid = ao2_find(unidentified_requests, rdata->pkt_info.src_name, OBJ_SEARCH_KEY))) {\n\t\t\t\tao2_unlink(unidentified_requests, unid);\n\t\t\t\tao2_ref(unid, -1);\n\t\t\t}\n\t\t\tast_sip_report_auth_success(endpoint, rdata);\n\t\t\tbreak;\n\t\tcase AST_SIP_AUTHENTICATION_FAILED:\n\t\t\tlog_failed_request(rdata, \"Failed to authenticate\", 0, 0);\n\t\t\tast_sip_report_auth_failed_challenge_response(endpoint, rdata);\n\t\t\tpjsip_endpt_send_response2(ast_sip_get_pjsip_endpoint(), rdata, tdata, NULL, NULL);\n\t\t\treturn PJ_TRUE;\n\t\tcase AST_SIP_AUTHENTICATION_ERROR:\n\t\t\tlog_failed_request(rdata, \"Error to authenticate\", 0, 0);\n\t\t\tast_sip_report_auth_failed_challenge_response(endpoint, rdata);\n\t\t\tpjsip_tx_data_dec_ref(tdata);\n\t\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 500, NULL, NULL, NULL);\n\t\t\treturn PJ_TRUE;\n\t\t}\n\t\tpjsip_tx_data_dec_ref(tdata);\n\t}\n\treturn PJ_FALSE;\n}\n", "bug_type": null, "idx": 213}
{"project": "Asterisk", "target": 0, "func": "int ooRTDTimerExpired(void *data)\n{\n   ooTimerCallback *cbData = (ooTimerCallback*)data;\n   OOH323CallData *call = cbData->call;\n   OOTRACEINFO3(\"Time to send new RTD request. (%s, %s)\\n\",\n                 call->callType, call->callToken);\n   ASN1MEMFREEPTR(call->pctxt, cbData);\n   ooSendRoundTripDelayRequest(call);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 214}
{"project": "Asterisk", "target": 0, "func": "#define AST_CALLERID_UNKNOWN\t\"<unknown>\"\nstatic inline void gen_tones(unsigned char *buf, int len, struct ast_format *codec, float ddr1, float ddi1, float ddr2, float ddi2, float *cr1, float *ci1, float *cr2, float *ci2)\n{\n\tint x;\n\tfloat t;\n\tfor (x = 0; x < len; x++) {\n\t\tt = *cr1 * ddr1 - *ci1 * ddi1;\n\t\t*ci1 = *cr1 * ddi1 + *ci1 * ddr1;\n\t\t*cr1 = t;\n\t\tt = 2.0 - (*cr1 * *cr1 + *ci1 * *ci1);\n\t\t*cr1 *= t;\n\t\t*ci1 *= t;\n\t\tt = *cr2 * ddr2 - *ci2 * ddi2;\n\t\t*ci2 = *cr2 * ddi2 + *ci2 * ddr2;\n\t\t*cr2 = t;\n\t\tt = 2.0 - (*cr2 * *cr2 + *ci2 * *ci2);\n\t\t*cr2 *= t;\n\t\t*ci2 *= t;\n\t\tbuf[x] = AST_LIN2X((*cr1 + *cr2) * 2048.0);\n\t}\n}\n", "bug_type": null, "idx": 215}
{"project": "Asterisk", "target": 0, "func": "static msg_t *build_timeout (struct isdn_msg msgs[], struct misdn_bchannel *bc, int nt)\n{\n\tmsg_t *msg =(msg_t*)create_l3msg(CC_STATUS | REQUEST, MT_STATUS,  bc?bc->l3_id:-1, sizeof(STATUS_t) ,nt);\n#ifdef DEBUG\n\tprintf(\"Building STATUS Msg\\n\");\n#endif\n\treturn msg;\n}\n", "bug_type": null, "idx": 216}
{"project": "Asterisk", "target": 0, "func": "int ast_max_forwards_decrement(struct ast_channel *chan)\n{\n\tstruct ast_datastore *mf_datastore;\n\tstruct max_forwards *mf;\n\tmf_datastore = max_forwards_datastore_find_or_alloc(chan);\n\tif (!mf_datastore) {\n\t\treturn -1;\n\t}\n\tmf = mf_datastore->data;\n\t--mf->current_count;\n\treturn 0;\n}\n", "bug_type": null, "idx": 217}
{"project": "Asterisk", "target": 0, "func": "static char *media_cache_handle_show_all(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"media cache show all\";\n\t\te->usage =\n\t\t\t\"Usage: media cache show all\\n\"\n\t\t\t\"       Display a summary of all current items\\n\"\n\t\t\t\"       in the media cache.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_cli(a->fd, \"URI\\n\\tLocal File\\n\");\n\tast_cli(a->fd, \"---------------\\n\");\n\tao2_callback(media_cache, OBJ_NODATA | OBJ_MULTIPLE, media_cache_prnt_summary, a);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 218}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_unregister_application(app);\n}\n", "bug_type": null, "idx": 219}
{"project": "Asterisk", "target": 0, "func": "int ooGkClientARQTimerExpired(void* pdata)\n{\n   int ret=0;\n   ooGkClientTimerCb *cbData = (ooGkClientTimerCb*)pdata;\n   ooGkClient *pGkClient = cbData->pGkClient;\n   RasCallAdmissionInfo *pAdmInfo = cbData->pAdmInfo;\n   OOTRACEDBGA1(\"Gatekeeper client ARQ timer expired.\\n\");\n   memFreePtr(&pGkClient->ctxt, cbData);   \n   if(!pAdmInfo)\n    return OO_OK;\n   if(pAdmInfo->retries < OO_MAX_ARQ_RETRIES)\n   {\n      ret = ooGkClientSendAdmissionRequest(pGkClient, pAdmInfo->call, TRUE);      \n      if(ret != OO_OK)\n      {\n         OOTRACEERR1(\"Error:Failed to send ARQ message\\n\");\n         return OO_FAILED;\n      }\n      pAdmInfo->retries++;\n      return OO_OK;\n   }\n   OOTRACEERR1(\"Error:Gatekeeper not responding to ARQ\\n\");\n   pGkClient->state = GkClientGkErr;\n   return OO_FAILED;\n}\n", "bug_type": null, "idx": 220}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235ECKASDH (OOCTXT* pctxt, H235ECKASDH* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 2);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 1);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H235ECKASDH_eckasdhp (pctxt, pvalue->u.eckasdhp);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H235ECKASDH_eckasdh2 (pctxt, pvalue->u.eckasdh2);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 3);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 221}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_send_stateful_response(pjsip_rx_data *rdata, pjsip_tx_data *tdata, struct ast_sip_endpoint *sip_endpoint)\n{\n\tpjsip_transaction *tsx;\n\tif (pjsip_tsx_create_uas(NULL, rdata, &tsx) != PJ_SUCCESS) {\n\t\tstruct ast_sip_contact *contact;\n\t\t\n\t\tcontact = ast_sip_mod_data_get(tdata->mod_data, supplement_module.id, MOD_DATA_CONTACT);\n\t\tao2_cleanup(contact);\n\t\tast_sip_mod_data_set(tdata->pool, tdata->mod_data, supplement_module.id, MOD_DATA_CONTACT, NULL);\n\t\tpjsip_tx_data_dec_ref(tdata);\n\t\treturn -1;\n\t}\n\tpjsip_tsx_recv_msg(tsx, rdata);\n\tsupplement_outgoing_response(tdata, sip_endpoint);\n\tif (pjsip_tsx_send_msg(tsx, tdata) != PJ_SUCCESS) {\n\t\tpjsip_tx_data_dec_ref(tdata);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 222}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void mm_atexit_list_sort(struct region_list *list, size_t length)\n{\n\t\n\tstruct region_list merged = AST_LIST_HEAD_NOLOCK_INIT_VALUE;\n\t\n\tstruct region_list sub[2] = {\n\t\tAST_LIST_HEAD_NOLOCK_INIT_VALUE,\n\t\tAST_LIST_HEAD_NOLOCK_INIT_VALUE\n\t};\n\t\n\tsize_t size = 1;\n\t\n\tsize_t remaining;\n\t\n\tint passes;\n\tfor (;;) {\n\t\tremaining = length;\n\t\tpasses = 0;\n\t\twhile (!AST_LIST_EMPTY(list)) {\n\t\t\tmm_atexit_list_split(list, sub, ARRAY_LEN(sub), size, &remaining);\n\t\t\tmm_atexit_list_merge(&merged, &sub[0], &sub[1]);\n\t\t\t++passes;\n\t\t}\n\t\tAST_LIST_APPEND_LIST(list, &merged, node);\n\t\tif (passes <= 1) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsize <<= 1;\n\t}\n}\n", "bug_type": null, "idx": 223}
{"project": "Asterisk", "target": 0, "func": "static AST_RWLIST_HEAD_STATIC(thread_list, thread_list_t);\nvoid ast_register_thread(char *name)\n{\n\tstruct thread_list_t *new = ast_calloc(1, sizeof(*new));\n\tif (!new)\n\t\treturn;\n\tast_assert(multi_thread_safe);\n\tnew->id = pthread_self();\n\tnew->lwp = ast_get_tid();\n\tnew->name = name; \n\tAST_RWLIST_WRLOCK(&thread_list);\n\tAST_RWLIST_INSERT_HEAD(&thread_list, new, list);\n\tAST_RWLIST_UNLOCK(&thread_list);\n}\n", "bug_type": null, "idx": 224}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int match_ie_val(\n\tconst struct ast_event *event1,\n\tconst struct ast_event *event2,\n\tenum ast_event_ie_type type)\n{\n\tenum ast_event_ie_pltype pltype = ast_event_get_ie_pltype(type);\n\t\n\tif (type == AST_EVENT_IE_CEL_EVENT_TIME_USEC) {\n\t\treturn 1;\n\t}\n\tif (type == AST_EVENT_IE_CEL_EVENT_TIME) {\n\t\treturn 1;\n\t}\n\tswitch (pltype) {\n\tcase AST_EVENT_IE_PLTYPE_UINT:\n\t{\n\t\tuint32_t val = ast_event_get_ie_uint(event2, type);\n\t\treturn (val == ast_event_get_ie_uint(event1, type)) ? 1 : 0;\n\t}\n\tcase AST_EVENT_IE_PLTYPE_STR:\n\t{\n\t\tconst char *str1 = ast_event_get_ie_str(event1, type);\n\t\tconst char *str2 = ast_event_get_ie_str(event2, type);\n\t\tif (!str1 && !str2) {\n\t\t\treturn 1;\n\t\t} else if (!str1) {\n\t\t\treturn 0;\n\t\t} else if (!str2) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (type == AST_EVENT_IE_CEL_PEER) {\n\t\t\treturn test_cel_peer_strings_match(str1, str2);\n\t\t}\n\t\treturn !strcmp(str1, str2);\n\t}\n\tcase AST_EVENT_IE_PLTYPE_RAW:\n\tcase AST_EVENT_IE_PLTYPE_BITFLAGS:\n\t\t\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 225}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tstruct ao2_container *endpoints;\n\tendpoints = stasis_cache_dump(ast_endpoint_cache(), ast_endpoint_snapshot_type());\n\tif (endpoints) {\n\t\tao2_callback(endpoints, OBJ_MULTIPLE | OBJ_NODATA | OBJ_NOLOCK, dump_cache_unload, NULL);\n\t\tao2_ref(endpoints, -1);\n\t}\n\tstasis_message_router_unsubscribe_and_join(router);\n\trouter = NULL;\n\treturn 0;\n}\n", "bug_type": null, "idx": 226}
{"project": "Asterisk", "target": 0, "func": "static void dahdi_train_ec(struct dahdi_pvt *p);\nstatic int my_train_echocanceller(void *pvt)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tdahdi_train_ec(p);\n\treturn 0;\n}\n", "bug_type": null, "idx": 227}
{"project": "Asterisk", "target": 0, "func": "static void spandsp_v21_tone(void *data, int code, int level, int delay)\n{\n\tstruct spandsp_pvt *p = data;\n\tif (code == MODEM_CONNECT_TONES_FAX_PREAMBLE) {\n\t\tp->v21_detected = 1;\n\t}\n}\n", "bug_type": null, "idx": 228}
{"project": "Asterisk", "target": 0, "func": "static int unbound_resolver_resolve(struct ast_dns_query *query)\n{\n\tstruct unbound_config *cfg = ao2_global_obj_ref(globals);\n\tstruct unbound_resolver_data *data;\n\tint res;\n\tdata = ao2_alloc_options(sizeof(*data), unbound_resolver_data_dtor,\n\t\tAO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!data) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate resolver data for resolution of '%s'\\n\",\n\t\t\tast_dns_query_get_name(query));\n\t\treturn -1;\n\t}\n\tdata->resolver = ao2_bump(cfg->global->state->resolver);\n\tast_dns_resolver_set_data(query, data);\n\tres = ub_resolve_async(data->resolver->context, (UNBOUND_CHAR *)ast_dns_query_get_name(query),\n\t\tast_dns_query_get_rr_type(query), ast_dns_query_get_rr_class(query),\n\t\tao2_bump(query), unbound_resolver_callback, &data->id);\n\tif (res) {\n\t\tast_log(LOG_ERROR, \"Failed to perform async DNS resolution of '%s'\\n\",\n\t\t\tast_dns_query_get_name(query));\n\t\tao2_ref(query, -1);\n\t}\n\tao2_ref(data, -1);\n\tao2_ref(cfg, -1);\n\treturn res;\n}\n", "bug_type": null, "idx": 229}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res;\n\tAST_LIST_LOCK(&cmts_list);\n\tres = load_pktccops_config();\n\tAST_LIST_UNLOCK(&cmts_list);\n\tif (res == -1) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_cli_register_multiple(cli_pktccops, sizeof(cli_pktccops) / sizeof(struct ast_cli_entry));\n\trestart_pktc_thread();\n\treturn 0;\n}\n", "bug_type": null, "idx": 230}
{"project": "Asterisk", "target": 0, "func": "void ast_iostream_set_timeout_inactivity(struct ast_iostream *stream, int timeout)\n{\n\tast_assert(stream != NULL);\n\tstream->start.tv_sec = 0;\n\tstream->timeout = timeout;\n\tstream->timeout_reset = timeout;\n}\n", "bug_type": null, "idx": 231}
{"project": "Asterisk", "target": 0, "func": "static int is_argument(const char *haystack, int needle)\n{\n\tif (ast_strlen_zero(haystack))\n\t\treturn 0;\n\tif (strchr(haystack, needle))\n\t\treturn -1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 232}
{"project": "Asterisk", "target": 0, "func": "static int bridge_builtin_set_limits(struct ast_bridge_features *features,\n\tstruct ast_bridge_features_limits *limits,\n\tenum ast_bridge_hook_remove_flags remove_flags)\n{\n\tRAII_VAR(struct ast_bridge_features_limits *, feature_limits, NULL, ao2_cleanup);\n\tif (!limits->duration) {\n\t\treturn -1;\n\t}\n\t\n\tast_module_ref(ast_module_info->self);\n\tfeature_limits = ao2_alloc_options(sizeof(*feature_limits),\n\t\tbridge_features_limits_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!feature_limits) {\n\t\tast_module_unref(ast_module_info->self);\n\t\treturn -1;\n\t}\n\tif (ast_bridge_features_limits_construct(feature_limits)) {\n\t\treturn -1;\n\t}\n\tbridge_features_limits_copy(feature_limits, limits);\n\tfeature_limits->quitting_time = ast_tvadd(ast_tvnow(),\n\t\tast_samp2tv(feature_limits->duration, 1000));\n\t\n\tao2_ref(feature_limits, +1);\n\tif (ast_bridge_interval_hook(features, AST_BRIDGE_HOOK_TIMER_OPTION_MEDIA,\n\t\tfeature_limits->duration,\n\t\tbridge_features_duration_callback, feature_limits, __ao2_cleanup, remove_flags)) {\n\t\tast_log(LOG_ERROR, \"Failed to schedule the duration limiter to the bridge channel.\\n\");\n\t\tao2_ref(feature_limits, -1);\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(feature_limits->connect_sound)) {\n\t\tao2_ref(feature_limits, +1);\n\t\tif (ast_bridge_interval_hook(features, AST_BRIDGE_HOOK_TIMER_OPTION_MEDIA, 1,\n\t\t\tbridge_features_connect_callback, feature_limits, __ao2_cleanup, remove_flags)) {\n\t\t\tast_log(LOG_WARNING, \"Failed to schedule connect sound to the bridge channel.\\n\");\n\t\t\tao2_ref(feature_limits, -1);\n\t\t}\n\t}\n\tif (feature_limits->warning && feature_limits->warning < feature_limits->duration) {\n\t\tao2_ref(feature_limits, +1);\n\t\tif (ast_bridge_interval_hook(features, AST_BRIDGE_HOOK_TIMER_OPTION_MEDIA,\n\t\t\tfeature_limits->duration - feature_limits->warning,\n\t\t\tbridge_features_warning_callback, feature_limits, __ao2_cleanup, remove_flags)) {\n\t\t\tast_log(LOG_WARNING, \"Failed to schedule warning sound playback to the bridge channel.\\n\");\n\t\t\tao2_ref(feature_limits, -1);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 233}
{"project": "Asterisk", "target": 0, "func": "static int auth_credentials(void *userdata, const char *realm, int attempts, char *username, char *secret)\n{\n\tstruct exchangecal_pvt *pvt = userdata;\n\tif (attempts > 1) {\n\t\tast_log(LOG_WARNING, \"Invalid username or password for Exchange calendar '%s'\\n\", pvt->owner->name);\n\t\treturn -1;\n\t}\n\tne_strnzcpy(username, pvt->user, NE_ABUFSIZ);\n\tne_strnzcpy(secret, pvt->secret, NE_ABUFSIZ);\n\treturn 0;\n}\n", "bug_type": null, "idx": 234}
{"project": "Asterisk", "target": 0, "func": "static void request_cc(struct cc_core_instance *core_instance)\n{\n\tstruct ast_cc_monitor *monitor_iter;\n\tAST_LIST_LOCK(core_instance->monitors);\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(core_instance->monitors, monitor_iter, next) {\n\t\tif (monitor_iter->interface->monitor_class == AST_CC_DEVICE_MONITOR) {\n\t\t\tif (monitor_iter->callbacks->request_cc(monitor_iter, &monitor_iter->available_timer_id)) {\n\t\t\t\tAST_LIST_REMOVE_CURRENT(next);\n\t\t\t\tcc_extension_monitor_change_is_valid(core_instance, monitor_iter->parent_id,\n\t\t\t\t\t\tmonitor_iter->interface->device_name, 1);\n\t\t\t\tcc_unref(monitor_iter, \"request_cc failed. Unref list's reference to monitor\");\n\t\t\t} else {\n\t\t\t\tcc_publish_requested(core_instance->core_id, core_instance->agent->device_name, monitor_iter->interface->device_name);\n\t\t\t}\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\tif (!has_device_monitors(core_instance)) {\n\t\tast_cc_failed(core_instance->core_id, \"All device monitors failed to request CC\");\n\t}\n\tAST_LIST_UNLOCK(core_instance->monitors);\n}\n", "bug_type": null, "idx": 235}
{"project": "Asterisk", "target": 0, "func": "static void destroy_routes(void)\n{\n\tstasis_message_router_unsubscribe_and_join(cel_state_router);\n\tcel_state_router = NULL;\n}\n", "bug_type": null, "idx": 236}
{"project": "Asterisk", "target": 0, "func": "static void *process_clearcache(void *ignore)\n{\n\tstruct ast_db_entry *db_entry, *db_tree;\n\tint striplen = sizeof(\"/dundi/cache\");\n\ttime_t now;\n\twhile (!dundi_shutdown) {\n\t\tpthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);\n\t\ttime(&now);\n\t\tdb_entry = db_tree = ast_db_gettree(\"dundi/cache\", NULL);\n\t\tfor (; db_entry; db_entry = db_entry->next) {\n\t\t\ttime_t expiry;\n\t\t\tif (!ast_get_time_t(db_entry->data, &expiry, 0, NULL)) {\n\t\t\t\tif (expiry < now) {\n\t\t\t\t\tast_debug(1, \"clearing expired DUNDI cache entry: %s\\n\", db_entry->key);\n\t\t\t\t\tast_db_del(\"dundi/cache\", db_entry->key + striplen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tast_db_freetree(db_tree);\n\t\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\t\tpthread_testcancel();\n\t\tsleep(60);\n\t\tpthread_testcancel();\n\t}\n\tclearcachethreadid = AST_PTHREADT_NULL;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 237}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225EndpointIdentifier (OOCTXT* pctxt, H225EndpointIdentifier* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeBMPString (pctxt, pvalue, 0);\n   if (stat != ASN_OK) return stat;\n   invokeCharStr16BitValue (pctxt, pvalue->nchars, pvalue->data);\n   return (stat);\n}\n", "bug_type": null, "idx": 238}
{"project": "Asterisk", "target": 0, "func": "static int smdi_md_q_cmp_fn(void *obj, void *arg, int flags)\n{\n\tconst struct ast_smdi_md_message *msg = obj;\n\tconst struct ast_smdi_md_message *search_msg = arg;\n\tconst char *search_key = arg;\n\tint cmp = 0;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_OBJECT:\n\t\tif (!ast_strlen_zero(search_msg->mesg_desk_num)) {\n\t\t\tcmp = strcmp(msg->mesg_desk_num, search_msg->mesg_desk_num);\n\t\t}\n\t\tif (!ast_strlen_zero(search_msg->mesg_desk_term)) {\n\t\t\tcmp |= strcmp(msg->mesg_desk_term, search_msg->mesg_desk_term);\n\t\t}\n\t\tbreak;\n\tcase OBJ_SEARCH_KEY:\n\t\tcmp = strcmp(msg->name, search_key);\n\t\tbreak;\n\t}\n\tif (cmp) {\n\t\treturn 0;\n\t}\n\treturn CMP_MATCH;\n}\n", "bug_type": null, "idx": 239}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_asterisk_add_log(struct ast_variable *headers,\n\tstruct ast_ari_asterisk_add_log_args *args,\n\tstruct ast_ari_response *response)\n{\n\tint res;\n\tast_assert(response != NULL);\n\tres = ast_logger_create_channel(args->log_channel_name, args->configuration);\n\tif (res == AST_LOGGER_DECLINE) {\n\t\tast_ari_response_error(response, 400, \"Bad Request\",\n\t\t\t\"Configuration levels are required\");\n\t\treturn;\n\t} else if (res == AST_LOGGER_FAILURE) {\n\t\tast_ari_response_error(response, 409, \"Conflict\",\n\t\t\t\"Log channel already exists\");\n\t\treturn;\n\t} else if (res == AST_LOGGER_ALLOC_ERROR) {\n\t\tast_ari_response_error(response, 500, \"Internal Server Error\",\n\t\t\t\"Allocation failed\");\n\t\treturn;\n\t}\n\tast_ari_response_no_content(response);\n}\n", "bug_type": null, "idx": 240}
{"project": "Asterisk", "target": 0, "func": "static int show_version(void)\n{\n\tprintf(\"Asterisk %s\\n\", ast_get_version());\n\treturn 0;\n}\n", "bug_type": null, "idx": 241}
{"project": "Asterisk", "target": 0, "func": "static void unlink_dirty_databases(void)\n{\n\tao2_callback(databases, OBJ_MULTIPLE | OBJ_NODATA | OBJ_UNLINK, is_dirty_cb, NULL);\n}\n", "bug_type": null, "idx": 242}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct control_dial_args *control_dial_args_alloc(const char *dialstring,\n\tunsigned int timeout)\n{\n\tstruct control_dial_args *args;\n\targs = ast_malloc(sizeof(*args) + strlen(dialstring) + 1);\n\tif (!args) {\n\t\treturn NULL;\n\t}\n\targs->timeout = timeout;\n\t\n\tstrcpy(args->dialstring, dialstring);\n\treturn args;\n}\n", "bug_type": null, "idx": 243}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_timingfunc_set(struct ast_channel *chan, ast_timing_func_t value)\n{\n\tchan->timingfunc = value;\n}\n", "bug_type": null, "idx": 244}
{"project": "Asterisk", "target": 0, "func": "*/\nint AST_OPTIONAL_API_NAME(ast_encrypt_bin)(unsigned char *dst, const unsigned char *src, int srclen, struct ast_key *key)\n{\n\tint res, bytes, pos = 0;\n\tif (key->ktype != AST_KEY_PUBLIC) {\n\t\tast_log(LOG_WARNING, \"Cannot encrypt with a private key\\n\");\n\t\treturn -1;\n\t}\n\twhile (srclen) {\n\t\tbytes = srclen;\n\t\tif (bytes > 128 - 41) {\n\t\t\tbytes = 128 - 41;\n\t\t}\n\t\t\n\t\tif ((res = RSA_public_encrypt(bytes, src, dst, key->rsa, RSA_PKCS1_OAEP_PADDING)) != 128) {\n\t\t\tast_log(LOG_NOTICE, \"How odd, encrypted size is %d\\n\", res);\n\t\t\treturn -1;\n\t\t}\n\t\tsrc += bytes;\n\t\tsrclen -= bytes;\n\t\tpos += res;\n\t\tdst += res;\n\t}\n\treturn pos;\n}\n", "bug_type": null, "idx": 245}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_internal_copy_linkedid(struct ast_channel *dest, struct ast_channel *source)\n{\n\tif (dest->linkedid.creation_time == source->linkedid.creation_time\n\t\t&& dest->linkedid.creation_unique == source->linkedid.creation_unique\n\t\t&& !strcmp(dest->linkedid.unique_id, source->linkedid.unique_id)) {\n\t\treturn;\n\t}\n\tdest->linkedid = source->linkedid;\n\tast_channel_publish_snapshot(dest);\n}\n", "bug_type": null, "idx": 246}
{"project": "Asterisk", "target": 0, "func": "int ast_hashtab_resize_java(struct ast_hashtab *tab)\n{\n\tdouble loadfactor = (double) tab->hash_tab_elements / (double) tab->hash_tab_size;\n\treturn (loadfactor > 0.75);\n}\n", "bug_type": null, "idx": 247}
{"project": "Asterisk", "target": 0, "func": "static AO2_GLOBAL_OBJ_STATIC(confs);\nstatic void conf_server(const struct conf *cfg, struct ast_sockaddr *addr)\n{\n\t*addr = cfg->global->statsd_server;\n\tif (ast_sockaddr_port(addr) == 0) {\n\t\tast_sockaddr_set_port(addr, DEFAULT_STATSD_PORT);\n\t}\n}\n", "bug_type": null, "idx": 248}
{"project": "Asterisk", "target": 0, "func": "static struct info_dtmf_data *info_dtmf_data_alloc(struct ast_sip_session *session, char digit, unsigned int duration)\n{\n\tstruct info_dtmf_data *dtmf_data = ao2_alloc(sizeof(*dtmf_data), info_dtmf_data_destroy);\n\tif (!dtmf_data) {\n\t\treturn NULL;\n\t}\n\tao2_ref(session, +1);\n\tdtmf_data->session = session;\n\tdtmf_data->digit = digit;\n\tdtmf_data->duration = duration;\n\treturn dtmf_data;\n}\n", "bug_type": null, "idx": 249}
{"project": "Asterisk", "target": 0, "func": "OOBOOL ooChannelsIsConnectionOK(OOH323CallData *call, OOSOCKET sock)\n{\n   struct timeval to = { .tv_usec = 500 };\n   struct pollfd pfds = { .fd = sock, .events = POLLIN };\n   int ret = 0;\n   ret = ast_poll2(&pfds, 1, &to);\n   if(ret == -1)\n   {\n      OOTRACEERR3(\"Error in select ...broken pipe check(%s, %s)\\n\",\n                   call->callType, call->callToken );\n      return FALSE;\n   }\n   if (pfds.events & POLLIN) {\n      char buf[2];\n      if(ooSocketRecvPeek(sock, (ASN1OCTET*) buf, 2) == 0)\n      {\n         OOTRACEWARN3(\"Broken pipe detected. (%s, %s)\", call->callType, \n                       call->callToken);\n         if(call->callState < OO_CALL_CLEAR)\n            call->callEndReason = OO_REASON_TRANSPORTFAILURE;\n         call->callState = OO_CALL_CLEARED;\n         return FALSE;\n      }\n   }\n   return TRUE;\n}  \n", "bug_type": null, "idx": 250}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_generatordata_set(struct ast_channel *chan, void *value)\n{\n\tchan->generatordata = value;\n}\n", "bug_type": null, "idx": 251}
{"project": "Asterisk", "target": 0, "func": "static inline int __ast_pthread_mutex_init(const char *filename, int lineno, const char *func,\n\t\t\t\t\t   const char *mutex_name, ast_mutex_t *t)\n{\n\tstatic pthread_mutexattr_t  attr;\n\tpthread_mutexattr_init(&attr);\n\tpthread_mutexattr_settype(&attr, AST_MUTEX_KIND);\n\treturn __ast_pthread_mutex_init_attr(filename, lineno, func, mutex_name, t, &attr);\n}\n", "bug_type": null, "idx": 252}
{"project": "Asterisk", "target": 0, "func": "#if defined(HAVE_PRI)\nstatic char *handle_pri_show_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint x;\n\tint span;\n\tint count=0;\n\tint debug;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"pri show debug\";\n\t\te->usage =\n\t\t\t\"Usage: pri show debug\\n\"\n\t\t\t\"\tShow the debug state of pri spans\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tfor (span = 0; span < NUM_SPANS; span++) {\n\t\tif (pris[span].pri.pri) {\n\t\t\tfor (x = 0; x < SIG_PRI_NUM_DCHANS; x++) {\n\t\t\t\tif (pris[span].pri.dchans[x]) {\n\t\t\t\t\tdebug = pri_get_debug(pris[span].pri.dchans[x]);\n\t\t\t\t\tast_cli(a->fd, \"Span %d: Debug: %s\\tIntense: %s\\n\", span+1, (debug&PRI_DEBUG_Q931_STATE)? \"Yes\" : \"No\" ,(debug&PRI_DEBUG_Q921_RAW)? \"Yes\" : \"No\" );\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tast_mutex_lock(&pridebugfdlock);\n\tif (pridebugfd >= 0)\n\t\tast_cli(a->fd, \"Logging PRI debug to file %s\\n\", pridebugfilename);\n\tast_mutex_unlock(&pridebugfdlock);\n\tif (!count)\n\t\tast_cli(a->fd, \"No PRI running\\n\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 253}
{"project": "Asterisk", "target": 0, "func": "const char *app_name(struct ast_app *app)\n{\n\treturn app->name;\n}\n", "bug_type": null, "idx": 254}
{"project": "Asterisk", "target": 0, "func": "static void mwi_ds_destroy(void *data)\n{\n\tstruct mwi_subscription *sub = data;\n\tao2_ref(sub, -1);\n}\n", "bug_type": null, "idx": 255}
{"project": "Asterisk", "target": 0, "func": "static void analog_set_cadence(struct analog_pvt *p, struct ast_channel *chan)\n{\n\tif (analog_callbacks.set_cadence) {\n\t\tanalog_callbacks.set_cadence(p->chan_pvt, &p->cidrings, chan);\n\t}\n}\n", "bug_type": null, "idx": 256}
{"project": "Asterisk", "target": 0, "func": "static void rtp_ice_wrap_turn_request(struct ast_rtp_instance *instance,\n\tenum ast_rtp_ice_component_type component, enum ast_transport transport,\n\tconst char *server, unsigned int port, const char *username, const char *password)\n{\n\tao2_lock(instance);\n\tinstance->engine->ice->turn_request(instance, component, transport, server, port,\n\t\tusername, password);\n\tao2_unlock(instance);\n}\n", "bug_type": null, "idx": 257}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void my_do_crash(void)\n{\n\t\n\tusleep(1);\n\tast_do_crash();\n}\n", "bug_type": null, "idx": 258}
{"project": "Asterisk", "target": 0, "func": "\nstatic int set_test_formats(struct ast_channel *chan)\n{\n\tstruct ast_format_cap *caps;\n\tcaps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\tif (!caps) {\n\t\treturn -1;\n\t}\n\tast_format_cap_append(caps, ast_format_ulaw, 0);\n\tast_channel_nativeformats_set(chan, caps);\n\tast_channel_set_writeformat(chan, ast_format_ulaw);\n\tast_channel_set_rawwriteformat(chan, ast_format_ulaw);\n\tast_channel_set_readformat(chan, ast_format_ulaw);\n\tast_channel_set_rawreadformat(chan, ast_format_ulaw);\n\tao2_ref(caps, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 259}
{"project": "Asterisk", "target": 0, "func": "\nstatic void check_dow(pval *DOW)\n{\n\tchar *dow;\n\tchar *c;\n\t\n\tint s, e;\n\tdow = ast_strdupa(DOW->u1.str);\n\t\n\tif (ast_strlen_zero(dow) || !strcmp(dow, \"*\"))\n\t\treturn;\n\t\n\tc = strchr(dow, '-');\n\tif (c) {\n\t\t*c = '\\0';\n\t\tc++;\n\t} else\n\t\tc = NULL;\n\t\n\ts = 0;\n\twhile ((s < 7) && strcasecmp(dow, days[s])) s++;\n\tif (s >= 7) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The day (%s) must be one of 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', or 'sat'!\\n\",\n\t\t\t\tDOW->filename, DOW->startline, DOW->endline, dow);\n\t\twarns++;\n\t}\n\tif (c) {\n\t\te = 0;\n\t\twhile ((e < 7) && strcasecmp(c, days[e])) e++;\n\t\tif (e >= 7) {\n\t\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The end day (%s) must be one of 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', or 'sat'!\\n\",\n\t\t\t\t\tDOW->filename, DOW->startline, DOW->endline, c);\n\t\t\twarns++;\n\t\t}\n\t} else\n\t\te = s;\n}\n", "bug_type": null, "idx": 260}
{"project": "Asterisk", "target": 0, "func": "static void nbs_destroy(struct nbs_pvt *p)\n{\n\tif (p->nbs)\n\t\tnbs_delstream(p->nbs);\n\tast_module_user_remove(p->u);\n\tast_free(p);\n}\n", "bug_type": null, "idx": 261}
{"project": "Asterisk", "target": 0, "func": "};\nint func_confbridge_helper(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tstruct ast_datastore *datastore;\n\tstruct func_confbridge_data *b_data;\n\tchar *parse;\n\tstruct ast_variable tmpvar = { 0, };\n\tstruct ast_variable template = {\n\t\t.name = \"template\",\n\t\t.file = \"CONFBRIDGE\"\n\t};\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(type);\n\t\tAST_APP_ARG(option);\n\t);\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\t\n\tif (ast_strlen_zero(data)) {\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (ast_strlen_zero(args.type) || ast_strlen_zero(args.option)) {\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\tdatastore = ast_channel_datastore_find(chan, &confbridge_datastore, NULL);\n\tif (!datastore) {\n\t\tdatastore = ast_datastore_alloc(&confbridge_datastore, NULL);\n\t\tif (!datastore) {\n\t\t\tast_channel_unlock(chan);\n\t\t\treturn 0;\n\t\t}\n\t\tb_data = ast_calloc(1, sizeof(*b_data));\n\t\tif (!b_data) {\n\t\t\tast_channel_unlock(chan);\n\t\t\tast_datastore_free(datastore);\n\t\t\treturn 0;\n\t\t}\n\t\tdatastore->data = b_data;\n\t\tb_data->b_profile.sounds = bridge_profile_sounds_alloc();\n\t\tif (!b_data->b_profile.sounds) {\n\t\t\tast_channel_unlock(chan);\n\t\t\tast_datastore_free(datastore);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(b_data->menu = menu_alloc(\"dialplan\"))) {\n\t\t\tast_channel_unlock(chan);\n\t\t\tast_datastore_free(datastore);\n\t\t\treturn 0;\n\t\t}\n\t\tast_channel_datastore_add(chan, datastore);\n\t} else {\n\t\tb_data = datastore->data;\n\t}\n\tast_channel_unlock(chan);\n\t\n\tif (!value) {\n\t\tvalue = \"\";\n\t}\n\ttmpvar.name = args.option;\n\ttmpvar.value = value;\n\ttmpvar.file = \"CONFBRIDGE\";\n\tif (!strcasecmp(args.type, \"bridge\")) {\n\t\tif (!strcasecmp(args.option, \"clear\")) {\n\t\t\tb_data->b_usable = 0;\n\t\t\tconf_bridge_profile_destroy(&b_data->b_profile);\n\t\t\tmemset(&b_data->b_profile, 0, sizeof(b_data->b_profile)) ;\n\t\t\tif (!(b_data->b_profile.sounds = bridge_profile_sounds_alloc())) {\n\t\t\t\t\n\t\t\t\tast_channel_lock(chan);\n\t\t\t\tast_channel_datastore_remove(chan, datastore);\n\t\t\t\tast_channel_unlock(chan);\n\t\t\t\tast_datastore_free(datastore);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (b_data && !b_data->b_usable && strcasecmp(args.option, \"template\")) {\n\t\t\ttemplate.value = DEFAULT_BRIDGE_PROFILE;\n\t\t\taco_process_var(&bridge_type, \"dialplan\", &template, &b_data->b_profile);\n\t\t}\n\t\tif (!aco_process_var(&bridge_type, \"dialplan\", &tmpvar, &b_data->b_profile)) {\n\t\t\tb_data->b_usable = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (!strcasecmp(args.type, \"user\")) {\n\t\tif (!strcasecmp(args.option, \"clear\")) {\n\t\t\tb_data->u_usable = 0;\n\t\t\tuser_profile_destructor(&b_data->u_profile);\n\t\t\tmemset(&b_data->u_profile, 0, sizeof(b_data->u_profile));\n\t\t\treturn 0;\n\t\t}\n\t\tif (b_data && !b_data->u_usable && strcasecmp(args.option, \"template\")) {\n\t\t\ttemplate.value = DEFAULT_USER_PROFILE;\n\t\t\taco_process_var(&user_type, \"dialplan\", &template, &b_data->u_profile);\n\t\t}\n\t\tif (!aco_process_var(&user_type, \"dialplan\", &tmpvar, &b_data->u_profile)) {\n\t\t\tb_data->u_usable = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (!strcasecmp(args.type, \"menu\")) {\n\t\tif (!strcasecmp(args.option, \"clear\")) {\n\t\t\tb_data->m_usable = 0;\n\t\t\tao2_cleanup(b_data->menu);\n\t\t\tif (!(b_data->menu = menu_alloc(\"dialplan\"))) {\n\t\t\t\t\n\t\t\t\tast_channel_lock(chan);\n\t\t\t\tast_channel_datastore_remove(chan, datastore);\n\t\t\t\tast_channel_unlock(chan);\n\t\t\t\tast_datastore_free(datastore);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (b_data && !b_data->m_usable && strcasecmp(args.option, \"template\")) {\n\t\t\ttemplate.value = DEFAULT_MENU_PROFILE;\n\t\t\taco_process_var(&menu_type, \"dialplan\", &template, &b_data->menu);\n\t\t}\n\t\tif (!aco_process_var(&menu_type, \"dialplan\", &tmpvar, b_data->menu)) {\n\t\t\tb_data->m_usable = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tast_log(LOG_WARNING, \"%s(%s,%s) cannot be set to '%s'. Invalid type, option, or value.\\n\",\n\t\tcmd, args.type, args.option, value);\n\treturn -1;\n}\n", "bug_type": null, "idx": 262}
{"project": "Asterisk", "target": 0, "func": "static int format_ami_endpoint_auth(const struct ast_sip_endpoint *endpoint,\n\t\t\t\t    struct ast_sip_ami *ami)\n{\n\tami->arg = (void *)endpoint;\n\tif (ast_sip_format_auths_ami(&endpoint->inbound_auths, ami)) {\n\t\treturn -1;\n\t}\n\treturn ast_sip_format_auths_ami(&endpoint->outbound_auths, ami);\n}\n", "bug_type": null, "idx": 263}
{"project": "Asterisk", "target": 0, "func": "static int ooh323_digit_begin(struct ast_channel *chan, char digit)\n{\n\tchar dtmf[2];\n\tstruct ooh323_pvt *p = (struct ooh323_pvt *) ast_channel_tech_pvt(chan);\n\tint res = 0;\n\tif (gH323Debug)\n\t\tast_verb(0, \"---   ooh323_digit_begin\\n\");\n\tif (!p) {\n\t\tast_log(LOG_ERROR, \"No private structure for call\\n\");\n\t\treturn -1;\n\t}\n\tast_mutex_lock(&p->lock);\n\tif (p->rtp && ((p->dtmfmode & H323_DTMF_RFC2833) || (p->dtmfmode & H323_DTMF_CISCO))) {\n\t\tast_rtp_instance_dtmf_begin(p->rtp, digit);\n\t} else if (((p->dtmfmode & H323_DTMF_Q931) ||\n\t\t\t\t\t\t (p->dtmfmode & H323_DTMF_H245ALPHANUMERIC) ||\n\t\t\t\t\t\t (p->dtmfmode & H323_DTMF_H245SIGNAL))) {\n\t\tdtmf[0] = digit;\n\t\tdtmf[1] = '\\0';\n\t\tooSendDTMFDigit(p->callToken, dtmf);\n\t} else if (p->dtmfmode & H323_DTMF_INBAND) {\n\t\tres = -1;  \n\t}\n\tast_mutex_unlock(&p->lock);\n\tif (gH323Debug) {\n\t\tast_verb(0, \"+++   ooh323_digit_begin, res = %d\\n\", res);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 264}
{"project": "Asterisk", "target": 0, "func": "};\nvoid stasis_app_channel_set_stasis_end_published(struct ast_channel *chan)\n{\n\tstruct ast_datastore *datastore;\n\tdatastore = ast_datastore_alloc(&set_end_published_info, NULL);\n\tif (datastore) {\n\t\tast_channel_lock(chan);\n\t\tast_channel_datastore_add(chan, datastore);\n\t\tast_channel_unlock(chan);\n\t}\n}\n", "bug_type": null, "idx": 265}
{"project": "Asterisk", "target": 0, "func": "static void cc_publish_recallcomplete(int core_id, const char *caller)\n{\n\tRAII_VAR(struct ast_json *, extras, NULL, ast_json_unref);\n\textras = ast_json_pack(\"{s: s}\",\n\t\t\"caller\", caller);\n\tcc_publish(ast_cc_recallcomplete_type(), core_id, extras);\n}\n", "bug_type": null, "idx": 266}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function channel_function = {\n\t.name = \"CHANNEL\",\n\t.read = func_channel_read,\n\t.write = func_channel_write,\n};\n}\nstatic struct ast_custom_function channel_function = {\n\t.name = \"CHANNEL\",\n\t.read = func_channel_read,\n\t.write = func_channel_write,\n};\nstatic int func_channels_read(struct ast_channel *chan, const char *function, char *data, char *buf, size_t maxlen)\n{\n\tstruct ast_channel *c = NULL;\n\tregex_t re;\n\tint res;\n\tsize_t buflen = 0;\n\tstruct ast_channel_iterator *iter;\n\tbuf[0] = '\\0';\n\tif (!ast_strlen_zero(data)) {\n\t\tif ((res = regcomp(&re, data, REG_EXTENDED | REG_ICASE | REG_NOSUB))) {\n\t\t\tregerror(res, &re, buf, maxlen);\n\t\t\tast_log(LOG_WARNING, \"Error compiling regular expression for %s(%s): %s\\n\", function, data, buf);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(iter = ast_channel_iterator_all_new())) {\n\t\tif (!ast_strlen_zero(data)) {\n\t\t\tregfree(&re);\n\t\t}\n\t\treturn -1;\n\t}\n\twhile ((c = ast_channel_iterator_next(iter))) {\n\t\tast_channel_lock(c);\n\t\tif (ast_strlen_zero(data) || regexec(&re, ast_channel_name(c), 0, NULL, 0) == 0) {\n\t\t\tsize_t namelen = strlen(ast_channel_name(c));\n\t\t\tif (buflen + namelen + (ast_strlen_zero(buf) ? 0 : 1) + 1 < maxlen) {\n\t\t\t\tif (!ast_strlen_zero(buf)) {\n\t\t\t\t\tstrcat(buf, \" \");\n\t\t\t\t\tbuflen++;\n\t\t\t\t}\n\t\t\t\tstrcat(buf, ast_channel_name(c));\n\t\t\t\tbuflen += namelen;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Number of channels exceeds the available buffer space.  Output will be truncated!\\n\");\n\t\t\t}\n\t\t}\n\t\tast_channel_unlock(c);\n\t\tc = ast_channel_unref(c);\n\t}\n\tast_channel_iterator_destroy(iter);\n\tif (!ast_strlen_zero(data)) {\n\t\tregfree(&re);\n\t}\n\treturn 0;\n}\nstatic struct ast_custom_function channels_function = {\n\t.name = \"CHANNELS\",\n\t.read = func_channels_read,\n};\nstatic int func_mchan_read(struct ast_channel *chan, const char *function,\n\t\t\t     char *data, struct ast_str **buf, ssize_t len)\n{\n\tstruct ast_channel *mchan;\n\tchar *template = ast_alloca(4 + strlen(data));\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", function);\n\t\treturn -1;\n\t}\n\tmchan = ast_channel_get_by_name(ast_channel_linkedid(chan));\n\tsprintf(template, \"${%s}\", data); \n\tast_str_substitute_variables(buf, len, mchan ? mchan : chan, template);\n\tif (mchan) {\n\t\tast_channel_unref(mchan);\n\t}\n\treturn 0;\n}\nstatic int func_mchan_write(struct ast_channel *chan, const char *function,\n\t\t\t      char *data, const char *value)\n{\n\tstruct ast_channel *mchan;\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", function);\n\t\treturn -1;\n\t}\n\tmchan = ast_channel_get_by_name(ast_channel_linkedid(chan));\n\tpbx_builtin_setvar_helper(mchan ? mchan : chan, data, value);\n\tif (mchan) {\n\t\tast_channel_unref(mchan);\n\t}\n\treturn 0;\n}\nstatic struct ast_custom_function mchan_function = {\n\t.name = \"MASTER_CHANNEL\",\n\t.read2 = func_mchan_read,\n\t.write = func_mchan_write,\n};\nstatic int unload_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_unregister(&channel_function);\n\tres |= ast_custom_function_unregister(&channels_function);\n\tres |= ast_custom_function_unregister(&mchan_function);\n\treturn res;\n}\nstatic int load_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_register(&channel_function);\n\tres |= ast_custom_function_register(&channels_function);\n\tres |= ast_custom_function_register(&mchan_function);\n\treturn res;\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"Channel information dialplan functions\");\n", "bug_type": null, "idx": 267}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int mwi_serializer_set_alert_levels(void)\n{\n\tint idx;\n\tlong tps_queue_high;\n\tlong tps_queue_low;\n\tif (!mwi_serializer_pool[0]) {\n\t\treturn -1;\n\t}\n\ttps_queue_high = ast_sip_get_mwi_tps_queue_high();\n\tif (tps_queue_high <= 0) {\n\t\tast_log(AST_LOG_WARNING, \"Invalid taskprocessor high water alert trigger level '%ld'\\n\",\n\t\t\ttps_queue_high);\n\t\ttps_queue_high = AST_TASKPROCESSOR_HIGH_WATER_LEVEL;\n\t}\n\ttps_queue_low = ast_sip_get_mwi_tps_queue_low();\n\tif (tps_queue_low < -1 || tps_queue_high < tps_queue_low) {\n\t\tast_log(AST_LOG_WARNING, \"Invalid taskprocessor low water clear alert level '%ld'\\n\",\n\t\t\ttps_queue_low);\n\t\ttps_queue_low = -1;\n\t}\n\tfor (idx = 0; idx < MWI_SERIALIZER_POOL_SIZE; ++idx) {\n\t\tif (ast_taskprocessor_alert_set_levels(mwi_serializer_pool[idx], tps_queue_low, tps_queue_high)) {\n\t\t\tast_log(AST_LOG_WARNING, \"Failed to set alert levels for MWI serializer pool #%d.\\n\",\n\t\t\t\tidx);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 268}
{"project": "Asterisk", "target": 0, "func": "static int user_reset_vol_cb(void *obj, void *unused, int flags)\n{\n\tstruct ast_conf_user *user = obj;\n\treset_volumes(user);\n\treturn 0;\n}\n", "bug_type": null, "idx": 269}
{"project": "Asterisk", "target": 0, "func": "static void parse_connect_acknowledge (struct isdn_msg msgs[], msg_t *msg, struct misdn_bchannel *bc, int nt)\n{\n#ifdef DEBUG\n\tprintf(\"Parsing CONNECT_ACKNOWLEDGE Msg\\n\");\n#endif\n}\n", "bug_type": null, "idx": 270}
{"project": "Asterisk", "target": 0, "func": "\nstatic int transport_tls_cipher_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_transport *transport = obj;\n\tchar *parse;\n\tchar *name;\n\tint res = 0;\n\tRAII_VAR(struct ast_sip_transport_state *, state, find_or_create_temporary_state(transport), ao2_cleanup);\n\tif (!state) {\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(S_OR(var->value, \"\"));\n\twhile ((name = ast_strip(strsep(&parse, \",\")))) {\n\t\tif (ast_strlen_zero(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ARRAY_LEN(state->ciphers) <= state->tls.ciphers_num) {\n\t\t\tast_log(LOG_ERROR, \"Too many ciphers specified\\n\");\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tres |= transport_cipher_add(state, name);\n\t}\n\treturn res ? -1 : 0;\n}\n", "bug_type": null, "idx": 271}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int t38udptl_ec_to_str(const void *obj, const intptr_t *args, char **buf)\n{\n\tconst struct ast_sip_endpoint *endpoint = obj;\n\tif (ARRAY_IN_BOUNDS(endpoint->media.t38.error_correction, ast_t38_ec_modes_map)) {\n\t\t*buf = ast_strdup(ast_t38_ec_modes_map[\n\t\t\t\t\t  endpoint->media.t38.error_correction]);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 272}
{"project": "Asterisk", "target": 0, "func": "static void my_set_needringing(void *pvt, int value)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tp->subs[SUB_REAL].needringing = value;\n}\n", "bug_type": null, "idx": 273}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245EncryptionUpdateRequest (OOCTXT* pctxt, H245EncryptionUpdateRequest* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.keyProtectionMethodPresent);\n   \n   if (pvalue->m.keyProtectionMethodPresent) {\n      stat = asn1PE_H245KeyProtectionMethod (pctxt, &pvalue->keyProtectionMethod);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 274}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void topic_pool_entry_dtor(void *obj)\n{\n\tstruct topic_pool_entry *entry = obj;\n\tentry->forward = stasis_forward_cancel(entry->forward);\n\tao2_cleanup(entry->topic);\n\tentry->topic = NULL;\n}\n", "bug_type": null, "idx": 275}
{"project": "Asterisk", "target": 0, "func": "static int ast_srtp_protect(struct ast_srtp *srtp, void **buf, int *len, int rtcp)\n{\n\tint res;\n\tunsigned char *localbuf;\n\tif ((*len + SRTP_MAX_TRAILER_LEN) > sizeof(srtp->buf)) {\n\t\treturn -1;\n\t}\n\tlocalbuf = rtcp ? srtp->rtcpbuf : srtp->buf;\n\tmemcpy(localbuf, *buf, *len);\n\tif ((res = rtcp ? srtp_protect_rtcp(srtp->session, localbuf, len) : srtp_protect(srtp->session, localbuf, len)) != err_status_ok && res != err_status_replay_fail) {\n\t\tast_log(LOG_WARNING, \"SRTP protect: %s\\n\", srtp_errstr(res));\n\t\treturn -1;\n\t}\n\t*buf = localbuf;\n\treturn *len;\n}\n", "bug_type": null, "idx": 276}
{"project": "Asterisk", "target": 0, "func": "\nstatic void session_destroy_fn(void *obj)\n{\n\tstruct ast_websocket *session = obj;\n\tif (session->stream) {\n\t\tast_websocket_close(session, 0);\n\t\tif (session->stream) {\n\t\t\tast_iostream_close(session->stream);\n\t\t\tsession->stream = NULL;\n\t\t\tast_verb(2, \"WebSocket connection %s '%s' closed\\n\", session->client ? \"to\" : \"from\",\n\t\t\t\tast_sockaddr_stringify(&session->address));\n\t\t}\n\t}\n\tao2_cleanup(session->client);\n\tast_free(session->payload);\n}\n", "bug_type": null, "idx": 277}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tilbc_f.format = ast_format_ilbc;\n\tif (ast_format_def_register(&ilbc_f))\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 278}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function queuemembercount_function = {\n\t.name = \"QUEUE_MEMBER\",\n\t.read = queue_function_mem_read,\n\t.write = queue_function_mem_write,\n};\n", "bug_type": null, "idx": 279}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245ConferenceRequest (OOCTXT* pctxt, H245ConferenceRequest* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 8);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 7);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            \n            break;\n         \n         case 2:\n            \n            break;\n         \n         case 3:\n            \n            break;\n         \n         case 4:\n            stat = asn1PE_H245TerminalLabel (pctxt, pvalue->u.dropTerminal);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 5:\n            stat = asn1PE_H245TerminalLabel (pctxt, pvalue->u.requestTerminalID);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 6:\n            \n            break;\n         \n         case 7:\n            \n            break;\n         \n         case 8:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 9);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 9:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 10:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 11:\n            stat = asn1PE_H245ConferenceRequest_requestTerminalCertificate (&lctxt, pvalue->u.requestTerminalCertificate);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 12:\n            stat = asn1PE_H245LogicalChannelNumber (&lctxt, pvalue->u.broadcastMyLogicalChannel);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 13:\n            stat = asn1PE_H245TerminalLabel (&lctxt, pvalue->u.makeTerminalBroadcaster);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 14:\n            stat = asn1PE_H245TerminalLabel (&lctxt, pvalue->u.sendThisSource);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 15:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 16:\n            stat = asn1PE_H245RemoteMCRequest (&lctxt, pvalue->u.remoteMCRequest);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 280}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245EncryptionSync (OOCTXT* pctxt, H245EncryptionSync* pvalue)\n{\n   static Asn1SizeCnst h235Key_lsize1 = { 0, 1, 65535, 0 };\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.escrowentryPresent = optbit;\n   \n   if (pvalue->m.nonStandardPresent) {\n      invokeStartElement (pctxt, \"nonStandard\", -1);\n      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandard\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"synchFlag\", -1);\n   stat = decodeConsUInt8 (pctxt, &pvalue->synchFlag, 0U, 255U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->synchFlag);\n   invokeEndElement (pctxt, \"synchFlag\", -1);\n   \n   invokeStartElement (pctxt, \"h235Key\", -1);\n   addSizeConstraint (pctxt, &h235Key_lsize1);\n   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->h235Key);\n   if (stat != ASN_OK) return stat;\n   invokeOctStrValue (pctxt, pvalue->h235Key.numocts, pvalue->h235Key.data);\n   invokeEndElement (pctxt, \"h235Key\", -1);\n   \n   if (pvalue->m.escrowentryPresent) {\n      invokeStartElement (pctxt, \"escrowentry\", -1);\n      stat = asn1PD_H245EncryptionSync_escrowentry (pctxt, &pvalue->escrowentry);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"escrowentry\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 281}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void fax_session_release(struct ast_fax_session *s, struct ast_fax_tech_token *token)\n{\n\tif (token) {\n\t\ts->tech->release_token(token);\n\t}\n\tif (s->state == AST_FAX_STATE_RESERVED) {\n\t\tast_atomic_fetchadd_int(&faxregistry.reserved_sessions, -1);\n\t\ts->state = AST_FAX_STATE_INACTIVE;\n\t}\n}\n", "bug_type": null, "idx": 282}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int bridge_channel_impart_add(struct ast_channel *chan, struct bridge_channel_impart_cond *cond)\n{\n\tstruct ast_datastore *datastore;\n\tstruct bridge_channel_impart_ds_head *ds_head;\n\tast_channel_lock(chan);\n\tdatastore = ast_channel_datastore_find(chan, &bridge_channel_impart_ds_info, NULL);\n\tif (!datastore) {\n\t\tdatastore = ast_datastore_alloc(&bridge_channel_impart_ds_info, NULL);\n\t\tif (!datastore) {\n\t\t\tast_channel_unlock(chan);\n\t\t\treturn -1;\n\t\t}\n\t\tds_head = ast_calloc(1, sizeof(*ds_head));\n\t\tif (!ds_head) {\n\t\t\tast_channel_unlock(chan);\n\t\t\tast_datastore_free(datastore);\n\t\t\treturn -1;\n\t\t}\n\t\tdatastore->data = ds_head;\n\t\tast_channel_datastore_add(chan, datastore);\n\t} else {\n\t\tds_head = datastore->data;\n\t\tast_assert(ds_head != NULL);\n\t}\n\tAST_LIST_INSERT_TAIL(ds_head, cond, node);\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 283}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int chan_msg_send_digit_end(struct ast_channel *chan, char digit,\n\t\tunsigned int duration)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 284}
{"project": "Asterisk", "target": 0, "func": "static int dundi_precache_internal(const char *context, const char *number, int ttl, dundi_eid *avoids[])\n{\n\tstruct dundi_request dr;\n\tstruct dundi_hint_metadata hmd;\n\tstruct dundi_result dr2[MAX_RESULTS];\n\tstruct timeval start;\n\tstruct dundi_mapping *maps = NULL, *cur;\n\tint nummaps = 0;\n\tint foundanswers;\n\tint foundcache, skipped, ttlms, ms;\n\tif (!context)\n\t\tcontext = \"e164\";\n\tast_debug(1, \"Precache internal (%s@%s)!\\n\", number, context);\n\tAST_LIST_LOCK(&peers);\n\tAST_LIST_TRAVERSE(&mappings, cur, list) {\n\t\tif (!strcasecmp(cur->dcontext, context))\n\t\t\tnummaps++;\n\t}\n\tif (nummaps) {\n\t\tmaps = ast_alloca(nummaps * sizeof(*maps));\n\t\tnummaps = 0;\n\t\tAST_LIST_TRAVERSE(&mappings, cur, list) {\n\t\t\tif (!strcasecmp(cur->dcontext, context))\n\t\t\t\tmaps[nummaps++] = *cur;\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(&peers);\n\tif (!nummaps) {\n\t\treturn -1;\n\t}\n\tttlms = DUNDI_FLUFF_TIME + ttl * DUNDI_TTL_TIME;\n\tmemset(&dr2, 0, sizeof(dr2));\n\tmemset(&dr, 0, sizeof(dr));\n\tmemset(&hmd, 0, sizeof(hmd));\n\tdr.dr = dr2;\n\tast_copy_string(dr.number, number, sizeof(dr.number));\n\tast_copy_string(dr.dcontext, context ? context : \"e164\", sizeof(dr.dcontext));\n\tdr.maxcount = MAX_RESULTS;\n\tdr.expiration = dundi_cache_time;\n\tdr.hmd = &hmd;\n\tdr.pfds[0] = dr.pfds[1] = -1;\n\tif (pipe(dr.pfds) < 0) {\n\t\tast_log(LOG_WARNING, \"pipe() failed: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\tbuild_transactions(&dr, ttl, 0, &foundcache, &skipped, 0, 1, 1, NULL, avoids, NULL);\n\toptimize_transactions(&dr, 0);\n\tfoundanswers = 0;\n\tprecache_transactions(&dr, maps, nummaps, &dr.expiration, &foundanswers);\n\tif (foundanswers) {\n\t\tif (dr.expiration > 0)\n\t\t\treschedule_precache(dr.number, dr.dcontext, dr.expiration);\n\t\telse\n\t\t\tast_log(LOG_NOTICE, \"Weird, expiration = %d, but need to precache for %s@%s?!\\n\", dr.expiration, dr.number, dr.dcontext);\n\t}\n\tstart = ast_tvnow();\n\twhile (!AST_LIST_EMPTY(&dr.trans) && (ast_tvdiff_ms(ast_tvnow(), start) < ttlms)) {\n\t\tif (dr.pfds[0] > -1) {\n\t\t\tms = 100;\n\t\t\tast_waitfor_n_fd(dr.pfds, 1, &ms, NULL);\n\t\t} else\n\t\t\tusleep(1);\n\t}\n\tcancel_request(&dr);\n\tif (dr.pfds[0] > -1) {\n\t\tclose(dr.pfds[0]);\n\t\tclose(dr.pfds[1]);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 285}
{"project": "Asterisk", "target": 0, "func": "*/\nint AST_OPTIONAL_API_NAME(ast_sign)(struct ast_key *key, char *msg, char *sig)\n{\n\tunsigned char dsig[128];\n\tint siglen = sizeof(dsig), res;\n\tif (!(res = ast_sign_bin(key, msg, strlen(msg), dsig))) {\n\t\t\n\t\tast_base64encode(sig, dsig, siglen, 256);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 286}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int xmldoc_parse_option(struct ast_xml_node *fixnode, const char *tabs, struct ast_str **buffer)\n{\n\tstruct ast_xml_node *node;\n\tint ret = 0;\n\tchar *optiontabs;\n\tif (ast_asprintf(&optiontabs, \"%s    \", tabs) < 0) {\n\t\treturn ret;\n\t}\n\tfor (node = ast_xml_node_get_children(fixnode); node; node = ast_xml_node_get_next(node)) {\n\t\tif (!strcasecmp(ast_xml_node_get_name(node), \"argument\")) {\n\t\t\t\n\t\t\tif (!ret && ast_xml_node_get_children(node)) {\n\t\t\t\t\n\t\t\t\tast_str_append(buffer, 0, \"\\n\");\n\t\t\t}\n\t\t\tif (xmldoc_parse_argument(node, 0, NULL, optiontabs, buffer)) {\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (xmldoc_parse_common_elements(node, (ret ? tabs :  \"\"), \"\\n\", buffer)) {\n\t\t\tret = 1;\n\t\t}\n\t\txmldoc_parse_variablelist(node, optiontabs, buffer);\n\t\txmldoc_parse_enumlist(node, optiontabs, buffer);\n\t}\n\tast_free(optiontabs);\n\treturn ret;\n}\n", "bug_type": null, "idx": 287}
{"project": "Asterisk", "target": 0, "func": " ***/\nstatic int ifmodule_read(struct ast_channel *chan, const char *cmd, char *data,\n\t\t    char *buf, size_t len)\n{\n\tchar *ret = \"0\";\n\t*buf = '\\0';\n\tif (data)\n\t\tif (ast_module_check(data))\n\t\t\tret = \"1\";\n\tast_copy_string(buf, ret, len);\n\treturn 0;\n}\n", "bug_type": null, "idx": 288}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void appcdr_callback(void *data, struct stasis_subscription *sub, struct stasis_message *message)\n{\n\tstruct app_cdr_message_payload *payload;\n\tif (stasis_message_type(message) != appcdr_message_type()) {\n\t\treturn;\n\t}\n\tpayload = stasis_message_data(message);\n\tif (!payload) {\n\t\treturn;\n\t}\n\tif (payload->disable) {\n\t\tif (ast_cdr_set_property(payload->channel_name, AST_CDR_FLAG_DISABLE_ALL)) {\n\t\t\tast_log(AST_LOG_WARNING, \"Failed to disable CDRs on channel %s\\n\",\n\t\t\t\tpayload->channel_name);\n\t\t}\n\t}\n\tif (payload->reenable) {\n\t\tif (ast_cdr_clear_property(payload->channel_name, AST_CDR_FLAG_DISABLE_ALL)) {\n\t\t\tast_log(AST_LOG_WARNING, \"Failed to enable CDRs on channel %s\\n\",\n\t\t\t\tpayload->channel_name);\n\t\t}\n\t}\n\tif (payload->reset) {\n\t\tif (ast_cdr_reset(payload->channel_name, payload->keep_variables)) {\n\t\t\tast_log(AST_LOG_WARNING, \"Failed to reset CDRs on channel %s\\n\",\n\t\t\t\tpayload->channel_name);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 289}
{"project": "Asterisk", "target": 0, "func": "static char *handle_memory_show_allocations(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tconst char *fn = NULL;\n\tstruct ast_region *reg;\n\tunsigned int idx;\n\tunsigned int whales_len;\n\tunsigned int minnows_len;\n\tunsigned int total_len = 0;\n\tunsigned int selected_len = 0;\n\tunsigned int cache_len = 0;\n\tunsigned int count = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"memory show allocations\";\n\t\te->usage =\n\t\t\t\"Usage: memory show allocations [<file>|anomalies]\\n\"\n\t\t\t\"       Dumps a list of segments of allocated memory.\\n\"\n\t\t\t\"       Defaults to listing all memory allocations.\\n\"\n\t\t\t\"       <file> - Restricts output to memory allocated by the file.\\n\"\n\t\t\t\"       anomalies - Only check for fence violations.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc == 4) {\n\t\tfn = a->argv[3];\n\t} else if (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\t\n\tif (fn && (!strcasecmp(fn, \"anomalies\") || !strcasecmp(fn, \"anomolies\"))) {\n\t\tregions_check_all_fences();\n\t\tast_cli(a->fd, \"Anomaly check complete.\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\tast_mutex_lock(&reglock);\n\tfor (idx = 0; idx < ARRAY_LEN(regions); ++idx) {\n\t\tfor (reg = regions[idx]; reg; reg = AST_LIST_NEXT(reg, node)) {\n\t\t\ttotal_len += reg->len;\n\t\t\tif (fn && strcasecmp(fn, reg->file)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregion_check_fences(reg);\n\t\t\tast_cli(a->fd, \"%10u bytes allocated%s by %20s() line %5u of %s\\n\",\n\t\t\t\t(unsigned int) reg->len, reg->cache ? \" (cache)\" : \"\",\n\t\t\t\treg->func, reg->lineno, reg->file);\n\t\t\tselected_len += reg->len;\n\t\t\tif (reg->cache) {\n\t\t\t\tcache_len += reg->len;\n\t\t\t}\n\t\t\t++count;\n\t\t}\n\t}\n\twhales_len = freed_regions_size(&whales);\n\tminnows_len = freed_regions_size(&minnows);\n\tast_mutex_unlock(&reglock);\n\tprint_memory_show_common_stats(a->fd,\n\t\twhales_len, minnows_len, total_len,\n\t\tselected_len, cache_len, count);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 290}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int static_realtime_cb(void *arg, int num_columns, char **values, char **columns)\n{\n\tstruct cfg_entry_args *args = arg;\n\tstruct ast_variable *var;\n\tif (!strcmp(values[COL_VAR_NAME], \"#include\")) {\n\t\tstruct ast_config *cfg;\n\t\tchar *val;\n\t\tval = values[COL_VAR_VAL];\n\t\tif (!(cfg = ast_config_internal_load(val, args->cfg, args->flags, \"\", args->who_asked))) {\n\t\t\tast_log(LOG_WARNING, \"Unable to include %s\\n\", val);\n\t\t\treturn SQLITE_ABORT;\n\t\t} else {\n\t\t\targs->cfg = cfg;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!args->cat_name || strcmp(args->cat_name, values[COL_CATEGORY])) {\n\t\targs->cat = ast_category_new_dynamic(values[COL_CATEGORY]);\n\t\tif (!args->cat) {\n\t\t\treturn SQLITE_ABORT;\n\t\t}\n\t\tast_free(args->cat_name);\n\t\tif (!(args->cat_name = ast_strdup(values[COL_CATEGORY]))) {\n\t\t\tast_category_destroy(args->cat);\n\t\t\treturn SQLITE_ABORT;\n\t\t}\n\t\tast_category_append(args->cfg, args->cat);\n\t}\n\tif (!(var = ast_variable_new(values[COL_VAR_NAME], values[COL_VAR_VAL], \"\"))) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate variable\\n\");\n\t\treturn SQLITE_ABORT;\n\t}\n\tast_variable_append(args->cat, var);\n\treturn 0;\n}\n", "bug_type": null, "idx": 291}
{"project": "Asterisk", "target": 0, "func": "int ast_unreal_fixup(struct ast_channel *oldchan, struct ast_channel *newchan)\n{\n\tstruct ast_unreal_pvt *p = ast_channel_tech_pvt(newchan);\n\tstruct ast_bridge *bridge_owner;\n\tstruct ast_bridge *bridge_chan;\n\tif (!p) {\n\t\treturn -1;\n\t}\n\tao2_lock(p);\n\tif ((p->owner != oldchan) && (p->chan != oldchan)) {\n\t\tast_log(LOG_WARNING, \"Old channel %p wasn't %p or %p\\n\", oldchan, p->owner, p->chan);\n\t\tao2_unlock(p);\n\t\treturn -1;\n\t}\n\tif (p->owner == oldchan) {\n\t\tp->owner = newchan;\n\t} else {\n\t\tp->chan = newchan;\n\t}\n\tif (ast_check_hangup(newchan) || !p->owner || !p->chan) {\n\t\tao2_unlock(p);\n\t\treturn 0;\n\t}\n\t\n\tbridge_owner = ast_channel_internal_bridge(p->owner);\n\tbridge_chan = ast_channel_internal_bridge(p->chan);\n\tif (bridge_owner && bridge_owner == bridge_chan) {\n\t\tast_log(LOG_WARNING, \"You can not bridge an unreal channel (%s) to itself!\\n\",\n\t\t\tast_channel_name(newchan));\n\t\tao2_unlock(p);\n\t\tast_queue_hangup(newchan);\n\t\treturn -1;\n\t}\n\tao2_unlock(p);\n\treturn 0;\n}\n", "bug_type": null, "idx": 292}
{"project": "Asterisk", "target": 0, "func": "static inline struct timeval msg_timestamp(void *msg, enum smdi_message_type type)\n{\n\tstruct ast_smdi_md_message *md_msg = msg;\n\tstruct ast_smdi_mwi_message *mwi_msg = msg;\n\tswitch (type) {\n\tcase SMDI_MWI:\n\t\treturn mwi_msg->timestamp;\n\tcase SMDI_MD:\n\t\treturn md_msg->timestamp;\n\t}\n\treturn ast_tv(0, 0);\n}\n", "bug_type": null, "idx": 293}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void answer_trunk_chan(struct ast_channel *chan)\n{\n\tast_answer(chan);\n\tast_indicate(chan, -1);\n}\n", "bug_type": null, "idx": 294}
{"project": "Asterisk", "target": 0, "func": "int ooHandleFastStart(OOH323CallData *call, H225Facility_UUIE *facility)\n{\n   H245OpenLogicalChannel* olc;\n   ASN1OCTET msgbuf[MAXMSGLEN];\n   ooLogicalChannel * pChannel = NULL;\n   H245H2250LogicalChannelParameters * h2250lcp = NULL;  \n   int i=0, ret=0;\n   \n   if(OO_TESTFLAG (call->flags, OO_M_FASTSTART))\n   {\n      if(facility->m.fastStartPresent)\n      {\n         \n         initializePrintHandler(&printHandler, \"FastStart Elements\");\n         \n         setEventHandler (call->pctxt, &printHandler);\n         for(i=0; i<(int)facility->fastStart.n; i++)\n         {\n            olc = NULL;\n            olc = (H245OpenLogicalChannel*)memAlloc(call->pctxt, \n                                              sizeof(H245OpenLogicalChannel));\n            if(!olc)\n            {\n               OOTRACEERR3(\"ERROR:Memory - ooHandleFastStart - olc\"\n                           \"(%s, %s)\\n\", call->callType, call->callToken);\n               \n               if(call->callState < OO_CALL_CLEAR)\n               {\n                  call->callEndReason = OO_REASON_LOCAL_CLEARED;\n                  call->callState = OO_CALL_CLEAR;\n               }\n               finishPrint();\n               removeEventHandler(call->pctxt);\n               return OO_FAILED;\n            }\n            memset(olc, 0, sizeof(H245OpenLogicalChannel));\n            memcpy(msgbuf, facility->fastStart.elem[i].data, \n                                    facility->fastStart.elem[i].numocts);\n            setPERBuffer(call->pctxt, msgbuf, \n                         facility->fastStart.elem[i].numocts, 1);\n            ret = asn1PD_H245OpenLogicalChannel(call->pctxt, olc);\n            if(ret != ASN_OK)\n            {\n               OOTRACEERR3(\"ERROR:Failed to decode fast start olc element \"\n                           \"(%s, %s)\\n\", call->callType, call->callToken);\n               \n               if(call->callState < OO_CALL_CLEAR)\n               {\n                  call->callEndReason = OO_REASON_INVALIDMESSAGE;\n                  call->callState = OO_CALL_CLEAR;\n               }\n               finishPrint();\n               removeEventHandler(call->pctxt);\n               return OO_FAILED;\n            }\n            dListAppend(call->pctxt, &call->remoteFastStartOLCs, olc);\n            pChannel = ooFindLogicalChannelByOLC(call, olc);\n            if(!pChannel)\n            {\n               OOTRACEERR4(\"ERROR: Logical Channel %d not found, fast start. \"\n                           \"(%s, %s)\\n\",\n                            olc->forwardLogicalChannelNumber, call->callType, \n                            call->callToken);\n               finishPrint();\n               removeEventHandler(call->pctxt);\n               return OO_FAILED;\n            }\n            if(pChannel->channelNo != olc->forwardLogicalChannelNumber)\n            {\n               OOTRACEINFO5(\"Remote endpoint changed forwardLogicalChannel\"\n                            \"Number from %d to %d (%s, %s)\\n\", \n                            pChannel->channelNo, \n                            olc->forwardLogicalChannelNumber, call->callType, \n                            call->callToken);\n               pChannel->channelNo = olc->forwardLogicalChannelNumber;\n            }\n            if(!strcmp(pChannel->dir, \"transmit\"))\n            {\n               if(olc->forwardLogicalChannelParameters.multiplexParameters.t !=\n                  T_H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters)\n               {\n                  OOTRACEERR4(\"ERROR:Unknown multiplex parameter type for \"\n                              \"channel %d (%s, %s)\\n\", \n                              olc->forwardLogicalChannelNumber, call->callType,\n                              call->callToken);\n                  continue;\n               }\n               \n               h2250lcp = olc->forwardLogicalChannelParameters.multiplexParameters.u.h2250LogicalChannelParameters;\n               if(!h2250lcp)\n               {\n                  OOTRACEERR3(\"ERROR:Invalid OLC received in fast start. No \"\n                              \"forward Logical Channel Parameters found. \"\n                              \"(%s, %s)\\n\", call->callType, call->callToken);\n                  finishPrint();\n                  removeEventHandler(call->pctxt);\n                  return OO_FAILED;\n               }\n               if(!h2250lcp->m.mediaChannelPresent)\n               {\n                  OOTRACEERR3(\"ERROR:Invalid OLC received in fast start. No \"\n                              \"reverse media channel information found.\"\n                              \"(%s, %s)\\n\", call->callType, call->callToken);\n                  return OO_FAILED;\n               }\n               ret = ooGetIpPortFromH245TransportAddress(call, \n                                   &h2250lcp->mediaChannel, pChannel->remoteIP,\n                                   &pChannel->remoteMediaPort);\n               if(ret != OO_OK)\n               {\n               \tif(call->callState < OO_CALL_CLEAR)\n               \t{\n                  call->callEndReason = OO_REASON_INVALIDMESSAGE;\n                  call->callState = OO_CALL_CLEAR;\n               \t}\n                  OOTRACEERR3(\"ERROR:Unsupported media channel address type \"\n                              \"(%s, %s)\\n\", call->callType, call->callToken);\n                  finishPrint();\n                  removeEventHandler(call->pctxt);\n                  return OO_FAILED;\n               }\n               if(!pChannel->chanCap->startTransmitChannel)\n               {\n                  OOTRACEERR3(\"ERROR:No callback registered to start transmit \"\n                              \"channel (%s, %s)\\n\",call->callType, \n                              call->callToken);\n                  return OO_FAILED;\n               }\n               pChannel->chanCap->startTransmitChannel(call, pChannel);\n            }\n            \n            ooOnLogicalChannelEstablished(call, pChannel);\n         }\n         finishPrint();\n         removeEventHandler(call->pctxt);\n         OO_SETFLAG(call->flags, OO_M_FASTSTARTANSWERED);\n      }\n   }\n   if(facility->m.h245AddressPresent)\n   {\n      if (OO_TESTFLAG (call->flags, OO_M_TUNNELING))\n      {\n         OO_CLRFLAG (call->flags, OO_M_TUNNELING);\n         OOTRACEINFO3(\"Tunneling is disabled for call as H245 address is \"\n                      \"provided in facility message (%s, %s)\\n\", \n                      call->callType, call->callToken);\n      }\n      ret = ooH323GetIpPortFromH225TransportAddress(call, \n                                  &facility->h245Address, call->remoteIP,\n                                  &call->remoteH245Port);\n      if(ret != OO_OK)\n      {\n         OOTRACEERR3(\"Error: Unknown H245 address type in received \"\n                     \"Facility message (%s, %s)\", call->callType, \n                     call->callToken);\n         \n         if(call->callState < OO_CALL_CLEAR)\n         {\n            call->callEndReason = OO_REASON_INVALIDMESSAGE;\n            call->callState = OO_CALL_CLEAR;\n         }\n         return OO_FAILED;\n      }\n      if(call->remoteH245Port != 0 && !call->pH245Channel) {\n      \n       if(ooCreateH245Connection(call)== OO_FAILED)\n       {\n         OOTRACEERR3(\"Error: H.245 channel creation failed (%s, %s)\\n\", \n                     call->callType, call->callToken);\n         if(call->callState < OO_CALL_CLEAR)\n         {\n            call->callEndReason = OO_REASON_TRANSPORTFAILURE;\n            call->callState = OO_CALL_CLEAR;\n         }\n         return OO_FAILED;\n       }\n      }\n   } else if (OO_TESTFLAG (call->flags, OO_M_TUNNELING)) {\n\tif (call->h225version >= 4) {\n\t\tret =ooSendTCSandMSD(call);\n\t}\n\tif (ret != OO_OK)\n\t\treturn ret;\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 295}
{"project": "Asterisk", "target": 0, "func": "int ast_is_shrinkable_phonenumber(const char *exten)\n{\n\treturn ast_is_valid_string(exten, \"0123456789*#+()-.\");\n}\n", "bug_type": null, "idx": 296}
{"project": "Asterisk", "target": 0, "func": "static int iftime(struct ast_channel *chan, const char *cmd, char *data, char *buf,\n\t\t  size_t len)\n{\n\tstruct ast_timing timing;\n\tchar *expr;\n\tchar *iftrue;\n\tchar *iffalse;\n\tdata = ast_strip_quoted(data, \"\\\"\", \"\\\"\");\n\texpr = strsep(&data, \"?\");\n\tiftrue = strsep(&data, \":\");\n\tiffalse = data;\n\tif (ast_strlen_zero(expr) || !(iftrue || iffalse)) {\n\t\tast_log(LOG_WARNING,\n\t\t\t\t\"Syntax IFTIME(<timespec>?[<true>][:<false>])\\n\");\n\t\treturn -1;\n\t}\n\tif (!ast_build_timing(&timing, expr)) {\n\t\tast_log(LOG_WARNING, \"Invalid Time Spec.\\n\");\n\t\tast_destroy_timing(&timing);\n\t\treturn -1;\n\t}\n\tif (iftrue)\n\t\tiftrue = ast_strip_quoted(iftrue, \"\\\"\", \"\\\"\");\n\tif (iffalse)\n\t\tiffalse = ast_strip_quoted(iffalse, \"\\\"\", \"\\\"\");\n\tast_copy_string(buf, ast_check_timing(&timing) ? S_OR(iftrue, \"\") : S_OR(iffalse, \"\"), len);\n\tast_destroy_timing(&timing);\n\treturn 0;\n}\n", "bug_type": null, "idx": 297}
{"project": "Asterisk", "target": 0, "func": "static int file_count_line(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\tenum file_format newline_format = FF_UNKNOWN;\n\tint64_t count;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(filename);\n\t\tAST_APP_ARG(format);\n\t);\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (args.argc > 1) {\n\t\tif (tolower(args.format[0]) == 'd') {\n\t\t\tnewline_format = FF_DOS;\n\t\t} else if (tolower(args.format[0]) == 'm') {\n\t\t\tnewline_format = FF_MAC;\n\t\t} else if (tolower(args.format[0]) == 'u') {\n\t\t\tnewline_format = FF_UNIX;\n\t\t}\n\t}\n\tcount = count_lines(args.filename, newline_format);\n\tast_str_set(buf, len, \"%\" PRId64, count);\n\treturn 0;\n}\n", "bug_type": null, "idx": 298}
{"project": "Asterisk", "target": 0, "func": "struct ast_format *ast_get_format_for_file_ext(const char *file_ext)\n{\n\tstruct ast_format_def *f;\n\tSCOPED_RDLOCK(lock, &formats.lock);\n\tAST_RWLIST_TRAVERSE(&formats, f, list) {\n\t\tif (exts_compare(f->exts, file_ext)) {\n\t\t\treturn f->format;\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 299}
{"project": "Asterisk", "target": 0, "func": "static int kp_match_area(const struct keypad_entry *e, int x, int y);\nstatic void set_drag(struct drag_info *drag, int x, int y, enum drag_window win)\n{\n\tdrag->x_start = x;\n\tdrag->y_start = y;\n\tdrag->drag_window = win;\n}\n", "bug_type": null, "idx": 300}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void) \n{\n\treturn ast_unregister_application(app);\n}\n", "bug_type": null, "idx": 301}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpAddAMRNBCapability(int cap, int txframes, int rxframes, \n                              OOBOOL silenceSuppression, int dir,\n                              cb_StartReceiveChannel startReceiveChannel,\n                              cb_StartTransmitChannel startTransmitChannel,\n                              cb_StopReceiveChannel stopReceiveChannel,\n                              cb_StopTransmitChannel stopTransmitChannel)\n{\n   return ooCapabilityAddSimpleCapability(NULL, cap, txframes, rxframes, \n                             silenceSuppression, dir, startReceiveChannel, \n                             startTransmitChannel, stopReceiveChannel, \n                             stopTransmitChannel, FALSE);\n}\n", "bug_type": null, "idx": 302}
{"project": "Asterisk", "target": 0, "func": "\nstatic enum ast_format_cmp_res test_core_format_cmp(const struct ast_format *format1, const struct ast_format *format2)\n{\n\tstruct test_core_format_pvt *pvt1 = ast_format_get_attribute_data(format1);\n\tstruct test_core_format_pvt *pvt2 = ast_format_get_attribute_data(format2);\n\t++test_callbacks_called.format_cmp;\n\tif (pvt1 == pvt2) {\n\t\treturn AST_FORMAT_CMP_EQUAL;\n\t}\n\tif ((!pvt1 && pvt2 && (pvt2->field_one != 0 || pvt2->field_two != 0))\n\t\t|| (pvt1 && !pvt2 && (pvt1->field_one != 0 || pvt1->field_two != 0))) {\n\t\treturn AST_FORMAT_CMP_NOT_EQUAL;\n\t}\n\tif (pvt1 && pvt2) {\n\t\tif (!memcmp(pvt1, pvt2, sizeof(*pvt1))) {\n\t\t\treturn AST_FORMAT_CMP_EQUAL;\n\t\t} else {\n\t\t\treturn AST_FORMAT_CMP_NOT_EQUAL;\n\t\t}\n\t}\n\treturn AST_FORMAT_CMP_EQUAL;\n}\n", "bug_type": null, "idx": 303}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void rb_insert_fixup(struct ao2_container_rbtree *self, struct rbtree_node *node)\n{\n\tstruct rbtree_node *g_parent;\t\n\twhile (node->parent && node->parent->is_red) {\n\t\tg_parent = node->parent->parent;\n\t\t\n\t\tast_assert(g_parent != NULL);\n\t\tif (node->parent == g_parent->left) {\n\t\t\t\n\t\t\tif (g_parent->right && g_parent->right->is_red) {\n\t\t\t\t\n\t\t\t\tAO2_DEVMODE_STAT(++self->stats.fixup_insert_left[0]);\n\t\t\t\tg_parent->right->is_red = 0;\n\t\t\t\tg_parent->left->is_red = 0;\n\t\t\t\tg_parent->is_red = 1;\n\t\t\t\tnode = g_parent;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (node->parent->right == node) {\n\t\t\t\t\t\n\t\t\t\t\tAO2_DEVMODE_STAT(++self->stats.fixup_insert_left[1]);\n\t\t\t\t\tnode = node->parent;\n\t\t\t\t\trb_rotate_left(self, node);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAO2_DEVMODE_STAT(++self->stats.fixup_insert_left[2]);\n\t\t\t\tnode->parent->is_red = 0;\n\t\t\t\tg_parent->is_red = 1;\n\t\t\t\trb_rotate_right(self, g_parent);\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tif (g_parent->left && g_parent->left->is_red) {\n\t\t\t\t\n\t\t\t\tAO2_DEVMODE_STAT(++self->stats.fixup_insert_right[0]);\n\t\t\t\tg_parent->left->is_red = 0;\n\t\t\t\tg_parent->right->is_red = 0;\n\t\t\t\tg_parent->is_red = 1;\n\t\t\t\tnode = g_parent;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (node->parent->left == node) {\n\t\t\t\t\t\n\t\t\t\t\tAO2_DEVMODE_STAT(++self->stats.fixup_insert_right[1]);\n\t\t\t\t\tnode = node->parent;\n\t\t\t\t\trb_rotate_right(self, node);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAO2_DEVMODE_STAT(++self->stats.fixup_insert_right[2]);\n\t\t\t\tnode->parent->is_red = 0;\n\t\t\t\tg_parent->is_red = 1;\n\t\t\t\trb_rotate_left(self, g_parent);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tself->root->is_red = 0;\n}\n", "bug_type": null, "idx": 304}
{"project": "Asterisk", "target": 0, "func": "void localized_use_conf_dir(void);\nvoid localized_use_local_dir(void)\n{\n\tuse_local_dir = 1;\n}\n", "bug_type": null, "idx": 305}
{"project": "Asterisk", "target": 0, "func": "int stasis_app_stored_recording_delete(\n\tstruct stasis_app_stored_recording *recording)\n{\n\t\n\treturn unlink(recording->file_with_ext);\n}\n", "bug_type": null, "idx": 306}
{"project": "Asterisk", "target": 0, "func": "static int prune_task(const void *data)\n{\n\tunsigned int maxage;\n\tast_sip_get_unidentified_request_thresholds(&unidentified_count, &unidentified_period, &unidentified_prune_interval);\n\tmaxage = unidentified_period * 2;\n\tao2_callback(unidentified_requests, OBJ_MULTIPLE | OBJ_NODATA | OBJ_UNLINK, expire_requests, &maxage);\n\treturn unidentified_prune_interval * 1000;\n}\n", "bug_type": null, "idx": 307}
{"project": "Asterisk", "target": 0, "func": "\nstatic int multicast_rtp_new(struct ast_rtp_instance *instance, struct ast_sched_context *sched, struct ast_sockaddr *addr, void *data)\n{\n\tstruct multicast_rtp *multicast;\n\tstruct ast_multicast_rtp_options *mcast_options = data;\n\tif (!(multicast = ast_calloc(1, sizeof(*multicast)))) {\n\t\treturn -1;\n\t}\n\tif (set_type(multicast, mcast_options->type)) {\n\t\tast_free(multicast);\n\t\treturn -1;\n\t}\n\tif ((multicast->socket = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t\tast_free(multicast);\n\t\treturn -1;\n\t}\n\tif (ast_test_flag(&mcast_options->opts, OPT_LOOP)) {\n\t\tset_loop(multicast->socket, mcast_options->opt_args[OPT_ARG_LOOP]);\n\t}\n\tif (ast_test_flag(&mcast_options->opts, OPT_TTL)) {\n\t\tset_ttl(multicast->socket, mcast_options->opt_args[OPT_ARG_TTL]);\n\t}\n\tif (ast_test_flag(&mcast_options->opts, OPT_IF)) {\n\t\tset_if(multicast->socket, mcast_options->opt_args[OPT_ARG_IF]);\n\t}\n\tmulticast->ssrc = ast_random();\n\tast_rtp_instance_set_data(instance, multicast);\n\treturn 0;\n}\n", "bug_type": null, "idx": 308}
{"project": "Asterisk", "target": 0, "func": "\nint ooOnReceivedCloseLogicalChannel(OOH323CallData *call, \n                                    H245CloseLogicalChannel* clc)\n{\n   int ret=0;\n   H245Message *ph245msg = NULL;\n   OOCTXT *pctxt = NULL;\n   H245CloseLogicalChannelAck * clcAck;\n   H245ResponseMessage *response;\n   OOTRACEINFO4(\"Closing logical channel number %d (%s, %s)\\n\",\n      clc->forwardLogicalChannelNumber, call->callType, call->callToken);\n   ret = ooClearLogicalChannel(call, clc->forwardLogicalChannelNumber);\n   if (ret != OO_OK) {\n      OOTRACEERR4(\"ERROR:Failed to close logical channel %d (%s, %s)\\n\",\n         clc->forwardLogicalChannelNumber, call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   ret = ooCreateH245Message(call, &ph245msg, \n                              T_H245MultimediaSystemControlMessage_response);\n   if(ret != OO_OK)\n   {\n      OOTRACEERR3(\"ERROR:Failed to create H245 message for \"\n                  \"closeLogicalChannelAck (%s, %s)\\n\", call->callType, \n                  call->callToken);\n      return OO_FAILED;\n   }\n   \n   pctxt = call->msgctxt;\n   ph245msg->msgType = OOCloseLogicalChannelAck;\n   ph245msg->logicalChannelNo = clc->forwardLogicalChannelNumber;\n   response = ph245msg->h245Msg.u.response;\n   response->t = T_H245ResponseMessage_closeLogicalChannelAck;\n   response->u.closeLogicalChannelAck = (H245CloseLogicalChannelAck*)\n                         ASN1MALLOC(pctxt, sizeof(H245CloseLogicalChannelAck));\n   clcAck = response->u.closeLogicalChannelAck;\n   if(!clcAck)\n   {\n      OOTRACEERR3(\"ERROR:Failed to allocate memory for closeLogicalChannelAck \"\n                  \"(%s, %s)\\n\", call->callType, call->callToken);\n      return OO_OK;\n   }\n   memset(clcAck, 0, sizeof(H245CloseLogicalChannelAck));\n   clcAck->forwardLogicalChannelNumber = clc->forwardLogicalChannelNumber;\n   OOTRACEDBGA3(\"Built CloseLogicalChannelAck message (%s, %s)\\n\",\n                 call->callType, call->callToken);\n   ret = ooSendH245Msg(call, ph245msg);\n   if(ret != OO_OK)\n   {\n     OOTRACEERR3(\"Error:Failed to enqueue CloseLogicalChannelAck message to \"\n                 \"outbound queue.(%s, %s)\\n\", call->callType, call->callToken);\n   }\n   ooFreeH245Message(call, ph245msg);\n   return ret;\n}\n", "bug_type": null, "idx": 309}
{"project": "Asterisk", "target": 0, "func": "void AST_OPTIONAL_API_NAME(ast_aes_encrypt)(const unsigned char *in, unsigned char *out, const ast_aes_encrypt_key *ctx)\n{\n\treturn AES_encrypt(in, out, ctx);\n}\n", "bug_type": null, "idx": 310}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_sip_session_unregister_supplement(&empty_info_supplement);\n\treturn 0;\n}\n", "bug_type": null, "idx": 311}
{"project": "Asterisk", "target": 0, "func": "\nstatic int xmpp_io_recv(struct ast_xmpp_client *client, char *buffer, size_t buf_len, int timeout)\n{\n\tstruct pollfd pfd = { .events = POLLIN };\n\tint len, res;\n#ifdef HAVE_OPENSSL\n\tif (xmpp_is_secure(client)) {\n\t\tpfd.fd = SSL_get_fd(client->ssl_session);\n\t\tif (pfd.fd < 0) {\n\t\t\treturn -1;\n\t\t}\n\t} else\n#endif \n\t\tpfd.fd = iks_fd(client->parser);\n\tres = ast_poll(&pfd, 1, timeout > 0 ? timeout * 1000 : -1);\n\tif (res > 0) {\n#ifdef HAVE_OPENSSL\n\t\tif (xmpp_is_secure(client)) {\n\t\t\tlen = SSL_read(client->ssl_session, buffer, buf_len);\n\t\t} else\n#endif \n\t\t\tlen = recv(pfd.fd, buffer, buf_len, 0);\n\t\tif (len > 0) {\n\t\t\treturn len;\n\t\t} else if (len <= 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 312}
{"project": "Asterisk", "target": 0, "func": "\nstatic int generate_makedeps_file(void)\n{\n\tFILE *f;\n\tstruct category *cat;\n\tstruct member *mem;\n\tstruct reference *dep;\n\tstruct reference *use;\n\tstruct dep_file *dep_file;\n\tif (!(f = fopen(output_makedeps, \"w\"))) {\n\t\tfprintf(stderr, \"Unable to open dependencies file (%s) for writing!\\n\", output_makedeps);\n\t\treturn -1;\n\t}\n\t\n\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n\t\t\tif (mem->is_separator) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAST_LIST_TRAVERSE(&mem->uses, use, list) {\n\t\t\t\tif (use->member) {\n\t\t\t\t\tuse->met = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tAST_LIST_TRAVERSE(&deps_file, dep_file, list) {\n\t\t\t\t\tif ((use->met = !strcasecmp(use->name, dep_file->name))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n\t\t\tif (mem->is_separator) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunsigned char header_printed = 0;\n\t\t\tif (AST_LIST_EMPTY(&mem->deps) && AST_LIST_EMPTY(&mem->uses))\n\t\t\t\tcontinue;\n\t\t\tAST_LIST_TRAVERSE(&mem->deps, dep, list) {\n\t\t\t\tconst char *c;\n\t\t\t\tif (dep->member) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!header_printed) {\n\t\t\t\t\tfprintf(f, \"MENUSELECT_DEPENDS_%s=\", mem->name);\n\t\t\t\t\theader_printed = 1;\n\t\t\t\t}\n\t\t\t\tfor (c = dep->name; *c; c++)\n\t\t\t\t\tfputc(toupper(*c), f);\n\t\t\t\tfputc(' ', f);\n\t\t\t}\n\t\t\tAST_LIST_TRAVERSE(&mem->uses, use, list) {\n\t\t\t\tconst char *c;\n\t\t\t\tif (!use->met) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!header_printed) {\n\t\t\t\t\tfprintf(f, \"MENUSELECT_DEPENDS_%s=\", mem->name);\n\t\t\t\t\theader_printed = 1;\n\t\t\t\t}\n\t\t\t\tfor (c = use->name; *c; c++)\n\t\t\t\t\tfputc(toupper(*c), f);\n\t\t\t\tfputc(' ', f);\n\t\t\t}\n\t\t\tif (header_printed) {\n\t\t\t\tfprintf(f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}\n", "bug_type": null, "idx": 313}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\ttopic_forwarder = stasis_forward_cancel(topic_forwarder);\n\tast_manager_unregister(\"DeviceStateList\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 314}
{"project": "Asterisk", "target": 0, "func": "static int get_write_timeout(void)\n{\n\tint write_timeout = -1;\n\tstruct ao2_container *transport_states;\n\ttransport_states = ast_sip_get_transport_states();\n\tif (transport_states) {\n\t\tstruct ao2_iterator it_transport_states = ao2_iterator_init(transport_states, 0);\n\t\tstruct ast_sip_transport_state *transport_state;\n\t\tfor (; (transport_state = ao2_iterator_next(&it_transport_states)); ao2_cleanup(transport_state)) {\n\t\t\tstruct ast_sip_transport *transport;\n\t\t\tif (transport_state->type != AST_TRANSPORT_WS && transport_state->type != AST_TRANSPORT_WSS) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttransport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"transport\", transport_state->id);\n\t\t\tif (!transport) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tast_debug(5, \"Found %s transport with write timeout: %d\\n\",\n\t\t\t\ttransport->type == AST_TRANSPORT_WS ? \"WS\" : \"WSS\",\n\t\t\t\ttransport->write_timeout);\n\t\t\twrite_timeout = MAX(write_timeout, transport->write_timeout);\n\t\t}\n\t\tao2_iterator_destroy(&it_transport_states);\n\t\tao2_cleanup(transport_states);\n\t}\n\tif (write_timeout < 0) {\n\t\twrite_timeout = AST_DEFAULT_WEBSOCKET_WRITE_TIMEOUT;\n\t}\n\tast_debug(1, \"Write timeout for WS/WSS transports: %d\\n\", write_timeout);\n\treturn write_timeout;\n}\n", "bug_type": null, "idx": 315}
{"project": "Asterisk", "target": 0, "func": "ari_validator ast_ari_validate_playback_continuing_fn(void)\n{\n\treturn ast_ari_validate_playback_continuing;\n}\n", "bug_type": null, "idx": 316}
{"project": "Asterisk", "target": 0, "func": " */\nstruct sig_ss7_chan *sig_ss7_chan_new(void *pvt_data, struct sig_ss7_linkset *ss7)\n{\n\tstruct sig_ss7_chan *pvt;\n\tpvt = ast_calloc(1, sizeof(*pvt));\n\tif (!pvt) {\n\t\treturn pvt;\n\t}\n\tpvt->chan_pvt = pvt_data;\n\tpvt->ss7 = ss7;\n\treturn pvt;\n}\n", "bug_type": null, "idx": 317}
{"project": "Asterisk", "target": 0, "func": "#define DATASTORE_BUCKETS 53\nstruct ast_datastore *__ast_datastore_alloc(const struct ast_datastore_info *info, const char *uid,\n\t\t\t\t\t    const char *file, int line, const char *function)\n{\n\tstruct ast_datastore *datastore = NULL;\n\t\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\tif (!(datastore = __ast_calloc(1, sizeof(*datastore), file, line, function))) {\n\t\treturn NULL;\n\t}\n\tdatastore->info = info;\n\tif (!ast_strlen_zero(uid) && !(datastore->uid = ast_strdup(uid))) {\n\t\tast_free(datastore);\n\t\tdatastore = NULL;\n\t}\n\treturn datastore;\n}\n", "bug_type": null, "idx": 318}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int pbx_builtin_progress(struct ast_channel *chan, const char *data)\n{\n\tast_indicate(chan, AST_CONTROL_PROGRESS);\n\treturn 0;\n}\n", "bug_type": null, "idx": 319}
{"project": "Asterisk", "target": 0, "func": "const char *ast_msg_get_from(const struct ast_msg *msg)\n{\n\treturn msg->from;\n}\n", "bug_type": null, "idx": 320}
{"project": "Asterisk", "target": 0, "func": "static int label_inside_case(pval *label)\n{\n\tpval *p = label;\n\twhile( p && p->type != PV_MACRO && p->type != PV_CONTEXT )  {\n\t\tif( p->type == PV_CASE || p->type == PV_DEFAULT || p->type == PV_PATTERN ) {\n\t\t\treturn 1;\n\t\t}\n\t\tp = p->dad;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 321}
{"project": "Asterisk", "target": 0, "func": "int ooOpenChannel(OOH323CallData* call, ooH323EpCapability *epCap)\n{\n   int ret;\n   H245Message *ph245msg = NULL;\n   H245RequestMessage * request;\n   OOCTXT *pctxt = NULL;\n   H245OpenLogicalChannel_forwardLogicalChannelParameters *flcp = NULL;\n   H245AudioCapability *audioCap = NULL;\n   H245VideoCapability *videoCap = NULL;\n   H245DataApplicationCapability *t38Cap = NULL;\n   H245H2250LogicalChannelParameters *h2250lcp = NULL;\n   H245UnicastAddress *unicastAddrs = NULL;\n   H245UnicastAddress_iPAddress *iPAddress = NULL;\n   H245UnicastAddress_iP6Address *iP6Address = NULL;\n   unsigned session_id=0;\n   ooLogicalChannel *pLogicalChannel = NULL;\n   OOTRACEDBGC4(\"Doing Open Channel for %s. (%s, %s)\\n\", \n                 ooGetCapTypeText(epCap->cap), call->callType, \n                 call->callToken);\n   ret = ooCreateH245Message(call, &ph245msg, \n                      T_H245MultimediaSystemControlMessage_request);\n   if(ret != OO_OK)\n   {\n      OOTRACEERR4(\"Error: H245 message creation failed for - Open %s\"\n                  \"channel (%s, %s)\\n\", ooGetCapTypeText(epCap->cap), \n                  call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   ph245msg->msgType = OOOpenLogicalChannel;\n   ph245msg->logicalChannelNo =  call->logicalChanNoCur++;\n   if(call->logicalChanNoCur > call->logicalChanNoMax)\n      call->logicalChanNoCur = call->logicalChanNoBase; \n   request = ph245msg->h245Msg.u.request;\n   \n   pctxt = call->msgctxt;\n   memset(request, 0, sizeof(H245RequestMessage));\n   request->t = T_H245RequestMessage_openLogicalChannel;\n   request->u.openLogicalChannel = (H245OpenLogicalChannel*)\n                     memAlloc(pctxt, sizeof(H245OpenLogicalChannel));\n   if(!request->u.openLogicalChannel)\n   {\n      OOTRACEERR3(\"Error:Memory - ooOpenChannel - openLogicalChannel.\"\n                  \"(%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   memset(request->u.openLogicalChannel, 0, \n                                     sizeof(H245OpenLogicalChannel));\n   request->u.openLogicalChannel->forwardLogicalChannelNumber = \n                                                 ph245msg->logicalChannelNo;\n   session_id = ooCallGenerateSessionID(call, epCap->capType, \"transmit\");\n   pLogicalChannel = ooAddNewLogicalChannel(call, \n                   request->u.openLogicalChannel->forwardLogicalChannelNumber,\n                   session_id, \"transmit\", epCap);\n   if(!pLogicalChannel)\n   {\n      OOTRACEERR3(\"ERROR:Failed to add new logical channel entry (%s, %s)\\n\",\n                  call->callType, call->callToken);\n      ooFreeH245Message(call, ph245msg);\n      return OO_FAILED;\n   }\n   \n   flcp = &(request->u.openLogicalChannel->forwardLogicalChannelParameters);\n   flcp->m.portNumberPresent = 0;\n   flcp->m.forwardLogicalChannelDependencyPresent = 0;\n   flcp->m.replacementForPresent = 0;\n   \n   if(epCap->capType == OO_CAP_TYPE_AUDIO)\n   {\n      flcp->dataType.t = T_H245DataType_audioData;\n      \n      audioCap = ooCapabilityCreateAudioCapability(epCap,pctxt, OOTX);\n      if(!audioCap)\n      {\n         OOTRACEERR4(\"Error:Failed to create duplicate audio capability in \"\n                     \"ooOpenChannel- %s (%s, %s)\\n\", \n                     ooGetCapTypeText(epCap->cap), call->callType, \n                     call->callToken);\n         ooFreeH245Message(call, ph245msg);\n         return OO_FAILED;\n      }\n      flcp->dataType.u.audioData = audioCap;\n   }\n   else if(epCap->capType == OO_CAP_TYPE_VIDEO)\n   {\n      flcp->dataType.t = T_H245DataType_videoData;      \n      videoCap = ooCapabilityCreateVideoCapability(epCap, pctxt, OOTX);\n      if(!videoCap)\n      {\n         OOTRACEERR4(\"Error:Failed to create duplicate video capability in \"\n                     \"ooOpenChannel- %s (%s, %s)\\n\", \n                     ooGetCapTypeText(epCap->cap), call->callType, \n                     call->callToken);\n         ooFreeH245Message(call, ph245msg);\n         return OO_FAILED;\n      }\n      flcp->dataType.u.videoData = videoCap;\n   }\n   else if(epCap->capType == OO_CAP_TYPE_DATA)\n   {\n      flcp->dataType.t = T_H245DataType_data;\n      \n      t38Cap = ooCapabilityCreateT38Capability(epCap,pctxt, OOTX);\n      if(!t38Cap)\n      {\n         OOTRACEERR4(\"Error:Failed to create duplicate T38 capability in \"\n                     \"ooOpenChannel- %s (%s, %s)\\n\", \n                     ooGetCapTypeText(epCap->cap), call->callType, \n                     call->callToken);\n         ooFreeH245Message(call, ph245msg);\n         return OO_FAILED;\n      }\n      flcp->dataType.u.data = t38Cap;\n   }\n   else{\n      OOTRACEERR1(\"Error: Unhandled media type in ooOpenChannel\\n\");\n      return OO_FAILED;\n   }\n   flcp->multiplexParameters.t = \n      T_H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters;\n   flcp->multiplexParameters.u.h2250LogicalChannelParameters = \n                         (H245H2250LogicalChannelParameters*)ASN1MALLOC(pctxt, \n                          sizeof(H245H2250LogicalChannelParameters));\n   h2250lcp = flcp->multiplexParameters.u.h2250LogicalChannelParameters;\n   memset(h2250lcp, 0, sizeof(H245H2250LogicalChannelParameters));\n   h2250lcp->sessionID = session_id;\n   h2250lcp->mediaGuaranteedDelivery = 0;\n   h2250lcp->silenceSuppression = 0;\n   h2250lcp->m.mediaControlChannelPresent = 1;\n   h2250lcp->mediaControlChannel.t = \n                                 T_H245TransportAddress_unicastAddress;\n   h2250lcp->mediaControlChannel.u.unicastAddress =  (H245UnicastAddress*)\n                         ASN1MALLOC(pctxt, sizeof(H245UnicastAddress));\n   unicastAddrs = h2250lcp->mediaControlChannel.u.unicastAddress;\n   memset(unicastAddrs, 0, sizeof(H245UnicastAddress));\n   if (call->versionIP == 6) {\n   \tunicastAddrs->t = T_H245UnicastAddress_iP6Address;\n   \tunicastAddrs->u.iP6Address = (H245UnicastAddress_iP6Address*)\n               ASN1MALLOC(pctxt, sizeof(H245UnicastAddress_iP6Address));\n   \tiP6Address = unicastAddrs->u.iP6Address;\n   \tmemset(iP6Address, 0, sizeof(H245UnicastAddress_iP6Address));\n\tinet_pton(AF_INET6, pLogicalChannel->localIP, iP6Address->network.data);\n   \tiP6Address->network.numocts = 16;\n   \tiP6Address->tsapIdentifier = pLogicalChannel->localRtcpPort;\n   } else {\n   \tunicastAddrs->t = T_H245UnicastAddress_iPAddress;\n   \tunicastAddrs->u.iPAddress = (H245UnicastAddress_iPAddress*)\n               ASN1MALLOC(pctxt, sizeof(H245UnicastAddress_iPAddress));\n   \tiPAddress = unicastAddrs->u.iPAddress;\n   \tmemset(iPAddress, 0, sizeof(H245UnicastAddress_iPAddress));\n\tinet_pton(AF_INET, pLogicalChannel->localIP, iPAddress->network.data);\n   \tiPAddress->network.numocts = 4;\n   \tiPAddress->tsapIdentifier = pLogicalChannel->localRtcpPort;\n   }\n   pLogicalChannel->state = OO_LOGICALCHAN_PROPOSED; \n   OOTRACEDBGA4(\"Built OpenLogicalChannel-%s (%s, %s)\\n\", \n                 ooGetCapTypeText(epCap->cap), call->callType, \n                 call->callToken);\n   ret = ooSendH245Msg(call, ph245msg);\n   if(ret != OO_OK)\n   {\n      OOTRACEERR3(\"Error:Failed to enqueue OpenLogicalChannel to outbound \"\n                 \"queue. (%s, %s)\\n\", call->callType,\n                 call->callToken);\n   }\n   ooFreeH245Message(call, ph245msg);\n   return ret;\n}\n", "bug_type": null, "idx": 322}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245FECData (OOCTXT* pctxt, H245FECData* pvalue)\n{\n   int stat = ASN_OK;\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 0);\n   if (stat != ASN_OK) return stat;\n   \n   switch (pvalue->t)\n   {\n      \n      case 1:\n         stat = asn1PE_H245FECData_rfc2733 (pctxt, pvalue->u.rfc2733);\n         if (stat != ASN_OK) return stat;\n         break;\n      default:\n         return ASN_E_INVOPT;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 323}
{"project": "Asterisk", "target": 0, "func": "static void presence_state_cb(void *unused, struct stasis_subscription *sub, struct stasis_message *msg)\n{\n\tstruct ast_presence_state_message *presence_state;\n\tstruct ast_str *hint_app = NULL;\n\tstruct ast_hintdevice *device;\n\tstruct ast_hintdevice *cmpdevice;\n\tstruct ao2_iterator *dev_iter;\n\tif (stasis_message_type(msg) != ast_presence_state_message_type()) {\n\t\treturn;\n\t}\n\tpresence_state = stasis_message_data(msg);\n\tif (ao2_container_count(hintdevices) == 0) {\n\t\t\n\t\treturn;\n\t}\n\thint_app = ast_str_create(1024);\n\tif (!hint_app) {\n\t\treturn;\n\t}\n\tcmpdevice = ast_alloca(sizeof(*cmpdevice) + strlen(presence_state->provider));\n\tstrcpy(cmpdevice->hintdevice, presence_state->provider);\n\tast_mutex_lock(&context_merge_lock);\n\tdev_iter = ao2_t_callback(hintdevices,\n\t\tOBJ_POINTER | OBJ_MULTIPLE,\n\t\thintdevice_cmp_multiple,\n\t\tcmpdevice,\n\t\t\"find devices in container\");\n\tif (!dev_iter) {\n\t\tast_mutex_unlock(&context_merge_lock);\n\t\tast_free(hint_app);\n\t\treturn;\n\t}\n\tfor (; (device = ao2_iterator_next(dev_iter)); ao2_t_ref(device, -1, \"Next device\")) {\n\t\tif (device->hint) {\n\t\t\tpresence_state_notify_callbacks(device->hint, &hint_app, presence_state);\n\t\t}\n\t}\n\tao2_iterator_destroy(dev_iter);\n\tast_mutex_unlock(&context_merge_lock);\n\tast_free(hint_app);\n}\n", "bug_type": null, "idx": 324}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225DisengageReason (OOCTXT* pctxt, H225DisengageReason* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"forcedDrop\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"forcedDrop\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"normalDrop\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"normalDrop\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"undefinedReason\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"undefinedReason\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 4;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 325}
{"project": "Asterisk", "target": 0, "func": "\nstatic void jingle_action_session_accept(struct jingle_endpoint *endpoint, struct jingle_session *session, ikspak *pak)\n{\n\tstruct ast_channel *chan;\n\tif (!session) {\n\t\tjingle_send_error_response(endpoint->connection, pak, \"cancel\", \"item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'\",\n\t\t\t\t\t   \"unknown-session xmlns='urn:xmpp:jingle:errors:1'\");\n\t\treturn;\n\t}\n\tjingle_interpret_content(session, pak);\n\tif ((chan = jingle_session_lock_full(session))) {\n\t\tast_queue_control(chan, AST_CONTROL_ANSWER);\n\t\tast_channel_unlock(chan);\n\t\tast_channel_unref(chan);\n\t}\n\tao2_unlock(session);\n\tjingle_send_response(endpoint->connection, pak);\n}\n", "bug_type": null, "idx": 326}
{"project": "Asterisk", "target": 0, "func": "struct ast_frame *ast_rtp_instance_read(struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct ast_frame *frame;\n\tao2_lock(instance);\n\tframe = instance->engine->read(instance, rtcp);\n\tao2_unlock(instance);\n\treturn frame;\n}\n", "bug_type": null, "idx": 327}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_channel *test_vm_api_create_mock_channel(void)\n{\n\tstruct ast_channel *mock_channel;\n\tstruct ast_format_cap *native_formats;\n\tif (!(mock_channel = ast_channel_alloc(0, AST_STATE_DOWN, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, \"TestChannel\"))) {\n\t\treturn NULL;\n\t}\n\tast_channel_set_writeformat(mock_channel, ast_format_gsm);\n\tast_channel_set_rawwriteformat(mock_channel, ast_format_gsm);\n\tast_channel_set_readformat(mock_channel, ast_format_gsm);\n\tast_channel_set_rawreadformat(mock_channel, ast_format_gsm);\n\tast_channel_tech_set(mock_channel, &mock_channel_tech);\n\tnative_formats = ast_channel_nativeformats(mock_channel);\n\tast_format_cap_append(native_formats, ast_channel_writeformat(mock_channel), 0);\n\tast_channel_unlock(mock_channel);\n\treturn mock_channel;\n}\n", "bug_type": null, "idx": 328}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void destroy_state_cb(void *doomed)\n{\n\tstruct ast_state_cb *state_cb = doomed;\n\tif (state_cb->destroy_cb) {\n\t\tstate_cb->destroy_cb(state_cb->id, state_cb->data);\n\t}\n}\n", "bug_type": null, "idx": 329}
{"project": "Asterisk", "target": 0, "func": "DEFINE_STRINGFIELD_GETTER_FOR(dialcontext);\nconst char *ast_channel_uniqueid(const struct ast_channel *chan)\n{\n\tast_assert(chan->uniqueid.unique_id[0] != '\\0');\n\treturn chan->uniqueid.unique_id;\n}\n", "bug_type": null, "idx": 330}
{"project": "Asterisk", "target": 0, "func": "long ast_threadpool_queue_size(struct ast_threadpool *pool)\n{\n\treturn ast_taskprocessor_size(pool->tps);\n}\n", "bug_type": null, "idx": 331}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_macropriority(const struct ast_channel *chan)\n{\n\treturn chan->macropriority;\n}\n", "bug_type": null, "idx": 332}
{"project": "Asterisk", "target": 0, "func": "int ast_playstream(struct ast_filestream *s)\n{\n\tenum fsread_res res;\n\tif (ast_format_get_type(s->fmt->format) == AST_MEDIA_TYPE_AUDIO)\n\t\tres = ast_readaudio_callback(s);\n\telse\n\t\tres = ast_readvideo_callback(s);\n\treturn (res == FSREAD_FAILURE) ? -1 : 0;\n}\n", "bug_type": null, "idx": 333}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel *ast_channel_masqr(const struct ast_channel *chan)\n{\n\treturn chan->masqr;\n}\n", "bug_type": null, "idx": 334}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void *test_data_alloc(const char *id)\n{\n\treturn ast_sorcery_generic_alloc(sizeof(struct test_data), NULL);\n}\n", "bug_type": null, "idx": 335}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ogg_vorbis_seek(struct ast_filestream *fs, off_t sample_offset, int whence)\n{\n\tint seek_result = -1;\n\toff_t relative_pcm_pos;\n\tstruct ogg_vorbis_desc *desc = (struct ogg_vorbis_desc *) fs->_private;\n\tif (desc->writing) {\n\t\tast_log(LOG_WARNING, \"Seeking is not supported on OGG/Vorbis streams in writing mode!\\n\");\n\t\treturn -1;\n\t}\n\t\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tseek_result = ov_pcm_seek(&desc->ov_f, sample_offset);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tif ((relative_pcm_pos = ogg_vorbis_tell(fs)) < 0) {\n\t\t\tseek_result = -1;\n\t\t\tbreak;\n\t\t}\n\t\tseek_result = ov_pcm_seek(&desc->ov_f, relative_pcm_pos + sample_offset);\n\t\tbreak;\n\tcase SEEK_END:\n\t\tif ((relative_pcm_pos = ov_pcm_total(&desc->ov_f, -1)) < 0) {\n\t\t\tseek_result = -1;\n\t\t\tbreak;\n\t\t}\n\t\tseek_result = ov_pcm_seek(&desc->ov_f, relative_pcm_pos - sample_offset);\n\t\tbreak;\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Unknown *whence* to seek on OGG/Vorbis streams!\\n\");\n\t\tbreak;\n\t}\n\t\n\treturn (seek_result == 0) ? 0 : -1;\n}\n", "bug_type": null, "idx": 336}
{"project": "Asterisk", "target": 0, "func": "static SQLHSTMT custom_prepare(struct odbc_obj *obj, void *data)\n{\n\tint res, x = 1, count = 0;\n\tstruct custom_prepare_struct *cps = data;\n\tconst struct ast_variable *field;\n\tchar encodebuf[1024];\n\tSQLHSTMT stmt;\n\tres = SQLAllocHandle(SQL_HANDLE_STMT, obj->con, &stmt);\n\tif ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {\n\t\tast_log(LOG_WARNING, \"SQL Alloc Handle failed!\\n\");\n\t\treturn NULL;\n\t}\n\tast_debug(1, \"Skip: %llu; SQL: %s\\n\", cps->skip, cps->sql);\n\tres = SQLPrepare(stmt, (unsigned char *)cps->sql, SQL_NTS);\n\tif ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {\n\t\tast_log(LOG_WARNING, \"SQL Prepare failed! [%s]\\n\", cps->sql);\n\t\tSQLFreeHandle (SQL_HANDLE_STMT, stmt);\n\t\treturn NULL;\n\t}\n\tfor (field = cps->fields; field; field = field->next) {\n\t\tconst char *newval = field->value;\n\t\tif ((1LL << count++) & cps->skip) {\n\t\t\tast_debug(1, \"Skipping field '%s'='%s' (%llo/%llo)\\n\", field->name, newval, 1ULL << (count - 1), cps->skip);\n\t\t\tcontinue;\n\t\t}\n\t\tast_debug(1, \"Parameter %d ('%s') = '%s'\\n\", x, field->name, newval);\n\t\tif (strchr(newval, ';') || strchr(newval, '^')) {\n\t\t\tENCODE_CHUNK(encodebuf, newval);\n\t\t\tast_string_field_set(cps, encoding[x], encodebuf);\n\t\t\tnewval = cps->encoding[x];\n\t\t}\n\t\tSQLBindParameter(stmt, x++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, strlen(newval), 0, (void *)newval, 0, NULL);\n\t}\n\tif (!ast_strlen_zero(cps->extra)) {\n\t\tconst char *newval = cps->extra;\n\t\tast_debug(1, \"Parameter %d = '%s'\\n\", x, newval);\n\t\tif (strchr(newval, ';') || strchr(newval, '^')) {\n\t\t\tENCODE_CHUNK(encodebuf, newval);\n\t\t\tast_string_field_set(cps, encoding[x], encodebuf);\n\t\t\tnewval = cps->encoding[x];\n\t\t} \n\t\tSQLBindParameter(stmt, x++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, strlen(newval), 0, (void *)newval, 0, NULL);\n\t}\n\treturn stmt;\n}\n", "bug_type": null, "idx": 337}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int xmldoc_parse_para(struct ast_xml_node *node, const char *tabs, const char *posttabs, struct ast_str **buffer)\n{\n\tconst char *tmptext;\n\tstruct ast_xml_node *tmp;\n\tint ret = 0;\n\tstruct ast_str *tmpstr;\n\tif (!node || !ast_xml_node_get_children(node)) {\n\t\treturn ret;\n\t}\n\tif (strcasecmp(ast_xml_node_get_name(node), \"para\")) {\n\t\treturn ret;\n\t}\n\tast_str_append(buffer, 0, \"%s\", tabs);\n\tret = 1;\n\tfor (tmp = ast_xml_node_get_children(node); tmp; tmp = ast_xml_node_get_next(tmp)) {\n\t\t\n\t\ttmptext = ast_xml_get_text(tmp);\n\t\tif (tmptext) {\n\t\t\t\n\t\t\txmldoc_string_cleanup(tmptext, &tmpstr, 0, 0);\n\t\t\tast_xml_free_text(tmptext);\n\t\t\tif (tmpstr) {\n\t\t\t\tif (strcasecmp(ast_xml_node_get_name(tmp), \"text\")) {\n\t\t\t\t\tast_str_append(buffer, 0, \"<%s>%s</%s>\", ast_xml_node_get_name(tmp),\n\t\t\t\t\t\t\tast_str_buffer(tmpstr), ast_xml_node_get_name(tmp));\n\t\t\t\t} else {\n\t\t\t\t\tast_str_append(buffer, 0, \"%s\", ast_str_buffer(tmpstr));\n\t\t\t\t}\n\t\t\t\tast_free(tmpstr);\n\t\t\t\tret = 2;\n\t\t\t}\n\t\t}\n\t}\n\tast_str_append(buffer, 0, \"%s\", posttabs);\n\treturn ret;\n}\n", "bug_type": null, "idx": 338}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct sched_data *sched_data_create(struct ast_sip_contact *contact)\n{\n\tstruct sched_data *data;\n\tdata = ao2_t_alloc(sizeof(*data), sched_data_destructor, contact->uri);\n\tif (!data) {\n\t\tast_log(LOG_ERROR, \"Unable to create schedule qualify data for contact %s\\n\",\n\t\t\tcontact->uri);\n\t\treturn NULL;\n\t}\n\tdata->contact = contact;\n\tao2_ref(data->contact, +1);\n\treturn data;\n}\n", "bug_type": null, "idx": 339}
{"project": "Asterisk", "target": 0, "func": " * \\param data framehook data (faxdetect data)*/\nstatic void fax_detect_framehook_destroy(void *data)\n{\n\tstruct fax_detect *faxdetect = data;\n\tao2_ref(faxdetect, -1);\n}\n", "bug_type": null, "idx": 340}
{"project": "Asterisk", "target": 0, "func": "static int pbx_builtin_saycharacters(struct ast_channel *chan, const char *data)\n{\n\tint res = 0;\n\tint interrupt = 0;\n\tconst char *interrupt_string;\n\tast_channel_lock(chan);\n\tinterrupt_string = pbx_builtin_getvar_helper(chan, \"SAY_DTMF_INTERRUPT\");\n\tif (ast_true(interrupt_string)) {\n\t\tinterrupt = 1;\n\t}\n\tast_channel_unlock(chan);\n\tif (data) {\n\t\tres = ast_say_character_str(chan, data, interrupt ? AST_DIGIT_ANY : \"\", ast_channel_language(chan), AST_SAY_CASE_NONE);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 341}
{"project": "Asterisk", "target": 0, "func": "static struct ast_manager_event_blob *aoc_s_to_ami(struct stasis_message *message)\n{\n\treturn aoc_to_ami(message, \"AOC-S\");\n}\n", "bug_type": null, "idx": 342}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn __unload_module();\n}\n", "bug_type": null, "idx": 343}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_sched_task_get_name(struct ast_sip_sched_task *schtd, char *name, size_t maxlen)\n{\n\tif (maxlen <= 0) {\n\t\treturn -1;\n\t}\n\tif (!ao2_ref_and_lock(schtd)) {\n\t\treturn -1;\n\t}\n\tast_copy_string(name, schtd->name, maxlen);\n\tao2_unlock_and_unref(schtd);\n\treturn 0;\n}\n", "bug_type": null, "idx": 344}
{"project": "Asterisk", "target": 0, "func": "int ast_adsi_input_format(unsigned char *buf, int num, int dir, int wrap, char *format1, char *format2)\n{\n\tint res = 0;\n\tast_rwlock_rdlock(&func_lock);\n\tif (installed_funcs && installed_funcs->input_format) {\n\t\tres = installed_funcs->input_format(buf, num, dir, wrap, format1, format2);\n\t}\n\tast_rwlock_unlock(&func_lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 345}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_variable *get_object_variables(struct ast_variable *vars, char *prefix)\n{\n\tstruct ast_variable *return_vars = NULL;\n\tstruct ast_variable *v = vars;\n\tint plen = strlen(prefix);\n\tfor(; v; v = v->next) {\n\t\tif (ast_begins_with(v->name, prefix) && strlen(v->name) > plen) {\n\t\t\tif (variable_list_append(&return_vars, v->name + plen, v->value)) {\n\t\t\t\tast_variables_destroy(return_vars);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn return_vars;\n}\n", "bug_type": null, "idx": 346}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245TerminalID (OOCTXT* pctxt, H245TerminalID* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = encodeOctetString (pctxt, pvalue->numocts, pvalue->data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 347}
{"project": "Asterisk", "target": 0, "func": "struct ast_features_general_config *ast_get_chan_features_general_config(struct ast_channel *chan)\n{\n\tRAII_VAR(struct features_config *, cfg, NULL, ao2_cleanup);\n\tif (chan) {\n\t\tcfg = get_feature_ds(chan);\n\t} else {\n\t\tcfg = ao2_global_obj_ref(globals);\n\t}\n\tif (!cfg) {\n\t\treturn NULL;\n\t}\n\tast_assert(cfg->global && cfg->global->general);\n\tao2_ref(cfg->global->general, +1);\n\treturn cfg->global->general;\n}\n", "bug_type": null, "idx": 348}
{"project": "Asterisk", "target": 0, "func": "void get_start_stop(unsigned int *word, int bitsperword, int totalbits, int *start, int *end)\n{\n\tint i;\n\tint thisbit, thatbit = bit_at(word, bitsperword, totalbits-1);\n\tfor (i=0; i<totalbits; i++) {\n\t\tthisbit = bit_at(word, bitsperword, i);\n\t\tif (thisbit != thatbit ) {\n\t\t\tif (thisbit) {\n\t\t\t\t*start = i;\n\t\t\t} else {\n\t\t\t\t*end = i;\n\t\t\t}\n\t\t}\n\t\tthatbit = thisbit;\n\t}\n}\n", "bug_type": null, "idx": 349}
{"project": "Asterisk", "target": 0, "func": "static struct ast_config *ast_config_internal_load(const char *filename, struct ast_config *cfg, int withcomments, const char *suggested_incl_file);\nstatic struct ast_config *ast_config_internal_load(const char *filename, struct ast_config *cfg, int withcomments, const char *suggested_incl_file)\n{\n\tchar db[256];\n\tchar table[256];\n\tstruct ast_config_engine *loader = &text_file_engine;\n\tstruct ast_config *result;\n\tif (cfg->include_level == cfg->max_include_level) {\n\t\tast_log(LOG_WARNING, \"Maximum Include level (%d) exceeded\\n\", cfg->max_include_level);\n\t\treturn NULL;\n\t}\n\tcfg->include_level++;\n\t\n\tif (strcmp(filename, extconfig_conf) && strcmp(filename, \"asterisk.conf\") && config_engine_list) {\n\t\tstruct ast_config_engine *eng;\n\t\teng = find_engine(filename, db, sizeof(db), table, sizeof(table));\n\t\tif (eng && eng->load_func) {\n\t\t\tloader = eng;\n\t\t} else {\n\t\t\teng = find_engine(\"global\", db, sizeof(db), table, sizeof(table));\n\t\t\tif (eng && eng->load_func)\n\t\t\t\tloader = eng;\n\t\t}\n\t}\n\tresult = loader->load_func(db, table, filename, cfg, withcomments, suggested_incl_file);\n\t\n\tif (result)\n\t\tresult->include_level--;\n\treturn result;\n}\n", "bug_type": null, "idx": 350}
{"project": "Asterisk", "target": 0, "func": "static struct sig_ss7_linkset *sig_ss7_find_linkset(struct ss7 *ss7)\n{\n\tif (sig_ss7_callbacks.find_linkset) {\n\t\treturn sig_ss7_callbacks.find_linkset(ss7);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 351}
{"project": "Asterisk", "target": 0, "func": "static void handle_cause(int cause, int *outstate)\n{\n\tif (outstate) {\n\t\t\n\t\tif (cause == AST_CAUSE_BUSY)\n\t\t\t*outstate = AST_CONTROL_BUSY;\n\t\telse if (cause == AST_CAUSE_CONGESTION)\n\t\t\t*outstate = AST_CONTROL_CONGESTION;\n\t\telse\n\t\t\t*outstate = 0;\n\t}\n}\n", "bug_type": null, "idx": 352}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tAST_TEST_REGISTER(srv_resolve_single_record);\n\tAST_TEST_REGISTER(srv_resolve_sort_priority);\n\tAST_TEST_REGISTER(srv_resolve_same_priority_zero_weight);\n\tAST_TEST_REGISTER(srv_resolve_same_priority_different_weights);\n\tAST_TEST_REGISTER(srv_resolve_different_priorities_different_weights);\n\tAST_TEST_REGISTER(srv_resolve_record_missing_weight_port_host);\n\tAST_TEST_REGISTER(srv_resolve_record_missing_port_host);\n\tAST_TEST_REGISTER(srv_resolve_record_missing_host);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 353}
{"project": "Asterisk", "target": 0, "func": "typedef int (*app_command_can_exec_cb)(struct stasis_app_control *control);\nstatic struct stasis_app_command *exec_command_on_condition(\n\tstruct stasis_app_control *control, stasis_app_command_cb command_fn,\n\tvoid *data, command_data_destructor_fn data_destructor,\n\tapp_command_can_exec_cb can_exec_fn)\n{\n\tint retval;\n\tstruct stasis_app_command *command;\n\tcommand_fn = command_fn ? : noop_cb;\n\tcommand = command_create(command_fn, data, data_destructor);\n\tif (!command) {\n\t\treturn NULL;\n\t}\n\tao2_lock(control->command_queue);\n\tif (control->is_done) {\n\t\tao2_unlock(control->command_queue);\n\t\tao2_ref(command, -1);\n\t\treturn NULL;\n\t}\n\tif (can_exec_fn && (retval = can_exec_fn(control))) {\n\t\tao2_unlock(control->command_queue);\n\t\tcommand_complete(command, retval);\n\t\treturn command;\n\t}\n\tao2_link_flags(control->command_queue, command, OBJ_NOLOCK);\n\tast_cond_signal(&control->wait_cond);\n\tao2_unlock(control->command_queue);\n\treturn command;\n}\n", "bug_type": null, "idx": 354}
{"project": "Asterisk", "target": 0, "func": "static const char app_execif[] = \"ExecIf\";\nstatic int exec_exec(struct ast_channel *chan, const char *data)\n{\n\tint res = 0;\n\tchar *s, *appname, *endargs;\n\tstruct ast_app *app;\n\tstruct ast_str *args = NULL;\n\tif (ast_strlen_zero(data))\n\t\treturn 0;\n\ts = ast_strdupa(data);\n\tappname = strsep(&s, \"(\");\n\tif (s) {\n\t\tendargs = strrchr(s, ')');\n\t\tif (endargs)\n\t\t\t*endargs = '\\0';\n\t\tif ((args = ast_str_create(16))) {\n\t\t\tast_str_substitute_variables(&args, 0, chan, s);\n\t\t}\n\t}\n\tif (appname) {\n\t\tapp = pbx_findapp(appname);\n\t\tif (app) {\n\t\t\tres = pbx_exec(chan, app, args ? ast_str_buffer(args) : NULL);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Could not find application (%s)\\n\", appname);\n\t\t\tres = -1;\n\t\t}\n\t}\n\tast_free(args);\n\treturn res;\n}\n", "bug_type": null, "idx": 355}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void notify_message(char *mailbox, int thereornot)\n{\n\tchar s[sizeof(mwimonitornotify) + 80];\n\tif (ast_strlen_zero(mailbox)) {\n\t\treturn;\n\t}\n\tast_publish_mwi_state(mailbox, NULL, thereornot, thereornot);\n\tif (!ast_strlen_zero(mwimonitornotify)) {\n\t\tsnprintf(s, sizeof(s), \"%s %s %d\", mwimonitornotify, mailbox, thereornot);\n\t\tast_safe_system(s);\n\t}\n}\n", "bug_type": null, "idx": 356}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int handle_manager_bridge_tech_suspend(struct mansession *s, const struct message *m, int suspend)\n{\n\tconst char *name = astman_get_header(m, \"BridgeTechnology\");\n\tstruct ast_bridge_technology *cur;\n\tint successful = 0;\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"BridgeTechnology must be provided\");\n\t\treturn 0;\n\t}\n\tAST_RWLIST_RDLOCK(&bridge_technologies);\n\tAST_RWLIST_TRAVERSE(&bridge_technologies, cur, entry) {\n\t\tif (!strcasecmp(cur->name, name)) {\n\t\t\tsuccessful = 1;\n\t\t\tif (suspend) {\n\t\t\t\tast_bridge_technology_suspend(cur);\n\t\t\t} else {\n\t\t\t\tast_bridge_technology_unsuspend(cur);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&bridge_technologies);\n\tif (!successful) {\n\t\tastman_send_error(s, m, \"BridgeTechnology not found\");\n\t\treturn 0;\n\t}\n\tastman_send_ack(s, m, (suspend ? \"Suspended bridge technology\" : \"Unsuspended bridge technology\"));\n\treturn 0;\n}\n", "bug_type": null, "idx": 357}
{"project": "Asterisk", "target": 0, "func": "static int set2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **str, ssize_t len)\n{\n\tif (len > -1) {\n\t\tast_str_make_space(str, len == 0 ? strlen(data) : len);\n\t}\n\treturn set(chan, cmd, data, ast_str_buffer(*str), ast_str_size(*str));\n}\n", "bug_type": null, "idx": 358}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int native_bridge_join(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)\n{\n\tstruct native_pvt_chan *tech_pvt;\n\tstruct ast_channel *c0;\n\tstruct ast_channel *c1;\n\tast_assert(!bridge_channel->tech_pvt);\n\ttech_pvt = ast_calloc(1, sizeof(*tech_pvt));\n\tif (!tech_pvt) {\n\t\treturn -1;\n\t}\n\tbridge_channel->tech_pvt = tech_pvt;\n\tnative_request_start(bridge);\n\t\n\tc0 = AST_LIST_FIRST(&bridge->channels)->chan;\n\tc1 = AST_LIST_LAST(&bridge->channels)->chan;\n\tif (c0 == c1) {\n\t\treturn 0;\n\t}\n\treturn ast_channel_make_compatible(c0, c1);\n}\n", "bug_type": null, "idx": 359}
{"project": "Asterisk", "target": 0, "func": "int ooSetFDSETs(struct pollfd *pfds, int *nfds)\n{\n   if(gH323ep.gkClient && gH323ep.gkClient->rasSocket != 0)\n   {\n      pfds[*nfds].fd = gH323ep.gkClient->rasSocket;\n      pfds[*nfds].events = POLLIN;\n      (*nfds)++;\n   }\n   if(gH323ep.listener)\n   {\n      pfds[*nfds].fd = *gH323ep.listener;\n      pfds[*nfds].events = POLLIN;\n      (*nfds)++;\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 360}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_cel_check_enabled(void)\n{\n\tunsigned int enabled;\n\tstruct cel_config *cfg = ao2_global_obj_ref(cel_configs);\n\tenabled = (!cfg || !cfg->general) ? 0 : cfg->general->enable;\n\tao2_cleanup(cfg);\n\treturn enabled;\n}\n", "bug_type": null, "idx": 361}
{"project": "Asterisk", "target": 0, "func": "\nint reload(void)\n{\n\tif (unistimdebug) {\n\t\tast_verb(0, \"reload unistim\\n\");\n\t}\n\tast_mutex_lock(&unistim_reload_lock);\n\tif (!unistim_reloading) {\n\t\tunistim_reloading = 1;\n\t}\n\tast_mutex_unlock(&unistim_reload_lock);\n\trestart_monitor();\n\treturn 0;\n}\n", "bug_type": null, "idx": 362}
{"project": "Asterisk", "target": 0, "func": "protected void\nsig_set(EditLine *el)\n{\n\tint i;\n\tsigset_t nset, oset;\n\t(void) sigemptyset(&nset);\n#define\t_DO(a) (void) sigaddset(&nset, a);\n\tALLSIGS\n#undef\t_DO\n\t    (void) sigprocmask(SIG_BLOCK, &nset, &oset);\n\tfor (i = 0; sighdl[i] != -1; i++) {\n\t\tsig_t s;\n\t\t\n\t\tif ((s = signal(sighdl[i], sig_handler)) != sig_handler)\n\t\t\tel->el_signal[i] = s;\n\t}\n\tsel = el;\n\t(void) sigprocmask(SIG_SETMASK, &oset, NULL);\n}\n", "bug_type": null, "idx": 363}
{"project": "Asterisk", "target": 0, "func": "static int analog_get_event(struct analog_pvt *p)\n{\n\tif (analog_callbacks.get_event) {\n\t\treturn analog_callbacks.get_event(p->chan_pvt);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 364}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void __attribute__((format(printf, 1, 2))) test_jb_warn_output(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[1024];\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tast_log(AST_LOG_WARNING, \"%s\", buf);\n}\n", "bug_type": null, "idx": 365}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_set_after_goto(struct ast_channel *chan, const char *context, const char *exten, int priority)\n{\n\t__after_bridge_set_goto(chan, 0, 1, context, exten, priority, NULL);\n}\n", "bug_type": null, "idx": 366}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function mchan_function = {\n\t.name = \"MASTER_CHANNEL\",\n\t.read2 = func_mchan_read,\n\t.write = func_mchan_write,\n};\n}\nstatic struct ast_custom_function mchan_function = {\n\t.name = \"MASTER_CHANNEL\",\n\t.read2 = func_mchan_read,\n\t.write = func_mchan_write,\n};\nstatic int unload_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_unregister(&channel_function);\n\tres |= ast_custom_function_unregister(&channels_function);\n\tres |= ast_custom_function_unregister(&mchan_function);\n\treturn res;\n}\nstatic int load_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_register(&channel_function);\n\tres |= ast_custom_function_register(&channels_function);\n\tres |= ast_custom_function_register(&mchan_function);\n\treturn res;\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"Channel information dialplan functions\");\n", "bug_type": null, "idx": 367}
{"project": "Asterisk", "target": 0, "func": "int dundi_precache(const char *context, const char *number)\n{\n\tdundi_eid *avoid[1] = { NULL, };\n\treturn dundi_precache_internal(context, number, dundi_ttl, avoid);\n}\n", "bug_type": null, "idx": 368}
{"project": "Asterisk", "target": 0, "func": "\t} while (0)\nvoid *ast_std_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n", "bug_type": null, "idx": 369}
{"project": "Asterisk", "target": 0, "func": "#undef socket\nint __ast_fdleak_socket(int domain, int type, int protocol, const char *file, int line, const char *func)\n{\n\tchar sdomain[20], stype[20], *sproto = NULL;\n\tstruct protoent *pe;\n\tint res = socket(domain, type, protocol);\n\tif (res < 0 || res >= ARRAY_LEN(fdleaks)) {\n\t\treturn res;\n\t}\n\tif ((pe = getprotobynumber(protocol))) {\n\t\tsproto = pe->p_name;\n\t}\n\tif (domain == PF_UNIX) {\n\t\tast_copy_string(sdomain, \"PF_UNIX\", sizeof(sdomain));\n\t} else if (domain == PF_INET) {\n\t\tast_copy_string(sdomain, \"PF_INET\", sizeof(sdomain));\n\t} else {\n\t\tsnprintf(sdomain, sizeof(sdomain), \"%d\", domain);\n\t}\n\tif (type == SOCK_DGRAM) {\n\t\tast_copy_string(stype, \"SOCK_DGRAM\", sizeof(stype));\n\t\tif (protocol == 0) {\n\t\t\tsproto = \"udp\";\n\t\t}\n\t} else if (type == SOCK_STREAM) {\n\t\tast_copy_string(stype, \"SOCK_STREAM\", sizeof(stype));\n\t\tif (protocol == 0) {\n\t\t\tsproto = \"tcp\";\n\t\t}\n\t} else {\n\t\tsnprintf(stype, sizeof(stype), \"%d\", type);\n\t}\n\tif (sproto) {\n\t\tSTORE_COMMON(res, \"socket\", \"%s,%s,\\\"%s\\\"\", sdomain, stype, sproto);\n\t} else {\n\t\tSTORE_COMMON(res, \"socket\", \"%s,%s,\\\"%d\\\"\", sdomain, stype, protocol);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 370}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int xmpp_status_exec(struct ast_channel *chan, const char *data)\n{\n\tRAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);\n\tRAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);\n\tchar *s = NULL, status[2];\n\tstatic int deprecation_warning = 0;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t     AST_APP_ARG(sender);\n\t\t\t     AST_APP_ARG(jid);\n\t\t\t     AST_APP_ARG(variable);\n\t\t);\n\tAST_DECLARE_APP_ARGS(jid,\n\t\t\t     AST_APP_ARG(screenname);\n\t\t\t     AST_APP_ARG(resource);\n\t\t);\n\tif (deprecation_warning++ % 10 == 0) {\n\t\tast_log(LOG_WARNING, \"JabberStatus is deprecated.  Please use the JABBER_STATUS dialplan function in the future.\\n\");\n\t}\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_ERROR, \"Usage: JabberStatus(<sender>,<jid>[/<resource>],<varname>\\n\");\n\t\treturn 0;\n\t}\n\ts = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, s);\n\tif (args.argc != 3) {\n\t\tast_log(LOG_ERROR, \"JabberStatus() requires 3 arguments.\\n\");\n\t\treturn -1;\n\t}\n\tAST_NONSTANDARD_APP_ARGS(jid, args.jid, '/');\n\tif (jid.argc < 1 || jid.argc > 2) {\n\t\tast_log(LOG_WARNING, \"Wrong JID %s, exiting\\n\", args.jid);\n\t\treturn -1;\n\t}\n\tif (!cfg || !cfg->clients || !(clientcfg = xmpp_config_find(cfg->clients, args.sender))) {\n\t\tast_log(LOG_WARNING, \"Could not find sender connection: '%s'\\n\", args.sender);\n\t\treturn -1;\n\t}\n\tsnprintf(status, sizeof(status), \"%d\", get_buddy_status(clientcfg, jid.screenname, jid.resource));\n\tpbx_builtin_setvar_helper(chan, args.variable, status);\n\treturn 0;\n}\n", "bug_type": null, "idx": 371}
{"project": "Asterisk", "target": 0, "func": "static int dundi_lookup_local(struct dundi_result *dr, struct dundi_mapping *map, char *called_number, dundi_eid *us_eid, int anscnt, struct dundi_hint_metadata *hmd)\n{\n\tstruct ast_flags flags = {0};\n\tint x;\n\tif (!ast_strlen_zero(map->lcontext)) {\n\t\tif (ast_exists_extension(NULL, map->lcontext, called_number, 1, NULL))\n\t\t\tast_set_flag(&flags, DUNDI_FLAG_EXISTS);\n\t\tif (ast_canmatch_extension(NULL, map->lcontext, called_number, 1, NULL))\n\t\t\tast_set_flag(&flags, DUNDI_FLAG_CANMATCH);\n\t\tif (ast_matchmore_extension(NULL, map->lcontext, called_number, 1, NULL))\n\t\t\tast_set_flag(&flags, DUNDI_FLAG_MATCHMORE);\n\t\tif (ast_ignore_pattern(map->lcontext, called_number))\n\t\t\tast_set_flag(&flags, DUNDI_FLAG_IGNOREPAT);\n\t\t\n\t\tif (ast_test_flag(&flags, AST_FLAGS_ALL))\n\t\t\tast_clear_flag_nonstd(hmd, DUNDI_HINT_DONT_ASK);\n\t\tif (map->options & DUNDI_FLAG_INTERNAL_NOPARTIAL) {\n\t\t\t\n\t\t\tast_clear_flag(&flags, DUNDI_FLAG_MATCHMORE|DUNDI_FLAG_CANMATCH);\n\t\t}\n\t\tif (ast_test_flag(&flags, AST_FLAGS_ALL)) {\n\t\t\tstruct varshead headp;\n\t\t\tstruct ast_var_t *newvariable;\n\t\t\tast_set_flag(&flags, map->options & 0xffff);\n\t\t\tast_copy_flags(dr + anscnt, &flags, AST_FLAGS_ALL);\n\t\t\tdr[anscnt].techint = map->tech;\n\t\t\tdr[anscnt].expiration = dundi_cache_time;\n\t\t\tast_copy_string(dr[anscnt].tech, tech2str(map->tech), sizeof(dr[anscnt].tech));\n\t\t\tdr[anscnt].eid = *us_eid;\n\t\t\tast_eid_to_str(dr[anscnt].eid_str, sizeof(dr[anscnt].eid_str), &dr[anscnt].eid);\n\t\t\tif (ast_test_flag(&flags, DUNDI_FLAG_EXISTS)) {\n\t\t\t\tAST_LIST_HEAD_INIT_NOLOCK(&headp);\n\t\t\t\tif ((newvariable = ast_var_assign(\"NUMBER\", called_number))) {\n\t\t\t\t\tAST_LIST_INSERT_HEAD(&headp, newvariable, entries);\n\t\t\t\t}\n\t\t\t\tif ((newvariable = ast_var_assign(\"EID\", dr[anscnt].eid_str))) {\n\t\t\t\t\tAST_LIST_INSERT_HEAD(&headp, newvariable, entries);\n\t\t\t\t}\n\t\t\t\tif ((newvariable = ast_var_assign(\"SECRET\", cursecret))) {\n\t\t\t\t\tAST_LIST_INSERT_HEAD(&headp, newvariable, entries);\n\t\t\t\t}\n\t\t\t\tif ((newvariable = ast_var_assign(\"IPADDR\", ipaddr))) {\n\t\t\t\t\tAST_LIST_INSERT_HEAD(&headp, newvariable, entries);\n\t\t\t\t}\n\t\t\t\tpbx_substitute_variables_varshead(&headp, map->dest, dr[anscnt].dest, sizeof(dr[anscnt].dest));\n\t\t\t\tdr[anscnt].weight = get_mapping_weight(map, &headp);\n\t\t\t\twhile ((newvariable = AST_LIST_REMOVE_HEAD(&headp, entries)))\n\t\t\t\t\tast_var_delete(newvariable);\n\t\t\t} else {\n\t\t\t\tdr[anscnt].dest[0] = '\\0';\n\t\t\t\tdr[anscnt].weight = get_mapping_weight(map, NULL);\n\t\t\t}\n\t\t\tanscnt++;\n\t\t} else {\n\t\t\t\n\t\t\tchar tmp[AST_MAX_EXTENSION + 1] = \"\";\n\t\t\tfor (x = 0; x < (sizeof(tmp) - 1); x++) {\n\t\t\t\ttmp[x] = called_number[x];\n\t\t\t\tif (!tmp[x])\n\t\t\t\t\tbreak;\n\t\t\t\tif (!ast_canmatch_extension(NULL, map->lcontext, tmp, 1, NULL)) {\n\t\t\t\t\t\n\t\t\t\t\tif (strlen(tmp) > strlen(hmd->exten)) {\n\t\t\t\t\t\tast_copy_string(hmd->exten, tmp, sizeof(hmd->exten));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn anscnt;\n}\n", "bug_type": null, "idx": 372}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225SetupAcknowledge_UUIE (OOCTXT* pctxt, H225SetupAcknowledge_UUIE* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.tokensPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.cryptoTokensPresent);\n   \n   stat = asn1PE_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225CallIdentifier (pctxt, &pvalue->callIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.tokensPresent) {\n      stat = asn1PE_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.cryptoTokensPresent) {\n      stat = asn1PE_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 373}
{"project": "Asterisk", "target": 0, "func": "struct ao2_container *command_prestart_get_container(struct ast_channel *chan)\n{\n\tstruct ast_datastore *datastore = ast_channel_datastore_find(chan, &command_queue_prestart, NULL);\n\tif (!datastore) {\n\t\treturn NULL;\n\t}\n\treturn ao2_bump(datastore->data);\n}\n", "bug_type": null, "idx": 374}
{"project": "Asterisk", "target": 0, "func": "protected el_action_t\ned_quoted_insert(EditLine *el, int c)\n{\n\tint num;\n\tchar tc;\n\ttty_quotemode(el);\n\tnum = el_getc(el, &tc);\n\tc = (unsigned char) tc;\n\ttty_noquotemode(el);\n\tif (num == 1)\n\t\treturn (ed_insert(el, c));\n\telse\n\t\treturn (ed_end_of_file(el, 0));\n}\n", "bug_type": null, "idx": 375}
{"project": "Asterisk", "target": 0, "func": "};\nint ast_syslog_priority_from_loglevel(int level)\n{\n\t\n\tif (level >= 16 && level < ASTNUMLOGLEVELS) {\n\t\treturn LOG_NOTICE;\n\t}\n\tif (level < 0 || level >= ARRAY_LEN(logger_level_to_syslog_map)) {\n\t\treturn -1;\n\t}\n\treturn logger_level_to_syslog_map[level];\n}\n", "bug_type": null, "idx": 376}
{"project": "Asterisk", "target": 0, "func": " */\nstatic pj_bool_t websocket_on_rx_msg(pjsip_rx_data *rdata)\n{\n\tstatic const pj_str_t STR_WS = { \"ws\", 2 };\n\tpjsip_contact_hdr *contact;\n\tlong type = rdata->tp_info.transport->key.type;\n\tif (type != (long) transport_type_wss && type != (long) transport_type_wss_ipv6) {\n\t\treturn PJ_FALSE;\n\t}\n\tcontact = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);\n\tif (contact\n\t\t&& !contact->star\n\t\t&& (PJSIP_URI_SCHEME_IS_SIP(contact->uri) || PJSIP_URI_SCHEME_IS_SIPS(contact->uri))) {\n\t\tpjsip_sip_uri *uri = pjsip_uri_get_uri(contact->uri);\n\t\tconst pj_str_t *txp_str = &STR_WS;\n\t\tast_debug(4, \"%s re-writing Contact URI from %.*s:%d%s%.*s to %s:%d;transport=%s\\n\",\n\t\t\tpjsip_rx_data_get_info(rdata),\n\t\t\t(int)pj_strlen(&uri->host), pj_strbuf(&uri->host), uri->port,\n\t\t\tpj_strlen(&uri->transport_param) ? \";transport=\" : \"\",\n\t\t\t(int)pj_strlen(&uri->transport_param), pj_strbuf(&uri->transport_param),\n\t\t\trdata->pkt_info.src_name ?: \"\", rdata->pkt_info.src_port, pj_strbuf(txp_str));\n\t\tpj_cstr(&uri->host, rdata->pkt_info.src_name);\n\t\turi->port = rdata->pkt_info.src_port;\n\t\tpj_strdup(rdata->tp_info.pool, &uri->transport_param, txp_str);\n\t}\n\trdata->msg_info.via->rport_param = 0;\n\treturn PJ_FALSE;\n}\n", "bug_type": null, "idx": 377}
{"project": "Asterisk", "target": 0, "func": "static void sleep_with_backoff(unsigned int *sleep_time)\n{\n\t\n\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n\tsleep(*sleep_time);\n\t*sleep_time = MIN(60, *sleep_time * 2);\n\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n}\n", "bug_type": null, "idx": 378}
{"project": "Asterisk", "target": 0, "func": "static void handle_end_element(void *data,\n\t\t\t\t\t\t\t   const xmlChar *localname, const xmlChar *prefix, const xmlChar *uri)\n{\n\tstruct xmlstate *state = data;\n\tstruct icaltimetype start, end;\n\ticaltimezone *utc = icaltimezone_get_utc_timezone();\n\ticalcomponent *iter;\n\ticalcomponent *comp;\n\tif (xmlStrcmp(localname, caldav_node_localname) || xmlStrcmp(uri, caldav_node_nsuri)) {\n\t\treturn;\n\t}\n\tstate->in_caldata = 0;\n\tif (!(state->cdata && ast_str_strlen(state->cdata))) {\n\t\treturn;\n\t}\n\t\n\tstart = icaltime_from_timet_with_zone(state->start, 0, utc);\n\tend = icaltime_from_timet_with_zone(state->end, 0, utc);\n\tcomp = icalparser_parse_string(ast_str_buffer(state->cdata));\n\tfor (iter = icalcomponent_get_first_component(comp, ICAL_VEVENT_COMPONENT);\n\t     iter;\n\t     iter = icalcomponent_get_next_component(comp, ICAL_VEVENT_COMPONENT))\n\t{\n\t\ticalcomponent_foreach_recurrence(iter, start, end, caldav_add_event, state->pvt);\n\t}\n\ticalcomponent_free(comp);\n}\n", "bug_type": null, "idx": 379}
{"project": "Asterisk", "target": 0, "func": "SQLHSTMT ast_odbc_direct_execute(struct odbc_obj *obj, SQLHSTMT (*exec_cb)(struct odbc_obj *obj, void *data), void *data)\n{\n\tSQLHSTMT stmt;\n\tstmt = exec_cb(obj, data);\n\treturn stmt;\n}\n", "bug_type": null, "idx": 380}
{"project": "Asterisk", "target": 0, "func": "static int manager_parking_lot_list(struct mansession *s, const struct message *m)\n{\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tstruct ao2_container *lot_container;\n\tchar id_text[256];\n\tstruct park_list_data list_data;\n\tid_text[0] = '\\0';\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(id_text, sizeof(id_text), \"ActionID: %s\\r\\n\", id);\n\t}\n\tlot_container = get_parking_lot_container();\n\tif (!lot_container) {\n\t\tast_log(LOG_ERROR, \"Failed to obtain parking lot list. Action canceled.\\n\");\n\t\tastman_send_error(s, m, \"Could not create parking lot list\");\n\t\treturn 0;\n\t}\n\tastman_send_listack(s, m, \"Parking lots will follow\", \"start\");\n\tlist_data.id_text = id_text;\n\tlist_data.count = 0;\n\tao2_callback_data(lot_container, OBJ_MULTIPLE | OBJ_NODATA,\n\t\tmanager_append_event_parking_lot_data_cb, s, &list_data);\n\tastman_send_list_complete_start(s, m, \"ParkinglotsComplete\", list_data.count);\n\tastman_send_list_complete_end(s);\n\treturn 0;\n}\n", "bug_type": null, "idx": 381}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct chan_list *get_chan_by_ast_name(const char *name)\n{\n\tstruct chan_list *tmp;\n\tast_mutex_lock(&cl_te_lock);\n\tfor (tmp = cl_te; tmp; tmp = tmp->next) {\n\t\tif (tmp->ast && strcmp(ast_channel_name(tmp->ast), name) == 0) {\n\t\t\tchan_list_ref(tmp, \"Found chan_list by ast name\");\n\t\t\tast_mutex_unlock(&cl_te_lock);\n\t\t\treturn tmp;\n\t\t}\n\t}\n\tast_mutex_unlock(&cl_te_lock);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 382}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic void queue_set_param(struct call_queue *q, const char *param, const char *val, int linenum, int failunknown)\n{\n\tif (!strcasecmp(param, \"musicclass\") ||\n\t\t!strcasecmp(param, \"music\") || !strcasecmp(param, \"musiconhold\")) {\n\t\tast_string_field_set(q, moh, val);\n\t} else if (!strcasecmp(param, \"announce\")) {\n\t\tast_string_field_set(q, announce, val);\n\t} else if (!strcasecmp(param, \"context\")) {\n\t\tast_string_field_set(q, context, val);\n\t} else if (!strcasecmp(param, \"timeout\")) {\n\t\tq->timeout = atoi(val);\n\t\tif (q->timeout < 0) {\n\t\t\tq->timeout = DEFAULT_TIMEOUT;\n\t\t}\n\t} else if (!strcasecmp(param, \"ringinuse\")) {\n\t\tq->ringinuse = ast_true(val);\n\t} else if (!strcasecmp(param, \"setinterfacevar\")) {\n\t\tq->setinterfacevar = ast_true(val);\n\t} else if (!strcasecmp(param, \"setqueuevar\")) {\n\t\tq->setqueuevar = ast_true(val);\n\t} else if (!strcasecmp(param, \"setqueueentryvar\")) {\n\t\tq->setqueueentryvar = ast_true(val);\n\t} else if (!strcasecmp(param, \"monitor-format\")) {\n\t\tast_copy_string(q->monfmt, val, sizeof(q->monfmt));\n\t} else if (!strcasecmp(param, \"membermacro\")) {\n\t\tast_string_field_set(q, membermacro, val);\n\t} else if (!strcasecmp(param, \"membergosub\")) {\n\t\tast_string_field_set(q, membergosub, val);\n\t} else if (!strcasecmp(param, \"queue-youarenext\")) {\n\t\tast_string_field_set(q, sound_next, val);\n\t} else if (!strcasecmp(param, \"queue-thereare\")) {\n\t\tast_string_field_set(q, sound_thereare, val);\n\t} else if (!strcasecmp(param, \"queue-callswaiting\")) {\n\t\tast_string_field_set(q, sound_calls, val);\n\t} else if (!strcasecmp(param, \"queue-quantity1\")) {\n\t\tast_string_field_set(q, queue_quantity1, val);\n\t} else if (!strcasecmp(param, \"queue-quantity2\")) {\n\t\tast_string_field_set(q, queue_quantity2, val);\n\t} else if (!strcasecmp(param, \"queue-holdtime\")) {\n\t\tast_string_field_set(q, sound_holdtime, val);\n\t} else if (!strcasecmp(param, \"queue-minutes\")) {\n\t\tast_string_field_set(q, sound_minutes, val);\n\t} else if (!strcasecmp(param, \"queue-minute\")) {\n\t\tast_string_field_set(q, sound_minute, val);\n\t} else if (!strcasecmp(param, \"queue-seconds\")) {\n\t\tast_string_field_set(q, sound_seconds, val);\n\t} else if (!strcasecmp(param, \"queue-thankyou\")) {\n\t\tast_string_field_set(q, sound_thanks, val);\n\t} else if (!strcasecmp(param, \"queue-callerannounce\")) {\n\t\tast_string_field_set(q, sound_callerannounce, val);\n\t} else if (!strcasecmp(param, \"queue-reporthold\")) {\n\t\tast_string_field_set(q, sound_reporthold, val);\n\t} else if (!strcasecmp(param, \"announce-frequency\")) {\n\t\tq->announcefrequency = atoi(val);\n\t} else if (!strcasecmp(param, \"announce-to-first-user\")) {\n\t\tq->announce_to_first_user = ast_true(val);\n\t} else if (!strcasecmp(param, \"min-announce-frequency\")) {\n\t\tq->minannouncefrequency = atoi(val);\n\t\tast_debug(1, \"%s=%s for queue '%s'\\n\", param, val, q->name);\n\t} else if (!strcasecmp(param, \"announce-round-seconds\")) {\n\t\tq->roundingseconds = atoi(val);\n\t\t\n\t\tif (!(q->roundingseconds == 0 || q->roundingseconds == 5 || q->roundingseconds == 10\n\t\t\t|| q->roundingseconds == 15 || q->roundingseconds == 20 || q->roundingseconds == 30)) {\n\t\t\tif (linenum >= 0) {\n\t\t\t\tast_log(LOG_WARNING, \"'%s' isn't a valid value for %s \"\n\t\t\t\t\t\"using 0 instead for queue '%s' at line %d of queues.conf\\n\",\n\t\t\t\t\tval, param, q->name, linenum);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"'%s' isn't a valid value for %s \"\n\t\t\t\t\t\"using 0 instead for queue '%s'\\n\", val, param, q->name);\n\t\t\t}\n\t\t\tq->roundingseconds=0;\n\t\t}\n\t} else if (!strcasecmp(param, \"announce-holdtime\")) {\n\t\tif (!strcasecmp(val, \"once\")) {\n\t\t\tq->announceholdtime = ANNOUNCEHOLDTIME_ONCE;\n\t\t} else if (ast_true(val)) {\n\t\t\tq->announceholdtime = ANNOUNCEHOLDTIME_ALWAYS;\n\t\t} else {\n\t\t\tq->announceholdtime = 0;\n\t\t}\n\t} else if (!strcasecmp(param, \"announce-position\")) {\n\t\tif (!strcasecmp(val, \"limit\")) {\n\t\t\tq->announceposition = ANNOUNCEPOSITION_LIMIT;\n\t\t} else if (!strcasecmp(val, \"more\")) {\n\t\t\tq->announceposition = ANNOUNCEPOSITION_MORE_THAN;\n\t\t} else if (ast_true(val)) {\n\t\t\tq->announceposition = ANNOUNCEPOSITION_YES;\n\t\t} else {\n\t\t\tq->announceposition = ANNOUNCEPOSITION_NO;\n\t\t}\n\t} else if (!strcasecmp(param, \"announce-position-only-up\")) {\n\t\tq->announceposition_only_up = ast_true(val);\n\t} else if (!strcasecmp(param, \"announce-position-limit\")) {\n\t\tq->announcepositionlimit = atoi(val);\n\t} else if (!strcasecmp(param, \"periodic-announce\")) {\n\t\tif (strchr(val, ',')) {\n\t\t\tchar *s, *buf = ast_strdupa(val);\n\t\t\tunsigned int i = 0;\n\t\t\twhile ((s = strsep(&buf, \",|\"))) {\n\t\t\t\tif (!q->sound_periodicannounce[i]) {\n\t\t\t\t\tq->sound_periodicannounce[i] = ast_str_create(16);\n\t\t\t\t}\n\t\t\t\tast_str_set(&q->sound_periodicannounce[i], 0, \"%s\", s);\n\t\t\t\ti++;\n\t\t\t\tif (i == MAX_PERIODIC_ANNOUNCEMENTS) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq->numperiodicannounce = i;\n\t\t} else {\n\t\t\tast_str_set(&q->sound_periodicannounce[0], 0, \"%s\", val);\n\t\t\tq->numperiodicannounce = 1;\n\t\t}\n\t} else if (!strcasecmp(param, \"periodic-announce-frequency\")) {\n\t\tq->periodicannouncefrequency = atoi(val);\n\t} else if (!strcasecmp(param, \"relative-periodic-announce\")) {\n\t\tq->relativeperiodicannounce = ast_true(val);\n\t} else if (!strcasecmp(param, \"random-periodic-announce\")) {\n\t\tq->randomperiodicannounce = ast_true(val);\n\t} else if (!strcasecmp(param, \"retry\")) {\n\t\tq->retry = atoi(val);\n\t\tif (q->retry <= 0) {\n\t\t\tq->retry = DEFAULT_RETRY;\n\t\t}\n\t} else if (!strcasecmp(param, \"wrapuptime\")) {\n\t\tq->wrapuptime = atoi(val);\n\t} else if (!strcasecmp(param, \"penaltymemberslimit\")) {\n\t\tif ((sscanf(val, \"%10d\", &q->penaltymemberslimit) != 1)) {\n\t\t\tq->penaltymemberslimit = 0;\n\t\t}\n\t} else if (!strcasecmp(param, \"autofill\")) {\n\t\tq->autofill = ast_true(val);\n\t} else if (!strcasecmp(param, \"monitor-type\")) {\n\t\tif (!strcasecmp(val, \"mixmonitor\")) {\n\t\t\tq->montype = 1;\n\t\t}\n\t} else if (!strcasecmp(param, \"autopause\")) {\n\t\tq->autopause = autopause2int(val);\n\t} else if (!strcasecmp(param, \"autopausedelay\")) {\n\t\tq->autopausedelay = atoi(val);\n\t} else if (!strcasecmp(param, \"autopausebusy\")) {\n\t\tq->autopausebusy = ast_true(val);\n\t} else if (!strcasecmp(param, \"autopauseunavail\")) {\n\t\tq->autopauseunavail = ast_true(val);\n\t} else if (!strcasecmp(param, \"maxlen\")) {\n\t\tq->maxlen = atoi(val);\n\t\tif (q->maxlen < 0) {\n\t\t\tq->maxlen = 0;\n\t\t}\n\t} else if (!strcasecmp(param, \"servicelevel\")) {\n\t\tq->servicelevel= atoi(val);\n\t} else if (!strcasecmp(param, \"strategy\")) {\n\t\tint strategy;\n\t\t\n\t\tif (failunknown) {\n\t\t\treturn;\n\t\t}\n\t\tstrategy = strat2int(val);\n\t\tif (strategy < 0) {\n\t\t\tast_log(LOG_WARNING, \"'%s' isn't a valid strategy for queue '%s', using ringall instead\\n\",\n\t\t\t\tval, q->name);\n\t\t\tq->strategy = QUEUE_STRATEGY_RINGALL;\n\t\t}\n\t\tif (strategy == q->strategy) {\n\t\t\treturn;\n\t\t}\n\t\tif (strategy == QUEUE_STRATEGY_LINEAR) {\n\t\t\tast_log(LOG_WARNING, \"Changing to the linear strategy currently requires asterisk to be restarted.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tq->strategy = strategy;\n\t} else if (!strcasecmp(param, \"joinempty\")) {\n\t\tparse_empty_options(val, &q->joinempty, 1);\n\t} else if (!strcasecmp(param, \"leavewhenempty\")) {\n\t\tparse_empty_options(val, &q->leavewhenempty, 0);\n\t} else if (!strcasecmp(param, \"reportholdtime\")) {\n\t\tq->reportholdtime = ast_true(val);\n\t} else if (!strcasecmp(param, \"memberdelay\")) {\n\t\tq->memberdelay = atoi(val);\n\t} else if (!strcasecmp(param, \"weight\")) {\n\t\tq->weight = atoi(val);\n\t} else if (!strcasecmp(param, \"timeoutrestart\")) {\n\t\tq->timeoutrestart = ast_true(val);\n\t} else if (!strcasecmp(param, \"defaultrule\")) {\n\t\tast_string_field_set(q, defaultrule, val);\n\t} else if (!strcasecmp(param, \"timeoutpriority\")) {\n\t\tif (!strcasecmp(val, \"conf\")) {\n\t\t\tq->timeoutpriority = TIMEOUT_PRIORITY_CONF;\n\t\t} else {\n\t\t\tq->timeoutpriority = TIMEOUT_PRIORITY_APP;\n\t\t}\n\t} else if (failunknown) {\n\t\tif (linenum >= 0) {\n\t\t\tast_log(LOG_WARNING, \"Unknown keyword in queue '%s': %s at line %d of queues.conf\\n\",\n\t\t\t\tq->name, param, linenum);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown keyword in queue '%s': %s\\n\", q->name, param);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 383}
{"project": "Asterisk", "target": 0, "func": "void te_lib_destroy(int midev)\n{\n\tchar buf[1024];\n\tmISDN_write_frame(midev, buf, 0, MGR_DELENTITY | REQUEST, entity, 0, NULL, TIMEOUT_1SEC);\n\tcb_log(4, 0, \"Entity deleted\\n\");\n\tmISDN_close(midev);\n\tcb_log(4, 0, \"midev closed\\n\");\n}\n", "bug_type": null, "idx": 384}
{"project": "Asterisk", "target": 0, "func": "int ast_sched_replace_variable(int old_id, struct ast_sched_context *con, int when, ast_sched_cb callback, const void *data, int variable)\n{\n\t\n\tif (old_id > 0) {\n\t\tAST_SCHED_DEL(con, old_id);\n\t}\n\treturn ast_sched_add_variable(con, when, callback, data, variable);\n}\n", "bug_type": null, "idx": 385}
{"project": "Asterisk", "target": 0, "func": "\nstatic int multicast_rtp_activate(struct ast_rtp_instance *instance)\n{\n\tstruct multicast_rtp *multicast = ast_rtp_instance_get_data(instance);\n\tif (multicast->type != MULTICAST_TYPE_LINKSYS) {\n\t\treturn 0;\n\t}\n\treturn multicast_send_control_packet(instance, multicast, LINKSYS_MCAST_STARTCMD);\n}\n", "bug_type": null, "idx": 386}
{"project": "Asterisk", "target": 0, "func": "\nstatic int queue_function_mem_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tint memvalue;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(queuename);\n\t\tAST_APP_ARG(option);\n\t\tAST_APP_ARG(interface);\n\t);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_ERROR,\n\t\t\t\"Missing required argument. %s([<queuename>],<option>,<interface>)\\n\",\n\t\t\tcmd);\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.option)\n\t\t|| ast_strlen_zero(args.interface)) {\n\t\tast_log(LOG_ERROR,\n\t\t\t\"Missing required argument. %s([<queuename>],<option>,<interface>)\\n\",\n\t\t\tcmd);\n\t\treturn -1;\n\t}\n\t\n\tmemvalue = atoi(value);\n\tif (!strcasecmp(args.option, \"penalty\")) {\n\t\tif (set_member_value(args.queuename, args.interface, MEMBER_PENALTY, memvalue)) {\n\t\t\tast_log(LOG_ERROR, \"Invalid interface, queue, or penalty\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcasecmp(args.option, \"paused\")) {\n\t\tmemvalue = (memvalue <= 0) ? 0 : 1;\n\t\tif (set_member_paused(args.queuename, args.interface, NULL, memvalue)) {\n\t\t\tast_log(LOG_ERROR, \"Invalid interface or queue\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcasecmp(args.option, \"ignorebusy\") \n\t\t|| !strcasecmp(args.option, \"ringinuse\")) {\n\t\tmemvalue = (memvalue <= 0) ? 0 : 1;\n\t\tif (set_member_value(args.queuename, args.interface, MEMBER_RINGINUSE, memvalue)) {\n\t\t\tast_log(LOG_ERROR, \"Invalid interface or queue\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tast_log(LOG_ERROR, \"%s: Invalid option '%s' provided.\\n\", cmd, args.option);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 387}
{"project": "Asterisk", "target": 0, "func": "static struct aco_type *internal_aco_type_find(struct aco_file *file, struct ast_config *cfg, const char *category)\n{\n\tsize_t x;\n\tstruct aco_type *match;\n\tconst char *val;\n\tfor (x = 0, match = file->types[x]; match; match = file->types[++x]) {\n\t\t\n\t\tif (!regexec(match->internal->regex, category, 0, NULL, 0) == !match->category_match) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!ast_strlen_zero(match->matchfield) && (!ast_strlen_zero(match->matchvalue) || match->matchfunc)) {\n\t\t\tif (!(val = ast_variable_retrieve(cfg, category, match->matchfield))) {\n\t\t\t\tast_log(LOG_ERROR, \"Required match field '%s' not found\\n\", match->matchfield);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (match->matchfunc) {\n\t\t\t\tif (!match->matchfunc(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (strcasecmp(val, match->matchvalue)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tbreak;\n\t}\n\treturn match;\n}\n", "bug_type": null, "idx": 388}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_set_outbound_proxy(pjsip_tx_data *tdata, const char *proxy)\n{\n\tpjsip_route_hdr *route;\n\tstatic const pj_str_t ROUTE_HNAME = { \"Route\", 5 };\n\tpj_str_t tmp;\n\tpj_strdup2_with_null(tdata->pool, &tmp, proxy);\n\tif (!(route = pjsip_parse_hdr(tdata->pool, &ROUTE_HNAME, tmp.ptr, tmp.slen, NULL))) {\n\t\treturn -1;\n\t}\n\tpj_list_insert_nodes_before(&tdata->msg->hdr, (pjsip_hdr*)route);\n\treturn 0;\n}\n", "bug_type": null, "idx": 389}
{"project": "Asterisk", "target": 0, "func": "\nstatic int line_identify_relationship(void *obj, void *arg, int flags)\n{\n\tstruct sip_outbound_registration_state *state = obj;\n\tpjsip_param *line = arg;\n\treturn !pj_strcmp2(&line->value, state->client_state->line) ? CMP_MATCH : 0;\n}\n", "bug_type": null, "idx": 390}
{"project": "Asterisk", "target": 0, "func": "static int sorcery_test_is_stale(const struct ast_sorcery *sorcery, void *data, void *object)\n{\n\tcache.is_stale = 1;\n\treturn 1;\n}\n", "bug_type": null, "idx": 391}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_hangupcause(const struct ast_channel *chan)\n{\n\treturn chan->hangupcause;\n}\n", "bug_type": null, "idx": 392}
{"project": "Asterisk", "target": 0, "func": "\nstatic int bridge_show_specific_print_channel(void *obj, void *arg, int flags)\n{\n\tconst char *uniqueid = obj;\n\tstruct ast_cli_args *a = arg;\n\tRAII_VAR(struct stasis_message *, msg, NULL, ao2_cleanup);\n\tstruct ast_channel_snapshot *snapshot;\n\tmsg = stasis_cache_get(ast_channel_cache(), ast_channel_snapshot_type(), uniqueid);\n\tif (!msg) {\n\t\treturn 0;\n\t}\n\tsnapshot = stasis_message_data(msg);\n\tast_cli(a->fd, \"Channel: %s\\n\", snapshot->name);\n\treturn 0;\n}\n", "bug_type": null, "idx": 393}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225GatekeeperInfo (OOCTXT* pctxt, H225GatekeeperInfo* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.nonStandardDataPresent);\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      stat = asn1PE_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 394}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_config *realtime_sqlite3_multi(const char *database, const char *table, const struct ast_variable *fields)\n{\n\tstruct ast_config *cfg;\n\tif (!(cfg = ast_config_new())) {\n\t\treturn NULL;\n\t}\n\tif (realtime_sqlite3_helper(database, table, fields, 1, cfg)) {\n\t\tast_config_destroy(cfg);\n\t\treturn NULL;\n\t}\n\treturn cfg;\n}\n", "bug_type": null, "idx": 395}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int iax_provision_init(void)\n{\n\tast_cli_register_multiple(cli_iax2_provision, sizeof(cli_iax2_provision) / sizeof(struct ast_cli_entry));\n\tprovinit = 1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 396}
{"project": "Asterisk", "target": 0, "func": "static void *user_profile_find(struct ao2_container *container, const char *category)\n{\n\treturn ao2_find(container, category, OBJ_KEY);\n}\n", "bug_type": null, "idx": 397}
{"project": "Asterisk", "target": 0, "func": "static void consumer_finalize(void *data, struct stasis_subscription *sub, struct stasis_message *message)\n{\n\tstruct consumer *consumer = data;\n\tif (stasis_subscription_final_message(sub, message)) {\n\t\tao2_cleanup(consumer);\n\t}\n}\n", "bug_type": null, "idx": 398}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int payload_helper_park(ast_bridge_channel_post_action_data post_it,\n\tstruct ast_bridge_channel *bridge_channel,\n\tconst char *parkee_uuid,\n\tconst char *parker_uuid,\n\tconst char *app_data)\n{\n\tstruct bridge_park *payload;\n\tsize_t len_parkee_uuid = strlen(parkee_uuid) + 1;\n\tsize_t len_parker_uuid = strlen(parker_uuid) + 1;\n\tsize_t len_app_data = !app_data ? 0 : strlen(app_data) + 1;\n\tsize_t len_payload = sizeof(*payload) + len_parker_uuid + len_parkee_uuid + len_app_data;\n\tpayload = alloca(len_payload);\n\tpayload->app_data_offset = len_app_data ? len_parkee_uuid + len_parker_uuid : 0;\n\tpayload->parker_uuid_offset = len_parkee_uuid;\n\tstrcpy(payload->parkee_uuid, parkee_uuid);\n\tstrcpy(&payload->parkee_uuid[payload->parker_uuid_offset], parker_uuid);\n\tif (app_data) {\n\t\tstrcpy(&payload->parkee_uuid[payload->app_data_offset], app_data);\n\t}\n\treturn post_it(bridge_channel, BRIDGE_CHANNEL_ACTION_PARK, payload, len_payload);\n}\n", "bug_type": null, "idx": 399}
{"project": "Asterisk", "target": 0, "func": " \nstruct ao2_container *ast_str_container_alloc_options(enum ao2_alloc_opts opts, int buckets)\n{\n\treturn ao2_container_alloc_hash(opts, 0, buckets, str_hash, str_sort, str_cmp);\n}\n", "bug_type": null, "idx": 400}
{"project": "Asterisk", "target": 0, "func": "static unsigned int name_sequence = 0;\nstatic int rec_call(struct ast_channel *chan, const char *addr, int timeout)\n{\n\t\n\treturn -1;\n}\n", "bug_type": null, "idx": 401}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *create_object(const struct ast_sorcery *sorcery,\n\tconst char *id, const char *type, struct ast_variable *vars)\n{\n\tstruct ast_sorcery_object *obj = ast_sorcery_alloc(sorcery, type, id);\n\tif (!obj) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate an object of type '%s' with id '%s'.\\n\", type, id);\n\t\treturn NULL;\n\t}\n\tif (ast_sorcery_objectset_apply(sorcery, obj, vars)) {\n\t\tast_log(LOG_ERROR, \"Unable to apply object type '%s' with id '%s'.  Check preceeding errors.\\n\", type, id);\n\t\tao2_ref(obj, -1);\n\t\treturn NULL;\n\t}\n\treturn obj;\n}\n", "bug_type": null, "idx": 402}
{"project": "Asterisk", "target": 0, "func": "static void handle_about(GtkWidget *w, gpointer data)\n{\n\tGtkWidget *dialog;\n\tdialog = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_MODAL,\n\t\t\t\tGTK_MESSAGE_INFO, GTK_BUTTONS_OK,\n\t\t\t\t\"GMenuselect - http://www.asterisk.org/\\n\"\n\t\t\t\t\"Russell Bryant <russell@digium.com>\\n\"\n\t\t\t\t\"Copyright (C) 2007\\n\");\n\tgtk_dialog_run(GTK_DIALOG(dialog));\n\tgtk_widget_destroy(dialog);\n}\n", "bug_type": null, "idx": 403}
{"project": "Asterisk", "target": 0, "func": "struct stasis_cache *stasis_cp_all_cache(struct stasis_cp_all *all)\n{\n\tif (!all) {\n\t\treturn NULL;\n\t}\n\treturn all->cache;\n}\n", "bug_type": null, "idx": 404}
{"project": "Asterisk", "target": 0, "func": "\nstatic int unbound_resolver_start(struct unbound_resolver *resolver)\n{\n\tint res;\n\tif (resolver->thread != AST_PTHREADT_NULL) {\n\t\treturn 0;\n\t}\n\tast_debug(1, \"Starting thread for unbound resolver\\n\");\n\tres = ast_pthread_create(&resolver->thread, NULL, unbound_resolver_thread, ao2_bump(resolver));\n\tif (res) {\n\t\tast_debug(1, \"Could not start thread for unbound resolver\\n\");\n\t\tao2_ref(resolver, -1);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 405}
{"project": "Asterisk", "target": 0, "func": "void misdn_lib_log_ies(struct misdn_bchannel *bc)\n{\n\tstruct misdn_stack *stack;\n\tif (!bc) return;\n\tstack = get_stack_by_bc(bc);\n\tif (!stack) return;\n\tcb_log(2, stack->port,\n\t\t\" --> channel:%d mode:%s cause:%d ocause:%d\\n\",\n\t\tbc->channel,\n\t\tstack->nt ? \"NT\" : \"TE\",\n\t\tbc->cause,\n\t\tbc->out_cause);\n\tcb_log(2, stack->port,\n\t\t\" --> info_dad:%s dialed numtype:%d plan:%d\\n\",\n\t\tbc->info_dad,\n\t\tbc->dialed.number_type,\n\t\tbc->dialed.number_plan);\n\tcb_log(2, stack->port,\n\t\t\" --> caller:\\\"%s\\\" <%s> type:%d plan:%d pres:%d screen:%d\\n\",\n\t\tbc->caller.name,\n\t\tbc->caller.number,\n\t\tbc->caller.number_type,\n\t\tbc->caller.number_plan,\n\t\tbc->caller.presentation,\n\t\tbc->caller.screening);\n\tcb_log(2, stack->port,\n\t\t\" --> redirecting-from:\\\"%s\\\" <%s> type:%d plan:%d pres:%d screen:%d\\n\",\n\t\tbc->redirecting.from.name,\n\t\tbc->redirecting.from.number,\n\t\tbc->redirecting.from.number_type,\n\t\tbc->redirecting.from.number_plan,\n\t\tbc->redirecting.from.presentation,\n\t\tbc->redirecting.from.screening);\n\tcb_log(2, stack->port,\n\t\t\" --> redirecting-to:\\\"%s\\\" <%s> type:%d plan:%d pres:%d screen:%d\\n\",\n\t\tbc->redirecting.to.name,\n\t\tbc->redirecting.to.number,\n\t\tbc->redirecting.to.number_type,\n\t\tbc->redirecting.to.number_plan,\n\t\tbc->redirecting.to.presentation,\n\t\tbc->redirecting.to.screening);\n\tcb_log(2, stack->port,\n\t\t\" --> redirecting reason:%d count:%d\\n\",\n\t\tbc->redirecting.reason,\n\t\tbc->redirecting.count);\n\tcb_log(2, stack->port,\n\t\t\" --> connected:\\\"%s\\\" <%s> type:%d plan:%d pres:%d screen:%d\\n\",\n\t\tbc->connected.name,\n\t\tbc->connected.number,\n\t\tbc->connected.number_type,\n\t\tbc->connected.number_plan,\n\t\tbc->connected.presentation,\n\t\tbc->connected.screening);\n\tcb_log(3, stack->port, \" --> caps:%s pi:%x keypad:%s sending_complete:%d\\n\", bearer2str(bc->capability),bc->progress_indicator, bc->keypad, bc->sending_complete);\n\tcb_log(4, stack->port, \" --> set_pres:%d pres:%d\\n\", bc->set_presentation, bc->presentation);\n\tcb_log(4, stack->port, \" --> addr:%x l3id:%x b_stid:%x layer_id:%x\\n\", bc->addr, bc->l3_id, bc->b_stid, bc->layer_id);\n\tcb_log(4, stack->port, \" --> facility in:%s out:%s\\n\", fac2str(bc->fac_in.Function), fac2str(bc->fac_out.Function));\n\tcb_log(5, stack->port, \" --> urate:%d rate:%d mode:%d user1:%d\\n\", bc->urate, bc->rate, bc->mode,bc->user1);\n\tcb_log(5, stack->port, \" --> bc:%p h:%d sh:%d\\n\", bc, bc->holded, bc->stack_holder);\n}\n", "bug_type": null, "idx": 406}
{"project": "Asterisk", "target": 0, "func": "static char *cli_show_subscription_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\ton_subscription_t on_subscription;\n\tstruct cli_sub_parms cli;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"pjsip show subscription {inbound|outbound}\";\n\t\te->usage = \"Usage:\\n\"\n\t\t\t\t   \"   pjsip show subscription inbound <call-id>\\n\"\n\t\t\t\t   \"   pjsip show subscription outbound <call-id>\\n\"\n\t\t\t\t   \"      Show active subscription with the dialog call-id\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn cli_complete_subscription_callid(a);\n\t}\n\tif (a->argc != 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (!strcasecmp(a->argv[3], \"inbound\")) {\n\t\ton_subscription = cli_show_subscription_inbound;\n\t} else if (!strcasecmp(a->argv[3], \"outbound\")) {\n\t\ton_subscription = cli_show_subscription_outbound;\n\t} else {\n\t\t\n\t\tast_assert(0);\n\t\treturn NULL;\n\t}\n\t\n\tcli.a = a;\n\tcli.e = e;\n\tcli.buf = (void *) a->argv[4];\n\tfor_each_subscription(on_subscription, &cli);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 407}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225LocationRejectReason (OOCTXT* pctxt, H225LocationRejectReason* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 4);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 3);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            \n            break;\n         \n         case 2:\n            \n            break;\n         \n         case 3:\n            \n            break;\n         \n         case 4:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 5);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 5:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 6:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 7:\n            stat = asn1PE_H225_SeqOfH225PartyNumber (&lctxt, pvalue->u.routeCalltoSCN);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 8:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 9:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 10:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 11:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 12:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 13:\n            stat = asn1PE_H225SecurityErrors2 (&lctxt, pvalue->u.securityError);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 14:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 15:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 16:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 408}
{"project": "Asterisk", "target": 0, "func": "static u_char *ast_var_channel_bridge(struct variable *vp, oid *name, size_t *length,\n\tint exact, size_t *var_len, WriteMethod **write_method)\n{\n\tstatic unsigned long long_ret;\n\tstruct ast_channel *chan = NULL;\n\tstruct ast_channel_iterator *iter;\n\tlong_ret = 0;\n\tif (header_generic(vp, name, length, exact, var_len, write_method)) {\n\t\treturn NULL;\n\t}\n\tif (!(iter = ast_channel_iterator_all_new())) {\n\t\treturn NULL;\n\t}\n\twhile ((chan = ast_channel_iterator_next(iter))) {\n\t\tast_channel_lock(chan);\n\t\tif (ast_channel_is_bridged(chan)) {\n\t\t\tlong_ret++;\n\t\t}\n\t\tast_channel_unlock(chan);\n\t\tchan = ast_channel_unref(chan);\n\t}\n\tast_channel_iterator_destroy(iter);\n\t*var_len = sizeof(long_ret);\n\treturn (vp->magic == ASTCHANBRIDGECOUNT) ? (u_char *) &long_ret : NULL;\n}\n", "bug_type": null, "idx": 409}
{"project": "Asterisk", "target": 0, "func": "OOStkCmdStat ooRequestChangeMode(const char *callToken, int isT38Mode)\n{\n   OOStackCommand cmd;\n   OOH323CallData *call;\n   if(!callToken)\n   {\n      return OO_STKCMD_INVALIDPARAM;\n   }\n   if(!(call = ooFindCallByToken(callToken))) {\n      return OO_STKCMD_INVALIDPARAM;\n   }\n   if(call->CmdChan == 0)\n   {\n      if(ooCreateCallCmdConnection(call) != OO_OK)\n         return OO_STKCMD_CONNECTIONERR;\n   }\n   memset(&cmd, 0, sizeof(OOStackCommand));\n   cmd.type = OO_CMD_REQMODE;\n   cmd.param1 = ast_malloc(strlen(callToken)+1);\n   cmd.param2 = ast_malloc(sizeof(int));\n   if(!cmd.param1 || !cmd.param2)\n   {\n      ast_free(cmd.param1); \n      ast_free(cmd.param2);\n      return OO_STKCMD_MEMERR;\n   }\n   strcpy((char*)cmd.param1, callToken);\n   cmd.plen1 = strlen(callToken);\n   *((int *) cmd.param2) = isT38Mode;\n   cmd.plen2 = sizeof(int);\n   if(ooWriteCallStackCommand(call,&cmd) != OO_OK)\n   {\n      ast_free(cmd.param1);\n      ast_free(cmd.param2);\n      return OO_STKCMD_WRITEERR;\n   }\n   ast_free(cmd.param1);\n   ast_free(cmd.param2);\n   return OO_STKCMD_SUCCESS;\n}\n", "bug_type": null, "idx": 410}
{"project": "Asterisk", "target": 0, "func": "static struct robin_list *robin = NULL;\nstatic void free_robin_list(void)\n{\n\tstruct robin_list *r;\n\tstruct robin_list *next;\n\tfor (r = robin, robin = NULL; r; r = next) {\n\t\tnext = r->next;\n\t\tast_free(r->group);\n\t\tast_free(r);\n\t}\n}\n", "bug_type": null, "idx": 411}
{"project": "Asterisk", "target": 0, "func": "int __attribute__((format(printf,1,2))) error( const char *format, ...)\n{\n    va_list ap;\n    int result;\n    va_start( ap, format);\n    result = vfprintf( stderr, format, ap);\n    va_end( ap);\n    return result;\n}\n", "bug_type": null, "idx": 412}
{"project": "Asterisk", "target": 0, "func": "struct ast_namedgroups *ast_unref_namedgroups(struct ast_namedgroups *groups)\n{\n\tao2_cleanup(groups);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 413}
{"project": "Asterisk", "target": 0, "func": "static int dtlsprivatekey_to_str(const void *obj, const intptr_t *args, char **buf)\n{\n\tconst struct ast_sip_endpoint *endpoint = obj;\n\t*buf = ast_strdup(endpoint->media.rtp.dtls_cfg.pvtfile);\n\treturn 0;\n}\n", "bug_type": null, "idx": 414}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *rtp_ice_wrap_get_local_candidates(struct ast_rtp_instance *instance)\n{\n\tstruct ao2_container *local_candidates;\n\tao2_lock(instance);\n\tlocal_candidates = instance->engine->ice->get_local_candidates(instance);\n\tao2_unlock(instance);\n\treturn local_candidates;\n}\n", "bug_type": null, "idx": 415}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int load_module(void)\n{\n\tstruct ast_flags config_flags = { 0 };\n\tstruct ast_config *cfg = ast_config_load(FESTIVAL_CONFIG, config_flags);\n\tif (!cfg) {\n\t\tast_log(LOG_WARNING, \"No such configuration file %s\\n\", FESTIVAL_CONFIG);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Config file \" FESTIVAL_CONFIG \" is in an invalid format.  Aborting.\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_config_destroy(cfg);\n\treturn ast_register_application_xml(app, festival_exec);\n}\n", "bug_type": null, "idx": 416}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void *sorcery_memory_cache_retrieve_id(const struct ast_sorcery *sorcery, void *data, const char *type, const char *id)\n{\n\tstruct sorcery_memory_cache *cache = data;\n\tstruct sorcery_memory_cached_object *cached;\n\tvoid *object;\n\tif (is_passthru_update()) {\n\t\treturn NULL;\n\t}\n\tmemory_cache_full_update(sorcery, type, cache);\n\tcached = ao2_find(cache->objects, id, OBJ_SEARCH_KEY);\n\tif (!cached) {\n\t\treturn NULL;\n\t}\n\tast_assert(!strcmp(ast_sorcery_object_get_id(cached->object), id));\n\tmemory_cache_stale_check_object(sorcery, cache, cached);\n\tobject = ao2_bump(cached->object);\n\tao2_ref(cached, -1);\n\treturn object;\n}\n", "bug_type": null, "idx": 417}
{"project": "Asterisk", "target": 0, "func": "static pj_bool_t logging_on_rx_msg(pjsip_rx_data *rdata)\n{\n\tif (!pjsip_log_test_addr(rdata->pkt_info.src_name, rdata->pkt_info.src_port)) {\n\t\treturn PJ_FALSE;\n\t}\n\tif (!rdata->msg_info.msg) {\n\t\treturn PJ_FALSE;\n\t}\n\tast_verbose(\"<--- Received SIP %s (%d bytes) from %s:%s:%d --->\\n%s\\n\",\n\t\t    rdata->msg_info.msg->type == PJSIP_REQUEST_MSG ? \"request\" : \"response\",\n\t\t    rdata->msg_info.len,\n\t\t    rdata->tp_info.transport->type_name,\n\t\t    rdata->pkt_info.src_name,\n\t\t    rdata->pkt_info.src_port,\n\t\t    rdata->pkt_info.packet);\n\treturn PJ_FALSE;\n}\n", "bug_type": null, "idx": 418}
{"project": "Asterisk", "target": 0, "func": "int\nhistory_search_prefix(const char *str, int direction)\n{\n\treturn (_history_search_gen(str, direction, 0));\n}\n", "bug_type": null, "idx": 419}
{"project": "Asterisk", "target": 0, "func": "static int app_control_can_remove_channel_from_bridge(\n\tstruct stasis_app_control *control)\n{\n\treturn app_control_check_rules(control, &control->remove_rules);\n}\n", "bug_type": null, "idx": 420}
{"project": "Asterisk", "target": 0, "func": "static off_t slinear_tell(struct ast_filestream *fs)\n{\n\treturn ftello(fs->f) / 2;\n}\n", "bug_type": null, "idx": 421}
{"project": "Asterisk", "target": 0, "func": "#define BYTES_TO_SAMPLES(x)\t((typeof(x)) x * ((float) 640 / 120))\nstatic struct ast_frame *siren14read(struct ast_filestream *s, int *whennext)\n{\n\tsize_t res;\n\t\n\tAST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, BUF_SIZE);\n\tif ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {\n\t\tif (res) {\n\t\t\tast_log(LOG_WARNING, \"Short read of %s data (expected %d bytes, read %zu): %s\\n\",\n\t\t\t\t\tast_format_get_name(s->fr.subclass.format), s->fr.datalen, res,\n\t\t\t\t\tstrerror(errno));\n\t\t}\n\t\treturn NULL;\n\t}\n\t*whennext = s->fr.samples = BYTES_TO_SAMPLES(res);\n\treturn &s->fr;\n}\n", "bug_type": null, "idx": 422}
{"project": "Asterisk", "target": 0, "func": "struct stasis_topic *stasis_cp_single_topic(struct stasis_cp_single *one)\n{\n\tif (!one) {\n\t\treturn NULL;\n\t}\n\treturn one->topic;\n}\n", "bug_type": null, "idx": 423}
{"project": "Asterisk", "target": 0, "func": "static int policy_hash_fn(const void *obj, const int flags)\n{\n\tconst struct ast_srtp_policy *policy = obj;\n\treturn policy->sp.ssrc.type == ssrc_specific ? policy->sp.ssrc.value : policy->sp.ssrc.type;\n}\n", "bug_type": null, "idx": 424}
{"project": "Asterisk", "target": 0, "func": "static AST_RWLIST_HEAD_STATIC(apps, ast_app);\nstatic struct ast_app *pbx_findapp_nolock(const char *name)\n{\n\tstruct ast_app *cur;\n\tint cmp;\n\tAST_RWLIST_TRAVERSE(&apps, cur, list) {\n\t\tcmp = strcasecmp(name, cur->name);\n\t\tif (cmp > 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!cmp) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcur = NULL;\n\t\tbreak;\n\t}\n\treturn cur;\n}\n", "bug_type": null, "idx": 425}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_core_show_file_formats(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n#define FORMAT \"%-10s %-10s %-20s\\n\"\n#define FORMAT2 \"%-10s %-10s %-20s\\n\"\n\tstruct ast_format_def *f;\n\tint count_fmt = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"core show file formats\";\n\t\te->usage =\n\t\t\t\"Usage: core show file formats\\n\"\n\t\t\t\"       Displays currently registered file formats (if any).\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4)\n\t\treturn CLI_SHOWUSAGE;\n\tast_cli(a->fd, FORMAT, \"Format\", \"Name\", \"Extensions\");\n\tast_cli(a->fd, FORMAT, \"------\", \"----\", \"----------\");\n\tAST_RWLIST_RDLOCK(&formats);\n\tAST_RWLIST_TRAVERSE(&formats, f, list) {\n\t\tast_cli(a->fd, FORMAT2, ast_format_get_name(f->format), f->name, f->exts);\n\t\tcount_fmt++;\n\t}\n\tAST_RWLIST_UNLOCK(&formats);\n\tast_cli(a->fd, \"%d file formats registered.\\n\", count_fmt);\n\treturn CLI_SUCCESS;\n#undef FORMAT\n#undef FORMAT2\n}\n", "bug_type": null, "idx": 426}
{"project": "Asterisk", "target": 0, "func": "static int format_ami_endpoint_transport(const struct ast_sip_endpoint *endpoint,\n\t\t\t\t\t struct ast_sip_ami *ami)\n{\n\tRAII_VAR(struct ast_str *, buf, NULL, ast_free);\n\tRAII_VAR(struct ast_sip_transport *, transport, NULL, ao2_cleanup);\n\tif (ast_strlen_zero(endpoint->transport)) {\n\t\treturn 0;\n\t}\n\tbuf = ast_sip_create_ami_event(\"TransportDetail\", ami);\n\tif (!buf) {\n\t\treturn -1;\n\t}\n\ttransport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"transport\",\n\t\tendpoint->transport);\n\tif (!transport) {\n\t\tastman_send_error_va(ami->s, ami->m, \"Unable to retrieve \"\n\t\t\t\t     \"transport %s\\n\", endpoint->transport);\n\t\treturn -1;\n\t}\n\tsip_transport_to_ami(transport, &buf);\n\tast_str_append(&buf, 0, \"EndpointName: %s\\r\\n\",\n\t\t       ast_sorcery_object_get_id(endpoint));\n\tastman_append(ami->s, \"%s\\r\\n\", ast_str_buffer(buf));\n\tami->count++;\n\treturn 0;\n}\n", "bug_type": null, "idx": 427}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245FunctionNotSupported (OOCTXT* pctxt, H245FunctionNotSupported* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.returnedFunctionPresent = optbit;\n   \n   invokeStartElement (pctxt, \"cause\", -1);\n   stat = asn1PD_H245FunctionNotSupported_cause (pctxt, &pvalue->cause);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"cause\", -1);\n   \n   if (pvalue->m.returnedFunctionPresent) {\n      invokeStartElement (pctxt, \"returnedFunction\", -1);\n      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->returnedFunction);\n      if (stat != ASN_OK) return stat;\n      invokeOctStrValue (pctxt, pvalue->returnedFunction.numocts, pvalue->returnedFunction.data);\n      invokeEndElement (pctxt, \"returnedFunction\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 428}
{"project": "Asterisk", "target": 0, "func": "AST_RWLOCK_DEFINE_STATIC(config_lock);\nconst struct ast_config *ast_calendar_config_acquire(void)\n{\n\tast_rwlock_rdlock(&config_lock);\n\tif (!calendar_config) {\n\t\tast_rwlock_unlock(&config_lock);\n\t\treturn NULL;\n\t}\n\treturn calendar_config;\n}\n", "bug_type": null, "idx": 429}
{"project": "Asterisk", "target": 0, "func": "static int ast_srtp_replace(struct ast_srtp **srtp, struct ast_rtp_instance *rtp, struct ast_srtp_policy *policy)\n{\n\tif ((*srtp) != NULL) {\n\t\tast_srtp_destroy(*srtp);\n\t}\n\treturn ast_srtp_create(srtp, rtp, policy);\n}\n", "bug_type": null, "idx": 430}
{"project": "Asterisk", "target": 0, "func": "static void app_control_unregister_rule(\n\tstruct stasis_app_control *control,\n\tstruct app_control_rules *list, struct stasis_app_control_rule *obj)\n{\n\tstruct stasis_app_control_rule *rule;\n\tSCOPED_AO2LOCK(lock, control->command_queue);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(list, rule, next) {\n\t\tif (rule == obj) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(next);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n}\n}\nstatic void app_control_unregister_rule(\n\tstruct stasis_app_control *control,\n\tstruct app_control_rules *list, struct stasis_app_control_rule *obj)\n{\n\tstruct stasis_app_control_rule *rule;\n\tSCOPED_AO2LOCK(lock, control->command_queue);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(list, rule, next) {\n\t\tif (rule == obj) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(next);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nstatic void app_control_unregister_rule(\n\tstruct stasis_app_control *control,\n\tstruct app_control_rules *list, struct stasis_app_control_rule *obj)\n{\n\tstruct stasis_app_control_rule *rule;\n\tSCOPED_AO2LOCK(lock, control->command_queue);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(list, rule, next) {\n\t\tif (rule == obj) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(next);\n\t\t\tbreak;\n\t\t}\n", "bug_type": null, "idx": 431}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_set_is_t38_active_nolock(struct ast_channel *chan, int is_t38_active)\n{\n\tchan->is_t38_active = !!is_t38_active;\n}\n", "bug_type": null, "idx": 432}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tCHECK_PJSIP_MODULE_LOADED();\n\tif (ast_sorcery_observer_add(ast_sip_get_sorcery(), \"global\", &global_observer)) {\n\t\tast_log(LOG_WARNING, \"Unable to add global observer\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tcheck_debug();\n\tast_sip_register_service(&logging_module);\n\tast_cli_register_multiple(cli_pjsip, ARRAY_LEN(cli_pjsip));\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 433}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int payload_helper_playfile(ast_bridge_channel_post_action_data post_it,\n\tstruct ast_bridge_channel *bridge_channel, ast_bridge_custom_play_fn custom_play, const char *playfile, const char *moh_class)\n{\n\tstruct bridge_playfile *payload;\n\tsize_t len_name = strlen(playfile) + 1;\n\tsize_t len_moh = !moh_class ? 0 : strlen(moh_class) + 1;\n\tsize_t len_payload = sizeof(*payload) + len_name + len_moh;\n\t\n\tpayload = ast_alloca(len_payload);\n\tpayload->custom_play = custom_play;\n\tpayload->moh_offset = len_moh ? len_name : 0;\n\tstrcpy(payload->playfile, playfile);\n\tif (moh_class) {\n\t\tstrcpy(&payload->playfile[payload->moh_offset], moh_class);\n\t}\n\treturn post_it(bridge_channel, BRIDGE_CHANNEL_ACTION_PLAY_FILE, payload, len_payload);\n}\n", "bug_type": null, "idx": 434}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct body_part *allocate_body_part(pj_pool_t *pool, const struct ast_sip_subscription *sub)\n{\n\tstruct body_part *bp;\n\tbp = ast_calloc(1, sizeof(*bp));\n\tif (!bp) {\n\t\treturn NULL;\n\t}\n\tbp->cid = generate_content_id_hdr(pool, sub);\n\tbp->resource = sub->resource;\n\tbp->state = sub->subscription_state;\n\tbp->uri = sub->uri;\n\treturn bp;\n}\n", "bug_type": null, "idx": 435}
{"project": "Asterisk", "target": 0, "func": "\nchar* errGetText (OOCTXT* pctxt)\n{\n   char lbuf[500];\n   char* pBuf = (char*) ASN1MALLOC (pctxt,\n      (sizeof(lbuf) + 100 * (2 + pctxt->errInfo.stkx)) * sizeof(char));\n   sprintf (pBuf, \"ASN.1 ERROR: Status %d\\n\", pctxt->errInfo.status);\n   sprintf (lbuf, \"%s\\nStack trace:\", errFmtMsg (&pctxt->errInfo, lbuf));\n   strcat(pBuf, lbuf);\n   while (pctxt->errInfo.stkx > 0) {\n      pctxt->errInfo.stkx--;\n      sprintf (lbuf, \"  Module: %s, Line %d\\n\", \n               pctxt->errInfo.stack[pctxt->errInfo.stkx].module,\n               pctxt->errInfo.stack[pctxt->errInfo.stkx].lineno);\n      strcat(pBuf, lbuf);\n   }\n   errFreeParms (&pctxt->errInfo);\n   return pBuf;\n}\n", "bug_type": null, "idx": 436}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void dec_ie_facility(unsigned char *p, Q931_info_t *qi, struct FacParm *fac, int nt, struct misdn_bchannel *bc)\n{\n\tfac->Function = Fac_None;\n\tif (!nt) {\n\t\tp = NULL;\n\t\tif (qi->QI_ELEMENT(facility)) {\n\t\t\tp = (unsigned char *) qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(facility) + 1;\n\t\t}\n\t}\n\tif (!p) {\n\t\treturn;\n\t}\n\tif (decodeFac(p, fac)) {\n\t\tcb_log(3, bc->port, \"Decoding facility ie failed! Unrecognized facility message?\\n\");\n\t}\n}\n", "bug_type": null, "idx": 437}
{"project": "Asterisk", "target": 0, "func": "static const char * const app = \"SendText\";\nstatic int sendtext_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *status = \"UNSUPPORTED\";\n\tstruct ast_str *str;\n\t\n\tif (!data) {\n\t\tast_log(LOG_WARNING, \"SendText requires an argument (text)\\n\");\n\t\treturn -1;\n\t}\n\tif (!(str = ast_str_alloca(strlen(data) + 1))) {\n\t\treturn -1;\n\t}\n\tast_str_get_encoded_str(&str, -1, data);\n\tast_channel_lock(chan);\n\tif (!ast_channel_tech(chan)->send_text) {\n\t\tast_channel_unlock(chan);\n\t\t\n\t\tpbx_builtin_setvar_helper(chan, \"SENDTEXTSTATUS\", status);\n\t\treturn 0;\n\t}\n\tstatus = \"FAILURE\";\n\tif (!ast_sendtext(chan, ast_str_buffer(str))) {\n\t\tstatus = \"SUCCESS\";\n\t}\n\tast_channel_unlock(chan);\n\tpbx_builtin_setvar_helper(chan, \"SENDTEXTSTATUS\", status);\n\treturn 0;\n}\n", "bug_type": null, "idx": 438}
{"project": "Asterisk", "target": 0, "func": "enum jb_return_code jb_getinfo(jitterbuf *jb, jb_info *stats)\n{\n\thistory_get(jb);\n\t*stats = jb->info;\n\treturn JB_OK;\n}\n", "bug_type": null, "idx": 439}
{"project": "Asterisk", "target": 0, "func": "static void unregister_all(void)\n{\n\tstruct ao2_container *states;\n\tstates = ao2_global_obj_ref(current_states);\n\tif (!states) {\n\t\treturn;\n\t}\n\t\n\tao2_callback(states, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);\n\tao2_ref(states, -1);\n}\n", "bug_type": null, "idx": 440}
{"project": "Asterisk", "target": 0, "func": "public void\nel_beep(EditLine *el)\n{\n\tterm_beep(el);\n}\n", "bug_type": null, "idx": 441}
{"project": "Asterisk", "target": 0, "func": "***/\nstatic int pjsip_aor_function_read(struct ast_channel *chan,\n\tconst char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\tstruct ast_sorcery *pjsip_sorcery;\n\tchar *parsed_data = ast_strdupa(data);\n\tRAII_VAR(struct ast_sip_aor *, aor_obj, NULL, ao2_cleanup);\n\tint res = 0;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(aor_name);\n\t\tAST_APP_ARG(field_name);\n\t);\n\t\n\tif (ast_strlen_zero(parsed_data)) {\n\t\tast_log(AST_LOG_ERROR, \"Cannot call %s without arguments\\n\", cmd);\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, parsed_data);\n\tif (ast_strlen_zero(args.aor_name)) {\n\t\tast_log(AST_LOG_ERROR, \"Cannot call %s without an AOR name to query\\n\", cmd);\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.field_name)) {\n\t\tast_log(AST_LOG_ERROR, \"Cannot call %s with an empty field name to query\\n\", cmd);\n\t\treturn -1;\n\t}\n\tpjsip_sorcery = ast_sip_get_sorcery();\n\tif (!pjsip_sorcery) {\n\t\tast_log(AST_LOG_ERROR, \"Unable to retrieve PJSIP configuration: sorcery object is NULL\\n\");\n\t\treturn -1;\n\t}\n\taor_obj = ast_sorcery_retrieve_by_id(pjsip_sorcery, \"aor\", args.aor_name);\n\tif (!aor_obj) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to retrieve information for AOR '%s'\\n\", args.aor_name);\n\t\treturn -1;\n\t}\n\tif (!strcmp(args.field_name, \"contact\")) {\n\t\t\n\t\tRAII_VAR(struct ao2_container *, contacts, NULL, ao2_cleanup);\n\t\tstruct ao2_iterator i;\n\t\tstruct ast_sip_contact *contact;\n\t\tint first = 1;\n\t\tcontacts = ast_sip_location_retrieve_aor_contacts(aor_obj);\n\t\tif (!contacts) {\n\t\t\tast_log(LOG_WARNING, \"Failed to retrieve contacts for AOR '%s'\\n\", args.aor_name);\n\t\t\treturn -1;\n\t\t}\n\t\ti = ao2_iterator_init(contacts, 0);\n\t\twhile ((contact = ao2_iterator_next(&i))) {\n\t\t\tif (!first) {\n\t\t\t\tast_str_append(buf, len, \"%s\", \",\");\n\t\t\t}\n\t\t\tast_str_append(buf, len, \"%s\", ast_sorcery_object_get_id(contact));\n\t\t\tfirst = 0;\n\t\t\tao2_ref(contact, -1);\n\t\t}\n\t\tao2_iterator_destroy(&i);\n\t} else {\n\t\tstruct ast_variable *change_set;\n\t\tstruct ast_variable *it_change_set;\n\t\tchange_set = ast_sorcery_objectset_create(pjsip_sorcery, aor_obj);\n\t\tif (!change_set) {\n\t\t\tast_log(AST_LOG_WARNING, \"Failed to retrieve information for AOR '%s': change set is NULL\\n\", args.aor_name);\n\t\t\treturn -1;\n\t\t}\n\t\tfor (it_change_set = change_set; it_change_set; it_change_set = it_change_set->next) {\n\t\t\tif (!strcmp(it_change_set->name, args.field_name)) {\n\t\t\t\tast_str_set(buf, len, \"%s\", it_change_set->value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!it_change_set) {\n\t\t\tast_log(AST_LOG_WARNING, \"Unknown property '%s' for PJSIP AOR\\n\", args.field_name);\n\t\t\tres = 1;\n\t\t}\n\t\tast_variables_destroy(change_set);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 442}
{"project": "Asterisk", "target": 0, "func": "void say_parking_space(struct ast_bridge_channel *bridge_channel, const char *payload)\n{\n\tunsigned int numeric_value;\n\tunsigned int hangup_after;\n\tif (sscanf(payload, \"%u %u\", &hangup_after, &numeric_value) != 2) {\n\t\t\n\t\tast_assert(0);\n\t\tast_bridge_channel_leave_bridge(bridge_channel,\n\t\t\tBRIDGE_CHANNEL_STATE_END_NO_DISSOLVE, AST_CAUSE_NORMAL_CLEARING);\n\t\treturn;\n\t}\n\tast_say_digits(bridge_channel->chan, numeric_value, \"\",\n\t\tast_channel_language(bridge_channel->chan));\n\tif (hangup_after) {\n\t\tast_bridge_channel_leave_bridge(bridge_channel,\n\t\t\tBRIDGE_CHANNEL_STATE_END_NO_DISSOLVE, AST_CAUSE_NORMAL_CLEARING);\n\t}\n}\n", "bug_type": null, "idx": 443}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void add_eyebeam(pj_pool_t *pool, pj_xml_node *node, const char *pidfstate)\n{\n\tstatic const char *XMLNS_DM_PREFIX = \"xmlns:dm\";\n\tstatic const char *XMLNS_DM = \"urn:ietf:params:xml:ns:pidf:data-model\";\n\tstatic const char *XMLNS_RPID_PREFIX = \"xmlns:rpid\";\n\tstatic const char *XMLNS_RPID = \"urn:ietf:params:xml:ns:pidf:rpid\";\n\tpj_xml_node *person = ast_sip_presence_xml_create_node(pool, node, \"dm:person\");\n\tif (pidfstate[0] != '-') {\n\t\tpj_xml_node *activities = ast_sip_presence_xml_create_node(pool, person, \"rpid:activities\");\n\t\tsize_t str_size = sizeof(\"rpid:\") + strlen(pidfstate);\n\t\tchar *act_str = ast_alloca(str_size);\n\t\t\n\t\tstrcpy(act_str, \"rpid:\");\n\t\tstrcat(act_str, pidfstate);\n\t\tast_sip_presence_xml_create_node(pool, activities, act_str);\n\t}\n\tast_sip_presence_xml_create_attr(pool, node, XMLNS_DM_PREFIX, XMLNS_DM);\n\tast_sip_presence_xml_create_attr(pool, node, XMLNS_RPID_PREFIX, XMLNS_RPID);\n}\n", "bug_type": null, "idx": 444}
{"project": "Asterisk", "target": 0, "func": "static int while_start_exec(struct ast_channel *chan, const char *data) {\n\treturn _while_exec(chan, data, 0);\n}\n", "bug_type": null, "idx": 445}
{"project": "Asterisk", "target": 0, "func": "void onModeChanged(ooCallData *call, int t38mode) {\n        struct ooh323_pvt *p;\n\tp = find_call(call);\n\tif (!p) {\n\t\tast_log(LOG_ERROR, \"No matching call found for %s\\n\", call->callToken);\n\t\treturn;\n\t}\n\tast_mutex_lock(&p->lock);\n\tif (gH323Debug)\n       \t\tast_debug(1, \"change mode to %d for %s\\n\", t38mode, call->callToken);\n\tif (t38mode == p->faxmode) {\n\t\tif (gH323Debug)\n\t\t\tast_debug(1, \"mode for %s is already %d\\n\", call->callToken,\n\t\t\t\t\tt38mode);\n\t\tp->chmodepend = 0;\n\t\tast_mutex_unlock(&p->lock);\n\t\treturn;\n\t}\n\tif (p->owner) {\n\t\twhile (p->owner && ast_channel_trylock(p->owner)) {\n\t\t\tast_debug(1,\"Failed to grab lock, trying again\\n\");\n\t\t\tDEADLOCK_AVOIDANCE(&p->lock);\n\t\t}\n\t\tif (!p->owner) {\n\t\t\tp->chmodepend = 0;\n\t\t\tast_mutex_unlock(&p->lock);\n\t\t\tast_log(LOG_ERROR, \"Channel has no owner\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tp->chmodepend = 0;\n\t\tast_mutex_unlock(&p->lock);\n\t\tast_log(LOG_ERROR, \"Channel has no owner\\n\");\n\t\treturn;\n\t}\n\tif (t38mode) {\n\t\tif (p->t38support == T38_ENABLED) {\n\t\t\tstruct ast_control_t38_parameters parameters = { .request_response = 0 };\n\t\t\tif ((p->faxdetect & FAXDETECT_T38) && !p->faxdetected) {\n                       \t\tconst char *target_context;\n\t\t\t\tast_debug(1, \"* Detected T.38 Request\\n\");\n\t\t\t\ttarget_context = S_OR(ast_channel_macrocontext(p->owner), ast_channel_context(p->owner));\n                        \tif ((strcmp(ast_channel_exten(p->owner), \"fax\")) &&\n                            \t\t(ast_exists_extension(p->owner, target_context, \"fax\", 1,\n                            \t\tS_COR(ast_channel_caller(p->owner)->id.number.valid, ast_channel_caller(p->owner)->id.number.str, NULL)))) {\n                                \tast_verb(2, \"Redirecting '%s' to fax extension due to CNG detection\\n\", ast_channel_name(p->owner));\n                                \tpbx_builtin_setvar_helper(p->owner, \"FAXEXTEN\", ast_channel_exten(p->owner));\n                                \tif (ast_async_goto(p->owner, target_context, \"fax\", 1)) {\n                                        \tast_log(LOG_NOTICE, \"Failed to async goto '%s' into fax of '%s'\\n\", ast_channel_name(p->owner),target_context);\n\t\t\t\t\t}\n                                }\n                                p->faxdetected = 1;\n\t\t\t}\n\n\t\t\tparameters.request_response = AST_T38_REQUEST_NEGOTIATE;\n\t\t\tif (call->T38FarMaxDatagram) {\n\t\t\t\tast_udptl_set_far_max_datagram(p->udptl, call->T38FarMaxDatagram);\n\t\t\t} else {\n\t\t\t\tast_udptl_set_far_max_datagram(p->udptl, 144);\n\t\t\t}\n\t\t\tif (call->T38Version) {\n\t\t\t\tparameters.version = call->T38Version;\n\t\t\t}\n\t\t\tparameters.max_ifp = ast_udptl_get_far_max_ifp(p->udptl);\n\t\t\tparameters.rate = AST_T38_RATE_14400;\n\t\t\tast_queue_control_data(p->owner, AST_CONTROL_T38_PARAMETERS, \n\t\t\t\t\t\t\t&parameters, sizeof(parameters));\n\t\t\tp->faxmode = 1;\n\t\t}\n\t} else {\n\t\tif (p->t38support == T38_ENABLED) {\n\t\t\tstruct ast_control_t38_parameters parameters = { .request_response = 0 };\n\t\t\tparameters.request_response = AST_T38_REQUEST_TERMINATE;\n\t\t\tparameters.max_ifp = ast_udptl_get_far_max_ifp(p->udptl);\n\t\t\tparameters.rate = AST_T38_RATE_14400;\n\t\t\tast_queue_control_data(p->owner, AST_CONTROL_T38_PARAMETERS, \n\t\t\t\t\t\t\t&parameters, sizeof(parameters));\n\t\t}\n\t\tp->faxmode = 0;\n\t\tp->faxdetected = 0;\n\t\tp->t38_init = 0;\n\t}\n\tp->chmodepend = 0;\n\tast_channel_unlock(p->owner);\n\tast_mutex_unlock(&p->lock);\n}\n", "bug_type": null, "idx": 446}
{"project": "Asterisk", "target": 0, "func": "static struct ast_calendar *find_calendar(const char *name)\n{\n\tstruct ast_calendar tmp = {\n\t\t.name = name,\n\t};\n\treturn ao2_find(calendars, &tmp, OBJ_POINTER);\n}\n", "bug_type": null, "idx": 447}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_recordings_get_stored(struct ast_variable *headers,\n\tstruct ast_ari_recordings_get_stored_args *args,\n\tstruct ast_ari_response *response)\n{\n\tRAII_VAR(struct stasis_app_stored_recording *, recording, NULL,\n\t\tao2_cleanup);\n\tstruct ast_json *json;\n\trecording = stasis_app_stored_recording_find_by_name(\n\t\targs->recording_name);\n\tif (recording == NULL) {\n\t\tast_ari_response_error(response, 404, \"Not Found\",\n\t\t\t\"Recording not found\");\n\t\treturn;\n\t}\n\tjson = stasis_app_stored_recording_to_json(recording);\n\tif (json == NULL) {\n\t\tast_ari_response_error(response, 500,\n\t\t\t\"Internal Server Error\", \"Error building response\");\n\t\treturn;\n\t}\n\tast_ari_response_ok(response, json);\n}\n", "bug_type": null, "idx": 448}
{"project": "Asterisk", "target": 0, "func": "static int moh_class_mark(void *obj, void *arg, int flags)\n{\n\tstruct mohclass *class = obj;\n\tif ( ((flags & MOH_REALTIME) && class->realtime) || !(flags & MOH_REALTIME) ) {\n\t\tclass->delete = 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 449}
{"project": "Asterisk", "target": 0, "func": "static int adsi_exec(struct ast_channel *chan, const char *data)\n{\n\tint res = 0;\n\tif (ast_strlen_zero(data))\n\t\tdata = \"asterisk.adsi\";\n\tif (!ast_adsi_available(chan)) {\n\t\tast_verb(3, \"ADSI Unavailable on CPE.  Not bothering to try.\\n\");\n\t} else {\n\t\tast_verb(3, \"ADSI Available on CPE.  Attempting Upload.\\n\");\n\t\tres = adsi_prog(chan, data);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 450}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225ProtocolIdentifier (OOCTXT* pctxt, H225ProtocolIdentifier* pvalue)\n{\n   int stat = ASN_OK;\n   stat = decodeObjectIdentifier (pctxt, pvalue);\n   if (stat != ASN_OK) return stat;\n   invokeOidValue (pctxt, pvalue->numids, pvalue->subid);\n   return (stat);\n}\n", "bug_type": null, "idx": 451}
{"project": "Asterisk", "target": 0, "func": "static int realtime_exec(struct ast_channel *chan, const char *context, const char *exten, int priority, const char *callerid, const char *data)\n{\n\tint res = -1;\n\tstruct ast_variable *var = realtime_common(context, exten, priority, data, MODE_MATCH);\n\tif (var) {\n\t\tchar *appdata_tmp = \"\";\n\t\tchar *app = NULL;\n\t\tstruct ast_variable *v;\n\t\tfor (v = var; v ; v = v->next) {\n\t\t\tif (!strcasecmp(v->name, \"app\"))\n\t\t\t\tapp = ast_strdupa(v->value);\n\t\t\telse if (!strcasecmp(v->name, \"appdata\")) {\n\t\t\t\tappdata_tmp = ast_strdupa(v->value);\n\t\t\t}\n\t\t}\n\t\tast_variables_destroy(var);\n\t\tif (!ast_strlen_zero(app)) {\n\t\t\tstruct ast_app *a = pbx_findapp(app);\n\t\t\tif (a) {\n\t\t\t\tchar appdata[512];\n\t\t\t\tchar tmp1[80];\n\t\t\t\tchar tmp2[80];\n\t\t\t\tchar tmp3[EXT_DATA_SIZE];\n\t\t\t\tRAII_VAR(struct ast_channel_snapshot *, snapshot, NULL, ao2_cleanup);\n\t\t\t\tRAII_VAR(struct stasis_message *, msg, NULL, ao2_cleanup);\n\t\t\t\tappdata[0] = 0; \n\t\t\t\tif(!ast_strlen_zero(appdata_tmp))\n\t\t\t\t\tpbx_substitute_variables_helper(chan, appdata_tmp, appdata, sizeof(appdata) - 1);\n\t\t\t\tast_verb(3, \"Executing [%s@%s:%d] %s(\\\"%s\\\", \\\"%s\\\")\\n\",\n\t\t\t\t\t\tast_channel_exten(chan), ast_channel_context(chan), ast_channel_priority(chan),\n\t\t\t\t\t\t term_color(tmp1, app, COLOR_BRCYAN, 0, sizeof(tmp1)),\n\t\t\t\t\t\t term_color(tmp2, ast_channel_name(chan), COLOR_BRMAGENTA, 0, sizeof(tmp2)),\n\t\t\t\t\t\t term_color(tmp3, S_OR(appdata, \"\"), COLOR_BRMAGENTA, 0, sizeof(tmp3)));\n\t\t\t\tif (ast_channel_snapshot_type()) {\n\t\t\t\t\tast_channel_lock(chan);\n\t\t\t\t\tsnapshot = ast_channel_snapshot_create(chan);\n\t\t\t\t\tast_channel_unlock(chan);\n\t\t\t\t}\n\t\t\t\tif (snapshot) {\n\t\t\t\t\t\n\t\t\t\t\tast_string_field_set(snapshot, appl, app);\n\t\t\t\t\tast_string_field_set(snapshot, data, !ast_strlen_zero(appdata) ? appdata : \"(NULL)\");\n\t\t\t\t\tmsg = stasis_message_create(ast_channel_snapshot_type(), snapshot);\n\t\t\t\t\tif (msg) {\n\t\t\t\t\t\tstasis_publish(ast_channel_topic(chan), msg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres = pbx_exec(chan, a, appdata);\n\t\t\t} else\n\t\t\t\tast_log(LOG_NOTICE, \"No such application '%s' for extension '%s' in context '%s'\\n\", app, exten, context);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"No application specified for realtime extension '%s' in context '%s'\\n\", exten, context);\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 452}
{"project": "Asterisk", "target": 0, "func": "int ast_dns_query_get_rr_class(const struct ast_dns_query *query)\n{\n\treturn query->rr_class;\n}\n", "bug_type": null, "idx": 453}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_format_def_unregister(name);\n}\n", "bug_type": null, "idx": 454}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245FECCapability_rfc2733 (OOCTXT* pctxt, H245FECCapability_rfc2733* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"redundancyEncoding\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->redundancyEncoding);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->redundancyEncoding);\n   invokeEndElement (pctxt, \"redundancyEncoding\", -1);\n   \n   invokeStartElement (pctxt, \"separateStream\", -1);\n   stat = asn1PD_H245FECCapability_rfc2733_separateStream (pctxt, &pvalue->separateStream);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"separateStream\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 455}
{"project": "Asterisk", "target": 0, "func": "static int goto_exten(struct ast_channel *chan, const char *dialcontext, char *ext)\n{\n\tif (!ast_goto_if_exists(chan, S_OR(dialcontext, ast_channel_context(chan)), ext, 1) ||\n\t\t(!ast_strlen_zero(ast_channel_macrocontext(chan)) &&\n\t\t!ast_goto_if_exists(chan, ast_channel_macrocontext(chan), ext, 1))) {\n\t\treturn 0;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Can't find extension '%s' in current context.  \"\n\t\t\t\"Not Exiting the Directory!\\n\", ext);\n\t\treturn -1;\n\t}\n}\n", "bug_type": null, "idx": 456}
{"project": "Asterisk", "target": 0, "func": "\nstatic int osp_unload(void)\n{\n\tstruct osp_provider* provider;\n\tstruct osp_provider* next;\n\tif (osp_initialized) {\n\t\tast_mutex_lock(&osp_lock);\n\t\tfor (provider = osp_providers; provider; provider = next) {\n\t\t\tnext = provider->next;\n\t\t\tOSPPProviderDelete(provider->handle, 0);\n\t\t\tast_free(provider);\n\t\t}\n\t\tosp_providers = NULL;\n\t\tast_mutex_unlock(&osp_lock);\n\t\tOSPPCleanup();\n\t\tosp_tokenformat = TOKEN_ALGO_SIGNED;\n\t\tosp_security = 0;\n\t\tosp_hardware = 0;\n\t\tosp_initialized = 0;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 457}
{"project": "Asterisk", "target": 0, "func": "void *ast_taskprocessor_listener_get_user_data(const struct ast_taskprocessor_listener *listener)\n{\n\treturn listener->user_data;\n}\n", "bug_type": null, "idx": 458}
{"project": "Asterisk", "target": 0, "func": "static int apply_config(struct aco_info *info)\n{\n\tao2_global_obj_replace_unref(*info->global_obj, info->internal->pending);\n\treturn 0;\n}\n", "bug_type": null, "idx": 459}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void native_bridge_unsuspend(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)\n{\n\tnative_request_start(bridge);\n}\n", "bug_type": null, "idx": 460}
{"project": "Asterisk", "target": 0, "func": "\nstatic void dns_synchronous_resolve_destroy(void *data)\n{\n\tstruct dns_synchronous_resolve *synchronous = data;\n\tast_mutex_destroy(&synchronous->lock);\n\tast_cond_destroy(&synchronous->cond);\n\t\n}\n", "bug_type": null, "idx": 461}
{"project": "Asterisk", "target": 0, "func": "int AST_OPTIONAL_API_NAME(ast_aes_set_encrypt_key)(const unsigned char *key, ast_aes_encrypt_key *ctx)\n{\n\treturn AES_set_encrypt_key(key, 128, ctx);\n}\n", "bug_type": null, "idx": 462}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_custom_function_register(&sorcery_function);\n}\n", "bug_type": null, "idx": 463}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_unregister_application(app);\n}\n", "bug_type": null, "idx": 464}
{"project": "Asterisk", "target": 0, "func": "int ast_aoc_s_add_rate_special_charge_code(struct ast_aoc_decoded *decoded,\n\tenum ast_aoc_s_charged_item charged_item,\n\tunsigned int code)\n{\n\tstruct ast_aoc_s_entry entry = { 0, };\n\tentry.charged_item = charged_item;\n\tentry.rate_type = AST_AOC_RATE_TYPE_SPECIAL_CODE;\n\tentry.rate.special_code = code;\n\treturn aoc_s_add_entry(decoded, &entry);\n}\n", "bug_type": null, "idx": 465}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245VCCapability (OOCTXT* pctxt, H245VCCapability* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.aal1Present = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.aal5Present = optbit;\n   \n   if (pvalue->m.aal1Present) {\n      invokeStartElement (pctxt, \"aal1\", -1);\n      stat = asn1PD_H245VCCapability_aal1 (pctxt, &pvalue->aal1);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"aal1\", -1);\n   }\n   \n   if (pvalue->m.aal5Present) {\n      invokeStartElement (pctxt, \"aal5\", -1);\n      stat = asn1PD_H245VCCapability_aal5 (pctxt, &pvalue->aal5);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"aal5\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"transportStream\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->transportStream);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->transportStream);\n   invokeEndElement (pctxt, \"transportStream\", -1);\n   \n   invokeStartElement (pctxt, \"programStream\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->programStream);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->programStream);\n   invokeEndElement (pctxt, \"programStream\", -1);\n   \n   invokeStartElement (pctxt, \"availableBitRates\", -1);\n   stat = asn1PD_H245VCCapability_availableBitRates (pctxt, &pvalue->availableBitRates);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"availableBitRates\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 1 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.aal1ViaGatewayPresent = 1;\n                     invokeStartElement (pctxt, \"aal1ViaGateway\", -1);\n                     stat = asn1PD_H245VCCapability_aal1ViaGateway (pctxt, &pvalue->aal1ViaGateway);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"aal1ViaGateway\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 466}
{"project": "Asterisk", "target": 0, "func": "protected void\nkey_print(EditLine *el, const char *key)\n{\n\t\n\tif (el->el_key.map == NULL && *key == 0)\n\t\treturn;\n\tel->el_key.buf[0] = '\"';\n\tif (node_lookup(el, key, el->el_key.map, 1) <= -1)\n\t\t\n\t\t(void) fprintf(el->el_errfile, \"Unbound extended key \\\"%s\\\"\\n\",\n\t\t    key);\n\treturn;\n}\n", "bug_type": null, "idx": 467}
{"project": "Asterisk", "target": 0, "func": "static void my_set_waitingfordt(void *pvt, struct ast_channel *ast)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tif (p->waitfordialtone && CANPROGRESSDETECT(p) && p->dsp) {\n\t\tast_debug(1, \"Defer dialing for %dms or dialtone\\n\", p->waitfordialtone);\n\t\tgettimeofday(&p->waitingfordt, NULL);\n\t\tast_setstate(ast, AST_STATE_OFFHOOK);\n\t}\n}\n", "bug_type": null, "idx": 468}
{"project": "Asterisk", "target": 0, "func": "static int generic_monitor_cmp_fn(void *obj, void *arg, int flags)\n{\n\tconst struct generic_monitor_instance_list *generic_list1 = obj;\n\tconst struct generic_monitor_instance_list *generic_list2 = arg;\n\treturn !strcmp(generic_list1->device_name, generic_list2->device_name) ? CMP_MATCH | CMP_STOP : 0;\n}\n", "bug_type": null, "idx": 469}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int rfcomm_write(int rsock, char *buf)\n{\n\treturn rfcomm_write_full(rsock, buf, strlen(buf));\n}\n", "bug_type": null, "idx": 470}
{"project": "Asterisk", "target": 0, "func": "#define ANALOG_NEED_MFDETECT(p) (((p)->sig == ANALOG_SIG_FEATDMF) || ((p)->sig == ANALOG_SIG_FEATDMF_TA) || ((p)->sig == ANALOG_SIG_E911) || ((p)->sig == ANALOG_SIG_FGC_CAMA) || ((p)->sig == ANALOG_SIG_FGC_CAMAMF) || ((p)->sig == ANALOG_SIG_FEATB))\nstatic int analog_canmatch_featurecode(const char *pickupexten, const char *exten)\n{\n\tint extlen = strlen(exten);\n\tif (!extlen) {\n\t\treturn 1;\n\t}\n\tif (extlen < strlen(pickupexten) && !strncmp(pickupexten, exten, extlen)) {\n\t\treturn 1;\n\t}\n\t\n\tif (exten[0] == '*' && extlen < 3) {\n\t\tif (extlen == 1) {\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tswitch (exten[1]) {\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 471}
{"project": "Asterisk", "target": 0, "func": "static void leave_waitmarked(struct confbridge_user *user)\n{\n\tconf_default_leave_waitmarked(user);\n\tif (user->conference->waitingusers == 0) {\n\t\tconf_change_state(user, CONF_STATE_EMPTY);\n\t}\n}\n", "bug_type": null, "idx": 472}
{"project": "Asterisk", "target": 0, "func": "struct stasis_topic *ast_bridge_topic_cached(struct ast_bridge *bridge)\n{\n\tif (!bridge) {\n\t\treturn ast_bridge_topic_all_cached();\n\t}\n\treturn stasis_cp_single_topic_cached(bridge->topics);\n}\n", "bug_type": null, "idx": 473}
{"project": "Asterisk", "target": 0, "func": "private int\nkey__decode_char(char *buf, int cnt, int ch)\n{\n\tif (ch == 0) {\n\t\tbuf[cnt++] = '^';\n\t\tbuf[cnt] = '@';\n\t\treturn (cnt);\n\t}\n\tif (iscntrl(ch)) {\n\t\tbuf[cnt++] = '^';\n\t\tif (ch == '\\177')\n\t\t\tbuf[cnt] = '?';\n\t\telse\n\t\t\tbuf[cnt] = ch | 0100;\n\t} else if (ch == '^') {\n\t\tbuf[cnt++] = '\\\\';\n\t\tbuf[cnt] = '^';\n\t} else if (ch == '\\\\') {\n\t\tbuf[cnt++] = '\\\\';\n\t\tbuf[cnt] = '\\\\';\n\t} else if (ch == ' ' || (isprint(ch) && !isspace(ch))) {\n\t\tbuf[cnt] = ch;\n\t} else {\n\t\tbuf[cnt++] = '\\\\';\n\t\tbuf[cnt++] = (((unsigned int) ch >> 6) & 7) + '0';\n\t\tbuf[cnt++] = (((unsigned int) ch >> 3) & 7) + '0';\n\t\tbuf[cnt] = (ch & 7) + '0';\n\t}\n\treturn (cnt);\n}\n", "bug_type": null, "idx": 474}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *complete_config_type(const char *module, const char *word, int pos, int state)\n{\n\tchar *c = NULL;\n\tsize_t wordlen = strlen(word);\n\tint which = 0;\n\tRAII_VAR(struct ast_xml_doc_item *, info, NULL, ao2_cleanup);\n\tstruct ast_xml_doc_item *cur;\n\tif (pos != 4) {\n\t\treturn NULL;\n\t}\n\tif (!(info = ao2_find(xmldocs, module, OBJ_KEY))) {\n\t\treturn NULL;\n\t}\n\tcur = info;\n\twhile ((cur = AST_LIST_NEXT(cur, next))) {\n\t\tif (!strcasecmp(cur->type, \"configObject\") && !strncasecmp(word, cur->name, wordlen) && ++which > state) {\n\t\t\tc = ast_strdup(cur->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn c;\n}\n", "bug_type": null, "idx": 475}
{"project": "Asterisk", "target": 0, "func": "*/\nint ooParseDestination\n   (struct OOH323CallData *call, char *dest, char* parsedIP, unsigned len,\n    ooAliases** aliasList)\n{\n   int iEk=-1, iDon=-1, iTeen=-1, iChaar=-1, iPort = -1, i;\n   ooAliases * psNewAlias = NULL;\n   char *cAt = NULL, *host=NULL;\n   char tmp[256], buf[30];\n   char *alias=NULL;\n   OOCTXT *pctxt = call->pctxt;\n   struct ast_sockaddr tmpaddr;\n   parsedIP[0] = '\\0';\n   OOTRACEINFO2(\"Parsing destination %s\\n\", dest);\n   \n   sscanf(dest, \"%d.%d.%d.%d:%d\", &iEk, &iDon, &iTeen, &iChaar, &iPort);\n   if((iEk > 0            && iEk <= 255)    &&\n      (iDon >= 0          && iDon <= 255)   &&\n      (iTeen >=0          && iTeen <= 255)  &&\n      (iChaar >= 0        && iChaar <= 255) &&\n      (!strchr(dest, ':') || iPort != -1))\n   {\n      if(!strchr(dest, ':'))\n         iPort = 1720; \n      sprintf(buf, \"%d.%d.%d.%d:%d\", iEk, iDon, iTeen, iChaar, iPort);\n      if(strlen(buf)+1>len)\n      {\n         OOTRACEERR1(\"Error:Insufficient buffer space for parsed ip - \"\n                     \"ooParseDestination\\n\");\n         return OO_FAILED;\n      }\n      strcpy(parsedIP, buf);\n      return OO_OK;\n   }\n   \n   if ((strchr(dest, ':') || strchr(dest,'[') || strchr(dest,'.')) && !ast_parse_arg(dest, PARSE_ADDR, &tmpaddr)) {\n      if(strlen(dest)+7>len)\n      {\n         OOTRACEERR1(\"Error:Insufficient buffer space for parsed ip - \"\n                     \"ooParseDestination\\n\");\n         return OO_FAILED;\n      }\n      strcpy(parsedIP, ast_sockaddr_stringify_addr(&tmpaddr));\n      strcat(parsedIP, \":\");\n      strcat(parsedIP, ast_sockaddr_stringify_port(&tmpaddr));\n      return OO_OK;\n   }\n   \n   strncpy(tmp, dest, sizeof(tmp)-1);\n   tmp[sizeof(tmp)-1]='\\0';\n   if((host=strchr(tmp, '@')) != NULL)\n   {\n      *host = '\\0';\n      host++;\n      sscanf(host, \"%d.%d.%d.%d:%d\", &iEk, &iDon, &iTeen, &iChaar, &iPort);\n      if((iEk > 0            && iEk <= 255)    &&\n         (iDon >= 0          && iDon <= 255)   &&\n         (iTeen >=0          && iTeen <= 255)  &&\n         (iChaar >= 0        && iChaar <= 255) &&\n         (!strchr(host, ':') || iPort != -1))\n      {\n         if(!strchr(dest, ':'))\n            iPort = 1720; \n         sprintf(buf, \"%d.%d.%d.%d:%d\", iEk, iDon, iTeen, iChaar, iPort);\n         if(strlen(buf)+1>len)\n         {\n            OOTRACEERR1(\"Error:Insufficient buffer space for parsed ip - \"\n                        \"ooParseDestination\\n\");\n            return OO_FAILED;\n         }\n         strncpy(parsedIP, buf, len-1);\n         parsedIP[len-1]='\\0';\n         alias = tmp;\n      }\n   }\n   if(!alias)\n   {\n     alias = dest;\n   }\n   \n   if(alias == strstr(alias, \"http://\"))\n   {\n      psNewAlias = (ooAliases*) memAlloc(pctxt, sizeof(ooAliases));\n      if(!psNewAlias)\n      {\n         OOTRACEERR1(\"Error:Memory - ooParseDestination - psNewAlias\\n\");\n         return OO_FAILED;\n      }\n      psNewAlias->type = T_H225AliasAddress_url_ID;\n      psNewAlias->value = (char*) memAlloc(pctxt, strlen(alias)+1);\n      if(!psNewAlias->value)\n      {\n         OOTRACEERR1(\"Error:Memory - ooParseDestination - \"\n                     \"psNewAlias->value\\n\");\n         memFreePtr(pctxt, psNewAlias);\n         return OO_FAILED;\n      }\n      strcpy(psNewAlias->value, alias);\n      psNewAlias->next = *aliasList;\n      *aliasList = psNewAlias;\n      OOTRACEINFO2(\"Destination parsed as url %s\\n\", psNewAlias->value);\n      return OO_OK;\n   }\n   \n   if((cAt = strchr(alias, '@')) && alias != strchr(alias, '@'))\n   {\n      if(strchr(cAt, '.'))\n      {\n         psNewAlias = (ooAliases*) memAlloc(pctxt, sizeof(ooAliases));\n         if(!psNewAlias)\n         {\n            OOTRACEERR1(\"Error:Memory - ooParseDestination - psNewAlias\\n\");\n            return OO_FAILED;\n         }\n         psNewAlias->type = T_H225AliasAddress_email_ID;\n         psNewAlias->value = (char*) memAlloc(pctxt, strlen(alias)+1);\n         if(!psNewAlias->value)\n         {\n            OOTRACEERR1(\"Error:Memory - ooParseDestination - \"\n                        \"psNewAlias->value\\n\");\n            memFreePtr(pctxt, psNewAlias);\n            return OO_FAILED;\n         }\n         strcpy(psNewAlias->value, alias);\n         psNewAlias->next = *aliasList;\n         *aliasList = psNewAlias;\n         OOTRACEINFO2(\"Destination is parsed as email %s\\n\",psNewAlias->value);\n         return OO_OK;\n      }\n   }\n   \n   \n   \n   for(i=0; *(alias+i) != '\\0'; i++)\n   {\n      if(!isdigit(alias[i]) && alias[i] != '#' && alias[i] != '*' && \n         alias[i] != ',')\n         break;\n   }\n   if(*(alias+i) == '\\0')\n   {\n      psNewAlias = (ooAliases*) memAlloc(pctxt, sizeof(ooAliases));\n      if(!psNewAlias)\n      {\n         OOTRACEERR1(\"Error:Memory - ooParseDestination - psNewAlias\\n\");\n         return OO_FAILED;\n      }\n      \n      psNewAlias->type = T_H225AliasAddress_dialedDigits;\n      psNewAlias->value = (char*) memAlloc(pctxt, strlen(alias)+1);\n      if(!psNewAlias->value)\n      {\n         OOTRACEERR1(\"Error:Memroy - ooParseDestination - \"\n                     \"psNewAlias->value\\n\");\n         memFreePtr(pctxt, psNewAlias);\n         return OO_FAILED;\n      }\n      strcpy(psNewAlias->value, alias);\n      psNewAlias->next = *aliasList;\n      *aliasList = psNewAlias;\n      OOTRACEINFO2(\"Destination is parsed as dialed digits %s\\n\",\n                  psNewAlias->value);\n      \n      if(!call->calledPartyNumber)\n      {\n         if(ooCallSetCalledPartyNumber(call, alias) != OO_OK)\n         {\n            OOTRACEWARN3(\"Warning:Failed to set calling party number.\"\n                         \"(%s, %s)\\n\", call->callType, call->callToken);\n         }\n      }\n      return OO_OK;\n   }\n   \n   psNewAlias = (ooAliases*) memAlloc(pctxt, sizeof(ooAliases));\n   if(!psNewAlias)\n   {\n      OOTRACEERR1(\"Error:Memory - ooParseDestination - psNewAlias\\n\");\n      return OO_FAILED;\n   }\n   psNewAlias->type = T_H225AliasAddress_h323_ID;\n   psNewAlias->value = (char*) memAlloc(pctxt, strlen(alias)+1);\n   if(!psNewAlias->value)\n   {\n      OOTRACEERR1(\"Error:Memory - ooParseDestination - psNewAlias->value\\n\");\n      memFreePtr(pctxt, psNewAlias);\n      return OO_FAILED;\n   }\n   strcpy(psNewAlias->value, alias);\n   psNewAlias->next = *aliasList;\n   *aliasList = psNewAlias;\n   OOTRACEINFO2(\"Destination for new call is parsed as h323-id %s \\n\",\n               psNewAlias->value);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 476}
{"project": "Asterisk", "target": 0, "func": "#endif\nenum jb_return_code jb_put(jitterbuf *jb, void *data, const enum jb_frame_type type, long ms, long ts, long now)\n{\n\tlong delay = now - (ts - jb->info.resync_offset);\n\tjb_dbg2(\"jb_put(%x,%x,%ld,%ld,%ld)\\n\", jb, data, ms, ts, now);\n\tif (check_resync(jb, ts, now, ms, type, &delay)) {\n\t\treturn JB_DROP;\n\t}\n\tif (type == JB_TYPE_VOICE) {\n\t\t\n\t\thistory_put(jb, ts, now, ms, delay);\n\t}\n\tjb->info.frames_in++;\n\t\n\tif (queue_put(jb,data,type,ms,ts)) {\n\t\treturn JB_SCHED;\n\t}\n\treturn JB_OK;\n}\n", "bug_type": null, "idx": 477}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void lua_state_destroy(void *data)\n{\n\tif (data)\n\t\tlua_close(data);\n}\n", "bug_type": null, "idx": 478}
{"project": "Asterisk", "target": 0, "func": "static pj_bool_t filter_on_rx_message(pjsip_rx_data *rdata)\n{\n\tpj_bool_t rc;\n\trc = on_rx_process_uris(rdata);\n\tif (rc == PJ_TRUE) {\n\t\treturn rc;\n\t}\n\trc = on_rx_process_symmetric_transport(rdata);\n\tif (rc == PJ_TRUE) {\n\t\treturn rc;\n\t}\n\treturn PJ_FALSE;\n}\n", "bug_type": null, "idx": 479}
{"project": "Asterisk", "target": 0, "func": "static int adsi_end_download(struct ast_channel *chan)\n{\n\tint bytes = 0;\n\tunsigned char buf[256];\n\t\n\t\n\tbytes += adsi_download_disconnect(buf + bytes);\n\tif (adsi_transmit_message_full(chan, buf, bytes, ADSI_MSG_DOWNLOAD, 0)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 480}
{"project": "Asterisk", "target": 0, "func": "\nstatic void parked_call_payload_destructor(void *obj)\n{\n\tstruct ast_parked_call_payload *park_obj = obj;\n\tao2_cleanup(park_obj->parkee);\n\tao2_cleanup(park_obj->retriever);\n\tast_string_field_free_memory(park_obj);\n}\n", "bug_type": null, "idx": 481}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function aes_decrypt_function = {\n\t.name = \"AES_DECRYPT\",\n\t.read = aes_helper,\n};\n};\nstatic struct ast_custom_function aes_decrypt_function = {\n\t.name = \"AES_DECRYPT\",\n\t.read = aes_helper,\n};\nstatic int unload_module(void)\n{\n\tint res = ast_custom_function_unregister(&aes_decrypt_function);\n\treturn res | ast_custom_function_unregister(&aes_encrypt_function);\n}\nstatic int load_module(void)\n{\n\tint res = ast_custom_function_register(&aes_decrypt_function);\n\tres |= ast_custom_function_register(&aes_encrypt_function);\n\treturn res ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS;\n}\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, \"AES dialplan functions\",\n\t.support_level = AST_MODULE_SUPPORT_CORE,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.nonoptreq = \"res_crypto\",\n);\n", "bug_type": null, "idx": 482}
{"project": "Asterisk", "target": 0, "func": "static char *complete_ari_show_user(struct ast_cli_args *a)\n{\n\tif (a->pos == 3) {\n\t\treturn complete_ari_user(a);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 483}
{"project": "Asterisk", "target": 0, "func": "static int publish_expire(const void *data)\n{\n\tstruct ast_sip_publication *publication = (struct ast_sip_publication*)data;\n\tao2_unlink(publication->handler->publications, publication);\n\tpublication->sched_id = -1;\n\tif (ast_sip_push_task(NULL, publish_expire_callback, publication)) {\n\t\tao2_cleanup(publication);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 484}
{"project": "Asterisk", "target": 0, "func": "static const char *ast_get_extension_name(struct ast_exten *exten)\n{\n\treturn exten ? exten->exten : NULL;\n}\n", "bug_type": null, "idx": 485}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int64_t count_lines(const char *filename, enum file_format newline_format)\n{\n\tint count = 0;\n\tchar fbuf[4096];\n\tFILE *ff;\n\tif (!(ff = fopen(filename, \"r\"))) {\n\t\tast_log(LOG_ERROR, \"Unable to open '%s': %s\\n\", filename, strerror(errno));\n\t\treturn -1;\n\t}\n\twhile (fgets(fbuf, sizeof(fbuf), ff)) {\n\t\tchar *next = fbuf, *first_cr = NULL, *first_nl = NULL;\n\t\t\n\t\twhile (next) {\n\t\t\tif (newline_format == FF_DOS || newline_format == FF_MAC || newline_format == FF_UNKNOWN) {\n\t\t\t\tfirst_cr = strchr(next, '\\r');\n\t\t\t}\n\t\t\tif (newline_format == FF_UNIX || newline_format == FF_UNKNOWN) {\n\t\t\t\tfirst_nl = strchr(next, '\\n');\n\t\t\t}\n\t\t\t\n\t\t\tif (!first_cr && !first_nl) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (newline_format == FF_UNKNOWN) {\n\t\t\t\tif ((first_cr && !first_nl) || (first_cr && first_cr < first_nl)) {\n\t\t\t\t\tif (first_nl && first_nl == first_cr + 1) {\n\t\t\t\t\t\tnewline_format = FF_DOS;\n\t\t\t\t\t} else if (first_cr && first_cr == &fbuf[sizeof(fbuf) - 2]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tfseek(ff, -1, SEEK_CUR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewline_format = FF_MAC;\n\t\t\t\t\t\tfirst_nl = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewline_format = FF_UNIX;\n\t\t\t\t\tfirst_cr = NULL;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (newline_format == FF_DOS) {\n\t\t\t\tif (first_nl && first_cr && first_nl == first_cr + 1) {\n\t\t\t\t\tnext = first_nl + 1;\n\t\t\t\t\tcount++;\n\t\t\t\t} else if (first_cr == &fbuf[sizeof(fbuf) - 2]) {\n\t\t\t\t\t\n\t\t\t\t\tfseek(ff, -1, SEEK_CUR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (newline_format == FF_MAC) {\n\t\t\t\tif (first_cr) {\n\t\t\t\t\tnext = first_cr + 1;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t} else if (newline_format == FF_UNIX) {\n\t\t\t\tif (first_nl) {\n\t\t\t\t\tnext = first_nl + 1;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(ff);\n\treturn count;\n}\n", "bug_type": null, "idx": 486}
{"project": "Asterisk", "target": 0, "func": "struct stasis_topic *ast_presence_state_topic_all(void)\n{\n\treturn presence_state_topic_all;\n}\n", "bug_type": null, "idx": 487}
{"project": "Asterisk", "target": 0, "func": "\nstatic int unistimsock_read(int *id, int fd, short events, void *ignore)\n{\n\tstruct sockaddr_in addr_from = { 0, };\n\tstruct unistimsession *cur = NULL;\n\tint found = 0;\n\tint tmp = 0;\n\tint dw_num_bytes_rcvd;\n\tunsigned int size_addr_from;\n#ifdef DUMP_PACKET\n\tint dw_num_bytes_rcvdd;\n#endif\n\tsize_addr_from = sizeof(addr_from);\n\tdw_num_bytes_rcvd =\n\t\trecvfrom(unistimsock, buff, SIZE_PAGE, 0, (struct sockaddr *) &addr_from,\n\t\t\t\t &size_addr_from);\n\tif (dw_num_bytes_rcvd == -1) {\n\t\tif (errno == EAGAIN) {\n\t\t\tast_log(LOG_NOTICE, \"UNISTIM: Received packet with bad UDP checksum\\n\");\n\t\t} else if (errno != ECONNREFUSED) {\n\t\t\tast_log(LOG_WARNING, \"Recv error %d (%s)\\n\", errno, strerror(errno));\n\t\t}\n\t\treturn 1;\n\t}\n\t\n\tast_mutex_lock(&sessionlock);\n\tcur = sessions;\n\twhile (cur) {\n\t\tif (cur->sin.sin_addr.s_addr == addr_from.sin_addr.s_addr) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttmp++;\n\t\tcur = cur->next;\n\t}\n\tast_mutex_unlock(&sessionlock);\n#ifdef DUMP_PACKET\n\tif (unistimdebug)\n\t\tast_verb(0, \"\\n*** Dump %d bytes from %s - phone_table[%d] ***\\n\",\n\t\t\t\t\tdw_num_bytes_rcvd, ast_inet_ntoa(addr_from.sin_addr), tmp);\n\tfor (dw_num_bytes_rcvdd = 0; dw_num_bytes_rcvdd < dw_num_bytes_rcvd;\n\t\t dw_num_bytes_rcvdd++)\n\t\tast_verb(0, \"%02hhx \", buff[dw_num_bytes_rcvdd]);\n\tast_verb(0, \"\\n******************************************\\n\");\n#endif\n\tif (!found) {\n\t\tif (unistimdebug) {\n\t\t\tast_verb(0, \"Received a packet from an unknown source\\n\");\n\t\t}\n\t\tparsing(dw_num_bytes_rcvd, buff, NULL, (struct sockaddr_in *) &addr_from);\n\t} else {\n\t\tparsing(dw_num_bytes_rcvd, buff, cur, (struct sockaddr_in *) &addr_from);\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 488}
{"project": "Asterisk", "target": 0, "func": "void SSL_load_error_strings(void)\n{\n#if defined(AST_DEVMODE)\n\tif (startup_complete) {\n\t\tast_debug(1, \"Called after startup... ignoring!\\n\");\n\t}\n#endif\n}\n", "bug_type": null, "idx": 489}
{"project": "Asterisk", "target": 0, "func": "static int recalling_enter(struct attended_transfer_properties *props)\n{\n\tRAII_VAR(struct ast_format_cap *, cap, ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT), ao2_cleanup);\n\tstruct ast_channel *recall;\n\tif (!cap) {\n\t\treturn -1;\n\t}\n\tast_format_cap_append(cap, ast_format_slin, 0);\n\t\n\tprops->dial = ast_dial_create();\n\tif (!props->dial) {\n\t\treturn -1;\n\t}\n\tif (ast_dial_append(props->dial, props->transferer_type, props->transferer_addr, NULL)) {\n\t\treturn -1;\n\t}\n\tif (ast_dial_prerun(props->dial, NULL, cap)) {\n\t\treturn -1;\n\t}\n\t\n\trecall = ast_dial_get_channel(props->dial, 0);\n\tif (!recall) {\n\t\treturn -1;\n\t}\n\tast_channel_lock_both(recall, props->transferer);\n\tast_party_caller_copy(ast_channel_caller(recall),\n\t\tast_channel_caller(props->transferer));\n\tast_party_connected_line_copy(ast_channel_connected(recall),\n\t\t&props->original_transferer_colp);\n\tcommon_recall_channel_setup(recall, props->transferer);\n\tast_channel_unlock(recall);\n\tast_channel_unlock(props->transferer);\n\tast_dial_set_state_callback(props->dial, recall_callback);\n\tao2_ref(props, +1);\n\tast_dial_set_user_data(props->dial, props);\n\tif (ast_dial_run(props->dial, NULL, 1) == AST_DIAL_RESULT_FAILED) {\n\t\tao2_ref(props, -1);\n\t\treturn -1;\n\t}\n\tbridge_ringing(props->transferee_bridge);\n\treturn 0;\n}\n", "bug_type": null, "idx": 490}
{"project": "Asterisk", "target": 0, "func": "int ast_parking_register_bridge_features(struct ast_parking_bridge_feature_fn_table *fn_table)\n{\n\tRAII_VAR(struct ast_parking_bridge_feature_fn_table *, wrapper,\n\t\tao2_global_obj_ref(parking_provider), ao2_cleanup);\n\tif (fn_table->module_version != PARKING_MODULE_VERSION) {\n\t\tast_log(AST_LOG_WARNING, \"Parking module provided incorrect parking module \"\n\t\t\t\"version: %u (expected: %d)\\n\", fn_table->module_version, PARKING_MODULE_VERSION);\n\t\treturn -1;\n\t}\n\tif (wrapper) {\n\t\tast_log(AST_LOG_WARNING, \"Parking provider already registered by %s!\\n\",\n\t\t\twrapper->module_name);\n\t\treturn -1;\n\t}\n\twrapper = ao2_alloc(sizeof(*wrapper), NULL);\n\tif (!wrapper) {\n\t\treturn -1;\n\t}\n\t*wrapper = *fn_table;\n\tao2_global_obj_replace_unref(parking_provider, wrapper);\n\treturn 0;\n}\n", "bug_type": null, "idx": 491}
{"project": "Asterisk", "target": 0, "func": "struct ast_stream_topology *ast_channel_set_stream_topology(struct ast_channel *chan,\n\tstruct ast_stream_topology *topology)\n{\n\tstruct ast_stream_topology *new_topology;\n\tast_assert(chan != NULL);\n\t\n\tast_assert(ast_channel_is_multistream(chan));\n\t\n\tif (!topology) {\n\t\tnew_topology = ast_stream_topology_alloc();\n\t} else {\n\t\tnew_topology = topology;\n\t}\n\tif (new_topology) {\n\t\tast_channel_internal_set_stream_topology(chan, new_topology);\n\t}\n\treturn new_topology;\n}\n", "bug_type": null, "idx": 492}
{"project": "Asterisk", "target": 0, "func": "\nstatic int handle_registration_response(void *data)\n{\n\tstruct registration_response *response = data;\n\tpjsip_regc_info info;\n\tchar server_uri[PJSIP_MAX_URL_SIZE];\n\tchar client_uri[PJSIP_MAX_URL_SIZE];\n\tif (response->client_state->status == SIP_REGISTRATION_STOPPED) {\n\t\tao2_ref(response, -1);\n\t\treturn 0;\n\t}\n\tpjsip_regc_get_info(response->client_state->client, &info);\n\tast_copy_pj_str(server_uri, &info.server_uri, sizeof(server_uri));\n\tast_copy_pj_str(client_uri, &info.client_uri, sizeof(client_uri));\n\tast_debug(1, \"Processing REGISTER response %d from server '%s' for client '%s'\\n\",\n\t\t\tresponse->code, server_uri, client_uri);\n\tif ((response->code == 401 || response->code == 407)\n\t\t&& (!response->client_state->auth_attempted\n\t\t\t|| response->rdata->msg_info.cseq->cseq != response->client_state->auth_cseq)) {\n\t\tint res;\n\t\tpjsip_cseq_hdr *cseq_hdr;\n\t\tpjsip_tx_data *tdata;\n\t\tif (!ast_sip_create_request_with_auth(&response->client_state->outbound_auths,\n\t\t\t\tresponse->rdata, response->old_request, &tdata)) {\n\t\t\tresponse->client_state->auth_attempted = 1;\n\t\t\tast_debug(1, \"Sending authenticated REGISTER to server '%s' from client '%s'\\n\",\n\t\t\t\t\tserver_uri, client_uri);\n\t\t\tpjsip_tx_data_add_ref(tdata);\n\t\t\tres = registration_client_send(response->client_state, tdata);\n\t\t\t\n\t\t\tcseq_hdr = (pjsip_cseq_hdr *) pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CSEQ,\n\t\t\t\tNULL);\n\t\t\tresponse->client_state->auth_cseq = cseq_hdr->cseq;\n\t\t\tpjsip_tx_data_dec_ref(tdata);\n\t\t\tif (res == PJ_SUCCESS) {\n\t\t\t\tao2_ref(response, -1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Failed to create authenticated REGISTER request to server '%s' from client '%s'\\n\",\n\t\t\t\t\tserver_uri, client_uri);\n\t\t}\n\t\t\n\t}\n\tresponse->client_state->auth_attempted = 0;\n\tif (PJSIP_IS_STATUS_IN_CLASS(response->code, 200)) {\n\t\t\n\t\tif (response->expiration) {\n\t\t\tint next_registration_round;\n\t\t\t\n\t\t\tast_debug(1, \"Outbound registration to '%s' with client '%s' successful\\n\", server_uri, client_uri);\n\t\t\tupdate_client_state_status(response->client_state, SIP_REGISTRATION_REGISTERED);\n\t\t\tresponse->client_state->retries = 0;\n\t\t\tnext_registration_round = response->expiration - REREGISTER_BUFFER_TIME;\n\t\t\tif (next_registration_round < 0) {\n\t\t\t\t\n\t\t\t\tnext_registration_round = 0;\n\t\t\t}\n\t\t\tschedule_registration(response->client_state, next_registration_round);\n\t\t\t\n\t\t\tregistration_transport_monitor_setup(response->rdata->tp_info.transport,\n\t\t\t\tresponse->client_state->registration_name);\n\t\t} else {\n\t\t\tast_debug(1, \"Outbound unregistration to '%s' with client '%s' successful\\n\", server_uri, client_uri);\n\t\t\tupdate_client_state_status(response->client_state, SIP_REGISTRATION_UNREGISTERED);\n\t\t\tast_sip_transport_monitor_unregister(response->rdata->tp_info.transport,\n\t\t\t\tregistration_transport_shutdown_cb);\n\t\t}\n\t} else if (response->client_state->destroy) {\n\t\t\n\t} else if (response->retry_after) {\n\t\t\n\t\tschedule_retry(response, response->retry_after, server_uri, client_uri);\n\t} else if (response->client_state->retry_interval\n\t\t&& sip_outbound_registration_is_temporal(response->code, response->client_state)) {\n\t\tif (response->client_state->retries == response->client_state->max_retries) {\n\t\t\t\n\t\t\tupdate_client_state_status(response->client_state, SIP_REGISTRATION_REJECTED_PERMANENT);\n\t\t\tast_log(LOG_WARNING, \"Maximum retries reached when attempting outbound registration to '%s' with client '%s', stopping registration attempt\\n\",\n\t\t\t\tserver_uri, client_uri);\n\t\t} else {\n\t\t\t\n\t\t\tresponse->client_state->retries++;\n\t\t\tschedule_retry(response, response->client_state->retry_interval, server_uri, client_uri);\n\t\t}\n\t} else {\n\t\tif (response->code == 403\n\t\t\t&& response->client_state->forbidden_retry_interval\n\t\t\t&& response->client_state->retries < response->client_state->max_retries) {\n\t\t\t\n\t\t\tupdate_client_state_status(response->client_state, SIP_REGISTRATION_REJECTED_TEMPORARY);\n\t\t\tresponse->client_state->retries++;\n\t\t\tschedule_registration(response->client_state, response->client_state->forbidden_retry_interval);\n\t\t\tast_log(LOG_WARNING, \"403 Forbidden fatal response received from '%s' on registration attempt to '%s', retrying in '%u' seconds\\n\",\n\t\t\t\tserver_uri, client_uri, response->client_state->forbidden_retry_interval);\n\t\t} else if (response->client_state->fatal_retry_interval\n\t\t\t   && response->client_state->retries < response->client_state->max_retries) {\n\t\t\t\n\t\t\tupdate_client_state_status(response->client_state, SIP_REGISTRATION_REJECTED_TEMPORARY);\n\t\t\tresponse->client_state->retries++;\n\t\t\tschedule_registration(response->client_state, response->client_state->fatal_retry_interval);\n\t\t\tast_log(LOG_WARNING, \"'%d' fatal response received from '%s' on registration attempt to '%s', retrying in '%u' seconds\\n\",\n\t\t\t\tresponse->code, server_uri, client_uri, response->client_state->fatal_retry_interval);\n\t\t} else {\n\t\t\t\n\t\t\tupdate_client_state_status(response->client_state, SIP_REGISTRATION_REJECTED_PERMANENT);\n\t\t\tif (response->rdata) {\n\t\t\t\tast_log(LOG_WARNING, \"Fatal response '%d' received from '%s' on registration attempt to '%s', stopping outbound registration\\n\",\n\t\t\t\t\tresponse->code, server_uri, client_uri);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Fatal registration attempt to '%s', stopping outbound registration\\n\", client_uri);\n\t\t\t}\n\t\t}\n\t}\n\tast_system_publish_registry(\"PJSIP\", client_uri, server_uri,\n\t\tsip_outbound_registration_status_str(response->client_state->status), NULL);\n\tif (response->client_state->destroy) {\n\t\t\n\t\tao2_ref(response->client_state, +1);\n\t\thandle_client_state_destruction(response->client_state);\n\t}\n\tao2_ref(response, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 493}
{"project": "Asterisk", "target": 0, "func": "static int check_cache_content(struct ast_test *test, struct ast_sorcery *sorcery, struct sorcery_memory_cache *cache,\n\t\tconst char **in_cache, size_t num_in_cache, const char **not_in_cache, size_t num_not_in_cache)\n{\n\tint i;\n\tint res = 0;\n\tRAII_VAR(void *, cached_object, NULL, ao2_cleanup);\n\tfor (i = 0; i < num_in_cache; ++i) {\n\t\tcached_object = sorcery_memory_cache_retrieve_id(sorcery, cache, \"test\", in_cache[i]);\n\t\tif (!cached_object) {\n\t\t\tast_test_status_update(test, \"Failed to retrieve '%s' object from the cache\\n\",\n\t\t\t\t\tin_cache[i]);\n\t\t\tres = -1;\n\t\t}\n\t\tao2_ref(cached_object, -1);\n\t}\n\tfor (i = 0; i < num_not_in_cache; ++i) {\n\t\tcached_object = sorcery_memory_cache_retrieve_id(sorcery, cache, \"test\", not_in_cache[i]);\n\t\tif (cached_object) {\n\t\t\tast_test_status_update(test, \"Retrieved '%s' object from the cache unexpectedly\\n\",\n\t\t\t\t\tnot_in_cache[i]);\n\t\t\tao2_ref(cached_object, -1);\n\t\t\tres = -1;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 494}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel *ast_waitfor_n(struct ast_channel **c, int n, int *ms)\n{\n\treturn ast_waitfor_nandfds(c, n, NULL, 0, NULL, NULL, ms);\n}\n", "bug_type": null, "idx": 495}
{"project": "Asterisk", "target": 0, "func": " */\nstatic iks* xmpp_pubsub_build_publish_skeleton(struct ast_xmpp_client *client, const char *node,\n\t\t\t\t\t       const char *event_type, unsigned int cachable)\n{\n\tRAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);\n\tiks *request, *pubsub, *publish, *item;\n\tif (!cfg || !cfg->global || !(request = xmpp_pubsub_iq_create(client, \"set\"))) {\n\t\treturn NULL;\n\t}\n\tpubsub = iks_insert(request, \"pubsub\");\n\tiks_insert_attrib(pubsub, \"xmlns\", \"http://jabber.org/protocol/pubsub\");\n\tpublish = iks_insert(pubsub, \"publish\");\n\tiks_insert_attrib(publish, \"node\", ast_test_flag(&cfg->global->pubsub, XMPP_XEP0248) ? node : event_type);\n\titem = iks_insert(publish, \"item\");\n\tiks_insert_attrib(item, \"id\", node);\n\tif (cachable == AST_DEVSTATE_NOT_CACHABLE) {\n\t\tiks *options, *x, *field_form_type, *field_persist;\n\t\toptions = iks_insert(pubsub, \"publish-options\");\n\t\tx = iks_insert(options, \"x\");\n\t\tiks_insert_attrib(x, \"xmlns\", \"jabber:x:data\");\n\t\tiks_insert_attrib(x, \"type\", \"submit\");\n\t\tfield_form_type = iks_insert(x, \"field\");\n\t\tiks_insert_attrib(field_form_type, \"var\", \"FORM_TYPE\");\n\t\tiks_insert_attrib(field_form_type, \"type\", \"hidden\");\n\t\tiks_insert_cdata(iks_insert(field_form_type, \"value\"), \"http://jabber.org/protocol/pubsub#publish-options\", 0);\n\t\tfield_persist = iks_insert(x, \"field\");\n\t\tiks_insert_attrib(field_persist, \"var\", \"pubsub#persist_items\");\n\t\tiks_insert_cdata(iks_insert(field_persist, \"value\"), \"0\", 1);\n\t}\n\treturn item;\n}\n", "bug_type": null, "idx": 496}
{"project": "Asterisk", "target": 0, "func": "AST_MUTEX_DEFINE_STATIC(f_lock);\nstatic int load_config(int reload)\n{\n\tstruct ast_config *cfg;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\tif (!(cfg = ast_config_load(config, config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_WARNING, \"unable to load config: %s\\n\", config);\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {\n\t\treturn 1;\n\t}\n\taccountlogs = 1;\n\tusegmtime = 0;\n\tloguniqueid = 0;\n\tloguserfield = 0;\n\tnewcdrcolumns = 0;\n\tif (!(v = ast_variable_browse(cfg, \"csv\"))) {\n\t\tast_config_destroy(cfg);\n\t\treturn 0;\n\t}\n\t\n\tast_mutex_lock(&f_lock);\n\tsnprintf(file_csv_master, sizeof(file_csv_master),\n\t\t\"%s/%s/%s\", ast_config_AST_LOG_DIR, CSV_LOG_DIR, CSV_MASTER);\n\tast_mutex_unlock(&f_lock);\n\tfor (; v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"usegmtime\")) {\n\t\t\tusegmtime = ast_true(v->value);\n\t\t} else if (!strcasecmp(v->name, \"accountlogs\")) {\n\t\t\t\n\t\t\taccountlogs = ast_true(v->value);\n\t\t} else if (!strcasecmp(v->name, \"loguniqueid\")) {\n\t\t\tloguniqueid = ast_true(v->value);\n\t\t} else if (!strcasecmp(v->name, \"loguserfield\")) {\n\t\t\tloguserfield = ast_true(v->value);\n\t\t} else if (!strcasecmp(v->name, \"newcdrcolumns\")) {\n\t\t\tnewcdrcolumns = ast_true(v->value);\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n\treturn 1;\n}\n", "bug_type": null, "idx": 497}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245H263Version3Options (OOCTXT* pctxt, H245H263Version3Options* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"dataPartitionedSlices\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->dataPartitionedSlices);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->dataPartitionedSlices);\n   invokeEndElement (pctxt, \"dataPartitionedSlices\", -1);\n   \n   invokeStartElement (pctxt, \"fixedPointIDCT0\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->fixedPointIDCT0);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->fixedPointIDCT0);\n   invokeEndElement (pctxt, \"fixedPointIDCT0\", -1);\n   \n   invokeStartElement (pctxt, \"interlacedFields\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->interlacedFields);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->interlacedFields);\n   invokeEndElement (pctxt, \"interlacedFields\", -1);\n   \n   invokeStartElement (pctxt, \"currentPictureHeaderRepetition\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->currentPictureHeaderRepetition);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->currentPictureHeaderRepetition);\n   invokeEndElement (pctxt, \"currentPictureHeaderRepetition\", -1);\n   \n   invokeStartElement (pctxt, \"previousPictureHeaderRepetition\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->previousPictureHeaderRepetition);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->previousPictureHeaderRepetition);\n   invokeEndElement (pctxt, \"previousPictureHeaderRepetition\", -1);\n   \n   invokeStartElement (pctxt, \"nextPictureHeaderRepetition\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->nextPictureHeaderRepetition);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->nextPictureHeaderRepetition);\n   invokeEndElement (pctxt, \"nextPictureHeaderRepetition\", -1);\n   \n   invokeStartElement (pctxt, \"pictureNumber\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->pictureNumber);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->pictureNumber);\n   invokeEndElement (pctxt, \"pictureNumber\", -1);\n   \n   invokeStartElement (pctxt, \"spareReferencePictures\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->spareReferencePictures);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->spareReferencePictures);\n   invokeEndElement (pctxt, \"spareReferencePictures\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 498}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct state *sstate_alloc(void)\n{\n\tstruct state *p = ast_calloc(1, sizeof(*p));\n\tif (p != NULL) {\n\t\tSP_HEAP_INIT(p);\n\t}\n\treturn p;\n}\n", "bug_type": null, "idx": 499}
{"project": "Asterisk", "target": 0, "func": "static enum ast_test_result_state wait_until_thread_state_task_pushed(struct ast_test *test,\n\t\tstruct test_listener_data *tld, int num_active, int num_idle, int num_tasks)\n{\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\tstruct timeval start;\n\tstruct timespec end;\n\tres = wait_until_thread_state(test, tld, num_active, num_idle);\n\tif (res == AST_TEST_FAIL) {\n\t\treturn res;\n\t}\n\tstart = ast_tvnow();\n\tend.tv_sec = start.tv_sec + 5;\n\tend.tv_nsec = start.tv_usec * 1000;\n\tast_mutex_lock(&tld->lock);\n\twhile (tld->num_tasks != num_tasks) {\n\t\tif (ast_cond_timedwait(&tld->cond, &tld->lock, &end) == ETIMEDOUT) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tld->num_tasks != num_tasks) {\n\t\tast_test_status_update(test, \"Number of tasks pushed %d does not match expected %d\\n\",\n\t\t\t\ttld->num_tasks, num_tasks);\n\t\tres = AST_TEST_FAIL;\n\t}\n\tast_mutex_unlock(&tld->lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 500}
{"project": "Asterisk", "target": 0, "func": "int sig_pri_hangup(struct sig_pri_chan *p, struct ast_channel *ast)\n{\n\tast_debug(1, \"%s %d\\n\", __FUNCTION__, p->channel);\n\tif (!ast_channel_tech_pvt(ast)) {\n\t\tast_log(LOG_WARNING, \"Asked to hangup channel not connected\\n\");\n\t\treturn 0;\n\t}\n\tsig_pri_set_outgoing(p, 0);\n\tsig_pri_set_digital(p, 0);\t\n#if defined(HAVE_PRI_CALL_WAITING)\n\tif (p->is_call_waiting) {\n\t\tp->is_call_waiting = 0;\n\t\tast_atomic_fetchadd_int(&p->pri->num_call_waiting_calls, -1);\n\t}\n#endif\t\n\tp->call_level = SIG_PRI_CALL_LEVEL_IDLE;\n\tp->progress = 0;\n\tp->cid_num[0] = '\\0';\n\tp->cid_subaddr[0] = '\\0';\n\tp->cid_name[0] = '\\0';\n\tp->user_tag[0] = '\\0';\n\tp->exten[0] = '\\0';\n\tsig_pri_set_dialing(p, 0);\n\t\n\tpri_grab(p, p->pri);\n\tsig_pri_moh_fsm_event(ast, p, SIG_PRI_MOH_EVENT_RESET);\n\tif (p->call) {\n#if defined(SUPPORT_USERUSER)\n\t\tconst char *useruser = pbx_builtin_getvar_helper(ast, \"USERUSERINFO\");\n\t\tif (!ast_strlen_zero(useruser)) {\n\t\t\tpri_call_set_useruser(p->call, useruser);\n\t\t}\n#endif\t\n#if defined(HAVE_PRI_TRANSFER)\n\t\tif (p->xfer_data) {\n\t\t\t\n\t\t\tsig_pri_transfer_rsp(p->xfer_data, 1);\n\t\t}\n#endif\t\n#if defined(HAVE_PRI_AOC_EVENTS)\n\t\tif (p->holding_aoce) {\n\t\t\tpri_aoc_e_send(p->pri->pri, p->call, &p->aoc_e);\n\t\t}\n#endif\t\n\t\tif (p->alreadyhungup) {\n\t\t\tast_debug(1, \"Already hungup...  Calling hangup once, and clearing call\\n\");\n\t\t\tpri_hangup(p->pri->pri, p->call, -1);\n\t\t\tp->call = NULL;\n\t\t} else {\n\t\t\tconst char *cause = pbx_builtin_getvar_helper(ast,\"PRI_CAUSE\");\n\t\t\tint icause = ast_channel_hangupcause(ast) ? ast_channel_hangupcause(ast) : -1;\n\t\t\tp->alreadyhungup = 1;\n\t\t\tif (!ast_strlen_zero(cause)) {\n\t\t\t\tif (atoi(cause)) {\n\t\t\t\t\ticause = atoi(cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_debug(1,\n\t\t\t\t\"Not yet hungup...  Calling hangup with cause %d, and clearing call\\n\",\n\t\t\t\ticause);\n\t\t\tpri_hangup(p->pri->pri, p->call, icause);\n\t\t}\n\t}\n#if defined(HAVE_PRI_TRANSFER)\n\tp->xfer_data = NULL;\n#endif\t\n#if defined(HAVE_PRI_AOC_EVENTS)\n\tp->aoc_s_request_invoke_id_valid = 0;\n\tp->holding_aoce = 0;\n\tp->waiting_for_aoce = 0;\n#endif\t\n\tp->allocated = 0;\n\tp->owner = NULL;\n\tsig_pri_span_devstate_changed(p->pri);\n\tpri_rel(p->pri);\n\treturn 0;\n}\n", "bug_type": null, "idx": 501}
{"project": "Asterisk", "target": 0, "func": "static AST_RWLIST_HEAD_STATIC(sinks, cdr_syslog_config);\nstatic void free_config(void)\n{\n\tstruct cdr_syslog_config *sink;\n\twhile ((sink = AST_RWLIST_REMOVE_HEAD(&sinks, list))) {\n\t\tast_mutex_destroy(&sink->lock);\n\t\tast_string_field_free_memory(sink);\n\t\tast_free(sink);\n\t}\n}\n", "bug_type": null, "idx": 502}
{"project": "Asterisk", "target": 0, "func": "int ast_format_cache_init(void)\n{\n\tformats = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_RWLOCK, CACHE_BUCKETS,\n\t\tformat_hash_cb, format_cmp_cb);\n\tif (!formats) {\n\t\treturn -1;\n\t}\n\tast_register_cleanup(format_cache_shutdown);\n\treturn 0;\n}\n", "bug_type": null, "idx": 503}
{"project": "Asterisk", "target": 0, "func": "int ast_adsi_display(unsigned char *buf, int page, int line, int just, int wrap, char *col1, char *col2)\n{\n\tint res = 0;\n\tast_rwlock_rdlock(&func_lock);\n\tif (installed_funcs && installed_funcs->display) {\n\t\tres = installed_funcs->display(buf, page, line, just, wrap, col1, col2);\n\t}\n\tast_rwlock_unlock(&func_lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 504}
{"project": "Asterisk", "target": 0, "func": "int ast_queue_unhold(struct ast_channel *chan)\n{\n\tstruct ast_frame f = { AST_FRAME_CONTROL, .subclass.integer = AST_CONTROL_UNHOLD };\n\tint res;\n\tast_channel_publish_cached_blob(chan, ast_channel_unhold_type(), NULL);\n\tres = ast_queue_frame(chan, &f);\n\treturn res;\n}\n", "bug_type": null, "idx": 505}
{"project": "Asterisk", "target": 0, "func": "void pvalConditionalSetElseStatement( pval *p, pval *statement )\n{\n\tp->u3.else_statements = statement;\n}\n", "bug_type": null, "idx": 506}
{"project": "Asterisk", "target": 0, "func": "struct stasis_topic *ast_channel_topic_all(void)\n{\n\treturn stasis_cp_all_topic(channel_cache_all);\n}\n", "bug_type": null, "idx": 507}
{"project": "Asterisk", "target": 0, "func": "\nstatic int process_config(int reload)\n{\n\tRAII_VAR(struct ast_ari_conf *, conf, NULL, ao2_cleanup);\n\tswitch (aco_process_config(&cfg_info, reload)) {\n\tcase ACO_PROCESS_ERROR:\n\t\treturn -1;\n\tcase ACO_PROCESS_OK:\n\tcase ACO_PROCESS_UNCHANGED:\n\t\tbreak;\n\t}\n\tconf = ast_ari_config_get();\n\tif (!conf) {\n\t\tast_assert(0); \n\t\treturn -1;\n\t}\n\tif (conf->general->enabled) {\n\t\tif (ao2_container_count(conf->users) == 0) {\n\t\t\tast_log(LOG_ERROR, \"No configured users for ARI\\n\");\n\t\t} else {\n\t\t\tao2_callback(conf->users, OBJ_NODATA, validate_user_cb, NULL);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 508}
{"project": "Asterisk", "target": 0, "func": "\nstatic void ast_tone_zone_destructor(void *obj)\n{\n\tstruct ast_tone_zone *zone = obj;\n\tstruct ast_tone_zone_sound *current;\n\twhile ((current = AST_LIST_REMOVE_HEAD(&zone->tones, entry))) {\n\t\tcurrent = ast_tone_zone_sound_unref(current);\n\t}\n\tif (zone->ringcadence) {\n\t\tast_free(zone->ringcadence);\n\t\tzone->ringcadence = NULL;\n\t}\n}\n", "bug_type": null, "idx": 509}
{"project": "Asterisk", "target": 0, "func": "#ifdef NOT_ANYMORE\nstatic struct ast_switch *pbx_findswitch(const char *sw)\n{\n\tstruct ast_switch *asw;\n\tAST_RWLIST_TRAVERSE(&switches, asw, list) {\n\t\tif (!strcasecmp(asw->name, sw))\n\t\t\tbreak;\n\t}\n\treturn asw;\n}\n", "bug_type": null, "idx": 510}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_priority_set(struct ast_channel *chan, int value)\n{\n\tchan->priority = value;\n}\n", "bug_type": null, "idx": 511}
{"project": "Asterisk", "target": 0, "func": "static int item_in_vector(const struct resource_list *list, const char *item)\n{\n\tint i;\n\tfor (i = 0; i < AST_VECTOR_SIZE(&list->items); ++i) {\n\t\tif (!strcmp(item, AST_VECTOR_GET(&list->items, i))) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 512}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245TerminalInformation (OOCTXT* pctxt, H245TerminalInformation* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"terminalLabel\", -1);\n   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"terminalLabel\", -1);\n   \n   invokeStartElement (pctxt, \"terminalID\", -1);\n   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"terminalID\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 513}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_session_suspend(struct ast_sip_session *session)\n{\n\tstruct ast_sip_session_suspender *suspender;\n\tint res;\n\tast_assert(session->suspended == NULL);\n\tif (ast_taskprocessor_is_task(session->serializer)) {\n\t\t\n\t\treturn;\n\t}\n\tif (ast_taskprocessor_is_suspended(session->serializer)) {\n\t\t\n\t\treturn;\n\t}\n\tsuspender = ao2_alloc(sizeof(*suspender), sip_session_suspender_dtor);\n\tif (!suspender) {\n\t\t\n\t\treturn;\n\t}\n\tast_cond_init(&suspender->cond_suspended, NULL);\n\tast_cond_init(&suspender->cond_complete, NULL);\n\tao2_ref(suspender, +1);\n\tres = ast_sip_push_task(session->serializer, sip_session_suspend_task, suspender);\n\tif (res) {\n\t\t\n\t\tao2_ref(suspender, -2);\n\t\treturn;\n\t}\n\tsession->suspended = suspender;\n\t\n\tao2_lock(suspender);\n\twhile (!suspender->suspended) {\n\t\tast_cond_wait(&suspender->cond_suspended, ao2_object_get_lockaddr(suspender));\n\t}\n\tao2_unlock(suspender);\n\tast_taskprocessor_suspend(session->serializer);\n}\n", "bug_type": null, "idx": 514}
{"project": "Asterisk", "target": 0, "func": "static int user_no_cmp(void *obj, void *arg, int flags)\n{\n\tstruct ast_conf_user *user = obj;\n\tint *user_no = arg;\n\tif (user->user_no == *user_no) {\n\t\treturn (CMP_MATCH | CMP_STOP);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 515}
{"project": "Asterisk", "target": 0, "func": "static void send_mwi_notify(struct mwi_subscription *sub)\n{\n\tstruct ast_sip_message_accumulator counter = {\n\t\t.old_msgs = 0,\n\t\t.new_msgs = 0,\n\t\t.message_account[0] = '\\0',\n\t};\n\tstruct ast_sip_body_data data = {\n\t\t.body_type = AST_SIP_MESSAGE_ACCUMULATOR,\n\t\t.body_data = &counter,\n\t};\n\tconst char *resource = ast_sip_subscription_get_resource_name(sub->sip_sub);\n\tao2_callback(sub->stasis_subs, OBJ_NODATA, get_message_count, &counter);\n\tif (sub->is_solicited) {\n\t\tstruct ast_sip_endpoint *endpoint = ast_sip_subscription_get_endpoint(sub->sip_sub);\n\t\tstruct ast_sip_aor *aor = find_aor_for_resource(endpoint, resource);\n\t\tpjsip_dialog *dlg = ast_sip_subscription_get_dialog(sub->sip_sub);\n\t\tpjsip_sip_uri *sip_uri = ast_sip_subscription_get_sip_uri(sub->sip_sub);\n\t\tif (aor && dlg && sip_uri) {\n\t\t\tset_voicemail_extension(dlg->pool, sip_uri, &counter, aor->voicemail_extension);\n\t\t}\n\t\tao2_cleanup(aor);\n\t\tao2_cleanup(endpoint);\n\t\tast_sip_subscription_notify(sub->sip_sub, &data, 0);\n\t\treturn;\n\t}\n\tsend_unsolicited_mwi_notify(sub, &counter);\n}\n", "bug_type": null, "idx": 516}
{"project": "Asterisk", "target": 0, "func": "int ast_waitstream_exten(struct ast_channel *c, const char *context)\n{\n\tint res;\n\t\n\t\n\tif (!context)\n\t\tcontext = ast_channel_context(c);\n\tres = waitstream_core(c, NULL, NULL, NULL, 0,\n\t\t-1, -1, context, NULL );\n\treturn sanitize_waitstream_return(res);\n}\n", "bug_type": null, "idx": 517}
{"project": "Asterisk", "target": 0, "func": "\nstatic int multicast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame)\n{\n\tstruct multicast_rtp *multicast = ast_rtp_instance_get_data(instance);\n\tstruct ast_format *format;\n\tstruct ast_frame *f;\n\tint codec;\n\t\n\tif (frame->frametype != AST_FRAME_VOICE) {\n\t\treturn 0;\n\t}\n\t\n\tcodec = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance),\n\t\t1, frame->subclass.format, 0);\n\tif (codec < 0) {\n\t\treturn -1;\n\t}\n\tformat = frame->subclass.format;\n\tif (!multicast->smoother && ast_format_can_be_smoothed(format)) {\n\t\tunsigned int smoother_flags = ast_format_get_smoother_flags(format);\n\t\tunsigned int framing_ms = ast_rtp_codecs_get_framing(ast_rtp_instance_get_codecs(instance));\n\t\tif (!framing_ms && (smoother_flags & AST_SMOOTHER_FLAG_FORCED)) {\n\t\t\tframing_ms = ast_format_get_default_ms(format);\n\t\t}\n\t\tif (framing_ms) {\n\t\t\tmulticast->smoother = ast_smoother_new((framing_ms * ast_format_get_minimum_bytes(format)) / ast_format_get_minimum_ms(format));\n\t\t\tif (!multicast->smoother) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create smoother: format %s ms: %u len %u\\n\",\n\t\t\t\t\t\tast_format_get_name(format), framing_ms, ast_format_get_minimum_bytes(format));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tast_smoother_set_flags(multicast->smoother, smoother_flags);\n\t\t}\n\t}\n\tif (multicast->smoother) {\n\t\tif (ast_smoother_test_flag(multicast->smoother, AST_SMOOTHER_FLAG_BE)) {\n\t\t\tast_smoother_feed_be(multicast->smoother, frame);\n\t\t} else {\n\t\t\tast_smoother_feed(multicast->smoother, frame);\n\t\t}\n\t\twhile ((f = ast_smoother_read(multicast->smoother)) && f->data.ptr) {\n\t\t\trtp_raw_write(instance, f, codec);\n\t\t}\n\t} else {\n\t\tint hdrlen = 12;\n\t\t\n\t\tif (frame->offset < hdrlen) {\n\t\t\tf = ast_frdup(frame);\n\t\t} else {\n\t\t\tf = frame;\n\t\t}\n\t\tif (f->data.ptr) {\n\t\t\trtp_raw_write(instance, f, codec);\n\t\t}\n\t\tif (f != frame) {\n\t\t\tast_frfree(f);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 518}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H235EncodedPwdCertToken (OOCTXT* pctxt, H235EncodedPwdCertToken* pvalue)\n{\n   int stat = ASN_OK;\n   stat = decodeOpenType (pctxt, &pvalue->data, &pvalue->numocts);\n   if (stat != ASN_OK) return stat;\n   invokeOpenTypeValue\n      (pctxt, pvalue->numocts, pvalue->data);\n   return (stat);\n}\n", "bug_type": null, "idx": 519}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_asterisk_unload_module(struct ast_variable *headers,\n\tstruct ast_ari_asterisk_unload_module_args *args,\n\tstruct ast_ari_response *response)\n{\n\tint unload_result;\n\tenum ast_module_unload_mode unload_mode = AST_FORCE_SOFT;\n\tast_assert(response != NULL);\n\tif (!ast_module_check(args->module_name)) {\n\t\tast_ari_response_error(\n\t\t\tresponse, 404, \"Not Found\",\n\t\t\t\"Module not found in running modules\");\n\t\treturn;\n\t}\n\tunload_result = ast_unload_resource(args->module_name, unload_mode);\n\tif (unload_result != 0) {\n\t\tast_ari_response_error(\n\t\t\tresponse, 409, \"Conflict\",\n\t\t\t\"Module could not be unloaded\");\n\t\treturn;\n\t}\n\tast_ari_response_no_content(response);\n}\n", "bug_type": null, "idx": 520}
{"project": "Asterisk", "target": 0, "func": " */\nvoid bridge_channel_internal_suspend_nolock(struct ast_bridge_channel *bridge_channel)\n{\n\tbridge_channel->suspended = 1;\n\tif (bridge_channel->in_bridge) {\n\t\t--bridge_channel->bridge->num_active;\n\t}\n\t\n\tif (bridge_channel->bridge->technology->suspend) {\n\t\tbridge_channel->bridge->technology->suspend(bridge_channel->bridge, bridge_channel);\n\t}\n}\n", "bug_type": null, "idx": 521}
{"project": "Asterisk", "target": 0, "func": "static void discard_call(struct unistimsession *pte)\n{\n\tstruct unistim_subchannel* sub;\n\tsub = get_sub(pte->device, SUB_RING);\n\tif (!sub) {\n\t    return;\n\t}\n\tast_queue_hangup_with_cause(sub->owner, AST_CAUSE_NORMAL_CLEARING);\n\treturn;\n}\n", "bug_type": null, "idx": 522}
{"project": "Asterisk", "target": 0, "func": "STASIS_MESSAGE_TYPE_DEFN(ast_endpoint_snapshot_type);\nstatic struct ast_manager_event_blob *peerstatus_to_ami(struct stasis_message *msg)\n{\n\tstruct ast_endpoint_blob *obj = stasis_message_data(msg);\n\tRAII_VAR(struct ast_str *, peerstatus_event_string, ast_str_create(64), ast_free);\n\tconst char *value;\n\t\n\tif (!(value = ast_json_string_get(ast_json_object_get(obj->blob, \"peer_status\")))) {\n\t\treturn NULL;\n\t}\n\tast_str_append(&peerstatus_event_string, 0, \"PeerStatus: %s\\r\\n\", value);\n\tif ((value = ast_json_string_get(ast_json_object_get(obj->blob, \"cause\")))) {\n\t\tast_str_append(&peerstatus_event_string, 0, \"Cause: %s\\r\\n\", value);\n\t}\n\tif ((value = ast_json_string_get(ast_json_object_get(obj->blob, \"address\")))) {\n\t\tast_str_append(&peerstatus_event_string, 0, \"Address: %s\\r\\n\", value);\n\t}\n\tif ((value = ast_json_string_get(ast_json_object_get(obj->blob, \"port\")))) {\n\t\tast_str_append(&peerstatus_event_string, 0, \"Port: %s\\r\\n\", value);\n\t}\n\tif ((value = ast_json_string_get(ast_json_object_get(obj->blob, \"time\")))) {\n\t\tast_str_append(&peerstatus_event_string, 0, \"Time: %s\\r\\n\", value);\n\t}\n\treturn ast_manager_event_blob_create(EVENT_FLAG_SYSTEM, \"PeerStatus\",\n\t\t\"ChannelType: %s\\r\\n\"\n\t\t\"Peer: %s/%s\\r\\n\"\n\t\t\"%s\",\n\t\tobj->snapshot->tech,\n\t\tobj->snapshot->tech,\n\t\tobj->snapshot->resource,\n\t\tast_str_buffer(peerstatus_event_string));\n}\n", "bug_type": null, "idx": 523}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *__ast_read(struct ast_channel *chan, int dropaudio, int dropnondefault)\n{\n\tstruct ast_frame *f = NULL;\t\n\tint prestate;\n\tint cause = 0;\n\tstruct ast_stream *stream = NULL, *default_stream = NULL;\n\t\n\tast_channel_lock(chan);\n\t\n\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE) || ast_check_hangup(chan)) {\n\t\tif (ast_channel_generator(chan))\n\t\t\tast_deactivate_generator(chan);\n\t\t\n\t\tif (ast_channel_softhangup_internal_flag(chan)) {\n\t\t\tast_queue_control(chan, AST_CONTROL_END_OF_Q);\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t} else {\n#ifdef AST_DEVMODE\n\t\t\n\t\tif (ast_channel_fdno(chan) == -1) {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ast_read() on chan '%s' called with no recorded file descriptor.\\n\",\n\t\t\t\tast_channel_name(chan));\n\t\t}\n#endif\n\t}\n\tprestate = ast_channel_state(chan);\n\tif (ast_channel_timingfd(chan) > -1 && ast_channel_fdno(chan) == AST_TIMING_FD) {\n\t\tenum ast_timer_event res;\n\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_EXCEPTION);\n\t\tres = ast_timer_get_event(ast_channel_timer(chan));\n\t\tswitch (res) {\n\t\tcase AST_TIMING_EVENT_EXPIRED:\n\t\t\tif (ast_timer_ack(ast_channel_timer(chan), 1) < 0) {\n\t\t\t\tast_log(LOG_ERROR, \"Failed to acknoweldge timer in ast_read\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (ast_channel_timingfunc(chan)) {\n\t\t\t\t\n\t\t\t\tast_timing_func_t func = ast_channel_timingfunc(chan);\n\t\t\t\tvoid *data = ast_channel_timingdata(chan);\n\t\t\t\tint got_ref = 0;\n\t\t\t\tif (data && ast_test_flag(ast_channel_flags(chan), AST_FLAG_TIMINGDATA_IS_AO2_OBJ)) {\n\t\t\t\t\tao2_ref(data, 1);\n\t\t\t\t\tgot_ref = 1;\n\t\t\t\t}\n\t\t\t\tast_channel_fdno_set(chan, -1);\n\t\t\t\tast_channel_unlock(chan);\n\t\t\t\tfunc(data);\n\t\t\t\tif (got_ref) {\n\t\t\t\t\tao2_ref(data, -1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_timer_set_rate(ast_channel_timer(chan), 0);\n\t\t\t\tast_channel_fdno_set(chan, -1);\n\t\t\t\tast_channel_unlock(chan);\n\t\t\t}\n\t\t\t\n\t\t\treturn &ast_null_frame;\n\t\tcase AST_TIMING_EVENT_CONTINUOUS:\n\t\t\tif (AST_LIST_EMPTY(ast_channel_readq(chan)) ||\n\t\t\t\t!AST_LIST_NEXT(AST_LIST_FIRST(ast_channel_readq(chan)), frame_list)) {\n\t\t\t\tast_timer_disable_continuous(ast_channel_timer(chan));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else if (ast_channel_fd_isset(chan, AST_GENERATOR_FD) && ast_channel_fdno(chan) == AST_GENERATOR_FD) {\n\t\t\n\t\tvoid *tmp = ast_channel_generatordata(chan);\n\t\tast_channel_generatordata_set(chan, NULL);     \n\t\tast_channel_generator(chan)->generate(chan, tmp, -1, -1);\n\t\tast_channel_generatordata_set(chan, tmp);\n\t\tf = &ast_null_frame;\n\t\tast_channel_fdno_set(chan, -1);\n\t\tgoto done;\n\t} else if (ast_channel_fd_isset(chan, AST_JITTERBUFFER_FD) && ast_channel_fdno(chan) == AST_JITTERBUFFER_FD) {\n\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_EXCEPTION);\n\t}\n\t\n\tif (ast_channel_internal_alert_read(chan) == AST_ALERT_READ_FATAL) {\n\t\tf = &ast_null_frame;\n\t\tgoto done;\n\t}\n\t\n\tif (!AST_LIST_EMPTY(ast_channel_readq(chan))) {\n\t\tint skip_dtmf = should_skip_dtmf(chan);\n\t\tAST_LIST_TRAVERSE_SAFE_BEGIN(ast_channel_readq(chan), f, frame_list) {\n\t\t\t\n\t\t\tif ( (f->frametype == AST_FRAME_DTMF_BEGIN || f->frametype == AST_FRAME_DTMF_END) && skip_dtmf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAST_LIST_REMOVE_CURRENT(frame_list);\n\t\t\tbreak;\n\t\t}\n\t\tAST_LIST_TRAVERSE_SAFE_END;\n\t\tif (!f) {\n\t\t\t\n\t\t\tf = &ast_null_frame;\n\t\t\tast_channel_alert_write(chan);\n\t\t}\n\t\t\n\t\t\n\t\tif (f->frametype == AST_FRAME_CONTROL) {\n\t\t\tswitch (f->subclass.integer) {\n\t\t\tcase AST_CONTROL_HANGUP:\n\t\t\t\tast_channel_softhangup_internal_flag_add(chan, AST_SOFTHANGUP_DEV);\n\t\t\t\tcause = f->data.uint32;\n\t\t\t\t\n\t\t\tcase AST_CONTROL_END_OF_Q:\n\t\t\t\tast_frfree(f);\n\t\t\t\tf = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (f->frametype == AST_FRAME_VOICE || f->frametype == AST_FRAME_VIDEO) {\n\t\t\tif (ast_channel_tech(chan) && ast_channel_tech(chan)->read_stream) {\n\t\t\t\tstream = ast_stream_topology_get_stream(ast_channel_get_stream_topology(chan), f->stream_num);\n\t\t\t\tdefault_stream = ast_channel_get_default_stream(chan, ast_format_get_type(f->subclass.format));\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tstream = default_stream = ast_channel_get_default_stream(chan, ast_format_get_type(f->subclass.format));\n\t\t\t\tf->stream_num = ast_stream_get_position(stream);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tast_channel_blocker_set(chan, pthread_self());\n\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_EXCEPTION)) {\n\t\t\tif (ast_channel_tech(chan)->exception)\n\t\t\t\tf = ast_channel_tech(chan)->exception(chan);\n\t\t\telse {\n\t\t\t\tast_log(LOG_WARNING, \"Exception flag set on '%s', but no exception handler\\n\", ast_channel_name(chan));\n\t\t\t\tf = &ast_null_frame;\n\t\t\t}\n\t\t\t\n\t\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_EXCEPTION);\n\t\t} else if (ast_channel_tech(chan) && ast_channel_tech(chan)->read_stream) {\n\t\t\tf = ast_channel_tech(chan)->read_stream(chan);\n\t\t\t\n\t\t\tif (f && (f->frametype == AST_FRAME_VOICE || f->frametype == AST_FRAME_VIDEO)) {\n\t\t\t\tstream = ast_stream_topology_get_stream(ast_channel_get_stream_topology(chan), f->stream_num);\n\t\t\t\tdefault_stream = ast_channel_get_default_stream(chan, ast_format_get_type(f->subclass.format));\n\t\t\t}\n\t\t} else if (ast_channel_tech(chan) && ast_channel_tech(chan)->read) {\n\t\t\tf = ast_channel_tech(chan)->read(chan);\n\t\t\t\n\t\t\tif (f && (f->frametype == AST_FRAME_VOICE || f->frametype == AST_FRAME_VIDEO)) {\n\t\t\t\tstream = default_stream = ast_channel_get_default_stream(chan, ast_format_get_type(f->subclass.format));\n\t\t\t\tf->stream_num = ast_stream_get_position(stream);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tast_log(LOG_WARNING, \"No read routine on channel %s\\n\", ast_channel_name(chan));\n\t}\n\tif (stream == default_stream) {\n\t\t\n\t\tf = ast_framehook_list_read_event(ast_channel_framehooks(chan), f);\n\t}\n\t\n\tast_channel_fdno_set(chan, -1);\n\tif (f) {\n\t\tstruct ast_frame *readq_tail = AST_LIST_LAST(ast_channel_readq(chan));\n\t\tstruct ast_control_read_action_payload *read_action_payload;\n\t\tstruct ast_party_connected_line connected;\n\t\tint hooked = 0;\n\t\t\n\t\tif (AST_LIST_NEXT(f, frame_list)) {\n\t\t\tast_queue_frame(chan, AST_LIST_NEXT(f, frame_list));\n\t\t\tast_frfree(AST_LIST_NEXT(f, frame_list));\n\t\t\tAST_LIST_NEXT(f, frame_list) = NULL;\n\t\t}\n\t\tif (dropnondefault && stream != default_stream) {\n\t\t\t\n\t\t\tast_frfree(f);\n\t\t\tf = &ast_null_frame;\n\t\t}\n\t\tswitch (f->frametype) {\n\t\tcase AST_FRAME_CONTROL:\n\t\t\tif (f->subclass.integer == AST_CONTROL_ANSWER) {\n\t\t\t\tif (prestate == AST_STATE_UP && ast_channel_is_bridged(chan)) {\n\t\t\t\t\tast_debug(1, \"Dropping duplicate answer!\\n\");\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tf = &ast_null_frame;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tset_channel_answer_time(chan);\n\t\t\t\t\tast_setstate(chan, AST_STATE_UP);\n\t\t\t\t}\n\t\t\t} else if (f->subclass.integer == AST_CONTROL_READ_ACTION) {\n\t\t\t\tread_action_payload = f->data.ptr;\n\t\t\t\tswitch (read_action_payload->action) {\n\t\t\t\tcase AST_FRAME_READ_ACTION_CONNECTED_LINE_MACRO:\n\t\t\t\t\tast_party_connected_line_init(&connected);\n\t\t\t\t\tast_party_connected_line_copy(&connected, ast_channel_connected(chan));\n\t\t\t\t\tif (ast_connected_line_parse_data(read_action_payload->payload,\n\t\t\t\t\t\tread_action_payload->payload_size, &connected)) {\n\t\t\t\t\t\tast_party_connected_line_free(&connected);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tast_channel_unlock(chan);\n\t\t\t\t\tif (ast_channel_connected_line_sub(NULL, chan, &connected, 0) &&\n\t\t\t\t\t\tast_channel_connected_line_macro(NULL, chan, &connected, 1, 0)) {\n\t\t\t\t\t\tast_indicate_data(chan, AST_CONTROL_CONNECTED_LINE,\n\t\t\t\t\t\t\tread_action_payload->payload,\n\t\t\t\t\t\t\tread_action_payload->payload_size);\n\t\t\t\t\t}\n\t\t\t\t\tast_party_connected_line_free(&connected);\n\t\t\t\t\tast_channel_lock(chan);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tast_frfree(f);\n\t\t\t\tf = &ast_null_frame;\n\t\t\t} else if (f->subclass.integer == AST_CONTROL_STREAM_TOPOLOGY_REQUEST_CHANGE && dropnondefault) {\n\t\t\t\t\n\t\t\t\tast_channel_stream_topology_changed(chan, ast_channel_get_stream_topology(chan));\n\t\t\t\tast_frfree(f);\n\t\t\t\tf = &ast_null_frame;\n\t\t\t} else if (f->subclass.integer == AST_CONTROL_STREAM_TOPOLOGY_CHANGED && dropnondefault) {\n\t\t\t\t\n\t\t\t\tast_frfree(f);\n\t\t\t\tf = &ast_null_frame;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AST_FRAME_DTMF_END:\n\t\t\tsend_dtmf_end_event(chan, DTMF_RECEIVED, f->subclass.integer, f->len);\n\t\t\tast_log(LOG_DTMF, \"DTMF end '%c' received on %s, duration %ld ms\\n\", f->subclass.integer, ast_channel_name(chan), f->len);\n\t\t\t\n\t\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_DEFER_DTMF) || ast_test_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF)) {\n\t\t\t\tqueue_dtmf_readq(chan, f);\n\t\t\t\tast_frfree(f);\n\t\t\t\tf = &ast_null_frame;\n\t\t\t} else if (!ast_test_flag(ast_channel_flags(chan), AST_FLAG_IN_DTMF | AST_FLAG_END_DTMF_ONLY)) {\n\t\t\t\tif (!ast_tvzero(*ast_channel_dtmf_tv(chan)) &&\n\t\t\t\t    ast_tvdiff_ms(ast_tvnow(), *ast_channel_dtmf_tv(chan)) < AST_MIN_DTMF_GAP) {\n\t\t\t\t\t\n\t\t\t\t\tqueue_dtmf_readq(chan, f);\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tf = &ast_null_frame;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tstruct timeval tv = ast_tvnow();\n\t\t\t\t\tf->frametype = AST_FRAME_DTMF_BEGIN;\n\t\t\t\t\tast_set_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF);\n\t\t\t\t\tast_channel_dtmf_digit_to_emulate_set(chan, f->subclass.integer);\n\t\t\t\t\tast_channel_dtmf_tv_set(chan, &tv);\n\t\t\t\t\tif (f->len) {\n\t\t\t\t\t\tif (f->len > option_dtmfminduration)\n\t\t\t\t\t\t\tast_channel_emulate_dtmf_duration_set(chan, f->len);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tast_channel_emulate_dtmf_duration_set(chan, option_dtmfminduration);\n\t\t\t\t\t} else\n\t\t\t\t\t\tast_channel_emulate_dtmf_duration_set(chan, AST_DEFAULT_EMULATE_DTMF_DURATION);\n\t\t\t\t\tast_log(LOG_DTMF, \"DTMF begin emulation of '%c' with duration %u queued on %s\\n\", f->subclass.integer, ast_channel_emulate_dtmf_duration(chan), ast_channel_name(chan));\n\t\t\t\t}\n\t\t\t\tif (ast_channel_audiohooks(chan)) {\n\t\t\t\t\tstruct ast_frame *old_frame = f;\n\t\t\t\t\t\n\t\t\t\t\tf = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);\n\t\t\t\t\tif (old_frame != f)\n\t\t\t\t\t\tast_frfree(old_frame);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct timeval now = ast_tvnow();\n\t\t\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_IN_DTMF)) {\n\t\t\t\t\tast_log(LOG_DTMF, \"DTMF end accepted with begin '%c' on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\t\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_IN_DTMF);\n\t\t\t\t\tif (!f->len)\n\t\t\t\t\t\tf->len = ast_tvdiff_ms(now, *ast_channel_dtmf_tv(chan));\n\t\t\t\t\t\n\t\t\t\t\tif (ast_tvdiff_ms(now, *ast_channel_dtmf_tv(chan)) < option_dtmfminduration) {\n\t\t\t\t\t\tf->len = ast_tvdiff_ms(now, *ast_channel_dtmf_tv(chan));\n\t\t\t\t\t\tast_log(LOG_DTMF, \"DTMF end '%c' detected to have actual duration %ld on the wire, emulation will be triggered on %s\\n\", f->subclass.integer, f->len, ast_channel_name(chan));\n\t\t\t\t\t}\n\t\t\t\t} else if (!f->len) {\n\t\t\t\t\tast_log(LOG_DTMF, \"DTMF end accepted without begin '%c' on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\t\t\tf->len = option_dtmfminduration;\n\t\t\t\t}\n\t\t\t\tif (f->len < option_dtmfminduration && !ast_test_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY)) {\n\t\t\t\t\tast_log(LOG_DTMF, \"DTMF end '%c' has duration %ld but want minimum %u, emulating on %s\\n\", f->subclass.integer, f->len, option_dtmfminduration, ast_channel_name(chan));\n\t\t\t\t\tast_set_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF);\n\t\t\t\t\tast_channel_dtmf_digit_to_emulate_set(chan, f->subclass.integer);\n\t\t\t\t\tast_channel_emulate_dtmf_duration_set(chan, option_dtmfminduration - f->len);\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tf = &ast_null_frame;\n\t\t\t\t} else {\n\t\t\t\t\tast_log(LOG_DTMF, \"DTMF end passthrough '%c' on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\t\t\tif (f->len < option_dtmfminduration) {\n\t\t\t\t\t\tf->len = option_dtmfminduration;\n\t\t\t\t\t}\n\t\t\t\t\tast_channel_dtmf_tv_set(chan, &now);\n\t\t\t\t}\n\t\t\t\tif (ast_channel_audiohooks(chan)) {\n\t\t\t\t\tstruct ast_frame *old_frame = f;\n\t\t\t\t\tf = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);\n\t\t\t\t\tif (old_frame != f)\n\t\t\t\t\t\tast_frfree(old_frame);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AST_FRAME_DTMF_BEGIN:\n\t\t\tsend_dtmf_begin_event(chan, DTMF_RECEIVED, f->subclass.integer);\n\t\t\tast_log(LOG_DTMF, \"DTMF begin '%c' received on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_DEFER_DTMF | AST_FLAG_END_DTMF_ONLY | AST_FLAG_EMULATE_DTMF) ||\n\t\t\t    (!ast_tvzero(*ast_channel_dtmf_tv(chan)) &&\n\t\t\t      ast_tvdiff_ms(ast_tvnow(), *ast_channel_dtmf_tv(chan)) < AST_MIN_DTMF_GAP) ) {\n\t\t\t\tast_log(LOG_DTMF, \"DTMF begin ignored '%c' on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\t\tast_frfree(f);\n\t\t\t\tf = &ast_null_frame;\n\t\t\t} else {\n\t\t\t\tstruct timeval now = ast_tvnow();\n\t\t\t\tast_set_flag(ast_channel_flags(chan), AST_FLAG_IN_DTMF);\n\t\t\t\tast_channel_dtmf_tv_set(chan, &now);\n\t\t\t\tast_log(LOG_DTMF, \"DTMF begin passthrough '%c' on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AST_FRAME_NULL:\n\t\t\t\n\t\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF)) {\n\t\t\t\tstruct timeval now = ast_tvnow();\n\t\t\t\tif (!ast_channel_emulate_dtmf_duration(chan)) {\n\t\t\t\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF);\n\t\t\t\t\tast_channel_dtmf_digit_to_emulate_set(chan, 0);\n\t\t\t\t} else if (ast_tvdiff_ms(now, *ast_channel_dtmf_tv(chan)) >= ast_channel_emulate_dtmf_duration(chan)) {\n\t\t\t\t\tast_channel_emulate_dtmf_duration_set(chan, 0);\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tf = ast_channel_dtmff(chan);\n\t\t\t\t\tf->frametype = AST_FRAME_DTMF_END;\n\t\t\t\t\tf->subclass.integer = ast_channel_dtmf_digit_to_emulate(chan);\n\t\t\t\t\tf->len = ast_tvdiff_ms(now, *ast_channel_dtmf_tv(chan));\n\t\t\t\t\tast_channel_dtmf_tv_set(chan, &now);\n\t\t\t\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF);\n\t\t\t\t\tast_channel_dtmf_digit_to_emulate_set(chan, 0);\n\t\t\t\t\tast_log(LOG_DTMF, \"DTMF end emulation of '%c' queued on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\t\t\tif (ast_channel_audiohooks(chan)) {\n\t\t\t\t\t\tstruct ast_frame *old_frame = f;\n\t\t\t\t\t\tf = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);\n\t\t\t\t\t\tif (old_frame != f) {\n\t\t\t\t\t\t\tast_frfree(old_frame);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AST_FRAME_VOICE:\n\t\t\t\n\t\t\tif (stream != default_stream) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF) && !ast_channel_emulate_dtmf_duration(chan)) {\n\t\t\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF);\n\t\t\t\tast_channel_dtmf_digit_to_emulate_set(chan, 0);\n\t\t\t}\n\t\t\tif (dropaudio || ast_test_flag(ast_channel_flags(chan), AST_FLAG_IN_DTMF)) {\n\t\t\t\tif (dropaudio)\n\t\t\t\t\tast_read_generator_actions(chan, f);\n\t\t\t\tast_frfree(f);\n\t\t\t\tf = &ast_null_frame;\n\t\t\t}\n\t\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_EMULATE_DTMF) && !ast_test_flag(ast_channel_flags(chan), AST_FLAG_IN_DTMF)) {\n\t\t\t\tstruct timeval now = ast_tvnow();\n\t\t\t\tif (ast_tvdiff_ms(now, *ast_channel_dtmf_tv(chan)) >= ast_channel_emulate_dtmf_duration(chan)) {\n\t\t\t\t\tast_channel_emulate_dtmf_duration_set(chan, 0);\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tf = ast_channel_dtmff(chan);\n\t\t\t\t\tf->frametype = AST_FRAME_DTMF_END;\n\t\t\t\t\tf->subclass.integer = ast_channel_dtmf_digit_to_emulate(chan);\n\t\t\t\t\tf->len = ast_tvdiff_ms(now, *ast_channel_dtmf_tv(chan));\n\t\t\t\t\tast_channel_dtmf_tv_set(chan, &now);\n\t\t\t\t\tif (ast_channel_audiohooks(chan)) {\n\t\t\t\t\t\tstruct ast_frame *old_frame = f;\n\t\t\t\t\t\tf = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);\n\t\t\t\t\t\tif (old_frame != f)\n\t\t\t\t\t\t\tast_frfree(old_frame);\n\t\t\t\t\t}\n\t\t\t\t\tast_log(LOG_DTMF, \"DTMF end emulation of '%c' queued on %s\\n\", f->subclass.integer, ast_channel_name(chan));\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tf = &ast_null_frame;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (f->frametype != AST_FRAME_VOICE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ast_format_cmp(f->subclass.format, ast_channel_rawreadformat(chan)) != AST_FORMAT_CMP_EQUAL\n\t\t\t\t&& ast_format_cmp(f->subclass.format, ast_channel_readformat(chan)) != AST_FORMAT_CMP_EQUAL) {\n\t\t\t\tstruct ast_format *core_format;\n\t\t\t\t\n\t\t\t\tcore_format = ast_channel_readformat(chan);\n\t\t\t\tif (!ast_format_cache_is_slinear(core_format)) {\n\t\t\t\t\tcore_format = f->subclass.format;\n\t\t\t\t}\n\t\t\t\tif (ast_set_read_format_path(chan, f->subclass.format, core_format)) {\n\t\t\t\t\t\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t\tf = &ast_null_frame;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ast_channel_audiohooks(chan) && ast_format_cache_is_slinear(f->subclass.format)) {\n\t\t\t\t\n\t\t\t\tstruct ast_frame *old_frame = f;\n\t\t\t\thooked = 1;\n\t\t\t\tf = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);\n\t\t\t\tif (old_frame != f) {\n\t\t\t\t\tast_frfree(old_frame);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ast_channel_monitor(chan) && ast_channel_monitor(chan)->read_stream) {\n\t\t\t\t\n#ifndef MONITOR_CONSTANT_DELAY\n\t\t\t\tint jump = ast_channel_outsmpl(chan) - ast_channel_insmpl(chan) - 4 * f->samples;\n\t\t\t\tif (jump >= 0) {\n\t\t\t\t\tjump = calc_monitor_jump((ast_channel_outsmpl(chan) - ast_channel_insmpl(chan)),\n\t\t\t\t\t\tast_format_get_sample_rate(f->subclass.format),\n\t\t\t\t\t\tast_format_get_sample_rate(ast_channel_monitor(chan)->read_stream->fmt->format));\n\t\t\t\t\tif (ast_seekstream(ast_channel_monitor(chan)->read_stream, jump, SEEK_FORCECUR) == -1) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Failed to perform seek in monitoring read stream, synchronization between the files may be broken\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tast_channel_insmpl_set(chan, ast_channel_insmpl(chan) + (ast_channel_outsmpl(chan) - ast_channel_insmpl(chan)) + f->samples);\n\t\t\t\t} else {\n\t\t\t\t\tast_channel_insmpl_set(chan, ast_channel_insmpl(chan) + f->samples);\n\t\t\t\t}\n#else\n\t\t\t\tint jump = calc_monitor_jump((ast_channel_outsmpl(chan) - ast_channel_insmpl(chan)),\n\t\t\t\t\tast_format_get_sample_rate(f->subclass.format),\n\t\t\t\t\tast_format_get_sample_rate(ast_channel_monitor(chan)->read_stream->fmt->format));\n\t\t\t\tif (jump - MONITOR_DELAY >= 0) {\n\t\t\t\t\tif (ast_seekstream(ast_channel_monitor(chan)->read_stream, jump - f->samples, SEEK_FORCECUR) == -1) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Failed to perform seek in monitoring read stream, synchronization between the files may be broken\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tast_channel_insmpl(chan) += ast_channel_outsmpl(chan) - ast_channel_insmpl(chan);\n\t\t\t\t} else {\n\t\t\t\t\tast_channel_insmpl(chan) += f->samples;\n\t\t\t\t}\n#endif\n\t\t\t\tif (ast_channel_monitor(chan)->state == AST_MONITOR_RUNNING) {\n\t\t\t\t\tif (ast_writestream(ast_channel_monitor(chan)->read_stream, f) < 0)\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Failed to write data to channel monitor read stream\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ast_channel_readtrans(chan)\n\t\t\t\t&& ast_format_cmp(f->subclass.format, ast_channel_rawreadformat(chan)) == AST_FORMAT_CMP_EQUAL) {\n\t\t\t\tf = ast_translate(ast_channel_readtrans(chan), f, 1);\n\t\t\t\tif (!f) {\n\t\t\t\t\tf = &ast_null_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ast_channel_audiohooks(chan) && !hooked) {\n\t\t\t\tstruct ast_frame *old_frame = f;\n\t\t\t\tf = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);\n\t\t\t\tif (old_frame != f) {\n\t\t\t\t\tast_frfree(old_frame);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (AST_LIST_NEXT(f, frame_list)) {\n\t\t\t\tstruct ast_frame *cur, *multi_frame = AST_LIST_NEXT(f, frame_list);\n\t\t\t\t\n\t\t\t\tfor (cur = multi_frame; cur; cur = AST_LIST_NEXT(cur, frame_list)) {\n\t\t\t\t\tast_set_flag(cur, AST_FRFLAG_REQUEUED);\n\t\t\t\t}\n\t\t\t\tif (!readq_tail) {\n\t\t\t\t\tast_queue_frame_head(chan, multi_frame);\n\t\t\t\t} else {\n\t\t\t\t\t__ast_queue_frame(chan, multi_frame, 0, readq_tail);\n\t\t\t\t}\n\t\t\t\tast_frfree(multi_frame);\n\t\t\t\tAST_LIST_NEXT(f, frame_list) = NULL;\n\t\t\t}\n\t\t\t\n\t\t\tast_read_generator_actions(chan, f);\n\t\t\tbreak;\n\t\tcase AST_FRAME_RTCP:\n\t\t\t\n\t\t\tif (ast_channel_writetrans(chan)) {\n\t\t\t\tast_translate(ast_channel_writetrans(chan), f, 0);\n\t\t\t}\n\t\t\tast_frfree(f);\n\t\t\tf = &ast_null_frame;\n\t\tdefault:\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t\n\t\tif (!ast_channel_softhangup_internal_flag(chan)) {\n\t\t\tast_channel_softhangup_internal_flag_add(chan, AST_SOFTHANGUP_DEV);\n\t\t}\n\t\tif (cause)\n\t\t\tast_channel_hangupcause_set(chan, cause);\n\t\tif (ast_channel_generator(chan))\n\t\t\tast_deactivate_generator(chan);\n\t\t\n\t}\n\t\n\tif (ast_channel_fin(chan) & DEBUGCHAN_FLAG)\n\t\tast_frame_dump(ast_channel_name(chan), f, \"<<\");\n\tast_channel_fin_set(chan, FRAMECOUNT_INC(ast_channel_fin(chan)));\ndone:\n\tif (ast_channel_music_state(chan) && ast_channel_generator(chan) && ast_channel_generator(chan)->digit && f && f->frametype == AST_FRAME_DTMF_END)\n\t\tast_channel_generator(chan)->digit(chan, f->subclass.integer);\n\tif (ast_channel_audiohooks(chan) && ast_audiohook_write_list_empty(ast_channel_audiohooks(chan))) {\n\t\t\n\t\tast_audiohook_detach_list(ast_channel_audiohooks(chan));\n\t\tast_channel_audiohooks_set(chan, NULL);\n\t}\n\tast_channel_unlock(chan);\n\treturn f;\n}\n", "bug_type": null, "idx": 524}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_log(char *title, struct ast_channel *chan);\nvoid ast_channel_log(char *title, struct ast_channel *chan) \n{\n\tast_log(LOG_NOTICE, \"______ %s (%lx)______\\n\", title, (unsigned long) chan);\n\tast_log(LOG_NOTICE, \"CHAN: name: %s;  appl: %s; data: %s; contxt: %s;  exten: %s; pri: %d;\\n\",\n\t\tast_channel_name(chan), ast_channel_appl(chan), ast_channel_data(chan),\n\t\tast_channel_context(chan), ast_channel_exten(chan), ast_channel_priority(chan));\n\tast_log(LOG_NOTICE, \"CHAN: acctcode: %s;  dialcontext: %s; amaflags: %x; maccontxt: %s;  macexten: %s; macpri: %d;\\n\",\n\t\tast_channel_accountcode(chan), ast_channel_dialcontext(chan), ast_channel_amaflags(chan),\n\t\tast_channel_macrocontext(chan), ast_channel_macroexten(chan), ast_channel_macropriority(chan));\n\tast_log(LOG_NOTICE, \"CHAN: masq: %p;  masqr: %p; uniqueID: %s; linkedID:%s\\n\",\n\t\tast_channel_masq(chan), ast_channel_masqr(chan),\n\t\tast_channel_uniqueid(chan), ast_channel_linkedid(chan));\n\tif (ast_channel_masqr(chan)) {\n\t\tast_log(LOG_NOTICE, \"CHAN: masquerading as: %s;  cdr: %p;\\n\",\n\t\t\tast_channel_name(ast_channel_masqr(chan)), ast_channel_cdr(ast_channel_masqr(chan)));\n\t}\n\tast_log(LOG_NOTICE, \"===== done ====\\n\");\n}\n", "bug_type": null, "idx": 525}
{"project": "Asterisk", "target": 0, "func": "const char *ast_msg_get_var(struct ast_msg *msg, const char *name)\n{\n\tstruct msg_data *data;\n\tconst char *val = NULL;\n\tif (!(data = msg_data_find(msg->vars, name))) {\n\t\treturn NULL;\n\t}\n\t\n\tval = data->value;\n\tao2_ref(data, -1);\n\treturn val;\n}\n", "bug_type": null, "idx": 526}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tAST_TEST_REGISTER(format_cache_set);\n\tAST_TEST_REGISTER(format_cache_set_duplicate);\n\tAST_TEST_REGISTER(format_cache_set_null);\n\tAST_TEST_REGISTER(format_cache_get);\n\tAST_TEST_REGISTER(format_cache_get_nonexistent);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 527}
{"project": "Asterisk", "target": 0, "func": "#if defined(HAVE_CRYPT_R)\nchar *ast_crypt(const char *key, const char *salt)\n{\n\tstruct crypt_data data = {};\n\tconst char *crypted = crypt_r(key, salt, &data);\n\t\n\tif (!crypted || !ast_begins_with(crypted, salt)) {\n\t\treturn NULL;\n\t}\n\treturn ast_strdup(crypted);\n}\nAST_MUTEX_DEFINE_STATIC(crypt_mutex);\nchar *ast_crypt(const char *key, const char *salt)\n{\n\tconst char *crypted;\n\tSCOPED_MUTEX(lock, &crypt_mutex);\n\tcrypted = crypt(key, salt);\n\t\n\tif (!crypted || !ast_begins_with(crypted, salt)) {\n\t\treturn NULL;\n\t}\n\treturn ast_strdup(crypted);\n}\n#else \nchar *ast_crypt(const char *key, const char *salt)\n{\n\tast_log(LOG_WARNING,\n\t\t\"crypt() support not available; cannot encrypt password\\n\");\n\treturn NULL;\n}\n", "bug_type": null, "idx": 528}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void add_header_from_channel_var(struct ast_channel *chan, const char *var_name, const char *header_name, pjsip_tx_data *tdata)\n{\n\tconst char *var_value;\n\tpj_str_t pj_header_name;\n\tpjsip_hdr *header;\n\tvar_value = pbx_builtin_getvar_helper(chan, var_name);\n\tif (ast_strlen_zero(var_value)) {\n\t\treturn;\n\t}\n\tpj_cstr(&pj_header_name, header_name);\n\theader = pjsip_msg_find_hdr_by_name(tdata->msg, &pj_header_name, NULL);\n\tif (header) {\n\t\treturn;\n\t}\n\tast_sip_add_header(tdata, header_name, var_value);\n}\n", "bug_type": null, "idx": 529}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235ChallengeString (OOCTXT* pctxt, H235ChallengeString* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 8, 128, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = encodeOctetString (pctxt, pvalue->numocts, pvalue->data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 530}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tif (ast_cdr_unregister(name)) {\n\t\treturn -1;\n\t}\n\tfree_config(0);\n\treturn 0;\n}\n", "bug_type": null, "idx": 531}
{"project": "Asterisk", "target": 0, "func": "static int ooh323_answer(struct ast_channel *ast)\n{\n\tstruct ooh323_pvt *p = ast_channel_tech_pvt(ast);\n\tchar *callToken = (char *)NULL;\n\tif (gH323Debug)\n\t\tast_verb(0, \"--- ooh323_answer\\n\");\n\tif (p) {\n\t\tast_mutex_lock(&p->lock);\n\t\tcallToken = (p->callToken ? ast_strdup(p->callToken) : NULL);\n\t\tif (ast_channel_state(ast) != AST_STATE_UP) {\n\t\t\tast_channel_lock(ast);\n\t\t\tif (!p->alertsent) {\n\t    \t\t\tif (gH323Debug) {\n\t\t\t\t\tast_debug(1, \"Sending forced ringback for %s, res = %u\\n\", \n\t\t\t\t\t\tcallToken, ooManualRingback(callToken));\n\t\t\t\t} else {\n\t    \t\t\t\tooManualRingback(callToken);\n\t\t\t\t}\n\t\t\t\tp->alertsent = 1;\n\t\t\t}\n\t\t\tast_setstate(ast, AST_STATE_UP);\n      \t\t\tif (option_debug)\n\t\t\t\tast_debug(1, \"ooh323_answer(%s)\\n\", ast_channel_name(ast));\n\t\t\tast_channel_unlock(ast);\n\t\t\tooAnswerCall(p->callToken);\n\t\t}\n\t\tif (callToken) {\n\t\t\tast_free(callToken);\n\t\t}\n\t\tast_mutex_unlock(&p->lock);\n\t}\n\tif (gH323Debug)\n\t\tast_verb(0, \"+++ ooh323_answer\\n\");\n  return 0;\n}\n", "bug_type": null, "idx": 532}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/module.h\"\nAST_TEST_DEFINE(uuid)\n{\n\tstruct ast_uuid *uuid1 = NULL;\n\tstruct ast_uuid *uuid2 = NULL;\n\tstruct ast_uuid *uuid3 = NULL;\n\tchar uuid_str[AST_UUID_STR_LEN];\n\tenum ast_test_result_state res = AST_TEST_FAIL;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"uuid\";\n\t\tinfo->category = \"/main/uuid/\";\n\t\tinfo->summary = \"UUID unit test\";\n\t\tinfo->description =\n\t\t\t\"This tests basic UUID operations to ensure they work properly\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\t\n\tast_uuid_generate_str(uuid_str, sizeof(uuid_str));\n\tif (strlen(uuid_str) != (AST_UUID_STR_LEN - 1)) {\n\t\tast_test_status_update(test, \"Failed to directly generate UUID string\\n\");\n\t\tgoto end;\n\t}\n\tast_test_status_update(test, \"Generate UUID direct to string, got %s\\n\", uuid_str);\n\t\n\tuuid1 = ast_str_to_uuid(uuid_str);\n\tif (!uuid1) {\n\t\tast_test_status_update(test, \"Unable to convert direct UUID string %s to UUID\\n\", uuid_str);\n\t\tgoto end;\n\t}\n\tast_free(uuid1);\n\t\n\tuuid1 = ast_uuid_generate();\n\tif (!uuid1) {\n\t\tast_test_status_update(test, \"Unable to generate a UUID\\n\");\n\t\tgoto end;\n\t}\n\t\n\tif (ast_uuid_is_nil(uuid1)) {\n\t\tast_test_status_update(test, \"We generated a nil UUID. Something is wrong\\n\");\n\t\tgoto end;\n\t}\n\t\n\tast_uuid_to_str(uuid1, uuid_str, sizeof(uuid_str));\n\tif (strlen(uuid_str) != (AST_UUID_STR_LEN - 1)) {\n\t\tast_test_status_update(test, \"Failed to convert the UUID to a string\\n\");\n\t\tgoto end;\n\t}\n\tast_test_status_update(test, \"Second generated UUID converted to string, got %s\\n\", uuid_str);\n\t\n\tuuid2 = ast_str_to_uuid(uuid_str);\n\tif (!uuid2) {\n\t\tast_test_status_update(test, \"Unable to convert string %s to UUID\\n\", uuid_str);\n\t\tgoto end;\n\t}\n\t\n\tif (ast_uuid_compare(uuid1, uuid2) != 0) {\n\t\tast_test_status_update(test, \"UUIDs that should be identical are different\\n\");\n\t\tgoto end;\n\t}\n\t\n\tuuid3 = ast_uuid_copy(uuid1);\n\tif (!uuid3) {\n\t\tast_test_status_update(test, \"Unable to copy UUID\\n\");\n\t\tgoto end;\n\t}\n\t\n\tif (ast_uuid_compare(uuid1, uuid3) != 0) {\n\t\tast_test_status_update(test, \"UUIDs that should be identical are different\\n\");\n\t\tgoto end;\n\t}\n\tif (ast_uuid_compare(uuid2, uuid3) != 0) {\n\t\tast_test_status_update(test, \"UUIDs that should be identical are different\\n\");\n\t\tgoto end;\n\t}\n\t\n\tast_uuid_clear(uuid1);\n\tif (!ast_uuid_is_nil(uuid1)) {\n\t\tast_test_status_update(test, \"UUID that was cleared does not appear to be nil\\n\");\n\t\tgoto end;\n\t}\n\tres = AST_TEST_PASS;\nend:\n\tast_free(uuid1);\n\tast_free(uuid2);\n\tast_free(uuid3);\n\treturn res;\n}\n", "bug_type": null, "idx": 533}
{"project": "Asterisk", "target": 0, "func": "\nstatic int create_outgoing_sdp_stream(struct ast_sip_session *session, struct ast_sip_session_media *session_media,\n\t\t\t\t      struct pjmedia_sdp_session *sdp, const struct pjmedia_sdp_session *remote, struct ast_stream *stream)\n{\n\tpj_pool_t *pool = session->inv_session->pool_prov;\n\tstatic const pj_str_t STR_RTP_AVP = { \"RTP/AVP\", 7 };\n\tstatic const pj_str_t STR_IN = { \"IN\", 2 };\n\tstatic const pj_str_t STR_IP4 = { \"IP4\", 3};\n\tstatic const pj_str_t STR_IP6 = { \"IP6\", 3};\n\tstatic const pj_str_t STR_SENDRECV = { \"sendrecv\", 8 };\n\tstatic const pj_str_t STR_SENDONLY = { \"sendonly\", 8 };\n\tpjmedia_sdp_media *media;\n\tconst char *hostip = NULL;\n\tstruct ast_sockaddr addr;\n\tchar tmp[512];\n\tpj_str_t stmp;\n\tpjmedia_sdp_attr *attr;\n\tint index = 0;\n\tint noncodec = (session->dtmf == AST_SIP_DTMF_RFC_4733 || session->dtmf == AST_SIP_DTMF_AUTO || session->dtmf == AST_SIP_DTMF_AUTO_INFO) ? AST_RTP_DTMF : 0;\n\tint min_packet_size = 0, max_packet_size = 0;\n\tint rtp_code;\n\tRAII_VAR(struct ast_format_cap *, caps, NULL, ao2_cleanup);\n\tenum ast_media_type media_type = session_media->type;\n\tstruct ast_sip_session_media *session_media_transport;\n\tint direct_media_enabled = !ast_sockaddr_isnull(&session_media->direct_media_addr) &&\n\t\tast_format_cap_count(session->direct_media_cap);\n\tmedia = pj_pool_zalloc(pool, sizeof(struct pjmedia_sdp_media));\n\tif (!media) {\n\t\treturn -1;\n\t}\n\tpj_strdup2(pool, &media->desc.media, ast_codec_media_type2str(session_media->type));\n\t\n\tif (ast_stream_get_state(stream) == AST_STREAM_STATE_REMOVED || !ast_stream_get_formats(stream) ||\n\t\t!ast_format_cap_count(ast_stream_get_formats(stream))) {\n\t\tmedia->desc.port = 0;\n\t\tmedia->desc.port_count = 1;\n\t\tif (remote && remote->media[ast_stream_get_position(stream)]) {\n\t\t\tpjmedia_sdp_media *remote_media = remote->media[ast_stream_get_position(stream)];\n\t\t\tint index;\n\t\t\tmedia->desc.transport = remote_media->desc.transport;\n\t\t\t\n\t\t\tfor (index = 0; index < remote_media->desc.fmt_count; ++index) {\n\t\t\t\tmedia->desc.fmt[index] = remote_media->desc.fmt[index];\n\t\t\t}\n\t\t\tmedia->desc.fmt_count = remote_media->desc.fmt_count;\n\t\t} else {\n\t\t\t\n\t\t\tmedia->desc.transport = STR_RTP_AVP;\n\t\t\tpj_strdup2(pool, &media->desc.fmt[media->desc.fmt_count++], \"32\");\n\t\t}\n\t\tsdp->media[sdp->media_count++] = media;\n\t\tast_stream_set_state(stream, AST_STREAM_STATE_REMOVED);\n\t\treturn 1;\n\t}\n\tif (!session_media->rtp && create_rtp(session, session_media)) {\n\t\treturn -1;\n\t}\n\t\n\tif (session_media->bundle_group != -1 && !session_media->bundled) {\n\t\tfor (index = 0; index < sdp->media_count; ++index) {\n\t\t\tstruct ast_sip_session_media *other_session_media;\n\t\t\tother_session_media = AST_VECTOR_GET(&session->pending_media_state->sessions, index);\n\t\t\tif (!other_session_media->rtp || other_session_media->bundle_group != session_media->bundle_group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ast_rtp_instance_get_ssrc(session_media->rtp) == ast_rtp_instance_get_ssrc(other_session_media->rtp)) {\n\t\t\t\tast_rtp_instance_change_source(session_media->rtp);\n\t\t\t\t\n\t\t\t\tindex = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\tsession_media_transport = ast_sip_session_media_get_transport(session, session_media);\n\tif (session_media_transport == session_media || !session_media->bundled) {\n\t\tset_ice_components(session, session_media);\n\t\tenable_rtcp(session, session_media, NULL);\n\t\t\n\t\tif (add_crypto_to_stream(session, session_media, pool, media)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (pj_strlen(&session_media->transport)) {\n\t\t\t\n\t\t\tmedia->desc.transport = session_media->transport;\n\t\t} else {\n\t\t\tmedia->desc.transport = pj_str(ast_sdp_get_rtp_profile(\n\t\t\t\t\n\t\t\t\t!session->endpoint->media.rtp.encryption_optimistic &&\n\t\t\t\t\t(session_media->encryption == AST_SIP_MEDIA_ENCRYPT_SDES),\n\t\t\t\tsession_media->rtp, session->endpoint->media.rtp.use_avpf,\n\t\t\t\tsession->endpoint->media.rtp.force_avp));\n\t\t}\n\t\tmedia->conn = pj_pool_zalloc(pool, sizeof(struct pjmedia_sdp_conn));\n\t\tif (!media->conn) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (direct_media_enabled) {\n\t\t\thostip = ast_sockaddr_stringify_fmt(&session_media->direct_media_addr, AST_SOCKADDR_STR_ADDR);\n\t\t} else if (ast_strlen_zero(session->endpoint->media.address)) {\n\t\t\thostip = ast_sip_get_host_ip_string(session->endpoint->media.rtp.ipv6 ? pj_AF_INET6() : pj_AF_INET());\n\t\t} else {\n\t\t\thostip = session->endpoint->media.address;\n\t\t}\n\t\tif (ast_strlen_zero(hostip)) {\n\t\t\tast_log(LOG_ERROR, \"No local host IP available for stream %s\\n\",\n\t\t\t\tast_codec_media_type2str(session_media->type));\n\t\t\treturn -1;\n\t\t}\n\t\tmedia->conn->net_type = STR_IN;\n\t\t\n\t\tmedia->conn->addr_type = STR_IP4;\n\t\tpj_strdup2(pool, &media->conn->addr, hostip);\n\t\tif (!ast_strlen_zero(session->endpoint->media.address)) {\n\t\t\tpj_sockaddr ip;\n\t\t\tif ((pj_sockaddr_parse(pj_AF_UNSPEC(), 0, &media->conn->addr, &ip) == PJ_SUCCESS) &&\n\t\t\t\t(ip.addr.sa_family == pj_AF_INET6())) {\n\t\t\t\tmedia->conn->addr_type = STR_IP6;\n\t\t\t}\n\t\t}\n\t\t\n\t\tadd_ice_to_stream(session, session_media, pool, media, 1);\n\t\tast_rtp_instance_get_local_address(session_media->rtp, &addr);\n\t\tmedia->desc.port = direct_media_enabled ? ast_sockaddr_port(&session_media->direct_media_addr) : (pj_uint16_t) ast_sockaddr_port(&addr);\n\t\tmedia->desc.port_count = 1;\n\t} else {\n\t\tpjmedia_sdp_media *bundle_group_stream = sdp->media[session_media_transport->stream_num];\n\t\t\n\t\tmedia->desc.transport = bundle_group_stream->desc.transport;\n\t\tmedia->conn = bundle_group_stream->conn;\n\t\tmedia->desc.port = bundle_group_stream->desc.port;\n\t\tif (add_crypto_to_stream(session, session_media_transport, pool, media)) {\n\t\t\treturn -1;\n\t\t}\n\t\tadd_ice_to_stream(session, session_media_transport, pool, media, 0);\n\t\tenable_rtcp(session, session_media, NULL);\n\t}\n\tif (!(caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate %s capabilities\\n\",\n\t\t\tast_codec_media_type2str(session_media->type));\n\t\treturn -1;\n\t}\n\tif (direct_media_enabled) {\n\t\tast_format_cap_get_compatible(session->endpoint->media.codecs, session->direct_media_cap, caps);\n\t} else {\n\t\tast_format_cap_append_from_cap(caps, ast_stream_get_formats(stream), media_type);\n\t}\n\tfor (index = 0; index < ast_format_cap_count(caps); ++index) {\n\t\tstruct ast_format *format = ast_format_cap_get_format(caps, index);\n\t\tif (ast_format_get_type(format) != media_type) {\n\t\t\tao2_ref(format, -1);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (session_media_transport != session_media) {\n\t\t\tif ((rtp_code = ast_rtp_codecs_payload_code(ast_rtp_instance_get_codecs(session_media_transport->rtp), 1, format, 0)) == -1) {\n\t\t\t\tast_log(LOG_WARNING,\"Unable to get rtp codec payload code for %s\\n\", ast_format_get_name(format));\n\t\t\t\tao2_ref(format, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tast_rtp_codecs_payload_set_rx(ast_rtp_instance_get_codecs(session_media->rtp), rtp_code, format);\n\t\t} else {\n\t\t\tif ((rtp_code = ast_rtp_codecs_payload_code(ast_rtp_instance_get_codecs(session_media->rtp), 1, format, 0)) == -1) {\n\t\t\t\tast_log(LOG_WARNING,\"Unable to get rtp codec payload code for %s\\n\", ast_format_get_name(format));\n\t\t\t\tao2_ref(format, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((attr = generate_rtpmap_attr(session, media, pool, rtp_code, 1, format, 0))) {\n\t\t\tmedia->attr[media->attr_count++] = attr;\n\t\t}\n\t\tif ((attr = generate_fmtp_attr(pool, format, rtp_code))) {\n\t\t\tmedia->attr[media->attr_count++] = attr;\n\t\t}\n\t\tif (ast_format_get_maximum_ms(format) &&\n\t\t\t((ast_format_get_maximum_ms(format) < max_packet_size) || !max_packet_size)) {\n\t\t\tmax_packet_size = ast_format_get_maximum_ms(format);\n\t\t}\n\t\tao2_ref(format, -1);\n\t\tif (media->desc.fmt_count == PJMEDIA_MAX_SDP_FMT) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (ast_sip_session_is_pending_stream_default(session, stream) && media_type != AST_MEDIA_TYPE_VIDEO\n\t\t&& media->desc.fmt_count < PJMEDIA_MAX_SDP_FMT) {\n\t\tfor (index = 1LL; index <= AST_RTP_MAX; index <<= 1) {\n\t\t\tif (!(noncodec & index)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtp_code = ast_rtp_codecs_payload_code(\n\t\t\t\tast_rtp_instance_get_codecs(session_media->rtp), 0, NULL, index);\n\t\t\tif (rtp_code == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((attr = generate_rtpmap_attr(session, media, pool, rtp_code, 0, NULL, index))) {\n\t\t\t\tmedia->attr[media->attr_count++] = attr;\n\t\t\t}\n\t\t\tif (index == AST_RTP_DTMF) {\n\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%d 0-16\", rtp_code);\n\t\t\t\tattr = pjmedia_sdp_attr_create(pool, \"fmtp\", pj_cstr(&stmp, tmp));\n\t\t\t\tmedia->attr[media->attr_count++] = attr;\n\t\t\t}\n\t\t\tif (media->desc.fmt_count == PJMEDIA_MAX_SDP_FMT) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (!media->desc.fmt_count) {\n\t\treturn 1;\n\t}\n\t\n\tmin_packet_size = ast_rtp_codecs_get_framing(ast_rtp_instance_get_codecs(session_media->rtp));\n\tif (!min_packet_size) {\n\t\tmin_packet_size = ast_format_cap_get_framing(caps);\n\t}\n\tif (min_packet_size) {\n\t\tsnprintf(tmp, sizeof(tmp), \"%d\", min_packet_size);\n\t\tattr = pjmedia_sdp_attr_create(pool, \"ptime\", pj_cstr(&stmp, tmp));\n\t\tmedia->attr[media->attr_count++] = attr;\n\t}\n\tif (max_packet_size) {\n\t\tsnprintf(tmp, sizeof(tmp), \"%d\", max_packet_size);\n\t\tattr = pjmedia_sdp_attr_create(pool, \"maxptime\", pj_cstr(&stmp, tmp));\n\t\tmedia->attr[media->attr_count++] = attr;\n\t}\n\t\n\tattr = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_attr);\n\tattr->name = !session_media->locally_held ? STR_SENDRECV : STR_SENDONLY;\n\tmedia->attr[media->attr_count++] = attr;\n\t\n\tif (session->endpoint->media.rtcp_mux) {\n\t\tattr = pjmedia_sdp_attr_create(pool, \"rtcp-mux\", NULL);\n\t\tpjmedia_sdp_attr_add(&media->attr_count, media->attr, attr);\n\t}\n\tadd_ssrc_to_stream(session, session_media, pool, media);\n\tadd_msid_to_stream(session, session_media, pool, media, stream);\n\tadd_rtcp_fb_to_stream(session, session_media, pool, media);\n\t\n\tsdp->media[sdp->media_count++] = media;\n\treturn 1;\n}\n", "bug_type": null, "idx": 534}
{"project": "Asterisk", "target": 0, "func": "int ast_context_includes_count(struct ast_context *con);\nint ast_context_includes_count(struct ast_context *con)\n{\n\tint c = 0;\n\tstruct ast_include *inc = NULL;\n\twhile ((inc = ast_walk_context_includes(con, inc))) {\n\t\tc++;\n\t}\n\treturn c;\n}\n", "bug_type": null, "idx": 535}
{"project": "Asterisk", "target": 0, "func": "void ooTimerFireExpired (OOCTXT* pctxt, DList *pList)\n{\n   OOTimer* pTimer;\n   while (pList->count > 0) {\n      pTimer = (OOTimer*) pList->head->data;\n      if (ooTimerExpired (pTimer)) {\n         \n         if (pTimer->reRegister) ooTimerReset (pctxt, pList, pTimer);\n         (*pTimer->timeoutCB)(pTimer->cbData);\n         if (!pTimer->reRegister) {\n            ooTimerDelete (pctxt, pList, pTimer);\n         }\n      }\n      else break;\n   }\n}\n", "bug_type": null, "idx": 536}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_register(&acf_cut);\n\tres |= ast_custom_function_register(&acf_sort);\n\treturn res;\n}\n", "bug_type": null, "idx": 537}
{"project": "Asterisk", "target": 0, "func": "void ast_rtp_instance_set_prop(struct ast_rtp_instance *instance, enum ast_rtp_property property, int value)\n{\n\tao2_lock(instance);\n\tinstance->properties[property] = value;\n\tif (instance->engine->prop_set) {\n\t\tinstance->engine->prop_set(instance, property, value);\n\t}\n\tao2_unlock(instance);\n}\n", "bug_type": null, "idx": 538}
{"project": "Asterisk", "target": 0, "func": "static void send_end_call(struct unistimsession *pte)\n{\n\tBUFFSEND;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending end call\\n\");\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_end_call, sizeof(packet_send_end_call));\n\tsend_client(SIZE_HEADER + sizeof(packet_send_end_call), buffsend, pte);\n}\n", "bug_type": null, "idx": 539}
{"project": "Asterisk", "target": 0, "func": "static char *app = \"BackgroundDetect\";\nstatic int background_detect_exec(struct ast_channel *chan, const char *data)\n{\n\tint res = 0;\n\tchar *tmp;\n\tstruct ast_frame *fr;\n\tint notsilent = 0;\n\tstruct timeval start = { 0, 0 };\n\tstruct timeval detection_start = { 0, 0 };\n\tint sil = 1000;\n\tint min = 100;\n\tint max = -1;\n\tint analysistime = -1;\n\tint continue_analysis = 1;\n\tint x;\n\tRAII_VAR(struct ast_format *, origrformat, NULL, ao2_cleanup);\n\tstruct ast_dsp *dsp = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(filename);\n\t\tAST_APP_ARG(silence);\n\t\tAST_APP_ARG(min);\n\t\tAST_APP_ARG(max);\n\t\tAST_APP_ARG(analysistime);\n\t);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"BackgroundDetect requires an argument (filename)\\n\");\n\t\treturn -1;\n\t}\n\ttmp = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, tmp);\n\tif (!ast_strlen_zero(args.silence) && (sscanf(args.silence, \"%30d\", &x) == 1) && (x > 0)) {\n\t\tsil = x;\n\t}\n\tif (!ast_strlen_zero(args.min) && (sscanf(args.min, \"%30d\", &x) == 1) && (x > 0)) {\n\t\tmin = x;\n\t}\n\tif (!ast_strlen_zero(args.max) && (sscanf(args.max, \"%30d\", &x) == 1) && (x > 0)) {\n\t\tmax = x;\n\t}\n\tif (!ast_strlen_zero(args.analysistime) && (sscanf(args.analysistime, \"%30d\", &x) == 1) && (x > 0)) {\n\t\tanalysistime = x;\n\t}\n\tast_debug(1, \"Preparing detect of '%s', sil=%d, min=%d, max=%d, analysistime=%d\\n\", args.filename, sil, min, max, analysistime);\n\tdo {\n\t\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\t\tif ((res = ast_answer(chan))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\torigrformat = ao2_bump(ast_channel_readformat(chan));\n\t\tif ((ast_set_read_format(chan, ast_format_slin))) {\n\t\t\tast_log(LOG_WARNING, \"Unable to set read format to linear!\\n\");\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(dsp = ast_dsp_new())) {\n\t\t\tast_log(LOG_WARNING, \"Unable to allocate DSP!\\n\");\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tast_stopstream(chan);\n\t\tif (ast_streamfile(chan, tmp, ast_channel_language(chan))) {\n\t\t\tast_log(LOG_WARNING, \"ast_streamfile failed on %s for %s\\n\", ast_channel_name(chan), (char *)data);\n\t\t\tbreak;\n\t\t}\n\t\tdetection_start = ast_tvnow();\n\t\twhile (ast_channel_stream(chan)) {\n\t\t\tres = ast_sched_wait(ast_channel_sched(chan));\n\t\t\tif ((res < 0) && !ast_channel_timingfunc(chan)) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res < 0) {\n\t\t\t\tres = 1000;\n\t\t\t}\n\t\t\tres = ast_waitfor(chan, res);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Waitfor failed on %s\\n\", ast_channel_name(chan));\n\t\t\t\tbreak;\n\t\t\t} else if (res > 0) {\n\t\t\t\tfr = ast_read(chan);\n\t\t\t\tif (continue_analysis && analysistime >= 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (ast_tvdiff_ms(ast_tvnow(), detection_start) >= analysistime) {\n\t\t\t\t\t\tcontinue_analysis = 0;\n\t\t\t\t\t\tast_verb(3, \"BackgroundDetect: Talk analysis time complete on %s.\\n\", ast_channel_name(chan));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!fr) {\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (fr->frametype == AST_FRAME_DTMF) {\n\t\t\t\t\tchar t[2];\n\t\t\t\t\tt[0] = fr->subclass.integer;\n\t\t\t\t\tt[1] = '\\0';\n\t\t\t\t\tif (ast_canmatch_extension(chan, ast_channel_context(chan), t, 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL))) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tres = fr->subclass.integer;\n\t\t\t\t\t\tast_frfree(fr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if ((fr->frametype == AST_FRAME_VOICE) &&\n\t\t\t\t(ast_format_cmp(fr->subclass.format, ast_format_slin) == AST_FORMAT_CMP_EQUAL) && continue_analysis) {\n\t\t\t\t\tint totalsilence;\n\t\t\t\t\tint ms;\n\t\t\t\t\tres = ast_dsp_silence(dsp, fr, &totalsilence);\n\t\t\t\t\tif (res && (totalsilence > sil)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (notsilent) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tms = ast_tvdiff_ms(ast_tvnow(), start);\n\t\t\t\t\t\t\tms -= sil;\n\t\t\t\t\t\t\tif (ms < 0)\n\t\t\t\t\t\t\t\tms = 0;\n\t\t\t\t\t\t\tif ((ms > min) && ((max < 0) || (ms < max))) {\n\t\t\t\t\t\t\t\tchar ms_str[12];\n\t\t\t\t\t\t\t\tast_debug(1, \"Found qualified token of %d ms\\n\", ms);\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tsnprintf(ms_str, sizeof(ms_str), \"%d\", ms);\t\n\t\t\t\t\t\t\t\tpbx_builtin_setvar_helper(chan, \"TALK_DETECTED\", ms_str);\n\t\t\t\t\t\t\t\tast_goto_if_exists(chan, ast_channel_context(chan), \"talk\", 1);\n\t\t\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\t\t\tast_frfree(fr);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tast_debug(1, \"Found unqualified token of %d ms\\n\", ms);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnotsilent = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!notsilent) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstart = ast_tvnow();\n\t\t\t\t\t\t\tast_debug(1, \"Start of voice token!\\n\");\n\t\t\t\t\t\t\tnotsilent = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tast_frfree(fr);\n\t\t\t}\n\t\t\tast_sched_runq(ast_channel_sched(chan));\n\t\t}\n\t\tast_stopstream(chan);\n\t} while (0);\n\tif (res > -1) {\n\t\tif (origrformat && ast_set_read_format(chan, origrformat)) {\n\t\t\tast_log(LOG_WARNING, \"Failed to restore read format for %s to %s\\n\", \n\t\t\t\tast_channel_name(chan), ast_format_get_name(origrformat));\n\t\t}\n\t}\n\tif (dsp) {\n\t\tast_dsp_free(dsp);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 540}
{"project": "Asterisk", "target": 0, "func": "static int native_rtp_bridge_write(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel, struct ast_frame *frame)\n{\n\tconst struct ast_control_t38_parameters *t38_parameters;\n\tint defer = 0;\n\tif (!ast_bridge_queue_everyone_else(bridge, bridge_channel, frame)) {\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tswitch (frame->frametype) {\n\tcase AST_FRAME_CONTROL:\n\t\tswitch (frame->subclass.integer) {\n\t\tcase AST_CONTROL_T38_PARAMETERS:\n\t\t\tt38_parameters = frame->data.ptr;\n\t\t\tswitch (t38_parameters->request_response) {\n\t\t\tcase AST_T38_REQUEST_NEGOTIATE:\n\t\t\t\tdefer = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn defer;\n}\n", "bug_type": null, "idx": 541}
{"project": "Asterisk", "target": 0, "func": "static int cc_generic_monitor_suspend(struct ast_cc_monitor *monitor)\n{\n\tstruct generic_monitor_instance_list *generic_list;\n\tstruct generic_monitor_instance *generic_instance;\n\tenum ast_device_state state = ast_device_state(monitor->interface->device_name);\n\tif (!(generic_list = find_generic_monitor_instance_list(monitor->interface->device_name))) {\n\t\treturn -1;\n\t}\n\t\n\tAST_LIST_TRAVERSE(&generic_list->list, generic_instance, next) {\n\t\tif (generic_instance->core_id == monitor->core_id) {\n\t\t\tgeneric_instance->is_suspended = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (!cc_generic_is_device_available(state)) {\n\t\tcc_unref(generic_list, \"Device is in use. Nothing to do. Unref generic list.\");\n\t\treturn 0;\n\t}\n\t\n\tAST_LIST_TRAVERSE(&generic_list->list, generic_instance, next) {\n\t\tif (!generic_instance->is_suspended) {\n\t\t\tast_cc_monitor_callee_available(generic_instance->core_id, \"Generic monitored party has become available\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tcc_unref(generic_list, \"Done with generic list in suspend callback\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 542}
{"project": "Asterisk", "target": 0, "func": "#endif \nint ast_xml_init(void)\n{\n\tLIBXML_TEST_VERSION\n\treturn 0;\n}\n", "bug_type": null, "idx": 543}
{"project": "Asterisk", "target": 0, "func": "static struct val *\nop_or (struct val *a, struct val *b)\n{\n\tif (is_zero_or_null (a)) {\n\t\tfree_value (a);\n\t\treturn (b);\n\t} else {\n\t\tfree_value (b);\n\t\treturn (a);\n\t}\n}\n", "bug_type": null, "idx": 544}
{"project": "Asterisk", "target": 0, "func": "OOBOOL ooCapabilityCheckCompatibility_GSM\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245AudioCapability* audioCap, int dir)\n{\n   unsigned noofframes=0, cap;\n   switch(audioCap->t)\n   {\n   case T_H245AudioCapability_gsmFullRate:\n      cap = OO_GSMFULLRATE;\n      noofframes = (audioCap->u.gsmFullRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      break;\n   case T_H245AudioCapability_gsmHalfRate:\n      cap = OO_GSMHALFRATE;\n      noofframes = (audioCap->u.gsmHalfRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      break;\n   case T_H245AudioCapability_gsmEnhancedFullRate:\n      cap = OO_GSMENHANCEDFULLRATE;\n      noofframes = (audioCap->u.gsmEnhancedFullRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      break;\n   default:\n      return FALSE;\n   }\n   if(cap != epCap->cap) { return FALSE; }\n   \n   if(dir & OORX)\n   {\n      if(((OOGSMCapParams*)epCap->params)->rxframes >= noofframes)\n         return TRUE;\n   }\n   \n   if(dir & OOTX)\n   {\n      if(((OOGSMCapParams*)epCap->params)->txframes > noofframes){\n         OOTRACEDBGA5(\"Reducing txframes for GSM from %d to %d to match \"\n                      \"receive capability of remote end.(%s, %s)\\n\", \n                     ((OOGSMCapParams*)epCap->params)->txframes, noofframes, \n                     call->callType, call->callToken);\n         ((OOGSMCapParams*)epCap->params)->txframes = noofframes;\n      }\n      return TRUE;\n   }\n   return FALSE;\n}\n}\nOOBOOL ooCapabilityCheckCompatibility_GSM\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245AudioCapability* audioCap, int dir)\n{\n   unsigned noofframes=0, cap;\n   switch(audioCap->t)\n   {\n   case T_H245AudioCapability_gsmFullRate:\n      cap = OO_GSMFULLRATE;\n      noofframes = (audioCap->u.gsmFullRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      break;\n   case T_H245AudioCapability_gsmHalfRate:\n      cap = OO_GSMHALFRATE;\n      noofframes = (audioCap->u.gsmHalfRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      break;\n   case T_H245AudioCapability_gsmEnhancedFullRate:\n      cap = OO_GSMENHANCEDFULLRATE;\n      noofframes = (audioCap->u.gsmEnhancedFullRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      break;\n   default:\n      return FALSE;\n   }\n}\nOOBOOL ooCapabilityCheckCompatibility_T38\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245DataApplicationCapability* t38Cap, int dir)\n{\n   unsigned cap = 0;\n   switch(t38Cap->application.t)\n   {\n   case T_H245DataApplicationCapability_application_t38fax:\n      cap = OO_T38;\n      break;\n   default:\n      return FALSE;\n   }\n   if(cap != epCap->cap) { return FALSE; }\n   return TRUE;\n}\n}\nOOBOOL ooCapabilityCheckCompatibility_T38\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245DataApplicationCapability* t38Cap, int dir)\n{\n   unsigned cap = 0;\n   switch(t38Cap->application.t)\n   {\n   case T_H245DataApplicationCapability_application_t38fax:\n      cap = OO_T38;\n      break;\n   default:\n      return FALSE;\n   }\n}\nOOBOOL ooCapabilityCheckCompatibility_H263Video\n   (struct OOH323CallData *call, ooH323EpCapability *epCap, \n    H245VideoCapability *pVideoCap, int dir)\n{\n   H245H263VideoCapability *pH263Cap = NULL;\n   OOH263CapParams *params = epCap->params;\n   if(!pVideoCap->u.h263VideoCapability)  \n   {\n      OOTRACEERR3(\"Error:No H263 video capability present in video capability\"\n                 \"structure. (%s, %s)\\n\", call->callType, call->callToken);\n      return FALSE;\n   }\n   pH263Cap = pVideoCap->u.h263VideoCapability;\n   \n   if(OORX & dir)\n   {\n      if(pH263Cap->m.sqcifMPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_SQCIF)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->sqcifMPI >= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.qcifMPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_QCIF)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->qcifMPI >= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.cifMPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_CIF)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->cifMPI >= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.cif4MPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_CIF4)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->cif4MPI >= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.cif16MPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_CIF16)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->cif16MPI >= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n   }\n   \n   if(OOTX & dir)\n   {\n       if(pH263Cap->m.sqcifMPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_SQCIF)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->sqcifMPI <= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.qcifMPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_QCIF)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->qcifMPI <= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.cifMPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_CIF)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->cifMPI <= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.cif4MPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_CIF4)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->cif4MPI <= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n      if(pH263Cap->m.cif16MPIPresent)\n      {\n         if(params->picFormat != OO_PICFORMAT_CIF16)\n         {\n            return FALSE;\n         }\n         else{\n            if(pH263Cap->cif16MPI <= params->MPI)\n               return TRUE;\n            else\n               return FALSE;\n         }\n      }\n   }\n   return FALSE;\n}\n}\nOOBOOL ooCapabilityCheckCompatibility_H263Video\n   (struct OOH323CallData *call, ooH323EpCapability *epCap, \n    H245VideoCapability *pVideoCap, int dir)\n{\n   H245H263VideoCapability *pH263Cap = NULL;\n   OOH263CapParams *params = epCap->params;\n   if(!pVideoCap->u.h263VideoCapability)  \n   {\n      OOTRACEERR3(\"Error:No H263 video capability present in video capability\"\n                 \"structure. (%s, %s)\\n\", call->callType, call->callToken);\n      return FALSE;\n   }\n}\nOOBOOL ooCapabilityCheckCompatibility_Audio\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245AudioCapability* audioCap, int dir)\n{\n   switch(audioCap->t)\n   {\n   case T_H245AudioCapability_g711Ulaw56k:\n   case T_H245AudioCapability_g711Ulaw64k:\n   case T_H245AudioCapability_g711Alaw64k:\n   case T_H245AudioCapability_g711Alaw56k:\n   \n   case T_H245AudioCapability_g728:\n   case T_H245AudioCapability_g729:\n   case T_H245AudioCapability_g729AnnexA:\n   case T_H245AudioCapability_g729wAnnexB:\n   case T_H245AudioCapability_g7231:\n      return ooCapabilityCheckCompatibility_Simple(call, epCap, audioCap, dir);\n   case T_H245AudioCapability_nonStandard:\n      return ooCapabilityCheckCompatibility_NonStandard(call, epCap, audioCap, dir);\n   case T_H245AudioCapability_gsmHalfRate:\n   case T_H245AudioCapability_gsmEnhancedFullRate:\n   case T_H245AudioCapability_gsmFullRate:\n      return ooCapabilityCheckCompatibility_GSM(call, epCap, audioCap, dir);\n   default:\n      return FALSE;\n   }\n   return FALSE;  \n}\n}\nOOBOOL ooCapabilityCheckCompatibility_Audio\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245AudioCapability* audioCap, int dir)\n{\n   switch(audioCap->t)\n   {\n   case T_H245AudioCapability_g711Ulaw56k:\n   case T_H245AudioCapability_g711Ulaw64k:\n   case T_H245AudioCapability_g711Alaw64k:\n   case T_H245AudioCapability_g711Alaw56k:\n   \n   case T_H245AudioCapability_g728:\n   case T_H245AudioCapability_g729:\n   case T_H245AudioCapability_g729AnnexA:\n   case T_H245AudioCapability_g729wAnnexB:\n   case T_H245AudioCapability_g7231:\n      return ooCapabilityCheckCompatibility_Simple(call, epCap, audioCap, dir);\n   case T_H245AudioCapability_nonStandard:\n      return ooCapabilityCheckCompatibility_NonStandard(call, epCap, audioCap, dir);\n   case T_H245AudioCapability_gsmHalfRate:\n   case T_H245AudioCapability_gsmEnhancedFullRate:\n   case T_H245AudioCapability_gsmFullRate:\n      return ooCapabilityCheckCompatibility_GSM(call, epCap, audioCap, dir);\n   default:\n      return FALSE;\n   }\n}\nOOBOOL ooCapabilityCheckCompatibility_Video\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245VideoCapability* videoCap, int dir)\n{\n   switch(videoCap->t)\n   {\n   case T_H245VideoCapability_h263VideoCapability:\n      return ooCapabilityCheckCompatibility_H263Video(call, epCap, \n                                                              videoCap, dir);\n   default:\n     OOTRACEDBGC3(\"ooCapabilityCheckCompatibility_Video - Unsupported video \"\n                  \"capability. (%s, %s)\\n\", call->callType, call->callToken);\n   }\n   return FALSE;\n}\n}\nOOBOOL ooCapabilityCheckCompatibility_Video\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245VideoCapability* videoCap, int dir)\n{\n   switch(videoCap->t)\n   {\n   case T_H245VideoCapability_h263VideoCapability:\n      return ooCapabilityCheckCompatibility_H263Video(call, epCap, \n                                                              videoCap, dir);\n   default:\n     OOTRACEDBGC3(\"ooCapabilityCheckCompatibility_Video - Unsupported video \"\n                  \"capability. (%s, %s)\\n\", call->callType, call->callToken);\n   }\n*/\nOOBOOL ooCapabilityCheckCompatibility\n   (struct OOH323CallData *call, ooH323EpCapability* epCap, \n    H245DataType* dataType, int dir)\n{\n   switch(dataType->t)\n   {\n   case T_H245DataType_audioData:\n      if(epCap->capType == OO_CAP_TYPE_AUDIO)\n         return ooCapabilityCheckCompatibility_Audio(call, epCap, \n                                                   dataType->u.audioData, dir);\n      break;\n   case T_H245DataType_videoData:\n      if(epCap->capType == OO_CAP_TYPE_VIDEO)\n         return ooCapabilityCheckCompatibility_Video(call, epCap, \n                                                   dataType->u.videoData, dir);\n      break;\n   case T_H245DataType_data:\n      if(epCap->capType == OO_CAP_TYPE_DATA)\n\treturn ooCapabilityCheckCompatibility_T38(call, epCap, dataType->u.data, dir);\n   default:\n      OOTRACEDBGC3(\"ooCapabilityCheckCompatibility - Unsupported  \"\n                  \"capability. (%s, %s)\\n\", call->callType, call->callToken);\n   }\n   return FALSE;\n}\n*/\nOOBOOL ooCapabilityCheckCompatibility\n   (struct OOH323CallData *call, ooH323EpCapability* epCap, \n    H245DataType* dataType, int dir)\n{\n   switch(dataType->t)\n   {\n   case T_H245DataType_audioData:\n      if(epCap->capType == OO_CAP_TYPE_AUDIO)\n         return ooCapabilityCheckCompatibility_Audio(call, epCap, \n                                                   dataType->u.audioData, dir);\n      break;\n   case T_H245DataType_videoData:\n      if(epCap->capType == OO_CAP_TYPE_VIDEO)\n         return ooCapabilityCheckCompatibility_Video(call, epCap, \n                                                   dataType->u.videoData, dir);\n      break;\n   case T_H245DataType_data:\n      if(epCap->capType == OO_CAP_TYPE_DATA)\n\treturn ooCapabilityCheckCompatibility_T38(call, epCap, dataType->u.data, dir);\n   default:\n      OOTRACEDBGC3(\"ooCapabilityCheckCompatibility - Unsupported  \"\n                  \"capability. (%s, %s)\\n\", call->callType, call->callToken);\n   }\n", "bug_type": null, "idx": 545}
{"project": "Asterisk", "target": 0, "func": "static int cdr_write(struct ast_channel *chan, const char *cmd, char *parse,\n\t\t     const char *value)\n{\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tRAII_VAR(struct cdr_func_payload *, payload, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message_router *, router,\n\t\t     ast_cdr_message_router(), ao2_cleanup);\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\tif (!router) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to manipulate CDR for channel %s: no message router\\n\",\n\t\t\tast_channel_name(chan));\n\t\treturn -1;\n\t}\n\tif (!cdr_write_message_type()) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to manipulate CDR for channel %s: message type not available\\n\",\n\t\t\tast_channel_name(chan));\n\t\treturn -1;\n\t}\n\tpayload = ao2_alloc(sizeof(*payload), NULL);\n\tif (!payload) {\n\t\treturn -1;\n\t}\n\tpayload->chan = chan;\n\tpayload->cmd = cmd;\n\tpayload->arguments = parse;\n\tpayload->value = value;\n\tmessage = stasis_message_create(cdr_write_message_type(), payload);\n\tif (!message) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to manipulate CDR for channel %s: unable to create message\\n\",\n\t\t\tast_channel_name(chan));\n\t\treturn -1;\n\t}\n\tstasis_message_router_publish_sync(router, message);\n\treturn 0;\n}\n", "bug_type": null, "idx": 546}
{"project": "Asterisk", "target": 0, "func": "static int lintog722_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tstruct g722_encoder_pvt *tmp = pvt->pvt;\n\tint outlen;\n\toutlen = g722_encode(&tmp->g722, (&pvt->outbuf.ui8[pvt->datalen]), \n\t\t(int16_t *) f->data.ptr, f->samples);\n\tpvt->samples += outlen * 2;\n\tpvt->datalen += outlen;\n\treturn 0;\n}\n", "bug_type": null, "idx": 547}
{"project": "Asterisk", "target": 0, "func": "\nvoid callerid_init(void)\n{\n\tcid_dr[0] = cos(CALLERID_SPACE * 2.0 * M_PI / 8000.0);\n\tcid_di[0] = sin(CALLERID_SPACE * 2.0 * M_PI / 8000.0);\n\tcid_dr[1] = cos(CALLERID_MARK * 2.0 * M_PI / 8000.0);\n\tcid_di[1] = sin(CALLERID_MARK * 2.0 * M_PI / 8000.0);\n\tsasdr = cos(SAS_FREQ * 2.0 * M_PI / 8000.0);\n\tsasdi = sin(SAS_FREQ * 2.0 * M_PI / 8000.0);\n\tcasdr1 = cos(CAS_FREQ1 * 2.0 * M_PI / 8000.0);\n\tcasdi1 = sin(CAS_FREQ1 * 2.0 * M_PI / 8000.0);\n\tcasdr2 = cos(CAS_FREQ2 * 2.0 * M_PI / 8000.0);\n\tcasdi2 = sin(CAS_FREQ2 * 2.0 * M_PI / 8000.0);\n}\n", "bug_type": null, "idx": 548}
{"project": "Asterisk", "target": 0, "func": "int ast_adsi_clear_soft_keys(unsigned char *buf)\n{\n\tint res = 0;\n\tast_rwlock_rdlock(&func_lock);\n\tif (installed_funcs && installed_funcs->clear_soft_keys) {\n\t\tres = installed_funcs->clear_soft_keys(buf);\n\t}\n\tast_rwlock_unlock(&func_lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 549}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void res_srtp_shutdown(void)\n{\n\tast_sdp_crypto_unregister(&res_sdp_crypto_api);\n\tast_rtp_engine_unregister_srtp();\n\tsrtp_install_event_handler(NULL);\n#ifdef HAVE_SRTP_SHUTDOWN\n\tsrtp_shutdown();\n#endif\n\tg_initialized = 0;\n}\n", "bug_type": null, "idx": 550}
{"project": "Asterisk", "target": 0, "func": "const char *ast_str_retrieve_variable(struct ast_str **str, ssize_t maxlen, struct ast_channel *c, struct varshead *headp, const char *var)\n{\n\tconst char not_found = '\\0';\n\tchar *tmpvar;\n\tconst char *ret;\n\tconst char *s;\t\n\tint offset, length;\n\tint i, need_substring;\n\tstruct varshead *places[2] = { headp, &globals };\t\n\tchar workspace[20];\n\tif (c) {\n\t\tast_channel_lock(c);\n\t\tplaces[0] = ast_channel_varshead(c);\n\t}\n\t\n\ttmpvar = ast_strdupa(var);\t\n\tneed_substring = parse_variable_name(tmpvar, &offset, &length, &i );\n\t\n\ts = &not_found;\t\n\tif (c) {\t\n\t\t\n\t\tif (!strncmp(var, \"CALL\", 4)) {\n\t\t\tif (!strncmp(var + 4, \"ING\", 3)) {\n\t\t\t\tif (!strcmp(var + 7, \"PRES\")) {\t\t\t\n\t\t\t\t\tast_str_set(str, maxlen, \"%d\",\n\t\t\t\t\t\tast_party_id_presentation(&ast_channel_caller(c)->id));\n\t\t\t\t\ts = ast_str_buffer(*str);\n\t\t\t\t} else if (!strcmp(var + 7, \"ANI2\")) {\t\t\n\t\t\t\t\tast_str_set(str, maxlen, \"%d\", ast_channel_caller(c)->ani2);\n\t\t\t\t\ts = ast_str_buffer(*str);\n\t\t\t\t} else if (!strcmp(var + 7, \"TON\")) {\t\t\n\t\t\t\t\tast_str_set(str, maxlen, \"%d\", ast_channel_caller(c)->id.number.plan);\n\t\t\t\t\ts = ast_str_buffer(*str);\n\t\t\t\t} else if (!strcmp(var + 7, \"TNS\")) {\t\t\n\t\t\t\t\tast_str_set(str, maxlen, \"%d\", ast_channel_dialed(c)->transit_network_select);\n\t\t\t\t\ts = ast_str_buffer(*str);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(var, \"HINT\")) {\n\t\t\ts = ast_str_get_hint(str, maxlen, NULL, 0, c, ast_channel_context(c), ast_channel_exten(c)) ? ast_str_buffer(*str) : NULL;\n\t\t} else if (!strcmp(var, \"HINTNAME\")) {\n\t\t\ts = ast_str_get_hint(NULL, 0, str, maxlen, c, ast_channel_context(c), ast_channel_exten(c)) ? ast_str_buffer(*str) : NULL;\n\t\t} else if (!strcmp(var, \"EXTEN\")) {\n\t\t\ts = ast_channel_exten(c);\n\t\t} else if (!strcmp(var, \"CONTEXT\")) {\n\t\t\ts = ast_channel_context(c);\n\t\t} else if (!strcmp(var, \"PRIORITY\")) {\n\t\t\tast_str_set(str, maxlen, \"%d\", ast_channel_priority(c));\n\t\t\ts = ast_str_buffer(*str);\n\t\t} else if (!strcmp(var, \"CHANNEL\")) {\n\t\t\ts = ast_channel_name(c);\n\t\t} else if (!strcmp(var, \"UNIQUEID\")) {\n\t\t\ts = ast_channel_uniqueid(c);\n\t\t} else if (!strcmp(var, \"HANGUPCAUSE\")) {\n\t\t\tast_str_set(str, maxlen, \"%d\", ast_channel_hangupcause(c));\n\t\t\ts = ast_str_buffer(*str);\n\t\t}\n\t}\n\tif (s == &not_found) { \n\t\tif (!strcmp(var, \"EPOCH\")) {\n\t\t\tast_str_set(str, maxlen, \"%d\", (int) time(NULL));\n\t\t\ts = ast_str_buffer(*str);\n\t\t} else if (!strcmp(var, \"SYSTEMNAME\")) {\n\t\t\ts = ast_config_AST_SYSTEM_NAME;\n\t\t} else if (!strcmp(var, \"ASTETCDIR\")) {\n\t\t\ts = ast_config_AST_CONFIG_DIR;\n\t\t} else if (!strcmp(var, \"ASTMODDIR\")) {\n\t\t\ts = ast_config_AST_MODULE_DIR;\n\t\t} else if (!strcmp(var, \"ASTVARLIBDIR\")) {\n\t\t\ts = ast_config_AST_VAR_DIR;\n\t\t} else if (!strcmp(var, \"ASTDBDIR\")) {\n\t\t\ts = ast_config_AST_DB;\n\t\t} else if (!strcmp(var, \"ASTKEYDIR\")) {\n\t\t\ts = ast_config_AST_KEY_DIR;\n\t\t} else if (!strcmp(var, \"ASTDATADIR\")) {\n\t\t\ts = ast_config_AST_DATA_DIR;\n\t\t} else if (!strcmp(var, \"ASTAGIDIR\")) {\n\t\t\ts = ast_config_AST_AGI_DIR;\n\t\t} else if (!strcmp(var, \"ASTSPOOLDIR\")) {\n\t\t\ts = ast_config_AST_SPOOL_DIR;\n\t\t} else if (!strcmp(var, \"ASTRUNDIR\")) {\n\t\t\ts = ast_config_AST_RUN_DIR;\n\t\t} else if (!strcmp(var, \"ASTLOGDIR\")) {\n\t\t\ts = ast_config_AST_LOG_DIR;\n\t\t} else if (!strcmp(var, \"ENTITYID\")) {\n\t\t\tast_eid_to_str(workspace, sizeof(workspace), &ast_eid_default);\n\t\t\ts = workspace;\n\t\t}\n\t}\n\t\n\tfor (i = 0; s == &not_found && i < ARRAY_LEN(places); i++) {\n\t\tstruct ast_var_t *variables;\n\t\tif (!places[i])\n\t\t\tcontinue;\n\t\tif (places[i] == &globals)\n\t\t\tast_rwlock_rdlock(&globalslock);\n\t\tAST_LIST_TRAVERSE(places[i], variables, entries) {\n\t\t\tif (!strcmp(ast_var_name(variables), var)) {\n\t\t\t\ts = ast_var_value(variables);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (places[i] == &globals)\n\t\t\tast_rwlock_unlock(&globalslock);\n\t}\n\tif (s == &not_found || s == NULL) {\n\t\tast_debug(5, \"Result of '%s' is NULL\\n\", var);\n\t\tret = NULL;\n\t} else {\n\t\tast_debug(5, \"Result of '%s' is '%s'\\n\", var, s);\n\t\tif (s != ast_str_buffer(*str)) {\n\t\t\tast_str_set(str, maxlen, \"%s\", s);\n\t\t}\n\t\tret = ast_str_buffer(*str);\n\t\tif (need_substring) {\n\t\t\tret = ast_str_substring(*str, offset, length);\n\t\t\tast_debug(2, \"Final result of '%s' is '%s'\\n\", var, ret);\n\t\t}\n\t}\n\tif (c) {\n\t\tast_channel_unlock(c);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 551}
{"project": "Asterisk", "target": 0, "func": "static int manager_stop_mixmonitor(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tconst char *mixmonitor_id = astman_get_header(m, \"MixMonitorID\");\n\tint res;\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn AMI_SUCCESS;\n\t}\n\tc = ast_channel_get_by_name(name);\n\tif (!c) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn AMI_SUCCESS;\n\t}\n\tres = stop_mixmonitor_full(c, mixmonitor_id);\n\tif (res) {\n\t\tast_channel_unref(c);\n\t\tastman_send_error(s, m, \"Could not stop monitoring channel\");\n\t\treturn AMI_SUCCESS;\n\t}\n\tastman_append(s, \"Response: Success\\r\\n\");\n\tif (!ast_strlen_zero(id)) {\n\t\tastman_append(s, \"ActionID: %s\\r\\n\", id);\n\t}\n\tastman_append(s, \"\\r\\n\");\n\tast_channel_unref(c);\n\treturn AMI_SUCCESS;\n}\n", "bug_type": null, "idx": 552}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tif (ast_format_interface_register(\"siren7\", &siren7_interface)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 553}
{"project": "Asterisk", "target": 0, "func": "};\nstatic char *alarm2str(int alm)\n{\n\tint x;\n\tfor (x = 0; x < ARRAY_LEN(alarms); x++) {\n\t\tif (alarms[x].alarm & alm)\n\t\t\treturn alarms[x].name;\n\t}\n\treturn alm ? \"Unknown Alarm\" : \"No Alarm\";\n}\n", "bug_type": null, "idx": 554}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_vm_unregister(vm_table.module_name);\n#if defined(MWI_DEBUG_CLI)\n\tast_cli_unregister_multiple(mwi_cli, ARRAY_LEN(mwi_cli));\n#endif\t\n\tast_sorcery_observer_remove(mwi_sorcery, MWI_MAILBOX_TYPE, &mwi_observers);\n\tast_sorcery_unref(mwi_sorcery);\n\tmwi_sorcery = NULL;\n\treturn 0;\n}\n", "bug_type": null, "idx": 555}
{"project": "Asterisk", "target": 0, "func": "enum ast_extension_states ast_devstate_to_extenstate(enum ast_device_state devstate)\n{\n\tswitch (devstate) {\n\tcase AST_DEVICE_ONHOLD:\n\t\treturn AST_EXTENSION_ONHOLD;\n\tcase AST_DEVICE_BUSY:\n\t\treturn AST_EXTENSION_BUSY;\n\tcase AST_DEVICE_UNKNOWN:\n\t\treturn AST_EXTENSION_NOT_INUSE;\n\tcase AST_DEVICE_UNAVAILABLE:\n\tcase AST_DEVICE_INVALID:\n\t\treturn AST_EXTENSION_UNAVAILABLE;\n\tcase AST_DEVICE_RINGINUSE:\n\t\treturn (AST_EXTENSION_INUSE | AST_EXTENSION_RINGING);\n\tcase AST_DEVICE_RINGING:\n\t\treturn AST_EXTENSION_RINGING;\n\tcase AST_DEVICE_INUSE:\n\t\treturn AST_EXTENSION_INUSE;\n\tcase AST_DEVICE_NOT_INUSE:\n\t\treturn AST_EXTENSION_NOT_INUSE;\n\tcase AST_DEVICE_TOTAL: \n\t\tbreak;\n\t}\n\treturn AST_EXTENSION_NOT_INUSE;\n}\n", "bug_type": null, "idx": 556}
{"project": "Asterisk", "target": 0, "func": "static int update_device_info(struct video_desc *env, int i)\n{\n\treset_board(env->gui->thumb_bd_array[i].board);\n\tprint_message(env->gui->thumb_bd_array[i].board,\n\t\tsrc_msgs[env->out.devices[i].status_index]);\n\treturn 0;\n}\n", "bug_type": null, "idx": 557}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ext_cmp_pattern(const char *left, const char *right)\n{\n\tint cmp;\n\tint left_pos;\n\tint right_pos;\n\tfor (;;) {\n\t\tunsigned char left_bitwise[32] = { 0, };\n\t\tunsigned char right_bitwise[32] = { 0, };\n\t\tleft_pos = ext_cmp_pattern_pos(&left, left_bitwise);\n\t\tright_pos = ext_cmp_pattern_pos(&right, right_bitwise);\n\t\tcmp = left_pos - right_pos;\n\t\tif (!cmp) {\n\t\t\t\n\t\t\tcmp = memcmp(right_bitwise, left_bitwise, ARRAY_LEN(left_bitwise));\n\t\t}\n\t\tif (cmp) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!left) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn cmp;\n}\n", "bug_type": null, "idx": 558}
{"project": "Asterisk", "target": 0, "func": "#endif\nstatic int check_header_fmt(FILE *f, int hsize, int hz)\n{\n\tunsigned short format, chans, bysam, bisam;\n\tunsigned int freq, bysec;\n\tif (hsize < 16) {\n\t\tast_log(LOG_WARNING, \"Unexpected header size %d\\n\", hsize);\n\t\treturn -1;\n\t}\n\tif (fread(&format, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Read failed (format)\\n\");\n\t\treturn -1;\n\t}\n\tif (ltohs(format) != 1) {\n\t\tast_log(LOG_WARNING, \"Not a supported wav file format (%d). Only PCM encoded, 16 bit, mono, 8kHz/16kHz files are supported with a lowercase '.wav' extension.\\n\", ltohs(format));\n\t\treturn -1;\n\t}\n\tif (fread(&chans, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Read failed (format)\\n\");\n\t\treturn -1;\n\t}\n\tif (ltohs(chans) != 1) {\n\t\tast_log(LOG_WARNING, \"Not in mono %d\\n\", ltohs(chans));\n\t\treturn -1;\n\t}\n\tif (fread(&freq, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Read failed (freq)\\n\");\n\t\treturn -1;\n\t}\n\tfreq = ltohl(freq);\n\tif ((freq != 8000 && freq != 16000) || freq != hz) {\n\t\tast_log(LOG_WARNING, \"Unexpected frequency mismatch %d (expecting %d)\\n\", freq, hz);\n\t\treturn -1;\n\t}\n\t\n\tif (fread(&bysec, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Read failed (BYTES_PER_SECOND)\\n\");\n\t\treturn -1;\n\t}\n\t\n\tif (fread(&bysam, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Read failed (BYTES_PER_SAMPLE)\\n\");\n\t\treturn -1;\n\t}\n\tif (ltohs(bysam) != 2) {\n\t\tast_log(LOG_WARNING, \"Can only handle 16bits per sample: %d\\n\", ltohs(bysam));\n\t\treturn -1;\n\t}\n\tif (fread(&bisam, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Read failed (Bits Per Sample): %d\\n\", ltohs(bisam));\n\t\treturn -1;\n\t}\n\t\n\tif (fseek(f,hsize-16,SEEK_CUR) == -1 ) {\n\t\tast_log(LOG_WARNING, \"Failed to skip remaining header bytes: %d\\n\", hsize-16 );\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 559}
{"project": "Asterisk", "target": 0, "func": "void *ast_dial_get_user_data(struct ast_dial *dial)\n{\n\treturn dial->user_data;\n}\n", "bug_type": null, "idx": 560}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235AuthenticationBES (OOCTXT* pctxt, H235AuthenticationBES* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 2);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 1);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            \n            break;\n         \n         case 2:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 3);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 561}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_get_unidentified_request_thresholds(unsigned int *count, unsigned int *period,\n\tunsigned int *prune_interval)\n{\n\tstruct global_config *cfg;\n\tcfg = get_global_cfg();\n\tif (!cfg) {\n\t\t*count = DEFAULT_UNIDENTIFIED_REQUEST_COUNT;\n\t\t*period = DEFAULT_UNIDENTIFIED_REQUEST_PERIOD;\n\t\t*prune_interval = DEFAULT_UNIDENTIFIED_REQUEST_PRUNE_INTERVAL;\n\t\treturn;\n\t}\n\t*count = cfg->unidentified_request_count;\n\t*period = cfg->unidentified_request_period;\n\t*prune_interval = cfg->unidentified_request_prune_interval;\n\tao2_ref(cfg, -1);\n\treturn;\n}\n", "bug_type": null, "idx": 562}
{"project": "Asterisk", "target": 0, "func": "};\nenum stasis_playback_oper_results stasis_app_playback_operation(\n\tstruct stasis_app_playback *playback,\n\tenum stasis_app_playback_media_operation operation)\n{\n\tplayback_opreation_cb cb;\n\tSCOPED_AO2LOCK(lock, playback);\n\tast_assert((unsigned int)playback->state < STASIS_PLAYBACK_STATE_MAX);\n\tif (operation >= STASIS_PLAYBACK_MEDIA_OP_MAX) {\n\t\tast_log(LOG_ERROR, \"Invalid playback operation %u\\n\", operation);\n\t\treturn -1;\n\t}\n\tcb = operations[playback->state][operation];\n\tif (!cb) {\n\t\tif (playback->state != STASIS_PLAYBACK_STATE_PLAYING) {\n\t\t\t\n\t\t\treturn STASIS_PLAYBACK_OPER_NOT_PLAYING;\n\t\t} else {\n\t\t\t\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Unhandled operation during playback: %u\\n\",\n\t\t\t\toperation);\n\t\t\treturn STASIS_PLAYBACK_OPER_FAILED;\n\t\t}\n\t}\n\treturn cb(playback) ?\n\t\tSTASIS_PLAYBACK_OPER_FAILED : STASIS_PLAYBACK_OPER_OK;\n}\n", "bug_type": null, "idx": 563}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tAST_TEST_REGISTER(get_docs);\n\tAST_TEST_REGISTER(get_docs_nohost);\n\tAST_TEST_REGISTER(get_docs_notfound);\n\tAST_TEST_REGISTER(get_docs_hackerz);\n\tAST_TEST_REGISTER(invoke_get);\n\tAST_TEST_REGISTER(invoke_wildcard);\n\tAST_TEST_REGISTER(invoke_delete);\n\tAST_TEST_REGISTER(invoke_post);\n\tAST_TEST_REGISTER(invoke_bad_post);\n\tAST_TEST_REGISTER(invoke_not_found);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 564}
{"project": "Asterisk", "target": 0, "func": "void misdn_cfg_get_config_string (int port, enum misdn_cfg_elements elem, char* buf, int bufsize)\n{\n\tint place;\n\tchar tempbuf[BUFFERSIZE] = \"\";\n\tstruct msn_list *iter;\n\tif ((elem < MISDN_CFG_LAST) && !misdn_cfg_is_port_valid(port)) {\n\t\t*buf = 0;\n\t\tast_log(LOG_WARNING, \"Invalid call to misdn_cfg_get_config_string! Port number %d is not valid.\\n\", port);\n\t\treturn;\n\t}\n\tplace = map[elem];\n\tmisdn_cfg_lock();\n\tif (elem == MISDN_CFG_PTP) {\n\t\tsnprintf(buf, bufsize, \" -> ptp: %s\", ptp[port] ? \"yes\" : \"no\");\n\t}\n\telse if (elem > MISDN_CFG_FIRST && elem < MISDN_CFG_LAST) {\n\t\tswitch (port_spec[place].type) {\n\t\tcase MISDN_CTYPE_INT:\n\t\tcase MISDN_CTYPE_BOOLINT:\n\t\t\tif (port_cfg[port][place].num)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %d\", port_spec[place].name, *port_cfg[port][place].num);\n\t\t\telse if (port_cfg[0][place].num)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %d\", port_spec[place].name, *port_cfg[0][place].num);\n\t\t\telse\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", port_spec[place].name);\n\t\t\tbreak;\n\t\tcase MISDN_CTYPE_BOOL:\n\t\t\tif (port_cfg[port][place].num)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name, *port_cfg[port][place].num ? \"yes\" : \"no\");\n\t\t\telse if (port_cfg[0][place].num)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name, *port_cfg[0][place].num ? \"yes\" : \"no\");\n\t\t\telse\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", port_spec[place].name);\n\t\t\tbreak;\n\t\tcase MISDN_CTYPE_ASTGROUP:\n\t\t\tif (port_cfg[port][place].grp)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name,\n\t\t\t\t\t\t ast_print_group(tempbuf, sizeof(tempbuf), *port_cfg[port][place].grp));\n\t\t\telse if (port_cfg[0][place].grp)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name,\n\t\t\t\t\t\t ast_print_group(tempbuf, sizeof(tempbuf), *port_cfg[0][place].grp));\n\t\t\telse\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", port_spec[place].name);\n\t\t\tbreak;\n\t\tcase MISDN_CTYPE_ASTNAMEDGROUP:\n\t\t\tif (port_cfg[port][place].namgrp) {\n\t\t\t\tstruct ast_str *tmp_str = ast_str_create(1024);\n\t\t\t\tif (tmp_str) {\n\t\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name,\n\t\t\t\t\t\t\tast_print_namedgroups(&tmp_str, port_cfg[port][place].namgrp));\n\t\t\t\t\tast_free(tmp_str);\n\t\t\t\t}\n\t\t\t} else if (port_cfg[0][place].namgrp) {\n\t\t\t\tstruct ast_str *tmp_str = ast_str_create(1024);\n\t\t\t\tif (tmp_str) {\n\t\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name,\n\t\t\t\t\t\t\tast_print_namedgroups(&tmp_str, port_cfg[0][place].namgrp));\n\t\t\t\t\tast_free(tmp_str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", port_spec[place].name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MISDN_CTYPE_MSNLIST:\n\t\t\tif (port_cfg[port][place].ml)\n\t\t\t\titer = port_cfg[port][place].ml;\n\t\t\telse\n\t\t\t\titer = port_cfg[0][place].ml;\n\t\t\tif (iter) {\n\t\t\t\tfor (; iter; iter = iter->next) {\n\t\t\t\t\tstrncat(tempbuf, iter->msn, sizeof(tempbuf) - strlen(tempbuf) - 1);\n\t\t\t\t}\n\t\t\t\tif (strlen(tempbuf) > 1) {\n\t\t\t\t\ttempbuf[strlen(tempbuf)-2] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnprintf(buf, bufsize, \" -> msns: %s\", *tempbuf ? tempbuf : \"none\");\n\t\t\tbreak;\n\t\tcase MISDN_CTYPE_STR:\n\t\t\tif ( port_cfg[port][place].str) {\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name, port_cfg[port][place].str);\n\t\t\t} else if (port_cfg[0][place].str) {\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", port_spec[place].name, port_cfg[0][place].str);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", port_spec[place].name);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else if (elem > MISDN_GEN_FIRST && elem < MISDN_GEN_LAST) {\n\t\tswitch (gen_spec[place].type) {\n\t\tcase MISDN_CTYPE_INT:\n\t\tcase MISDN_CTYPE_BOOLINT:\n\t\t\tif (general_cfg[place].num)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %d\", gen_spec[place].name, *general_cfg[place].num);\n\t\t\telse\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", gen_spec[place].name);\n\t\t\tbreak;\n\t\tcase MISDN_CTYPE_BOOL:\n\t\t\tif (general_cfg[place].num)\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", gen_spec[place].name, *general_cfg[place].num ? \"yes\" : \"no\");\n\t\t\telse\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", gen_spec[place].name);\n\t\t\tbreak;\n\t\tcase MISDN_CTYPE_STR:\n\t\t\tif ( general_cfg[place].str) {\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s: %s\", gen_spec[place].name, general_cfg[place].str);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufsize, \" -> %s:\", gen_spec[place].name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(buf, bufsize, \" -> type of %s not handled yet\", gen_spec[place].name);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t*buf = 0;\n\t\tast_log(LOG_WARNING, \"Invalid call to misdn_cfg_get_config_string! Invalid config element (%d) requested.\\n\", elem);\n\t}\n\tmisdn_cfg_unlock();\n}\n", "bug_type": null, "idx": 565}
{"project": "Asterisk", "target": 0, "func": "enum ast_cc_agent_policies ast_get_cc_agent_policy(struct ast_cc_config_params *config)\n{\n\treturn config->cc_agent_policy;\n}\n", "bug_type": null, "idx": 566}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void threadpool_tps_shutdown(struct ast_taskprocessor_listener *listener)\n{\n\tstruct ast_threadpool *pool = ast_taskprocessor_listener_get_user_data(listener);\n\tif (pool->listener && pool->listener->callbacks->shutdown) {\n\t\tpool->listener->callbacks->shutdown(pool->listener);\n\t}\n\tao2_cleanup(pool->active_threads);\n\tao2_cleanup(pool->idle_threads);\n\tao2_cleanup(pool->zombie_threads);\n\tao2_cleanup(pool);\n}\n", "bug_type": null, "idx": 567}
{"project": "Asterisk", "target": 0, "func": "static int sco_write(int s, char *buf, int len)\n{\n\tint r;\n\tif (s == -1) {\n\t\tast_debug(3, \"sco_write() not ready\\n\");\n\t\treturn 0;\n\t}\n\tast_debug(3, \"sco_write()\\n\");\n\tr = write(s, buf, len);\n\tif (r == -1) {\n\t\tast_debug(3, \"sco write error %d\\n\", errno);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 568}
{"project": "Asterisk", "target": 0, "func": "static GtkWidget *get_menubar_menu(GtkWidget *window)\n{\n\tGtkItemFactory *item_factory;\n\tGtkAccelGroup *accel_group;\n\t\n\taccel_group = gtk_accel_group_new();\n\t\n\titem_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, \"<main>\",\n\t\t\t\t\taccel_group);\n\t\n\tgtk_item_factory_create_items(item_factory, nmenu_items, menu_items, NULL);\n\t\n\tgtk_window_add_accel_group(GTK_WINDOW(window), accel_group);\n\t\n\treturn gtk_item_factory_get_widget(item_factory, \"<main>\");\n}\n", "bug_type": null, "idx": 569}
{"project": "Asterisk", "target": 0, "func": "const struct ast_mwi_mailbox_object *ast_mwi_mailbox_get(const char *mailbox_id)\n{\n\tif (ast_strlen_zero(mailbox_id)) {\n\t\treturn NULL;\n\t}\n\treturn ast_sorcery_retrieve_by_id(mwi_sorcery, MWI_MAILBOX_TYPE, mailbox_id);\n}\n", "bug_type": null, "idx": 570}
{"project": "Asterisk", "target": 0, "func": "static int calendar_busy_callback(void *obj, void *arg, int flags)\n{\n\tstruct ast_calendar_event *event = obj;\n\tint *is_busy = arg;\n\tstruct timeval tv = ast_tvnow();\n\tif (tv.tv_sec >= event->start && tv.tv_sec <= event->end && event->busy_state > AST_CALENDAR_BS_FREE) {\n\t\t*is_busy = 1;\n\t\treturn CMP_STOP;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 571}
{"project": "Asterisk", "target": 0, "func": "\nstatic int sorcery_instance_cmp(void *obj, void *arg, int flags)\n{\n\tconst struct sorcery_proxy *object_left = obj;\n\tconst struct sorcery_proxy *object_right = arg;\n\tconst char *right_key = arg;\n\tint cmp;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_OBJECT:\n\t\tright_key = object_right->module_name;\n\t\t\n\tcase OBJ_SEARCH_KEY:\n\t\tcmp = strcmp(object_left->module_name, right_key);\n\t\tbreak;\n\tcase OBJ_SEARCH_PARTIAL_KEY:\n\t\tcmp = strncmp(object_left->module_name, right_key, strlen(right_key));\n\t\tbreak;\n\tdefault:\n\t\tcmp = 0;\n\t\tbreak;\n\t}\n\tif (cmp) {\n\t\treturn 0;\n\t}\n\treturn CMP_MATCH;\n}\n", "bug_type": null, "idx": 572}
{"project": "Asterisk", "target": 0, "func": "static struct ast_str *caldav_get_events_between(struct caldav_pvt *pvt, time_t start_time, time_t end_time)\n{\n\tstruct ast_str *body, *response;\n\ticaltimezone *utc = icaltimezone_get_utc_timezone();\n\ticaltimetype start, end;\n\tconst char *start_str, *end_str;\n\tif (!(body = ast_str_create(512))) {\n\t\tast_log(LOG_ERROR, \"Could not allocate memory for body of request!\\n\");\n\t\treturn NULL;\n\t}\n\tstart = icaltime_from_timet_with_zone(start_time, 0, utc);\n\tend = icaltime_from_timet_with_zone(end_time, 0, utc);\n\tstart_str = icaltime_as_ical_string(start);\n\tend_str = icaltime_as_ical_string(end);\n\t\n\tast_str_append(&body, 0,\n\t\t\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n\"\n\t\t\"<C:calendar-query xmlns:D=\\\"DAV:\\\" xmlns:C=\\\"urn:ietf:params:xml:ns:caldav\\\">\\n\"\n\t\t\"  <D:prop>\\n\"\n\t\t\"    <C:calendar-data>\\n\"\n\t\t\"      <C:expand start=\\\"%s\\\" end=\\\"%s\\\"/>\\n\"\n\t\t\"    </C:calendar-data>\\n\"\n\t\t\"  </D:prop>\\n\"\n\t\t\"  <C:filter>\\n\"\n\t\t\"    <C:comp-filter name=\\\"VCALENDAR\\\">\\n\"\n\t\t\"      <C:comp-filter name=\\\"VEVENT\\\">\\n\"\n\t\t\"        <C:time-range start=\\\"%s\\\" end=\\\"%s\\\"/>\\n\"\n\t\t\"      </C:comp-filter>\\n\"\n\t\t\"    </C:comp-filter>\\n\"\n\t\t\"  </C:filter>\\n\"\n\t\t\"</C:calendar-query>\\n\", start_str, end_str, start_str, end_str);\n\tresponse = caldav_request(pvt, \"REPORT\", body, NULL, NULL);\n\tast_free(body);\n\tif (response && !ast_str_strlen(response)) {\n\t\tast_free(response);\n\t\treturn NULL;\n\t}\n\treturn response;\n}\n", "bug_type": null, "idx": 573}
{"project": "Asterisk", "target": 0, "func": "};\nint ooGkClientInit(enum RasGatekeeperMode eGkMode,\n              char *szGkAddr, int iGkPort )\n{\n   ooGkClient *pGkClient=NULL;\n   OOInterface *cur=NULL;\n   pGkClient = (ooGkClient*)\n                         memAlloc(&gH323ep.ctxt, sizeof(ooGkClient));\n   if(!pGkClient)\n   {\n      OOTRACEERR1(\"Error: Failed to allocate memory to Gatekeeper Client.\\n\");\n      return OO_FAILED;\n   }\n   memset(pGkClient, 0, sizeof(ooGkClient));\n   ast_mutex_init(&pGkClient->Lock);\n   gH323ep.gkClient = pGkClient;\n   initContext(&(pGkClient->ctxt));\n   initContext(&(pGkClient->msgCtxt));\n   pGkClient->rrqRetries = 0;\n   pGkClient->grqRetries = 0;\n   strcpy(pGkClient->localRASIP, gH323ep.signallingIP);\n#ifndef _WIN32\n   if(!strcmp(pGkClient->localRASIP, \"0.0.0.0\") ||\n      !strcmp(pGkClient->localRASIP, \"127.0.0.1\"))\n   {\n      if(!gH323ep.ifList)\n      {\n         if(ooSocketGetInterfaceList(&gH323ep.ctxt, &gH323ep.ifList)!= ASN_OK)\n         {\n            OOTRACEERR1(\"Error:Failed to retrieve interface addresses\\n\");\n            return OO_FAILED;\n         }\n      }\n      for(cur = gH323ep.ifList; cur; cur = cur->next)\n      {\n         if(!strcmp(cur->name, \"lo\") || !strcmp(cur->addr, \"127.0.0.1\"))\n            continue;\n         break;\n      }\n      if(cur)\n      {\n         OOTRACEINFO2(\"Using local RAS Ip address %s\\n\", cur->addr);\n         strcpy(pGkClient->localRASIP, cur->addr);\n      }\n      else{\n         OOTRACEERR1(\"Error:Failed to assign a local RAS IP address\\n\");\n         return OO_FAILED;\n      }\n   }\n#endif   \n   if(OO_OK != ooGkClientSetGkMode(pGkClient, eGkMode, szGkAddr, iGkPort))\n   {\n      OOTRACEERR1(\"Error:Failed to set Gk mode\\n\");\n      memReset(&gH323ep.ctxt);\n      return OO_FAILED;\n   }\n   \n   pGkClient->grqTimeout = DEFAULT_GRQ_TIMEOUT;\n   pGkClient->rrqTimeout = DEFAULT_RRQ_TIMEOUT;\n   pGkClient->regTimeout = DEFAULT_REG_TTL;\n   pGkClient->arqTimeout = DEFAULT_ARQ_TIMEOUT;\n   pGkClient->drqTimeout = DEFAULT_DRQ_TIMEOUT;\n   dListInit(&pGkClient->callsPendingList);\n   dListInit(&pGkClient->callsAdmittedList);\n   dListInit(&pGkClient->timerList);\n   pGkClient->state = GkClientIdle;\n   return OO_OK;\n}\n", "bug_type": null, "idx": 574}
{"project": "Asterisk", "target": 0, "func": "\nstatic int sorcery_observer_remove(void *obj, void *arg, int flags)\n{\n\tconst struct ast_sorcery_object_type_observer *observer = obj;\n\treturn (observer->callbacks == arg) ? CMP_MATCH : 0;\n}\n", "bug_type": null, "idx": 575}
{"project": "Asterisk", "target": 0, "func": "\nstatic void mwi_app_event_cb(void *data, struct stasis_subscription *sub,\n\t\t\t\t    struct stasis_message *message)\n{\n\tstruct ast_mwi_blob *payload = stasis_message_data(message);\n\tRAII_VAR(struct ast_str *, channel_event_string, NULL, ast_free);\n\tRAII_VAR(struct ast_str *, event_buffer, NULL, ast_free);\n\tstruct ast_json *event_json = ast_json_object_get(payload->blob, \"Event\");\n\tif (!event_json) {\n\t\treturn;\n\t}\n\tif (payload->mwi_state && payload->mwi_state->snapshot) {\n\t\tchannel_event_string = ast_manager_build_channel_state_string(payload->mwi_state->snapshot);\n\t}\n\tevent_buffer = ast_manager_str_from_json_object(payload->blob, exclude_event_cb);\n\tif (!event_buffer) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to create payload for event %s\\n\", ast_json_string_get(event_json));\n\t\treturn;\n\t}\n\tmanager_event(EVENT_FLAG_CALL, ast_json_string_get(event_json),\n\t\t\t\"Mailbox: %s\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"%s\",\n\t\t\tpayload->mwi_state ? payload->mwi_state->uniqueid : \"Unknown\",\n\t\t\tast_str_buffer(event_buffer),\n\t\t\tchannel_event_string ? ast_str_buffer(channel_event_string) : \"\");\n}\n", "bug_type": null, "idx": 576}
{"project": "Asterisk", "target": 0, "func": "static void hangup_chan(char *channel)\n{\n\tstruct channel *chan;\n\tif (debug)\n\t\tprintf(\"Hangup '%s'\\n\", channel);\n\tchan = find_channel(channel);\n\tif (chan)\n\t\tdelete_sub(chan, channel);\n\tcheck_mute();\n}\n", "bug_type": null, "idx": 577}
{"project": "Asterisk", "target": 0, "func": "void tdd_free(struct tdd_state *tdd)\n{\n\tast_free(tdd);\n}\n", "bug_type": null, "idx": 578}
{"project": "Asterisk", "target": 0, "func": "void command_invoke(struct stasis_app_command *command,\n\tstruct stasis_app_control *control, struct ast_channel *chan)\n{\n\tint retval = command->callback(control, chan, command->data);\n\tif (command->data_destructor) {\n\t\tcommand->data_destructor(command->data);\n\t\tcommand->data_destructor = NULL;\n\t}\n\tcommand_complete(command, retval);\n}\n", "bug_type": null, "idx": 579}
{"project": "Asterisk", "target": 0, "func": "static int misdn_answer(struct ast_channel *ast)\n{\n\tstruct chan_list *p;\n\tconst char *tmp;\n\tif (!ast || !(p = MISDN_ASTERISK_TECH_PVT(ast))) {\n\t\treturn -1;\n\t}\n\tchan_misdn_log(1, p ? (p->bc ? p->bc->port : 0) : 0, \"* ANSWER:\\n\");\n\tif (!p) {\n\t\tast_log(LOG_WARNING, \" --> Channel not connected ??\\n\");\n\t\tast_queue_hangup_with_cause(ast, AST_CAUSE_NETWORK_OUT_OF_ORDER);\n\t}\n\tif (!p->bc) {\n\t\tchan_misdn_log(1, 0, \" --> Got Answer, but there is no bc obj ??\\n\");\n\t\tast_queue_hangup_with_cause(ast, AST_CAUSE_PROTOCOL_ERROR);\n\t}\n\tast_channel_lock(ast);\n\ttmp = pbx_builtin_getvar_helper(ast, \"CRYPT_KEY\");\n\tif (!ast_strlen_zero(tmp)) {\n\t\tchan_misdn_log(1, p->bc->port, \" --> Connection will be BF crypted\\n\");\n\t\tast_copy_string(p->bc->crypt_key, tmp, sizeof(p->bc->crypt_key));\n\t} else {\n\t\tchan_misdn_log(3, p->bc->port, \" --> Connection is without BF encryption\\n\");\n\t}\n\ttmp = pbx_builtin_getvar_helper(ast, \"MISDN_DIGITAL_TRANS\");\n\tif (!ast_strlen_zero(tmp) && ast_true(tmp)) {\n\t\tchan_misdn_log(1, p->bc->port, \" --> Connection is transparent digital\\n\");\n\t\tp->bc->nodsp = 1;\n\t\tp->bc->hdlc = 0;\n\t\tp->bc->nojitter = 1;\n\t}\n\tast_channel_unlock(ast);\n\tp->state = MISDN_CONNECTED;\n\tstop_indicate(p);\n\tif (ast_strlen_zero(p->bc->connected.number)) {\n\t\tchan_misdn_log(2,p->bc->port,\" --> empty connected number using dialed number\\n\");\n\t\tast_copy_string(p->bc->connected.number, p->bc->dialed.number, sizeof(p->bc->connected.number));\n\t\t\n\t\tp->bc->connected.presentation = p->bc->presentation;\n\t\tp->bc->connected.screening = 0;\t\n\t\tp->bc->connected.number_type = p->bc->dialed.number_type;\n\t\tp->bc->connected.number_plan = p->bc->dialed.number_plan;\n\t}\n\tswitch (p->bc->outgoing_colp) {\n\tcase 1:\n\tcase 2:\n\t\tp->bc->connected.presentation = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#if defined(AST_MISDN_ENHANCEMENTS)\n\tif (p->bc->div_leg_3_tx_pending) {\n\t\tp->bc->div_leg_3_tx_pending = 0;\n\t\t\n\t\tp->bc->fac_out.Function = Fac_DivertingLegInformation3;\n\t\tp->bc->fac_out.u.DivertingLegInformation3.InvokeID = ++misdn_invoke_id;\n\t\tp->bc->fac_out.u.DivertingLegInformation3.PresentationAllowedIndicator =\n\t\t\t(p->bc->connected.presentation == 0) ? 1 : 0;\n\t\tprint_facility(&p->bc->fac_out, p->bc);\n\t}\n#endif\t\n\tmisdn_lib_send_event(p->bc, EVENT_CONNECT);\n\tstart_bc_tones(p);\n\treturn 0;\n}\n", "bug_type": null, "idx": 580}
{"project": "Asterisk", "target": 0, "func": "static void key_select_codec(struct unistimsession *pte, char keycode)\n{\n\tif (keycode == KEY_FUNC2) {\n\t\tif (pte->size_buff_entry <= 1) {\n\t\t\tkeycode = KEY_FUNC3;\n\t\t} else {\n\t\t\tpte->size_buff_entry -= 2;\n\t\t\tkeycode = pte->buff_entry[pte->size_buff_entry] + 0x10;\n\t\t}\n\t}\n\tif ((keycode >= KEY_0) && (keycode <= KEY_9)) {\n\t\tchar tmpbuf[] = SELECTCODEC_MSG;\n\t\tint i = 0;\n\t\tif (pte->size_buff_entry >= SELECTCODEC_MAX_LENGTH) {\n\t\t\treturn;\n\t\t}\n\t\twhile (i < pte->size_buff_entry) {\n\t\t\ttmpbuf[i + SELECTCODEC_START_ENTRY_POS] = pte->buff_entry[i];\n\t\t\ti++;\n\t\t}\n\t\ttmpbuf[i + SELECTCODEC_START_ENTRY_POS] = keycode - 0x10;\n\t\tpte->buff_entry[i] = keycode - 0x10;\n\t\tpte->size_buff_entry++;\n\t\tsend_text(TEXT_LINE2, TEXT_INVERSE, pte, tmpbuf);\n\t\tsend_blink_cursor(pte);\n\t\tsend_cursor_pos(pte,\n\t\t\t\t\t  (unsigned char) (TEXT_LINE2 + SELECTCODEC_START_ENTRY_POS + 1 + i));\n\t\treturn;\n\t}\n\tswitch (keycode) {\n\tcase KEY_FUNC1:\n\t\tif (pte->size_buff_entry == 1) {\n\t\t\tpte->device->codec_number = pte->buff_entry[0] - 48;\n\t\t} else if (pte->size_buff_entry == 2) {\n\t\t\tpte->device->codec_number =\n\t\t\t\t((pte->buff_entry[0] - 48) * 10) + (pte->buff_entry[1] - 48);\n\t\t}\n\t\tshow_main_page(pte);\n\t\tbreak;\n\tcase KEY_FUNC3:\n\t\tpte->size_buff_entry = 0;\n\t\tsend_text(TEXT_LINE2, TEXT_INVERSE, pte, SELECTCODEC_MSG);\n\t\tsend_blink_cursor(pte);\n\t\tsend_cursor_pos(pte, TEXT_LINE2 + SELECTCODEC_START_ENTRY_POS);\n\t\tbreak;\n\tcase KEY_HANGUP:\n\tcase KEY_FUNC4:\n\t\tshow_main_page(pte);\n\t\tbreak;\n\t}\n\treturn;\n}\n", "bug_type": null, "idx": 581}
{"project": "Asterisk", "target": 0, "func": "static void cc_generic_monitor_destructor(void *private_data)\n{\n\tstruct generic_monitor_pvt *gen_mon_pvt = private_data;\n\tstruct generic_monitor_instance_list *generic_list;\n\tstruct generic_monitor_instance *generic_instance;\n\tif (!private_data) {\n\t\t\n\t\treturn;\n\t}\n\tast_log_dynamic_level(cc_logger_level, \"Core %d: Destroying generic monitor %s\\n\",\n\t\t\tgen_mon_pvt->core_id, gen_mon_pvt->device_name);\n\tif (!(generic_list = find_generic_monitor_instance_list(gen_mon_pvt->device_name))) {\n\t\t\n\t\tast_free((char *)gen_mon_pvt->device_name);\n\t\tast_free(gen_mon_pvt);\n\t\treturn;\n\t}\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&generic_list->list, generic_instance, next) {\n\t\tif (generic_instance->core_id == gen_mon_pvt->core_id) {\n\t\t\tAST_LIST_REMOVE_CURRENT(next);\n\t\t\tast_free(generic_instance);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\tif (AST_LIST_EMPTY(&generic_list->list)) {\n\t\t\n\t\tao2_t_unlink(generic_monitors, generic_list, \"Generic list is empty. Unlink it from the container\");\n\t} else {\n\t\t\n\t\t\n\t\tif (generic_list->fit_for_recall\n\t\t\t&& cc_generic_is_device_available(generic_list->current_state)) {\n\t\t\tAST_LIST_TRAVERSE(&generic_list->list, generic_instance, next) {\n\t\t\t\tif (!generic_instance->is_suspended && generic_instance->monitoring) {\n\t\t\t\t\tast_cc_monitor_callee_available(generic_instance->core_id, \"Signaling generic monitor \"\n\t\t\t\t\t\t\t\"availability due to other instance's failure.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcc_unref(generic_list, \"Done with generic list in generic monitor destructor\");\n\tast_free((char *)gen_mon_pvt->device_name);\n\tast_free(gen_mon_pvt);\n}\n", "bug_type": null, "idx": 582}
{"project": "Asterisk", "target": 0, "func": "int ast_party_id_presentation(const struct ast_party_id *id)\n{\n\tint number_priority;\n\tint number_value;\n\tint number_screening;\n\tint name_priority;\n\tint name_value;\n\t\n\tif (!id->name.valid) {\n\t\tname_value = AST_PRES_UNAVAILABLE;\n\t\tname_priority = 3;\n\t} else {\n\t\tname_value = id->name.presentation & AST_PRES_RESTRICTION;\n\t\tswitch (name_value) {\n\t\tcase AST_PRES_RESTRICTED:\n\t\t\tname_priority = 0;\n\t\t\tbreak;\n\t\tcase AST_PRES_ALLOWED:\n\t\t\tname_priority = 1;\n\t\t\tbreak;\n\t\tcase AST_PRES_UNAVAILABLE:\n\t\t\tname_priority = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tname_value = AST_PRES_UNAVAILABLE;\n\t\t\tname_priority = 3;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (!id->number.valid) {\n\t\tnumber_screening = AST_PRES_USER_NUMBER_UNSCREENED;\n\t\tnumber_value = AST_PRES_UNAVAILABLE;\n\t\tnumber_priority = 3;\n\t} else {\n\t\tnumber_screening = id->number.presentation & AST_PRES_NUMBER_TYPE;\n\t\tnumber_value = id->number.presentation & AST_PRES_RESTRICTION;\n\t\tswitch (number_value) {\n\t\tcase AST_PRES_RESTRICTED:\n\t\t\tnumber_priority = 0;\n\t\t\tbreak;\n\t\tcase AST_PRES_ALLOWED:\n\t\t\tnumber_priority = 1;\n\t\t\tbreak;\n\t\tcase AST_PRES_UNAVAILABLE:\n\t\t\tnumber_priority = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnumber_screening = AST_PRES_USER_NUMBER_UNSCREENED;\n\t\t\tnumber_value = AST_PRES_UNAVAILABLE;\n\t\t\tnumber_priority = 3;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (name_priority < number_priority) {\n\t\tnumber_value = name_value;\n\t}\n\tif (number_value == AST_PRES_UNAVAILABLE) {\n\t\treturn AST_PRES_NUMBER_NOT_AVAILABLE;\n\t}\n\treturn number_value | number_screening;\n}\n", "bug_type": null, "idx": 583}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *grab_x11_close(void *desc)\n{\n\tstruct grab_x11_desc *v = desc;\n\tif (v->dpy)\n\t\tXCloseDisplay(v->dpy);\n\tv->dpy = NULL;\n\tv->image = NULL;\n\tast_free(v);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 584}
{"project": "Asterisk", "target": 0, "func": "void ast_phoneprov_provider_unregister(char *provider_name)\n{\n\tif (!providers) {\n\t\treturn;\n\t}\n\tast_phoneprov_delete_extensions(provider_name);\n\tao2_find(providers, provider_name, OBJ_SEARCH_KEY | OBJ_NODATA | OBJ_UNLINK);\n}\n", "bug_type": null, "idx": 585}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void rb_delete_node(struct ao2_container_rbtree *self, struct rbtree_node *doomed)\n{\n\tstruct rbtree_node *child;\n\tint need_fixup;\n\tif (doomed->left && doomed->right) {\n\t\tstruct rbtree_node *next;\n\t\tint is_red;\n\t\t\n\t\tAO2_DEVMODE_STAT(++self->stats.delete_children[2]);\n\t\tnext = rb_node_most_left(doomed->right);\n\t\tSWAP(doomed->parent, next->parent);\n\t\tSWAP(doomed->left, next->left);\n\t\tSWAP(doomed->right, next->right);\n\t\tis_red = doomed->is_red;\n\t\tdoomed->is_red = next->is_red;\n\t\tnext->is_red = is_red;\n\t\t\n\t\tif (!next->parent) {\n\t\t\t\n\t\t\tself->root = next;\n\t\t} else if (next->parent->left == doomed) {\n\t\t\t\n\t\t\tnext->parent->left = next;\n\t\t} else {\n\t\t\t\n\t\t\tnext->parent->right = next;\n\t\t}\n\t\tnext->left->parent = next;\n\t\tif (next->right == next) {\n\t\t\t\n\t\t\tnext->right = doomed;\n\t\t\tdoomed->parent = next;\n\t\t} else {\n\t\t\tnext->right->parent = next;\n\t\t\tdoomed->parent->left = doomed;\n\t\t}\n\t\t\n\t\tast_assert(doomed->left == NULL);\n\t\t\n\t\tchild = doomed->right;\n\t} else {\n\t\t\n\t\tchild = doomed->left;\n\t\tif (!child) {\n\t\t\tchild = doomed->right;\n\t\t}\n\t}\n\tif (child) {\n\t\tAO2_DEVMODE_STAT(++self->stats.delete_children[1]);\n\t} else {\n\t\tAO2_DEVMODE_STAT(++self->stats.delete_children[0]);\n\t}\n\tneed_fixup = (!doomed->is_red && !self->common.destroying);\n\tif (need_fixup && !child) {\n\t\t\n\t\trb_delete_fixup(self, doomed);\n\t\tast_assert(doomed->left == NULL);\n\t\tast_assert(doomed->right == NULL);\n\t\tast_assert(!doomed->is_red);\n\t}\n\t\n\tif (!doomed->parent) {\n\t\t\n\t\tself->root = child;\n\t} else if (doomed->parent->left == doomed) {\n\t\t\n\t\tdoomed->parent->left = child;\n\t} else {\n\t\t\n\t\tdoomed->parent->right = child;\n\t}\n\tif (child) {\n\t\tchild->parent = doomed->parent;\n\t\tif (need_fixup) {\n\t\t\trb_delete_fixup(self, child);\n\t\t}\n\t}\n\tAO2_DEVMODE_STAT(--self->common.nodes);\n}\n", "bug_type": null, "idx": 586}
{"project": "Asterisk", "target": 0, "func": "protected int\ntty_noquotemode(EditLine *el)\n{\n\tif (el->el_tty.t_mode != QU_IO)\n\t\treturn (0);\n\tif (tty_setty(el, &el->el_tty.t_ed) == -1) {\n#ifdef DEBUG_TTY\n\t\t(void) fprintf(el->el_errfile, \"QuoteModeOff: tty_setty: %s\\n\",\n\t\t    strerror(errno));\n#endif \n\t\treturn (-1);\n\t}\n\tel->el_tty.t_mode = ED_IO;\n\treturn (0);\n}\n", "bug_type": null, "idx": 587}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void _urg_handler(int num)\n{\n\treturn;\n}\n", "bug_type": null, "idx": 588}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_bridge *get_dial_bridge(void)\n{\n\tstruct ast_bridge *ret_bridge = NULL;\n\tast_mutex_lock(&dial_bridge_lock);\n\tif (shutting_down) {\n\t\tgoto end;\n\t}\n\tif (dial_bridge) {\n\t\tret_bridge = ao2_bump(dial_bridge);\n\t\tgoto end;\n\t}\n\tdial_bridge = stasis_app_bridge_create_invisible(\"holding\", \"dial_bridge\", NULL);\n\tif (!dial_bridge) {\n\t\tgoto end;\n\t}\n\tret_bridge = ao2_bump(dial_bridge);\nend:\n\tast_mutex_unlock(&dial_bridge_lock);\n\treturn ret_bridge;\n}\n", "bug_type": null, "idx": 589}
{"project": "Asterisk", "target": 0, "func": "*/\nstruct ast_key * AST_OPTIONAL_API_NAME(ast_key_get)(const char *kname, int ktype)\n{\n\tstruct ast_key *key;\n\tAST_RWLIST_RDLOCK(&keys);\n\tAST_RWLIST_TRAVERSE(&keys, key, list) {\n\t\tif (!strcmp(kname, key->name) &&\n\t\t    (ktype == key->ktype)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&keys);\n\treturn key;\n}\n", "bug_type": null, "idx": 590}
{"project": "Asterisk", "target": 0, "func": "static void *lock_broker(void *unused)\n{\n\tstruct lock_frame *frame;\n\tstruct timespec forever = { 1000000, 0 };\n\tfor (;;) {\n\t\tint found_requester = 0;\n\t\t\n\t\tpthread_testcancel();\n\t\tAST_LIST_LOCK(&locklist);\n\t\tAST_LIST_TRAVERSE(&locklist, frame, entries) {\n\t\t\tif (ao2_container_count(frame->requesters)) {\n\t\t\t\tfound_requester++;\n\t\t\t\tast_mutex_lock(&frame->mutex);\n\t\t\t\tif (!frame->owner) {\n\t\t\t\t\tast_cond_signal(&frame->cond);\n\t\t\t\t}\n\t\t\t\tast_mutex_unlock(&frame->mutex);\n\t\t\t}\n\t\t}\n\t\tAST_LIST_UNLOCK(&locklist);\n\t\tpthread_testcancel();\n\t\t\n\t\tif (!found_requester) {\n\t\t\tnanosleep(&forever, NULL);\n\t\t} else {\n\t\t\tsched_yield();\n\t\t}\n\t}\n\t\n\treturn NULL;\n}\n", "bug_type": null, "idx": 591}
{"project": "Asterisk", "target": 0, "func": "static const char *aoc_billingid_str(enum ast_aoc_billing_id billing_id)\n{\n\tswitch (billing_id) {\n\tcase AST_AOC_BILLING_NORMAL:\n\t\treturn \"Normal\";\n\tcase AST_AOC_BILLING_REVERSE_CHARGE:\n\t\treturn \"Reverse\";\n\tcase AST_AOC_BILLING_CREDIT_CARD:\n\t\treturn \"CreditCard\";\n\tcase AST_AOC_BILLING_CALL_FWD_UNCONDITIONAL:\n\t\treturn \"CallForwardingUnconditional\";\n\tcase AST_AOC_BILLING_CALL_FWD_BUSY:\n\t\treturn \"CallForwardingBusy\";\n\tcase AST_AOC_BILLING_CALL_FWD_NO_REPLY:\n\t\treturn \"CallForwardingNoReply\";\n\tcase AST_AOC_BILLING_CALL_DEFLECTION:\n\t\treturn \"CallDeflection\";\n\tcase AST_AOC_BILLING_CALL_TRANSFER:\n\t\treturn \"CallTransfer\";\n\tcase AST_AOC_BILLING_NA:\n\t\treturn \"NotAvailable\";\n\tcase AST_AOC_BILLING_NUM_ENTRIES:\n\t\tbreak;\n\t}\n\treturn \"NotAvailable\";\n}\n", "bug_type": null, "idx": 592}
{"project": "Asterisk", "target": 0, "func": "long ast_sched_when(struct ast_sched_context *con,int id)\n{\n\tstruct sched *s;\n\tlong secs = -1;\n\tDEBUG(ast_debug(1, \"ast_sched_when()\\n\"));\n\tast_mutex_lock(&con->lock);\n\ts = sched_find(con, id);\n\tif (s) {\n\t\tstruct timeval now = ast_tvnow();\n\t\tsecs = s->when.tv_sec - now.tv_sec;\n\t}\n\tast_mutex_unlock(&con->lock);\n\treturn secs;\n}\n", "bug_type": null, "idx": 593}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void *misdn_cc_ds_duplicate(void *data)\n{\n\tstruct misdn_cc_caller *cc_caller = data;\n\tao2_ref(cc_caller, +1);\n\treturn cc_caller;\n}\n", "bug_type": null, "idx": 594}
{"project": "Asterisk", "target": 0, "func": "int __ao2_ref(void *user_data, int delta,\n\tconst char *tag, const char *file, int line, const char *func)\n{\n\tstruct astobj2 *obj = __INTERNAL_OBJ_CHECK(user_data, file, line, func);\n\tstruct astobj2_lock *obj_mutex;\n\tstruct astobj2_rwlock *obj_rwlock;\n\tstruct astobj2_lockobj *obj_lockobj;\n\tint current_value;\n\tint ret;\n\tstruct ao2_weakproxy *weakproxy = NULL;\n\tif (obj == NULL) {\n\t\tif (ref_log && user_data) {\n\t\t\tfprintf(ref_log, \"%p,%d,%d,%s,%d,%s,**invalid**,%s\\n\",\n\t\t\t\tuser_data, delta, ast_get_tid(), file, line, func, tag ?: \"\");\n\t\t\tfflush(ref_log);\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tif (delta == 0) {\n\t\treturn obj->priv_data.ref_counter;\n\t}\n\tif (delta < 0 && obj->priv_data.magic == AO2_MAGIC && (weakproxy = obj->priv_data.weakptr)) {\n\t\tao2_lock(weakproxy);\n\t}\n\t\n\tret = ast_atomic_fetchadd_int(&obj->priv_data.ref_counter, delta);\n\tcurrent_value = ret + delta;\n#ifdef AO2_DEBUG\n\tast_atomic_fetchadd_int(&ao2.total_refs, delta);\n#endif\n\tif (weakproxy) {\n\t\tstruct ao2_weakproxy cbs;\n\t\tif (current_value == 1) {\n\t\t\t\n\t\t\tstruct astobj2 *internal_weakproxy;\n\t\t\tinternal_weakproxy = INTERNAL_OBJ_CHECK(weakproxy);\n\t\t\t\n\t\t\tinternal_weakproxy->priv_data.weakptr = NULL;\n\t\t\tobj->priv_data.weakptr = NULL;\n\t\t\t\n\t\t\tcbs.destroyed_cb = weakproxy->destroyed_cb;\n\t\t\tAST_LIST_HEAD_INIT_NOLOCK(&weakproxy->destroyed_cb);\n\t\t\t\n\t\t\tao2_ref(user_data, -1);\n\t\t}\n\t\tao2_unlock(weakproxy);\n\t\tif (current_value == 1) {\n\t\t\tstruct ao2_weakproxy_notification *destroyed_cb;\n\t\t\t\n\t\t\twhile ((destroyed_cb = AST_LIST_REMOVE_HEAD(&cbs.destroyed_cb, list))) {\n\t\t\t\tdestroyed_cb->cb(weakproxy, destroyed_cb->data);\n\t\t\t\tast_free(destroyed_cb);\n\t\t\t}\n\t\t\tao2_ref(weakproxy, -1);\n\t\t}\n\t}\n\tif (0 < current_value) {\n\t\t\n#define EXCESSIVE_REF_COUNT\t\t100000\n\t\tif (EXCESSIVE_REF_COUNT <= current_value && ret < EXCESSIVE_REF_COUNT) {\n\t\t\tchar excessive_ref_buf[100];\n\t\t\t\n\t\t\tsnprintf(excessive_ref_buf, sizeof(excessive_ref_buf),\n\t\t\t\t\"Excessive refcount %d reached on ao2 object %p\",\n\t\t\t\tcurrent_value, user_data);\n\t\t\tast_log(__LOG_ERROR, file, line, func, \"%s\\n\", excessive_ref_buf);\n\t\t\t__ast_assert_failed(0, excessive_ref_buf, file, line, func);\n\t\t}\n\t\tif (ref_log && tag) {\n\t\t\tfprintf(ref_log, \"%p,%s%d,%d,%s,%d,%s,%d,%s\\n\", user_data,\n\t\t\t\t(delta < 0 ? \"\" : \"+\"), delta, ast_get_tid(),\n\t\t\t\tfile, line, func, ret, tag);\n\t\t\tfflush(ref_log);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tif (current_value < 0) {\n\t\tast_log(__LOG_ERROR, file, line, func,\n\t\t\t\"Invalid refcount %d on ao2 object %p\\n\", current_value, user_data);\n\t\tif (ref_log) {\n\t\t\t\n\t\t\tfprintf(ref_log, \"%p,%d,%d,%s,%d,%s,**invalid**,%s\\n\",\n\t\t\t\tuser_data, delta, ast_get_tid(), file, line, func, tag ?: \"\");\n\t\t\tfflush(ref_log);\n\t\t}\n\t\tast_assert(0);\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tif (obj->priv_data.destructor_fn != NULL) {\n\t\tobj->priv_data.destructor_fn(user_data);\n\t}\n#ifdef AO2_DEBUG\n\tast_atomic_fetchadd_int(&ao2.total_mem, - obj->priv_data.data_size);\n\tast_atomic_fetchadd_int(&ao2.total_objects, -1);\n#endif\n\t\n\tobj->priv_data.magic = 0;\n\tswitch (obj->priv_data.options & AO2_ALLOC_OPT_LOCK_MASK) {\n\tcase AO2_ALLOC_OPT_LOCK_MUTEX:\n\t\tobj_mutex = INTERNAL_OBJ_MUTEX(user_data);\n\t\tast_mutex_destroy(&obj_mutex->mutex.lock);\n\t\tast_free(obj_mutex);\n\t\tbreak;\n\tcase AO2_ALLOC_OPT_LOCK_RWLOCK:\n\t\tobj_rwlock = INTERNAL_OBJ_RWLOCK(user_data);\n\t\tast_rwlock_destroy(&obj_rwlock->rwlock.lock);\n\t\tast_free(obj_rwlock);\n\t\tbreak;\n\tcase AO2_ALLOC_OPT_LOCK_NOLOCK:\n\t\tast_free(obj);\n\t\tbreak;\n\tcase AO2_ALLOC_OPT_LOCK_OBJ:\n\t\tobj_lockobj = INTERNAL_OBJ_LOCKOBJ(user_data);\n\t\tao2_t_ref(obj_lockobj->lockobj.lock, -1, \"release lockobj\");\n\t\tast_free(obj_lockobj);\n\t\tbreak;\n\tdefault:\n\t\tast_log(__LOG_ERROR, file, line, func,\n\t\t\t\"Invalid lock option on ao2 object %p\\n\", user_data);\n\t\tbreak;\n\t}\n\tif (ref_log && tag) {\n\t\tfprintf(ref_log, \"%p,%d,%d,%s,%d,%s,**destructor**,%s\\n\",\n\t\t\tuser_data, delta, ast_get_tid(), file, line, func, tag);\n\t\tfflush(ref_log);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 595}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/app.h\"\nstatic int shell_helper(struct ast_channel *chan, const char *cmd, char *data,\n\t\t                         char *buf, size_t len)\n{\n\tint res = 0;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"Missing Argument!  Example:  Set(foo=${SHELL(echo \\\"bar\\\")})\\n\");\n\t\treturn -1;\n\t}\n\tif (chan) {\n\t\tast_autoservice_start(chan);\n\t}\n\tif (len >= 1) {\n\t\tFILE *ptr;\n\t\tchar plbuff[4096];\n\t\tptr = popen(data, \"r\");\n\t\tif (ptr) {\n\t\t\twhile (fgets(plbuff, sizeof(plbuff), ptr)) {\n\t\t\t\tstrncat(buf, plbuff, len - strlen(buf) - 1);\n\t\t\t}\n\t\t\tpclose(ptr);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Failed to execute shell command '%s'\\n\", data);\n\t\t\tres = -1;\n\t\t}\n\t}\n\tif (chan) {\n\t\tast_autoservice_stop(chan);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 596}
{"project": "Asterisk", "target": 0, "func": "static int release_cr(struct misdn_stack *stack, mISDNuser_head_t *hh)\n{\n\tstruct misdn_bchannel *bc=find_bc_by_l3id(stack, hh->dinfo);\n\tstruct misdn_bchannel dummybc;\n\tiframe_t frm; \n\tfrm.dinfo = hh->dinfo;\n\tfrm.addr=stack->upper_id | FLG_MSG_DOWN;\n\tfrm.prim = CC_RELEASE_CR|INDICATION;\n\tcb_log(4, stack->port, \" --> CC_RELEASE_CR: Faking Release_cr for %x l3id:%x\\n\",frm.addr, frm.dinfo);\n\t\n\tif (!bc) {\n\t\tcb_log(4, stack->port, \" --> Didn't find BC so temporarily creating dummy BC (l3id:%x) on this port.\\n\", hh->dinfo);\n\t\tmisdn_make_dummy(&dummybc, stack->port, hh->dinfo, stack->nt, 0);\n\t\tbc=&dummybc;\n\t}\n\tif ((bc->l3_id & 0xff00) == 0xff00) {\n\t\tcb_log(4, stack->port, \" --> Removing Process Id:%x on this port.\\n\", bc->l3_id & 0xff);\n\t\tstack->procids[bc->l3_id & 0xff] = 0;\n\t}\n\tif (handle_cr(stack, &frm)<0) {\n\t}\n\treturn 0 ;\n}\n", "bug_type": null, "idx": 597}
{"project": "Asterisk", "target": 0, "func": " *  \\note Called with sla.lock locked */\nstatic int sla_process_timers(struct timespec *ts)\n{\n\tunsigned int timeout = UINT_MAX;\n\tstruct timeval wait;\n\tunsigned int change_made = 0;\n\t\n\tif (sla_calc_trunk_timeouts(&timeout))\n\t\tchange_made = 1;\n\t\n\tif (sla_calc_station_timeouts(&timeout))\n\t\tchange_made = 1;\n\t\n\tif (sla_calc_station_delays(&timeout))\n\t\tchange_made = 1;\n\t\n\tif (change_made)\n\t\tsla_queue_event_nolock(SLA_EVENT_RINGING_TRUNK);\n\t\n\tif (timeout == UINT_MAX)\n\t\treturn 0;\n\tif (ts) {\n\t\twait = ast_tvadd(ast_tvnow(), ast_samp2tv(timeout, 1000));\n\t\tts->tv_sec = wait.tv_sec;\n\t\tts->tv_nsec = wait.tv_usec * 1000;\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 598}
{"project": "Asterisk", "target": 0, "func": "static int history_put(jitterbuf *jb, long ts, long now, long ms, long delay)\n{\n\tlong kicked;\n\t\n\tif (ts <= 0)\n\t\treturn 0;\n\tkicked = jb->history[jb->hist_ptr % JB_HISTORY_SZ];\n\tjb->history[(jb->hist_ptr++) % JB_HISTORY_SZ] = delay;\n\t\n\tif (!jb->hist_maxbuf_valid)\n\t\treturn 0;\n\t\n\tif (jb->hist_ptr < JB_HISTORY_SZ)\n\t\tgoto invalidate;\n\t\n\tif (delay < jb->hist_minbuf[JB_HISTORY_MAXBUF_SZ-1])\n\t\tgoto invalidate;\n\t\n\tif (delay > jb->hist_maxbuf[JB_HISTORY_MAXBUF_SZ-1])\n\t\tgoto invalidate;\n\t\n\tif (kicked <= jb->hist_minbuf[JB_HISTORY_MAXBUF_SZ-1])\n\t\tgoto invalidate;\n\tif (kicked >= jb->hist_maxbuf[JB_HISTORY_MAXBUF_SZ-1])\n\t\tgoto invalidate;\n\t\n\treturn 0;\n\t\ninvalidate:\n\tjb->hist_maxbuf_valid = 0;\n\treturn 0;\n}\n", "bug_type": null, "idx": 599}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void g726_init_state(struct g726_state *state_ptr)\n{\n\tint\t\tcnta;\n\tstate_ptr->yl = 34816;\n\tstate_ptr->yu = 544;\n\tstate_ptr->dms = 0;\n\tstate_ptr->dml = 0;\n\tstate_ptr->ap = 0;\n\tfor (cnta = 0; cnta < 2; cnta++) {\n\t\tstate_ptr->a[cnta] = 0;\n\t\tstate_ptr->pk[cnta] = 0;\n#ifdef NOT_BLI\n\t\tstate_ptr->sr[cnta] = 1;\n#else\n\t\tstate_ptr->sr[cnta] = 32;\n#endif\n\t}\n\tfor (cnta = 0; cnta < 6; cnta++) {\n\t\tstate_ptr->b[cnta] = 0;\n#ifdef NOT_BLI\n\t\tstate_ptr->dq[cnta] = 1;\n#else\n\t\tstate_ptr->dq[cnta] = 32;\n#endif\n\t}\n\tstate_ptr->td = 0;\n}\n", "bug_type": null, "idx": 600}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void global_destructor(void *obj)\n{\n\tstruct global_config *cfg = obj;\n\tast_string_field_free_memory(cfg);\n}\n", "bug_type": null, "idx": 601}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void *contact_status_alloc(const char *name)\n{\n\tstruct ast_sip_contact_status *status = ast_sorcery_generic_alloc(sizeof(*status), contact_status_destroy);\n\tchar *id = ast_strdupa(name);\n\tchar *aor = id;\n\tchar *aor_separator = NULL;\n\tif (!status) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate ast_sip_contact_status\\n\");\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(status, 256)) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate ast_sip_contact_status stringfields\\n\");\n\t\tao2_cleanup(status);\n\t\treturn NULL;\n\t}\n\t\n\tif ((aor_separator = strstr(id, \";@\")) || (aor_separator = strstr(id, \"@@\"))) {\n\t\t*aor_separator = '\\0';\n\t}\n\tast_assert(aor_separator != NULL);\n\tast_string_field_set(status, aor, aor);\n\tstatus->status = CREATED;\n\treturn status;\n}\n", "bug_type": null, "idx": 602}
{"project": "Asterisk", "target": 0, "func": "\nstatic int jingle_interpret_google_transport(struct jingle_session *session, iks *transport, struct ast_rtp_instance *rtp)\n{\n\tstruct ast_rtp_engine_ice *ice = ast_rtp_instance_get_ice(rtp);\n\tiks *candidate;\n\tif (!ice) {\n\t\tjingle_queue_hangup_with_cause(session, AST_CAUSE_SWITCH_CONGESTION);\n\t\tast_log(LOG_ERROR, \"Received Google transport information on session '%s' but ICE support not available\\n\", session->sid);\n\t\treturn -1;\n\t}\n\t\n\tif ((session->transport != JINGLE_TRANSPORT_GOOGLE_V2) &&\n\t    (session->transport != JINGLE_TRANSPORT_GOOGLE_V1)) {\n\t\t\n\t\tice->stop(rtp);\n\t\tsession->transport = JINGLE_TRANSPORT_GOOGLE_V2;\n\t}\n\tfor (candidate = iks_child(transport); candidate; candidate = iks_next(candidate)) {\n\t\tchar *address = iks_find_attrib(candidate, \"address\"), *port = iks_find_attrib(candidate, \"port\");\n\t\tchar *username = iks_find_attrib(candidate, \"username\"), *name = iks_find_attrib(candidate, \"name\");\n\t\tchar *protocol = iks_find_attrib(candidate, \"protocol\");\n\t\tint real_port;\n\t\tstruct ast_sockaddr target = { { 0, } };\n\t\t\n\t\tchar combined[33] = \"\";\n\t\t\n\t\tif (strcasecmp(iks_name(candidate), \"candidate\") &&\n\t\t    strcasecmp(iks_name(candidate), \"p:candidate\") &&\n\t\t    strcasecmp(iks_name(candidate), \"ses:candidate\")) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (ast_strlen_zero(address) || ast_strlen_zero(port) || ast_strlen_zero(username) ||\n\t\t    ast_strlen_zero(name)) {\n\t\t\tjingle_queue_hangup_with_cause(session, AST_CAUSE_PROTOCOL_ERROR);\n\t\t\tast_log(LOG_ERROR, \"Incomplete Google candidate received on session '%s'\\n\", session->sid);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (!ast_strlen_zero(protocol) && strcasecmp(protocol, \"udp\")) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (strcasecmp(name, \"rtp\") && strcasecmp(name, \"video_rtp\")) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (sscanf(port, \"%30d\", &real_port) != 1) {\n\t\t\tjingle_queue_hangup_with_cause(session, AST_CAUSE_PROTOCOL_ERROR);\n\t\t\tast_log(LOG_ERROR, \"Invalid Google candidate port '%s' received on session '%s'\\n\", port, session->sid);\n\t\t\treturn -1;\n\t\t}\n\t\tast_sockaddr_parse(&target, address, PARSE_PORT_FORBID);\n\t\tast_sockaddr_set_port(&target, real_port);\n\t\t\n\t\tsnprintf(combined, sizeof(combined), \"%s%s\", username, ice->get_ufrag(rtp));\n\t\t\n\t\tast_rtp_instance_stun_request(rtp, &target, combined);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 603}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void test_vm_api_destroy_mailbox_voicemails(const char *mailbox, struct ast_vm_mailbox_snapshot *mailbox_snapshot)\n{\n\tstruct ast_vm_msg_snapshot *msg;\n\tint i;\n\tfor (i = 0; i < 12; ++i) {\n\t\tAST_LIST_TRAVERSE(&mailbox_snapshot->snapshots[i], msg, msg) {\n\t\t\tast_string_field_set(msg, exten, mailbox);\n\t\t\ttest_vm_api_remove_voicemail(msg);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 604}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 605}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225ScnConnectionType (OOCTXT* pctxt, H225ScnConnectionType* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 7);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 6);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            \n            break;\n         \n         case 2:\n            \n            break;\n         \n         case 3:\n            \n            break;\n         \n         case 4:\n            \n            break;\n         \n         case 5:\n            \n            break;\n         \n         case 6:\n            \n            break;\n         \n         case 7:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 8);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 606}
{"project": "Asterisk", "target": 0, "func": "static int sql_db_init(const char *dbname)\n{\n\tif (db_open(dbname) || db_create_astdb() || init_statements()) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 607}
{"project": "Asterisk", "target": 0, "func": "void stasis_app_set_debug_by_name(const char *app_name, int debug)\n{\n\tstruct stasis_app *app = stasis_app_get_by_name(app_name);\n\tif (!app) {\n\t\treturn;\n\t}\n\tapp->debug = debug;\n\tao2_cleanup(app);\n}\n", "bug_type": null, "idx": 608}
{"project": "Asterisk", "target": 0, "func": "static int acf_transaction_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(property);\n\t\tAST_APP_ARG(opt);\n\t);\n\tstruct odbc_txn_frame *tx;\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (strcasecmp(args.property, \"transaction\") == 0) {\n\t\tif ((tx = find_transaction(chan, NULL, 1))) {\n\t\t\tast_copy_string(buf, tx->name, len);\n\t\t\treturn 0;\n\t\t}\n\t} else if (strcasecmp(args.property, \"isolation\") == 0) {\n\t\tif (!ast_strlen_zero(args.opt)) {\n\t\t\ttx = find_transaction(chan, args.opt, 0);\n\t\t} else {\n\t\t\ttx = find_transaction(chan, NULL, 1);\n\t\t}\n\t\tif (tx) {\n\t\t\tast_copy_string(buf, ast_odbc_isolation2text(tx->isolation), len);\n\t\t\treturn 0;\n\t\t}\n\t} else if (strcasecmp(args.property, \"forcecommit\") == 0) {\n\t\tif (!ast_strlen_zero(args.opt)) {\n\t\t\ttx = find_transaction(chan, args.opt, 0);\n\t\t} else {\n\t\t\ttx = find_transaction(chan, NULL, 1);\n\t\t}\n\t\tif (tx) {\n\t\t\tast_copy_string(buf, tx->forcecommit ? \"1\" : \"0\", len);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 609}
{"project": "Asterisk", "target": 0, "func": "struct ast_exten *ast_walk_extension_priorities(struct ast_exten *exten,\n\tstruct ast_exten *priority)\n{\n\treturn priority ? priority->peer : exten;\n}\n", "bug_type": null, "idx": 610}
{"project": "Asterisk", "target": 0, "func": "static void key_select_extension(struct unistimsession *pte, char keycode)\n{\n\tif (keycode == KEY_FUNC2) {\n\t\tif (pte->size_buff_entry <= 1) {\n\t\t\tkeycode = KEY_FUNC3;\n\t\t} else {\n\t\t\tpte->size_buff_entry -= 2;\n\t\t\tkeycode = pte->buff_entry[pte->size_buff_entry] + 0x10;\n\t\t}\n\t}\n\tif ((keycode >= KEY_0) && (keycode <= KEY_9)) {\n\t\tchar tmpbuf[] = SELECTEXTENSION_MSG;\n\t\tint i = 0;\n\t\tif (pte->size_buff_entry >= SELECTEXTENSION_MAX_LENGTH) {\n\t\t\treturn;\n\t\t}\n\t\twhile (i < pte->size_buff_entry) {\n\t\t\ttmpbuf[i + SELECTEXTENSION_START_ENTRY_POS] = pte->buff_entry[i];\n\t\t\ti++;\n\t\t}\n\t\ttmpbuf[i + SELECTEXTENSION_START_ENTRY_POS] = keycode - 0x10;\n\t\tpte->buff_entry[i] = keycode - 0x10;\n\t\tpte->size_buff_entry++;\n\t\tsend_text(TEXT_LINE2, TEXT_NORMAL, pte, tmpbuf);\n\t\tsend_blink_cursor(pte);\n\t\tsend_cursor_pos(pte, (unsigned char) (TEXT_LINE2 + SELECTEXTENSION_START_ENTRY_POS + 1 + i));\n\t\treturn;\n\t}\n\tswitch (keycode) {\n\tcase KEY_FUNC1:\n\t\tif (pte->size_buff_entry < 1) {\n\t\t\treturn;\n\t\t}\n\t\tif (autoprovisioning == AUTOPROVISIONING_TN) {\n\t\t\tstruct unistim_device *d;\n\t\t\t\n\t\t\tast_mutex_lock(&devicelock);\n\t\t\td = devices;\n\t\t\tpte->buff_entry[pte->size_buff_entry] = '\\0';\n\t\t\twhile (d) {\n\t\t\t\tif (d->id[0] == 'T') {  \n\t\t\t\t\t\n\t\t\t\t\tif (!strcmp((d->id) + 1, pte->buff_entry)) {\n\t\t\t\t\t\tpte->device = d;\n\t\t\t\t\t\td->session = pte;\n\t\t\t\t\t\td->codec_number = DEFAULT_CODEC;\n\t\t\t\t\t\td->missed_call = 0;\n\t\t\t\t\t\td->receiver_state = STATE_ONHOOK;\n\t\t\t\t\t\tstrcpy(d->id, pte->macaddr);\n\t\t\t\t\t\tpte->device->extension_number[0] = 'T';\n\t\t\t\t\t\tpte->device->extension = EXTENSION_TN;\n\t\t\t\t\t\tast_copy_string((pte->device->extension_number) + 1,\n\t\t\t\t\t\t\t\t\t\tpte->buff_entry, pte->size_buff_entry + 1);\n\t\t\t\t\t\tast_mutex_unlock(&devicelock);\n\t\t\t\t\t\tshow_main_page(pte);\n\t\t\t\t\t\trefresh_all_favorite(pte);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\td = d->next;\n\t\t\t}\n\t\t\tast_mutex_unlock(&devicelock);\n\t\t\tsend_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext(\"Invalid Terminal Number.\", pte));\n\t\t\tsend_text(TEXT_LINE1, TEXT_NORMAL, pte, ustmtext(\"Please try again :\", pte));\n\t\t\tsend_cursor_pos(pte, (unsigned char) (TEXT_LINE2 + SELECTEXTENSION_START_ENTRY_POS +\n\t\t\t\t\t\t\t\t\t\t   pte->size_buff_entry));\n\t\t\tsend_blink_cursor(pte);\n\t\t} else {\n\t\t\tast_copy_string(pte->device->extension_number, pte->buff_entry,\n\t\t\t\t\t\t\tpte->size_buff_entry + 1);\n\t\t\tif (register_extension(pte)) {\n\t\t\t\tsend_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext(\"Invalid extension.\", pte));\n\t\t\t\tsend_text(TEXT_LINE1, TEXT_NORMAL, pte, ustmtext(\"Please try again :\", pte));\n\t\t\t\tsend_cursor_pos(pte, (unsigned char) (TEXT_LINE2 +\n\t\t\t\t\t\t\t\t\t\t   SELECTEXTENSION_START_ENTRY_POS +\n\t\t\t\t\t\t\t\t\t\t   pte->size_buff_entry));\n\t\t\t\tsend_blink_cursor(pte);\n\t\t\t} else\n\t\t\t\tshow_main_page(pte);\n\t\t}\n\t\tbreak;\n\tcase KEY_FUNC3:\n\t\tpte->size_buff_entry = 0;\n\t\tsend_text(TEXT_LINE2, TEXT_NORMAL, pte, SELECTEXTENSION_MSG);\n\t\tsend_blink_cursor(pte);\n\t\tsend_cursor_pos(pte, TEXT_LINE2 + SELECTEXTENSION_START_ENTRY_POS);\n\t\tbreak;\n\t}\n\treturn;\n}\n", "bug_type": null, "idx": 611}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int misdn_command_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *parse;\n\tunsigned index;\n\tstruct misdn_command_args subcommand;\n\tif (ast_strlen_zero((char *) data)) {\n\t\tast_log(LOG_ERROR, \"%s requires arguments\\n\", misdn_command_name);\n\t\treturn -1;\n\t}\n\tast_debug(1, \"%s(%s)\\n\", misdn_command_name, (char *) data);\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(subcommand, parse);\n\tif (!subcommand.argc || ast_strlen_zero(subcommand.name)) {\n\t\tast_log(LOG_ERROR, \"%s requires a subcommand\\n\", misdn_command_name);\n\t\treturn -1;\n\t}\n\tfor (index = 0; index < ARRAY_LEN(misdn_commands); ++index) {\n\t\tif (strcasecmp(misdn_commands[index].name, subcommand.name) == 0) {\n\t\t\tstrcpy(subcommand.name, misdn_commands[index].name);\n\t\t\tif (misdn_commands[index].misdn_only\n\t\t\t\t&& strcasecmp(ast_channel_tech(chan)->type, misdn_type) != 0) {\n\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\"%s(%s) only makes sense with %s channels!\\n\",\n\t\t\t\t\tmisdn_command_name, subcommand.name, misdn_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn misdn_commands[index].func(chan, &subcommand);\n\t\t}\n\t}\n\tast_log(LOG_WARNING, \"%s(%s) subcommand is unknown\\n\", misdn_command_name,\n\t\tsubcommand.name);\n\treturn -1;\n}\n", "bug_type": null, "idx": 612}
{"project": "Asterisk", "target": 0, "func": "int messaging_app_subscribe_endpoint(const char *app_name, struct ast_endpoint *endpoint, message_received_cb callback, void *pvt)\n{\n\tRAII_VAR(struct message_subscription *, sub, NULL, ao2_cleanup);\n\tstruct application_tuple *tuple;\n\tsub = get_or_create_subscription(endpoint);\n\tif (!sub) {\n\t\treturn -1;\n\t}\n\tao2_lock(sub);\n\tif (is_app_subscribed(sub, app_name)) {\n\t\tao2_unlock(sub);\n\t\treturn 0;\n\t}\n\ttuple = application_tuple_alloc(app_name, callback, pvt);\n\tif (!tuple) {\n\t\tao2_unlock(sub);\n\t\treturn -1;\n\t}\n\tAST_VECTOR_APPEND(&sub->applications, tuple);\n\tao2_unlock(sub);\n\tast_debug(3, \"App '%s' subscribed to messages from endpoint '%s'\\n\", app_name, endpoint ? ast_endpoint_get_id(endpoint) : \"-- ALL --\");\n\tast_test_suite_event_notify(\"StasisMessagingSubscription\", \"SubState: Subscribed\\r\\nAppName: %s\\r\\nToken: %s\\r\\n\",\n\t\tapp_name, endpoint ? ast_endpoint_get_id(endpoint) : \"ALL\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 613}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void xmpp_pubsub_publish_mwi(struct ast_xmpp_client *client, const char *mailbox,\n\tconst char *oldmsgs, const char *newmsgs)\n{\n\tchar eid_str[20];\n\tiks *mailbox_node, *request;\n\trequest = xmpp_pubsub_build_publish_skeleton(client, mailbox, \"message_waiting\",\n\t\tAST_DEVSTATE_CACHABLE);\n\tif (!request) {\n\t\treturn;\n\t}\n\tast_eid_to_str(eid_str, sizeof(eid_str), &ast_eid_default);\n\tmailbox_node = iks_insert(request, \"mailbox\");\n\tiks_insert_attrib(mailbox_node, \"xmlns\", \"http://asterisk.org\");\n\tiks_insert_attrib(mailbox_node, \"eid\", eid_str);\n\tiks_insert_cdata(iks_insert(mailbox_node, \"NEWMSGS\"), newmsgs, strlen(newmsgs));\n\tiks_insert_cdata(iks_insert(mailbox_node, \"OLDMSGS\"), oldmsgs, strlen(oldmsgs));\n\tast_xmpp_client_send(client, iks_root(request));\n\tiks_delete(request);\n}\n", "bug_type": null, "idx": 614}
{"project": "Asterisk", "target": 0, "func": "public void\nel_reset(EditLine *el)\n{\n\ttty_cookedmode(el);\n\tch_reset(el);\t\t\n}\n", "bug_type": null, "idx": 615}
{"project": "Asterisk", "target": 0, "func": "static int handle_speechdeactivategrammar(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])\n{\n\tif (argc != 4)\n\t\treturn RESULT_SHOWUSAGE;\n\tif (!agi->speech) {\n\t\tast_agi_send(agi->fd, chan, \"200 result=0\\n\");\n\t\treturn RESULT_SUCCESS;\n\t}\n\tif (ast_speech_grammar_deactivate(agi->speech, argv[3]))\n\t\tast_agi_send(agi->fd, chan, \"200 result=0\\n\");\n\telse\n\t\tast_agi_send(agi->fd, chan, \"200 result=1\\n\");\n\treturn RESULT_SUCCESS;\n}\n", "bug_type": null, "idx": 616}
{"project": "Asterisk", "target": 0, "func": "static char *complete_peer_helper(const char *line, const char *word, int pos, int state, int rpos)\n{\n\tint which=0, len;\n\tchar *ret = NULL;\n\tstruct dundi_peer *p;\n\tchar eid_str[20];\n\tif (pos != rpos)\n\t\treturn NULL;\n\tAST_LIST_LOCK(&peers);\n\tlen = strlen(word);\n\tAST_LIST_TRAVERSE(&peers, p, list) {\n\t\tconst char *s = ast_eid_to_str(eid_str, sizeof(eid_str), &p->eid);\n\t\tif (!strncasecmp(word, s, len) && ++which > state) {\n\t\t\tret = ast_strdup(s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(&peers);\n\treturn ret;\n}\n", "bug_type": null, "idx": 617}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int xfer_response_code2sip(enum ast_transfer_result xfer_code)\n{\n\tint response;\n\tresponse = 503;\n\tswitch (xfer_code) {\n\tcase AST_BRIDGE_TRANSFER_INVALID:\n\t\tresponse = 400;\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_NOT_PERMITTED:\n\t\tresponse = 403;\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_FAIL:\n\t\tresponse = 500;\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_SUCCESS:\n\t\tresponse = 200;\n\t\tbreak;\n\t}\n\treturn response;\n}\n", "bug_type": null, "idx": 618}
{"project": "Asterisk", "target": 0, "func": "\t} while (0)\nstatic enum ast_test_result_state verify_mock_cdr_record(struct ast_test *test, struct ast_cdr *expected, int record)\n{\n\tstruct ast_cdr *actual = NULL;\n\tstruct test_cdr_entry *cdr_wrapper;\n\tint count = 0;\n\tstruct timeval wait_now = ast_tvnow();\n\tstruct timespec wait_time = { .tv_sec = wait_now.tv_sec + 5, .tv_nsec = wait_now.tv_usec * 1000 };\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\twhile (count < record) {\n\t\tAST_LIST_LOCK(&actual_cdr_entries);\n\t\tif (global_mock_cdr_count < record) {\n\t\t\tast_cond_timedwait(&mock_cdr_cond, &actual_cdr_entries.lock, &wait_time);\n\t\t}\n\t\tcdr_wrapper = AST_LIST_REMOVE_HEAD(&actual_cdr_entries, list);\n\t\tAST_LIST_UNLOCK(&actual_cdr_entries);\n\t\tif (!cdr_wrapper) {\n\t\t\tast_test_status_update(test, \"Unable to find actual CDR record at %d\\n\", count);\n\t\t\treturn AST_TEST_FAIL;\n\t\t}\n\t\tactual = cdr_wrapper->cdr;\n\t\tif (!expected && actual) {\n\t\t\tast_test_status_update(test, \"CDRs recorded where no record expected\\n\");\n\t\t\treturn AST_TEST_FAIL;\n\t\t}\n\t\tast_test_debug(test, \"Verifying expected record %s, %s\\n\",\n\t\t\texpected->channel, S_OR(expected->dstchannel, \"<none>\"));\n\t\tVERIFY_STRING_FIELD(accountcode, actual, expected);\n\t\tVERIFY_NUMERIC_FIELD(amaflags, actual, expected);\n\t\tVERIFY_STRING_FIELD(channel, actual, expected);\n\t\tVERIFY_STRING_FIELD(clid, actual, expected);\n\t\tVERIFY_STRING_FIELD(dcontext, actual, expected);\n\t\tVERIFY_NUMERIC_FIELD(disposition, actual, expected);\n\t\tVERIFY_STRING_FIELD(dst, actual, expected);\n\t\tVERIFY_STRING_FIELD(dstchannel, actual, expected);\n\t\tVERIFY_STRING_FIELD(lastapp, actual, expected);\n\t\tVERIFY_STRING_FIELD(lastdata, actual, expected);\n\t\tVERIFY_STRING_FIELD(linkedid, actual, expected);\n\t\tVERIFY_STRING_FIELD(peeraccount, actual, expected);\n\t\tVERIFY_STRING_FIELD(src, actual, expected);\n\t\tVERIFY_STRING_FIELD(uniqueid, actual, expected);\n\t\tVERIFY_STRING_FIELD(userfield, actual, expected);\n\t\tVERIFY_TIME_VALUE(start, actual);\n\t\tVERIFY_TIME_VALUE(end, actual);\n\t\t\n\t\tif (expected->billsec) {\n\t\t\tVERIFY_TIME_VALUE(answer, actual);\n\t\t}\n\t\tast_test_debug(test, \"Finished expected record %s, %s\\n\",\n\t\t\t\texpected->channel, S_OR(expected->dstchannel, \"<none>\"));\n\t\texpected = expected->next;\n\t\t++count;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 619}
{"project": "Asterisk", "target": 0, "func": "\nstatic int transport_tls_method_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_transport *transport = obj;\n\tRAII_VAR(struct ast_sip_transport_state *, state, find_or_create_temporary_state(transport), ao2_cleanup);\n\tif (!state) {\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(var->value) || !strcasecmp(var->value, \"default\")) {\n\t\tstate->tls.method = PJSIP_SSL_DEFAULT_METHOD;\n\t} else if (!strcasecmp(var->value, \"unspecified\")) {\n\t\tstate->tls.method = PJSIP_SSL_UNSPECIFIED_METHOD;\n\t} else if (!strcasecmp(var->value, \"tlsv1\")) {\n\t\tstate->tls.method = PJSIP_TLSV1_METHOD;\n\t} else if (!strcasecmp(var->value, \"sslv2\")) {\n\t\tstate->tls.method = PJSIP_SSLV2_METHOD;\n\t} else if (!strcasecmp(var->value, \"sslv3\")) {\n\t\tstate->tls.method = PJSIP_SSLV3_METHOD;\n\t} else if (!strcasecmp(var->value, \"sslv23\")) {\n\t\tstate->tls.method = PJSIP_SSLV23_METHOD;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 620}
{"project": "Asterisk", "target": 0, "func": "#define MEMBER_INFO_LEFT_ADJ 25\nstatic void draw_main_menu(WINDOW *menu, int curopt)\n{\n\tstruct category *cat;\n\tchar buf[64];\n\tint i = 0;\n\twclear(menu);\n\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\twmove(menu, i++, max_x / 2 - MAIN_MENU_LEFT_ADJ);\n\t\tsnprintf(buf, sizeof(buf), \"%s\", strlen_zero(cat->displayname) ? cat->name : cat->displayname);\n\t\twaddstr(menu, buf);\n\t}\n\twmove(menu, curopt, (max_x / 2) - MAIN_MENU_LEFT_ADJ - 5);\n\twaddstr(menu, \"--->\");\n\twmove(menu, curopt, (max_x / 2) - MAIN_MENU_LEFT_ADJ);\n\twrefresh(menu);\n}\n", "bug_type": null, "idx": 621}
{"project": "Asterisk", "target": 0, "func": "static void rtp_glue_data_reset(struct rtp_glue_data *glue)\n{\n\trtp_glue_data_destroy(glue);\n\trtp_glue_data_init(glue);\n}\n", "bug_type": null, "idx": 622}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void tonepair_release(struct ast_channel *chan, void *params)\n{\n\tstruct tonepair_state *ts = params;\n\tif (chan) {\n\t\tast_set_write_format(chan, ts->origwfmt);\n\t}\n\tao2_cleanup(ts->origwfmt);\n\tast_free(ts);\n}\n", "bug_type": null, "idx": 623}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ast_say_number_full_de(struct ast_channel *chan, int num, const char *ints, const char *language, const char *options, int audiofd, int ctrlfd)\n{\n\tint res = 0, t = 0;\n\tint mf = 1;                            \n\tchar fn[256] = \"\";\n\tchar fna[256] = \"\";\n\tif (!num)\n\t\treturn ast_say_digits_full(chan, 0, ints, language, audiofd, ctrlfd);\n\tif (options && (!strncasecmp(options, \"f\", 1)))\n\t\tmf = -1;\n\twhile (!res && num) {\n\t\t\n\t\tif (num < 0) {\n\t\t\tast_copy_string(fn, \"digits/minus\", sizeof(fn));\n\t\t\tif ( num > INT_MIN ) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t} else if (num == 1 && mf == -1) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%dF\", num);\n\t\t\tnum = 0;\n\t\t} else if (num < 20) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num);\n\t\t\tnum = 0;\n\t\t} else if (num < 100) {\n\t\t\tint ones = num % 10;\n\t\t\tif (ones) {\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d-and\", ones);\n\t\t\t\tnum -= ones;\n\t\t\t} else {\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num);\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t} else if (num == 100 && t == 0) {\n\t\t\tast_copy_string(fn, \"digits/hundred\", sizeof(fn));\n\t\t\tnum = 0;\n\t\t} else if (num < 1000) {\n\t\t\tint hundreds = num / 100;\n\t\t\tnum = num % 100;\n\t\t\tif (hundreds == 1) {\n\t\t\t\tast_copy_string(fn, \"digits/1N\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", hundreds);\n\t\t\t}\n\t\t\tast_copy_string(fna, \"digits/hundred\", sizeof(fna));\n\t\t} else if (num == 1000 && t == 0) {\n\t\t\tast_copy_string(fn, \"digits/thousand\", sizeof(fn));\n\t\t\tnum = 0;\n\t\t} else if (num < 1000000) {\n\t\t\tint thousands = num / 1000;\n\t\t\tnum = num % 1000;\n\t\t\tt = 1;\n\t\t\tif (thousands == 1) {\n\t\t\t\tast_copy_string(fn, \"digits/1N\", sizeof(fn));\n\t\t\t\tast_copy_string(fna, \"digits/thousand\", sizeof(fna));\n\t\t\t} else {\n\t\t\t\tres = ast_say_number_full_de(chan, thousands, ints, language, options, audiofd, ctrlfd);\n\t\t\t\tif (res)\n\t\t\t\t\treturn res;\n\t\t\t\tast_copy_string(fn, \"digits/thousand\", sizeof(fn));\n\t\t\t}\n\t\t} else if (num < 1000000000) {\n\t\t\tint millions = num / 1000000;\n\t\t\tnum = num % 1000000;\n\t\t\tt = 1;\n\t\t\tif (millions == 1) {\n\t\t\t\tast_copy_string(fn, \"digits/1F\", sizeof(fn));\n\t\t\t\tast_copy_string(fna, \"digits/million\", sizeof(fna));\n\t\t\t} else {\n\t\t\t\tres = ast_say_number_full_de(chan, millions, ints, language, options, audiofd, ctrlfd);\n\t\t\t\tif (res)\n\t\t\t\t\treturn res;\n\t\t\t\tast_copy_string(fn, \"digits/millions\", sizeof(fn));\n\t\t\t}\n\t\t} else if (num <= INT_MAX) {\n\t\t\tint billions = num / 1000000000;\n\t\t\tnum = num % 1000000000;\n\t\t\tt = 1;\n\t\t\tif (billions == 1) {\n\t\t\t\tast_copy_string(fn, \"digits/1F\", sizeof(fn));\n\t\t\t\tast_copy_string(fna, \"digits/milliard\", sizeof(fna));\n\t\t\t} else {\n\t\t\t\tres = ast_say_number_full_de(chan, billions, ints, language, options, audiofd, ctrlfd);\n\t\t\t\tif (res) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tast_copy_string(fn, \"digits/milliards\", sizeof(fn));\n\t\t\t}\n\t\t} else {\n\t\t\tast_debug(1, \"Number '%d' is too big for me\\n\", num);\n\t\t\tres = -1;\n\t\t}\n\t\tif (!res) {\n\t\t\tif (!ast_streamfile(chan, fn, language)) {\n\t\t\t\tif ((audiofd > -1) && (ctrlfd > -1))\n\t\t\t\t\tres = ast_waitstream_full(chan, ints, audiofd, ctrlfd);\n\t\t\t\telse\n\t\t\t\t\tres = ast_waitstream(chan, ints);\n\t\t\t}\n\t\t\tast_stopstream(chan);\n\t\t\tif (!res) {\n\t\t\t\tif (strlen(fna) != 0 && !ast_streamfile(chan, fna, language)) {\n\t\t\t\t\tif ((audiofd > -1) && (ctrlfd > -1))\n\t\t\t\t\t\tres = ast_waitstream_full(chan, ints, audiofd, ctrlfd);\n\t\t\t\t\telse\n\t\t\t\t\t\tres = ast_waitstream(chan, ints);\n\t\t\t\t}\n\t\t\t\tast_stopstream(chan);\n\t\t\t\tstrcpy(fna, \"\");\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 624}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(test_cdr_fork_cdr)\n{\n\tRAII_VAR(struct ast_channel *, chan, NULL, safe_channel_release);\n\tRAII_VAR(struct ast_cdr_config *, config, ao2_alloc(sizeof(*config), NULL),\n\t\t\tao2_cleanup);\n\tchar varbuffer[128];\n\tchar fork_varbuffer[128];\n\tchar answer_time[128];\n\tchar fork_answer_time[128];\n\tchar start_time[128];\n\tchar fork_start_time[128];\n\tstruct ast_flags fork_options = { 0, };\n\tstruct timespec to_sleep = {1, 10000};\n\tstruct ast_party_caller caller = ALICE_CALLERID;\n\tstruct ast_cdr original = {\n\t\t.clid = \"\\\"Alice\\\" <100>\",\n\t\t.src = \"100\",\n\t\t.dst = \"100\",\n\t\t.dcontext = \"default\",\n\t\t.channel = CHANNEL_TECH_NAME \"/Alice\",\n\t\t.amaflags = AST_AMA_DOCUMENTATION,\n\t\t.disposition = AST_CDR_ANSWERED,\n\t\t.accountcode = \"100\",\n\t};\n\tstruct ast_cdr fork_expected_one = {\n\t\t.clid = \"\\\"Alice\\\" <100>\",\n\t\t.src = \"100\",\n\t\t.dst = \"100\",\n\t\t.dcontext = \"default\",\n\t\t.channel = CHANNEL_TECH_NAME \"/Alice\",\n\t\t.amaflags = AST_AMA_DOCUMENTATION,\n\t\t.disposition = AST_CDR_ANSWERED,\n\t\t.accountcode = \"100\",\n\t};\n\tstruct ast_cdr fork_expected_two = {\n\t\t.clid = \"\\\"Alice\\\" <100>\",\n\t\t.src = \"100\",\n\t\t.dst = \"100\",\n\t\t.dcontext = \"default\",\n\t\t.channel = CHANNEL_TECH_NAME \"/Alice\",\n\t\t.amaflags = AST_AMA_DOCUMENTATION,\n\t\t.disposition = AST_CDR_ANSWERED,\n\t\t.accountcode = \"100\",\n\t};\n\tenum ast_test_result_state result = AST_TEST_NOT_RUN;\n\tstruct ast_cdr *expected = &original;\n\toriginal.next = &fork_expected_one;\n\tfork_expected_one.next = &fork_expected_two;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = __func__;\n\t\tinfo->category = TEST_CATEGORY;\n\t\tinfo->summary = \"Test field access CDRs\";\n\t\tinfo->description =\n\t\t\t\"This tests setting/retrieving data on CDR records.\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tSWAP_CONFIG(config, debug_cdr_config);\n\tCREATE_ALICE_CHANNEL(chan, &caller, &original);\n\tast_copy_string(fork_expected_one.uniqueid, ast_channel_uniqueid(chan), sizeof(fork_expected_one.uniqueid));\n\tast_copy_string(fork_expected_one.linkedid, ast_channel_linkedid(chan), sizeof(fork_expected_one.linkedid));\n\tast_copy_string(fork_expected_two.uniqueid, ast_channel_uniqueid(chan), sizeof(fork_expected_two.uniqueid));\n\tast_copy_string(fork_expected_two.linkedid, ast_channel_linkedid(chan), sizeof(fork_expected_two.linkedid));\n\tdo_sleep(&to_sleep);\n\t\n\tast_test_validate(test, ast_cdr_setvar(ast_channel_name(chan), \"test_variable\", \"record_1\") == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"test_variable\", varbuffer, sizeof(varbuffer)) == 0);\n\tast_test_validate(test, strcmp(varbuffer, \"record_1\") == 0);\n\tast_copy_string(varbuffer, \"\", sizeof(varbuffer));\n\tast_test_validate(test, ast_cdr_fork(ast_channel_name(chan), &fork_options) == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"test_variable\", fork_varbuffer, sizeof(fork_varbuffer)) == 0);\n\tast_test_validate(test, strcmp(varbuffer, \"record_1\") != 0);\n\t\n\tast_set_flag(&fork_options, AST_CDR_FLAG_FINALIZE);\n\tast_test_validate(test, ast_cdr_fork(ast_channel_name(chan), &fork_options) == 0);\n\t\n\tast_channel_lock(chan);\n\tast_setstate(chan, AST_STATE_UP);\n\tast_channel_unlock(chan);\n\tdo_sleep(&to_sleep);\n\tast_test_validate(test, ast_cdr_setvar(ast_channel_name(chan), \"test_variable\", \"record_2\") == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"test_variable\", varbuffer, sizeof(varbuffer)) == 0);\n\tast_test_validate(test, strcmp(varbuffer, \"record_2\") == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"answer\", answer_time, sizeof(answer_time)) == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"start\", start_time, sizeof(start_time)) == 0);\n\tast_set_flag(&fork_options, AST_CDR_FLAG_FINALIZE);\n\tast_set_flag(&fork_options, AST_CDR_FLAG_KEEP_VARS);\n\tast_set_flag(&fork_options, AST_CDR_FLAG_SET_ANSWER);\n\tast_test_validate(test, ast_cdr_fork(ast_channel_name(chan), &fork_options) == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"answer\", fork_answer_time, sizeof(fork_answer_time)) == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"start\", fork_start_time, sizeof(fork_start_time)) == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"test_variable\", fork_varbuffer, sizeof(fork_varbuffer)) == 0);\n\tast_test_validate(test, strcmp(fork_varbuffer, varbuffer) == 0);\n\tast_test_validate(test, strcmp(fork_start_time, start_time) == 0);\n\tast_test_validate(test, strcmp(fork_answer_time, answer_time) != 0);\n\tast_clear_flag(&fork_options, AST_CDR_FLAG_SET_ANSWER);\n\tast_set_flag(&fork_options, AST_CDR_FLAG_RESET);\n\tast_test_validate(test, ast_cdr_fork(ast_channel_name(chan), &fork_options) == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"answer\", fork_answer_time, sizeof(fork_answer_time)) == 0);\n\tast_test_validate(test, ast_cdr_getvar(ast_channel_name(chan), \"start\", fork_start_time, sizeof(fork_start_time)) == 0);\n\tast_test_validate(test, strcmp(fork_start_time, start_time) != 0);\n\tast_test_validate(test, strcmp(fork_answer_time, answer_time) != 0);\n\tast_channel_hangupcause_set(chan, AST_CAUSE_NORMAL);\n\tast_hangup(chan);\n\tchan = NULL;\n\tresult = verify_mock_cdr_record(test, expected, 3);\n\treturn result;\n}\n", "bug_type": null, "idx": 625}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *ast_bridge_snapshot_to_json(\n\tconst struct ast_bridge_snapshot *snapshot,\n\tconst struct stasis_message_sanitizer *sanitize)\n{\n\tRAII_VAR(struct ast_json *, json_bridge, NULL, ast_json_unref);\n\tstruct ast_json *json_channels;\n\tif (snapshot == NULL) {\n\t\treturn NULL;\n\t}\n\tjson_channels = container_to_json_array(snapshot->channels, sanitize);\n\tif (!json_channels) {\n\t\treturn NULL;\n\t}\n\tjson_bridge = ast_json_pack(\"{s: s, s: s, s: s, s: s, s: s, s: s, s: o, s: s}\",\n\t\t\"id\", snapshot->uniqueid,\n\t\t\"technology\", snapshot->technology,\n\t\t\"bridge_type\", capability2str(snapshot->capabilities),\n\t\t\"bridge_class\", snapshot->subclass,\n\t\t\"creator\", snapshot->creator,\n\t\t\"name\", snapshot->name,\n\t\t\"channels\", json_channels,\n\t\t\"video_mode\", ast_bridge_video_mode_to_string(snapshot->video_mode));\n\tif (!json_bridge) {\n\t\treturn NULL;\n\t}\n\tif (snapshot->video_mode != AST_BRIDGE_VIDEO_MODE_NONE\n\t\t&& !ast_strlen_zero(snapshot->video_source_id)) {\n\t\tast_json_object_set(json_bridge, \"video_source_id\",\n\t\t\tast_json_string_create(snapshot->video_source_id));\n\t}\n\treturn ast_json_ref(json_bridge);\n}\n", "bug_type": null, "idx": 626}
{"project": "Asterisk", "target": 0, "func": "static void evt_gen_session_limit(void)\n{\n\tstruct ast_sockaddr addr_local = { {0,} };\n\tstruct ast_sockaddr addr_remote = { {0,} };\n\tstruct timeval session_tv = ast_tvnow();\n\tstruct ast_security_event_session_limit session_limit = {\n\t\t.common.event_type = AST_SECURITY_EVENT_SESSION_LIMIT,\n\t\t.common.version    = AST_SECURITY_EVENT_SESSION_LIMIT_VERSION,\n\t\t.common.service    = \"TEST\",\n\t\t.common.module     = AST_MODULE,\n\t\t.common.account_id = \"Jenny\",\n\t\t.common.session_id = \"8675309\",\n\t\t.common.session_tv = &session_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr  = &addr_local,\n\t\t\t.transport  = AST_TRANSPORT_TLS,\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr = &addr_remote,\n\t\t\t.transport  = AST_TRANSPORT_TLS,\n\t\t},\n\t};\n\tchar localaddr[53];\n\tchar remoteaddr[53];\n\tast_copy_string(localaddr, \"10.5.4.3:4444\", sizeof(localaddr));\n\tast_copy_string(remoteaddr, \"10.5.4.2:3333\", sizeof(remoteaddr));\n\tast_sockaddr_parse(&addr_local, localaddr, 0);\n\tast_sockaddr_parse(&addr_remote, remoteaddr, 0);\n\tast_security_event_report(AST_SEC_EVT(&session_limit));\n}\n", "bug_type": null, "idx": 627}
{"project": "Asterisk", "target": 0, "func": "static int handle_frame(struct dundi_hdr *h, struct sockaddr_in *sin, int datalen)\n{\n\tstruct dundi_transaction *trans;\n\ttrans = find_transaction(h, sin);\n\tif (!trans) {\n\t\tdundi_reject(h, sin);\n\t\treturn 0;\n\t}\n\t\n\tif (h->oseqno == trans->iseqno) {\n\t\t\n\t\tif (ack_trans(trans, h->iseqno) && ast_test_flag(trans, FLAG_FINAL)) {\n\t\t\t\n\t\t\tdestroy_trans(trans, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tif (h->cmdresp != DUNDI_COMMAND_ACK) {\n\t\t\ttrans->oiseqno = trans->iseqno;\n\t\t\ttrans->iseqno++;\n\t\t\thandle_command_response(trans, h, datalen, 0);\n\t\t}\n\t\tif (trans->aseqno != trans->iseqno) {\n\t\t\tdundi_ack(trans, h->cmdresp & 0x80);\n\t\t\ttrans->aseqno = trans->iseqno;\n\t\t}\n\t\t\n\t\tdestroy_packets(&trans->lasttrans);\n\t\tif (h->cmdresp & 0x80) {\n\t\t\t\n\t\t\tdestroy_trans(trans, 0);\n\t\t}\n\t} else if (h->oseqno == trans->oiseqno) {\n\t\t\n\t\tdundi_ack(trans, 0);\n\t} else {\n\t\t\n\t\tast_debug(1, \"Dropping packet out of window!\\n\");\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 628}
{"project": "Asterisk", "target": 0, "func": "struct ast_aoc_decoded *ast_aoc_decode(struct ast_aoc_encoded *encoded, size_t size, struct ast_channel *chan)\n{\n\tstruct ast_aoc_decoded *decoded;\n\t\n\tif ((size - (sizeof(struct ast_aoc_encoded)) != ntohs(encoded->datalen))) {\n\t\tast_log(LOG_WARNING, \"Corrupted aoc encoded object, can not decode\\n\");\n\t\treturn NULL;\n\t}\n\tif (!(decoded = ast_calloc(1, sizeof(struct ast_aoc_decoded)))) {\n\t\tast_log(LOG_WARNING, \"Failed to create ast_aoc_decoded object \\n\");\n\t\treturn NULL;\n\t}\n\t\n\tif ((encoded->flags & AST_AOC_ENCODED_TYPE_S) == AST_AOC_ENCODED_TYPE_S) {\n\t\tdecoded->msg_type = AST_AOC_S;\n\t} else if (encoded->flags & AST_AOC_ENCODED_TYPE_E) {\n\t\tdecoded->msg_type = AST_AOC_E;\n\t} else if (encoded->flags & AST_AOC_ENCODED_TYPE_D) {\n\t\tdecoded->msg_type = AST_AOC_D;\n\t} else {\n\t\tdecoded->msg_type = AST_AOC_REQUEST;\n\t}\n\tif (decoded->msg_type == AST_AOC_REQUEST) {\n\t\tif (encoded->flags & AST_AOC_ENCODED_REQUEST_S) {\n\t\t\tdecoded->request_flag |= AST_AOC_REQUEST_S;\n\t\t}\n\t\tif (encoded->flags & AST_AOC_ENCODED_REQUEST_D) {\n\t\t\tdecoded->request_flag |= AST_AOC_REQUEST_D;\n\t\t}\n\t\tif (encoded->flags & AST_AOC_ENCODED_REQUEST_E) {\n\t\t\tdecoded->request_flag |= AST_AOC_REQUEST_E;\n\t\t}\n\t} else if ((decoded->msg_type == AST_AOC_D) || (decoded->msg_type == AST_AOC_E)) {\n\t\tif ((encoded->flags & AST_AOC_ENCODED_CHARGE_UNIT) == AST_AOC_ENCODED_CHARGE_UNIT) {\n\t\t\tdecoded->charge_type = AST_AOC_CHARGE_UNIT;\n\t\t} else if ((encoded->flags & AST_AOC_ENCODED_CHARGE_CURRENCY) == AST_AOC_ENCODED_CHARGE_CURRENCY) {\n\t\t\tdecoded->charge_type = AST_AOC_CHARGE_CURRENCY;\n\t\t} else if ((encoded->flags & AST_AOC_ENCODED_CHARGE_FREE) == AST_AOC_ENCODED_CHARGE_FREE) {\n\t\t\tdecoded->charge_type = AST_AOC_CHARGE_FREE;\n\t\t} else {\n\t\t\tdecoded->charge_type = AST_AOC_CHARGE_NA;\n\t\t}\n\t\tif (encoded->flags & AST_AOC_ENCODED_CHARGE_SUBTOTAL) {\n\t\t\tdecoded->total_type = AST_AOC_SUBTOTAL;\n\t\t}\n\t}\n\t\n\taoc_parse_ie(decoded, encoded->data, ntohs(encoded->datalen));\n\tif (aoc_debug_enabled) {\n\t\taoc_display_decoded_debug(decoded, 1, chan);\n\t}\n\treturn decoded;\n}\n", "bug_type": null, "idx": 629}
{"project": "Asterisk", "target": 0, "func": "static int cli_print_body(void *obj, void *arg, int flags)\n{\n\tRAII_VAR(struct ast_str *, str, ast_str_create(MAX_OBJECT_FIELD), ast_free);\n\tstruct ip_identify_match *ident = obj;\n\tstruct ast_sip_cli_context *context = arg;\n\tstruct ast_ha *match;\n\tint indent;\n\tast_assert(context->output_buffer != NULL);\n\tast_str_append(&context->output_buffer, 0, \"%*s:  %s/%s\\n\",\n\t\tCLI_INDENT_TO_SPACES(context->indent_level), \"Identify\",\n\t\tast_sorcery_object_get_id(ident), ident->endpoint_name);\n\tif (context->recurse) {\n\t\tcontext->indent_level++;\n\t\tindent = CLI_INDENT_TO_SPACES(context->indent_level);\n\t\tfor (match = ident->matches; match; match = match->next) {\n\t\t\tconst char *addr = ast_sockaddr_stringify_addr(&match->addr);\n\t\t\tast_str_append(&context->output_buffer, 0, \"%*s: %s%s/%d\\n\",\n\t\t\t\tindent,\n\t\t\t\t\"Match\",\n\t\t\t\tmatch->sense == AST_SENSE_ALLOW ? \"!\" : \"\",\n\t\t\t\taddr, ast_sockaddr_cidr_bits(&match->netmask));\n\t\t}\n\t\tif (!ast_strlen_zero(ident->match_header)) {\n\t\t\tast_str_append(&context->output_buffer, 0, \"%*s: %s\\n\",\n\t\t\t\tindent,\n\t\t\t\t\"Match\",\n\t\t\t\tident->match_header);\n\t\t}\n\t\tcontext->indent_level--;\n\t\tif (context->indent_level == 0) {\n\t\t\tast_str_append(&context->output_buffer, 0, \"\\n\");\n\t\t}\n\t}\n\tif (context->show_details\n\t\t|| (context->show_details_only_level_0 && context->indent_level == 0)) {\n\t\tast_str_append(&context->output_buffer, 0, \"\\n\");\n\t\tast_sip_cli_print_sorcery_objectset(ident, context, 0);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 630}
{"project": "Asterisk", "target": 0, "func": "static int isslavenative(struct dahdi_pvt *p, struct dahdi_pvt **out)\n{\n\tint x;\n\tint useslavenative;\n\tstruct dahdi_pvt *slave = NULL;\n\t\n\tuseslavenative = 1;\n\t\n\tfor (x = 0; x < 3; x++) {\n\t\t\n\t\tif ((p->subs[x].dfd > -1) && p->subs[x].inthreeway)\n\t\t\tuseslavenative = 0;\n\t}\n\t\n\tif (useslavenative) {\n\t\tfor (x = 0; x < MAX_SLAVES; x++) {\n\t\t\tif (p->slaves[x]) {\n\t\t\t\tif (slave) {\n\t\t\t\t\t\n\t\t\t\t\tslave = NULL;\n\t\t\t\t\tuseslavenative = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tslave = p->slaves[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (!slave)\n\t\tuseslavenative = 0;\n\telse if (slave->law != p->law) {\n\t\tuseslavenative = 0;\n\t\tslave = NULL;\n\t}\n\tif (out)\n\t\t*out = slave;\n\treturn useslavenative;\n}\n", "bug_type": null, "idx": 631}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void misdn_prefix_string(const char *str_prefix, char *str_main, size_t size)\n{\n\tsize_t len_over;\n\tsize_t len_total;\n\tsize_t len_main;\n\tsize_t len_prefix;\n\tlen_prefix = strlen(str_prefix);\n\tif (!len_prefix) {\n\t\t\n\t\treturn;\n\t}\n\tlen_main = strlen(str_main);\n\tlen_total = len_prefix + len_main;\n\tif (size <= len_total) {\n\t\t\n\t\tlen_over = len_total + 1 - size;\n\t\tif (len_over <= len_main) {\n\t\t\tlen_main -= len_over;\n\t\t} else {\n\t\t\tlen_over -= len_main;\n\t\t\tlen_main = 0;\n\t\t\tlen_prefix -= len_over;\n\t\t}\n\t}\n\tif (len_main) {\n\t\tmemmove(str_main + len_prefix, str_main, len_main);\n\t}\n\tmemcpy(str_main, str_prefix, len_prefix);\n\tstr_main[len_prefix + len_main] = '\\0';\n}\n", "bug_type": null, "idx": 632}
{"project": "Asterisk", "target": 0, "func": "void ast_sorcery_load(const struct ast_sorcery *sorcery)\n{\n\tstruct sorcery_load_details details = {\n\t\t.sorcery = sorcery,\n\t\t.reload = 0,\n\t};\n\tNOTIFY_INSTANCE_OBSERVERS(sorcery->observers, instance_loading,\n\t\tsorcery->module_name, sorcery, 0);\n\tao2_callback(sorcery->types, OBJ_NODATA, sorcery_object_load, &details);\n\tNOTIFY_INSTANCE_OBSERVERS(sorcery->observers, instance_loaded,\n\t\tsorcery->module_name, sorcery, 0);\n}\n", "bug_type": null, "idx": 633}
{"project": "Asterisk", "target": 0, "func": "static int hook_config_sane;\nstatic int hook_cb(struct ast_config *cfg)\n{\n\thook_run = 1;\n\tif (test_config_validity(cfg) == 0) {\n\t\thook_config_sane = 1;\n\t}\n\tast_config_destroy(cfg);\n\treturn 0;\n}\n", "bug_type": null, "idx": 634}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void erds_destroy(struct enum_result_datastore *data) \n{\n\tint k;\n\tfor (k = 0; k < data->context->naptr_rrs_count; k++) {\n\t\tast_free(data->context->naptr_rrs[k].result);\n\t\tast_free(data->context->naptr_rrs[k].tech);\n\t}\n\tast_free(data->context->naptr_rrs);\n\tast_free(data->context);\n\tast_free(data);\n}\n", "bug_type": null, "idx": 635}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225CicInfo (OOCTXT* pctxt, H225CicInfo* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"cic\", -1);\n   stat = asn1PD_H225_SeqOfH225CicInfo_cic_element (pctxt, &pvalue->cic);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"cic\", -1);\n   \n   invokeStartElement (pctxt, \"pointCode\", -1);\n   stat = asn1PD_H225CicInfo_pointCode (pctxt, &pvalue->pointCode);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"pointCode\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 636}
{"project": "Asterisk", "target": 0, "func": "static enum attended_transfer_state hesitant_exit(struct attended_transfer_properties *props,\n\t\tenum attended_transfer_stimulus stimulus)\n{\n\tswitch (stimulus) {\n\tcase STIMULUS_TRANSFEREE_HANGUP:\n\t\tplay_failsound(props->transferer);\n\t\tpublish_transfer_fail(props);\n\t\treturn TRANSFER_FAIL;\n\tcase STIMULUS_DTMF_ATXFER_COMPLETE:\n\tcase STIMULUS_TRANSFERER_HANGUP:\n\t\treturn props->atxferdropcall ? TRANSFER_BLOND : TRANSFER_BLOND_NONFINAL;\n\tcase STIMULUS_TRANSFER_TARGET_ANSWER:\n\t\treturn TRANSFER_DOUBLECHECKING;\n\tcase STIMULUS_TRANSFER_TARGET_HANGUP:\n\tcase STIMULUS_TIMEOUT:\n\tcase STIMULUS_DTMF_ATXFER_ABORT:\n\t\tplay_failsound(props->transferer);\n\t\treturn TRANSFER_RESUME;\n\tcase STIMULUS_DTMF_ATXFER_THREEWAY:\n\t\treturn TRANSFER_THREEWAY;\n\tcase STIMULUS_DTMF_ATXFER_SWAP:\n\t\thold(props->transferer);\n\t\treturn TRANSFER_CALLING_TARGET;\n\tcase STIMULUS_NONE:\n\tcase STIMULUS_RECALL_TARGET_HANGUP:\n\tcase STIMULUS_RECALL_TARGET_ANSWER:\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Unexpected stimulus '%s' received in attended transfer state '%s'\\n\",\n\t\t\t\tstimulus_strs[stimulus], state_properties[props->state].state_name);\n\t\treturn props->state;\n\t}\n}\n", "bug_type": null, "idx": 637}
{"project": "Asterisk", "target": 0, "func": "static void *playtones_alloc(struct ast_channel *chan, void *params)\n{\n\tstruct playtones_def *pd = params;\n\tstruct playtones_state *ps = NULL;\n\tif (!(ps = ast_calloc(1, sizeof(*ps)))) {\n\t\treturn NULL;\n\t}\n\tps->origwfmt = ao2_bump(ast_channel_writeformat(chan));\n\tif (ast_set_write_format(chan, ast_format_slin)) {\n\t\tast_log(LOG_WARNING, \"Unable to set '%s' to signed linear format (write)\\n\", ast_channel_name(chan));\n\t\tplaytones_release(NULL, ps);\n\t\tps = NULL;\n\t} else {\n\t\tps->vol = pd->vol;\n\t\tps->reppos = pd->reppos;\n\t\tps->nitems = pd->nitems;\n\t\tps->items = pd->items;\n\t\tps->oldnpos = -1;\n\t}\n\t\n\tif (pd->interruptible) {\n\t\tast_set_flag(ast_channel_flags(chan), AST_FLAG_WRITE_INT);\n\t} else {\n\t\tast_clear_flag(ast_channel_flags(chan), AST_FLAG_WRITE_INT);\n\t}\n\treturn ps;\n}\n", "bug_type": null, "idx": 638}
{"project": "Asterisk", "target": 0, "func": "void gsm_debug_longwords P4( (name, from, to, ptr),\n\tchar \t      * name,\n\tint\t\tfrom,\n\tint\t\tto,\n\tlongword      * ptr)\n{\n\tint \tnprinted = 0;\n\tfprintf( stderr, \"%s [%d .. %d]: \", name, from, to );\n\twhile (from <= to) {\n\t\tfprintf(stderr, \"%d \", ptr[ from ] );\n\t\tfrom++;\n\t\tif (nprinted++ >= 7) {\n\t\t\tnprinted = 0;\n\t\t\tif (from < to) putc('\\n', stderr);\n\t\t}\n\t}\n\tputc('\\n', stderr);\n}\n", "bug_type": null, "idx": 639}
{"project": "Asterisk", "target": 0, "func": "static int res_sdp_crypto_parse_offer(struct ast_rtp_instance *rtp, struct ast_sdp_srtp *srtp, const char *attr)\n{\n\tchar *str = NULL;\n\tchar *tag = NULL;\n\tchar *suite = NULL;\n\tchar *key_params = NULL;\n\tchar *key_param = NULL;\n\tchar *session_params = NULL;\n\tchar *key_salt = NULL;       \n\tchar *lifetime = NULL;       \n\tchar *mki = NULL;            \n\tint found = 0;\n\tint key_len_from_sdp;\n\tint key_len_expected;\n\tint tag_from_sdp;\n\tint suite_val = 0;\n\tunsigned char remote_key[SRTP_MAX_KEY_LEN];\n\tint taglen;\n\tdouble sdes_lifetime;\n\tstruct ast_sdp_crypto *crypto;\n\tstruct ast_sdp_srtp *tmp;\n\tstr = ast_strdupa(attr);\n\ttag = strsep(&str, \" \");\n\tsuite = strsep(&str, \" \");\n\tkey_params = strsep(&str, \" \");\n\tsession_params = strsep(&str, \" \");\n\tif (!tag || !suite) {\n\t\tast_log(LOG_WARNING, \"Unrecognized crypto attribute a=%s\\n\", attr);\n\t\treturn -1;\n\t}\n\t\n\tif (sscanf(tag, \"%30d\", &tag_from_sdp) != 1 || tag_from_sdp < 0 || tag_from_sdp > 999999999) {\n\t\tast_log(LOG_WARNING, \"Unacceptable a=crypto tag: %s\\n\", tag);\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(session_params)) {\n\t\tast_log(LOG_WARNING, \"Unsupported crypto parameters: %s\\n\", session_params);\n\t\treturn -1;\n\t}\n\t\n\tfor (tmp = srtp; tmp && tmp->crypto && tmp->crypto->tag != tag_from_sdp;) {\n\t\ttmp = AST_LIST_NEXT(tmp, sdp_srtp_list);\n\t}\n\tif (tmp) { \n\t\tunsigned int flags = tmp->flags;\n\t\t\n\t\tcrypto = tmp->crypto;\n\t\ttmp->crypto = srtp->crypto;\n\t\ttmp->flags = srtp->flags;\n\t\tsrtp->crypto = crypto;\n\t\tsrtp->flags = flags;\n\t} else {\n\t\tcrypto = srtp->crypto;\n\t\tcrypto->tag = tag_from_sdp;\n\t}\n\tif (!strcmp(suite, \"AES_CM_128_HMAC_SHA1_80\")) {\n\t\tsuite_val = AST_AES_CM_128_HMAC_SHA1_80;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_80);\n\t\tkey_len_expected = 30;\n\t} else if (!strcmp(suite, \"AES_CM_128_HMAC_SHA1_32\")) {\n\t\tsuite_val = AST_AES_CM_128_HMAC_SHA1_32;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_32);\n\t\tkey_len_expected = 30;\n#ifdef HAVE_SRTP_192\n\t} else if (!strcmp(suite, \"AES_192_CM_HMAC_SHA1_80\")) {\n\t\tsuite_val = AST_AES_CM_192_HMAC_SHA1_80;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_80);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_192);\n\t\tkey_len_expected = 38;\n\t} else if (!strcmp(suite, \"AES_192_CM_HMAC_SHA1_32\")) {\n\t\tsuite_val = AST_AES_CM_192_HMAC_SHA1_32;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_32);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_192);\n\t\tkey_len_expected = 38;\n\t\n\t} else if (!strcmp(suite, \"AES_CM_192_HMAC_SHA1_80\")) {\n\t\tsuite_val = AST_AES_CM_192_HMAC_SHA1_80;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_80);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_192);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_OLD_NAME);\n\t\tkey_len_expected = 38;\n\t} else if (!strcmp(suite, \"AES_CM_192_HMAC_SHA1_32\")) {\n\t\tsuite_val = AST_AES_CM_192_HMAC_SHA1_32;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_32);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_192);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_OLD_NAME);\n\t\tkey_len_expected = 38;\n#endif\n#ifdef HAVE_SRTP_256\n\t} else if (!strcmp(suite, \"AES_256_CM_HMAC_SHA1_80\")) {\n\t\tsuite_val = AST_AES_CM_256_HMAC_SHA1_80;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_80);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_256);\n\t\tkey_len_expected = 46;\n\t} else if (!strcmp(suite, \"AES_256_CM_HMAC_SHA1_32\")) {\n\t\tsuite_val = AST_AES_CM_256_HMAC_SHA1_32;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_32);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_256);\n\t\tkey_len_expected = 46;\n\t\n\t} else if (!strcmp(suite, \"AES_CM_256_HMAC_SHA1_80\")) {\n\t\tsuite_val = AST_AES_CM_256_HMAC_SHA1_80;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_80);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_256);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_OLD_NAME);\n\t\tkey_len_expected = 46;\n\t} else if (!strcmp(suite, \"AES_CM_256_HMAC_SHA1_32\")) {\n\t\tsuite_val = AST_AES_CM_256_HMAC_SHA1_32;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_32);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_256);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_OLD_NAME);\n\t\tkey_len_expected = 46;\n#endif\n#ifdef HAVE_SRTP_GCM\n\t} else if (!strcmp(suite, \"AEAD_AES_128_GCM\")) {\n\t\tsuite_val = AST_AES_GCM_128;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_16);\n\t\tkey_len_expected = AES_128_GCM_KEYSIZE_WSALT;\n\t} else if (!strcmp(suite, \"AEAD_AES_256_GCM\")) {\n\t\tsuite_val = AST_AES_GCM_256;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_16);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_256);\n\t\tkey_len_expected = AES_256_GCM_KEYSIZE_WSALT;\n\t\n\t} else if (!strcmp(suite, \"AEAD_AES_128_GCM_8\")) {\n\t\tsuite_val = AST_AES_GCM_128_8;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_8);\n\t\tkey_len_expected = AES_128_GCM_KEYSIZE_WSALT;\n\t} else if (!strcmp(suite, \"AEAD_AES_256_GCM_8\")) {\n\t\tsuite_val = AST_AES_GCM_256_8;\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_TAG_8);\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_AES_256);\n\t\tkey_len_expected = AES_256_GCM_KEYSIZE_WSALT;\n#endif\n\t} else {\n\t\tast_verb(1, \"Unsupported crypto suite: %s\\n\", suite);\n\t\treturn -1;\n\t}\n\twhile ((key_param = strsep(&key_params, \";\"))) {\n\t\tunsigned int n_lifetime;\n\t\tchar *method = NULL;\n\t\tchar *info = NULL;\n\t\tmethod = strsep(&key_param, \":\");\n\t\tinfo = strsep(&key_param, \";\");\n\t\tsdes_lifetime = 0;\n\t\tif (strcmp(method, \"inline\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tkey_salt = strsep(&info, \"|\");\n\t\t\n\t\tlifetime = strsep(&info, \"|\");\n\t\tif (!lifetime) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tmki = strchr(lifetime, ':');\n\t\tif (mki) {\n\t\t\tmki = lifetime;\n\t\t\tlifetime = NULL;\n\t\t} else {\n\t\t\tmki = strsep(&info, \"|\");\n\t\t}\n\t\tif (mki && *mki != '1') {\n\t\t\tast_log(LOG_NOTICE, \"Crypto MKI handling is not supported: ignoring attribute %s\\n\", attr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (lifetime) {\n\t\t\tif (!strncmp(lifetime, \"2^\", 2)) {\n\t\t\t\tchar *lifetime_val = lifetime + 2;\n\t\t\t\t\n\t\t\t\tif (sscanf(lifetime_val, \"%30u\", &n_lifetime) != 1) {\n\t\t\t\t\tast_log(LOG_NOTICE, \"Failed to parse lifetime value in crypto attribute: %s\\n\", attr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (n_lifetime > 48) {\n\t\t\t\t\t\n\t\t\t\t\tast_log(LOG_NOTICE, \"Crypto lifetime exponent of '%u' is a bit large; using 48\\n\", n_lifetime);\n\t\t\t\t\tn_lifetime = 48;\n\t\t\t\t}\n\t\t\t\tsdes_lifetime = pow(2, n_lifetime);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (sscanf(lifetime, \"%30u\", &n_lifetime) != 1) {\n\t\t\t\t\tast_log(LOG_NOTICE, \"Failed to parse lifetime value in crypto attribute: %s\\n\", attr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsdes_lifetime = n_lifetime;\n\t\t\t}\n\t\t\t\n\t\t\tif (sdes_lifetime < 1800000) {\n\t\t\t\tast_log(LOG_NOTICE, \"Rejecting crypto attribute '%s': lifetime '%f' too short\\n\", attr, sdes_lifetime);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tast_debug(2, \"Crypto attribute '%s' accepted with lifetime '%f', MKI '%s'\\n\",\n\t\t\tattr, sdes_lifetime, mki ? mki : \"-\");\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tast_log(LOG_NOTICE, \"SRTP crypto offer not acceptable: '%s'\\n\", attr);\n\t\treturn -1;\n\t}\n\tkey_len_from_sdp = ast_base64decode(remote_key, key_salt, sizeof(remote_key));\n\tif (key_len_from_sdp != key_len_expected) {\n\t\tast_log(LOG_WARNING, \"SRTP descriptions key length is '%d', not '%d'\\n\",\n\t\t\tkey_len_from_sdp, key_len_expected);\n\t\treturn -1;\n\t}\n\t\n\t\n\t\n\tif (crypto->key_len != key_len_from_sdp) {\n\t\tif (!crypto_init_keys(crypto, key_len_from_sdp)) {\n\t\t\treturn -1;\n\t\t}\n\t} else if (!memcmp(crypto->remote_key, remote_key, key_len_from_sdp)) {\n\t\tast_debug(1, \"SRTP remote key unchanged; maintaining current policy\\n\");\n\t\tast_set_flag(srtp, AST_SRTP_CRYPTO_OFFER_OK);\n\t\treturn 0;\n\t}\n\tif (key_len_from_sdp > sizeof(crypto->remote_key)) {\n\t\tast_log(LOG_ERROR,\n\t\t\t\"SRTP key buffer is %zu although it must be at least %d bytes\\n\",\n\t\t\tsizeof(crypto->remote_key), key_len_from_sdp);\n\t\treturn -1;\n\t}\n\tmemcpy(crypto->remote_key, remote_key, key_len_from_sdp);\n\tif (crypto_activate(crypto, suite_val, remote_key, key_len_from_sdp, rtp) < 0) {\n\t\treturn -1;\n\t}\n\tif (ast_test_flag(srtp, AST_SRTP_CRYPTO_TAG_32)) {\n\t\ttaglen = 32;\n\t} else if (ast_test_flag(srtp, AST_SRTP_CRYPTO_TAG_16)) {\n\t\ttaglen = 16;\n\t} else if (ast_test_flag(srtp, AST_SRTP_CRYPTO_TAG_8)) {\n\t\ttaglen = 8;\n\t} else {\n\t\ttaglen = 80;\n\t}\n\tif (ast_test_flag(srtp, AST_SRTP_CRYPTO_AES_256)) {\n\t\ttaglen |= 0x0200;\n\t} else if (ast_test_flag(srtp, AST_SRTP_CRYPTO_AES_192)) {\n\t\ttaglen |= 0x0100;\n\t}\n\tif (ast_test_flag(srtp, AST_SRTP_CRYPTO_OLD_NAME)) {\n\t\ttaglen |= 0x0080;\n\t}\n\t\n\tif (res_sdp_crypto_build_offer(crypto, taglen)) {\n\t\treturn -1;\n\t}\n\tast_set_flag(srtp, AST_SRTP_CRYPTO_OFFER_OK);\n\treturn 0;\n}\n", "bug_type": null, "idx": 640}
{"project": "Asterisk", "target": 0, "func": "static enum ast_device_state calendarstate(const char *data)\n{\n\tenum ast_device_state state;\n\tstruct ast_calendar *cal;\n\tif (ast_strlen_zero(data) || (!(cal = find_calendar(data)))) {\n\t\treturn AST_DEVICE_INVALID;\n\t}\n\tif (cal->tech->is_busy) {\n\t\tstate = cal->tech->is_busy(cal) ? AST_DEVICE_INUSE : AST_DEVICE_NOT_INUSE;\n\t} else {\n\t\tstate = calendar_is_busy(cal) ? AST_DEVICE_INUSE : AST_DEVICE_NOT_INUSE;\n\t}\n\tcal = unref_calendar(cal);\n\treturn state;\n}\n", "bug_type": null, "idx": 641}
{"project": "Asterisk", "target": 0, "func": "int stasis_app_control_is_done(struct stasis_app_control *control)\n{\n\treturn control_is_done(control);\n}\n", "bug_type": null, "idx": 642}
{"project": "Asterisk", "target": 0, "func": "\nint ast_bridge_features_init(struct ast_bridge_features *features)\n{\n\t\n\tmemset(features, 0, sizeof(*features));\n\t\n\tfeatures->dtmf_hooks = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX,\n\t\tAO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE, bridge_dtmf_hook_sort, NULL);\n\tif (!features->dtmf_hooks) {\n\t\treturn -1;\n\t}\n\t\n\tfeatures->other_hooks = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL,\n\t\tNULL);\n\tif (!features->other_hooks) {\n\t\treturn -1;\n\t}\n\t\n\tfeatures->interval_hooks = ast_heap_create(8, interval_hook_time_cmp,\n\t\toffsetof(struct ast_bridge_hook_timer, timer.heap_index));\n\tif (!features->interval_hooks) {\n\t\treturn -1;\n\t}\n\tfeatures->dtmf_passthrough = 1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 643}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/module.h\"\nstatic char *handle_cli_test_locales(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tDIR *localedir;\n\tstruct dirent *dent;\n\tstruct ast_tm atm;\n\tstruct timeval tv;\n\tconst char *orig_locale;\n\tchar origlocalformat[200] = \"\", localformat[200] = \"\";\n\tstruct test_locales {\n\t\tAST_LIST_ENTRY(test_locales) list;\n\t\tchar *localformat;\n\t\tchar name[0];\n\t} *tl = NULL;\n\tAST_LIST_HEAD_NOLOCK(locales, test_locales) locales;\n\tint varies = 0, all_successful = 1, count = 0, count_fail = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"test locale\";\n\t\te->usage = \"\"\n\t\t\t\"Usage: test locale\\n\"\n\t\t\t\"   Test thread safety of locale functions.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != e->args) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\t\n\tif (!(localedir = opendir(\n#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined( __NetBSD__ ) || defined(__APPLE__)\n\t\t\"/usr/share/locale\"\n#else \n\t\t\"/usr/lib/locale\"\n#endif\n\t\t))) {\n\t\tast_cli(a->fd, \"No locales seem to exist on this platform.\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\ttv = ast_tvnow();\n\tast_localtime(&tv, &atm, NULL);\n\torig_locale = setlocale(LC_ALL, NULL);\n\tAST_LIST_HEAD_SET_NOLOCK(&locales, NULL);\n\t\n\tast_strftime(origlocalformat, sizeof(origlocalformat), \"%c\", &atm);\n\twhile ((dent = readdir(localedir))) {\n\t\tsize_t namelen;\n\t\tif (dent->d_name[0] == '.') {\n\t\t\tcontinue;\n\t\t}\n\t\tsetlocale(LC_ALL, dent->d_name);\n\t\tast_strftime(localformat, sizeof(localformat), \"%c\", &atm);\n\t\t\n\t\tif (!(tl = ast_calloc(1, sizeof(*tl) + strlen(localformat) + (namelen = strlen(dent->d_name)) + 2))) {\n\t\t\tcontinue;\n\t\t}\n\t\tstrcpy(tl->name, dent->d_name); \n\t\ttl->localformat = tl->name + namelen + 1;\n\t\tstrcpy(tl->localformat, localformat); \n\t\tAST_LIST_INSERT_TAIL(&locales, tl, list);\n\t\t\n\t\tif (!varies && strcmp(AST_LIST_FIRST(&locales)->localformat, localformat)) {\n\t\t\tvaries = 1;\n\t\t}\n\t}\n\tsetlocale(LC_ALL, orig_locale);\n\tclosedir(localedir);\n\tif (!varies) {\n\t\tif (!strcmp(origlocalformat, localformat)) {\n\t\t\tast_cli(a->fd, \"WARNING: the locales on your system don't differ.  Install more locales if you want this test to mean something.\\n\");\n\t\t}\n\t}\n\torig_locale = ast_setlocale(AST_LIST_FIRST(&locales)->name);\n\twhile ((tl = AST_LIST_REMOVE_HEAD(&locales, list))) {\n\t\tast_setlocale(tl->name);\n\t\tast_strftime(localformat, sizeof(localformat), \"%c\", &atm);\n\t\tif (strcmp(localformat, tl->localformat)) {\n\t\t\tast_cli(a->fd, \"WARNING: locale test fails for locale %s\\n\", tl->name);\n\t\t\tall_successful = 0;\n\t\t\tcount_fail++;\n\t\t}\n\t\tast_free(tl);\n\t\tcount++;\n\t}\n\tast_setlocale(orig_locale);\n\tif (all_successful) {\n\t\tast_cli(a->fd, \"All %d locale tests successful\\n\", count);\n\t} else if (count_fail == count && count > 0) {\n\t\tast_cli(a->fd, \"No locale tests successful out of %d tries\\n\", count);\n\t} else if (count > 0) {\n\t\tast_cli(a->fd, \"Partial failure (%d/%d) for a %.0f%% failure rate\\n\", count_fail, count, count_fail * 100.0 / count);\n\t} else {\n\t\tast_cli(a->fd, \"No locales tested.  Install more locales.\\n\");\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 644}
{"project": "Asterisk", "target": 0, "func": "static int bridgewait_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *bridge_name = DEFAULT_BRIDGE_NAME;\n\tstruct ast_bridge_features chan_features;\n\tstruct ast_flags flags = { 0 };\n\tchar *parse;\n\tenum wait_bridge_roles role = ROLE_PARTICIPANT;\n\tchar *opts[OPT_ARG_ARRAY_SIZE] = { NULL, };\n\tstruct wait_bridge_wrapper *bridge_wrapper;\n\tint res;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(name);\n\t\tAST_APP_ARG(role);\n\t\tAST_APP_ARG(options);\n\t\tAST_APP_ARG(other);\t\t\n\t);\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (!ast_strlen_zero(args.name)) {\n\t\tbridge_name = args.name;\n\t}\n\tif (!ast_strlen_zero(args.role)) {\n\t\trole = validate_role(args.role);\n\t\tif (role == ROLE_INVALID) {\n\t\t\tast_log(LOG_ERROR, \"Requested waiting bridge role '%s' is invalid.\\n\", args.role);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (ast_bridge_features_init(&chan_features)) {\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\tast_log(LOG_ERROR, \"'%s' failed to enter the waiting bridge - could not set up channel features\\n\",\n\t\t\tast_channel_name(chan));\n\t\treturn -1;\n\t}\n\tif (args.options) {\n\t\tast_app_parse_options(bridgewait_opts, &flags, opts, args.options);\n\t}\n\t\n\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\tast_answer(chan);\n\t}\n\tif (process_options(chan, &flags, opts, &chan_features, role)) {\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\treturn -1;\n\t}\n\tbridge_wrapper = get_wait_bridge_wrapper(bridge_name);\n\tif (!bridge_wrapper) {\n\t\tast_log(LOG_WARNING, \"Failed to find or create waiting bridge '%s' for '%s'.\\n\", bridge_name, ast_channel_name(chan));\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\treturn -1;\n\t}\n\tast_verb(3, \"%s is entering waiting bridge %s:%s\\n\", ast_channel_name(chan), bridge_name, bridge_wrapper->bridge->uniqueid);\n\tres = ast_bridge_join(bridge_wrapper->bridge, chan, NULL, &chan_features, NULL, 0);\n\twait_wrapper_removal(bridge_wrapper);\n\tast_bridge_features_cleanup(&chan_features);\n\tif (res) {\n\t\t\n\t\tast_log(LOG_WARNING, \"Failed to join waiting bridge '%s' for '%s'.\\n\", bridge_name, ast_channel_name(chan));\n\t}\n\treturn (res || ast_check_hangup_locked(chan)) ? -1 : 0;\n}\n", "bug_type": null, "idx": 645}
{"project": "Asterisk", "target": 0, "func": "#endif\nstatic void update_filter(SpeexResamplerState *st)\n{\n   spx_uint32_t old_length;\n   old_length = st->filt_len;\n   st->oversample = quality_map[st->quality].oversample;\n   st->filt_len = quality_map[st->quality].base_length;\n   if (st->num_rate > st->den_rate)\n   {\n      \n      st->cutoff = quality_map[st->quality].downsample_bandwidth * st->den_rate / st->num_rate;\n      \n      st->filt_len = st->filt_len*st->num_rate / st->den_rate;\n      \n      st->filt_len &= (~0x3);\n      if (2*st->den_rate < st->num_rate)\n         st->oversample >>= 1;\n      if (4*st->den_rate < st->num_rate)\n         st->oversample >>= 1;\n      if (8*st->den_rate < st->num_rate)\n         st->oversample >>= 1;\n      if (16*st->den_rate < st->num_rate)\n         st->oversample >>= 1;\n      if (st->oversample < 1)\n         st->oversample = 1;\n   } else {\n      \n      st->cutoff = quality_map[st->quality].upsample_bandwidth;\n   }\n   \n   if (st->den_rate <= st->oversample)\n   {\n      spx_uint32_t i;\n      if (!st->sinc_table)\n         st->sinc_table = (spx_word16_t *)speex_alloc(st->filt_len*st->den_rate*sizeof(spx_word16_t));\n      else if (st->sinc_table_length < st->filt_len*st->den_rate)\n      {\n         st->sinc_table = (spx_word16_t *)speex_realloc(st->sinc_table,st->filt_len*st->den_rate*sizeof(spx_word16_t));\n         st->sinc_table_length = st->filt_len*st->den_rate;\n      }\n      for (i=0;i<st->den_rate;i++)\n      {\n         spx_int32_t j;\n         for (j=0;j<st->filt_len;j++)\n         {\n            st->sinc_table[i*st->filt_len+j] = sinc(st->cutoff,((j-(spx_int32_t)st->filt_len/2+1)-((float)i)/st->den_rate), st->filt_len, quality_map[st->quality].window_func);\n         }\n      }\n#ifdef FIXED_POINT\n      st->resampler_ptr = resampler_basic_direct_single;\n#else\n      if (st->quality>8)\n         st->resampler_ptr = resampler_basic_direct_double;\n      else\n         st->resampler_ptr = resampler_basic_direct_single;\n#endif\n      \n   } else {\n      spx_int32_t i;\n      if (!st->sinc_table)\n         st->sinc_table = (spx_word16_t *)speex_alloc((st->filt_len*st->oversample+8)*sizeof(spx_word16_t));\n      else if (st->sinc_table_length < st->filt_len*st->oversample+8)\n      {\n         st->sinc_table = (spx_word16_t *)speex_realloc(st->sinc_table,(st->filt_len*st->oversample+8)*sizeof(spx_word16_t));\n         st->sinc_table_length = st->filt_len*st->oversample+8;\n      }\n      for (i=-4;i<(spx_int32_t)(st->oversample*st->filt_len+4);i++)\n         st->sinc_table[i+4] = sinc(st->cutoff,(i/(float)st->oversample - st->filt_len/2), st->filt_len, quality_map[st->quality].window_func);\n#ifdef FIXED_POINT\n      st->resampler_ptr = resampler_basic_interpolate_single;\n#else\n      if (st->quality>8)\n         st->resampler_ptr = resampler_basic_interpolate_double;\n      else\n         st->resampler_ptr = resampler_basic_interpolate_single;\n#endif\n      \n   }\n   st->int_advance = st->num_rate/st->den_rate;\n   st->frac_advance = st->num_rate%st->den_rate;\n   \n   if (!st->mem)\n   {\n      spx_uint32_t i;\n      st->mem_alloc_size = st->filt_len-1 + st->buffer_size;\n      st->mem = (spx_word16_t*)speex_alloc(st->nb_channels*st->mem_alloc_size * sizeof(spx_word16_t));\n      for (i=0;i<st->nb_channels*st->mem_alloc_size;i++)\n         st->mem[i] = 0;\n      \n   } else if (!st->started)\n   {\n      spx_uint32_t i;\n      st->mem_alloc_size = st->filt_len-1 + st->buffer_size;\n      st->mem = (spx_word16_t*)speex_realloc(st->mem, st->nb_channels*st->mem_alloc_size * sizeof(spx_word16_t));\n      for (i=0;i<st->nb_channels*st->mem_alloc_size;i++)\n         st->mem[i] = 0;\n      \n   } else if (st->filt_len > old_length)\n   {\n      spx_int32_t i;\n      \n      \n      int old_alloc_size = st->mem_alloc_size;\n      if ((st->filt_len-1 + st->buffer_size) > st->mem_alloc_size)\n      {\n         st->mem_alloc_size = st->filt_len-1 + st->buffer_size;\n         st->mem = (spx_word16_t*)speex_realloc(st->mem, st->nb_channels*st->mem_alloc_size * sizeof(spx_word16_t));\n      }\n      for (i=st->nb_channels-1;i>=0;i--)\n      {\n         spx_int32_t j;\n         spx_uint32_t olen = old_length;\n         \n         {\n            \n            \n            olen = old_length + 2*st->magic_samples[i];\n            for (j=old_length-2+st->magic_samples[i];j>=0;j--)\n               st->mem[i*st->mem_alloc_size+j+st->magic_samples[i]] = st->mem[i*old_alloc_size+j];\n            for (j=0;j<st->magic_samples[i];j++)\n               st->mem[i*st->mem_alloc_size+j] = 0;\n            st->magic_samples[i] = 0;\n         }\n         if (st->filt_len > olen)\n         {\n            \n            \n            for (j=0;j<olen-1;j++)\n               st->mem[i*st->mem_alloc_size+(st->filt_len-2-j)] = st->mem[i*st->mem_alloc_size+(olen-2-j)];\n            \n            for (;j<st->filt_len-1;j++)\n               st->mem[i*st->mem_alloc_size+(st->filt_len-2-j)] = 0;\n            \n            st->last_sample[i] += (st->filt_len - olen)/2;\n         } else {\n            \n            st->magic_samples[i] = (olen - st->filt_len)/2;\n            for (j=0;j<st->filt_len-1+st->magic_samples[i];j++)\n               st->mem[i*st->mem_alloc_size+j] = st->mem[i*st->mem_alloc_size+j+st->magic_samples[i]];\n         }\n      }\n   } else if (st->filt_len < old_length)\n   {\n      spx_uint32_t i;\n      \n      for (i=0;i<st->nb_channels;i++)\n      {\n         spx_uint32_t j;\n         spx_uint32_t old_magic = st->magic_samples[i];\n         st->magic_samples[i] = (old_length - st->filt_len)/2;\n         \n         \n         for (j=0;j<st->filt_len-1+st->magic_samples[i]+old_magic;j++)\n            st->mem[i*st->mem_alloc_size+j] = st->mem[i*st->mem_alloc_size+j+st->magic_samples[i]];\n         st->magic_samples[i] += old_magic;\n      }\n   }\n}\n", "bug_type": null, "idx": 646}
{"project": "Asterisk", "target": 0, "func": "\nvi_substitute_char(EditLine *el, int c)\n{\n\tc_delafter(el, el->el_state.argument);\n\tel->el_map.current = el->el_map.key;\n\treturn (CC_REFRESH);\n}\n", "bug_type": null, "idx": 647}
{"project": "Asterisk", "target": 0, "func": "\nstatic void reload_queue_members(void)\n{\n\tchar *cur_ptr;\n\tconst char *queue_name;\n\tchar *member;\n\tchar *interface;\n\tchar *membername = NULL;\n\tchar *state_interface;\n\tchar *penalty_tok;\n\tint penalty = 0;\n\tchar *paused_tok;\n\tint paused = 0;\n\tchar *reason_paused;\n\tstruct ast_db_entry *db_tree;\n\tstruct ast_db_entry *entry;\n\tstruct call_queue *cur_queue;\n\tchar *queue_data;\n\t\n\tdb_tree = ast_db_gettree(pm_family, NULL);\n\tfor (entry = db_tree; entry; entry = entry->next) {\n\t\tqueue_name = entry->key + strlen(pm_family) + 2;\n\t\t{\n\t\t\tstruct call_queue tmpq = {\n\t\t\t\t.name = queue_name,\n\t\t\t};\n\t\t\tcur_queue = ao2_t_find(queues, &tmpq, OBJ_POINTER, \"Reload queue members\");\n\t\t}\n\t\tif (!cur_queue) {\n\t\t\tcur_queue = find_load_queue_rt_friendly(queue_name);\n\t\t}\n\t\tif (!cur_queue) {\n\t\t\t\n\t\t\tast_log(LOG_WARNING, \"Error loading persistent queue: '%s': it does not exist\\n\", queue_name);\n\t\t\tast_db_del(pm_family, queue_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ast_db_get_allocated(pm_family, queue_name, &queue_data)) {\n\t\t\tqueue_t_unref(cur_queue, \"Expire reload reference\");\n\t\t\tcontinue;\n\t\t}\n\t\tcur_ptr = queue_data;\n\t\twhile ((member = strsep(&cur_ptr, \",|\"))) {\n\t\t\tif (ast_strlen_zero(member)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinterface = strsep(&member, \";\");\n\t\t\tpenalty_tok = strsep(&member, \";\");\n\t\t\tpaused_tok = strsep(&member, \";\");\n\t\t\tmembername = strsep(&member, \";\");\n\t\t\tstate_interface = strsep(&member, \";\");\n\t\t\treason_paused = strsep(&member, \";\");\n\t\t\tif (!penalty_tok) {\n\t\t\t\tast_log(LOG_WARNING, \"Error parsing persistent member string for '%s' (penalty)\\n\", queue_name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpenalty = strtol(penalty_tok, NULL, 10);\n\t\t\tif (errno == ERANGE) {\n\t\t\t\tast_log(LOG_WARNING, \"Error converting penalty: %s: Out of range.\\n\", penalty_tok);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!paused_tok) {\n\t\t\t\tast_log(LOG_WARNING, \"Error parsing persistent member string for '%s' (paused)\\n\", queue_name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpaused = strtol(paused_tok, NULL, 10);\n\t\t\tif ((errno == ERANGE) || paused < 0 || paused > 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Error converting paused: %s: Expected 0 or 1.\\n\", paused_tok);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_debug(1, \"Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d ReasonPause: %s\\n\",\n\t\t\t              queue_name, interface, membername, penalty, paused, reason_paused);\n\t\t\tif (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, reason_paused) == RES_OUTOFMEMORY) {\n\t\t\t\tast_log(LOG_ERROR, \"Out of Memory when reloading persistent queue member\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue_t_unref(cur_queue, \"Expire reload reference\");\n\t\tast_free(queue_data);\n\t}\n\tif (db_tree) {\n\t\tast_log(LOG_NOTICE, \"Queue members successfully reloaded from database.\\n\");\n\t\tast_db_freetree(db_tree);\n\t}\n}\n", "bug_type": null, "idx": 648}
{"project": "Asterisk", "target": 0, "func": "int __ast_cond_timedwait(const char *filename, int lineno, const char *func,\n\t\t\t\t       const char *cond_name, const char *mutex_name, ast_cond_t *cond,\n\t\t\t\t       ast_mutex_t *t, const struct timespec *abstime)\n{\n\tint res;\n#ifdef DEBUG_THREADS\n\tstruct ast_lock_track *lt = NULL;\n\tstruct ast_lock_track lt_orig;\n\tint canlog = t->tracking && strcmp(filename, \"logger.c\");\n#if defined(AST_MUTEX_INIT_W_CONSTRUCTORS) && defined(CAN_COMPARE_MUTEX_TO_INIT_VALUE)\n\tif ((t->mutex) == ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)) {\n\t\t__ast_mutex_logger(\"%s line %d (%s): Error: mutex '%s' is uninitialized.\\n\",\n\t\t\t\t   filename, lineno, func, mutex_name);\n\t\tDO_THREAD_CRASH;\n\t\treturn EINVAL;\n\t}\n#endif \n\tif (t->tracking) {\n\t\tlt = ast_get_reentrancy(&t->track);\n\t}\n\tif (lt) {\n\t\tast_reentrancy_lock(lt);\n\t\tif (lt->reentrancy && (lt->thread_id[ROFFSET] != pthread_self())) {\n\t\t\t__ast_mutex_logger(\"%s line %d (%s): attempted wait using mutex '%s' without owning it!\\n\",\n\t\t\t\t\t   filename, lineno, func, mutex_name);\n\t\t\t__ast_mutex_logger(\"%s line %d (%s): '%s' was locked here.\\n\",\n\t\t\t\t\t   lt->file[ROFFSET], lt->lineno[ROFFSET], lt->func[ROFFSET], mutex_name);\n#ifdef HAVE_BKTR\n\t\t\t__dump_backtrace(&lt->backtrace[ROFFSET], canlog);\n#endif\n\t\t\tDO_THREAD_CRASH;\n\t\t} else if (lt->reentrancy <= 0) {\n\t\t\t__ast_mutex_logger(\"%s line %d (%s): attempted wait using an unlocked mutex '%s'\\n\",\n\t\t\t\t\t   filename, lineno, func, mutex_name);\n\t\t\tDO_THREAD_CRASH;\n\t\t}\n\t\t\n\t\tlt_orig = *lt;\n\t\tlt->reentrancy = 0;\n\t\tast_reentrancy_unlock(lt);\n\t\tast_suspend_lock_info(t);\n\t}\n#endif \n\tres = pthread_cond_timedwait(cond, &t->mutex, abstime);\n#ifdef DEBUG_THREADS\n\tif (res && (res != ETIMEDOUT)) {\n\t\t__ast_mutex_logger(\"%s line %d (%s): Error waiting on condition mutex '%s'\\n\",\n\t\t\t\t   filename, lineno, func, strerror(res));\n\t\tDO_THREAD_CRASH;\n\t} else if (lt) {\n\t\trestore_lock_tracking(lt, &lt_orig);\n\t\tast_restore_lock_info(t);\n\t}\n#endif \n\treturn res;\n}\n", "bug_type": null, "idx": 649}
{"project": "Asterisk", "target": 0, "func": "static int transfer(void *data)\n{\n\tstruct transfer_data *trnf_data = data;\n\tstruct ast_sip_endpoint *endpoint = NULL;\n\tstruct ast_sip_contact *contact = NULL;\n\tconst char *target = trnf_data->target;\n\tif (trnf_data->session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {\n\t\tast_log(LOG_ERROR, \"Session already DISCONNECTED [reason=%d (%s)]\\n\",\n\t\t\ttrnf_data->session->inv_session->cause,\n\t\t\tpjsip_get_status_text(trnf_data->session->inv_session->cause)->ptr);\n\t} else {\n\t\t\n\t\tendpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"endpoint\", target);\n\t\tif (endpoint) {\n\t\t\tcontact = ast_sip_location_retrieve_contact_from_aor_list(endpoint->aors);\n\t\t\tif (contact && !ast_strlen_zero(contact->uri)) {\n\t\t\t\ttarget = contact->uri;\n\t\t\t}\n\t\t}\n\t\tif (ast_channel_state(trnf_data->session->channel) == AST_STATE_RING) {\n\t\t\ttransfer_redirect(trnf_data->session, target);\n\t\t} else {\n\t\t\ttransfer_refer(trnf_data->session, target);\n\t\t}\n\t}\n#ifdef HAVE_PJSIP_INV_SESSION_REF\n\tpjsip_inv_dec_ref(trnf_data->session->inv_session);\n#endif\n\tao2_ref(trnf_data, -1);\n\tao2_cleanup(endpoint);\n\tao2_cleanup(contact);\n\treturn 0;\n}\n", "bug_type": null, "idx": 650}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_cli_formatter_entry *channel_formatter;\nint pjsip_channel_cli_register(void)\n{\n\tchannel_formatter = ao2_alloc(sizeof(struct ast_sip_cli_formatter_entry), NULL);\n\tif (!channel_formatter) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate memory for channel_formatter\\n\");\n\t\treturn -1;\n\t}\n\tchannel_formatter->name = \"channel\";\n\tchannel_formatter->print_header = cli_channel_print_header;\n\tchannel_formatter->print_body = cli_channel_print_body;\n\tchannel_formatter->get_container = cli_channel_get_container;\n\tchannel_formatter->iterate = cli_channel_iterate;\n\tchannel_formatter->retrieve_by_id = cli_channel_retrieve_by_id;\n\tchannel_formatter->get_id = cli_channel_get_id;\n\tchannelstats_formatter = ao2_alloc(sizeof(struct ast_sip_cli_formatter_entry), NULL);\n\tif (!channelstats_formatter) {\n\t\tao2_ref(channel_formatter, -1);\n\t\tast_log(LOG_ERROR, \"Unable to allocate memory for channelstats_formatter\\n\");\n\t\treturn -1;\n\t}\n\tchannelstats_formatter->name = \"channelstat\";\n\tchannelstats_formatter->print_header = cli_channelstats_print_header;\n\tchannelstats_formatter->print_body = cli_channelstats_print_body;\n\tchannelstats_formatter->get_container = cli_channelstats_get_container;\n\tchannelstats_formatter->iterate = cli_channelstats_iterate;\n\tchannelstats_formatter->retrieve_by_id = cli_channel_retrieve_by_id;\n\tchannelstats_formatter->get_id = cli_channel_get_id;\n\tast_sip_register_cli_formatter(channel_formatter);\n\tast_sip_register_cli_formatter(channelstats_formatter);\n\tast_cli_register_multiple(cli_commands, ARRAY_LEN(cli_commands));\n\treturn 0;\n}\n", "bug_type": null, "idx": 651}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum AST_REDIRECTING_REASON pri_to_ast_reason(int pri_reason)\n{\n\tenum AST_REDIRECTING_REASON ast_reason;\n\tswitch (pri_reason) {\n\tcase PRI_REDIR_FORWARD_ON_BUSY:\n\t\tast_reason = AST_REDIRECTING_REASON_USER_BUSY;\n\t\tbreak;\n\tcase PRI_REDIR_FORWARD_ON_NO_REPLY:\n\t\tast_reason = AST_REDIRECTING_REASON_NO_ANSWER;\n\t\tbreak;\n\tcase PRI_REDIR_DEFLECTION:\n\t\tast_reason = AST_REDIRECTING_REASON_DEFLECTION;\n\t\tbreak;\n\tcase PRI_REDIR_UNCONDITIONAL:\n\t\tast_reason = AST_REDIRECTING_REASON_UNCONDITIONAL;\n\t\tbreak;\n\tcase PRI_REDIR_UNKNOWN:\n\tdefault:\n\t\tast_reason = AST_REDIRECTING_REASON_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn ast_reason;\n}\n", "bug_type": null, "idx": 652}
{"project": "Asterisk", "target": 0, "func": "static struct ast_bridge_methods bridge_stasis_v_table;\nstatic void bridge_stasis_run_cb(struct ast_channel *chan, void *data)\n{\n\tRAII_VAR(char *, app_name, NULL, ast_free);\n\tstruct ast_app *app_stasis;\n\t\n\tapp_name = app_get_replace_channel_app(chan);\n\tif (!app_name) {\n\t\tast_log(LOG_ERROR, \"Failed to get app name for %s (%p)\\n\", ast_channel_name(chan), chan);\n\t\treturn;\n\t}\n\t\n\tapp_stasis = pbx_findapp(\"Stasis\");\n\tif (!app_stasis) {\n\t\tast_log(LOG_WARNING, \"Could not find application (Stasis)\\n\");\n\t\treturn;\n\t}\n\tif (ast_check_hangup_locked(chan)) {\n\t\t\n\t\treturn;\n\t}\n\t\n\tpbx_exec(chan, app_stasis, app_name);\n}\n", "bug_type": null, "idx": 653}
{"project": "Asterisk", "target": 0, "func": "static void dump_chan_list(struct misdn_stack *stack)\n{\n\tint i;\n\tfor (i = 0; i <= stack->b_num; ++i) {\n\t\tcb_log(6, stack->port, \"Idx:%d stack->cchan:%d in_use:%d Chan:%d\\n\",\n\t\t\ti, stack->channels[i], stack->bc[i].in_use, i + 1);\n\t}\n#if defined(AST_MISDN_ENHANCEMENTS)\n\tfor (i = MAX_BCHANS + 1; i < ARRAY_LEN(stack->bc); ++i) {\n\t\tif (stack->bc[i].in_use) {\n\t\t\tcb_log(6, stack->port, \"Idx:%d stack->cchan:%d REGISTER Chan:%d in_use\\n\",\n\t\t\t\ti, stack->channels[i], i + 1);\n\t\t}\n\t}\n#endif\t\n}\n", "bug_type": null, "idx": 654}
{"project": "Asterisk", "target": 0, "func": "\nstatic void microphone_mute_toggle(struct unistimsession *pte)\n{\n\tif (pte->device->microphone == MUTE_OFF) {\n\t\tpte->device->microphone = MUTE_ON;\n\t\tsend_led_update(pte, LED_MUTE_ON);\n\t} else if (pte->device->microphone == MUTE_ON) {\n\t\tpte->device->microphone = MUTE_OFF;\n\t\tsend_led_update(pte, LED_MUTE_OFF);\n\t}\n\tsend_mute(pte, (pte->device->microphone & 0x01));\n}\n", "bug_type": null, "idx": 655}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint i;\n\tslin_f.format = ast_format_slin;\n\tslin12_f.format = ast_format_slin12;\n\tslin16_f.format = ast_format_slin16;\n\tslin24_f.format = ast_format_slin24;\n\tslin32_f.format = ast_format_slin32;\n\tslin44_f.format = ast_format_slin44;\n\tslin48_f.format = ast_format_slin48;\n\tslin96_f.format = ast_format_slin96;\n\tslin192_f.format = ast_format_slin192;\n\tfor (i = 0; i < ARRAY_LEN(slin_list); i++) {\n\t\tif (ast_format_def_register(slin_list[i])) {\n\t\t\tunload_module();\n\t\t\treturn AST_MODULE_LOAD_DECLINE;\n\t\t}\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 656}
{"project": "Asterisk", "target": 0, "func": "static void recording_set_state(struct stasis_app_recording *recording,\n\t\t\t\tenum stasis_app_recording_state state,\n\t\t\t\tconst char *cause)\n{\n\tSCOPED_AO2LOCK(lock, recording);\n\trecording->state = state;\n\trecording_publish(recording, cause);\n}\n", "bug_type": null, "idx": 657}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_set_caller_event(struct ast_channel *chan, const struct ast_party_caller *caller, const struct ast_set_party_caller *update)\n{\n\tif (ast_channel_caller(chan) == caller) {\n\t\t\n\t\treturn;\n\t}\n\tast_channel_lock(chan);\n\tast_party_caller_set(ast_channel_caller(chan), caller, update);\n\tast_channel_publish_snapshot(chan);\n\tast_channel_unlock(chan);\n}\n", "bug_type": null, "idx": 658}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void rtp_codecs_payloads_copy_tx(struct ast_rtp_codecs *src, struct ast_rtp_codecs *dest, struct ast_rtp_instance *instance)\n{\n\tint idx;\n\tstruct ast_rtp_payload_type *type;\n\tfor (idx = 0; idx < AST_VECTOR_SIZE(&src->payload_mapping_tx); ++idx) {\n\t\ttype = AST_VECTOR_GET(&src->payload_mapping_tx, idx);\n\t\tif (!type) {\n\t\t\tcontinue;\n\t\t}\n\t\tast_debug(2, \"Copying tx payload mapping %d (%p) from %p to %p\\n\",\n\t\t\tidx, type, src, dest);\n\t\tao2_ref(type, +1);\n\t\tif (idx < AST_VECTOR_SIZE(&dest->payload_mapping_tx)) {\n\t\t\tao2_t_cleanup(AST_VECTOR_GET(&dest->payload_mapping_tx, idx),\n\t\t\t\t\"cleaning up tx mapping vector element about to be replaced\");\n\t\t}\n\t\tAST_VECTOR_REPLACE(&dest->payload_mapping_tx, idx, type);\n\t\tif (instance && instance->engine && instance->engine->payload_set) {\n\t\t\tao2_lock(instance);\n\t\t\tinstance->engine->payload_set(instance, idx, type->asterisk_format, type->format, type->rtp_code);\n\t\t\tao2_unlock(instance);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 659}
{"project": "Asterisk", "target": 0, "func": "static void *test_item_alloc(const char *cat)\n{\n\tstruct test_item *item;\n\tif (!(item = ao2_alloc(sizeof(*item), test_item_destructor))) {\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(item, 128)) {\n\t\tao2_ref(item, -1);\n\t\treturn NULL;\n\t}\n\tif (!(item->codeccapopt = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {\n\t\tao2_ref(item, -1);\n\t\treturn NULL;\n\t}\n\tast_string_field_set(item, name, cat);\n\treturn item;\n}\n", "bug_type": null, "idx": 660}
{"project": "Asterisk", "target": 0, "func": "struct ast_rtp_instance *ast_sdp_state_get_rtp_instance(\n\tconst struct ast_sdp_state *sdp_state, int stream_index)\n{\n\tstruct sdp_state_stream *stream_state;\n\tast_assert(sdp_state != NULL);\n\tast_assert(ast_stream_get_type(ast_stream_topology_get_stream(sdp_state->proposed_capabilities->topology,\n\t\tstream_index)) == AST_MEDIA_TYPE_AUDIO || ast_stream_get_type(ast_stream_topology_get_stream(\n\t\t\tsdp_state->proposed_capabilities->topology, stream_index)) == AST_MEDIA_TYPE_VIDEO);\n\tstream_state = sdp_state_get_stream(sdp_state, stream_index);\n\tif (!stream_state || !stream_state->rtp) {\n\t\treturn NULL;\n\t}\n\treturn stream_state->rtp->instance;\n}\n", "bug_type": null, "idx": 661}
{"project": "Asterisk", "target": 0, "func": "char *\nusername_completion_function(const char *text, int state)\n{\n\tstruct passwd *pwd;\n\tif (text[0] == '\\0')\n\t\treturn (NULL);\n\tif (*text == '~')\n\t\ttext++;\n\tif (state == 0)\n\t\tsetpwent();\n\twhile ((pwd = getpwent()) && text[0] == pwd->pw_name[0]\n\t    && strcmp(text, pwd->pw_name) == 0);\n\tif (pwd == NULL) {\n\t\tendpwent();\n\t\treturn (NULL);\n\t}\n\treturn (strdup(pwd->pw_name));\n}\n", "bug_type": null, "idx": 662}
{"project": "Asterisk", "target": 0, "func": "#line 656 \"ael.flex\"\nstatic void pbcpush(char x)\n{\n\tpbcstack[pbcpos++] = x;\n}\n", "bug_type": null, "idx": 663}
{"project": "Asterisk", "target": 0, "func": "static void display_parking_lot(struct parking_lot *lot, int fd)\n{\n\tast_cli(fd, \"Parking Lot: %s\\n--------------------------------------------------------------------------\\n\", lot->name);\n\tast_cli(fd, \"Parking Extension   :  %s\\n\", lot->cfg->parkext);\n\tast_cli(fd, \"Parking Context     :  %s\\n\", lot->cfg->parking_con);\n\tast_cli(fd, \"Parking Spaces      :  %d-%d\\n\", lot->cfg->parking_start, lot->cfg->parking_stop);\n\tast_cli(fd, \"Parking Time        :  %u sec\\n\", lot->cfg->parkingtime);\n\tast_cli(fd, \"Comeback to Origin  :  %s\\n\", lot->cfg->comebacktoorigin ? \"yes\" : \"no\");\n\tast_cli(fd, \"Comeback Context    :  %s%s\\n\", lot->cfg->comebackcontext, lot->cfg->comebacktoorigin ? \" (comebacktoorigin=yes, not used)\" : \"\");\n\tast_cli(fd, \"Comeback Dial Time  :  %u sec\\n\", lot->cfg->comebackdialtime);\n\tast_cli(fd, \"MusicOnHold Class   :  %s\\n\", lot->cfg->mohclass);\n\tast_cli(fd, \"Enabled             :  %s\\n\", (lot->mode == PARKINGLOT_DISABLED) ? \"no\" : \"yes\");\n\tast_cli(fd, \"Dynamic             :  %s\\n\", (lot->mode == PARKINGLOT_DYNAMIC) ? \"yes\" : \"no\");\n\tast_cli(fd, \"\\n\");\n}\n", "bug_type": null, "idx": 664}
{"project": "Asterisk", "target": 0, "func": "static int reload(void)\n{\n\tparse_config(1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 665}
{"project": "Asterisk", "target": 0, "func": "struct ast_party_dialed *ast_channel_dialed(struct ast_channel *chan)\n{\n\treturn &chan->dialed;\n}\n", "bug_type": null, "idx": 666}
{"project": "Asterisk", "target": 0, "func": " */\nvoid ast_dial_set_timeout(struct ast_dial *dial, int num, int timeout)\n{\n\tstruct ast_dial_channel *channel = NULL;\n\tif (!(channel = find_dial_channel(dial, num)))\n\t\treturn;\n\tchannel->timeout = timeout;\n\tif (channel->timeout > 0 && (dial->actual_timeout > channel->timeout || dial->actual_timeout == -1))\n\t\tdial->actual_timeout = channel->timeout;\n\treturn;\n}\n", "bug_type": null, "idx": 667}
{"project": "Asterisk", "target": 0, "func": "\n int dcbias_(integer *len, real *speech, real *sigout)\n{\n    \n    integer i__1;\n    \n    real bias;\n    integer i__;\n\n\n    \n    --sigout;\n    --speech;\n    \n    bias = 0.f;\n    i__1 = *len;\n    for (i__ = 1; i__ <= i__1; ++i__) {\n\tbias += speech[i__];\n    }\n    bias /= *len;\n    i__1 = *len;\n    for (i__ = 1; i__ <= i__1; ++i__) {\n\tsigout[i__] = speech[i__] - bias;\n    }\n    return 0;\n} \n", "bug_type": null, "idx": 668}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct mysql_conn *find_database(const char *database, int for_write)\n{\n\tchar *whichdb;\n\tconst char *ptr;\n\tstruct mysql_conn *cur;\n\tif ((ptr = strchr(database, '/'))) {\n\t\t\n\t\tif (for_write) {\n\t\t\twhichdb = ast_strdupa(ptr + 1);\n\t\t} else {\n\t\t\twhichdb = ast_alloca(ptr - database + 1);\n\t\t\tstrncpy(whichdb, database, ptr - database);\n\t\t\twhichdb[ptr - database] = '\\0';\n\t\t}\n\t} else {\n\t\twhichdb = ast_strdupa(database);\n\t}\n\tAST_RWLIST_RDLOCK(&databases);\n\tAST_RWLIST_TRAVERSE(&databases, cur, list) {\n\t\tif (!strcmp(cur->unique_name, whichdb)) {\n\t\t\tast_mutex_lock(&cur->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&databases);\n\treturn cur;\n}\n", "bug_type": null, "idx": 669}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int acf_odbc_write(struct ast_channel *chan, const char *cmd, char *s, const char *value)\n{\n\tstruct odbc_obj *obj = NULL;\n\tstruct acf_odbc_query *query;\n\tchar *t, varname[15];\n\tint i, dsn_num, bogus_chan = 0;\n\tint transactional = 0;\n\tAST_DECLARE_APP_ARGS(values,\n\t\tAST_APP_ARG(field)[100];\n\t);\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(field)[100];\n\t);\n\tSQLHSTMT stmt = NULL;\n\tSQLLEN rows=0;\n\tstruct ast_str *buf = ast_str_thread_get(&sql_buf, 16);\n\tstruct ast_str *insertbuf = ast_str_thread_get(&sql2_buf, 16);\n\tconst char *status = \"FAILURE\";\n\tstruct dsn *dsn = NULL;\n\tif (!buf || !insertbuf) {\n\t\treturn -1;\n\t}\n\tAST_RWLIST_RDLOCK(&queries);\n\tAST_RWLIST_TRAVERSE(&queries, query, list) {\n\t\tif (!strcmp(query->acf->name, cmd)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!query) {\n\t\tast_log(LOG_ERROR, \"No such function '%s'\\n\", cmd);\n\t\tAST_RWLIST_UNLOCK(&queries);\n\t\tif (chan) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBCSTATUS\", status);\n\t\t}\n\t\treturn -1;\n\t}\n\tif (!chan) {\n\t\tif (!(chan = ast_dummy_channel_alloc())) {\n\t\t\tAST_RWLIST_UNLOCK(&queries);\n\t\t\treturn -1;\n\t\t}\n\t\tbogus_chan = 1;\n\t}\n\tif (!bogus_chan) {\n\t\tast_autoservice_start(chan);\n\t}\n\tast_str_make_space(&buf, strlen(query->sql_write) * 2 + 300);\n\t\n\tif (query->sql_insert) {\n\t\tast_str_make_space(&insertbuf, strlen(query->sql_insert) * 2 + 300);\n\t}\n\t\n\tt = value ? ast_strdupa(value) : \"\";\n\tif (!s || !t) {\n\t\tast_log(LOG_ERROR, \"Out of memory\\n\");\n\t\tAST_RWLIST_UNLOCK(&queries);\n\t\tif (!bogus_chan) {\n\t\t\tast_autoservice_stop(chan);\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBCSTATUS\", status);\n\t\t} else {\n\t\t\tast_channel_unref(chan);\n\t\t}\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, s);\n\tfor (i = 0; i < args.argc; i++) {\n\t\tsnprintf(varname, sizeof(varname), \"ARG%d\", i + 1);\n\t\tpbx_builtin_pushvar_helper(chan, varname, args.field[i]);\n\t}\n\t\n\tAST_STANDARD_APP_ARGS(values, t);\n\tfor (i = 0; i < values.argc; i++) {\n\t\tsnprintf(varname, sizeof(varname), \"VAL%d\", i + 1);\n\t\tpbx_builtin_pushvar_helper(chan, varname, values.field[i]);\n\t}\n\t\n\tpbx_builtin_pushvar_helper(chan, \"VALUE\", value ? value : \"\");\n\tast_str_substitute_variables(&buf, 0, chan, query->sql_write);\n\tif (query->sql_insert) {\n\t\tast_str_substitute_variables(&insertbuf, 0, chan, query->sql_insert);\n\t}\n\tif (bogus_chan) {\n\t\tchan = ast_channel_unref(chan);\n\t} else {\n\t\t\n\t\tfor (i = 0; i < args.argc; i++) {\n\t\t\tsnprintf(varname, sizeof(varname), \"ARG%d\", i + 1);\n\t\t\tpbx_builtin_setvar_helper(chan, varname, NULL);\n\t\t}\n\t\tfor (i = 0; i < values.argc; i++) {\n\t\t\tsnprintf(varname, sizeof(varname), \"VAL%d\", i + 1);\n\t\t\tpbx_builtin_setvar_helper(chan, varname, NULL);\n\t\t}\n\t\tpbx_builtin_setvar_helper(chan, \"VALUE\", NULL);\n\t}\n\t\n\tfor (dsn_num = 0; dsn_num < 5; dsn_num++) {\n\t\tif (!ast_strlen_zero(query->writehandle[dsn_num])) {\n\t\t\tif (transactional) {\n\t\t\t\t\n\t\t\t\tast_log(LOG_WARNING, \"Transactions do not work well with multiple DSNs for 'writehandle'\\n\");\n\t\t\t}\n\t\t\tif ((obj = ast_odbc_retrieve_transaction_obj(chan, query->writehandle[dsn_num]))) {\n\t\t\t\ttransactional = 1;\n\t\t\t} else {\n\t\t\t\tobj = get_odbc_obj(query->writehandle[dsn_num], &dsn);\n\t\t\t\ttransactional = 0;\n\t\t\t}\n\t\t\tif (obj && (stmt = ast_odbc_direct_execute(obj, generic_execute, ast_str_buffer(buf)))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!transactional) {\n\t\t\t\trelease_obj_or_dsn (&obj, &dsn);\n\t\t\t}\n\t\t}\n\t}\n\tif (stmt) {\n\t\tSQLRowCount(stmt, &rows);\n\t\tSQLCloseCursor(stmt);\n\t\tSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n\t\tif (rows != 0) {\n\t\t\tstatus = \"SUCCESS\";\n\t\t} else if (query->sql_insert) {\n\t\t\tif (!transactional) {\n\t\t\t\trelease_obj_or_dsn (&obj, &dsn);\n\t\t\t}\n\t\t\tfor (transactional = 0, dsn_num = 0; dsn_num < 5; dsn_num++) {\n\t\t\t\tif (!ast_strlen_zero(query->writehandle[dsn_num])) {\n\t\t\t\t\tif (transactional) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Transactions do not work well with multiple DSNs for 'writehandle'\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\trelease_obj_or_dsn (&obj, &dsn);\n\t\t\t\t\t}\n\t\t\t\t\tif ((obj = ast_odbc_retrieve_transaction_obj(chan, query->writehandle[dsn_num]))) {\n\t\t\t\t\t\ttransactional = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj = get_odbc_obj(query->writehandle[dsn_num], &dsn);\n\t\t\t\t\t\ttransactional = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (obj) {\n\t\t\t\t\t\tstmt = ast_odbc_direct_execute(obj, generic_execute, ast_str_buffer(insertbuf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stmt) {\n\t\t\t\t\tstatus = \"FAILOVER\";\n\t\t\t\t\tSQLRowCount(stmt, &rows);\n\t\t\t\t\tSQLCloseCursor(stmt);\n\t\t\t\t\tSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&queries);\n\t\n\tif (!bogus_chan) {\n\t\tsnprintf(varname, sizeof(varname), \"%d\", (int)rows);\n\t\tpbx_builtin_setvar_helper(chan, \"ODBCROWS\", varname);\n\t\tpbx_builtin_setvar_helper(chan, \"ODBCSTATUS\", status);\n\t}\n\tif (!transactional) {\n\t\trelease_obj_or_dsn (&obj, &dsn);\n\t}\n\tif (!bogus_chan) {\n\t\tast_autoservice_stop(chan);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 670}
{"project": "Asterisk", "target": 0, "func": "\nint AST_OPTIONAL_API_NAME(ast_monitor_pause)(struct ast_channel *chan)\n{\n\treturn ast_monitor_set_state(chan, AST_MONITOR_PAUSED);\n}\n", "bug_type": null, "idx": 671}
{"project": "Asterisk", "target": 0, "func": "protected void\nmap_init_vi(EditLine *el)\n{\n\tint i;\n\tel_action_t *key = el->el_map.key;\n\tel_action_t *alt = el->el_map.alt;\n\tconst el_action_t *vii = el->el_map.vii;\n\tconst el_action_t *vic = el->el_map.vic;\n\tel->el_map.type = MAP_VI;\n\tel->el_map.current = el->el_map.key;\n\tkey_reset(el);\n\tfor (i = 0; i < N_KEYS; i++) {\n\t\tkey[i] = vii[i];\n\t\talt[i] = vic[i];\n\t}\n\tmap_init_meta(el);\n\tmap_init_nls(el);\n\ttty_bind_char(el, 1);\n\tterm_bind_arrow(el);\n}\n", "bug_type": null, "idx": 672}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245MaintenanceLoopAck (OOCTXT* pctxt, H245MaintenanceLoopAck* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"type\", -1);\n   stat = asn1PD_H245MaintenanceLoopAck_type (pctxt, &pvalue->type);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"type\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 673}
{"project": "Asterisk", "target": 0, "func": "static void sched_thread_destroy(struct ast_sched_context *con)\n{\n\tif (!con->sched_thread) {\n\t\treturn;\n\t}\n\tif (con->sched_thread->thread != AST_PTHREADT_NULL) {\n\t\tast_mutex_lock(&con->lock);\n\t\tcon->sched_thread->stop = 1;\n\t\tast_cond_signal(&con->sched_thread->cond);\n\t\tast_mutex_unlock(&con->lock);\n\t\tpthread_join(con->sched_thread->thread, NULL);\n\t\tcon->sched_thread->thread = AST_PTHREADT_NULL;\n\t}\n\tast_cond_destroy(&con->sched_thread->cond);\n\tast_free(con->sched_thread);\n\tcon->sched_thread = NULL;\n}\n", "bug_type": null, "idx": 674}
{"project": "Asterisk", "target": 0, "func": "int ooCallAddRemoteAliasDialedDigits\n   (OOH323CallData *call, const char* dialedDigits)\n{\n   return ooCallAddAlias\n              (call, T_H225AliasAddress_dialedDigits, dialedDigits, FALSE);\n}\n", "bug_type": null, "idx": 675}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int lua_set_variable_value(lua_State *L)\n{\n\tconst char *name, *value;\n\tstruct ast_channel *chan;\n\tint autoservice;\n\tif (!lua_istable(L, 1)) {\n\t\tlua_pushstring(L, \"User probably used '.' instead of ':' for setting a channel variable\");\n\t\treturn lua_error(L);\n\t}\n\tlua_getfield(L, 1, \"name\");\n\tname = ast_strdupa(lua_tostring(L, -1));\n\tlua_pop(L, 1);\n\tvalue = luaL_checkstring(L, 2);\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"channel\");\n\tchan = lua_touserdata(L, -1);\n\tlua_pop(L, 1);\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"autoservice\");\n\tautoservice = lua_toboolean(L, -1);\n\tlua_pop(L, 1);\n\tif (autoservice)\n\t\tast_autoservice_stop(chan);\n\tpbx_builtin_setvar_helper(chan, name, value);\n\tif (autoservice)\n\t\tast_autoservice_start(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 676}
{"project": "Asterisk", "target": 0, "func": "int app_unsubscribe_channel(struct stasis_app *app, struct ast_channel *chan)\n{\n\tif (!app) {\n\t\treturn -1;\n\t}\n\treturn app_unsubscribe_channel_id(app, chan ? ast_channel_uniqueid(chan) : CHANNEL_ALL);\n}\n", "bug_type": null, "idx": 677}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int asterisk_publication_new(struct ast_sip_endpoint *endpoint, const char *resource, const char *event_configuration)\n{\n\tRAII_VAR(struct asterisk_publication_config *, config, ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"asterisk-publication\",\n\t\tevent_configuration), ao2_cleanup);\n\t\n\tif (!config) {\n\t\treturn 404;\n\t}\n\treturn 200;\n}\n", "bug_type": null, "idx": 678}
{"project": "Asterisk", "target": 0, "func": "static void rcv_mac_addr(struct unistimsession *pte, const unsigned char *buf)\n{\n\tBUFFSEND;\n\tint tmp, i = 0;\n\tchar addrmac[19];\n\tint res = 0;\n\tfor (tmp = 15; tmp < 15 + SIZE_HEADER; tmp++) {\n\t\tsprintf(&addrmac[i], \"%02hhx\", buf[tmp]);\n\t\ti += 2;\n\t}\n\tif (unistimdebug) {\n\t\tast_verb(0, \"MAC Address received: %s\\n\", addrmac);\n\t}\n\tstrcpy(pte->macaddr, addrmac);\n\tres = unistim_register(pte);\n\tif (!res) {\n\t\tswitch (autoprovisioning) {\n\t\tcase AUTOPROVISIONING_NO:\n\t\t\tast_log(LOG_WARNING, \"No entry found for this phone : %s\\n\", addrmac);\n\t\t\tpte->state = STATE_AUTHDENY;\n\t\t\tbreak;\n\t\tcase AUTOPROVISIONING_YES:\n\t\t\t{\n\t\t\t\tstruct unistim_device *d = NULL, *newd = NULL;\n\t\t\t\tstruct unistim_line *newl = NULL, *l = NULL;\n\t\t\t\tif (unistimdebug) {\n\t\t\t\t\tast_verb(0, \"New phone, autoprovisioning on\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tast_mutex_lock(&devicelock);\n\t\t\t\td = devices;\n\t\t\t\twhile (d) {\n\t\t\t\t\tif (strcasecmp(d->name, \"template\")) {\n\t\t\t\t\t\td = d->next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!(newd = ast_malloc(sizeof(*newd)))) {\n\t\t\t\t\t\tast_mutex_unlock(&devicelock);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(newd, d, sizeof(*newd));\n\t\t\t\t\tast_mutex_init(&newd->lock);\n\t\t\t\t\tnewd->lines.first = NULL;\n\t\t\t\t\tnewd->lines.last = NULL;\n\t\t\t\t\tAST_LIST_LOCK(&d->lines);\n\t\t\t\t\tAST_LIST_TRAVERSE(&d->lines, l, list) {\n\t\t\t\t\t\tif (!(newl = unistim_line_alloc())) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunistim_line_copy(l, newl);\n\t\t\t\t\t\tnewl->parent = newd;\n\t\t\t\t\t\tast_copy_string(newl->name, l->name, sizeof(newl->name));\n\t\t\t\t\t\tsnprintf(newl->fullname, sizeof(newl->fullname), \"USTM/%s@%s\",\n\t\t\t\t\t\t\t\t newl->name, newd->name);\n\t\t\t\t\t\tsnprintf(l->name, sizeof(l->name), \"%d\", atoi(l->name) + 1);\n\t\t\t\t\t\tAST_LIST_LOCK(&newd->lines);\n\t\t\t\t\t\tAST_LIST_INSERT_TAIL(&newd->lines, newl, list);\n\t\t\t\t\t\tAST_LIST_UNLOCK(&newd->lines);\n\t\t\t\t\t}\n\t\t\t\t\tAST_LIST_UNLOCK(&d->lines);\n\t\t\t\t\tif (!newl) {\n\t\t\t\t\t\tast_free(newd);\n\t\t\t\t\t\tast_mutex_unlock(&devicelock);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tast_copy_string(newd->id, addrmac, sizeof(newd->id));\n\t\t\t\t\tast_copy_string(newd->name, addrmac, sizeof(newd->name));\n\t\t\t\t\tif (newd->extension == EXTENSION_NONE) {\n\t\t\t\t\t\tnewd->extension = EXTENSION_ASK;\n\t\t\t\t\t}\n\t\t\t\t\tnewd->receiver_state = STATE_ONHOOK;\n\t\t\t\t\tnewd->session = pte;\n\t\t\t\t\tnewd->language[0] = '\\0';\n\t\t\t\t\tnewd->to_delete = -1;\n\t\t\t\t\tnewd->next = NULL;\n\t\t\t\t\tpte->device = newd;\n\t\t\t\t\t\n\t\t\t\t\twhile (d->next) {\n\t\t\t\t\t\td = d->next;\n\t\t\t\t\t}\n\t\t\t\t\td->next = newd;\n\t\t\t\t\td = newd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tast_mutex_unlock(&devicelock);\n\t\t\t\tif (!d) {\n\t\t\t\t\tast_log(LOG_WARNING, \"No entry [template] found in unistim.conf\\n\");\n\t\t\t\t\tpte->state = STATE_AUTHDENY;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUTOPROVISIONING_TN:\n\t\t\tpte->state = STATE_AUTHDENY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_WARNING, \"Internal error : unknown autoprovisioning value = %u\\n\",\n\t\t\t\t\tautoprovisioning);\n\t\t}\n\t}\n\tif (pte->state != STATE_AUTHDENY) {\n\t\tstruct unistim_line *line;\n\t\tstruct unistim_subchannel *sub;\n\t\tast_verb(3, \"Device '%s' successfuly registered\\n\", pte->device->name);\n\t\tAST_LIST_LOCK(&pte->device->subs);\n\t\tAST_LIST_TRAVERSE_SAFE_BEGIN(&pte->device->subs, sub, list) {\n\t\t\tif (sub) {\n\t\t\t\tast_log(LOG_ERROR, \"Subchannel lost sice reboot. Hanged channel may apear!\\n\");\n\t\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\t\tast_free(sub);\n\t\t\t}\n\t\t}\n\t\tAST_LIST_TRAVERSE_SAFE_END;\n\t\tAST_LIST_UNLOCK(&pte->device->subs);\n\t\tswitch (pte->device->extension) {\n\t\tcase EXTENSION_NONE:\n\t\t\tpte->state = STATE_MAINPAGE;\n\t\t\tbreak;\n\t\tcase EXTENSION_ASK:\n\t\t\t\n\t\t\tif (ast_strlen_zero(pte->device->extension_number)) {\n\t\t\t\tpte->state = STATE_EXTENSION;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (register_extension(pte)) {\n\t\t\t\t\tpte->state = STATE_EXTENSION;\n\t\t\t\t} else {\n\t\t\t\t\tpte->state = STATE_MAINPAGE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXTENSION_LINE:\n\t\t\tline = AST_LIST_FIRST(&pte->device->lines);\n\t\t\tast_copy_string(pte->device->extension_number, line->name,\n\t\t\t\t\t\t\tsizeof(pte->device->extension_number));\n\t\t\tif (register_extension(pte)) {\n\t\t\t\tpte->state = STATE_EXTENSION;\n\t\t\t} else {\n\t\t\t\tpte->state = STATE_MAINPAGE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXTENSION_TN:\n\t\t\t\n\t\t\tpte->state = STATE_MAINPAGE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_WARNING, \"Internal error, extension value unknown : %u\\n\",\n\t\t\t\t\tpte->device->extension);\n\t\t\tpte->state = STATE_AUTHDENY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pte->state == STATE_EXTENSION) {\n\t\tif (pte->device->extension != EXTENSION_TN) {\n\t\t\tpte->device->extension = EXTENSION_ASK;\n\t\t}\n\t\tpte->device->extension_number[0] = '\\0';\n\t}\n\tif (unistimdebug) {\n\t\tast_verb(0, \"\\nSending S1\\n\");\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_S1, sizeof(packet_send_S1));\n\tsend_client(SIZE_HEADER + sizeof(packet_send_S1), buffsend, pte);\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending query_basic_manager_04\\n\");\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_query_basic_manager_04,\n\t\t   sizeof(packet_send_query_basic_manager_04));\n\tsend_client(SIZE_HEADER + sizeof(packet_send_query_basic_manager_04), buffsend, pte);\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending query_basic_manager_10\\n\");\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_query_basic_manager_10,\n\t\t   sizeof(packet_send_query_basic_manager_10));\n\tsend_client(SIZE_HEADER + sizeof(packet_send_query_basic_manager_10), buffsend, pte);\n\tsend_date_time(pte);\n\treturn;\n}\n", "bug_type": null, "idx": 679}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_rtp_lookup_sample_rate2(int asterisk_format,\n\tconst struct ast_format *format, int code)\n{\n\tunsigned int i;\n\tunsigned int res = 0;\n\tast_rwlock_rdlock(&mime_types_lock);\n\tfor (i = 0; i < mime_types_len; ++i) {\n\t\tif (ast_rtp_mime_types[i].payload_type.asterisk_format && asterisk_format && format &&\n\t\t\t(ast_format_cmp(format, ast_rtp_mime_types[i].payload_type.format) != AST_FORMAT_CMP_NOT_EQUAL)) {\n\t\t\tres = ast_rtp_mime_types[i].sample_rate;\n\t\t\tbreak;\n\t\t} else if (!ast_rtp_mime_types[i].payload_type.asterisk_format && !asterisk_format &&\n\t\t\tast_rtp_mime_types[i].payload_type.rtp_code == code) {\n\t\t\tres = ast_rtp_mime_types[i].sample_rate;\n\t\t\tbreak;\n\t\t}\n\t}\n\tast_rwlock_unlock(&mime_types_lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 680}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void message_playback_callback_fn(struct ast_channel *chan, const char *file, int duration)\n{\n\tif ((chan) && !ast_strlen_zero(file) && duration > 0) {\n\t\tglobal_entered_playback_callback = 1;\n\t} else {\n\t\tast_log(AST_LOG_WARNING, \"Entered into message playback callback function with invalid parameters\\n\");\n\t}\n}\n", "bug_type": null, "idx": 681}
{"project": "Asterisk", "target": 0, "func": "void *__ao2_callback_data(struct ao2_container *c, enum search_flags flags,\n\tao2_callback_data_fn *cb_fn, void *arg, void *data, const char *tag, const char *file,\n\tint line, const char *func)\n{\n\treturn internal_ao2_traverse(c, flags, cb_fn, arg, data, AO2_CALLBACK_WITH_DATA, tag, file, line, func);\n}\n", "bug_type": null, "idx": 682}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225NonStandardProtocol (OOCTXT* pctxt, H225NonStandardProtocol* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.nonStandardDataPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.dataRatesSupportedPresent);\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      stat = asn1PE_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.dataRatesSupportedPresent) {\n      stat = asn1PE_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = asn1PE_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 683}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void mwi_mailbox_delete_all(struct ao2_container *mailboxes)\n{\n\tstruct ast_mwi_mailbox_object *mailbox;\n\tstruct ao2_iterator iter;\n\titer = ao2_iterator_init(mailboxes, AO2_ITERATOR_UNLINK);\n\tfor (; (mailbox = ao2_iterator_next(&iter)); ast_mwi_mailbox_unref(mailbox)) {\n\t\tmwi_mailbox_delete(mailbox);\n\t}\n\tao2_iterator_destroy(&iter);\n}\n", "bug_type": null, "idx": 684}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tparse_config(0);\n\tast_config_engine_register(&mysql_engine);\n\tast_verb(2, \"MySQL RealTime driver loaded.\\n\");\n\tast_cli_register_multiple(cli_realtime_mysql_status, sizeof(cli_realtime_mysql_status) / sizeof(struct ast_cli_entry));\n\treturn 0;\n}\n", "bug_type": null, "idx": 685}
{"project": "Asterisk", "target": 0, "func": "static int test_sort_cb(const void *obj_left, const void *obj_right, int flags)\n{\n\tconst struct test_obj *test_left = obj_left;\n\tif (flags & OBJ_KEY) {\n\t\tconst int *i = obj_right;\n\t\treturn test_left->i - *i;\n\t} else if (flags & OBJ_PARTIAL_KEY) {\n\t\tint *i = (int *) obj_right;\n\t\tif (*i - partial_key_match_range <= test_left->i\n\t\t\t&& test_left->i <= *i + partial_key_match_range) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn test_left->i - *i;\n\t} else {\n\t\tconst struct test_obj *test_right = obj_right;\n\t\treturn test_left->i - test_right->i;\n\t}\n}\n", "bug_type": null, "idx": 686}
{"project": "Asterisk", "target": 0, "func": "static unsigned int hashtab_hash_labels(const void *obj)\n{\n\tconst struct ast_exten *ac = obj;\n\treturn ast_hashtab_hash_string(S_OR(ac->label, \"\"));\n}\n", "bug_type": null, "idx": 687}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225AlternateGK (OOCTXT* pctxt, H225AlternateGK* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.gatekeeperIdentifierPresent);\n   \n   stat = asn1PE_H225TransportAddress (pctxt, &pvalue->rasAddress);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.gatekeeperIdentifierPresent) {\n      stat = asn1PE_H225GatekeeperIdentifier (pctxt, pvalue->gatekeeperIdentifier);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->needToRegister);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->priority, 0U, 127U);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 688}
{"project": "Asterisk", "target": 0, "func": "ari_validator ast_ari_validate_application_replaced_fn(void)\n{\n\treturn ast_ari_validate_application_replaced;\n}\n", "bug_type": null, "idx": 689}
{"project": "Asterisk", "target": 0, "func": "static int check_for_conference(struct dahdi_pvt *p);\nstatic int my_check_for_conference(void *pvt)\n{\n\tstruct dahdi_pvt *p = pvt;\n\treturn check_for_conference(p);\n}\n", "bug_type": null, "idx": 690}
{"project": "Asterisk", "target": 0, "func": "static void t38_parameters_fax_to_ast(struct ast_control_t38_parameters *dst, const struct ast_fax_t38_parameters *src)\n{\n\tdst->version = src->version;\n\tdst->max_ifp = src->max_ifp;\n\tdst->rate = src->rate;\n\tdst->rate_management = src->rate_management;\n\tdst->fill_bit_removal = src->fill_bit_removal;\n\tdst->transcoding_mmr = src->transcoding_mmr;\n\tdst->transcoding_jbig = src->transcoding_jbig;\n}\n", "bug_type": null, "idx": 691}
{"project": "Asterisk", "target": 0, "func": "int ast_isphonenumber(const char *n)\n{\n\treturn ast_is_valid_string(n, \"0123456789*#+\");\n}\n", "bug_type": null, "idx": 692}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function denoise_function = {\n\t.name = \"DENOISE\",\n\t.write = speex_write,\n\t.read = speex_read,\n\t.read_max = 22,\n};\n};\nstatic struct ast_custom_function denoise_function = {\n\t.name = \"DENOISE\",\n\t.write = speex_write,\n\t.read = speex_read,\n\t.read_max = 22,\n};\nstatic int unload_module(void)\n{\n\tast_custom_function_unregister(&agc_function);\n\tast_custom_function_unregister(&denoise_function);\n\treturn 0;\n}\nstatic int load_module(void)\n{\n\tif (ast_custom_function_register(&agc_function)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (ast_custom_function_register(&denoise_function)) {\n\t\tast_custom_function_unregister(&agc_function);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"Noise reduction and Automatic Gain Control (AGC)\");\n", "bug_type": null, "idx": 693}
{"project": "Asterisk", "target": 0, "func": "static int mp3_squeue(struct ast_filestream *s)\n{\n\tstruct mp3_private *p = s->_private;\n\tint res=0;\n\tres = ftell(s->f);\n\tp->sbuflen = fread(p->sbuf, 1, MP3_SCACHE, s->f);\n\tif (p->sbuflen < MP3_SCACHE) {\n\t\tif (ferror(s->f)) {\n\t\t\tast_log(LOG_WARNING, \"Error while reading MP3 file: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tres = decodeMP3(&p->mp,p->sbuf,p->sbuflen,p->dbuf,MP3_DCACHE,&p->dbuflen);\n\tif(res != MP3_OK)\n\t\treturn -1;\n\tp->sbuflen -= p->dbuflen;\n\tp->dbufoffset = 0;\n\treturn 0;\n}\n", "bug_type": null, "idx": 694}
{"project": "Asterisk", "target": 0, "func": "static void my_set_cadence(void *pvt, int *cid_rings, struct ast_channel *ast)\n{\n\tstruct dahdi_pvt *p = pvt;\n\t\n\tif ((p->distinctivering > 0) && (p->distinctivering <= num_cadence)) {\n\t\tif (ioctl(p->subs[SUB_REAL].dfd, DAHDI_SETCADENCE, &cadences[p->distinctivering - 1]))\n\t\t\tast_log(LOG_WARNING, \"Unable to set distinctive ring cadence %d on '%s': %s\\n\", p->distinctivering, ast_channel_name(ast), strerror(errno));\n\t\t*cid_rings = cidrings[p->distinctivering - 1];\n\t} else {\n\t\tif (ioctl(p->subs[SUB_REAL].dfd, DAHDI_SETCADENCE, NULL))\n\t\t\tast_log(LOG_WARNING, \"Unable to reset default ring on '%s': %s\\n\", ast_channel_name(ast), strerror(errno));\n\t\t*cid_rings = p->sendcalleridafter;\n\t}\n}\n", "bug_type": null, "idx": 695}
{"project": "Asterisk", "target": 0, "func": "static void send_ping(struct unistimsession *pte)\n{\n\tBUFFSEND;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending ping\\n\");\n\t}\n\tpte->tick_next_ping = get_tick_count() + unistim_keepalive;\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_ping, sizeof(packet_send_ping));\n\tsend_client(SIZE_HEADER + sizeof(packet_send_ping), buffsend, pte);\n}\n", "bug_type": null, "idx": 696}
{"project": "Asterisk", "target": 0, "func": "static int say_phonetic_str_full(struct ast_channel *chan, const char *str, const char *ints, const char *lang, int audiofd, int ctrlfd)\n{\n\tconst char *fn;\n\tchar fnbuf[256];\n\tchar ltr;\n\tint num = 0;\n\tint res = 0;\n\twhile (str[num] && !res) {\n\t\tfn = NULL;\n\t\tswitch (str[num]) {\n\t\tcase ('*'):\n\t\t\tfn = \"digits/star\";\n\t\t\tbreak;\n\t\tcase ('#'):\n\t\t\tfn = \"digits/pound\";\n\t\t\tbreak;\n\t\tcase ('!'):\n\t\t\tfn = \"letters/exclaimation-point\";\n\t\t\tbreak;\n\t\tcase ('@'):\n\t\t\tfn = \"letters/at\";\n\t\t\tbreak;\n\t\tcase ('$'):\n\t\t\tfn = \"letters/dollar\";\n\t\t\tbreak;\n\t\tcase ('-'):\n\t\t\tfn = \"letters/dash\";\n\t\t\tbreak;\n\t\tcase ('.'):\n\t\t\tfn = \"letters/dot\";\n\t\t\tbreak;\n\t\tcase ('='):\n\t\t\tfn = \"letters/equals\";\n\t\t\tbreak;\n\t\tcase ('+'):\n\t\t\tfn = \"letters/plus\";\n\t\t\tbreak;\n\t\tcase ('/'):\n\t\t\tfn = \"letters/slash\";\n\t\t\tbreak;\n\t\tcase (' '):\n\t\t\tfn = \"letters/space\";\n\t\t\tbreak;\n\t\tcase ('0'):\n\t\tcase ('1'):\n\t\tcase ('2'):\n\t\tcase ('3'):\n\t\tcase ('4'):\n\t\tcase ('5'):\n\t\tcase ('6'):\n\t\tcase ('7'):\n\t\tcase ('8'):\n\t\t\tstrcpy(fnbuf, \"digits/X\");\n\t\t\tfnbuf[7] = str[num];\n\t\t\tfn = fnbuf;\n\t\t\tbreak;\n\t\tdefault:\t\n\t\t\tltr = str[num];\n\t\t\tif ('A' <= ltr && ltr <= 'Z') ltr += 'a' - 'A';\t\t\n\t\t\tstrcpy(fnbuf, \"phonetic/X_p\");\n\t\t\tfnbuf[9] = ltr;\n\t\t\tfn = fnbuf;\n\t\t}\n\t\tif (fn && ast_fileexists(fn, NULL, lang) > 0) {\n\t\t\tres = ast_streamfile(chan, fn, lang);\n\t\t\tif (!res) {\n\t\t\t\tif ((audiofd  > -1) && (ctrlfd > -1))\n\t\t\t\t\tres = ast_waitstream_full(chan, ints, audiofd, ctrlfd);\n\t\t\t\telse\n\t\t\t\t\tres = ast_waitstream(chan, ints);\n\t\t\t}\n\t\t\tast_stopstream(chan);\n\t\t}\n\t\tnum++;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 697}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct realtime_sqlite3_db *new_realtime_sqlite3_db(struct ast_config *config, const char *cat)\n{\n\tstruct ast_variable *var;\n\tstruct realtime_sqlite3_db *db;\n\tif (!(db = ao2_alloc(sizeof(*db), db_destructor))) {\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(db, 64)) {\n\t\tunref_db(&db);\n\t\treturn NULL;\n\t}\n\t\n\tdb->requirements = REALTIME_SQLITE3_REQ_WARN;\n\tdb->batch = 100;\n\tast_string_field_set(db, name, cat);\n\tdb->busy_timeout = 1000;\n\tfor (var = ast_variable_browse(config, cat); var; var = var->next) {\n\t\tif (!strcasecmp(var->name, \"dbfile\")) {\n\t\t\tast_string_field_set(db, filename, var->value);\n\t\t} else if (!strcasecmp(var->name, \"requirements\")) {\n\t\t\tdb->requirements = str_to_requirements(var->value);\n\t\t} else if (!strcasecmp(var->name, \"batch\")) {\n\t\t\tast_app_parse_timelen(var->value, (int *) &db->batch, TIMELEN_MILLISECONDS);\n\t\t} else if (!strcasecmp(var->name, \"debug\")) {\n\t\t\tdb->debug = ast_true(var->value);\n\t\t} else if (!strcasecmp(var->name, \"busy_timeout\")) {\n\t\t\tif (ast_parse_arg(var->value, PARSE_INT32|PARSE_DEFAULT, &(db->busy_timeout), 1000) != 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid busy_timeout value '%s' at res_config_sqlite3.conf:%d. Using 1000 instead.\\n\", var->value, var->lineno);\n\t\t\t}\n\t\t}\n\t}\n\tif (ast_strlen_zero(db->filename)) {\n\t\tast_log(LOG_WARNING, \"Must specify dbfile in res_config_sqlite3.conf\\n\");\n\t\tunref_db(&db);\n\t\treturn NULL;\n\t}\n\treturn db;\n}\n", "bug_type": null, "idx": 698}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function csv_quote_function = {\n\t.name = \"CSV_QUOTE\",\n\t.read = csv_quote,\n};\n}\nstatic struct ast_custom_function csv_quote_function = {\n\t.name = \"CSV_QUOTE\",\n\t.read = csv_quote,\n};\nstatic int len(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t buflen)\n{\n\tint length = 0;\n\tif (data)\n\t\tlength = strlen(data);\n\tsnprintf(buf, buflen, \"%d\", length);\n\treturn 0;\n}\nstatic struct ast_custom_function len_function = {\n\t.name = \"LEN\",\n\t.read = len,\n\t.read_max = 12,\n};\nstatic int acf_strftime(struct ast_channel *chan, const char *cmd, char *parse,\n\t\t\tchar *buf, size_t buflen)\n{\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t     AST_APP_ARG(epoch);\n\t\t\t     AST_APP_ARG(timezone);\n\t\t\t     AST_APP_ARG(format);\n\t);\n\tstruct timeval when;\n\tstruct ast_tm tm;\n\tbuf[0] = '\\0';\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tast_get_timeval(args.epoch, &when, ast_tvnow(), NULL);\n\tast_localtime(&when, &tm, args.timezone);\n\tif (!args.format)\n\t\targs.format = \"%c\";\n\tif (ast_strftime(buf, buflen, args.format, &tm) <= 0)\n\t\tast_log(LOG_WARNING, \"C function strftime() output nothing?!!\\n\");\n\tbuf[buflen - 1] = '\\0';\n\treturn 0;\n}\nstatic struct ast_custom_function strftime_function = {\n\t.name = \"STRFTIME\",\n\t.read = acf_strftime,\n};\nstatic int acf_strptime(struct ast_channel *chan, const char *cmd, char *data,\n\t\t\tchar *buf, size_t buflen)\n{\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t     AST_APP_ARG(timestring);\n\t\t\t     AST_APP_ARG(timezone);\n\t\t\t     AST_APP_ARG(format);\n\t);\n\tstruct ast_tm tm;\n\tbuf[0] = '\\0';\n\tif (!data) {\n\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Asterisk function STRPTIME() requires an argument.\\n\");\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.format)) {\n\t\tast_log(LOG_ERROR,\n\t\t\t\t\"No format supplied to STRPTIME(<timestring>,<timezone>,<format>)\");\n\t\treturn -1;\n\t}\n\tif (!ast_strptime(args.timestring, args.format, &tm)) {\n\t\tast_log(LOG_WARNING, \"STRPTIME() found no time specified within the string\\n\");\n\t} else {\n\t\tstruct timeval when;\n\t\twhen = ast_mktime(&tm, args.timezone);\n\t\tsnprintf(buf, buflen, \"%d\", (int) when.tv_sec);\n\t}\n\treturn 0;\n}\nstatic struct ast_custom_function strptime_function = {\n\t.name = \"STRPTIME\",\n\t.read = acf_strptime,\n};\nstatic int function_eval(struct ast_channel *chan, const char *cmd, char *data,\n\t\t\t char *buf, size_t buflen)\n{\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"EVAL requires an argument: EVAL(<string>)\\n\");\n\t\treturn -1;\n\t}\n\tpbx_substitute_variables_helper(chan, data, buf, buflen - 1);\n\treturn 0;\n}\nstatic int function_eval2(struct ast_channel *chan, const char *cmd, char *data,\n\t\t\t struct ast_str **buf, ssize_t buflen)\n{\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"EVAL requires an argument: EVAL(<string>)\\n\");\n\t\treturn -1;\n\t}\n\tast_str_substitute_variables(buf, buflen, chan, data);\n\treturn 0;\n}\nstatic struct ast_custom_function eval_function = {\n\t.name = \"EVAL\",\n\t.read = function_eval,\n\t.read2 = function_eval2,\n};\nstatic int keypadhash(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t buflen)\n{\n\tchar *bufptr, *dataptr;\n\tfor (bufptr = buf, dataptr = data; bufptr < buf + buflen - 1; dataptr++) {\n\t\tif (*dataptr == '\\0') {\n\t\t\t*bufptr++ = '\\0';\n\t\t\tbreak;\n\t\t} else if (*dataptr == '1') {\n\t\t\t*bufptr++ = '1';\n\t\t} else if (strchr(\"AaBbCc2\", *dataptr)) {\n\t\t\t*bufptr++ = '2';\n\t\t} else if (strchr(\"DdEeFf3\", *dataptr)) {\n\t\t\t*bufptr++ = '3';\n\t\t} else if (strchr(\"GgHhIi4\", *dataptr)) {\n\t\t\t*bufptr++ = '4';\n\t\t} else if (strchr(\"JjKkLl5\", *dataptr)) {\n\t\t\t*bufptr++ = '5';\n\t\t} else if (strchr(\"MmNnOo6\", *dataptr)) {\n\t\t\t*bufptr++ = '6';\n\t\t} else if (strchr(\"PpQqRrSs7\", *dataptr)) {\n\t\t\t*bufptr++ = '7';\n\t\t} else if (strchr(\"TtUuVv8\", *dataptr)) {\n\t\t\t*bufptr++ = '8';\n\t\t} else if (strchr(\"WwXxYyZz9\", *dataptr)) {\n\t\t\t*bufptr++ = '9';\n\t\t} else if (*dataptr == '0') {\n\t\t\t*bufptr++ = '0';\n\t\t}\n\t}\n\tbuf[buflen - 1] = '\\0';\n\treturn 0;\n}\nstatic struct ast_custom_function keypadhash_function = {\n\t.name = \"KEYPADHASH\",\n\t.read = keypadhash,\n};\nstatic int string_toupper(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t buflen)\n{\n\tchar *bufptr = buf, *dataptr = data;\n\twhile ((bufptr < buf + buflen - 1) && (*bufptr++ = toupper(*dataptr++)));\n\treturn 0;\n}\nstatic int string_toupper2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t buflen)\n{\n\tchar *bufptr, *dataptr = data;\n\tif (buflen > -1) {\n\t\tast_str_make_space(buf, buflen > 0 ? buflen : strlen(data) + 1);\n\t}\n\tbufptr = ast_str_buffer(*buf);\n\twhile ((bufptr < ast_str_buffer(*buf) + ast_str_size(*buf) - 1) && (*bufptr++ = toupper(*dataptr++)));\n\tast_str_update(*buf);\n\treturn 0;\n}\nstatic struct ast_custom_function toupper_function = {\n\t.name = \"TOUPPER\",\n\t.read = string_toupper,\n\t.read2 = string_toupper2,\n};\nstatic int string_tolower(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t buflen)\n{\n\tchar *bufptr = buf, *dataptr = data;\n\twhile ((bufptr < buf + buflen - 1) && (*bufptr++ = tolower(*dataptr++)));\n\treturn 0;\n}\nstatic int string_tolower2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t buflen)\n{\n\tchar *bufptr, *dataptr = data;\n\tif (buflen > -1) {\n\t\tast_str_make_space(buf, buflen > 0 ? buflen : strlen(data) + 1);\n\t}\n\tbufptr = ast_str_buffer(*buf);\n\twhile ((bufptr < ast_str_buffer(*buf) + ast_str_size(*buf) - 1) && (*bufptr++ = tolower(*dataptr++)));\n\tast_str_update(*buf);\n\treturn 0;\n}\nstatic struct ast_custom_function tolower_function = {\n\t.name = \"TOLOWER\",\n\t.read = string_tolower,\n\t.read2 = string_tolower2,\n};\nstatic int shift_pop(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n#define beginning\t(cmd[0] == 'S') \n\tchar *after, delimiter[2] = \",\", *varsubst;\n\tsize_t unused;\n\tstruct ast_str *before = ast_str_thread_get(&result_buf, 16);\n\tchar *(*search_func)(const char *s, int c) = (beginning ? strchr : strrchr);\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(var);\n\t\tAST_APP_ARG(delimiter);\n\t);\n\tif (!before) {\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.var)) {\n\t\tast_log(LOG_WARNING, \"%s requires a variable name\\n\", cmd);\n\t\treturn -1;\n\t}\n\tvarsubst = ast_alloca(strlen(args.var) + 4);\n\tsprintf(varsubst, \"${%s}\", args.var);\n\tast_str_substitute_variables(&before, 0, chan, varsubst);\n\tif (args.argc > 1 && !ast_strlen_zero(args.delimiter)) {\n\t\tast_get_encoded_char(args.delimiter, delimiter, &unused);\n\t}\n\tif (!ast_str_strlen(before)) {\n\t\t\n\t\treturn -1;\n\t}\n\tif (!(after = search_func(ast_str_buffer(before), delimiter[0]))) {\n\t\t\n\t\tast_str_set(buf, len, \"%s\", ast_str_buffer(before));\n\t\tpbx_builtin_setvar_helper(chan, args.var, \"\");\n\t} else {\n\t\t*after++ = '\\0';\n\t\tast_str_set(buf, len, \"%s\", beginning ? ast_str_buffer(before) : after);\n\t\tpbx_builtin_setvar_helper(chan, args.var, beginning ? after : ast_str_buffer(before));\n\t}\n\treturn 0;\n#undef beginning\n}\nstatic struct ast_custom_function shift_function = {\n\t.name = \"SHIFT\",\n\t.read2 = shift_pop,\n};\nstatic struct ast_custom_function pop_function = {\n\t.name = \"POP\",\n\t.read2 = shift_pop,\n};\nstatic int unshift_push(struct ast_channel *chan, const char *cmd, char *data, const char *new_value)\n{\n#define beginning\t(cmd[0] == 'U') \n\tchar delimiter[2] = \",\", *varsubst;\n\tsize_t unused;\n\tstruct ast_str *buf, *previous_value;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(var);\n\t\tAST_APP_ARG(delimiter);\n\t);\n\tconst char *stripped_var;\n\tif (!(buf = ast_str_thread_get(&result_buf, 16)) ||\n\t\t!(previous_value = ast_str_thread_get(&tmp_buf, 16))) {\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.var)) {\n\t\tast_log(LOG_WARNING, \"%s requires a variable name\\n\", cmd);\n\t\treturn -1;\n\t}\n\tif (args.argc > 1 && !ast_strlen_zero(args.delimiter)) {\n\t\tast_get_encoded_char(args.delimiter, delimiter, &unused);\n\t}\n\t\n\tstripped_var = args.var + MIN(strspn(args.var, \"_\"), 2);\n\tvarsubst = ast_alloca(strlen(stripped_var) + 4);\n\tsprintf(varsubst, \"${%s}\", stripped_var);\n\tast_str_substitute_variables(&previous_value, 0, chan, varsubst);\n\tif (!ast_str_strlen(previous_value)) {\n\t\tast_str_set(&buf, 0, \"%s\", new_value);\n\t} else {\n\t\tast_str_set(&buf, 0, \"%s%c%s\",\n\t\t\tbeginning ? new_value : ast_str_buffer(previous_value),\n\t\t\tdelimiter[0],\n\t\t\tbeginning ? ast_str_buffer(previous_value) : new_value);\n\t}\n\tpbx_builtin_setvar_helper(chan, args.var, ast_str_buffer(buf));\n\treturn 0;\n#undef beginning\n}\nstatic struct ast_custom_function push_function = {\n\t.name = \"PUSH\",\n\t.write = unshift_push,\n};\nstatic struct ast_custom_function unshift_function = {\n\t.name = \"UNSHIFT\",\n\t.write = unshift_push,\n};\nstatic int passthru(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\tast_str_set(buf, len, \"%s\", data);\n\treturn 0;\n}\nstatic struct ast_custom_function passthru_function = {\n\t.name = \"PASSTHRU\",\n\t.read2 = passthru,\n};\n#ifdef TEST_FRAMEWORK\nAST_TEST_DEFINE(test_FIELDNUM)\n{\n\tint i, res = AST_TEST_PASS;\n\tstruct ast_channel *chan;\n\tstruct ast_str *str;\n\tchar expression[256];\n\tstruct {\n\t\tconst char *fields;\n\t\tconst char *delim;\n\t\tconst char *field;\n\t\tconst char *expected;\n\t} test_args[] = {\n\t\t{\"abc,def,ghi,jkl\", \"\\\\,\",     \"ghi\", \"3\"},\n\t\t{\"abc def ghi jkl\", \" \",       \"abc\", \"1\"},\n\t\t{\"abc/def/ghi/jkl\", \"\\\\\\\\x2f\", \"def\", \"2\"},\n\t\t{\"abc$def$ghi$jkl\", \"\",        \"ghi\", \"0\"},\n\t\t{\"abc,def,ghi,jkl\", \"-\",       \"\",    \"0\"},\n\t\t{\"abc-def-ghi-jkl\", \"-\",       \"mno\", \"0\"}\n\t};\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"func_FIELDNUM_test\";\n\t\tinfo->category = \"/funcs/func_strings/\";\n\t\tinfo->summary = \"Test FIELDNUM function\";\n\t\tinfo->description = \"Verify FIELDNUM behavior\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tif (!(chan = ast_dummy_channel_alloc())) {\n\t\tast_test_status_update(test, \"Unable to allocate dummy channel\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tif (!(str = ast_str_create(16))) {\n\t\tast_test_status_update(test, \"Unable to allocate dynamic string buffer\\n\");\n\t\tast_channel_release(chan);\n\t\treturn AST_TEST_FAIL;\n\t}\n\tfor (i = 0; i < ARRAY_LEN(test_args); i++) {\n\t\tstruct ast_var_t *var = ast_var_assign(\"FIELDS\", test_args[i].fields);\n\t\tif (!var) {\n\t\t\tast_test_status_update(test, \"Out of memory\\n\");\n\t\t\tres = AST_TEST_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tAST_LIST_INSERT_HEAD(ast_channel_varshead(chan), var, entries);\n\t\tsnprintf(expression, sizeof(expression), \"${FIELDNUM(%s,%s,%s)}\", var->name, test_args[i].delim, test_args[i].field);\n\t\tast_str_substitute_variables(&str, 0, chan, expression);\n\t\tAST_LIST_REMOVE(ast_channel_varshead(chan), var, entries);\n\t\tast_var_delete(var);\n\t\tif (strcasecmp(ast_str_buffer(str), test_args[i].expected)) {\n\t\t\tast_test_status_update(test, \"Evaluation of '%s' returned '%s' instead of the expected value '%s'\\n\",\n\t\t\t\texpression, ast_str_buffer(str), test_args[i].expected);\n\t\t\tres = AST_TEST_FAIL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tast_free(str);\n\tast_channel_release(chan);\n\treturn res;\n}\nAST_TEST_DEFINE(test_REPLACE)\n{\n\tint i, res = AST_TEST_PASS;\n\tstruct ast_channel *chan;\n\tstruct ast_str *str;\n\tchar expression[256];\n\tstruct {\n\t\tconst char *test_string;\n\t\tconst char *find_chars;\n\t\tconst char *replace_char;\n\t\tconst char *expected;\n\t} test_args[] = {\n\t\t{\"abc,def\", \"\\\\,\", \"-\", \"abc-def\"},\n\t\t{\"abc,abc\", \"bc\",  \"a\", \"aaa,aaa\"},\n\t\t{\"abc,def\", \"x\",   \"?\", \"abc,def\"},\n\t\t{\"abc,def\", \"\\\\,\", \"\",  \"abcdef\"}\n\t};\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"func_REPLACE_test\";\n\t\tinfo->category = \"/funcs/func_strings/\";\n\t\tinfo->summary = \"Test REPLACE function\";\n\t\tinfo->description = \"Verify REPLACE behavior\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tif (!(chan = ast_dummy_channel_alloc())) {\n\t\tast_test_status_update(test, \"Unable to allocate dummy channel\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tif (!(str = ast_str_create(16))) {\n\t\tast_test_status_update(test, \"Unable to allocate dynamic string buffer\\n\");\n\t\tast_channel_release(chan);\n\t\treturn AST_TEST_FAIL;\n\t}\n\tfor (i = 0; i < ARRAY_LEN(test_args); i++) {\n\t\tstruct ast_var_t *var = ast_var_assign(\"TEST_STRING\", test_args[i].test_string);\n\t\tif (!var) {\n\t\t\tast_test_status_update(test, \"Out of memory\\n\");\n\t\t\tres = AST_TEST_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tAST_LIST_INSERT_HEAD(ast_channel_varshead(chan), var, entries);\n\t\tsnprintf(expression, sizeof(expression), \"${REPLACE(%s,%s,%s)}\", var->name, test_args[i].find_chars, test_args[i].replace_char);\n\t\tast_str_substitute_variables(&str, 0, chan, expression);\n\t\tAST_LIST_REMOVE(ast_channel_varshead(chan), var, entries);\n\t\tast_var_delete(var);\n\t\tif (strcasecmp(ast_str_buffer(str), test_args[i].expected)) {\n\t\t\tast_test_status_update(test, \"Evaluation of '%s' returned '%s' instead of the expected value '%s'\\n\",\n\t\t\t\texpression, ast_str_buffer(str), test_args[i].expected);\n\t\t\tres = AST_TEST_FAIL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tast_free(str);\n\tast_channel_release(chan);\n\treturn res;\n}\nAST_TEST_DEFINE(test_FILTER)\n{\n\tint i, res = AST_TEST_PASS;\n\tconst char *test_strings[][2] = {\n\t\t{\"A-R\",            \"DAHDI\"},\n\t\t{\"A\\\\-R\",          \"A\"},\n\t\t{\"\\\\x41-R\",        \"DAHDI\"},\n\t\t{\"0-9A-Ca-c\",      \"0042133333A12212\"},\n\t\t{\"0-9a-cA-C_+\\\\-\", \"0042133333A12212\"},\n\t\t{NULL,             NULL},\n\t};\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"func_FILTER_test\";\n\t\tinfo->category = \"/funcs/func_strings/\";\n\t\tinfo->summary = \"Test FILTER function\";\n\t\tinfo->description = \"Verify FILTER behavior\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tfor (i = 0; test_strings[i][0]; i++) {\n\t\tchar tmp[256], tmp2[256] = \"\";\n\t\tsnprintf(tmp, sizeof(tmp), \"${FILTER(%s,0042133333&DAHDI/g1/2212)}\", test_strings[i][0]);\n\t\tpbx_substitute_variables_helper(NULL, tmp, tmp2, sizeof(tmp2) - 1);\n\t\tif (strcmp(test_strings[i][1], tmp2)) {\n\t\t\tast_test_status_update(test, \"Format string '%s' substituted to '%s'.  Expected '%s'.\\n\", test_strings[i][0], tmp2, test_strings[i][1]);\n\t\t\tres = AST_TEST_FAIL;\n\t\t}\n\t}\n\treturn res;\n}\nAST_TEST_DEFINE(test_STRREPLACE)\n{\n\tint i, res = AST_TEST_PASS;\n\tstruct ast_channel *chan; \n\tstruct ast_str *str; \n\tconst char *test_strings[][5] = {\n\t\t{\"Weasels have eaten my telephone system\", \"have eaten my\", \"are eating our\", \"\", \"Weasels are eating our telephone system\"}, \n\t\t{\"Did you know twenty plus two is twenty-two?\", \"twenty\", \"thirty\", NULL, \"Did you know thirty plus two is thirty-two?\"}, \n\t\t{\"foofoofoofoofoofoofoo\", \"foofoo\", \"bar\", NULL, \"barbarbarfoo\"}, \n\t\t{\"My pet dog once ate a dog who sat on a dog while eating a corndog.\", \"dog\", \"cat\", \"3\", \"My pet cat once ate a cat who sat on a cat while eating a corndog.\"},\n\t\t{\"One and one and one is three\", \"and\", \"plus\", \"1\", \"One plus one and one is three\"}, \n\t\t{\"\", \"fhqwagads\", \"spelunker\", NULL, \"\"}, \n\t\t{\"Part of this string is missing.\", \"missing\", NULL, NULL, \"Part of this string is .\"}, \n\t\t{\"'Accidentally' left off a bunch of stuff.\", NULL, NULL, NULL, \"\"}, \n\t\t{\"This test will also error.\", \"\", \"\", \"\", \"\"}, \n\t\t{\"This is an \\\"escape character\\\" test.\", \"\\\\\\\"escape character\\\\\\\"\", \"evil\", NULL, \"This is an evil test.\"}\n\t};\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"func_STRREPLACE_test\";\n\t\tinfo->category = \"/funcs/func_strings/\";\n\t\tinfo->summary = \"Test STRREPLACE function\";\n\t\tinfo->description = \"Verify STRREPLACE behavior\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tif (!(chan = ast_dummy_channel_alloc())) {\n\t\tast_test_status_update(test, \"Unable to allocate dummy channel\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tif (!(str = ast_str_create(64))) {\n\t\tast_test_status_update(test, \"Unable to allocate dynamic string buffer\\n\");\n\t\tast_channel_release(chan);\n\t\treturn AST_TEST_FAIL;\n\t}\n\tfor (i = 0; i < ARRAY_LEN(test_strings); i++) {\n\t\tchar tmp[512], tmp2[512] = \"\";\n\t\tstruct ast_var_t *var = ast_var_assign(\"test_string\", test_strings[i][0]);\n\t\tif (!var) {\n\t\t\tast_test_status_update(test, \"Unable to allocate variable\\n\");\n\t\t\tast_free(str);\n\t\t\tast_channel_release(chan);\n\t\t\treturn AST_TEST_FAIL;\n\t\t}\n\t\tAST_LIST_INSERT_HEAD(ast_channel_varshead(chan), var, entries);\n\t\tif (test_strings[i][3]) {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"${STRREPLACE(%s,%s,%s,%s)}\", \"test_string\", test_strings[i][1], test_strings[i][2], test_strings[i][3]);\n\t\t} else if (test_strings[i][2]) {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"${STRREPLACE(%s,%s,%s)}\", \"test_string\", test_strings[i][1], test_strings[i][2]);\n\t\t} else if (test_strings[i][1]) {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"${STRREPLACE(%s,%s)}\", \"test_string\", test_strings[i][1]);\n\t\t} else {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"${STRREPLACE(%s)}\", \"test_string\");\n\t\t}\n\t\tast_str_substitute_variables(&str, 0, chan, tmp);\n\t\tif (strcmp(test_strings[i][4], ast_str_buffer(str))) {\n\t\t\tast_test_status_update(test, \"Format string '%s' substituted to '%s'.  Expected '%s'.\\n\", test_strings[i][0], tmp2, test_strings[i][4]);\n\t\t\tres = AST_TEST_FAIL;\n\t\t}\n\t}\n\tast_free(str);\n\tast_channel_release(chan);\n\treturn res;\n}\n#endif\nstatic int unload_module(void)\n{\n\tint res = 0;\n\tAST_TEST_UNREGISTER(test_FIELDNUM);\n\tAST_TEST_UNREGISTER(test_REPLACE);\n\tAST_TEST_UNREGISTER(test_FILTER);\n\tAST_TEST_UNREGISTER(test_STRREPLACE);\n\tres |= ast_custom_function_unregister(&fieldqty_function);\n\tres |= ast_custom_function_unregister(&fieldnum_function);\n\tres |= ast_custom_function_unregister(&filter_function);\n\tres |= ast_custom_function_unregister(&replace_function);\n\tres |= ast_custom_function_unregister(&strreplace_function);\n\tres |= ast_custom_function_unregister(&listfilter_function);\n\tres |= ast_custom_function_unregister(&regex_function);\n\tres |= ast_custom_function_unregister(&array_function);\n\tres |= ast_custom_function_unregister(&quote_function);\n\tres |= ast_custom_function_unregister(&csv_quote_function);\n\tres |= ast_custom_function_unregister(&len_function);\n\tres |= ast_custom_function_unregister(&strftime_function);\n\tres |= ast_custom_function_unregister(&strptime_function);\n\tres |= ast_custom_function_unregister(&eval_function);\n\tres |= ast_custom_function_unregister(&keypadhash_function);\n\tres |= ast_custom_function_unregister(&hashkeys_function);\n\tres |= ast_custom_function_unregister(&hash_function);\n\tres |= ast_unregister_application(app_clearhash);\n\tres |= ast_custom_function_unregister(&toupper_function);\n\tres |= ast_custom_function_unregister(&tolower_function);\n\tres |= ast_custom_function_unregister(&shift_function);\n\tres |= ast_custom_function_unregister(&pop_function);\n\tres |= ast_custom_function_unregister(&push_function);\n\tres |= ast_custom_function_unregister(&unshift_function);\n\tres |= ast_custom_function_unregister(&passthru_function);\n\treturn res;\n}\nstatic int load_module(void)\n{\n\tint res = 0;\n\tAST_TEST_REGISTER(test_FIELDNUM);\n\tAST_TEST_REGISTER(test_REPLACE);\n\tAST_TEST_REGISTER(test_FILTER);\n\tAST_TEST_REGISTER(test_STRREPLACE);\n\tres |= ast_custom_function_register(&fieldqty_function);\n\tres |= ast_custom_function_register(&fieldnum_function);\n\tres |= ast_custom_function_register(&filter_function);\n\tres |= ast_custom_function_register(&replace_function);\n\tres |= ast_custom_function_register(&strreplace_function);\n\tres |= ast_custom_function_register(&listfilter_function);\n\tres |= ast_custom_function_register(&regex_function);\n\tres |= ast_custom_function_register(&array_function);\n\tres |= ast_custom_function_register(&quote_function);\n\tres |= ast_custom_function_register(&csv_quote_function);\n\tres |= ast_custom_function_register(&len_function);\n\tres |= ast_custom_function_register(&strftime_function);\n\tres |= ast_custom_function_register(&strptime_function);\n\tres |= ast_custom_function_register(&eval_function);\n\tres |= ast_custom_function_register(&keypadhash_function);\n\tres |= ast_custom_function_register(&hashkeys_function);\n\tres |= ast_custom_function_register(&hash_function);\n\tres |= ast_register_application_xml(app_clearhash, exec_clearhash);\n\tres |= ast_custom_function_register(&toupper_function);\n\tres |= ast_custom_function_register(&tolower_function);\n\tres |= ast_custom_function_register(&shift_function);\n\tres |= ast_custom_function_register(&pop_function);\n\tres |= ast_custom_function_register(&push_function);\n\tres |= ast_custom_function_register(&unshift_function);\n\tres |= ast_custom_function_register(&passthru_function);\n\treturn res;\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"String handling dialplan functions\");\n", "bug_type": null, "idx": 699}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225_SeqOfH225GenericData (OOCTXT* pctxt, H225_SeqOfH225GenericData* pvalue)\n{\n   int stat = ASN_OK;\n   DListNode* pnode;\n   ASN1UINT xx1;\n   ASN1UINT enclen, fraglen;\n   enclen = fraglen = xx1 = 0;\n   pnode = pvalue->head;\n   for (;;) {\n      \n      stat = encodeLength (pctxt, (pvalue->count - enclen));\n      if (stat < 0) return stat;\n      fraglen = stat;\n      enclen += fraglen;\n      \n      for (; xx1 < enclen; xx1++) {\n         stat = asn1PE_H225GenericData (pctxt, ((H225GenericData*)pnode->data));\n         if (stat != ASN_OK) return stat;\n         pnode = pnode->next;\n      }\n      if ( pvalue->count == enclen && fraglen < 16384) {\n         break;\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 700}
{"project": "Asterisk", "target": 0, "func": "static struct topic_pool_entry *topic_pool_entry_alloc(void)\n{\n\treturn ao2_alloc_options(sizeof(struct topic_pool_entry), topic_pool_entry_dtor,\n\t\tAO2_ALLOC_OPT_LOCK_NOLOCK);\n}\n", "bug_type": null, "idx": 701}
{"project": "Asterisk", "target": 0, "func": "const char *ast_stream_state2str(enum ast_stream_state state)\n{\n\tswitch (state) {\n\tcase AST_STREAM_STATE_REMOVED:\n\t\treturn \"removed\";\n\tcase AST_STREAM_STATE_SENDRECV:\n\t\treturn \"sendrecv\";\n\tcase AST_STREAM_STATE_SENDONLY:\n\t\treturn \"sendonly\";\n\tcase AST_STREAM_STATE_RECVONLY:\n\t\treturn \"recvonly\";\n\tcase AST_STREAM_STATE_INACTIVE:\n\t\treturn \"inactive\";\n\tdefault:\n\t\treturn \"<unknown>\";\n\t}\n}\n", "bug_type": null, "idx": 702}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_ari_response *response_alloc(void)\n{\n\tstruct ast_ari_response *resp = ast_calloc(1, sizeof(struct ast_ari_response));\n\tresp->headers = ast_str_create(24);\n\treturn resp;\n}\n", "bug_type": null, "idx": 703}
{"project": "Asterisk", "target": 0, "func": "static void start_message_blob_dtor(void *obj)\n{\n\tstruct start_message_blob *payload = obj;\n\tao2_cleanup(payload->channel);\n\tao2_cleanup(payload->replace_channel);\n\tast_json_unref(payload->blob);\n}\n", "bug_type": null, "idx": 704}
{"project": "Asterisk", "target": 0, "func": "static struct device_state_subscription *device_state_subscription_create(\n\tconst struct stasis_app *app, const char *device_name)\n{\n\tstruct device_state_subscription *sub;\n\tconst char *app_name = stasis_app_name(app);\n\tsize_t size;\n\tif (ast_strlen_zero(device_name)) {\n\t\tdevice_name = DEVICE_STATE_ALL;\n\t}\n\tsize = strlen(device_name) + strlen(app_name) + 2;\n \tsub = ao2_alloc(sizeof(*sub), device_state_subscription_destroy);\n\tif (!sub) {\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(sub, size)) {\n\t\tao2_ref(sub, -1);\n\t\treturn NULL;\n\t}\n\tast_string_field_set(sub, app_name, app_name);\n\tast_string_field_set(sub, device_name, device_name);\n\treturn sub;\n}\n", "bug_type": null, "idx": 705}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int misdn_command_cc_initialize(struct ast_channel *chan, struct misdn_command_args *subcommand)\n{\n\tstruct misdn_cc_caller *cc_caller;\n\tstruct ast_datastore *datastore;\n\tif (!(cc_caller = misdn_cc_caller_alloc(chan))) {\n\t\treturn -1;\n\t}\n\tif (!(datastore = ast_datastore_alloc(&misdn_cc_ds_info, NULL))) {\n\t\tao2_ref(cc_caller, -1);\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\t\n\tdatastore->data = cc_caller;\n\tcc_caller = NULL;\n\tdatastore->inheritance = DATASTORE_INHERIT_FOREVER;\n\tast_channel_datastore_add(chan, datastore);\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 706}
{"project": "Asterisk", "target": 0, "func": "void *ast_stream_set_data(struct ast_stream *stream, enum ast_stream_data_slot slot,\n\tvoid *data, ast_stream_data_free_fn data_free_fn)\n{\n\tast_assert(stream != NULL);\n\tstream->data[slot] = data;\n\tstream->data_free_fn[slot] = data_free_fn;\n\treturn data;\n}\n", "bug_type": null, "idx": 707}
{"project": "Asterisk", "target": 0, "func": "int ast_calendar_register(struct ast_calendar_tech *tech)\n{\n\tstruct ast_calendar_tech *iter;\n\tif (!calendar_config) {\n\t\tast_log(LOG_WARNING, \"Calendar support disabled, not loading %s calendar module\\n\", tech->type);\n\t\treturn -1;\n\t}\n\tAST_LIST_LOCK(&techs);\n\tAST_LIST_TRAVERSE(&techs, iter, list) {\n\t\tif(!strcasecmp(tech->type, iter->type)) {\n\t\t\tast_log(LOG_WARNING, \"Already have a handler for calendar type '%s'\\n\", tech->type);\n\t\t\tAST_LIST_UNLOCK(&techs);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tAST_LIST_INSERT_HEAD(&techs, tech, list);\n\ttech->user = ast_module_user_add(NULL);\n\tAST_LIST_UNLOCK(&techs);\n\tast_verb(2, \"Registered calendar type '%s' (%s)\\n\", tech->type, tech->description);\n\treturn load_tech_calendars(tech);\n}\n", "bug_type": null, "idx": 708}
{"project": "Asterisk", "target": 0, "func": "static int action_extensionstatelist(struct mansession *s, const struct message *m)\n{\n\tconst char *action_id = astman_get_header(m, \"ActionID\");\n\tstruct ast_hint *hint;\n\tstruct ao2_iterator it_hints;\n\tint hint_count = 0;\n\tif (!hints) {\n\t\tastman_send_error(s, m, \"No dialplan hints are available\");\n\t\treturn 0;\n\t}\n\tastman_send_listack(s, m, \"Extension Statuses will follow\", \"start\");\n\tao2_lock(hints);\n\tit_hints = ao2_iterator_init(hints, 0);\n\tfor (; (hint = ao2_iterator_next(&it_hints)); ao2_ref(hint, -1)) {\n\t\tao2_lock(hint);\n\t\t\n\t\tif (hint->exten->exten[0] == '_') {\n\t\t\tao2_unlock(hint);\n\t\t\tcontinue;\n\t\t}\n\t\t++hint_count;\n\t\tastman_append(s, \"Event: ExtensionStatus\\r\\n\");\n\t\tif (!ast_strlen_zero(action_id)) {\n\t\t\tastman_append(s, \"ActionID: %s\\r\\n\", action_id);\n\t\t}\n\t\tastman_append(s,\n\t\t   \"Exten: %s\\r\\n\"\n\t\t   \"Context: %s\\r\\n\"\n\t\t   \"Hint: %s\\r\\n\"\n\t\t   \"Status: %d\\r\\n\"\n\t\t   \"StatusText: %s\\r\\n\\r\\n\",\n\t\t   hint->exten->exten,\n\t\t   hint->exten->parent->name,\n\t\t   hint->exten->app,\n\t\t   hint->laststate,\n\t\t   ast_extension_state2str(hint->laststate));\n\t\tao2_unlock(hint);\n\t}\n\tao2_iterator_destroy(&it_hints);\n\tao2_unlock(hints);\n\tastman_send_list_complete_start(s, m, \"ExtensionStateListComplete\", hint_count);\n\tastman_send_list_complete_end(s);\n\treturn 0;\n}\n", "bug_type": null, "idx": 709}
{"project": "Asterisk", "target": 0, "func": "void conf_destroy_config(void)\n{\n\tast_cli_unregister_multiple(cli_confbridge_parser, ARRAY_LEN(cli_confbridge_parser));\n\taco_info_destroy(&cfg_info);\n\tao2_global_obj_release(cfg_handle);\n}\n", "bug_type": null, "idx": 710}
{"project": "Asterisk", "target": 0, "func": "\nstatic int load_file(const char *filename, char **ret)\n{\n\tint len = 0;\n\tFILE *f;\n\tif (!(f = fopen(filename, \"r\"))) {\n\t\t*ret = NULL;\n\t\treturn -1;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tlen = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\tif (!(*ret = ast_malloc(len + 1))) {\n\t\tfclose(f);\n\t\treturn -2;\n\t}\n\tif (len != fread(*ret, sizeof(char), len, f)) {\n\t\tfclose(f);\n\t\tast_free(*ret);\n\t\t*ret = NULL;\n\t\treturn -3;\n\t}\n\tfclose(f);\n\t(*ret)[len] = '\\0';\n\treturn len;\n}\n", "bug_type": null, "idx": 711}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_dtmf_digit_to_emulate_set(struct ast_channel *chan, char value)\n{\n\tchan->dtmf_digit_to_emulate = value;\n}\n", "bug_type": null, "idx": 712}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel_monitor *ast_channel_monitor(const struct ast_channel *chan)\n{\n\treturn chan->monitor;\n}\n", "bug_type": null, "idx": 713}
{"project": "Asterisk", "target": 0, "func": "static void ast_dsp_prog_reset(struct ast_dsp *dsp)\n{\n\tint max = 0;\n\tint x;\n\tdsp->gsamp_size = modes[dsp->progmode].size;\n\tdsp->gsamps = 0;\n\tfor (x = 0; x < FREQ_ARRAY_SIZE; x++) {\n\t\tif (modes[dsp->progmode].freqs[x]) {\n\t\t\tgoertzel_init(&dsp->freqs[x], (float)modes[dsp->progmode].freqs[x], dsp->sample_rate);\n\t\t\tmax = x + 1;\n\t\t}\n\t}\n\tdsp->freqcount = max;\n\tdsp->ringtimeout = 0;\n}\n", "bug_type": null, "idx": 714}
{"project": "Asterisk", "target": 0, "func": "});\nstatic int apply_option_timeout (int *var, char *timeout_arg)\n{\n\tif (ast_strlen_zero(timeout_arg)) {\n\t\tast_log(LOG_ERROR, \"No duration value provided for the timeout ('t') option.\\n\");\n\t\treturn -1;\n\t}\n\tif (sscanf(timeout_arg, \"%d\", var) != 1 || *var < 0) {\n\t\tast_log(LOG_ERROR, \"Duration value provided for timeout ('t') option must be 0 or greater.\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 715}
{"project": "Asterisk", "target": 0, "func": "static struct ast_device_state_message *device_state_alloc(const char *device, enum ast_device_state state, enum ast_devstate_cache cachable, const struct ast_eid *eid)\n{\n\tstruct ast_device_state_message *new_device_state;\n\tchar *pos;\n\tsize_t stuff_len;\n\tast_assert(!ast_strlen_zero(device));\n\tstuff_len = strlen(device) + 1;\n\tif (eid) {\n\t\tstuff_len += sizeof(*eid);\n\t}\n\tnew_device_state = ao2_alloc_options(sizeof(*new_device_state) + stuff_len, NULL,\n\t\tAO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!new_device_state) {\n\t\treturn NULL;\n\t}\n\tif (eid) {\n\t\t\n\t\tnew_device_state->stuff[0] = *eid;\n\t\tnew_device_state->eid = &new_device_state->stuff[0];\n\t\tpos = (char *) &new_device_state->stuff[1];\n\t} else {\n\t\tpos = (char *) &new_device_state->stuff[0];\n\t}\n\tstrcpy(pos, device);\n\tnew_device_state->device = pos;\n\tnew_device_state->state = state;\n\tnew_device_state->cachable = cachable;\n\treturn new_device_state;\n}\n", "bug_type": null, "idx": 716}
{"project": "Asterisk", "target": 0, "func": "static int pcm_seek(struct ast_filestream *fs, off_t sample_offset, int whence)\n{\n\toff_t cur, max, offset = 0;\n \tint ret = -1;\t\n\tif ((cur = ftello(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine current position in pcm filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fseeko(fs->f, 0, SEEK_END) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to seek to end of pcm filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((max = ftello(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine max position in pcm filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\toffset = sample_offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\toffset = max - sample_offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\tcase SEEK_FORCECUR:\n\t\toffset = cur + sample_offset;\n\t\tbreak;\n\tdefault:\n\t\tast_log(LOG_WARNING, \"invalid whence %d, assuming SEEK_SET\\n\", whence);\n\t\toffset = sample_offset;\n\t}\n\tif (offset < 0) {\n\t\tast_log(LOG_WARNING, \"negative offset %ld, resetting to 0\\n\", (long) offset);\n\t\toffset = 0;\n\t}\n\tif (whence == SEEK_FORCECUR && offset > max) { \n\t\tsize_t left = offset - max;\n\t\tconst char *src = (ast_format_cmp(fs->fmt->format, ast_format_alaw) == AST_FORMAT_CMP_EQUAL) ? alaw_silence : ulaw_silence;\n\t\twhile (left) {\n\t\t\tsize_t written = fwrite(src, 1, MIN(left, BUF_SIZE), fs->f);\n\t\t\tif (written < MIN(left, BUF_SIZE)) {\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tleft -= written;\n\t\t}\n\t\tret = 0; \n\t} else {\n\t\tif (offset > max) {\n\t\t\tast_log(LOG_WARNING, \"offset too large %ld, truncating to %ld\\n\", (long) offset, (long) max);\n\t\t\toffset = max;\n\t\t}\n\t\tret = fseeko(fs->f, offset, SEEK_SET);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 717}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245RTPPayloadType (OOCTXT* pctxt, H245RTPPayloadType* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.payloadTypePresent);\n   \n   stat = asn1PE_H245RTPPayloadType_payloadDescriptor (pctxt, &pvalue->payloadDescriptor);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.payloadTypePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->payloadType, 0U, 127U);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 718}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void celt_destroy(struct ast_format *format)\n{\n\tstruct celt_attr *attr = ast_format_get_attribute_data(format);\n\tast_free(attr);\n}\n", "bug_type": null, "idx": 719}
{"project": "Asterisk", "target": 0, "func": "void __ao2_cleanup_debug(void *obj, const char *tag, const char *file, int line, const char *function)\n{\n\tif (obj) {\n\t\t__ao2_ref(obj, -1, tag, file, line, function);\n\t}\n}\n", "bug_type": null, "idx": 720}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_channel(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_accountcode = 0;\n\tint has_caller = 0;\n\tint has_connected = 0;\n\tint has_creationtime = 0;\n\tint has_dialplan = 0;\n\tint has_id = 0;\n\tint has_language = 0;\n\tint has_name = 0;\n\tint has_state = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"accountcode\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_accountcode = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field accountcode failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"caller\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_caller = 1;\n\t\t\tprop_is_valid = ast_ari_validate_caller_id(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field caller failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"channelvars\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_object(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field channelvars failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"connected\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_connected = 1;\n\t\t\tprop_is_valid = ast_ari_validate_caller_id(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field connected failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"creationtime\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_creationtime = 1;\n\t\t\tprop_is_valid = ast_ari_validate_date(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field creationtime failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"dialplan\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_dialplan = 1;\n\t\t\tprop_is_valid = ast_ari_validate_dialplan_cep(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field dialplan failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"id\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_id = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field id failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"language\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_language = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field language failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"name\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_name = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field name failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"state\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_state = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Channel field state failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI Channel has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_accountcode) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field accountcode\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_caller) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field caller\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_connected) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field connected\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_creationtime) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field creationtime\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_dialplan) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field dialplan\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_id) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field id\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_language) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field language\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_name) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field name\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_state) {\n\t\tast_log(LOG_ERROR, \"ARI Channel missing required field state\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 721}
{"project": "Asterisk", "target": 0, "func": "\nstatic void answer_exec_run(struct ast_dial *dial, struct ast_dial_channel *dial_channel, char *app, char *args)\n{\n\tstruct ast_channel *chan = dial_channel->owner;\n\tstruct ast_app *ast_app = pbx_findapp(app);\n\t\n\tif (!ast_app)\n\t\treturn;\n\t\n\tpbx_exec(chan, ast_app, args);\n\t\n\tast_mutex_lock(&dial->lock);\n\tif (dial->thread != AST_PTHREADT_STOP) {\n\t\tast_hangup(chan);\n\t\tdial_channel->owner = NULL;\n\t}\n\tast_mutex_unlock(&dial->lock);\n\treturn;\n}\n", "bug_type": null, "idx": 722}
{"project": "Asterisk", "target": 0, "func": "static int asterisk_publication_mailboxstate(struct ast_sip_publication *pub, struct asterisk_publication_config *config,\n\tstruct ast_eid *pubsub_eid, struct ast_json *json)\n{\n\tconst char *uniqueid = ast_json_string_get(ast_json_object_get(json, \"uniqueid\"));\n\tint old_msgs = ast_json_integer_get(ast_json_object_get(json, \"old\"));\n\tint new_msgs = ast_json_integer_get(ast_json_object_get(json, \"new\"));\n\tchar *item_id;\n\tconst char *mailbox;\n\tif (!config->mailbox_state) {\n\t\tast_debug(2, \"Received mailbox state event for resource '%s' but it is not configured to accept them\\n\",\n\t\t\tast_sorcery_object_get_id(config));\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(uniqueid)) {\n\t\tast_debug(1, \"Received incomplete mailbox state event for resource '%s'\\n\",\n\t\t\tast_sorcery_object_get_id(config));\n\t\treturn -1;\n\t}\n\tif (config->mailbox_state_filter && regexec(&config->mailbox_state_regex, uniqueid, 0, NULL, 0)) {\n\t\tast_debug(2, \"Received mailbox state on resource '%s' for uniqueid '%s' but it has been filtered out\\n\",\n\t\t\tast_sorcery_object_get_id(config), uniqueid);\n\t\treturn 0;\n\t}\n\titem_id = ast_strdupa(uniqueid);\n\tmailbox = strsep(&item_id, \"@\");\n\tast_publish_mwi_state_full(mailbox, item_id, new_msgs, old_msgs, NULL, pubsub_eid);\n\treturn 0;\n}\n", "bug_type": null, "idx": 723}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_amihook_send(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"amihook send\";\n\t\te->usage = \"\"\n\t\t\t\"Usage: amihook send\"\n\t\t\t\"\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\tcase CLI_HANDLER:\n\t\thook_send();\n\t\treturn CLI_SUCCESS;\n\t}\n\treturn CLI_FAILURE;\n}\n", "bug_type": null, "idx": 724}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct hash_bucket_node *hash_ao2_new_node(struct ao2_container_hash *self, void *obj_new, const char *tag, const char *file, int line, const char *func)\n{\n\tstruct hash_bucket_node *node;\n\tint i;\n\tnode = ao2_t_alloc_options(sizeof(*node), hash_ao2_node_destructor, AO2_ALLOC_OPT_LOCK_NOLOCK, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\ti = abs(self->hash_fn(obj_new, OBJ_SEARCH_OBJECT) % self->n_buckets);\n\t__ao2_ref(obj_new, +1, tag ?: \"Container node creation\", file, line, func);\n\tnode->common.obj = obj_new;\n\tnode->common.my_container = (struct ao2_container *) self;\n\tnode->my_bucket = i;\n\treturn node;\n}\n", "bug_type": null, "idx": 725}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245MultiplePayloadStream (OOCTXT* pctxt, H245MultiplePayloadStream* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"elements\", -1);\n   stat = asn1PD_H245_SeqOfH245MultiplePayloadStreamElement (pctxt, &pvalue->elements);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"elements\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 726}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(strings_match)\n{\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"strings_match\";\n\t\tinfo->category = \"/main/strings/\";\n\t\tinfo->summary = \"Test ast_strings_match\";\n\t\tinfo->description = \"Test ast_strings_match\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tast_test_validate(test, ast_strings_match(\"aaa\", NULL, \"aaa\"));\n\tast_test_validate(test, ast_strings_match(\"aaa\", \"\", \"aaa\"));\n\tast_test_validate(test, ast_strings_match(\"aaa\", \"=\", \"aaa\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \"!=\", \"aaa\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", NULL, \"aba\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \"\", \"aba\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \"=\", \"aba\"));\n\tast_test_validate(test, ast_strings_match(\"aaa\", \"!=\", \"aba\"));\n\tast_test_validate(test, ast_strings_match(\"aaa\", \"<=\", \"aba\"));\n\tast_test_validate(test, ast_strings_match(\"aaa\", \"<=\", \"aaa\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \"<\", \"aaa\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \">=\", \"aba\"));\n\tast_test_validate(test, ast_strings_match(\"aaa\", \">=\", \"aaa\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \">\", \"aaa\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \"=\", \"aa\"));\n\tast_test_validate(test, ast_strings_match(\"aaa\", \">\", \"aa\"));\n\tast_test_validate(test, !ast_strings_match(\"aaa\", \"<\", \"aa\"));\n\tast_test_validate(test, ast_strings_match(\"1\", \"=\", \"1\"));\n\tast_test_validate(test, !ast_strings_match(\"1\", \"!=\", \"1\"));\n\tast_test_validate(test, !ast_strings_match(\"2\", \"=\", \"1\"));\n\tast_test_validate(test, ast_strings_match(\"2\", \">\", \"1\"));\n\tast_test_validate(test, ast_strings_match(\"2\", \">=\", \"1\"));\n\tast_test_validate(test, ast_strings_match(\"2\", \">\", \"1.9888\"));\n\tast_test_validate(test, ast_strings_match(\"2.9\", \">\", \"1\"));\n\tast_test_validate(test, ast_strings_match(\"2\", \">\", \"1\"));\n\tast_test_validate(test, ast_strings_match(\"2.999\", \"<\", \"3\"));\n\tast_test_validate(test, ast_strings_match(\"2\", \">\", \"#\"));\n\tast_test_validate(test, ast_strings_match(\"abcccc\", \"like\", \"%a%c\"));\n\tast_test_validate(test, !ast_strings_match(\"abcccx\", \"like\", \"%a%c\"));\n\tast_test_validate(test, ast_strings_match(\"abcccc\", \"regex\", \"a[bc]+c\"));\n\tast_test_validate(test, !ast_strings_match(\"abcccx\", \"regex\", \"^a[bxdfgtc]+c$\"));\n\tast_test_validate(test, !ast_strings_match(\"neener-93joe\", \"LIKE\", \"%blah-%\"));\n\tast_test_validate(test, ast_strings_match(\"blah-93joe\", \"LIKE\", \"%blah-%\"));\n\tast_test_validate(test, !ast_strings_match(\"abcccx\", \"regex\", NULL));\n\tast_test_validate(test, !ast_strings_match(\"abcccx\", NULL, NULL));\n\tast_test_validate(test, !ast_strings_match(NULL, \"regex\", NULL));\n\tast_test_validate(test, !ast_strings_match(NULL, NULL, \"abc\"));\n\tast_test_validate(test, !ast_strings_match(NULL, NULL, NULL));\n\treturn AST_TEST_PASS;\n}\n", "bug_type": null, "idx": 727}
{"project": "Asterisk", "target": 0, "func": "static char *agent_handle_show_specific(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct agent_pvt *agent;\n\tstruct ast_channel *logged;\n\tstruct ast_str *out = ast_str_alloca(4096);\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"agent show\";\n\t\te->usage =\n\t\t\t\"Usage: agent show <agent-id>\\n\"\n\t\t\t\"       Show information about the <agent-id> agent\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tif (a->pos == 2) {\n\t\t\treturn complete_agent(a->word, a->n);\n\t\t}\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tagent = ao2_find(agents, a->argv[2], OBJ_KEY);\n\tif (!agent) {\n\t\tast_cli(a->fd, \"Agent '%s' not found\\n\", a->argv[2]);\n\t\treturn CLI_SUCCESS;\n\t}\n\tagent_lock(agent);\n\tlogged = agent_lock_logged(agent);\n\tast_str_set(&out, 0, \"Id: %s\\n\", agent->username);\n\tast_str_append(&out, 0, \"Name: %s\\n\", agent->cfg->full_name);\n\tast_str_append(&out, 0, \"Beep: %s\\n\", agent->cfg->beep_sound);\n\tast_str_append(&out, 0, \"MOH: %s\\n\", agent->cfg->moh);\n\tast_str_append(&out, 0, \"RecordCalls: %s\\n\", AST_CLI_YESNO(agent->cfg->record_agent_calls));\n\tast_str_append(&out, 0, \"State: %s\\n\", ast_devstate_str(agent->devstate));\n\tif (logged) {\n\t\tconst char *talking_with;\n\t\tast_str_append(&out, 0, \"LoggedInChannel: %s\\n\", ast_channel_name(logged));\n\t\tast_str_append(&out, 0, \"LoggedInTime: %ld\\n\", (long) agent->login_start);\n\t\ttalking_with = pbx_builtin_getvar_helper(logged, \"BRIDGEPEER\");\n\t\tif (!ast_strlen_zero(talking_with)) {\n\t\t\tast_str_append(&out, 0, \"TalkingWith: %s\\n\", talking_with);\n\t\t\tast_str_append(&out, 0, \"CallStarted: %ld\\n\", (long) agent->call_start);\n\t\t}\n\t\tast_channel_unlock(logged);\n\t\tast_channel_unref(logged);\n\t}\n\tagent_unlock(agent);\n\tao2_ref(agent, -1);\n\tast_cli(a->fd, \"%s\", ast_str_buffer(out));\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 728}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tif (AST_RWLIST_WRLOCK(&sinks)) {\n\t\tast_log(LOG_ERROR, \"Unable to lock sink list.  Unload failed.\\n\");\n\t\treturn -1;\n\t}\n\tfree_config();\n\tAST_RWLIST_UNLOCK(&sinks);\n\tast_cel_backend_unregister(CUSTOM_BACKEND_NAME);\n\treturn 0;\n}\n", "bug_type": null, "idx": 729}
{"project": "Asterisk", "target": 0, "func": "int ast_rtp_engine_load_format(struct ast_format *format)\n{\n\tset_next_mime_type(format,\n\t\t0,\n\t\tast_codec_media_type2str(ast_format_get_type(format)),\n\t\tast_format_get_codec_name(format),\n\t\tast_format_get_sample_rate(format));\n\tadd_static_payload(-1, format, 0);\n\treturn 0;\n}\n", "bug_type": null, "idx": 730}
{"project": "Asterisk", "target": 0, "func": "static int from_user_handler(const struct aco_option *opt,\n\tstruct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\t\n\tchar *valid_uri_marks = \"-_.!~*`()\";\n\tconst char *val;\n\tfor (val = var->value; *val; val++) {\n\t\tif (!strchr(valid_uri_marks, *val) && !isdigit(*val) && !isalpha(*val)) {\n\t\t\tast_log(LOG_ERROR, \"Error configuring endpoint '%s' - '%s' field \"\n\t\t\t\"contains invalid character '%c'\\n\",\n\t\t\tast_sorcery_object_get_id(endpoint), var->name, *val);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tast_string_field_set(endpoint, fromuser, var->value);\n\treturn 0;\n}\n", "bug_type": null, "idx": 731}
{"project": "Asterisk", "target": 0, "func": "void ast_playtones_stop(struct ast_channel *chan)\n{\n\tast_deactivate_generator(chan);\n}\n", "bug_type": null, "idx": 732}
{"project": "Asterisk", "target": 0, "func": "static void setup_mixmonitor(struct queue_ent *qe, const char *filename)\n{\n\tchar escaped_filename[256];\n\tchar file_with_ext[256];\n\tchar mixmonargs[1512];\n\tchar escaped_monitor_exec[1024];\n\tconst char *monitor_options;\n\tconst char *monitor_exec;\n\tescaped_monitor_exec[0] = '\\0';\n\tif (filename) {\n\t\tescape_and_substitute(qe->chan, filename, escaped_filename, sizeof(escaped_filename));\n\t} else {\n\t\tast_copy_string(escaped_filename, ast_channel_uniqueid(qe->chan), sizeof(escaped_filename));\n\t}\n\tast_channel_lock(qe->chan);\n\tif ((monitor_exec = pbx_builtin_getvar_helper(qe->chan, \"MONITOR_EXEC\"))) {\n\t\tmonitor_exec = ast_strdupa(monitor_exec);\n\t}\n\tif ((monitor_options = pbx_builtin_getvar_helper(qe->chan, \"MONITOR_OPTIONS\"))) {\n\t\tmonitor_options = ast_strdupa(monitor_options);\n\t} else {\n\t\tmonitor_options = \"\";\n\t}\n\tast_channel_unlock(qe->chan);\n\tif (monitor_exec) {\n\t\tescape_and_substitute(qe->chan, monitor_exec, escaped_monitor_exec, sizeof(escaped_monitor_exec));\n\t}\n\tsnprintf(file_with_ext, sizeof(file_with_ext), \"%s.%s\", escaped_filename, qe->parent->monfmt);\n\tif (!ast_strlen_zero(escaped_monitor_exec)) {\n\t\tsnprintf(mixmonargs, sizeof(mixmonargs), \"b%s,%s\", monitor_options, escaped_monitor_exec);\n\t} else {\n\t\tsnprintf(mixmonargs, sizeof(mixmonargs), \"b%s\", monitor_options);\n\t}\n\tast_debug(1, \"Arguments being passed to MixMonitor: %s,%s\\n\", file_with_ext, mixmonargs);\n\tif (ast_start_mixmonitor(qe->chan, file_with_ext, mixmonargs)) {\n\t\tast_log(LOG_WARNING, \"Unable to start mixmonitor. Is the MixMonitor app loaded?\\n\");\n\t}\n}\n", "bug_type": null, "idx": 733}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ext_cmp1(const char **p)\n{\n\tuint32_t chars[8];\n\tint c, cmin = 0xff, count = 0;\n\tconst char *end;\n\t\n\twhile ( (c = *(*p)++) && (c == ' ' || c == '-') )\n\t\t;\t\n\t\n\tswitch (c) {\n\tdefault:\t\n\t\treturn 0x0000 | (c & 0xff);\n\tcase 'N':\t\n\t\treturn 0x0700 | '2' ;\n\tcase 'X':\t\n\t\treturn 0x0900 | '0';\n\tcase 'Z':\t\n\t\treturn 0x0800 | '1';\n\tcase '.':\t\n\t\treturn 0x10000;\n\tcase '!':\t\n\t\treturn 0x20000;\t\n\tcase '\\0':\t\n\t\t*p = NULL;\n\t\treturn 0x30000;\n\tcase '[':\t\n\t\tbreak;\n\t}\n\t\n\tend = strchr(*p, ']');\n\tif (end == NULL) {\n\t\tast_log(LOG_WARNING, \"Wrong usage of [] in the extension\\n\");\n\t\treturn 0x40000;\t\n\t}\n\tmemset(chars, '\\0', sizeof(chars));\t\n\tfor (; *p < end  ; (*p)++) {\n\t\tunsigned char c1, c2;\t\n\t\tc1 = (unsigned char)((*p)[0]);\n\t\tif (*p + 2 < end && (*p)[1] == '-') { \n\t\t\tc2 = (unsigned char)((*p)[2]);\n\t\t\t*p += 2;\t\n\t\t} else\t\t\t\n\t\t\tc2 = c1;\n\t\tif (c1 < cmin)\n\t\t\tcmin = c1;\n\t\tfor (; c1 <= c2; c1++) {\n\t\t\tuint32_t mask = 1 << (c1 % 32);\n\t\t\tif ( (chars[ c1 / 32 ] & mask) == 0)\n\t\t\t\tcount += 0x100;\n\t\t\tchars[ c1 / 32 ] |= mask;\n\t\t}\n\t}\n\t(*p)++;\n\treturn count == 0 ? 0x30000 : (count | cmin);\n}\n", "bug_type": null, "idx": 734}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int qualify_contact_sched(const void *obj)\n{\n\tstruct sched_data *data = (struct sched_data *) obj;\n\tao2_ref(data->contact, +1);\n\tif (ast_sip_push_task(NULL, qualify_contact_task, data->contact)) {\n\t\tao2_ref(data->contact, -1);\n\t}\n\t\n\treturn data->contact->qualify_frequency * 1000;\n}\n", "bug_type": null, "idx": 735}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245McuNumber (OOCTXT* pctxt, H245McuNumber value)\n{\n   int stat = ASN_OK;\n   stat = encodeConsUnsigned (pctxt, value, 0U, 192U);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 736}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpDestroy(void)\n{\n   \n   OOH323CallData * cur, *temp;\n   if(OO_TESTFLAG(gH323ep.flags, OO_M_ENDPOINTCREATED))\n   {\n      OOTRACEINFO1(\"Destroying H323 Endpoint\\n\");\n      if(gH323ep.callList)\n      {\n         cur = gH323ep.callList;\n         while(cur)\n         {\n            temp = cur;\n            cur = cur->next;\n            temp->callEndReason = OO_REASON_LOCAL_CLEARED;\n            ooCleanCall(temp);\n         }\n         gH323ep.callList = NULL;\n      }\n      if(gH323ep.listener)\n      {\n         ooSocketClose(*(gH323ep.listener));\n         gH323ep.listener = NULL;   \n      }\n\t  ooGkClientDestroy();  \n      if(gH323ep.fptraceFile)\n      {\n         fclose(gH323ep.fptraceFile);\n         gH323ep.fptraceFile = NULL;\n      }\n      freeContext(&(gH323ep.ctxt));\n      freeContext(&(gH323ep.msgctxt));\n      OO_CLRFLAG(gH323ep.flags, OO_M_ENDPOINTCREATED);\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 737}
{"project": "Asterisk", "target": 0, "func": "static struct message *wait_for_response(int timeout)\n{\n\tstruct message *m;\n\tstruct timeval tv;\n\tint res;\n\tfd_set fds;\n\tfor (;;) {\n\t\ttv.tv_sec = timeout / 1000;\n\t\ttv.tv_usec = (timeout % 1000) * 1000;\n\t\tFD_SET(session.fd, &fds);\n\t\tres = select(session.fd + 1, &fds, NULL, NULL, &tv);\n\t\tif (res < 1)\n\t\t\tbreak;\n\t\tif (input_check(&session, &m) < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (m)\n\t\t\treturn m;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 738}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void update_rtp_after_merge(const struct ast_sdp_state *state,\n\tstruct sdp_state_rtp *rtp,\n    const struct ast_sdp_options *options,\n\tconst struct ast_sdp *remote_sdp,\n\tconst struct ast_sdp_m_line *remote_m_line)\n{\n\tstruct ast_sdp_c_line *c_line;\n\tstruct ast_sockaddr *addrs;\n\tif (!rtp) {\n\t\t\n\t\treturn;\n\t}\n\tc_line = remote_m_line->c_line;\n\tif (!c_line) {\n\t\tc_line = remote_sdp->c_line;\n\t}\n\t\n\tast_assert(c_line != NULL);\n\tif (ast_sockaddr_resolve(&addrs, c_line->address, PARSE_PORT_FORBID, AST_AF_UNSPEC) > 0) {\n\t\t\n\t\tast_sockaddr_set_port(addrs, remote_m_line->port);\n\t\tast_rtp_instance_set_remote_address(rtp->instance, addrs);\n\t\tast_free(addrs);\n\t}\n\tif (ast_sdp_options_get_rtcp_mux(options)\n\t\t&& ast_sdp_m_find_attribute(remote_m_line, \"rtcp-mux\", -1)) {\n\t\tast_rtp_instance_set_prop(rtp->instance, AST_RTP_PROPERTY_RTCP,\n\t\t\tAST_RTP_INSTANCE_RTCP_MUX);\n\t} else {\n\t\tast_rtp_instance_set_prop(rtp->instance, AST_RTP_PROPERTY_RTCP,\n\t\t\tAST_RTP_INSTANCE_RTCP_STANDARD);\n\t}\n\tupdate_ice(state, rtp->instance, options, remote_sdp, remote_m_line);\n}\n", "bug_type": null, "idx": 739}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_channels_list(struct ast_variable *headers,\n\tstruct ast_ari_channels_list_args *args,\n\tstruct ast_ari_response *response)\n{\n\tRAII_VAR(struct stasis_cache *, cache, NULL, ao2_cleanup);\n\tRAII_VAR(struct ao2_container *, snapshots, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_json *, json, NULL, ast_json_unref);\n\tstruct ao2_iterator i;\n\tvoid *obj;\n\tstruct stasis_message_sanitizer *sanitize = stasis_app_get_sanitizer();\n\tcache = ast_channel_cache();\n\tif (!cache) {\n\t\tast_ari_response_error(\n\t\t\tresponse, 500, \"Internal Server Error\",\n\t\t\t\"Message bus not initialized\");\n\t\treturn;\n\t}\n\tao2_ref(cache, +1);\n\tsnapshots = stasis_cache_dump(cache, ast_channel_snapshot_type());\n\tif (!snapshots) {\n\t\tast_ari_response_alloc_failed(response);\n\t\treturn;\n\t}\n\tjson = ast_json_array_create();\n\tif (!json) {\n\t\tast_ari_response_alloc_failed(response);\n\t\treturn;\n\t}\n\ti = ao2_iterator_init(snapshots, 0);\n\twhile ((obj = ao2_iterator_next(&i))) {\n\t\tRAII_VAR(struct stasis_message *, msg, obj, ao2_cleanup);\n\t\tstruct ast_channel_snapshot *snapshot = stasis_message_data(msg);\n\t\tint r;\n\t\tif (sanitize && sanitize->channel_snapshot\n\t\t\t&& sanitize->channel_snapshot(snapshot)) {\n\t\t\tcontinue;\n\t\t}\n\t\tr = ast_json_array_append(\n\t\t\tjson, ast_channel_snapshot_to_json(snapshot, NULL));\n\t\tif (r != 0) {\n\t\t\tast_ari_response_alloc_failed(response);\n\t\t\tao2_iterator_destroy(&i);\n\t\t\treturn;\n\t\t}\n\t}\n\tao2_iterator_destroy(&i);\n\tast_ari_response_ok(response, ast_json_ref(json));\n}\n", "bug_type": null, "idx": 740}
{"project": "Asterisk", "target": 0, "func": "\nstatic int t38_automatic_reject(void *obj)\n{\n\tRAII_VAR(struct ast_sip_session *, session, obj, ao2_cleanup);\n\tRAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(session, \"t38\"), ao2_cleanup);\n\tstruct ast_sip_session_media *session_media;\n\tif (!datastore) {\n\t\treturn 0;\n\t}\n\tast_debug(2, \"Automatically rejecting T.38 request on channel '%s'\\n\",\n\t\tsession->channel ? ast_channel_name(session->channel) : \"<gone>\");\n\tsession_media = session->pending_media_state->default_session[AST_MEDIA_TYPE_IMAGE];\n\tt38_change_state(session, session_media, datastore->data, T38_REJECTED);\n\tast_sip_session_resume_reinvite(session);\n\treturn 0;\n}\n", "bug_type": null, "idx": 741}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int mark_object_as_stale_in_cache(struct sorcery_memory_cache *cache, const char *id)\n{\n\tstruct sorcery_memory_cached_object *cached;\n\tcached = ao2_find(cache->objects, id, OBJ_SEARCH_KEY | OBJ_NOLOCK);\n\tif (!cached) {\n\t\treturn -1;\n\t}\n\tast_assert(!strcmp(ast_sorcery_object_get_id(cached->object), id));\n\tobject_stale_callback(cached, cache, 0);\n\tao2_ref(cached, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 742}
{"project": "Asterisk", "target": 0, "func": "\nstatic int handle_call_forward(struct ast_dial *dial, struct ast_dial_channel *channel, struct ast_channel *chan)\n{\n\tstruct ast_channel *original = channel->owner;\n\tchar *tmp = ast_strdupa(ast_channel_call_forward(channel->owner));\n\tchar *tech = \"Local\", *device = tmp, *stuff;\n\tchar *predial_string = dial->options[AST_DIAL_OPTION_PREDIAL];\n\t\n\tif (FIND_RELATIVE_OPTION(dial, channel, AST_DIAL_OPTION_DISABLE_CALL_FORWARDING)) {\n\t\tast_hangup(original);\n\t\tchannel->owner = NULL;\n\t\treturn 0;\n\t}\n\t\n\tif ((stuff = strchr(tmp, '/'))) {\n\t\t*stuff++ = '\\0';\n\t\ttech = tmp;\n\t\tdevice = stuff;\n\t} else {\n\t\tconst char *forward_context;\n\t\tchar destination[AST_MAX_CONTEXT + AST_MAX_EXTENSION + 1];\n\t\tast_channel_lock(original);\n\t\tforward_context = pbx_builtin_getvar_helper(original, \"FORWARD_CONTEXT\");\n\t\tsnprintf(destination, sizeof(destination), \"%s@%s\", tmp, S_OR(forward_context, ast_channel_context(original)));\n\t\tast_channel_unlock(original);\n\t\tdevice = ast_strdupa(destination);\n\t}\n\t\n\tast_free(channel->tech);\n\tast_free(channel->device);\n\tast_free(channel->assignedid1);\n\tchannel->assignedid1 = NULL;\n\tast_free(channel->assignedid2);\n\tchannel->assignedid2 = NULL;\n\t\n\tchannel->tech = ast_strdup(tech);\n\tchannel->device = ast_strdup(device);\n\tAST_LIST_UNLOCK(&dial->channels);\n\t\n\tchannel->owner = NULL;\n\t\n\tbegin_dial_channel(channel, chan, chan ? 0 : 1, predial_string, original);\n\tast_channel_publish_dial_forward(chan, original, channel->owner, NULL, \"CANCEL\",\n\t\tast_channel_call_forward(original));\n\tast_hangup(original);\n\treturn 0;\n}\n", "bug_type": null, "idx": 743}
{"project": "Asterisk", "target": 0, "func": "struct ast_stream_topology *ast_get_topology_from_sdp(const struct ast_sdp *sdp, int g726_non_standard)\n{\n\tstruct ast_stream_topology *topology;\n\tint i;\n\ttopology = ast_stream_topology_alloc();\n\tif (!topology) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < ast_sdp_get_m_count(sdp); ++i) {\n\t\tstruct ast_stream *stream;\n\t\tstream = get_stream_from_m(ast_sdp_get_m(sdp, i), g726_non_standard);\n\t\tif (!stream) {\n\t\t\t\n\t\t\tast_stream_topology_free(topology);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (ast_stream_topology_append_stream(topology, stream) < 0) {\n\t\t\t\n\t\t\tast_stream_free(stream);\n\t\t\tast_stream_topology_free(topology);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn topology;\n}\n", "bug_type": null, "idx": 744}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void t38_parameters_ast_to_fax(struct ast_fax_t38_parameters *dst, const struct ast_control_t38_parameters *src)\n{\n\tdst->version = src->version;\n\tdst->max_ifp = src->max_ifp;\n\tdst->rate = src->rate;\n\tdst->rate_management = src->rate_management;\n\tdst->fill_bit_removal = src->fill_bit_removal;\n\tdst->transcoding_mmr = src->transcoding_mmr;\n\tdst->transcoding_jbig = src->transcoding_jbig;\n}\n", "bug_type": null, "idx": 745}
{"project": "Asterisk", "target": 0, "func": "static char *app = \"UserEvent\";\nstatic int userevent_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *parse;\n\tint x;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(eventname);\n\t\tAST_APP_ARG(extra)[100];\n\t);\n\tRAII_VAR(struct ast_json *, blob, NULL, ast_json_unref);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"UserEvent requires an argument (eventname,optional event body)\\n\");\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tblob = ast_json_pack(\"{s: s}\",\n\t\t\t     \"eventname\", args.eventname);\n\tif (!blob) {\n\t\treturn -1;\n\t}\n\tfor (x = 0; x < args.argc - 1; x++) {\n\t\tchar *key, *value = args.extra[x];\n\t\tstruct ast_json *json_value;\n\t\tkey = strsep(&value, \":\");\n\t\tif (!value) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = ast_strip(value);\n\t\tjson_value = ast_json_string_create(value);\n\t\tif (!json_value) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (ast_json_object_set(blob, key, json_value)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tast_channel_lock(chan);\n\tast_multi_object_blob_single_channel_publish(chan, ast_multi_user_event_type(), blob);\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 746}
{"project": "Asterisk", "target": 0, "func": "static void *recordthread(void *args)\n{\n\tstruct ast_conference *cnf = args;\n\tstruct ast_frame *f = NULL;\n\tint flags;\n\tstruct ast_filestream *s = NULL;\n\tint res = 0;\n\tint x;\n\tconst char *oldrecordingfilename = NULL;\n\tchar filename_buffer[PATH_MAX];\n\tif (!cnf || !cnf->lchan) {\n\t\tpthread_exit(0);\n\t}\n\tfilename_buffer[0] = '\\0';\n\tfilename_parse(cnf->recordingfilename, filename_buffer);\n\tast_stopstream(cnf->lchan);\n\tflags = O_CREAT | O_TRUNC | O_WRONLY;\n\tcnf->recording = MEETME_RECORD_ACTIVE;\n\twhile (ast_waitfor(cnf->lchan, -1) > -1) {\n\t\tif (cnf->recording == MEETME_RECORD_TERMINATE) {\n\t\t\tAST_LIST_LOCK(&confs);\n\t\t\tAST_LIST_UNLOCK(&confs);\n\t\t\tbreak;\n\t\t}\n\t\tif (!s && !(ast_strlen_zero(filename_buffer)) && (filename_buffer != oldrecordingfilename)) {\n\t\t\ts = ast_writefile(filename_buffer, cnf->recordingformat, NULL, flags, 0, AST_FILE_MODE);\n\t\t\toldrecordingfilename = filename_buffer;\n\t\t}\n\t\tf = ast_read(cnf->lchan);\n\t\tif (!f) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (f->frametype == AST_FRAME_VOICE) {\n\t\t\tast_mutex_lock(&cnf->listenlock);\n\t\t\tfor (x = 0; x < AST_FRAME_BITS; x++) {\n\t\t\t\t\n\t\t\t\tif (cnf->transframe[x]) {\n\t\t\t\t\tast_frfree(cnf->transframe[x]);\n\t\t\t\t\tcnf->transframe[x] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnf->origframe)\n\t\t\t\tast_frfree(cnf->origframe);\n\t\t\tcnf->origframe = ast_frdup(f);\n\t\t\tast_mutex_unlock(&cnf->listenlock);\n\t\t\tif (s)\n\t\t\t\tres = ast_writestream(s, f);\n\t\t\tif (res) {\n\t\t\t\tast_frfree(f);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tast_frfree(f);\n\t}\n\tcnf->recording = MEETME_RECORD_OFF;\n\tif (s)\n\t\tast_closestream(s);\n\tpthread_exit(0);\n}\n", "bug_type": null, "idx": 747}
{"project": "Asterisk", "target": 0, "func": "\nstruct pval *ael2_parse(char *filename, int *errors)\n{\n\tstruct pval *pvalue;\n\tstruct parse_io *io;\n\tchar *buffer;\n\tstruct stat stats;\n\tFILE *fin;\n\t\n\tio = calloc(sizeof(struct parse_io),1);\n\t\n\tprev_word = 0;\n\tmy_lineno = 1;\n\tinclude_stack_index=0;\n\tmy_col = 0;\n\t\n\tael_yylex_init(&io->scanner);\n\tfin = fopen(filename,\"r\");\n\tif ( !fin ) {\n\t\tast_log(LOG_ERROR,\"File %s could not be opened\\n\", filename);\n\t\t*errors = 1;\n\t\treturn 0;\n\t}\n\tif (my_file)\n\t\tfree(my_file);\n\tmy_file = strdup(filename);\n\tif (stat(filename, &stats)) {\n\t\tast_log(LOG_WARNING, \"failed to populate stats from file '%s'\\n\", filename);\n\t}\n\tbuffer = (char*)malloc(stats.st_size+2);\n\tif (fread(buffer, 1, stats.st_size, fin) != stats.st_size) {\n\t\tast_log(LOG_ERROR, \"fread() failed: %s\\n\", strerror(errno));\n\t}\t\t\t\n\tbuffer[stats.st_size]=0;\n\tfclose(fin);\n\tael_yy_scan_string (buffer ,io->scanner);\n\tael_yyset_lineno(1 , io->scanner);\n\t\n\tael_yyparse(io);\n\tpvalue = io->pval;\n\t*errors = io->syntax_error_count;\n\tael_yylex_destroy(io->scanner);\n\tfree(buffer);\n\tfree(io);\n\treturn pvalue;\n}\n", "bug_type": null, "idx": 748}
{"project": "Asterisk", "target": 0, "func": "void dListFindAndRemove(struct OOCTXT* pctxt, DList* pList, void *data)\n{\n   DListNode *pNode, *pNextNode;\n   for(pNode = pList->head; pNode !=0; pNode = pNextNode){\n      pNextNode = pNode->next;\n      if(pNode->data == data) \n         break;\n   }\n   if(pNode) {\n      dListRemove(pList, pNode);\n      memFreePtr(pctxt, pNode);\n   }\n}\n", "bug_type": null, "idx": 749}
{"project": "Asterisk", "target": 0, "func": "static int has_diversion_reason(pjsip_rx_data *rdata)\n{\n\tpjsip_param *reason;\n\tpjsip_fromto_hdr *hdr = get_diversion_header(rdata);\n\tif (!hdr) {\n\t\treturn 0;\n\t}\n\treason = get_diversion_reason(hdr);\n\treturn reason\n\t\t&& (!pj_stricmp2(&reason->value, SEND_TO_VM_REDIRECT_QUOTED_VALUE)\n\t\t\t|| !pj_stricmp2(&reason->value, SEND_TO_VM_REDIRECT_VALUE));\n}\n", "bug_type": null, "idx": 750}
{"project": "Asterisk", "target": 1, "func": "\nstatic int action_status(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *cvariables = astman_get_header(m, \"Variables\");\n\tchar *variables = ast_strdupa(S_OR(cvariables, \"\"));\n\tstruct ast_channel *c;\n\tchar bridge[256];\n\tstruct timeval now = ast_tvnow();\n\tlong elapsed_seconds = 0;\n\tint channels = 0;\n\tint all = ast_strlen_zero(name); \n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tchar idText[256];\n\tAST_DECLARE_APP_ARGS(vars,\n\t\tAST_APP_ARG(name)[100];\n\t);\n\tstruct ast_str *str = ast_str_create(1000);\n\tif (!ast_strlen_zero(id))\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", id);\n\telse\n\t\tidText[0] = '\\0';\n\tif (all)\n\t\tc = ast_channel_walk_locked(NULL);\n\telse {\n\t\tc = ast_get_channel_by_name_locked(name);\n\t\tif (!c) {\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\tast_free(str);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tastman_send_ack(s, m, \"Channel status will follow\");\n\tif (!ast_strlen_zero(cvariables)) {\n\t\tAST_STANDARD_APP_ARGS(vars, variables);\n\t}\n\t\n\twhile (c) {\n\t\tif (!ast_strlen_zero(cvariables)) {\n\t\t\tint i;\n\t\t\tast_str_reset(str);\n\t\t\tfor (i = 0; i < vars.argc; i++) {\n\t\t\t\tchar valbuf[512], *ret = NULL;\n\t\t\t\tif (vars.name[i][strlen(vars.name[i]) - 1] == ')') {\n\t\t\t\t\tif (ast_func_read(c, vars.name[i], valbuf, sizeof(valbuf)) < 0) {\n\t\t\t\t\t\tvalbuf[0] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tret = valbuf;\n\t\t\t\t} else {\n\t\t\t\t\tpbx_retrieve_variable(c, vars.name[i], &ret, valbuf, sizeof(valbuf), NULL);\n\t\t\t\t}\n\t\t\t\tast_str_append(&str, 0, \"Variable: %s=%s\\r\\n\", vars.name[i], ret);\n\t\t\t}\n\t\t}\n\t\tchannels++;\n\t\tif (c->_bridge)\n\t\t\tsnprintf(bridge, sizeof(bridge), \"BridgedChannel: %s\\r\\nBridgedUniqueid: %s\\r\\n\", c->_bridge->name, c->_bridge->uniqueid);\n\t\telse\n\t\t\tbridge[0] = '\\0';\n\t\tif (c->pbx) {\n\t\t\tif (c->cdr) {\n\t\t\t\telapsed_seconds = now.tv_sec - c->cdr->start.tv_sec;\n\t\t\t}\n\t\t\tastman_append(s,\n\t\t\t\"Event: Status\\r\\n\"\n\t\t\t\"Privilege: Call\\r\\n\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"CallerIDNum: %s\\r\\n\"\n\t\t\t\"CallerIDName: %s\\r\\n\"\n\t\t\t\"Accountcode: %s\\r\\n\"\n\t\t\t\"ChannelState: %d\\r\\n\"\n\t\t\t\"ChannelStateDesc: %s\\r\\n\"\n\t\t\t\"Context: %s\\r\\n\"\n\t\t\t\"Extension: %s\\r\\n\"\n\t\t\t\"Priority: %d\\r\\n\"\n\t\t\t\"Seconds: %ld\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"Uniqueid: %s\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"%s\"\n\t\t\t\"\\r\\n\",\n\t\t\tc->name,\n\t\t\tS_OR(c->cid.cid_num, \"\"),\n\t\t\tS_OR(c->cid.cid_name, \"\"),\n\t\t\tc->accountcode,\n\t\t\tc->_state,\n\t\t\tast_state2str(c->_state), c->context,\n\t\t\tc->exten, c->priority, (long)elapsed_seconds, bridge, c->uniqueid, ast_str_buffer(str), idText);\n\t\t} else {\n\t\t\tastman_append(s,\n\t\t\t\"Event: Status\\r\\n\"\n\t\t\t\"Privilege: Call\\r\\n\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"CallerIDNum: %s\\r\\n\"\n\t\t\t\"CallerIDName: %s\\r\\n\"\n\t\t\t\"Account: %s\\r\\n\"\n\t\t\t\"State: %s\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"Uniqueid: %s\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"%s\"\n\t\t\t\"\\r\\n\",\n\t\t\tc->name,\n\t\t\tS_OR(c->cid.cid_num, \"<unknown>\"),\n\t\t\tS_OR(c->cid.cid_name, \"<unknown>\"),\n\t\t\tc->accountcode,\n\t\t\tast_state2str(c->_state), bridge, c->uniqueid, ast_str_buffer(str), idText);\n\t\t}\n\t\tast_channel_unlock(c);\n\t\tif (!all)\n\t\t\tbreak;\n\t\tc = ast_channel_walk_locked(c);\n\t}\n\tastman_append(s,\n\t\"Event: StatusComplete\\r\\n\"\n\t\"%s\"\n\t\"Items: %d\\r\\n\"\n\t\"\\r\\n\", idText, channels);\n\tast_free(str);\n\treturn 0;\n}\n", "bug_type": "CVE-2012-2414-2", "idx": 751}
{"project": "Asterisk", "target": 0, "func": "\nstatic int begin_dial_prerun(struct ast_dial_channel *channel, struct ast_channel *chan, struct ast_format_cap *cap, const char *predial_string)\n{\n\tchar numsubst[AST_MAX_EXTENSION];\n\tstruct ast_format_cap *cap_all_audio = NULL;\n\tstruct ast_format_cap *cap_request;\n\tstruct ast_format_cap *requester_cap = NULL;\n\tstruct ast_assigned_ids assignedids = {\n\t\t.uniqueid = channel->assignedid1,\n\t\t.uniqueid2 = channel->assignedid2,\n\t};\n\tif (chan) {\n\t\tint max_forwards;\n\t\tast_channel_lock(chan);\n\t\tmax_forwards = ast_max_forwards_get(chan);\n\t\trequester_cap = ao2_bump(ast_channel_nativeformats(chan));\n\t\tast_channel_unlock(chan);\n\t\tif (max_forwards <= 0) {\n\t\t\tast_log(LOG_WARNING, \"Cannot dial from channel '%s'. Max forwards exceeded\\n\",\n\t\t\t\t\tast_channel_name(chan));\n\t\t}\n\t}\n\tif (!channel->owner) {\n\t\t\n\t\tast_copy_string(numsubst, channel->device, sizeof(numsubst));\n\t\tif (cap && ast_format_cap_count(cap)) {\n\t\t\tcap_request = cap;\n\t\t} else if (requester_cap) {\n\t\t\tcap_request = requester_cap;\n\t\t} else {\n\t\t\tcap_all_audio = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\t\t\tast_format_cap_append_by_type(cap_all_audio, AST_MEDIA_TYPE_AUDIO);\n\t\t\tcap_request = cap_all_audio;\n\t\t}\n\t\t\n\t\tif (!(channel->owner = ast_request(channel->tech, cap_request, &assignedids, chan, numsubst, &channel->cause))) {\n\t\t\tao2_cleanup(cap_all_audio);\n\t\t\treturn -1;\n\t\t}\n\t\tcap_request = NULL;\n\t\tao2_cleanup(requester_cap);\n\t\tao2_cleanup(cap_all_audio);\n\t}\n\tif (chan) {\n\t\tast_channel_lock_both(chan, channel->owner);\n\t} else {\n\t\tast_channel_lock(channel->owner);\n\t}\n\tast_channel_stage_snapshot(channel->owner);\n\tast_channel_appl_set(channel->owner, \"AppDial2\");\n\tast_channel_data_set(channel->owner, \"(Outgoing Line)\");\n\tmemset(ast_channel_whentohangup(channel->owner), 0, sizeof(*ast_channel_whentohangup(channel->owner)));\n\t\n\tif (chan) {\n\t\tast_channel_inherit_variables(chan, channel->owner);\n\t\tast_channel_datastore_inherit(chan, channel->owner);\n\t\tast_max_forwards_decrement(channel->owner);\n\t\t\n\t\tast_party_redirecting_copy(ast_channel_redirecting(channel->owner), ast_channel_redirecting(chan));\n\t\tast_channel_dialed(channel->owner)->transit_network_select = ast_channel_dialed(chan)->transit_network_select;\n\t\tast_connected_line_copy_from_caller(ast_channel_connected(channel->owner), ast_channel_caller(chan));\n\t\tast_channel_language_set(channel->owner, ast_channel_language(chan));\n\t\tif (channel->options[AST_DIAL_OPTION_DIAL_REPLACES_SELF]) {\n\t\t\tast_channel_req_accountcodes(channel->owner, chan, AST_CHANNEL_REQUESTOR_REPLACEMENT);\n\t\t} else {\n\t\t\tast_channel_req_accountcodes(channel->owner, chan, AST_CHANNEL_REQUESTOR_BRIDGE_PEER);\n\t\t}\n\t\tif (ast_strlen_zero(ast_channel_musicclass(channel->owner)))\n\t\t\tast_channel_musicclass_set(channel->owner, ast_channel_musicclass(chan));\n\t\tast_channel_adsicpe_set(channel->owner, ast_channel_adsicpe(chan));\n\t\tast_channel_transfercapability_set(channel->owner, ast_channel_transfercapability(chan));\n\t\tast_channel_unlock(chan);\n\t}\n\tast_channel_stage_snapshot_done(channel->owner);\n\tast_channel_unlock(channel->owner);\n\tif (!ast_strlen_zero(predial_string)) {\n\t\tif (chan) {\n\t\t\tast_autoservice_start(chan);\n\t\t}\n\t\tast_pre_call(channel->owner, predial_string);\n\t\tif (chan) {\n\t\t\tast_autoservice_stop(chan);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 752}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void transfer_data_destroy(void *obj)\n{\n\tstruct transfer_data *trnf_data = obj;\n\tast_free(trnf_data->target);\n\tao2_cleanup(trnf_data->session);\n}\n", "bug_type": null, "idx": 753}
{"project": "Asterisk", "target": 0, "func": "struct ast_smdi_md_message * AST_OPTIONAL_API_NAME(ast_smdi_md_message_wait)(struct ast_smdi_interface *iface, int timeout)\n{\n\tstruct ast_flags options = { 0 };\n\treturn smdi_message_wait(iface, timeout, SMDI_MD, NULL, options);\n}\n", "bug_type": null, "idx": 754}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_hangup_hook(struct ast_bridge_features *features,\n\tast_bridge_hook_callback callback,\n\tvoid *hook_pvt,\n\tast_bridge_hook_pvt_destructor destructor,\n\tenum ast_bridge_hook_remove_flags remove_flags)\n{\n\treturn bridge_other_hook(features, callback, hook_pvt, destructor, remove_flags,\n\t\tAST_BRIDGE_HOOK_TYPE_HANGUP);\n}\n", "bug_type": null, "idx": 755}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_session_media_state *ast_sip_session_media_state_clone(const struct ast_sip_session_media_state *media_state)\n{\n\tstruct ast_sip_session_media_state *cloned;\n\tint index;\n\tif (!media_state) {\n\t\treturn NULL;\n\t}\n\tcloned = ast_sip_session_media_state_alloc();\n\tif (!cloned) {\n\t\treturn NULL;\n\t}\n\tif (media_state->topology) {\n\t\tcloned->topology = ast_stream_topology_clone(media_state->topology);\n\t\tif (!cloned->topology) {\n\t\t\tast_sip_session_media_state_free(cloned);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tfor (index = 0; index < AST_VECTOR_SIZE(&media_state->sessions); ++index) {\n\t\tstruct ast_sip_session_media *session_media = AST_VECTOR_GET(&media_state->sessions, index);\n\t\tenum ast_media_type type = ast_stream_get_type(ast_stream_topology_get_stream(cloned->topology, index));\n\t\tAST_VECTOR_REPLACE(&cloned->sessions, index, ao2_bump(session_media));\n\t\tif (ast_stream_get_state(ast_stream_topology_get_stream(cloned->topology, index)) != AST_STREAM_STATE_REMOVED &&\n\t\t\t!cloned->default_session[type]) {\n\t\t\tcloned->default_session[type] = session_media;\n\t\t}\n\t}\n\tfor (index = 0; index < AST_VECTOR_SIZE(&media_state->read_callbacks); ++index) {\n\t\tstruct ast_sip_session_media_read_callback_state *read_callback = AST_VECTOR_GET_ADDR(&media_state->read_callbacks, index);\n\t\tAST_VECTOR_REPLACE(&cloned->read_callbacks, index, *read_callback);\n\t}\n\treturn cloned;\n}\n", "bug_type": null, "idx": 756}
{"project": "Asterisk", "target": 0, "func": "\t\tstruct ast_bridge_channel *bridge_channel);\nstatic int simple_bridge_join(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)\n{\n\tstruct ast_channel *c0 = AST_LIST_FIRST(&bridge->channels)->chan;\n\tstruct ast_channel *c1 = AST_LIST_LAST(&bridge->channels)->chan;\n\t\n\tif (c0 == c1) {\n\t\treturn 0;\n\t}\n\tif (ast_channel_make_compatible(c0, c1)) {\n\t\treturn -1;\n\t}\n\t\n\tsimple_bridge_stream_topology_changed(bridge, NULL);\n\treturn 0;\n}\n", "bug_type": null, "idx": 757}
{"project": "Asterisk", "target": 0, "func": "int ast_json_array_remove(struct ast_json *array, size_t index)\n{\n\treturn json_array_remove((json_t *)array, index);\n}\n", "bug_type": null, "idx": 758}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\treturn ast_custom_function_unregister(&timeout_function);\n}\n", "bug_type": null, "idx": 759}
{"project": "Asterisk", "target": 0, "func": "static char *handle_skel_show_config(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tRAII_VAR(struct skel_config *, cfg, NULL, ao2_cleanup);\n\tswitch(cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"skel show config\";\n\t\te->usage =\n\t\t\t\"Usage: skel show config\\n\"\n\t\t\t\"       List app_skel global config\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (!(cfg = ao2_global_obj_ref(globals)) || !cfg->global) {\n\t\treturn NULL;\n\t}\n\tast_cli(a->fd, \"games per call:  %u\\n\", cfg->global->num_games);\n\tast_cli(a->fd, \"computer cheats: %s\\n\", AST_CLI_YESNO(cfg->global->cheat));\n\tast_cli(a->fd, \"\\n\");\n\tast_cli(a->fd, \"Sounds\\n\");\n\tast_cli(a->fd, \"  prompt:      %s\\n\", cfg->global->prompt);\n\tast_cli(a->fd, \"  wrong guess: %s\\n\", cfg->global->wrong);\n\tast_cli(a->fd, \"  right guess: %s\\n\", cfg->global->right);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 760}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *alloc_device_state_info(void)\n{\n\treturn ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, 1, NULL, NULL);\n}\n", "bug_type": null, "idx": 761}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_unregister_application(app_originate);\n}\n", "bug_type": null, "idx": 762}
{"project": "Asterisk", "target": 0, "func": "int ast_stream_topology_equal(const struct ast_stream_topology *left,\n\tconst struct ast_stream_topology *right)\n{\n\tint index;\n\tast_assert(left != NULL);\n\tast_assert(right != NULL);\n\tif (ast_stream_topology_get_count(left) != ast_stream_topology_get_count(right)) {\n\t\treturn 0;\n\t}\n\tfor (index = 0; index < ast_stream_topology_get_count(left); ++index) {\n\t\tconst struct ast_stream *left_stream = ast_stream_topology_get_stream(left, index);\n\t\tconst struct ast_stream *right_stream = ast_stream_topology_get_stream(right, index);\n\t\tif (ast_stream_get_type(left_stream) != ast_stream_get_type(right_stream)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (ast_stream_get_state(left_stream) != ast_stream_get_state(right_stream)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!ast_stream_get_formats(left_stream) && ast_stream_get_formats(right_stream) &&\n\t\t\tast_format_cap_count(ast_stream_get_formats(right_stream))) {\n\t\t\t\n\t\t\treturn 0;\n\t\t} else if (!ast_stream_get_formats(right_stream) && ast_stream_get_formats(left_stream) &&\n\t\t\tast_format_cap_count(ast_stream_get_formats(left_stream))) {\n\t\t\treturn 0;\n\t\t} else if (ast_stream_get_formats(left_stream) && ast_stream_get_formats(right_stream) &&\n\t\t\t!ast_format_cap_identical(ast_stream_get_formats(left_stream), ast_stream_get_formats(right_stream))) {\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t\tif (strcmp(ast_stream_get_name(left_stream), ast_stream_get_name(right_stream))) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 763}
{"project": "Asterisk", "target": 0, "func": "static struct stasis_forward *topic_forwarder;\nstatic int action_presencestatelist(struct mansession *s, const struct message *m)\n{\n\tRAII_VAR(struct ao2_container *, presence_states, NULL, ao2_cleanup);\n\tconst char *action_id = astman_get_header(m, \"ActionID\");\n\tstruct stasis_message *msg;\n\tstruct ao2_iterator it_states;\n\tint count = 0;\n\tpresence_states = stasis_cache_dump(ast_presence_state_cache(),\n\t\tast_presence_state_message_type());\n\tif (!presence_states) {\n\t\tastman_send_error(s, m, \"Memory Allocation Failure\");\n\t\treturn 0;\n\t}\n\tastman_send_listack(s, m, \"Presence State Changes will follow\", \"start\");\n\tit_states = ao2_iterator_init(presence_states, 0);\n\tfor (; (msg = ao2_iterator_next(&it_states)); ao2_ref(msg, -1)) {\n\t\tstruct ast_manager_event_blob *blob = stasis_message_to_ami(msg);\n\t\tif (!blob) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t\tastman_append(s, \"Event: %s\\r\\n\", blob->manager_event);\n\t\tif (!ast_strlen_zero(action_id)) {\n\t\t\tastman_append(s, \"ActionID: %s\\r\\n\", action_id);\n\t\t}\n\t\tastman_append(s, \"%s\\r\\n\", blob->extra_fields);\n\t\tao2_ref(blob, -1);\n\t}\n\tao2_iterator_destroy(&it_states);\n\tastman_send_list_complete_start(s, m, \"PresenceStateListComplete\", count);\n\tastman_send_list_complete_end(s);\n\treturn 0;\n}\n", "bug_type": null, "idx": 764}
{"project": "Asterisk", "target": 0, "func": "void destroy_pval(pval *item) \n{\n\tpval *i,*nxt;\n\tfor (i=item; i; i=nxt) {\n\t\tnxt = i->next;\n\t\tdestroy_pval_item(i);\n\t}\n}\n", "bug_type": null, "idx": 765}
{"project": "Asterisk", "target": 0, "func": "private void\nnode__put(EditLine *el, key_node_t *ptr)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\tif (ptr->next != NULL) {\n\t\tnode__put(el, ptr->next);\n\t\tptr->next = NULL;\n\t}\n\tnode__put(el, ptr->sibling);\n\tswitch (ptr->type) {\n\tcase XK_CMD:\n\tcase XK_NOD:\n\t\tbreak;\n\tcase XK_EXE:\n\tcase XK_STR:\n\t\tif (ptr->val.str != NULL)\n\t\t\tel_free((ptr_t) ptr->val.str);\n\t\tbreak;\n\tdefault:\n\t\tEL_ABORT((el->el_errfile, \"Bad XK_ type %d\\n\", ptr->type));\n\t\tbreak;\n\t}\n\tel_free((ptr_t) ptr);\n}\n", "bug_type": null, "idx": 766}
{"project": "Asterisk", "target": 0, "func": "int ast_pre_call(struct ast_channel *chan, const char *sub_args)\n{\n\tint (*pre_call)(struct ast_channel *chan, const char *sub_args);\n\tast_channel_lock(chan);\n\tpre_call = ast_channel_tech(chan)->pre_call;\n\tif (pre_call) {\n\t\tint res;\n\t\tres = pre_call(chan, sub_args);\n\t\tast_channel_unlock(chan);\n\t\treturn res;\n\t}\n\tast_channel_unlock(chan);\n\treturn ast_app_exec_sub(NULL, chan, sub_args, 0);\n}\n", "bug_type": null, "idx": 767}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_custom_function talk_detect_function = {\n\t.name = \"TALK_DETECT\",\n\t.write = talk_detect_fn_write,\n};\n", "bug_type": null, "idx": 768}
{"project": "Asterisk", "target": 0, "func": "int dnsmgr_init(void)\n{\n\tif (!(sched = ast_sched_context_create())) {\n\t\tast_log(LOG_ERROR, \"Unable to create schedule context.\\n\");\n\t\treturn -1;\n\t}\n\tast_cli_register(&cli_reload);\n\tast_cli_register(&cli_status);\n\tast_cli_register(&cli_refresh);\n\tast_register_cleanup(dnsmgr_shutdown);\n\treturn do_reload(1);\n}\n", "bug_type": null, "idx": 769}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225Content (OOCTXT* pctxt, H225Content* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 12);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 11);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = encodeOctetString (pctxt, pvalue->u.raw->numocts, pvalue->u.raw->data);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = encodeConstrainedStringEx (pctxt, pvalue->u.text, 0, 8, 7, 7);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = encodeBMPString (pctxt, pvalue->u.unicode, 0);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = encodeBit (pctxt, (ASN1BOOL)pvalue->u.bool_);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 5:\n            stat = encodeConsUnsigned (pctxt, pvalue->u.number8, 0U, 255U);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 6:\n            stat = encodeConsUnsigned (pctxt, pvalue->u.number16, 0U, 65535U);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 7:\n            stat = encodeConsUnsigned (pctxt, pvalue->u.number32, 0U, ASN1UINT_MAX);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 8:\n            stat = asn1PE_H225GenericIdentifier (pctxt, pvalue->u.id);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 9:\n            stat = asn1PE_H225AliasAddress (pctxt, pvalue->u.alias);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 10:\n            stat = asn1PE_H225TransportAddress (pctxt, pvalue->u.transport);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 11:\n            stat = asn1PE_H225Content_compound (pctxt, pvalue->u.compound);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 12:\n            stat = asn1PE_H225Content_nested (pctxt, pvalue->u.nested);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 13);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 770}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225RequestInProgress (OOCTXT* pctxt, H225RequestInProgress* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.tokensPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.cryptoTokensPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.integrityCheckValuePresent = optbit;\n   \n   invokeStartElement (pctxt, \"requestSeqNum\", -1);\n   stat = asn1PD_H225RequestSeqNum (pctxt, &pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"requestSeqNum\", -1);\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   \n   if (pvalue->m.tokensPresent) {\n      invokeStartElement (pctxt, \"tokens\", -1);\n      stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"tokens\", -1);\n   }\n   \n   if (pvalue->m.cryptoTokensPresent) {\n      invokeStartElement (pctxt, \"cryptoTokens\", -1);\n      stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"cryptoTokens\", -1);\n   }\n   \n   if (pvalue->m.integrityCheckValuePresent) {\n      invokeStartElement (pctxt, \"integrityCheckValue\", -1);\n      stat = asn1PD_H225ICV (pctxt, &pvalue->integrityCheckValue);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"integrityCheckValue\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"delay\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->delay, 1U, 65535U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->delay);\n   invokeEndElement (pctxt, \"delay\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 771}
{"project": "Asterisk", "target": 0, "func": "\nstatic int ast_srtp_unprotect(struct ast_srtp *srtp, void *buf, int *len, int rtcp)\n{\n\tint res = 0;\n\tint i;\n\tint retry = 0;\n\tstruct ast_rtp_instance_stats stats = {0,};\ntryagain:\n\tfor (i = 0; i < 2; i++) {\n\t\tres = rtcp ? srtp_unprotect_rtcp(srtp->session, buf, len) : srtp_unprotect(srtp->session, buf, len);\n\t\tif (res != err_status_no_ctx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (srtp->cb && srtp->cb->no_ctx) {\n\t\t\tif (ast_rtp_instance_get_stats(srtp->rtp, &stats, AST_RTP_INSTANCE_STAT_REMOTE_SSRC)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (srtp->cb->no_ctx(srtp->rtp, stats.remote_ssrc, srtp->data) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retry == 0  && res == err_status_replay_old) {\n\t\tast_log(AST_LOG_NOTICE, \"SRTP unprotect failed with %s, retrying\\n\", srtp_errstr(res));\n\t\tif (srtp->session) {\n\t\t\tstruct ast_srtp_policy *policy;\n\t\t\tstruct ao2_iterator it;\n\t\t\tint policies_count;\n\t\t\t\n\t\t\tast_debug(5, \"SRTP destroy before re-create\\n\");\n\t\t\tsrtp_dealloc(srtp->session);\n\t\t\t\n\t\t\tpolicies_count = ao2_container_count(srtp->policies);\n\t\t\t\n\t\t\tit = ao2_iterator_init(srtp->policies, 0);\n\t\t\tpolicy = ao2_iterator_next(&it);\n\t\t\tast_debug(5, \"SRTP try to re-create\\n\");\n\t\t\tif (policy) {\n\t\t\t\tint res_srtp_create = srtp_create(&srtp->session, &policy->sp);\n\t\t\t\tif (res_srtp_create == err_status_ok) {\n\t\t\t\t\tast_debug(5, \"SRTP re-created with first policy\\n\");\n\t\t\t\t\tao2_t_ref(policy, -1, \"Unreffing first policy for re-creating srtp session\");\n\t\t\t\t\t\n\t\t\t\t\tif (policies_count > 1) {\n\t\t\t\t\t\tast_debug(5, \"Add all the other %d policies\\n\",\n\t\t\t\t\t\t\tpolicies_count - 1);\n\t\t\t\t\t\twhile ((policy = ao2_iterator_next(&it))) {\n\t\t\t\t\t\t\tsrtp_add_stream(srtp->session, &policy->sp);\n\t\t\t\t\t\t\tao2_t_ref(policy, -1, \"Unreffing n-th policy for re-creating srtp session\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tretry++;\n\t\t\t\t\tao2_iterator_destroy(&it);\n\t\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\t\tast_log(LOG_ERROR, \"SRTP session could not be re-created after unprotect failure: %s\\n\", srtp_errstr(res_srtp_create));\n\t\t\t\t\n\t\t\t\tsrtp->session = NULL;\n\t\t\t\tao2_t_ref(policy, -1, \"Unreffing first policy after srtp_create failed\");\n\t\t\t}\n\t\t\tao2_iterator_destroy(&it);\n\t\t}\n\t}\n\tif (!srtp->session) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (res != err_status_ok && res != err_status_replay_fail ) {\n\t\t\n\t\tif (rtcp) {\n\t\t\tast_verb(2, \"SRTCP unprotect failed on SSRC %u because of %s\\n\",\n\t\t\t\tast_rtp_instance_get_ssrc(srtp->rtp), srtp_errstr(res));\n\t\t} else {\n\t\t\tif ((srtp->warned >= 10) && !((srtp->warned - 10) % 150)) {\n\t\t\t\tast_verb(2, \"SRTP unprotect failed on SSRC %u because of %s %d\\n\",\n\t\t\t\t\tast_rtp_instance_get_ssrc(srtp->rtp), srtp_errstr(res), srtp->warned);\n\t\t\t\tsrtp->warned = 11;\n\t\t\t} else {\n\t\t\t\tsrtp->warned++;\n\t\t\t}\n\t\t}\n\t\terrno = EAGAIN;\n\t\treturn -1;\n\t}\n\treturn *len;\n}\n", "bug_type": null, "idx": 772}
{"project": "Asterisk", "target": 0, "func": "int __attribute__((format(printf,1,2))) chat( const char *format, ...)\n{\n    va_list ap;\n    int result = 0;\n    if (verboselevel > 5)\n    {\n\tva_start( ap, format);\n\tresult = vfprintf( stderr, format, ap);\n\tva_end( ap);\n    }\n    return result;\n}\n", "bug_type": null, "idx": 773}
{"project": "Asterisk", "target": 0, "func": "\nstatic int xmpp_client_subscribe_user(void *obj, void *arg, int flags)\n{\n\tstruct ast_xmpp_buddy *buddy = obj;\n\tstruct ast_xmpp_client *client = arg;\n\tif (!buddy->subscribe) {\n\t\treturn 0;\n\t}\n\tif (ast_xmpp_client_send(client, iks_make_s10n(IKS_TYPE_SUBSCRIBE, buddy->id,\n\t\t\t\t\t\t       \"Greetings! I am the Asterisk Open Source PBX and I want to subscribe to your presence\\n\"))) {\n\t\tast_log(LOG_WARNING, \"Could not send subscription for '%s' on client '%s'\\n\",\n\t\t\tbuddy->id, client->name);\n\t}\n\tbuddy->subscribe = 0;\n\treturn 0;\n}\n", "bug_type": null, "idx": 774}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_channel *local_request(const char *type, struct ast_format_cap *cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause)\n{\n\tstruct local_pvt *p;\n\tstruct ast_channel *chan;\n\tast_callid callid;\n\t\n\tp = local_alloc(data, cap);\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\tcallid = ast_read_threadstorage_callid();\n\tchan = ast_unreal_new_channels(&p->base, &local_tech, AST_STATE_DOWN, AST_STATE_RING,\n\t\tp->exten, p->context, assignedids, requestor, callid);\n\tif (chan) {\n\t\tao2_link(locals, p);\n\t}\n\tao2_ref(p, -1); \n\treturn chan;\n}\n", "bug_type": null, "idx": 775}
{"project": "Asterisk", "target": 0, "func": "static struct ast_channel_snapshot *get_replace_channel_snapshot(struct ast_channel *chan)\n{\n\tstruct replace_channel_store *replace = get_replace_channel_store(chan, 1);\n\tstruct ast_channel_snapshot *replace_channel_snapshot;\n\tif (!replace) {\n\t\treturn NULL;\n\t}\n\treplace_channel_snapshot = replace->snapshot;\n\treplace->snapshot = NULL;\n\treturn replace_channel_snapshot;\n}\n", "bug_type": null, "idx": 776}
{"project": "Asterisk", "target": 0, "func": "static struct parking_lot *create_dynamic_lot_full(const char *name, struct ast_channel *chan, int forced)\n{\n\tRAII_VAR(struct parking_lot_cfg *, cfg, NULL, ao2_cleanup);\n\tRAII_VAR(struct parking_lot *, template_lot, NULL, ao2_cleanup);\n\tstruct parking_lot *lot;\n\tconst char *dyn_context;\n\tconst char *dyn_exten;\n\tconst char *dyn_range;\n\tconst char *template_name;\n\tconst char *chan_template_name;\n\tint dyn_start;\n\tint dyn_end;\n\tif (!forced && !parking_dynamic_lots_enabled()) {\n\t\treturn NULL;\n\t}\n\tast_channel_lock(chan);\n\tchan_template_name = ast_strdupa(S_OR(pbx_builtin_getvar_helper(chan, \"PARKINGDYNAMIC\"), \"\"));\n\tdyn_context = ast_strdupa(S_OR(pbx_builtin_getvar_helper(chan, \"PARKINGDYNCONTEXT\"), \"\"));\n\tdyn_exten = ast_strdupa(S_OR(pbx_builtin_getvar_helper(chan, \"PARKINGDYNEXTEN\"), \"\"));\n\tdyn_range = ast_strdupa(S_OR(pbx_builtin_getvar_helper(chan, \"PARKINGDYNPOS\"), \"\"));\n\tast_channel_unlock(chan);\n\ttemplate_name = S_OR(chan_template_name, DEFAULT_PARKING_LOT);\n\ttemplate_lot = parking_lot_find_by_name(template_name);\n\tif (!template_lot) {\n\t\tast_log(LOG_ERROR, \"Lot %s does not exist. Can not use it as a dynamic parking lot template.\\n\",\n\t\t\ttemplate_name);\n\t\treturn NULL;\n\t}\n\tcfg = clone_parkinglot_cfg(template_lot->cfg, name);\n\tif (!cfg) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate dynamic parking lot configuration.\\n\");\n\t\treturn NULL;\n\t}\n\tif (!ast_strlen_zero(dyn_exten)) {\n\t\tast_string_field_set(cfg, parkext, dyn_exten);\n\t}\n\tif (!ast_strlen_zero(dyn_context)) {\n\t\tast_string_field_set(cfg, parking_con, dyn_context);\n\t}\n\tif (!ast_strlen_zero(dyn_range)) {\n\t\tif (sscanf(dyn_range, \"%30d-%30d\", &dyn_start, &dyn_end) != 2) {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Invalid parking range %s specified in PARKINGDYNPOS: could not parse minimum/maximum parking space range\\n\", dyn_range);\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (dyn_end < dyn_start || dyn_start < 0) {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Invalid parking range %s specified for PARKINGDYNPOS: end parking space must be greater than starting parking space.\\n\", dyn_range);\n\t\t\t\treturn NULL;\n\t\t}\n\t\tcfg->parking_start = dyn_start;\n\t\tcfg->parking_stop = dyn_end;\n\t}\n\tif (parking_lot_cfg_create_extensions(cfg)) {\n\t\tast_log(LOG_ERROR, \"Extensions for dynamic parking lot '%s' could not be registered. Dynamic lot creation failed.\\n\", name);\n\t\treturn NULL;\n\t}\n\tao2_lock(parking_lot_container);\n\tif ((lot = parking_lot_find_by_name(name))) {\n\t\tao2_unlock(parking_lot_container);\n\t\tast_log(LOG_ERROR, \"Started creating dynamic parking lot '%s', but a parking lot with that name already exists.\\n\", name);\n\t\tao2_ref(lot, -1);\n\t\treturn NULL;\n\t}\n\tlot = parking_lot_build_or_update(cfg, 1);\n\tao2_unlock(parking_lot_container);\n\tif (!lot) {\n\t\tast_log(LOG_NOTICE, \"Failed to build dynamic parking lot '%s'\\n\", name);\n\t}\n\treturn lot;\n}\n", "bug_type": null, "idx": 777}
{"project": "Asterisk", "target": 0, "func": "struct stasis_cp_single *stasis_cp_single_create(struct stasis_cp_all *all,\n\tconst char *name)\n{\n\tRAII_VAR(struct stasis_cp_single *, one, NULL, ao2_cleanup);\n\tone = stasis_cp_sink_create(all, name);\n\tif (!one) {\n\t\treturn NULL;\n\t}\n\tone->forward_topic_to_all = stasis_forward_all(one->topic, all->topic);\n\tif (!one->forward_topic_to_all) {\n\t\treturn NULL;\n\t}\n\tone->forward_cached_to_all = stasis_forward_all(\n\t\tstasis_caching_get_topic(one->topic_cached), all->topic_cached);\n\tif (!one->forward_cached_to_all) {\n\t\treturn NULL;\n\t}\n\tao2_ref(one, +1);\n\treturn one;\n}\n", "bug_type": null, "idx": 778}
{"project": "Asterisk", "target": 0, "func": "static enum ast_test_result_state wait_for_completion(struct ast_test *test, struct simple_task_data *std)\n{\n\tstruct timeval start = ast_tvnow();\n\tstruct timespec end = {\n\t\t.tv_sec = start.tv_sec + 5,\n\t\t.tv_nsec = start.tv_usec * 1000\n\t};\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\tSCOPED_MUTEX(lock, &std->lock);\n\twhile (!std->task_executed) {\n\t\tif (ast_cond_timedwait(&std->cond, lock, &end) == ETIMEDOUT) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!std->task_executed) {\n\t\tast_test_status_update(test, \"Task execution did not occur\\n\");\n\t\tres = AST_TEST_FAIL;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 779}
{"project": "Asterisk", "target": 0, "func": " */\nstatic unsigned misdn_to_PartyNumber_plan(enum mISDN_NUMBER_PLAN number_plan)\n{\n\tunsigned party_plan;\n\tswitch (number_plan) {\n\tdefault:\n\tcase NUMPLAN_UNKNOWN:\n\t\tparty_plan = 0;\n\t\tbreak;\n\tcase NUMPLAN_ISDN:\n\t\tparty_plan = 1;\n\t\tbreak;\n\tcase NUMPLAN_DATA:\n\t\tparty_plan = 3;\n\t\tbreak;\n\tcase NUMPLAN_TELEX:\n\t\tparty_plan = 4;\n\t\tbreak;\n\tcase NUMPLAN_NATIONAL:\n\t\tparty_plan = 8;\n\t\tbreak;\n\tcase NUMPLAN_PRIVATE:\n\t\tparty_plan = 5;\n\t\tbreak;\n\t}\n\treturn party_plan;\n}\n", "bug_type": null, "idx": 780}
{"project": "Asterisk", "target": 0, "func": "static void set_ping_timer(struct unistimsession *pte)\n{\n\tunsigned int tick = 0;\t\n\tpte->timeout = pte->tick_next_ping;\n\tDEBUG_TIMER(\"tick = %u next ping at %u tick\\n\", tick, pte->timeout);\n\treturn;\n}\n", "bug_type": null, "idx": 781}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum stasis_app_subscribe_res app_unsubscribe(\n\tstruct stasis_app *app, const char *uri,\n\tstruct stasis_app_event_source *event_source)\n{\n\tconst char *app_name = stasis_app_name(app);\n\tconst char *id = uri + strlen(event_source->scheme);\n\tif (!event_source->is_subscribed ||\n\t    (!event_source->is_subscribed(app, id))) {\n\t\treturn STASIS_ASR_EVENT_SOURCE_NOT_FOUND;\n\t}\n\tast_debug(3, \"%s: Unsubscribing from %s\\n\", app_name, uri);\n\tif (!event_source->unsubscribe || (event_source->unsubscribe(app, id))) {\n\t\tast_log(LOG_WARNING, \"Error unsubscribing app '%s' to '%s'\\n\",\n\t\t\tapp_name, uri);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 782}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245ConferenceResponse (OOCTXT* pctxt, H245ConferenceResponse* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 8);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 7);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245ConferenceResponse_mCTerminalIDResponse (pctxt, pvalue->u.mCTerminalIDResponse);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245ConferenceResponse_terminalIDResponse (pctxt, pvalue->u.terminalIDResponse);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245ConferenceResponse_conferenceIDResponse (pctxt, pvalue->u.conferenceIDResponse);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = asn1PE_H245ConferenceResponse_passwordResponse (pctxt, pvalue->u.passwordResponse);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 5:\n            stat = asn1PE_H245ConferenceResponse_terminalListResponse (pctxt, pvalue->u.terminalListResponse);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 6:\n            \n            break;\n         \n         case 7:\n            \n            break;\n         \n         case 8:\n            stat = asn1PE_H245ConferenceResponse_makeMeChairResponse (pctxt, pvalue->u.makeMeChairResponse);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 9);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 9:\n            stat = asn1PE_H245ConferenceResponse_extensionAddressResponse (&lctxt, pvalue->u.extensionAddressResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 10:\n            stat = asn1PE_H245ConferenceResponse_chairTokenOwnerResponse (&lctxt, pvalue->u.chairTokenOwnerResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 11:\n            stat = asn1PE_H245ConferenceResponse_terminalCertificateResponse (&lctxt, pvalue->u.terminalCertificateResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 12:\n            stat = asn1PE_H245ConferenceResponse_broadcastMyLogicalChannelResponse (&lctxt, pvalue->u.broadcastMyLogicalChannelResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 13:\n            stat = asn1PE_H245ConferenceResponse_makeTerminalBroadcasterResponse (&lctxt, pvalue->u.makeTerminalBroadcasterResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 14:\n            stat = asn1PE_H245ConferenceResponse_sendThisSourceResponse (&lctxt, pvalue->u.sendThisSourceResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 15:\n            stat = asn1PE_H245RequestAllTerminalIDsResponse (&lctxt, pvalue->u.requestAllTerminalIDsResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 16:\n            stat = asn1PE_H245RemoteMCResponse (&lctxt, pvalue->u.remoteMCResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 783}
{"project": "Asterisk", "target": 0, "func": "struct ast_module *__ast_module_ref(struct ast_module *mod, const char *file, int line, const char *func)\n{\n\tif (!mod) {\n\t\treturn NULL;\n\t}\n\tif (mod->ref_debug) {\n\t\t__ao2_ref(mod->ref_debug, +1, \"\", file, line, func);\n\t}\n\tast_atomic_fetchadd_int(&mod->usecount, +1);\n\tast_update_use_count();\n\treturn mod;\n}\n", "bug_type": null, "idx": 784}
{"project": "Asterisk", "target": 0, "func": "const char * AST_OPTIONAL_API_NAME(ast_websocket_session_id)(struct ast_websocket *session)\n{\n\treturn session->session_id;\n}\n", "bug_type": null, "idx": 785}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int spawn_mp3(struct mohclass *class)\n{\n\tint fds[2];\n\tint files = 0;\n\tchar fns[MAX_MP3S][80];\n\tchar *argv[MAX_MP3S + 50];\n\tchar xargs[256];\n\tchar *argptr;\n\tint argc = 0;\n\tDIR *dir = NULL;\n\tstruct dirent *de;\n\tif (!strcasecmp(class->dir, \"nodir\")) {\n\t\tfiles = 1;\n\t} else {\n\t\tdir = opendir(class->dir);\n\t\tif (!dir && strncasecmp(class->dir, \"http://\", 7)) {\n\t\t\tast_log(LOG_WARNING, \"%s is not a valid directory\\n\", class->dir);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!ast_test_flag(class, MOH_CUSTOM)) {\n\t\targv[argc++] = \"mpg123\";\n\t\targv[argc++] = \"-q\";\n\t\targv[argc++] = \"-s\";\n\t\targv[argc++] = \"--mono\";\n\t\targv[argc++] = \"-r\";\n\t\targv[argc++] = \"8000\";\n\t\tif (!ast_test_flag(class, MOH_SINGLE)) {\n\t\t\targv[argc++] = \"-b\";\n\t\t\targv[argc++] = \"2048\";\n\t\t}\n\t\targv[argc++] = \"-f\";\n\t\tif (ast_test_flag(class, MOH_QUIET))\n\t\t\targv[argc++] = \"4096\";\n\t\telse\n\t\t\targv[argc++] = \"8192\";\n\t\t\n\t\tast_copy_string(xargs, class->args, sizeof(xargs));\n\t\targptr = xargs;\n\t\twhile (!ast_strlen_zero(argptr)) {\n\t\t\targv[argc++] = argptr;\n\t\t\tstrsep(&argptr, \",\");\n\t\t}\n\t} else  {\n\t\t\n\t\tast_copy_string(xargs, class->args, sizeof(xargs));\n\t\targptr = xargs;\n\t\twhile (!ast_strlen_zero(argptr)) {\n\t\t\targv[argc++] = argptr;\n\t\t\tstrsep(&argptr, \" \");\n\t\t}\n\t}\n\tif (!strncasecmp(class->dir, \"http://\", 7)) {\n\t\tast_copy_string(fns[files], class->dir, sizeof(fns[files]));\n\t\targv[argc++] = fns[files];\n\t\tfiles++;\n\t} else if (dir) {\n\t\twhile ((de = readdir(dir)) && (files < MAX_MP3S)) {\n\t\t\tif ((strlen(de->d_name) > 3) && \n\t\t\t    ((ast_test_flag(class, MOH_CUSTOM) && \n\t\t\t      (!strcasecmp(de->d_name + strlen(de->d_name) - 4, \".raw\") || \n\t\t\t       !strcasecmp(de->d_name + strlen(de->d_name) - 4, \".sln\"))) ||\n\t\t\t     !strcasecmp(de->d_name + strlen(de->d_name) - 4, \".mp3\"))) {\n\t\t\t\tast_copy_string(fns[files], de->d_name, sizeof(fns[files]));\n\t\t\t\targv[argc++] = fns[files];\n\t\t\t\tfiles++;\n\t\t\t}\n\t\t}\n\t}\n\targv[argc] = NULL;\n\tif (dir) {\n\t\tclosedir(dir);\n\t}\n\tif (pipe(fds)) {\t\n\t\tast_log(LOG_WARNING, \"Pipe failed\\n\");\n\t\treturn -1;\n\t}\n\tif (!files) {\n\t\tast_log(LOG_WARNING, \"Found no files in '%s'\\n\", class->dir);\n\t\tclose(fds[0]);\n\t\tclose(fds[1]);\n\t\treturn -1;\n\t}\n\tif (!strncasecmp(class->dir, \"http://\", 7) && time(NULL) - class->start < respawn_time) {\n\t\tsleep(respawn_time - (time(NULL) - class->start));\n\t}\n\ttime(&class->start);\n\tclass->pid = ast_safe_fork(0);\n\tif (class->pid < 0) {\n\t\tclose(fds[0]);\n\t\tclose(fds[1]);\n\t\tast_log(LOG_WARNING, \"Fork failed: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!class->pid) {\n\t\tif (ast_opt_high_priority)\n\t\t\tast_set_priority(0);\n\t\tclose(fds[0]);\n\t\t\n\t\tdup2(fds[1], STDOUT_FILENO);\n\t\t\n\t\tast_close_fds_above_n(STDERR_FILENO);\n\t\t\n\t\tif (strncasecmp(class->dir, \"http://\", 7) && strcasecmp(class->dir, \"nodir\") && chdir(class->dir) < 0) {\n\t\t\tast_log(LOG_WARNING, \"chdir() failed: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tsetpgid(0, getpid());\n\t\tif (ast_test_flag(class, MOH_CUSTOM)) {\n\t\t\texecv(argv[0], argv);\n\t\t} else {\n\t\t\t\n\t\t\texecv(LOCAL_MPG_123, argv);\n\t\t\t\n\t\t\texecv(MPG_123, argv);\n\t\t\t\n\t\t\texecvp(\"mpg123\", argv);\n\t\t}\n\t\t\n\t\tfprintf(stderr, \"MOH: exec failed: %s\\n\", strerror(errno));\n\t\tclose(fds[1]);\n\t\t_exit(1);\n\t} else {\n\t\t\n\t\tclose(fds[1]);\n\t}\n\treturn fds[0];\n}\n", "bug_type": null, "idx": 786}
{"project": "Asterisk", "target": 0, "func": "\nvoid set_all(struct category *cat, int val)\n{\n\tstruct member *mem;\n\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n\t\tif (mem->enabled == val)\n\t\t\tcontinue;\n\t\tif (mem->is_separator)\n\t\t\tcontinue;\n\t\tif ((mem->depsfailed == HARD_FAILURE) || (mem->conflictsfailed == HARD_FAILURE))\n\t\t\tcontinue;\n\t\tif (val) {\n\t\t\tenable_member(mem);\n\t\t} else {\n\t\t\tmem->enabled = 0;\n\t\t}\n\t\tmem->was_defaulted = 0;\n\t\tchanges_made++;\n\t}\n\twhile (calc_dep_failures(1, 0) || calc_conflict_failures(1, 0));\n}\n", "bug_type": null, "idx": 787}
{"project": "Asterisk", "target": 0, "func": "OOBOOL ooUtilsIsStrEmpty (const char* str)\n{\n   return (str == NULL || *str =='\\0');\n}\n", "bug_type": null, "idx": 788}
{"project": "Asterisk", "target": 0, "func": "static AST_LIST_HEAD_STATIC(firmwares, iax_firmware);\nstatic int try_firmware(char *s)\n{\n\tstruct stat stbuf;\n\tstruct iax_firmware *cur = NULL;\n\tint ifd, fd, res, len, chunk;\n\tstruct ast_iax2_firmware_header *fwh, fwh2;\n\tstruct MD5Context md5;\n\tunsigned char sum[16], buf[1024];\n\tchar *s2, *last;\n\ts2 = ast_alloca(strlen(s) + 100);\n\tlast = strrchr(s, '/');\n\tif (last)\n\t\tlast++;\n\telse\n\t\tlast = s;\n\tsnprintf(s2, strlen(s) + 100, \"/var/tmp/%s-%ld\", last, ast_random());\n\tif (stat(s, &stbuf) < 0) {\n\t\tast_log(LOG_WARNING, \"Failed to stat '%s': %s\\n\", s, strerror(errno));\n\t\treturn -1;\n\t}\n\t\n\tif (S_ISDIR(stbuf.st_mode))\n\t\treturn -1;\n\tifd = open(s, O_RDONLY);\n\tif (ifd < 0) {\n\t\tast_log(LOG_WARNING, \"Cannot open '%s': %s\\n\", s, strerror(errno));\n\t\treturn -1;\n\t}\n\tfd = open(s2, O_RDWR | O_CREAT | O_EXCL, AST_FILE_MODE);\n\tif (fd < 0) {\n\t\tast_log(LOG_WARNING, \"Cannot open '%s' for writing: %s\\n\", s2, strerror(errno));\n\t\tclose(ifd);\n\t\treturn -1;\n\t}\n\t\n\tunlink(s2);\n\t\n\tlen = stbuf.st_size;\n\twhile(len) {\n\t\tchunk = len;\n\t\tif (chunk > sizeof(buf))\n\t\t\tchunk = sizeof(buf);\n\t\tres = read(ifd, buf, chunk);\n\t\tif (res != chunk) {\n\t\t\tast_log(LOG_WARNING, \"Only read %d of %d bytes of data :(: %s\\n\", res, chunk, strerror(errno));\n\t\t\tclose(ifd);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t\tres = write(fd, buf, chunk);\n\t\tif (res != chunk) {\n\t\t\tast_log(LOG_WARNING, \"Only write %d of %d bytes of data :(: %s\\n\", res, chunk, strerror(errno));\n\t\t\tclose(ifd);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t\tlen -= chunk;\n\t}\n\tclose(ifd);\n\t\n\tlseek(fd, 0, SEEK_SET);\n\tif ((res = read(fd, &fwh2, sizeof(fwh2))) != sizeof(fwh2)) {\n\t\tast_log(LOG_WARNING, \"Unable to read firmware header in '%s'\\n\", s);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (ntohl(fwh2.magic) != IAX_FIRMWARE_MAGIC) {\n\t\tast_log(LOG_WARNING, \"'%s' is not a valid firmware file\\n\", s);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (ntohl(fwh2.datalen) != (stbuf.st_size - sizeof(fwh2))) {\n\t\tast_log(LOG_WARNING, \"Invalid data length in firmware '%s'\\n\", s);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (fwh2.devname[sizeof(fwh2.devname) - 1] || ast_strlen_zero((char *)fwh2.devname)) {\n\t\tast_log(LOG_WARNING, \"No or invalid device type specified for '%s'\\n\", s);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tfwh = (struct ast_iax2_firmware_header*)mmap(NULL, stbuf.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (fwh == MAP_FAILED) {\n\t\tast_log(LOG_WARNING, \"mmap failed: %s\\n\", strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tMD5Init(&md5);\n\tMD5Update(&md5, fwh->data, ntohl(fwh->datalen));\n\tMD5Final(sum, &md5);\n\tif (memcmp(sum, fwh->chksum, sizeof(sum))) {\n\t\tast_log(LOG_WARNING, \"Firmware file '%s' fails checksum\\n\", s);\n\t\tmunmap((void*)fwh, stbuf.st_size);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tAST_LIST_TRAVERSE(&firmwares, cur, list) {\n\t\tif (!strcmp((const char *) cur->fwh->devname, (const char *) fwh->devname)) {\n\t\t\t\n\t\t\tif (cur->dead || (ntohs(cur->fwh->version) < ntohs(fwh->version)))\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tmunmap((void*)fwh, stbuf.st_size);\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!cur && ((cur = ast_calloc(1, sizeof(*cur))))) {\n\t\tcur->fd = -1;\n\t\tAST_LIST_INSERT_TAIL(&firmwares, cur, list);\n\t}\n\tif (cur) {\n\t\tif (cur->fwh)\n\t\t\tmunmap((void*)cur->fwh, cur->mmaplen);\n\t\tif (cur->fd > -1)\n\t\t\tclose(cur->fd);\n\t\tcur->fwh = fwh;\n\t\tcur->fd = fd;\n\t\tcur->mmaplen = stbuf.st_size;\n\t\tcur->dead = 0;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 789}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int evaluate_like(struct operator *op, enum aco_option_type type, void *op_left, struct expression_token *op_right)\n{\n\tswitch (type) {\n\tcase OPT_CHAR_ARRAY_T:\n\tcase OPT_STRINGFIELD_T:\n\t\n\t{\n\t\tint result;\n\t\tregex_t regexbuf;\n\t\tchar buf[pj_strlen(op_left) + 1];\n\t\tast_copy_pj_str(buf, op_left, pj_strlen(op_left));\n\t\tif (regcomp(&regexbuf, op_right->field, REG_EXTENDED | REG_NOSUB)) {\n\t\t\tast_log(LOG_WARNING, \"Failed to compile '%s' into a regular expression\\n\", op_right->field);\n\t\t\treturn -1;\n\t\t}\n\t\tresult = (regexec(&regexbuf, buf, 0, NULL, 0) == 0);\n\t\tregfree(&regexbuf);\n\t\treturn result;\n\t}\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Cannot evaluate: invalid operand type for operator '%s'\\n\", op->symbol);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 790}
{"project": "Asterisk", "target": 0, "func": "static int add_new_event_cb(void *obj, void *arg, int flags)\n{\n\tstruct ast_calendar_event *new_event = obj;\n\tstruct ao2_container *events = arg;\n\tao2_link(events, new_event);\n\tschedule_calendar_event(new_event->owner, new_event, NULL);\n\treturn CMP_MATCH;\n}\n", "bug_type": null, "idx": 791}
{"project": "Asterisk", "target": 0, "func": "struct stasis_message *ast_channel_blob_create(struct ast_channel *chan,\n\tstruct stasis_message_type *type, struct ast_json *blob)\n{\n\tRAII_VAR(struct ast_channel_snapshot *, snapshot, NULL, ao2_cleanup);\n\tif (!type) {\n\t\treturn NULL;\n\t}\n\tif (chan) {\n\t\tsnapshot = ast_channel_snapshot_create(chan);\n\t}\n\treturn create_channel_blob_message(snapshot, type, blob);\n}\n", "bug_type": null, "idx": 792}
{"project": "Asterisk", "target": 0, "func": " */\nstatic iks* xmpp_pubsub_iq_create(struct ast_xmpp_client *client, const char *type)\n{\n\tRAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);\n\tRAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);\n\tiks *request;\n\tif (!cfg || !cfg->clients || !(clientcfg = xmpp_config_find(cfg->clients, client->name)) ||\n\t    !(request = iks_new(\"iq\"))) {\n\t\treturn NULL;\n\t}\n\tif (!ast_strlen_zero(clientcfg->pubsubnode)) {\n\t\tiks_insert_attrib(request, \"to\", clientcfg->pubsubnode);\n\t}\n\tiks_insert_attrib(request, \"from\", client->jid->full);\n\tiks_insert_attrib(request, \"type\", type);\n\tast_xmpp_client_lock(client);\n\tast_xmpp_increment_mid(client->mid);\n\tiks_insert_attrib(request, \"id\", client->mid);\n\tast_xmpp_client_unlock(client);\n\treturn request;\n}\n", "bug_type": null, "idx": 793}
{"project": "Asterisk", "target": 0, "func": "\nstatic char *handle_show_routes(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint fd = a->fd;\n\tswitch(cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"phoneprov show routes\";\n\t\te->usage =\n\t\t\t\"Usage: phoneprov show routes\\n\"\n\t\t\t\"       Lists all registered phoneprov http routes.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\t\n\tast_cli(a->fd, \"Static routes\\n\\n\");\n\tast_cli(a->fd, FORMATS, \"Profile\", \"Relative URI\", \"Physical location\");\n\tao2_callback_data(http_routes, OBJ_NODATA | OBJ_MULTIPLE, route_list_cb, &fd, NULL);\n\tast_cli(a->fd, \"\\nDynamic routes\\n\\n\");\n\tast_cli(a->fd, FORMATD, \"Provider\", \"Profile\", \"Relative URI\", \"Template\");\n\tao2_callback_data(http_routes, OBJ_NODATA | OBJ_MULTIPLE, route_list_cb, &fd, (void *)1);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 794}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225T38FaxAnnexbOnlyCaps (OOCTXT* pctxt, H225T38FaxAnnexbOnlyCaps* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.dataRatesSupportedPresent = optbit;\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   \n   if (pvalue->m.dataRatesSupportedPresent) {\n      invokeStartElement (pctxt, \"dataRatesSupported\", -1);\n      stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"dataRatesSupported\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"supportedPrefixes\", -1);\n   stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"supportedPrefixes\", -1);\n   \n   invokeStartElement (pctxt, \"t38FaxProtocol\", -1);\n   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t38FaxProtocol);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"t38FaxProtocol\", -1);\n   \n   invokeStartElement (pctxt, \"t38FaxProfile\", -1);\n   stat = asn1PD_H245T38FaxProfile (pctxt, &pvalue->t38FaxProfile);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"t38FaxProfile\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 795}
{"project": "Asterisk", "target": 0, "func": "static char *complete_core_id(const char *line, const char *word, int pos, int state)\n{\n\tint which = 0;\n\tint wordlen = strlen(word);\n\tchar *ret = NULL;\n\tstruct ao2_iterator core_iter = ao2_iterator_init(cc_core_instances, 0);\n\tstruct cc_core_instance *core_instance;\n\tfor (; (core_instance = ao2_t_iterator_next(&core_iter, \"Next core instance\"));\n\t\t\tcc_unref(core_instance, \"CLI tab completion iteration\")) {\n\t\tchar core_id_str[20];\n\t\tsnprintf(core_id_str, sizeof(core_id_str), \"%d\", core_instance->core_id);\n\t\tif (!strncmp(word, core_id_str, wordlen) && ++which > state) {\n\t\t\tret = ast_strdup(core_id_str);\n\t\t\tcc_unref(core_instance, \"Found a matching core ID for CLI tab-completion\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tao2_iterator_destroy(&core_iter);\n\treturn ret;\n}\n", "bug_type": null, "idx": 796}
{"project": "Asterisk", "target": 0, "func": "protected void\nterm_clear_screen(EditLine *el)\n{\t\t\t\t\n\tif (GoodStr(T_cl))\n\t\t\n\t\t(void) tputs(Str(T_cl), Val(T_li), term__putc);\n\telse if (GoodStr(T_ho) && GoodStr(T_cd)) {\n\t\t(void) tputs(Str(T_ho), Val(T_li), term__putc);\t\n\t\t\n\t\t(void) tputs(Str(T_cd), Val(T_li), term__putc);\n\t} else {\n\t\tterm__putc('\\r');\n\t\tterm__putc('\\n');\n\t}\n}\n", "bug_type": null, "idx": 797}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225InfoRequest (OOCTXT* pctxt, H225InfoRequest* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.replyAddressPresent = optbit;\n   \n   invokeStartElement (pctxt, \"requestSeqNum\", -1);\n   stat = asn1PD_H225RequestSeqNum (pctxt, &pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"requestSeqNum\", -1);\n   \n   invokeStartElement (pctxt, \"callReferenceValue\", -1);\n   stat = asn1PD_H225CallReferenceValue (pctxt, &pvalue->callReferenceValue);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"callReferenceValue\", -1);\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   \n   if (pvalue->m.replyAddressPresent) {\n      invokeStartElement (pctxt, \"replyAddress\", -1);\n      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->replyAddress);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"replyAddress\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 11 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.callIdentifierPresent = 1;\n                     invokeStartElement (pctxt, \"callIdentifier\", -1);\n                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"callIdentifier\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.tokensPresent = 1;\n                     invokeStartElement (pctxt, \"tokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"tokens\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.cryptoTokensPresent = 1;\n                     invokeStartElement (pctxt, \"cryptoTokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"cryptoTokens\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.integrityCheckValuePresent = 1;\n                     invokeStartElement (pctxt, \"integrityCheckValue\", -1);\n                     stat = asn1PD_H225ICV (pctxt, &pvalue->integrityCheckValue);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"integrityCheckValue\", -1);\n                     break;\n                  case 4:\n                     pvalue->m.uuiesRequestedPresent = 1;\n                     invokeStartElement (pctxt, \"uuiesRequested\", -1);\n                     stat = asn1PD_H225UUIEsRequested (pctxt, &pvalue->uuiesRequested);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"uuiesRequested\", -1);\n                     break;\n                  case 5:\n                     pvalue->m.callLinkagePresent = 1;\n                     invokeStartElement (pctxt, \"callLinkage\", -1);\n                     stat = asn1PD_H225CallLinkage (pctxt, &pvalue->callLinkage);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"callLinkage\", -1);\n                     break;\n                  case 6:\n                     pvalue->m.usageInfoRequestedPresent = 1;\n                     invokeStartElement (pctxt, \"usageInfoRequested\", -1);\n                     stat = asn1PD_H225RasUsageInfoTypes (pctxt, &pvalue->usageInfoRequested);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"usageInfoRequested\", -1);\n                     break;\n                  case 7:\n                     pvalue->m.segmentedResponseSupportedPresent = 1;\n                     invokeStartElement (pctxt, \"segmentedResponseSupported\", -1);\n                     \n                     invokeNullValue (pctxt);\n                     invokeEndElement (pctxt, \"segmentedResponseSupported\", -1);\n                     break;\n                  case 8:\n                     pvalue->m.nextSegmentRequestedPresent = 1;\n                     invokeStartElement (pctxt, \"nextSegmentRequested\", -1);\n                     stat = decodeConsUInt16 (pctxt, &pvalue->nextSegmentRequested, 0U, 65535U);\n                     if (stat != ASN_OK) return stat;\n                     invokeUIntValue (pctxt, pvalue->nextSegmentRequested);\n                     invokeEndElement (pctxt, \"nextSegmentRequested\", -1);\n                     break;\n                  case 9:\n                     pvalue->m.capacityInfoRequestedPresent = 1;\n                     invokeStartElement (pctxt, \"capacityInfoRequested\", -1);\n                     \n                     invokeNullValue (pctxt);\n                     invokeEndElement (pctxt, \"capacityInfoRequested\", -1);\n                     break;\n                  case 10:\n                     pvalue->m.genericDataPresent = 1;\n                     invokeStartElement (pctxt, \"genericData\", -1);\n                     stat = asn1PD_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"genericData\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 798}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int do_waiting(struct ast_channel *chan, int timereqd, time_t waitstart, int timeout, const struct wait_type *wait_for)\n{\n\tRAII_VAR(struct ast_format *, rfmt, NULL, ao2_cleanup);\n\tint res;\n\tstruct ast_dsp *sildet;\n\trfmt = ao2_bump(ast_channel_readformat(chan));\n\tif ((res = ast_set_read_format(chan, ast_format_slin)) < 0) {\n\t\tast_log(LOG_WARNING, \"Unable to set channel to linear mode, giving up\\n\");\n\t\treturn -1;\n\t}\n\t\n\tif (!(sildet = ast_dsp_new())) {\n\t\tast_log(LOG_WARNING, \"Unable to create silence detector\\n\");\n\t\treturn -1;\n\t}\n\tast_dsp_set_threshold(sildet, ast_dsp_get_threshold_from_settings(THRESHOLD_SILENCE));\n\tfor (;;) {\n\t\tint dsptime = 0;\n\t\tres = ast_waitfor(chan, timereqd);\n\t\t\n\t\tif (res < 0) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"WAITSTATUS\", \"HANGUP\");\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (res == 0) {\n\t\t\tif (wait_for->stop_on_frame_timeout) {\n\t\t\t\tdsptime = timereqd;\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tstruct ast_frame *f = ast_read(chan);\n\t\t\tif (!f) {\n\t\t\t\tpbx_builtin_setvar_helper(chan, \"WAITSTATUS\", \"HANGUP\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (f->frametype == AST_FRAME_VOICE) {\n\t\t\t\twait_for->func(sildet, f, &dsptime);\n\t\t\t}\n\t\t\tast_frfree(f);\n\t\t}\n\t\tast_debug(1, \"Got %dms of %s < %dms required\\n\", dsptime, wait_for->name, timereqd);\n\t\tif (dsptime >= timereqd) {\n\t\t\tast_verb(3, \"Exiting with %dms of %s >= %dms required\\n\", dsptime, wait_for->name, timereqd);\n\t\t\tpbx_builtin_setvar_helper(chan, \"WAITSTATUS\", wait_for->status);\n\t\t\tast_debug(1, \"WAITSTATUS was set to %s\\n\", wait_for->status);\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (timeout && difftime(time(NULL), waitstart) >= timeout) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"WAITSTATUS\", \"TIMEOUT\");\n\t\t\tast_debug(1, \"WAITSTATUS was set to TIMEOUT\\n\");\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rfmt && ast_set_read_format(chan, rfmt)) {\n\t\tast_log(LOG_WARNING, \"Unable to restore format %s to channel '%s'\\n\", ast_format_get_name(rfmt), ast_channel_name(chan));\n\t}\n\tast_dsp_free(sildet);\n\treturn res;\n}\n", "bug_type": null, "idx": 799}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_speech *find_speech(struct ast_channel *chan)\n{\n\tstruct ast_speech *speech = NULL;\n\tstruct ast_datastore *datastore = NULL;\n\tif (!chan) {\n\t\treturn NULL;\n\t}\n\tast_channel_lock(chan);\n\tdatastore = ast_channel_datastore_find(chan, &speech_datastore, NULL);\n\tast_channel_unlock(chan);\n\tif (datastore == NULL) {\n\t\treturn NULL;\n\t}\n\tspeech = datastore->data;\n\treturn speech;\n}\n", "bug_type": null, "idx": 800}
{"project": "Asterisk", "target": 0, "func": "const struct timeval ast_sorcery_object_get_created(const void *object)\n{\n\tconst struct ast_sorcery_object_details *details = object;\n\treturn details->object->created;\n}\n", "bug_type": null, "idx": 801}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int stun_get_mapped(struct stun_attr *attr, void *arg)\n{\n\tstruct stun_addr *addr = (struct stun_addr *)(attr + 1);\n\tstruct sockaddr_in *sa = (struct sockaddr_in *)arg;\n\tif (ntohs(attr->attr) != STUN_MAPPED_ADDRESS || ntohs(attr->len) != 8)\n\t\treturn 1;\t\n\tsa->sin_port = addr->port;\n\tsa->sin_addr.s_addr = addr->addr;\n\treturn 0;\n}\n", "bug_type": null, "idx": 802}
{"project": "Asterisk", "target": 0, "func": "int manager_bridging_init(void)\n{\n\tint ret = 0;\n\tstruct stasis_topic *manager_topic;\n\tstruct stasis_topic *bridge_topic;\n\tif (bridge_state_router) {\n\t\t\n\t\treturn 0;\n\t}\n\tast_register_cleanup(manager_bridging_cleanup);\n\tmanager_topic = ast_manager_get_topic();\n\tif (!manager_topic) {\n\t\treturn -1;\n\t}\n\tbridge_topic = ast_bridge_topic_all_cached();\n\tif (!bridge_topic) {\n\t\treturn -1;\n\t}\n\ttopic_forwarder = stasis_forward_all(bridge_topic, manager_topic);\n\tif (!topic_forwarder) {\n\t\treturn -1;\n\t}\n\tbridge_state_router = ast_manager_get_message_router();\n\tif (!bridge_state_router) {\n\t\treturn -1;\n\t}\n\tret |= stasis_message_router_add_cache_update(bridge_state_router,\n\t\tast_bridge_snapshot_type(), bridge_snapshot_update, NULL);\n\tret |= stasis_message_router_add(bridge_state_router,\n\t\tast_bridge_merge_message_type(), bridge_merge_cb, NULL);\n\tret |= stasis_message_router_add(bridge_state_router,\n\t\tast_channel_entered_bridge_type(), channel_enter_cb, NULL);\n\tret |= stasis_message_router_add(bridge_state_router,\n\t\tast_channel_left_bridge_type(), channel_leave_cb, NULL);\n\tret |= ast_manager_register_xml_core(\"BridgeList\", 0, manager_bridges_list);\n\tret |= ast_manager_register_xml_core(\"BridgeInfo\", 0, manager_bridge_info);\n\tret |= ast_manager_register_xml_core(\"BridgeDestroy\", 0, manager_bridge_destroy);\n\tret |= ast_manager_register_xml_core(\"BridgeKick\", 0, manager_bridge_kick);\n\t\n\tif (ret) {\n\t\tmanager_bridging_cleanup();\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 803}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void evt_gen_failed_acl(void)\n{\n\tstruct ast_sockaddr addr_local = { {0,} };\n\tstruct ast_sockaddr addr_remote = { {0,} };\n\tstruct timeval session_tv = ast_tvnow();\n\tstruct ast_security_event_failed_acl failed_acl_event = {\n\t\t.common.event_type = AST_SECURITY_EVENT_FAILED_ACL,\n\t\t.common.version    = AST_SECURITY_EVENT_FAILED_ACL_VERSION,\n\t\t.common.service    = \"TEST\",\n\t\t.common.module     = AST_MODULE,\n\t\t.common.account_id = \"Username\",\n\t\t.common.session_id = \"Session123\",\n\t\t.common.session_tv = &session_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr  = &addr_local,\n\t\t\t.transport  = AST_TRANSPORT_UDP,\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr = &addr_remote,\n\t\t\t.transport  = AST_TRANSPORT_UDP,\n\t\t},\n\t\t.acl_name   = \"TEST_ACL\",\n\t};\n\tchar localaddr[53];\n\tchar remoteaddr[53];\n\tast_copy_string(localaddr, \"192.168.1.1:12121\", sizeof(localaddr));\n\tast_copy_string(remoteaddr, \"192.168.1.2:12345\", sizeof(remoteaddr));\n\tast_sockaddr_parse(&addr_local, localaddr, 0);\n\tast_sockaddr_parse(&addr_remote, remoteaddr, 0);\n\tast_security_event_report(AST_SEC_EVT(&failed_acl_event));\n}\n", "bug_type": null, "idx": 804}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int notify_contact(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_contact *contact = obj;\n\tstruct notify_data *data = arg;\n\tpjsip_tx_data *tdata;\n\tif (ast_sip_create_request(\"NOTIFY\", NULL, data->endpoint,\n\t\t\t\t   NULL, contact, &tdata)) {\n\t\tast_log(LOG_WARNING, \"SIP NOTIFY - Unable to create request for \"\n\t\t\t\"contact %s\\n\",\tcontact->uri);\n\t\treturn -1;\n\t}\n\tast_sip_add_header(tdata, \"Subscription-State\", \"terminated\");\n\tdata->build_notify(tdata, data->info);\n\tif (ast_sip_send_request(tdata, NULL, data->endpoint, NULL, NULL)) {\n\t\tast_log(LOG_ERROR, \"SIP NOTIFY - Unable to send request for \"\n\t\t\t\"contact %s\\n\",\tcontact->uri);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 805}
{"project": "Asterisk", "target": 0, "func": "SQLRETURN ast_odbc_ast_str_SQLGetData(struct ast_str **buf, int pmaxlen, SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLLEN *StrLen_or_Ind)\n{\n\tSQLRETURN res;\n\tif (pmaxlen == 0) {\n\t\tif (SQLGetData(StatementHandle, ColumnNumber, TargetType, ast_str_buffer(*buf), 0, StrLen_or_Ind) == SQL_SUCCESS_WITH_INFO) {\n\t\t\tast_str_make_space(buf, *StrLen_or_Ind + 1);\n\t\t}\n\t} else if (pmaxlen > 0) {\n\t\tast_str_make_space(buf, pmaxlen);\n\t}\n\tres = SQLGetData(StatementHandle, ColumnNumber, TargetType, ast_str_buffer(*buf), ast_str_size(*buf), StrLen_or_Ind);\n\tast_str_update(*buf);\n\treturn res;\n}\n", "bug_type": null, "idx": 806}
{"project": "Asterisk", "target": 0, "func": "static int complex_task(void *data)\n{\n\tstruct complex_task_data *ctd = data;\n\tSCOPED_MUTEX(lock, &ctd->lock);\n\t\n\tctd->task_started = 1;\n\tast_cond_signal(&ctd->notify_cond);\n\twhile (!ctd->continue_task) {\n\t\tast_cond_wait(&ctd->stall_cond, lock);\n\t}\n\t\n\tctd->task_executed = 1;\n\tast_cond_signal(&ctd->notify_cond);\n\treturn 0;\n}\n", "bug_type": null, "idx": 807}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct chan_oss_pvt *find_desc(const char *dev)\n{\n\tstruct chan_oss_pvt *o = NULL;\n\tif (!dev)\n\t\tast_log(LOG_WARNING, \"null dev\\n\");\n\tfor (o = oss_default.next; o && o->name && dev && strcmp(o->name, dev) != 0; o = o->next);\n\tif (!o)\n\t\tast_log(LOG_WARNING, \"could not find <%s>\\n\", dev ? dev : \"--no-device--\");\n\treturn o;\n}\n", "bug_type": null, "idx": 808}
{"project": "Asterisk", "target": 0, "func": " */\nstatic pjsip_hdr *find_header(struct hdr_list *list, const char *header_name,\n\t\t\t\t\t\t\t  int header_number)\n{\n\tstruct hdr_list_entry *le;\n\tpjsip_hdr *hdr = NULL;\n\tint i = 1;\n\tif (!list || ast_strlen_zero(header_name) || header_number < 1) {\n\t\treturn NULL;\n\t}\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tif (pj_stricmp2(&le->hdr->name, header_name) == 0 && i++ == header_number) {\n\t\t\thdr = le->hdr;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn hdr;\n}\n", "bug_type": null, "idx": 809}
{"project": "Asterisk", "target": 0, "func": "static int permanent_uri_sort_fn(const void *obj_left, const void *obj_right, int flags)\n{\n\tconst struct ast_sip_contact *object_left = obj_left;\n\tconst struct ast_sip_contact *object_right = obj_right;\n\tconst char *right_key = obj_right;\n\tint cmp;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_OBJECT:\n\t\tright_key = ast_sorcery_object_get_id(object_right);\n\t\t\n\tcase OBJ_SEARCH_KEY:\n\t\tcmp = strcmp(ast_sorcery_object_get_id(object_left), right_key);\n\t\tbreak;\n\tcase OBJ_SEARCH_PARTIAL_KEY:\n\t\t\n\t\tcmp = strncmp(ast_sorcery_object_get_id(object_left), right_key, strlen(right_key));\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tast_assert(0);\n\t\tcmp = 0;\n\t\tbreak;\n\t}\n\treturn cmp;\n}\n", "bug_type": null, "idx": 810}
{"project": "Asterisk", "target": 0, "func": "int __ast_rwlock_rdlock(const char *filename, int line, const char *func, ast_rwlock_t *t, const char *name)\n{\n\tint res;\n#ifdef DEBUG_THREADS\n\tstruct ast_lock_track *lt = NULL;\n\tint canlog = t->tracking && strcmp(filename, \"logger.c\");\n#ifdef HAVE_BKTR\n\tstruct ast_bt *bt = NULL;\n#endif\n\tif (t->tracking) {\n\t\tlt = ast_get_reentrancy(&t->track);\n\t}\n\tif (lt) {\n#ifdef HAVE_BKTR\n\t\tstruct ast_bt tmp;\n\t\t\n\t\tast_bt_get_addresses(&tmp);\n\t\tast_reentrancy_lock(lt);\n\t\tif (lt->reentrancy < AST_MAX_REENTRANCY) {\n\t\t\tlt->backtrace[lt->reentrancy] = tmp;\n\t\t\tbt = &lt->backtrace[lt->reentrancy];\n\t\t}\n\t\tast_reentrancy_unlock(lt);\n\t\tast_store_lock_info(AST_RDLOCK, filename, line, func, name, t, bt);\n#else\n\t\tast_store_lock_info(AST_RDLOCK, filename, line, func, name, t);\n#endif\n\t}\n#endif \n#if defined(DETECT_DEADLOCKS) && defined(DEBUG_THREADS)\n\t{\n\t\ttime_t seconds = time(NULL);\n\t\ttime_t wait_time, reported_wait = 0;\n\t\tdo {\n\t\t\tres = pthread_rwlock_tryrdlock(&t->lock);\n\t\t\tif (res == EBUSY) {\n\t\t\t\twait_time = time(NULL) - seconds;\n\t\t\t\tif (wait_time > reported_wait && (wait_time % 5) == 0) {\n\t\t\t\t\t__ast_mutex_logger(\"%s line %d (%s): Deadlock? waited %d sec for readlock '%s'?\\n\",\n\t\t\t\t\t\tfilename, line, func, (int)wait_time, name);\n\t\t\t\t\tif (lt) {\n\t\t\t\t\t\tast_reentrancy_lock(lt);\n#ifdef HAVE_BKTR\n\t\t\t\t\t\t__dump_backtrace(&lt->backtrace[lt->reentrancy], canlog);\n#endif\n\t\t\t\t\t\t__ast_mutex_logger(\"%s line %d (%s): '%s' was locked  here.\\n\",\n\t\t\t\t\t\t\t\tlt->file[lt->reentrancy-1], lt->lineno[lt->reentrancy-1],\n\t\t\t\t\t\t\t\tlt->func[lt->reentrancy-1], name);\n#ifdef HAVE_BKTR\n\t\t\t\t\t\t__dump_backtrace(&lt->backtrace[lt->reentrancy-1], canlog);\n#endif\n\t\t\t\t\t\tast_reentrancy_unlock(lt);\n\t\t\t\t\t}\n\t\t\t\t\treported_wait = wait_time;\n\t\t\t\t}\n\t\t\t\tusleep(200);\n\t\t\t}\n\t\t} while (res == EBUSY);\n\t}\n#else \n\tres = pthread_rwlock_rdlock(&t->lock);\n#endif \n#ifdef DEBUG_THREADS\n\tif (!res && lt) {\n\t\tast_reentrancy_lock(lt);\n\t\tif (lt->reentrancy < AST_MAX_REENTRANCY) {\n\t\t\tlt->file[lt->reentrancy] = filename;\n\t\t\tlt->lineno[lt->reentrancy] = line;\n\t\t\tlt->func[lt->reentrancy] = func;\n\t\t\tlt->thread_id[lt->reentrancy] = pthread_self();\n\t\t\tlt->reentrancy++;\n\t\t}\n\t\tast_reentrancy_unlock(lt);\n\t\tast_mark_lock_acquired(t);\n\t} else if (lt) {\n#ifdef HAVE_BKTR\n\t\tif (lt->reentrancy) {\n\t\t\tast_reentrancy_lock(lt);\n\t\t\tbt = &lt->backtrace[lt->reentrancy-1];\n\t\t\tast_reentrancy_unlock(lt);\n\t\t} else {\n\t\t\tbt = NULL;\n\t\t}\n\t\tast_remove_lock_info(t, bt);\n#else\n\t\tast_remove_lock_info(t);\n#endif\n\t}\n\tif (res) {\n\t\t__ast_mutex_logger(\"%s line %d (%s): Error obtaining read lock: %s\\n\",\n\t\t\t\tfilename, line, func, strerror(res));\n\t\tDO_THREAD_CRASH;\n\t}\n#endif \n\treturn res;\n}\n", "bug_type": null, "idx": 811}
{"project": "Asterisk", "target": 0, "func": "int ooOnReceivedSetup(OOH323CallData *call, Q931Message *q931Msg)\n{\n   H225Setup_UUIE *setup=NULL;\n   int i=0, ret=0;\n   H245OpenLogicalChannel* olc;\n   ASN1OCTET msgbuf[MAXMSGLEN];\n   H225TransportAddress_ipAddress_ip *ip = NULL;\n   H225TransportAddress_ip6Address_ip *ip6 = NULL;\n   Q931InformationElement* pDisplayIE=NULL;\n   OOAliases *pAlias=NULL;\n   char remoteIP[2+8*4+7] = \"\";\n   call->callReference = q931Msg->callReference;\n   if(!q931Msg->userInfo)\n   {\n      OOTRACEERR3(\"ERROR:No User-User IE in received SETUP message (%s, %s)\\n\",\n                  call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   setup = q931Msg->userInfo->h323_uu_pdu.h323_message_body.u.setup;\n   if(!setup)\n   {\n      OOTRACEERR3(\"Error: Setup UUIE not found in received setup message - %s \"\n                  \"%s\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   ooHandleH2250ID(call, &setup->protocolIdentifier);\n   memcpy(call->callIdentifier.guid.data, setup->callIdentifier.guid.data, \n          setup->callIdentifier.guid.numocts);\n   call->callIdentifier.guid.numocts = setup->callIdentifier.guid.numocts;\n   memcpy(call->confIdentifier.data, setup->conferenceID.data,\n          setup->conferenceID.numocts);\n   call->confIdentifier.numocts = setup->conferenceID.numocts;\n   \n   pDisplayIE = ooQ931GetIE(q931Msg, Q931DisplayIE);\n   if(pDisplayIE)\n   {\n      call->remoteDisplayName = (char *) memAllocZ(call->pctxt, \n                                 pDisplayIE->length*sizeof(ASN1OCTET)+1);\n      strncpy(call->remoteDisplayName, (char *)pDisplayIE->data, pDisplayIE->length*sizeof(ASN1OCTET));\n   }\n   \n   if(setup->m.sourceAddressPresent)\n   {\n      if(setup->sourceAddress.count>0)\n      {\n         ooH323RetrieveAliases(call, &setup->sourceAddress, \n                                                       &call->remoteAliases);\n         pAlias = call->remoteAliases;\n         while(pAlias)\n         {\n            if(pAlias->type ==  T_H225AliasAddress_dialedDigits)\n            {\n              if(!call->callingPartyNumber)\n              {\n                 call->callingPartyNumber = (char*)memAlloc(call->pctxt,\n                                                    strlen(pAlias->value)*+1);\n                 if(call->callingPartyNumber)\n                 {\n                     strcpy(call->callingPartyNumber, pAlias->value);\n                 }\n              }\n              break;\n           }\n           pAlias = pAlias->next;\n         }\n      }\n   }\n         \n   if(setup->m.destinationAddressPresent)\n   {\n      if(setup->destinationAddress.count>0)\n      {\n         ooH323RetrieveAliases(call, &setup->destinationAddress, \n                                                       &call->ourAliases);\n         pAlias = call->ourAliases;\n         while(pAlias)\n         {\n            if(pAlias->type == T_H225AliasAddress_dialedDigits)\n            {\n              if(!call->calledPartyNumber)\n              {\n                 call->calledPartyNumber = (char*)memAlloc(call->pctxt,\n                                                    strlen(pAlias->value)*+1);\n                 if(call->calledPartyNumber)\n                 {\n                    strcpy(call->calledPartyNumber, pAlias->value);\n                 }\n              }\n              break;\n            }\n            pAlias = pAlias->next; \n         }\n      }\n   }\n   \n   if(q931Msg->userInfo->h323_uu_pdu.m.h245TunnelingPresent)\n   {\n      \n      if(q931Msg->userInfo->h323_uu_pdu.h245Tunneling &&\n         !setup->m.h245AddressPresent)\n      {\n         if(OO_TESTFLAG(gH323ep.flags, OO_M_TUNNELING))\n         {\n            OO_SETFLAG (call->flags, OO_M_TUNNELING);\n            OOTRACEINFO3(\"Call has tunneling active (%s,%s)\\n\", call->callType,\n                          call->callToken);\n         }\n         else\n            OOTRACEINFO3(\"ERROR:Remote endpoint wants to use h245Tunneling, \"\n                        \"local endpoint has it disabled (%s,%s)\\n\",\n                        call->callType, call->callToken);\n      }\n      else {\n         if(OO_TESTFLAG(gH323ep.flags, OO_M_TUNNELING))\n         {\n            OOTRACEINFO3(\"Tunneling disabled by remote endpoint. (%s, %s)\\n\",\n                         call->callType, call->callToken);\n         }\n         OO_CLRFLAG (call->flags, OO_M_TUNNELING);\n      }\n   }\n   else {\n      if(OO_TESTFLAG(gH323ep.flags, OO_M_TUNNELING))\n      {\n         OOTRACEINFO3(\"Tunneling disabled by remote endpoint. (%s, %s)\\n\",\n                       call->callType, call->callToken);\n      }\n      OO_CLRFLAG (call->flags, OO_M_TUNNELING);\n   }\n   \n   if(!setup->m.sourceCallSignalAddressPresent)\n   {\n      OOTRACEWARN3(\"WARNING:Missing source call signal address in received \"\n                   \"setup (%s, %s)\\n\", call->callType, call->callToken);\n   }\n   else{\n      if(setup->sourceCallSignalAddress.t == T_H225TransportAddress_ip6Address) {\n        ip6 = &setup->sourceCallSignalAddress.u.ip6Address->ip;\n        inet_ntop(AF_INET6, ip6->data, remoteIP, INET6_ADDRSTRLEN);\n        call->remotePort =  setup->sourceCallSignalAddress.u.ip6Address->port;\n      } else  if(setup->sourceCallSignalAddress.t == T_H225TransportAddress_ipAddress) {\n        ip = &setup->sourceCallSignalAddress.u.ipAddress->ip;\n        sprintf(remoteIP, \"%d.%d.%d.%d\", ip->data[0], ip->data[1], \n                                         ip->data[2], ip->data[3]);\n        call->remotePort =  setup->sourceCallSignalAddress.u.ipAddress->port;\n      } else {\n         OOTRACEERR3(\"ERROR: Source call signalling address type not ip4 nor ip6 \"\n                     \"(%s, %s)\\n\", call->callType, call->callToken);\n         return OO_FAILED;\n      }\n   }\n\n   if (strncmp(remoteIP, call->remoteIP, strlen(remoteIP))) {\n\tif(!gH323ep.gkClient || OO_TESTFLAG(call->flags, OO_M_DISABLEGK) || (gH323ep.gkClient->state != GkClientRegistered)) {\n     \t\tOOTRACEERR5(\"ERROR: Security denial remote sig IP isn't a socket ip, %s not %s \"\n\t\t     \t\"(%s, %s)\\n\", remoteIP, call->remoteIP, call->callType, call->callToken);\n     \t\treturn OO_FAILED;\n\t}\n   }\n   \n   if(setup->m.fastStartPresent)\n   {\n      if(!OO_TESTFLAG(gH323ep.flags, OO_M_FASTSTART))\n      {\n         OOTRACEINFO3(\"Local endpoint does not support fastStart. Ignoring \"\n                     \"fastStart. (%s, %s)\\n\", call->callType, call->callToken);\n         OO_CLRFLAG (call->flags, OO_M_FASTSTART);\n      }\n      else if(setup->fastStart.n == 0)\n      {\n         OOTRACEINFO3(\"Empty faststart element received. Ignoring fast start. \"\n                      \"(%s, %s)\\n\", call->callType, call->callToken);\n         OO_CLRFLAG (call->flags, OO_M_FASTSTART);\n      }\n      else{\n         OO_SETFLAG (call->flags, OO_M_FASTSTART);\n         OOTRACEINFO3(\"FastStart enabled for call(%s, %s)\\n\", call->callType,\n                       call->callToken);\n      }\n   }\n   if (OO_TESTFLAG (call->flags, OO_M_FASTSTART))\n   {\n      \n      initializePrintHandler(&printHandler, \"FastStart Elements\");\n      \n      setEventHandler (call->pctxt, &printHandler);\n      for(i=0; i<(int)setup->fastStart.n; i++)\n      {\n         olc = NULL;\n         \n         olc = (H245OpenLogicalChannel*)memAlloc(call->pctxt, \n                                              sizeof(H245OpenLogicalChannel));\n         if(!olc)\n         {\n            OOTRACEERR3(\"ERROR:Memory - ooOnReceivedSetup - olc (%s, %s)\\n\", \n                        call->callType, call->callToken);\n            \n            if(call->callState < OO_CALL_CLEAR)\n            {\n               call->callEndReason = OO_REASON_LOCAL_CLEARED;\n               call->callState = OO_CALL_CLEAR;\n            }\n            finishPrint();\n            removeEventHandler(call->pctxt);\n            return OO_FAILED;\n         }\n         memset(olc, 0, sizeof(H245OpenLogicalChannel));\n         memcpy(msgbuf, setup->fastStart.elem[i].data, \n                setup->fastStart.elem[i].numocts);\n         setPERBuffer(call->pctxt, msgbuf, \n                      setup->fastStart.elem[i].numocts, 1);\n         ret = asn1PD_H245OpenLogicalChannel(call->pctxt, olc);\n         if(ret != ASN_OK)\n         {\n            OOTRACEERR3(\"ERROR:Failed to decode fast start olc element \"\n                        \"(%s, %s)\\n\", call->callType, call->callToken);\n            \n            if(call->callState < OO_CALL_CLEAR)\n            {\n               call->callEndReason = OO_REASON_INVALIDMESSAGE;\n               call->callState = OO_CALL_CLEAR;\n            }\n              finishPrint();\n              removeEventHandler(call->pctxt);\n              return OO_FAILED;\n         }\n         \n         dListAppend(call->pctxt, &call->remoteFastStartOLCs, olc);\n      }\n      finishPrint();\n      removeEventHandler(call->pctxt);\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 812}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void *named_acl_alloc(const char *cat)\n{\n\tstruct named_acl *named_acl;\n\tnamed_acl = ao2_alloc(sizeof(*named_acl), destroy_named_acl);\n\tif (!named_acl) {\n\t\treturn NULL;\n\t}\n\tast_copy_string(named_acl->name, cat, sizeof(named_acl->name));\n\treturn named_acl;\n}\n", "bug_type": null, "idx": 813}
{"project": "Asterisk", "target": 0, "func": "static enum ast_timer_event kqueue_timer_get_event(void *data)\n{\n\tstruct kqueue_timer *timer = data;\n\tenum ast_timer_event res;\n\tif (timer->is_continuous) {\n\t\tres = AST_TIMING_EVENT_CONTINUOUS;\n\t} else {\n\t\tres = AST_TIMING_EVENT_EXPIRED;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 814}
{"project": "Asterisk", "target": 0, "func": "enum ast_channel_adsicpe ast_channel_adsicpe(const struct ast_channel *chan)\n{\n\treturn chan->adsicpe;\n}\n", "bug_type": null, "idx": 815}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tconst pj_str_t STR_REGISTER = { \"REGISTER\", 8 };\n\tCHECK_PJPROJECT_MODULE_LOADED();\n\tast_pjproject_get_buildopt(\"PJ_MAX_HOSTNAME\", \"%d\", &pj_max_hostname);\n\t\n\tast_pjproject_get_buildopt(\"PJSIP_MAX_URL_SIZE\", \"%d\", &pjsip_max_url_size);\n\tCHECK_PJSIP_MODULE_LOADED();\n\tif (ast_sip_register_service(&registrar_module)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (pjsip_endpt_add_capability(ast_sip_get_pjsip_endpoint(), NULL, PJSIP_H_ALLOW, NULL, 1, &STR_REGISTER) != PJ_SUCCESS) {\n\t\tast_sip_unregister_service(&registrar_module);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_manager_register_xml(AMI_SHOW_REGISTRATIONS, EVENT_FLAG_SYSTEM,\n\t\t\t\t ami_show_registrations);\n\tast_manager_register_xml(AMI_SHOW_REGISTRATION_CONTACT_STATUSES, EVENT_FLAG_SYSTEM,\n\t\t\t\t ami_show_registration_contact_statuses);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 816}
{"project": "Asterisk", "target": 0, "func": "static int event_session_shutdown_cb(void *session, void *arg, int flags)\n{\n\tevent_session_cleanup(session);\n\treturn 0;\n}\n", "bug_type": null, "idx": 817}
{"project": "Asterisk", "target": 0, "func": " int speex_resampler_process_interleaved_int(SpeexResamplerState *st, const spx_int16_t *in, spx_uint32_t *in_len, spx_int16_t *out, spx_uint32_t *out_len)\n{\n   spx_uint32_t i;\n   int istride_save, ostride_save;\n   spx_uint32_t bak_len = *out_len;\n   istride_save = st->in_stride;\n   ostride_save = st->out_stride;\n   st->in_stride = st->out_stride = st->nb_channels;\n   for (i=0;i<st->nb_channels;i++)\n   {\n      *out_len = bak_len;\n      if (in != NULL)\n         speex_resampler_process_int(st, i, in+i, in_len, out+i, out_len);\n      else\n         speex_resampler_process_int(st, i, NULL, in_len, out+i, out_len);\n   }\n   st->in_stride = istride_save;\n   st->out_stride = ostride_save;\n   return RESAMPLER_ERR_SUCCESS;\n}\n", "bug_type": null, "idx": 818}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_initialize_global_headers(void)\n{\n\tAST_RWLIST_HEAD_INIT(&request_headers);\n\tAST_RWLIST_HEAD_INIT(&response_headers);\n\tinternal_sip_register_service(&global_header_mod);\n}\n", "bug_type": null, "idx": 819}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tAST_TEST_REGISTER(str_to_uint);\n\tAST_TEST_REGISTER(str_to_ulong);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 820}
{"project": "Asterisk", "target": 0, "func": "struct timeval ast_tvadd(struct timeval a, struct timeval b);\nstruct timeval ast_tvadd(struct timeval a, struct timeval b)\n{\n\t\n\ta = tvfix(a);\n\tb = tvfix(b);\n\ta.tv_sec += b.tv_sec;\n\ta.tv_usec += b.tv_usec;\n\tif (a.tv_usec >= ONE_MILLION) {\n\t\ta.tv_sec++;\n\t\ta.tv_usec -= ONE_MILLION;\n\t}\n\treturn a;\n}\n", "bug_type": null, "idx": 821}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void stale_update_task_data_destructor(void *obj)\n{\n\tstruct stale_update_task_data *task_data = obj;\n\tao2_cleanup(task_data->cache);\n\tao2_cleanup(task_data->object);\n\tast_sorcery_unref(task_data->sorcery);\n}\n", "bug_type": null, "idx": 822}
{"project": "Asterisk", "target": 0, "func": "void pbx_substitute_variables_varshead(struct varshead *headp, const char *cp1, char *cp2, int count)\n{\n\tsize_t used;\n\tpbx_substitute_variables_helper_full(NULL, headp, cp1, cp2, count, &used);\n}\n", "bug_type": null, "idx": 823}
{"project": "Asterisk", "target": 0, "func": " */\nstatic inline const char *at_msg2str(at_message_t msg)\n{\n\tswitch (msg) {\n\t\n\tcase AT_PARSE_ERROR:\n\t\treturn \"PARSE ERROR\";\n\tcase AT_READ_ERROR:\n\t\treturn \"READ ERROR\";\n\tdefault:\n\tcase AT_UNKNOWN:\n\t\treturn \"UNKNOWN\";\n\t\n\tcase AT_OK:\n\t\treturn \"OK\";\n\tcase AT_ERROR:\n\t\treturn \"ERROR\";\n\tcase AT_RING:\n\t\treturn \"RING\";\n\tcase AT_BRSF:\n\t\treturn \"AT+BRSF\";\n\tcase AT_CIND:\n\t\treturn \"AT+CIND\";\n\tcase AT_CIEV:\n\t\treturn \"AT+CIEV\";\n\tcase AT_CLIP:\n\t\treturn \"AT+CLIP\";\n\tcase AT_CMTI:\n\t\treturn \"AT+CMTI\";\n\tcase AT_CMGR:\n\t\treturn \"AT+CMGR\";\n\tcase AT_SMS_PROMPT:\n\t\treturn \"SMS PROMPT\";\n\tcase AT_CMS_ERROR:\n\t\treturn \"+CMS ERROR\";\n\tcase AT_BUSY:\n\t\treturn \"BUSY\";\n\tcase AT_NO_DIALTONE:\n\t\treturn \"NO DIALTONE\";\n\tcase AT_NO_CARRIER:\n\t\treturn \"NO CARRIER\";\n\t\n\tcase AT_A:\n\t\treturn \"ATA\";\n\tcase AT_D:\n\t\treturn \"ATD\";\n\tcase AT_CHUP:\n\t\treturn \"AT+CHUP\";\n\tcase AT_CKPD:\n\t\treturn \"AT+CKPD\";\n\tcase AT_CMGS:\n\t\treturn \"AT+CMGS\";\n\tcase AT_VGM:\n\t\treturn \"AT+VGM\";\n\tcase AT_VGS:\n\t\treturn \"AT+VGS\";\n\tcase AT_VTS:\n\t\treturn \"AT+VTS\";\n\tcase AT_CMGF:\n\t\treturn \"AT+CMGF\";\n\tcase AT_CNMI:\n\t\treturn \"AT+CNMI\";\n\tcase AT_CMER:\n\t\treturn \"AT+CMER\";\n\tcase AT_CIND_TEST:\n\t\treturn \"AT+CIND=?\";\n\tcase AT_CUSD:\n\t\treturn \"AT+CUSD\";\n\tcase AT_ECAM:\n\t\treturn \"AT*ECAM\";\n\t}\n}\n", "bug_type": null, "idx": 824}
{"project": "Asterisk", "target": 0, "func": "int ooOnReceivedCallProceeding(OOH323CallData *call, Q931Message *q931Msg)\n{\n   H225CallProceeding_UUIE *callProceeding=NULL;\n   H245OpenLogicalChannel* olc;\n   ASN1OCTET msgbuf[MAXMSGLEN];\n   ooLogicalChannel * pChannel = NULL;\n   H245H2250LogicalChannelParameters * h2250lcp = NULL;  \n   int i=0, ret=0;\n   if(!q931Msg->userInfo)\n   {\n      OOTRACEERR3(\"ERROR:No User-User IE in received CallProceeding message.\"\n                  \" (%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   callProceeding = \n             q931Msg->userInfo->h323_uu_pdu.h323_message_body.u.callProceeding;\n   if(callProceeding == NULL)\n   {\n      OOTRACEERR3(\"Error: Received CallProceeding message does not have \"\n                  \"CallProceeding UUIE (%s, %s)\\n\", call->callType, \n                  call->callToken);\n      \n      if(call->callState < OO_CALL_CLEAR)\n      {\n         call->callEndReason = OO_REASON_INVALIDMESSAGE;\n         call->callState = OO_CALL_CLEAR;\n      }\n      return OO_FAILED;\n   }\n   ooHandleH2250ID(call, &callProceeding->protocolIdentifier);\n   \n   if(OO_TESTFLAG (call->flags, OO_M_FASTSTART))\n   {\n      if(callProceeding->m.fastStartPresent)\n      {\n         \n         initializePrintHandler(&printHandler, \"FastStart Elements\");\n         \n         setEventHandler (call->pctxt, &printHandler);\n         for(i=0; i<(int)callProceeding->fastStart.n; i++)\n         {\n            olc = NULL;\n            olc = (H245OpenLogicalChannel*)memAlloc(call->pctxt, \n                                              sizeof(H245OpenLogicalChannel));\n            if(!olc)\n            {\n               OOTRACEERR3(\"ERROR:Memory - ooOnReceivedCallProceeding - olc\"\n                           \"(%s, %s)\\n\", call->callType, call->callToken);\n               \n               if(call->callState < OO_CALL_CLEAR)\n               {\n                  call->callEndReason = OO_REASON_LOCAL_CLEARED;\n                  call->callState = OO_CALL_CLEAR;\n               }\n               finishPrint();\n               removeEventHandler(call->pctxt);\n               return OO_FAILED;\n            }\n            memset(olc, 0, sizeof(H245OpenLogicalChannel));\n            memcpy(msgbuf, callProceeding->fastStart.elem[i].data, \n                                    callProceeding->fastStart.elem[i].numocts);\n            setPERBuffer(call->pctxt, msgbuf, \n                         callProceeding->fastStart.elem[i].numocts, 1);\n            ret = asn1PD_H245OpenLogicalChannel(call->pctxt, olc);\n            if(ret != ASN_OK)\n            {\n               OOTRACEERR3(\"ERROR:Failed to decode fast start olc element \"\n                           \"(%s, %s)\\n\", call->callType, call->callToken);\n               \n               if(call->callState < OO_CALL_CLEAR)\n               {\n                  call->callEndReason = OO_REASON_INVALIDMESSAGE;\n                  call->callState = OO_CALL_CLEAR;\n               }\n               finishPrint();\n               removeEventHandler(call->pctxt);\n               return OO_FAILED;\n            }\n            dListAppend(call->pctxt, &call->remoteFastStartOLCs, olc);\n            pChannel = ooFindLogicalChannelByOLC(call, olc);\n            if(!pChannel)\n            {\n               OOTRACEERR4(\"ERROR: Logical Channel %d not found, fast start. \"\n                           \"(%s, %s)\\n\",\n                            olc->forwardLogicalChannelNumber, call->callType, \n                            call->callToken);\n               finishPrint();\n               removeEventHandler(call->pctxt);\n               return OO_FAILED;\n            }\n            if(pChannel->channelNo != olc->forwardLogicalChannelNumber)\n            {\n               OOTRACEINFO5(\"Remote endpoint changed forwardLogicalChannel\"\n                            \"Number from %d to %d (%s, %s)\\n\", \n                            pChannel->channelNo, \n                            olc->forwardLogicalChannelNumber, call->callType, \n                            call->callToken);\n               pChannel->channelNo = olc->forwardLogicalChannelNumber;\n            }\n            if(!strcmp(pChannel->dir, \"transmit\"))\n            {\n               if(olc->forwardLogicalChannelParameters.multiplexParameters.t !=\n                  T_H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters)\n               {\n                  OOTRACEERR4(\"ERROR:Unknown multiplex parameter type for \"\n                              \"channel %d (%s, %s)\\n\", \n                              olc->forwardLogicalChannelNumber, call->callType,\n                              call->callToken);\n                  continue;\n               }\n               \n               h2250lcp = olc->forwardLogicalChannelParameters.multiplexParameters.u.h2250LogicalChannelParameters;\n               if(!h2250lcp)\n               {\n                  OOTRACEERR3(\"ERROR:Invalid OLC received in fast start. No \"\n                              \"forward Logical Channel Parameters found. \"\n                              \"(%s, %s)\\n\", call->callType, call->callToken);\n                  finishPrint();\n                  removeEventHandler(call->pctxt);\n                  return OO_FAILED;\n               }\n               if(!h2250lcp->m.mediaChannelPresent)\n               {\n                  OOTRACEERR3(\"ERROR:Invalid OLC received in fast start. No \"\n                              \"reverse media channel information found.\"\n                              \"(%s, %s)\\n\", call->callType, call->callToken);\n                  finishPrint();\n                  removeEventHandler(call->pctxt);\n                  return OO_FAILED;\n               }\n               ret = ooGetIpPortFromH245TransportAddress(call, \n                                   &h2250lcp->mediaChannel, pChannel->remoteIP,\n                                   &pChannel->remoteMediaPort);\n               if(ret != OO_OK)\n               {\n               \tif(call->callState < OO_CALL_CLEAR)\n               \t{\n                  call->callEndReason = OO_REASON_INVALIDMESSAGE;\n                  call->callState = OO_CALL_CLEAR;\n               \t}\n                  OOTRACEERR3(\"ERROR:Unsupported media channel address type \"\n                              \"(%s, %s)\\n\", call->callType, call->callToken);\n                  finishPrint();\n                  removeEventHandler(call->pctxt);\n                  return OO_FAILED;\n               }\n               if(!pChannel->chanCap->startTransmitChannel)\n               {\n                  OOTRACEERR3(\"ERROR:No callback registered to start transmit \"\n                              \"channel (%s, %s)\\n\",call->callType, \n                              call->callToken);\n                  finishPrint();\n                  removeEventHandler(call->pctxt);\n                  return OO_FAILED;\n               }\n               pChannel->chanCap->startTransmitChannel(call, pChannel);\n            }\n            \n            ooOnLogicalChannelEstablished(call, pChannel);\n         }\n         finishPrint();\n         removeEventHandler(call->pctxt);\n         OO_SETFLAG(call->flags, OO_M_FASTSTARTANSWERED);\n      }\n   }\n   \n   if(q931Msg->userInfo->h323_uu_pdu.m.h245TunnelingPresent && \n      !q931Msg->userInfo->h323_uu_pdu.h245Tunneling) {\n\tif (OO_TESTFLAG (call->flags, OO_M_TUNNELING)) {\n\t\tOO_CLRFLAG (call->flags, OO_M_TUNNELING);\n\t\tOOTRACEINFO3(\"Tunneling is disabled for call due to remote reject tunneling\"\n\t\t\t      \" (%s, %s)\\n\", call->callType, call->callToken);\n\t}\n   }\n   if(q931Msg->userInfo->h323_uu_pdu.m.h245TunnelingPresent &&\n      q931Msg->userInfo->h323_uu_pdu.h245Tunneling &&\n      OO_TESTFLAG (call->flags, OO_M_TUNNELING) &&\n      callProceeding->m.h245AddressPresent) {\n      OOTRACEINFO3(\"Tunneling and h245address provided.\"\n                   \"Using Tunneling for H.245 messages (%s, %s)\\n\", \n                   call->callType, call->callToken);\n   }\n   else if(callProceeding->m.h245AddressPresent)\n   {\n      if (OO_TESTFLAG (call->flags, OO_M_TUNNELING))\n      {\n         OO_CLRFLAG (call->flags, OO_M_TUNNELING);\n         OOTRACEINFO3(\"Tunneling is disabled for call as H245 address is \"\n                      \"provided in callProceeding message (%s, %s)\\n\", \n                      call->callType, call->callToken);\n      }\n      ret = ooH323GetIpPortFromH225TransportAddress(call, \n                                  &callProceeding->h245Address, call->remoteIP,\n                                  &call->remoteH245Port);\n      if(ret != OO_OK)\n      {\n         OOTRACEERR3(\"Error: Unknown H245 address type in received \"\n                     \"CallProceeding message (%s, %s)\", call->callType, \n                     call->callToken);\n         \n         if(call->callState < OO_CALL_CLEAR)\n         {\n            call->callEndReason = OO_REASON_INVALIDMESSAGE;\n            call->callState = OO_CALL_CLEAR;\n         }\n         return OO_FAILED;\n      }\n      if(call->remoteH245Port != 0 && !call->pH245Channel) {\n      \n       if(ooCreateH245Connection(call)== OO_FAILED)\n       {\n         OOTRACEERR3(\"Error: H.245 channel creation failed (%s, %s)\\n\", \n                     call->callType, call->callToken);\n         if(call->callState < OO_CALL_CLEAR)\n         {\n            call->callEndReason = OO_REASON_TRANSPORTFAILURE;\n            call->callState = OO_CALL_CLEAR;\n         }\n         return OO_FAILED;\n       }\n      }\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 825}
{"project": "Asterisk", "target": 0, "func": "static void mark_lots_as_disabled(void)\n{\n\tstruct ao2_iterator iter;\n\tstruct parking_lot *lot;\n\tfor (iter = ao2_iterator_init(parking_lot_container, 0); (lot = ao2_iterator_next(&iter)); ao2_ref(lot, -1)) {\n\t\tlot->disable_mark = 1;\n\t}\n\tao2_iterator_destroy(&iter);\n}\n", "bug_type": null, "idx": 826}
{"project": "Asterisk", "target": 0, "func": "AST_THREADSTORAGE(commonbuf);\nstatic struct ast_config *realtime_directory(char *context)\n{\n\tstruct ast_config *cfg;\n\tstruct ast_config *rtdata = NULL;\n\tstruct ast_category *cat;\n\tstruct ast_variable *var;\n\tchar *category = NULL;\n\tconst char *fullname;\n\tconst char *hidefromdir, *searchcontexts = NULL;\n\tstruct ast_flags config_flags = { 0 };\n\tstruct ast_str *tmp = ast_str_thread_get(&commonbuf, 100);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\t\n\tcfg = ast_config_load(VOICEMAIL_CONFIG, config_flags);\n\tif (!cfg) {\n\t\t\n\t\tast_log(LOG_WARNING, \"Loading config failed.\\n\");\n\t\treturn NULL;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Config file %s is in an invalid format.  Aborting.\\n\", VOICEMAIL_CONFIG);\n\t\treturn NULL;\n\t}\n\t\n\tif (ast_strlen_zero(context) && (searchcontexts = ast_variable_retrieve(cfg, \"general\", \"searchcontexts\"))) {\n\t\tif (ast_true(searchcontexts)) {\n\t\t\trtdata = ast_load_realtime_multientry(\"voicemail\", \"mailbox LIKE\", \"%\", SENTINEL);\n\t\t\tcontext = NULL;\n\t\t} else {\n\t\t\trtdata = ast_load_realtime_multientry(\"voicemail\", \"mailbox LIKE\", \"%\", \"context\", \"default\", SENTINEL);\n\t\t\tcontext = \"default\";\n\t\t}\n\t} else if (!ast_strlen_zero(context)) {\n\t\trtdata = ast_load_realtime_multientry(\"voicemail\", \"mailbox LIKE\", \"%\", \"context\", context, SENTINEL);\n\t}\n\t\n\tif (!rtdata) {\n\t\treturn cfg;\n\t}\n\twhile ((category = ast_category_browse(rtdata, category))) {\n\t\tconst char *mailbox = ast_variable_retrieve(rtdata, category, \"mailbox\");\n\t\tconst char *ctx = ast_variable_retrieve(rtdata, category, \"context\");\n\t\tif (ast_strlen_zero(mailbox)) {\n\t\t\tast_debug(3, \"Skipping result with missing or empty mailbox\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfullname = ast_variable_retrieve(rtdata, category, \"fullname\");\n\t\thidefromdir = ast_variable_retrieve(rtdata, category, \"hidefromdir\");\n\t\tif (ast_true(hidefromdir)) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tast_str_set(&tmp, 0, \"no-password,%s,,,\", S_OR(fullname, \"\"));\n\t\tif (ast_variable_retrieve(rtdata, category, \"alias\")) {\n\t\t\tstruct ast_variable *alias;\n\t\t\tfor (alias = ast_variable_browse(rtdata, category); alias; alias = alias->next) {\n\t\t\t\tif (!strcasecmp(alias->name, \"alias\")) {\n\t\t\t\t\tast_str_append(&tmp, 0, \"|alias=%s\", alias->value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!(cat = ast_category_get(cfg, ctx, NULL))) {\n\t\t\tif (!(cat = ast_category_new_dynamic(ctx))) {\n\t\t\t\tast_log(LOG_WARNING, \"Out of memory\\n\");\n\t\t\t\tast_config_destroy(cfg);\n\t\t\t\tif (rtdata) {\n\t\t\t\t\tast_config_destroy(rtdata);\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tast_category_append(cfg, cat);\n\t\t}\n\t\tif ((var = ast_variable_new(mailbox, ast_str_buffer(tmp), \"\"))) {\n\t\t\tast_variable_append(cat, var);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of memory adding mailbox '%s'\\n\", mailbox);\n\t\t}\n\t}\n\tast_config_destroy(rtdata);\n\treturn cfg;\n}\n", "bug_type": null, "idx": 827}
{"project": "Asterisk", "target": 0, "func": "static int manager_add_queue_member(struct mansession *s, const struct message *m)\n{\n\tconst char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface;\n\tint paused, penalty = 0;\n\tqueuename = astman_get_header(m, \"Queue\");\n\tinterface = astman_get_header(m, \"Interface\");\n\tpenalty_s = astman_get_header(m, \"Penalty\");\n\tpaused_s = astman_get_header(m, \"Paused\");\n\tmembername = astman_get_header(m, \"MemberName\");\n\tstate_interface = astman_get_header(m, \"StateInterface\");\n\tif (ast_strlen_zero(queuename)) {\n\t\tastman_send_error(s, m, \"'Queue' not specified.\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(interface)) {\n\t\tastman_send_error(s, m, \"'Interface' not specified.\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(penalty_s)) {\n\t\tpenalty = 0;\n\t} else if (sscanf(penalty_s, \"%30d\", &penalty) != 1 || penalty < 0) {\n\t\tpenalty = 0;\n\t}\n\tif (ast_strlen_zero(paused_s)) {\n\t\tpaused = 0;\n\t} else {\n\t\tpaused = abs(ast_true(paused_s));\n\t}\n\tswitch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, NULL)) {\n\tcase RES_OKAY:\n\t\tif (ast_strlen_zero(membername) || !log_membername_as_agent) {\n\t\t\tast_queue_log(queuename, \"MANAGER\", interface, \"ADDMEMBER\", \"%s\", paused ? \"PAUSED\" : \"\");\n\t\t} else {\n\t\t\tast_queue_log(queuename, \"MANAGER\", membername, \"ADDMEMBER\", \"%s\", paused ? \"PAUSED\" : \"\");\n\t\t}\n\t\tastman_send_ack(s, m, \"Added interface to queue\");\n\t\tbreak;\n\tcase RES_EXISTS:\n\t\tastman_send_error(s, m, \"Unable to add interface: Already there\");\n\t\tbreak;\n\tcase RES_NOSUCHQUEUE:\n\t\tastman_send_error(s, m, \"Unable to add interface to queue: No such queue\");\n\t\tbreak;\n\tcase RES_OUTOFMEMORY:\n\t\tastman_send_error(s, m, \"Out of memory\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 828}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(codec_get_id)\n{\n\tRAII_VAR(struct ast_codec *, named, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_codec *, codec, NULL, ao2_cleanup);\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"codec_get_unknown\";\n\t\tinfo->category = \"/main/core_codec/\";\n\t\tinfo->summary = \"codec get unit test\";\n\t\tinfo->description =\n\t\t\t\"Test that getting of a known codec using name and unknown type succeeds\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tif (ast_codec_register(&audio_get_id)) {\n\t\tast_test_status_update(test, \"Unsucessfully registered a codec for getting\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tnamed = ast_codec_get(\"unit_test_audio_get_id\", AST_MEDIA_TYPE_AUDIO, 8000);\n\tif (!named) {\n\t\tast_test_status_update(test, \"Unsuccessfully retrieved a codec we just registered\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tcodec = ast_codec_get_by_id(named->id);\n\tif (!codec) {\n\t\tast_test_status_update(test, \"Unsuccessfully retrieved a codec using id of a named codec we just got\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\treturn AST_TEST_PASS;\n}\n", "bug_type": null, "idx": 829}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int blr_txt(const char *cc, const char *suffix)\n{\n\tstruct txt_context context;\n\tchar domain[128] = \"\";\n\tchar *p1, *p2;\n\tint ret;\n\tast_mutex_lock(&enumlock);\n\tast_verb(4, \"blr_txt()  cc='%s', suffix='%s', c_bl='%s'\\n\", cc, suffix, ienum_branchlabel);\n\tif (sizeof(domain) < (strlen(cc) * 2 + strlen(ienum_branchlabel) + strlen(suffix) + 2)) {\n\t\tast_mutex_unlock(&enumlock);\n\t\tast_log(LOG_WARNING, \"ERROR: string sizing in blr_txt.\\n\");\n\t\treturn -1;\n\t}\n\tp1 = domain + snprintf(domain, sizeof(domain), \"%s.\", ienum_branchlabel);\n\tast_mutex_unlock(&enumlock);\n\tfor (p2 = (char *) cc + strlen(cc) - 1; p2 >= cc; p2--) {\n\t\tif (isdigit(*p2)) {\n\t\t\t*p1++ = *p2;\n\t\t\t*p1++ = '.';\n\t\t}\n\t}\n\tstrcat(p1, suffix);\n\tast_verb(4, \"blr_txt() FQDN for TXT record: %s, cc was %s\\n\", domain, cc);\n\tret = ast_search_dns(&context, domain, C_IN, T_TXT, txt_callback);\n\tif (ret > 0) {\n\t\tret = atoi(context.txt);\n\t\tif ((ret >= 0) && (ret < 20)) {\n\t\t\tast_verb(3, \"blr_txt() BLR TXT record for %s is %d (apex: %s)\\n\", cc, ret, suffix);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tast_verb(3, \"blr_txt() BLR TXT record for %s not found (apex: %s)\\n\", cc, suffix);\n\treturn -1;\n}\n", "bug_type": null, "idx": 830}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_get_device_name(struct ast_channel *chan, char *device_name, size_t name_buffer_length)\n{\n\tint len = name_buffer_length;\n\tchar *dash;\n\tif (!ast_channel_queryoption(chan, AST_OPTION_DEVICE_NAME, device_name, &len, 0)) {\n\t\treturn 0;\n\t}\n\t\n\tast_copy_string(device_name, ast_channel_name(chan), name_buffer_length);\n\tif ((dash = strrchr(device_name, '-'))) {\n\t\t*dash = '\\0';\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 831}
{"project": "Asterisk", "target": 0, "func": " */\nstatic unsigned misdn_to_diversion_reason(enum mISDN_REDIRECTING_REASON reason)\n{\n\tunsigned diversion_reason;\n\tswitch (reason) {\n\tcase mISDN_REDIRECTING_REASON_CALL_FWD:\n\t\tdiversion_reason = 1;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_CALL_FWD_BUSY:\n\t\tdiversion_reason = 2;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_NO_REPLY:\n\t\tdiversion_reason = 3;\n\t\tbreak;\n\tdefault:\n\t\tdiversion_reason = 0;\n\t\tbreak;\n\t}\n\treturn diversion_reason;\n}\n", "bug_type": null, "idx": 832}
{"project": "Asterisk", "target": 0, "func": "static void sorcery_memory_close(void *data)\n{\n\tao2_ref(data, -1);\n}\n", "bug_type": null, "idx": 833}
{"project": "Asterisk", "target": 0, "func": "static inline int include_valid(struct ast_include *i)\n{\n\tif (!i->hastime)\n\t\treturn 1;\n\treturn ast_check_timing(&(i->timing));\n}\n", "bug_type": null, "idx": 834}
{"project": "Asterisk", "target": 0, "func": " */\nstatic const char *misdn_to_str_ton(enum mISDN_NUMBER_TYPE number_type)\n{\n\tconst char *str;\n\tswitch (number_type) {\n\tdefault:\n\tcase NUMTYPE_UNKNOWN:\n\t\tstr = \"Unknown\";\n\t\tbreak;\n\tcase NUMTYPE_INTERNATIONAL:\n\t\tstr = \"International\";\n\t\tbreak;\n\tcase NUMTYPE_NATIONAL:\n\t\tstr = \"National\";\n\t\tbreak;\n\tcase NUMTYPE_NETWORK_SPECIFIC:\n\t\tstr = \"Network Specific\";\n\t\tbreak;\n\tcase NUMTYPE_SUBSCRIBER:\n\t\tstr = \"Subscriber\";\n\t\tbreak;\n\tcase NUMTYPE_ABBREVIATED:\n\t\tstr = \"Abbreviated\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n", "bug_type": null, "idx": 835}
{"project": "Asterisk", "target": 0, "func": "void *ast_sorcery_copy(const struct ast_sorcery *sorcery, const void *object)\n{\n\tconst struct ast_sorcery_object_details *details = object;\n\tRAII_VAR(struct ast_sorcery_object_type *, object_type, ao2_find(sorcery->types, details->object->type, OBJ_KEY), ao2_cleanup);\n\tstruct ast_sorcery_object_details *copy = ast_sorcery_alloc(sorcery, details->object->type, details->object->id);\n\tRAII_VAR(struct ast_variable *, objectset, NULL, ast_variables_destroy);\n\tint res = 0;\n\tif (!copy) {\n\t\treturn NULL;\n\t} else if (object_type->copy) {\n\t\tres = object_type->copy(object, copy);\n\t} else if ((objectset = ast_sorcery_objectset_create(sorcery, object))) {\n\t\tres = ast_sorcery_objectset_apply(sorcery, copy, objectset);\n\t} else {\n\t\t\n\t\tres = -1;\n\t}\n\tif (res) {\n\t\tao2_cleanup(copy);\n\t\tcopy = NULL;\n\t}\n\treturn copy;\n}\n", "bug_type": null, "idx": 836}
{"project": "Asterisk", "target": 0, "func": "static int test_files_create(struct ast_test *test, char *dir_name,\n\t\t\t     struct _filenames *filenames, int num)\n{\n\tint i;\n\tif (!(mkdtemp(dir_name))) {\n\t\tast_test_status_update(test, \"Failed to create directory: %s\\n\", dir_name);\n\t\treturn -1;\n\t}\n\tAST_VECTOR_INIT(filenames, num);\n\t\n\tfor (i = 0; i < num; ++i) {\n\t\tint fd;\n\t\tstruct ast_str *filename = ast_str_create(32);\n\t\tif (!filename) {\n\t\t\tbreak;\n\t\t}\n\t\tast_str_set(&filename, 0, \"%s/XXXXXX\", dir_name);\n\t\tfd = mkstemp(ast_str_buffer(filename));\n\t\tif (fd < 0) {\n\t\t\tast_test_status_update(test, \"Failed to create file: %s\\n\",\n\t\t\t\t\t       ast_str_buffer(filename));\n\t\t\tast_free(filename);\n\t\t\tbreak;\n\t\t}\n\t\tclose(fd);\n\t\tAST_VECTOR_APPEND(filenames, filename);\n\t}\n\tif (i != num) {\n\t\ttest_files_destroy(test, dir_name, filenames);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 837}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245ParameterValue (OOCTXT* pctxt, H245ParameterValue* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"logical\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"logical\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"booleanArray\", -1);\n            stat = decodeConsUInt8 (pctxt, &pvalue->u.booleanArray, 0U, 255U);\n            if (stat != ASN_OK) return stat;\n            invokeUIntValue (pctxt, pvalue->u.booleanArray);\n            invokeEndElement (pctxt, \"booleanArray\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"unsignedMin\", -1);\n            stat = decodeConsUInt16 (pctxt, &pvalue->u.unsignedMin, 0U, 65535U);\n            if (stat != ASN_OK) return stat;\n            invokeUIntValue (pctxt, pvalue->u.unsignedMin);\n            invokeEndElement (pctxt, \"unsignedMin\", -1);\n            break;\n         \n         case 3:\n            invokeStartElement (pctxt, \"unsignedMax\", -1);\n            stat = decodeConsUInt16 (pctxt, &pvalue->u.unsignedMax, 0U, 65535U);\n            if (stat != ASN_OK) return stat;\n            invokeUIntValue (pctxt, pvalue->u.unsignedMax);\n            invokeEndElement (pctxt, \"unsignedMax\", -1);\n            break;\n         \n         case 4:\n            invokeStartElement (pctxt, \"unsigned32Min\", -1);\n            stat = decodeConsUnsigned (pctxt, &pvalue->u.unsigned32Min, 0U, ASN1UINT_MAX);\n            if (stat != ASN_OK) return stat;\n            invokeUIntValue (pctxt, pvalue->u.unsigned32Min);\n            invokeEndElement (pctxt, \"unsigned32Min\", -1);\n            break;\n         \n         case 5:\n            invokeStartElement (pctxt, \"unsigned32Max\", -1);\n            stat = decodeConsUnsigned (pctxt, &pvalue->u.unsigned32Max, 0U, ASN1UINT_MAX);\n            if (stat != ASN_OK) return stat;\n            invokeUIntValue (pctxt, pvalue->u.unsigned32Max);\n            invokeEndElement (pctxt, \"unsigned32Max\", -1);\n            break;\n         \n         case 6:\n            invokeStartElement (pctxt, \"octetString\", -1);\n            pvalue->u.octetString = ALLOC_ASN1ELEM (pctxt, ASN1DynOctStr);\n            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)pvalue->u.octetString);\n            if (stat != ASN_OK) return stat;\n            invokeOctStrValue (pctxt, pvalue->u.octetString->numocts, pvalue->u.octetString->data);\n            invokeEndElement (pctxt, \"octetString\", -1);\n            break;\n         \n         case 7:\n            invokeStartElement (pctxt, \"genericParameter\", -1);\n            pvalue->u.genericParameter = ALLOC_ASN1ELEM (pctxt, H245_SeqOfH245GenericParameter);\n            stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, (H245_SeqOfH245GenericParameter*)pvalue->u.genericParameter);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"genericParameter\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 9;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 838}
{"project": "Asterisk", "target": 0, "func": "void printEndElement (const char* name, int index)\n{\n   gIndentSpaces -= 3;\n   indent ();\n   OOTRACEDBGB1 (\"}\\n\");\n", "bug_type": null, "idx": 839}
{"project": "Asterisk", "target": 0, "func": "static struct ast_manager_event_blob *system_registry_to_ami(struct stasis_message *message)\n{\n\tstruct ast_json_payload *payload = stasis_message_data(message);\n\tconst char *channeltype;\n\tconst char *username;\n\tconst char *domain;\n\tconst char *status;\n\tconst char *cause;\n\tRAII_VAR(struct ast_str *, cause_string, ast_str_create(32), ast_free);\n\tif (!cause_string) {\n\t\treturn NULL;\n\t}\n\tchanneltype = ast_json_string_get(ast_json_object_get(payload->json, \"channeltype\"));\n\tusername = ast_json_string_get(ast_json_object_get(payload->json, \"username\"));\n\tdomain = ast_json_string_get(ast_json_object_get(payload->json, \"domain\"));\n\tstatus = ast_json_string_get(ast_json_object_get(payload->json, \"status\"));\n\tcause = ast_json_string_get(ast_json_object_get(payload->json, \"cause\"));\n\tif (!ast_strlen_zero(cause)) {\n\t\tast_str_set(&cause_string, 0, \"Cause: %s\\r\\n\", cause);\n\t}\n\treturn ast_manager_event_blob_create(EVENT_FLAG_SYSTEM, \"Registry\",\n\t\t\"ChannelType: %s\\r\\n\"\n\t\t\"Username: %s\\r\\n\"\n\t\t\"Domain: %s\\r\\n\"\n\t\t\"Status: %s\\r\\n\"\n\t\t\"%s\",\n\t\tchanneltype, username, domain, status, ast_str_buffer(cause_string));\n}\n", "bug_type": null, "idx": 840}
{"project": "Asterisk", "target": 0, "func": "static int select_item_pause(struct ast_channel *chan, struct ast_flags *flags, char *opts[])\n{\n\tint res = 0, opt_pause = 0;\n\tif (ast_test_flag(flags, OPT_PAUSE) && !ast_strlen_zero(opts[OPT_ARG_PAUSE])) {\n\t\topt_pause = atoi(opts[OPT_ARG_PAUSE]);\n\t\tif (opt_pause > 3000) {\n\t\t\topt_pause = 3000;\n\t\t}\n\t\tres = ast_waitfordigit(chan, opt_pause);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 841}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int reload_queue_rules(int reload)\n{\n\tstruct ast_config *cfg;\n\tstruct rule_list *rl_iter, *new_rl;\n\tstruct penalty_rule *pr_iter;\n\tchar *rulecat = NULL;\n\tstruct ast_variable *rulevar = NULL;\n\tstruct ast_flags config_flags = { (reload && !realtime_rules) ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\tif (!(cfg = ast_config_load(\"queuerules.conf\", config_flags))) {\n\t\tast_log(LOG_NOTICE, \"No queuerules.conf file found, queues will not follow penalty rules\\n\");\n\t\treturn AST_MODULE_LOAD_SUCCESS;\n\t} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {\n\t\tast_log(LOG_NOTICE, \"queuerules.conf has not changed since it was last loaded. Not taking any action.\\n\");\n\t\treturn AST_MODULE_LOAD_SUCCESS;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Config file queuerules.conf is in an invalid format.  Aborting.\\n\");\n\t\treturn AST_MODULE_LOAD_SUCCESS;\n\t}\n\tAST_LIST_LOCK(&rule_lists);\n\twhile ((rl_iter = AST_LIST_REMOVE_HEAD(&rule_lists, list))) {\n\t\twhile ((pr_iter = AST_LIST_REMOVE_HEAD(&rl_iter->rules, list)))\n\t\t\tast_free(pr_iter);\n\t\tast_free(rl_iter);\n\t}\n\twhile ((rulecat = ast_category_browse(cfg, rulecat))) {\n\t\tif (!strcasecmp(rulecat, \"general\")) {\n\t\t\tqueue_rules_set_global_params(cfg);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(new_rl = ast_calloc(1, sizeof(*new_rl)))) {\n\t\t\tAST_LIST_UNLOCK(&rule_lists);\n\t\t\tast_config_destroy(cfg);\n\t\t\treturn AST_MODULE_LOAD_DECLINE;\n\t\t} else {\n\t\t\tast_copy_string(new_rl->name, rulecat, sizeof(new_rl->name));\n\t\t\tAST_LIST_INSERT_TAIL(&rule_lists, new_rl, list);\n\t\t\tfor (rulevar = ast_variable_browse(cfg, rulecat); rulevar; rulevar = rulevar->next)\n\t\t\t\tif(!strcasecmp(rulevar->name, \"penaltychange\"))\n\t\t\t\t\tinsert_penaltychange(new_rl->name, rulevar->value, rulevar->lineno);\n\t\t\t\telse\n\t\t\t\t\tast_log(LOG_WARNING, \"Don't know how to handle rule type '%s' on line %d\\n\", rulevar->name, rulevar->lineno);\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n\tif (realtime_rules && load_realtime_rules()) {\n\t\tAST_LIST_UNLOCK(&rule_lists);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tAST_LIST_UNLOCK(&rule_lists);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 842}
{"project": "Asterisk", "target": 0, "func": "static void *cli_channel_retrieve_by_id(const char *id)\n{\n\treturn ast_channel_snapshot_get_latest_by_name(id);\n}\n", "bug_type": null, "idx": 843}
{"project": "Asterisk", "target": 0, "func": "static struct ast_json *queue_member_blob_create(struct call_queue *q, struct member *mem)\n{\n\treturn ast_json_pack(\"{s: s, s: s, s: s, s: s, s: s, s: i, s: i, s: i, s: i, s: i, s: i, s: i, s: s, s: i}\",\n\t\t\"Queue\", q->name,\n\t\t\"MemberName\", mem->membername,\n\t\t\"Interface\", mem->interface,\n\t\t\"StateInterface\", mem->state_interface,\n\t\t\"Membership\", (mem->dynamic ? \"dynamic\" : (mem->realtime ? \"realtime\" : \"static\")),\n\t\t\"Penalty\", mem->penalty,\n\t\t\"CallsTaken\", mem->calls,\n\t\t\"LastCall\", (int)mem->lastcall,\n\t\t\"LastPause\", (int)mem->lastpause,\n\t\t\"InCall\", mem->starttime ? 1 : 0,\n\t\t\"Status\", mem->status,\n\t\t\"Paused\", mem->paused,\n\t\t\"PausedReason\", mem->reason_paused,\n\t\t\"Ringinuse\", mem->ringinuse);\n}\n", "bug_type": null, "idx": 844}
{"project": "Asterisk", "target": 0, "func": "void ooh323_set_write_format(ooCallData *call, struct ast_format *fmt, int txframes)\n{\n\tstruct ooh323_pvt *p = NULL;\n\tif (gH323Debug)\n\t\tast_verb(0, \"---   ooh323_update_writeformat %s/%d\\n\", \n\t\t\t\tast_format_get_name(fmt), txframes);\n\tp = find_call(call);\n\tif (!p) {\n\t\tast_log(LOG_ERROR, \"No matching call found for %s\\n\", call->callToken);\n\t\treturn;\n\t}\n\tast_mutex_lock(&p->lock);\n\tao2_replace(p->writeformat, fmt);\n\tif (p->owner) {\n\t\tstruct ast_format_cap *caps;\n\t\tcaps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\t\tif (!caps) {\n\t\t\tast_log(LOG_ERROR, \"Could not allocate capabilities structure\\n\");\n\t\t\treturn;\n\t\t}\n\t\twhile (p->owner && ast_channel_trylock(p->owner)) {\n\t\t\tast_debug(1,\"Failed to grab lock, trying again\\n\");\n\t\t\tDEADLOCK_AVOIDANCE(&p->lock);\n\t\t}\n\t\tif (!p->owner) {\n\t\t\tast_mutex_unlock(&p->lock);\n\t\t\tast_log(LOG_ERROR, \"Channel has no owner\\n\");\n\t\t\tao2_ref(caps, -1);\n\t\t\treturn;\n\t\t}\n\t\tif (gH323Debug) {\n\t\t\tstruct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\t\t\tast_verb(0, \"Writeformat before update %s/%s\\n\", \n\t\t\t  ast_format_get_name(ast_channel_writeformat(p->owner)),\n\t\t\t  ast_format_cap_get_names(ast_channel_nativeformats(p->owner), &codec_buf));\n\t\t}\n\t\tif (p->dtmfmode & H323_DTMF_RFC2833 && p->dtmfcodec) {\n\t\t\tast_rtp_codecs_payloads_set_rtpmap_type(ast_rtp_instance_get_codecs(p->rtp),\n\t\t\t\t p->rtp, p->dtmfcodec, \"audio\", \"telephone-event\", 0);\n\t\t}\n\t\tif (p->dtmfmode & H323_DTMF_CISCO && p->dtmfcodec) {\n\t\t\tast_rtp_codecs_payloads_set_rtpmap_type(ast_rtp_instance_get_codecs(p->rtp),\n\t\t\t\t p->rtp, p->dtmfcodec, \"audio\", \"cisco-telephone-event\", 0);\n\t\t}\n\t\tif (txframes) {\n\t\t\tast_format_cap_set_framing(caps, txframes);\n\t\t}\n\t\tast_format_cap_append(caps, fmt, 0);\n\t\tast_channel_nativeformats_set(p->owner, caps);\n\t\tao2_ref(caps, -1);\n\t  \tast_set_write_format(p->owner, ast_channel_writeformat(p->owner));\n\t  \tast_set_read_format(p->owner, ast_channel_readformat(p->owner));\n\t\tast_channel_unlock(p->owner);\n   \t} else\n\t\tast_log(LOG_ERROR, \"No owner found\\n\");\n\tast_mutex_unlock(&p->lock);\n\tif (gH323Debug)\n\t\tast_verb(0, \"+++   ooh323_update_writeformat\\n\");\n}\n", "bug_type": null, "idx": 845}
{"project": "Asterisk", "target": 0, "func": "void ast_ignore_cc(struct ast_channel *chan)\n{\n\tstruct ast_datastore *cc_datastore;\n\tstruct ast_datastore *cc_recall_datastore;\n\tstruct dialed_cc_interfaces *cc_interfaces;\n\tstruct cc_recall_ds_data *recall_cc_data;\n\tast_channel_lock(chan);\n\tif ((cc_datastore = ast_channel_datastore_find(chan, &dialed_cc_interfaces_info, NULL))) {\n\t\tcc_interfaces = cc_datastore->data;\n\t\tcc_interfaces->ignore = 1;\n\t}\n\tif ((cc_recall_datastore = ast_channel_datastore_find(chan, &recall_ds_info, NULL))) {\n\t\trecall_cc_data = cc_recall_datastore->data;\n\t\trecall_cc_data->ignore = 1;\n\t}\n\tast_channel_unlock(chan);\n}\n", "bug_type": null, "idx": 846}
{"project": "Asterisk", "target": 0, "func": "\nstatic int rqm_exec(struct ast_channel *chan, const char *data)\n{\n\tint res=-1;\n\tchar *parse, *temppos = NULL;\n\tstruct member *mem = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(queuename);\n\t\tAST_APP_ARG(interface);\n\t);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"RemoveQueueMember requires an argument (queuename[,interface])\\n\");\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (ast_strlen_zero(args.interface)) {\n\t\targs.interface = ast_strdupa(ast_channel_name(chan));\n\t\ttemppos = strrchr(args.interface, '-');\n\t\tif (temppos) {\n\t\t\t*temppos = '\\0';\n\t\t}\n\t}\n\tast_debug(1, \"queue: %s, member: %s\\n\", args.queuename, args.interface);\n\tif (log_membername_as_agent) {\n\t\tmem = find_member_by_queuename_and_interface(args.queuename, args.interface);\n\t}\n\tswitch (remove_from_queue(args.queuename, args.interface)) {\n\tcase RES_OKAY:\n\t\tif (!mem || ast_strlen_zero(mem->membername)) {\n\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), args.interface, \"REMOVEMEMBER\", \"%s\", \"\");\n\t\t} else {\n\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), mem->membername, \"REMOVEMEMBER\", \"%s\", \"\");\n\t\t}\n\t\tast_log(LOG_NOTICE, \"Removed interface '%s' from queue '%s'\\n\", args.interface, args.queuename);\n\t\tpbx_builtin_setvar_helper(chan, \"RQMSTATUS\", \"REMOVED\");\n\t\tres = 0;\n\t\tbreak;\n\tcase RES_EXISTS:\n\t\tast_debug(1, \"Unable to remove interface '%s' from queue '%s': Not there\\n\", args.interface, args.queuename);\n\t\tpbx_builtin_setvar_helper(chan, \"RQMSTATUS\", \"NOTINQUEUE\");\n\t\tres = 0;\n\t\tbreak;\n\tcase RES_NOSUCHQUEUE:\n\t\tast_log(LOG_WARNING, \"Unable to remove interface from queue '%s': No such queue\\n\", args.queuename);\n\t\tpbx_builtin_setvar_helper(chan, \"RQMSTATUS\", \"NOSUCHQUEUE\");\n\t\tres = 0;\n\t\tbreak;\n\tcase RES_NOT_DYNAMIC:\n\t\tast_log(LOG_WARNING, \"Unable to remove interface from queue '%s': '%s' is not a dynamic member\\n\", args.queuename, args.interface);\n\t\tpbx_builtin_setvar_helper(chan, \"RQMSTATUS\", \"NOTDYNAMIC\");\n\t\tres = 0;\n\t\tbreak;\n\t}\n\tif (mem) {\n\t\tao2_ref(mem, -1);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 847}
{"project": "Asterisk", "target": 0, "func": "struct ast_include *ast_walk_context_includes(struct ast_context *con, struct ast_include *inc);\nstruct ast_include *ast_walk_context_includes(struct ast_context *con, struct ast_include *inc)\n{\n\treturn NULL;\n}\n", "bug_type": null, "idx": 848}
{"project": "Asterisk", "target": 0, "func": "\nstatic pid_t safe_exec_prep(int dualfork)\n{\n\tpid_t pid;\n#if defined(HAVE_WORKING_FORK) || defined(HAVE_WORKING_VFORK)\n\tast_replace_sigchld();\n#ifdef HAVE_WORKING_FORK\n\tpid = fork();\n#else\n\tpid = vfork();\n#endif\n\tif (pid == 0) {\n#ifdef HAVE_CAP\n\t\tcap_t cap = cap_from_text(\"cap_net_admin-eip\");\n\t\tif (cap_set_proc(cap)) {\n\t\t\t\n\t\t\tast_log(LOG_WARNING, \"Unable to remove capabilities.\\n\");\n\t\t}\n\t\tcap_free(cap);\n#endif\n#ifdef HAVE_WORKING_FORK\n\t\tif (ast_opt_high_priority) {\n\t\t\tast_set_priority(0);\n\t\t}\n\t\t\n\t\tast_close_fds_above_n(STDERR_FILENO);\n#endif\n\t\tif (dualfork) {\n#ifdef HAVE_WORKING_FORK\n\t\t\tpid = fork();\n#else\n\t\t\tpid = vfork();\n#endif\n\t\t\tif (pid < 0) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tif (pid > 0) {\n\t\t\t\t\n\t\t\t\t_exit(0);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif (pid < 0) {\n\t\tast_log(LOG_WARNING, \"Fork failed: %s\\n\", strerror(errno));\n\t}\n#else\n\tast_log(LOG_WARNING, \"Fork failed: %s\\n\", strerror(ENOTSUP));\n\tpid = -1;\n#endif\n\treturn pid;\n}\n", "bug_type": null, "idx": 849}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void xmldoc_parse_optionlist(struct ast_xml_node *fixnode, const char *tabs, struct ast_str **buffer)\n{\n\tstruct ast_xml_node *node;\n\tconst char *optname, *hasparams;\n\tchar *optionsyntax;\n\tint optparams;\n\tfor (node = ast_xml_node_get_children(fixnode); node; node = ast_xml_node_get_next(node)) {\n\t\t\n\t\tif (strcasecmp(ast_xml_node_get_name(node), \"option\")) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\toptname = ast_xml_get_attribute(node, \"name\");\n\t\tif (!optname) {\n\t\t\tcontinue;\n\t\t}\n\t\toptparams = 1;\n\t\thasparams = ast_xml_get_attribute(node, \"hasparams\");\n\t\tif (hasparams && !strcasecmp(hasparams, \"optional\")) {\n\t\t\toptparams = 2;\n\t\t}\n\t\toptionsyntax = xmldoc_get_syntax_fun(node, optname, \"argument\", 0, optparams);\n\t\tif (!optionsyntax) {\n\t\t\tast_xml_free_attr(optname);\n\t\t\tast_xml_free_attr(hasparams);\n\t\t\tcontinue;\n\t\t}\n\t\tast_str_append(buffer, 0, \"%s%s: \", tabs, optionsyntax);\n\t\tif (!xmldoc_parse_option(node, tabs, buffer)) {\n\t\t\tast_str_append(buffer, 0, \"\\n\");\n\t\t}\n\t\tast_str_append(buffer, 0, \"\\n\");\n\t\tast_xml_free_attr(optname);\n\t\tast_xml_free_attr(hasparams);\n\t\tast_free(optionsyntax);\n\t}\n}\n", "bug_type": null, "idx": 850}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_ari_endpoints_list_by_tech_cb(\n\tstruct ast_tcptls_session_instance *ser,\n\tstruct ast_variable *get_params, struct ast_variable *path_vars,\n\tstruct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)\n{\n\tstruct ast_ari_endpoints_list_by_tech_args args = {};\n\tstruct ast_variable *i;\n#if defined(AST_DEVMODE)\n\tint is_valid;\n\tint code;\n#endif \n\tfor (i = path_vars; i; i = i->next) {\n\t\tif (strcmp(i->name, \"tech\") == 0) {\n\t\t\targs.tech = (i->value);\n\t\t} else\n\t\t{}\n\t}\n\tast_ari_endpoints_list_by_tech(headers, &args, response);\n#if defined(AST_DEVMODE)\n\tcode = response->response_code;\n\tswitch (code) {\n\tcase 0: \n\t\tis_valid = response->message == NULL;\n\t\tbreak;\n\tcase 500: \n\tcase 501: \n\tcase 404: \n\t\tis_valid = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (200 <= code && code <= 299) {\n\t\t\tis_valid = ast_ari_validate_list(response->message,\n\t\t\t\tast_ari_validate_endpoint_fn());\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Invalid error response %d for /endpoints/{tech}\\n\", code);\n\t\t\tis_valid = 0;\n\t\t}\n\t}\n\tif (!is_valid) {\n\t\tast_log(LOG_ERROR, \"Response validation failed for /endpoints/{tech}\\n\");\n\t\tast_ari_response_error(response, 500,\n\t\t\t\"Internal Server Error\", \"Response validation failed\");\n\t}\n#endif \nfin: __attribute__((unused))\n\treturn;\n}\n", "bug_type": null, "idx": 851}
{"project": "Asterisk", "target": 0, "func": "static int pbcpop3(char x)\n{\n\tif (   ( x == ')' && pbcstack3[pbcpos3-1] == '(' )\n\t\t|| ( x == ']' && pbcstack3[pbcpos3-1] == '[' )\n\t\t|| ( x == '}' && pbcstack3[pbcpos3-1] == '{' )) {\n\t\tpbcpos3--;\n\t\treturn 0;\n\t}\n", "bug_type": null, "idx": 852}
{"project": "Asterisk", "target": 0, "func": "static int store_mysql(const char *database, const char *table, const struct ast_variable *rt_fields)\n{\n\tstruct mysql_conn *dbh;\n\tstruct ast_str *sql = ast_str_thread_get(&sql_buf, 16);\n\tstruct ast_str *sql2 = ast_str_thread_get(&sql2_buf, 16);\n\tstruct ast_str *buf = ast_str_thread_get(&scratch_buf, 16);\n\tconst struct ast_variable *field = rt_fields;\n\tif (!(dbh = find_database(database, 1))) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Invalid database specified: '%s' (check res_mysql.conf)\\n\", database);\n\t\treturn -1;\n\t}\n\tif (!table) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: No table specified.\\n\");\n\t\trelease_database(dbh);\n\t\treturn -1;\n\t}\n\t\n\tif (!field) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Realtime storage requires at least 1 parameter and 1 value to search on.\\n\");\n\t\trelease_database(dbh);\n\t\treturn -1;\n\t}\n\t\n\tif (!mysql_reconnect(dbh)) {\n\t\trelease_database(dbh);\n\t\treturn -1;\n\t}\n\t\n\tESCAPE_STRING(buf, field->value);\n\tast_str_set(&sql, 0, \"INSERT INTO %s (`%s`\", table, field->name);\n\tast_str_set(&sql2, 0, \") VALUES ('%s'\", ast_str_buffer(buf));\n\twhile ((field = field->next)) {\n\t\tESCAPE_STRING(buf, field->value);\n\t\tast_str_append(&sql, 0, \", `%s`\", field->name);\n\t\tast_str_append(&sql2, 0, \", '%s'\", ast_str_buffer(buf));\n\t}\n\tast_str_append(&sql, 0, \"%s)\", ast_str_buffer(sql2));\n\tast_debug(1,\"MySQL RealTime: Insert SQL: %s\\n\", ast_str_buffer(sql));\n\t\n\tif (mysql_real_query(&dbh->handle, ast_str_buffer(sql), ast_str_strlen(sql))) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Failed to insert into database: %s\\n\", mysql_error(&dbh->handle));\n\t\trelease_database(dbh);\n\t\treturn -1;\n\t}\n\trelease_database(dbh);\n\tast_debug(1, \"MySQL RealTime: row inserted on table: %s\\n\", table);\n\treturn 1;\n}\n", "bug_type": null, "idx": 853}
{"project": "Asterisk", "target": 0, "func": "void bridge_channel_queue_deferred_frames(struct ast_bridge_channel *bridge_channel)\n{\n\tstruct ast_frame *frame;\n\tast_bridge_channel_lock(bridge_channel);\n\tast_channel_lock(bridge_channel->chan);\n\twhile ((frame = AST_LIST_REMOVE_HEAD(&bridge_channel->deferred_queue, frame_list))) {\n\t\tast_queue_frame_head(bridge_channel->chan, frame);\n\t\tast_frfree(frame);\n\t}\n\tast_channel_unlock(bridge_channel->chan);\n\tast_bridge_channel_unlock(bridge_channel);\n}\n", "bug_type": null, "idx": 854}
{"project": "Asterisk", "target": 0, "func": "static char *complete_queue_show(const char *line, const char *word, int pos, int state)\n{\n\tif (pos == 2) {\n\t\treturn complete_queue(line, word, pos, state, 0);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 855}
{"project": "Asterisk", "target": 0, "func": "static int mbl_answer(struct ast_channel *ast)\n{\n\tstruct mbl_pvt *pvt;\n\tpvt = ast_channel_tech_pvt(ast);\n\tif (pvt->type == MBL_TYPE_HEADSET)\n\t\treturn 0;\n\tast_mutex_lock(&pvt->lock);\n\tif (pvt->incoming) {\n\t\thfp_send_ata(pvt->hfp);\n\t\tmsg_queue_push(pvt, AT_OK, AT_A);\n\t\tpvt->answered = 1;\n\t}\n\tast_mutex_unlock(&pvt->lock);\n\treturn 0;\n}\n", "bug_type": null, "idx": 856}
{"project": "Asterisk", "target": 0, "func": "STASIS_MESSAGE_TYPE_DEFN(ast_cluster_discovery_type);\nvoid ast_system_publish_registry(const char *channeltype, const char *username, const char *domain, const char *status, const char *cause)\n{\n\tRAII_VAR(struct ast_json *, registry, NULL, ast_json_unref);\n\tRAII_VAR(struct ast_json_payload *, payload, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tif (!ast_system_registry_type()) {\n\t\treturn;\n\t}\n\tregistry = ast_json_pack(\"{s: s, s: s, s: s, s: s, s: s, s: s}\",\n\t\t\"type\", \"registry\",\n\t\t\"channeltype\", channeltype,\n\t\t\"username\", username,\n\t\t\"domain\", domain,\n\t\t\"status\", status,\n\t\t\"cause\", S_OR(cause, \"\"));\n\tif (!(payload = ast_json_payload_create(registry))) {\n\t\treturn;\n\t}\n\tif (!(message = stasis_message_create(ast_system_registry_type(), payload))) {\n\t\treturn;\n\t}\n\tstasis_publish(ast_system_topic(), message);\n}\n", "bug_type": null, "idx": 857}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void sig_pri_aoc_e_from_ast(struct sig_pri_chan *pvt, struct ast_aoc_decoded *decoded)\n{\n\tstruct pri_subcmd_aoc_e *aoc_e = &pvt->aoc_e;\n\tconst struct ast_aoc_charging_association *ca = ast_aoc_get_association_info(decoded);\n\tmemset(aoc_e, 0, sizeof(*aoc_e));\n\tpvt->holding_aoce = 1;\n\tswitch (ca->charging_type) {\n\tcase AST_AOC_CHARGING_ASSOCIATION_NUMBER:\n\t\taoc_e->associated.charge.number.valid = 1;\n\t\tast_copy_string(aoc_e->associated.charge.number.str,\n\t\t\tca->charge.number.number,\n\t\t\tsizeof(aoc_e->associated.charge.number.str));\n\t\taoc_e->associated.charge.number.plan = ca->charge.number.plan;\n\t\taoc_e->associated.charging_type = PRI_AOC_E_CHARGING_ASSOCIATION_NUMBER;\n\t\tbreak;\n\tcase AST_AOC_CHARGING_ASSOCIATION_ID:\n\t\taoc_e->associated.charge.id = ca->charge.id;\n\t\taoc_e->associated.charging_type = PRI_AOC_E_CHARGING_ASSOCIATION_ID;\n\t\tbreak;\n\tcase AST_AOC_CHARGING_ASSOCIATION_NA:\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (ast_aoc_get_billing_id(decoded)) {\n\tcase AST_AOC_BILLING_NORMAL:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_NORMAL;\n\t\tbreak;\n\tcase AST_AOC_BILLING_REVERSE_CHARGE:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_REVERSE;\n\t\tbreak;\n\tcase AST_AOC_BILLING_CREDIT_CARD:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_CREDIT_CARD;\n\t\tbreak;\n\tcase AST_AOC_BILLING_CALL_FWD_UNCONDITIONAL:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_CALL_FORWARDING_UNCONDITIONAL;\n\t\tbreak;\n\tcase AST_AOC_BILLING_CALL_FWD_BUSY:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_CALL_FORWARDING_BUSY;\n\t\tbreak;\n\tcase AST_AOC_BILLING_CALL_FWD_NO_REPLY:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_CALL_FORWARDING_NO_REPLY;\n\t\tbreak;\n\tcase AST_AOC_BILLING_CALL_DEFLECTION:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_CALL_DEFLECTION;\n\t\tbreak;\n\tcase AST_AOC_BILLING_CALL_TRANSFER:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_CALL_TRANSFER;\n\t\tbreak;\n\tcase AST_AOC_BILLING_NA:\n\tdefault:\n\t\taoc_e->billing_id = PRI_AOC_E_BILLING_ID_NOT_AVAILABLE;\n\t\tbreak;\n\t}\n\tswitch (ast_aoc_get_charge_type(decoded)) {\n\tcase AST_AOC_CHARGE_FREE:\n\t\taoc_e->charge = PRI_AOC_DE_CHARGE_FREE;\n\t\tbreak;\n\tcase AST_AOC_CHARGE_CURRENCY:\n\t\t{\n\t\t\tconst char *currency_name = ast_aoc_get_currency_name(decoded);\n\t\t\taoc_e->charge = PRI_AOC_DE_CHARGE_CURRENCY;\n\t\t\taoc_e->recorded.money.amount.cost = ast_aoc_get_currency_amount(decoded);\n\t\t\taoc_e->recorded.money.amount.multiplier = sig_pri_aoc_multiplier_from_ast(ast_aoc_get_currency_multiplier(decoded));\n\t\t\tif (!ast_strlen_zero(currency_name)) {\n\t\t\t\tast_copy_string(aoc_e->recorded.money.currency, currency_name, sizeof(aoc_e->recorded.money.currency));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AST_AOC_CHARGE_UNIT:\n\t\t{\n\t\t\tconst struct ast_aoc_unit_entry *entry;\n\t\t\tint i;\n\t\t\taoc_e->charge = PRI_AOC_DE_CHARGE_UNITS;\n\t\t\tfor (i = 0; i < ast_aoc_get_unit_count(decoded); i++) {\n\t\t\t\tif ((entry = ast_aoc_get_unit_info(decoded, i)) && i < ARRAY_LEN(aoc_e->recorded.unit.item)) {\n\t\t\t\t\tif (entry->valid_amount) {\n\t\t\t\t\t\taoc_e->recorded.unit.item[i].number = entry->amount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\taoc_e->recorded.unit.item[i].number = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (entry->valid_type) {\n\t\t\t\t\t\taoc_e->recorded.unit.item[i].type = entry->type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\taoc_e->recorded.unit.item[i].type = -1;\n\t\t\t\t\t}\n\t\t\t\t\taoc_e->recorded.unit.num_items++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AST_AOC_CHARGE_NA:\n\tdefault:\n\t\taoc_e->charge = PRI_AOC_DE_CHARGE_NOT_AVAILABLE;\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 858}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function config_function = {\n\t.name = \"AST_CONFIG\",\n\t.read = config_function_read,\n};\n}\nstatic struct ast_custom_function config_function = {\n\t.name = \"AST_CONFIG\",\n\t.read = config_function_read,\n};\nstatic int unload_module(void)\n{\n\tstruct config_item *current;\n\tint res = ast_custom_function_unregister(&config_function);\n\tAST_RWLIST_WRLOCK(&configs);\n\twhile ((current = AST_RWLIST_REMOVE_HEAD(&configs, entry))) {\n\t\tast_config_destroy(current->cfg);\n\t\tast_free(current);\n\t}\n\tAST_RWLIST_UNLOCK(&configs);\n\treturn res;\n}\nstatic int load_module(void)\n{\n\treturn ast_custom_function_register(&config_function);\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"Asterisk configuration file variable access\");\n", "bug_type": null, "idx": 859}
{"project": "Asterisk", "target": 0, "func": "static pj_bool_t on_rx_process_symmetric_transport(pjsip_rx_data *rdata)\n{\n\tpjsip_contact_hdr *contact;\n\tpjsip_sip_uri *uri;\n\tconst char *transport_id;\n\tstruct ast_sip_transport *transport;\n\tpjsip_param *x_transport;\n\tif (rdata->msg_info.msg->type != PJSIP_REQUEST_MSG) {\n\t\treturn PJ_FALSE;\n\t}\n\tcontact = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);\n\tif (!(contact && contact->uri\n\t\t&& ast_begins_with(rdata->tp_info.transport->info, AST_SIP_X_AST_TXP \":\"))) {\n\t\treturn PJ_FALSE;\n\t}\n\turi = pjsip_uri_get_uri(contact->uri);\n\ttransport_id = rdata->tp_info.transport->info + AST_SIP_X_AST_TXP_LEN + 1;\n\ttransport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"transport\", transport_id);\n\tif (!(transport && transport->symmetric_transport)) {\n\t\tao2_cleanup(transport);\n\t\treturn PJ_FALSE;\n\t}\n\tao2_cleanup(transport);\n\tx_transport = PJ_POOL_ALLOC_T(rdata->tp_info.pool, pjsip_param);\n\tx_transport->name = pj_strdup3(rdata->tp_info.pool, AST_SIP_X_AST_TXP);\n\tx_transport->value = pj_strdup3(rdata->tp_info.pool, transport_id);\n\tpj_list_insert_before(&uri->other_param, x_transport);\n\tast_debug(1, \"Set transport '%s' on %.*s from %.*s:%d\\n\", transport_id,\n\t\t(int)rdata->msg_info.msg->line.req.method.name.slen,\n\t\trdata->msg_info.msg->line.req.method.name.ptr,\n\t\t(int)uri->host.slen, uri->host.ptr, uri->port);\n\treturn PJ_FALSE;\n}\n", "bug_type": null, "idx": 860}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int softmix_bridge_write(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel, struct ast_frame *frame)\n{\n\tint res = 0;\n\tif (!bridge->tech_pvt || !bridge_channel || !bridge_channel->tech_pvt) {\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tswitch (frame->frametype) {\n\tcase AST_FRAME_NULL:\n\t\t\n\t\tbreak;\n\tcase AST_FRAME_DTMF_BEGIN:\n\tcase AST_FRAME_DTMF_END:\n\t\tres = ast_bridge_queue_everyone_else(bridge, bridge_channel, frame);\n\t\tbreak;\n\tcase AST_FRAME_VOICE:\n\t\tsoftmix_bridge_write_voice(bridge, bridge_channel, frame);\n\t\tbreak;\n\tcase AST_FRAME_VIDEO:\n\t\tsoftmix_bridge_write_video(bridge, bridge_channel, frame);\n\t\tbreak;\n\tcase AST_FRAME_CONTROL:\n\t\tres = softmix_bridge_write_control(bridge, bridge_channel, frame);\n\t\tbreak;\n\tcase AST_FRAME_BRIDGE_ACTION:\n\t\tres = ast_bridge_queue_everyone_else(bridge, bridge_channel, frame);\n\t\tbreak;\n\tcase AST_FRAME_BRIDGE_ACTION_SYNC:\n\t\tast_log(LOG_ERROR, \"Synchronous bridge action written to a softmix bridge.\\n\");\n\t\tast_assert(0);\n\tdefault:\n\t\tast_debug(3, \"Frame type %u unsupported\\n\", frame->frametype);\n\t\t\n\t\tbreak;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 861}
{"project": "Asterisk", "target": 0, "func": "struct stasis_topic *ast_presence_state_topic_cached(void)\n{\n\treturn stasis_caching_get_topic(presence_state_topic_cached);\n}\n", "bug_type": null, "idx": 862}
{"project": "Asterisk", "target": 0, "func": "static int context_used(struct ael_extension *exten_list, struct ast_context *context)\n{\n\tstruct ael_extension *exten;\n\t\n\tif (ast_walk_context_extensions(context, NULL) || ast_context_includes_count(context) || ast_context_ignorepats_count(context) || ast_context_switches_count(context)) {\n\t\treturn 1;\n\t}\n\tfor (exten = exten_list; exten; exten = exten->next_exten) {\n\t\tif (exten->context == context) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 863}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_ari_bridges_add_channel_cb(\n\tstruct ast_tcptls_session_instance *ser,\n\tstruct ast_variable *get_params, struct ast_variable *path_vars,\n\tstruct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)\n{\n\tstruct ast_ari_bridges_add_channel_args args = {};\n\tstruct ast_variable *i;\n#if defined(AST_DEVMODE)\n\tint is_valid;\n\tint code;\n#endif \n\tfor (i = get_params; i; i = i->next) {\n\t\tif (strcmp(i->name, \"channel\") == 0) {\n\t\t\t\n\t\t\tchar *vals[MAX_VALS];\n\t\t\tsize_t j;\n\t\t\targs.channel_parse = ast_strdup(i->value);\n\t\t\tif (!args.channel_parse) {\n\t\t\t\tast_ari_response_alloc_failed(response);\n\t\t\t\tgoto fin;\n\t\t\t}\n\t\t\tif (strlen(args.channel_parse) == 0) {\n\t\t\t\t\n\t\t\t\targs.channel_count = 1;\n\t\t\t\tvals[0] = args.channel_parse;\n\t\t\t} else {\n\t\t\t\targs.channel_count = ast_app_separate_args(\n\t\t\t\t\targs.channel_parse, ',', vals,\n\t\t\t\t\tARRAY_LEN(vals));\n\t\t\t}\n\t\t\tif (args.channel_count == 0) {\n\t\t\t\tast_ari_response_alloc_failed(response);\n\t\t\t\tgoto fin;\n\t\t\t}\n\t\t\tif (args.channel_count >= MAX_VALS) {\n\t\t\t\tast_ari_response_error(response, 400,\n\t\t\t\t\t\"Bad Request\",\n\t\t\t\t\t\"Too many values for channel\");\n\t\t\t\tgoto fin;\n\t\t\t}\n\t\t\targs.channel = ast_malloc(sizeof(*args.channel) * args.channel_count);\n\t\t\tif (!args.channel) {\n\t\t\t\tast_ari_response_alloc_failed(response);\n\t\t\t\tgoto fin;\n\t\t\t}\n\t\t\tfor (j = 0; j < args.channel_count; ++j) {\n\t\t\t\targs.channel[j] = (vals[j]);\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(i->name, \"role\") == 0) {\n\t\t\targs.role = (i->value);\n\t\t} else\n\t\t{}\n\t}\n\tfor (i = path_vars; i; i = i->next) {\n\t\tif (strcmp(i->name, \"bridgeId\") == 0) {\n\t\t\targs.bridge_id = (i->value);\n\t\t} else\n\t\t{}\n\t}\n\tif (ast_ari_bridges_add_channel_parse_body(body, &args)) {\n\t\tast_ari_response_alloc_failed(response);\n\t\tgoto fin;\n\t}\n\tast_ari_bridges_add_channel(headers, &args, response);\n#if defined(AST_DEVMODE)\n\tcode = response->response_code;\n\tswitch (code) {\n\tcase 0: \n\t\tis_valid = response->message == NULL;\n\t\tbreak;\n\tcase 500: \n\tcase 501: \n\tcase 400: \n\tcase 404: \n\tcase 409: \n\tcase 422: \n\t\tis_valid = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (200 <= code && code <= 299) {\n\t\t\tis_valid = ast_ari_validate_void(\n\t\t\t\tresponse->message);\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Invalid error response %d for /bridges/{bridgeId}/addChannel\\n\", code);\n\t\t\tis_valid = 0;\n\t\t}\n\t}\n\tif (!is_valid) {\n\t\tast_log(LOG_ERROR, \"Response validation failed for /bridges/{bridgeId}/addChannel\\n\");\n\t\tast_ari_response_error(response, 500,\n\t\t\t\"Internal Server Error\", \"Response validation failed\");\n\t}\n#endif \nfin: __attribute__((unused))\n\tast_free(args.channel_parse);\n\tast_free(args.channel);\n\treturn;\n}\n", "bug_type": null, "idx": 864}
{"project": "Asterisk", "target": 0, "func": "const char *ast_channel_linkedid(const struct ast_channel *chan)\n{\n\tast_assert(chan->linkedid.unique_id[0] != '\\0');\n\treturn chan->linkedid.unique_id;\n}\n", "bug_type": null, "idx": 865}
{"project": "Asterisk", "target": 0, "func": "static int require_pgsql(const char *database, const char *tablename, va_list ap)\n{\n\tstruct columns *column;\n\tstruct tables *table;\n\tchar *elm;\n\tint type, size, res = 0;\n\t\n\tdatabase = dbname;\n\ttable = find_table(database, tablename);\n\tif (!table) {\n\t\tast_log(LOG_WARNING, \"Table %s not found in database.  This table should exist if you're using realtime.\\n\", tablename);\n\t\treturn -1;\n\t}\n\twhile ((elm = va_arg(ap, char *))) {\n\t\ttype = va_arg(ap, require_type);\n\t\tsize = va_arg(ap, int);\n\t\tAST_LIST_TRAVERSE(&table->columns, column, list) {\n\t\t\tif (strcmp(column->name, elm) == 0) {\n\t\t\t\t\n\t\t\t\tif ((strncmp(column->type, \"char\", 4) == 0 || strncmp(column->type, \"varchar\", 7) == 0 || strcmp(column->type, \"bpchar\") == 0)) {\n\t\t\t\t\tif ((size > column->len) && column->len != -1) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Column '%s' should be at least %d long, but is only %d long.\\n\", column->name, size, column->len);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t} else if (strncmp(column->type, \"int\", 3) == 0) {\n\t\t\t\t\tint typesize = atoi(column->type + 3);\n\t\t\t\t\t\n\t\t\t\t\tif ((type == RQ_INTEGER8 || type == RQ_UINTEGER8 ||\n\t\t\t\t\t\ttype == RQ_INTEGER4 || type == RQ_UINTEGER4 ||\n\t\t\t\t\t\ttype == RQ_INTEGER3 || type == RQ_UINTEGER3 ||\n\t\t\t\t\t\ttype == RQ_UINTEGER2) && typesize == 2) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Column '%s' may not be large enough for the required data length: %d\\n\", column->name, size);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t} else if ((type == RQ_INTEGER8 || type == RQ_UINTEGER8 ||\n\t\t\t\t\t\ttype == RQ_UINTEGER4) && typesize == 4) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Column '%s' may not be large enough for the required data length: %d\\n\", column->name, size);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t} else if (type == RQ_CHAR || type == RQ_DATETIME || type == RQ_FLOAT || type == RQ_DATE) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Column '%s' is of the incorrect type: (need %s(%d) but saw %s)\\n\",\n\t\t\t\t\t\t\tcolumn->name,\n\t\t\t\t\t\t\t\ttype == RQ_CHAR ? \"char\" :\n\t\t\t\t\t\t\t\ttype == RQ_DATETIME ? \"datetime\" :\n\t\t\t\t\t\t\t\ttype == RQ_DATE ? \"date\" :\n\t\t\t\t\t\t\t\ttype == RQ_FLOAT ? \"float\" :\n\t\t\t\t\t\t\t\t\"a rather stiff drink \",\n\t\t\t\t\t\t\tsize, column->type);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t} else if (strncmp(column->type, \"float\", 5) == 0) {\n\t\t\t\t\tif (!ast_rq_is_int(type) && type != RQ_FLOAT) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Column %s cannot be a %s\\n\", column->name, column->type);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t} else if (strncmp(column->type, \"timestamp\", 9) == 0) {\n\t\t\t\t\tif (type != RQ_DATETIME && type != RQ_DATE) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Column %s cannot be a %s\\n\", column->name, column->type);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t} else { \n\t\t\t\t\tast_log(LOG_WARNING, \"Possibly unsupported column type '%s' on column '%s'\\n\", column->type, column->name);\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!column) {\n\t\t\tif (requirements == RQ_WARN) {\n\t\t\t\tast_log(LOG_WARNING, \"Table %s requires a column '%s' of size '%d', but no such column exists.\\n\", tablename, elm, size);\n\t\t\t\tres = -1;\n\t\t\t} else {\n\t\t\t\tstruct ast_str *sql = ast_str_create(100);\n\t\t\t\tchar fieldtype[15];\n\t\t\t\tPGresult *result;\n\t\t\t\tif (requirements == RQ_CREATECHAR || type == RQ_CHAR) {\n\t\t\t\t\t\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"CHAR(%hhu)\",\n\t\t\t\t\t\tsize < 15 ? size * 2 :\n\t\t\t\t\t\t(size * 3 / 2 > 255) ? 255 : size * 3 / 2);\n\t\t\t\t} else if (type == RQ_INTEGER1 || type == RQ_UINTEGER1 || type == RQ_INTEGER2) {\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"INT2\");\n\t\t\t\t} else if (type == RQ_UINTEGER2 || type == RQ_INTEGER3 || type == RQ_UINTEGER3 || type == RQ_INTEGER4) {\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"INT4\");\n\t\t\t\t} else if (type == RQ_UINTEGER4 || type == RQ_INTEGER8) {\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"INT8\");\n\t\t\t\t} else if (type == RQ_UINTEGER8) {\n\t\t\t\t\t\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"CHAR(20)\");\n\t\t\t\t} else if (type == RQ_FLOAT) {\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"FLOAT8\");\n\t\t\t\t} else if (type == RQ_DATE) {\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"DATE\");\n\t\t\t\t} else if (type == RQ_DATETIME) {\n\t\t\t\t\tsnprintf(fieldtype, sizeof(fieldtype), \"TIMESTAMP\");\n\t\t\t\t} else {\n\t\t\t\t\tast_log(LOG_ERROR, \"Unrecognized request type %d\\n\", type);\n\t\t\t\t\tast_free(sql);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tast_str_set(&sql, 0, \"ALTER TABLE %s ADD COLUMN %s %s\", tablename, elm, fieldtype);\n\t\t\t\tast_debug(1, \"About to lock pgsql_lock (running alter on table '%s' to add column '%s')\\n\", tablename, elm);\n\t\t\t\tast_mutex_lock(&pgsql_lock);\n\t\t\t\tast_debug(1, \"About to run ALTER query on table '%s' to add column '%s'\\n\", tablename, elm);\n\t\t\t        if (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {\n\t\t\t\t\tast_mutex_unlock(&pgsql_lock);\n\t\t\t\t\trelease_table(table);\n\t\t\t\t        return -1;\n\t\t\t        }\n\t\t\t\tast_debug(1, \"Finished running ALTER query on table '%s'\\n\", tablename);\n\t\t\t\tif (PQresultStatus(result) != PGRES_COMMAND_OK) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Unable to add column: %s\\n\", ast_str_buffer(sql));\n\t\t\t\t}\n\t\t\t\tPQclear(result);\n\t\t\t\tast_mutex_unlock(&pgsql_lock);\n\t\t\t\tast_free(sql);\n\t\t\t}\n\t\t}\n\t}\n\trelease_table(table);\n\treturn res;\n}\n", "bug_type": null, "idx": 866}
{"project": "Asterisk", "target": 0, "func": "struct ast_websocket_protocol *AST_OPTIONAL_API_NAME(ast_websocket_sub_protocol_alloc)(const char *name)\n{\n\tstruct ast_websocket_protocol *protocol;\n\tprotocol = ao2_alloc(sizeof(*protocol), protocol_destroy_fn);\n\tif (!protocol) {\n\t\treturn NULL;\n\t}\n\tprotocol->name = ast_strdup(name);\n\tif (!protocol->name) {\n\t\tao2_ref(protocol, -1);\n\t\treturn NULL;\n\t}\n\tprotocol->version = AST_WEBSOCKET_PROTOCOL_VERSION;\n\treturn protocol;\n}\n", "bug_type": null, "idx": 867}
{"project": "Asterisk", "target": 0, "func": "int ooHandleStartH245FacilityMessage\n   (OOH323CallData *call, H225Facility_UUIE *facility)\n{\n   H225TransportAddress_ipAddress *ipAddress = NULL;\n   H225TransportAddress_ip6Address *ip6Address = NULL;\n   int ret;\n   \n   if(!facility->m.h245AddressPresent)\n   {\n      OOTRACEERR3(\"ERROR: startH245 facility message received with no h245 \"\n                  \"address (%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   if (call->versionIP == 6) {\n    if(facility->h245Address.t != T_H225TransportAddress_ip6Address)\n    {\n      OOTRACEERR3(\"ERROR:Unknown H245 address type in received startH245 \"\n               \"facility message (%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n    }\n    ip6Address = facility->h245Address.u.ip6Address;\n    if(!ip6Address)\n    {\n      OOTRACEERR3(\"ERROR:Invalid startH245 facility message. No H245 ip6 \"\n                  \"address found. (%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n    }\n    inet_ntop(AF_INET6, ip6Address->ip.data, call->remoteIP, INET6_ADDRSTRLEN);\n    call->remoteH245Port = ip6Address->port;\n   } else {\n    if(facility->h245Address.t != T_H225TransportAddress_ipAddress)\n    {\n      OOTRACEERR3(\"ERROR:Unknown H245 address type in received startH245 \"\n               \"facility message (%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n    }\n    ipAddress = facility->h245Address.u.ipAddress;\n    if(!ipAddress)\n    {\n      OOTRACEERR3(\"ERROR:Invalid startH245 facility message. No H245 ip \"\n                  \"address found. (%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n    }\n    sprintf(call->remoteIP, \"%d.%d.%d.%d\", ipAddress->ip.data[0],\n                                          ipAddress->ip.data[1],\n                                          ipAddress->ip.data[2],\n                                          ipAddress->ip.data[3]);\n    call->remoteH245Port = ipAddress->port;\n   }\n   \n   OO_CLRFLAG (call->flags, OO_M_TUNNELING);\n   \n   if (!call->pH245Channel) {\n    ret = ooCreateH245Connection(call);\n    if(ret != OO_OK)\n    {\n      OOTRACEERR3(\"ERROR: Failed to establish an H.245 connection with remote\"\n                  \" endpoint (%s, %s)\\n\", call->callType, call->callToken);\n      return ret;\n    }\n   } else {\n     OOTRACEINFO3(\"INFO: H.245 connection already established with remote\"\n                  \" endpoint (%s, %s)\\n\", call->callType, call->callToken);\n   }\n   ooSendTCSandMSD(call);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 868}
{"project": "Asterisk", "target": 0, "func": "void ast_dial_set_state_callback(struct ast_dial *dial, ast_dial_state_callback callback)\n{\n\tdial->state_callback = callback;\n}\n", "bug_type": null, "idx": 869}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tCHECK_PJSIP_SESSION_MODULE_LOADED();\n\tast_sip_session_register_supplement(&header_funcs_supplement);\n\tast_custom_function_register(&pjsip_header_function);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 870}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int load_module(void)\n{\n\tstruct ast_config *cfg = NULL;\n\tchar *ctg = NULL;\n\tstruct ast_flags config_flags = { 0 };\n\t\n\tmemcpy(&global_jbconf, &default_jbconf, sizeof(struct ast_jb_conf));\n\t\n\tif (!(cfg = ast_config_load(config, config_flags))) {\n\t\tast_log(LOG_NOTICE, \"Unable to load config %s\\n\", config);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Config file %s is in an invalid format.  Aborting.\\n\", config);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tdo {\n\t\tstore_config(cfg, ctg);\n\t} while ( (ctg = ast_category_browse(cfg, ctg)) != NULL);\n\tast_config_destroy(cfg);\n\tif (find_desc(oss_active) == NULL) {\n\t\tast_log(LOG_NOTICE, \"Device %s not found\\n\", oss_active);\n\t\t\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (!(oss_tech.capabilities = ast_format_cap_alloc(0))) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_format_cap_append(oss_tech.capabilities, ast_format_slin, 0);\n\t\n\tif (ast_channel_register(&oss_tech)) {\n\t\tast_log(LOG_ERROR, \"Unable to register channel type 'OSS'\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_cli_register_multiple(cli_oss, ARRAY_LEN(cli_oss));\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 871}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int parking_blind_transfer_park(struct ast_bridge_channel *bridge_channel,\n\t\tconst char *context, const char *exten, transfer_channel_cb parked_channel_cb,\n\t\tstruct transfer_channel_data *parked_channel_data)\n{\n\tRAII_VAR(struct ast_bridge_channel *, other, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_channel *, other_chan, NULL, ast_channel_cleanup);\n\tstruct ast_exten *e;\n\tstruct pbx_find_info find_info = { .stacklen = 0 };\n\tint peer_count;\n\tif (ast_strlen_zero(context) || ast_strlen_zero(exten)) {\n\t\treturn -1;\n\t}\n\tif (!bridge_channel->in_bridge) {\n\t\treturn -1;\n\t}\n\tif (!parking_is_exten_park(context, exten)) {\n\t\treturn -1;\n\t}\n\tast_bridge_channel_lock_bridge(bridge_channel);\n\tpeer_count = bridge_channel->bridge->num_channels;\n\tif (peer_count == 2) {\n\t\tother = ast_bridge_channel_peer(bridge_channel);\n\t\tao2_ref(other, +1);\n\t\tother_chan = other->chan;\n\t\tast_channel_ref(other_chan);\n\t}\n\tast_bridge_unlock(bridge_channel->bridge);\n\tif (peer_count < 2) {\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tif (peer_count > 2) {\n\t\tstruct ast_channel *transfer_chan = NULL;\n\t\ttransfer_chan = park_local_transfer(bridge_channel->chan, context, exten, parked_channel_data);\n\t\tif (!transfer_chan) {\n\t\t\treturn -1;\n\t\t}\n\t\tast_channel_ref(transfer_chan);\n\t\tif (parked_channel_cb) {\n\t\t\tparked_channel_cb(transfer_chan, parked_channel_data, AST_BRIDGE_TRANSFER_MULTI_PARTY);\n\t\t}\n\t\tif (ast_bridge_impart(bridge_channel->bridge, transfer_chan, NULL, NULL,\n\t\t\tAST_BRIDGE_IMPART_CHAN_INDEPENDENT)) {\n\t\t\tast_hangup(transfer_chan);\n\t\t\tast_channel_unref(transfer_chan);\n\t\t\treturn -1;\n\t\t}\n\t\tast_channel_unref(transfer_chan);\n\t\treturn 0;\n\t}\n\t\n\tif (create_parked_subscription_full(bridge_channel->chan, ast_channel_uniqueid(other->chan), 1, parked_channel_data)) {\n\t\treturn -1;\n\t}\n\tif (parked_channel_cb) {\n\t\tparked_channel_cb(other_chan, parked_channel_data, AST_BRIDGE_TRANSFER_SINGLE_PARTY);\n\t}\n\te = pbx_find_extension(NULL, NULL, &find_info, context, exten, 1, NULL, NULL, E_MATCH);\n\t\n\tast_bridge_channel_write_park(bridge_channel,\n\t\tast_channel_uniqueid(other_chan),\n\t\tast_channel_uniqueid(bridge_channel->chan),\n\t\te ? ast_get_extension_app_data(e) : NULL);\n\treturn 0;\n}\n", "bug_type": null, "idx": 872}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum notify_result push_notify(const char *endpoint_name, void *info,\n\t\t\t\t      task_data_create data_create)\n{\n\tRAII_VAR(struct ast_sip_endpoint *, endpoint, NULL, ao2_cleanup);\n\tstruct notify_data *data;\n\tif (!(endpoint = ast_sorcery_retrieve_by_id(\n\t\t      ast_sip_get_sorcery(), \"endpoint\", endpoint_name))) {\n\t\treturn INVALID_ENDPOINT;\n\t}\n\tif (!(data = data_create(endpoint, info))) {\n\t\treturn ALLOC_ERROR;\n\t}\n\tif (ast_sip_push_task(NULL, notify_endpoint, data)) {\n\t\tao2_cleanup(data);\n\t\treturn TASK_PUSH_ERROR;\n\t}\n\treturn SUCCESS;\n}\n", "bug_type": null, "idx": 873}
{"project": "Asterisk", "target": 0, "func": "int ooAcceptH245Connection(OOH323CallData *call)\n{\n   int ret;\n   OOSOCKET h245Channel=0;\n   ret = ooSocketAccept (*(call->h245listener), &h245Channel, \n                         NULL, NULL);\n   if(ret != ASN_OK)\n   {\n      OOTRACEERR1(\"Error:Accepting h245 connection\\n\");\n      return OO_FAILED;\n   }\n   if (0 == call->pH245Channel) {\n      call->pH245Channel = \n         (OOH323Channel*) memAllocZ (call->pctxt, sizeof(OOH323Channel));\n   }\n   call->pH245Channel->sock = h245Channel; \n   call->h245SessionState = OO_H245SESSION_ACTIVE;\n   OOTRACEINFO3(\"H.245 connection established (%s, %s)\\n\", \n                call->callType, call->callToken);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 874}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_recordings_copy_stored_parse_body(\n\tstruct ast_json *body,\n\tstruct ast_ari_recordings_copy_stored_args *args)\n{\n\tstruct ast_json *field;\n\t\n\tfield = ast_json_object_get(body, \"destinationRecordingName\");\n\tif (field) {\n\t\targs->destination_recording_name = ast_json_string_get(field);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 875}
{"project": "Asterisk", "target": 0, "func": "static int feature_callback(struct ast_bridge_channel *bridge_channel, void *obj)\n{\n\tint *callback_executed = obj;\n\t(*callback_executed)++;\n\treturn 0;\n}\n", "bug_type": null, "idx": 876}
{"project": "Asterisk", "target": 0, "func": "\nstatic void snoop_determine_format(struct ast_channel *chan, struct stasis_app_snoop *snoop)\n{\n\tSCOPED_CHANNELLOCK(lock, chan);\n\tunsigned int rate = MAX(ast_format_get_sample_rate(ast_channel_rawwriteformat(chan)),\n\t\tast_format_get_sample_rate(ast_channel_rawreadformat(chan)));\n\tsnoop->spy_format = ast_format_cache_get_slin_by_rate(rate);\n}\n", "bug_type": null, "idx": 877}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_fax_session_details *find_details(struct ast_channel *chan)\n{\n\tstruct ast_fax_session_details *details;\n\tstruct ast_datastore *datastore;\n\tast_channel_lock(chan);\n\tif (!(datastore = ast_channel_datastore_find(chan, &fax_datastore, NULL))) {\n\t\tast_channel_unlock(chan);\n\t\treturn NULL;\n\t}\n\tif (!(details = datastore->data)) {\n\t\tast_log(LOG_WARNING, \"Huh?  channel '%s' has a FAX datastore without data!\\n\", ast_channel_name(chan));\n\t\tast_channel_unlock(chan);\n\t\treturn NULL;\n\t}\n\tao2_ref(details, 1);\n\tast_channel_unlock(chan);\n\treturn details;\n}\n", "bug_type": null, "idx": 878}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int thread_inhibits_escalations(void)\n{\n\tint *thread_inhibit_escalations;\n\tthread_inhibit_escalations = ast_threadstorage_get(\n\t\t&thread_inhibit_escalations_tl, sizeof(*thread_inhibit_escalations));\n\tif (thread_inhibit_escalations == NULL) {\n\t\tast_log(LOG_ERROR, \"Error checking thread's ability to run dangerous functions\\n\");\n\t\t\n\t\treturn 1;\n\t}\n\treturn *thread_inhibit_escalations;\n}\n", "bug_type": null, "idx": 879}
{"project": "Asterisk", "target": 0, "func": "\nstatic enum ast_device_state meetmestate(const char *data)\n{\n\tstruct ast_conference *conf;\n\t\n\tAST_LIST_LOCK(&confs);\n\tAST_LIST_TRAVERSE(&confs, conf, list) {\n\t\tif (!strcmp(data, conf->confno))\n\t\t\tbreak;\n\t}\n\tAST_LIST_UNLOCK(&confs);\n\tif (!conf)\n\t\treturn AST_DEVICE_INVALID;\n\t\n\tif (!conf->users)\n\t\treturn AST_DEVICE_NOT_INUSE;\n\treturn AST_DEVICE_INUSE;\n}\n", "bug_type": null, "idx": 880}
{"project": "Asterisk", "target": 0, "func": "struct stasis_cache *ast_channel_cache(void)\n{\n\treturn stasis_cp_all_cache(channel_cache_all);\n}\n", "bug_type": null, "idx": 881}
{"project": "Asterisk", "target": 0, "func": "static struct sdp_state_stream *sdp_state_get_stream(const struct ast_sdp_state *sdp_state, int stream_index)\n{\n\tif (stream_index >= AST_VECTOR_SIZE(&sdp_state->proposed_capabilities->streams)) {\n\t\treturn NULL;\n\t}\n\treturn AST_VECTOR_GET(&sdp_state->proposed_capabilities->streams, stream_index);\n}\n", "bug_type": null, "idx": 882}
{"project": "Asterisk", "target": 0, "func": "static int devstate_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tsize_t len = strlen(\"Custom:\");\n\tenum ast_device_state state_val;\n\tif (strncasecmp(data, \"Custom:\", len)) {\n\t\tast_log(LOG_WARNING, \"The DEVICE_STATE function can only be used to set 'Custom:' device state!\\n\");\n\t\treturn -1;\n\t}\n\tdata += len;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"DEVICE_STATE function called with no custom device name!\\n\");\n\t\treturn -1;\n\t}\n\tstate_val = ast_devstate_val(value);\n\tif (state_val == AST_DEVICE_UNKNOWN) {\n\t\tast_log(LOG_ERROR, \"DEVICE_STATE function given invalid state value '%s'\\n\", value);\n\t\treturn -1;\n\t}\n\tast_db_put(astdb_family, data, value);\n\tast_devstate_changed(state_val, AST_DEVSTATE_CACHABLE, \"Custom:%s\", data);\n\treturn 0;\n}\n", "bug_type": null, "idx": 883}
{"project": "Asterisk", "target": 0, "func": "\nstatic void codec_pref_remove(struct iax2_codec_pref *pref, int format_index)\n{\n\tint x;\n\tif (!pref->order[0]) {\n\t\treturn;\n\t}\n\tfor (x = 0; x < ARRAY_LEN(pref->order); ++x) {\n\t\tif (!pref->order[x]) {\n\t\t\tbreak;\n\t\t}\n\t\tif (pref->order[x] == format_index) {\n\t\t\tcodec_pref_remove_index(pref, x);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 884}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_misdn_show_ports_stats(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint port;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"misdn show ports stats\";\n\t\te->usage =\n\t\t\t\"Usage: misdn show ports stats\\n\"\n\t\t\t\"       Show mISDNs channel's call statistics per port.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_cli(a->fd, \"Port\\tin_calls\\tout_calls\\n\");\n\tfor (port = misdn_cfg_get_next_port(0); port > 0;\n\t\tport = misdn_cfg_get_next_port(port)) {\n\t\tast_cli(a->fd, \"%d\\t%d\\t\\t%d\\n\", port, misdn_in_calls[port], misdn_out_calls[port]);\n\t}\n\tast_cli(a->fd, \"\\n\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 885}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(create);\n\tAST_TEST_UNREGISTER(defaults);\n\tAST_TEST_UNREGISTER(setters);\n\treturn 0;\n}\n", "bug_type": null, "idx": 886}
{"project": "Asterisk", "target": 0, "func": "int app_is_active(struct stasis_app *app)\n{\n\tSCOPED_AO2LOCK(lock, app);\n\treturn app->handler != NULL;\n}\n", "bug_type": null, "idx": 887}
{"project": "Asterisk", "target": 0, "func": "static void *unref_ewscal(void *obj)\n{\n\tstruct ewscal_pvt *pvt = obj;\n\tast_debug(5, \"EWS: unref_ewscal()\\n\");\n\tao2_ref(pvt, -1);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 888}
{"project": "Asterisk", "target": 0, "func": "int ast_get_txt(struct ast_channel *chan, const char *number, char *txt, int txtlen, char *suffix)\n{\n\tstruct txt_context context;\n\tchar tmp[259 + 512];\n\tint pos = strlen(number) - 1;\n\tint newpos = 0;\n\tint ret = -1;\n\tast_debug(4, \"ast_get_txt: Number = '%s', suffix = '%s'\\n\", number, suffix);\n\tif (chan && ast_autoservice_start(chan) < 0) {\n\t\treturn -1;\n\t}\n\tif (pos > 128) {\n\t\tpos = 128;\n\t}\n\twhile (pos >= 0) {\n\t\tif (isdigit(number[pos])) {\n\t\t\ttmp[newpos++] = number[pos];\n\t\t\ttmp[newpos++] = '.';\n\t\t}\n\t\tpos--;\n\t}\n\tast_copy_string(&tmp[newpos], suffix, sizeof(tmp) - newpos);\n\tif (ret < 0) {\n\t\tast_debug(2, \"No such number found in ENUM: %s (%s)\\n\", tmp, strerror(errno));\n\t\tret = 0;\n\t} else {\n\t\tast_copy_string(txt, context.txt, txtlen);\n\t}\n\tif (chan) {\n\t\tret |= ast_autoservice_stop(chan);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 889}
{"project": "Asterisk", "target": 0, "func": "static void transfer_target_framehook_destroy_cb(void *data)\n{\n\tstruct attended_transfer_properties *props = data;\n\tao2_cleanup(props);\n}\n", "bug_type": null, "idx": 890}
{"project": "Asterisk", "target": 0, "func": "int __ast_pthread_mutex_lock(const char *filename, int lineno, const char *func,\n\t\t\t\tconst char* mutex_name, ast_mutex_t *t)\n{\n\tint res;\n#ifdef DEBUG_THREADS\n\tstruct ast_lock_track *lt = NULL;\n\tint canlog = t->tracking && strcmp(filename, \"logger.c\");\n#ifdef HAVE_BKTR\n\tstruct ast_bt *bt = NULL;\n#endif\n\tif (t->tracking) {\n\t\tlt = ast_get_reentrancy(&t->track);\n\t}\n\tif (lt) {\n#ifdef HAVE_BKTR\n\t\tstruct ast_bt tmp;\n\t\t\n\t\tast_bt_get_addresses(&tmp);\n\t\tast_reentrancy_lock(lt);\n\t\tif (lt->reentrancy < AST_MAX_REENTRANCY) {\n\t\t\tlt->backtrace[lt->reentrancy] = tmp;\n\t\t\tbt = &lt->backtrace[lt->reentrancy];\n\t\t}\n\t\tast_reentrancy_unlock(lt);\n\t\tast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t, bt);\n#else\n\t\tast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t);\n#endif\n\t}\n#endif \n#if defined(DETECT_DEADLOCKS) && defined(DEBUG_THREADS)\n\t{\n\t\ttime_t seconds = time(NULL);\n\t\ttime_t wait_time, reported_wait = 0;\n\t\tdo {\n#ifdef\tHAVE_MTX_PROFILE\n\t\t\tast_mark(mtx_prof, 1);\n#endif\n\t\t\tres = pthread_mutex_trylock(&t->mutex);\n#ifdef\tHAVE_MTX_PROFILE\n\t\t\tast_mark(mtx_prof, 0);\n#endif\n\t\t\tif (res == EBUSY) {\n\t\t\t\twait_time = time(NULL) - seconds;\n\t\t\t\tif (wait_time > reported_wait && (wait_time % 5) == 0) {\n\t\t\t\t\t__ast_mutex_logger(\"%s line %d (%s): Deadlock? waited %d sec for mutex '%s'?\\n\",\n\t\t\t\t\t\t\t   filename, lineno, func, (int) wait_time, mutex_name);\n\t\t\t\t\tif (lt) {\n\t\t\t\t\t\tast_reentrancy_lock(lt);\n#ifdef HAVE_BKTR\n\t\t\t\t\t\t__dump_backtrace(&lt->backtrace[lt->reentrancy], canlog);\n#endif\n\t\t\t\t\t\t__ast_mutex_logger(\"%s line %d (%s): '%s' was locked here.\\n\",\n\t\t\t\t\t\t\t\t   lt->file[ROFFSET], lt->lineno[ROFFSET],\n\t\t\t\t\t\t\t\t   lt->func[ROFFSET], mutex_name);\n#ifdef HAVE_BKTR\n\t\t\t\t\t\t__dump_backtrace(&lt->backtrace[ROFFSET], canlog);\n#endif\n\t\t\t\t\t\tast_reentrancy_unlock(lt);\n\t\t\t\t\t}\n\t\t\t\t\treported_wait = wait_time;\n\t\t\t\t}\n\t\t\t\tusleep(200);\n\t\t\t}\n\t\t} while (res == EBUSY);\n\t}\n#else \n#ifdef\tHAVE_MTX_PROFILE\n\tast_mark(mtx_prof, 1);\n\tres = pthread_mutex_trylock(&t->mutex);\n\tast_mark(mtx_prof, 0);\n\tif (res)\n#endif\n\tres = pthread_mutex_lock(&t->mutex);\n#endif \n#ifdef DEBUG_THREADS\n\tif (lt && !res) {\n\t\tast_reentrancy_lock(lt);\n\t\tif (lt->reentrancy < AST_MAX_REENTRANCY) {\n\t\t\tlt->file[lt->reentrancy] = filename;\n\t\t\tlt->lineno[lt->reentrancy] = lineno;\n\t\t\tlt->func[lt->reentrancy] = func;\n\t\t\tlt->thread_id[lt->reentrancy] = pthread_self();\n\t\t\tlt->reentrancy++;\n\t\t} else {\n\t\t\t__ast_mutex_logger(\"%s line %d (%s): '%s' really deep reentrancy!\\n\",\n\t\t\t\t\t\t\t   filename, lineno, func, mutex_name);\n\t\t}\n\t\tast_reentrancy_unlock(lt);\n\t\tast_mark_lock_acquired(t);\n\t} else if (lt) {\n#ifdef HAVE_BKTR\n\t\tif (lt->reentrancy) {\n\t\t\tast_reentrancy_lock(lt);\n\t\t\tbt = &lt->backtrace[lt->reentrancy-1];\n\t\t\tast_reentrancy_unlock(lt);\n\t\t} else {\n\t\t\tbt = NULL;\n\t\t}\n\t\tast_remove_lock_info(t, bt);\n#else\n\t\tast_remove_lock_info(t);\n#endif\n\t}\n\tif (res) {\n\t\t__ast_mutex_logger(\"%s line %d (%s): Error obtaining mutex: %s\\n\",\n\t\t\t\t   filename, lineno, func, strerror(res));\n\t\tDO_THREAD_CRASH;\n\t}\n#endif \n\treturn res;\n}\n", "bug_type": null, "idx": 891}
{"project": "Asterisk", "target": 0, "func": "\nstatic char *dahdi_show_status(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\t#define FORMAT \"%-40.40s %-7.7s %-6d %-6d %-6d %-3.3s %-4.4s %-8.8s %s\\n\"\n\t#define FORMAT2 \"%-40.40s %-7.7s %-6.6s %-6.6s %-6.6s %-3.3s %-4.4s %-8.8s %s\\n\"\n\tint span;\n\tint res;\n\tchar alarmstr[50];\n\tint ctl;\n\tstruct dahdi_spaninfo s;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"dahdi show status\";\n\t\te->usage =\n\t\t\t\"Usage: dahdi show status\\n\"\n\t\t\t\"       Shows a list of DAHDI cards with status\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tctl = open(\"/dev/dahdi/ctl\", O_RDWR);\n\tif (ctl < 0) {\n\t\tast_cli(a->fd, \"No DAHDI found. Unable to open /dev/dahdi/ctl: %s\\n\", strerror(errno));\n\t\treturn CLI_FAILURE;\n\t}\n\tast_cli(a->fd, FORMAT2, \"Description\", \"Alarms\", \"IRQ\", \"bpviol\", \"CRC\", \"Framing\", \"Coding\", \"Options\", \"LBO\");\n\tfor (span = 1; span < DAHDI_MAX_SPANS; ++span) {\n\t\ts.spanno = span;\n\t\tres = ioctl(ctl, DAHDI_SPANSTAT, &s);\n\t\tif (res) {\n\t\t\tcontinue;\n\t\t}\n\t\talarmstr[0] = '\\0';\n\t\tif (s.alarms > 0) {\n\t\t\tif (s.alarms & DAHDI_ALARM_BLUE)\n\t\t\t\tstrcat(alarmstr, \"BLU/\");\n\t\t\tif (s.alarms & DAHDI_ALARM_YELLOW)\n\t\t\t\tstrcat(alarmstr, \"YEL/\");\n\t\t\tif (s.alarms & DAHDI_ALARM_RED)\n\t\t\t\tstrcat(alarmstr, \"RED/\");\n\t\t\tif (s.alarms & DAHDI_ALARM_LOOPBACK)\n\t\t\t\tstrcat(alarmstr, \"LB/\");\n\t\t\tif (s.alarms & DAHDI_ALARM_RECOVER)\n\t\t\t\tstrcat(alarmstr, \"REC/\");\n\t\t\tif (s.alarms & DAHDI_ALARM_NOTOPEN)\n\t\t\t\tstrcat(alarmstr, \"NOP/\");\n\t\t\tif (!strlen(alarmstr))\n\t\t\t\tstrcat(alarmstr, \"UUU/\");\n\t\t\tif (strlen(alarmstr)) {\n\t\t\t\t\n\t\t\t\talarmstr[strlen(alarmstr) - 1] = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tif (s.numchans)\n\t\t\t\tstrcpy(alarmstr, \"OK\");\n\t\t\telse\n\t\t\t\tstrcpy(alarmstr, \"UNCONFIGURED\");\n\t\t}\n\t\tast_cli(a->fd, FORMAT, s.desc, alarmstr, s.irqmisses, s.bpvcount, s.crc4count,\n\t\t\ts.lineconfig & DAHDI_CONFIG_D4 ? \"D4\" :\n\t\t\ts.lineconfig & DAHDI_CONFIG_ESF ? \"ESF\" :\n\t\t\ts.lineconfig & DAHDI_CONFIG_CCS ? \"CCS\" :\n\t\t\t\"CAS\",\n\t\t\ts.lineconfig & DAHDI_CONFIG_B8ZS ? \"B8ZS\" :\n\t\t\ts.lineconfig & DAHDI_CONFIG_HDB3 ? \"HDB3\" :\n\t\t\ts.lineconfig & DAHDI_CONFIG_AMI ? \"AMI\" :\n\t\t\t\"Unk\",\n\t\t\ts.lineconfig & DAHDI_CONFIG_CRC4 ?\n\t\t\t\ts.lineconfig & DAHDI_CONFIG_NOTOPEN ? \"CRC4/YEL\" : \"CRC4\" :\n\t\t\t\ts.lineconfig & DAHDI_CONFIG_NOTOPEN ? \"YEL\" : \"\",\n\t\t\tlbostr[s.lbo]\n\t\t\t);\n\t}\n\tclose(ctl);\n\treturn CLI_SUCCESS;\n#undef FORMAT\n#undef FORMAT2\n}\n", "bug_type": null, "idx": 892}
{"project": "Asterisk", "target": 0, "func": "\nstatic char *cli_fax_show_stats(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct fax_module *fax;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"fax show stats\";\n\t\te->usage =\n\t\t\t\"Usage: fax show stats\\n\"\n\t\t\t\"       Shows a statistical summary of FAX transmissions\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tast_cli(a->fd, \"\\nFAX Statistics:\\n---------------\\n\\n\");\n\tast_cli(a->fd, \"%-20.20s : %d\\n\", \"Current Sessions\", faxregistry.active_sessions);\n\tast_cli(a->fd, \"%-20.20s : %d\\n\", \"Reserved Sessions\", faxregistry.reserved_sessions);\n\tast_cli(a->fd, \"%-20.20s : %d\\n\", \"Transmit Attempts\", faxregistry.fax_tx_attempts);\n\tast_cli(a->fd, \"%-20.20s : %d\\n\", \"Receive Attempts\", faxregistry.fax_rx_attempts);\n\tast_cli(a->fd, \"%-20.20s : %d\\n\", \"Completed FAXes\", faxregistry.fax_complete);\n\tast_cli(a->fd, \"%-20.20s : %d\\n\", \"Failed FAXes\", faxregistry.fax_failures);\n\tAST_RWLIST_RDLOCK(&faxmodules);\n\tAST_RWLIST_TRAVERSE(&faxmodules, fax, list) {\n\t\tfax->tech->cli_show_stats(a->fd);\n\t}\n\tAST_RWLIST_UNLOCK(&faxmodules);\n\tast_cli(a->fd, \"\\n\\n\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 893}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function enum_function = {\n\t.name = \"ENUMLOOKUP\",\n\t.read = function_enum,\n};\n", "bug_type": null, "idx": 894}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245RSVPParameters (OOCTXT* pctxt, H245RSVPParameters* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.qosModePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.tokenRatePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.bucketSizePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.peakRatePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.minPolicedPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.maxPktSizePresent);\n   \n   if (pvalue->m.qosModePresent) {\n      stat = asn1PE_H245QOSMode (pctxt, &pvalue->qosMode);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.tokenRatePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->tokenRate, 1U, ASN1UINT_MAX);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.bucketSizePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->bucketSize, 1U, ASN1UINT_MAX);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.peakRatePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->peakRate, 1U, ASN1UINT_MAX);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.minPolicedPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->minPoliced, 1U, ASN1UINT_MAX);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.maxPktSizePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->maxPktSize, 1U, ASN1UINT_MAX);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 895}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int gsm_samples(struct ast_frame *frame)\n{\n\treturn 160 * (frame->datalen / 33);\n}\n", "bug_type": null, "idx": 896}
{"project": "Asterisk", "target": 0, "func": "struct stasis_caching_topic *stasis_caching_unsubscribe_and_join(struct stasis_caching_topic *caching_topic)\n{\n\tif (!caching_topic) {\n\t\treturn NULL;\n\t}\n\t\n\tao2_ref(caching_topic, +1);\n\tstasis_caching_unsubscribe(caching_topic);\n\tstasis_subscription_join(caching_topic->sub);\n\tao2_cleanup(caching_topic);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 897}
{"project": "Asterisk", "target": 0, "func": "static int group_function_write(struct ast_channel *chan, const char *cmd,\n\t\t\t\tchar *data, const char *value)\n{\n\tchar grpcat[256];\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\tif (!value) {\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(data)) {\n\t\tsnprintf(grpcat, sizeof(grpcat), \"%s@%s\", value, data);\n\t} else {\n\t\tast_copy_string(grpcat, value, sizeof(grpcat));\n\t}\n\tif (ast_app_group_set_channel(chan, grpcat))\n\t\tast_log(LOG_WARNING,\n\t\t\t\t\"Setting a group requires an argument (group name)\\n\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 898}
{"project": "Asterisk", "target": 0, "func": "int ooGkClientGRQTimerExpired(void* pdata)\n{\n   int ret=0;\n   ooGkClientTimerCb *cbData = (ooGkClientTimerCb*)pdata;\n   ooGkClient *pGkClient = cbData->pGkClient;\n   OOTRACEDBGA1(\"Gatekeeper client GRQ timer expired.\\n\");\n   memFreePtr(&pGkClient->ctxt, cbData);   \n   if(pGkClient->grqRetries < OO_MAX_GRQ_RETRIES)\n   {\n      ret = ooGkClientSendGRQ(pGkClient);      \n      if(ret != OO_OK)\n      {\n         OOTRACEERR1(\"Error:Failed to send GRQ message\\n\");\n         pGkClient->state = GkClientFailed;\n         return OO_FAILED;\n      }\n      pGkClient->grqRetries++;\n      return OO_OK;\n   }\n   OOTRACEERR1(\"Error:Gatekeeper could not be found\\n\");\n   pGkClient->state = GkClientUnregistered;\n\n   ast_mutex_lock(&pGkClient->Lock);\n   cbData = (ooGkClientTimerCb*) memAlloc\n                               (&pGkClient->ctxt, sizeof(ooGkClientTimerCb));\n   if(!cbData)\n   {\n      OOTRACEERR1(\"Error:Failed to allocate memory to GRQ timer callback\\n\");\n      pGkClient->state = GkClientFailed;\n      ast_mutex_unlock(&pGkClient->Lock);\n      return OO_FAILED;\n   }\n   cbData->timerType = OO_GRQ_TIMER;\n   cbData->pGkClient = pGkClient;\n   if(!ooTimerCreate(&pGkClient->ctxt, &pGkClient->timerList,\n                     &ooGkClientGRQTimerExpired, pGkClient->grqTimeout,\n                     cbData, FALSE))\n   {\n      OOTRACEERR1(\"Error:Unable to create GRQ timer.\\n \");\n      memFreePtr(&pGkClient->ctxt, cbData);\n      pGkClient->state = GkClientFailed;\n      ast_mutex_unlock(&pGkClient->Lock);\n      return OO_FAILED;\n   }\n\n   pGkClient->grqRetries = 0;\n   ast_mutex_unlock(&pGkClient->Lock);\n   return OO_FAILED;\n}\n", "bug_type": null, "idx": 899}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int set_config(char *config_file, struct sockaddr_in* sin, int reload)\n{\n\tstruct ast_config *cfg;\n\tstruct ast_variable *v;\n\tchar *cat;\n\tint x;\n\tstruct ast_flags config_flags = { 0 };\n\tchar hn[MAXHOSTNAMELEN] = \"\";\n\tstruct ast_hostent he;\n\tstruct hostent *hp;\n\tstruct sockaddr_in sin2;\n\tstatic int last_port = 0;\n\tint globalpcmodel = 0;\n\tdundi_eid testeid;\n\tif (!(cfg = ast_config_load(config_file, config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Unable to load config %s\\n\", config_file);\n\t\treturn -1;\n\t}\n\tdundi_ttl = DUNDI_DEFAULT_TTL;\n\tdundi_cache_time = DUNDI_DEFAULT_CACHE_TIME;\n\tany_peer = NULL;\n\tipaddr[0] = '\\0';\n\tif (!gethostname(hn, sizeof(hn)-1)) {\n\t\thp = ast_gethostbyname(hn, &he);\n\t\tif (hp) {\n\t\t\tmemcpy(&sin2.sin_addr, hp->h_addr, sizeof(sin2.sin_addr));\n\t\t\tast_copy_string(ipaddr, ast_inet_ntoa(sin2.sin_addr), sizeof(ipaddr));\n\t\t} else\n\t\t\tast_log(LOG_WARNING, \"Unable to look up host '%s'\\n\", hn);\n\t} else\n\t\tast_log(LOG_WARNING, \"Unable to get host name!\\n\");\n\tAST_LIST_LOCK(&peers);\n\tif (ast_eid_is_empty(&ast_eid_default)) {\n\t\tast_log(LOG_WARNING, \"Entity ID is not set.\\n\");\n\t}\n\tmemcpy(&global_eid, &ast_eid_default, sizeof(global_eid));\n\tglobal_storehistory = 0;\n\tast_copy_string(secretpath, \"dundi\", sizeof(secretpath));\n\tv = ast_variable_browse(cfg, \"general\");\n\twhile(v) {\n\t\tif (!strcasecmp(v->name, \"port\")){\n\t\t\tsin->sin_port = htons(atoi(v->value));\n\t\t\tif(last_port==0){\n\t\t\t\tlast_port=sin->sin_port;\n\t\t\t} else if(sin->sin_port != last_port)\n\t\t\t\tast_log(LOG_WARNING, \"change to port ignored until next asterisk re-start\\n\");\n\t\t} else if (!strcasecmp(v->name, \"bindaddr\")) {\n\t\t\tstruct hostent *hep;\n\t\t\tstruct ast_hostent hent;\n\t\t\thep = ast_gethostbyname(v->value, &hent);\n\t\t\tif (hep) {\n\t\t\t\tmemcpy(&sin->sin_addr, hep->h_addr, sizeof(sin->sin_addr));\n\t\t\t} else\n\t\t\t\tast_log(LOG_WARNING, \"Invalid host/IP '%s'\\n\", v->value);\n\t\t} else if (!strcasecmp(v->name, \"authdebug\")) {\n\t\t\tauthdebug = ast_true(v->value);\n\t\t} else if (!strcasecmp(v->name, \"ttl\")) {\n\t\t\tif ((sscanf(v->value, \"%30d\", &x) == 1) && (x > 0) && (x < DUNDI_DEFAULT_TTL)) {\n\t\t\t\tdundi_ttl = x;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"'%s' is not a valid TTL at line %d, must be number from 1 to %d\\n\",\n\t\t\t\t\tv->value, v->lineno, DUNDI_DEFAULT_TTL);\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"autokill\")) {\n\t\t\tif (sscanf(v->value, \"%30d\", &x) == 1) {\n\t\t\t\tif (x >= 0)\n\t\t\t\t\tglobal_autokilltimeout = x;\n\t\t\t\telse\n\t\t\t\t\tast_log(LOG_NOTICE, \"Nice try, but autokill has to be >0 or 'yes' or 'no' at line %d\\n\", v->lineno);\n\t\t\t} else if (ast_true(v->value)) {\n\t\t\t\tglobal_autokilltimeout = DEFAULT_MAXMS;\n\t\t\t} else {\n\t\t\t\tglobal_autokilltimeout = 0;\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"entityid\")) {\n\t\t\tif (!ast_str_to_eid(&testeid, v->value))\n\t\t\t\tglobal_eid = testeid;\n\t\t\telse\n\t\t\t\tast_log(LOG_WARNING, \"Invalid global endpoint identifier '%s' at line %d\\n\", v->value, v->lineno);\n\t\t} else if (!strcasecmp(v->name, \"tos\")) {\n\t\t\tif (ast_str2tos(v->value, &tos))\n\t\t\t\tast_log(LOG_WARNING, \"Invalid tos value at line %d, refer to QoS documentation\\n\", v->lineno);\n\t\t} else if (!strcasecmp(v->name, \"department\")) {\n\t\t\tast_copy_string(dept, v->value, sizeof(dept));\n\t\t} else if (!strcasecmp(v->name, \"organization\")) {\n\t\t\tast_copy_string(org, v->value, sizeof(org));\n\t\t} else if (!strcasecmp(v->name, \"locality\")) {\n\t\t\tast_copy_string(locality, v->value, sizeof(locality));\n\t\t} else if (!strcasecmp(v->name, \"stateprov\")) {\n\t\t\tast_copy_string(stateprov, v->value, sizeof(stateprov));\n\t\t} else if (!strcasecmp(v->name, \"country\")) {\n\t\t\tast_copy_string(country, v->value, sizeof(country));\n\t\t} else if (!strcasecmp(v->name, \"email\")) {\n\t\t\tast_copy_string(email, v->value, sizeof(email));\n\t\t} else if (!strcasecmp(v->name, \"phone\")) {\n\t\t\tast_copy_string(phone, v->value, sizeof(phone));\n\t\t} else if (!strcasecmp(v->name, \"storehistory\")) {\n\t\t\tglobal_storehistory = ast_true(v->value);\n\t\t} else if (!strcasecmp(v->name, \"cachetime\")) {\n\t\t\tif ((sscanf(v->value, \"%30d\", &x) == 1)) {\n\t\t\t\tdundi_cache_time = x;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"'%s' is not a valid cache time at line %d. Using default value '%d'.\\n\",\n\t\t\t\t\tv->value, v->lineno, DUNDI_DEFAULT_CACHE_TIME);\n\t\t\t}\n\t\t}\n\t\tv = v->next;\n\t}\n\tAST_LIST_UNLOCK(&peers);\n\tmark_mappings();\n\tv = ast_variable_browse(cfg, \"mappings\");\n\twhile(v) {\n\t\tbuild_mapping(v->name, v->value);\n\t\tv = v->next;\n\t}\n\tprune_mappings();\n\tmark_peers();\n\tcat = ast_category_browse(cfg, NULL);\n\twhile(cat) {\n\t\tif (strcasecmp(cat, \"general\") && strcasecmp(cat, \"mappings\")) {\n\t\t\t\n\t\t\tif (!ast_str_to_eid(&testeid, cat))\n\t\t\t\tbuild_peer(&testeid, ast_variable_browse(cfg, cat), &globalpcmodel);\n\t\t\telse if (!strcasecmp(cat, \"*\")) {\n\t\t\t\tbuild_peer(&empty_eid, ast_variable_browse(cfg, cat), &globalpcmodel);\n\t\t\t\tany_peer = find_peer(NULL);\n\t\t\t} else\n\t\t\t\tast_log(LOG_NOTICE, \"Ignoring invalid EID entry '%s'\\n\", cat);\n\t\t}\n\t\tcat = ast_category_browse(cfg, cat);\n\t}\n\tprune_peers();\n\tast_config_destroy(cfg);\n\tload_password();\n\tif (globalpcmodel & DUNDI_MODEL_OUTBOUND)\n\t\tdundi_precache_full();\n\treturn 0;\n}\n", "bug_type": null, "idx": 900}
{"project": "Asterisk", "target": 0, "func": "static inline void misdn_tasks_wakeup(void)\n{\n\tpthread_kill(misdn_tasks_thread, SIGUSR1);\n}\n", "bug_type": null, "idx": 901}
{"project": "Asterisk", "target": 0, "func": "protected char *\nce__endword(char *p, char *high, int n)\n{\n\tp++;\n\twhile (n--) {\n\t\twhile ((p < high) && isspace((unsigned char) *p))\n\t\t\tp++;\n\t\twhile ((p < high) && !isspace((unsigned char) *p))\n\t\t\tp++;\n\t}\n\tp--;\n\treturn (p);\n}\n", "bug_type": null, "idx": 902}
{"project": "Asterisk", "target": 0, "func": "int ast_sem_timedwait(struct ast_sem *sem, const struct timespec *abs_timeout)\n{\n\tint res;\n\tSCOPED_MUTEX(lock, &sem->mutex);\n\tast_assert(sem->count >= 0);\n\t\n\t++sem->waiters;\n\twhile (sem->count == 0) {\n\t\tres = ast_cond_timedwait(&sem->cond, &sem->mutex, abs_timeout);\n\t\t\n\t\tif (res != 0) {\n\t\t\t--sem->waiters;\n\t\t\treturn res;\n\t\t}\n\t}\n\t--sem->waiters;\n\t\n\t--sem->count;\n\treturn 0;\n}\n", "bug_type": null, "idx": 903}
{"project": "Asterisk", "target": 0, "func": "struct ast_frame *ast_framehook_list_write_event(struct ast_framehook_list *framehooks, struct ast_frame *frame)\n{\n\treturn framehook_list_push_event(framehooks, frame, AST_FRAMEHOOK_EVENT_WRITE);\n}\n", "bug_type": null, "idx": 904}
{"project": "Asterisk", "target": 0, "func": "\nstatic int update_index_cb(void *obj, void *arg, int flags)\n{\n\tchar *lang = obj;\n\tstruct ast_media_index *index = arg;\n\tif (ast_media_index_update(index, lang)) {\n\t\treturn CMP_MATCH;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 905}
{"project": "Asterisk", "target": 0, "func": "static const char app[] = \"BridgeAdd\";\nstatic int bridgeadd_exec(struct ast_channel *chan, const char *data)\n{\n\tstruct ast_channel *c_ref;\n\tstruct ast_bridge_features chan_features;\n\tstruct ast_bridge *bridge;\n\tchar *c_name;\n\t\n\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\tast_answer(chan);\n\t}\n\tif (!(c_ref = ast_channel_get_by_name_prefix(data, strlen(data)))) {\n\t\tast_log(LOG_WARNING, \"Channel %s not found\\n\", data);\n\t\treturn -1;\n\t}\n\tc_name = ast_strdupa(ast_channel_name(c_ref));\n\tast_channel_lock(c_ref);\n\tbridge = ast_channel_get_bridge(c_ref);\n\tast_channel_unlock(c_ref);\n\tast_channel_unref(c_ref);\n\tif (!bridge) {\n\t\tast_log(LOG_WARNING, \"Channel %s is not in a bridge\\n\", c_name);\n\t\treturn -1;\n\t}\n\tast_verb(3, \"%s is joining %s in bridge %s\\n\", ast_channel_name(chan),\n\t\tc_name, bridge->uniqueid);\n\tif (ast_bridge_features_init(&chan_features)\n\t\t|| ast_bridge_join(bridge, chan, NULL, &chan_features, NULL, 0)) {\n\t\tast_log(LOG_WARNING, \"%s failed to join %s in bridge %s\\n\", ast_channel_name(chan),\n\t\t\t c_name, bridge->uniqueid);\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\tao2_cleanup(bridge);\n\t\treturn -1;\n\t}\n\tast_bridge_features_cleanup(&chan_features);\n\tao2_cleanup(bridge);\n\treturn 0;\n}\n", "bug_type": null, "idx": 906}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int group_function_read(struct ast_channel *chan, const char *cmd,\n\t\t\t       char *data, char *buf, size_t len)\n{\n\tint ret = -1;\n\tstruct ast_group_info *gi = NULL;\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\tast_app_group_list_rdlock();\n\tfor (gi = ast_app_group_list_head(); gi; gi = AST_LIST_NEXT(gi, group_list)) {\n\t\tif (gi->chan != chan)\n\t\t\tcontinue;\n\t\tif (ast_strlen_zero(data))\n\t\t\tbreak;\n\t\tif (!ast_strlen_zero(gi->category) && !strcasecmp(gi->category, data))\n\t\t\tbreak;\n\t}\n\tif (gi) {\n\t\tast_copy_string(buf, gi->group, len);\n\t\tret = 0;\n\t}\n\tast_app_group_list_unlock();\n\treturn ret;\n}\n", "bug_type": null, "idx": 907}
{"project": "Asterisk", "target": 0, "func": "static char *cli_show_subscriptions_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\ton_subscription_t on_subscription;\n\tstruct cli_sub_parms cli;\n\tregex_t like;\n\tconst char *regex;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"pjsip show subscriptions {inbound|outbound} [like]\";\n\t\te->usage = \"Usage:\\n\"\n\t\t\t\t   \"   pjsip show subscriptions inbound [like <regex>]\\n\"\n\t\t\t\t   \"      Show active inbound subscriptions\\n\"\n\t\t\t\t   \"   pjsip show subscriptions outbound [like <regex>]\\n\"\n\t\t\t\t   \"      Show active outbound subscriptions\\n\"\n\t\t\t\t   \"\\n\"\n\t\t\t\t   \"   The regex selects a subscriptions output that matches.\\n\"\n\t\t\t\t   \"   i.e.,  All output lines for a subscription are checked\\n\"\n\t\t\t\t   \"   as a block by the regex.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4 && a->argc != 6) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (!strcasecmp(a->argv[3], \"inbound\")) {\n\t\ton_subscription = cli_show_subscriptions_inbound;\n\t} else if (!strcasecmp(a->argv[3], \"outbound\")) {\n\t\ton_subscription = cli_show_subscriptions_outbound;\n\t} else {\n\t\t\n\t\tast_assert(0);\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (a->argc == 6) {\n\t\tint rc;\n\t\tif (strcasecmp(a->argv[4], \"like\")) {\n\t\t\treturn CLI_SHOWUSAGE;\n\t\t}\n\t\t\n\t\tmemset(&like, 0, sizeof(like));\n\t\tcli.like = &like;\n\t\tregex = a->argv[5];\n\t\trc = regcomp(cli.like, regex, REG_EXTENDED | REG_NOSUB);\n\t\tif (rc) {\n\t\t\tchar *regerr = ast_alloca(MAX_REGEX_ERROR_LEN);\n\t\t\tregerror(rc, cli.like, regerr, MAX_REGEX_ERROR_LEN);\n\t\t\tast_cli(a->fd, \"Regular expression '%s' failed to compile: %s\\n\",\n\t\t\t\tregex, regerr);\n\t\t\treturn CLI_FAILURE;\n\t\t}\n\t} else {\n\t\tcli.like = NULL;\n\t\tregex = NULL;\n\t}\n\tcli.a = a;\n\tcli.e = e;\n\tcli.count = 0;\n\tcli.buf = ast_str_create(256);\n\tif (!cli.buf) {\n\t\tif (cli.like) {\n\t\t\tregfree(cli.like);\n\t\t}\n\t\treturn CLI_FAILURE;\n\t}\n\tast_cli(a->fd, CLI_SHOW_SUB_FORMAT_HEADER);\n\tfor_each_subscription(on_subscription, &cli);\n\tast_cli(a->fd, \"%d active subscriptions%s%s%s\\n\",\n\t\tcli.count,\n\t\tregex ? \" matched \\\"\" : \"\",\n\t\tregex ?: \"\",\n\t\tregex ? \"\\\"\" : \"\");\n\tast_free(cli.buf);\n\tif (cli.like) {\n\t\tregfree(cli.like);\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 908}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_location_add_contact(struct ast_sip_aor *aor, const char *uri,\n\t\tstruct timeval expiration_time, const char *path_info, const char *user_agent,\n\t\tconst char *via_addr, int via_port, const char *call_id,\n\t\tstruct ast_sip_endpoint *endpoint)\n{\n\tint res;\n\tao2_lock(aor);\n\tres = ast_sip_location_add_contact_nolock(aor, uri, expiration_time, path_info, user_agent,\n\t\tvia_addr, via_port, call_id,\n\t\tendpoint);\n\tao2_unlock(aor);\n\treturn res;\n}\n", "bug_type": null, "idx": 909}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225Progress_UUIE (OOCTXT* pctxt, H225Progress_UUIE* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.multipleCallsPresent ||\n   pvalue->m.maintainConnectionPresent ||\n   pvalue->m.fastConnectRefusedPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.h245AddressPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.h245SecurityModePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.tokensPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.cryptoTokensPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.fastStartPresent);\n   \n   stat = asn1PE_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225EndpointType (pctxt, &pvalue->destinationInfo);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.h245AddressPresent) {\n      stat = asn1PE_H225TransportAddress (pctxt, &pvalue->h245Address);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = asn1PE_H225CallIdentifier (pctxt, &pvalue->callIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.h245SecurityModePresent) {\n      stat = asn1PE_H225H245Security (pctxt, &pvalue->h245SecurityMode);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.tokensPresent) {\n      stat = asn1PE_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.cryptoTokensPresent) {\n      stat = asn1PE_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.fastStartPresent) {\n      stat = asn1PE_H225Progress_UUIE_fastStart (pctxt, &pvalue->fastStart);\n      if (stat != ASN_OK) return stat;\n   }\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 2);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.multipleCallsPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.maintainConnectionPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.fastConnectRefusedPresent);\n      \n      if (pvalue->m.multipleCallsPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeBit (&lctxt, (ASN1BOOL)pvalue->multipleCalls);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.maintainConnectionPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeBit (&lctxt, (ASN1BOOL)pvalue->maintainConnection);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.fastConnectRefusedPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         \n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 910}
{"project": "Asterisk", "target": 0, "func": "void *__ast_calloc_with_stringfields(unsigned int num_structs, size_t struct_size,\n\tsize_t field_mgr_offset, size_t field_mgr_pool_offset, size_t pool_size, const char *file,\n\tint lineno, const char *func)\n{\n\tstruct ast_string_field_mgr *mgr;\n\tstruct ast_string_field_pool *pool;\n\tstruct ast_string_field_pool **pool_head;\n\tsize_t pool_size_needed = sizeof(*pool) + pool_size;\n\tsize_t size_to_alloc = optimal_alloc_size(struct_size + pool_size_needed);\n\tvoid *allocation;\n\tconst char **p;\n\tsize_t initial_vector_size;\n\tast_assert(num_structs == 1);\n\tif (!(allocation = calloc_wrapper(num_structs, size_to_alloc, file, lineno, func))) {\n\t\treturn NULL;\n\t}\n\tmgr = allocation + field_mgr_offset;\n\tpool = allocation + struct_size;\n\tpool_head = allocation + field_mgr_pool_offset;\n\tp = (const char **) pool_head + 1;\n\tinitial_vector_size = ((size_t) (((char *)mgr) - ((char *)p))) / sizeof(*p);\n\tif (AST_VECTOR_INIT(&mgr->string_fields, initial_vector_size)) {\n\t\tast_free(allocation);\n\t\treturn NULL;\n\t}\n\twhile ((struct ast_string_field_mgr *) p != mgr) {\n\t\tAST_VECTOR_APPEND(&mgr->string_fields, p);\n\t\t*p++ = __ast_string_field_empty;\n\t}\n\tmgr->embedded_pool = pool;\n\t*pool_head = pool;\n\tpool->size = size_to_alloc - struct_size - sizeof(*pool);\n#if defined(__AST_DEBUG_MALLOC)\n\t\tmgr->owner_file = file;\n\t\tmgr->owner_func = func;\n\t\tmgr->owner_line = lineno;\n#endif\n\treturn allocation;\n}\n", "bug_type": null, "idx": 911}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_destroy_global_headers(void)\n{\n\tdestroy_headers(&request_headers);\n\tdestroy_headers(&response_headers);\n\tinternal_sip_unregister_service(&global_header_mod);\n}\n", "bug_type": null, "idx": 912}
{"project": "Asterisk", "target": 0, "func": " * of messing with column widths, etc. */\nstatic const char *get_sqlite_column_type(int type)\n{\n\tswitch(type) {\n\tcase RQ_INTEGER1 :\n\tcase RQ_UINTEGER1 :\n\tcase RQ_INTEGER2 :\n\tcase RQ_UINTEGER2 :\n\tcase RQ_INTEGER3 :\n\tcase RQ_UINTEGER3 :\n\tcase RQ_INTEGER4 :\n\tcase RQ_UINTEGER4 :\n\tcase RQ_INTEGER8 :\n\t\treturn \"INTEGER\";\n\tcase RQ_UINTEGER8 : \n\tcase RQ_CHAR :\n\tcase RQ_DATE :\n\tcase RQ_DATETIME :\n\t\treturn \"TEXT\";\n\tcase RQ_FLOAT :\n\t\treturn \"REAL\";\n\tdefault :\n\t\treturn \"TEXT\";\n\t}\n\treturn \"TEXT\";\n}\n", "bug_type": null, "idx": 913}
{"project": "Asterisk", "target": 0, "func": "private void\nmap_init_meta(EditLine *el)\n{\n\tchar buf[3];\n\tint i;\n\tel_action_t *map = el->el_map.key;\n\tel_action_t *alt = el->el_map.alt;\n\tfor (i = 0; i <= 0377 && map[i] != EM_META_NEXT; i++)\n\t\tcontinue;\n\tif (i > 0377) {\n\t\tfor (i = 0; i <= 0377 && alt[i] != EM_META_NEXT; i++)\n\t\t\tcontinue;\n\t\tif (i > 0377) {\n\t\t\ti = 033;\n\t\t\tif (el->el_map.type == MAP_VI)\n\t\t\t\tmap = alt;\n\t\t} else\n\t\t\tmap = alt;\n\t}\n\tbuf[0] = (char) i;\n\tbuf[2] = 0;\n\tfor (i = 0200; i <= 0377; i++)\n\t\tswitch (map[i]) {\n\t\tcase ED_INSERT:\n\t\tcase ED_UNASSIGNED:\n\t\tcase ED_SEQUENCE_LEAD_IN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuf[1] = i & 0177;\n\t\t\tkey_add(el, buf, key_map_cmd(el, (int) map[i]), XK_CMD);\n\t\t\tbreak;\n\t\t}\n\tmap[(int) buf[0]] = ED_SEQUENCE_LEAD_IN;\n}\n", "bug_type": null, "idx": 914}
{"project": "Asterisk", "target": 0, "func": "struct ast_xml_node *ast_xml_node_get_children(struct ast_xml_node *node)\n{\n\treturn (struct ast_xml_node *) ((xmlNode *) node)->children;\n}\n", "bug_type": null, "idx": 915}
{"project": "Asterisk", "target": 0, "func": "\nstatic void t38_interpret_sdp(struct t38_state *state, struct ast_sip_session *session, struct ast_sip_session_media *session_media,\n\tconst struct pjmedia_sdp_media *stream)\n{\n\tunsigned int attr_i;\n\tfor (attr_i = 0; attr_i < stream->attr_count; attr_i++) {\n\t\tpjmedia_sdp_attr *attr = stream->attr[attr_i];\n\t\tif (!pj_stricmp2(&attr->name, \"t38faxmaxbuffer\")) {\n\t\t\t\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38maxbitrate\") || !pj_stricmp2(&attr->name, \"t38faxmaxrate\")) {\n\t\t\tswitch (pj_strtoul(&attr->value)) {\n\t\t\tcase 14400:\n\t\t\t\tstate->their_parms.rate = AST_T38_RATE_14400;\n\t\t\t\tbreak;\n\t\t\tcase 12000:\n\t\t\t\tstate->their_parms.rate = AST_T38_RATE_12000;\n\t\t\t\tbreak;\n\t\t\tcase 9600:\n\t\t\t\tstate->their_parms.rate = AST_T38_RATE_9600;\n\t\t\t\tbreak;\n\t\t\tcase 7200:\n\t\t\t\tstate->their_parms.rate = AST_T38_RATE_7200;\n\t\t\t\tbreak;\n\t\t\tcase 4800:\n\t\t\t\tstate->their_parms.rate = AST_T38_RATE_4800;\n\t\t\t\tbreak;\n\t\t\tcase 2400:\n\t\t\t\tstate->their_parms.rate = AST_T38_RATE_2400;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38faxversion\")) {\n\t\t\tstate->their_parms.version = pj_strtoul(&attr->value);\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38faxmaxdatagram\") || !pj_stricmp2(&attr->name, \"t38maxdatagram\")) {\n\t\t\tif (!session->endpoint->media.t38.maxdatagram) {\n\t\t\t\tast_udptl_set_far_max_datagram(session_media->udptl, pj_strtoul(&attr->value));\n\t\t\t}\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38faxfillbitremoval\")) {\n\t\t\tstate->their_parms.fill_bit_removal = 1;\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38faxtranscodingmmr\")) {\n\t\t\tstate->their_parms.transcoding_mmr = 1;\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38faxtranscodingjbig\")) {\n\t\t\tstate->their_parms.transcoding_jbig = 1;\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38faxratemanagement\")) {\n\t\t\tif (!pj_stricmp2(&attr->value, \"localTCF\")) {\n\t\t\t\tstate->their_parms.rate_management = AST_T38_RATE_MANAGEMENT_LOCAL_TCF;\n\t\t\t} else if (!pj_stricmp2(&attr->value, \"transferredTCF\")) {\n\t\t\t\tstate->their_parms.rate_management = AST_T38_RATE_MANAGEMENT_TRANSFERRED_TCF;\n\t\t\t}\n\t\t} else if (!pj_stricmp2(&attr->name, \"t38faxudpec\")) {\n\t\t\tif (!pj_stricmp2(&attr->value, \"t38UDPRedundancy\")) {\n\t\t\t\tast_udptl_set_error_correction_scheme(session_media->udptl, UDPTL_ERROR_CORRECTION_REDUNDANCY);\n\t\t\t} else if (!pj_stricmp2(&attr->value, \"t38UDPFEC\")) {\n\t\t\t\tast_udptl_set_error_correction_scheme(session_media->udptl, UDPTL_ERROR_CORRECTION_FEC);\n\t\t\t} else {\n\t\t\t\tast_udptl_set_error_correction_scheme(session_media->udptl, UDPTL_ERROR_CORRECTION_NONE);\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 916}
{"project": "Asterisk", "target": 0, "func": "int internal_sip_unregister_endpoint_formatter(struct ast_sip_endpoint_formatter *obj)\n{\n\tstruct ast_sip_endpoint_formatter *i;\n\tSCOPED_LOCK(lock, &endpoint_formatters, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&endpoint_formatters, i, next) {\n\t\tif (i == obj) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(next);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\treturn i == obj ? 0 : -1;\n}\n", "bug_type": null, "idx": 917}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225_SeqOfH225CicInfo_cic_element (OOCTXT* pctxt, H225_SeqOfH225CicInfo_cic_element* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT xx1;\n   \n   stat = encodeLength (pctxt, pvalue->n);\n   if (stat < 0) return stat;\n   \n   for (xx1 = 0; xx1 < pvalue->n; xx1++) {\n      stat = asn1PE_H225CicInfo_cic_element (pctxt, &pvalue->elem[xx1]);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 918}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void get_device_state_causing_channels(struct ao2_container *c)\n{\n\tstruct ao2_iterator iter;\n\tstruct ast_device_state_info *info;\n\tstruct ast_channel *chan;\n\tif (!c || !ao2_container_count(c)) {\n\t\treturn;\n\t}\n\titer = ao2_iterator_init(c, 0);\n\tfor (; (info = ao2_iterator_next(&iter)); ao2_ref(info, -1)) {\n\t\tenum ast_channel_state search_state = 0; \n\t\tchar match[AST_CHANNEL_NAME];\n\t\tstruct ast_channel_iterator *chan_iter;\n\t\tstruct timeval chantime = {0, }; \n\t\tswitch (info->device_state) {\n\t\tcase AST_DEVICE_RINGING:\n\t\tcase AST_DEVICE_RINGINUSE:\n\t\t\t\n\t\t\tsearch_state = AST_STATE_RINGING;\n\t\t\tbreak;\n\t\tcase AST_DEVICE_BUSY:\n\t\t\t\n\t\t\tsearch_state = AST_STATE_BUSY;\n\t\t\tbreak;\n\t\tcase AST_DEVICE_ONHOLD:\n\t\tcase AST_DEVICE_INUSE:\n\t\t\t\n\t\t\tsearch_state = AST_STATE_UP;\n\t\t\tbreak;\n\t\tcase AST_DEVICE_UNKNOWN:\n\t\tcase AST_DEVICE_NOT_INUSE:\n\t\tcase AST_DEVICE_INVALID:\n\t\tcase AST_DEVICE_UNAVAILABLE:\n\t\tcase AST_DEVICE_TOTAL :\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t        snprintf(match, sizeof(match), \"%s-\", info->device_name);\n\t\tchan_iter = ast_channel_iterator_by_name_new(match, strlen(match));\n\t\tfor (; (chan = ast_channel_iterator_next(chan_iter)); ast_channel_unref(chan)) {\n\t\t\tast_channel_lock(chan);\n\t\t\t\n\t\t\tif (search_state != ast_channel_state(chan)) {\n\t\t\t\tast_channel_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (search_state != AST_STATE_RINGING) {\n\t\t\t\tast_channel_unlock(chan);\n\t\t\t\tinfo->causing_channel = chan; \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (!info->causing_channel) {\n\t\t\t\tchantime = ast_channel_creationtime(chan);\n\t\t\t\tast_channel_ref(chan); \n\t\t\t\tinfo->causing_channel = chan;\n\t\t\t} else if (ast_tvcmp(ast_channel_creationtime(chan), chantime) < 0) {\n\t\t\t\tchantime = ast_channel_creationtime(chan);\n\t\t\t\tast_channel_unref(info->causing_channel);\n\t\t\t\tast_channel_ref(chan); \n\t\t\t\tinfo->causing_channel = chan;\n\t\t\t}\n\t\t\tast_channel_unlock(chan);\n\t\t}\n\t\tast_channel_iterator_destroy(chan_iter);\n\t}\n\tao2_iterator_destroy(&iter);\n}\n", "bug_type": null, "idx": 919}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_snapshot_connected_line_equal(\n\tconst struct ast_channel_snapshot *old_snapshot,\n\tconst struct ast_channel_snapshot *new_snapshot)\n{\n\tast_assert(old_snapshot != NULL);\n\tast_assert(new_snapshot != NULL);\n\treturn strcmp(old_snapshot->connected_number, new_snapshot->connected_number) == 0 &&\n\t\tstrcmp(old_snapshot->connected_name, new_snapshot->connected_name) == 0;\n}\n", "bug_type": null, "idx": 920}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void __attribute__((constructor)) __say_init(void)\n{\n\tast_say_number_full = say_number_full;\n\tast_say_enumeration_full = say_enumeration_full;\n\tast_say_digit_str_full = say_digit_str_full;\n\tast_say_character_str_full = say_character_str_full;\n\tast_say_phonetic_str_full = say_phonetic_str_full;\n\tast_say_datetime = say_datetime;\n\tast_say_time = say_time;\n\tast_say_date = say_date;\n\tast_say_datetime_from_now = say_datetime_from_now;\n\tast_say_date_with_format = say_date_with_format;\n}\n", "bug_type": null, "idx": 921}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_asterisk_list_modules(struct ast_variable *headers,\n\tstruct ast_ari_asterisk_list_modules_args *args,\n\tstruct ast_ari_response *response)\n{\n\tstruct ast_json *json;\n\tjson = ast_json_array_create();\n\tast_update_module_list_data(&process_module_list, NULL, json);\n\tast_ari_response_ok(response, json);\n}\n", "bug_type": null, "idx": 922}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_manager_unregister(\"PresenceStateList\");\n\ttopic_forwarder = stasis_forward_cancel(topic_forwarder);\n\treturn 0;\n}\n", "bug_type": null, "idx": 923}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_publish_client_user_send(struct ast_sip_outbound_publish_client *client,\n\t\t\t\t     const char *user, const struct ast_sip_body *body)\n{\n\tstruct sip_outbound_publisher *publisher;\n\tint res;\n\tpublisher = sip_outbound_publish_client_get_publisher(client, user);\n\tif (!publisher) {\n\t\treturn -1;\n\t}\n\tpublisher_client_send(publisher, (void *)body, &res, 0);\n\tao2_ref(publisher, -1);\n\treturn res;\n}\n", "bug_type": null, "idx": 924}
{"project": "Asterisk", "target": 0, "func": "static struct ast_context *ast_walk_contexts(struct ast_context *con);\nstatic struct ast_context *ast_walk_contexts(struct ast_context *con)\n{\n\treturn con ? con->next : contexts;\n}\n", "bug_type": null, "idx": 925}
{"project": "Asterisk", "target": 0, "func": "static char *console_flash(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_frame f = { AST_FRAME_CONTROL, { AST_CONTROL_FLASH } };\n\tstruct chan_oss_pvt *o = find_desc(oss_active);\n\tif (cmd == CLI_INIT) {\n\t\te->command = \"console flash\";\n\t\te->usage =\n\t\t\t\"Usage: console flash\\n\"\n\t\t\t\"       Flashes the call currently placed on the console.\\n\";\n\t\treturn NULL;\n\t} else if (cmd == CLI_GENERATE)\n\t\treturn NULL;\n\tif (a->argc != e->args)\n\t\treturn CLI_SHOWUSAGE;\n\tif (!o->owner) {\t\t\t\n\t\tast_cli(a->fd, \"No call to flash\\n\");\n\t\treturn CLI_FAILURE;\n\t}\n\to->hookstate = 0;\n\tif (o->owner)\n\t\tast_queue_frame(o->owner, &f);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 926}
{"project": "Asterisk", "target": 0, "func": "#endif\nooH323EpCapability* ooIsAudioDataTypeGSMSupported\n   (OOH323CallData *call, H245AudioCapability* audioCap, int dir)\n{\n   unsigned framesPerPkt=0;\n   int cap=0;\n   ooH323EpCapability *cur = NULL, *epCap=NULL;\n   OOGSMCapParams *params = NULL;\n   switch(audioCap->t)\n   {\n   case T_H245AudioCapability_gsmFullRate:\n      framesPerPkt = (audioCap->u.gsmFullRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      cap = OO_GSMFULLRATE;\n      break;\n   case T_H245AudioCapability_gsmHalfRate:\n      framesPerPkt = (audioCap->u.gsmHalfRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      cap = OO_GSMHALFRATE;\n      break;\n   case T_H245AudioCapability_gsmEnhancedFullRate:\n      framesPerPkt = (audioCap->u.gsmEnhancedFullRate->audioUnitSize)/OO_GSMFRAMESIZE;\n      cap = OO_GSMENHANCEDFULLRATE;\n      break;\n   default:\n      OOTRACEERR3(\"Error:Invalid GSM capability type.(%s, %s)\\n\", \n                                           call->callType, call->callToken);\n     return NULL;\n   }\n   OOTRACEDBGC4(\"Determined audio data type to be of type %d. Searching\"\n                \" for matching capability.(%s, %s)\\n\", cap, call->callType, \n                call->callToken);\n   \n   if(call->ourCaps)   \n      cur = call->ourCaps;\n   else\n      cur = gH323ep.myCaps;\n   while(cur)\n   {\n      OOTRACEDBGC4(\"Local cap being compared %d. (%s, %s)\\n\", cur->cap,\n                     call->callType, call->callToken);\n      if(cur->cap == cap && (cur->dir & dir))\n         break;\n      cur = cur->next;\n   }\n   if(!cur) return NULL;\n   OOTRACEDBGC4(\"Found matching audio capability type %d. Comparing\"\n                \" other parameters. (%s, %s)\\n\", cap, call->callType, \n                call->callToken);\n   \n   if(dir & OORX)\n   {\n      if(((OOGSMCapParams*)cur->params)->rxframes < framesPerPkt)\n         return NULL;\n      else{\n         epCap = (ooH323EpCapability*)memAlloc(call->pctxt, \n                                                 sizeof(ooH323EpCapability));\n         params =(OOGSMCapParams*)memAlloc(call->pctxt,sizeof(OOGSMCapParams));\n         if(!epCap || !params)\n         {\n            OOTRACEERR3(\"Error:Memory - ooIsAudioDataTypeGSMSupported - \"\n                        \"epCap/params (%s, %s)\\n\", call->callType, \n                        call->callToken);\n            return NULL;\n         }\n         epCap->params = params;\n         epCap->cap = cur->cap;\n         epCap->dir = cur->dir;\n         epCap->capType = cur->capType;\n         epCap->startReceiveChannel = cur->startReceiveChannel;\n         epCap->startTransmitChannel= cur->startTransmitChannel;\n         epCap->stopReceiveChannel = cur->stopReceiveChannel;\n         epCap->stopTransmitChannel = cur->stopTransmitChannel;\n         epCap->next = NULL;\n         memcpy(epCap->params, cur->params, sizeof(OOGSMCapParams));\n         return epCap;\n      }\n   }\n   \n   if(dir & OOTX)\n   {\n      epCap = (ooH323EpCapability*)memAlloc(call->pctxt, \n                                                sizeof(ooH323EpCapability));\n      params =(OOGSMCapParams*)memAlloc(call->pctxt,sizeof(OOGSMCapParams));\n      if(!epCap || !params)\n      {\n         OOTRACEERR3(\"Error:Memory - ooIsAudioDataTypeGSMSupported - \"\n                     \"epCap/params (%s, %s)\\n\", call->callType, \n                     call->callToken);\n         return NULL;\n      }\n      epCap->params = params;\n      epCap->cap = cur->cap;\n      epCap->dir = cur->dir;\n      epCap->capType = cur->capType;\n      epCap->startReceiveChannel = cur->startReceiveChannel;\n      epCap->startTransmitChannel= cur->startTransmitChannel;\n      epCap->stopReceiveChannel = cur->stopReceiveChannel;\n      epCap->stopTransmitChannel = cur->stopTransmitChannel;\n      epCap->next = NULL;\n      memcpy(epCap->params, cur->params, sizeof(OOGSMCapParams));\n      if(params->txframes > framesPerPkt)\n      {\n         OOTRACEINFO5(\"Reducing framesPerPkt for transmission of GSM \"\n                      \"capability from %d to %d to match receive capability of\"\n                      \" remote endpoint.(%s, %s)\\n\", params->txframes, \n                      framesPerPkt, call->callType, call->callToken);\n         params->txframes = framesPerPkt;\n      }\n      return epCap;\n   }\n   return NULL;\n}\n", "bug_type": null, "idx": 927}
{"project": "Asterisk", "target": 0, "func": "static void analog_cancel_cidspill(struct analog_pvt *p)\n{\n\tif (analog_callbacks.cancel_cidspill) {\n\t\tanalog_callbacks.cancel_cidspill(p->chan_pvt);\n\t}\n}\n", "bug_type": null, "idx": 928}
{"project": "Asterisk", "target": 0, "func": "\ned_next_char(EditLine *el, int c)\n{\n\tif (el->el_line.cursor >= el->el_line.lastchar)\n\t\treturn (CC_ERROR);\n\tel->el_line.cursor += el->el_state.argument;\n\tif (el->el_line.cursor > el->el_line.lastchar)\n\t\tel->el_line.cursor = el->el_line.lastchar;\n\tif (el->el_map.type == MAP_VI)\n\t\tif (el->el_chared.c_vcmd.action & DELETE) {\n\t\t\tcv_delfini(el);\n\t\t\treturn (CC_REFRESH);\n\t\t}\n\treturn (CC_CURSOR);\n}\n", "bug_type": null, "idx": 929}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tCHECK_PJSIP_MODULE_LOADED();\n\tif (ast_sip_register_outbound_authenticator(&digest_authenticator)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 930}
{"project": "Asterisk", "target": 0, "func": "static void sig_ss7_unlock_private(struct sig_ss7_chan *p)\n{\n\tif (sig_ss7_callbacks.unlock_private) {\n\t\tsig_ss7_callbacks.unlock_private(p->chan_pvt);\n\t}\n}\n", "bug_type": null, "idx": 931}
{"project": "Asterisk", "target": 0, "func": "};\nstruct ast_threadpool *ast_threadpool_create(const char *name,\n\t\tstruct ast_threadpool_listener *listener,\n\t\tconst struct ast_threadpool_options *options)\n{\n\tstruct ast_taskprocessor *tps;\n\tRAII_VAR(struct ast_taskprocessor_listener *, tps_listener, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_threadpool *, pool, NULL, ao2_cleanup);\n\tpool = threadpool_alloc(name, options);\n\tif (!pool) {\n\t\treturn NULL;\n\t}\n\ttps_listener = ast_taskprocessor_listener_alloc(&threadpool_tps_listener_callbacks, pool);\n\tif (!tps_listener) {\n\t\treturn NULL;\n\t}\n\tif (options->version != AST_THREADPOOL_OPTIONS_VERSION) {\n\t\tast_log(LOG_WARNING, \"Incompatible version of threadpool options in use.\\n\");\n\t\treturn NULL;\n\t}\n\ttps = ast_taskprocessor_create_with_listener(name, tps_listener);\n\tif (!tps) {\n\t\treturn NULL;\n\t}\n\tpool->tps = tps;\n\tif (listener) {\n\t\tao2_ref(listener, +1);\n\t\tpool->listener = listener;\n\t}\n\tast_threadpool_set_size(pool, pool->options.initial_size);\n\tao2_ref(pool, +1);\n\treturn pool;\n}\n", "bug_type": null, "idx": 932}
{"project": "Asterisk", "target": 0, "func": "int __ast_bt_get_addresses(struct ast_bt *bt)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 933}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpDisableAutoAnswer(void)\n{\n   OO_CLRFLAG(gH323ep.flags, OO_M_AUTOANSWER);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 934}
{"project": "Asterisk", "target": 0, "func": "*/\nint ooCallAddG728Capability(OOH323CallData *call, int cap, int txframes, \n                            int rxframes, int dir,\n                            cb_StartReceiveChannel startReceiveChannel,\n                            cb_StartTransmitChannel startTransmitChannel,\n                            cb_StopReceiveChannel stopReceiveChannel,\n                            cb_StopTransmitChannel stopTransmitChannel)\n{\n   return ooCapabilityAddSimpleCapability(call, cap, txframes, rxframes, FALSE,\n                          dir, startReceiveChannel, startTransmitChannel, \n                          stopReceiveChannel, stopTransmitChannel, FALSE);\n}\n", "bug_type": null, "idx": 935}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H235Password (OOCTXT* pctxt, H235Password* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeBMPString (pctxt, pvalue, 0);\n   if (stat != ASN_OK) return stat;\n   invokeCharStr16BitValue (pctxt, pvalue->nchars, pvalue->data);\n   return (stat);\n}\n", "bug_type": null, "idx": 936}
{"project": "Asterisk", "target": 0, "func": "static void play_files_helper(struct ast_channel *chan, const char *prompts)\n{\n\tchar *prompt, *rest = ast_strdupa(prompts);\n\tast_stopstream(chan);\n\twhile ((prompt = strsep(&rest, \"&\")) && !ast_stream_and_wait(chan, prompt, \"\")) {\n\t\tast_stopstream(chan);\n\t}\n}\n", "bug_type": null, "idx": 937}
{"project": "Asterisk", "target": 0, "func": "void ast_pjproject_ref(void)\n{\n\tast_module_ref(ast_module_info->self);\n}\n", "bug_type": null, "idx": 938}
{"project": "Asterisk", "target": 0, "func": "void fixed_jb_set_force_resynch(struct fixed_jb *jb)\n{\n\tjb->force_resynch = 1;\n}\n", "bug_type": null, "idx": 939}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ast_say_number_full_nl(struct ast_channel *chan, int num, const char *ints, const char *language, int audiofd, int ctrlfd)\n{\n\tint res = 0;\n\tint playh = 0;\n\tint units = 0;\n\tchar fn[256] = \"\";\n\tif (!num)\n\t\treturn ast_say_digits_full(chan, 0, ints, language, audiofd, ctrlfd);\n\twhile (!res && (num || playh )) {\n\t\tif (num < 0) {\n\t\t\tast_copy_string(fn, \"digits/minus\", sizeof(fn));\n\t\t\tif ( num > INT_MIN ) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t} else if (playh) {\n\t\t\tast_copy_string(fn, \"digits/hundred\", sizeof(fn));\n\t\t\tplayh = 0;\n\t\t} else if (num < 20) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num);\n\t\t\tnum = 0;\n\t\t} else if (num < 100) {\n\t\t\tunits = num % 10;\n\t\t\tif (units > 0) {\n\t\t\t\tres = ast_say_number_full_nl(chan, units, ints, language, audiofd, ctrlfd);\n\t\t\t\tif (res)\n\t\t\t\t\treturn res;\n\t\t\t\tnum = num - units;\n\t\t\t\tast_copy_string(fn, \"digits/nl-en\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num - units);\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t} else if (num < 200) {\n\t\t\t\n\t\t\tast_copy_string(fn, \"digits/hundred\", sizeof(fn));\n\t\t\tnum %= 100;\n\t\t} else if (num < 1000) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num / 100);\n\t\t\tplayh++;\n\t\t\tnum %= 100;\n\t\t} else {\n\t\t\tif (num < 1100) {\n\t\t\t\t\n\t\t\t\tnum %= 1000;\n\t\t\t\tast_copy_string(fn, \"digits/thousand\", sizeof(fn));\n\t\t\t} else if (num < 10000)\t{ \n\t\t\t\tres = ast_say_number_full_nl(chan, num / 100, ints, language, audiofd, ctrlfd);\n\t\t\t\tif (res)\n\t\t\t\t\treturn res;\n\t\t\t\tnum %= 100;\n\t\t\t\tast_copy_string(fn, \"digits/hundred\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tif (num < 1000000) { \n\t\t\t\t\tres = ast_say_number_full_nl(chan, num / 1000, ints, language, audiofd, ctrlfd);\n\t\t\t\t\tif (res)\n\t\t\t\t\t\treturn res;\n\t\t\t\t\tnum %= 1000;\n\t\t\t\t\tast_copy_string(fn, \"digits/thousand\", sizeof(fn));\n\t\t\t\t} else {\n\t\t\t\t\tif (num < 1000000000) { \n\t\t\t\t\t\tres = ast_say_number_full_nl(chan, num / 1000000, ints, language, audiofd, ctrlfd);\n\t\t\t\t\t\tif (res)\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\tnum %= 1000000;\n\t\t\t\t\t\tast_copy_string(fn, \"digits/million\", sizeof(fn));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_debug(1, \"Number '%d' is too big for me\\n\", num);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!res) {\n\t\t\tif (!ast_streamfile(chan, fn, language)) {\n\t\t\t\tif ((audiofd > -1) && (ctrlfd > -1))\n\t\t\t\t\tres = ast_waitstream_full(chan, ints, audiofd, ctrlfd);\n\t\t\t\telse\n\t\t\t\t\tres = ast_waitstream(chan, ints);\n\t\t\t}\n\t\t\tast_stopstream(chan);\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 940}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int record_dtmf_response(struct ast_channel *chan, struct ast_flags *flags, int dtmf_integer, int terminator)\n{\n\tif ((dtmf_integer == OPERATOR_KEY) &&\n\t\t(ast_test_flag(flags, OPTION_OPERATOR_EXIT))) {\n\t\tpbx_builtin_setvar_helper(chan, \"RECORD_STATUS\", \"OPERATOR\");\n\t\treturn -1;\n\t}\n\tif ((dtmf_integer == terminator) ||\n\t\t(ast_test_flag(flags, OPTION_ANY_TERMINATE))) {\n\t\tpbx_builtin_setvar_helper(chan, \"RECORD_STATUS\", \"DTMF\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 941}
{"project": "Asterisk", "target": 0, "func": "void conf_change_state(struct confbridge_user *user, struct confbridge_state *newstate)\n{\n\tast_debug(1, \"Changing conference '%s' state from %s to %s\\n\", user->conference->name, user->conference->state->name, newstate->name);\n\tast_test_suite_event_notify(\"CONF_CHANGE_STATE\", \"Conference: %s\\r\\nOldState: %s\\r\\nNewState: %s\\r\\n\",\n\t\t\tuser->conference->name,\n\t\t\tuser->conference->state->name,\n\t\t\tnewstate->name);\n\tif (user->conference->state->exit) {\n\t\tuser->conference->state->exit(user);\n\t}\n\tuser->conference->state = newstate;\n\tif (user->conference->state->entry) {\n\t\tuser->conference->state->entry(user);\n\t}\n}\n", "bug_type": null, "idx": 942}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int clear_stats(const char *queuename)\n{\n\tstruct call_queue *q;\n\tstruct ao2_iterator queue_iter;\n\tqueue_iter = ao2_iterator_init(queues, 0);\n\twhile ((q = ao2_t_iterator_next(&queue_iter, \"Iterate through queues\"))) {\n\t\tao2_lock(q);\n\t\tif (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename))\n\t\t\tclear_queue(q);\n\t\tao2_unlock(q);\n\t\tqueue_t_unref(q, \"Done with iterator\");\n\t}\n\tao2_iterator_destroy(&queue_iter);\n\treturn 0;\n}\n", "bug_type": null, "idx": 943}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225BandwidthDetails (OOCTXT* pctxt, H225BandwidthDetails* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"sender\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->sender);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->sender);\n   invokeEndElement (pctxt, \"sender\", -1);\n   \n   invokeStartElement (pctxt, \"multicast\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->multicast);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->multicast);\n   invokeEndElement (pctxt, \"multicast\", -1);\n   \n   invokeStartElement (pctxt, \"bandwidth\", -1);\n   stat = asn1PD_H225BandWidth (pctxt, &pvalue->bandwidth);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"bandwidth\", -1);\n   \n   invokeStartElement (pctxt, \"rtcpAddresses\", -1);\n   stat = asn1PD_H225TransportChannelInfo (pctxt, &pvalue->rtcpAddresses);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"rtcpAddresses\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 944}
{"project": "Asterisk", "target": 0, "func": "static int codec2_length(unsigned int samples)\n{\n\treturn (samples / 160) * 6;\n}\n", "bug_type": null, "idx": 945}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_json *create_sound_blob(const char *filename,\n\tstruct ast_ari_sounds_list_args *args)\n{\n\tRAII_VAR(struct ast_json *, sound, NULL, ast_json_unref);\n\tRAII_VAR(struct ao2_container *, languages, NULL, ao2_cleanup);\n\tconst char *description;\n\tstruct ast_json *format_lang_list;\n\tstruct lang_format_info info;\n\tRAII_VAR(struct ast_media_index *, sounds_index, ast_sounds_get_index(), ao2_cleanup);\n\tif (!sounds_index) {\n\t\treturn NULL;\n\t}\n\tdescription = ast_media_get_description(sounds_index, filename, \"en\");\n\tif (ast_strlen_zero(description)) {\n\t\tsound = ast_json_pack(\"{s: s, s: []}\",\n\t\t\t\"id\", filename,\n\t\t\t\"formats\");\n\t} else {\n\t\tsound = ast_json_pack(\"{s: s, s: s, s: []}\",\n\t\t\t\"id\", filename,\n\t\t\t\"text\", description,\n\t\t\t\"formats\");\n\t}\n\tif (!sound) {\n\t\treturn NULL;\n\t}\n\tformat_lang_list = ast_json_object_get(sound, \"formats\");\n\tif (!format_lang_list) {\n\t\treturn NULL;\n\t}\n\tlanguages = ast_media_get_variants(sounds_index, filename);\n\tif (!languages || !ao2_container_count(languages)) {\n\t\treturn NULL;\n\t}\n\t\n\tif (args && !ast_strlen_zero(args->lang)) {\n\t\tchar *lang_filter = ast_strdupa(args->lang);\n\t\tao2_callback(languages, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK, filter_langs_cb, lang_filter);\n\t\tif (!languages || !ao2_container_count(languages)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tinfo.filename = filename;\n\tinfo.format_list = format_lang_list;\n\tinfo.format_filter = NULL;\n\tif (args) {\n\t\tinfo.format_filter = args->format;\n\t}\n\tao2_callback(languages, OBJ_NODATA, add_format_information_cb, &info);\n\t\n\tif (!ast_json_array_size(format_lang_list)) {\n\t\treturn NULL;\n\t}\n\treturn ast_json_ref(sound);\n}\n", "bug_type": null, "idx": 946}
{"project": "Asterisk", "target": 0, "func": "void AST_OPTIONAL_API_NAME(ast_websocket_reconstruct_enable)(struct ast_websocket *session, size_t bytes)\n{\n\tsession->reconstruct = MIN(bytes, MAXIMUM_RECONSTRUCTION_CEILING);\n}\n", "bug_type": null, "idx": 947}
{"project": "Asterisk", "target": 0, "func": "static int reload_module(void)\n{\n\tast_sorcery_reload_object(ast_sip_get_sorcery(), \"outbound-publish\");\n\tAST_RWLIST_RDLOCK(&publisher_handlers);\n\tsip_outbound_publish_synchronize(NULL);\n\tAST_RWLIST_UNLOCK(&publisher_handlers);\n\treturn 0;\n}\n", "bug_type": null, "idx": 948}
{"project": "Asterisk", "target": 0, "func": "static void ast_srtp_policy_set_ssrc(struct ast_srtp_policy *policy,\n\t\tunsigned long ssrc, int inbound)\n{\n\tif (ssrc) {\n\t\tpolicy->sp.ssrc.type = ssrc_specific;\n\t\tpolicy->sp.ssrc.value = ssrc;\n\t} else {\n\t\tpolicy->sp.ssrc.type = inbound ? ssrc_any_inbound : ssrc_any_outbound;\n\t}\n}\n", "bug_type": null, "idx": 949}
{"project": "Asterisk", "target": 0, "func": "struct ast_sdp_a_line *ast_sdp_m_get_a(const struct ast_sdp_m_line *m_line, int index)\n{\n\tast_assert(m_line != NULL);\n\treturn AST_VECTOR_GET(m_line->a_lines, index);\n}\n", "bug_type": null, "idx": 950}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void unschedule_qualify(struct ast_sip_contact *contact)\n{\n\tstruct sched_data *data;\n\tdata = ao2_find(sched_qualifies, contact, OBJ_UNLINK | OBJ_SEARCH_KEY);\n\tif (!data) {\n\t\treturn;\n\t}\n\tAST_SCHED_DEL_UNREF(sched, data->id,\n\t\tao2_t_ref(data, -1, \"Delete scheduler entry ref\"));\n\tao2_t_ref(data, -1, \"Done with ao2_find ref\");\n}\n", "bug_type": null, "idx": 951}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225Setup_UUIE_parallelH245Control (OOCTXT* pctxt, H225Setup_UUIE_parallelH245Control* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT xx1;\n   \n   stat = decodeLength (pctxt, &pvalue->n);\n   if (stat != ASN_OK) return stat;\n   \n   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);\n   for (xx1 = 0; xx1 < pvalue->n; xx1++) {\n      invokeStartElement (pctxt, \"elem\", xx1);\n      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);\n      if (stat != ASN_OK) return stat;\n      invokeOctStrValue (pctxt, pvalue->elem[xx1].numocts, pvalue->elem[xx1].data);\n      invokeEndElement (pctxt, \"elem\", xx1);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 952}
{"project": "Asterisk", "target": 0, "func": "static char *complete_dialplan_add_ignorepat(struct ast_cli_args *a)\n{\n\tif (a->pos == 4)\n\t\treturn a->n == 0 ? ast_strdup(\"into\") : NULL;\n\telse if (a->pos == 5) {\n\t\tstruct ast_context *c;\n\t\tint which = 0;\n\t\tchar *dupline, *ignorepat = NULL;\n\t\tconst char *s;\n\t\tchar *ret = NULL;\n\t\tint len = strlen(a->word);\n\t\t\n\t\ts = skip_words(a->line, 3);\n\t\tif (s == NULL)\n\t\t\treturn NULL;\n\t\tdupline = ast_strdup(s);\n\t\tif (!dupline) {\n\t\t\tast_log(LOG_ERROR, \"Malloc failure\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tignorepat = strsep(&dupline, \" \");\n\t\tif (ast_rdlock_contexts()) {\n\t\t\tast_log(LOG_ERROR, \"Failed to lock contexts list\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (c = NULL; !ret && (c = ast_walk_contexts(c));) {\n\t\t\tint found = 0;\n\t\t\tif (!partial_match(ast_get_context_name(c), a->word, len))\n\t\t\t\tcontinue; \n\t\t\tif (ignorepat) \n\t\t\t\tfound = lookup_c_ip(c, ignorepat);\n\t\t\tif (!found && ++which > a->n)\n\t\t\t\tret = ast_strdup(ast_get_context_name(c));\n\t\t}\n\t\tast_free(ignorepat);\n\t\tast_unlock_contexts();\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 953}
{"project": "Asterisk", "target": 0, "func": "static int sched_order_1_cb(const void *data)\n{\n\tsched_order_check((void *) data, 1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 954}
{"project": "Asterisk", "target": 0, "func": "static void on_personality_change_normal(struct ast_bridge *bridge)\n{\n\tstruct ast_bridge_channel *iter;\n\tAST_LIST_TRAVERSE(&bridge->channels, iter, entry) {\n\t\tif (add_normal_hooks(bridge, iter)) {\n\t\t\tast_log(LOG_WARNING, \"Unable to set up bridge hooks for channel %s. Features may not work properly\\n\",\n\t\t\t\t\tast_channel_name(iter->chan));\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 955}
{"project": "Asterisk", "target": 0, "func": "static int handle_recvtext(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])\n{\n\tchar *buf;\n\tif (argc != 3)\n\t\treturn RESULT_SHOWUSAGE;\n\tbuf = ast_recvtext(chan, atoi(argv[2]));\n\tif (buf) {\n\t\tast_agi_send(agi->fd, chan, \"200 result=1 (%s)\\n\", buf);\n\t\tast_free(buf);\n\t} else {\n\t\tast_agi_send(agi->fd, chan, \"200 result=-1\\n\");\n\t}\n\treturn RESULT_SUCCESS;\n}\n", "bug_type": null, "idx": 956}
{"project": "Asterisk", "target": 0, "func": "protected char *\nkey__decode_str(const char *str, char *buf, const char *sep)\n{\n\tchar *b;\n\tconst char *p;\n\tb = buf;\n\tif (sep[0] != '\\0')\n\t\t*b++ = sep[0];\n\tif (*str == 0) {\n\t\t*b++ = '^';\n\t\t*b++ = '@';\n\t\tif (sep[0] != '\\0' && sep[1] != '\\0')\n\t\t\t*b++ = sep[1];\n\t\t*b++ = 0;\n\t\treturn (buf);\n\t}\n\tfor (p = str; *p != 0; p++) {\n\t\tif (iscntrl((unsigned char) *p)) {\n\t\t\t*b++ = '^';\n\t\t\tif (*p == '\\177')\n\t\t\t\t*b++ = '?';\n\t\t\telse\n\t\t\t\t*b++ = *p | 0100;\n\t\t} else if (*p == '^' || *p == '\\\\') {\n\t\t\t*b++ = '\\\\';\n\t\t\t*b++ = *p;\n\t\t} else if (*p == ' ' || (isprint((unsigned char) *p) &&\n\t\t\t!isspace((unsigned char) *p))) {\n\t\t\t*b++ = *p;\n\t\t} else {\n\t\t\t*b++ = '\\\\';\n\t\t\t*b++ = (((unsigned int) *p >> 6) & 7) + '0';\n\t\t\t*b++ = (((unsigned int) *p >> 3) & 7) + '0';\n\t\t\t*b++ = (*p & 7) + '0';\n\t\t}\n\t}\n\tif (sep[0] != '\\0' && sep[1] != '\\0')\n\t\t*b++ = sep[1];\n\t*b++ = 0;\n\treturn (buf);\t\t\n}\n", "bug_type": null, "idx": 957}
{"project": "Asterisk", "target": 0, "func": "static char *dahdi_show_channel(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint channel;\n\tstruct dahdi_pvt *tmp = NULL;\n\tstruct dahdi_confinfo ci;\n\tstruct dahdi_params ps;\n\tint x;\n\tchar hwrxgain[15];\n\tchar hwtxgain[15];\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"dahdi show channel\";\n\t\te->usage =\n\t\t\t\"Usage: dahdi show channel <chan num>\\n\"\n\t\t\t\"\tDetailed information about a given channel\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4)\n\t\treturn CLI_SHOWUSAGE;\n\tchannel = atoi(a->argv[3]);\n\tast_mutex_lock(&iflock);\n\tfor (tmp = iflist; tmp; tmp = tmp->next) {\n\t\tif (tmp->channel == channel) {\n\t\t\tast_cli(a->fd, \"Channel: %d\\n\", tmp->channel);\n\t\t\tast_cli(a->fd, \"Description: %s\\n\", tmp->description);\n\t\t\tast_cli(a->fd, \"File Descriptor: %d\\n\", tmp->subs[SUB_REAL].dfd);\n\t\t\tast_cli(a->fd, \"Span: %d\\n\", tmp->span);\n\t\t\tast_cli(a->fd, \"Extension: %s\\n\", tmp->exten);\n\t\t\tast_cli(a->fd, \"Dialing: %s\\n\", tmp->dialing ? \"yes\" : \"no\");\n\t\t\tast_cli(a->fd, \"Context: %s\\n\", tmp->context);\n\t\t\tast_cli(a->fd, \"Caller ID: %s\\n\", tmp->cid_num);\n\t\t\tast_cli(a->fd, \"Calling TON: %d\\n\", tmp->cid_ton);\n#if defined(HAVE_PRI)\n#if defined(HAVE_PRI_SUBADDR)\n\t\t\tast_cli(a->fd, \"Caller ID subaddress: %s\\n\", tmp->cid_subaddr);\n#endif\t\n#endif\t\n\t\t\tast_cli(a->fd, \"Caller ID name: %s\\n\", tmp->cid_name);\n\t\t\tast_cli(a->fd, \"Mailbox: %s\\n\", S_OR(tmp->mailbox, \"none\"));\n\t\t\tif (tmp->vars) {\n\t\t\t\tstruct ast_variable *v;\n\t\t\t\tast_cli(a->fd, \"Variables:\\n\");\n\t\t\t\tfor (v = tmp->vars ; v ; v = v->next)\n\t\t\t\t\tast_cli(a->fd, \"       %s = %s\\n\", v->name, v->value);\n\t\t\t}\n\t\t\tast_cli(a->fd, \"Destroy: %d\\n\", tmp->destroy);\n\t\t\tast_cli(a->fd, \"InAlarm: %d\\n\", tmp->inalarm);\n\t\t\tast_cli(a->fd, \"Signalling Type: %s\\n\", sig2str(tmp->sig));\n\t\t\tast_cli(a->fd, \"Radio: %d\\n\", tmp->radio);\n\t\t\tast_cli(a->fd, \"Owner: %s\\n\", tmp->owner ? ast_channel_name(tmp->owner) : \"<None>\");\n\t\t\tast_cli(a->fd, \"Real: %s%s%s\\n\", tmp->subs[SUB_REAL].owner ? ast_channel_name(tmp->subs[SUB_REAL].owner) : \"<None>\", tmp->subs[SUB_REAL].inthreeway ? \" (Confed)\" : \"\", tmp->subs[SUB_REAL].linear ? \" (Linear)\" : \"\");\n\t\t\tast_cli(a->fd, \"Callwait: %s%s%s\\n\", tmp->subs[SUB_CALLWAIT].owner ? ast_channel_name(tmp->subs[SUB_CALLWAIT].owner) : \"<None>\", tmp->subs[SUB_CALLWAIT].inthreeway ? \" (Confed)\" : \"\", tmp->subs[SUB_CALLWAIT].linear ? \" (Linear)\" : \"\");\n\t\t\tast_cli(a->fd, \"Threeway: %s%s%s\\n\", tmp->subs[SUB_THREEWAY].owner ? ast_channel_name(tmp->subs[SUB_THREEWAY].owner) : \"<None>\", tmp->subs[SUB_THREEWAY].inthreeway ? \" (Confed)\" : \"\", tmp->subs[SUB_THREEWAY].linear ? \" (Linear)\" : \"\");\n\t\t\tast_cli(a->fd, \"Confno: %d\\n\", tmp->confno);\n\t\t\tast_cli(a->fd, \"Propagated Conference: %d\\n\", tmp->propconfno);\n\t\t\tast_cli(a->fd, \"Real in conference: %d\\n\", tmp->inconference);\n\t\t\tast_cli(a->fd, \"DSP: %s\\n\", tmp->dsp ? \"yes\" : \"no\");\n\t\t\tast_cli(a->fd, \"Busy Detection: %s\\n\", tmp->busydetect ? \"yes\" : \"no\");\n\t\t\tif (tmp->busydetect) {\n#if defined(BUSYDETECT_TONEONLY)\n\t\t\t\tast_cli(a->fd, \"    Busy Detector Helper: BUSYDETECT_TONEONLY\\n\");\n#elif defined(BUSYDETECT_COMPARE_TONE_AND_SILENCE)\n\t\t\t\tast_cli(a->fd, \"    Busy Detector Helper: BUSYDETECT_COMPARE_TONE_AND_SILENCE\\n\");\n#endif\n#ifdef BUSYDETECT_DEBUG\n\t\t\t\tast_cli(a->fd, \"    Busy Detector Debug: Enabled\\n\");\n#endif\n\t\t\t\tast_cli(a->fd, \"    Busy Count: %d\\n\", tmp->busycount);\n\t\t\t\tast_cli(a->fd, \"    Busy Pattern: %d,%d,%d,%d\\n\", tmp->busy_cadence.pattern[0], tmp->busy_cadence.pattern[1], (tmp->busy_cadence.length == 4) ? tmp->busy_cadence.pattern[2] : 0, (tmp->busy_cadence.length == 4) ? tmp->busy_cadence.pattern[3] : 0);\n\t\t\t}\n\t\t\tast_cli(a->fd, \"TDD: %s\\n\", tmp->tdd ? \"yes\" : \"no\");\n\t\t\tast_cli(a->fd, \"Relax DTMF: %s\\n\", tmp->dtmfrelax ? \"yes\" : \"no\");\n\t\t\tast_cli(a->fd, \"Dialing/CallwaitCAS: %d/%d\\n\", tmp->dialing, tmp->callwaitcas);\n\t\t\tast_cli(a->fd, \"Default law: %s\\n\", tmp->law_default == DAHDI_LAW_MULAW ? \"ulaw\" : tmp->law_default == DAHDI_LAW_ALAW ? \"alaw\" : \"unknown\");\n\t\t\tast_cli(a->fd, \"Fax Handled: %s\\n\", tmp->faxhandled ? \"yes\" : \"no\");\n\t\t\tast_cli(a->fd, \"Pulse phone: %s\\n\", tmp->pulsedial ? \"yes\" : \"no\");\n\t\t\tif (tmp->hwrxgain_enabled) {\n\t\t\t\tsnprintf(hwrxgain, sizeof(hwrxgain), \"%.1f\", tmp->hwrxgain);\n\t\t\t} else {\n\t\t\t\tast_copy_string(hwrxgain, \"Disabled\", sizeof(hwrxgain));\n\t\t\t}\n\t\t\tif (tmp->hwtxgain_enabled) {\n\t\t\t\tsnprintf(hwtxgain, sizeof(hwtxgain), \"%.1f\", tmp->hwtxgain);\n\t\t\t} else {\n\t\t\t\tast_copy_string(hwtxgain, \"Disabled\", sizeof(hwtxgain));\n\t\t\t}\n\t\t\tast_cli(a->fd, \"HW Gains (RX/TX): %s/%s\\n\", hwrxgain, hwtxgain);\n\t\t\tast_cli(a->fd, \"SW Gains (RX/TX): %.2f/%.2f\\n\", tmp->rxgain, tmp->txgain);\n\t\t\tast_cli(a->fd, \"Dynamic Range Compression (RX/TX): %.2f/%.2f\\n\", tmp->rxdrc, tmp->txdrc);\n\t\t\tast_cli(a->fd, \"DND: %s\\n\", dahdi_dnd(tmp, -1) ? \"yes\" : \"no\");\n\t\t\tast_cli(a->fd, \"Echo Cancellation:\\n\");\n\t\t\tif (tmp->echocancel.head.tap_length) {\n\t\t\t\tast_cli(a->fd, \"\\t%u taps\\n\", tmp->echocancel.head.tap_length);\n\t\t\t\tfor (x = 0; x < tmp->echocancel.head.param_count; x++) {\n\t\t\t\t\tast_cli(a->fd, \"\\t\\t%s: %dd\\n\", tmp->echocancel.params[x].name, tmp->echocancel.params[x].value);\n\t\t\t\t}\n\t\t\t\tast_cli(a->fd, \"\\t%scurrently %s\\n\", tmp->echocanbridged ? \"\" : \"(unless TDM bridged) \", tmp->echocanon ? \"ON\" : \"OFF\");\n\t\t\t} else {\n\t\t\t\tast_cli(a->fd, \"\\tnone\\n\");\n\t\t\t}\n\t\t\tast_cli(a->fd, \"Wait for dialtone: %dms\\n\", tmp->waitfordialtone);\n\t\t\tif (tmp->master)\n\t\t\t\tast_cli(a->fd, \"Master Channel: %d\\n\", tmp->master->channel);\n\t\t\tfor (x = 0; x < MAX_SLAVES; x++) {\n\t\t\t\tif (tmp->slaves[x])\n\t\t\t\t\tast_cli(a->fd, \"Slave Channel: %d\\n\", tmp->slaves[x]->channel);\n\t\t\t}\n#ifdef HAVE_OPENR2\n\t\t\tif (tmp->mfcr2) {\n\t\t\t\tchar calldir[OR2_MAX_PATH];\n\t\t\t\topenr2_context_t *r2context = openr2_chan_get_context(tmp->r2chan);\n\t\t\t\topenr2_variant_t r2variant = openr2_context_get_variant(r2context);\n\t\t\t\tast_cli(a->fd, \"MFC/R2 MF State: %s\\n\", openr2_chan_get_mf_state_string(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 MF Group: %s\\n\", openr2_chan_get_mf_group_string(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 State: %s\\n\", openr2_chan_get_r2_state_string(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Call State: %s\\n\", openr2_chan_get_call_state_string(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Call Files Enabled: %s\\n\", openr2_chan_get_call_files_enabled(tmp->r2chan) ? \"Yes\" : \"No\");\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Variant: %s\\n\", openr2_proto_get_variant_string(r2variant));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Max ANI: %d\\n\", openr2_context_get_max_ani(r2context));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Max DNIS: %d\\n\", openr2_context_get_max_dnis(r2context));\n#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 2\n\t\t\t\tast_cli(a->fd, \"MFC/R2 DTMF Dialing: %s\\n\", openr2_context_get_dtmf_dialing(r2context, NULL, NULL) ? \"Yes\" : \"No\");\n\t\t\t\tast_cli(a->fd, \"MFC/R2 DTMF Detection: %s\\n\", openr2_context_get_dtmf_detection(r2context) ? \"Yes\" : \"No\");\n#endif\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Get ANI First: %s\\n\", openr2_context_get_ani_first(r2context) ? \"Yes\" : \"No\");\n#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 1\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Skip Category Request: %s\\n\", openr2_context_get_skip_category_request(r2context) ? \"Yes\" : \"No\");\n#endif\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Immediate Accept: %s\\n\", openr2_context_get_immediate_accept(r2context) ? \"Yes\" : \"No\");\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Accept on Offer: %s\\n\", tmp->mfcr2_accept_on_offer ? \"Yes\" : \"No\");\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Charge Calls: %s\\n\", tmp->mfcr2_charge_calls ? \"Yes\" : \"No\");\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Allow Collect Calls: %s\\n\", tmp->mfcr2_allow_collect_calls ? \"Yes\" : \"No\");\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Forced Release: %s\\n\", tmp->mfcr2_forced_release ? \"Yes\" : \"No\");\n\t\t\t\tast_cli(a->fd, \"MFC/R2 MF Back Timeout: %dms\\n\", openr2_context_get_mf_back_timeout(r2context));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 R2 Metering Pulse Timeout: %dms\\n\", openr2_context_get_metering_pulse_timeout(r2context));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Rx CAS: %s\\n\", openr2_chan_get_rx_cas_string(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Tx CAS: %s\\n\", openr2_chan_get_tx_cas_string(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 MF Tx Signal: %d\\n\", openr2_chan_get_tx_mf_signal(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 MF Rx Signal: %d\\n\", openr2_chan_get_rx_mf_signal(tmp->r2chan));\n\t\t\t\tast_cli(a->fd, \"MFC/R2 Call Files Directory: %s\\n\", openr2_context_get_log_directory(r2context, calldir, sizeof(calldir)));\n\t\t\t}\n#endif\n#if defined(HAVE_SS7)\n\t\t\tif (tmp->ss7) {\n\t\t\t\tstruct sig_ss7_chan *chan = tmp->sig_pvt;\n\t\t\t\tast_cli(a->fd, \"CIC: %d\\n\", chan->cic);\n\t\t\t}\n#endif\t\n#ifdef HAVE_PRI\n\t\t\tif (tmp->pri) {\n\t\t\t\tstruct sig_pri_chan *chan = tmp->sig_pvt;\n\t\t\t\tast_cli(a->fd, \"PRI Flags: \");\n\t\t\t\tif (chan->resetting != SIG_PRI_RESET_IDLE) {\n\t\t\t\t\tast_cli(a->fd, \"Resetting=%u \", chan->resetting);\n\t\t\t\t}\n\t\t\t\tif (chan->call)\n\t\t\t\t\tast_cli(a->fd, \"Call \");\n\t\t\t\tif (chan->allocated) {\n\t\t\t\t\tast_cli(a->fd, \"Allocated \");\n\t\t\t\t}\n\t\t\t\tast_cli(a->fd, \"\\n\");\n\t\t\t\tif (tmp->logicalspan)\n\t\t\t\t\tast_cli(a->fd, \"PRI Logical Span: %d\\n\", tmp->logicalspan);\n\t\t\t\telse\n\t\t\t\t\tast_cli(a->fd, \"PRI Logical Span: Implicit\\n\");\n\t\t\t}\n#endif\n\t\t\tmemset(&ci, 0, sizeof(ci));\n\t\t\tps.channo = tmp->channel;\n\t\t\tif (tmp->subs[SUB_REAL].dfd > -1) {\n\t\t\t\tmemset(&ci, 0, sizeof(ci));\n\t\t\t\tif (!ioctl(tmp->subs[SUB_REAL].dfd, DAHDI_GETCONF, &ci)) {\n\t\t\t\t\tast_cli(a->fd, \"Actual Confinfo: Num/%d, Mode/0x%04x\\n\", ci.confno, (unsigned)ci.confmode);\n\t\t\t\t}\n\t\t\t\tif (!ioctl(tmp->subs[SUB_REAL].dfd, DAHDI_GETCONFMUTE, &x)) {\n\t\t\t\t\tast_cli(a->fd, \"Actual Confmute: %s\\n\", x ? \"Yes\" : \"No\");\n\t\t\t\t}\n\t\t\t\tmemset(&ps, 0, sizeof(ps));\n\t\t\t\tif (ioctl(tmp->subs[SUB_REAL].dfd, DAHDI_GET_PARAMS, &ps) < 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Failed to get parameters on channel %d: %s\\n\", tmp->channel, strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tast_cli(a->fd, \"Hookstate (FXS only): %s\\n\", ps.rxisoffhook ? \"Offhook\" : \"Onhook\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iflock);\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t}\n\tast_mutex_unlock(&iflock);\n\tast_cli(a->fd, \"Unable to find given channel %d\\n\", channel);\n\treturn CLI_FAILURE;\n}\n", "bug_type": null, "idx": 958}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct rbtree_node *rb_ao2_new_node(struct ao2_container_rbtree *self, void *obj_new, const char *tag, const char *file, int line, const char *func)\n{\n\tstruct rbtree_node *node;\n\tnode = ao2_t_alloc_options(sizeof(*node), rb_ao2_node_destructor, AO2_ALLOC_OPT_LOCK_NOLOCK, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\t__ao2_ref(obj_new, +1, tag ?: \"Container node creation\", file, line, func);\n\tnode->common.obj = obj_new;\n\tnode->common.my_container = (struct ao2_container *) self;\n\treturn node;\n}\n", "bug_type": null, "idx": 959}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int test_traversal_nonsorted(int res, int tst_num, enum test_container_type type, struct ast_test *test)\n{\n\tstruct ao2_container *c1;\n\tstruct ao2_container *c2 = NULL;\n\tint partial;\n\tint destructor_count = 0;\n\t\n\tstatic const int test_initial[] = {\n\t\t1, 0, 2, 6, 4, 7, 5, 3, 9, 8\n\t};\n\t\n\tstatic const int test_reverse[] = {\n\t\t8, 9, 3, 5, 7, 4, 6, 2, 0, 1\n\t};\n\tstatic const int test_list_partial_forward[] = {\n\t\t6, 7, 5\n\t};\n\tstatic const int test_list_partial_backward[] = {\n\t\t5, 7, 6\n\t};\n\t\n\tstatic const int test_hash_end_forward[] = {\n\t\t0, 5, 1, 6, 2, 7, 3, 8, 4, 9\n\t};\n\tstatic const int test_hash_end_backward[] = {\n\t\t9, 4, 8, 3, 7, 2, 6, 1, 5, 0\n\t};\n\tstatic const int test_hash_begin_forward[] = {\n\t\t5, 0, 6, 1, 7, 2, 8, 3, 9, 4\n\t};\n\tstatic const int test_hash_begin_backward[] = {\n\t\t4, 9, 3, 8, 2, 7, 1, 6, 0, 5\n\t};\n\tstatic const int test_hash_partial_forward[] = {\n\t\t5, 6, 7\n\t};\n\tstatic const int test_hash_partial_backward[] = {\n\t\t7, 6, 5\n\t};\n\tast_test_status_update(test, \"Test %d, %s containers.\\n\",\n\t\ttst_num, test_container2str(type));\n\t\n\tc1 = test_make_nonsorted(type, 0);\n\tif (!c1) {\n\t\tast_test_status_update(test, \"Container c1 creation failed.\\n\");\n\t\tres = AST_TEST_FAIL;\n\t\tgoto test_cleanup;\n\t}\n\tif (insert_test_vector(c1, &destructor_count, test_initial, ARRAY_LEN(test_initial), \"c1\", test)) {\n\t\tres = AST_TEST_FAIL;\n\t\tgoto test_cleanup;\n\t}\n\t\n\tc2 = test_make_nonsorted(type, AO2_CONTAINER_ALLOC_OPT_INSERT_BEGIN);\n\tif (!c2) {\n\t\tast_test_status_update(test, \"Container c2 creation failed.\\n\");\n\t\tres = AST_TEST_FAIL;\n\t\tgoto test_cleanup;\n\t}\n\tif (insert_test_vector(c2, &destructor_count, test_initial, ARRAY_LEN(test_initial), \"c2\", test)) {\n\t\tres = AST_TEST_FAIL;\n\t\tgoto test_cleanup;\n\t}\n\t\n\tswitch (type) {\n\tcase TEST_CONTAINER_LIST:\n\t\tres = test_ao2_iteration(res, c1, 0,\n\t\t\ttest_initial, ARRAY_LEN(test_initial),\n\t\t\t\"Iteration (ascending, insert end)\", test);\n\t\tres = test_ao2_iteration(res, c1, AO2_ITERATOR_DESCENDING,\n\t\t\ttest_reverse, ARRAY_LEN(test_reverse),\n\t\t\t\"Iteration (descending, insert end)\", test);\n\t\tres = test_ao2_iteration(res, c2, 0,\n\t\t\ttest_reverse, ARRAY_LEN(test_reverse),\n\t\t\t\"Iteration (ascending, insert begin)\", test);\n\t\tres = test_ao2_iteration(res, c2, AO2_ITERATOR_DESCENDING,\n\t\t\ttest_initial, ARRAY_LEN(test_initial),\n\t\t\t\"Iteration (descending, insert begin)\", test);\n\t\tbreak;\n\tcase TEST_CONTAINER_HASH:\n\t\tres = test_ao2_iteration(res, c1, 0,\n\t\t\ttest_hash_end_forward, ARRAY_LEN(test_hash_end_forward),\n\t\t\t\"Iteration (ascending, insert end)\", test);\n\t\tres = test_ao2_iteration(res, c1, AO2_ITERATOR_DESCENDING,\n\t\t\ttest_hash_end_backward, ARRAY_LEN(test_hash_end_backward),\n\t\t\t\"Iteration (descending, insert end)\", test);\n\t\tres = test_ao2_iteration(res, c2, 0,\n\t\t\ttest_hash_begin_forward, ARRAY_LEN(test_hash_begin_forward),\n\t\t\t\"Iteration (ascending, insert begin)\", test);\n\t\tres = test_ao2_iteration(res, c2, AO2_ITERATOR_DESCENDING,\n\t\t\ttest_hash_begin_backward, ARRAY_LEN(test_hash_begin_backward),\n\t\t\t\"Iteration (descending, insert begin)\", test);\n\t\tbreak;\n\tcase TEST_CONTAINER_RBTREE:\n\t\tbreak;\n\t}\n\t\n\tswitch (type) {\n\tcase TEST_CONTAINER_LIST:\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_ORDER_ASCENDING, NULL, NULL,\n\t\t\ttest_initial, ARRAY_LEN(test_initial),\n\t\t\t\"Traversal (ascending, insert end)\", test);\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_ORDER_DESCENDING, NULL, NULL,\n\t\t\ttest_reverse, ARRAY_LEN(test_reverse),\n\t\t\t\"Traversal (descending, insert end)\", test);\n\t\tres = test_ao2_callback_traversal(res, c2, OBJ_ORDER_ASCENDING, NULL, NULL,\n\t\t\ttest_reverse, ARRAY_LEN(test_reverse),\n\t\t\t\"Traversal (ascending, insert begin)\", test);\n\t\tres = test_ao2_callback_traversal(res, c2, OBJ_ORDER_DESCENDING, NULL, NULL,\n\t\t\ttest_initial, ARRAY_LEN(test_initial),\n\t\t\t\"Traversal (descending, insert begin)\", test);\n\t\tbreak;\n\tcase TEST_CONTAINER_HASH:\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_ORDER_ASCENDING, NULL, NULL,\n\t\t\ttest_hash_end_forward, ARRAY_LEN(test_hash_end_forward),\n\t\t\t\"Traversal (ascending, insert end)\", test);\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_ORDER_DESCENDING, NULL, NULL,\n\t\t\ttest_hash_end_backward, ARRAY_LEN(test_hash_end_backward),\n\t\t\t\"Traversal (descending, insert end)\", test);\n\t\tres = test_ao2_callback_traversal(res, c2, OBJ_ORDER_ASCENDING, NULL, NULL,\n\t\t\ttest_hash_begin_forward, ARRAY_LEN(test_hash_begin_forward),\n\t\t\t\"Traversal (ascending, insert begin)\", test);\n\t\tres = test_ao2_callback_traversal(res, c2, OBJ_ORDER_DESCENDING, NULL, NULL,\n\t\t\ttest_hash_begin_backward, ARRAY_LEN(test_hash_begin_backward),\n\t\t\t\"Traversal (descending, insert begin)\", test);\n\t\tbreak;\n\tcase TEST_CONTAINER_RBTREE:\n\t\tbreak;\n\t}\n\t\n\tpartial = 6;\n\tpartial_key_match_range = 1;\n\tswitch (type) {\n\tcase TEST_CONTAINER_LIST:\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_PARTIAL_KEY | OBJ_ORDER_ASCENDING,\n\t\t\ttest_cmp_cb, &partial,\n\t\t\ttest_list_partial_forward, ARRAY_LEN(test_list_partial_forward),\n\t\t\t\"Traversal OBJ_PARTIAL_KEY (ascending)\", test);\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_PARTIAL_KEY | OBJ_ORDER_DESCENDING,\n\t\t\ttest_cmp_cb, &partial,\n\t\t\ttest_list_partial_backward, ARRAY_LEN(test_list_partial_backward),\n\t\t\t\"Traversal OBJ_PARTIAL_KEY (descending)\", test);\n\t\tbreak;\n\tcase TEST_CONTAINER_HASH:\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_PARTIAL_KEY | OBJ_ORDER_ASCENDING,\n\t\t\ttest_cmp_cb, &partial,\n\t\t\ttest_hash_partial_forward, ARRAY_LEN(test_hash_partial_forward),\n\t\t\t\"Traversal OBJ_PARTIAL_KEY (ascending)\", test);\n\t\tres = test_ao2_callback_traversal(res, c1, OBJ_PARTIAL_KEY | OBJ_ORDER_DESCENDING,\n\t\t\ttest_cmp_cb, &partial,\n\t\t\ttest_hash_partial_backward, ARRAY_LEN(test_hash_partial_backward),\n\t\t\t\"Traversal OBJ_PARTIAL_KEY (descending)\", test);\n\t\tbreak;\n\tcase TEST_CONTAINER_RBTREE:\n\t\tbreak;\n\t}\ntest_cleanup:\n\t\n\tif (c1) {\n\t\tao2_t_ref(c1, -1, \"bye c1\");\n\t}\n\tif (c2) {\n\t\tao2_t_ref(c2, -1, \"bye c2\");\n\t}\n\tif (destructor_count > 0) {\n\t\tast_test_status_update(test,\n\t\t\t\"all destructors were not called, destructor count is %d\\n\",\n\t\t\tdestructor_count);\n\t\tres = AST_TEST_FAIL;\n\t} else if (destructor_count < 0) {\n\t\tast_test_status_update(test,\n\t\t\t\"Destructor was called too many times, destructor count is %d\\n\",\n\t\t\tdestructor_count);\n\t\tres = AST_TEST_FAIL;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 960}
{"project": "Asterisk", "target": 0, "func": "static int pbx_load_config(const char *config_file);\nstatic int pbx_load_config(const char *config_file)\n{\n\tstruct ast_config *cfg;\n\tchar *end;\n\tchar *label;\n\tchar realvalue[256];\n\tint lastpri = -2;\n\tstruct ast_context *con;\n\tstruct ast_variable *v;\n\tconst char *cxt;\n\tconst char *aft;\n\tcfg = localized_config_load(config_file);\n\tif (!cfg)\n\t\treturn 0;\n\t\n\tstatic_config = ast_true(ast_variable_retrieve(cfg, \"general\", \"static\"));\n\twrite_protect_config = ast_true(ast_variable_retrieve(cfg, \"general\", \"writeprotect\"));\n\tif ((aft = ast_variable_retrieve(cfg, \"general\", \"autofallthrough\")))\n\t\tautofallthrough_config = ast_true(aft);\n\tclearglobalvars_config = ast_true(ast_variable_retrieve(cfg, \"general\", \"clearglobalvars\"));\n\tif ((cxt = ast_variable_retrieve(cfg, \"general\", \"userscontext\")))\n\t\tast_copy_string(userscontext, cxt, sizeof(userscontext));\n\telse\n\t\tast_copy_string(userscontext, \"default\", sizeof(userscontext));\n\tfor (v = ast_variable_browse(cfg, \"globals\"); v; v = v->next) {\n\t\tmemset(realvalue, 0, sizeof(realvalue));\n\t\tpbx_substitute_variables_helper(NULL, v->value, realvalue, sizeof(realvalue) - 1);\n\t\tpbx_builtin_setvar_helper(NULL, v->name, realvalue);\n\t}\n\tfor (cxt = NULL; (cxt = ast_category_browse(cfg, cxt)); ) {\n\t\t\n\t\tif (!strcasecmp(cxt, \"general\") || !strcasecmp(cxt, \"globals\"))\n\t\t\tcontinue;\n\t\tcon=ast_context_find_or_create(&local_contexts,NULL,cxt, global_registrar);\n\t\tif (con == NULL)\n\t\t\tcontinue;\n\t\tfor (v = ast_variable_browse(cfg, cxt); v; v = v->next) {\n\t\t\tif (!strcasecmp(v->name, \"exten\")) {\n\t\t\t\tchar *tc = ast_strdup(v->value);\n\t\t\t\tif (tc) {\n\t\t\t\t\tint ipri = -2;\n\t\t\t\t\tchar realext[256]=\"\";\n\t\t\t\t\tchar *plus, *firstp, *firstc;\n\t\t\t\t\tchar *pri, *appl, *data, *cidmatch;\n\t\t\t\t\tchar *stringp = tc;\n\t\t\t\t\tchar *ext = strsep(&stringp, \",\");\n\t\t\t\t\tif (!ext)\n\t\t\t\t\t\text=\"\";\n\t\t\t\t\tpbx_substitute_variables_helper(NULL, ext, realext, sizeof(realext) - 1);\n\t\t\t\t\tcidmatch = strchr(realext, '/');\n\t\t\t\t\tif (cidmatch) {\n\t\t\t\t\t\t*cidmatch++ = '\\0';\n\t\t\t\t\t\tast_shrink_phone_number(cidmatch);\n\t\t\t\t\t}\n\t\t\t\t\tpri = strsep(&stringp, \",\");\n\t\t\t\t\tif (!pri)\n\t\t\t\t\t\tpri=\"\";\n\t\t\t\t\tlabel = strchr(pri, '(');\n\t\t\t\t\tif (label) {\n\t\t\t\t\t\t*label++ = '\\0';\n\t\t\t\t\t\tend = strchr(label, ')');\n\t\t\t\t\t\tif (end)\n\t\t\t\t\t\t\t*end = '\\0';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Label missing trailing ')' at line %d\\n\", v->lineno);\n\t\t\t\t\t}\n\t\t\t\t\tplus = strchr(pri, '+');\n\t\t\t\t\tif (plus)\n\t\t\t\t\t\t*plus++ = '\\0';\n\t\t\t\t\tif (!strcmp(pri,\"hint\"))\n\t\t\t\t\t\tipri=PRIORITY_HINT;\n\t\t\t\t\telse if (!strcmp(pri, \"next\") || !strcmp(pri, \"n\")) {\n\t\t\t\t\t\tif (lastpri > -2)\n\t\t\t\t\t\t\tipri = lastpri + 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Can't use 'next' priority on the first entry!\\n\");\n\t\t\t\t\t} else if (!strcmp(pri, \"same\") || !strcmp(pri, \"s\")) {\n\t\t\t\t\t\tif (lastpri > -2)\n\t\t\t\t\t\t\tipri = lastpri;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Can't use 'same' priority on the first entry!\\n\");\n\t\t\t\t\t} else if (sscanf(pri, \"%30d\", &ipri) != 1 &&\n\t\t\t\t\t    (ipri = ast_findlabel_extension2(NULL, con, realext, pri, cidmatch)) < 1) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Invalid priority/label '%s' at line %d\\n\", pri, v->lineno);\n\t\t\t\t\t\tipri = 0;\n\t\t\t\t\t}\n\t\t\t\t\tappl = S_OR(stringp, \"\");\n\t\t\t\t\t\n\t\t\t\t\tfirstc = strchr(appl, ',');\n\t\t\t\t\tfirstp = strchr(appl, '(');\n\t\t\t\t\tif (firstc && (!firstp || firstc < firstp)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tappl = strsep(&stringp, \",\");\n\t\t\t\t\t\tdata = stringp;\n\t\t\t\t\t} else if (!firstc && !firstp) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tdata = \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tappl = strsep(&stringp, \"(\");\n\t\t\t\t\t\tdata = stringp;\n\t\t\t\t\t\tend = strrchr(data, ')');\n\t\t\t\t\t\tif ((end = strrchr(data, ')'))) {\n\t\t\t\t\t\t\t*end = '\\0';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"No closing parenthesis found? '%s(%s'\\n\", appl, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tast_process_quotes_and_slashes(data, ',', '|');\n\t\t\t\t\t}\n\t\t\t\t\tif (!data)\n\t\t\t\t\t\tdata=\"\";\n\t\t\t\t\tappl = ast_skip_blanks(appl);\n\t\t\t\t\tif (ipri) {\n\t\t\t\t\t\tif (plus)\n\t\t\t\t\t\t\tipri += atoi(plus);\n\t\t\t\t\t\tlastpri = ipri;\n\t\t\t\t\t\tif (!ast_opt_dont_warn && !strcmp(realext, \"_.\"))\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"The use of '_.' for an extension is strongly discouraged and can have unexpected behavior.  Please use '_X.' instead at line %d\\n\", v->lineno);\n\t\t\t\t\t\tif (ast_add_extension2(con, 0, realext, ipri, label, cidmatch, appl, strdup(data), ast_free_ptr, global_registrar)) {\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Unable to register extension at line %d\\n\", v->lineno);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(tc);\n\t\t\t\t}\n\t\t\t} else if (!strcasecmp(v->name, \"include\")) {\n\t\t\t\tmemset(realvalue, 0, sizeof(realvalue));\n\t\t\t\tpbx_substitute_variables_helper(NULL, v->value, realvalue, sizeof(realvalue) - 1);\n\t\t\t\tif (ast_context_add_include2(con, realvalue, global_registrar))\n\t\t\t\t\tast_log(LOG_WARNING, \"Unable to include context '%s' in context '%s'\\n\", v->value, cxt);\n\t\t\t} else if (!strcasecmp(v->name, \"ignorepat\")) {\n\t\t\t\tmemset(realvalue, 0, sizeof(realvalue));\n\t\t\t\tpbx_substitute_variables_helper(NULL, v->value, realvalue, sizeof(realvalue) - 1);\n\t\t\t\tif (ast_context_add_ignorepat2(con, realvalue, global_registrar))\n\t\t\t\t\tast_log(LOG_WARNING, \"Unable to include ignorepat '%s' in context '%s'\\n\", v->value, cxt);\n\t\t\t} else if (!strcasecmp(v->name, \"switch\") || !strcasecmp(v->name, \"lswitch\") || !strcasecmp(v->name, \"eswitch\")) {\n\t\t\t\tchar *stringp= realvalue;\n\t\t\t\tchar *appl, *data;\n\t\t\t\tmemset(realvalue, 0, sizeof(realvalue));\n\t\t\t\tif (!strcasecmp(v->name, \"switch\"))\n\t\t\t\t\tpbx_substitute_variables_helper(NULL, v->value, realvalue, sizeof(realvalue) - 1);\n\t\t\t\telse\n\t\t\t\t\tast_copy_string(realvalue, v->value, sizeof(realvalue));\n\t\t\t\tappl = strsep(&stringp, \"/\");\n\t\t\t\tdata = strsep(&stringp, \"\"); \n\t\t\t\tif (!data)\n\t\t\t\t\tdata = \"\";\n\t\t\t\tif (ast_context_add_switch2(con, appl, data, !strcasecmp(v->name, \"eswitch\"), global_registrar))\n\t\t\t\t\tast_log(LOG_WARNING, \"Unable to include switch '%s' in context '%s'\\n\", v->value, cxt);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"==!!== Unknown directive: %s at line %d -- IGNORING!!!\\n\", v->name, v->lineno);\n\t\t\t}\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n\treturn 1;\n}\n", "bug_type": null, "idx": 961}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *cli_channelstats_get_container(const char *regex)\n{\n\treturn get_container(regex, cli_channelstats_sort, cli_channelstats_compare);\n}\n", "bug_type": null, "idx": 962}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int parking_add_extension(struct ast_context *context, int replace, const char *extension,\n\tint priority, const char *application, const char *data, const char *registrar)\n{\n\tchar *data_duplicate = ast_strdup(data);\n\tif (!data_duplicate) {\n\t\treturn -1;\n\t}\n\tif (ast_add_extension2_nolock(context, replace, extension, priority, NULL, NULL,\n\t\t\tapplication, data_duplicate, ast_free_ptr, registrar, NULL, 0)) {\n\t\tast_free(data_duplicate);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 963}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct chan_list *get_chan_by_ast(struct ast_channel *ast)\n{\n\tstruct chan_list *tmp;\n\tast_mutex_lock(&cl_te_lock);\n\tfor (tmp = cl_te; tmp; tmp = tmp->next) {\n\t\tif (tmp->ast == ast) {\n\t\t\tchan_list_ref(tmp, \"Found chan_list by ast\");\n\t\t\tast_mutex_unlock(&cl_te_lock);\n\t\t\treturn tmp;\n\t\t}\n\t}\n\tast_mutex_unlock(&cl_te_lock);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 964}
{"project": "Asterisk", "target": 0, "func": "static int connected_line_method_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\tif (!strcasecmp(var->value, \"invite\") || !strcasecmp(var->value, \"reinvite\")) {\n\t\tendpoint->id.refresh_method = AST_SIP_SESSION_REFRESH_METHOD_INVITE;\n\t} else if (!strcasecmp(var->value, \"update\")) {\n\t\tendpoint->id.refresh_method = AST_SIP_SESSION_REFRESH_METHOD_UPDATE;\n\t} else {\n\t\tast_log(LOG_NOTICE, \"Unrecognized option value %s for %s on endpoint %s\\n\",\n\t\t\t\tvar->value, var->name, ast_sorcery_object_get_id(endpoint));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 965}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225_SeqOfH225DataRate (OOCTXT* pctxt, H225_SeqOfH225DataRate* pvalue)\n{\n   int stat = ASN_OK;\n   DListNode* pnode;\n   ASN1UINT xx1;\n   ASN1UINT enclen, fraglen;\n   enclen = fraglen = xx1 = 0;\n   pnode = pvalue->head;\n   for (;;) {\n      \n      stat = encodeLength (pctxt, (pvalue->count - enclen));\n      if (stat < 0) return stat;\n      fraglen = stat;\n      enclen += fraglen;\n      \n      for (; xx1 < enclen; xx1++) {\n         stat = asn1PE_H225DataRate (pctxt, ((H225DataRate*)pnode->data));\n         if (stat != ASN_OK) return stat;\n         pnode = pnode->next;\n      }\n      if ( pvalue->count == enclen && fraglen < 16384) {\n         break;\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 966}
{"project": "Asterisk", "target": 0, "func": "AST_THREADSTORAGE(desc_storage);\nstatic int idle_sched_cb(const void *data)\n{\n\tstruct monitored_transport *monitored = (struct monitored_transport *) data;\n\tif (!pj_thread_is_registered()) {\n\t\tpj_thread_t *thread;\n\t\tpj_thread_desc *desc;\n\t\tdesc = ast_threadstorage_get(&desc_storage, sizeof(pj_thread_desc));\n\t\tif (!desc) {\n\t\t\tast_log(LOG_ERROR, \"Could not get thread desc from thread-local storage.\\n\");\n\t\t\tao2_ref(monitored, -1);\n\t\t\treturn 0;\n\t\t}\n\t\tpj_bzero(*desc, sizeof(*desc));\n\t\tpj_thread_register(\"Transport Monitor\", *desc, &thread);\n\t}\n\tif (!monitored->sip_received) {\n\t\tast_log(LOG_NOTICE, \"Shutting down transport '%s' since no request was received in %d seconds\\n\",\n\t\t\tmonitored->transport->info, IDLE_TIMEOUT / 1000);\n\t\tpjsip_transport_shutdown(monitored->transport);\n\t}\n\tao2_ref(monitored, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 967}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_endpoint *ast_sip_get_artificial_endpoint(void)\n{\n\tao2_ref(artificial_endpoint, +1);\n\treturn artificial_endpoint;\n}\n", "bug_type": null, "idx": 968}
{"project": "Asterisk", "target": 0, "func": "void stasis_message_router_publish_sync(struct stasis_message_router *router,\n\tstruct stasis_message *message)\n{\n\tast_assert(router != NULL);\n\tao2_bump(router);\n\tstasis_publish_sync(router->subscription, message);\n\tao2_cleanup(router);\n}\n", "bug_type": null, "idx": 969}
{"project": "Asterisk", "target": 0, "func": "static int cli_print_header(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_cli_context *context = arg;\n\tint indent = CLI_INDENT_TO_SPACES(context->indent_level);\n\tint filler = CLI_MAX_WIDTH - indent - 22;\n\tast_assert(context->output_buffer != NULL);\n\tast_str_append(&context->output_buffer, 0,\n\t\t\"%*s:  <Identify/Endpoint%*.*s>\\n\",\n\t\tindent, \"Identify\", filler, filler, CLI_HEADER_FILLER);\n\tif (context->recurse) {\n\t\tcontext->indent_level++;\n\t\tindent = CLI_INDENT_TO_SPACES(context->indent_level);\n\t\tfiller = CLI_LAST_TABSTOP - indent - 24;\n\t\tast_str_append(&context->output_buffer, 0,\n\t\t\t\"%*s:  <criteria%*.*s>\\n\",\n\t\t\tindent, \"Match\", filler, filler, CLI_HEADER_FILLER);\n\t\tcontext->indent_level--;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 970}
{"project": "Asterisk", "target": 0, "func": "static int csv_log(struct ast_cdr *cdr)\n{\n\t\n\tchar buf[1024];\n\tif (build_csv_record(buf, sizeof(buf), cdr)) {\n\t\tast_log(LOG_WARNING, \"Unable to create CSV record in %d bytes.  CDR not recorded!\\n\", (int)sizeof(buf));\n\t\treturn 0;\n\t}\n\tast_mutex_lock(&f_lock);\n\tif (writefile(buf, file_csv_master))\n\t\tast_log(LOG_WARNING, \"Unable to write CSV record to master '%s' : %s\\n\", file_csv_master, strerror(errno));\n\tif (accountlogs && !ast_strlen_zero(cdr->accountcode)) {\n\t\tif (writefile_account(buf, cdr->accountcode))\n\t\t\tast_log(LOG_WARNING, \"Unable to write CSV record to account file '%s' : %s\\n\", cdr->accountcode, strerror(errno));\n\t}\n\tast_mutex_unlock(&f_lock);\n\treturn 0;\n}\n", "bug_type": null, "idx": 971}
{"project": "Asterisk", "target": 0, "func": "};\nstatic SQLHSTMT update2_prepare(struct odbc_obj *obj, void *data)\n{\n\tint res, x = 1, first = 1;\n\tstruct update2_prepare_struct *ups = data;\n\tconst struct ast_variable *field;\n\tstruct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);\n\tSQLHSTMT stmt;\n\tstruct odbc_cache_tables *tableptr;\n\tif (!sql) {\n\t\treturn NULL;\n\t}\n\ttableptr = ast_odbc_find_table(ups->database, ups->table);\n\tif (!tableptr) {\n\t\tast_log(LOG_ERROR, \"Could not retrieve metadata for table '%s@%s'.  Update will fail!\\n\", ups->table, ups->database);\n\t\treturn NULL;\n\t}\n\tres = SQLAllocHandle(SQL_HANDLE_STMT, obj->con, &stmt);\n\tif ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {\n\t\tast_log(LOG_WARNING, \"SQL Alloc Handle failed!\\n\");\n\t\tast_odbc_release_table(tableptr);\n\t\treturn NULL;\n\t}\n\tast_str_set(&sql, 0, \"UPDATE %s SET \", ups->table);\n\tfor (field = ups->update_fields; field; field = field->next) {\n\t\tif (ast_odbc_find_column(tableptr, field->name)) {\n\t\t\tast_str_append(&sql, 0, \"%s%s=? \", first ? \"\" : \", \", field->name);\n\t\t\tSQLBindParameter(stmt, x++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, strlen(field->name), 0, (void *)field->value, 0, NULL);\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tast_log(LOG_NOTICE, \"Not updating column '%s' in '%s@%s' because that column does not exist!\\n\", field->name, ups->table, ups->database);\n\t\t}\n\t}\n\tast_str_append(&sql, 0, \"WHERE\");\n\tfirst = 1;\n\tfor (field = ups->lookup_fields; field; field = field->next) {\n\t\tif (!ast_odbc_find_column(tableptr, field->name)) {\n\t\t\tast_log(LOG_ERROR, \"One or more of the criteria columns '%s' on '%s@%s' for this update does not exist!\\n\", field->name, ups->table, ups->database);\n\t\t\tast_odbc_release_table(tableptr);\n\t\t\tSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n\t\t\treturn NULL;\n\t\t}\n\t\tast_str_append(&sql, 0, \"%s %s=?\", first ? \"\" : \" AND\", field->name);\n\t\tSQLBindParameter(stmt, x++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, strlen(field->value), 0, (void *)field->value, 0, NULL);\n\t\tfirst = 0;\n\t}\n\t\n\tast_odbc_release_table(tableptr);\n\tres = SQLPrepare(stmt, (unsigned char *)ast_str_buffer(sql), SQL_NTS);\n\tif ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {\n\t\tast_log(LOG_WARNING, \"SQL Prepare failed! [%s]\\n\", ast_str_buffer(sql));\n\t\tSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n\t\treturn NULL;\n\t}\n\treturn stmt;\n}\n", "bug_type": null, "idx": 972}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_channel_unhold(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_type = 0;\n\tint has_application = 0;\n\tint has_channel = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"asterisk_id\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold field asterisk_id failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"type\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_type = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold field type failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"application\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_application = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold field application failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"timestamp\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_date(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold field timestamp failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"channel\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_channel = 1;\n\t\t\tprop_is_valid = ast_ari_validate_channel(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold field channel failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI ChannelUnhold has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_type) {\n\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold missing required field type\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_application) {\n\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold missing required field application\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_channel) {\n\t\tast_log(LOG_ERROR, \"ARI ChannelUnhold missing required field channel\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 973}
{"project": "Asterisk", "target": 0, "func": " */\nvoid __ast_mm_init_phase_1(void)\n{\n\tatexit(mm_atexit_final);\n}\n", "bug_type": null, "idx": 974}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int bridge_basic_setup_features(struct ast_bridge_channel *bridge_channel)\n{\n\tint res = 0;\n\tres |= setup_bridge_features_builtin(bridge_channel->features, bridge_channel->chan);\n\tres |= setup_bridge_features_dynamic(bridge_channel->features, bridge_channel->chan);\n\treturn res;\n}\n", "bug_type": null, "idx": 975}
{"project": "Asterisk", "target": 1, "func": "static int handle_request_invite(struct sip_pvt *p, struct sip_request *req, int debug, uint32_t seqno, struct ast_sockaddr *addr, int *recount, const char *e, int *nounlock)\n{\n\tint res = 1;\n\tint gotdest;\n\tconst char *p_replaces;\n\tchar *replace_id = NULL;\n\tint refer_locked = 0;\n\tconst char *required;\n\tunsigned int required_profile = 0;\n\tstruct ast_channel *c = NULL;\t\t\n\tstruct sip_peer *authpeer = NULL;\t\n\tint reinvite = 0;\n\tint rtn;\n\tstruct ast_party_redirecting redirecting;\n\tstruct ast_set_party_redirecting update_redirecting;\n\tconst char *p_uac_se_hdr;       \n\tconst char *p_uac_min_se;       \n\tint uac_max_se = -1;            \n\tint uac_min_se = -1;            \n\tint st_active = FALSE;          \n\tint st_interval = 0;            \n\tenum st_refresher st_ref;       \n\tint dlg_min_se = -1;\n\tstruct {\n\t\tchar exten[AST_MAX_EXTENSION];\n\t\tchar context[AST_MAX_CONTEXT];\n\t} pickup = {\n\t\t\t.exten = \"\",\n\t};\n\tst_ref = SESSION_TIMER_REFRESHER_AUTO;\n\t\n\tif (!p->sipoptions) {\n\t\tconst char *supported = get_header(req, \"Supported\");\n\t\tif (!ast_strlen_zero(supported)) {\n\t\t\tp->sipoptions = parse_sip_options(supported, NULL, 0);\n\t\t}\n\t}\n\t\n\trequired = get_header(req, \"Require\");\n\tif (!ast_strlen_zero(required)) {\n\t\tchar unsupported[256] = { 0, };\n\t\trequired_profile = parse_sip_options(required, unsupported, ARRAY_LEN(unsupported));\n\t\t\n\t\tif (!ast_strlen_zero(unsupported)) {\n\t\t\ttransmit_response_with_unsupported(p, \"420 Bad extension (unsupported)\", req, unsupported);\n\t\t\tast_log(LOG_WARNING, \"Received SIP INVITE with unsupported required extension: required:%s unsupported:%s\\n\", required, unsupported);\n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tif (!p->lastinvite)\n\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\tres = -1;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t}\n\t\n\tp->sipoptions |= required_profile;\n\tp->reqsipoptions = required_profile;\n\t\n\tif (ast_test_flag(&p->flags[0], SIP_OUTGOING) && p->owner && (p->invitestate != INV_TERMINATED && p->invitestate != INV_CONFIRMED) && p->owner->_state != AST_STATE_UP) {\n\t\t\n\t\t\n\t\tint different;\n\t\tconst char *initial_rlPart2 = REQ_OFFSET_TO_STR(&p->initreq, rlPart2);\n\t\tconst char *this_rlPart2 = REQ_OFFSET_TO_STR(req, rlPart2);\n\t\tif (sip_cfg.pedanticsipchecking)\n\t\t\tdifferent = sip_uri_cmp(initial_rlPart2, this_rlPart2);\n\t\telse\n\t\t\tdifferent = strcmp(initial_rlPart2, this_rlPart2);\n\t\tif (!different) {\n\t\t\ttransmit_response(p, \"482 Loop Detected\", req);\n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t} else {\n\t\t\t\n\t\t\tchar *uri = ast_strdupa(this_rlPart2);\n\t\t\tchar *at = strchr(uri, '@');\n\t\t\tchar *peerorhost;\n\t\t\tast_debug(2, \"Potential spiral detected. Original RURI was %s, new RURI is %s\\n\", initial_rlPart2, this_rlPart2);\n\t\t\ttransmit_response(p, \"100 Trying\", req);\n\t\t\tif (at) {\n\t\t\t\t*at = '\\0';\n\t\t\t}\n\t\t\t\n\t\t\tif ((peerorhost = strchr(uri, ':'))) {\n\t\t\t\t*peerorhost++ = '\\0';\n\t\t\t}\n\t\t\tast_string_field_set(p, theirtag, NULL);\n\t\t\t\n\t\t\tast_string_field_set(p->owner, call_forward, peerorhost);\n\t\t\tast_queue_control(p->owner, AST_CONTROL_BUSY);\n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t}\n\tif (!req->ignore && p->pendinginvite) {\n\t\tif (!ast_test_flag(&p->flags[0], SIP_OUTGOING) && (p->invitestate == INV_COMPLETED || p->invitestate == INV_TERMINATED)) {\n\t\t\t\n\t\t\t__sip_ack(p, p->pendinginvite, 1, 0);\n\t\t} else {\n\t\t\t\n\t\t\tp->glareinvite = seqno;\n\t\t\tif (p->rtp && find_sdp(req)) {\n\t\t\t\tstruct ast_sockaddr addr;\n\t\t\t\tif (get_ip_and_port_from_sdp(req, SDP_AUDIO, &addr)) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Failed to set an alternate media source on glared reinvite. Audio may not work properly on this call.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_alt_remote_address(p->rtp, &addr);\n\t\t\t\t}\n\t\t\t\tif (p->vrtp) {\n\t\t\t\t\tif (get_ip_and_port_from_sdp(req, SDP_VIDEO, &addr)) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Failed to set an alternate media source on glared reinvite. Video may not work properly on this call.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_rtp_instance_set_alt_remote_address(p->vrtp, &addr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttransmit_response_reliable(p, \"491 Request Pending\", req);\n\t\t\tcheck_via(p, req);\n\t\t\tast_debug(1, \"Got INVITE on call where we already have pending INVITE, deferring that - %s\\n\", p->callid);\n\t\t\t\n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t}\n\tp_replaces = get_header(req, \"Replaces\");\n\tif (!ast_strlen_zero(p_replaces)) {\n\t\t\n\t\tchar *ptr;\n\t\tchar *fromtag = NULL;\n\t\tchar *totag = NULL;\n\t\tchar *start, *to;\n\t\tint error = 0;\n\t\tif (p->owner) {\n\t\t\tast_debug(3, \"INVITE w Replaces on existing call? Refusing action. [%s]\\n\", p->callid);\n\t\t\ttransmit_response_reliable(p, \"400 Bad request\", req);\t\n\t\t\tcheck_via(p, req);\n\t\t\tcopy_request(&p->initreq, req);\n\t\t\t\n\t\t\tres = -1;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t\tif (sipdebug)\n\t\t\tast_debug(3, \"INVITE part of call transfer. Replaces [%s]\\n\", p_replaces);\n\t\t\n\t\treplace_id = ast_strdupa(p_replaces);\n\t\tast_uri_decode(replace_id);\n\t\tif (!p->refer && !sip_refer_allocate(p)) {\n\t\t\ttransmit_response_reliable(p, \"500 Server Internal Error\", req);\n\t\t\tappend_history(p, \"Xfer\", \"INVITE/Replace Failed. Out of memory.\");\n\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tcheck_via(p, req);\n\t\t\tcopy_request(&p->initreq, req);\n\t\t\tres = -1;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t\t\n\t\t\n\t\treplace_id = ast_skip_blanks(replace_id);\n\t\tstart = replace_id;\n\t\twhile ( (ptr = strsep(&start, \";\")) ) {\n\t\t\tptr = ast_skip_blanks(ptr); \n\t\t\tif ( (to = strcasestr(ptr, \"to-tag=\") ) )\n\t\t\t\ttotag = to + 7;\t\n\t\t\telse if ( (to = strcasestr(ptr, \"from-tag=\") ) ) {\n\t\t\t\tfromtag = to + 9;\t\n\t\t\t\tfromtag = strsep(&fromtag, \"&\"); \n\t\t\t}\n\t\t}\n\t\tif (sipdebug)\n\t\t\tast_debug(4, \"Invite/replaces: Will use Replace-Call-ID : %s Fromtag: %s Totag: %s\\n\",\n\t\t\t\t\t  replace_id,\n\t\t\t\t\t  fromtag ? fromtag : \"<no from tag>\",\n\t\t\t\t\t  totag ? totag : \"<no to tag>\");\n\t\t\n\t\tif (strncmp(replace_id, \"pickup-\", 7) == 0) {\n\t\t\tstruct sip_pvt *subscription = NULL;\n\t\t\treplace_id += 7; \n\t\t\tif ((subscription = get_sip_pvt_byid_locked(replace_id, totag, fromtag)) == NULL) {\n\t\t\t\tast_log(LOG_NOTICE, \"Unable to find subscription with call-id: %s\\n\", replace_id);\n\t\t\t\ttransmit_response_reliable(p, \"481 Call Leg Does Not Exist (Replaces)\", req);\n\t\t\t\terror = 1;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_NOTICE, \"Trying to pick up %s@%s\\n\", subscription->exten, subscription->context);\n\t\t\t\tast_copy_string(pickup.exten, subscription->exten, sizeof(pickup.exten));\n\t\t\t\tast_copy_string(pickup.context, subscription->context, sizeof(pickup.context));\n\t\t\t\tsip_pvt_unlock(subscription);\n\t\t\t\tif (subscription->owner) {\n\t\t\t\t\tast_channel_unlock(subscription->owner);\n\t\t\t\t}\n\t\t\t\tsubscription = dialog_unref(subscription, \"unref dialog subscription\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!error && ast_strlen_zero(pickup.exten) && (p->refer->refer_call = get_sip_pvt_byid_locked(replace_id, totag, fromtag)) == NULL) {\n\t\t\tast_log(LOG_NOTICE, \"Supervised transfer attempted to replace non-existent call id (%s)!\\n\", replace_id);\n\t\t\ttransmit_response_reliable(p, \"481 Call Leg Does Not Exist (Replaces)\", req);\n\t\t\terror = 1;\n\t\t} else {\n\t\t\trefer_locked = 1;\n\t\t}\n\t\t\n\t\tif (p->refer->refer_call == p) {\n\t\t\tast_log(LOG_NOTICE, \"INVITE with replaces into it's own call id (%s == %s)!\\n\", replace_id, p->callid);\n\t\t\ttransmit_response_reliable(p, \"400 Bad request\", req);\t\n\t\t\terror = 1;\n\t\t}\n\t\tif (!error && ast_strlen_zero(pickup.exten) && !p->refer->refer_call->owner) {\n\t\t\t\n\t\t\tast_log(LOG_NOTICE, \"Supervised transfer attempted to replace non-existing call id (%s)!\\n\", replace_id);\n\t\t\t\n\t\t\ttransmit_response_reliable(p, \"481 Call Leg Does Not Exist (Replace)\", req);\n\t\t\terror = 1;\n\t\t}\n\t\tif (!error && ast_strlen_zero(pickup.exten) && p->refer->refer_call->owner->_state != AST_STATE_RINGING && p->refer->refer_call->owner->_state != AST_STATE_RING && p->refer->refer_call->owner->_state != AST_STATE_UP) {\n\t\t\tast_log(LOG_NOTICE, \"Supervised transfer attempted to replace non-ringing or active call id (%s)!\\n\", replace_id);\n\t\t\ttransmit_response_reliable(p, \"603 Declined (Replaces)\", req);\n\t\t\terror = 1;\n\t\t}\n\t\tif (error) {\t\n\t\t\tappend_history(p, \"Xfer\", \"INVITE/Replace Failed.\");\n\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\tsip_pvt_unlock(p);\n\t\t\tif (p->refer->refer_call) {\n\t\t\t\tsip_pvt_unlock(p->refer->refer_call);\n\t\t\t\tif (p->refer->refer_call->owner) {\n\t\t\t\t\tast_channel_unlock(p->refer->refer_call->owner);\n\t\t\t\t}\n\t\t\t\tp->refer->refer_call = dialog_unref(p->refer->refer_call, \"unref dialog p->refer->refer_call\");\n\t\t\t}\n\t\t\trefer_locked = 0;\n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tcheck_via(p, req);\n\t\t\tcopy_request(&p->initreq, req);\n\t\t\tres = -1;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t}\n\t\n\tif (!req->ignore) {\n\t\tint newcall = (p->initreq.headers ? TRUE : FALSE);\n\t\tif (sip_cancel_destroy(p))\n\t\t\tast_log(LOG_WARNING, \"Unable to cancel SIP destruction.  Expect bad things.\\n\");\n\t\t\n\t\tp->pendinginvite = seqno;\n\t\tcheck_via(p, req);\n\t\tcopy_request(&p->initreq, req);\t\t\n\t\tif (sipdebug)\n\t\t\tast_debug(1, \"Initializing initreq for method %s - callid %s\\n\", sip_methods[req->method].text, p->callid);\n\t\tif (!p->owner) {\t\n\t\t\tif (debug)\n\t\t\t\tast_verbose(\"Using INVITE request as basis request - %s\\n\", p->callid);\n\t\t\tif (newcall)\n\t\t\t\tappend_history(p, \"Invite\", \"New call: %s\", p->callid);\n\t\t\tparse_ok_contact(p, req);\n\t\t} else {\t\n\t\t\tast_clear_flag(&p->flags[0], SIP_OUTGOING);\t\n\t\t\tif (get_rpid(p, req)) {\n\t\t\t\tstruct ast_party_connected_line connected;\n\t\t\t\tstruct ast_set_party_connected_line update_connected;\n\t\t\t\tast_party_connected_line_init(&connected);\n\t\t\t\tmemset(&update_connected, 0, sizeof(update_connected));\n\t\t\t\tupdate_connected.id.number = 1;\n\t\t\t\tconnected.id.number.valid = 1;\n\t\t\t\tconnected.id.number.str = (char *) p->cid_num;\n\t\t\t\tconnected.id.number.presentation = p->callingpres;\n\t\t\t\tupdate_connected.id.name = 1;\n\t\t\t\tconnected.id.name.valid = 1;\n\t\t\t\tconnected.id.name.str = (char *) p->cid_name;\n\t\t\t\tconnected.id.name.presentation = p->callingpres;\n\t\t\t\tconnected.id.tag = (char *) p->cid_tag;\n\t\t\t\tconnected.source = AST_CONNECTED_LINE_UPDATE_SOURCE_TRANSFER;\n\t\t\t\tast_channel_queue_connected_line_update(p->owner, &connected,\n\t\t\t\t\t&update_connected);\n\t\t\t}\n\t\t\t\n\t\t\tif (find_sdp(req)) {\n\t\t\t\tif (process_sdp(p, req, SDP_T38_INITIATE)) {\n\t\t\t\t\tif (!ast_strlen_zero(get_header(req, \"Content-Encoding\"))) {\n\t\t\t\t\t\t\n\t\t\t\t\t\ttransmit_response_reliable(p, \"415 Unsupported Media type\", req);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttransmit_response_reliable(p, \"488 Not acceptable here\", req);\n\t\t\t\t\t}\n\t\t\t\t\tif (!p->lastinvite)\n\t\t\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\t\t\tres = -1;\n\t\t\t\t\tgoto request_invite_cleanup;\n\t\t\t\t}\n\t\t\t\tast_queue_control(p->owner, AST_CONTROL_SRCUPDATE);\n\t\t\t} else {\n\t\t\t\tp->jointcapability = p->capability;\n\t\t\t\tast_debug(1, \"Hm....  No sdp for the moment\\n\");\n\t\t\t\t\n\t\t\t\tif (ast_test_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD)) {\n\t\t\t\t\tast_queue_control(p->owner, AST_CONTROL_UNHOLD);\n\t\t\t\t\t\n\t\t\t\t\tast_queue_frame(p->owner, &ast_null_frame);\n\t\t\t\t\tchange_hold_state(p, req, FALSE, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p->do_history) \n\t\t\t\tappend_history(p, \"ReInv\", \"Re-invite received\");\n\t\t}\n\t} else if (debug)\n\t\tast_verbose(\"Ignoring this INVITE request\\n\");\n\tif (!p->lastinvite && !req->ignore && !p->owner) {\n\t\t\n\t\t\n\t\tint cc_recall_core_id = -1;\n\t\tset_pvt_allowed_methods(p, req);\n\t\tres = check_user_full(p, req, SIP_INVITE, e, XMIT_RELIABLE, addr, &authpeer);\n\t\tif (res == AUTH_CHALLENGE_SENT) {\n\t\t\tp->invitestate = INV_COMPLETED;\t\t\n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t\tif (res < 0) { \n\t\t\tif (res == AUTH_FAKE_AUTH) {\n\t\t\t\tast_log(LOG_NOTICE, \"Sending fake auth rejection for device %s\\n\", get_header(req, \"From\"));\n\t\t\t\ttransmit_fake_auth_response(p, SIP_INVITE, req, XMIT_RELIABLE);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_NOTICE, \"Failed to authenticate device %s\\n\", get_header(req, \"From\"));\n\t\t\t\ttransmit_response_reliable(p, \"403 Forbidden\", req);\n\t\t\t}\n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t\t\n\t\tif (p->relatedpeer) {\n\t\t\tp->relatedpeer = unref_peer(p->relatedpeer,\"unsetting the relatedpeer field in the dialog, before it is set to something else.\");\n\t\t}\n\t\tif (authpeer) {\n\t\t\tp->relatedpeer = ref_peer(authpeer, \"setting dialog's relatedpeer pointer\");\n\t\t}\n\t\treq->authenticated = 1;\n\t\t\n\t\tif (find_sdp(req)) {\n\t\t\tif (process_sdp(p, req, SDP_T38_INITIATE)) {\n\t\t\t\t\n\t\t\t\tif (!ast_strlen_zero(get_header(req, \"Content-Encoding\"))) {\n\t\t\t\t\ttransmit_response_reliable(p, \"415 Unsupported Media type\", req);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\ttransmit_response_reliable(p, \"488 Not acceptable here\", req);\n\t\t\t\t}\n\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\t\tast_debug(1, \"No compatible codecs for this SIP call.\\n\");\n\t\t\t\tres = -1;\n\t\t\t\tgoto request_invite_cleanup;\n\t\t\t}\n\t\t} else {\t\n\t\t\tp->jointcapability = p->capability;\n\t\t\tast_debug(2, \"No SDP in Invite, third party call control\\n\");\n\t\t}\n\t\t\n\t\t\n\t\tif (p->owner)\n\t\t\tast_queue_frame(p->owner, &ast_null_frame);\n\t\t\n\t\tif (ast_strlen_zero(p->context))\n\t\t\tast_string_field_set(p, context, sip_cfg.default_context);\n\t\t\n\t\tast_debug(1, \"Checking SIP call limits for device %s\\n\", p->username);\n\t\tif ((res = update_call_counter(p, INC_CALL_LIMIT))) {\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_NOTICE, \"Failed to place call for device %s, too many calls\\n\", p->username);\n\t\t\t\ttransmit_response_reliable(p, \"480 Temporarily Unavailable (Call limit) \", req);\n\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t\tgotdest = get_destination(p, NULL, &cc_recall_core_id);\t\n\t\textract_uri(p, req);\t\t\t\n\t\tbuild_contact(p);\t\t\t\n\t\tif (p->rtp) {\n\t\t\tast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_DTMF, ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833);\n\t\t\tast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_DTMF_COMPENSATE, ast_test_flag(&p->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));\n\t\t}\n\t\tif (!replace_id && (gotdest != SIP_GET_DEST_EXTEN_FOUND)) {\t\n\t\t\tswitch(gotdest) {\n\t\t\tcase SIP_GET_DEST_INVALID_URI:\n\t\t\t\ttransmit_response_reliable(p, \"416 Unsupported URI scheme\", req);\n\t\t\t\tbreak;\n\t\t\tcase SIP_GET_DEST_EXTEN_MATCHMORE:\n\t\t\t\tif (ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWOVERLAP)\n\t\t\t\t\t== SIP_PAGE2_ALLOWOVERLAP_YES) {\n\t\t\t\t\ttransmit_response_reliable(p, \"484 Address Incomplete\", req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\tcase SIP_GET_DEST_EXTEN_NOT_FOUND:\n\t\t\t\t{\n\t\t\t\t\tchar *decoded_exten = ast_strdupa(p->exten);\n\t\t\t\t\ttransmit_response_reliable(p, \"404 Not Found\", req);\n\t\t\t\t\tast_uri_decode(decoded_exten);\n\t\t\t\t\tast_log(LOG_NOTICE, \"Call from '%s' (%s) to extension\"\n\t\t\t\t\t\t\" '%s' rejected because extension not found in context '%s'.\\n\",\n\t\t\t\t\t\tS_OR(p->username, p->peername), ast_sockaddr_stringify(&p->recv), decoded_exten, p->context);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SIP_GET_DEST_REFUSED:\n\t\t\tdefault:\n\t\t\t\ttransmit_response_reliable(p, \"403 Forbidden\", req);\n\t\t\t} \n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tupdate_call_counter(p, DEC_CALL_LIMIT);\n\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tif (ast_strlen_zero(p->exten))\n\t\t\t\tast_string_field_set(p, exten, \"s\");\n\t\t\t\n\t\t\tmake_our_tag(p);\n\t\t\t\n\t\t\tc = sip_new(p, AST_STATE_DOWN, S_OR(p->peername, NULL), NULL);\n\t\t\tif (cc_recall_core_id != -1) {\n\t\t\t\tast_setup_cc_recall_datastore(c, cc_recall_core_id);\n\t\t\t\tast_cc_agent_set_interfaces_chanvar(c);\n\t\t\t}\n\t\t\t*recount = 1;\n\t\t\t\n\t\t\tbuild_route(p, req, 0, 0);\n\t\t\tif (c) {\n\t\t\t\tast_party_redirecting_init(&redirecting);\n\t\t\t\tmemset(&update_redirecting, 0, sizeof(update_redirecting));\n\t\t\t\tchange_redirecting_information(p, req, &redirecting, &update_redirecting,\n\t\t\t\t\tFALSE); \n\t\t\t\tast_channel_set_redirecting(c, &redirecting, &update_redirecting);\n\t\t\t\tast_party_redirecting_free(&redirecting);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tast_party_redirecting_init(&redirecting);\n\t\tmemset(&update_redirecting, 0, sizeof(update_redirecting));\n\t\tif (sipdebug) {\n\t\t\tif (!req->ignore)\n\t\t\t\tast_debug(2, \"Got a SIP re-invite for call %s\\n\", p->callid);\n\t\t\telse\n\t\t\t\tast_debug(2, \"Got a SIP re-transmit of INVITE for call %s\\n\", p->callid);\n\t\t}\n\t\tif (!req->ignore)\n\t\t\treinvite = 1;\n\t\tc = p->owner;\n\t\tchange_redirecting_information(p, req, &redirecting, &update_redirecting, FALSE); \n\t\tif (c) {\n\t\t\tast_channel_set_redirecting(c, &redirecting, &update_redirecting);\n\t\t}\n\t\tast_party_redirecting_free(&redirecting);\n\t}\n\t\n\tif ((p->sipoptions & SIP_OPT_TIMER) && !ast_strlen_zero(get_header(req, \"Session-Expires\"))) {\n\t\t\n\t\tast_debug(2, \"Incoming INVITE with 'timer' option supported and \\\"Session-Expires\\\" header.\\n\");\n\t\t\n\t\tif (!p->stimer)\n\t\t\tsip_st_alloc(p);\n\t\t\n\t\tp_uac_se_hdr = get_header(req, \"Session-Expires\");\n\t\trtn = parse_session_expires(p_uac_se_hdr, &uac_max_se, &st_ref);\n\t\tif (rtn != 0) {\n\t\t\ttransmit_response_reliable(p, \"400 Session-Expires Invalid Syntax\", req);\n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tif (!p->lastinvite) {\n\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\t}\n\t\t\tres = -1;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t\t\n\t\tp_uac_min_se = get_header(req, \"Min-SE\");\n\t\tif (!ast_strlen_zero(p_uac_min_se)) {\n\t\t\trtn = parse_minse(p_uac_min_se, &uac_min_se);\n\t\t\tif (rtn != 0) {\n\t\t\t\ttransmit_response_reliable(p, \"400 Min-SE Invalid Syntax\", req);\n\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t\tif (!p->lastinvite) {\n\t\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\t\t}\n\t\t\t\tres = -1;\n\t\t\t\tgoto request_invite_cleanup;\n\t\t\t}\n\t\t}\n\t\tdlg_min_se = st_get_se(p, FALSE);\n\t\tswitch (st_get_mode(p, 1)) {\n\t\tcase SESSION_TIMER_MODE_ACCEPT:\n\t\tcase SESSION_TIMER_MODE_ORIGINATE:\n\t\t\tif (uac_max_se > 0 && uac_max_se < dlg_min_se) {\n\t\t\t\ttransmit_response_with_minse(p, \"422 Session Interval Too Small\", req, dlg_min_se);\n\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t\tif (!p->lastinvite) {\n\t\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\t\t}\n\t\t\t\tres = -1;\n\t\t\t\tgoto request_invite_cleanup;\n\t\t\t}\n\t\t\tp->stimer->st_active_peer_ua = TRUE;\n\t\t\tst_active = TRUE;\n\t\t\tif (st_ref == SESSION_TIMER_REFRESHER_AUTO) {\n\t\t\t\tst_ref = st_get_refresher(p);\n\t\t\t}\n\t\t\tif (uac_max_se > 0) {\n\t\t\t\tint dlg_max_se = st_get_se(p, TRUE);\n\t\t\t\tif (dlg_max_se >= uac_min_se) {\n\t\t\t\t\tst_interval = (uac_max_se < dlg_max_se) ? uac_max_se : dlg_max_se;\n\t\t\t\t} else {\n\t\t\t\t\tst_interval = uac_max_se;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tst_interval = global_max_se;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SESSION_TIMER_MODE_REFUSE:\n\t\t\tif (p->reqsipoptions & SIP_OPT_TIMER) {\n\t\t\t\ttransmit_response_with_unsupported(p, \"420 Option Disabled\", req, required);\n\t\t\t\tast_log(LOG_WARNING, \"Received SIP INVITE with supported but disabled option: %s\\n\", required);\n\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t\tif (!p->lastinvite) {\n\t\t\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t\t\t}\n\t\t\t\tres = -1;\n\t\t\t\tgoto request_invite_cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_ERROR, \"Internal Error %d at %s:%d\\n\", st_get_mode(p, 1), __FILE__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t\n\t\tswitch (st_get_mode(p, 1)) {\n\t\tcase SESSION_TIMER_MODE_ORIGINATE:\n\t\t\tst_active = TRUE;\n\t\t\tst_interval = st_get_se(p, TRUE);\n\t\t\tst_ref = SESSION_TIMER_REFRESHER_UAS;\n\t\t\tp->stimer->st_active_peer_ua = FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reinvite == 0) {\n\t\t\n\t\tif (st_active == TRUE) {\n\t\t\tp->stimer->st_active   = TRUE;\n\t\t\tp->stimer->st_interval = st_interval;\n\t\t\tp->stimer->st_ref      = st_ref;\n\t\t\tstart_session_timer(p);\n\t\t}\n\t} else {\n\t\tif (p->stimer->st_active == TRUE) {\n\t\t\t\n\t\t\tast_debug (2, \"Restarting session-timers on a refresh - %s\\n\", p->callid);\n\t\t\t\n\t\t\tif (st_interval > 0) {\n\t\t\t\tp->stimer->st_interval = st_interval;\n\t\t\t\tp->stimer->st_ref      = st_ref;\n\t\t\t}\n\t\t\trestart_session_timer(p);\n\t\t\tif (p->stimer->st_expirys > 0) {\n\t\t\t\tp->stimer->st_expirys--;\n\t\t\t}\n\t\t}\n\t}\n\tif (!req->ignore && p)\n\t\tp->lastinvite = seqno;\n\tif (c && replace_id) {\t\n\t\tif (!ast_strlen_zero(pickup.exten)) {\n\t\t\tappend_history(p, \"Xfer\", \"INVITE/Replace received\");\n\t\t\t\n\t\t\ttransmit_response(p, \"100 Trying\", req);\n\t\t\tp->invitestate = INV_PROCEEDING;\n\t\t\tast_setstate(c, AST_STATE_RING);\n\t\t\t\n\t\t\tast_channel_unlock(c);\n\t\t\t*nounlock = 1;\n\t\t\t\n\t\t\tsip_pvt_unlock(p);\n\t\t\tdo_magic_pickup(c, pickup.exten, pickup.context);\n\t\t\t\n\t\t\tast_hangup(c);\n\t\t\tsip_pvt_lock(p); \n\t\t\tres = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t} else {\n\t\t\t\n\t\t\tif (sipdebug)\n\t\t\t\tast_debug(4, \"Sending this call to the invite/replcaes handler %s\\n\", p->callid);\n\t\t\tres = handle_invite_replaces(p, req, debug, seqno, addr, nounlock);\n\t\t\trefer_locked = 0;\n\t\t\tgoto request_invite_cleanup;\n\t\t}\n\t}\n\tif (c) {\t\n\t\tenum ast_channel_state c_state = c->_state;\n\t\tif (c_state != AST_STATE_UP && reinvite &&\n\t\t\t(p->invitestate == INV_TERMINATED || p->invitestate == INV_CONFIRMED)) {\n\t\t\t\n\t\t\tc_state = AST_STATE_UP;\n\t\t}\n\t\tswitch(c_state) {\n\t\tcase AST_STATE_DOWN:\n\t\t\tast_debug(2, \"%s: New call is still down.... Trying... \\n\", c->name);\n\t\t\ttransmit_provisional_response(p, \"100 Trying\", req, 0);\n\t\t\tp->invitestate = INV_PROCEEDING;\n\t\t\tast_setstate(c, AST_STATE_RING);\n\t\t\tif (strcmp(p->exten, ast_pickup_ext())) {\t\n\t\t\t\tenum ast_pbx_result result;\n\t\t\t\tresult = ast_pbx_start(c);\n\t\t\t\tswitch(result) {\n\t\t\t\tcase AST_PBX_FAILED:\n\t\t\t\t\tast_log(LOG_WARNING, \"Failed to start PBX :(\\n\");\n\t\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t\t\ttransmit_response_reliable(p, \"503 Unavailable\", req);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AST_PBX_CALL_LIMIT:\n\t\t\t\t\tast_log(LOG_WARNING, \"Failed to start PBX (call limit reached) \\n\");\n\t\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t\t\ttransmit_response_reliable(p, \"480 Temporarily Unavailable\", req);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AST_PBX_SUCCESS:\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (result) {\n\t\t\t\t\t\n\t\t\t\t\tast_channel_unlock(c);\n\t\t\t\t\t*nounlock = 1;\n\t\t\t\t\tsip_pvt_unlock(p);\n\t\t\t\t\tast_hangup(c);\n\t\t\t\t\tsip_pvt_lock(p);\n\t\t\t\t\tc = NULL;\n\t\t\t\t}\n\t\t\t} else {\t\n\t\t\t\tif (sip_pickup(c)) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Failed to start Group pickup by %s\\n\", c->name);\n\t\t\t\t\ttransmit_response_reliable(p, \"480 Temporarily Unavailable\", req);\n\t\t\t\t\tsip_alreadygone(p);\n\t\t\t\t\tc->hangupcause = AST_CAUSE_FAILURE;\n\t\t\t\t\t\n\t\t\t\t\tast_channel_unlock(c);\n\t\t\t\t\t*nounlock = 1;\n\t\t\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\t\t\tsip_pvt_unlock(p);\n\t\t\t\t\tast_hangup(c);\n\t\t\t\t\tsip_pvt_lock(p);\n\t\t\t\t\tc = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AST_STATE_RING:\n\t\t\ttransmit_provisional_response(p, \"100 Trying\", req, 0);\n\t\t\tp->invitestate = INV_PROCEEDING;\n\t\t\tbreak;\n\t\tcase AST_STATE_RINGING:\n\t\t\ttransmit_provisional_response(p, \"180 Ringing\", req, 0);\n\t\t\tp->invitestate = INV_PROCEEDING;\n\t\t\tbreak;\n\t\tcase AST_STATE_UP:\n\t\t\tast_debug(2, \"%s: This call is UP.... \\n\", c->name);\n\t\t\ttransmit_response(p, \"100 Trying\", req);\n\t\t\tif (p->t38.state == T38_PEER_REINVITE) {\n\t\t\t\tif (p->t38id > -1) {\n\t\t\t\t\t\n\t\t\t\t\tAST_SCHED_DEL_UNREF(sched, p->t38id, dialog_unref(p, \"remove ref for t38id\"));\n\t\t\t\t}\n\t\t\t\tp->t38id = ast_sched_add(sched, 5000, sip_t38_abort, dialog_ref(p, \"passing dialog ptr into sched structure based on t38id for sip_t38_abort.\"));\n\t\t\t} else if (p->t38.state == T38_ENABLED) {\n\t\t\t\tast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);\n\t\t\t\ttransmit_response_with_t38_sdp(p, \"200 OK\", req, (reinvite ? XMIT_RELIABLE : (req->ignore ?  XMIT_UNRELIABLE : XMIT_CRITICAL)));\n\t\t\t} else if (p->t38.state == T38_DISABLED) {\n\t\t\t\t\n\t\t\t\tif (p->srtp && !ast_test_flag(p->srtp, SRTP_CRYPTO_OFFER_OK)) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Target does not support required crypto\\n\");\n\t\t\t\t\ttransmit_response_reliable(p, \"488 Not Acceptable Here (crypto)\", req);\n\t\t\t\t} else {\n\t\t\t\t\tast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);\n\t\t\t\t\ttransmit_response_with_sdp(p, \"200 OK\", req, (reinvite ? XMIT_RELIABLE : (req->ignore ?  XMIT_UNRELIABLE : XMIT_CRITICAL)), p->session_modify == TRUE ? FALSE : TRUE, FALSE);\n\t\t\t\t\tast_queue_control(p->owner, AST_CONTROL_UPDATE_RTP_PEER);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp->invitestate = INV_TERMINATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_WARNING, \"Don't know how to handle INVITE in state %d\\n\", c->_state);\n\t\t\ttransmit_response(p, \"100 Trying\", req);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (p && (p->autokillid == -1)) {\n\t\t\tconst char *msg;\n\t\t\tif (!p->jointcapability)\n\t\t\t\tmsg = \"488 Not Acceptable Here (codec error)\";\n\t\t\telse {\n\t\t\t\tast_log(LOG_NOTICE, \"Unable to create/find SIP channel for this INVITE\\n\");\n\t\t\t\tmsg = \"503 Unavailable\";\n\t\t\t}\n\t\t\ttransmit_response_reliable(p, msg, req);\n\t\t\tp->invitestate = INV_COMPLETED;\n\t\t\tsip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);\n\t\t}\n\t}\nrequest_invite_cleanup:\n\tif (refer_locked && p->refer && p->refer->refer_call) {\n\t\tsip_pvt_unlock(p->refer->refer_call);\n\t\tif (p->refer->refer_call->owner) {\n\t\t\tast_channel_unlock(p->refer->refer_call->owner);\n\t\t}\n\t\tp->refer->refer_call = dialog_unref(p->refer->refer_call, \"unref dialog p->refer->refer_call\");\n\t}\n\tif (authpeer) {\n\t\tauthpeer = unref_peer(authpeer, \"unref_peer, from handle_request_invite authpeer\");\n\t}\n\treturn res;\n}\n", "bug_type": "CVE-2014-2287", "idx": 976}
{"project": "Asterisk", "target": 0, "func": "#define MAX_HISTORY_COMMAND_LENGTH 256\nstatic int ast_el_add_history(const char *buf)\n{\n\tHistEvent ev;\n\tchar *stripped_buf;\n\tif (el_hist == NULL || el == NULL) {\n\t\tast_el_initialize();\n\t}\n\tif (strlen(buf) > (MAX_HISTORY_COMMAND_LENGTH - 1)) {\n\t\treturn 0;\n\t}\n\tstripped_buf = ast_strip(ast_strdupa(buf));\n\t\n\tif (!history(el_hist, &ev, H_FIRST) && strcmp(ev.str, stripped_buf) == 0) {\n\t\treturn 0;\n\t}\n\treturn history(el_hist, &ev, H_ENTER, stripped_buf);\n}\n", "bug_type": null, "idx": 977}
{"project": "Asterisk", "target": 0, "func": "static int mp3_exec(struct ast_channel *chan, const char *data)\n{\n\tint res=0;\n\tint fds[2];\n\tint ms = -1;\n\tint pid = -1;\n\tRAII_VAR(struct ast_format *, owriteformat, NULL, ao2_cleanup);\n\tint timeout = 2000;\n\tstruct timeval next;\n\tstruct ast_frame *f;\n\tstruct myframe {\n\t\tstruct ast_frame f;\n\t\tchar offset[AST_FRIENDLY_OFFSET];\n\t\tshort frdata[160];\n\t} myf = {\n\t\t.f = { 0, },\n\t};\n\tstruct ast_format * native_format;\n\tunsigned int sampling_rate;\n\tstruct ast_format * write_format;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"MP3 Playback requires an argument (filename)\\n\");\n\t\treturn -1;\n\t}\n\tif (pipe(fds)) {\n\t\tast_log(LOG_WARNING, \"Unable to create pipe\\n\");\n\t\treturn -1;\n\t}\n\tast_stopstream(chan);\n\tnative_format = ast_format_cap_get_format(ast_channel_nativeformats(chan), 0);\n\tsampling_rate = ast_format_get_sample_rate(native_format);\n\twrite_format = ast_format_cache_get_slin_by_rate(sampling_rate);\n\towriteformat = ao2_bump(ast_channel_writeformat(chan));\n\tres = ast_set_write_format(chan, write_format);\n\tif (res < 0) {\n\t\tast_log(LOG_WARNING, \"Unable to set write format to signed linear\\n\");\n\t\treturn -1;\n\t}\n\tmyf.f.frametype = AST_FRAME_VOICE;\n\tmyf.f.subclass.format = write_format;\n\tmyf.f.mallocd = 0;\n\tmyf.f.offset = AST_FRIENDLY_OFFSET;\n\tmyf.f.src = __PRETTY_FUNCTION__;\n\tmyf.f.delivery.tv_sec = 0;\n\tmyf.f.delivery.tv_usec = 0;\n\tmyf.f.data.ptr = myf.frdata;\n\tres = mp3play(data, sampling_rate, fds[1]);\n\tif (!strncasecmp(data, \"http://\", 7)) {\n\t\ttimeout = 10000;\n\t}\n\t\n\tnext = ast_tvnow();\n\tnext.tv_sec += 1;\n\tif (res >= 0) {\n\t\tpid = res;\n\t\t\n\t\tfor (;;) {\n\t\t\tms = ast_tvdiff_ms(next, ast_tvnow());\n\t\t\tif (ms <= 0) {\n\t\t\t\tres = timed_read(fds[0], myf.frdata, sizeof(myf.frdata), timeout);\n\t\t\t\tif (res > 0) {\n\t\t\t\t\tmyf.f.datalen = res;\n\t\t\t\t\tmyf.f.samples = res / 2;\n\t\t\t\t\tif (ast_write(chan, &myf.f) < 0) {\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tast_debug(1, \"No more mp3\\n\");\n\t\t\t\t\tres = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext = ast_tvadd(next, ast_samp2tv(myf.f.samples, sampling_rate));\n\t\t\t} else {\n\t\t\t\tms = ast_waitfor(chan, ms);\n\t\t\t\tif (ms < 0) {\n\t\t\t\t\tast_debug(1, \"Hangup detected\\n\");\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ms) {\n\t\t\t\t\tf = ast_read(chan);\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tast_debug(1, \"Null frame == hangup() detected\\n\");\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (f->frametype == AST_FRAME_DTMF) {\n\t\t\t\t\t\tast_debug(1, \"User pressed a key\\n\");\n\t\t\t\t\t\tast_frfree(f);\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tif (pid > -1)\n\t\tkill(pid, SIGKILL);\n\tif (!res && owriteformat)\n\t\tast_set_write_format(chan, owriteformat);\n\tast_frfree(&myf.f);\n\treturn res;\n}\n", "bug_type": null, "idx": 978}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void bridge_sync_signal(struct bridge_sync *sync_struct)\n{\n\tast_sem_post(&sync_struct->sem);\n}\n", "bug_type": null, "idx": 979}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int defer_action(struct ast_bridge_channel *bridge_channel, deferred_cb callback)\n{\n\tstruct deferred_data data = { .callback = callback };\n\tint res;\n\tres = ast_bridge_channel_queue_callback(bridge_channel, 0, deferred_action,\n\t\t&data, sizeof(data));\n\tif (res) {\n\t\tast_log(LOG_WARNING, \"Bridge %s: Could not defer action on %s.\\n\",\n\t\t\tbridge_channel->bridge->uniqueid, ast_channel_name(bridge_channel->chan));\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 980}
{"project": "Asterisk", "target": 0, "func": "int ast_async_parseable_goto(struct ast_channel *chan, const char *goto_string)\n{\n\treturn pbx_parseable_goto(chan, goto_string, 1);\n}\n", "bug_type": null, "idx": 981}
{"project": "Asterisk", "target": 0, "func": "void stasis_subscription_join(struct stasis_subscription *subscription)\n{\n\tif (subscription) {\n\t\tSCOPED_AO2LOCK(lock, subscription);\n\t\t\n\t\twhile (!subscription->final_message_processed) {\n\t\t\tast_cond_wait(&subscription->join_cond,\n\t\t\t\tao2_object_get_lockaddr(subscription));\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 982}
{"project": "Asterisk", "target": 0, "func": "struct ast_xml_node *ast_xml_node_get_parent(struct ast_xml_node *node)\n{\n\treturn (struct ast_xml_node *) ((xmlNode *) node)->parent;\n}\n", "bug_type": null, "idx": 983}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(test_substitution)\n{\n\tstruct ast_channel *c;\n\tint i;\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"test_substitution\";\n\t\tinfo->category = \"/main/pbx/\";\n\t\tinfo->summary = \"Test variable and function substitution\";\n\t\tinfo->description =\n\t\t\t\"This test executes a variety of variable and function substitutions \"\n\t\t\t\"and ensures that the expected results are received.\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tast_test_status_update(test, \"Testing variable substitution ...\\n\");\n\tc = ast_channel_alloc(0, 0, \"\", \"\", \"\", \"\", \"\", NULL, NULL, 0, \"Test/substitution\");\n\tast_channel_unlock(c);\n#define TEST(t) if (t == AST_TEST_FAIL) { res = AST_TEST_FAIL; }\n#if 0\n\t\n\tTEST(test_chan_integer(test, c, &c->caller.id.number.presentation, \"${CALLINGPRES}\"));\n#endif\n\tTEST(test_chan_integer(test, c, &ast_channel_caller(c)->ani2, \"${CALLINGANI2}\"));\n\tTEST(test_chan_integer(test, c, &ast_channel_caller(c)->id.number.plan, \"${CALLINGTON}\"));\n\tTEST(test_chan_integer(test, c, &ast_channel_dialed(c)->transit_network_select, \"${CALLINGTNS}\"));\n\tTEST(test_chan_integer_accessor(test, c, ast_channel_hangupcause_set, \"${HANGUPCAUSE}\"));\n\tTEST(test_chan_integer_accessor(test, c, ast_channel_priority_set, \"${PRIORITY}\"));\n\tTEST(test_chan_string(test, c, ast_channel_context_set, ast_channel_context, \"${CONTEXT}\"));\n\tTEST(test_chan_string(test, c, ast_channel_exten_set, ast_channel_exten, \"${EXTEN}\"));\n\tTEST(test_chan_variable(test, c, \"CHANNEL(language)\"));\n\tTEST(test_chan_variable(test, c, \"CHANNEL(musicclass)\"));\n\tTEST(test_chan_variable(test, c, \"CHANNEL(parkinglot)\"));\n\tTEST(test_chan_variable(test, c, \"CALLERID(name)\"));\n\tTEST(test_chan_variable(test, c, \"CURLOPT(proxyuserpwd)\"));\n\tTEST(test_chan_variable(test, c, \"CDR(foo)\"));\n\tTEST(test_chan_variable(test, c, \"ENV(foo)\"));\n\tTEST(test_chan_variable(test, c, \"GLOBAL(foo)\"));\n\tTEST(test_chan_variable(test, c, \"GROUP()\"));\n\tTEST(test_2way_function(test, c, \"${AES_ENCRYPT(abcdefghijklmnop,\", \")}\", \"${AES_DECRYPT(abcdefghijklmnop,\", \")}\"));\n\tTEST(test_2way_function(test, c, \"${BASE64_ENCODE(\", \")}\", \"${BASE64_DECODE(\", \")}\"));\n\tpbx_builtin_setvar_helper(c, \"foo\", \"123\");\n\tpbx_builtin_setvar_helper(c, \"bar\", \"foo\");\n\tpbx_builtin_setvar_helper(c, \"baz\", \"fo\");\n\tTEST(test_expected_result(test, c, \"${foo}${foo}\", \"123123\"));\n\tTEST(test_expected_result(test, c, \"A${foo}A${foo}A\", \"A123A123A\"));\n\tTEST(test_expected_result(test, c, \"A${${bar}}A\", \"A123A\"));\n\tTEST(test_expected_result(test, c, \"A${${baz}o}A\", \"A123A\"));\n\tTEST(test_expected_result(test, c, \"A${${baz}o:1}A\", \"A23A\"));\n\tTEST(test_expected_result(test, c, \"A${${baz}o:1:1}A\", \"A2A\"));\n\tTEST(test_expected_result(test, c, \"A${${baz}o:1:-1}A\", \"A2A\"));\n\tTEST(test_expected_result(test, c, \"A${${baz}o:-1:1}A\", \"A3A\"));\n\tTEST(test_expected_result(test, c, \"A${${baz}o:-2:1}A\", \"A2A\"));\n\tTEST(test_expected_result(test, c, \"A${${baz}o:-2:-1}A\", \"A2A\"));\n\tpbx_builtin_setvar_helper(c, \"list1\", \"ab&cd&ef\");\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list1,&,ab)}\", \"cd&ef\"));\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list1,&,cd)}\", \"ab&ef\"));\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list1,&,ef)}\", \"ab&cd\"));\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list1,&,gh)}\", \"ab&cd&ef\"));\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list1,&,c)}\", \"ab&cd&ef\"));\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list1,&,d)}\", \"ab&cd&ef\"));\n\tpbx_builtin_setvar_helper(c, \"list2\", \"ab\");\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list2,&,ab)}\", \"\"));\n\tpbx_builtin_setvar_helper(c, \"list_empty\", \"\");\n\tTEST(test_expected_result(test, c, \"${LISTFILTER(list_empty,&,ab)}\", \"\"));\n\tTEST(test_expected_result(test, c, \"${SHELL(printf '%d' 123)},${SHELL(printf '%d' 456)}\", \"123,456\"));\n\tTEST(test_expected_result(test, c, \"${foo},${CDR(answer)},${SHELL(printf '%d' 456)}\", \"123,,456\"));\n\tTEST(test_expected_result(test, c, \"${foo},${CDR(answer,u)},${SHELL(printf '%d' 456)}\", \"123,0.000000,456\"));\n\tTEST(test_expected_result(test, c, \"${foo},${this_does_not_exist},${THIS_DOES_NOT_EXIST(either)}\", \"123,,\"));\n#undef TEST\n\t\n\tfor (i = 0; ; i++) {\n\t\tchar *cmd = ast_cli_generator(\"core show function\", \"\", i);\n\t\tif (cmd == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(cmd, \"CHANNEL\") && strcmp(cmd, \"CALLERID\") && strncmp(cmd, \"CURL\", 4) &&\n\t\t\t\tstrncmp(cmd, \"AES\", 3) && strncmp(cmd, \"BASE64\", 6) &&\n\t\t\t\tstrcmp(cmd, \"CDR\") && strcmp(cmd, \"ENV\") && strcmp(cmd, \"GLOBAL\") &&\n\t\t\t\tstrcmp(cmd, \"GROUP\") && strcmp(cmd, \"CUT\") && strcmp(cmd, \"LISTFILTER\") &&\n\t\t\t\tstrcmp(cmd, \"PP_EACH_EXTENSION\") && strcmp(cmd, \"SET\")) {\n\t\t\tstruct ast_custom_function *acf = ast_custom_function_find(cmd);\n\t\t\tif (acf->read && acf->read2) {\n\t\t\t\tchar expression[80];\n\t\t\t\tsnprintf(expression, sizeof(expression), \"${%s(foo)}\", cmd);\n\t\t\t\tif (AST_TEST_FAIL == test_chan_function(test, c, expression)) {\n\t\t\t\t\tres = AST_TEST_FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tast_free(cmd);\n\t}\n\tast_hangup(c);\n\treturn res;\n}\n", "bug_type": null, "idx": 984}
{"project": "Asterisk", "target": 0, "func": "static void send_icon(unsigned char pos, unsigned char status, struct unistimsession *pte)\n{\n\tBUFFSEND;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending icon pos %d with status 0x%02hhx\\n\", pos, status);\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_icon, sizeof(packet_send_icon));\n\tbuffsend[9] = pos;\n\tbuffsend[10] = status;\n\tsend_client(SIZE_HEADER + sizeof(packet_send_icon), buffsend, pte);\n}\n", "bug_type": null, "idx": 985}
{"project": "Asterisk", "target": 1, "func": "static void ast_rtp_remote_address_set(struct ast_rtp_instance *instance, struct ast_sockaddr *addr)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tif (rtp->rtcp) {\n\t\tast_debug(1, \"Setting RTCP address on RTP instance '%p'\\n\", instance);\n\t\tast_sockaddr_copy(&rtp->rtcp->them, addr);\n\t\tif (!ast_sockaddr_isnull(addr)) {\n\t\t\tast_sockaddr_set_port(&rtp->rtcp->them,\n\t\t\t\t\t      ast_sockaddr_port(addr) + 1);\n\t\t}\n\t}\n\trtp->rxseqno = 0;\n\tif (strictrtp && rtp->strict_rtp_state != STRICT_RTP_OPEN) {\n\t\trtp->strict_rtp_state = STRICT_RTP_LEARN;\n\t\trtp_learning_seq_init(&rtp->rtp_source_learn, rtp->seqno);\n\t}\n\treturn;\n}\n", "bug_type": "CVE-2017-14099-5", "idx": 986}
{"project": "Asterisk", "target": 0, "func": "static int compress_char(const char c)\n{\n\tif (c < 32) {\n\t\treturn 0;\n\t} else if (c > 96) {\n\t\treturn c - 64;\n\t}\n\treturn c - 32;\n}\n", "bug_type": null, "idx": 987}
{"project": "Asterisk", "target": 0, "func": "static int spandsp_modems(struct ast_fax_session_details *details)\n{\n\tint modems = 0;\n\tif (AST_FAX_MODEM_V17 & details->modems) {\n\t\tmodems |= T30_SUPPORT_V17;\n\t}\n\tif (AST_FAX_MODEM_V27TER & details->modems) {\n\t\tmodems |= T30_SUPPORT_V27TER;\n\t}\n\tif (AST_FAX_MODEM_V29 & details->modems) {\n\t\tmodems |= T30_SUPPORT_V29;\n\t}\n\tif (AST_FAX_MODEM_V34 & details->modems) {\n#if defined(T30_SUPPORT_V34)\n\t\tmodems |= T30_SUPPORT_V34;\n#elif defined(T30_SUPPORT_V34HDX)\n\t\tmodems |= T30_SUPPORT_V34HDX;\n#else\n\t\tast_log(LOG_WARNING, \"v34 not supported in this version of spandsp\\n\");\n#endif\n\t}\n\treturn modems;\n}\n", "bug_type": null, "idx": 988}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ao2_container *cli_aor_get_container(const char *regex)\n{\n\tstruct ao2_container *container;\n\tstruct ao2_container *s_container;\n\tcontainer = ast_sorcery_retrieve_by_regex(ast_sip_get_sorcery(), \"aor\", regex);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\t\n\ts_container = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_NOLOCK, 0,\n\t\tast_sorcery_object_id_sort, ast_sorcery_object_id_compare);\n\tif (s_container\n\t\t&& ao2_container_dup(s_container, container, 0)) {\n\t\tao2_ref(s_container, -1);\n\t\ts_container = NULL;\n\t}\n\tao2_ref(container, -1);\n\treturn s_container;\n}\n", "bug_type": null, "idx": 989}
{"project": "Asterisk", "target": 0, "func": "int ast_adsi_unload_session(struct ast_channel *chan)\n{\n\tint res = 0;\n\tast_rwlock_rdlock(&func_lock);\n\tif (installed_funcs && installed_funcs->unload_session) {\n\t\tres = installed_funcs->unload_session(chan);\n\t}\n\tast_rwlock_unlock(&func_lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 990}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_get_default_realm(char *realm, size_t size)\n{\n\tstruct global_config *cfg;\n\tcfg = get_global_cfg();\n\tif (!cfg) {\n\t\tast_copy_string(realm, DEFAULT_REALM, size);\n\t} else {\n\t\tast_copy_string(realm, cfg->default_realm, size);\n\t\tao2_ref(cfg, -1);\n\t}\n}\n", "bug_type": null, "idx": 991}
{"project": "Asterisk", "target": 0, "func": "int __ast_asprintf(const char *file, int lineno, const char *func, char **strp, const char *fmt, ...)\n{\n\tint size;\n\tva_list ap, ap2;\n\tchar s;\n\t*strp = NULL;\n\tva_start(ap, fmt);\n\tva_copy(ap2, ap);\n\tsize = vsnprintf(&s, 1, fmt, ap2);\n\tva_end(ap2);\n\tif (!(*strp = __ast_alloc_region(size + 1, FUNC_ASPRINTF, file, lineno, func, 0))) {\n\t\tva_end(ap);\n\t\treturn -1;\n\t}\n\tvsnprintf(*strp, size + 1, fmt, ap);\n\tva_end(ap);\n\treturn size;\n}\n", "bug_type": null, "idx": 992}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_interval_register(enum ast_bridge_builtin_interval interval, ast_bridge_builtin_set_limits_fn callback)\n{\n\tif (ARRAY_LEN(builtin_interval_handlers) <= interval\n\t\t|| builtin_interval_handlers[interval]) {\n\t\treturn -1;\n\t}\n\tbuiltin_interval_handlers[interval] = callback;\n\treturn 0;\n}\n", "bug_type": null, "idx": 993}
{"project": "Asterisk", "target": 0, "func": "static int dbl_list_expect_forward(struct test_dbl_llist *test_list, const char *expect, struct ast_str **buf)\n{\n\tstruct test_val *i;\n\tast_str_reset(*buf);\n\tAST_DLLIST_TRAVERSE(test_list, i, dbl_list) {\n\t\tast_str_append(buf, 0, \"%s\", i->name);\n\t}\n\treturn strcmp(expect, ast_str_buffer(*buf));\n}\n", "bug_type": null, "idx": 994}
{"project": "Asterisk", "target": 0, "func": "static struct media_variant *find_variant(struct ast_media_index *index, const char *filename, const char *variant)\n{\n\tRAII_VAR(struct media_info *, info, NULL, ao2_cleanup);\n\tinfo = ao2_find(index->index, filename, OBJ_KEY);\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\treturn ao2_find(info->variants, variant, OBJ_KEY);\n}\n", "bug_type": null, "idx": 995}
{"project": "Asterisk", "target": 0, "func": "static void log_forwarder(int level, const char *data, int len)\n{\n\tint ast_level;\n\t\n\tconst char * log_source = \"pjproject\";\n\tint log_line = 0;\n\tconst char *log_func = \"<?>\";\n\tif (pjproject_log_intercept.fd != -1\n\t\t&& pjproject_log_intercept.thread == pthread_self()) {\n\t\t\n\t\tast_cli(pjproject_log_intercept.fd, \"%s\\n\", data);\n\t\treturn;\n\t}\n\tast_level = get_log_level(level);\n\tif (ast_level == __LOG_SUPPRESS) {\n\t\treturn;\n\t}\n\t\n\tast_log(ast_level, log_source, log_line, log_func, \"\\t%s\\n\", data);\n}\n", "bug_type": null, "idx": 996}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hsp_send_error(int rsock)\n{\n\treturn rfcomm_write(rsock, \"\\r\\nERROR\\r\\n\");\n}\n", "bug_type": null, "idx": 997}
{"project": "Asterisk", "target": 0, "func": "#define PAST_END_OF_RECORD ptr >= end_of_record\nstruct ast_dns_record *dns_naptr_alloc(struct ast_dns_query *query, const char *data, const size_t size)\n{\n\tstruct ast_dns_naptr_record *naptr;\n\tchar *ptr = NULL;\n\tuint16_t order;\n\tuint16_t preference;\n\tuint8_t flags_size;\n\tchar *flags;\n\tuint8_t services_size;\n\tchar *services;\n\tuint8_t regexp_size;\n\tchar *regexp;\n\tchar replacement[256] = \"\";\n\tint replacement_size;\n\tconst char *end_of_record;\n\tenum flags_result flags_res;\n\tptr = dns_find_record(data, size, query->result->answer, query->result->answer_size);\n\tast_assert(ptr != NULL);\n\tend_of_record = ptr + size;\n\t\n\t\n\tptr += dns_parse_short((unsigned char *) ptr, &order);\n\tif (PAST_END_OF_RECORD) {\n\t\treturn NULL;\n\t}\n\t\n\tptr += dns_parse_short((unsigned char *) ptr, &preference);\n\tif (PAST_END_OF_RECORD) {\n\t\treturn NULL;\n\t}\n\t\n\tptr += dns_parse_string(ptr, &flags_size, &flags);\n\tif (PAST_END_OF_RECORD) {\n\t\treturn NULL;\n\t}\n\t\n\tptr += dns_parse_string(ptr, &services_size, &services);\n\tif (PAST_END_OF_RECORD) {\n\t\treturn NULL;\n\t}\n\t\n\tptr += dns_parse_string(ptr, &regexp_size, &regexp);\n\tif (PAST_END_OF_RECORD) {\n\t\treturn NULL;\n\t}\n\treplacement_size = dn_expand((unsigned char *)query->result->answer, (unsigned char *) end_of_record, (unsigned char *) ptr, replacement, sizeof(replacement) - 1);\n\tif (replacement_size < 0) {\n\t\tast_log(LOG_ERROR, \"Failed to expand domain name: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tptr += replacement_size;\n\tif (ptr != end_of_record) {\n\t\tast_log(LOG_ERROR, \"NAPTR record gave undersized string indications.\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tflags_res = interpret_flags(flags, flags_size);\n\tif (flags_res == FLAGS_INVALID) {\n\t\tast_log(LOG_ERROR, \"NAPTR Record contained invalid flags %.*s\\n\", flags_size, flags);\n\t\treturn NULL;\n\t}\n\tif (services_invalid(services, services_size)) {\n\t\tast_log(LOG_ERROR, \"NAPTR record contained invalid services %.*s\\n\", services_size, services);\n\t\treturn NULL;\n\t}\n\tif (regexp_invalid(regexp, regexp_size)) {\n\t\tast_log(LOG_ERROR, \"NAPTR record contained invalid regexp %.*s\\n\", regexp_size, regexp);\n\t\treturn NULL;\n\t}\n\t\n\tif (regexp_size && replacement_size > 1) {\n\t\tast_log(LOG_ERROR, \"NAPTR record contained both a regexp and replacement\\n\");\n\t\treturn NULL;\n\t}\n\tnaptr = ast_calloc(1, sizeof(*naptr) + size + flags_size + 1 + services_size + 1 + regexp_size + 1 + replacement_size + 1);\n\tif (!naptr) {\n\t\treturn NULL;\n\t}\n\tnaptr->order = order;\n\tnaptr->preference = preference;\n\tptr = naptr->data;\n\tptr += size;\n\tstrncpy(ptr, flags, flags_size);\n\tptr[flags_size] = '\\0';\n\tnaptr->flags = ptr;\n\tptr += flags_size + 1;\n\tstrncpy(ptr, services, services_size);\n\tptr[services_size] = '\\0';\n\tnaptr->service = ptr;\n\tptr += services_size + 1;\n\tstrncpy(ptr, regexp, regexp_size);\n\tptr[regexp_size] = '\\0';\n\tnaptr->regexp = ptr;\n\tptr += regexp_size + 1;\n\tstrcpy(ptr, replacement);\n\tnaptr->replacement = ptr;\n\tnaptr->generic.data_ptr = naptr->data;\n\treturn (struct ast_dns_record *)naptr;\n}\n", "bug_type": null, "idx": 998}
{"project": "Asterisk", "target": 0, "func": "char *dundi_hint2str(char *buf, int bufsiz, int flags)\n{\n\tstrcpy(buf, \"\");\n\tbuf[bufsiz-1] = '\\0';\n\tif (flags & DUNDI_HINT_TTL_EXPIRED) {\n\t\tstrncat(buf, \"TTLEXPIRED|\", bufsiz - strlen(buf) - 1);\n\t}\n\tif (flags & DUNDI_HINT_DONT_ASK) {\n\t\tstrncat(buf, \"DONTASK|\", bufsiz - strlen(buf) - 1);\n\t}\n\tif (flags & DUNDI_HINT_UNAFFECTED) {\n\t\tstrncat(buf, \"UNAFFECTED|\", bufsiz - strlen(buf) - 1);\n\t}\n\t\n\tif (ast_strlen_zero(buf))\n\t\tstrcpy(buf, \"NONE|\");\n\tbuf[strlen(buf)-1] = '\\0';\n\treturn buf;\n}\n", "bug_type": null, "idx": 999}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_bridges_clear_video_source(struct ast_variable *headers,\n\tstruct ast_ari_bridges_clear_video_source_args *args, struct ast_ari_response *response)\n{\n\tstruct ast_bridge *bridge;\n\tbridge = find_bridge(response, args->bridge_id);\n\tif (!bridge) {\n\t\treturn;\n\t}\n\tast_bridge_lock(bridge);\n\tast_bridge_set_talker_src_video_mode(bridge);\n\tast_bridge_unlock(bridge);\n\tao2_ref(bridge, -1);\n\tast_ari_response_no_content(response);\n}\n", "bug_type": null, "idx": 1000}
{"project": "Asterisk", "target": 0, "func": "\nvoid ast_channel_set_fd(struct ast_channel *chan, int which, int fd)\n{\n\tast_channel_internal_fd_set(chan, which, fd);\n\treturn;\n}\n", "bug_type": null, "idx": 1001}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int unreal_colp_redirect_indicate(struct ast_unreal_pvt *p, struct ast_channel *ast, int condition)\n{\n\tstruct ast_channel *my_chan;\n\tstruct ast_channel *my_owner;\n\tstruct ast_channel *this_channel;\n\tstruct ast_channel *the_other_channel;\n\tint isoutbound;\n\tint res = 0;\n\tunsigned char frame_data[1024];\n\tstruct ast_frame f = {\n\t\t.frametype = AST_FRAME_CONTROL,\n\t\t.subclass.integer = condition,\n\t\t.data.ptr = frame_data,\n\t};\n\t\n\tast_channel_unlock(ast);\n\tast_unreal_lock_all(p, &my_chan, &my_owner);\n\tisoutbound = AST_UNREAL_IS_OUTBOUND(ast, p);\n\tif (isoutbound) {\n\t\tthis_channel = p->chan;\n\t\tthe_other_channel = p->owner;\n\t} else {\n\t\tthis_channel = p->owner;\n\t\tthe_other_channel = p->chan;\n\t}\n\tif (the_other_channel) {\n\t\tif (condition == AST_CONTROL_CONNECTED_LINE) {\n\t\t\tast_connected_line_copy_to_caller(ast_channel_caller(the_other_channel),\n\t\t\t\tast_channel_connected(this_channel));\n\t\t\tf.datalen = ast_connected_line_build_data(frame_data, sizeof(frame_data),\n\t\t\t\tast_channel_connected(this_channel), NULL);\n\t\t} else {\n\t\t\tf.datalen = ast_redirecting_build_data(frame_data, sizeof(frame_data),\n\t\t\t\tast_channel_redirecting(this_channel), NULL);\n\t\t}\n\t}\n\tif (my_chan) {\n\t\tast_channel_unlock(my_chan);\n\t\tast_channel_unref(my_chan);\n\t}\n\tif (my_owner) {\n\t\tast_channel_unlock(my_owner);\n\t\tast_channel_unref(my_owner);\n\t}\n\tif (the_other_channel) {\n\t\tres = unreal_queue_frame(p, isoutbound, &f, ast, 0);\n\t}\n\tao2_unlock(p);\n\tast_channel_lock(ast);\n\treturn res;\n}\n", "bug_type": null, "idx": 1002}
{"project": "Asterisk", "target": 0, "func": "static void confbridge_join_cb(void *data, struct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tstruct ast_str *extra_text = NULL;\n\tif (!get_admin_header(&extra_text, message)) {\n\t\tconfbridge_publish_manager_event(message, \"ConfbridgeJoin\", extra_text);\n\t}\n\tast_free(extra_text);\n}\n", "bug_type": null, "idx": 1003}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct rbtree_node *rb_node_next(struct rbtree_node *node)\n{\n\tif (node->right) {\n\t\treturn rb_node_most_left(node->right);\n\t}\n\t\n\twhile (node->parent) {\n\t\tif (node->parent->left == node) {\n\t\t\t\n\t\t\treturn node->parent;\n\t\t}\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1004}
{"project": "Asterisk", "target": 0, "func": "int ast_endpoint_stasis_init(void)\n{\n\tint res = 0;\n\tast_register_cleanup(endpoints_stasis_cleanup);\n\tendpoint_cache_all = stasis_cp_all_create(\"endpoint_topic_all\",\n\t\tendpoint_snapshot_get_id);\n\tif (!endpoint_cache_all) {\n\t\treturn -1;\n\t}\n\tres |= STASIS_MESSAGE_TYPE_INIT(ast_endpoint_snapshot_type);\n\tres |= STASIS_MESSAGE_TYPE_INIT(ast_endpoint_state_type);\n\tres |= STASIS_MESSAGE_TYPE_INIT(ast_endpoint_contact_state_type);\n\treturn res;\n}\n", "bug_type": null, "idx": 1005}
{"project": "Asterisk", "target": 0, "func": "const struct ast_sdp *ast_sdp_state_get_local_sdp(struct ast_sdp_state *sdp_state)\n{\n\tast_assert(sdp_state != NULL);\n\tif (sdp_state->role == SDP_ROLE_NOT_SET) {\n\t\tast_assert(sdp_state->local_sdp == NULL);\n\t\tsdp_state->role = SDP_ROLE_OFFERER;\n\t\tsdp_state->local_sdp = sdp_create_from_state(sdp_state, sdp_state->proposed_capabilities);\n\t}\n\treturn sdp_state->local_sdp;\n}\n", "bug_type": null, "idx": 1006}
{"project": "Asterisk", "target": 0, "func": "static int radius_log(struct ast_cdr *cdr)\n{\n\tint result = ERROR_RC;\n\tVALUE_PAIR *tosend = NULL;\n\tif (build_radius_record(&tosend, cdr)) {\n\t\tast_debug(1, \"Unable to create RADIUS record. CDR not recorded!\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tresult = rc_acct(rh, 0, tosend);\n\tif (result != OK_RC) {\n\t\tast_log(LOG_ERROR, \"Failed to record Radius CDR record!\\n\");\n\t}\nreturn_cleanup:\n\tif (tosend) {\n\t\trc_avpair_free(tosend);\n\t}\n\treturn result;\n}\n", "bug_type": null, "idx": 1007}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic struct dahdi_pvt *duplicate_pseudo(struct dahdi_pvt *src)\n{\n\tstruct dahdi_pvt *p;\n\tstruct dahdi_bufferinfo bi;\n\tint res;\n\tp = ast_malloc(sizeof(*p));\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\t*p = *src;\n\t\n\tp->cc_params = ast_cc_config_params_init();\n\tif (!p->cc_params) {\n\t\tast_free(p);\n\t\treturn NULL;\n\t}\n\tast_cc_copy_config_params(p->cc_params, src->cc_params);\n\tp->which_iflist = DAHDI_IFLIST_NONE;\n\tp->next = NULL;\n\tp->prev = NULL;\n\tast_mutex_init(&p->lock);\n\tp->subs[SUB_REAL].dfd = dahdi_open(\"/dev/dahdi/pseudo\");\n\tif (p->subs[SUB_REAL].dfd < 0) {\n\t\tast_log(LOG_ERROR, \"Unable to dup channel: %s\\n\", strerror(errno));\n\t\tdestroy_dahdi_pvt(p);\n\t\treturn NULL;\n\t}\n\tres = ioctl(p->subs[SUB_REAL].dfd, DAHDI_GET_BUFINFO, &bi);\n\tif (!res) {\n\t\tbi.txbufpolicy = src->buf_policy;\n\t\tbi.rxbufpolicy = src->buf_policy;\n\t\tbi.numbufs = src->buf_no;\n\t\tres = ioctl(p->subs[SUB_REAL].dfd, DAHDI_SET_BUFINFO, &bi);\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_WARNING, \"Unable to set buffer policy on dup channel: %s\\n\", strerror(errno));\n\t\t}\n\t} else\n\t\tast_log(LOG_WARNING, \"Unable to check buffer policy on dup channel: %s\\n\", strerror(errno));\n\tp->destroy = 1;\n\tdahdi_iflist_insert(p);\n\treturn p;\n}\n", "bug_type": null, "idx": 1008}
{"project": "Asterisk", "target": 0, "func": "void callerid_free(struct callerid_state *cid)\n{\n\tast_free(cid);\n}\n", "bug_type": null, "idx": 1009}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct dial_masquerade_datastore *dial_masquerade_datastore_add(\n\tstruct ast_channel *chan, struct dial_masquerade_datastore *masq_data)\n{\n\tstruct ast_datastore *datastore;\n\tdatastore = ast_datastore_alloc(!masq_data ? &dial_masquerade_caller_info : &dial_masquerade_info, NULL);\n\tif (!datastore) {\n\t\treturn NULL;\n\t}\n\tif (!masq_data) {\n\t\tmasq_data = dial_masquerade_datastore_alloc();\n\t\tif (!masq_data) {\n\t\t\tast_datastore_free(datastore);\n\t\t\treturn NULL;\n\t\t}\n\t\tmasq_data->caller = chan;\n\t}\n\tdatastore->data = masq_data;\n\tast_channel_datastore_add(chan, datastore);\n\treturn masq_data;\n}\n", "bug_type": null, "idx": 1010}
{"project": "Asterisk", "target": 0, "func": "\nstatic int resampler_basic_direct_double(SpeexResamplerState *st, spx_uint32_t channel_index, const spx_word16_t *in, spx_uint32_t *in_len, spx_word16_t *out, spx_uint32_t *out_len)\n{\n   const int N = st->filt_len;\n   int out_sample = 0;\n   int last_sample = st->last_sample[channel_index];\n   spx_uint32_t samp_frac_num = st->samp_frac_num[channel_index];\n   const spx_word16_t *sinc_table = st->sinc_table;\n   const int out_stride = st->out_stride;\n   const int int_advance = st->int_advance;\n   const int frac_advance = st->frac_advance;\n   const spx_uint32_t den_rate = st->den_rate;\n   double sum;\n   int j;\n   while (!(last_sample >= (spx_int32_t)*in_len || out_sample >= (spx_int32_t)*out_len))\n   {\n      const spx_word16_t *sinc = & sinc_table[samp_frac_num*N];\n      const spx_word16_t *iptr = & in[last_sample];\n#ifndef OVERRIDE_INNER_PRODUCT_DOUBLE\n      double accum[4] = {0,0,0,0};\n      for(j=0;j<N;j+=4) {\n        accum[0] += sinc[j]*iptr[j];\n        accum[1] += sinc[j+1]*iptr[j+1];\n        accum[2] += sinc[j+2]*iptr[j+2];\n        accum[3] += sinc[j+3]*iptr[j+3];\n      }\n      sum = accum[0] + accum[1] + accum[2] + accum[3];\n#else\n      sum = inner_product_double(sinc, iptr, N);\n#endif\n      out[out_stride * out_sample++] = PSHR32(sum, 15);\n      last_sample += int_advance;\n      samp_frac_num += frac_advance;\n      if (samp_frac_num >= den_rate)\n      {\n         samp_frac_num -= den_rate;\n         last_sample++;\n      }\n   }\n   st->last_sample[channel_index] = last_sample;\n   st->samp_frac_num[channel_index] = samp_frac_num;\n   return out_sample;\n}\n", "bug_type": null, "idx": 1011}
{"project": "Asterisk", "target": 0, "func": "\nstatic int pickup_by_exten(struct ast_channel *chan, const char *exten, const char *context)\n{\n\tstruct ast_channel *target = NULL;\n\tstruct ast_channel_iterator *iter;\n\tint res = -1;\n\tif (!(iter = ast_channel_iterator_by_exten_new(exten, context))) {\n\t\treturn -1;\n\t}\n\twhile ((target = ast_channel_iterator_next(iter))) {\n\t\tast_channel_lock(target);\n\t\tif ((chan != target) && ast_can_pickup(target)) {\n\t\t\tast_log(LOG_NOTICE, \"%s pickup by %s\\n\", ast_channel_name(target), ast_channel_name(chan));\n\t\t\tbreak;\n\t\t}\n\t\tast_channel_unlock(target);\n\t\ttarget = ast_channel_unref(target);\n\t}\n\tast_channel_iterator_destroy(iter);\n\tif (target) {\n\t\tres = ast_do_pickup(chan, target);\n\t\tast_channel_unlock(target);\n\t\ttarget = ast_channel_unref(target);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1012}
{"project": "Asterisk", "target": 0, "func": "\nstatic int unload_module(void)\n{\n\tast_sip_session_unregister_sdp_handler(&image_sdp_handler, \"image\");\n\tast_sip_session_unregister_supplement(&t38_supplement);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1013}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int bridge_base_get_merge_priority(struct ast_bridge *self)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1014}
{"project": "Asterisk", "target": 0, "func": "int ooStopMonitorCalls()\n{\n   OOH323CallData * call;\n   if(gMonitor)\n   {\n      OOTRACEINFO1(\"Doing ooStopMonitorCalls\\n\");\n      if(gH323ep.cmdSock)\n      {\n         ooCloseCmdConnection();\n      }\n      if(gH323ep.callList)\n      {\n         OOTRACEWARN1(\"Warn:Abruptly ending calls as stack going down\\n\");\n         call = gH323ep.callList;\n         while(call)\n         {\n            OOTRACEWARN3(\"Clearing call (%s, %s)\\n\", call->callType, \n                          call->callToken);\n            call->callEndReason = OO_REASON_LOCAL_CLEARED;\n            ooCleanCall(call);\n            call = NULL;\n            call = gH323ep.callList;\n         }\n         gH323ep.callList = NULL;\n      }\n      OOTRACEINFO1(\"Stopping listener for incoming calls\\n\");   \n      if(gH323ep.listener)\n      {\n         ooSocketClose(*(gH323ep.listener));\n         memFreePtr(&gH323ep.ctxt, gH323ep.listener);\n         gH323ep.listener = NULL;\n      }\n      gMonitor = FALSE;\n      OOTRACEINFO1(\"Done ooStopMonitorCalls\\n\");\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1015}
{"project": "Asterisk", "target": 0, "func": "struct ast_json_iter *ast_json_object_iter_next(struct ast_json *object, struct ast_json_iter *iter)\n{\n\treturn json_object_iter_next((json_t *)object, iter);\n}\n", "bug_type": null, "idx": 1016}
{"project": "Asterisk", "target": 0, "func": "static struct unistim_subchannel *find_subchannel_by_name(const char *dest)\n{\n\tstruct unistim_line *l;\n\tstruct unistim_device *d;\n\tstruct unistim_subchannel *sub = NULL;\n\tchar line[256];\n\tchar *at;\n\tchar *device;\n\tast_copy_string(line, dest, sizeof(line));\n\tat = strchr(line, '@');\n\tif (!at) {\n\t\tast_log(LOG_NOTICE, \"Device '%s' has no @ (at) sign!\\n\", dest);\n\t\treturn NULL;\n\t}\n\t*at = '\\0';\n\tat++;\n\tdevice = at;\n\tast_mutex_lock(&devicelock);\n\td = devices;\n\tat = strchr(device, '/');       \n\tif (at) {\n\t\t*at = '\\0';\n\t}\n\twhile (d) {\n\t\tif (!strcasecmp(d->name, device)) {\n\t\t\tif (unistimdebug) {\n\t\t\t\tast_verb(0, \"Found device: %s\\n\", d->name);\n\t\t\t}\n\t\t\t\n\t\t\tAST_LIST_LOCK(&d->lines);\n\t\t\tAST_LIST_TRAVERSE(&d->lines, l, list) {\n\t\t\t\t\n\t\t\t\tif (!strcasecmp(l->name, line)) {\n\t\t\t\t\tif (unistimdebug) {\n\t\t\t\t\t\tast_verb(0, \"Found line: %s\\n\", l->name);\n\t\t\t\t\t}\n\t\t\t\t\tsub = get_sub(d, SUB_REAL);\n\t\t\t\t\tif (!sub) {\n\t\t\t\t\t\tsub = unistim_alloc_sub(d, SUB_REAL);\n\t\t\t\t\t}\n\t\t\t\t\tif (sub->owner) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tsub = unistim_alloc_sub(d, SUB_ONHOLD);\n\t\t\t\t\t}\n\t\t\t\t\tsub->ringvolume = -1;\n\t\t\t\t\tsub->ringstyle = -1;\n\t\t\t\t\tif (at) {       \n\t\t\t\t\t\tat++;   \n\t\t\t\t\t\tif (*at == 'r') {       \n\t\t\t\t\t\t\tat++;\n\t\t\t\t\t\t\tif ((*at < '0') || (*at > '7')) { \n\t\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Invalid ring selection (%s)\", at);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsigned char ring_volume = -1;\n\t\t\t\t\t\t\t\tsigned char ring_style = *at - '0';\n\t\t\t\t\t\t\t\tat++;\n\t\t\t\t\t\t\t\tif ((*at >= '0') && (*at <= '3')) {      \n\t\t\t\t\t\t\t\t\tring_volume = *at - '0';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (unistimdebug) {\n\t\t\t\t\t\t\t\t\tast_verb(0, \"Distinctive ring: style #%d volume %d\\n\",\n\t\t\t\t\t\t\t\t\t\t ring_style, ring_volume);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsub->ringvolume = ring_volume;\n\t\t\t\t\t\t\t\tsub->ringstyle = ring_style;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsub->parent = l;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAST_LIST_UNLOCK(&d->lines);\n\t\t\tif (sub) {\n\t\t\t\tast_mutex_unlock(&devicelock);\n\t\t\t\treturn sub;\n\t\t\t}\n\t\t}\n\t\td = d->next;\n\t}\n\t\n\tast_mutex_unlock(&devicelock);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1017}
{"project": "Asterisk", "target": 0, "func": "void ast_framehook_list_fixup(struct ast_channel *old_chan, struct ast_channel *new_chan)\n{\n\tstruct ast_framehook *framehook;\n\tint moved_framehook_id;\n\tif (ast_channel_framehooks(new_chan)) {\n\t\tAST_LIST_TRAVERSE_SAFE_BEGIN(&ast_channel_framehooks(new_chan)->list, framehook, list) {\n\t\t\tif (framehook->i.disable_inheritance) {\n\t\t\t\tast_framehook_detach(new_chan, framehook->id);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (framehook->i.chan_breakdown_cb) {\n\t\t\t\tframehook->i.chan_breakdown_cb(framehook->i.data, framehook->id,\n\t\t\t\t\told_chan, new_chan);\n\t\t\t}\n\t\t}\n\t\tAST_LIST_TRAVERSE_SAFE_END;\n\t}\n\tif (!ast_channel_framehooks(old_chan)) {\n\t\treturn;\n\t}\n\tif (!AST_LIST_EMPTY(&ast_channel_framehooks(old_chan)->list)\n\t\t&& ast_channel_is_bridged(old_chan)) {\n\t\tast_channel_set_unbridged_nolock(old_chan, 1);\n\t}\n\twhile ((framehook = AST_LIST_REMOVE_HEAD(&ast_channel_framehooks(old_chan)->list, list))) {\n\t\t\n\t\tif (framehook->i.disable_inheritance) {\n\t\t\tframehook_detach(framehook, FRAMEHOOK_DETACH_DESTROY);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tmoved_framehook_id = ast_framehook_attach(new_chan, &framehook->i);\n\t\tif (moved_framehook_id < 0) {\n\t\t\tast_log(LOG_WARNING, \"Failed framehook copy during masquerade. Expect loss of features.\\n\");\n\t\t\tframehook_detach(framehook, FRAMEHOOK_DETACH_DESTROY);\n\t\t} else {\n\t\t\tif (framehook->i.chan_fixup_cb) {\n\t\t\t\tframehook->i.chan_fixup_cb(framehook->i.data, moved_framehook_id,\n\t\t\t\t\told_chan, new_chan);\n\t\t\t}\n\t\t\tframehook_detach(framehook, FRAMEHOOK_DETACH_PRESERVE);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1018}
{"project": "Asterisk", "target": 0, "func": "pval *pvalMacroWalkStatements( pval *p, pval **next_statement )\n{\n\tif (!pvalCheckType(p, \"pvalMacroWalkStatements\", PV_MACRO))\n\t\treturn 0;\n\tif (!(*next_statement))\n\t\t*next_statement = p->u3.macro_statements;\n\telse {\n\t\t*next_statement = (*next_statement)->next;\n\t}\n\treturn *next_statement;\n}\n", "bug_type": null, "idx": 1019}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void database_increment(char *key)\n{\n\tunsigned v;\n\tchar value[16];\n\tif (ast_strlen_zero(db_family)) {\n\t\treturn;\t\n\t}\n\tif (ast_db_get(db_family, key, value, sizeof(value) - 1)) {\n\t\tast_verb(4, \"AlarmReceiver: Creating database entry %s and setting to 1\\n\", key);\n\t\t\n\t\tast_db_put(db_family, key, \"1\");\n\t\treturn;\n\t}\n\tsscanf(value, \"%30u\", &v);\n\tv++;\n\tast_verb(4, \"AlarmReceiver: New value for %s: %u\\n\", key, v);\n\tsnprintf(value, sizeof(value), \"%u\", v);\n\tif (ast_db_put(db_family, key, value)) {\n\t\tast_verb(4, \"AlarmReceiver: database_increment write error\\n\");\n\t}\n\treturn;\n}\n", "bug_type": null, "idx": 1020}
{"project": "Asterisk", "target": 0, "func": "#endif\t\nstatic void parse_setup (struct isdn_msg msgs[], msg_t *msg, struct misdn_bchannel *bc, int nt)\n{\n\tint HEADER_LEN = nt?mISDNUSER_HEAD_SIZE:mISDN_HEADER_LEN;\n\tSETUP_t *setup = (SETUP_t *) (msg->data + HEADER_LEN);\n\tQ931_info_t *qi = (Q931_info_t *) (msg->data + HEADER_LEN);\n\tint type;\n\tint plan;\n\tint present;\n\tint screen;\n\tint reason;\n#ifdef DEBUG\n\tprintf(\"Parsing SETUP Msg\\n\");\n#endif\n\tdec_ie_calling_pn(setup->CALLING_PN, qi, &type, &plan, &present, &screen, bc->caller.number, sizeof(bc->caller.number), nt, bc);\n\tbc->caller.number_type = type;\n\tbc->caller.number_plan = plan;\n\tswitch (present) {\n\tdefault:\n\tcase 0:\n\t\tbc->caller.presentation = 0;\t\n\t\tbreak;\n\tcase 1:\n\t\tbc->caller.presentation = 1;\t\n\t\tbreak;\n\tcase 2:\n\t\tbc->caller.presentation = 2;\t\n\t\tbreak;\n\t}\n\tif (0 <= screen) {\n\t\tbc->caller.screening = screen;\n\t} else {\n\t\tbc->caller.screening = 0;\t\n\t}\n\tdec_ie_facility(setup->FACILITY, (Q931_info_t *) setup, &bc->fac_in, nt, bc);\n\tdec_ie_called_pn(setup->CALLED_PN, (Q931_info_t *) setup, &type, &plan, bc->dialed.number, sizeof(bc->dialed.number), nt, bc);\n\tbc->dialed.number_type = type;\n\tbc->dialed.number_plan = plan;\n\tdec_ie_keypad(setup->KEYPAD, (Q931_info_t *) setup, bc->keypad, sizeof(bc->keypad), nt, bc);\n\tdec_ie_complete(setup->COMPLETE, (Q931_info_t *) setup, &bc->sending_complete, nt, bc);\n\tdec_ie_redir_nr(setup->REDIR_NR, (Q931_info_t *) setup, &type, &plan, &present, &screen, &reason, bc->redirecting.from.number, sizeof(bc->redirecting.from.number), nt, bc);\n\tbc->redirecting.from.number_type = type;\n\tbc->redirecting.from.number_plan = plan;\n\tswitch (present) {\n\tdefault:\n\tcase 0:\n\t\tbc->redirecting.from.presentation = 0;\t\n\t\tbreak;\n\tcase 1:\n\t\tbc->redirecting.from.presentation = 1;\t\n\t\tbreak;\n\tcase 2:\n\t\tbc->redirecting.from.presentation = 2;\t\n\t\tbreak;\n\t}\n\tif (0 <= screen) {\n\t\tbc->redirecting.from.screening = screen;\n\t} else {\n\t\tbc->redirecting.from.screening = 0;\t\n\t}\n\tif (0 <= reason) {\n\t\tbc->redirecting.reason = reason;\n\t} else {\n\t\tbc->redirecting.reason = mISDN_REDIRECTING_REASON_UNKNOWN;\n\t}\n\t{\n\t\tint  coding, capability, mode, rate, multi, user, async, urate, stopbits, dbits, parity;\n\t\tdec_ie_bearer(setup->BEARER, (Q931_info_t *)setup, &coding, &capability, &mode, &rate, &multi, &user, &async, &urate, &stopbits, &dbits, &parity, nt,bc);\n\t\tswitch (capability) {\n\t\tcase -1: bc->capability=INFO_CAPABILITY_DIGITAL_UNRESTRICTED;\n\t\t\tbreak;\n\t\tcase 0: bc->capability=INFO_CAPABILITY_SPEECH;\n\t\t\tbreak;\n\t\tcase 18: bc->capability=INFO_CAPABILITY_VIDEO;\n\t\t\tbreak;\n\t\tcase 8: bc->capability=INFO_CAPABILITY_DIGITAL_UNRESTRICTED;\n\t\t\tbc->user1 = user;\n\t\t\tbc->urate = urate;\n\t\t\tbc->rate = rate;\n\t\t\tbc->mode = mode;\n\t\t\tbreak;\n\t\tcase 9: bc->capability=INFO_CAPABILITY_DIGITAL_RESTRICTED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tswitch(user) {\n\t\tcase 2:\n\t\t\tbc->law=INFO_CODEC_ULAW;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbc->law=INFO_CODEC_ALAW;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbc->law=INFO_CODEC_ALAW;\n\t\t}\n\t\tbc->capability=capability;\n\t}\n\t{\n\t\tint  exclusive, channel;\n\t\tdec_ie_channel_id(setup->CHANNEL_ID, (Q931_info_t *)setup, &exclusive, &channel, nt,bc);\n\t\tset_channel(bc,channel);\n\t}\n\t{\n\t\tint  protocol ;\n\t\tdec_ie_useruser(setup->USER_USER, (Q931_info_t *)setup, &protocol, bc->uu, &bc->uulen, nt,bc);\n\t\tif (bc->uulen) cb_log(1, bc->port, \"USERUSERINFO:%s\\n\", bc->uu);\n\t\telse\n\t\tcb_log(1, bc->port, \"NO USERUSERINFO\\n\");\n\t}\n\tdec_ie_progress(setup->PROGRESS, (Q931_info_t *)setup, &bc->progress_coding, &bc->progress_location, &bc->progress_indicator, nt, bc);\n#if defined(AST_MISDN_ENHANCEMENTS)\n\textract_setup_Bc_Hlc_Llc(setup, nt, bc);\n#endif\t\n}\n", "bug_type": null, "idx": 1021}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tRAII_VAR(struct stasis_message_router *, router, ast_cdr_message_router(), ao2_cleanup);\n\tint res = 0;\n\tif (!router) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tres |= STASIS_MESSAGE_TYPE_INIT(cdr_read_message_type);\n\tres |= STASIS_MESSAGE_TYPE_INIT(cdr_write_message_type);\n\tres |= STASIS_MESSAGE_TYPE_INIT(cdr_prop_write_message_type);\n\tres |= ast_custom_function_register(&cdr_function);\n\tres |= ast_custom_function_register(&cdr_prop_function);\n\tres |= stasis_message_router_add(router, cdr_prop_write_message_type(),\n\t                                 cdr_prop_write_callback, NULL);\n\tres |= stasis_message_router_add(router, cdr_write_message_type(),\n\t                                 cdr_write_callback, NULL);\n\tres |= stasis_message_router_add(router, cdr_read_message_type(),\n\t                                 cdr_read_callback, NULL);\n\tif (res) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1022}
{"project": "Asterisk", "target": 0, "func": "*/\nint ast_transfer(struct ast_channel *chan, char *dest)\n{\n\tint res = -1;\n\t\n\tast_channel_lock(chan);\n\tif (!ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE) && !ast_check_hangup(chan)) {\n\t\tif (ast_channel_tech(chan)->transfer) {\n\t\t\tres = ast_channel_tech(chan)->transfer(chan, dest);\n\t\t\tif (!res)\n\t\t\t\tres = 1;\n\t\t} else\n\t\t\tres = 0;\n\t}\n\tast_channel_unlock(chan);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\tfor (;;) {\n\t\tstruct ast_frame *fr;\n\t\tres = ast_waitfor(chan, -1);\n\t\tif (res < 0 || !(fr = ast_read(chan))) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (fr->frametype == AST_FRAME_CONTROL && fr->subclass.integer == AST_CONTROL_TRANSFER) {\n\t\t\tenum ast_control_transfer *message = fr->data.ptr;\n\t\t\tif (*message == AST_TRANSFER_SUCCESS) {\n\t\t\t\tres = 1;\n\t\t\t} else {\n\t\t\t\tres = -1;\n\t\t\t}\n\t\t\tast_frfree(fr);\n\t\t\tbreak;\n\t\t}\n\t\tast_frfree(fr);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1023}
{"project": "Asterisk", "target": 0, "func": "static void pending_members_remove(struct member *mem)\n{\n\tast_debug(3, \"Removed %s from pending_members\\n\", mem->membername);\n\tao2_find(pending_members, mem, OBJ_POINTER | OBJ_NODATA | OBJ_UNLINK);\n}\n", "bug_type": null, "idx": 1024}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int dahdi_pri_cc_agent_init(struct ast_cc_agent *agent, struct ast_channel *chan)\n{\n\tstruct dahdi_pvt *pvt;\n\tstruct sig_pri_chan *pvt_chan;\n\tint res;\n\tast_assert(!strcmp(ast_channel_tech(chan)->type, \"DAHDI\"));\n\tpvt = ast_channel_tech_pvt(chan);\n\tif (dahdi_sig_pri_lib_handles(pvt->sig)) {\n\t\tpvt_chan = pvt->sig_pvt;\n\t} else {\n\t\tpvt_chan = NULL;\n\t}\n\tif (!pvt_chan) {\n\t\treturn -1;\n\t}\n\tast_module_ref(ast_module_info->self);\n\tres = sig_pri_cc_agent_init(agent, pvt_chan);\n\tif (res) {\n\t\tast_module_unref(ast_module_info->self);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1025}
{"project": "Asterisk", "target": 0, "func": "AST_RWLIST_HEAD_STATIC(cc_monitor_backends, cc_monitor_backend);\nint ast_cc_monitor_register(const struct ast_cc_monitor_callbacks *callbacks)\n{\n\tstruct cc_monitor_backend *backend = ast_calloc(1, sizeof(*backend));\n\tif (!backend) {\n\t\treturn -1;\n\t}\n\tbackend->callbacks = callbacks;\n\tAST_RWLIST_WRLOCK(&cc_monitor_backends);\n\tAST_RWLIST_INSERT_TAIL(&cc_monitor_backends, backend, next);\n\tAST_RWLIST_UNLOCK(&cc_monitor_backends);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1026}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ogg_vorbis_rewrite(struct ast_filestream *s,\n\t\t\t\t\t\t const char *comment)\n{\n\togg_packet header;\n\togg_packet header_comm;\n\togg_packet header_code;\n\tstruct ogg_vorbis_desc *tmp = (struct ogg_vorbis_desc *) s->_private;\n\ttmp->writing = 1;\n\ttmp->writing_pcm_pos = 0;\n\tvorbis_info_init(&tmp->vi);\n\tif (vorbis_encode_init_vbr(&tmp->vi, 1, DEFAULT_SAMPLE_RATE, 0.4)) {\n\t\tast_log(LOG_ERROR, \"Unable to initialize Vorbis encoder!\\n\");\n\t\tvorbis_info_clear(&tmp->vi);\n\t\treturn -1;\n\t}\n\tvorbis_comment_init(&tmp->vc);\n\tvorbis_comment_add_tag(&tmp->vc, \"ENCODER\", \"Asterisk PBX\");\n\tif (comment)\n\t\tvorbis_comment_add_tag(&tmp->vc, \"COMMENT\", (char *) comment);\n\tvorbis_analysis_init(&tmp->vd, &tmp->vi);\n\tvorbis_block_init(&tmp->vd, &tmp->vb);\n\togg_stream_init(&tmp->os, ast_random());\n\tvorbis_analysis_headerout(&tmp->vd, &tmp->vc, &header, &header_comm,\n\t\t\t\t  &header_code);\n\togg_stream_packetin(&tmp->os, &header);\n\togg_stream_packetin(&tmp->os, &header_comm);\n\togg_stream_packetin(&tmp->os, &header_code);\n\twhile (!tmp->eos) {\n\t\tif (ogg_stream_flush(&tmp->os, &tmp->og) == 0)\n\t\t\tbreak;\n\t\tif (fwrite(tmp->og.header, 1, tmp->og.header_len, s->f) != tmp->og.header_len) {\n\t\t\tast_log(LOG_WARNING, \"fwrite() failed: %s\\n\", strerror(errno));\n\t\t}\n\t\tif (fwrite(tmp->og.body, 1, tmp->og.body_len, s->f) != tmp->og.body_len) {\n\t\t\tast_log(LOG_WARNING, \"fwrite() failed: %s\\n\", strerror(errno));\n\t\t}\n\t\tif (ogg_page_eos(&tmp->og))\n\t\t\ttmp->eos = 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1027}
{"project": "Asterisk", "target": 0, "func": "void AST_OPTIONAL_API_NAME(ast_statsd_log_string)(const char *metric_name,\n\tconst char *metric_type, const char *value, double sample_rate)\n{\n\tstruct conf *cfg;\n\tstruct ast_str *msg;\n\tsize_t len;\n\tstruct ast_sockaddr statsd_server;\n\tif (socket_fd == -1) {\n\t\treturn;\n\t}\n\t\n\tif (sample_rate <= 0.0 ||\n\t\t(sample_rate < 1.0 && sample_rate < ast_random_double())) {\n\t\treturn;\n\t}\n\tcfg = ao2_global_obj_ref(confs);\n\tconf_server(cfg, &statsd_server);\n\tmsg = ast_str_create(40);\n\tif (!msg) {\n\t\tao2_cleanup(cfg);\n\t\treturn;\n\t}\n\tif (!ast_strlen_zero(cfg->global->prefix)) {\n\t\tast_str_append(&msg, 0, \"%s.\", cfg->global->prefix);\n\t}\n\tast_str_append(&msg, 0, \"%s:%s|%s\", metric_name, value, metric_type);\n\tif (sample_rate < 1.0) {\n\t\tast_str_append(&msg, 0, \"|@%.2f\", sample_rate);\n\t}\n\tif (cfg->global->add_newline) {\n\t\tast_str_append(&msg, 0, \"\\n\");\n\t}\n\tlen = ast_str_strlen(msg);\n\tast_debug(6, \"Sending statistic %s to StatsD server\\n\", ast_str_buffer(msg));\n\tast_sendto(socket_fd, ast_str_buffer(msg), len, 0, &statsd_server);\n\tao2_cleanup(cfg);\n\tast_free(msg);\n}\n", "bug_type": null, "idx": 1028}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void misdn_update_remote_party(struct ast_channel *ast, const struct misdn_party_id *id, enum AST_CONNECTED_LINE_UPDATE_SOURCE source, char *cid_tag)\n{\n\tmisdn_update_caller_id(ast, id, cid_tag);\n\tmisdn_queue_connected_line_update(ast, id, source, cid_tag);\n}\n", "bug_type": null, "idx": 1029}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *jb_create_adaptive(struct ast_jb_conf *general_config)\n{\n\tjb_conf jbconf;\n\tjitterbuf *adaptivejb;\n\tadaptivejb = jb_new();\n\tif (adaptivejb) {\n\t\tjbconf.max_jitterbuf = general_config->max_size;\n\t\tjbconf.resync_threshold = general_config->resync_threshold;\n\t\tjbconf.max_contig_interp = 10;\n\t\tjbconf.target_extra = general_config->target_extra;\n\t\tjb_setconf(adaptivejb, &jbconf);\n\t}\n\treturn adaptivejb;\n}\n", "bug_type": null, "idx": 1030}
{"project": "Asterisk", "target": 0, "func": "static int register_request(struct dundi_request *dr, struct dundi_request **pending)\n{\n\tstruct dundi_request *cur;\n\tint res=0;\n\tchar eid_str[20];\n\tAST_LIST_LOCK(&peers);\n\tAST_LIST_TRAVERSE(&requests, cur, list) {\n\t\tast_debug(1, \"Checking '%s@%s' vs '%s@%s'\\n\", cur->dcontext, cur->number,\n\t\t\tdr->dcontext, dr->number);\n\t\tif (!strcasecmp(cur->dcontext, dr->dcontext) &&\n\t\t    !strcasecmp(cur->number, dr->number) &&\n\t\t    (!ast_eid_cmp(&cur->root_eid, &dr->root_eid) || (cur->crc32 == dr->crc32))) {\n\t\t\tast_debug(1, \"Found existing query for '%s@%s' for '%s' crc '%08x'\\n\",\n\t\t\t\tcur->dcontext, cur->number, ast_eid_to_str(eid_str, sizeof(eid_str), &cur->root_eid), cur->crc32);\n\t\t\t*pending = cur;\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\tast_debug(1, \"Registering request for '%s@%s' on behalf of '%s' crc '%08x'\\n\",\n\t\t\t\tdr->number, dr->dcontext, ast_eid_to_str(eid_str, sizeof(eid_str), &dr->root_eid), dr->crc32);\n\t\t\n\t\tAST_LIST_INSERT_HEAD(&requests, dr, list);\n\t\t*pending = NULL;\n\t}\n\tAST_LIST_UNLOCK(&peers);\n\treturn res;\n}\n", "bug_type": null, "idx": 1031}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_format_def_unregister(gsm_f.name);\n}\n", "bug_type": null, "idx": 1032}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int asterisk_start_mwi_publishing(struct ast_sip_outbound_publish *configuration,\n\tstruct ast_sip_outbound_publish_client *client)\n{\n\tRAII_VAR(struct ast_datastore *, datastore, NULL, ao2_cleanup);\n\tstruct asterisk_mwi_publisher_state *publisher_state;\n\tconst char *value;\n\tstruct ao2_container *cached;\n\tdatastore = ast_sip_publish_client_alloc_datastore(&asterisk_mwi_publisher_state_datastore, \"asterisk-mwi-publisher\");\n\tif (!datastore) {\n\t\treturn -1;\n\t}\n\tpublisher_state = ast_calloc(1, sizeof(struct asterisk_mwi_publisher_state));\n\tif (!publisher_state) {\n\t\treturn -1;\n\t}\n\tdatastore->data = publisher_state;\n\tvalue = ast_sorcery_object_get_extended(configuration, \"mailbox_state_filter\");\n\tif (!ast_strlen_zero(value)) {\n\t\tif (build_regex(&publisher_state->mailbox_state_regex, value)) {\n\t\t\treturn -1;\n\t\t}\n\t\tpublisher_state->mailbox_state_filter = 1;\n\t}\n\tpublisher_state->client = ao2_bump(client);\n\tif (ast_sip_publish_client_add_datastore(client, datastore)) {\n\t\treturn -1;\n\t}\n\tpublisher_state->mailbox_state_subscription = stasis_subscribe(ast_mwi_topic_all(),\n\t\tasterisk_publisher_mwistate_cb, ao2_bump(datastore));\n\tif (!publisher_state->mailbox_state_subscription) {\n\t\tast_sip_publish_client_remove_datastore(client, \"asterisk-mwi-publisher\");\n\t\tao2_ref(datastore, -1);\n\t\treturn -1;\n\t}\n\tcached = stasis_cache_dump(ast_mwi_state_cache(), NULL);\n\tao2_callback(cached, OBJ_NODATA, cached_mwistate_cb, datastore);\n\tao2_ref(cached, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1033}
{"project": "Asterisk", "target": 1, "func": "\nchar *ast_uri_encode(const char *string, char *outbuf, int buflen, int doreserved) \n{\n\tchar *reserved = \";/?:@&=+$,# \";\t\n \tconst char *ptr  = string;\t\n\tchar *out = outbuf;\n\t\n\twhile (*ptr && out - outbuf < buflen - 1) {\n\t\tif ((*ptr < 32) || (doreserved && strchr(reserved, *ptr))) {\n\t\t\tif (out - outbuf >= buflen - 3) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tout += sprintf(out, \"%%%02x\", (unsigned char) *ptr);\n\t\t} else {\n\t\t\t*out = *ptr;\t\n\t\t\tout++;\n\t\t}\n\t\tptr++;\n\t}\n\tif (buflen) {\n\t\t*out = '\\0';\n\t}\n\treturn outbuf;\n}\n", "bug_type": "CVE-2011-0495", "idx": 1034}
{"project": "Asterisk", "target": 0, "func": "static regex_t *build_regex(const char *text)\n{\n\tint res;\n\tregex_t *regex;\n\tif (!(regex = ast_malloc(sizeof(*regex)))) {\n\t\treturn NULL;\n\t}\n\tif ((res = regcomp(regex, text, REG_EXTENDED | REG_ICASE | REG_NOSUB))) {\n\t\tsize_t len = regerror(res, regex, NULL, 0);\n\t\tchar buf[len];\n\t\tregerror(res, regex, buf, len);\n\t\tast_log(LOG_ERROR, \"Could not compile regex '%s': %s\\n\", text, buf);\n\t\tast_free(regex);\n\t\treturn NULL;\n\t}\n\treturn regex;\n}\n", "bug_type": null, "idx": 1035}
{"project": "Asterisk", "target": 0, "func": "static AVPicture *fill_pict(struct fbuf_t *b, AVPicture *p);\nvoid fbuf_free(struct fbuf_t *b)\n{\n\tstruct fbuf_t x = *b;\n\tif (b->data && b->size)\n\t\tast_free(b->data);\n\tmemset(b, '\\0', sizeof(*b));\n\t\n\tb->w = x.w;\n\tb->h = x.h;\n\tb->pix_fmt = x.pix_fmt;\n}\n", "bug_type": null, "idx": 1036}
{"project": "Asterisk", "target": 0, "func": "static int counter = 1;\nint ooGenerateOutgoingCallToken (char *callToken, size_t size)\n{\n   char aCallToken[200];\n   int  ret = 0;\n   ast_mutex_lock(&newCallLock);\n   sprintf (aCallToken, \"ooh323c_o_%d\", counter++);\n   if (counter > OO_MAX_CALL_TOKEN)\n      counter = 1;\n   ast_mutex_unlock(&newCallLock);\n   if ((strlen(aCallToken)+1) < size)\n      strcpy (callToken, aCallToken);\n   else {\n      ret = OO_FAILED;\n   }\n   return ret;\n}\n", "bug_type": null, "idx": 1037}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res = 0;\n\tif (parse_config(0))\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\tres |= ast_register_translator(&speextolin);\n\tres |= ast_register_translator(&lintospeex);\n\tres |= ast_register_translator(&speexwbtolin16);\n\tres |= ast_register_translator(&lin16tospeexwb);\n\tres |= ast_register_translator(&speexuwbtolin32);\n\tres |= ast_register_translator(&lin32tospeexuwb);\n\tif (res) {\n\t\tunload_module();\n\t\treturn res;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1038}
{"project": "Asterisk", "target": 0, "func": "\nstatic void bucket_destroy(void *obj)\n{\n\tstruct ast_bucket *bucket = obj;\n\tao2_cleanup(bucket->scheme_impl);\n\tast_string_field_free_memory(bucket);\n\tao2_cleanup(bucket->buckets);\n\tao2_cleanup(bucket->files);\n}\n", "bug_type": null, "idx": 1039}
{"project": "Asterisk", "target": 0, "func": "static int analog_tone_to_dahditone(enum analog_tone tone)\n{\n\tswitch (tone) {\n\tcase ANALOG_TONE_RINGTONE:\n\t\treturn DAHDI_TONE_RINGTONE;\n\tcase ANALOG_TONE_STUTTER:\n\t\treturn DAHDI_TONE_STUTTER;\n\tcase ANALOG_TONE_CONGESTION:\n\t\treturn DAHDI_TONE_CONGESTION;\n\tcase ANALOG_TONE_DIALTONE:\n\t\treturn DAHDI_TONE_DIALTONE;\n\tcase ANALOG_TONE_DIALRECALL:\n\t\treturn DAHDI_TONE_DIALRECALL;\n\tcase ANALOG_TONE_INFO:\n\t\treturn DAHDI_TONE_INFO;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n", "bug_type": null, "idx": 1040}
{"project": "Asterisk", "target": 0, "func": "static int reload(void)\n{\n\tif (aco_process_config(&cfg_info, 1) == ACO_PROCESS_ERROR) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1041}
{"project": "Asterisk", "target": 0, "func": "void ast_uuid_init(void)\n{\n\t\n\tuuid_t uu;\n\tint dev_urandom_fd;\n\tdev_urandom_fd = open(\"/dev/urandom\", O_RDONLY);\n\tif (dev_urandom_fd < 0) {\n\t\tast_log(LOG_WARNING, \"It appears your system does not have /dev/urandom on it. This\\n\"\n\t\t\t\t\"means that UUID generation will use a pseudorandom number generator. Since\\n\"\n\t\t\t\t\"the thread-safety of your system's random number generator cannot\\n\"\n\t\t\t\t\"be guaranteed, we have to synchronize UUID generation. This may result\\n\"\n\t\t\t\t\"in decreased performance. It is highly recommended that you set up your\\n\"\n\t\t\t\t\"system to have /dev/urandom\\n\");\n\t} else {\n\t\thas_dev_urandom = 1;\n\t\tclose(dev_urandom_fd);\n\t}\n\tuuid_generate_random(uu);\n\tast_debug(1, \"UUID system initiated\\n\");\n}\n", "bug_type": null, "idx": 1042}
{"project": "Asterisk", "target": 0, "func": "\nvi_replace_mode(EditLine *el, int c)\n{\n\tel->el_map.current = el->el_map.key;\n\tel->el_state.inputmode = MODE_REPLACE;\n\tel->el_chared.c_undo.action = CHANGE;\n\tel->el_chared.c_undo.ptr = el->el_line.cursor;\n\tel->el_chared.c_undo.isize = 0;\n\tel->el_chared.c_undo.dsize = 0;\n\treturn (CC_NORM);\n}\n", "bug_type": null, "idx": 1043}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(codec_register);\n\tAST_TEST_UNREGISTER(codec_register_twice);\n\tAST_TEST_UNREGISTER(codec_register_unknown);\n\tAST_TEST_UNREGISTER(codec_register_audio_no_sample_rate);\n\tAST_TEST_UNREGISTER(codec_get);\n\tAST_TEST_UNREGISTER(codec_get_unregistered);\n\tAST_TEST_UNREGISTER(codec_get_unknown);\n\tAST_TEST_UNREGISTER(codec_get_id);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1044}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int set_timeout(struct ast_channel *chan, unsigned int timeout)\n{\n\tstruct ast_datastore *datastore;\n\tstruct timeval *hangup_time;\n\thangup_time = ast_malloc(sizeof(struct timeval));\n\tdatastore = ast_datastore_alloc(&timeout_datastore, NULL);\n\tif (!datastore) {\n\t\treturn -1;\n\t}\n\t*hangup_time = ast_tvadd(ast_tvnow(), ast_samp2tv(timeout, 1));\n\tdatastore->data = hangup_time;\n\tast_channel_lock(chan);\n\tast_channel_datastore_add(chan, datastore);\n\tif (ast_channel_is_bridged(chan)) {\n\t\tset_interval_hook(chan);\n\t}\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1045}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_channel_establish_roles(struct ast_bridge_channel *bridge_channel)\n{\n\tstruct bridge_roles_datastore *roles_datastore;\n\tstruct bridge_role *role = NULL;\n\tstruct bridge_role_option *role_option;\n\tif (!bridge_channel->chan) {\n\t\tast_debug(2, \"Attempted to set roles on a bridge channel that has no associated channel. That's a bad idea.\\n\");\n\t\treturn -1;\n\t}\n\tif (bridge_channel->bridge_roles) {\n\t\tast_debug(2, \"Attempted to reset roles while roles were already established. Purge existing roles first.\\n\");\n\t\treturn -1;\n\t}\n\troles_datastore = fetch_bridge_roles_datastore(bridge_channel->chan);\n\tif (!roles_datastore) {\n\t\t\n\t\treturn 0;\n\t}\n\tif (!(bridge_channel->bridge_roles = ast_calloc(1, sizeof(*bridge_channel->bridge_roles)))) {\n\t\treturn -1;\n\t}\n\tAST_LIST_TRAVERSE(&roles_datastore->role_list, role, list) {\n\t\tstruct bridge_role *this_role_copy;\n\t\tif (setup_bridge_role(bridge_channel->bridge_roles, role->role)) {\n\t\t\t\n\t\t\tast_bridge_channel_clear_roles(bridge_channel);\n\t\t\treturn -1;\n\t\t}\n\t\tthis_role_copy = AST_LIST_LAST(&bridge_channel->bridge_roles->role_list);\n\t\tAST_LIST_TRAVERSE(&role->options, role_option, list) {\n\t\t\tif (setup_bridge_role_option(this_role_copy, role_option->option, role_option->value)) {\n\t\t\t\t\n\t\t\t\tast_bridge_channel_clear_roles(bridge_channel);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1046}
{"project": "Asterisk", "target": 0, "func": "static int cache_cmp(void *obj, void *arg, int flags)\n{\n\tstruct cache_entry *e = obj, *f = arg;\n\treturn e->priority != f->priority ? 0 :\n\t\tstrcmp(e->exten, f->exten) ? 0 :\n\t\tstrcmp(e->context, f->context) ? 0 :\n\t\tCMP_MATCH;\n}\n", "bug_type": null, "idx": 1047}
{"project": "Asterisk", "target": 0, "func": "static int adsi_query_cpeinfo(unsigned char *buf)\n{\n\tint bytes = 0;\n\tbuf[bytes++] = ADSI_QUERY_CONFIG;\n\t\n\tbytes++;\n\tbuf[1] = bytes - 2;\n\treturn bytes;\n}\n", "bug_type": null, "idx": 1048}
{"project": "Asterisk", "target": 0, "func": "static void display_mem_info(WINDOW *menu, struct member *mem, int start_y, int end)\n{\n\tchar buf[64];\n\tstruct reference *dep;\n\tstruct reference *con;\n\tstruct reference *use;\n\tint start_x = (max_x / 2 - MEMBER_INFO_LEFT_ADJ);\n\tint maxlen = (max_x - start_x);\n\twmove(menu, end - start_y + 1, 0);\n\twclrtoeol(menu);\n\twmove(menu, end - start_y + 2, 0);\n\twclrtoeol(menu);\n\twmove(menu, end - start_y + 3, 0);\n\twclrtoeol(menu);\n\twmove(menu, end - start_y + 4, 0);\n\twclrtoeol(menu);\n\twmove(menu, end - start_y + 5, 0);\n\twclrtoeol(menu);\n\twmove(menu, end - start_y + 6, 0);\n\twclrtoeol(menu);\n\twmove(menu, end - start_y + 7, 0);\n\twclrtoeol(menu);\n\tif (mem->displayname) {\n\t\tchar buf[maxlen + 1];\n\t\tchar *displayname = ast_strdupa(mem->displayname);\n\t\tchar *word;\n\t\tint current_line = 1;\n\t\tint new_line = 1;\n\t\tbuf[0] = '\\0';\n\t\twmove(menu, end - start_y + 1, start_x);\n\t\twhile ((word = strsep(&displayname, \" \"))) {\n\t\t\tif ((strlen(buf) + strlen(word) + 1) > maxlen) {\n\t\t\t\twaddstr(menu, buf);\n\t\t\t\tcurrent_line++;\n\t\t\t\twmove(menu, end - start_y + current_line, start_x);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tnew_line = 1;\n\t\t\t}\n\t\t\tsprintf(buf, \"%s%*.*s%s\", buf, new_line ? 0 : 1, new_line ? 0 : 1, \" \", word);\n\t\t\tnew_line = 0;\n\t\t}\n\t\tif (strlen(buf)) {\n\t\t\twaddstr(menu, buf);\n\t\t}\n\t}\n\tif (!AST_LIST_EMPTY(&mem->deps)) {\n\t\twmove(menu, end - start_y + 4, start_x);\n\t\tstrcpy(buf, \"Depends on: \");\n\t\tAST_LIST_TRAVERSE(&mem->deps, dep, list) {\n\t\t\tstrncat(buf, dep->displayname, sizeof(buf) - strlen(buf) - 1);\n\t\t\tstrncat(buf, dep->member ? \"(M)\" : \"(E)\", sizeof(buf) - strlen(buf) - 1);\n\t\t\tif (AST_LIST_NEXT(dep, list))\n\t\t\t\tstrncat(buf, \", \", sizeof(buf) - strlen(buf) - 1);\n\t\t}\n\t\twaddstr(menu, buf);\n\t}\n\tif (!AST_LIST_EMPTY(&mem->uses)) {\n\t\twmove(menu, end - start_y + 5, start_x);\n\t\tstrcpy(buf, \"Can use: \");\n\t\tAST_LIST_TRAVERSE(&mem->uses, use, list) {\n\t\t\tstrncat(buf, use->displayname, sizeof(buf) - strlen(buf) - 1);\n\t\t\tstrncat(buf, use->member ? \"(M)\" : \"(E)\", sizeof(buf) - strlen(buf) - 1);\n\t\t\tif (AST_LIST_NEXT(use, list))\n\t\t\t\tstrncat(buf, \", \", sizeof(buf) - strlen(buf) - 1);\n\t\t}\n\t\twaddstr(menu, buf);\n\t}\n\tif (!AST_LIST_EMPTY(&mem->conflicts)) {\n\t\twmove(menu, end - start_y + 6, start_x);\n\t\tstrcpy(buf, \"Conflicts with: \");\n\t\tAST_LIST_TRAVERSE(&mem->conflicts, con, list) {\n\t\t\tstrncat(buf, con->displayname, sizeof(buf) - strlen(buf) - 1);\n\t\t\tstrncat(buf, con->member ? \"(M)\" : \"(E)\", sizeof(buf) - strlen(buf) - 1);\n\t\t\tif (AST_LIST_NEXT(con, list))\n\t\t\t\tstrncat(buf, \", \", sizeof(buf) - strlen(buf) - 1);\n\t\t}\n\t\twaddstr(menu, buf);\n\t}\n\tif (!mem->is_separator) { \n\t\t{ \n\t\t\twmove(menu, end - start_y + 7, start_x);\n\t\t\tsnprintf(buf, sizeof(buf), \"Support Level: %s\", mem->support_level);\n\t\t\tif (mem->replacement && *mem->replacement) {\n\t\t\t\tchar buf2[64];\n\t\t\t\tsnprintf(buf2, sizeof(buf2), \", Replaced by: %s\", mem->replacement);\n\t\t\t\tstrncat(buf, buf2, sizeof(buf) - strlen(buf) - 1);\n\t\t\t}\n\t\t\twaddstr(menu, buf);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1049}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic void matrix_rebuild(int samples)\n{\n\tstruct ast_translator *t;\n\tint newtablecost;\n\tint x;      \n\tint y;      \n\tint z;      \n\tast_debug(1, \"Resetting translation matrix\\n\");\n\tmatrix_clear();\n\t\n\tAST_RWLIST_TRAVERSE(&translators, t, list) {\n\t\tif (!t->active) {\n\t\t\tcontinue;\n\t\t}\n\t\tx = t->src_fmt_index;\n\t\tz = t->dst_fmt_index;\n\t\tif (samples) {\n\t\t\tgenerate_computational_cost(t, samples);\n\t\t}\n\t\t\n\t\tif (!matrix_get(x, z)->step ||\n\t\t\t(t->table_cost < matrix_get(x, z)->step->table_cost) ||\n\t\t\t(t->comp_cost < matrix_get(x, z)->step->comp_cost)) {\n\t\t\tmatrix_get(x, z)->step = t;\n\t\t\tmatrix_get(x, z)->table_cost = t->table_cost;\n\t\t}\n\t}\n\t\n\tfor (;;) {\n\t\tint changed = 0;\n\t\tfor (x = 0; x < cur_max_index; x++) {      \n\t\t\tfor (y = 0; y < cur_max_index; y++) {  \n\t\t\t\tif (x == y) {                      \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (z = 0; z < cur_max_index; z++) {  \n\t\t\t\t\tif ((z == x || z == y) ||        \n\t\t\t\t\t\t!matrix_get(x, y)->step ||   \n\t\t\t\t\t\t!matrix_get(y, z)->step) {   \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnewtablecost = matrix_get(x, y)->table_cost + matrix_get(y, z)->table_cost;\n\t\t\t\t\t\n\t\t\t\t\tif (!matrix_get(x, z)->step || (newtablecost < matrix_get(x, z)->table_cost)) {\n\t\t\t\t\t\tmatrix_get(x, z)->step = matrix_get(x, y)->step;\n\t\t\t\t\t\tmatrix_get(x, z)->table_cost = newtablecost;\n\t\t\t\t\t\tmatrix_get(x, z)->multistep = 1;\n\t\t\t\t\t\tchanged++;\n\t\t\t\t\t\tif (DEBUG_ATLEAST(10)) {\n\t\t\t\t\t\t\tstruct ast_codec *x_codec = index2codec(x);\n\t\t\t\t\t\t\tstruct ast_codec *y_codec = index2codec(y);\n\t\t\t\t\t\t\tstruct ast_codec *z_codec = index2codec(z);\n\t\t\t\t\t\t\tast_log(LOG_DEBUG,\n\t\t\t\t\t\t\t\t\"Discovered %u cost path from %s to %s, via %s\\n\",\n\t\t\t\t\t\t\t\tmatrix_get(x, z)->table_cost, x_codec->name,\n\t\t\t\t\t\t\t\ty_codec->name, z_codec->name);\n\t\t\t\t\t\t\tao2_ref(x_codec, -1);\n\t\t\t\t\t\t\tao2_ref(y_codec, -1);\n\t\t\t\t\t\t\tao2_ref(z_codec, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!changed) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1050}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic struct ast_tm *gmtsub(const struct timeval *timep, const long offset, struct ast_tm *tmp)\n{\n\tstruct ast_tm *\tresult;\n\tstruct state *sp;\n\tAST_LIST_LOCK(&zonelist);\n\tAST_LIST_TRAVERSE(&zonelist, sp, list) {\n\t\tif (!strcmp(sp->name, \"UTC\"))\n\t\t\tbreak;\n\t}\n\tif (!sp) {\n\t\tif (!(sp = sstate_alloc())) {\n\t\t\tAST_LIST_UNLOCK(&zonelist);\n\t\t\treturn NULL;\n\t\t}\n\t\tgmtload(sp);\n\t\tAST_LIST_INSERT_TAIL(&zonelist, sp, list);\n\t}\n\tAST_LIST_UNLOCK(&zonelist);\n\tresult = timesub(timep, offset, sp, tmp);\n#ifdef TM_ZONE\n\t\n\tif (offset != 0)\n\t\ttmp->TM_ZONE = \"    \";\n\telse\n\t\ttmp->TM_ZONE = sp->chars;\n#endif \n\treturn result;\n}\n", "bug_type": null, "idx": 1051}
{"project": "Asterisk", "target": 0, "func": "\nstatic int load_indications(int reload)\n{\n\tstruct ast_config *cfg;\n\tconst char *cxt = NULL;\n\tconst char *country = NULL;\n\tstruct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\tint res = -1;\n\tcfg = ast_config_load2(config, \"indications\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_WARNING, \"Can't find indications config file %s.\\n\", config);\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {\n\t\treturn 0;\n\t}\n\t\n\tao2_lock(ast_tone_zones);\n\tao2_callback(ast_tone_zones, OBJ_NODATA, tone_zone_mark, NULL);\n\t\n\twhile ((cxt = ast_category_browse(cfg, cxt))) {\n\t\t\n\t\tif (!strcasecmp(cxt, \"general\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (parse_tone_zone(cfg, cxt)) {\n\t\t\tgoto return_cleanup;\n\t\t}\n\t}\n\tao2_callback(ast_tone_zones, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK,\n\t\t\tprune_tone_zone, NULL);\n\t\n\tcountry = ast_variable_retrieve(cfg, \"general\", \"country\");\n\tif (ast_strlen_zero(country) || ast_set_indication_country(country)) {\n\t\tast_log(LOG_WARNING, \"Unable to set the default country (for indication tones)\\n\");\n\t}\n\tres = 0;\nreturn_cleanup:\n\tao2_unlock(ast_tone_zones);\n\tast_config_destroy(cfg);\n\treturn res;\n}\n", "bug_type": null, "idx": 1052}
{"project": "Asterisk", "target": 0, "func": "void finalize()\n{\n\tclose(command_desc);\n\tclose(speech_desc);\n\tfree(winbuf);\t\n}\n", "bug_type": null, "idx": 1053}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void after_bridge_cb_destroy(void *data)\n{\n\tstruct after_bridge_cb_ds *after_bridge = data;\n\tafter_bridge_cb_run_discard(after_bridge, AST_BRIDGE_AFTER_CB_REASON_DESTROY);\n\tAST_LIST_HEAD_DESTROY(&after_bridge->callbacks);\n\tast_free(after_bridge);\n}\n", "bug_type": null, "idx": 1054}
{"project": "Asterisk", "target": 0, "func": "#endif\nstatic void internaloutput(const char *str)\n{\n\tfputs(str, stdout);\n}\n", "bug_type": null, "idx": 1055}
{"project": "Asterisk", "target": 0, "func": "static int mwi_send_process_buffer(struct dahdi_pvt * pvt, int num_read)\n{\n\tstruct timeval \tnow;\n\tint \t\t\tres;\n\t\n\tif (MWI_SEND_DONE != pvt->mwisend_data.mwisend_current && !pvt->cidspill) {\n\t\tpvt->mwisend_data.mwisend_current = MWI_SEND_DONE;\n\t} else if (MWI_SEND_DONE != pvt->mwisend_data.mwisend_current) {\n\t\t\n\t\tswitch ( pvt->mwisend_data.mwisend_current) {\n\t\tcase MWI_SEND_SA:\n\t\t\t\n\t\t\tres = ioctl(pvt->subs[SUB_REAL].dfd, DAHDI_SETCADENCE, &AS_RP_cadence);\n\t\t\tif (res) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to set RP-AS ring cadence: %s\\n\", strerror(errno));\n\t\t\t\tgoto quit;\n\t\t\t}\n\t\t\tres = dahdi_set_hook(pvt->subs[SUB_REAL].dfd, DAHDI_RING);\n\t\t\tpvt->mwisend_data.mwisend_current = MWI_SEND_SA_WAIT;\n\t\t\tbreak;\n\t\tcase MWI_SEND_SA_WAIT:  \n\t\t\tbreak;\n\t\tcase MWI_SEND_PAUSE:  \n#ifdef HAVE_DAHDI_LINEREVERSE_VMWI\n\t\t\tif (pvt->mwisend_fsk) {\n#endif\n\t\t\t\tgettimeofday(&now, NULL);\n\t\t\t\tif ((int)(now.tv_sec - pvt->mwisend_data.pause.tv_sec) * 1000000 + (int)now.tv_usec - (int)pvt->mwisend_data.pause.tv_usec > 500000) {\n\t\t\t\t\tpvt->mwisend_data.mwisend_current = MWI_SEND_SPILL;\n\t\t\t\t}\n#ifdef HAVE_DAHDI_LINEREVERSE_VMWI\n\t\t\t} else { \n\t\t\t\tpvt->mwisend_data.mwisend_current = MWI_SEND_CLEANUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase MWI_SEND_SPILL:\n\t\t\t\n\t\t\tif (0 < num_read) {\n\t\t\t\tif (num_read > pvt->cidlen - pvt->cidpos) {\n\t\t\t\t\tnum_read = pvt->cidlen - pvt->cidpos;\n\t\t\t\t}\n\t\t\t\tres = write(pvt->subs[SUB_REAL].dfd, pvt->cidspill + pvt->cidpos, num_read);\n\t\t\t\tif (res > 0) {\n\t\t\t\t\tpvt->cidpos += res;\n\t\t\t\t\tif (pvt->cidpos >= pvt->cidlen) {\n\t\t\t\t\t\tpvt->mwisend_data.mwisend_current = MWI_SEND_CLEANUP;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tast_log(LOG_WARNING, \"MWI FSK Send Write failed: %s\\n\", strerror(errno));\n\t\t\t\t\tgoto quit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MWI_SEND_CLEANUP:\n\t\t\t\n\t\t\tpvt->mwisend_data.mwisend_current = MWI_SEND_DONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\n\t\t\tgoto quit;\n\t\t}\n\t}\n\tif (MWI_SEND_DONE == pvt->mwisend_data.mwisend_current) {\n\t\tif (pvt->cidspill) {\n\t\t\tast_free(pvt->cidspill);\n\t\t\tpvt->cidspill = NULL;\n\t\t\tpvt->cidpos = 0;\n\t\t\tpvt->cidlen = 0;\n\t\t}\n\t\tpvt->mwisendactive = 0;\n\t}\n\treturn 0;\nquit:\n\tif (pvt->cidspill) {\n\t\tast_free(pvt->cidspill);\n\t\tpvt->cidspill = NULL;\n\t\tpvt->cidpos = 0;\n\t\tpvt->cidlen = 0;\n\t}\n\tpvt->mwisendactive = 0;\n\treturn -1;\n}\n", "bug_type": null, "idx": 1056}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res = 0;\n\tres = ast_register_application_xml(\"SpeechCreate\", speech_create);\n\tres |= ast_register_application_xml(\"SpeechLoadGrammar\", speech_load);\n\tres |= ast_register_application_xml(\"SpeechUnloadGrammar\", speech_unload);\n\tres |= ast_register_application_xml(\"SpeechActivateGrammar\", speech_activate);\n\tres |= ast_register_application_xml(\"SpeechDeactivateGrammar\", speech_deactivate);\n\tres |= ast_register_application_xml(\"SpeechStart\", speech_start);\n\tres |= ast_register_application_xml(\"SpeechBackground\", speech_background);\n\tres |= ast_register_application_xml(\"SpeechDestroy\", speech_destroy);\n\tres |= ast_register_application_xml(\"SpeechProcessingSound\", speech_processing_sound);\n\tres |= ast_custom_function_register(&speech_function);\n\tres |= ast_custom_function_register(&speech_score_function);\n\tres |= ast_custom_function_register(&speech_text_function);\n\tres |= ast_custom_function_register(&speech_grammar_function);\n\tres |= ast_custom_function_register(&speech_engine_function);\n\tres |= ast_custom_function_register(&speech_results_type_function);\n\treturn res;\n}\n", "bug_type": null, "idx": 1057}
{"project": "Asterisk", "target": 0, "func": "static struct ast_manager_event_blob *agi_async_end_to_ami(struct stasis_message *message)\n{\n\treturn agi_channel_to_ami(\"AsyncAGIEnd\", message);\n}\n", "bug_type": null, "idx": 1058}
{"project": "Asterisk", "target": 0, "func": "int pbx_builtin_setvar(struct ast_channel *chan, const char *data)\n{\n\tchar *name, *value, *mydata;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"Set requires one variable name/value pair.\\n\");\n\t\treturn 0;\n\t}\n\tmydata = ast_strdupa(data);\n\tname = strsep(&mydata, \"=\");\n\tvalue = mydata;\n\tif (!value) {\n\t\tast_log(LOG_WARNING, \"Set requires an '=' to be a valid assignment.\\n\");\n\t\treturn 0;\n\t}\n\tif (strchr(name, ' ')) {\n\t\tast_log(LOG_WARNING, \"Please avoid unnecessary spaces on variables as it may lead to unexpected results ('%s' set to '%s').\\n\", name, mydata);\n\t}\n\tpbx_builtin_setvar_helper(chan, name, value);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1059}
{"project": "Asterisk", "target": 0, "func": "\nstruct ast_speech *ast_speech_new(const char *engine_name, const struct ast_format_cap *cap)\n{\n\tstruct ast_speech_engine *engine = NULL;\n\tstruct ast_speech *new_speech = NULL;\n\tstruct ast_format_cap *joint;\n\tRAII_VAR(struct ast_format *, best, NULL, ao2_cleanup);\n\t\n\tif (!(engine = find_engine(engine_name)))\n\t\treturn NULL;\n\tjoint = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\tif (!joint) {\n\t\treturn NULL;\n\t}\n\tast_format_cap_get_compatible(engine->formats, cap, joint);\n\tbest = ast_format_cap_get_format(joint, 0);\n\tao2_ref(joint, -1);\n\tif (!best) {\n\t\tif (ast_format_cap_iscompatible_format(engine->formats, ast_format_slin) != AST_FORMAT_CMP_NOT_EQUAL) {\n\t\t\tbest = ao2_bump(ast_format_slin);\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t\n\tif (!(new_speech = ast_calloc(1, sizeof(*new_speech)))) {\n\t\treturn NULL;\n\t}\n\t\n\tast_mutex_init(&new_speech->lock);\n\t\n\tnew_speech->results = NULL;\n\t\n\tnew_speech->engine = engine;\n\t\n\tnew_speech->format = best;\n\t\n\tast_speech_change_state(new_speech, AST_SPEECH_STATE_NOT_READY);\n\t\n\tif (engine->create(new_speech, best)) {\n\t\tast_mutex_destroy(&new_speech->lock);\n\t\tast_free(new_speech);\n\t\tnew_speech = NULL;\n\t}\n\treturn new_speech;\n}\n", "bug_type": null, "idx": 1060}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_visible_indication(const struct ast_channel *chan)\n{\n\treturn chan->visible_indication;\n}\n", "bug_type": null, "idx": 1061}
{"project": "Asterisk", "target": 0, "func": "static void unregister_hook(void) {\n\t\n\tast_manager_unregister_hook(&test_hook);\n}\n", "bug_type": null, "idx": 1062}
{"project": "Asterisk", "target": 0, "func": "\nstatic void set_dads(struct pval *dad, struct pval *child_list)\n{\n\tstruct pval *t;\n\tfor(t=child_list;t;t=t->next)  \n\t\tt->dad = dad;\n}\n", "bug_type": null, "idx": 1063}
{"project": "Asterisk", "target": 0, "func": "static int adsi_careful_send(struct ast_channel *chan, unsigned char *buf, int len, int *remain)\n{\n\t\n\tstruct ast_frame *inf;\n\tstruct ast_frame outf = {\n\t\t.frametype = AST_FRAME_VOICE,\n\t\t.subclass.format = ast_format_ulaw,\n\t\t.data.ptr = buf,\n\t};\n\tint amt;\n\tif (remain && *remain) {\n\t\tamt = len;\n\t\t\n\t\tif (amt > *remain) {\n\t\t\tamt = *remain;\n\t\t} else {\n\t\t\t*remain = *remain - amt;\n\t\t}\n\t\toutf.datalen = amt;\n\t\toutf.samples = amt;\n\t\tif (ast_write(chan, &outf)) {\n\t\t\tast_log(LOG_WARNING, \"Failed to carefully write frame\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tbuf += amt;\n\t\tlen -= amt;\n\t}\n\twhile (len) {\n\t\tamt = len;\n\t\t\n\t\tif (ast_waitfor(chan, 1000) < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (!(inf = ast_read(chan))) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (inf->frametype != AST_FRAME_VOICE) {\n\t\t\tast_frfree(inf);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ast_format_cmp(inf->subclass.format, ast_format_ulaw) != AST_FORMAT_CMP_EQUAL) {\n\t\t\tast_log(LOG_WARNING, \"Channel not in ulaw?\\n\");\n\t\t\tast_frfree(inf);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (amt > inf->datalen) {\n\t\t\tamt = inf->datalen;\n\t\t} else if (remain) {\n\t\t\t*remain = inf->datalen - amt;\n\t\t}\n\t\toutf.datalen = amt;\n\t\toutf.samples = amt;\n\t\tif (ast_write(chan, &outf)) {\n\t\t\tast_log(LOG_WARNING, \"Failed to carefully write frame\\n\");\n\t\t\tast_frfree(inf);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tbuf += amt;\n\t\tlen -= amt;\n\t\tast_frfree(inf);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1064}
{"project": "Asterisk", "target": 0, "func": "static int system_create_resolver_and_set_nameservers(void *data)\n{\n\tstruct ao2_container *discovered_nameservers;\n\tstruct ao2_iterator it_nameservers;\n\tchar *nameserver;\n\tpj_status_t status;\n\tpj_dns_resolver *resolver;\n\tpj_str_t nameservers[PJ_DNS_RESOLVER_MAX_NS];\n\tunsigned int count = 0;\n\tdiscovered_nameservers = ast_dns_get_nameservers();\n\tif (!discovered_nameservers) {\n\t\tast_log(LOG_ERROR, \"Could not retrieve local system nameservers, resorting to system resolution\\n\");\n\t\treturn 0;\n\t}\n\tif (!ao2_container_count(discovered_nameservers)) {\n\t\tast_log(LOG_ERROR, \"There are no local system nameservers configured, resorting to system resolution\\n\");\n\t\tao2_ref(discovered_nameservers, -1);\n\t\treturn -1;\n\t}\n\tif (!(resolver = pjsip_endpt_get_resolver(ast_sip_get_pjsip_endpoint()))) {\n\t\tstatus = pjsip_endpt_create_resolver(ast_sip_get_pjsip_endpoint(), &resolver);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tast_log(LOG_ERROR, \"Could not create DNS resolver(%d), resorting to system resolution\\n\", status);\n\t\t\tao2_ref(discovered_nameservers, -1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tit_nameservers = ao2_iterator_init(discovered_nameservers, 0);\n\twhile ((nameserver = ao2_iterator_next(&it_nameservers))) {\n\t\tpj_strset2(&nameservers[count++], nameserver);\n\t\tao2_ref(nameserver, -1);\n\t\tif (count == (PJ_DNS_RESOLVER_MAX_NS - 1)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tao2_iterator_destroy(&it_nameservers);\n\tstatus = pj_dns_resolver_set_ns(resolver, count, nameservers, NULL);\n\t\n\tao2_ref(discovered_nameservers, -1);\n\tif (status != PJ_SUCCESS) {\n\t\tast_log(LOG_ERROR, \"Could not set nameservers on DNS resolver in PJSIP(%d), resorting to system resolution\\n\",\n\t\t\tstatus);\n\t\treturn 0;\n\t}\n\tif (!pjsip_endpt_get_resolver(ast_sip_get_pjsip_endpoint())) {\n\t\tstatus = pjsip_endpt_set_resolver(ast_sip_get_pjsip_endpoint(), resolver);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tast_log(LOG_ERROR, \"Could not set DNS resolver in PJSIP(%d), resorting to system resolution\\n\", status);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1065}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_initialize_sorcery_global(void)\n{\n\tstruct ast_sorcery *sorcery = ast_sip_get_sorcery();\n\tsnprintf(default_useragent, sizeof(default_useragent), \"%s %s\",\n\t\tDEFAULT_USERAGENT_PREFIX, ast_get_version());\n\tast_sorcery_apply_default(sorcery, \"global\", \"config\", \"pjsip.conf,criteria=type=global\");\n\tif (ast_sorcery_object_register(sorcery, \"global\", global_alloc, NULL, global_apply)) {\n\t\treturn -1;\n\t}\n\tast_sorcery_object_field_register(sorcery, \"global\", \"type\", \"\", OPT_NOOP_T, 0, 0);\n\tast_sorcery_object_field_register(sorcery, \"global\", \"max_forwards\",\n\t\t__stringify(DEFAULT_MAX_FORWARDS),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, max_forwards));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"user_agent\", default_useragent,\n\t\tOPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, useragent));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"default_outbound_endpoint\",\n\t\tDEFAULT_OUTBOUND_ENDPOINT,\n\t\tOPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, default_outbound_endpoint));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"debug\", DEFAULT_DEBUG,\n\t\tOPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, debug));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"endpoint_identifier_order\",\n\t\tDEFAULT_ENDPOINT_IDENTIFIER_ORDER,\n\t\tOPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, endpoint_identifier_order));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"keep_alive_interval\",\n\t\t__stringify(DEFAULT_KEEPALIVE_INTERVAL),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, keep_alive_interval));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"max_initial_qualify_time\",\n\t\t__stringify(DEFAULT_MAX_INITIAL_QUALIFY_TIME),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, max_initial_qualify_time));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"default_from_user\", DEFAULT_FROM_USER,\n\t\tOPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, default_from_user));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"default_voicemail_extension\",\n\t\tDEFAULT_VOICEMAIL_EXTENSION, OPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config,\n\t\tdefault_voicemail_extension));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"regcontext\", DEFAULT_REGCONTEXT,\n\t\tOPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, regcontext));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"contact_expiration_check_interval\",\n\t\t__stringify(DEFAULT_CONTACT_EXPIRATION_CHECK_INTERVAL),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, contact_expiration_check_interval));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"disable_multi_domain\",\n\t\tDEFAULT_DISABLE_MULTI_DOMAIN ? \"yes\" : \"no\",\n\t\tOPT_BOOL_T, 1, FLDSET(struct global_config, disable_multi_domain));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"unidentified_request_count\",\n\t\t__stringify(DEFAULT_UNIDENTIFIED_REQUEST_COUNT),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, unidentified_request_count));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"unidentified_request_period\",\n\t\t__stringify(DEFAULT_UNIDENTIFIED_REQUEST_PERIOD),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, unidentified_request_period));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"unidentified_request_prune_interval\",\n\t\t__stringify(DEFAULT_UNIDENTIFIED_REQUEST_PRUNE_INTERVAL),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, unidentified_request_prune_interval));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"default_realm\", DEFAULT_REALM,\n\t\tOPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, default_realm));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"mwi_tps_queue_high\",\n\t\t__stringify(DEFAULT_MWI_TPS_QUEUE_HIGH),\n\t\tOPT_UINT_T, 0, FLDSET(struct global_config, mwi.tps_queue_high));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"mwi_tps_queue_low\",\n\t\t__stringify(DEFAULT_MWI_TPS_QUEUE_LOW),\n\t\tOPT_INT_T, 0, FLDSET(struct global_config, mwi.tps_queue_low));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"mwi_disable_initial_unsolicited\",\n\t\tDEFAULT_MWI_DISABLE_INITIAL_UNSOLICITED ? \"yes\" : \"no\",\n\t\tOPT_BOOL_T, 1, FLDSET(struct global_config, mwi.disable_initial_unsolicited));\n\tast_sorcery_object_field_register(sorcery, \"global\", \"ignore_uri_user_options\",\n\t\tDEFAULT_IGNORE_URI_USER_OPTIONS ? \"yes\" : \"no\",\n\t\tOPT_BOOL_T, 1, FLDSET(struct global_config, ignore_uri_user_options));\n\tif (ast_sorcery_instance_observer_add(sorcery, &observer_callbacks_global)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1066}
{"project": "Asterisk", "target": 0, "func": "static off_t g723_tell(struct ast_filestream *fs)\n{\n\treturn -1;\n}\n", "bug_type": null, "idx": 1067}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void hash_ao2_stats(struct ao2_container_hash *self, void *where, ao2_prnt_fn *prnt)\n{\n#define FORMAT  \"%10.10s %10.10s %10.10s\\n\"\n#define FORMAT2 \"%10d %10d %10d\\n\"\n\tint bucket;\n\tint suppressed_buckets = 0;\n\tprnt(where, \"Number of buckets: %d\\n\\n\", self->n_buckets);\n\tprnt(where, FORMAT, \"Bucket\", \"Objects\", \"Max\");\n\tfor (bucket = 0; bucket < self->n_buckets; ++bucket) {\n\t\tif (self->buckets[bucket].max_elements) {\n\t\t\tsuppressed_buckets = 0;\n\t\t\tprnt(where, FORMAT2, bucket, self->buckets[bucket].elements,\n\t\t\t\tself->buckets[bucket].max_elements);\n\t\t} else if (!suppressed_buckets) {\n\t\t\tsuppressed_buckets = 1;\n\t\t\tprnt(where, \"...\\n\");\n\t\t}\n\t}\n#undef FORMAT\n#undef FORMAT2\n}\n", "bug_type": null, "idx": 1068}
{"project": "Asterisk", "target": 0, "func": "static void parse_restart (struct isdn_msg msgs[], msg_t *msg, struct misdn_bchannel *bc, int nt)\n{\n\tint HEADER_LEN = nt?mISDNUSER_HEAD_SIZE:mISDN_HEADER_LEN;\n\tRESTART_t *restart = (RESTART_t *) (msg->data + HEADER_LEN);\n\tstruct misdn_stack *stack=get_stack_by_bc(bc);\n#ifdef DEBUG\n\tprintf(\"Parsing RESTART Msg\\n\");\n#endif\n\t{\n\t\tint  exclusive;\n\t\tdec_ie_channel_id(restart->CHANNEL_ID, (Q931_info_t *)restart, &exclusive, &bc->restart_channel, nt,bc);\n\t\tcb_log(3, stack->port, \"CC_RESTART Request on channel:%d on this port.\\n\", bc->restart_channel);\n\t}\n}\n", "bug_type": null, "idx": 1069}
{"project": "Asterisk", "target": 0, "func": "static enum ast_device_state sla_state_to_devstate(enum sla_trunk_state state)\n{\n\tswitch (state) {\n\tcase SLA_TRUNK_STATE_IDLE:\n\t\treturn AST_DEVICE_NOT_INUSE;\n\tcase SLA_TRUNK_STATE_RINGING:\n\t\treturn AST_DEVICE_RINGING;\n\tcase SLA_TRUNK_STATE_UP:\n\t\treturn AST_DEVICE_INUSE;\n\tcase SLA_TRUNK_STATE_ONHOLD:\n\tcase SLA_TRUNK_STATE_ONHOLD_BYME:\n\t\treturn AST_DEVICE_ONHOLD;\n\t}\n\treturn AST_DEVICE_UNKNOWN;\n}\n", "bug_type": null, "idx": 1070}
{"project": "Asterisk", "target": 0, "func": "static void clear_mixmonitor_recipient_list(struct mixmonitor *mixmonitor)\n{\n\tstruct vm_recipient *current;\n\twhile ((current = AST_LIST_REMOVE_HEAD(&mixmonitor->recipient_list, list))) {\n\t\t\n\t\tast_free(current);\n\t}\n}\n", "bug_type": null, "idx": 1071}
{"project": "Asterisk", "target": 0, "func": "\t} while(0)\nAST_TEST_DEFINE(stream_topology_map_create)\n{\n\tRAII_VAR(struct ast_stream_topology *, t0, NULL, ast_stream_topology_free);\n\tstruct ast_vector_int types = { NULL };\n\tstruct ast_vector_int v0 = { NULL };\n\tstruct ast_vector_int v1 = { NULL };\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"stream_topology_map_create\";\n\t\tinfo->category = \"/main/stream/\";\n\t\tinfo->summary = \"stream topology map creation unit test\";\n\t\tinfo->description =\n\t\t\t\"Test that creating a stream topology map works\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tast_test_validate(test, AST_VECTOR_INIT(&types, 5) == 0);\n\t\n\tast_test_validate_cleanup(test, (t0 = ast_stream_topology_alloc()), res, done);\n\ttopology_append_stream(t0, \"audio\", AST_MEDIA_TYPE_AUDIO, res, done);\n\ttopology_append_stream(t0, \"video\", AST_MEDIA_TYPE_VIDEO, res, done);\n\tast_stream_topology_map(t0, &types, &v0, &v1);\n\tast_test_validate_cleanup(test, AST_VECTOR_SIZE(&types) == 2, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&types, 0) == AST_MEDIA_TYPE_AUDIO, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&types, 1) == AST_MEDIA_TYPE_VIDEO, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v0, 0) == 0, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v0, 1) == 1, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v1, 0) == 0, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v1, 1) == 1, res, done);\n\t\n\tast_stream_topology_free(t0);\n\tast_test_validate_cleanup(test, (t0 = ast_stream_topology_alloc()), res, done);\n\ttopology_append_stream(t0, \"video\", AST_MEDIA_TYPE_VIDEO, res, done);\n\ttopology_append_stream(t0, \"audio\", AST_MEDIA_TYPE_AUDIO, res, done);\n\tast_stream_topology_map(t0, &types, &v0, &v1);\n\tast_test_validate_cleanup(test, AST_VECTOR_SIZE(&types) == 2, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&types, 0) == AST_MEDIA_TYPE_AUDIO, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&types, 1) == AST_MEDIA_TYPE_VIDEO, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v0, 0) == 1, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v0, 1) == 0, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v1, 0) == 1, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v1, 1) == 0, res, done);\n\t\n\tast_stream_topology_free(t0);\n\tast_test_validate_cleanup(test, (t0 = ast_stream_topology_alloc()), res, done);\n\ttopology_append_stream(t0, \"video\", AST_MEDIA_TYPE_VIDEO, res, done);\n\ttopology_append_stream(t0, \"audio\", AST_MEDIA_TYPE_AUDIO, res, done);\n\ttopology_append_stream(t0, \"audio\", AST_MEDIA_TYPE_AUDIO, res, done);\n\tast_stream_topology_map(t0, &types, &v0, &v1);\n\tast_test_validate_cleanup(test, AST_VECTOR_SIZE(&types) == 3, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&types, 0) == AST_MEDIA_TYPE_AUDIO, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&types, 1) == AST_MEDIA_TYPE_VIDEO, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&types, 2) == AST_MEDIA_TYPE_AUDIO, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v0, 0) == 1, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v0, 1) == 0, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v0, 2) == 2, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v1, 0) == 1, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v1, 1) == 0, res, done);\n\tast_test_validate_cleanup(test, AST_VECTOR_GET(&v1, 2) == 2, res, done);\ndone:\n\tAST_VECTOR_FREE(&v1);\n\tAST_VECTOR_FREE(&v0);\n\tAST_VECTOR_FREE(&types);\n\treturn res;\n}\n", "bug_type": null, "idx": 1072}
{"project": "Asterisk", "target": 0, "func": "*/\nint ooOnLogicalChannelEstablished\n   (OOH323CallData *call, OOLogicalChannel * pChannel)\n{\n   OOLogicalChannel * temp = NULL, *prev=NULL; \n   OOTRACEDBGC3(\"In ooOnLogicalChannelEstablished (%s, %s)\\n\",\n                call->callType, call->callToken);\n   pChannel->state = OO_LOGICALCHAN_ESTABLISHED;\n   temp = call->logicalChans;\n   while(temp)\n   {\n      if(temp->channelNo != pChannel->channelNo &&\n         temp->sessionID == pChannel->sessionID &&\n         !strcmp(temp->dir, pChannel->dir)        )\n      {\n         prev = temp;\n         temp = temp->next;\n         ooClearLogicalChannel(call, prev->channelNo);\n      }\n      else\n         temp = temp->next;\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1073}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245EncryptionMode (OOCTXT* pctxt, H245EncryptionMode* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"nonStandard\", -1);\n            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);\n            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"nonStandard\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"h233Encryption\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"h233Encryption\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 3;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1074}
{"project": "Asterisk", "target": 0, "func": "#endif \nstatic char *dahdi_destroy_channels(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint start;\n\tint end;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"dahdi destroy channels\";\n\t\te->usage =\n\t\t\t\"Usage: dahdi destroy channels <from_channel> [<to_channel>]\\n\"\n\t\t\t\"\tDON'T USE THIS UNLESS YOU KNOW WHAT YOU ARE DOING.  Immediately removes a given channel, whether it is in use or not\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif ((a->argc < 4) || a->argc > 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tstart = atoi(a->argv[3]);\n\tif (start < 1) {\n\t\tast_cli(a->fd, \"Invalid starting channel number %s.\\n\",\n\t\t\t\ta->argv[4]);\n\t\treturn CLI_FAILURE;\n\t}\n\tif (a->argc == 5) {\n\t\tend = atoi(a->argv[4]);\n\t\tif (end < 1) {\n\t\t\tast_cli(a->fd, \"Invalid ending channel number %s.\\n\",\n\t\t\t\t\ta->argv[4]);\n\t\t\treturn CLI_FAILURE;\n\t\t}\n\t} else {\n\t\tend = start;\n\t}\n\tif (end < start) {\n\t\tast_cli(a->fd,\n\t\t\t\"range end (%d) is smaller than range start (%d)\\n\",\n\t\t\tend, start);\n\t\treturn CLI_FAILURE;\n\t}\n\tdahdi_destroy_channel_range(start, end);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1075}
{"project": "Asterisk", "target": 0, "func": "void stasis_app_control_flush_queue(struct stasis_app_control *control)\n{\n\tcontrol_flush_queue(control);\n}\n", "bug_type": null, "idx": 1076}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void set_bridge_peer_vars_multiparty(struct ast_bridge *bridge)\n{\n\n#define MAX_BRIDGEPEER_CHANS\t(10 + 1)\n\tunsigned int idx;\n\tunsigned int num_names;\n\tunsigned int len;\n\tconst char **names;\n\tchar *buf;\n\tstruct ast_bridge_channel *bridge_channel;\n\t\n\tnum_names = MIN(bridge->num_channels, MAX_BRIDGEPEER_CHANS);\n\tnames = ast_alloca(num_names * sizeof(*names));\n\tidx = 0;\n\tAST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {\n\t\tif (num_names <= idx) {\n\t\t\tbreak;\n\t\t}\n\t\tast_channel_lock(bridge_channel->chan);\n\t\tnames[idx++] = ast_strdupa(ast_channel_name(bridge_channel->chan));\n\t\tast_channel_unlock(bridge_channel->chan);\n\t}\n\t\n\tlen = num_names;\n\tfor (idx = 0; idx < num_names; ++idx) {\n\t\tlen += strlen(names[idx]);\n\t}\n\tbuf = ast_alloca(len);\n\t\n\tidx = 0;\n\tbuf[0] = '\\0';\n\tAST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {\n\t\tif (idx < num_names) {\n\t\t\tfill_bridgepeer_buf(buf, idx, names, num_names);\n\t\t}\n\t\t++idx;\n\t\tast_channel_lock(bridge_channel->chan);\n\t\tast_bridge_vars_set(bridge_channel->chan, buf, NULL);\n\t\tast_channel_unlock(bridge_channel->chan);\n\t}\n}\n", "bug_type": null, "idx": 1077}
{"project": "Asterisk", "target": 0, "func": "static void handle_select_language(struct unistimsession *pte)\n{\n\tchar tmp_language[40];\n\tstruct unistim_languages lang;\n\tif (pte->state != STATE_SELECTLANGUAGE) {\n\t\tpte->state = STATE_SELECTLANGUAGE;\n\t\tpte->size_buff_entry = 1;\n\t\tpte->buff_entry[0] = find_language(pte->device->language);\n\t}\n\tlang = options_languages[(int)pte->buff_entry[0]];\n\tast_copy_string(tmp_language, pte->device->language, sizeof(tmp_language));\n\tast_copy_string(pte->device->language, lang.lang_short, sizeof(pte->device->language));\n\tsend_charset_update(pte, lang.encoding);\n\tsend_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext(lang.label, pte));\n\tast_copy_string(pte->device->language, tmp_language, sizeof(pte->device->language));\n\tlang = options_languages[find_language(pte->device->language)];\n\tsend_charset_update(pte, lang.encoding);\n\tsend_text_status(pte, ustmtext(\"Select               Cancel\", pte));\n\treturn;\n}\n", "bug_type": null, "idx": 1078}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void xmpp_pubsub_unsubscribe(struct ast_xmpp_client *client, const char *node)\n{\n\tiks *request = xmpp_pubsub_iq_create(client, \"set\");\n\tiks *pubsub, *unsubscribe;\n\tif (!request) {\n\t\tast_log(LOG_ERROR, \"Could not create IQ when creating pubsub unsubscription on client '%s'\\n\", client->name);\n\t\treturn;\n\t}\n\tpubsub = iks_insert(request, \"pubsub\");\n\tiks_insert_attrib(pubsub, \"xmlns\", \"http://jabber.org/protocol/pubsub\");\n\tunsubscribe = iks_insert(pubsub, \"unsubscribe\");\n\tiks_insert_attrib(unsubscribe, \"jid\", client->jid->partial);\n\tiks_insert_attrib(unsubscribe, \"node\", node);\n\tast_xmpp_client_send(client, request);\n\tiks_delete(request);\n}\n", "bug_type": null, "idx": 1079}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int test_resolve(struct ast_dns_query *query)\n{\n\tpthread_t resolver_thread;\n\ttest_resolver_data.resolve_called = 1;\n\treturn ast_pthread_create_detached(&resolver_thread, NULL, resolution_thread, ao2_bump(query));\n}\n", "bug_type": null, "idx": 1080}
{"project": "Asterisk", "target": 0, "func": "\nstatic void siren14_destroy(struct ast_format *format)\n{\n}\n", "bug_type": null, "idx": 1081}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_variable *realtime_ldap(const char *basedn,\n\t\t\t\t\t  const char *table_name, const struct ast_variable *fields)\n{\n\tstruct ast_variable **vars = realtime_ldap_base_ap(NULL, basedn, table_name, fields);\n\tstruct ast_variable *var = NULL;\n\tif (vars) {\n\t\tstruct ast_variable *last_var = NULL;\n\t\tstruct ast_variable **p = vars;\n\t\t\n\t\twhile (*p) {\n\t\t\tif (last_var) {\n\t\t\t\twhile (last_var->next) {\n\t\t\t\t\tlast_var = last_var->next;\n\t\t\t\t}\n\t\t\t\tlast_var->next = *p;\n\t\t\t} else {\n\t\t\t\tvar = *p;\n\t\t\t\tlast_var = var;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tast_free(vars);\n\t}\n\treturn var;\n}\n", "bug_type": null, "idx": 1082}
{"project": "Asterisk", "target": 0, "func": "};\nint unpark_parked_user(struct parked_user *pu)\n{\n\tif (pu->lot) {\n\t\tao2_unlink(pu->lot->parked_users, pu);\n\t\tparking_lot_remove_if_unused(pu->lot);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1083}
{"project": "Asterisk", "target": 0, "func": "static int format_ami_auth_handler(void *obj, void *arg, int flags)\n{\n\tconst struct ast_sip_auth *auth = obj;\n\tstruct ast_sip_ami *ami = arg;\n\tconst struct ast_sip_endpoint *endpoint = ami->arg;\n\tRAII_VAR(struct ast_str *, buf,\n\t\t ast_sip_create_ami_event(\"AuthDetail\", ami), ast_free);\n\tif (!buf) {\n\t\treturn -1;\n\t}\n\tif (sip_auth_to_ami(auth, &buf)) {\n\t\treturn -1;\n\t}\n\tif (endpoint) {\n\t\tast_str_append(&buf, 0, \"EndpointName: %s\\r\\n\",\n\t\t       ast_sorcery_object_get_id(endpoint));\n\t}\n\tastman_append(ami->s, \"%s\\r\\n\", ast_str_buffer(buf));\n\tami->count++;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1084}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_hashtab_hash_string_sax(const void *obj) \n{\n\tconst unsigned char *str = obj;\n\tunsigned int total = 0, c = 0;\n\twhile ((c = *str++))\n\t\ttotal ^= (total << 5) + (total >> 2) + (total << 10) + c;\n\treturn total;\n}\n", "bug_type": null, "idx": 1085}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum folder_map mwi_folder_map(const char *folder)\n{\n\tenum folder_map which_folder;\n\tif (ast_strlen_zero(folder) || !strcasecmp(folder, \"INBOX\")) {\n\t\twhich_folder = FOLDER_INBOX;\n\t} else if (!strcasecmp(folder, \"Old\")) {\n\t\twhich_folder = FOLDER_OLD;\n\t} else {\n\t\twhich_folder = FOLDER_INVALID;\n\t}\n\treturn which_folder;\n}\n", "bug_type": null, "idx": 1086}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_endpoints_send_message_parse_body(\n\tstruct ast_json *body,\n\tstruct ast_ari_endpoints_send_message_args *args)\n{\n\tstruct ast_json *field;\n\t\n\tfield = ast_json_object_get(body, \"to\");\n\tif (field) {\n\t\targs->to = ast_json_string_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"from\");\n\tif (field) {\n\t\targs->from = ast_json_string_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"body\");\n\tif (field) {\n\t\targs->body = ast_json_string_get(field);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1087}
{"project": "Asterisk", "target": 0, "func": "static int function_fieldqty(struct ast_channel *chan, const char *cmd,\n\t\t\t     char *parse, char *buf, size_t len)\n{\n\treturn function_fieldqty_helper(chan, cmd, parse, buf, NULL, len);\n}\n", "bug_type": null, "idx": 1088}
{"project": "Asterisk", "target": 0, "func": "static int unsubscribe_device_state(struct stasis_app *app, const char *name)\n{\n\tstruct device_state_subscription *sub;\n\tao2_lock(device_state_subscriptions);\n\tsub = find_device_state_subscription(app, name);\n\tif (sub) {\n\t\tremove_device_state_subscription(sub);\n\t}\n\tao2_unlock(device_state_subscriptions);\n\tao2_cleanup(sub);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1089}
{"project": "Asterisk", "target": 0, "func": "\nstatic int safe_fclose(FILE *f)\n{\n\tif (f) {\n\t\treturn fclose(f);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1090}
{"project": "Asterisk", "target": 0, "func": "#define release_table(a)\tAST_RWLIST_UNLOCK(&((a)->columns))\nstatic int set_var(char **var, const char *name, const char *value)\n{\n\tif (*var)\n\t\tast_free(*var);\n\t*var = ast_strdup(value);\n\tif (!*var) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate variable %s\\n\", name);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1091}
{"project": "Asterisk", "target": 0, "func": "#define MAX_CHANLIST_LEN 80\nstatic void process_echocancel(struct dahdi_chan_conf *confp, const char *data, unsigned int line)\n{\n\tchar *parse = ast_strdupa(data);\n\tchar *params[DAHDI_MAX_ECHOCANPARAMS + 1];\n\tunsigned int param_count;\n\tunsigned int x;\n\tif (!(param_count = ast_app_separate_args(parse, ',', params, ARRAY_LEN(params))))\n\t\treturn;\n\tmemset(&confp->chan.echocancel, 0, sizeof(confp->chan.echocancel));\n\t\n\tx = ast_strlen_zero(params[0]) ? 0 : atoi(params[0]);\n\tif ((x == 32) || (x == 64) || (x == 128) || (x == 256) || (x == 512) || (x == 1024))\n\t\tconfp->chan.echocancel.head.tap_length = x;\n\telse if ((confp->chan.echocancel.head.tap_length = ast_true(params[0])))\n\t\tconfp->chan.echocancel.head.tap_length = 128;\n\t\n\tfor (x = 1; x < param_count; x++) {\n\t\tstruct {\n\t\t\tchar *name;\n\t\t\tchar *value;\n\t\t} param;\n\t\tif (ast_app_separate_args(params[x], '=', (char **) &param, 2) < 1) {\n\t\t\tast_log(LOG_WARNING, \"Invalid echocancel parameter supplied at line %u: '%s'\\n\", line, params[x]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ast_strlen_zero(param.name) || (strlen(param.name) > sizeof(confp->chan.echocancel.params[0].name)-1)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid echocancel parameter supplied at line %u: '%s'\\n\", line, param.name);\n\t\t\tcontinue;\n\t\t}\n\t\tstrcpy(confp->chan.echocancel.params[confp->chan.echocancel.head.param_count].name, param.name);\n\t\tif (param.value) {\n\t\t\tif (sscanf(param.value, \"%30d\", &confp->chan.echocancel.params[confp->chan.echocancel.head.param_count].value) != 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid echocancel parameter value supplied at line %u: '%s'\\n\", line, param.value);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconfp->chan.echocancel.head.param_count++;\n\t}\n}\n", "bug_type": null, "idx": 1092}
{"project": "Asterisk", "target": 0, "func": "\nstatic void _null_sig_handler(int sig)\n{\n}\n", "bug_type": null, "idx": 1093}
{"project": "Asterisk", "target": 0, "func": "\nstatic void dns_query_active_destroy(void *data)\n{\n\tstruct ast_dns_query_active *active = data;\n\tao2_cleanup(active->query);\n}\n", "bug_type": null, "idx": 1094}
{"project": "Asterisk", "target": 0, "func": "static struct extension *delete_extension(struct extension *exten)\n{\n\tast_var_list_destroy(exten->headp);\n\tast_string_field_free_memory(exten);\n\tast_free(exten);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1095}
{"project": "Asterisk", "target": 0, "func": " */\nstatic const char *aoc_charged_item_str(enum ast_aoc_s_charged_item value)\n{\n\tconst char *str;\n\tswitch (value) {\n\tdefault:\n\tcase AST_AOC_CHARGED_ITEM_NA:\n\t\tstr = \"NotAvailable\";\n\t\tbreak;\n\tcase AST_AOC_CHARGED_ITEM_SPECIAL_ARRANGEMENT:\n\t\tstr = \"SpecialArrangement\";\n\t\tbreak;\n\tcase AST_AOC_CHARGED_ITEM_BASIC_COMMUNICATION:\n\t\tstr = \"BasicCommunication\";\n\t\tbreak;\n\tcase AST_AOC_CHARGED_ITEM_CALL_ATTEMPT:\n\t\tstr = \"CallAttempt\";\n\t\tbreak;\n\tcase AST_AOC_CHARGED_ITEM_CALL_SETUP:\n\t\tstr = \"CallSetup\";\n\t\tbreak;\n\tcase AST_AOC_CHARGED_ITEM_USER_USER_INFO:\n\t\tstr = \"UserUserInfo\";\n\t\tbreak;\n\tcase AST_AOC_CHARGED_ITEM_SUPPLEMENTARY_SERVICE:\n\t\tstr = \"SupplementaryService\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n", "bug_type": null, "idx": 1096}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int double_handler_fn(const struct aco_option *opt, struct ast_variable *var, void *obj) {\n\tdouble *field = (double *)(obj + opt->args[0]);\n\treturn ast_parse_arg(var->value, PARSE_DOUBLE | opt->flags, field);\n}\n", "bug_type": null, "idx": 1097}
{"project": "Asterisk", "target": 0, "func": "void ast_optional_api_unuse(const char *symname, ast_optional_fn *optional_ref,\n\tconst char *module)\n{\n\tstruct optional_api *api;\n\tsize_t i;\n\tapi = get_api(symname);\n\tif (!api) {\n\t\tast_log(LOG_ERROR, \"%s: Could not find api\\n\", symname);\n\t\tast_do_crash();\n\t\treturn;\n\t}\n\tfor (i = 0; i < api->users_len; ++i) {\n\t\tstruct optional_api_user *user = api->users[i];\n\t\tif (user->optional_ref == optional_ref) {\n\t\t\tif (*user->optional_ref != user->stub) {\n\t\t\t\t*user->optional_ref = user->stub;\n\t\t\t}\n\t\t\t\n\t\t\tapi->users[i] = api->users[--api->users_len];\n\t\t\toptional_api_user_destroy(user);\n\t\t\treturn;\n\t\t}\n\t}\n\tast_log(LOG_ERROR, \"%s: Could not find user %s\\n\", symname, module);\n}\n", "bug_type": null, "idx": 1098}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void *dialog_info_allocate_body(void *data)\n{\n\tstruct ast_sip_exten_state_data *state_data = data;\n\treturn ast_sip_presence_xml_create_node(state_data->pool, NULL, \"dialog-info\");\n}\n", "bug_type": null, "idx": 1099}
{"project": "Asterisk", "target": 0, "func": "static struct ast_str *test_cel_generate_peer_str_snapshot(struct ast_channel_snapshot *chan, struct ast_bridge *bridge)\n{\n\tRAII_VAR(struct ast_bridge_snapshot *, snapshot,\n\t\tast_bridge_snapshot_get_latest(bridge->uniqueid),\n\t\tao2_cleanup);\n\tif (!snapshot) {\n\t\treturn NULL;\n\t}\n\treturn __test_cel_generate_peer_str(chan, snapshot);\n}\n", "bug_type": null, "idx": 1100}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225PublicPartyNumber (OOCTXT* pctxt, H225PublicPartyNumber* pvalue)\n{\n   int stat = ASN_OK;\n   \n   stat = asn1PE_H225PublicTypeOfNumber (pctxt, &pvalue->publicTypeOfNumber);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225NumberDigits (pctxt, pvalue->publicNumberDigits);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1101}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpClearAllAliases(void)\n{\n   ooAliases *pAlias = NULL, *pTemp;\n   if(gH323ep.aliases)\n   {\n      pAlias = gH323ep.aliases;\n      while(pAlias)\n      {\n         pTemp = pAlias;\n         pAlias = pAlias->next;\n         memFreePtr(&gH323ep.ctxt, pTemp);\n      }\n      gH323ep.aliases = NULL;\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1102}
{"project": "Asterisk", "target": 0, "func": "static void check_translation_path(\n\tstruct ast_format_cap *dest, struct ast_format_cap *src,\n\tstruct ast_format_cap *result, struct ast_format *src_fmt,\n\tenum ast_media_type type)\n{\n\tint index, src_index = format2index(src_fmt);\n\t\n\tfor (index = 0; (src_index >= 0) && index < cur_max_index; index++) {\n\t\tstruct ast_codec *codec = index2codec(index);\n\t\tRAII_VAR(struct ast_format *, fmt, ast_format_create(codec), ao2_cleanup);\n\t\tao2_ref(codec, -1);\n\t\tif (ast_format_get_type(fmt) != type) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (ast_format_cap_iscompatible_format(dest, fmt) == AST_FORMAT_CMP_NOT_EQUAL) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (ast_format_cap_iscompatible_format(src, fmt) == AST_FORMAT_CMP_EQUAL) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!matrix_get(src_index, index)->step) {\n\t\t\tast_format_cap_remove(result, fmt);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!matrix_get(index, src_index)->step) {\n\t\t\tast_format_cap_remove(result, fmt);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1103}
{"project": "Asterisk", "target": 0, "func": "float *get_hrir(unsigned int chan_pos, unsigned int chan_side)\n{\n#ifdef BINAURAL_RENDERING\n\tif (chan_side == HRIRS_CHANNEL_LEFT) {\n\t\treturn hrirs_left[ast_binaural_positions[chan_pos]];\n\t} else if (chan_side == HRIRS_CHANNEL_RIGHT) {\n\t\treturn hrirs_right[ast_binaural_positions[chan_pos]];\n\t}\n#else\n\tast_log(LOG_ERROR, \"Requesting data for the binaural conference feature without \"\n\t\t\t\"it beeing active.\\n\");\n#endif\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1104}
{"project": "Asterisk", "target": 0, "func": "static int res_srtp_init(void)\n{\n\tif (g_initialized) {\n\t\treturn 0;\n\t}\n\tif (srtp_init() != err_status_ok) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to initialize libsrtp\\n\");\n\t\treturn -1;\n\t}\n\tsrtp_install_event_handler(srtp_event_cb);\n\tif (ast_rtp_engine_register_srtp(&srtp_res, &policy_res)) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to register SRTP with rtp engine\\n\");\n\t\tres_srtp_shutdown();\n\t\treturn -1;\n\t}\n\tif (ast_sdp_crypto_register(&res_sdp_crypto_api)) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to register SDP SRTP crypto API\\n\");\n\t\tres_srtp_shutdown();\n\t\treturn -1;\n\t}\n\tg_initialized = 1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1105}
{"project": "Asterisk", "target": 0, "func": " */\nint sig_pri_is_alarm_ignored(struct sig_pri_span *pri)\n{\n\treturn pri->layer1_ignored;\n}\n", "bug_type": null, "idx": 1106}
{"project": "Asterisk", "target": 0, "func": "static void rtp_ice_wrap_ice_lite(struct ast_rtp_instance *instance)\n{\n\tao2_lock(instance);\n\tinstance->engine->ice->ice_lite(instance);\n\tao2_unlock(instance);\n}\n", "bug_type": null, "idx": 1107}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int bit_at(unsigned int *word, int bitsperword, int bitnum)\n{\n\treturn word[bitnum/bitsperword] & (1 << (bitnum % bitsperword));\n}\n", "bug_type": null, "idx": 1108}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int verify(const struct ast_sip_auth *auth, pjsip_rx_data *rdata, pj_pool_t *pool)\n{\n\tpj_status_t authed;\n\tint response_code;\n\tpjsip_auth_srv auth_server;\n\tint stale = 0;\n\tif (!find_challenge(rdata, auth)) {\n\t\t\n\t\tstale = 1;\n\t}\n\tsetup_auth_srv(pool, &auth_server, auth->realm);\n\tstore_auth(auth);\n\tauthed = pjsip_auth_srv_verify(&auth_server, rdata, &response_code);\n\tremove_auth();\n\tif (authed == PJ_SUCCESS) {\n\t\tif (stale) {\n\t\t\treturn AUTH_STALE;\n\t\t} else {\n\t\t\treturn AUTH_SUCCESS;\n\t\t}\n\t}\n\tif (authed == PJSIP_EAUTHNOAUTH) {\n\t\treturn AUTH_NOAUTH;\n\t}\n\treturn AUTH_FAIL;\n}\n", "bug_type": null, "idx": 1109}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245H263VideoMode_resolution (OOCTXT* pctxt, H245H263VideoMode_resolution* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   OOCTXT lctxt;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"sqcif\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"sqcif\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"qcif\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"qcif\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"cif\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"cif\", -1);\n            break;\n         \n         case 3:\n            invokeStartElement (pctxt, \"cif4\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"cif4\", -1);\n            break;\n         \n         case 4:\n            invokeStartElement (pctxt, \"cif16\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"cif16\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 6;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n      copyContext (&lctxt, pctxt);\n      initContextBuffer (pctxt, openType.data, openType.numocts);\n      switch (pvalue->t) {\n         \n         case 6:\n            invokeStartElement (pctxt, \"custom\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"custom\", -1);\n            break;\n         default:;\n      }\n      copyContext (pctxt, &lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1110}
{"project": "Asterisk", "target": 0, "func": "static AST_RWLIST_HEAD_STATIC(agi_commands, agi_command);\nstatic char *help_workhorse(int fd, const char * const match[])\n{\n\tchar fullcmd[MAX_CMD_LEN], matchstr[MAX_CMD_LEN];\n\tstruct agi_command *e;\n\tif (match)\n\t\tast_join(matchstr, sizeof(matchstr), match);\n\tast_cli(fd, \"%5.5s %30.30s   %s\\n\",\"Dead\",\"Command\",\"Description\");\n\tAST_RWLIST_RDLOCK(&agi_commands);\n\tAST_RWLIST_TRAVERSE(&agi_commands, e, list) {\n\t\tif (!e->cmda[0])\n\t\t\tbreak;\n\t\t\n\t\tif ((e->cmda[0])[0] == '_')\n\t\t\tcontinue;\n\t\tast_join(fullcmd, sizeof(fullcmd), e->cmda);\n\t\tif (match && strncasecmp(matchstr, fullcmd, strlen(matchstr)))\n\t\t\tcontinue;\n\t\tast_cli(fd, \"%5.5s %30.30s   %s\\n\", e->dead ? \"Yes\" : \"No\" , fullcmd, S_OR(e->summary, \"Not available\"));\n\t}\n\tAST_RWLIST_UNLOCK(&agi_commands);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1111}
{"project": "Asterisk", "target": 0, "func": "static char *handle_show_translation_table(struct ast_cli_args *a)\n{\n\tint x, y, i, k;\n\tint longest = 0, num_codecs = 0, curlen = 0;\n\tstruct ast_str *out = ast_str_create(1024);\n\tstruct ast_codec *codec;\n\t\n\tfor (i = 1; (codec = ast_codec_get_by_id(i)); ao2_ref(codec, -1), ++i) {\n\t\t++num_codecs;\n\t\tif (codec->type != AST_MEDIA_TYPE_AUDIO) {\n\t\t\tcontinue;\n\t\t}\n\t\tcurlen = strlen(codec->name);\n\t\tif (curlen > longest) {\n\t\t\tlongest = curlen;\n\t\t}\n\t}\n\tAST_RWLIST_RDLOCK(&translators);\n\tast_cli(a->fd, \"         Translation times between formats (in microseconds) for one second of data\\n\");\n\tast_cli(a->fd, \"          Source Format (Rows) Destination Format (Columns)\\n\\n\");\n\tfor (i = 0; i < num_codecs; i++) {\n\t\tstruct ast_codec *row = i ? ast_codec_get_by_id(i) : NULL;\n\t\tx = -1;\n\t\tif ((i > 0) && (row->type != AST_MEDIA_TYPE_AUDIO)) {\n\t\t\tao2_ref(row, -1);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((i > 0) && (x = codec2index(row)) == -1) {\n\t\t\tao2_ref(row, -1);\n\t\t\tcontinue;\n\t\t}\n\t\tast_str_set(&out, 0, \" \");\n\t\tfor (k = 0; k < num_codecs; k++) {\n\t\t\tstruct ast_codec *col = k ? ast_codec_get_by_id(k) : NULL;\n\t\t\ty = -1;\n\t\t\tif ((k > 0) && (col->type != AST_MEDIA_TYPE_AUDIO)) {\n\t\t\t\tao2_ref(col, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((k > 0) && (y = codec2index(col)) == -1) {\n\t\t\t\tao2_ref(col, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (k > 0) {\n\t\t\t\tcurlen = strlen(col->name);\n\t\t\t}\n\t\t\tif (curlen < 5) {\n\t\t\t\tcurlen = 5;\n\t\t\t}\n\t\t\tif (x >= 0 && y >= 0 && matrix_get(x, y)->step) {\n\t\t\t\t\n\t\t\t\tast_str_append(&out, 0, \"%*u\", curlen + 1, (matrix_get(x, y)->table_cost/100));\n\t\t\t} else if (i == 0 && k > 0) {\n\t\t\t\t\n\t\t\t\tast_str_append(&out, 0, \"%*s\", curlen + 1, col->name);\n\t\t\t} else if (k == 0 && i > 0) {\n\t\t\t\t\n\t\t\t\tast_str_append(&out, 0, \"%*s\", longest, row->name);\n\t\t\t} else if (x >= 0 && y >= 0) {\n\t\t\t\t\n\t\t\t\tast_str_append(&out, 0, \"%*s\", curlen + 1, \"-\");\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tast_str_append(&out, 0, \"%*s\", longest, \"\");\n\t\t\t}\n\t\t\tao2_cleanup(col);\n\t\t}\n\t\tast_str_append(&out, 0, \"\\n\");\n\t\tast_cli(a->fd, \"%s\", ast_str_buffer(out));\n\t\tao2_cleanup(row);\n\t}\n\tast_free(out);\n\tAST_RWLIST_UNLOCK(&translators);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1112}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res = 0;\n\tstruct ast_db_entry *db_entry, *db_tree;\n\t\n\tdb_entry = db_tree = ast_db_gettree(astdb_family, NULL);\n\tfor (; db_entry; db_entry = db_entry->next) {\n\t\tconst char *dev_name = strrchr(db_entry->key, '/') + 1;\n\t\tenum ast_presence_state state;\n\t\tchar *message;\n\t\tchar *subtype;\n\t\tif (dev_name <= (const char *) 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tstate = custom_presence_callback(dev_name, &subtype, &message);\n\t\tast_presence_state_changed(state, subtype, message, \"CustomPresence:%s\", dev_name);\n\t\tast_free(subtype);\n\t\tast_free(message);\n\t}\n\tast_db_freetree(db_tree);\n\tdb_tree = NULL;\n\tres |= ast_custom_function_register(&presence_function);\n\tres |= ast_presence_state_prov_add(\"CustomPresence\", custom_presence_callback);\n\tres |= ast_cli_register_multiple(cli_funcpresencestate, ARRAY_LEN(cli_funcpresencestate));\n#ifdef TEST_FRAMEWORK\n\tAST_TEST_REGISTER(test_valid_parse_data);\n\tAST_TEST_REGISTER(test_invalid_parse_data);\n\tAST_TEST_REGISTER(test_presence_state_change);\n\tAST_TEST_REGISTER(test_presence_state_base64_encode);\n#endif\n\treturn res;\n}\n", "bug_type": null, "idx": 1113}
{"project": "Asterisk", "target": 0, "func": "int ast_pbx_init(void)\n{\n\thints = ao2_container_alloc(HASH_EXTENHINT_SIZE, hint_hash, hint_cmp);\n\tif (hints) {\n\t\tao2_container_register(\"hints\", hints, print_hints_key);\n\t}\n\thintdevices = ao2_container_alloc(HASH_EXTENHINT_SIZE, hintdevice_hash_cb, hintdevice_cmp_multiple);\n\tif (hintdevices) {\n\t\tao2_container_register(\"hintdevices\", hintdevices, print_hintdevices_key);\n\t}\n\t\n\tautohints = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, HASH_EXTENHINT_SIZE,\n\t\tautohint_hash_cb, autohint_cmp);\n\tif (hintdevices) {\n\t\tao2_container_register(\"autohints\", autohints, print_autohint_key);\n\t}\n\tstatecbs = ao2_container_alloc(1, NULL, statecbs_cmp);\n\tif (statecbs) {\n\t\tao2_container_register(\"statecbs\", statecbs, print_statecbs_key);\n\t}\n\tast_register_cleanup(pbx_shutdown);\n\tif (STASIS_MESSAGE_TYPE_INIT(hint_change_message_type) != 0) {\n\t\treturn -1;\n\t}\n\treturn (hints && hintdevices && autohints && statecbs) ? 0 : -1;\n}\n", "bug_type": null, "idx": 1114}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hook_remove_match(void *obj, void *arg, int flags)\n{\n\tstruct ast_bridge_hook *hook = obj;\n\tenum ast_bridge_hook_remove_flags *remove_flags = arg;\n\tif (ast_test_flag(&hook->remove_flags, *remove_flags)) {\n\t\treturn CMP_MATCH;\n\t} else {\n\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 1115}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_custom_function_register(&blacklist_function);\n}\n", "bug_type": null, "idx": 1116}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_register_application_xml(app2, setcallerid_pres_exec);\n}\n", "bug_type": null, "idx": 1117}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tint res = 0;\n\tstruct ast_config *cfg;\n\tchar *catg;\n\tconst char *s;\n\tstruct ast_flags config_flags = { 0 };\n\tres |= ast_custom_function_register(&fetch_function);\n\tres |= ast_register_application_xml(app_odbcfinish, exec_odbcfinish);\n\tcfg = ast_config_load(config, config_flags);\n\tif (!cfg || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_NOTICE, \"Unable to load config for func_odbc: %s\\n\", config);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_rwlock_wrlock(&single_db_connection_lock);\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"single_db_connection\"))) {\n\t\tsingle_db_connection = ast_true(s);\n\t} else {\n\t\tsingle_db_connection = DEFAULT_SINGLE_DB_CONNECTION;\n\t}\n\tdsns = NULL;\n\tif (single_db_connection) {\n\t\tdsns = ao2_container_alloc(DSN_BUCKETS, dsn_hash, dsn_cmp);\n\t\tif (!dsns) {\n\t\t\tast_log(LOG_ERROR, \"Could not initialize DSN container\\n\");\n\t\t\tast_rwlock_unlock(&single_db_connection_lock);\n\t\t\treturn AST_MODULE_LOAD_DECLINE;\n\t\t}\n\t}\n\tast_rwlock_unlock(&single_db_connection_lock);\n\tAST_RWLIST_WRLOCK(&queries);\n\tfor (catg = ast_category_browse(cfg, NULL);\n\t     catg;\n\t     catg = ast_category_browse(cfg, catg)) {\n\t\tstruct acf_odbc_query *query = NULL;\n\t\tint err;\n\t\tif (!strcasecmp(catg, \"general\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((err = init_acf_query(cfg, catg, &query))) {\n\t\t\tif (err == ENOMEM)\n\t\t\t\tast_log(LOG_ERROR, \"Out of memory\\n\");\n\t\t\telse if (err == EINVAL)\n\t\t\t\tast_log(LOG_ERROR, \"Invalid parameters for category %s\\n\", catg);\n\t\t\telse\n\t\t\t\tast_log(LOG_ERROR, \"%s (%d)\\n\", strerror(err), err);\n\t\t} else {\n\t\t\tAST_RWLIST_INSERT_HEAD(&queries, query, list);\n\t\t\tast_custom_function_register(query->acf);\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n\tres |= ast_custom_function_register(&escape_function);\n\tast_cli_register_multiple(cli_func_odbc, ARRAY_LEN(cli_func_odbc));\n\tAST_RWLIST_UNLOCK(&queries);\n\treturn res;\n}\n", "bug_type": null, "idx": 1118}
{"project": "Asterisk", "target": 0, "func": "static int load_config(unsigned int reload)\n{\n\tstatic const char filename[] = \"res_corosync.conf\";\n\tstruct ast_config *cfg;\n\tconst char *cat = NULL;\n\tstruct ast_flags config_flags = { 0 };\n\tint res = 0;\n\tcfg = ast_config_load(filename, config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\treturn -1;\n\t}\n\twhile ((cat = ast_category_browse(cfg, cat))) {\n\t\tif (!strcasecmp(cat, \"general\")) {\n\t\t\tres = load_general_config(cfg);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown configuration section '%s'\\n\", cat);\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n\treturn res;\n}\n", "bug_type": null, "idx": 1119}
{"project": "Asterisk", "target": 0, "func": "static int say_date(struct ast_channel *chan, time_t t, const char *ints, const char *lang)\n{\n\treturn say_date_generic(chan, t, ints, lang, \"\", NULL, \"date\");\n}\n", "bug_type": null, "idx": 1120}
{"project": "Asterisk", "target": 0, "func": "static int handle_asyncagi_break(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])\n{\n\tast_agi_send(agi->fd, chan, \"200 result=0\\n\");\n\treturn ASYNC_AGI_BREAK;\n}\n", "bug_type": null, "idx": 1121}
{"project": "Asterisk", "target": 0, "func": "\nstatic const char *tech_capability2str(uint32_t capabilities)\n{\n\tconst char *type;\n\tif (capabilities & AST_BRIDGE_CAPABILITY_HOLDING) {\n\t\ttype = \"Holding\";\n\t} else if (capabilities & AST_BRIDGE_CAPABILITY_EARLY) {\n\t\ttype = \"Early\";\n\t} else if (capabilities & AST_BRIDGE_CAPABILITY_NATIVE) {\n\t\ttype = \"Native\";\n\t} else if (capabilities & AST_BRIDGE_CAPABILITY_1TO1MIX) {\n\t\ttype = \"1to1Mix\";\n\t} else if (capabilities & AST_BRIDGE_CAPABILITY_MULTIMIX) {\n\t\ttype = \"MultiMix\";\n\t} else {\n\t\ttype = \"<Unknown>\";\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 1122}
{"project": "Asterisk", "target": 0, "func": "static pj_bool_t logging_on_rx_msg(pjsip_rx_data *rdata)\n{\n\tchar local_buf[256];\n\tchar remote_buf[256];\n\tchar *uuid;\n\tstruct hepv3_capture_info *capture_info;\n\tpjsip_tpmgr_fla2_param prm;\n\tcapture_info = hepv3_create_capture_info(&rdata->pkt_info.packet, rdata->pkt_info.len);\n\tif (!capture_info) {\n\t\treturn PJ_SUCCESS;\n\t}\n\tif (!rdata->pkt_info.src_addr_len) {\n\t\treturn PJ_SUCCESS;\n\t}\n\tpj_sockaddr_print(&rdata->pkt_info.src_addr, remote_buf, sizeof(remote_buf), 3);\n\t\n\tpjsip_tpmgr_fla2_param_default(&prm);\n\tprm.tp_type = rdata->tp_info.transport->key.type;\n\tpj_strset2(&prm.dst_host, rdata->pkt_info.src_name);\n\tprm.local_if = PJ_TRUE;\n\t\n\tif (pjsip_tpmgr_find_local_addr2(pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint()), rdata->tp_info.pool, &prm) != PJ_SUCCESS) {\n\t\tpj_sockaddr_print(&rdata->tp_info.transport->local_addr, local_buf, sizeof(local_buf), 3);\n\t} else {\n\t\tif (prm.tp_type & PJSIP_TRANSPORT_IPV6) {\n\t\t\tsnprintf(local_buf, sizeof(local_buf), \"[%.*s]:%hu\",\n\t\t\t\t(int)pj_strlen(&prm.ret_addr),\n\t\t\t\tpj_strbuf(&prm.ret_addr),\n\t\t\t\tprm.ret_port);\n\t\t} else {\n\t\t\tsnprintf(local_buf, sizeof(local_buf), \"%.*s:%hu\",\n\t\t\t\t(int)pj_strlen(&prm.ret_addr),\n\t\t\t\tpj_strbuf(&prm.ret_addr),\n\t\t\t\tprm.ret_port);\n\t\t}\n\t}\n\tuuid = assign_uuid(&rdata->msg_info.cid->id, &rdata->msg_info.to->tag, &rdata->msg_info.from->tag);\n\tif (!uuid) {\n\t\tao2_ref(capture_info, -1);\n\t\treturn PJ_SUCCESS;\n\t}\n\tast_sockaddr_parse(&capture_info->src_addr, remote_buf, PARSE_PORT_REQUIRE);\n\tast_sockaddr_parse(&capture_info->dst_addr, local_buf, PARSE_PORT_REQUIRE);\n\tcapture_info->protocol_id = transport_to_protocol_id(rdata->tp_info.transport);\n\tcapture_info->capture_time.tv_sec = rdata->pkt_info.timestamp.sec;\n\tcapture_info->capture_time.tv_usec = rdata->pkt_info.timestamp.msec * 1000;\n\tcapture_info->capture_type = HEPV3_CAPTURE_TYPE_SIP;\n\tcapture_info->uuid = uuid;\n\tcapture_info->zipped = 0;\n\thepv3_send_packet(capture_info);\n\treturn PJ_FALSE;\n}\n", "bug_type": null, "idx": 1123}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void rtp_codecs_payload_replace_rx(struct ast_rtp_codecs *codecs, int payload, struct ast_rtp_payload_type *new_type)\n{\n\tao2_ref(new_type, +1);\n\tif (payload < AST_VECTOR_SIZE(&codecs->payload_mapping_rx)) {\n\t\tao2_t_cleanup(AST_VECTOR_GET(&codecs->payload_mapping_rx, payload),\n\t\t\t\"cleaning up rx mapping vector element about to be replaced\");\n\t}\n\tAST_VECTOR_REPLACE(&codecs->payload_mapping_rx, payload, new_type);\n\tpayload_mapping_rx_clear_primary(codecs, new_type);\n}\n", "bug_type": null, "idx": 1124}
{"project": "Asterisk", "target": 0, "func": "static int reload(void)\n{\n\tosp_load(1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1125}
{"project": "Asterisk", "target": 0, "func": "static int conf_menu_profile_copy(struct conf_menu *dst, struct conf_menu *src)\n{\n\t\n\tstruct conf_menu_entry *cur;\n\tAST_LIST_TRAVERSE(&src->entries, cur, entry) {\n\t\tstruct conf_menu_entry *cpy;\n\t\tif (!(cpy = ast_calloc(1, sizeof(*cpy)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (copy_menu_entry(cpy, cur)) {\n\t\t\tconf_menu_entry_destroy(cpy);\n\t\t\tast_free(cpy);\n\t\t\treturn -1;\n\t\t}\n\t\tAST_LIST_INSERT_TAIL(&dst->entries, cpy, entry);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1126}
{"project": "Asterisk", "target": 0, "func": "static void capture_buildopts_cb(int level, const char *data, int len)\n{\n\tif (strstr(data, \"Teluu\") || strstr(data, \"Dumping\")) {\n\t\treturn;\n\t}\n\tAST_VECTOR_ADD_SORTED(&buildopts, ast_strdup(ast_skip_blanks(data)), strcmp);\n}\n", "bug_type": null, "idx": 1127}
{"project": "Asterisk", "target": 0, "func": "static int consulting_enter(struct attended_transfer_properties *props)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1128}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int has_destination_cb(const struct ast_msg *msg)\n{\n\tstruct message_subscription *sub;\n\tint i;\n\tchar buf[256];\n\tmsg_to_endpoint(msg, buf, sizeof(buf));\n\tast_rwlock_rdlock(&tech_subscriptions_lock);\n\tfor (i = 0; i < AST_VECTOR_SIZE(&tech_subscriptions); i++) {\n\t\tsub = AST_VECTOR_GET(&tech_subscriptions, i);\n\t\tif (!sub) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(sub->token, TECH_WILDCARD)\n\t\t    || !strncasecmp(sub->token, buf, strlen(sub->token))\n\t\t    || !strncasecmp(sub->token, buf, strlen(sub->token))) {\n\t\t\tast_rwlock_unlock(&tech_subscriptions_lock);\n\t\t\tgoto match;\n\t\t}\n\t}\n\tast_rwlock_unlock(&tech_subscriptions_lock);\n\tsub = ao2_find(endpoint_subscriptions, buf, OBJ_SEARCH_KEY);\n\tif (sub) {\n\t\tao2_ref(sub, -1);\n\t\tgoto match;\n\t}\n\tast_debug(1, \"No subscription found for %s\\n\", buf);\n\treturn 0;\nmatch:\n\treturn 1;\n}\n", "bug_type": null, "idx": 1129}
{"project": "Asterisk", "target": 0, "func": "static int reload_module(void)\n{\n\tchar was_enabled = is_enabled();\n\tif (ast_ari_config_reload() != 0) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (was_enabled && !is_enabled()) {\n\t\tast_debug(3, \"Disabling ARI\\n\");\n\t\tast_http_uri_unlink(&http_uri);\n\t} else if (!was_enabled && is_enabled()) {\n\t\tast_debug(3, \"Enabling ARI\\n\");\n\t\tast_http_uri_link(&http_uri);\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1130}
{"project": "Asterisk", "target": 0, "func": "\nstatic int control_hash(const void *obj, const int flags)\n{\n\tconst struct stasis_app_control *control;\n\tconst char *key;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_KEY:\n\t\tkey = obj;\n\t\tbreak;\n\tcase OBJ_SEARCH_OBJECT:\n\t\tcontrol = obj;\n\t\tkey = stasis_app_control_get_channel_id(control);\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tast_assert(0);\n\t\treturn 0;\n\t}\n\treturn ast_str_hash(key);\n}\n", "bug_type": null, "idx": 1131}
{"project": "Asterisk", "target": 0, "func": "static void cel_generic_cb(\n\tvoid *data, struct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tstruct ast_channel_blob *obj = stasis_message_data(message);\n\tint event_type = ast_json_integer_get(ast_json_object_get(obj->blob, \"event_type\"));\n\tstruct ast_json *event_details = ast_json_object_get(obj->blob, \"event_details\");\n\tswitch (event_type) {\n\tcase AST_CEL_USER_DEFINED:\n\t\t{\n\t\t\tconst char *event = ast_json_string_get(ast_json_object_get(event_details, \"event\"));\n\t\t\tstruct ast_json *extra = ast_json_object_get(event_details, \"extra\");\n\t\t\tcel_report_event(obj->snapshot, event_type, event, extra, NULL);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tast_log(LOG_ERROR, \"Unhandled %s event blob\\n\", ast_cel_get_type_name(event_type));\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1132}
{"project": "Asterisk", "target": 0, "func": "static void dahdi_wait_for_packet(int fd)\n{\n\tstruct pollfd p = {0};\n\tp.fd = fd;\n\tp.events = POLLIN;\n\tpoll(&p, 1, 10);\n}\n", "bug_type": null, "idx": 1133}
{"project": "Asterisk", "target": 0, "func": "\nstatic int persistent_endpoint_publish_status(void *obj, void *arg, int flags)\n{\n\tstruct sip_persistent_endpoint *persistent = obj;\n\tstruct ast_endpoint *endpoint = persistent->endpoint;\n\tstruct ast_sip_contact_status *status = arg;\n\t\n\tif (!strstr(persistent->aors, status->aor)) {\n\t\treturn 0;\n\t}\n\tendpoint_publish_contact_status(endpoint, status);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1134}
{"project": "Asterisk", "target": 0, "func": " */\nvoid MD5Transform(uint32_t buf[4], uint32_t const in[16])\n{\n\tregister uint32_t a, b, c, d;\n\ta = buf[0];\n\tb = buf[1];\n\tc = buf[2];\n\td = buf[3];\n\tMD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n\tMD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n\tMD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n\tMD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n\tMD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n\tMD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n\tMD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n\tMD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n\tMD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n\tMD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n\tMD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n\tMD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n\tMD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n\tMD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n\tMD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n\tMD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\tMD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n\tMD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n\tMD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n\tMD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n\tMD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n\tMD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n\tMD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n\tMD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n\tMD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n\tMD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n\tMD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n\tMD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n\tMD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n\tMD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n\tMD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n\tMD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\tMD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n\tMD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n\tMD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n\tMD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n\tMD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n\tMD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n\tMD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n\tMD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n\tMD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n\tMD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n\tMD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n\tMD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n\tMD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n\tMD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n\tMD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n\tMD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\tMD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n\tMD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n\tMD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n\tMD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n\tMD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n\tMD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n\tMD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n\tMD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n\tMD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n\tMD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n\tMD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n\tMD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n\tMD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n\tMD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n\tMD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n\tMD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\tbuf[0] += a;\n\tbuf[1] += b;\n\tbuf[2] += c;\n\tbuf[3] += d;\n}\n", "bug_type": null, "idx": 1135}
{"project": "Asterisk", "target": 0, "func": "struct ast_rtp_rtcp_report *ast_rtp_rtcp_report_alloc(unsigned int report_blocks)\n{\n\tstruct ast_rtp_rtcp_report *rtcp_report;\n\t\n\trtcp_report = ao2_alloc((sizeof(*rtcp_report) + report_blocks * sizeof(struct ast_rtp_rtcp_report_block *)),\n\t\trtp_rtcp_report_dtor);\n\treturn rtcp_report;\n}\n", "bug_type": null, "idx": 1136}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void json_mem_unlock(struct json_mem *mem)\n{\n\tif (!mem) {\n\t\treturn;\n\t}\n\tast_mutex_unlock(&mem->mutex);\n}\n", "bug_type": null, "idx": 1137}
{"project": "Asterisk", "target": 0, "func": "int __ao2_unlock(void *user_data, const char *file, const char *func, int line, const char *var)\n{\n\tstruct astobj2 *obj = __INTERNAL_OBJ_CHECK(user_data, file, line, func);\n\tstruct astobj2_lock *obj_mutex;\n\tstruct astobj2_rwlock *obj_rwlock;\n\tstruct astobj2_lockobj *obj_lockobj;\n\tint res = 0;\n\tint current_value;\n\tif (obj == NULL) {\n\t\treturn -1;\n\t}\n\tswitch (obj->priv_data.options & AO2_ALLOC_OPT_LOCK_MASK) {\n\tcase AO2_ALLOC_OPT_LOCK_MUTEX:\n\t\tobj_mutex = INTERNAL_OBJ_MUTEX(user_data);\n\t\tres = __ast_pthread_mutex_unlock(file, line, func, var, &obj_mutex->mutex.lock);\n#ifdef AO2_DEBUG\n\t\tif (!res) {\n\t\t\tast_atomic_fetchadd_int(&ao2.total_locked, -1);\n\t\t}\n#endif\n\t\tbreak;\n\tcase AO2_ALLOC_OPT_LOCK_RWLOCK:\n\t\tobj_rwlock = INTERNAL_OBJ_RWLOCK(user_data);\n\t\tcurrent_value = ast_atomic_fetchadd_int(&obj_rwlock->rwlock.num_lockers, -1) - 1;\n\t\tif (current_value < 0) {\n\t\t\t\n\t\t\tast_atomic_fetchadd_int(&obj_rwlock->rwlock.num_lockers, -current_value);\n\t\t}\n\t\tres = __ast_rwlock_unlock(file, line, func, &obj_rwlock->rwlock.lock, var);\n#ifdef AO2_DEBUG\n\t\tif (!res) {\n\t\t\tast_atomic_fetchadd_int(&ao2.total_locked, -1);\n\t\t}\n#endif\n\t\tbreak;\n\tcase AO2_ALLOC_OPT_LOCK_NOLOCK:\n\t\t\n\t\tbreak;\n\tcase AO2_ALLOC_OPT_LOCK_OBJ:\n\t\tobj_lockobj = INTERNAL_OBJ_LOCKOBJ(user_data);\n\t\tres = __ao2_unlock(obj_lockobj->lockobj.lock, file, func, line, var);\n\t\tbreak;\n\tdefault:\n\t\tast_log(__LOG_ERROR, file, line, func, \"Invalid lock option on ao2 object %p\\n\",\n\t\t\tuser_data);\n\t\tres = -1;\n\t\tbreak;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1138}
{"project": "Asterisk", "target": 0, "func": "static struct ast_json *channel_created_event(\n\tstruct ast_channel_snapshot *snapshot,\n\tconst struct timeval *tv)\n{\n\treturn simple_channel_event(\"ChannelCreated\", snapshot, tv);\n}\n", "bug_type": null, "idx": 1139}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_custom_function_register(&pjsip_contact_function);\n}\n", "bug_type": null, "idx": 1140}
{"project": "Asterisk", "target": 0, "func": "static int dahdi_wink(struct dahdi_pvt *p, int index);\nstatic int my_wink(void *pvt, enum analog_sub sub)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tint index = analogsub_to_dahdisub(sub);\n\tif (index != SUB_REAL) {\n\t\tast_log(LOG_ERROR, \"We used a sub other than SUB_REAL (incorrect assumption sir)\\n\");\n\t}\n\treturn dahdi_wink(p, index);\n}\n", "bug_type": null, "idx": 1141}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_set_binaural_active(struct ast_bridge *bridge, unsigned int binaural_active)\n{\n\tast_bridge_lock(bridge);\n\tbridge->softmix.binaural_active = binaural_active;\n\tast_bridge_unlock(bridge);\n}\n", "bug_type": null, "idx": 1142}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225H323_UserInformation (OOCTXT* pctxt, H225H323_UserInformation* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.user_dataPresent = optbit;\n   \n   invokeStartElement (pctxt, \"h323_uu_pdu\", -1);\n   stat = asn1PD_H225H323_UU_PDU (pctxt, &pvalue->h323_uu_pdu);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"h323_uu_pdu\", -1);\n   \n   if (pvalue->m.user_dataPresent) {\n      invokeStartElement (pctxt, \"user_data\", -1);\n      stat = asn1PD_H225H323_UserInformation_user_data (pctxt, &pvalue->user_data);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"user_data\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1143}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\treturn ast_custom_function_unregister(&jb_function);\n}\n", "bug_type": null, "idx": 1144}
{"project": "Asterisk", "target": 0, "func": "void ast_bucket_file_observer_remove(const struct ast_sorcery_observer *callbacks)\n{\n\tast_sorcery_observer_remove(bucket_sorcery, \"file\", callbacks);\n}\n", "bug_type": null, "idx": 1145}
{"project": "Asterisk", "target": 0, "func": "static int analog_handles_digit(struct ast_frame *f)\n{\n\tchar subclass = toupper(f->subclass.integer);\n\tswitch (subclass) {\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '9':\n\tcase 'A':\n\tcase 'B':\n\tcase 'C':\n\tcase 'D':\n\tcase 'E':\n\tcase 'F':\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 1146}
{"project": "Asterisk", "target": 0, "func": "static const char *cache_simple(struct stasis_message *message)\n{\n\tconst char *type_name =\n\t\tstasis_message_type_name(stasis_message_type(message));\n\tif (!ast_begins_with(type_name, \"Cache\")) {\n\t\treturn NULL;\n\t}\n\treturn \"cached\";\n}\n", "bug_type": null, "idx": 1147}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_features_set_flag(struct ast_bridge_features *features, unsigned int flag)\n{\n\tast_set_flag(&features->feature_flags, flag);\n\tfeatures->usable = 1;\n}\n", "bug_type": null, "idx": 1148}
{"project": "Asterisk", "target": 0, "func": "static int verify_m_line(struct ast_sdp *sdp, int index, char *type, int port,\n\tint port_count, char *profile, ...)\n{\n\tstruct ast_sdp_m_line *m_line;\n\tint res;\n\tva_list ap;\n\tint i;\n\tm_line = ast_sdp_get_m(sdp, index);\n\tres = strcmp(m_line->type, type) == 0;\n\tres |= m_line->port == port;\n\tres |= m_line->port_count == port_count;\n\tres |= strcmp(m_line->proto, profile) == 0;\n\tva_start(ap, profile);\n\tfor (i = 0; i < ast_sdp_m_get_payload_count(m_line); ++i) {\n\t\tchar *payload;\n\t\tpayload = va_arg(ap, char *);\n\t\tif (!payload) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tres |= strcmp(ast_sdp_m_get_payload(m_line, i)->fmt, payload) == 0;\n\t}\n\tva_end(ap);\n\treturn res;\n}\n", "bug_type": null, "idx": 1149}
{"project": "Asterisk", "target": 0, "func": "static void agents_post_apply_config(void)\n{\n\tstruct ao2_iterator iter;\n\tstruct agent_cfg *cfg;\n\tRAII_VAR(struct agents_cfg *, cfgs, ao2_global_obj_ref(cfg_handle), ao2_cleanup);\n\tast_assert(cfgs != NULL);\n\tagents_mark();\n\titer = ao2_iterator_init(cfgs->agents, 0);\n\tfor (; (cfg = ao2_iterator_next(&iter)); ao2_ref(cfg, -1)) {\n\t\tRAII_VAR(struct agent_pvt *, agent, ao2_find(agents, cfg->username, OBJ_KEY), ao2_cleanup);\n\t\tif (agent) {\n\t\t\tagent_lock(agent);\n\t\t\tagent->the_mark = 0;\n\t\t\tif (!agent->logged) {\n\t\t\t\tstruct agent_cfg *cfg_old;\n\t\t\t\t\n\t\t\t\tcfg_old = agent->cfg;\n\t\t\t\tao2_ref(cfg, +1);\n\t\t\t\tagent->cfg = cfg;\n\t\t\t\tao2_cleanup(cfg_old);\n\t\t\t}\n\t\t\tagent_unlock(agent);\n\t\t\tcontinue;\n\t\t}\n\t\tagent = agent_pvt_new(cfg);\n\t\tif (!agent) {\n\t\t\tcontinue;\n\t\t}\n\t\tao2_link(agents, agent);\n\t\tast_debug(1, \"Agent %s: Created.\\n\", agent->username);\n\t\tagent_devstate_changed(agent->username);\n\t}\n\tao2_iterator_destroy(&iter);\n\tagents_sweep();\n}\n", "bug_type": null, "idx": 1150}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235NonStandardParameter (OOCTXT* pctxt, H235NonStandardParameter* pvalue)\n{\n   int stat = ASN_OK;\n   \n   stat = encodeObjectIdentifier (pctxt, &pvalue->nonStandardIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeOctetString (pctxt, pvalue->data.numocts, pvalue->data.data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1151}
{"project": "Asterisk", "target": 0, "func": "})\nstatic struct ast_sdp_m_line *pjmedia_copy_m_line(struct pjmedia_sdp_media *pjmedia_m_line)\n{\n\tint i;\n\tstruct ast_sdp_c_line *c_line = pjmedia_m_line->conn ?\n\t\tast_sdp_c_alloc(dupa_pj_str(pjmedia_m_line->conn->addr_type),\n\t\tdupa_pj_str(pjmedia_m_line->conn->addr)) : NULL;\n\tstruct ast_sdp_m_line *m_line = ast_sdp_m_alloc(dupa_pj_str(pjmedia_m_line->desc.media),\n\t\tpjmedia_m_line->desc.port, pjmedia_m_line->desc.port_count,\n\t\tdupa_pj_str(pjmedia_m_line->desc.transport), c_line);\n\tfor (i = 0; i < pjmedia_m_line->desc.fmt_count; ++i) {\n\t\tast_sdp_m_add_payload(m_line,\n\t\t\tast_sdp_payload_alloc(dupa_pj_str(pjmedia_m_line->desc.fmt[i])));\n\t}\n\tfor (i = 0; i < pjmedia_m_line->attr_count; ++i) {\n\t\tast_sdp_m_add_a(m_line, ast_sdp_a_alloc(dupa_pj_str(pjmedia_m_line->attr[i]->name),\n\t\t\tdupa_pj_str(pjmedia_m_line->attr[i]->value)));\n\t}\n\treturn m_line;\n}\n", "bug_type": null, "idx": 1152}
{"project": "Asterisk", "target": 0, "func": "protected void\nterm_move_to_char(EditLine *el, int where)\n{\n\tint del, i;\nmc_again:\n\tif (where == el->el_cursor.h)\n\t\treturn;\n\tif (where > el->el_term.t_size.h) {\n#ifdef DEBUG_SCREEN\n\t\t(void) fprintf(el->el_errfile,\n\t\t    \"term_move_to_char: where is riduculous: %d\\r\\n\", where);\n#endif \n\t\treturn;\n\t}\n\tif (!where) {\t\t\n\t\tterm__putc('\\r');\t\n\t\tel->el_cursor.h = 0;\n\t\treturn;\n\t}\n\tdel = where - el->el_cursor.h;\n\tif ((del < -4 || del > 4) && GoodStr(T_ch))\n\t\t\n\t\t(void) tputs(tgoto(Str(T_ch), where, where), where, term__putc);\n\telse {\n\t\tif (del > 0) {\t\n\t\t\tif ((del > 4) && GoodStr(T_RI))\n\t\t\t\t(void) tputs(tgoto(Str(T_RI), del, del),\n\t\t\t\t    del, term__putc);\n\t\t\telse {\n\t\t\t\t\t\n\t\t\t\tif (EL_CAN_TAB) {\n\t\t\t\t\tif ((el->el_cursor.h & 0370) !=\n\t\t\t\t\t    (where & 0370)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (i =\n\t\t\t\t\t\t    (el->el_cursor.h & 0370);\n\t\t\t\t\t\t    i < (where & 0370);\n\t\t\t\t\t\t    i += 8)\n\t\t\t\t\t\t\tterm__putc('\\t');\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tel->el_cursor.h = where & 0370;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tterm_overwrite(el,\n\t\t\t\t    &el->el_display[el->el_cursor.v][el->el_cursor.h],\n\t\t\t\t    where - el->el_cursor.h);\n\t\t\t}\n\t\t} else {\t\n\t\t\tif ((-del > 4) && GoodStr(T_LE))\n\t\t\t\t(void) tputs(tgoto(Str(T_LE), -del, -del),\n\t\t\t\t    -del, term__putc);\n\t\t\telse {\t\n\t\t\t\t\n\t\t\t\tif (EL_CAN_TAB ?\n\t\t\t\t    (-del > (((unsigned int) where >> 3) +\n\t\t\t\t     (where & 07)))\n\t\t\t\t    : (-del > where)) {\n\t\t\t\t\tterm__putc('\\r');\t\n\t\t\t\t\tel->el_cursor.h = 0;\n\t\t\t\t\tgoto mc_again;\t\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < -del; i++)\n\t\t\t\t\tterm__putc('\\b');\n\t\t\t}\n\t\t}\n\t}\n\tel->el_cursor.h = where;\t\t\n}\n", "bug_type": null, "idx": 1153}
{"project": "Asterisk", "target": 0, "func": "struct ao2_container *ast_sorcery_retrieve_by_regex(const struct ast_sorcery *sorcery, const char *type, const char *regex)\n{\n\tRAII_VAR(struct ast_sorcery_object_type *, object_type, ao2_find(sorcery->types, type, OBJ_KEY), ao2_cleanup);\n\tstruct ao2_container *objects;\n\tint i;\n\tif (!object_type || !(objects = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, 1, NULL, NULL))) {\n\t\treturn NULL;\n\t}\n\tAST_VECTOR_RW_RDLOCK(&object_type->wizards);\n\tfor (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {\n\t\tstruct ast_sorcery_object_wizard *wizard =\n\t\t\tAST_VECTOR_GET(&object_type->wizards, i);\n\t\tif (!wizard->wizard->callbacks.retrieve_regex) {\n\t\t\tcontinue;\n\t\t}\n\t\twizard->wizard->callbacks.retrieve_regex(sorcery, wizard->data, object_type->name, objects, regex);\n\t\tif (wizard->caching && ao2_container_count(objects)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_VECTOR_RW_UNLOCK(&object_type->wizards);\n\treturn objects;\n}\n", "bug_type": null, "idx": 1154}
{"project": "Asterisk", "target": 0, "func": "char* pvalESwitchesWalkNames( pval *p, pval **next_item )\n{\n\tif (!pvalCheckType(p, \"pvalESwitchesWalkNames\", PV_ESWITCHES))\n\t\treturn 0;\n\tif (!(*next_item))\n\t\t*next_item = p->u1.list;\n\telse {\n\t\t*next_item = (*next_item)->next;\n\t}\n\treturn (*next_item)->u1.str;\n}\n", "bug_type": null, "idx": 1155}
{"project": "Asterisk", "target": 0, "func": "void ao2_iterator_restart(struct ao2_iterator *iter)\n{\n\tif (!is_ao2_object(iter->c)) {\n\t\t\n\t\treturn;\n\t}\n\t\n\tif (iter->last_node) {\n\t\tenum ao2_lock_req orig_lock;\n\t\t\n\t\tif (iter->flags & AO2_ITERATOR_DONTLOCK) {\n\t\t\torig_lock = __adjust_lock(iter->c, AO2_LOCK_REQ_RDLOCK, 1);\n\t\t} else {\n\t\t\torig_lock = AO2_LOCK_REQ_MUTEX;\n\t\t\tao2_rdlock(iter->c);\n\t\t}\n\t\tao2_t_ref(iter->last_node, -1, NULL);\n\t\titer->last_node = NULL;\n\t\tif (iter->flags & AO2_ITERATOR_DONTLOCK) {\n\t\t\t__adjust_lock(iter->c, orig_lock, 0);\n\t\t} else {\n\t\t\tao2_unlock(iter->c);\n\t\t}\n\t}\n\t\n\titer->complete = 0;\n}\n", "bug_type": null, "idx": 1156}
{"project": "Asterisk", "target": 0, "func": "static int acf_transaction_write(struct ast_channel *chan, const char *cmd, char *s, const char *value)\n{\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(property);\n\t\tAST_APP_ARG(opt);\n\t);\n\tstruct odbc_txn_frame *tx;\n\tAST_STANDARD_APP_ARGS(args, s);\n\tif (strcasecmp(args.property, \"transaction\") == 0) {\n\t\t\n\t\tif ((tx = find_transaction(chan, value, 0))) {\n\t\t\tmark_transaction_active(chan, tx);\n\t\t} else if (!create_transaction(chan, value, args.opt)) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"FAILED_TO_CREATE\");\n\t\t\treturn -1;\n\t\t}\n\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"OK\");\n\t\treturn 0;\n\t} else if (strcasecmp(args.property, \"forcecommit\") == 0) {\n\t\t\n\t\tif (ast_strlen_zero(args.opt)) {\n\t\t\ttx = find_transaction(chan, NULL, 1);\n\t\t} else {\n\t\t\ttx = find_transaction(chan, args.opt, 0);\n\t\t}\n\t\tif (!tx) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"FAILED_TO_CREATE\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (ast_true(value)) {\n\t\t\ttx->forcecommit = 1;\n\t\t} else if (ast_false(value)) {\n\t\t\ttx->forcecommit = 0;\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Invalid value for forcecommit: '%s'\\n\", S_OR(value, \"\"));\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"INVALID_VALUE\");\n\t\t\treturn -1;\n\t\t}\n\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"OK\");\n\t\treturn 0;\n\t} else if (strcasecmp(args.property, \"isolation\") == 0) {\n\t\t\n\t\t\n\t\tint isolation = ast_odbc_text2isolation(value);\n\t\tif (ast_strlen_zero(args.opt)) {\n\t\t\ttx = find_transaction(chan, NULL, 1);\n\t\t} else {\n\t\t\ttx = find_transaction(chan, args.opt, 0);\n\t\t}\n\t\tif (!tx) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"FAILED_TO_CREATE\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (isolation == 0) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"INVALID_VALUE\");\n\t\t\tast_log(LOG_ERROR, \"Invalid isolation specification: '%s'\\n\", S_OR(value, \"\"));\n\t\t} else if (SQLSetConnectAttr(tx->obj->con, SQL_ATTR_TXN_ISOLATION, (void *)(long)isolation, 0) == SQL_ERROR) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"SQL_ERROR\");\n\t\t\tast_odbc_print_errors(SQL_HANDLE_DBC, tx->obj->con, \"SetConnectAttr (Txn isolation)\");\n\t\t} else {\n\t\t\tpbx_builtin_setvar_helper(chan, \"ODBC_RESULT\", \"OK\");\n\t\t\ttx->isolation = isolation;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tast_log(LOG_ERROR, \"Unknown property: '%s'\\n\", args.property);\n\t\treturn -1;\n\t}\n}\n", "bug_type": null, "idx": 1157}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel *ast_channel_iterator_next(struct ast_channel_iterator *i)\n{\n\treturn ao2_iterator_next(i->active_iterator);\n}\n", "bug_type": null, "idx": 1158}
{"project": "Asterisk", "target": 0, "func": "static pj_status_t filter_on_tx_message(pjsip_tx_data *tdata)\n{\n\tstruct filter_message_restrictions *restrictions =\n\t\tast_sip_mod_data_get(tdata->mod_data, filter_module_transport.id, MOD_DATA_RESTRICTIONS);\n\tpjsip_tpmgr_fla2_param prm;\n\tpjsip_cseq_hdr *cseq;\n\tpjsip_via_hdr *via;\n\tpjsip_fromto_hdr *from;\n\tsanitize_tdata(tdata);\n\t\n\tpjsip_tpmgr_fla2_param_default(&prm);\n\tprm.tp_type = tdata->tp_info.transport->key.type;\n\tpj_strset2(&prm.dst_host, tdata->tp_info.dst_name);\n\tprm.local_if = PJ_TRUE;\n\t\n\tif (pjsip_tpmgr_find_local_addr2(pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint()), tdata->pool, &prm) != PJ_SUCCESS) {\n\t\treturn PJ_SUCCESS;\n\t}\n\t\n\tif (tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP ||\n\t\ttdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP6) {\n\t\tprm.ret_port = tdata->tp_info.transport->local_name.port;\n\t}\n\t\n\tif (pj_strcmp(&prm.ret_addr, &tdata->tp_info.transport->local_name.host)) {\n\t\t\n\t\tif (tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP ||\n\t\t\ttdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP6) {\n\t\t\tpjsip_transport *transport;\n\t\t\ttransport = get_udp_transport(&prm.ret_addr, prm.ret_port);\n\t\t\tif (transport) {\n\t\t\t\ttdata->tp_info.transport = transport;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!is_bound_any(tdata->tp_info.transport)) {\n\t\t\tpj_strassign(&prm.ret_addr, &tdata->tp_info.transport->local_name.host);\n\t\t}\n\t} else {\n\t\t\n\t\tpj_strassign(&prm.ret_addr, &tdata->tp_info.transport->local_name.host);\n\t}\n\t\n\tif (tdata->msg->type == PJSIP_REQUEST_MSG || !(cseq = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CSEQ, NULL)) ||\n\t\tpj_strcmp2(&cseq->method.name, \"REGISTER\")) {\n\t\tpjsip_contact_hdr *contact = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CONTACT, NULL);\n\t\tif (contact && (PJSIP_URI_SCHEME_IS_SIP(contact->uri) || PJSIP_URI_SCHEME_IS_SIPS(contact->uri))\n\t\t\t&& !(tdata->msg->type == PJSIP_RESPONSE_MSG && tdata->msg->line.status.code / 100 == 3)) {\n\t\t\tpjsip_sip_uri *uri = pjsip_uri_get_uri(contact->uri);\n\t\t\t\n\t\t\tpj_strassign(&uri->host, &prm.ret_addr);\n\t\t\turi->port = prm.ret_port;\n\t\t\tast_debug(5, \"Re-wrote Contact URI host/port to %.*s:%d (this may be re-written again later)\\n\",\n\t\t\t\t(int)pj_strlen(&uri->host), pj_strbuf(&uri->host), uri->port);\n\t\t\tif (tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP ||\n\t\t\t\ttdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP6) {\n\t\t\t\turi->transport_param.slen = 0;\n\t\t\t} else {\n\t\t\t\tpj_strdup2(tdata->pool, &uri->transport_param, pjsip_transport_get_type_name(tdata->tp_info.transport->key.type));\n\t\t\t}\n\t\t\tpjsip_tx_data_invalidate_msg(tdata);\n\t\t}\n\t}\n\tif (tdata->msg->type == PJSIP_REQUEST_MSG && (via = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_VIA, NULL))) {\n\t\tpj_strassign(&via->sent_by.host, &prm.ret_addr);\n\t\tvia->sent_by.port = prm.ret_port;\n\t\tpjsip_tx_data_invalidate_msg(tdata);\n\t}\n\tif (tdata->msg->type == PJSIP_REQUEST_MSG && (from = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_FROM, NULL)) &&\n\t\t(restrictions && !restrictions->disallow_from_domain_modification)) {\n\t\tpjsip_name_addr *id_name_addr = (pjsip_name_addr *)from->uri;\n\t\tpjsip_sip_uri *uri = pjsip_uri_get_uri(id_name_addr);\n\t\tpj_sockaddr ip;\n\t\tif (pj_strcmp2(&uri->host, \"localhost\") && pj_sockaddr_parse(pj_AF_UNSPEC(), 0, &uri->host, &ip) == PJ_SUCCESS) {\n\t\t\tpj_strassign(&uri->host, &prm.ret_addr);\n\t\t\tpjsip_tx_data_invalidate_msg(tdata);\n\t\t}\n\t}\n\t\n\tif (tdata->msg->body && ast_sip_is_content_type(&tdata->msg->body->content_type, \"application\", \"sdp\") &&\n\t\tmultihomed_rewrite_sdp(tdata->msg->body->data)) {\n\t\tstruct pjmedia_sdp_session *sdp = tdata->msg->body->data;\n\t\tstatic const pj_str_t STR_IP4 = { \"IP4\", 3 };\n\t\tstatic const pj_str_t STR_IP6 = { \"IP6\", 3 };\n\t\tpj_str_t STR_IP;\n\t\tint stream;\n\t\tSTR_IP = tdata->tp_info.transport->key.type & PJSIP_TRANSPORT_IPV6 ? STR_IP6 : STR_IP4;\n\t\tpj_strassign(&sdp->origin.addr, &prm.ret_addr);\n\t\tsdp->origin.addr_type = STR_IP;\n\t\tpj_strassign(&sdp->conn->addr, &prm.ret_addr);\n\t\tsdp->conn->addr_type = STR_IP;\n\t\tfor (stream = 0; stream < sdp->media_count; ++stream) {\n\t\t\tif (sdp->media[stream]->conn) {\n\t\t\t\tpj_strassign(&sdp->media[stream]->conn->addr, &prm.ret_addr);\n\t\t\t\tsdp->media[stream]->conn->addr_type = STR_IP;\n\t\t\t}\n\t\t}\n\t\tpjsip_tx_data_invalidate_msg(tdata);\n\t}\n\treturn PJ_SUCCESS;\n}\n", "bug_type": null, "idx": 1159}
{"project": "Asterisk", "target": 0, "func": "void\nrl_reset_terminal(const char *p)\n{\n\tif (h == NULL || e == NULL)\n\t\trl_initialize();\n\tel_reset(e);\n}\n", "bug_type": null, "idx": 1160}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225CircuitInfo (OOCTXT* pctxt, H225CircuitInfo* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.sourceCircuitIDPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.destinationCircuitIDPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.genericDataPresent);\n   \n   if (pvalue->m.sourceCircuitIDPresent) {\n      stat = asn1PE_H225CircuitIdentifier (pctxt, &pvalue->sourceCircuitID);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.destinationCircuitIDPresent) {\n      stat = asn1PE_H225CircuitIdentifier (pctxt, &pvalue->destinationCircuitID);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.genericDataPresent) {\n      stat = asn1PE_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1161}
{"project": "Asterisk", "target": 0, "func": "\nstatic int chan_pjsip_transfer(struct ast_channel *chan, const char *target)\n{\n\tstruct ast_sip_channel_pvt *channel = ast_channel_tech_pvt(chan);\n\tstruct transfer_data *trnf_data = transfer_data_alloc(channel->session, target);\n\tif (!trnf_data) {\n\t\treturn -1;\n\t}\n#ifdef HAVE_PJSIP_INV_SESSION_REF\n\tif (pjsip_inv_add_ref(trnf_data->session->inv_session) != PJ_SUCCESS) {\n\t\tast_log(LOG_ERROR, \"Can't increase the session reference counter\\n\");\n\t\tao2_cleanup(trnf_data);\n\t\treturn -1;\n\t}\n#endif\n\tif (ast_sip_push_task(channel->session->serializer, transfer, trnf_data)) {\n\t\tast_log(LOG_WARNING, \"Error requesting transfer\\n\");\n#ifdef HAVE_PJSIP_INV_SESSION_REF\n\t\tpjsip_inv_dec_ref(trnf_data->session->inv_session);\n#endif\n\t\tao2_cleanup(trnf_data);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1162}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void set_pvt_defaults(struct console_pvt *pvt)\n{\n\tif (pvt == &globals) {\n\t\tast_string_field_set(pvt, mohinterpret, \"default\");\n\t\tast_string_field_set(pvt, context, \"default\");\n\t\tast_string_field_set(pvt, exten, \"s\");\n\t\tast_string_field_set(pvt, language, \"\");\n\t\tast_string_field_set(pvt, cid_num, \"\");\n\t\tast_string_field_set(pvt, cid_name, \"\");\n\t\tast_string_field_set(pvt, parkinglot, \"\");\n\t\tpvt->overridecontext = 0;\n\t\tpvt->autoanswer = 0;\n\t} else {\n\t\tast_mutex_lock(&globals_lock);\n\t\tast_string_field_set(pvt, mohinterpret, globals.mohinterpret);\n\t\tast_string_field_set(pvt, context, globals.context);\n\t\tast_string_field_set(pvt, exten, globals.exten);\n\t\tast_string_field_set(pvt, language, globals.language);\n\t\tast_string_field_set(pvt, cid_num, globals.cid_num);\n\t\tast_string_field_set(pvt, cid_name, globals.cid_name);\n\t\tast_string_field_set(pvt, parkinglot, globals.parkinglot);\n\t\tpvt->overridecontext = globals.overridecontext;\n\t\tpvt->autoanswer = globals.autoanswer;\n\t\tast_mutex_unlock(&globals_lock);\n\t}\n}\n", "bug_type": null, "idx": 1163}
{"project": "Asterisk", "target": 0, "func": "   -----------------------------------------------------------------------*/\nint parsefreq(char *string, double *result)\n{\n    int k;\n    double temp;\n    char m, s, end;\n    k = sscanf(string, \"%30lf%1c%1c%1c\", &temp, &m, &s, &end);\n    switch (k)\n      {\n      case 0: case EOF: case 2: case 4:\n\treturn FALSE;\n      case 1:\n\t*result = temp;\n\tbreak;\n      case 3:\n\tif (m == 'H' && s == 'z')\n\t  *result = samplefrequency / temp;\n\telse\n\t  return FALSE;\n\tbreak;\n      default:\n\targerrornum(NULL, ME_THISCANTHAPPEN);\n      }\n    return TRUE;\n}\n", "bug_type": null, "idx": 1164}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(object_filter)\n{\n\tRAII_VAR(struct ast_sorcery *, sorcery, NULL, deinitialize_sorcery);\n\tRAII_VAR(struct test_sorcery_object *, obj, NULL, ao2_cleanup);\n\tstruct ast_category *cat;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"object_filter\";\n\t\tinfo->category = \"/res/sorcery_realtime/\";\n\t\tinfo->summary = \"sorcery object field filter unit test\";\n\t\tinfo->description =\n\t\t\t\"This test creates data in a realtime backend, not through sorcery. In addition to\\n\"\n\t\t\t\"the object fields that have been registered with sorcery, there is data in the\\n\"\n\t\t\t\"realtime backend that is unknown to sorcery. When sorcery attempts to retrieve\\n\"\n\t\t\t\"the object from the realtime backend, the data unknown to sorcery should be\\n\"\n\t\t\t\"filtered out of the returned objectset, and the object should be successfully\\n\"\n\t\t\t\"allocated by sorcery\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tif (!(sorcery = alloc_and_initialize_sorcery(\"sorcery_realtime_test\"))) {\n\t\tast_test_status_update(test, \"Failed to open sorcery structure\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tcat = ast_category_new(\"blah\", \"\", 0);\n\tast_variable_append(cat, ast_variable_new(\"id\", \"blah\", \"\"));\n\tast_variable_append(cat, ast_variable_new(\"bob\", \"42\", \"\"));\n\tast_variable_append(cat, ast_variable_new(\"joe\", \"93\", \"\"));\n\tast_variable_append(cat, ast_variable_new(\"fred\", \"50\", \"\"));\n\tast_category_append(realtime_objects, cat);\n\tif (!(obj = ast_sorcery_retrieve_by_id(sorcery, \"test\", \"blah\"))) {\n\t\tast_test_status_update(test, \"Failed to retrieve properly created object using id of 'blah'\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tif (obj->bob != 42) {\n\t\tast_test_status_update(test, \"Object's 'bob' field does not have expected value: %u != 42\\n\",\n\t\t\t\tobj->bob);\n\t\treturn AST_TEST_FAIL;\n\t} else if (obj->joe != 93) {\n\t\tast_test_status_update(test, \"Object's 'joe' field does not have expected value: %u != 93\\n\",\n\t\t\t\tobj->joe);\n\t\treturn AST_TEST_FAIL;\n\t}\n\treturn AST_TEST_PASS;\n}\n", "bug_type": null, "idx": 1165}
{"project": "Asterisk", "target": 0, "func": "static int find_language(const char* lang)\n{\n\tint i = 0;\n\twhile (options_languages[i].lang_short != NULL) {\n\t\tif(!strcmp(options_languages[i].lang_short, lang)) {\n\t\t\treturn i;\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1166}
{"project": "Asterisk", "target": 0, "func": "int ast_prod(struct ast_channel *chan)\n{\n\tstruct ast_frame a = { AST_FRAME_VOICE };\n\tchar nothing[128];\n\t\n\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\tast_debug(1, \"Prodding channel '%s'\\n\", ast_channel_name(chan));\n\t\ta.subclass.format = ast_channel_rawwriteformat(chan);\n\t\ta.data.ptr = nothing + AST_FRIENDLY_OFFSET;\n\t\ta.src = \"ast_prod\"; \n\t\tif (ast_write(chan, &a))\n\t\t\tast_log(LOG_WARNING, \"Prodding channel '%s' failed\\n\", ast_channel_name(chan));\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1167}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic int ast_say_number_full_hu(struct ast_channel *chan, int num, const char *ints, const char *language, int audiofd, int ctrlfd)\n{\n\tint res = 0;\n\tint playh = 0;\n\tchar fn[256] = \"\";\n\tif (!num)\n\t\treturn ast_say_digits_full(chan, 0, ints, language, audiofd, ctrlfd);\n\t\n\twhile(!res && (num || playh)) {\n\t\tif (num < 0) {\n\t\t\tast_copy_string(fn, \"digits/minus\", sizeof(fn));\n\t\t\tif ( num > INT_MIN ) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t} else if (playh) {\n\t\t\tast_copy_string(fn, \"digits/hundred\", sizeof(fn));\n\t\t\tplayh = 0;\n\t\t} else if (num < 11 || num == 20) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num);\n\t\t\tnum = 0;\n\t\t} else if (num < 20) {\n\t\t\tast_copy_string(fn, \"digits/10en\", sizeof(fn));\n\t\t\tnum -= 10;\n\t\t} else if (num < 30) {\n\t\t\tast_copy_string(fn, \"digits/20on\", sizeof(fn));\n\t\t\tnum -= 20;\n\t\t} else\tif (num < 100) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", (num /10) * 10);\n\t\t\tnum %= 10;\n\t\t} else {\n\t\t\tif (num < 1000){\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", (num/100));\n\t\t\t\tplayh++;\n\t\t\t\tnum %= 100;\n\t\t\t} else {\n\t\t\t\tif (num < 1000000) { \n\t\t\t\t\tres = ast_say_number_full_hu(chan, num / 1000, ints, language, audiofd, ctrlfd);\n\t\t\t\t\tif (res)\n\t\t\t\t\t\treturn res;\n\t\t\t\t\tnum %= 1000;\n\t\t\t\t\tast_copy_string(fn, \"digits/thousand\", sizeof(fn));\n\t\t\t\t} else {\n\t\t\t\t\tif (num < 1000000000) {\t\n\t\t\t\t\t\tres = ast_say_number_full_hu(chan, num / 1000000, ints, language, audiofd, ctrlfd);\n\t\t\t\t\t\tif (res)\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\tnum %= 1000000;\n\t\t\t\t\t\tast_copy_string(fn, \"digits/million\", sizeof(fn));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_debug(1, \"Number '%d' is too big for me\\n\", num);\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!res) {\n\t\t\tif(!ast_streamfile(chan, fn, language)) {\n\t\t\t\tif ((audiofd  > -1) && (ctrlfd > -1))\n\t\t\t\t\tres = ast_waitstream_full(chan, ints, audiofd, ctrlfd);\n\t\t\t\telse\n\t\t\t\t\tres = ast_waitstream(chan, ints);\n\t\t\t}\n\t\t\tast_stopstream(chan);\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1168}
{"project": "Asterisk", "target": 0, "func": "void ast_json_unref(struct ast_json *json)\n{\n\tstruct json_mem_list *free_list;\n\tstruct json_mem *mem;\n\tif (!json) {\n\t\treturn;\n\t}\n\t\n\t{\n\t\tSCOPED_JSON_LOCK(json);\n\t\tjson_decref((json_t *) json);\n\t}\n\t\n\tfree_list = json_free_list();\n\tif (!free_list) {\n\t\treturn;\n\t}\n\twhile ((mem = AST_LIST_REMOVE_HEAD(free_list, list))) {\n\t\tjson_mem_free(mem);\n\t}\n}\n", "bug_type": null, "idx": 1169}
{"project": "Asterisk", "target": 0, "func": " */\nint sip_parse_register_line(struct sip_registry *reg, int default_expiry, const char *value, int lineno)\n{\n\tint portnum = 0;\n\tint domainport = 0;\n\tenum ast_transport transport = AST_TRANSPORT_UDP;\n\tchar buf[256] = \"\";\n\tchar *userpart = NULL, *hostpart = NULL;\n\t\n\tAST_DECLARE_APP_ARGS(pre1,\n\t\tAST_APP_ARG(peer);\n\t\tAST_APP_ARG(userpart);\n\t);\n\tAST_DECLARE_APP_ARGS(pre2,\n\t\tAST_APP_ARG(transport);\n\t\tAST_APP_ARG(blank);\n\t\tAST_APP_ARG(userpart);\n\t);\n\tAST_DECLARE_APP_ARGS(user1,\n\t\tAST_APP_ARG(userpart);\n\t\tAST_APP_ARG(secret);\n\t\tAST_APP_ARG(authuser);\n\t);\n\tAST_DECLARE_APP_ARGS(user2,\n\t\tAST_APP_ARG(user);\n\t\tAST_APP_ARG(domain);\n\t);\n\tAST_DECLARE_APP_ARGS(user3,\n\t\tAST_APP_ARG(authuser);\n\t\tAST_APP_ARG(domainport);\n\t);\n\tAST_DECLARE_APP_ARGS(host1,\n\t\tAST_APP_ARG(hostpart);\n\t\tAST_APP_ARG(expiry);\n\t);\n\tAST_DECLARE_APP_ARGS(host2,\n\t\tAST_APP_ARG(hostpart);\n\t\tAST_APP_ARG(extension);\n\t);\n\tAST_DECLARE_APP_ARGS(host3,\n\t\tAST_APP_ARG(host);\n\t\tAST_APP_ARG(port);\n\t);\n\tif (!reg) {\n\t\treturn -1;\n\t}\n\treg->expire = -1;\n\treg->timeout = -1;\n\tif (!value) {\n\t\treturn -1;\n\t}\n\tast_copy_string(buf, value, sizeof(buf));\n\t\n\tif ((hostpart = strrchr(buf, '@'))) {\n\t\t*hostpart++ = '\\0';\n\t\tuserpart = buf;\n\t}\n\tif (ast_strlen_zero(userpart) || ast_strlen_zero(hostpart)) {\n\t\tast_log(LOG_WARNING, \"Format for registration is [peer?][transport://]user[@domain][:secret[:authuser]]@host[:port][/extension][~expiry] at line %d\\n\", lineno);\n\t\treturn -1;\n\t}\n\t\n\tAST_NONSTANDARD_RAW_ARGS(pre1, userpart, '?');\n\tif (ast_strlen_zero(pre1.userpart)) {\n\t\tpre1.userpart = pre1.peer;\n\t\tpre1.peer = NULL;\n\t}\n\t\n\tAST_NONSTANDARD_RAW_ARGS(pre2, pre1.userpart, '/');\n\tif (ast_strlen_zero(pre2.userpart)) {\n\t\tpre2.userpart = pre2.transport;\n\t\tpre2.transport = NULL;\n\t} else {\n\t\tpre2.transport[strlen(pre2.transport) - 1] = '\\0'; \n\t}\n\tif (!ast_strlen_zero(pre2.blank)) {\n\t\tast_log(LOG_WARNING, \"Format for registration is [peer?][transport://]user[@domain][:secret[:authuser]]@host[:port][/extension][~expiry] at line %d\\n\", lineno);\n\t\treturn -1;\n\t}\n\t\n\tAST_NONSTANDARD_RAW_ARGS(user1, pre2.userpart, ':');\n\t\n\tAST_NONSTANDARD_RAW_ARGS(host1, hostpart, '~');\n\t\n\tAST_NONSTANDARD_RAW_ARGS(host2, host1.hostpart, '/');\n\t\n\tAST_NONSTANDARD_RAW_ARGS(host3, host2.hostpart, ':');\n\t\n\tAST_NONSTANDARD_RAW_ARGS(user2, user1.userpart, '@');\n\t\n\tAST_NONSTANDARD_RAW_ARGS(user3, user1.authuser, ':');\n\t\n\tif (user3.argc == 2) {\n\t\tchar *reorder = user3.domainport;\n\t\tuser3.domainport = user1.secret;\n\t\tuser1.secret = user3.authuser;\n\t\tuser3.authuser = reorder;\n\t}\n\tif (host3.port) {\n\t\tif (!(portnum = port_str2int(host3.port, 0))) {\n\t\t\tast_log(LOG_NOTICE, \"'%s' is not a valid port number on line %d of sip.conf. using default.\\n\", host3.port, lineno);\n\t\t}\n\t}\n\tif (user3.domainport) {\n\t\tif (!(domainport = port_str2int(user3.domainport, 0))) {\n\t\t\tast_log(LOG_NOTICE, \"'%s' is not a valid domain port number on line %d of sip.conf. using default.\\n\", user3.domainport, lineno);\n\t\t}\n\t}\n\t\n\tif (!pre2.transport) {\n\t\ttransport = AST_TRANSPORT_UDP;\n\t} else if (!strncasecmp(pre2.transport, \"tcp\", 3)) {\n\t\ttransport = AST_TRANSPORT_TCP;\n\t} else if (!strncasecmp(pre2.transport, \"tls\", 3)) {\n\t\ttransport = AST_TRANSPORT_TLS;\n\t} else if (!strncasecmp(pre2.transport, \"udp\", 3)) {\n\t\ttransport = AST_TRANSPORT_UDP;\n\t} else {\n\t\ttransport = AST_TRANSPORT_UDP;\n\t\tast_log(LOG_NOTICE, \"'%.3s' is not a valid transport type on line %d of sip.conf. defaulting to udp.\\n\", pre2.transport, lineno);\n\t}\n\t\n\tif (!portnum) {\n\t\tif (transport == AST_TRANSPORT_TLS) {\n\t\t\tportnum = STANDARD_TLS_PORT;\n\t\t} else {\n\t\t\tportnum = STANDARD_SIP_PORT;\n\t\t}\n\t}\n\t\n\tast_string_field_set(reg, callback, ast_strip_quoted(S_OR(host2.extension, \"s\"), \"\\\"\", \"\\\"\"));\n\tast_string_field_set(reg, username, ast_strip_quoted(S_OR(user2.user, \"\"), \"\\\"\", \"\\\"\"));\n\tast_string_field_set(reg, hostname, ast_strip_quoted(S_OR(host3.host, \"\"), \"\\\"\", \"\\\"\"));\n\tast_string_field_set(reg, authuser, ast_strip_quoted(S_OR(user3.authuser, \"\"), \"\\\"\", \"\\\"\"));\n\tast_string_field_set(reg, secret, ast_strip_quoted(S_OR(user1.secret, \"\"), \"\\\"\", \"\\\"\"));\n\tast_string_field_set(reg, peername, ast_strip_quoted(S_OR(pre1.peer, \"\"), \"\\\"\", \"\\\"\"));\n\tast_string_field_set(reg, regdomain, ast_strip_quoted(S_OR(user2.domain, \"\"), \"\\\"\", \"\\\"\"));\n\treg->transport = transport;\n\treg->portno = portnum;\n\treg->regdomainport = domainport;\n\treg->callid_valid = FALSE;\n\treg->ocseq = INITIAL_CSEQ;\n\treg->refresh = reg->expiry = reg->configured_expiry = (host1.expiry ? atoi(ast_strip_quoted(host1.expiry, \"\\\"\", \"\\\"\")) : default_expiry);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1170}
{"project": "Asterisk", "target": 0, "func": "static void transition_to_single_marked(struct confbridge_user *user)\n{\n\tconf_mute_only_active(user->conference);\n}\n", "bug_type": null, "idx": 1171}
{"project": "Asterisk", "target": 0, "func": "\nstatic void copy_rules(struct queue_ent *qe, const char *rulename)\n{\n\tstruct penalty_rule *pr_iter;\n\tstruct rule_list *rl_iter;\n\tconst char *tmp = ast_strlen_zero(rulename) ? qe->parent->defaultrule : rulename;\n\tAST_LIST_LOCK(&rule_lists);\n\tAST_LIST_TRAVERSE(&rule_lists, rl_iter, list) {\n\t\tif (!strcasecmp(rl_iter->name, tmp)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rl_iter) {\n\t\tAST_LIST_TRAVERSE(&rl_iter->rules, pr_iter, list) {\n\t\t\tstruct penalty_rule *new_pr = ast_calloc(1, sizeof(*new_pr));\n\t\t\tif (!new_pr) {\n\t\t\t\tast_log(LOG_ERROR, \"Memory allocation error when copying penalty rules! Aborting!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnew_pr->time = pr_iter->time;\n\t\t\tnew_pr->max_value = pr_iter->max_value;\n\t\t\tnew_pr->min_value = pr_iter->min_value;\n\t\t\tnew_pr->raise_value = pr_iter->raise_value;\n\t\t\tnew_pr->max_relative = pr_iter->max_relative;\n\t\t\tnew_pr->min_relative = pr_iter->min_relative;\n\t\t\tnew_pr->raise_relative = pr_iter->raise_relative;\n\t\t\tAST_LIST_INSERT_TAIL(&qe->qe_rules, new_pr, list);\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(&rule_lists);\n}\n", "bug_type": null, "idx": 1172}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int _extension_match_core(const char *pattern, const char *data, enum ext_match_t mode)\n{\n\tmode &= E_MATCH_MASK;\t\n#ifdef NEED_DEBUG_HERE\n\tast_log(LOG_NOTICE,\"match core: pat: '%s', dat: '%s', mode=%d\\n\", pattern, data, (int)mode);\n#endif\n\tif (pattern[0] != '_') { \n\t\tint lp = ext_cmp_exten_strlen(pattern);\n\t\tint ld = ext_cmp_exten_strlen(data);\n\t\tif (lp < ld) {\t\t\n#ifdef NEED_DEBUG_HERE\n\t\t\tast_log(LOG_NOTICE,\"return (0) - pattern too short, cannot match\\n\");\n#endif\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (mode == E_MATCH) {\n#ifdef NEED_DEBUG_HERE\n\t\t\tast_log(LOG_NOTICE,\"return (!ext_cmp_exten(%s,%s) when mode== E_MATCH)\\n\", pattern, data);\n#endif\n\t\t\treturn !ext_cmp_exten(pattern, data); \n\t\t}\n\t\tif (ld == 0 || !ext_cmp_exten_partial(pattern, data)) { \n#ifdef NEED_DEBUG_HERE\n\t\t\tast_log(LOG_NOTICE,\"return (mode(%d) == E_MATCHMORE ? lp(%d) > ld(%d) : 1)\\n\", mode, lp, ld);\n#endif\n\t\t\treturn (mode == E_MATCHMORE) ? lp > ld : 1; \n\t\t} else {\n#ifdef NEED_DEBUG_HERE\n\t\t\tast_log(LOG_NOTICE,\"return (0) when ld(%d) > 0 && pattern(%s) != data(%s)\\n\", ld, pattern, data);\n#endif\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (mode == E_MATCH && data[0] == '_') {\n\t\t\n#ifdef NEED_DEBUG_HERE\n\t\tast_log(LOG_NOTICE, \"Comparing as patterns first. pattern:%s data:%s\\n\", pattern, data);\n#endif\n\t\tif (!ext_cmp_pattern(pattern + 1, data + 1)) {\n#ifdef NEED_DEBUG_HERE\n\t\t\tast_log(LOG_NOTICE,\"return (1) - pattern matches pattern\\n\");\n#endif\n\t\t\treturn 1;\n\t\t}\n\t}\n\t++pattern; \n\t\n\tfor (;;) {\n\t\tconst char *end;\n\t\t\n\t\twhile (*data == '-') {\n\t\t\t++data;\n\t\t}\n\t\twhile (*pattern == '-') {\n\t\t\t++pattern;\n\t\t}\n\t\tif (!*data || !*pattern || *pattern == '/') {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (*pattern) {\n\t\tcase '[':\t\n\t\t\t++pattern;\n\t\t\tend = strchr(pattern, ']'); \n\t\t\tif (!end) {\n\t\t\t\tast_log(LOG_WARNING, \"Wrong usage of [] in the extension\\n\");\n\t\t\t\treturn 0;\t\n\t\t\t}\n\t\t\tif (pattern == end) {\n\t\t\t\t\n\t\t\t\t++pattern;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (; pattern < end; ++pattern) {\n\t\t\t\tif (pattern+2 < end && pattern[1] == '-') { \n\t\t\t\t\tif (*data >= pattern[0] && *data <= pattern[2])\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tpattern += 2; \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (*data == pattern[0])\n\t\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tif (pattern >= end) {\n#ifdef NEED_DEBUG_HERE\n\t\t\t\tast_log(LOG_NOTICE,\"return (0) when pattern>=end\\n\");\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpattern = end;\t\n\t\t\tbreak;\n\t\tcase 'n':\n\t\tcase 'N':\n\t\t\tif (*data < '2' || *data > '9') {\n#ifdef NEED_DEBUG_HERE\n\t\t\t\tast_log(LOG_NOTICE,\"return (0) N is not matched\\n\");\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tif (*data < '0' || *data > '9') {\n#ifdef NEED_DEBUG_HERE\n\t\t\t\tast_log(LOG_NOTICE,\"return (0) X is not matched\\n\");\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'z':\n\t\tcase 'Z':\n\t\t\tif (*data < '1' || *data > '9') {\n#ifdef NEED_DEBUG_HERE\n\t\t\t\tast_log(LOG_NOTICE,\"return (0) Z is not matched\\n\");\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.':\t\n#ifdef NEED_DEBUG_HERE\n\t\t\tast_log(LOG_NOTICE, \"return (1) when '.' is matched\\n\");\n#endif\n\t\t\treturn 1;\n\t\tcase '!':\t\n#ifdef NEED_DEBUG_HERE\n\t\t\tast_log(LOG_NOTICE, \"return (2) when '!' is matched\\n\");\n#endif\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\tif (*data != *pattern) {\n#ifdef NEED_DEBUG_HERE\n\t\t\t\tast_log(LOG_NOTICE, \"return (0) when *data(%c) != *pattern(%c)\\n\", *data, *pattern);\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t++data;\n\t\t++pattern;\n\t}\n\tif (*data)\t\t\t {\n#ifdef NEED_DEBUG_HERE\n\t\tast_log(LOG_NOTICE, \"return (0) when data longer than pattern\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (*pattern == '\\0' || *pattern == '/') {\t\n#ifdef NEED_DEBUG_HERE\n\t\tast_log(LOG_NOTICE, \"at end, return (%d) in 'exact match'\\n\", (mode==E_MATCHMORE) ? 0 : 1);\n#endif\n\t\treturn (mode == E_MATCHMORE) ? 0 : 1;\t\n\t} else if (*pattern == '!')\t{\t\t\n#ifdef NEED_DEBUG_HERE\n\t\tast_log(LOG_NOTICE, \"at end, return (2) when '!' is matched\\n\");\n#endif\n\t\treturn 2;\n\t} else {\t\t\t\t\t\t\n#ifdef NEED_DEBUG_HERE\n\t\tast_log(LOG_NOTICE, \"at end, return (%d) which deps on E_MATCH\\n\", (mode == E_MATCH) ? 0 : 1);\n#endif\n\t\treturn (mode == E_MATCH) ? 0 : 1;\t\n\t}\n}\n", "bug_type": null, "idx": 1173}
{"project": "Asterisk", "target": 0, "func": "void printCharStr32BitValue (ASN1UINT nchars, ASN132BITCHAR* data)\n{\n   ASN1UINT ui;\n   indent ();\n   for ( ui = 0; ui < nchars; ui++) {\n      if (data[ui] >= 32 && data[ui] <= 127)\n         OOTRACEDBGB2 (\"%c\", (char)data[ui]);\n      else\n         OOTRACEDBGB2 (\"\\\\%d\", data[ui]);\n   }\n   OOTRACEDBGB1 (\"\\n\");\n}\n", "bug_type": null, "idx": 1174}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225GSM_UIM_tmsi (OOCTXT* pctxt, H225GSM_UIM_tmsi* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 4, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeOctetString (pctxt,\n                          &pvalue->numocts,\n                          pvalue->data,\n                          sizeof(pvalue->data));\n   if (stat != ASN_OK) return stat;\n   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);\n   return (stat);\n}\n", "bug_type": null, "idx": 1175}
{"project": "Asterisk", "target": 0, "func": "static int bridge_hash_cb(const void *obj, const int flags)\n{\n\tconst struct bridge_profile *b_profile = obj;\n\tconst char *name = obj;\n\tint hash;\n\tswitch (flags & (OBJ_POINTER | OBJ_KEY | OBJ_PARTIAL_KEY)) {\n\tdefault:\n\tcase OBJ_POINTER:\n\t\tname = b_profile->name;\n\t\t\n\tcase OBJ_KEY:\n\t\thash = ast_str_case_hash(name);\n\t\tbreak;\n\tcase OBJ_PARTIAL_KEY:\n\t\t\n\t\tast_assert(0);\n\t\thash = 0;\n\t\tbreak;\n\t}\n\treturn hash;\n}\n", "bug_type": null, "idx": 1176}
{"project": "Asterisk", "target": 0, "func": "static const char *noop_get_id(struct stasis_message *message)\n{\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1177}
{"project": "Asterisk", "target": 0, "func": "\nstatic int xmpp_resource_hash(const void *obj, const int flags)\n{\n\tconst struct ast_xmpp_resource *resource = obj;\n\treturn flags & OBJ_KEY ? -1 : resource->priority;\n}\n", "bug_type": null, "idx": 1178}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_technology_unregister(struct ast_bridge_technology *technology)\n{\n\tstruct ast_bridge_technology *current;\n\tAST_RWLIST_WRLOCK(&bridge_technologies);\n\t\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&bridge_technologies, current, entry) {\n\t\tif (current == technology) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(entry);\n\t\t\tast_verb(2, \"Unregistered bridge technology %s\\n\", technology->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&bridge_technologies);\n\treturn current ? 0 : -1;\n}\n", "bug_type": null, "idx": 1179}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void audiohook_volume_destroy(void *data)\n{\n\tstruct audiohook_volume *audiohook_volume = data;\n\t\n\tast_audiohook_destroy(&audiohook_volume->audiohook);\n\t\n\tast_free(audiohook_volume);\n\treturn;\n}\n", "bug_type": null, "idx": 1180}
{"project": "Asterisk", "target": 0, "func": "int ooCallClearAliases(OOH323CallData *call)\n{\n   if(call->ourAliases)\n      memFreePtr(call->pctxt, call->ourAliases);\n   call->ourAliases = NULL;\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1181}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_unregister_application(app);\n}\n", "bug_type": null, "idx": 1182}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int run_app_helper(struct ast_channel *chan, const char *app_name, const char *app_args)\n{\n\tint res = 0;\n\tif (!strcasecmp(\"Gosub\", app_name)) {\n\t\tast_app_exec_sub(NULL, chan, app_args, 0);\n\t} else if (!strcasecmp(\"Macro\", app_name)) {\n\t\tast_app_exec_macro(NULL, chan, app_args);\n\t} else {\n\t\tstruct ast_app *app;\n\t\tapp = pbx_findapp(app_name);\n\t\tif (!app) {\n\t\t\tast_log(LOG_WARNING, \"Could not find application (%s)\\n\", app_name);\n\t\t} else {\n\t\t\tstruct ast_str *substituted_args = ast_str_create(16);\n\t\t\tif (substituted_args) {\n\t\t\t\tast_str_substitute_variables(&substituted_args, 0, chan, app_args);\n\t\t\t\tres = pbx_exec(chan, app, ast_str_buffer(substituted_args));\n\t\t\t\tast_free(substituted_args);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Could not substitute application argument variables for %s\\n\", app_name);\n\t\t\t\tres = pbx_exec(chan, app, app_args);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1183}
{"project": "Asterisk", "target": 0, "func": "\nstatic void mark_as_present(const char *member, const char *category)\n{\n\tstruct category *cat;\n\tstruct member *mem;\n\tchar negate = 0;\n\tif (*member == '-') {\n\t\tmember++;\n\t\tnegate = 1;\n\t}\n\tprint_debug(\"Marking %s of %s as present\\n\", member, category);\n\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\tif (strcmp(category, cat->name))\n\t\t\tcontinue;\n\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n\t\t\tif (mem->is_separator) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(member, mem->name)) {\n\t\t\t\tmem->was_enabled = mem->enabled = (negate ? !cat->positive_output : cat->positive_output);\n\t\t\t\tprint_debug(\"Just set %s enabled to %d\\n\", mem->name, mem->enabled);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!mem)\n\t\t\tfprintf(stderr, \"member '%s' in category '%s' not found, ignoring.\\n\", member, category);\n\t\tbreak;\n\t}\n\tif (!cat)\n\t\tfprintf(stderr, \"category '%s' not found! Can't mark '%s' as disabled.\\n\", category, member);\n}\n", "bug_type": null, "idx": 1184}
{"project": "Asterisk", "target": 0, "func": "static int odbc_log(struct ast_cdr *cdr)\n{\n\tstruct odbc_obj *obj = ast_odbc_request_obj(dsn, 0);\n\tSQLHSTMT stmt;\n\tif (!obj) {\n\t\tast_log(LOG_ERROR, \"Unable to retrieve database handle.  CDR failed.\\n\");\n\t\treturn -1;\n\t}\n\tstmt = ast_odbc_direct_execute(obj, execute_cb, cdr);\n\tif (stmt) {\n\t\tSQLLEN rows = 0;\n\t\tSQLRowCount(stmt, &rows);\n\t\tSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n\t\tif (rows == 0)\n\t\t\tast_log(LOG_WARNING, \"CDR successfully ran, but inserted 0 rows?\\n\");\n\t} else\n\t\tast_log(LOG_ERROR, \"CDR direct execute failed\\n\");\n\tast_odbc_release_obj(obj);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1185}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int filehelper(const char *filename, const void *arg2, const char *fmt, const enum file_action action)\n{\n\tstruct ast_format_def *f;\n\tint res = (action == ACTION_EXISTS) ? 0 : -1;\n\tAST_RWLIST_RDLOCK(&formats);\n\t\n\tAST_RWLIST_TRAVERSE(&formats, f, list) {\n\t\tchar *stringp, *ext = NULL;\n\t\tif (fmt && !exts_compare(f->exts, fmt))\n\t\t\tcontinue;\n\t\t\n\t\tstringp = ast_strdupa(f->exts);\t\n\t\twhile ( (ext = strsep(&stringp, \"|\")) ) {\n\t\t\tstruct stat st;\n\t\t\tchar *fn = build_filename(filename, ext);\n\t\t\tif (fn == NULL)\n\t\t\t\tcontinue;\n\t\t\tif ( stat(fn, &st) ) { \n\t\t\t\tast_free(fn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (action == ACTION_OPEN) {\n\t\t\t\tstruct ast_channel *chan = (struct ast_channel *)arg2;\n\t\t\t\tFILE *bfile;\n\t\t\t\tstruct ast_filestream *s;\n\t\t\t\tif ((ast_format_cmp(ast_channel_writeformat(chan), f->format) == AST_FORMAT_CMP_NOT_EQUAL) &&\n\t\t\t\t     !(((ast_format_get_type(f->format) == AST_MEDIA_TYPE_AUDIO) && fmt) ||\n\t\t\t\t\t  ((ast_format_get_type(f->format) == AST_MEDIA_TYPE_VIDEO) && fmt))) {\n\t\t\t\t\tast_free(fn);\n\t\t\t\t\tcontinue;\t\n\t\t\t\t}\n\t\t\t\tif ( (bfile = fopen(fn, \"r\")) == NULL) {\n\t\t\t\t\tast_free(fn);\n\t\t\t\t\tcontinue;\t\n\t\t\t\t}\n\t\t\t\ts = get_filestream(f, bfile);\n\t\t\t\tif (!s) {\n\t\t\t\t\tfclose(bfile);\n\t\t\t\t\tast_free(fn);\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (open_wrapper(s)) {\n\t\t\t\t\tast_free(fn);\n\t\t\t\t\tast_closestream(s);\n\t\t\t\t\tcontinue;\t\n\t\t\t\t}\n\t\t\t\tif (st.st_size == 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"File %s detected to have zero size.\\n\", fn);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tres = 1;\t\n\t\t\t\ts->lasttimeout = -1;\n\t\t\t\ts->fmt = f;\n\t\t\t\ts->trans = NULL;\n\t\t\t\ts->filename = NULL;\n\t\t\t\tif (ast_format_get_type(s->fmt->format) == AST_MEDIA_TYPE_AUDIO) {\n\t\t\t\t\tif (ast_channel_stream(chan))\n\t\t\t\t\t\tast_closestream(ast_channel_stream(chan));\n\t\t\t\t\tast_channel_stream_set(chan, s);\n\t\t\t\t} else {\n\t\t\t\t\tif (ast_channel_vstream(chan))\n\t\t\t\t\t\tast_closestream(ast_channel_vstream(chan));\n\t\t\t\t\tast_channel_vstream_set(chan, s);\n\t\t\t\t}\n\t\t\t\tast_free(fn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (action) {\n\t\t\tcase ACTION_OPEN:\n\t\t\t\tbreak;\t\n\t\t\tcase ACTION_EXISTS:\t\n\t\t\t\t\n\t\t\t\tif (arg2) {\n\t\t\t\t\tast_format_cap_append((struct ast_format_cap *) arg2, f->format, 0);\n\t\t\t\t}\n\t\t\t\tres = 1; \n\t\t\t\tbreak;\n\t\t\tcase ACTION_DELETE:\n\t\t\t\tif ( (res = unlink(fn)) )\n\t\t\t\t\tast_log(LOG_WARNING, \"unlink(%s) failed: %s\\n\", fn, strerror(errno));\n\t\t\t\tbreak;\n\t\t\tcase ACTION_RENAME:\n\t\t\tcase ACTION_COPY: {\n\t\t\t\tchar *nfn = build_filename((const char *)arg2, ext);\n\t\t\t\tif (!nfn)\n\t\t\t\t\tast_log(LOG_WARNING, \"Out of memory\\n\");\n\t\t\t\telse {\n\t\t\t\t\tres = action == ACTION_COPY ? copy(fn, nfn) : rename(fn, nfn);\n\t\t\t\t\tif (res)\n\t\t\t\t\t\tast_log(LOG_WARNING, \"%s(%s,%s) failed: %s\\n\",\n\t\t\t\t\t\t\taction == ACTION_COPY ? \"copy\" : \"rename\",\n\t\t\t\t\t\t\t fn, nfn, strerror(errno));\n\t\t\t\t\tast_free(nfn);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tast_log(LOG_WARNING, \"Unknown helper %u\\n\", action);\n\t\t\t}\n\t\t\tast_free(fn);\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&formats);\n\treturn res;\n}\n", "bug_type": null, "idx": 1186}
{"project": "Asterisk", "target": 0, "func": "*/\nint ast_say_date_with_format_fr(struct ast_channel *chan, time_t t, const char *ints, const char *lang, const char *format, const char *tzone)\n{\n\tstruct timeval when = { t, 0 };\n\tstruct ast_tm tm;\n\tint res=0, offset, sndoffset;\n\tchar sndfile[256], nextmsg[256];\n\tif (format == NULL)\n\t\tformat = \"AdBY 'digits/at' IMp\";\n\tast_localtime(&when, &tm, tzone);\n\tfor (offset=0 ; format[offset] != '\\0' ; offset++) {\n\t\tast_debug(1, \"Parsing %c (offset %d) in %s\\n\", format[offset], offset, format);\n\t\tswitch (format[offset]) {\n\t\t\t\n\t\t\tcase '\\'':\n\t\t\t\t\n\t\t\t\tfor (sndoffset = 0; !strchr(\"\\'\\0\", format[++offset]) && (sndoffset < sizeof(sndfile) - 1) ; sndoffset++) {\n\t\t\t\t\tsndfile[sndoffset] = format[offset];\n\t\t\t\t}\n\t\t\t\tsndfile[sndoffset] = '\\0';\n\t\t\t\tres = wait_file(chan, ints, sndfile, lang);\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\tcase 'a':\n\t\t\t\t\n\t\t\t\tsnprintf(nextmsg, sizeof(nextmsg), \"digits/day-%d\", tm.tm_wday);\n\t\t\t\tres = wait_file(chan, ints, nextmsg, lang);\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\tcase 'b':\n\t\t\tcase 'h':\n\t\t\t\t\n\t\t\t\tsnprintf(nextmsg, sizeof(nextmsg), \"digits/mon-%d\", tm.tm_mon);\n\t\t\t\tres = wait_file(chan, ints, nextmsg, lang);\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\t\n\t\t\t\tsnprintf(nextmsg, sizeof(nextmsg), \"digits/h-%d\", tm.tm_mon +1);\n\t\t\t\tres = wait_file(chan, ints, nextmsg, lang);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\tcase 'e':\n\t\t\t\t\n\t\t\t\tif (tm.tm_mday == 1) {\n\t\t\t\t\tsnprintf(nextmsg, sizeof(nextmsg), \"digits/h-%d\", tm.tm_mday);\n\t\t\t\t\tres = wait_file(chan, ints, nextmsg, lang);\n\t\t\t\t} else {\n\t\t\t\t\tres = ast_say_number(chan, tm.tm_mday, ints, lang, (char * ) NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Y':\n\t\t\t\t\n\t\t\t\tif (tm.tm_year > 99) {\n\t\t\t\t\tres = wait_file(chan, ints, \"digits/2\", lang);\n\t\t\t\t\tif (!res) {\n\t\t\t\t\t\tres = wait_file(chan, ints, \"digits/thousand\", lang);\n\t\t\t\t\t}\n\t\t\t\t\tif (tm.tm_year > 100) {\n\t\t\t\t\t\tif (!res) {\n\t\t\t\t\t\t\tres = ast_say_number(chan, tm.tm_year - 100, ints, lang, (char * ) NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (tm.tm_year < 1) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres = wait_file(chan, ints, \"digits/thousand\", lang);\n\t\t\t\t\t\tif (!res) {\n\t\t\t\t\t\t\twait_file(chan, ints, \"digits/9\", lang);\n\t\t\t\t\t\t\twait_file(chan, ints, \"digits/hundred\", lang);\n\t\t\t\t\t\t\tres = ast_say_number(chan, tm.tm_year, ints, lang, (char * ) NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\tcase 'l':\n\t\t\t\t\n\t\t\t\tif (tm.tm_hour == 0)\n\t\t\t\t\tast_copy_string(nextmsg, \"digits/12\", sizeof(nextmsg));\n\t\t\t\telse if (tm.tm_hour > 12)\n\t\t\t\t\tsnprintf(nextmsg, sizeof(nextmsg), \"digits/%d\", tm.tm_hour - 12);\n\t\t\t\telse\n\t\t\t\t\tsnprintf(nextmsg, sizeof(nextmsg), \"digits/%d\", tm.tm_hour);\n\t\t\t\tres = wait_file(chan, ints, nextmsg, lang);\n\t\t\t\tif (!res)\n\t\t\t\t\tres = wait_file(chan, ints, \"digits/oclock\", lang);\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\tcase 'k':\n\t\t\t\t\n\t\t\t\tres = ast_say_number(chan, tm.tm_hour, ints, lang, (char * ) NULL);\n\t\t\t\tif (!res)\n\t\t\t\t\tres = wait_file(chan, ints, \"digits/oclock\", lang);\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\t\n\t\t\t\tif (tm.tm_min == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres = ast_say_number(chan, tm.tm_min, ints, lang, (char * ) NULL);\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\tcase 'p':\n\t\t\t\t\n\t\t\t\tif (tm.tm_hour > 11)\n\t\t\t\t\tast_copy_string(nextmsg, \"digits/p-m\", sizeof(nextmsg));\n\t\t\t\telse\n\t\t\t\t\tast_copy_string(nextmsg, \"digits/a-m\", sizeof(nextmsg));\n\t\t\t\tres = wait_file(chan, ints, nextmsg, lang);\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tstruct timeval now = ast_tvnow();\n\t\t\t\t\tstruct ast_tm tmnow;\n\t\t\t\t\ttime_t beg_today;\n\t\t\t\t\tast_localtime(&now, &tmnow, tzone);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbeg_today = now.tv_sec - (tmnow.tm_hour * 3600) - (tmnow.tm_min * 60) - (tmnow.tm_sec);\n\t\t\t\t\tif (beg_today < t) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tres = wait_file(chan, ints, \"digits/today\", lang);\n\t\t\t\t\t} else if (beg_today - 86400 < t) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tres = wait_file(chan, ints, \"digits/yesterday\", lang);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres = ast_say_date_with_format_fr(chan, t, ints, lang, \"AdBY\", tzone);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tstruct timeval now = ast_tvnow();\n\t\t\t\t\tstruct ast_tm tmnow;\n\t\t\t\t\ttime_t beg_today;\n\t\t\t\t\tast_localtime(&now, &tmnow, tzone);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbeg_today = now.tv_sec - (tmnow.tm_hour * 3600) - (tmnow.tm_min * 60) - (tmnow.tm_sec);\n\t\t\t\t\tif (beg_today < t) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else if ((beg_today - 86400) < t) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tres = wait_file(chan, ints, \"digits/yesterday\", lang);\n\t\t\t\t\t} else if (beg_today - 86400 * 6 < t) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tres = ast_say_date_with_format_fr(chan, t, ints, lang, \"A\", tzone);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres = ast_say_date_with_format_fr(chan, t, ints, lang, \"AdBY\", tzone);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tres = ast_say_date_with_format_fr(chan, t, ints, lang, \"HM\", tzone);\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\t\n\t\t\t\tres = ast_say_number(chan, tm.tm_sec, ints, lang, (char * ) NULL);\n\t\t\t\tif (!res) {\n\t\t\t\t\tres = wait_file(chan, ints, \"second\", lang);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tres = ast_say_date_with_format_fr(chan, t, ints, lang, \"HMS\", tzone);\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\tcase '\t':\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\tast_log(LOG_WARNING, \"Unknown character in datetime format %s: %c at pos %d\\n\", format, format[offset], offset);\n\t\t}\n\t\t\n\t\tif (res) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1187}
{"project": "Asterisk", "target": 0, "func": "char *ast_var_find(const struct varshead *head, const char *name)\n{\n\tstruct ast_var_t *var;\n\tAST_LIST_TRAVERSE(head, var, entries) {\n\t\tif (!strcmp(name, var->name)) {\n\t\t\treturn var->value;\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1188}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225AddressPattern_range (OOCTXT* pctxt, H225AddressPattern_range* pvalue)\n{\n   int stat = ASN_OK;\n   \n   invokeStartElement (pctxt, \"startOfRange\", -1);\n   stat = asn1PD_H225PartyNumber (pctxt, &pvalue->startOfRange);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"startOfRange\", -1);\n   \n   invokeStartElement (pctxt, \"endOfRange\", -1);\n   stat = asn1PD_H225PartyNumber (pctxt, &pvalue->endOfRange);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"endOfRange\", -1);\n   return (stat);\n}\n", "bug_type": null, "idx": 1189}
{"project": "Asterisk", "target": 0, "func": " */\nstatic inline int check_unloading()\n{\n\tint res;\n\tast_mutex_lock(&unload_mutex);\n\tres = unloading_flag;\n\tast_mutex_unlock(&unload_mutex);\n\treturn res;\n}\n", "bug_type": null, "idx": 1190}
{"project": "Asterisk", "target": 0, "func": "static int\nrl_complete_internal(int what_to_do)\n{\n\tCPFunction *complet_func;\n\tconst LineInfo *li;\n\tchar *temp, **matches;\n\tconst char *ctemp;\n\tsize_t len;\n\trl_completion_type = what_to_do;\n\tif (h == NULL || e == NULL)\n\t\trl_initialize();\n\tcomplet_func = rl_completion_entry_function;\n\tif (!complet_func)\n\t\tcomplet_func = filename_completion_function;\n\t\n\tli = el_line(e);\n\tctemp = (const char *) li->cursor;\n\twhile (ctemp > li->buffer\n\t    && !strchr(rl_basic_word_break_characters, ctemp[-1])\n\t    && (!rl_special_prefixes\n\t\t\t|| !strchr(rl_special_prefixes, ctemp[-1]) ) )\n\t\tctemp--;\n\tlen = li->cursor - ctemp;\n\ttemp = alloca(len + 1);\n\t(void) strncpy(temp, ctemp, len);\n\ttemp[len] = '\\0';\n\t\n\t\n\trl_point = li->cursor - li->buffer;\n\trl_end = li->lastchar - li->buffer;\n\tif (!rl_attempted_completion_function)\n\t\tmatches = completion_matches(temp, complet_func);\n\telse {\n\t\tint end = li->cursor - li->buffer;\n\t\tmatches = (*rl_attempted_completion_function) (temp, (int)\n\t\t    (end - len), end);\n\t}\n\tif (matches) {\n\t\tint i, retval = CC_REFRESH;\n\t\tint matches_num, maxlen, match_len, match_display=1;\n\t\t\n\t\tif (matches[0][0] != '\\0') {\n\t\t\tel_deletestr(e, (int) len);\n\t\t\tel_insertstr(e, matches[0]);\n\t\t}\n\t\tif (what_to_do == '?')\n\t\t\tgoto display_matches;\n\t\tif (matches[2] == NULL && strcmp(matches[0], matches[1]) == 0) {\n\t\t\t\n\t\t\tsize_t alen = strlen(matches[0]);\n\t\t\tif ((complet_func != filename_completion_function\n\t\t\t      || (alen > 0 && (matches[0])[alen - 1] != '/'))\n\t\t\t    && rl_completion_append_character) {\n\t\t\t\tchar buf[2];\n\t\t\t\tbuf[0] = rl_completion_append_character;\n\t\t\t\tbuf[1] = '\\0';\n\t\t\t\tel_insertstr(e, buf);\n\t\t\t}\n\t\t} else if (what_to_do == '!') {\n    display_matches:\n\t\t\t\n\t\t\tfor(i=1, maxlen=0; matches[i]; i++) {\n\t\t\t\tmatch_len = strlen(matches[i]);\n\t\t\t\tif (match_len > maxlen)\n\t\t\t\t\tmaxlen = match_len;\n\t\t\t}\n\t\t\tmatches_num = i - 1;\n\t\t\t\n\t\t\tfprintf(e->el_outfile, \"\\n\");\n\t\t\t\n\t\t\tif (matches_num > rl_completion_query_items) {\n\t\t\t\tfprintf(e->el_outfile,\n\t\t\t\t\"Display all %d possibilities? (y or n) \",\n\t\t\t\t\tmatches_num);\n\t\t\t\tfflush(e->el_outfile);\n\t\t\t\tif (getc(stdin) != 'y')\n\t\t\t\t\tmatch_display = 0;\n\t\t\t\tfprintf(e->el_outfile, \"\\n\");\n\t\t\t}\n\t\t\tif (match_display)\n\t\t\t\trl_display_match_list(matches, matches_num,\n\t\t\t\t\tmaxlen);\n\t\t\tretval = CC_REDISPLAY;\n\t\t} else if (matches[0][0]) {\n\t\t\t\n\t\t\tel_beep(e);\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tel_beep(e);\n\t\t\tretval = CC_NORM;\n\t\t}\n\t\t\n\t\tfor (i = 0; matches[i]; i++)\n\t\t\tfree(matches[i]);\n\t\tfree(matches), matches = NULL;\n\t\treturn (retval);\n\t}\n\treturn (CC_NORM);\n}\n", "bug_type": null, "idx": 1191}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_destroy_cli(void)\n{\n\tast_cli_unregister_multiple(pjsip_cli, ARRAY_LEN(pjsip_cli));\n\tao2_ref(formatter_registry, -1);\n}\n", "bug_type": null, "idx": 1192}
{"project": "Asterisk", "target": 0, "func": "\ned_tty_sigint(EditLine *el, int c)\n{\n\treturn (CC_NORM);\n}\n", "bug_type": null, "idx": 1193}
{"project": "Asterisk", "target": 0, "func": "static int realtime_sorcery_destroy(const char *database, const char *table, const char *keyfield, const char *entity, const struct ast_variable *fields)\n{\n\tstruct ast_category *found;\n\tif (!(found = ast_category_get(realtime_objects, entity, NULL))) {\n\t\treturn 0;\n\t}\n\tast_category_delete(realtime_objects, found);\n\treturn 1;\n}\n", "bug_type": null, "idx": 1194}
{"project": "Asterisk", "target": 0, "func": "struct ast_bridge *park_application_setup(struct ast_channel *parkee, struct ast_channel *parker, const char *app_data,\n\t\tint *silence_announcements)\n{\n\tint use_ringing = 0;\n\tint randomize = 0;\n\tint time_limit = -1;\n\tRAII_VAR(char *, comeback_override, NULL, ast_free);\n\tRAII_VAR(char *, lot_name_app_arg, NULL, ast_free);\n\tif (app_data) {\n\t\tpark_app_parse_data(app_data, silence_announcements, &use_ringing, &randomize, &time_limit, &comeback_override, &lot_name_app_arg);\n\t}\n\treturn park_common_setup(parkee, parker, lot_name_app_arg, comeback_override, use_ringing,\n\t\trandomize, time_limit, silence_announcements ? *silence_announcements : 0);\n}\n", "bug_type": null, "idx": 1195}
{"project": "Asterisk", "target": 0, "func": "\t__attribute__((format (printf, 3, 0)));\nstatic void dahdi_r2_on_context_log(openr2_context_t *r2context, openr2_log_level_t level, const char *fmt, va_list ap)\n{\n#define CONTEXT_TAG \"Context - \"\n\tchar logmsg[256];\n\tchar completemsg[sizeof(logmsg) + sizeof(CONTEXT_TAG) - 1];\n\tvsnprintf(logmsg, sizeof(logmsg), fmt, ap);\n\tsnprintf(completemsg, sizeof(completemsg), CONTEXT_TAG \"%s\", logmsg);\n\tdahdi_r2_write_log(level, completemsg);\n#undef CONTEXT_TAG\n}\n", "bug_type": null, "idx": 1196}
{"project": "Asterisk", "target": 0, "func": "int ooSendAlerting(OOH323CallData *call)\n{\n   int ret;    \n   H225Alerting_UUIE *alerting;\n   H225VendorIdentifier *vendor;\n   Q931Message *q931msg=NULL;\n   \n   OOCTXT *pctxt = call->msgctxt;\n   ret = ooCreateQ931Message(pctxt, &q931msg, Q931AlertingMsg);\n   if(ret != OO_OK)\n   {      \n      OOTRACEERR1(\"Error: In allocating memory for - H225 \"\n                  \"Alerting message\\n\");\n      return OO_FAILED;\n   }\n   call->alertingTime = (H235TimeStamp) time(NULL);\n   q931msg->callReference = call->callReference;\n   q931msg->userInfo = (H225H323_UserInformation*)memAlloc(pctxt,\n                             sizeof(H225H323_UserInformation));\n   if(!q931msg->userInfo)\n   {\n      OOTRACEERR1(\"ERROR:Memory -  ooSendAlerting - userInfo\\n\");\n      return OO_FAILED;\n   }\n   memset (q931msg->userInfo, 0, sizeof(H225H323_UserInformation));\n   q931msg->userInfo->h323_uu_pdu.m.h245TunnelingPresent=1; \n   q931msg->userInfo->h323_uu_pdu.h245Tunneling = OO_TESTFLAG(call->flags, \n                                                              OO_M_TUNNELING); \n   q931msg->userInfo->h323_uu_pdu.h323_message_body.t = \n         T_H225H323_UU_PDU_h323_message_body_alerting;\n   alerting = (H225Alerting_UUIE*)memAlloc(pctxt, \n                                             sizeof(H225Alerting_UUIE));\n   if(!alerting)\n   {\n      OOTRACEERR1(\"ERROR:Memory -  ooSendAlerting - alerting\\n\");\n      return OO_FAILED;\n   }\n   memset(alerting, 0, sizeof(H225Alerting_UUIE));\n   q931msg->userInfo->h323_uu_pdu.h323_message_body.u.alerting = alerting;\n   alerting->m.multipleCallsPresent = 1;\n   alerting->m.maintainConnectionPresent = 1;\n   alerting->multipleCalls = FALSE;\n   alerting->maintainConnection = FALSE;\n   \n   alerting->m.alertingAddressPresent = TRUE;\n   if(call->ourAliases)\n      ret = ooPopulateAliasList(pctxt, call->ourAliases, \n                                       &alerting->alertingAddress, 0);\n   else\n      ret = ooPopulateAliasList(pctxt, gH323ep.aliases,\n                                       &alerting->alertingAddress, 0);\n   if(OO_OK != ret)\n   {\n      OOTRACEERR1(\"Error:Failed to populate alias list in Alert message\\n\");\n      memReset(pctxt);\n      return OO_FAILED;\n   }\n   alerting->m.presentationIndicatorPresent = TRUE;\n   alerting->presentationIndicator.t = \n                             T_H225PresentationIndicator_presentationAllowed;\n   alerting->m.screeningIndicatorPresent = TRUE;\n   alerting->screeningIndicator = userProvidedNotScreened;\n   alerting->m.callIdentifierPresent = 1;\n   alerting->callIdentifier.guid.numocts = \n                                   call->callIdentifier.guid.numocts;\n   memcpy(alerting->callIdentifier.guid.data, \n          call->callIdentifier.guid.data, \n          call->callIdentifier.guid.numocts);\n   alerting->protocolIdentifier = gProtocolID;  \n   \n   if(gH323ep.isGateway)\n      alerting->destinationInfo.m.gatewayPresent = TRUE;\n   else\n      alerting->destinationInfo.m.terminalPresent = TRUE;\n   alerting->destinationInfo.m.vendorPresent = 1;\n   vendor = &alerting->destinationInfo.vendor;\n   if(gH323ep.productID)\n   {\n      vendor->m.productIdPresent = 1;\n      vendor->productId.numocts = ASN1MIN(strlen(gH323ep.productID), \n                                        sizeof(vendor->productId.data));\n      strncpy((char *)vendor->productId.data, gH323ep.productID, \n                                        vendor->productId.numocts);\n   }\n   if(gH323ep.versionID)\n   {\n      vendor->m.versionIdPresent = 1;\n      vendor->versionId.numocts = ASN1MIN(strlen(gH323ep.versionID), \n                                        sizeof(vendor->versionId.data));\n      strncpy((char *)vendor->versionId.data, gH323ep.versionID, \n              vendor->versionId.numocts); \n   }\n   vendor->vendor.t35CountryCode = gH323ep.t35CountryCode;\n   vendor->vendor.t35Extension = gH323ep.t35Extension;\n   vendor->vendor.manufacturerCode = gH323ep.manufacturerCode;\n   if (!call->fsSent) {\n    ret = ooSetFastStartResponse(call, q931msg, \n       &alerting->fastStart.n, &alerting->fastStart.elem);\n    if(ret != ASN_OK) { return ret; }\n    if(alerting->fastStart.n > 0) {\n       alerting->m.fastStartPresent = TRUE;\n       call->fsSent = TRUE;\n    } else\n      alerting->m.fastStartPresent = FALSE;\n   } else {\n      alerting->m.fastStartPresent = FALSE;\n   }\n   OOTRACEDBGA3(\"Built Alerting (%s, %s)\\n\", call->callType, call->callToken);\n   ret = ooSendH225Msg(call, q931msg);\n   if(ret != OO_OK)\n   {\n      OOTRACEERR3(\"Error: Failed to enqueue Alerting message to outbound queue. (%s, %s)\\n\", call->callType, call->callToken);\n   }\n   if (call->h225version >= 4) {\n\tooSendTCSandMSD(call);\n   }\n   memReset (call->msgctxt);\n   return ret;\n}\n", "bug_type": null, "idx": 1197}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int load_module(void)\n{\n\tif(!reload_followme(0))\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\treturn ast_register_application_xml(app, app_exec);\n}\n", "bug_type": null, "idx": 1198}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function dtmf_mode_function = {\n\t.name = \"PJSIP_DTMF_MODE\",\n\t.read = pjsip_acf_dtmf_mode_read,\n\t.write = pjsip_acf_dtmf_mode_write\n};\n", "bug_type": null, "idx": 1199}
{"project": "Asterisk", "target": 0, "func": "\nint load_module(void)\n{\n\tint res;\n\tif (!(global_cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {\n\t\tgoto buff_failed;\n\t}\n\tif (!(unistim_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {\n\t\tgoto buff_failed;\n\t}\n\tast_format_cap_append(global_cap, ast_format_ulaw, 0);\n\tast_format_cap_append(global_cap, ast_format_alaw, 0);\n\tast_format_cap_append_from_cap(unistim_tech.capabilities, global_cap, AST_MEDIA_TYPE_AUDIO);\n\tif (!(buff = ast_malloc(SIZE_PAGE))) {\n\t\tgoto buff_failed;\n\t}\n\tio = io_context_create();\n\tif (!io) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate IO context\\n\");\n\t\tgoto io_failed;\n\t}\n\tsched = ast_sched_context_create();\n\tif (!sched) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate scheduler context\\n\");\n\t\tgoto sched_failed;\n\t}\n\tres = reload_config();\n\tif (res) {\n\t\tao2_ref(unistim_tech.capabilities, -1);\n\t\tao2_ref(global_cap, -1);\n\t\tast_sched_context_destroy(sched);\n\t\tio_context_destroy(io);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\t\n\tif (ast_channel_register(&unistim_tech)) {\n\t\tast_log(LOG_ERROR, \"Unable to register channel type '%s'\\n\", channel_type);\n\t\tgoto chanreg_failed;\n\t}\n\tast_rtp_glue_register(&unistim_rtp_glue);\n\tast_cli_register_multiple(unistim_cli, ARRAY_LEN(unistim_cli));\n\trestart_monitor();\n\treturn AST_MODULE_LOAD_SUCCESS;\nchanreg_failed:\n\t\n\tast_sched_context_destroy(sched);\n\tsched = NULL;\nsched_failed:\n\tio_context_destroy(io);\n\tio = NULL;\nio_failed:\n\tast_free(buff);\n\tbuff = NULL;\nbuff_failed:\n\tao2_cleanup(global_cap);\n\tglobal_cap = NULL;\n\tao2_cleanup(unistim_tech.capabilities);\n\tunistim_tech.capabilities = NULL;\n\treturn AST_MODULE_LOAD_DECLINE;\n}\n", "bug_type": null, "idx": 1200}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void bridge_channel_wait(struct ast_bridge_channel *bridge_channel)\n{\n\tint ms;\n\tint outfd;\n\tstruct ast_channel *chan;\n\t\n\tast_bridge_channel_lock(bridge_channel);\n\tif (bridge_channel->state != BRIDGE_CHANNEL_STATE_WAIT) {\n\t} else if (bridge_channel->suspended) {\n\n\t\tast_debug(1, \"Bridge %s: %p(%s) is going into a signal wait\\n\",\n\t\t\tbridge_channel->bridge->uniqueid, bridge_channel,\n\t\t\tast_channel_name(bridge_channel->chan));\n\t\tast_cond_wait(&bridge_channel->cond, ao2_object_get_lockaddr(bridge_channel));\n\t} else {\n\t\tast_bridge_channel_unlock(bridge_channel);\n\t\toutfd = -1;\n\t\tms = bridge_channel_next_timeout(bridge_channel);\n\t\tchan = ast_waitfor_nandfds(&bridge_channel->chan, 1,\n\t\t\t&bridge_channel->alert_pipe[0], 1, NULL, &outfd, &ms);\n\t\tif (ast_channel_unbridged(bridge_channel->chan)) {\n\t\t\tast_channel_set_unbridged(bridge_channel->chan, 0);\n\t\t\tast_bridge_channel_lock_bridge(bridge_channel);\n\t\t\tbridge_channel->bridge->reconfigured = 1;\n\t\t\tbridge_reconfigured(bridge_channel->bridge, 0);\n\t\t\tast_bridge_unlock(bridge_channel->bridge);\n\t\t}\n\t\tast_bridge_channel_lock(bridge_channel);\n\t\tbridge_channel->activity = BRIDGE_CHANNEL_THREAD_FRAME;\n\t\tast_bridge_channel_unlock(bridge_channel);\n\t\tif (!bridge_channel->suspended\n\t\t\t&& bridge_channel->state == BRIDGE_CHANNEL_STATE_WAIT) {\n\t\t\tif (chan) {\n\t\t\t\tbridge_handle_trip(bridge_channel);\n\t\t\t} else if (ms == 0) {\n\t\t\t\t\n\t\t\t\tbridge_channel_handle_feature_timeout(bridge_channel);\n\t\t\t\tbridge_channel_handle_interval(bridge_channel);\n\t\t\t} else if (-1 < outfd) {\n\t\t\t\t\n\t\t\t\tbridge_channel_handle_write(bridge_channel);\n\t\t\t}\n\t\t}\n\t\tbridge_channel->activity = BRIDGE_CHANNEL_THREAD_IDLE;\n\t\treturn;\n\t}\n\tast_bridge_channel_unlock(bridge_channel);\n}\n", "bug_type": null, "idx": 1201}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function session_refresh_function = {\n\t.name = \"PJSIP_SEND_SESSION_REFRESH\",\n\t.write = pjsip_acf_session_refresh_write,\n};\n", "bug_type": null, "idx": 1202}
{"project": "Asterisk", "target": 0, "func": "\nint ast_speech_results_free(struct ast_speech_result *result)\n{\n\tstruct ast_speech_result *current_result = result, *prev_result = NULL;\n\tint res = 0;\n\twhile (current_result != NULL) {\n\t\tprev_result = current_result;\n\t\t\n\t\tif (current_result->text != NULL) {\n\t\t\tast_free(current_result->text);\n\t\t\tcurrent_result->text = NULL;\n\t\t}\n\t\tif (current_result->grammar != NULL) {\n\t\t\tast_free(current_result->grammar);\n\t\t\tcurrent_result->grammar = NULL;\n\t\t}\n\t\t\n\t\tcurrent_result = AST_LIST_NEXT(current_result, list);\n\t\tast_free(prev_result);\n\t\tprev_result = NULL;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1203}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int queue_exec(struct ast_channel *chan, const char *data)\n{\n\tint res=-1;\n\tint ringing=0;\n\tconst char *user_priority;\n\tconst char *max_penalty_str;\n\tconst char *min_penalty_str;\n\tconst char *raise_penalty_str;\n\tint prio;\n\tint qcontinue = 0;\n\tint max_penalty, min_penalty, raise_penalty;\n\tenum queue_result reason = QUEUE_UNKNOWN;\n\t\n\tint tries = 0;\n\tint noption = 0;\n\tchar *parse;\n\tint makeannouncement = 0;\n\tint position = 0;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(queuename);\n\t\tAST_APP_ARG(options);\n\t\tAST_APP_ARG(url);\n\t\tAST_APP_ARG(announceoverride);\n\t\tAST_APP_ARG(queuetimeoutstr);\n\t\tAST_APP_ARG(agi);\n\t\tAST_APP_ARG(macro);\n\t\tAST_APP_ARG(gosub);\n\t\tAST_APP_ARG(rule);\n\t\tAST_APP_ARG(position);\n\t);\n\t\n\tstruct queue_ent qe = { 0 };\n\tstruct ast_flags opts = { 0, };\n\tchar *opt_args[OPT_ARG_ARRAY_SIZE];\n\tint max_forwards;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"Queue requires an argument: queuename[,options[,URL[,announceoverride[,timeout[,agi[,macro[,gosub[,rule[,position]]]]]]]]]\\n\");\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\tmax_forwards = ast_max_forwards_get(chan);\n\tast_channel_unlock(chan);\n\tif (max_forwards <= 0) {\n\t\tast_log(LOG_WARNING, \"Channel '%s' cannot enter queue. Max forwards exceeded\\n\", ast_channel_name(chan));\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tast_debug(1, \"queue: %s, options: %s, url: %s, announce: %s, timeout: %s, agi: %s, macro: %s, gosub: %s, rule: %s, position: %s\\n\",\n\t\targs.queuename,\n\t\tS_OR(args.options, \"\"),\n\t\tS_OR(args.url, \"\"),\n\t\tS_OR(args.announceoverride, \"\"),\n\t\tS_OR(args.queuetimeoutstr, \"\"),\n\t\tS_OR(args.agi, \"\"),\n\t\tS_OR(args.macro, \"\"),\n\t\tS_OR(args.gosub, \"\"),\n\t\tS_OR(args.rule, \"\"),\n\t\tS_OR(args.position, \"\"));\n\tif (!ast_strlen_zero(args.options)) {\n\t\tast_app_parse_options(queue_exec_options, &opts, opt_args, args.options);\n\t}\n\t\n\tqe.start = time(NULL);\n\tpbx_builtin_setvar_helper(chan, \"ABANDONED\", NULL);\n\t\n\tif (!ast_strlen_zero(args.queuetimeoutstr)) {\n\t\tqe.expire = qe.start + atoi(args.queuetimeoutstr);\n\t} else {\n\t\tqe.expire = 0;\n\t}\n\t\n\tast_channel_lock(chan);\n\tuser_priority = pbx_builtin_getvar_helper(chan, \"QUEUE_PRIO\");\n\tif (user_priority) {\n\t\tif (sscanf(user_priority, \"%30d\", &prio) == 1) {\n\t\t\tast_debug(1, \"%s: Got priority %d from ${QUEUE_PRIO}.\\n\", ast_channel_name(chan), prio);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"${QUEUE_PRIO}: Invalid value (%s), channel %s.\\n\",\n\t\t\t\tuser_priority, ast_channel_name(chan));\n\t\t\tprio = 0;\n\t\t}\n\t} else {\n\t\tast_debug(3, \"NO QUEUE_PRIO variable found. Using default.\\n\");\n\t\tprio = 0;\n\t}\n\t\n\tif ((max_penalty_str = pbx_builtin_getvar_helper(chan, \"QUEUE_MAX_PENALTY\"))) {\n\t\tif (sscanf(max_penalty_str, \"%30d\", &max_penalty) == 1) {\n\t\t\tast_debug(1, \"%s: Got max penalty %d from ${QUEUE_MAX_PENALTY}.\\n\", ast_channel_name(chan), max_penalty);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"${QUEUE_MAX_PENALTY}: Invalid value (%s), channel %s.\\n\",\n\t\t\t\tmax_penalty_str, ast_channel_name(chan));\n\t\t\tmax_penalty = INT_MAX;\n\t\t}\n\t} else {\n\t\tmax_penalty = INT_MAX;\n\t}\n\tif ((min_penalty_str = pbx_builtin_getvar_helper(chan, \"QUEUE_MIN_PENALTY\"))) {\n\t\tif (sscanf(min_penalty_str, \"%30d\", &min_penalty) == 1) {\n\t\t\tast_debug(1, \"%s: Got min penalty %d from ${QUEUE_MIN_PENALTY}.\\n\", ast_channel_name(chan), min_penalty);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"${QUEUE_MIN_PENALTY}: Invalid value (%s), channel %s.\\n\",\n\t\t\t\tmin_penalty_str, ast_channel_name(chan));\n\t\t\tmin_penalty = INT_MAX;\n\t\t}\n\t} else {\n\t\tmin_penalty = INT_MAX;\n\t}\n\tif ((raise_penalty_str = pbx_builtin_getvar_helper(chan, \"QUEUE_RAISE_PENALTY\"))) {\n\t\tif (sscanf(raise_penalty_str, \"%30d\", &raise_penalty) == 1) {\n\t\t\tast_debug(1, \"%s: Got raise penalty %d from ${QUEUE_RAISE_PENALTY}.\\n\", ast_channel_name(chan), raise_penalty);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"${QUEUE_RAISE_PENALTY}: Invalid value (%s), channel %s.\\n\",\n\t\t\t\traise_penalty_str, ast_channel_name(chan));\n\t\t\traise_penalty = INT_MAX;\n\t\t}\n\t} else {\n\t\traise_penalty = INT_MAX;\n\t}\n\tast_channel_unlock(chan);\n\tif (ast_test_flag(&opts, OPT_RINGING)) {\n\t\tringing = 1;\n\t}\n\tif (ringing != 1 && ast_test_flag(&opts, OPT_RING_WHEN_RINGING)) {\n\t\tqe.ring_when_ringing = 1;\n\t}\n\tif (ast_test_flag(&opts, OPT_GO_ON)) {\n\t\tqcontinue = 1;\n\t}\n\tif (args.position) {\n\t\tposition = atoi(args.position);\n\t\tif (position < 0) {\n\t\t\tast_log(LOG_WARNING, \"Invalid position '%s' given for call to queue '%s'. Assuming no preference for position\\n\", args.position, args.queuename);\n\t\t\tposition = 0;\n\t\t}\n\t}\n\tast_debug(1, \"queue: %s, expires: %ld, priority: %d\\n\",\n\t\targs.queuename, (long)qe.expire, prio);\n\tqe.chan = chan;\n\tqe.prio = prio;\n\tqe.max_penalty = max_penalty;\n\tqe.min_penalty = min_penalty;\n\tqe.raise_penalty = raise_penalty;\n\tqe.last_pos_said = 0;\n\tqe.last_pos = 0;\n\tqe.last_periodic_announce_time = time(NULL);\n\tqe.last_periodic_announce_sound = 0;\n\tqe.valid_digits = 0;\n\tif (join_queue(args.queuename, &qe, &reason, position)) {\n\t\tast_log(LOG_WARNING, \"Unable to join queue '%s'\\n\", args.queuename);\n\t\tset_queue_result(chan, reason);\n\t\treturn 0;\n\t}\n\tast_assert(qe.parent != NULL);\n\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), \"NONE\", \"ENTERQUEUE\", \"%s|%s|%d\",\n\t\tS_OR(args.url, \"\"),\n\t\tS_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, \"\"),\n\t\tqe.opos);\n\tcopy_rules(&qe, args.rule);\n\tqe.pr = AST_LIST_FIRST(&qe.qe_rules);\ncheck_turns:\n\tif (ringing) {\n\t\tast_indicate(chan, AST_CONTROL_RINGING);\n\t} else {\n\t\tast_moh_start(chan, qe.moh, NULL);\n\t}\n\t\n\tres = wait_our_turn(&qe, ringing, &reason);\n\tif (res) {\n\t\tgoto stop;\n\t}\n\tmakeannouncement = qe.parent->announce_to_first_user;\n\tfor (;;) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (qe.expire && (time(NULL) >= qe.expire)) {\n\t\t\trecord_abandoned(&qe);\n\t\t\treason = QUEUE_TIMEOUT;\n\t\t\tres = 0;\n\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan),\"NONE\", \"EXITWITHTIMEOUT\", \"%d|%d|%ld\",\n\t\t\t\tqe.pos, qe.opos, (long) (time(NULL) - qe.start));\n\t\t\tbreak;\n\t\t}\n\t\tif (makeannouncement) {\n\t\t\t\n\t\t\tif (qe.parent->announcefrequency) {\n\t\t\t\tif ((res = say_position(&qe, ringing))) {\n\t\t\t\t\tgoto stop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmakeannouncement = 1;\n\t\t\n\t\tif (qe.parent->periodicannouncefrequency) {\n\t\t\tif ((res = say_periodic_announcement(&qe, ringing))) {\n\t\t\t\tgoto stop;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (qe.expire && (time(NULL) >= qe.expire)) {\n\t\t\trecord_abandoned(&qe);\n\t\t\treason = QUEUE_TIMEOUT;\n\t\t\tres = 0;\n\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), \"NONE\", \"EXITWITHTIMEOUT\",\n\t\t\t\t\"%d|%d|%ld\", qe.pos, qe.opos, (long) (time(NULL) - qe.start));\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\twhile (qe.pr && ((time(NULL) - qe.start) > qe.pr->time)) {\n\t\t\tupdate_qe_rule(&qe);\n\t\t}\n\t\t\n\t\tres = try_calling(&qe, opts, opt_args, args.announceoverride, args.url, &tries, &noption, args.agi, args.macro, args.gosub, ringing);\n\t\tif (res) {\n\t\t\tgoto stop;\n\t\t}\n\t\tif (qe.parent->leavewhenempty) {\n\t\t\tint status = 0;\n\t\t\tif ((status = get_member_status(qe.parent, qe.max_penalty, qe.min_penalty, qe.raise_penalty, qe.parent->leavewhenempty, 0))) {\n\t\t\t\trecord_abandoned(&qe);\n\t\t\t\treason = QUEUE_LEAVEEMPTY;\n\t\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), \"NONE\", \"EXITEMPTY\", \"%d|%d|%ld\", qe.pos, qe.opos, (long)(time(NULL) - qe.start));\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (noption && tries >= ao2_container_count(qe.parent->members)) {\n\t\t\tast_verb(3, \"Exiting on time-out cycle\\n\");\n\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), \"NONE\", \"EXITWITHTIMEOUT\",\n\t\t\t\t\"%d|%d|%ld\", qe.pos, qe.opos, (long) (time(NULL) - qe.start));\n\t\t\trecord_abandoned(&qe);\n\t\t\treason = QUEUE_TIMEOUT;\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (qe.expire && (time(NULL) >= qe.expire)) {\n\t\t\trecord_abandoned(&qe);\n\t\t\treason = QUEUE_TIMEOUT;\n\t\t\tres = 0;\n\t\t\tast_queue_log(qe.parent->name, ast_channel_uniqueid(qe.chan),\"NONE\", \"EXITWITHTIMEOUT\", \"%d|%d|%ld\", qe.pos, qe.opos, (long) (time(NULL) - qe.start));\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tupdate_realtime_members(qe.parent);\n\t\t\n\t\tres = wait_a_bit(&qe);\n\t\tif (res) {\n\t\t\tgoto stop;\n\t\t}\n\t\t\n\t\tif (!is_our_turn(&qe)) {\n\t\t\tast_debug(1, \"Darn priorities, going back in queue (%s)!\\n\", ast_channel_name(qe.chan));\n\t\t\tgoto check_turns;\n\t\t}\n\t}\nstop:\n\tif (res) {\n\t\tif (res < 0) {\n\t\t\tif (!qe.handled) {\n\t\t\t\trecord_abandoned(&qe);\n\t\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), \"NONE\", \"ABANDON\",\n\t\t\t\t\t\"%d|%d|%ld\", qe.pos, qe.opos,\n\t\t\t\t\t(long) (time(NULL) - qe.start));\n\t\t\t\tres = -1;\n\t\t\t} else if (qcontinue) {\n\t\t\t\treason = QUEUE_CONTINUE;\n\t\t\t\tres = 0;\n\t\t\t} else if (reason == QUEUE_LEAVEEMPTY) {\n\t\t\t\t\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else if (qe.valid_digits) {\n\t\t\tast_queue_log(args.queuename, ast_channel_uniqueid(chan), \"NONE\", \"EXITWITHKEY\",\n\t\t\t\t\"%s|%d|%d|%ld\", qe.digits, qe.pos, qe.opos, (long) (time(NULL) - qe.start));\n\t\t}\n\t}\n\t\n\tif (res >= 0) {\n\t\tres = 0;\n\t\tif (ringing) {\n\t\t\tast_indicate(chan, -1);\n\t\t} else {\n\t\t\tast_moh_stop(chan);\n\t\t}\n\t\tast_stopstream(chan);\n\t}\n\tset_queue_variables(qe.parent, qe.chan);\n\tleave_queue(&qe);\n\tif (reason != QUEUE_UNKNOWN)\n\t\tset_queue_result(chan, reason);\n\t\n\tqe.parent = queue_unref(qe.parent);\n\treturn res;\n}\n", "bug_type": null, "idx": 1204}
{"project": "Asterisk", "target": 0, "func": "static struct ast_cli_entry cli_show_fd = AST_CLI_DEFINE(handle_show_fd, \"Show open file descriptors\");\nstatic void fd_shutdown(void)\n{\n\tast_cli_unregister(&cli_show_fd);\n}\n", "bug_type": null, "idx": 1205}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tAST_TEST_REGISTER(config_save);\n\tAST_TEST_REGISTER(config_basic_ops);\n\tAST_TEST_REGISTER(config_filtered_ops);\n\tAST_TEST_REGISTER(config_template_ops);\n\tAST_TEST_REGISTER(copy_config);\n\tAST_TEST_REGISTER(config_hook);\n\tAST_TEST_REGISTER(ast_parse_arg_test);\n\tAST_TEST_REGISTER(config_options_test);\n\tAST_TEST_REGISTER(config_dialplan_function);\n\tAST_TEST_REGISTER(variable_lists_match);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1206}
{"project": "Asterisk", "target": 0, "func": "int ast_add_extension2_nolock(struct ast_context *con,\n\tint replace, const char *extension, int priority, const char *label, const char *callerid,\n\tconst char *application, void *data, void (*datad)(void *),\n\tconst char *registrar, const char *registrar_file, int registrar_line)\n{\n\treturn ast_add_extension2_lockopt(con, replace, extension, priority, label, callerid,\n\t\tapplication, data, datad, registrar, registrar_file, registrar_line, 0);\n}\n", "bug_type": null, "idx": 1207}
{"project": "Asterisk", "target": 0, "func": "const char *ast_dns_srv_get_host(const struct ast_dns_record *record)\n{\n\tstruct ast_dns_srv_record *srv = (struct ast_dns_srv_record *) record;\n\tast_assert(ast_dns_record_get_rr_type(record) == T_SRV);\n\treturn srv->host;\n}\n", "bug_type": null, "idx": 1208}
{"project": "Asterisk", "target": 0, "func": "static int stream_echo_exec(struct ast_channel *chan, const char *data)\n{\n\tint res;\n\tunsigned int num = 0;\n\tenum ast_media_type type;\n\tchar *parse;\n\tstruct ast_stream_topology *topology;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(num);\n\t\tAST_APP_ARG(type);\n\t);\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (ast_strlen_zero(args.num)) {\n\t\t\n\t\treturn stream_echo_perform(chan, NULL, AST_MEDIA_TYPE_UNKNOWN);\n\t}\n\tif (ast_str_to_uint(args.num, &num)) {\n\t\tast_log(LOG_ERROR, \"Failed to parse the first parameter '%s' into a\"\n\t\t\t\" greater than or equal to zero\\n\", args.num);\n\t\treturn -1;\n\t}\n\ttype = ast_strlen_zero(args.type) ? AST_MEDIA_TYPE_VIDEO :\n\t\tast_media_type_from_str(args.type);\n\ttopology = stream_echo_topology_alloc(\n\t\tast_channel_get_stream_topology(chan), num, type);\n\tif (!topology) {\n\t\tast_log(LOG_ERROR, \"Unable to create '%u' streams of type '%s' to\"\n\t\t\t\" the topology\\n\", num, ast_codec_media_type2str(type));\n\t\treturn -1;\n\t}\n\tres = stream_echo_perform(chan, topology, type);\n\tif (ast_channel_get_stream_topology(chan) != topology) {\n\t\tast_stream_topology_free(topology);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1209}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ringing(struct ast_channel *chan)\n{\n\tstruct ast_bridge_channel *bridge_channel;\n\tast_channel_lock(chan);\n\tbridge_channel = ast_channel_get_bridge_channel(chan);\n\tast_channel_unlock(chan);\n\tif (bridge_channel) {\n\t\tast_bridge_channel_write_control_data(bridge_channel, AST_CONTROL_RINGING, NULL, 0);\n\t\tao2_ref(bridge_channel, -1);\n\t}\n}\n", "bug_type": null, "idx": 1210}
{"project": "Asterisk", "target": 0, "func": "static struct transfer_data *transfer_data_alloc(struct ast_sip_session *session, const char *target)\n{\n\tstruct transfer_data *trnf_data = ao2_alloc(sizeof(*trnf_data), transfer_data_destroy);\n\tif (!trnf_data) {\n\t\treturn NULL;\n\t}\n\tif (!(trnf_data->target = ast_strdup(target))) {\n\t\tao2_ref(trnf_data, -1);\n\t\treturn NULL;\n\t}\n\tao2_ref(session, +1);\n\ttrnf_data->session = session;\n\treturn trnf_data;\n}\n", "bug_type": null, "idx": 1211}
{"project": "Asterisk", "target": 0, "func": "static void delete_file(struct phoneprov_file *file)\n{\n\tast_string_field_free_memory(file);\n\tast_free(file);\n}\n", "bug_type": null, "idx": 1212}
{"project": "Asterisk", "target": 0, "func": "#if defined(HAVE_PRI)\nstatic int action_pri_debug_file_unset(struct mansession *s, const struct message *m)\n{\n\tast_mutex_lock(&pridebugfdlock);\n\tif (pridebugfd >= 0) {\n\t\tclose(pridebugfd);\n\t}\n\tpridebugfd = -1;\n\tast_mutex_unlock(&pridebugfdlock);\n\tastman_send_ack(s, m, \"PRI Debug output to file disabled\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 1213}
{"project": "Asterisk", "target": 0, "func": "void io_context_destroy(struct io_context *ioc)\n{\n\t\n\tif (ioc->fds)\n\t\tast_free(ioc->fds);\n\tif (ioc->ior)\n\t\tast_free(ioc->ior);\n\tast_free(ioc);\n}\n", "bug_type": null, "idx": 1214}
{"project": "Asterisk", "target": 0, "func": "static int sched_order_8_cb(const void *data)\n{\n\tsched_order_check((void *) data, 8);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1215}
{"project": "Asterisk", "target": 0, "func": "\nstatic void codec_shutdown(void)\n{\n\tast_cli_unregister_multiple(codec_cli, ARRAY_LEN(codec_cli));\n\tao2_cleanup(codecs);\n\tcodecs = NULL;\n}\n", "bug_type": null, "idx": 1216}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245H235Mode_mediaMode (OOCTXT* pctxt, H245H235Mode_mediaMode* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 4);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 3);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245VideoMode (pctxt, pvalue->u.videoMode);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245AudioMode (pctxt, pvalue->u.audioMode);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = asn1PE_H245DataMode (pctxt, pvalue->u.dataMode);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 5);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1217}
{"project": "Asterisk", "target": 0, "func": "static int unistim_fixup(struct ast_channel *oldchan, struct ast_channel *newchan)\n{\n\tstruct unistim_subchannel *p = ast_channel_tech_pvt(newchan);\n\tstruct unistim_line *l = p->parent;\n\tast_mutex_lock(&p->lock);\n\tast_debug(1, \"New owner for channel USTM/%s@%s-%u is %s\\n\", l->name,\n\t\t\tl->parent->name, p->subtype, ast_channel_name(newchan));\n\tif (p->owner != oldchan) {\n\t\tast_log(LOG_WARNING, \"old channel wasn't %s (%p) but was %s (%p)\\n\",\n\t\t\t\tast_channel_name(oldchan), oldchan, ast_channel_name(p->owner), p->owner);\n\t\tast_mutex_unlock(&p->lock);\n\t\treturn -1;\n\t}\n\tunistim_set_owner(p, newchan);\n\tast_mutex_unlock(&p->lock);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1218}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *cel_expected_events = NULL;\nstatic struct ast_event *ao2_dup_event(const struct ast_event *event)\n{\n\tstruct ast_event *event_dup;\n\tuint16_t event_len;\n\tevent_len = ast_event_get_size(event);\n\tevent_dup = ao2_alloc(event_len, NULL);\n\tif (!event_dup) {\n\t\treturn NULL;\n\t}\n\tmemcpy(event_dup, event, event_len);\n\treturn event_dup;\n}\n", "bug_type": null, "idx": 1219}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225UUIEsRequested (OOCTXT* pctxt, H225UUIEsRequested* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   \n   invokeStartElement (pctxt, \"setup\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->setup);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->setup);\n   invokeEndElement (pctxt, \"setup\", -1);\n   \n   invokeStartElement (pctxt, \"callProceeding\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->callProceeding);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->callProceeding);\n   invokeEndElement (pctxt, \"callProceeding\", -1);\n   \n   invokeStartElement (pctxt, \"connect\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->connect);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->connect);\n   invokeEndElement (pctxt, \"connect\", -1);\n   \n   invokeStartElement (pctxt, \"alerting\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->alerting);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->alerting);\n   invokeEndElement (pctxt, \"alerting\", -1);\n   \n   invokeStartElement (pctxt, \"information\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->information);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->information);\n   invokeEndElement (pctxt, \"information\", -1);\n   \n   invokeStartElement (pctxt, \"releaseComplete\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->releaseComplete);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->releaseComplete);\n   invokeEndElement (pctxt, \"releaseComplete\", -1);\n   \n   invokeStartElement (pctxt, \"facility\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->facility);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->facility);\n   invokeEndElement (pctxt, \"facility\", -1);\n   \n   invokeStartElement (pctxt, \"progress\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->progress);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->progress);\n   invokeEndElement (pctxt, \"progress\", -1);\n   \n   invokeStartElement (pctxt, \"empty\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->empty);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->empty);\n   invokeEndElement (pctxt, \"empty\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 4 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.statusPresent = 1;\n                     invokeStartElement (pctxt, \"status\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->status);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->status);\n                     invokeEndElement (pctxt, \"status\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.statusInquiryPresent = 1;\n                     invokeStartElement (pctxt, \"statusInquiry\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->statusInquiry);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->statusInquiry);\n                     invokeEndElement (pctxt, \"statusInquiry\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.setupAcknowledgePresent = 1;\n                     invokeStartElement (pctxt, \"setupAcknowledge\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->setupAcknowledge);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->setupAcknowledge);\n                     invokeEndElement (pctxt, \"setupAcknowledge\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.notifyPresent = 1;\n                     invokeStartElement (pctxt, \"notify\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->notify);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->notify);\n                     invokeEndElement (pctxt, \"notify\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1220}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tast_channel_unregister(&alsa_tech);\n\tast_cli_unregister_multiple(cli_alsa, ARRAY_LEN(cli_alsa));\n\tif (alsa.icard)\n\t\tsnd_pcm_close(alsa.icard);\n\tif (alsa.ocard)\n\t\tsnd_pcm_close(alsa.ocard);\n\tif (alsa.owner)\n\t\tast_softhangup(alsa.owner, AST_SOFTHANGUP_APPUNLOAD);\n\tif (alsa.owner)\n\t\treturn -1;\n\tao2_cleanup(alsa_tech.capabilities);\n\talsa_tech.capabilities = NULL;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1221}
{"project": "Asterisk", "target": 0, "func": "int ast_shutting_down(void)\n{\n\treturn shutdown_pending;\n}\n", "bug_type": null, "idx": 1222}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hfp_send_sms_text(struct hfp_pvt *hfp, const char *message)\n{\n\tchar cmd[162];\n\tsnprintf(cmd, sizeof(cmd), \"%.160s\\x1a\", message);\n\treturn rfcomm_write(hfp->rsock, cmd);\n}\n", "bug_type": null, "idx": 1223}
{"project": "Asterisk", "target": 0, "func": "static void kqueue_daemon_freestate(struct state *sp)\n{\n\tstruct kevent kev;\n\tstruct timespec no_wait = { 0, 1 };\n\t\n\tif (sp->fd > -1) {\n\t\t\n\t\tEV_SET(&kev, sp->fd, EVFILT_VNODE, EV_DELETE, 0, 0, NULL);\n\t\tkevent(queue_fd, &kev, 1, NULL, 0, &no_wait);\n\t}\n#ifdef HAVE_O_SYMLINK\n\tif (sp->fds > -1) {\n\t\t\n\t\tEV_SET(&kev, sp->fds, EVFILT_VNODE, EV_DELETE, 0, 0, NULL);\n\t\tkevent(queue_fd, &kev, 1, NULL, 0, &no_wait);\n\t}\n#else\n\tif (sp->dir) {\n\t\t\n\t\tEV_SET(&kev, dirfd(sp->dir), EVFILT_VNODE, EV_DELETE, 0, 0, NULL);\n\t\tkevent(queue_fd, &kev, 1, NULL, 0, &no_wait);\n\t}\n#endif\n}\n", "bug_type": null, "idx": 1224}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void poll_mailbox(struct mailbox_mapping *mm)\n{\n\tchar buf[1024];\n\tunsigned int state;\n\tsnprintf(buf, sizeof(buf), \"%s@%s\", mm->mailbox, mm->context);\n\tstate = !!ast_app_has_voicemail(mm->mailbox, NULL);\n\tif (state != mm->cur_state) {\n\t\tif (state)\n\t\t\tast_smdi_mwi_set(mm->iface, mm->smdi);\n\t\telse\n\t\t\tast_smdi_mwi_unset(mm->iface, mm->smdi);\n\t\tmm->cur_state = state;\n\t}\n}\n", "bug_type": null, "idx": 1225}
{"project": "Asterisk", "target": 0, "func": "\nstatic int pvt_cause_cmp_fn(void *obj, void *vstr, int flags)\n{\n\tstruct ast_control_pvt_cause_code *pc = obj;\n\tchar *str = ast_tech_to_upper(ast_strdupa(vstr));\n\tchar *pc_str = ast_tech_to_upper(ast_strdupa(pc->chan_name));\n\treturn !strcmp(pc_str, str) ? CMP_MATCH | CMP_STOP : 0;\n}\n", "bug_type": null, "idx": 1226}
{"project": "Asterisk", "target": 0, "func": "void misdn_split_conf(struct misdn_bchannel *bc, int conf_id)\n{\n\tbc_state_change(bc,BCHAN_ACTIVATED);\n\tmanager_ph_control(bc, CMX_RECEIVE_ON, 0);\n\tmanager_ph_control(bc, CMX_CONF_SPLIT, conf_id);\n\tcb_log(4,bc->port, \"Splitting bc:%x in conf:%d\\n\",bc->addr,conf_id);\n}\n", "bug_type": null, "idx": 1227}
{"project": "Asterisk", "target": 0, "func": "int iax_provision_version(unsigned int *version, const char *template, int force)\n{\n\tchar tmp[80] = \"\";\n\tstruct iax_ie_data ied;\n\tint ret=0;\n\tmemset(&ied, 0, sizeof(ied));\n\tast_mutex_lock(&provlock);\n\tif (ast_db_get(\"iax/provisioning/cache\", template, tmp, sizeof(tmp))) {\n\t\tast_log(LOG_ERROR, \"ast_db_get failed to retrieve iax/provisioning/cache/%s\\n\", template);\n\t}\n\tif (sscanf(tmp, \"v%30x\", version) != 1) {\n\t\tif (strcmp(tmp, \"u\")) {\n\t\t\tret = iax_provision_build(&ied, version, template, force);\n\t\t\tif (ret)\n\t\t\t\tast_debug(1, \"Unable to create provisioning packet for '%s'\\n\", template);\n\t\t} else\n\t\t\tret = -1;\n\t} else\n\t\tast_debug(1, \"Retrieved cached version '%s' = '%08x'\\n\", tmp, *version);\n\tast_mutex_unlock(&provlock);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1228}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_adsicpe_set(struct ast_channel *chan, enum ast_channel_adsicpe value)\n{\n\tchan->adsicpe = value;\n}\n", "bug_type": null, "idx": 1229}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tstruct ast_config *cfg;\n\tstruct ast_flags cfg_flags = { 0, };\n\tif (aco_info_init(&cfg_info)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\taco_option_register(&cfg_info, \"hosts\", ACO_EXACT, global_options, \"system\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct unbound_global_config, hosts));\n\taco_option_register(&cfg_info, \"resolv\", ACO_EXACT, global_options, \"system\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct unbound_global_config, resolv));\n\taco_option_register_custom(&cfg_info, \"nameserver\", ACO_EXACT, global_options, \"\", custom_nameserver_handler, 0);\n\taco_option_register(&cfg_info, \"debug\", ACO_EXACT, global_options, \"0\", OPT_UINT_T, 0, FLDSET(struct unbound_global_config, debug));\n\taco_option_register(&cfg_info, \"ta_file\", ACO_EXACT, global_options, \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct unbound_global_config, ta_file));\n\t\n\tcfg = ast_config_load(resolver_unbound_conf.filename, cfg_flags);\n\tif (!cfg) {\n\t\tif (unbound_config_apply_default()) {\n\t\t\tunload_module();\n\t\t\treturn AST_MODULE_LOAD_DECLINE;\n\t\t}\n\t} else {\n\t\tast_config_destroy(cfg);\n\t\tif (aco_process_config(&cfg_info, 0) == ACO_PROCESS_ERROR) {\n\t\t\tunload_module();\n\t\t\treturn AST_MODULE_LOAD_DECLINE;\n\t\t}\n\t}\n\tast_dns_resolver_register(&unbound_resolver);\n\tast_module_shutdown_ref(ast_module_info->self);\n\tAST_TEST_REGISTER(resolve_sync);\n\tAST_TEST_REGISTER(resolve_async);\n\tAST_TEST_REGISTER(resolve_sync_off_nominal);\n\tAST_TEST_REGISTER(resolve_async_off_nominal);\n\tAST_TEST_REGISTER(resolve_cancel_off_nominal);\n\tAST_TEST_REGISTER(resolve_naptr);\n\tAST_TEST_REGISTER(resolve_srv);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1230}
{"project": "Asterisk", "target": 0, "func": "static struct ast_calendar *unref_calendar(struct ast_calendar *cal)\n{\n\tao2_ref(cal, -1);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1231}
{"project": "Asterisk", "target": 0, "func": "void toggle_enabled(struct member *mem)\n{\n\tif ((mem->depsfailed == HARD_FAILURE) || (mem->conflictsfailed == HARD_FAILURE) || (mem->is_separator))\n\t\treturn;\n\tif (!mem->enabled)\n\t\tenable_member(mem);\n\telse\n\t\tmem->enabled = 0;\n\tprint_debug(\"3- changed %s to %d\\n\", mem->name, mem->enabled);\n\tmem->was_defaulted = 0;\n\tchanges_made++;\n\twhile (calc_dep_failures(1, 0) || calc_conflict_failures(1, 0));\n}\n", "bug_type": null, "idx": 1232}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int fileexists_test(const char *filename, const char *fmt, const char *lang,\n\t\t\t   char *buf, int buflen, struct ast_format_cap *result_cap)\n{\n\tif (buf == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ast_media_cache_retrieve(filename, NULL, buf, buflen)) {\n\t\treturn filehelper(buf, result_cap, NULL, ACTION_EXISTS);\n\t}\n\tif (ast_language_is_prefix && !is_absolute_path(filename)) { \n\t\tif (lang) {\n\t\t\tsnprintf(buf, buflen, \"%s/%s\", lang, filename);\n\t\t} else {\n\t\t\tsnprintf(buf, buflen, \"%s\", filename);\n\t\t}\n\t} else { \n\t\tstrcpy(buf, filename);\t\n\t\tif (lang) {\n\t\t\t\n\t\t\tconst char *c = strrchr(filename, '/');\n\t\t\tint offset = c ? c - filename + 1 : 0;\t\n\t\t\tsnprintf(buf + offset, buflen - offset, \"%s/%s\", lang, filename + offset);\n\t\t}\n\t}\n\treturn filehelper(buf, result_cap, fmt, ACTION_EXISTS);\n}\n", "bug_type": null, "idx": 1233}
{"project": "Asterisk", "target": 0, "func": "int bridge_channel_internal_queue_blind_transfer(struct ast_channel *transferee,\n\t\tconst char *exten, const char *context,\n\t\ttransfer_channel_cb new_channel_cb, void *user_data)\n{\n\tRAII_VAR(struct ast_bridge_channel *, transferee_bridge_channel, NULL, ao2_cleanup);\n\tstruct blind_transfer_data blind_data;\n\tast_channel_lock(transferee);\n\ttransferee_bridge_channel = ast_channel_get_bridge_channel(transferee);\n\tast_channel_unlock(transferee);\n\tif (!transferee_bridge_channel) {\n\t\treturn -1;\n\t}\n\tif (new_channel_cb) {\n\t\tnew_channel_cb(transferee, user_data, AST_BRIDGE_TRANSFER_SINGLE_PARTY);\n\t}\n\tast_copy_string(blind_data.exten, exten, sizeof(blind_data.exten));\n\tast_copy_string(blind_data.context, context, sizeof(blind_data.context));\n\treturn bridge_channel_queue_action_data(transferee_bridge_channel,\n\t\tBRIDGE_CHANNEL_ACTION_BLIND_TRANSFER, &blind_data, sizeof(blind_data));\n}\n", "bug_type": null, "idx": 1234}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *stasis_message_to_json(\n\tstruct stasis_message *msg,\n\tstruct stasis_message_sanitizer *sanitize)\n{\n\treturn INVOKE_VIRTUAL(to_json, msg, sanitize);\n}\n", "bug_type": null, "idx": 1235}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_channel_run_app(struct ast_bridge_channel *bridge_channel, const char *app_name, const char *app_args, const char *moh_class)\n{\n\tif (moh_class) {\n\t\tast_bridge_channel_write_hold(bridge_channel, moh_class);\n\t}\n\tif (run_app_helper(bridge_channel->chan, app_name, S_OR(app_args, \"\"))) {\n\t\t\n\t\tast_bridge_channel_kick(bridge_channel, AST_CAUSE_NORMAL_CLEARING);\n\t}\n\tif (moh_class) {\n\t\tast_bridge_channel_write_unhold(bridge_channel);\n\t}\n}\n", "bug_type": null, "idx": 1236}
{"project": "Asterisk", "target": 0, "func": "\nstatic void sorcery_object_wizard_destructor(void *obj)\n{\n\tstruct ast_sorcery_object_wizard *object_wizard = obj;\n\tif (object_wizard->data && object_wizard->wizard->callbacks.close) {\n\t\tobject_wizard->wizard->callbacks.close(object_wizard->data);\n\t}\n\tif (object_wizard->wizard) {\n\t\tast_module_unref(object_wizard->wizard->callbacks.module);\n\t}\n\tao2_cleanup(object_wizard->wizard);\n}\n", "bug_type": null, "idx": 1237}
{"project": "Asterisk", "target": 0, "func": "static int set_var_to_vl(const void *obj, struct ast_variable **fields)\n{\n\tconst struct ast_sip_endpoint *endpoint = obj;\n\tif (endpoint->channel_vars) {\n\t\t*fields = ast_variables_dup(endpoint->channel_vars);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1238}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_sched_bench(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_sched_context *con;\n\tstruct timeval start;\n\tunsigned int num, i;\n\tint *sched_ids = NULL;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"sched benchmark\";\n\t\te->usage = \"\"\n\t\t\t\"Usage: sched benchmark <num>\\n\"\n\t\t\t\"\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != e->args + 1) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (sscanf(a->argv[e->args], \"%u\", &num) != 1) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (!(con = ast_sched_context_create())) {\n\t\tast_cli(a->fd, \"Test failed - could not create scheduler context\\n\");\n\t\treturn CLI_FAILURE;\n\t}\n\tif (!(sched_ids = ast_malloc(sizeof(*sched_ids) * num))) {\n\t\tast_cli(a->fd, \"Test failed - memory allocation failure\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tast_cli(a->fd, \"Testing ast_sched_add() performance - timing how long it takes \"\n\t\t\t\"to add %u entries at random time intervals from 0 to 60 seconds\\n\", num);\n\tstart = ast_tvnow();\n\tfor (i = 0; i < num; i++) {\n\t\tlong when = labs(ast_random()) % 60000;\n\t\tif ((sched_ids[i] = ast_sched_add(con, when, sched_cb, NULL)) == -1) {\n\t\t\tast_cli(a->fd, \"Test failed - sched_add returned -1\\n\");\n\t\t\tgoto return_cleanup;\n\t\t}\n\t}\n\tast_cli(a->fd, \"Test complete - %\" PRIi64 \" us\\n\", ast_tvdiff_us(ast_tvnow(), start));\n\tast_cli(a->fd, \"Testing ast_sched_del() performance - timing how long it takes \"\n\t\t\t\"to delete %u entries with random time intervals from 0 to 60 seconds\\n\", num);\n\tstart = ast_tvnow();\n\tfor (i = 0; i < num; i++) {\n\t\tif (ast_sched_del(con, sched_ids[i]) == -1) {\n\t\t\tast_cli(a->fd, \"Test failed - sched_del returned -1\\n\");\n\t\t\tgoto return_cleanup;\n\t\t}\n\t}\n\tast_cli(a->fd, \"Test complete - %\" PRIi64 \" us\\n\", ast_tvdiff_us(ast_tvnow(), start));\nreturn_cleanup:\n\tast_sched_context_destroy(con);\n\tif (sched_ids) {\n\t\tast_free(sched_ids);\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1239}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void misdn_PresentedNumberUnscreened_fill(struct FacPresentedNumberUnscreened *presented, const struct misdn_party_id *id)\n{\n\tpresented->Type = misdn_to_PresentedNumberUnscreened_type(id->presentation, id->number[0] ? 1 : 0);\n\tmisdn_PartyNumber_fill(&presented->Unscreened, id);\n}\n", "bug_type": null, "idx": 1240}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct features_config *get_feature_ds(struct ast_channel *chan)\n{\n\tRAII_VAR(struct features_config *, orig, NULL, ao2_cleanup);\n\tstruct features_config *cfg;\n\tstruct ast_datastore *ds;\n\tif ((ds = ast_channel_datastore_find(chan, &feature_ds_info, NULL))) {\n\t\tcfg = ds->data;\n\t\tao2_ref(cfg, +1);\n\t\treturn cfg;\n\t}\n\torig = ao2_global_obj_ref(globals);\n\tif (!orig) {\n\t\treturn NULL;\n\t}\n\tcfg = features_config_dup(orig);\n\tif (!cfg) {\n\t\treturn NULL;\n\t}\n\tif (!(ds = ast_datastore_alloc(&feature_ds_info, NULL))) {\n\t\tao2_cleanup(cfg);\n\t\treturn NULL;\n\t}\n\t\n\tao2_ref(cfg, +1);\n\tds->data = cfg;\n\tast_channel_datastore_add(chan, ds);\n\treturn cfg;\n}\n", "bug_type": null, "idx": 1241}
{"project": "Asterisk", "target": 0, "func": "\nvi_repeat_next_char(EditLine *el, int c)\n{\n\tif (el->el_search.chacha == 0)\n\t\treturn (CC_ERROR);\n\treturn (el->el_search.chadir == CHAR_FWD\n\t    ? cv_csearch_fwd(el, el->el_search.chacha,\n\t\tel->el_state.argument, 0)\n\t    : cv_csearch_back(el, el->el_search.chacha,\n\t\tel->el_state.argument, 0));\n}\n", "bug_type": null, "idx": 1242}
{"project": "Asterisk", "target": 0, "func": "\nstatic int begin_dial(struct ast_dial *dial, struct ast_channel *chan, int async)\n{\n\tstruct ast_dial_channel *channel = NULL;\n\tint success = 0;\n\tchar *predial_string = dial->options[AST_DIAL_OPTION_PREDIAL];\n\t\n\tAST_LIST_LOCK(&dial->channels);\n\tAST_LIST_TRAVERSE(&dial->channels, channel, list) {\n\t\tsuccess += begin_dial_channel(channel, chan, async, predial_string, NULL);\n\t}\n\tAST_LIST_UNLOCK(&dial->channels);\n\t\n\treturn success;\n}\n", "bug_type": null, "idx": 1243}
{"project": "Asterisk", "target": 0, "func": "static int action_messagesend(struct mansession *s, const struct message *m)\n{\n\tconst char *to = ast_strdupa(astman_get_header(m, \"To\"));\n\tconst char *from = astman_get_header(m, \"From\");\n\tconst char *body = astman_get_header(m, \"Body\");\n\tconst char *base64body = astman_get_header(m, \"Base64Body\");\n\tchar base64decoded[1301] = { 0, };\n\tchar *tech_name = NULL;\n\tstruct ast_variable *vars = NULL;\n\tstruct ast_variable *data = NULL;\n\tconst struct ast_msg_tech *msg_tech;\n\tstruct ast_msg *msg;\n\tint res = -1;\n\tif (ast_strlen_zero(to)) {\n\t\tastman_send_error(s, m, \"No 'To' address specified.\");\n\t\treturn 0;\n\t}\n\tif (!ast_strlen_zero(base64body)) {\n\t\tast_base64decode((unsigned char *) base64decoded, base64body, sizeof(base64decoded) - 1);\n\t\tbody = base64decoded;\n\t}\n\ttech_name = ast_strdupa(to);\n\ttech_name = strsep(&tech_name, \":\");\n\tast_rwlock_rdlock(&msg_techs_lock);\n\tmsg_tech = msg_find_by_tech_name(tech_name);\n\tif (!msg_tech) {\n\t\tast_rwlock_unlock(&msg_techs_lock);\n\t\tastman_send_error(s, m, \"Message technology not found.\");\n\t\treturn 0;\n\t}\n\tif (!(msg = ast_msg_alloc())) {\n\t\tast_rwlock_unlock(&msg_techs_lock);\n\t\tastman_send_error(s, m, \"Internal failure\\n\");\n\t\treturn 0;\n\t}\n\tdata = astman_get_variables_order(m, ORDER_NATURAL);\n\tfor (vars = data; vars; vars = vars->next) {\n\t\tast_msg_set_var_outbound(msg, vars->name, vars->value);\n\t}\n\tast_msg_set_body(msg, \"%s\", body);\n\tres = msg_tech->msg_send(msg, S_OR(to, \"\"), S_OR(from, \"\"));\n\tast_rwlock_unlock(&msg_techs_lock);\n\tast_variables_destroy(vars);\n\tao2_ref(msg, -1);\n\tif (res) {\n\t\tastman_send_error(s, m, \"Message failed to send.\");\n\t} else {\n\t\tastman_send_ack(s, m, \"Message successfully sent\");\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1244}
{"project": "Asterisk", "target": 0, "func": "void printRealValue (double value);\nvoid initializePrintHandler(EventHandler *printHandler, char * varname)\n{\n   printHandler->startElement = &printStartElement;\n   printHandler->endElement = &printEndElement;\n   printHandler->boolValue = &printBoolValue;\n   printHandler->intValue = &printIntValue;\n   printHandler->uIntValue = &printuIntValue ;\n   printHandler->bitStrValue = &printBitStrValue;\n   printHandler->octStrValue = &printOctStrValue;\n   printHandler->charStrValue = &printCharStrValue;\n   printHandler->charStr16BitValue = &printCharStr16BitValue ;\n   printHandler->nullValue = &printNullValue;\n   printHandler->oidValue = &printOidValue;\n   printHandler->enumValue = &printEnumValue;\n   printHandler->openTypeValue = &printOpenTypeValue;\n   pVarName = varname;\n   ast_mutex_lock(&printlock);\n   OOTRACEDBGB2(\"%s = {\\n\", pVarName);\n   gIndentSpaces += 3;\n}\nvoid finishPrint()\n{\n   OOTRACEDBGB1 (\"}\\n\");\n   gIndentSpaces -= 3;\n   if (gIndentSpaces != 0) {\n      OOTRACEDBGB1 (\"ERROR: unbalanced structure\\n\");\n   }\n   gIndentSpaces = 0;\n   ast_mutex_unlock(&printlock);\n}\n", "bug_type": null, "idx": 1245}
{"project": "Asterisk", "target": 0, "func": "int ooCapabilityDisableDTMFCISCO(OOH323CallData *call)\n{\n   if(!call){\n      gH323ep.dtmfmode ^= OO_CAP_DTMF_CISCO;\n      OOTRACEINFO1(\"Disabled RTP/CISCO DTMF capability for end-point\\n\");\n   }\n   else{\n      call->dtmfmode ^= OO_CAP_DTMF_CISCO;\n      OOTRACEINFO3(\"Disabled RTP/CISCO DTMF capability for (%s, %s)\\n\", \n                    call->callType, call->callToken);\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1246}
{"project": "Asterisk", "target": 0, "func": "static void dec_ie_channel_id(unsigned char *p, Q931_info_t *qi, int *exclusive, int *channel, int nt, struct misdn_bchannel *bc)\n{\n\tstruct misdn_stack *stack=get_stack_by_bc(bc);\n\tint pri =stack->pri;\n\t*exclusive = -1;\n\t*channel = -1;\n\tif (!nt)\n\t{\n\t\tp = NULL;\n\t\tif (qi->QI_ELEMENT(channel_id))\n\t\t\tp = (unsigned char *)qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(channel_id) + 1;\n\t}\n\tif (!p)\n\t\treturn;\n\tif (p[0] < 1)\n\t{\n\t\tprintf(\"%s: ERROR: IE too short (%d).\\n\", __FUNCTION__, p[0]);\n\t\treturn;\n\t}\n\tif (p[1] & 0x40)\n\t{\n\t\tprintf(\"%s: ERROR: refering to channels of other interfaces is not supported.\\n\", __FUNCTION__);\n\t\treturn;\n\t}\n\tif (p[1] & 0x04)\n\t{\n\t\tprintf(\"%s: ERROR: using d-channel is not supported.\\n\", __FUNCTION__);\n\t\treturn;\n\t}\n\t*exclusive = (p[1]&0x08) >> 3;\n\tif (!pri)\n\t{\n\t\t\n\t\tif (p[1] & 0x20)\n\t\t{\n\t\t\tprintf(\"%s: ERROR: extended channel ID with non PRI interface.\\n\", __FUNCTION__);\n\t\t\treturn;\n\t\t}\n\t\t*channel = p[1] & 0x03;\n\t\tif (*channel == 3)\n\t\t\t*channel = 0xff;\n\t} else\n\t{\n\t\t\n\t\tif (p[0] < 1)\n\t\t{\n\t\t\tprintf(\"%s: ERROR: IE too short for PRI (%d).\\n\", __FUNCTION__, p[0]);\n\t\t\treturn;\n\t\t}\n\t\tif (!(p[1] & 0x20))\n\t\t{\n\t\t\tprintf(\"%s: ERROR: basic channel ID with PRI interface.\\n\", __FUNCTION__);\n\t\t\treturn;\n\t\t}\n\t\tif ((p[1]&0x03) == 0x00)\n\t\t{\n\t\t\t\n\t\t\t*channel = 0;\n\t\t\treturn;\n\t\t}\n\t\tif ((p[1]&0x03) == 0x03)\n\t\t{\n\t\t\t\n\t\t\t*channel = 0xff;\n\t\t\treturn;\n\t\t}\n\t\tif (p[0] < 3)\n\t\t{\n\t\t\tprintf(\"%s: ERROR: IE too short for PRI with channel(%d).\\n\", __FUNCTION__, p[0]);\n\t\t\treturn;\n\t\t}\n\t\tif (p[2] & 0x10)\n\t\t{\n\t\t\tprintf(\"%s: ERROR: channel map not supported.\\n\", __FUNCTION__);\n\t\t\treturn;\n\t\t}\n\t\t*channel = p[3] & 0x7f;\n\t\tif ( (*channel<1) | (*channel==16) | (*channel>31))\n\t\t{\n\t\t\tprintf(\"%s: ERROR: PRI interface channel out of range (%d).\\n\", __FUNCTION__, *channel);\n\t\t\treturn;\n\t\t}\n\n\t}\n\tif (MISDN_IE_DEBG) printf(\"    exclusive=%d channel=%d\\n\", *exclusive, *channel);\n}\n", "bug_type": null, "idx": 1247}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int ast_add_extension_nolock(const char *context, int replace, const char *extension,\n\tint priority, const char *label, const char *callerid,\n\tconst char *application, void *data, void (*datad)(void *), const char *registrar)\n{\n\tint ret = -1;\n\tstruct ast_context *c;\n\tc = find_context(context);\n\tif (c) {\n\t\tret = ast_add_extension2_lockopt(c, replace, extension, priority, label, callerid,\n\t\t\tapplication, data, datad, registrar, NULL, 0, 1);\n\t}\n\treturn ret;\n}\n */\nstatic int ast_add_extension_nolock(const char *context, int replace, const char *extension,\n\tint priority, const char *label, const char *callerid,\n\tconst char *application, void *data, void (*datad)(void *), const char *registrar)\n{\n\tint ret = -1;\n\tstruct ast_context *c;\n\tc = find_context(context);\n\tif (c) {\n\t\tret = ast_add_extension2_lockopt(c, replace, extension, priority, label, callerid,\n\t\t\tapplication, data, datad, registrar, NULL, 0, 1);\n\t}\n", "bug_type": null, "idx": 1248}
{"project": "Asterisk", "target": 0, "func": "int ast_bucket_observer_add(const struct ast_sorcery_observer *callbacks)\n{\n\treturn ast_sorcery_observer_add(bucket_sorcery, \"bucket\", callbacks);\n}\n", "bug_type": null, "idx": 1249}
{"project": "Asterisk", "target": 0, "func": "static int write_entry_history(struct unistimsession *pte, FILE * f, char c, char *line1)\n{\n\tif (fwrite(&c, 1, 1, f) != 1) {\n\t\tdisplay_last_error(\"Unable to write history log header.\");\n\t\treturn -1;\n\t}\n\tif (fwrite(line1, TEXT_LENGTH_MAX, 1, f) != 1) {\n\t\tdisplay_last_error(\"Unable to write history entry - date.\");\n\t\treturn -1;\n\t}\n\tif (fwrite(pte->device->lst_cid, TEXT_LENGTH_MAX, 1, f) != 1) {\n\t\tdisplay_last_error(\"Unable to write history entry - callerid.\");\n\t\treturn -1;\n\t}\n\tif (fwrite(pte->device->lst_cnm, TEXT_LENGTH_MAX, 1, f) != 1) {\n\t\tdisplay_last_error(\"Unable to write history entry - callername.\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1250}
{"project": "Asterisk", "target": 0, "func": "int ast_sockaddr_cidr_bits(const struct ast_sockaddr *sa)\n{\n\tstruct ast_sockaddr sa_ipv4;\n\tconst struct ast_sockaddr *sa_tmp;\n\tint bits = 0;\n\tint bytes;\n\tint i;\n\tint j;\n\tchar *addr;\n\tif (ast_sockaddr_isnull(sa)) {\n\t\treturn 0;\n\t}\n\tif (ast_sockaddr_ipv4_mapped(sa, &sa_ipv4)) {\n\t\tsa_tmp = &sa_ipv4;\n\t} else {\n\t\tsa_tmp = sa;\n\t}\n\tbytes = sa_tmp->len;\n\taddr = ((struct sockaddr *)&sa_tmp->ss)->sa_data;\n\tfor (i = 0; i < bytes ; ++i) {\n\t\tfor (j = 0; j < 8; ++j) {\n\t\t\tif ((addr[i] >> j) & 1) {\n\t\t\t\tbits++;\n\t\t\t}\n\t\t}\n\t}\n\treturn bits;\n}\n", "bug_type": null, "idx": 1251}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic struct minivm_account *find_user_realtime(const char *domain, const char *username)\n{\n\tstruct ast_variable *var;\n\tstruct minivm_account *retval;\n\tchar name[MAXHOSTNAMELEN];\n\tretval = mvm_user_alloc();\n\tif (!retval)\n\t\treturn NULL;\n\tif (username) \n\t\tast_copy_string(retval->username, username, sizeof(retval->username));\n\tpopulate_defaults(retval);\n\tvar = ast_load_realtime(\"minivm\", \"username\", username, \"domain\", domain, SENTINEL);\n\tif (!var) {\n\t\tast_free(retval);\n\t\treturn NULL;\n\t}\n\tsnprintf(name, sizeof(name), \"%s@%s\", username, domain);\n\tcreate_vmaccount(name, var, TRUE);\n\tast_variables_destroy(var);\n\treturn retval;\n}\n", "bug_type": null, "idx": 1252}
{"project": "Asterisk", "target": 0, "func": "struct ao2_container *ast_mwi_mailbox_get_all(void)\n{\n\treturn ast_sorcery_retrieve_by_fields(mwi_sorcery, MWI_MAILBOX_TYPE,\n\t\tAST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);\n}\n", "bug_type": null, "idx": 1253}
{"project": "Asterisk", "target": 0, "func": "static int analog_set_echocanceller(struct analog_pvt *p, int enable)\n{\n\tif (analog_callbacks.set_echocanceller) {\n\t\treturn analog_callbacks.set_echocanceller(p->chan_pvt, enable);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1254}
{"project": "Asterisk", "target": 0, "func": "void invokeCharStr16BitValue (OOCTXT* pctxt, ASN1UINT nchars, \n                              ASN116BITCHAR* data)\n{\n   if (0 != pctxt->pEventHandler) {\n      pctxt->pEventHandler->charStr16BitValue (nchars, data);\n   }\n}\n", "bug_type": null, "idx": 1255}
{"project": "Asterisk", "target": 0, "func": "static int sip_publication_respond(struct ast_sip_publication *pub, int status_code,\n\t\tpjsip_rx_data *rdata)\n{\n\tpjsip_tx_data *tdata;\n\tpjsip_transaction *tsx;\n\tif (pjsip_endpt_create_response(ast_sip_get_pjsip_endpoint(), rdata, status_code, NULL, &tdata) != PJ_SUCCESS) {\n\t\treturn -1;\n\t}\n\tif (PJSIP_IS_STATUS_IN_CLASS(status_code, 200)) {\n\t\tchar buf[30];\n\t\tsnprintf(buf, sizeof(buf), \"%d\", pub->entity_tag);\n\t\tast_sip_add_header(tdata, \"SIP-ETag\", buf);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", pub->expires);\n\t\tast_sip_add_header(tdata, \"Expires\", buf);\n\t}\n\tif (pjsip_tsx_create_uas(&pubsub_module, rdata, &tsx) != PJ_SUCCESS) {\n\t\tpjsip_tx_data_dec_ref(tdata);\n\t\treturn -1;\n\t}\n\tpjsip_tsx_recv_msg(tsx, rdata);\n\tif (pjsip_tsx_send_msg(tsx, tdata) != PJ_SUCCESS) {\n\t\tpjsip_tx_data_dec_ref(tdata);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1256}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_get_docs(const char *uri, const char *prefix, struct ast_variable *headers,\n\t\t\t  struct ast_ari_response *response)\n{\n\tRAII_VAR(struct ast_str *, absolute_path_builder, NULL, ast_free);\n\tRAII_VAR(char *, absolute_api_dirname, NULL, ast_std_free);\n\tRAII_VAR(char *, absolute_filename, NULL, ast_std_free);\n\tstruct ast_json *obj = NULL;\n\tstruct ast_variable *host = NULL;\n\tstruct ast_json_error error = {};\n\tstruct stat file_stat;\n\tast_debug(3, \"%s(%s)\\n\", __func__, uri);\n\tabsolute_path_builder = ast_str_create(80);\n\tif (absolute_path_builder == NULL) {\n\t\tast_ari_response_alloc_failed(response);\n\t\treturn;\n\t}\n\t\n\tast_str_append(&absolute_path_builder, 0, \"%s\", ast_config_AST_DATA_DIR);\n\tast_str_append(&absolute_path_builder, 0, \"/rest-api/\");\n\tabsolute_api_dirname = realpath(ast_str_buffer(absolute_path_builder), NULL);\n\tif (absolute_api_dirname == NULL) {\n\t\tast_log(LOG_ERROR, \"Error determining real directory for rest-api\\n\");\n\t\tast_ari_response_error(\n\t\t\tresponse, 500, \"Internal Server Error\",\n\t\t\t\"Cannot find rest-api directory\");\n\t\treturn;\n\t}\n\t\n\tast_str_append(&absolute_path_builder, 0, \"%s\", uri);\n\tabsolute_filename = realpath(ast_str_buffer(absolute_path_builder), NULL);\n\tif (absolute_filename == NULL) {\n\t\tswitch (errno) {\n\t\tcase ENAMETOOLONG:\n\t\tcase ENOENT:\n\t\tcase ENOTDIR:\n\t\t\tast_ari_response_error(\n\t\t\t\tresponse, 404, \"Not Found\",\n\t\t\t\t\"Resource not found\");\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tast_ari_response_error(\n\t\t\t\tresponse, 403, \"Forbidden\",\n\t\t\t\t\"Permission denied\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Error determining real path for uri '%s': %s\\n\",\n\t\t\t\turi, strerror(errno));\n\t\t\tast_ari_response_error(\n\t\t\t\tresponse, 500, \"Internal Server Error\",\n\t\t\t\t\"Cannot find file\");\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (!ast_begins_with(absolute_filename, absolute_api_dirname)) {\n\t\t\n\t\tast_log(LOG_ERROR,\n\t\t\t\"Invalid attempt to access '%s' (not in %s)\\n\",\n\t\t\tabsolute_filename, absolute_api_dirname);\n\t\tast_ari_response_error(\n\t\t\tresponse, 404, \"Not Found\",\n\t\t\t\"Resource not found\");\n\t\treturn;\n\t}\n\tif (stat(absolute_filename, &file_stat) == 0) {\n\t\tif (!(file_stat.st_mode & S_IFREG)) {\n\t\t\t\n\t\t\tast_ari_response_error(\n\t\t\t\tresponse, 403, \"Forbidden\",\n\t\t\t\t\"Invalid access\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t\n\t\tast_ari_response_error(\n\t\t\tresponse, 404, \"Not Found\",\n\t\t\t\"Resource not found\");\n\t\treturn;\n\t}\n\t\n\tobj = ast_json_load_new_file(absolute_filename, &error);\n\tif (obj == NULL) {\n\t\tast_log(LOG_ERROR, \"Error parsing resource file: %s:%d(%d) %s\\n\",\n\t\t\terror.source, error.line, error.column, error.text);\n\t\tast_ari_response_error(\n\t\t\tresponse, 500, \"Internal Server Error\",\n\t\t\t\"Yikes! Cannot parse resource\");\n\t\treturn;\n\t}\n\t\n\tif (ast_json_object_get(obj, \"basePath\") != NULL) {\n\t\tfor (host = headers; host; host = host->next) {\n\t\t\tif (strcasecmp(host->name, \"Host\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (host != NULL) {\n\t\t\tif (prefix != NULL && strlen(prefix) > 0) {\n\t\t\t\tast_json_object_set(\n\t\t\t\t\tobj, \"basePath\",\n\t\t\t\t\tast_json_stringf(\"http://%s%s/ari\", host->value,prefix));\n\t\t\t} else {\n\t\t\t\tast_json_object_set(\n\t\t\t\t\tobj, \"basePath\",\n\t\t\t\t\tast_json_stringf(\"http://%s/ari\", host->value));\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tast_json_object_del(obj, \"basePath\");\n\t\t}\n\t}\n\tast_ari_response_ok(response, obj);\n}\n", "bug_type": null, "idx": 1257}
{"project": "Asterisk", "target": 0, "func": "static int console_write(struct ast_channel *chan, struct ast_frame *f)\n{\n\tstruct console_pvt *pvt = ast_channel_tech_pvt(chan);\n\tPa_WriteStream(pvt->stream, f->data.ptr, f->samples);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1258}
{"project": "Asterisk", "target": 0, "func": "int ast_sockaddr_resolve(struct ast_sockaddr **addrs, const char *str,\n\t\t\t int flags, int family)\n{\n\tstruct addrinfo hints, *res, *ai;\n\tchar *s, *host, *port;\n\tint\te, i, res_cnt;\n\tif (!str) {\n\t\t*addrs = NULL;\n\t\treturn 0;\n\t}\n\ts = ast_strdupa(str);\n\tif (!ast_sockaddr_split_hostport(s, &host, &port, flags)) {\n\t\t*addrs = NULL;\n\t\treturn 0;\n\t}\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = family;\n\thints.ai_socktype = SOCK_DGRAM;\n\tif ((e = getaddrinfo(host, port, &hints, &res))) {\n\t\tast_log(LOG_ERROR, \"getaddrinfo(\\\"%s\\\", \\\"%s\\\", ...): %s\\n\",\n\t\t\thost, S_OR(port, \"(null)\"), gai_strerror(e));\n\t\t*addrs = NULL;\n\t\treturn 0;\n\t}\n\tres_cnt = 0;\n\tfor (ai = res; ai; ai = ai->ai_next) {\n\t\tres_cnt++;\n\t}\n\tif (res_cnt == 0) {\n\t\t*addrs = NULL;\n\t\tgoto cleanup;\n\t}\n\tif ((*addrs = ast_malloc(res_cnt * sizeof(struct ast_sockaddr))) == NULL) {\n\t\tres_cnt = 0;\n\t\tgoto cleanup;\n\t}\n\ti = 0;\n\tfor (ai = res; ai; ai = ai->ai_next) {\n\t\t(*addrs)[i].len = ai->ai_addrlen;\n\t\tmemcpy(&(*addrs)[i].ss, ai->ai_addr, ai->ai_addrlen);\n\t\t++i;\n\t}\ncleanup:\n\tfreeaddrinfo(res);\n\treturn res_cnt;\n}\n", "bug_type": null, "idx": 1259}
{"project": "Asterisk", "target": 0, "func": "static void analog_get_and_handle_alarms(struct analog_pvt *p)\n{\n\tif (analog_callbacks.get_and_handle_alarms) {\n\t\tanalog_callbacks.get_and_handle_alarms(p->chan_pvt);\n\t}\n}\n", "bug_type": null, "idx": 1260}
{"project": "Asterisk", "target": 0, "func": "static char *console_dial(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tchar *s = NULL;\n\tchar *mye = NULL, *myc = NULL;\n\tstruct chan_oss_pvt *o = find_desc(oss_active);\n\tif (cmd == CLI_INIT) {\n\t\te->command = \"console dial\";\n\t\te->usage =\n\t\t\t\"Usage: console dial [extension[@context]]\\n\"\n\t\t\t\"       Dials a given extension (and context if specified)\\n\";\n\t\treturn NULL;\n\t} else if (cmd == CLI_GENERATE)\n\t\treturn NULL;\n\tif (a->argc > e->args + 1)\n\t\treturn CLI_SHOWUSAGE;\n\tif (o->owner) {\t\n\t\tint i;\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, { 0 } };\n\t\tconst char *digits;\n\t\tif (a->argc == e->args) {\t\n\t\t\tast_cli(a->fd, \"Already in a call. You can only dial digits until you hangup.\\n\");\n\t\t\treturn CLI_FAILURE;\n\t\t}\n\t\tdigits = a->argv[e->args];\n\t\t\n\t\tfor (i = 0; i < strlen(digits); i++) {\n\t\t\tf.subclass.integer = digits[i];\n\t\t\tast_queue_frame(o->owner, &f);\n\t\t}\n\t\treturn CLI_SUCCESS;\n\t}\n\t\n\tif (a->argc == e->args + 1)\n\t\ts = ast_ext_ctx(a->argv[e->args], &mye, &myc);\n\t\n\tif (mye == NULL)\n\t\tmye = o->ext;\n\tif (myc == NULL)\n\t\tmyc = o->ctx;\n\tif (ast_exists_extension(NULL, myc, mye, 1, NULL)) {\n\t\to->hookstate = 1;\n\t\toss_new(o, mye, myc, AST_STATE_RINGING, NULL, NULL);\n\t} else\n\t\tast_cli(a->fd, \"No such extension '%s' in context '%s'\\n\", mye, myc);\n\tif (s)\n\t\tast_free(s);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1261}
{"project": "Asterisk", "target": 0, "func": "static pj_bool_t pubsub_on_rx_subscribe_request(pjsip_rx_data *rdata)\n{\n\tpjsip_expires_hdr *expires_header;\n\tstruct ast_sip_subscription_handler *handler;\n\tRAII_VAR(struct ast_sip_endpoint *, endpoint, NULL, ao2_cleanup);\n\tstruct sip_subscription_tree *sub_tree;\n\tstruct ast_sip_pubsub_body_generator *generator;\n\tchar *resource;\n\tpjsip_uri *request_uri;\n\tpjsip_sip_uri *request_uri_sip;\n\tsize_t resource_size;\n\tint resp;\n\tstruct resource_tree tree;\n\tpj_status_t dlg_status;\n\tendpoint = ast_pjsip_rdata_get_endpoint(rdata);\n\tast_assert(endpoint != NULL);\n\tif (!endpoint->subscription.allow) {\n\t\tast_log(LOG_WARNING, \"Subscriptions not permitted for endpoint %s.\\n\", ast_sorcery_object_get_id(endpoint));\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 603, NULL, NULL, NULL);\n\t\treturn PJ_TRUE;\n\t}\n\trequest_uri = rdata->msg_info.msg->line.req.uri;\n\tif (!PJSIP_URI_SCHEME_IS_SIP(request_uri) && !PJSIP_URI_SCHEME_IS_SIPS(request_uri)) {\n\t\tchar uri_str[PJSIP_MAX_URL_SIZE];\n\t\tpjsip_uri_print(PJSIP_URI_IN_REQ_URI, request_uri, uri_str, sizeof(uri_str));\n\t\tast_log(LOG_WARNING, \"Request URI '%s' is not a sip: or sips: URI.\\n\", uri_str);\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 416, NULL, NULL, NULL);\n\t\treturn PJ_TRUE;\n\t}\n\trequest_uri_sip = pjsip_uri_get_uri(request_uri);\n\tresource_size = pj_strlen(&request_uri_sip->user) + 1;\n\tresource = ast_alloca(resource_size);\n\tast_copy_pj_str(resource, &request_uri_sip->user, resource_size);\n\t\n\tAST_SIP_USER_OPTIONS_TRUNCATE_CHECK(resource);\n\texpires_header = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_EXPIRES, rdata->msg_info.msg->hdr.next);\n\tif (expires_header) {\n\t\tif (expires_header->ivalue == 0) {\n\t\t\tast_log(LOG_WARNING, \"Subscription request from endpoint %s rejected. Expiration of 0 is invalid\\n\",\n\t\t\t\tast_sorcery_object_get_id(endpoint));\n\t\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 400, NULL, NULL, NULL);\n\t\t\t\treturn PJ_TRUE;\n\t\t}\n\t\tif (expires_header->ivalue < endpoint->subscription.minexpiry) {\n\t\t\tast_log(LOG_WARNING, \"Subscription expiration %d is too brief for endpoint %s. Minimum is %u\\n\",\n\t\t\t\texpires_header->ivalue, ast_sorcery_object_get_id(endpoint), endpoint->subscription.minexpiry);\n\t\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 423, NULL, NULL, NULL);\n\t\t\treturn PJ_TRUE;\n\t\t}\n\t}\n\thandler = subscription_get_handler_from_rdata(rdata);\n\tif (!handler) {\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 489, NULL, NULL, NULL);\n\t\treturn PJ_TRUE;\n\t}\n\tgenerator = subscription_get_generator_from_rdata(rdata, handler);\n\tif (!generator) {\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 489, NULL, NULL, NULL);\n\t\treturn PJ_TRUE;\n\t}\n\tmemset(&tree, 0, sizeof(tree));\n\tresp = build_resource_tree(endpoint, handler, resource, &tree,\n\t\tast_sip_pubsub_has_eventlist_support(rdata));\n\tif (!PJSIP_IS_STATUS_IN_CLASS(resp, 200)) {\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, resp, NULL, NULL, NULL);\n\t\tresource_tree_destroy(&tree);\n\t\treturn PJ_TRUE;\n\t}\n\tsub_tree = create_subscription_tree(handler, endpoint, rdata, resource, generator, &tree, &dlg_status);\n\tif (!sub_tree) {\n\t\tif (dlg_status != PJ_EEXISTS) {\n\t\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 500, NULL, NULL, NULL);\n\t\t}\n\t} else {\n\t\tstruct initial_notify_data *ind = ast_malloc(sizeof(*ind));\n\t\tif (!ind) {\n\t\t\tpjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);\n\t\t\tresource_tree_destroy(&tree);\n\t\t\treturn PJ_TRUE;\n\t\t}\n\t\tind->sub_tree = ao2_bump(sub_tree);\n\t\t\n\t\tind->expires = -1;\n\t\tsub_tree->persistence = subscription_persistence_create(sub_tree);\n\t\tsubscription_persistence_update(sub_tree, rdata, SUBSCRIPTION_PERSISTENCE_CREATED);\n\t\tsip_subscription_accept(sub_tree, rdata, resp);\n\t\tif (ast_sip_push_task(sub_tree->serializer, initial_notify_task, ind)) {\n\t\t\tpjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);\n\t\t\tao2_ref(sub_tree, -1);\n\t\t\tast_free(ind);\n\t\t}\n\t}\n\tresource_tree_destroy(&tree);\n\treturn PJ_TRUE;\n}\n", "bug_type": null, "idx": 1262}
{"project": "Asterisk", "target": 0, "func": " */\nstatic msg_t *build_register(struct isdn_msg msgs[], struct misdn_bchannel *bc, int nt)\n{\n\tint HEADER_LEN;\n\tREGISTER_t *reg;\n\tmsg_t *msg;\n\tmsg = (msg_t *) create_l3msg(CC_REGISTER | REQUEST, MT_REGISTER,  bc ? bc->l3_id : -1, sizeof(REGISTER_t), nt);\n\tHEADER_LEN = nt ? mISDNUSER_HEAD_SIZE : mISDN_HEADER_LEN;\n\treg = (REGISTER_t *) (msg->data + HEADER_LEN);\n\tif (bc->fac_out.Function != Fac_None) {\n\t\tenc_ie_facility(&reg->FACILITY, msg, &bc->fac_out, nt);\n\t}\n\treturn msg;\n}\n", "bug_type": null, "idx": 1263}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function media_offer_function = {\n\t.name = \"PJSIP_MEDIA_OFFER\",\n\t.read = pjsip_acf_media_offer_read,\n\t.write = pjsip_acf_media_offer_write\n};\n", "bug_type": null, "idx": 1264}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H235IV8 (OOCTXT* pctxt, H235IV8* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 8, 8, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeOctetString (pctxt,\n                          &pvalue->numocts,\n                          pvalue->data,\n                          sizeof(pvalue->data));\n   if (stat != ASN_OK) return stat;\n   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);\n   return (stat);\n}\n", "bug_type": null, "idx": 1265}
{"project": "Asterisk", "target": 0, "func": "static void *timerfd_timer_open(void)\n{\n\tstruct timerfd_timer *timer;\n\tif (!(timer = ao2_alloc(sizeof(*timer), timer_destroy))) {\n\t\tast_log(LOG_ERROR, \"Could not allocate memory for timerfd_timer structure\\n\");\n\t\treturn NULL;\n\t}\n\tif ((timer->fd = timerfd_create(CLOCK_MONOTONIC, 0)) < 0) {\n\t\tast_log(LOG_ERROR, \"Failed to create timerfd timer: %s\\n\", strerror(errno));\n\t\tao2_ref(timer, -1);\n\t\treturn NULL;\n\t}\n\treturn timer;\n}\n", "bug_type": null, "idx": 1266}
{"project": "Asterisk", "target": 0, "func": "void *__ast_calloc(size_t nmemb, size_t size, const char *file, int lineno, const char *func)\n{\n\treturn calloc(nmemb, size);\n}\n", "bug_type": null, "idx": 1267}
{"project": "Asterisk", "target": 0, "func": "static int update_ewscal(struct ewscal_pvt *pvt)\n{\n\tstruct calendar_id *id_head;\n\tstruct calendar_id *iter;\n\tif (!(id_head = get_ewscal_ids_for(pvt))) {\n\t\treturn 0;\n\t}\n\tfor (iter = id_head; iter; iter = AST_LIST_NEXT(iter, next)) {\n\t\tparse_ewscal_id(pvt, ast_str_buffer(iter->id));\n\t\tast_free(iter->id);\n\t\tast_free(iter);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1268}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *entry_get_number(struct pjsip_history_entry *entry)\n{\n\treturn &entry->number;\n}\n", "bug_type": null, "idx": 1269}
{"project": "Asterisk", "target": 0, "func": "static void build_iv(unsigned char *iv)\n{\n\t\n\tunsigned int *fluffy;\n\tint x;\n\tfluffy = (unsigned int *)(iv);\n\tfor (x=0;x<4;x++)\n\t\tfluffy[x] = ast_random();\n}\n", "bug_type": null, "idx": 1270}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MultiplexEntrySendReject (OOCTXT* pctxt, H245MultiplexEntrySendReject* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   \n   stat = asn1PE_H245SequenceNumber (pctxt, pvalue->sequenceNumber);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H245MultiplexEntrySendReject_rejectionDescriptions (pctxt, &pvalue->rejectionDescriptions);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1271}
{"project": "Asterisk", "target": 0, "func": " \nvoid pvalIncludesAddIncludeWithTimeConstraints( pval *p, const char *include, char *hour_range, char *dom_range, char *dow_range, char *month_range )\n{\n\tpval *hr;\n\tpval *dom;\n\tpval *dow;\n\tpval *mon;\n\tpval *s;\n\tif (!pvalCheckType(p, \"pvalIncludeAddIncludeWithTimeConstraints\", PV_INCLUDES)) {\n\t\treturn;\n\t}\n\thr = pvalCreateNode(PV_WORD);\n\tdom = pvalCreateNode(PV_WORD);\n\tdow = pvalCreateNode(PV_WORD);\n\tmon = pvalCreateNode(PV_WORD);\n\ts = pvalCreateNode(PV_WORD);\n\tif (!hr || !dom || !dow || !mon || !s) {\n\t\tdestroy_pval(hr);\n\t\tdestroy_pval(dom);\n\t\tdestroy_pval(dow);\n\t\tdestroy_pval(mon);\n\t\tdestroy_pval(s);\n\t\treturn;\n\t}\n\ts->u1.str = (char *)include;\n\tp->u1.list = linku1(p->u1.list, s);\n\thr->u1.str = hour_range;\n\tdom->u1.str = dom_range;\n\tdow->u1.str = dow_range;\n\tmon->u1.str = month_range;\n\ts->u2.arglist = hr;\n\thr->next = dom;\n\tdom->next = dow;\n\tdow->next = mon;\n\tmon->next = 0;\n}\n", "bug_type": null, "idx": 1272}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245RefPictureSelection (OOCTXT* pctxt, H245RefPictureSelection* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.enhancedReferencePicSelectPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.additionalPictureMemoryPresent);\n   \n   if (pvalue->m.additionalPictureMemoryPresent) {\n      stat = asn1PE_H245RefPictureSelection_additionalPictureMemory (pctxt, &pvalue->additionalPictureMemory);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->videoMux);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H245RefPictureSelection_videoBackChannelSend (pctxt, &pvalue->videoBackChannelSend);\n   if (stat != ASN_OK) return stat;\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 0);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.enhancedReferencePicSelectPresent);\n      \n      if (pvalue->m.enhancedReferencePicSelectPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H245RefPictureSelection_enhancedReferencePicSelect (&lctxt, &pvalue->enhancedReferencePicSelect);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1273}
{"project": "Asterisk", "target": 0, "func": "\nvoid ast_sched_dump(struct ast_sched_context *con)\n{\n\tstruct sched *q;\n\tstruct timeval when = ast_tvnow();\n\tint x;\n\tsize_t heap_size;\n#ifdef SCHED_MAX_CACHE\n\tast_debug(1, \"Asterisk Schedule Dump (%zu in Q, %u Total, %u Cache, %u high-water)\\n\", ast_heap_size(con->sched_heap), con->eventcnt - 1, con->schedccnt, con->highwater);\n#else\n\tast_debug(1, \"Asterisk Schedule Dump (%zu in Q, %u Total, %u high-water)\\n\", ast_heap_size(con->sched_heap), con->eventcnt - 1, con->highwater);\n#endif\n\tast_debug(1, \"=============================================================\\n\");\n\tast_debug(1, \"|ID    Callback          Data              Time  (sec:ms)   |\\n\");\n\tast_debug(1, \"+-----+-----------------+-----------------+-----------------+\\n\");\n\tast_mutex_lock(&con->lock);\n\theap_size = ast_heap_size(con->sched_heap);\n\tfor (x = 1; x <= heap_size; x++) {\n\t\tstruct timeval delta;\n\t\tq = ast_heap_peek(con->sched_heap, x);\n\t\tdelta = ast_tvsub(q->when, when);\n\t\tast_debug(1, \"|%.4d | %-15p | %-15p | %.6ld : %.6ld |\\n\",\n\t\t\tq->sched_id->id,\n\t\t\tq->callback,\n\t\t\tq->data,\n\t\t\t(long)delta.tv_sec,\n\t\t\t(long int)delta.tv_usec);\n\t}\n\tast_mutex_unlock(&con->lock);\n\tast_debug(1, \"=============================================================\\n\");\n}\n", "bug_type": null, "idx": 1274}
{"project": "Asterisk", "target": 0, "func": "void ooTrace(OOUINT32 traceLevel, const char * fmtspec, ...) __attribute__((format(printf, 2, 3)));\nvoid ooTrace(OOUINT32 traceLevel, const char * fmtspec, ...) {\n   va_list arglist;\n   char logMessage[MAXLOGMSGLEN];\n   if(traceLevel > gs_traceLevel) return;\n   va_start (arglist, fmtspec);\n   \n   vsprintf(logMessage, fmtspec, arglist);   \n   va_end(arglist);\n   ooTraceLogMessage(logMessage);\n}\n", "bug_type": null, "idx": 1275}
{"project": "Asterisk", "target": 0, "func": "static void hanguptone_indicate(struct chan_list *cl)\n{\n\tmisdn_lib_send_tone(cl->bc, TONE_HANGUP);\n}\n", "bug_type": null, "idx": 1276}
{"project": "Asterisk", "target": 0, "func": "void ast_calendar_merge_events(struct ast_calendar *cal, struct ao2_container *new_events)\n{\n\t\n\tao2_callback(cal->events, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, merge_events_cb, new_events);\n\t\n\tao2_callback(new_events, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, add_new_event_cb, cal->events);\n}\n", "bug_type": null, "idx": 1277}
{"project": "Asterisk", "target": 0, "func": " \\note This is the default syntax, if no other syntax defined in this file is used */\nstatic int ast_say_enumeration_full_en(struct ast_channel *chan, int num, const char *ints, const char *language, int audiofd, int ctrlfd)\n{\n\tint res = 0, t = 0;\n\tchar fn[256] = \"\";\n\twhile (!res && num) {\n\t\tif (num < 0) {\n\t\t\tast_copy_string(fn, \"digits/minus\", sizeof(fn)); \n\t\t\tif ( num > INT_MIN ) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t} else if (num < 20) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/h-%d\", num);\n\t\t\tnum = 0;\n\t\t} else if (num < 100) {\n\t\t\tint tens = num / 10;\n\t\t\tnum = num % 10;\n\t\t\tif (num == 0) {\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/h-%d\", (tens * 10));\n\t\t\t} else {\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", (tens * 10));\n\t\t\t}\n\t\t} else if (num < 1000) {\n\t\t\tint hundreds = num / 100;\n\t\t\tnum = num % 100;\n\t\t\tif (hundreds > 1 || t == 1) {\n\t\t\t\tres = ast_say_number_full_en(chan, hundreds, ints, language, audiofd, ctrlfd);\n\t\t\t}\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tif (num) {\n\t\t\t\tast_copy_string(fn, \"digits/hundred\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tast_copy_string(fn, \"digits/h-hundred\", sizeof(fn));\n\t\t\t}\n\t\t} else if (num < 1000000) {\n\t\t\tint thousands = num / 1000;\n\t\t\tnum = num % 1000;\n\t\t\tif (thousands > 1 || t == 1) {\n\t\t\t\tres = ast_say_number_full_en(chan, thousands, ints, language, audiofd, ctrlfd);\n\t\t\t}\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tif (num) {\n\t\t\t\tast_copy_string(fn, \"digits/thousand\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tast_copy_string(fn, \"digits/h-thousand\", sizeof(fn));\n\t\t\t}\n\t\t\tt = 1;\n\t\t} else if (num < 1000000000) {\n\t\t\tint millions = num / 1000000;\n\t\t\tnum = num % 1000000;\n\t\t\tt = 1;\n\t\t\tres = ast_say_number_full_en(chan, millions, ints, language, audiofd, ctrlfd);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tif (num) {\n\t\t\t\tast_copy_string(fn, \"digits/million\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tast_copy_string(fn, \"digits/h-million\", sizeof(fn));\n\t\t\t}\n\t\t} else if (num < INT_MAX) {\n\t\t\tint billions = num / 1000000000;\n\t\t\tnum = num % 1000000000;\n\t\t\tt = 1;\n\t\t\tres = ast_say_number_full_en(chan, billions, ints, language, audiofd, ctrlfd);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tif (num) {\n\t\t\t\tast_copy_string(fn, \"digits/billion\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tast_copy_string(fn, \"digits/h-billion\", sizeof(fn));\n\t\t\t}\n\t\t} else if (num == INT_MAX) {\n\t\t\tast_copy_string(fn, \"digits/h-last\", sizeof(fn));\n\t\t\tnum = 0;\n\t\t} else {\n\t\t\tast_debug(1, \"Number '%d' is too big for me\\n\", num);\n\t\t\tres = -1;\n\t\t}\n\t\tif (!res) {\n\t\t\tif (!ast_streamfile(chan, fn, language)) {\n\t\t\t\tif ((audiofd > -1) && (ctrlfd > -1)) {\n\t\t\t\t\tres = ast_waitstream_full(chan, ints, audiofd, ctrlfd);\n\t\t\t\t} else {\n\t\t\t\t\tres = ast_waitstream(chan, ints);\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_stopstream(chan);\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1278}
{"project": "Asterisk", "target": 0, "func": "static int update2_mysql(const char *database, const char *tablename, const struct ast_variable *lookup_fields, const struct ast_variable *update_fields)\n{\n\tstruct mysql_conn *dbh;\n\tmy_ulonglong numrows;\n\tint first;\n\tconst struct ast_variable *field;\n\tstruct ast_str *sql = ast_str_thread_get(&sql_buf, 100), *buf = ast_str_thread_get(&scratch_buf, 100);\n\tstruct ast_str *where = ast_str_thread_get(&sql2_buf, 100);\n\tstruct tables *table;\n\tstruct columns *column = NULL;\n\tif (!tablename) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: No table specified.\\n\");\n\t\treturn -1;\n\t}\n\tif (!(dbh = find_database(database, 1))) {\n\t\tast_log(LOG_ERROR, \"Invalid database specified: %s\\n\", database);\n\t\treturn -1;\n\t}\n\tif (!(table = find_table(database, tablename))) {\n\t\tast_log(LOG_ERROR, \"Table '%s' does not exist!!\\n\", tablename);\n\t\trelease_database(dbh);\n\t\treturn -1;\n\t}\n\tif (!sql || !buf || !where) {\n\t\trelease_database(dbh);\n\t\trelease_table(table);\n\t\treturn -1;\n\t}\n\tast_str_set(&sql, 0, \"UPDATE %s SET\", tablename);\n\tast_str_set(&where, 0, \"WHERE\");\n\t\n\tif (!mysql_reconnect(dbh)) {\n\t\trelease_table(table);\n\t\trelease_database(dbh);\n\t\treturn -1;\n\t}\n\tfirst = 1;\n\tfor (field = lookup_fields; field; field = field->next) {\n\t\tif (!(column = find_column(table, field->name))) {\n\t\t\tast_log(LOG_ERROR, \"Updating on column '%s', but that column does not exist within the table '%s'!\\n\", field->name, tablename);\n\t\t\trelease_table(table);\n\t\t\trelease_database(dbh);\n\t\t\treturn -1;\n\t\t}\n\t\tESCAPE_STRING(buf, field->value);\n\t\tast_str_append(&where, 0, \"%s `%s` = '%s'\", first ? \"\" : \" AND\", field->name, ast_str_buffer(buf));\n\t\tfirst = 0;\n\t}\n\tfirst = 1;\n\tfor (field = update_fields; field; field = field->next) {\n\t\t\n\t\tif (!(column = find_column(table, field->name))) {\n\t\t\tast_log(LOG_WARNING, \"Attempted to update column '%s' in table '%s', but column does not exist!\\n\", field->name, tablename);\n\t\t\tcontinue;\n\t\t}\n\t\tESCAPE_STRING(buf, field->value);\n\t\tast_str_append(&sql, 0, \"%s `%s` = '%s'\", first ? \"\" : \",\", field->name, ast_str_buffer(buf));\n\t\tfirst = 0;\n\t}\n\trelease_table(table);\n\tast_str_append(&sql, 0, \" %s\", ast_str_buffer(where));\n\tast_debug(1, \"MySQL RealTime: Update SQL: %s\\n\", ast_str_buffer(sql));\n\t\n\tif (mysql_real_query(&dbh->handle, ast_str_buffer(sql), ast_str_strlen(sql))) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Failed to update database: %s\\n\", mysql_error(&dbh->handle));\n\t\trelease_table(table);\n\t\trelease_database(dbh);\n\t\treturn -1;\n\t}\n\tnumrows = mysql_affected_rows(&dbh->handle);\n\trelease_database(dbh);\n\tast_debug(1, \"MySQL RealTime: Updated %llu rows on table: %s\\n\", numrows, tablename);\n\t\n\treturn (int)numrows;\n}\n", "bug_type": null, "idx": 1279}
{"project": "Asterisk", "target": 0, "func": "\nint ast_speech_grammar_unload(struct ast_speech *speech, const char *grammar_name)\n{\n\treturn (speech->engine->unload ? speech->engine->unload(speech, grammar_name) : -1);\n}\n", "bug_type": null, "idx": 1280}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void memory_cache_stale_check_object(const struct ast_sorcery *sorcery, struct sorcery_memory_cache *cache,\n\tstruct sorcery_memory_cached_object *cached)\n{\n\tstruct timeval elapsed;\n\tif (!cache->object_lifetime_stale) {\n\t\treturn;\n\t}\n\t\n\telapsed = ast_tvsub(ast_tvnow(), cached->created);\n\tif (elapsed.tv_sec < cache->object_lifetime_stale) {\n\t\treturn;\n\t}\n\tif (cache->full_backend_cache) {\n\t\tmemory_cache_stale_update_full(sorcery, cache, ast_sorcery_object_get_type(cached->object));\n\t} else {\n\t\tmemory_cache_stale_update_object(sorcery, cache, cached);\n\t}\n}\n", "bug_type": null, "idx": 1281}
{"project": "Asterisk", "target": 0, "func": "static int agent_function_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tchar *parse;\n\tstruct agent_pvt *agent;\n\tstruct ast_channel *logged;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(agentid);\n\t\tAST_APP_ARG(item);\n\t);\n\tbuf[0] = '\\0';\n\tparse = ast_strdupa(data ?: \"\");\n\tAST_NONSTANDARD_APP_ARGS(args, parse, ':');\n\tif (ast_strlen_zero(args.agentid)) {\n\t\tast_log(LOG_WARNING, \"The AGENT function requires an argument - agentid!\\n\");\n\t\treturn -1;\n\t}\n\tif (!args.item) {\n\t\targs.item = \"status\";\n\t}\n\tagent = ao2_find(agents, args.agentid, OBJ_KEY);\n\tif (!agent) {\n\t\tast_log(LOG_WARNING, \"Agent '%s' not found!\\n\", args.agentid);\n\t\treturn -1;\n\t}\n\tagent_lock(agent);\n\tif (!strcasecmp(args.item, \"status\")) {\n\t\tconst char *status;\n\t\tif (agent->logged) {\n\t\t\tstatus = \"LOGGEDIN\";\n\t\t} else {\n\t\t\tstatus = \"LOGGEDOUT\";\n\t\t}\n\t\tast_copy_string(buf, status, len);\n\t} else if (!strcasecmp(args.item, \"name\")) {\n\t\tast_copy_string(buf, agent->cfg->full_name, len);\n\t} else if (!strcasecmp(args.item, \"mohclass\")) {\n\t\tast_copy_string(buf, agent->cfg->moh, len);\n\t} else if (!strcasecmp(args.item, \"channel\")) {\n\t\tlogged = agent_lock_logged(agent);\n\t\tif (logged) {\n\t\t\tchar *pos;\n\t\t\tast_copy_string(buf, ast_channel_name(logged), len);\n\t\t\tast_channel_unlock(logged);\n\t\t\tast_channel_unref(logged);\n\t\t\tpos = strrchr(buf, '-');\n\t\t\tif (pos) {\n\t\t\t\t*pos = '\\0';\n\t\t\t}\n\t\t}\n\t} else if (!strcasecmp(args.item, \"fullchannel\")) {\n\t\tlogged = agent_lock_logged(agent);\n\t\tif (logged) {\n\t\t\tast_copy_string(buf, ast_channel_name(logged), len);\n\t\t\tast_channel_unlock(logged);\n\t\t\tast_channel_unref(logged);\n\t\t}\n\t}\n\tagent_unlock(agent);\n\tao2_ref(agent, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1282}
{"project": "Asterisk", "target": 0, "func": "static struct ast_manager_event_blob *fake_ami(struct stasis_message *message)\n{\n\tRAII_VAR(struct ast_manager_event_blob *, res, NULL, ao2_cleanup);\n\tconst char *text = stasis_message_data(message);\n\tres = ast_manager_event_blob_create(EVENT_FLAG_TEST, \"FakeMI\",\n\t\t\"Message: %s\\r\\n\", text);\n\tif (res == NULL) {\n\t\treturn NULL;\n\t}\n\tao2_ref(res, +1);\n\treturn res;\n}\n", "bug_type": null, "idx": 1283}
{"project": "Asterisk", "target": 0, "func": "static struct val *\nop_le (struct val *a, struct val *b)\n{\n\tstruct val *r;\n\tif (isstring (a) || isstring (b)) {\n\t\tto_string (a);\n\t\tto_string (b);\n\t\tr = make_number ((FP___TYPE)(strcoll (a->u.s, b->u.s) <= 0));\n\t} else {\n\t\t(void)to_number(a);\n\t\t(void)to_number(b);\n\t\tr = make_number ((FP___TYPE)(a->u.i <= b->u.i));\n\t}\n\tfree_value (a);\n\tfree_value (b);\n\treturn r;\n}\n", "bug_type": null, "idx": 1284}
{"project": "Asterisk", "target": 0, "func": "static void send_ring(struct unistimsession *pte, signed char volume, signed char style)\n{\n\tBUFFSEND;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending ring packet\\n\");\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_ring, sizeof(packet_send_ring));\n\tbuffsend[24] = style + 0x10;\n\tbuffsend[29] = volume * 0x10;\n\tsend_client(SIZE_HEADER + sizeof(packet_send_ring), buffsend, pte);\n}\n", "bug_type": null, "idx": 1285}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int io_grow(struct io_context *ioc)\n{\n\tvoid *tmp;\n\tDEBUG(ast_debug(1, \"io_grow()\\n\"));\n\tioc->maxfdcnt += GROW_SHRINK_SIZE;\n\tif ((tmp = ast_realloc(ioc->ior, (ioc->maxfdcnt + 1) * sizeof(*ioc->ior)))) {\n\t\tioc->ior = tmp;\n\t\tif ((tmp = ast_realloc(ioc->fds, (ioc->maxfdcnt + 1) * sizeof(*ioc->fds)))) {\n\t\t\tioc->fds = tmp;\n\t\t} else {\n\t\t\t\n\t\t\tioc->maxfdcnt -= GROW_SHRINK_SIZE;\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t\n\t\tioc->maxfdcnt -= GROW_SHRINK_SIZE;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1286}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_set_talker_src_video_mode(struct ast_bridge *bridge)\n{\n\tast_bridge_lock(bridge);\n\tcleanup_video_mode(bridge);\n\tbridge->softmix.video_mode.mode = AST_BRIDGE_VIDEO_MODE_TALKER_SRC;\n\tast_bridge_unlock(bridge);\n}\n", "bug_type": null, "idx": 1287}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int misdn_cc_response_check(void *data)\n{\n\tint not_responded;\n\tstruct misdn_cc_record *cc_record;\n\tAST_LIST_LOCK(&misdn_cc_records_db);\n\tcc_record = misdn_cc_find_by_id(*(long *) data);\n\tif (cc_record) {\n\t\tif (cc_record->outstanding_message) {\n\t\t\tnot_responded = -1;\n\t\t} else {\n\t\t\tnot_responded = 0;\n\t\t}\n\t} else {\n\t\t\n\t\tnot_responded = 0;\n\t}\n\tAST_LIST_UNLOCK(&misdn_cc_records_db);\n\treturn not_responded;\n}\n", "bug_type": null, "idx": 1288}
{"project": "Asterisk", "target": 0, "func": "void ast_stream_topology_map(const struct ast_stream_topology *topology,\n\tstruct ast_vector_int *types, struct ast_vector_int *v0, struct ast_vector_int *v1)\n{\n\tint i;\n\tint nths[AST_MEDIA_TYPE_END] = {0};\n\tint size = ast_stream_topology_get_count(topology);\n\t\n\tAST_VECTOR_FREE(v0);\n\tAST_VECTOR_FREE(v1);\n\t\n\tAST_VECTOR_INIT(v0, size);\n\tAST_VECTOR_INIT(v1, size);\n\tfor (i = 0; i < size; ++i) {\n\t\tstruct ast_stream *stream = ast_stream_topology_get_stream(topology, i);\n\t\tenum ast_media_type type = ast_stream_get_type(stream);\n\t\tint index = AST_VECTOR_GET_INDEX_NTH(types, ++nths[type],\n\t\t\ttype, AST_VECTOR_ELEM_DEFAULT_CMP);\n\t\tif (index == -1) {\n\t\t\t\n\t\t\tAST_VECTOR_APPEND(types, type);\n\t\t\tindex = AST_VECTOR_SIZE(types) - 1;\n\t\t}\n\t\t\n\t\tAST_VECTOR_REPLACE(v0, i, index);\n\t\tAST_VECTOR_REPLACE(v1, index, i);\n\t}\n}\n", "bug_type": null, "idx": 1289}
{"project": "Asterisk", "target": 0, "func": "static struct ast_format *opus_set(const struct ast_format *format,\n\tconst char *name, const char *value)\n{\n\tstruct ast_format *cloned;\n\tstruct opus_attr *attr;\n\tint val;\n\tif (!(cloned = ast_format_clone(format))) {\n\t\treturn NULL;\n\t}\n\tattr = ast_format_get_attribute_data(cloned);\n\tif (!strcmp(name, CODEC_OPUS_ATTR_DATA)) {\n\t\tao2_cleanup(attr->data);\n\t\tattr->data = ao2_bump((void*)value);\n\t\treturn cloned;\n\t}\n\tif (sscanf(value, \"%30d\", &val) != 1) {\n\t\tast_log(LOG_WARNING, \"Unknown value '%s' for attribute type '%s'\\n\",\n\t\t\tvalue, name);\n\t\tao2_ref(cloned, -1);\n\t\treturn NULL;\n\t}\n\tif (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PLAYBACK_RATE)) {\n\t\tattr->maxplayrate = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_CODED_AUDIO_BANDWIDTH)) {\n\t\tattr->maxplayrate = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_MAX_CAPTURE_RATE)) {\n\t\tattr->spropmaxcapturerate = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PTIME)) {\n\t\tattr->maxptime = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_PTIME)) {\n\t\tattr->ptime = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_AVERAGE_BITRATE)) {\n\t\tattr->maxbitrate = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_STEREO)) {\n\t\tattr->stereo = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_STEREO)) {\n\t\tattr->spropstereo = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_CBR)) {\n\t\tattr->cbr = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_FEC)) {\n\t\tattr->fec = val;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_DTX)) {\n\t\tattr->dtx = val;\n\t} else {\n\t\tast_log(LOG_WARNING, \"unknown attribute type %s\\n\", name);\n\t}\n\treturn cloned;\n}\n", "bug_type": null, "idx": 1290}
{"project": "Asterisk", "target": 0, "func": "END_OPTIONS);\nstatic void debug_check_frame_for_silence(struct ast_fax_session *s, unsigned int c2s, struct ast_frame *frame)\n{\n\tstruct debug_info_history *history = c2s ? &s->debug_info->c2s : &s->debug_info->s2c;\n\tint dspsilence;\n\tunsigned int last_consec_frames, last_consec_ms;\n\tunsigned char wassil;\n\tstruct timeval diff;\n\tdiff = ast_tvsub(ast_tvnow(), s->debug_info->base_tv);\n\tast_dsp_reset(s->debug_info->dsp);\n\tast_dsp_silence(s->debug_info->dsp, frame, &dspsilence);\n\twassil = history->silence;\n\thistory->silence = (dspsilence != 0) ? 1 : 0;\n\tif (history->silence != wassil) {\n\t\tlast_consec_frames = history->consec_frames;\n\t\tlast_consec_ms = history->consec_ms;\n\t\thistory->consec_frames = 0;\n\t\thistory->consec_ms = 0;\n\t\tif ((last_consec_frames != 0)) {\n\t\t\tast_verb(0, \"Channel '%s' fax session '%u', [ %.3ld.%.6ld ], %s sent %u frames (%u ms) of %s.\\n\",\n\t\t\t\t s->channame, s->id, (long) diff.tv_sec, (long int) diff.tv_usec,\n\t\t\t\t (c2s) ? \"channel\" : \"stack\", last_consec_frames, last_consec_ms,\n\t\t\t\t (wassil) ? \"silence\" : \"energy\");\n\t\t}\n\t}\n\thistory->consec_frames++;\n\thistory->consec_ms += (frame->samples / 8);\n}\n", "bug_type": null, "idx": 1291}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int cc_generic_is_device_available(enum ast_device_state state)\n{\n\treturn state == AST_DEVICE_NOT_INUSE || state == AST_DEVICE_UNKNOWN;\n}\n", "bug_type": null, "idx": 1292}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic void gen_header(FILE *f1, const char *configfile, const char *fn, const char *generator)\n{\n\tchar date[256]=\"\";\n\ttime_t t;\n\ttime(&t);\n\tast_copy_string(date, ctime(&t), sizeof(date));\n\tfprintf(f1, \";!\\n\");\n\tfprintf(f1, \";! Automatically generated configuration file\\n\");\n\tif (strcmp(configfile, fn))\n\t\tfprintf(f1, \";! Filename: %s (%s)\\n\", configfile, fn);\n\telse\n\t\tfprintf(f1, \";! Filename: %s\\n\", configfile);\n\tfprintf(f1, \";! Generator: %s\\n\", generator);\n\tfprintf(f1, \";! Creation Date: %s\", date);\n\tfprintf(f1, \";!\\n\");\n}\n", "bug_type": null, "idx": 1293}
{"project": "Asterisk", "target": 0, "func": "private int\nhistory_def_next(ptr_t p, HistEvent *ev)\n{\n\thistory_t *h = (history_t *) p;\n\tif (h->cursor != &h->list)\n\t\th->cursor = h->cursor->next;\n\telse {\n\t\the_seterrev(ev, _HE_EMPTY_LIST);\n\t\treturn (-1);\n\t}\n\tif (h->cursor != &h->list)\n\t\t*ev = h->cursor->ev;\n\telse {\n\t\the_seterrev(ev, _HE_END_REACHED);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n", "bug_type": null, "idx": 1294}
{"project": "Asterisk", "target": 0, "func": "static void delete_device(struct unistim_device *d)\n{\n\tstruct unistim_line *l;\n\tstruct unistim_subchannel *sub;\n\tstruct unistimsession *s;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Removing device '%s'\\n\", d->name);\n\t}\n\tAST_LIST_LOCK(&d->subs);\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&d->subs, sub, list){\n\t\tif (sub->subtype == SUB_REAL) {\n\t\t\tif (sub->owner) {\n\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\"Device '%s' was not deleted : a call is in progress. Try again later.\\n\",\n\t\t\t\t\t\td->name);\n\t\t\t\tAST_LIST_UNLOCK(&d->subs);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (sub->subtype == SUB_THREEWAY) {\n\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\"Device '%s' with threeway call subchannels allocated, aborting.\\n\",\n\t\t\t\t\td->name);\n\t\t\tAST_LIST_UNLOCK(&d->subs);\n\t\t\treturn;\n\t\t}\n\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\tast_mutex_destroy(&sub->lock);\n\t\tast_free(sub);\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END\n\tAST_LIST_UNLOCK(&d->subs);\n\tAST_LIST_LOCK(&d->lines);\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&d->lines, l, list){\n\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\tast_mutex_destroy(&l->lock);\n\t\tunistim_line_destroy(l);\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END\n\tAST_LIST_UNLOCK(&d->lines);\n\tif (d->session) {\n\t\tif (sessions == d->session) {\n\t\t\tsessions = d->session->next;\n\t\t} else {\n\t\t\ts = sessions;\n\t\t\twhile (s) {\n\t\t\t\tif (s->next == d->session) {\n\t\t\t\t\ts->next = d->session->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts = s->next;\n\t\t\t}\n\t\t}\n\t\tast_mutex_destroy(&d->session->lock);\n\t\tast_free(d->session);\n\t}\n\tif (devices == d) {\n\t\tdevices = d->next;\n\t} else {\n\t\tstruct unistim_device *d2 = devices;\n\t\twhile (d2) {\n\t\t\tif (d2->next == d) {\n\t\t\t\td2->next = d->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td2 = d2->next;\n\t\t}\n\t}\n\tif (d->tz) {\n\t\td->tz = ast_tone_zone_unref(d->tz);\n\t}\n\tast_mutex_destroy(&d->lock);\n\tast_free(d);\n}\n", "bug_type": null, "idx": 1295}
{"project": "Asterisk", "target": 0, "func": "static int pack_channel_into_message(struct ast_channel *chan, const char *role,\n\t\t\t\t\t\t\t\t\t struct ast_multi_channel_blob *payload)\n{\n\tRAII_VAR(struct ast_channel_snapshot *, snapshot,\n\t\t\tast_channel_snapshot_get_latest(ast_channel_uniqueid(chan)),\n\t\t\tao2_cleanup);\n\tif (!snapshot) {\n\t\treturn -1;\n\t}\n\tast_multi_channel_blob_add_channel(payload, role, snapshot);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1296}
{"project": "Asterisk", "target": 0, "func": "static int misdn_check_l2l1(struct ast_channel *chan, const char *data)\n{\n\tchar *parse;\n\tchar group[BUFFERSIZE + 1];\n\tchar *port_str;\n\tint port = 0;\n\tint timeout;\n\tint dowait = 0;\n\tint port_up;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(grouppar);\n\t\tAST_APP_ARG(timeout);\n\t);\n\tif (ast_strlen_zero((char *) data)) {\n\t\tast_log(LOG_WARNING, \"misdn_check_l2l1 Requires arguments\\n\");\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc != 2) {\n\t\tast_log(LOG_WARNING, \"Wrong argument count\\n\");\n\t\treturn 0;\n\t}\n\t\n\ttimeout = atoi(args.timeout);\n\tport_str = args.grouppar;\n\tif (port_str[0] == 'g' && port_str[1] == ':') {\n\t\t\n\t\tport_str += 2;\n\t\tast_copy_string(group, port_str, sizeof(group));\n\t\tchan_misdn_log(2, 0, \"Checking Ports in group: %s\\n\", group);\n\t\tfor (port = misdn_cfg_get_next_port(port);\n\t\t\tport > 0;\n\t\t\tport = misdn_cfg_get_next_port(port)) {\n\t\t\tchar cfg_group[BUFFERSIZE + 1];\n\t\t\tchan_misdn_log(2, 0, \"trying port %d\\n\", port);\n\t\t\tmisdn_cfg_get(port, MISDN_CFG_GROUPNAME, cfg_group, sizeof(cfg_group));\n\t\t\tif (!strcasecmp(cfg_group, group)) {\n\t\t\t\tport_up = misdn_lib_port_up(port, 1);\n\t\t\t\tif (!port_up) {\n\t\t\t\t\tchan_misdn_log(2, 0, \" --> port '%d'\\n\", port);\n\t\t\t\t\tmisdn_lib_get_port_up(port);\n\t\t\t\t\tdowait = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tport = atoi(port_str);\n\t\tchan_misdn_log(2, 0, \"Checking Port: %d\\n\", port);\n\t\tport_up = misdn_lib_port_up(port, 1);\n\t\tif (!port_up) {\n\t\t\tmisdn_lib_get_port_up(port);\n\t\t\tdowait = 1;\n\t\t}\n\t}\n\tif (dowait) {\n\t\tchan_misdn_log(2, 0, \"Waiting for '%d' seconds\\n\", timeout);\n\t\tast_safe_sleep(chan, timeout * 1000);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1297}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res;\n\tcaches = ao2_container_alloc(CACHES_CONTAINER_BUCKET_SIZE, sorcery_memory_cache_hash,\n\t\tsorcery_memory_cache_cmp);\n\tif (!caches) {\n\t\tast_log(LOG_ERROR, \"Failed to create container for configured caches\\n\");\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tsched = ast_sched_context_create();\n\tif (!sched) {\n\t\tast_log(LOG_ERROR, \"Failed to create scheduler for cache management\\n\");\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (ast_sched_start_thread(sched)) {\n\t\tast_log(LOG_ERROR, \"Failed to create scheduler thread for cache management\\n\");\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (ast_sorcery_wizard_register(&memory_cache_object_wizard)) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tres = ast_cli_register_multiple(cli_memory_cache, ARRAY_LEN(cli_memory_cache));\n\tres |= ast_manager_register_xml(\"SorceryMemoryCacheExpireObject\", EVENT_FLAG_SYSTEM, sorcery_memory_cache_ami_expire_object);\n\tres |= ast_manager_register_xml(\"SorceryMemoryCacheExpire\", EVENT_FLAG_SYSTEM, sorcery_memory_cache_ami_expire);\n\tres |= ast_manager_register_xml(\"SorceryMemoryCacheStaleObject\", EVENT_FLAG_SYSTEM, sorcery_memory_cache_ami_stale_object);\n\tres |= ast_manager_register_xml(\"SorceryMemoryCacheStale\", EVENT_FLAG_SYSTEM, sorcery_memory_cache_ami_stale);\n\tres |= ast_manager_register_xml(\"SorceryMemoryCachePopulate\", EVENT_FLAG_SYSTEM, sorcery_memory_cache_ami_populate);\n\tif (res) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\t\n\tAST_TEST_REGISTER(stale);\n\tAST_TEST_REGISTER(open_with_valid_options);\n\tAST_TEST_REGISTER(open_with_invalid_options);\n\tAST_TEST_REGISTER(create_and_retrieve);\n\tAST_TEST_REGISTER(update);\n\tAST_TEST_REGISTER(delete);\n\tAST_TEST_REGISTER(maximum_objects);\n\tAST_TEST_REGISTER(expiration);\n\tAST_TEST_REGISTER(full_backend_cache_expiration);\n\tAST_TEST_REGISTER(full_backend_cache_stale);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1298}
{"project": "Asterisk", "target": 0, "func": "int ast_rtp_red_init(struct ast_rtp_instance *instance, int buffer_time, int *payloads, int generations)\n{\n\tint res;\n\tif (instance->engine->red_init) {\n\t\tao2_lock(instance);\n\t\tres = instance->engine->red_init(instance, buffer_time, payloads, generations);\n\t\tao2_unlock(instance);\n\t} else {\n\t\tres = -1;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1299}
{"project": "Asterisk", "target": 0, "func": "static void confbridge_start_cb(void *data, struct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tconfbridge_publish_manager_event(message, \"ConfbridgeStart\", NULL);\n}\n", "bug_type": null, "idx": 1300}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_calendar_unregister(&ical_tech);\n\tne_sock_exit();\n\treturn 0;\n}\n", "bug_type": null, "idx": 1301}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct expression_token *expression_token_alloc(enum expression_token_type token_type, void *value)\n{\n\tstruct expression_token *token;\n\tswitch (token_type) {\n\tcase TOKEN_TYPE_RESULT:\n\tcase TOKEN_TYPE_OPERATOR:\n\t\ttoken = ast_calloc(1, sizeof(*token));\n\t\tbreak;\n\tcase TOKEN_TYPE_FIELD:\n\t\ttoken = ast_calloc(1, sizeof(*token) + strlen((const char *)value) + 1);\n\t\tbreak;\n\tdefault:\n\t\tast_assert(0);\n\t\treturn NULL;\n\t}\n\tif (!token) {\n\t\treturn NULL;\n\t}\n\ttoken->token_type = token_type;\n\tswitch (token_type) {\n\tcase TOKEN_TYPE_RESULT:\n\t\ttoken->result = *(int *)value;\n\t\tbreak;\n\tcase TOKEN_TYPE_OPERATOR:\n\t\ttoken->op = value;\n\t\tbreak;\n\tcase TOKEN_TYPE_FIELD:\n\t\tstrcpy(token->field, value); \n\t\tbreak;\n\tdefault:\n\t\tast_assert(0);\n\t}\n\treturn token;\n}\n", "bug_type": null, "idx": 1302}
{"project": "Asterisk", "target": 0, "func": "struct stasis_message *stasis_cache_entry_get_aggregate(struct stasis_cache_entry *entry)\n{\n\treturn entry->aggregate;\n}\n", "bug_type": null, "idx": 1303}
{"project": "Asterisk", "target": 0, "func": "};\nint ast_redirecting_reason_parse(const char *data)\n{\n\tint index;\n\tfor (index = 0; index < ARRAY_LEN(redirecting_reason_types); ++index) {\n\t\tif (!strcasecmp(redirecting_reason_types[index].name, data)) {\n\t\t\treturn redirecting_reason_types[index].value;\n\t\t}\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1304}
{"project": "Asterisk", "target": 0, "func": "struct ast_iostream *ast_iostream_from_fd(int *fd)\n{\n\tstruct ast_iostream *stream;\n\tstream = ao2_alloc_options(sizeof(*stream), iostream_dtor,\n\t\tAO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (stream) {\n\t\tstream->timeout = -1;\n\t\tstream->timeout_reset = -1;\n\t\tstream->fd = *fd;\n\t\t*fd = -1;\n\t}\n\treturn stream;\n}\n", "bug_type": null, "idx": 1305}
{"project": "Asterisk", "target": 0, "func": "static int check_header(FILE *f, int hz)\n{\n\tint type, size, formtype;\n\tint data;\n\tif (fread(&type, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Read failed (type)\\n\");\n\t\treturn -1;\n\t}\n\tif (fread(&size, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Read failed (size)\\n\");\n\t\treturn -1;\n\t}\n#if __BYTE_ORDER == __BIG_ENDIAN\n\tsize = ltohl(size);\n#endif\n\tif (fread(&formtype, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Read failed (formtype)\\n\");\n\t\treturn -1;\n\t}\n\tif (memcmp(&type, \"RIFF\", 4)) {\n\t\tast_log(LOG_WARNING, \"Does not begin with RIFF\\n\");\n\t\treturn -1;\n\t}\n\tif (memcmp(&formtype, \"WAVE\", 4)) {\n\t\tast_log(LOG_WARNING, \"Does not contain WAVE\\n\");\n\t\treturn -1;\n\t}\n\t\n\tfor(;;)\n\t{ \n\t\tchar buf[4];\n\t\t\n\t\tif (fread(&buf, 1, 4, f) != 4) {\n\t\t\tast_log(LOG_WARNING, \"Read failed (block header format)\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (fread(&data, 1, 4, f) != 4) {\n\t\t\tast_log(LOG_WARNING, \"Read failed (block '%.4s' header length)\\n\", buf);\n\t\t\treturn -1;\n\t\t}\n#if __BYTE_ORDER == __BIG_ENDIAN\n\t\tdata = ltohl(data);\n#endif\n\t\tif (memcmp(&buf, \"fmt \", 4) == 0) {\n\t\t\tif (check_header_fmt(f, data, hz))\n\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif(memcmp(buf, \"data\", 4) == 0 ) \n\t\t\tbreak;\n\t\tast_log(LOG_DEBUG, \"Skipping unknown block '%.4s'\\n\", buf);\n\t\tif (fseek(f,data,SEEK_CUR) == -1 ) {\n\t\t\tast_log(LOG_WARNING, \"Failed to skip '%.4s' block: %d\\n\", buf, data);\n\t\t\treturn -1;\n\t\t}\n\t}\n#if 0\n\tcurpos = lseek(fd, 0, SEEK_CUR);\n\ttruelength = lseek(fd, 0, SEEK_END);\n\tlseek(fd, curpos, SEEK_SET);\n\ttruelength -= curpos;\n#endif\t\n\treturn data;\n}\n", "bug_type": null, "idx": 1306}
{"project": "Asterisk", "target": 0, "func": "static void set_member_enabled(struct member *mem)\n{\n\tif ((mem->depsfailed == HARD_FAILURE) || (mem->conflictsfailed == HARD_FAILURE))\n\t\treturn;\n\tif ((mem->enabled) || (mem->is_separator))\n\t\treturn;\n\tenable_member(mem);\n\tmem->was_defaulted = 0;\n\tchanges_made++;\n\twhile (calc_dep_failures(1, 0) || calc_conflict_failures(1, 0));\n}\n", "bug_type": null, "idx": 1307}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_unregister_application(app);\n}\n", "bug_type": null, "idx": 1308}
{"project": "Asterisk", "target": 0, "func": "void ast_rtp_publish_rtcp_message(struct ast_rtp_instance *rtp,\n\t\tstruct stasis_message_type *message_type,\n\t\tstruct ast_rtp_rtcp_report *report,\n\t\tstruct ast_json *blob)\n{\n\tRAII_VAR(struct rtcp_message_payload *, payload, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tif (!message_type) {\n\t\treturn;\n\t}\n\tpayload = ao2_alloc(sizeof(*payload), rtcp_message_payload_dtor);\n\tif (!payload || !report) {\n\t\treturn;\n\t}\n\tif (!ast_strlen_zero(rtp->channel_uniqueid)) {\n\t\tpayload->snapshot = ast_channel_snapshot_get_latest(rtp->channel_uniqueid);\n\t}\n\tif (blob) {\n\t\tpayload->blob = blob;\n\t\tast_json_ref(blob);\n\t}\n\tao2_ref(report, +1);\n\tpayload->report = report;\n\tmessage = stasis_message_create(message_type, payload);\n\tif (!message) {\n\t\treturn;\n\t}\n\tstasis_publish(ast_rtp_topic(), message);\n}\n}\nvoid ast_rtp_publish_rtcp_message(struct ast_rtp_instance *rtp,\n\t\tstruct stasis_message_type *message_type,\n\t\tstruct ast_rtp_rtcp_report *report,\n\t\tstruct ast_json *blob)\n{\n\tRAII_VAR(struct rtcp_message_payload *, payload, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tif (!message_type) {\n\t\treturn;\n\t}\n", "bug_type": null, "idx": 1309}
{"project": "Asterisk", "target": 0, "func": "static void set_logging(logging_state_t *state, struct ast_fax_session_details *details)\n{\n\tint level = SPAN_LOG_WARNING;\n        if (details->option.debug) {\n\t\tlevel = SPAN_LOG_DEBUG_3;\n\t}\n\tspan_log_set_message_handler(state, spandsp_log);\n\tspan_log_set_level(state, SPAN_LOG_SHOW_SEVERITY | SPAN_LOG_SHOW_PROTOCOL | level);\n}\n", "bug_type": null, "idx": 1310}
{"project": "Asterisk", "target": 0, "func": "int ooSetCallFDSETs(OOH323CallData* call, struct pollfd* pfds, int *nfds)\n{\n   if(call) {\n    if(call->cmdSock && call->callState < OO_CALL_CLEAR) {\n      pfds[*nfds].fd = call->cmdSock;\n      pfds[*nfds].events = POLLIN;\n      (*nfds)++;\n    }\n    if (0 != call->pH225Channel && 0 != call->pH225Channel->sock) {\n      pfds[*nfds].fd = call->pH225Channel->sock;\n      pfds[*nfds].events = POLLIN;\n      if (call->pH225Channel->outQueue.count > 0 ||\n       (OO_TESTFLAG (call->flags, OO_M_TUNNELING) && \n         0 != call->pH245Channel && \n         call->pH245Channel->outQueue.count>0))\n       pfds[*nfds].events |= POLLOUT;\n      (*nfds)++;\n    }\n    if (0 != call->pH245Channel &&  call->pH245Channel->sock != 0) {\n       pfds[*nfds].fd = call->pH245Channel->sock;\n       pfds[*nfds].events = POLLIN;\n       if (call->pH245Channel->outQueue.count>0)\n        pfds[*nfds].events |= POLLOUT;\n       (*nfds)++;\n      }\n      else if(call->h245listener) {\n       OOTRACEINFO3(\"H.245 Listerner socket being monitored \"\n        \"(%s, %s)\\n\", call->callType, call->callToken);\n       pfds[*nfds].fd = *(call->h245listener);\n       pfds[*nfds].events = POLLIN;\n       (*nfds)++;\n      }\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1311}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235ENCRYPTED (OOCTXT* pctxt, H235ENCRYPTED* pvalue)\n{\n   int stat = ASN_OK;\n   \n   stat = encodeObjectIdentifier (pctxt, &pvalue->algorithmOID);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H235Params (pctxt, &pvalue->paramS);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeOctetString (pctxt, pvalue->encryptedData.numocts, pvalue->encryptedData.data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1312}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_mwi_mailbox_get_msgs_old(const struct ast_mwi_mailbox_object *mailbox)\n{\n\treturn mailbox->msgs_old;\n}\n", "bug_type": null, "idx": 1313}
{"project": "Asterisk", "target": 0, "func": "static void sla_station_destructor(void *obj)\n{\n\tstruct sla_station *station = obj;\n\tast_debug(1, \"sla_station destructor for '%s'\\n\", station->name);\n\tif (!ast_strlen_zero(station->autocontext)) {\n\t\tstruct sla_trunk_ref *trunk_ref;\n\t\tAST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {\n\t\t\tchar exten[AST_MAX_EXTENSION];\n\t\t\tchar hint[AST_MAX_APP];\n\t\t\tsnprintf(exten, sizeof(exten), \"%s_%s\", station->name, trunk_ref->trunk->name);\n\t\t\tsnprintf(hint, sizeof(hint), \"SLA:%s\", exten);\n\t\t\tast_context_remove_extension(station->autocontext, exten, \n\t\t\t\t1, sla_registrar);\n\t\t\tast_context_remove_extension(station->autocontext, hint, \n\t\t\t\tPRIORITY_HINT, sla_registrar);\n\t\t}\n\t}\n\tsla_station_release_refs(station, NULL, 0);\n\tast_string_field_free_memory(station);\n}\n", "bug_type": null, "idx": 1314}
{"project": "Asterisk", "target": 0, "func": "static struct ast_category *ast_category_get(const struct ast_config *config, const char *category_name)\n{\n\treturn category_get(config, category_name, 0);\n}\n", "bug_type": null, "idx": 1315}
{"project": "Asterisk", "target": 0, "func": "static void *hook_launch_thread(void *data)\n{\n\tstruct hook_thread_arg *arg = data;\n\tstruct ast_variable hook_id = {\n\t\t.name = \"HOOK_ID\",\n\t\t.value = arg->hook_id,\n\t};\n\tstruct ast_variable chan_name_var = {\n\t\t.name = \"HOOK_CHANNEL\",\n\t\t.value = arg->chan_name,\n\t\t.next = &hook_id,\n\t};\n\tast_pbx_outgoing_exten(\"Local\", NULL, full_exten_name, 60,\n\t\t\targ->context, arg->exten, 1, NULL, AST_OUTGOING_NO_WAIT,\n\t\t\tNULL, NULL, &chan_name_var, NULL, NULL, 1, NULL);\n\thook_thread_arg_destroy(arg);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1316}
{"project": "Asterisk", "target": 0, "func": "static int caller_id_to_str(const void *obj, const intptr_t *args, char **buf)\n{\n\tconst struct ast_sip_endpoint *endpoint = obj;\n\tconst char *name = S_COR(endpoint->id.self.name.valid,\n\t\t\t\t endpoint->id.self.name.str, NULL);\n\tconst char *number = S_COR(endpoint->id.self.number.valid,\n\t\t\t\t   endpoint->id.self.number.str, NULL);\n\t\n\tint size = 10;\n\tsize += name ? strlen(name) : 0;\n\tsize += number ? strlen(number) : 0;\n\tif (!(*buf = ast_calloc(size + 1, sizeof(char)))) {\n\t\treturn -1;\n\t}\n\tast_callerid_merge(*buf, size + 1, name, number, NULL);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1317}
{"project": "Asterisk", "target": 0, "func": "static int pickup_handler(const struct aco_option *opt,\n\t\tstruct ast_variable *var, void *obj)\n{\n\tstruct features_global_config *global = obj;\n\tstruct ast_features_pickup_config *pickup = global->pickup;\n\treturn pickup_set(pickup, var->name, var->value);\n}\n", "bug_type": null, "idx": 1318}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int direct_media_glare_mitigation_to_str(const void *obj, const intptr_t *args, char **buf)\n{\n\tconst struct ast_sip_endpoint *endpoint = obj;\n\tif (ARRAY_IN_BOUNDS(endpoint->media.direct_media.glare_mitigation, direct_media_glare_mitigation_map)) {\n\t\t*buf = ast_strdup(direct_media_glare_mitigation_map[endpoint->media.direct_media.glare_mitigation]);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1319}
{"project": "Asterisk", "target": 0, "func": "static int sched_order_6_cb(const void *data)\n{\n\tsched_order_check((void *) data, 6);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1320}
{"project": "Asterisk", "target": 0, "func": "\nstatic int ast_change_hint(struct ast_exten *oe, struct ast_exten *ne)\n{\n\tstruct ast_hint *hint;\n\tif (!oe || !ne) {\n\t\treturn -1;\n\t}\n\tao2_lock(hints);\n\t\n\thint = ao2_find(hints, oe, OBJ_UNLINK);\n\tif (!hint) {\n\t\tao2_unlock(hints);\n\t\tast_mutex_unlock(&context_merge_lock);\n\t\treturn -1;\n\t}\n\tremove_hintdevice(hint);\n\t\n\tao2_lock(hint);\n\thint->exten = ne;\n\tao2_unlock(hint);\n\tao2_link(hints, hint);\n\tif (add_hintdevice(hint, ast_get_extension_app(ne))) {\n\t\tast_log(LOG_WARNING, \"Could not add devices for hint: %s@%s.\\n\",\n\t\t\tast_get_extension_name(ne),\n\t\t\tast_get_context_name(ast_get_extension_context(ne)));\n\t}\n\tao2_unlock(hints);\n\tpublish_hint_change(hint, ne);\n\tao2_ref(hint, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1321}
{"project": "Asterisk", "target": 0, "func": "static void *sorcery_memory_retrieve_id(const struct ast_sorcery *sorcery, void *data, const char *type, const char *id)\n{\n\treturn ao2_find(data, id, OBJ_KEY);\n}\n", "bug_type": null, "idx": 1322}
{"project": "Asterisk", "target": 0, "func": "int dundi_ie_append_eid(struct dundi_ie_data *ied, unsigned char ie, dundi_eid *eid)\n{\n\treturn dundi_ie_append_raw(ied, ie, (unsigned char *)eid, sizeof(dundi_eid));\n}\n", "bug_type": null, "idx": 1323}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tif (dahdi_test_timer()) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn (timing_funcs_handle = ast_register_timing_interface(&dahdi_timing)) ?\n\t\tAST_MODULE_LOAD_SUCCESS : AST_MODULE_LOAD_DECLINE;\n}\n", "bug_type": null, "idx": 1324}
{"project": "Asterisk", "target": 0, "func": "\nstatic const char *skip_words(const char *p, int n)\n{\n\tint in_blank = 0;\n\tfor (;n && *p; p++) {\n\t\tif (isblank(*p)  && !in_blank) {\n\t\t\tn--;\t\n\t\t\tin_blank = 1;\n\t\t} else if ( in_blank) {\n\t\t\tin_blank = 0;\n\t\t}\n\t}\n\treturn p;\n}\n", "bug_type": null, "idx": 1325}
{"project": "Asterisk", "target": 0, "func": "static struct ast_format *ilbc_getjoint(const struct ast_format *format1, const struct ast_format *format2)\n{\n\tstruct ast_format *jointformat;\n\tstruct ilbc_attr *attr1 = ast_format_get_attribute_data(format1);\n\tstruct ilbc_attr *attr2 = ast_format_get_attribute_data(format2);\n\tstruct ilbc_attr *attr_res;\n\tif (!attr1) {\n\t\tattr1 = &default_ilbc_attr;\n\t}\n\tif (!attr2) {\n\t\tattr2 = &default_ilbc_attr;\n\t}\n\tjointformat = ast_format_clone(format1);\n\tif (!jointformat) {\n\t\treturn NULL;\n\t}\n\tattr_res = ast_format_get_attribute_data(jointformat);\n\tif (attr1->mode != attr2->mode) {\n\t\tattr_res->mode = 30;\n\t}\n\treturn jointformat;\n}\n", "bug_type": null, "idx": 1326}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpAddG7231Capability(int cap, int txframes, int rxframes, \n                              OOBOOL silenceSuppression, int dir,\n                              cb_StartReceiveChannel startReceiveChannel,\n                              cb_StartTransmitChannel startTransmitChannel,\n                              cb_StopReceiveChannel stopReceiveChannel,\n                              cb_StopTransmitChannel stopTransmitChannel)\n{\n   return ooCapabilityAddSimpleCapability(NULL, cap, txframes, rxframes, \n                             silenceSuppression, dir, startReceiveChannel, \n                             startTransmitChannel, stopReceiveChannel, \n                             stopTransmitChannel, FALSE);\n}\n", "bug_type": null, "idx": 1327}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res;\n\tif (mwi_sorcery_init()\n\t\t|| ast_sorcery_observer_add(mwi_sorcery, MWI_MAILBOX_TYPE, &mwi_observers)\n#if defined(MWI_DEBUG_CLI)\n\t\t|| ast_cli_register_multiple(mwi_cli, ARRAY_LEN(mwi_cli))\n#endif\t\n\t\t) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\t\n\tres = ast_vm_register(&vm_table);\n\tif (res) {\n\t\tast_log(LOG_ERROR, \"Failure registering as a voicemail provider\\n\");\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\t\n\tmwi_initial_events();\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1328}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum AST_REDIRECTING_REASON misdn_to_ast_reason(const enum mISDN_REDIRECTING_REASON q931)\n{\n\tenum AST_REDIRECTING_REASON ast;\n\tswitch (q931) {\n\tdefault:\n\tcase mISDN_REDIRECTING_REASON_UNKNOWN:\n\t\tast = AST_REDIRECTING_REASON_UNKNOWN;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_CALL_FWD_BUSY:\n\t\tast = AST_REDIRECTING_REASON_USER_BUSY;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_NO_REPLY:\n\t\tast = AST_REDIRECTING_REASON_NO_ANSWER;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_DEFLECTION:\n\t\tast = AST_REDIRECTING_REASON_DEFLECTION;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_OUT_OF_ORDER:\n\t\tast = AST_REDIRECTING_REASON_OUT_OF_ORDER;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_CALL_FWD_DTE:\n\t\tast = AST_REDIRECTING_REASON_CALL_FWD_DTE;\n\t\tbreak;\n\tcase mISDN_REDIRECTING_REASON_CALL_FWD:\n\t\tast = AST_REDIRECTING_REASON_UNCONDITIONAL;\n\t\tbreak;\n\t}\n\treturn ast;\n}\n", "bug_type": null, "idx": 1329}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void native_rtp_bridge_stop(struct ast_bridge *bridge, struct ast_channel *target)\n{\n\tstruct ast_bridge_channel *bc0 = AST_LIST_FIRST(&bridge->channels);\n\tstruct ast_bridge_channel *bc1 = AST_LIST_LAST(&bridge->channels);\n\tstruct native_rtp_bridge_channel_data *data0;\n\tstruct native_rtp_bridge_channel_data *data1;\n\tstruct rtp_glue_data *glue0;\n\tstruct rtp_glue_data *glue1;\n\tif (bc0 == bc1) {\n\t\treturn;\n\t}\n\tdata0 = bc0->tech_pvt;\n\tdata1 = bc1->tech_pvt;\n\tif (!data0 || !data1) {\n\t\t\n\t\treturn;\n\t}\n\tglue0 = &data0->glue;\n\tglue1 = &data1->glue;\n\tast_debug(2, \"Bridge '%s'.  Tech stopping '%s' and '%s' with target '%s'\\n\",\n\t\tbridge->uniqueid, ast_channel_name(bc0->chan), ast_channel_name(bc1->chan),\n\t\ttarget ? ast_channel_name(target) : \"none\");\n\tif (!glue0->cb || !glue1->cb) {\n\t\t\n\t\tast_assert(!glue0->cb && !glue1->cb);\n\t\t\n\t\tast_assert(!data0->remote_cb || !data1->remote_cb);\n\t\t\n\t\tif (data0->remote_cb && (!target || target == bc0->chan)) {\n\t\t\tast_channel_lock(bc0->chan);\n\t\t\tast_debug(2, \"Bridge '%s'.  Bringing back '%s' to us\\n\",\n\t\t\t\tbridge->uniqueid, ast_channel_name(bc0->chan));\n\t\t\tdata0->remote_cb->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);\n\t\t\tdata0->remote_cb = NULL;\n\t\t\tast_channel_unlock(bc0->chan);\n\t\t}\n\t\tif (data1->remote_cb && (!target || target == bc1->chan)) {\n\t\t\tast_channel_lock(bc1->chan);\n\t\t\tast_debug(2, \"Bridge '%s'.  Bringing back '%s' to us\\n\",\n\t\t\t\tbridge->uniqueid, ast_channel_name(bc1->chan));\n\t\t\tdata1->remote_cb->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);\n\t\t\tdata1->remote_cb = NULL;\n\t\t\tast_channel_unlock(bc1->chan);\n\t\t}\n\t\treturn;\n\t}\n\tast_channel_lock_both(bc0->chan, bc1->chan);\n\tswitch (glue0->result) {\n\tcase AST_RTP_GLUE_RESULT_LOCAL:\n\t\tif (ast_rtp_instance_get_engine(glue0->audio.instance)->local_bridge) {\n\t\t\tast_rtp_instance_get_engine(glue0->audio.instance)->local_bridge(glue0->audio.instance, NULL);\n\t\t}\n\t\tif (ast_rtp_instance_get_engine(glue1->audio.instance)->local_bridge) {\n\t\t\tast_rtp_instance_get_engine(glue1->audio.instance)->local_bridge(glue1->audio.instance, NULL);\n\t\t}\n\t\tast_rtp_instance_set_bridged(glue0->audio.instance, NULL);\n\t\tast_rtp_instance_set_bridged(glue1->audio.instance, NULL);\n\t\tbreak;\n\tcase AST_RTP_GLUE_RESULT_REMOTE:\n\t\tif (target) {\n\t\t\t\n\t\t\tast_debug(2, \"Bridge '%s'.  Bringing back '%s' to us\\n\",\n\t\t\t\tbridge->uniqueid, ast_channel_name(target));\n\t\t\tif (bc0->chan == target) {\n\t\t\t\tdata0->remote_cb = NULL;\n\t\t\t\tglue0->cb->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);\n\t\t\t} else {\n\t\t\t\tdata1->remote_cb = NULL;\n\t\t\t\tglue1->cb->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tdata0->remote_cb = NULL;\n\t\t\tdata1->remote_cb = NULL;\n\t\t\t\n\t\t\tif (rtp_glue_get_current_combined_result(bc0->chan, bc1->chan)\n\t\t\t\t!= AST_RTP_GLUE_RESULT_FORBID) {\n\t\t\t\tast_debug(2, \"Bridge '%s'.  Bringing back '%s' and '%s' to us\\n\",\n\t\t\t\t\tbridge->uniqueid, ast_channel_name(bc0->chan),\n\t\t\t\t\tast_channel_name(bc1->chan));\n\t\t\t\tglue0->cb->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);\n\t\t\t\tglue1->cb->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);\n\t\t\t} else {\n\t\t\t\tast_debug(2, \"Bridge '%s'.  Skip bringing back '%s' and '%s' to us\\n\",\n\t\t\t\t\tbridge->uniqueid, ast_channel_name(bc0->chan),\n\t\t\t\t\tast_channel_name(bc1->chan));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AST_RTP_GLUE_RESULT_FORBID:\n\t\tbreak;\n\t}\n\trtp_glue_data_reset(glue0);\n\trtp_glue_data_reset(glue1);\n\tast_debug(2, \"Discontinued RTP bridging of '%s' and '%s' - media will flow through Asterisk core\\n\",\n\t\tast_channel_name(bc0->chan), ast_channel_name(bc1->chan));\n\tast_channel_unlock(bc0->chan);\n\tast_channel_unlock(bc1->chan);\n}\n", "bug_type": null, "idx": 1330}
{"project": "Asterisk", "target": 0, "func": "void pvalGlobalsAddStatement( pval *p, pval *statement )\n{\n\tif (p->type != PV_GLOBALS) {\n\t\tast_log(LOG_ERROR, \"pvalGlobalsAddStatement called where first arg is not a Globals!\\n\");\n\t} else {\n\t\tif (!p->u1.statements) {\n\t\t\tp->u1.statements = statement;\n\t\t} else {\n\t\t\tp->u1.statements = linku1(p->u1.statements,statement);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1331}
{"project": "Asterisk", "target": 0, "func": "protected char *\nparse__string(char *out, const char *in)\n{\n\tchar *rv = out;\n\tint n;\n\tfor (;;)\n\t\tswitch (*in) {\n\t\tcase '\\0':\n\t\t\t*out = '\\0';\n\t\t\treturn (rv);\n\t\tcase '\\\\':\n\t\tcase '^':\n\t\t\tif ((n = parse__escape(&in)) == -1)\n\t\t\t\treturn (NULL);\n\t\t\t*out++ = n;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out++ = *in++;\n\t\t\tbreak;\n\t\t}\n}\n", "bug_type": null, "idx": 1332}
{"project": "Asterisk", "target": 0, "func": "static struct agent_pvt *agent_pvt_new(struct agent_cfg *cfg)\n{\n\tstruct agent_pvt *agent;\n\tagent = ao2_alloc(sizeof(*agent), agent_pvt_destructor);\n\tif (!agent) {\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(agent, 32)) {\n\t\tao2_ref(agent, -1);\n\t\treturn NULL;\n\t}\n\tast_string_field_set(agent, username, cfg->username);\n\tast_party_connected_line_init(&agent->waiting_colp);\n\tao2_ref(cfg, +1);\n\tagent->cfg = cfg;\n\tagent->devstate = AST_DEVICE_UNAVAILABLE;\n\treturn agent;\n}\n", "bug_type": null, "idx": 1333}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tRAII_VAR(struct stasis_message_router *, router, ast_cdr_message_router(), ao2_cleanup);\n\tif (router) {\n\t\tstasis_message_router_remove(router, forkcdr_message_type());\n\t}\n\tSTASIS_MESSAGE_TYPE_CLEANUP(forkcdr_message_type);\n\tast_unregister_application(app);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1334}
{"project": "Asterisk", "target": 0, "func": "\nstatic int codec2tolin_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tstruct codec2_translator_pvt *tmp = pvt->pvt;\n\tint x;\n\tfor (x = 0; x < f->datalen; x += CODEC2_FRAME_LEN) {\n\t\tunsigned char *src = f->data.ptr + x;\n\t\tint16_t *dst = pvt->outbuf.i16 + pvt->samples;\n\t\tcodec2_decode(tmp->state, dst, src);\n\t\tpvt->samples += CODEC2_SAMPLES;\n\t\tpvt->datalen += CODEC2_SAMPLES * 2;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1335}
{"project": "Asterisk", "target": 0, "func": "static struct ast_json *contactstatus_to_json(struct stasis_message *msg, const struct stasis_message_sanitizer *sanitize)\n{\n\tstruct ast_endpoint_blob *obj = stasis_message_data(msg);\n\tstruct ast_json *json_endpoint;\n\tstruct ast_json *json_final;\n\tconst char *rtt;\n\tconst struct timeval *tv = stasis_message_timestamp(msg);\n\tjson_endpoint = ast_endpoint_snapshot_to_json(obj->snapshot, NULL);\n\tif (!json_endpoint) {\n\t\treturn NULL;\n\t}\n\t\n\trtt = ast_json_string_get(ast_json_object_get(obj->blob, \"roundtrip_usec\"));\n\tif (!ast_strlen_zero(rtt)) {\n\t\tjson_final = ast_json_pack(\"{s: s, s: o, s: o, s: { s: s, s: s, s: s, s: s } } \",\n\t\t\t\"type\", \"ContactStatusChange\",\n\t\t\t\"timestamp\", ast_json_timeval(*tv, NULL),\n\t\t\t\"endpoint\", json_endpoint,\n\t\t\t\"contact_info\",\n\t\t\t\"uri\", ast_json_string_get(ast_json_object_get(obj->blob, \"uri\")),\n\t\t\t\"contact_status\", ast_json_string_get(ast_json_object_get(obj->blob,\n\t\t\t\t\"contact_status\")),\n\t\t\t\"aor\", ast_json_string_get(ast_json_object_get(obj->blob, \"aor\")),\n\t\t\t\"roundtrip_usec\", rtt);\n\t} else {\n\t\tjson_final = ast_json_pack(\"{s: s, s: o, s: o, s: { s: s, s: s, s: s } } \",\n\t\t\t\"type\", \"ContactStatusChange\",\n\t\t\t\"timestamp\", ast_json_timeval(*tv, NULL),\n\t\t\t\"endpoint\", json_endpoint,\n\t\t\t\"contact_info\",\n\t\t\t\"uri\", ast_json_string_get(ast_json_object_get(obj->blob, \"uri\")),\n\t\t\t\"contact_status\", ast_json_string_get(ast_json_object_get(obj->blob,\n\t\t\t\t\"contact_status\")),\n\t\t\t\"aor\", ast_json_string_get(ast_json_object_get(obj->blob, \"aor\")));\n\t}\n\tif (!json_final) {\n\t\tast_json_unref(json_endpoint);\n\t}\n\treturn json_final;\n}\n", "bug_type": null, "idx": 1336}
{"project": "Asterisk", "target": 0, "func": "enum ast_transport_monitor_reg ast_sip_transport_monitor_register(pjsip_transport *transport,\n\tast_transport_monitor_shutdown_cb cb, void *ao2_data)\n{\n\tstruct ao2_container *transports;\n\tstruct transport_monitor *monitored;\n\tenum ast_transport_monitor_reg res = AST_TRANSPORT_MONITOR_REG_NOT_FOUND;\n\ttransports = ao2_global_obj_ref(active_transports);\n\tif (!transports) {\n\t\treturn res;\n\t}\n\tao2_lock(transports);\n\tmonitored = ao2_find(transports, transport->obj_name, OBJ_SEARCH_KEY | OBJ_NOLOCK);\n\tif (monitored) {\n\t\tint idx;\n\t\tstruct transport_monitor_notifier new_monitor;\n\t\t\n\t\tfor (idx = AST_VECTOR_SIZE(&monitored->monitors); idx--;) {\n\t\t\tstruct transport_monitor_notifier *notifier;\n\t\t\tnotifier = AST_VECTOR_GET_ADDR(&monitored->monitors, idx);\n\t\t\tif (notifier->cb == cb) {\n\t\t\t\t\n\t\t\t\tao2_replace(notifier->data, ao2_data);\n\t\t\t\tres = AST_TRANSPORT_MONITOR_REG_REPLACED;\n\t\t\t\tgoto register_done;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnew_monitor.cb = cb;\n\t\tnew_monitor.data = ao2_bump(ao2_data);\n\t\tif (AST_VECTOR_APPEND(&monitored->monitors, new_monitor)) {\n\t\t\tao2_cleanup(ao2_data);\n\t\t\tres = AST_TRANSPORT_MONITOR_REG_FAILED;\n\t\t}\nregister_done:\n\t\tao2_ref(monitored, -1);\n\t}\n\tao2_unlock(transports);\n\tao2_ref(transports, -1);\n\treturn res;\n}\n", "bug_type": null, "idx": 1337}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(hash_test)\n{\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\tstruct hash_test data = {};\n\tpthread_t grow_thread, count_thread, lookup_thread, shrink_thread;\n\tvoid *thread_results;\n\tint i;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"thrash\";\n\t\tinfo->category = \"/main/hashtab/\";\n\t\tinfo->summary = \"Testing hashtab concurrency\";\n\t\tinfo->description = \"Test hashtab concurrency correctness.\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tast_test_status_update(test, \"Executing hash concurrency test...\\n\");\n\tdata.test = test;\n\tdata.preload = MAX_HASH_ENTRIES / 2;\n\tdata.max_grow = MAX_HASH_ENTRIES - data.preload;\n\tdata.deadline = ast_tvadd(ast_tvnow(), ast_tv(MAX_TEST_SECONDS, 0));\n\tdata.to_be_thrashed = ast_hashtab_create(MAX_HASH_ENTRIES / 100,\n\t\tast_hashtab_compare_strings_nocase, ast_hashtab_resize_java,\n\t\tast_hashtab_newsize_java, ast_hashtab_hash_string_nocase, 1);\n\tif (data.to_be_thrashed == NULL) {\n\t\tast_test_status_update(test, \"Allocation failed\\n\");\n\t\t\n\t\treturn AST_TEST_FAIL;\n\t}\n\t\n\tfor (i = 1; i < data.preload; ++i) {\n\t\tchar *obj = ht_new(-i);\n\t\tif (obj == NULL) {\n\t\t\tast_test_status_update(test, \"Allocation failed\\n\");\n\t\t\tast_hashtab_destroy(data.to_be_thrashed, ht_delete);\n\t\t\treturn AST_TEST_FAIL;\n\t\t}\n\t\tast_hashtab_insert_immediate(data.to_be_thrashed, obj);\n\t}\n\t\n\tast_pthread_create(&grow_thread, NULL, hash_test_grow, &data);\n\t\n\tast_pthread_create(&count_thread, NULL, hash_test_count, &data);\n\t\n\tast_pthread_create(&lookup_thread, NULL, hash_test_lookup, &data);\n\t\n\tast_pthread_create(&shrink_thread, NULL, hash_test_shrink, &data);\n\tpthread_join(grow_thread, &thread_results);\n\tif (thread_results != NULL) {\n\t\tast_test_status_update(test, \"Growth thread failed: %s\\n\",\n\t\t\t(char *)thread_results);\n\t\tres = AST_TEST_FAIL;\n\t}\n\tpthread_join(count_thread, &thread_results);\n\tif (thread_results != NULL) {\n\t\tast_test_status_update(test, \"Count thread failed: %s\\n\",\n\t\t\t(char *)thread_results);\n\t\tres = AST_TEST_FAIL;\n\t}\n\tpthread_join(lookup_thread, &thread_results);\n\tif (thread_results != NULL) {\n\t\tast_test_status_update(test, \"Lookup thread failed: %s\\n\",\n\t\t\t(char *)thread_results);\n\t\tres = AST_TEST_FAIL;\n\t}\n\tpthread_join(shrink_thread, &thread_results);\n\tif (thread_results != NULL) {\n\t\tast_test_status_update(test, \"Shrink thread failed: %s\\n\",\n\t\t\t(char *)thread_results);\n\t\tres = AST_TEST_FAIL;\n\t}\n\tif (ast_hashtab_size(data.to_be_thrashed) != data.max_grow) {\n\t\tast_test_status_update(test,\n\t\t\t\"Invalid hashtab size. Expected: %d, Actual: %d\\n\",\n\t\t\tdata.max_grow, ast_hashtab_size(data.to_be_thrashed));\n\t\tres = AST_TEST_FAIL;\n\t}\n\tast_hashtab_destroy(data.to_be_thrashed, ht_delete);\n\treturn res;\n}\n", "bug_type": null, "idx": 1338}
{"project": "Asterisk", "target": 0, "func": "static int qualify_and_schedule_cb_without_aor(void *obj, void *arg, int flags)\n{\n\tqualify_and_schedule_contact((struct ast_sip_contact *) obj);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1339}
{"project": "Asterisk", "target": 0, "func": "ari_validator ast_ari_validate_config_tuple_fn(void)\n{\n\treturn ast_ari_validate_config_tuple;\n}\n", "bug_type": null, "idx": 1340}
{"project": "Asterisk", "target": 0, "func": "static int extstate_read(struct ast_channel *chan, const char *cmd, char *data,\n\tchar *buf, size_t len)\n{\n\tchar *exten, *context;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"EXTENSION_STATE requires an extension\\n\");\n\t\treturn -1;\n\t}\n\tcontext = exten = data;\n\tstrsep(&context, \"@\");\n\tif (ast_strlen_zero(context))\n\t\tcontext = \"default\";\n\tif (ast_strlen_zero(exten)) {\n\t\tast_log(LOG_WARNING, \"EXTENSION_STATE requires an extension\\n\");\n\t\treturn -1;\n\t}\n\tast_copy_string(buf, \n\t\tast_extstate_str(ast_extension_state(chan, context, exten)), len);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1341}
{"project": "Asterisk", "target": 0, "func": "static int update_pgsql(const char *database, const char *tablename, const char *keyfield,\n\t\t\t\t\t\tconst char *lookup, const struct ast_variable *fields)\n{\n\tRAII_VAR(PGresult *, result, NULL, PQclear);\n\tint numrows = 0, pgresult;\n\tconst struct ast_variable *field = fields;\n\tstruct ast_str *sql = ast_str_thread_get(&sql_buf, 100);\n\tstruct ast_str *escapebuf = ast_str_thread_get(&escapebuf_buf, 100);\n\tstruct tables *table;\n\tstruct columns *column = NULL;\n\t\n\tdatabase = dbname;\n\tif (!tablename) {\n\t\tast_log(LOG_WARNING, \"PostgreSQL RealTime: No table specified.\\n\");\n\t\treturn -1;\n\t}\n\tif (!(table = find_table(database, tablename))) {\n\t\tast_log(LOG_ERROR, \"Table '%s' does not exist!!\\n\", tablename);\n\t\treturn -1;\n\t}\n\t\n\tast_mutex_lock(&pgsql_lock);\n\tif (!pgsql_reconnect(database)) {\n\t\tast_mutex_unlock(&pgsql_lock);\n\t\trelease_table(table);\n\t\treturn -1;\n\t}\n\t\n\tif (!field) {\n\t\tast_log(LOG_WARNING,\n\t\t\t\t\"PostgreSQL RealTime: Realtime retrieval requires at least 1 parameter and 1 value to search on.\\n\");\n\t\tif (pgsqlConn) {\n\t\t\tPQfinish(pgsqlConn);\n\t\t\tpgsqlConn = NULL;\n\t\t}\n\t\tast_mutex_unlock(&pgsql_lock);\n\t\trelease_table(table);\n\t\treturn -1;\n\t}\n\t\n\tAST_LIST_TRAVERSE(&table->columns, column, list) {\n\t\tif (strcmp(column->name, field->name) == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!column) {\n\t\tast_log(LOG_ERROR, \"PostgreSQL RealTime: Updating on column '%s', but that column does not exist within the table '%s'!\\n\", field->name, tablename);\n\t\tast_mutex_unlock(&pgsql_lock);\n\t\trelease_table(table);\n\t\treturn -1;\n\t}\n\t\n\tESCAPE_STRING(escapebuf, field->value);\n\tif (pgresult) {\n\t\tast_log(LOG_ERROR, \"PostgreSQL RealTime: detected invalid input: '%s'\\n\", field->value);\n\t\tast_mutex_unlock(&pgsql_lock);\n\t\trelease_table(table);\n\t\treturn -1;\n\t}\n\tast_str_set(&sql, 0, \"UPDATE %s SET %s = '%s'\", tablename, field->name, ast_str_buffer(escapebuf));\n\twhile ((field = field->next)) {\n\t\tif (!find_column(table, field->name)) {\n\t\t\tast_log(LOG_NOTICE, \"Attempted to update column '%s' in table '%s', but column does not exist!\\n\", field->name, tablename);\n\t\t\tcontinue;\n\t\t}\n\t\tESCAPE_STRING(escapebuf, field->value);\n\t\tif (pgresult) {\n\t\t\tast_log(LOG_ERROR, \"PostgreSQL RealTime: detected invalid input: '%s'\\n\", field->value);\n\t\t\tast_mutex_unlock(&pgsql_lock);\n\t\t\trelease_table(table);\n\t\t\treturn -1;\n\t\t}\n\t\tast_str_append(&sql, 0, \", %s = '%s'\", field->name, ast_str_buffer(escapebuf));\n\t}\n\trelease_table(table);\n\tESCAPE_STRING(escapebuf, lookup);\n\tif (pgresult) {\n\t\tast_log(LOG_ERROR, \"PostgreSQL RealTime: detected invalid input: '%s'\\n\", lookup);\n\t\tast_mutex_unlock(&pgsql_lock);\n\t\treturn -1;\n\t}\n\tast_str_append(&sql, 0, \" WHERE %s = '%s'\", keyfield, ast_str_buffer(escapebuf));\n\tast_debug(1, \"PostgreSQL RealTime: Update SQL: %s\\n\", ast_str_buffer(sql));\n\t\n\tif (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {\n\t\tast_mutex_unlock(&pgsql_lock);\n\t\treturn -1;\n\t} else {\n\t\tExecStatusType result_status = PQresultStatus(result);\n\t\tif (result_status != PGRES_COMMAND_OK\n\t\t\t&& result_status != PGRES_TUPLES_OK\n\t\t\t&& result_status != PGRES_NONFATAL_ERROR) {\n\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\"PostgreSQL RealTime: Failed to query database. Check debug for more info.\\n\");\n\t\t\tast_debug(1, \"PostgreSQL RealTime: Query: %s\\n\", ast_str_buffer(sql));\n\t\t\tast_debug(1, \"PostgreSQL RealTime: Query Failed because: %s (%s)\\n\",\n\t\t\t\t\t\tPQresultErrorMessage(result), PQresStatus(result_status));\n\t\t\tast_mutex_unlock(&pgsql_lock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tnumrows = atoi(PQcmdTuples(result));\n\tast_mutex_unlock(&pgsql_lock);\n\tast_debug(1, \"PostgreSQL RealTime: Updated %d rows on table: %s\\n\", numrows, tablename);\n\t\n\tif (numrows >= 0)\n\t\treturn (int) numrows;\n\treturn -1;\n}\n", "bug_type": null, "idx": 1342}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225_SeqOfH225H248PackagesDescriptor (OOCTXT* pctxt, H225_SeqOfH225H248PackagesDescriptor* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT xx1;\n   \n   stat = decodeLength (pctxt, &pvalue->n);\n   if (stat != ASN_OK) return stat;\n   \n   ALLOC_ASN1ARRAY (pctxt, pvalue, H225H248PackagesDescriptor);\n   for (xx1 = 0; xx1 < pvalue->n; xx1++) {\n      invokeStartElement (pctxt, \"elem\", xx1);\n      stat = asn1PD_H225H248PackagesDescriptor (pctxt, &pvalue->elem[xx1]);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"elem\", xx1);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1343}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res = 0;\n\tstruct ast_db_entry *db_entry, *db_tree;\n\t\n\tdb_entry = db_tree = ast_db_gettree(astdb_family, NULL);\n\tfor (; db_entry; db_entry = db_entry->next) {\n\t\tconst char *dev_name = strrchr(db_entry->key, '/') + 1;\n\t\tif (dev_name <= (const char *) 1)\n\t\t\tcontinue;\n\t\tast_devstate_changed(ast_devstate_val(db_entry->data),\n\t\t\tAST_DEVSTATE_CACHABLE, \"Custom:%s\", dev_name);\n\t}\n\tast_db_freetree(db_tree);\n\tdb_tree = NULL;\n\tres |= ast_custom_function_register(&devstate_function);\n\tres |= ast_custom_function_register(&hint_function);\n\tres |= ast_devstate_prov_add(\"Custom\", custom_devstate_callback);\n\tres |= ast_cli_register_multiple(cli_funcdevstate, ARRAY_LEN(cli_funcdevstate));\n\treturn res;\n}\n", "bug_type": null, "idx": 1344}
{"project": "Asterisk", "target": 0, "func": "static int ast_all_zeros(const char *s)\n{\n\twhile (*s) {\n\t\tif (*s > 32)\n\t\t\treturn 0;\n\t\ts++;\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 1345}
{"project": "Asterisk", "target": 0, "func": "static int action_transfer(struct mansession *s, const struct message *m)\n{\n\tstruct dahdi_pvt *p;\n\tconst char *channel = astman_get_header(m, \"DAHDIChannel\");\n\tif (ast_strlen_zero(channel)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\tp = find_channel_from_str(channel);\n\tif (!p) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn 0;\n\t}\n\tif (!dahdi_analog_lib_handles(p->sig, 0, 0)) {\n\t\tastman_send_error(s, m, \"Channel signaling is not analog\");\n\t\treturn 0;\n\t}\n\tdahdi_fake_event(p,TRANSFER);\n\tastman_send_ack(s, m, \"DAHDITransfer\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 1346}
{"project": "Asterisk", "target": 0, "func": "static enum ast_websocket_result websocket_client_connect(struct ast_websocket *ws)\n{\n\tenum ast_websocket_result res;\n\t\n\tif (!(ws->client->ser = ast_tcptls_client_start(\n\t\t      ast_tcptls_client_create(ws->client->args)))) {\n\t\treturn WS_CLIENT_START_ERROR;\n\t}\n\tif ((res = websocket_client_handshake(ws->client)) != WS_OK) {\n\t\tao2_ref(ws->client->ser, -1);\n\t\tws->client->ser = NULL;\n\t\treturn res;\n\t}\n\tws->stream = ws->client->ser->stream;\n\tws->secure = ast_iostream_get_ssl(ws->stream) ? 1 : 0;\n\tws->client->ser->stream = NULL;\n\tast_sockaddr_copy(&ws->address, &ws->client->ser->remote_address);\n\treturn WS_OK;\n}\n", "bug_type": null, "idx": 1347}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245RedundancyEncodingDTMode (OOCTXT* pctxt, H245RedundancyEncodingDTMode* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"redundancyEncodingMethod\", -1);\n   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"redundancyEncodingMethod\", -1);\n   \n   invokeStartElement (pctxt, \"primary\", -1);\n   stat = asn1PD_H245RedundancyEncodingDTModeElement (pctxt, &pvalue->primary);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"primary\", -1);\n   \n   invokeStartElement (pctxt, \"secondary\", -1);\n   stat = asn1PD_H245_SeqOfH245RedundancyEncodingDTModeElement (pctxt, &pvalue->secondary);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"secondary\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1348}
{"project": "Asterisk", "target": 0, "func": "\nstatic void check_macro_returns(pval *macro)\n{\n\tpval *i;\n\tif (!macro->u3.macro_statements)\n\t{\n\t\tpval *z = calloc(1, sizeof(struct pval));\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The macro %s is empty! I will insert a return.\\n\",\n\t\t\t\tmacro->filename, macro->startline, macro->endline, macro->u1.str);\n\t\tz->type = PV_RETURN;\n\t\tz->startline = macro->startline;\n\t\tz->endline = macro->endline;\n\t\tz->startcol = macro->startcol;\n\t\tz->endcol = macro->endcol;\n\t\tz->filename = strdup(macro->filename);\n\t\tmacro->u3.macro_statements = z;\n\t\treturn;\n\t}\n\tfor (i=macro->u3.macro_statements; i; i=i->next) {\n\t\t\n\t\tif (i->next == NULL) {\n\t\t\tif (i->type != PV_RETURN) {\n\t\t\t\tpval *z = calloc(1, sizeof(struct pval));\n\t\t\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The macro %s does not end with a return; I will insert one.\\n\",\n\t\t\t\t\t\tmacro->filename, macro->startline, macro->endline, macro->u1.str);\n\t\t\t\tz->type = PV_RETURN;\n\t\t\t\tz->startline = macro->startline;\n\t\t\t\tz->endline = macro->endline;\n\t\t\t\tz->startcol = macro->startcol;\n\t\t\t\tz->endcol = macro->endcol;\n\t\t\t\tz->filename = strdup(macro->filename);\n\t\t\t\ti->next = z;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n", "bug_type": null, "idx": 1349}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225GatekeeperReject (OOCTXT* pctxt, H225GatekeeperReject* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.altGKInfoPresent ||\n   pvalue->m.tokensPresent ||\n   pvalue->m.cryptoTokensPresent ||\n   pvalue->m.integrityCheckValuePresent ||\n   pvalue->m.featureSetPresent ||\n   pvalue->m.genericDataPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.nonStandardDataPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.gatekeeperIdentifierPresent);\n   \n   stat = asn1PE_H225RequestSeqNum (pctxt, pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      stat = asn1PE_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.gatekeeperIdentifierPresent) {\n      stat = asn1PE_H225GatekeeperIdentifier (pctxt, pvalue->gatekeeperIdentifier);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = asn1PE_H225GatekeeperRejectReason (pctxt, &pvalue->rejectReason);\n   if (stat != ASN_OK) return stat;\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 5);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.altGKInfoPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.tokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.cryptoTokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.integrityCheckValuePresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.featureSetPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.genericDataPresent);\n      \n      if (pvalue->m.altGKInfoPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225AltGKInfo (&lctxt, &pvalue->altGKInfo);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.tokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225ClearToken (&lctxt, &pvalue->tokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.cryptoTokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225CryptoH323Token (&lctxt, &pvalue->cryptoTokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.integrityCheckValuePresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225ICV (&lctxt, &pvalue->integrityCheckValue);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.featureSetPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225FeatureSet (&lctxt, &pvalue->featureSet);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.genericDataPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225GenericData (&lctxt, &pvalue->genericData);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1350}
{"project": "Asterisk", "target": 0, "func": "int ast_get_srv(struct ast_channel *chan, char *host, int hostlen, int *port, const char *service)\n{\n\tstruct srv_context context = { .entries = AST_LIST_HEAD_NOLOCK_INIT_VALUE };\n\tstruct srv_entry *current;\n\tint ret;\n\tif (chan && ast_autoservice_start(chan) < 0) {\n\t\treturn -1;\n\t}\n\tret = ast_search_dns(&context, service, C_IN, T_SRV, srv_callback);\n\tif (context.have_weights) {\n\t\tprocess_weights(&context);\n\t}\n\tif (chan) {\n\t\tret |= ast_autoservice_stop(chan);\n\t}\n\t\n\t\n\tif ((ret > 0) && (current = AST_LIST_REMOVE_HEAD(&context.entries, list))) {\n\t\tast_copy_string(host, current->host, hostlen);\n\t\t*port = current->port;\n\t\tast_free(current);\n\t\tast_debug(4, \"ast_get_srv: SRV lookup for '%s' mapped to host %s, port %d\\n\",\n\t\t\t\t    service, host, *port);\n\t} else {\n\t\thost[0] = '\\0';\n\t\t*port = -1;\n\t}\n\twhile ((current = AST_LIST_REMOVE_HEAD(&context.entries, list))) {\n\t\tast_free(current);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 1351}
{"project": "Asterisk", "target": 0, "func": "char *malloccopy( char *string)\n{\n    char *result;\n    result = malloc( strlen( string) + 1);\n    if (result != NULL)\n\tstrcpy( result, string);\n    return result;\n}\n", "bug_type": null, "idx": 1352}
{"project": "Asterisk", "target": 0, "func": "\nstatic int expiration_struct2str(const void *obj, const intptr_t *args, char **buf)\n{\n\tconst struct ast_sip_contact *contact = obj;\n\treturn (ast_asprintf(buf, \"%ld\", contact->expiration_time.tv_sec) < 0) ? -1 : 0;\n}\n", "bug_type": null, "idx": 1353}
{"project": "Asterisk", "target": 0, "func": "static int app_exec(struct ast_channel *chan, const char *data)\n{\n\tstruct ast_flags flags = { 0, };\n\tchar *opts[0];\n\tstruct playlist_entry *entry;\n\tint child_stdin[2] = { -1, -1 };\n\tint child_stdout[2] = { -1, -1 };\n\tint child_stderr[2] = { -1, -1 };\n\tstruct ast_iostream *stream_stdin = NULL, *stream_stdout = NULL,\n\t\t*stream_stderr = NULL;\n\tint res = -1;\n\tint pid;\n\tstruct ast_tcptls_session_instance *ser = NULL;\n\tstruct ivr_localuser foo = {\n\t\t.playlist = AST_LIST_HEAD_INIT_VALUE,\n\t\t.finishlist = AST_LIST_HEAD_INIT_VALUE,\n\t\t.gen_active = 0,\n\t\t.playing_silence = 1,\n\t};\n\tstruct ivr_localuser *u = &foo;\n\tchar *buf;\n\tint j;\n\tchar *s, **app_args, *e; \n\tstruct ast_str *comma_delim_args = ast_str_alloca(100);\n\tAST_DECLARE_APP_ARGS(eivr_args,\n\t\tAST_APP_ARG(application);\n\t\tAST_APP_ARG(options);\n\t);\n\tAST_DECLARE_APP_ARGS(application_args,\n\t\tAST_APP_ARG(cmd)[32];\n\t);\n\tu->abort_current_sound = 0;\n\tu->chan = chan;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_ERROR, \"ExternalIVR requires a command to execute\\n\");\n\t\tgoto exit;\n\t}\n\tbuf = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(eivr_args, buf);\n\tast_verb(4, \"ExternalIVR received application and arguments: %s\\n\", eivr_args.application);\n\tast_verb(4, \"ExternalIVR received options: %s\\n\", eivr_args.options);\n\t\n\tif ((s = strchr(eivr_args.application, '('))) {\n\t\ts[0] = ',';\n\t\tif ((e = strrchr(s, ')'))) {\n\t\t\t*e = '\\0';\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Parse error, missing closing parenthesis\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tAST_STANDARD_APP_ARGS(application_args, eivr_args.application);\n\tapp_args = application_args.argv;\n\t\n\tast_str_reset(comma_delim_args);\n\tfor (j = 0; application_args.cmd[j] != NULL; j++) {\n\t\tast_str_append(&comma_delim_args, 0, \"%s%s\", j == 0 ? \"\" : \",\", application_args.cmd[j]);\n\t}\n\t\n\tif (eivr_args.options && (s = strchr(eivr_args.options, ','))) {\n\t\t*s = '\\0';\n\t}\n\t\n\tast_verb(4, \"Parsing options from: [%s]\\n\", eivr_args.options);\n\tast_app_parse_options(app_opts, &flags, opts, eivr_args.options);\n\tif (ast_test_flag(&flags, noanswer)) {\n\t\tast_verb(4, \"noanswer is set\\n\");\n\t}\n\tif (ast_test_flag(&flags, ignore_hangup)) {\n\t\tast_verb(4, \"ignore_hangup is set\\n\");\n\t}\n\tif (ast_test_flag(&flags, run_dead)) {\n\t\tast_verb(4, \"run_dead is set\\n\");\n\t}\n\tif (!(ast_test_flag(&flags, noanswer))) {\n\t\tast_verb(3, \"Answering channel and starting generator\\n\");\n\t\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\t\tif (ast_test_flag(&flags, run_dead)) {\n\t\t\t\tast_chan_log(LOG_ERROR, chan, \"Running ExternalIVR with 'd'ead flag on non-hungup channel isn't supported\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tast_answer(chan);\n\t\t}\n\t\tif (ast_activate_generator(chan, &gen, u) < 0) {\n\t\t\tast_chan_log(LOG_ERROR, chan, \"Failed to activate generator\\n\");\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tu->gen_active = 1;\n\t\t}\n\t}\n\tif (!strncmp(app_args[0], \"ivr://\", sizeof(\"ivr://\") - 1)) {\n\t\tstruct ast_tcptls_session_args ivr_desc = {\n\t\t\t.accept_fd = -1,\n\t\t\t.name = \"IVR\",\n\t\t};\n\t\tstruct ast_sockaddr *addrs;\n\t\tint num_addrs = 0, i = 0;\n\t\tchar *host = app_args[0] + sizeof(\"ivr://\") - 1;\n\t\t\n\t\tast_debug(1, \"Parsing hostname/port for socket connect from \\\"%s\\\"\\n\", host);\n\t\tif (!(num_addrs = ast_sockaddr_resolve(&addrs, host, 0, AST_AF_UNSPEC))) {\n\t\t\tast_chan_log(LOG_ERROR, chan, \"Unable to locate host '%s'\\n\", host);\n\t\t\tgoto exit;\n\t\t}\n\t\tfor (i = 0; i < num_addrs; i++) {\n\t\t\tif (!ast_sockaddr_port(&addrs[i])) {\n\t\t\t\t\n\t\t\t\tast_sockaddr_set_port(&addrs[i], EXTERNALIVR_PORT);\n\t\t\t}\n\t\t\tast_sockaddr_copy(&ivr_desc.remote_address, &addrs[i]);\n\t\t\tif (!(ser = ast_tcptls_client_create(&ivr_desc)) || !(ser = ast_tcptls_client_start(ser))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tast_free(addrs);\n\t\tif (i == num_addrs) {\n\t\t\tast_chan_log(LOG_ERROR, chan, \"Could not connect to any host.  ExternalIVR failed.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tres = eivr_comm(chan, u, ser->stream, ser->stream, NULL, comma_delim_args, flags);\n\t} else {\n\t\tif (pipe(child_stdin)) {\n\t\t\tast_chan_log(LOG_ERROR, chan, \"Could not create pipe for child input: %s\\n\", strerror(errno));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (pipe(child_stdout)) {\n\t\t\tast_chan_log(LOG_ERROR, chan, \"Could not create pipe for child output: %s\\n\", strerror(errno));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (pipe(child_stderr)) {\n\t\t\tast_chan_log(LOG_ERROR, chan, \"Could not create pipe for child errors: %s\\n\", strerror(errno));\n\t\t\tgoto exit;\n\t\t}\n\t\tpid = ast_safe_fork(0);\n\t\tif (pid < 0) {\n\t\t\tast_log(LOG_ERROR, \"Failed to fork(): %s\\n\", strerror(errno));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!pid) {\n\t\t\t\n\t\t\tif (ast_opt_high_priority)\n\t\t\t\tast_set_priority(0);\n\t\t\tdup2(child_stdin[0], STDIN_FILENO);\n\t\t\tdup2(child_stdout[1], STDOUT_FILENO);\n\t\t\tdup2(child_stderr[1], STDERR_FILENO);\n\t\t\tast_close_fds_above_n(STDERR_FILENO);\n\t\t\texecv(app_args[0], app_args);\n\t\t\tfprintf(stderr, \"Failed to execute '%s': %s\\n\", app_args[0], strerror(errno));\n\t\t\t_exit(1);\n\t\t} else {\n\t\t\t\n\t\t\tclose(child_stdin[0]);\n\t\t\tchild_stdin[0] = -1;\n\t\t\tclose(child_stdout[1]);\n\t\t\tchild_stdout[1] = -1;\n\t\t\tclose(child_stderr[1]);\n\t\t\tchild_stderr[1] = -1;\n\t\t\tstream_stdin  = ast_iostream_from_fd(&child_stdin[1]);\n\t\t\tstream_stdout = ast_iostream_from_fd(&child_stdout[0]);\n\t\t\tstream_stderr = ast_iostream_from_fd(&child_stderr[0]);\n\t\t\tres = eivr_comm(chan, u, stream_stdin, stream_stdout, stream_stderr, comma_delim_args, flags);\n\t\t}\n\t}\n\texit:\n\tif (u->gen_active) {\n\t\tast_deactivate_generator(chan);\n\t}\n\tif (stream_stdin) {\n\t\tast_iostream_close(stream_stdin);\n\t}\n\tif (stream_stdout) {\n\t\tast_iostream_close(stream_stdout);\n\t}\n\tif (stream_stderr) {\n\t\tast_iostream_close(stream_stderr);\n\t}\n\tif (child_stdin[0] > -1) {\n\t\tclose(child_stdin[0]);\n\t}\n\tif (child_stdin[1] > -1) {\n\t\tclose(child_stdin[1]);\n\t}\n\tif (child_stdout[0] > -1) {\n\t\tclose(child_stdout[0]);\n\t}\n\tif (child_stdout[1] > -1) {\n\t\tclose(child_stdout[1]);\n\t}\n\tif (child_stderr[0] > -1) {\n\t\tclose(child_stderr[0]);\n\t}\n\tif (child_stderr[1] > -1) {\n\t\tclose(child_stderr[1]);\n\t}\n\tif (ser) {\n\t\tao2_ref(ser, -1);\n\t}\n\twhile ((entry = AST_LIST_REMOVE_HEAD(&u->playlist, list))) {\n\t\tast_free(entry);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1354}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tcrypto_init();\n\tif (ast_opt_init_keys) {\n\t\tcrypto_load(STDIN_FILENO, STDOUT_FILENO);\n\t} else {\n\t\tcrypto_load(-1, -1);\n\t}\n\t\n\tast_module_shutdown_ref(ast_module_info->self);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1355}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_asterisk_update_object_parse_body(\n\tstruct ast_json *body,\n\tstruct ast_ari_asterisk_update_object_args *args)\n{\n\t\n\treturn 0;\n}\n", "bug_type": null, "idx": 1356}
{"project": "Asterisk", "target": 0, "func": "};\nstatic pj_bool_t distributor(pjsip_rx_data *rdata)\n{\n\tpjsip_dialog *dlg;\n\tstruct distributor_dialog_data *dist = NULL;\n\tstruct ast_taskprocessor *serializer = NULL;\n\tpjsip_rx_data *clone;\n\tif (!ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {\n\t\t\n\t\treturn PJ_TRUE;\n\t}\n\tdlg = find_dialog(rdata);\n\tif (dlg) {\n\t\tast_debug(3, \"Searching for serializer associated with dialog %s for %s\\n\",\n\t\t\tdlg->obj_name, pjsip_rx_data_get_info(rdata));\n\t\tdist = ao2_find(dialog_associations, dlg, OBJ_SEARCH_KEY);\n\t\tif (dist) {\n\t\t\tao2_lock(dist);\n\t\t\tserializer = ao2_bump(dist->serializer);\n\t\t\tao2_unlock(dist);\n\t\t\tif (serializer) {\n\t\t\t\tast_debug(3, \"Found serializer %s associated with dialog %s\\n\",\n\t\t\t\t\tast_taskprocessor_name(serializer), dlg->obj_name);\n\t\t\t}\n\t\t}\n\t}\n\tif (serializer) {\n\t\t\n\t} else if (rdata->msg_info.msg->type == PJSIP_RESPONSE_MSG) {\n\t\tast_debug(3, \"No dialog serializer for %s.  Using request transaction as basis.\\n\",\n\t\t\tpjsip_rx_data_get_info(rdata));\n\t\tserializer = find_request_serializer(rdata);\n\t\tif (!serializer) {\n\t\t\t\n\t\t\tserializer = ast_sip_get_distributor_serializer(rdata);\n\t\t}\n\t} else if (!pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_cancel_method)\n\t\t|| !pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_bye_method)) {\n\t\t\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata,\n\t\t\tPJSIP_SC_CALL_TSX_DOES_NOT_EXIST, NULL, NULL, NULL);\n\t\tao2_cleanup(dist);\n\t\treturn PJ_TRUE;\n\t} else {\n\t\tif (ast_taskprocessor_alert_get()) {\n\t\t\t\n\t\t\tast_debug(3, \"Taskprocessor overload alert: Ignoring '%s'.\\n\",\n\t\t\t\tpjsip_rx_data_get_info(rdata));\n\t\t\tao2_cleanup(dist);\n\t\t\treturn PJ_TRUE;\n\t\t}\n\t\t\n\t\tserializer = ast_sip_get_distributor_serializer(rdata);\n\t}\n\tif (pjsip_rx_data_clone(rdata, 0, &clone) != PJ_SUCCESS) {\n\t\tast_taskprocessor_unreference(serializer);\n\t\tao2_cleanup(dist);\n\t\treturn PJ_TRUE;\n\t}\n\tif (dist) {\n\t\tao2_lock(dist);\n\t\tclone->endpt_info.mod_data[endpoint_mod.id] = ao2_bump(dist->endpoint);\n\t\tao2_unlock(dist);\n\t\tao2_cleanup(dist);\n\t}\n\tif (ast_sip_push_task(serializer, distribute, clone)) {\n\t\tao2_cleanup(clone->endpt_info.mod_data[endpoint_mod.id]);\n\t\tpjsip_rx_data_free_cloned(clone);\n\t}\n\tast_taskprocessor_unreference(serializer);\n\treturn PJ_TRUE;\n}\n", "bug_type": null, "idx": 1357}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *dahdi_decoder_frameout(struct ast_trans_pvt *pvt)\n{\n\tint res;\n\tstruct codec_dahdi_pvt *dahdip = pvt->pvt;\n\tif (2 == dahdip->fake) {\n\t\tstruct ast_frame frm = {\n\t\t\t.frametype = AST_FRAME_VOICE,\n\t\t\t.samples = dahdip->required_samples,\n\t\t\t.src = pvt->t->name,\n\t\t};\n\t\tdahdip->fake = 1;\n\t\tpvt->samples = 0;\n\t\treturn ast_frisolate(&frm);\n\t} else if (1 == dahdip->fake) {\n\t\tpvt->samples = 0;\n\t\tdahdip->fake = 0;\n\t\treturn NULL;\n\t}\n\tif (dahdip->samples_written_to_hardware >= ULAW_SAMPLES) {\n\t\tdahdi_wait_for_packet(dahdip->fd);\n\t}\n\t\n\tif (dahdip->softslin) {\n\t\tres = read(dahdip->fd, dahdip->ulaw_buffer, sizeof(dahdip->ulaw_buffer));\n\t} else {\n\t\tres = read(dahdip->fd, pvt->outbuf.c + pvt->datalen, pvt->t->buf_size - pvt->datalen);\n\t}\n\tif (-1 == res) {\n\t\tif (EWOULDBLOCK == errno) {\n\t\t\t\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Failed to read from transcoder: %s\\n\", strerror(errno));\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (dahdip->softslin) {\n\t\t\tulawtolin(pvt, res);\n\t\t\tpvt->f.datalen = res * 2;\n\t\t} else {\n\t\t\tpvt->f.datalen = res;\n\t\t}\n\t\tpvt->datalen = 0;\n\t\tpvt->f.samples = res;\n\t\tpvt->samples = 0;\n\t\tdahdip->samples_written_to_hardware =\n\t\t\t(dahdip->samples_written_to_hardware >= res) ?\n\t\t\t        dahdip->samples_written_to_hardware - res : 0;\n\t\treturn ast_frisolate(&pvt->f);\n\t}\n\t\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1358}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225AdmissionRequest (OOCTXT* pctxt, H225AdmissionRequest* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.callModelPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.destinationInfoPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.destCallSignalAddressPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.destExtraCallInfoPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.srcCallSignalAddressPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.callServicesPresent = optbit;\n   \n   invokeStartElement (pctxt, \"requestSeqNum\", -1);\n   stat = asn1PD_H225RequestSeqNum (pctxt, &pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"requestSeqNum\", -1);\n   \n   invokeStartElement (pctxt, \"callType\", -1);\n   stat = asn1PD_H225CallType (pctxt, &pvalue->callType);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"callType\", -1);\n   \n   if (pvalue->m.callModelPresent) {\n      invokeStartElement (pctxt, \"callModel\", -1);\n      stat = asn1PD_H225CallModel (pctxt, &pvalue->callModel);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"callModel\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"endpointIdentifier\", -1);\n   stat = asn1PD_H225EndpointIdentifier (pctxt, &pvalue->endpointIdentifier);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"endpointIdentifier\", -1);\n   \n   if (pvalue->m.destinationInfoPresent) {\n      invokeStartElement (pctxt, \"destinationInfo\", -1);\n      stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destinationInfo);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"destinationInfo\", -1);\n   }\n   \n   if (pvalue->m.destCallSignalAddressPresent) {\n      invokeStartElement (pctxt, \"destCallSignalAddress\", -1);\n      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->destCallSignalAddress);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"destCallSignalAddress\", -1);\n   }\n   \n   if (pvalue->m.destExtraCallInfoPresent) {\n      invokeStartElement (pctxt, \"destExtraCallInfo\", -1);\n      stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destExtraCallInfo);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"destExtraCallInfo\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"srcInfo\", -1);\n   stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->srcInfo);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"srcInfo\", -1);\n   \n   if (pvalue->m.srcCallSignalAddressPresent) {\n      invokeStartElement (pctxt, \"srcCallSignalAddress\", -1);\n      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->srcCallSignalAddress);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"srcCallSignalAddress\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"bandWidth\", -1);\n   stat = asn1PD_H225BandWidth (pctxt, &pvalue->bandWidth);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"bandWidth\", -1);\n   \n   invokeStartElement (pctxt, \"callReferenceValue\", -1);\n   stat = asn1PD_H225CallReferenceValue (pctxt, &pvalue->callReferenceValue);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"callReferenceValue\", -1);\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   \n   if (pvalue->m.callServicesPresent) {\n      invokeStartElement (pctxt, \"callServices\", -1);\n      stat = asn1PD_H225QseriesOptions (pctxt, &pvalue->callServices);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"callServices\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"conferenceID\", -1);\n   stat = asn1PD_H225ConferenceIdentifier (pctxt, &pvalue->conferenceID);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"conferenceID\", -1);\n   \n   invokeStartElement (pctxt, \"activeMC\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->activeMC);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->activeMC);\n   invokeEndElement (pctxt, \"activeMC\", -1);\n   \n   invokeStartElement (pctxt, \"answerCall\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->answerCall);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->answerCall);\n   invokeEndElement (pctxt, \"answerCall\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 19 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.canMapAliasPresent = 1;\n                     invokeStartElement (pctxt, \"canMapAlias\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->canMapAlias);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->canMapAlias);\n                     invokeEndElement (pctxt, \"canMapAlias\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.callIdentifierPresent = 1;\n                     invokeStartElement (pctxt, \"callIdentifier\", -1);\n                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"callIdentifier\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.srcAlternativesPresent = 1;\n                     invokeStartElement (pctxt, \"srcAlternatives\", -1);\n                     stat = asn1PD_H225_SeqOfH225Endpoint (pctxt, &pvalue->srcAlternatives);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"srcAlternatives\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.destAlternativesPresent = 1;\n                     invokeStartElement (pctxt, \"destAlternatives\", -1);\n                     stat = asn1PD_H225_SeqOfH225Endpoint (pctxt, &pvalue->destAlternatives);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"destAlternatives\", -1);\n                     break;\n                  case 4:\n                     pvalue->m.gatekeeperIdentifierPresent = 1;\n                     invokeStartElement (pctxt, \"gatekeeperIdentifier\", -1);\n                     stat = asn1PD_H225GatekeeperIdentifier (pctxt, &pvalue->gatekeeperIdentifier);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"gatekeeperIdentifier\", -1);\n                     break;\n                  case 5:\n                     pvalue->m.tokensPresent = 1;\n                     invokeStartElement (pctxt, \"tokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"tokens\", -1);\n                     break;\n                  case 6:\n                     pvalue->m.cryptoTokensPresent = 1;\n                     invokeStartElement (pctxt, \"cryptoTokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"cryptoTokens\", -1);\n                     break;\n                  case 7:\n                     pvalue->m.integrityCheckValuePresent = 1;\n                     invokeStartElement (pctxt, \"integrityCheckValue\", -1);\n                     stat = asn1PD_H225ICV (pctxt, &pvalue->integrityCheckValue);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"integrityCheckValue\", -1);\n                     break;\n                  case 8:\n                     pvalue->m.transportQOSPresent = 1;\n                     invokeStartElement (pctxt, \"transportQOS\", -1);\n                     stat = asn1PD_H225TransportQOS (pctxt, &pvalue->transportQOS);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"transportQOS\", -1);\n                     break;\n                  case 9:\n                     pvalue->m.willSupplyUUIEsPresent = 1;\n                     invokeStartElement (pctxt, \"willSupplyUUIEs\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->willSupplyUUIEs);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->willSupplyUUIEs);\n                     invokeEndElement (pctxt, \"willSupplyUUIEs\", -1);\n                     break;\n                  case 10:\n                     pvalue->m.callLinkagePresent = 1;\n                     invokeStartElement (pctxt, \"callLinkage\", -1);\n                     stat = asn1PD_H225CallLinkage (pctxt, &pvalue->callLinkage);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"callLinkage\", -1);\n                     break;\n                  case 11:\n                     pvalue->m.gatewayDataRatePresent = 1;\n                     invokeStartElement (pctxt, \"gatewayDataRate\", -1);\n                     stat = asn1PD_H225DataRate (pctxt, &pvalue->gatewayDataRate);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"gatewayDataRate\", -1);\n                     break;\n                  case 12:\n                     pvalue->m.capacityPresent = 1;\n                     invokeStartElement (pctxt, \"capacity\", -1);\n                     stat = asn1PD_H225CallCapacity (pctxt, &pvalue->capacity);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"capacity\", -1);\n                     break;\n                  case 13:\n                     pvalue->m.circuitInfoPresent = 1;\n                     invokeStartElement (pctxt, \"circuitInfo\", -1);\n                     stat = asn1PD_H225CircuitInfo (pctxt, &pvalue->circuitInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"circuitInfo\", -1);\n                     break;\n                  case 14:\n                     pvalue->m.desiredProtocolsPresent = 1;\n                     invokeStartElement (pctxt, \"desiredProtocols\", -1);\n                     stat = asn1PD_H225_SeqOfH225SupportedProtocols (pctxt, &pvalue->desiredProtocols);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"desiredProtocols\", -1);\n                     break;\n                  case 15:\n                     pvalue->m.desiredTunnelledProtocolPresent = 1;\n                     invokeStartElement (pctxt, \"desiredTunnelledProtocol\", -1);\n                     stat = asn1PD_H225TunnelledProtocol (pctxt, &pvalue->desiredTunnelledProtocol);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"desiredTunnelledProtocol\", -1);\n                     break;\n                  case 16:\n                     pvalue->m.featureSetPresent = 1;\n                     invokeStartElement (pctxt, \"featureSet\", -1);\n                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"featureSet\", -1);\n                     break;\n                  case 17:\n                     pvalue->m.genericDataPresent = 1;\n                     invokeStartElement (pctxt, \"genericData\", -1);\n                     stat = asn1PD_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"genericData\", -1);\n                     break;\n                  case 18:\n                     pvalue->m.canMapSrcAliasPresent = 1;\n                     invokeStartElement (pctxt, \"canMapSrcAlias\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->canMapSrcAlias);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->canMapSrcAlias);\n                     invokeEndElement (pctxt, \"canMapSrcAlias\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1359}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1360}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int retrieve_parked_user_targeted(void *obj, void *arg, int flags)\n{\n\tint *target = arg;\n\tstruct parked_user *user = obj;\n\tif (user->parking_space == *target) {\n\t\treturn CMP_MATCH;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1361}
{"project": "Asterisk", "target": 0, "func": "static int osp_load(int reload)\n{\n\tconst char* cvar;\n\tunsigned int ivar;\n\tstruct ast_config* cfg;\n\tstruct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\tint error = OSPC_ERR_NO_ERROR;\n\tif ((cfg = ast_config_load(OSP_CONFIG_FILE, config_flags)) == CONFIG_STATUS_FILEUNCHANGED) {\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Config file %s is in an invalid format.  Aborting.\\n\", OSP_CONFIG_FILE);\n\t\treturn 0;\n\t}\n\tif (cfg) {\n\t\tif (reload) {\n\t\t\tosp_unload();\n\t\t}\n\t\tif ((cvar = ast_variable_retrieve(cfg, OSP_GENERAL_CAT, \"accelerate\")) && ast_true(cvar)) {\n\t\t\tif ((error = OSPPInit(1)) != OSPC_ERR_NO_ERROR) {\n\t\t\t\tast_log(LOG_WARNING, \"OSP: Unable to enable hardware acceleration, error='%d'\\n\", error);\n\t\t\t\tOSPPInit(0);\n\t\t\t} else {\n\t\t\t\tosp_hardware = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tOSPPInit(0);\n\t\t}\n\t\tast_debug(1, \"OSP: osp_hardware '%d'\\n\", osp_hardware);\n\t\tif ((cvar = ast_variable_retrieve(cfg, OSP_GENERAL_CAT, \"securityfeatures\")) && ast_true(cvar)) {\n\t\t\tosp_security = 1;\n\t\t}\n\t\tast_debug(1, \"OSP: osp_security '%d'\\n\", osp_security);\n\t\tif ((cvar = ast_variable_retrieve(cfg, OSP_GENERAL_CAT, \"tokenformat\"))) {\n\t\t\tif ((sscanf(cvar, \"%30d\", &ivar) == 1) &&\n\t\t\t\t((ivar == TOKEN_ALGO_SIGNED) || (ivar == TOKEN_ALGO_UNSIGNED) || (ivar == TOKEN_ALGO_BOTH)))\n\t\t\t{\n\t\t\t\tosp_tokenformat = ivar;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"tokenformat should be an integer from %d, %d or %d, not '%s'\\n\",\n\t\t\t\t\tTOKEN_ALGO_SIGNED, TOKEN_ALGO_UNSIGNED, TOKEN_ALGO_BOTH, cvar);\n\t\t\t}\n\t\t}\n\t\tast_debug(1, \"OSP: osp_tokenformat '%d'\\n\", osp_tokenformat);\n\t\tfor (cvar = ast_category_browse(cfg, NULL); cvar != NULL; cvar = ast_category_browse(cfg, cvar)) {\n\t\t\tif (strcasecmp(cvar, OSP_GENERAL_CAT)) {\n\t\t\t\tosp_create_provider(cfg, cvar);\n\t\t\t}\n\t\t}\n\t\tosp_initialized = 1;\n\t\tast_config_destroy(cfg);\n\t} else {\n\t\tast_log(LOG_WARNING, \"OSP: Unable to find configuration. OSP support disabled\\n\");\n\t\treturn 0;\n\t}\n\tast_debug(1, \"OSP: osp_initialized '%d'\\n\", osp_initialized);\n\treturn 1;\n}\n", "bug_type": null, "idx": 1362}
{"project": "Asterisk", "target": 0, "func": "void dahdi_master_slave_unlink(struct dahdi_pvt *slave, struct dahdi_pvt *master, int needlock)\n{\n\t\n\tint x;\n\tint hasslaves;\n\tif (!master)\n\t\treturn;\n\tif (needlock) {\n\t\tast_mutex_lock(&master->lock);\n\t\tif (slave) {\n\t\t\twhile (ast_mutex_trylock(&slave->lock)) {\n\t\t\t\tDEADLOCK_AVOIDANCE(&master->lock);\n\t\t\t}\n\t\t}\n\t}\n\thasslaves = 0;\n\tfor (x = 0; x < MAX_SLAVES; x++) {\n\t\tif (master->slaves[x]) {\n\t\t\tif (!slave || (master->slaves[x] == slave)) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"Unlinking slave %d from %d\\n\", master->slaves[x]->channel, master->channel);\n\t\t\t\tconf_del(master, &master->slaves[x]->subs[SUB_REAL], SUB_REAL);\n\t\t\t\tconf_del(master->slaves[x], &master->subs[SUB_REAL], SUB_REAL);\n\t\t\t\tmaster->slaves[x]->master = NULL;\n\t\t\t\tmaster->slaves[x] = NULL;\n\t\t\t} else\n\t\t\t\thasslaves = 1;\n\t\t}\n\t\tif (!hasslaves)\n\t\t\tmaster->inconference = 0;\n\t}\n\tif (!slave) {\n\t\tif (master->master) {\n\t\t\t\n\t\t\tconf_del(master->master, &master->subs[SUB_REAL], SUB_REAL);\n\t\t\tconf_del(master, &master->master->subs[SUB_REAL], SUB_REAL);\n\t\t\thasslaves = 0;\n\t\t\tfor (x = 0; x < MAX_SLAVES; x++) {\n\t\t\t\tif (master->master->slaves[x] == master)\n\t\t\t\t\tmaster->master->slaves[x] = NULL;\n\t\t\t\telse if (master->master->slaves[x])\n\t\t\t\t\thasslaves = 1;\n\t\t\t}\n\t\t\tif (!hasslaves)\n\t\t\t\tmaster->master->inconference = 0;\n\t\t}\n\t\tmaster->master = NULL;\n\t}\n\tdahdi_conf_update(master);\n\tif (needlock) {\n\t\tif (slave)\n\t\t\tast_mutex_unlock(&slave->lock);\n\t\tast_mutex_unlock(&master->lock);\n\t}\n}\n", "bug_type": null, "idx": 1363}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tast_ari_remove_handler(&sounds);\n\tstasis_app_unref();\n\treturn 0;\n}\n", "bug_type": null, "idx": 1364}
{"project": "Asterisk", "target": 0, "func": "static struct msg_data *msg_data_create(const struct ast_msg *msg, const char *to, const char *from)\n{\n\tchar *uri_params;\n\tstruct msg_data *mdata = ao2_alloc(sizeof(*mdata), msg_data_destroy);\n\tif (!mdata) {\n\t\treturn NULL;\n\t}\n\t\n\tmdata->msg = ast_msg_ref((struct ast_msg *) msg);\n\t\n\tif (!(to = strchr(to, ':'))) {\n\t\tao2_ref(mdata, -1);\n\t\treturn NULL;\n\t}\n\t++to;\n\t\n\tmdata->to = ast_begins_with(to, \"sip:\") ? ast_strdup(to) : ast_strdup(to - 4);\n\tmdata->from = ast_strdup(from);\n\tif (!mdata->to || !mdata->from) {\n\t\tao2_ref(mdata, -1);\n\t\treturn NULL;\n\t}\n\t\n\turi_params = strchr(mdata->from, '@');\n\tif (uri_params && (uri_params = strchr(mdata->from, ';'))) {\n\t\t*uri_params = '\\0';\n\t}\n\treturn mdata;\n}\n", "bug_type": null, "idx": 1365}
{"project": "Asterisk", "target": 0, "func": "static void categories_flatten()\n{\n\tint idx;\n\tstruct category *c;\n\tstruct member *m;\n\tAST_LIST_TRAVERSE(&categories, c, list) {\n\t\tfor (idx = 0; idx < SUPPORT_COUNT; idx++) {\n\t\t\tstruct support_level_bucket bucket = c->buckets[idx];\n\t\t\twhile ((m = AST_LIST_REMOVE_HEAD(&bucket, list))) {\n\t\t\t\tAST_LIST_INSERT_TAIL(&c->members, m, list);\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1366}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct stasis_message *cache_remove(struct ao2_container *entries, struct stasis_cache_entry *cached_entry, const struct ast_eid *eid)\n{\n\tstruct stasis_message *old_snapshot;\n\tint is_remote;\n\tis_remote = ast_eid_cmp(eid, &ast_eid_default);\n\tif (!is_remote) {\n\t\told_snapshot = cached_entry->local;\n\t\tcached_entry->local = NULL;\n\t} else {\n\t\tint idx;\n\t\told_snapshot = NULL;\n\t\tfor (idx = 0; idx < AST_VECTOR_SIZE(&cached_entry->remote); ++idx) {\n\t\t\tstruct stasis_message *cur;\n\t\t\tcur = AST_VECTOR_GET(&cached_entry->remote, idx);\n\t\t\tif (!ast_eid_cmp(eid, stasis_message_eid(cur))) {\n\t\t\t\told_snapshot = AST_VECTOR_REMOVE_UNORDERED(&cached_entry->remote, idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cached_entry->local && !AST_VECTOR_SIZE(&cached_entry->remote)) {\n\t\tao2_unlink_flags(entries, cached_entry, OBJ_NOLOCK);\n\t}\n\treturn old_snapshot;\n}\n", "bug_type": null, "idx": 1367}
{"project": "Asterisk", "target": 0, "func": "\nstatic void append_attr_string(struct stun_attr **attr, int attrval, const char *s, int *len, int *left)\n{\n\tint str_length = strlen(s);\n\tint attr_length = str_length + ((~(str_length - 1)) & 0x3);\n\tint size = sizeof(**attr) + attr_length;\n\tif (*left > size) {\n\t\t(*attr)->attr = htons(attrval);\n\t\t(*attr)->len = htons(attr_length);\n\t\tmemcpy((*attr)->value, s, str_length);\n\t\tmemset((*attr)->value + str_length, 0, attr_length - str_length);\n\t\t(*attr) = (struct stun_attr *)((*attr)->value + attr_length);\n\t\t*len += size;\n\t\t*left -= size;\n\t}\n}\n", "bug_type": null, "idx": 1368}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res;\n\t\n\tast_mwi_external_ref();\n\tres = 0;\n\tres |= ast_manager_register_xml(\"MWIGet\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, mwi_mailbox_get);\n\tres |= ast_manager_register_xml(\"MWIDelete\", EVENT_FLAG_CALL, mwi_mailbox_delete);\n\tres |= ast_manager_register_xml(\"MWIUpdate\", EVENT_FLAG_CALL, mwi_mailbox_update);\n\tif (res) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1369}
{"project": "Asterisk", "target": 0, "func": "static void app_dtor(void *obj)\n{\n\tstruct stasis_app *app = obj;\n\tast_verb(1, \"Destroying Stasis app %s\\n\", app->name);\n\tast_assert(app->router == NULL);\n\tast_assert(app->bridge_router == NULL);\n\tast_assert(app->endpoint_router == NULL);\n\tao2_cleanup(app->topic);\n\tapp->topic = NULL;\n\tao2_cleanup(app->forwards);\n\tapp->forwards = NULL;\n\tao2_cleanup(app->data);\n\tapp->data = NULL;\n}\n", "bug_type": null, "idx": 1370}
{"project": "Asterisk", "target": 0, "func": "pthread_t cleanup_thread = 0;\nstatic int cache_hash(const void *obj, const int flags)\n{\n\tconst struct cache_entry *e = obj;\n\treturn ast_str_case_hash(e->exten) + e->priority;\n}\n", "bug_type": null, "idx": 1371}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int reconstruct(\n\tint\t\tsign,\t\n\tint\t\tdqln,\t\n\tint\t\ty)\t\n{\n\tint\t\tdql;\t\n\tint\t\tdex;\t\n\tint\t\tdqt;\n\tint\t\tdq;\t\n\tdql = dqln + (y >> 2);\t\n\tif (dql < 0) {\n#ifdef NOT_BLI\n\t\treturn (sign) ? -1 : 1;\n#else\n\t\treturn (sign) ? -0x8000 : 0;\n#endif\n\t} else {\t\t\n\t\tdex = (dql >> 7) & 15;\n\t\tdqt = 128 + (dql & 127);\n#ifdef NOT_BLI\n\t\tdq = ((dqt << 19) >> (14 - dex));\n\t\treturn (sign) ? -dq : dq;\n#else\n\t\tdq = (dqt << 7) >> (14 - dex);\n\t\treturn (sign) ? (dq - 0x8000) : dq;\n#endif\n\t}\n}\n", "bug_type": null, "idx": 1372}
{"project": "Asterisk", "target": 0, "func": "static void *featuregroup_find(struct ao2_container *group_container, const char *category)\n{\n\treturn ao2_find(group_container, category, OBJ_KEY);\n}\n", "bug_type": null, "idx": 1373}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/manager.h\"\nstatic void display_parked_call(struct parked_user *user, int fd)\n{\n\tast_cli(fd, \"  Space               :  %d\\n\", user->parking_space);\n\tast_cli(fd, \"  Channel             :  %s\\n\", ast_channel_name(user->chan));\n\tast_cli(fd, \"  Parker Dial String  :  %s\\n\", user->parker_dial_string);\n\tast_cli(fd, \"\\n\");\n}\n", "bug_type": null, "idx": 1374}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum ID_FIELD_STATUS party_number_write(struct ast_party_number *number, int argc, char *argv[], const char *value)\n{\n\tchar *val;\n\tenum ID_FIELD_STATUS status;\n\tstatus = ID_FIELD_VALID;\n\tif (argc == 0) {\n\t\t\n\t\tnumber->valid = 1;\n\t\tnumber->str = ast_strdup(value);\n\t\tast_trim_blanks(number->str);\n\t} else if (argc == 1 && !strcasecmp(\"valid\", argv[0])) {\n\t\tnumber->valid = atoi(value) ? 1 : 0;\n\t} else if (argc == 1 && !strcasecmp(\"plan\", argv[0])) {\n\t\tval = ast_strdupa(value);\n\t\tast_trim_blanks(val);\n\t\tif (('0' <= val[0]) && (val[0] <= '9')) {\n\t\t\tnumber->plan = atoi(val);\n\t\t} else {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Unknown type-of-number/numbering-plan '%s', value unchanged\\n\", val);\n\t\t\tstatus = ID_FIELD_INVALID;\n\t\t}\n\t} else if (argc == 1 && !strncasecmp(\"pres\", argv[0], 4)) {\n\t\tint pres;\n\t\t\n\t\tval = ast_strdupa(value);\n\t\tast_trim_blanks(val);\n\t\tif (('0' <= val[0]) && (val[0] <= '9')) {\n\t\t\tpres = atoi(val);\n\t\t} else {\n\t\t\tpres = ast_parse_caller_presentation(val);\n\t\t}\n\t\tif (pres < 0) {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Unknown number presentation '%s', value unchanged\\n\", val);\n\t\t\tstatus = ID_FIELD_INVALID;\n\t\t} else {\n\t\t\tnumber->presentation = pres;\n\t\t}\n\t} else {\n\t\tstatus = ID_FIELD_UNKNOWN;\n\t}\n\treturn status;\n}\n", "bug_type": null, "idx": 1375}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function group_count_function = {\n\t.name = \"GROUP_COUNT\",\n\t.read = group_count_function_read,\n\t.read_max = 12,\n};\n", "bug_type": null, "idx": 1376}
{"project": "Asterisk", "target": 0, "func": "static void my_set_polarity(void *pvt, int value)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tif (p->channel == CHAN_PSEUDO) {\n\t\treturn;\n\t}\n\tp->polarity = value;\n\tioctl(p->subs[SUB_REAL].dfd, DAHDI_SETPOLARITY, &value);\n}\n", "bug_type": null, "idx": 1377}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MiscellaneousIndication (OOCTXT* pctxt, H245MiscellaneousIndication* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   \n   stat = asn1PE_H245LogicalChannelNumber (pctxt, pvalue->logicalChannelNumber);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H245MiscellaneousIndication_type (pctxt, &pvalue->type);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1378}
{"project": "Asterisk", "target": 0, "func": "static int hashtab_compare_extens(const void *ah_a, const void *ah_b)\n{\n\tconst struct ast_exten *ac = ah_a;\n\tconst struct ast_exten *bc = ah_b;\n\tint x = strcmp(ac->exten, bc->exten);\n\tif (x) { \n\t\treturn x;\n\t}\n\t\n\t\n\tif (ac->matchcid == AST_EXT_MATCHCID_ANY || bc->matchcid == AST_EXT_MATCHCID_ANY) {\n\t\treturn 0;\n\t}\n\tif (ac->matchcid == AST_EXT_MATCHCID_OFF && bc->matchcid == AST_EXT_MATCHCID_OFF) {\n\t\treturn 0;\n\t}\n\tif (ac->matchcid != bc->matchcid) {\n\t\treturn 1;\n\t}\n\t\n\t\n\tif (ast_strlen_zero(ac->cidmatch) && ast_strlen_zero(bc->cidmatch)) {\n\t\treturn 0;\n\t}\n\treturn strcmp(ac->cidmatch, bc->cidmatch);\n}\n", "bug_type": null, "idx": 1379}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_dial_channel *find_dial_channel(struct ast_dial *dial, int num)\n{\n\tstruct ast_dial_channel *channel = AST_LIST_LAST(&dial->channels);\n\t\n\tif (channel->num == num)\n\t\treturn channel;\n\t\n\tAST_LIST_LOCK(&dial->channels);\n\tAST_LIST_TRAVERSE(&dial->channels, channel, list) {\n\t\tif (channel->num == num)\n\t\t\tbreak;\n\t}\n\tAST_LIST_UNLOCK(&dial->channels);\n\treturn channel;\n}\n", "bug_type": null, "idx": 1380}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int fax_detect_attach(struct ast_channel *chan, int timeout, int flags)\n{\n\tstruct fax_detect *faxdetect;\n\tstruct ast_fax_session_details *details;\n\tstruct ast_framehook_interface fr_hook = {\n\t\t.version = AST_FRAMEHOOK_INTERFACE_VERSION,\n\t\t.event_cb = fax_detect_framehook,\n\t\t.destroy_cb = fax_detect_framehook_destroy,\n\t};\n\tif (!(details = find_or_create_details(chan))) {\n\t\tast_log(LOG_ERROR, \"System cannot provide memory for session requirements.\\n\");\n\t\treturn -1;\n\t}\n\t\n\tfaxdetect = fax_detect_new(chan, timeout, flags);\n\tif (!faxdetect) {\n\t\tao2_ref(details, -1);\n\t\treturn -1;\n\t}\n\tfr_hook.data = faxdetect;\n\tfaxdetect->details = details;\n\tast_channel_lock(chan);\n\tdetails->faxdetect_id = ast_framehook_attach(chan, &fr_hook);\n\tdetails->faxdetect_timeout = timeout;\n\tdetails->faxdetect_flags = flags;\n\tast_channel_unlock(chan);\n\tif (details->faxdetect_id < 0) {\n\t\tao2_ref(faxdetect, -1);\n\t}\n\treturn details->faxdetect_id;\n}\n", "bug_type": null, "idx": 1381}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_recording_finished(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_type = 0;\n\tint has_application = 0;\n\tint has_recording = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"asterisk_id\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI RecordingFinished field asterisk_id failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"type\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_type = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI RecordingFinished field type failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"application\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_application = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI RecordingFinished field application failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"timestamp\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_date(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI RecordingFinished field timestamp failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"recording\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_recording = 1;\n\t\t\tprop_is_valid = ast_ari_validate_live_recording(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI RecordingFinished field recording failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI RecordingFinished has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_type) {\n\t\tast_log(LOG_ERROR, \"ARI RecordingFinished missing required field type\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_application) {\n\t\tast_log(LOG_ERROR, \"ARI RecordingFinished missing required field application\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_recording) {\n\t\tast_log(LOG_ERROR, \"ARI RecordingFinished missing required field recording\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1382}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_sip_unregister_endpoint_identifier(&auth_username_identifier);\n\tast_sip_unregister_endpoint_identifier(&username_identifier);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1383}
{"project": "Asterisk", "target": 0, "func": "static int my_check_waitingfordt(void *pvt)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tif (p->waitingfordt.tv_sec) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1384}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hfp_parse_cmgr(struct hfp_pvt *hfp, char *buf, char **from_number, char **text)\n{\n\tint i, state;\n\tsize_t s;\n\t\n\tstate = 0;\n\ts = strlen(buf);\n\tfor (i = 0; i < s && state != 6; i++) {\n\t\tswitch (state) {\n\t\tcase 0: \n\t\t\tif (buf[i] == ',') {\n\t\t\t\tstate++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tif (buf[i] == '\"') {\n\t\t\t\tstate++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tif (from_number) {\n\t\t\t\t*from_number = &buf[i];\n\t\t\t\tstate++;\n\t\t\t}\n\t\t\t\n\t\tcase 3: \n\t\t\tif (buf[i] == '\"') {\n\t\t\t\tbuf[i] = '\\0';\n\t\t\t\tstate++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4: \n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tstate++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5: \n\t\t\tif (text) {\n\t\t\t\t*text = &buf[i];\n\t\t\t\tstate++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (state != 6) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1385}
{"project": "Asterisk", "target": 0, "func": "static int wait_bridge_sort_fn(const void *obj_left, const void *obj_right, const int flags)\n{\n\tconst struct wait_bridge_wrapper *left = obj_left;\n\tconst struct wait_bridge_wrapper *right = obj_right;\n\tconst char *right_key = obj_right;\n\tint cmp;\n\tswitch (flags & (OBJ_POINTER | OBJ_KEY | OBJ_PARTIAL_KEY)) {\n\tcase OBJ_POINTER:\n\t\tright_key = right->name;\n\t\t\n\tcase OBJ_KEY:\n\t\tcmp = strcmp(left->name, right_key);\n\t\tbreak;\n\tcase OBJ_PARTIAL_KEY:\n\t\tcmp = strncmp(left->name, right_key, strlen(right_key));\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tast_assert(0);\n\t\tcmp = 0;\n\t\tbreak;\n\t}\n\treturn cmp;\n}\n", "bug_type": null, "idx": 1386}
{"project": "Asterisk", "target": 0, "func": "#ifdef DEBUG_THREADS\nstatic void restore_lock_tracking(struct ast_lock_track *lt, struct ast_lock_track *lt_saved)\n{\n\tast_reentrancy_lock(lt);\n\t\n\tmemcpy(lt->file, lt_saved->file, sizeof(lt->file));\n\tmemcpy(lt->lineno, lt_saved->lineno, sizeof(lt->lineno));\n\tlt->reentrancy = lt_saved->reentrancy;\n\tmemcpy(lt->func, lt_saved->func, sizeof(lt->func));\n\tmemcpy(lt->thread_id, lt_saved->thread_id, sizeof(lt->thread_id));\n#ifdef HAVE_BKTR\n\tmemcpy(lt->backtrace, lt_saved->backtrace, sizeof(lt->backtrace));\n#endif\n\tast_reentrancy_unlock(lt);\n}\n", "bug_type": null, "idx": 1387}
{"project": "Asterisk", "target": 0, "func": "static void publish_span_alarm(int span, const char *alarm_txt)\n{\n\tRAII_VAR(struct ast_json *, body, NULL, ast_json_unref);\n\tbody = ast_json_pack(\"{s: i, s: s}\",\n\t\t\"Span\", span,\n\t\t\"Alarm\", alarm_txt);\n\tif (!body) {\n\t\treturn;\n\t}\n\tast_manager_publish_event(\"SpanAlarm\", EVENT_FLAG_SYSTEM, body);\n}\n", "bug_type": null, "idx": 1388}
{"project": "Asterisk", "target": 0, "func": "#endif\t\nstatic void sig_pri_dial_digits(struct sig_pri_chan *p, const char *dial_string)\n{\n\tif (sig_pri_callbacks.dial_digits) {\n\t\tsig_pri_callbacks.dial_digits(p->chan_pvt, dial_string);\n\t}\n}\n", "bug_type": null, "idx": 1389}
{"project": "Asterisk", "target": 0, "func": "static int set_asterisk_int(struct ast_channel *chan, char *varname, int id)\n{\n\tif (id >= 0) {\n\t\tchar s[12] = \"\";\n\t\tsnprintf(s, sizeof(s), \"%d\", id);\n\t\tast_debug(5, \"MYSQL: setting var '%s' to value '%s'\\n\", varname, s);\n\t\tpbx_builtin_setvar_helper(chan, varname, s);\n\t}\n\treturn id;\n}\n", "bug_type": null, "idx": 1390}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void mixmonitor_ds_close_fs(struct mixmonitor_ds *mixmonitor_ds)\n{\n\tunsigned char quitting = 0;\n\tif (mixmonitor_ds->fs) {\n\t\tquitting = 1;\n\t\tast_closestream(mixmonitor_ds->fs);\n\t\tmixmonitor_ds->fs = NULL;\n\t\tast_verb(2, \"MixMonitor close filestream (mixed)\\n\");\n\t}\n\tif (mixmonitor_ds->fs_read) {\n\t\tquitting = 1;\n\t\tast_closestream(mixmonitor_ds->fs_read);\n\t\tmixmonitor_ds->fs_read = NULL;\n\t\tast_verb(2, \"MixMonitor close filestream (read)\\n\");\n\t}\n\tif (mixmonitor_ds->fs_write) {\n\t\tquitting = 1;\n\t\tast_closestream(mixmonitor_ds->fs_write);\n\t\tmixmonitor_ds->fs_write = NULL;\n\t\tast_verb(2, \"MixMonitor close filestream (write)\\n\");\n\t}\n\tif (quitting) {\n\t\tmixmonitor_ds->fs_quit = 1;\n\t}\n}\n", "bug_type": null, "idx": 1391}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void recording_fail(struct stasis_app_control *control,\n\t\t\t   struct stasis_app_recording *recording,\n\t\t\t   const char *cause)\n{\n\tstasis_app_control_unregister_add_rule(control, &rule_recording);\n\trecording_set_state(\n\t\trecording, STASIS_APP_RECORDING_STATE_FAILED, cause);\n}\n", "bug_type": null, "idx": 1392}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int load_module(void)\n{\n\tif (load_config(0)) {\n\t\tif (ast_register_application_xml(app, alarmreceiver_exec)) {\n\t\t\treturn AST_MODULE_LOAD_DECLINE;\n\t\t}\n\t\treturn AST_MODULE_LOAD_SUCCESS;\n\t}\n\treturn AST_MODULE_LOAD_DECLINE;\n}\n", "bug_type": null, "idx": 1393}
{"project": "Asterisk", "target": 0, "func": "static int restore_gains(struct dahdi_pvt *p);\nstatic int my_stop_cid_detect(void *pvt)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tint index = SUB_REAL;\n\tif (p->cs) {\n\t\tcallerid_free(p->cs);\n\t}\n\t\n\tdahdi_setlinear(p->subs[index].dfd, p->subs[index].linear);\n\trestore_gains(p);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1394}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ao2_container *test_make_sorted(enum test_container_type type, int options)\n{\n\tstruct ao2_container *container;\n\tcontainer = NULL;\n\tswitch (type) {\n\tcase TEST_CONTAINER_LIST:\n\t\tcontainer = ao2_t_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, options,\n\t\t\ttest_sort_cb, test_cmp_cb, \"test\");\n\t\tbreak;\n\tcase TEST_CONTAINER_HASH:\n\t\tcontainer = ao2_t_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, options, 5,\n\t\t\ttest_hash_cb, test_sort_cb, test_cmp_cb, \"test\");\n\t\tbreak;\n\tcase TEST_CONTAINER_RBTREE:\n\t\tcontainer = ao2_t_container_alloc_rbtree(AO2_ALLOC_OPT_LOCK_MUTEX, options,\n\t\t\ttest_sort_cb, test_cmp_cb, \"test\");\n\t\tbreak;\n\t}\n\treturn container;\n}\n", "bug_type": null, "idx": 1395}
{"project": "Asterisk", "target": 0, "func": "#define EXTERNAL_OBJ(_p)\t((_p) == NULL ? NULL : (_p)->user_data)\nint internal_is_ao2_object(void *user_data)\n{\n\tstruct astobj2 *p;\n\tif (!user_data) {\n\t\treturn 0;\n\t}\n\tp = INTERNAL_OBJ(user_data);\n\treturn !p || IS_AO2_MAGIC_BAD(p) ? 0 : 1;\n}\n", "bug_type": null, "idx": 1396}
{"project": "Asterisk", "target": 0, "func": "\nstatic spx_word16_t sinc(float cutoff, float x, int N, struct FuncDef *window_func)\n{\n   \n   float xx = x * cutoff;\n   if (fabs(x)<1e-6f)\n      return WORD2INT(32768.*cutoff);\n   else if (fabs(x) > .5f*N)\n      return 0;\n   \n   return WORD2INT(32768.*cutoff*sin(M_PI*xx)/(M_PI*xx) * compute_func(fabs(2.*x/N), window_func));\n}\n\nstatic spx_word16_t sinc(float cutoff, float x, int N, struct FuncDef *window_func)\n{\n   \n   float xx = x * cutoff;\n   if (fabs(x)<1e-6)\n      return cutoff;\n   else if (fabs(x) > .5*N)\n      return 0;\n   \n   return cutoff*sin(M_PI*xx)/(M_PI*xx) * compute_func(fabs(2.*x/N), window_func);\n}\n", "bug_type": null, "idx": 1397}
{"project": "Asterisk", "target": 0, "func": "int\nhistory_expand(char *str, char **output)\n{\n\tint i, retval = 0, idx;\n\tsize_t size;\n\tchar *temp, *result;\n\tif (h == NULL || e == NULL)\n\t\trl_initialize();\n\t*output = strdup(str);\t\n\tif (str[0] == history_subst_char) {\n\t\t\n\t\ttemp = alloca(4 + strlen(str) + 1);\n\t\ttemp[0] = temp[1] = history_expansion_char;\n\t\ttemp[2] = ':';\n\t\ttemp[3] = 's';\n\t\t(void) strcpy(temp + 4, str);\n\t\tstr = temp;\n\t}\n#define\tADD_STRING(what, len) \t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tif (idx + len + 1 > size)\t\t\t\t\\\n\t\t\tresult = realloc(result, (size += len + 1));\t\\\n\t\t(void)strncpy(&result[idx], what, len);\t\t\t\\\n\t\tidx += len;\t\t\t\t\t\t\\\n\t\tresult[idx] = '\\0';\t\t\t\t\t\\\n\t}\n\tresult = NULL;\n\tsize = idx = 0;\n\tfor (i = 0; str[i];) {\n\t\tint start, j, loop_again;\n\t\tsize_t len;\n\t\tloop_again = 1;\n\t\tstart = j = i;\nloop:\n\t\tfor (; str[j]; j++) {\n\t\t\tif (str[j] == '\\\\' &&\n\t\t\t    str[j + 1] == history_expansion_char) {\n\t\t\t\t(void) strcpy(&str[j], &str[j + 1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!loop_again) {\n\t\t\t\tif (str[j] == '?') {\n\t\t\t\t\twhile (str[j] && str[++j] != '?');\n\t\t\t\t\tif (str[j] == '?')\n\t\t\t\t\t\tj++;\n\t\t\t\t} else if (isspace((unsigned char) str[j]))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str[j] == history_expansion_char\n\t\t\t    && !strchr(history_no_expand_chars, str[j + 1])\n\t\t\t    && (!history_inhibit_expansion_function ||\n\t\t\t    (*history_inhibit_expansion_function)(str, j) == 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (str[j] && str[j + 1] != '#' && loop_again) {\n\t\t\ti = j;\n\t\t\tj++;\n\t\t\tif (str[j] == history_expansion_char)\n\t\t\t\tj++;\n\t\t\tloop_again = 0;\n\t\t\tgoto loop;\n\t\t}\n\t\tlen = i - start;\n\t\ttemp = &str[start];\n\t\tADD_STRING(temp, len);\n\t\tif (str[i] == '\\0' || str[i] != history_expansion_char\n\t\t    || str[i + 1] == '#') {\n\t\t\tlen = j - i;\n\t\t\ttemp = &str[i];\n\t\t\tADD_STRING(temp, len);\n\t\t\tif (start == 0)\n\t\t\t\tretval = 0;\n\t\t\telse\n\t\t\t\tretval = 1;\n\t\t\tbreak;\n\t\t}\n\t\tretval = _history_expand_command(&str[i], (size_t) (j - i),\n\t\t    &temp);\n\t\tif (retval != -1) {\n\t\t\tlen = strlen(temp);\n\t\t\tADD_STRING(temp, len);\n\t\t}\n\t\ti = j;\n\t}\t\t\t\n\tif (retval == 2) {\n\t\tadd_history(temp);\n#ifdef GDB_411_HACK\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tretval = -1;\n#endif\n\t}\n\tfree(*output);\n\t*output = result;\n\treturn (retval);\n}\n", "bug_type": null, "idx": 1398}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_format_def_unregister(h263_f.name);\n}\n", "bug_type": null, "idx": 1399}
{"project": "Asterisk", "target": 0, "func": "\nstatic int contact_apply_handler(const struct ast_sorcery *sorcery, void *object)\n{\n\tstruct ast_sip_contact_status *status;\n\tstruct ast_sip_contact *contact = object;\n\tstatus = ast_res_pjsip_find_or_create_contact_status(contact);\n\tao2_cleanup(status);\n\treturn status ? 0 : -1;\n}\n", "bug_type": null, "idx": 1400}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int should_queue_connected_line_update(const struct ast_sip_session *session, const struct ast_party_id *id)\n{\n\t\n\tif (!id->number.valid) {\n\t\treturn 0;\n\t}\n\t\n\tif (ast_strlen_zero(session->id.number.str) ||\n\t\t\tstrcmp(session->id.number.str, id->number.str)) {\n\t\treturn 1;\n\t}\n\t\n\t\n\tif (!id->name.valid) {\n\t\treturn 0;\n\t}\n\t\n\tif (ast_strlen_zero(session->id.name.str) ||\n\t\t\tstrcmp(session->id.name.str, id->name.str)) {\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n}\n", "bug_type": null, "idx": 1401}
{"project": "Asterisk", "target": 0, "func": "static pj_bool_t registrar_on_rx_request(struct pjsip_rx_data *rdata)\n{\n\tRAII_VAR(struct ast_sip_endpoint *, endpoint,\n\t\t ast_pjsip_rdata_get_endpoint(rdata), ao2_cleanup);\n\tstruct ast_sip_aor *aor;\n\tconst char *aor_name;\n\tif (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_register_method) || !endpoint) {\n\t\treturn PJ_FALSE;\n\t}\n\tif (ast_strlen_zero(endpoint->aors)) {\n\t\t\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);\n\t\tast_sip_report_failed_acl(endpoint, rdata, \"registrar_attempt_without_configured_aors\");\n\t\tast_log(LOG_WARNING, \"Endpoint '%s' has no configured AORs\\n\", ast_sorcery_object_get_id(endpoint));\n\t\treturn PJ_TRUE;\n\t}\n\tif (!PJSIP_URI_SCHEME_IS_SIP(rdata->msg_info.to->uri) && !PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.to->uri)) {\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 416, NULL, NULL, NULL);\n\t\tast_sip_report_failed_acl(endpoint, rdata, \"registrar_invalid_uri_in_to_received\");\n\t\tast_log(LOG_WARNING, \"Endpoint '%s' attempted to register to an AOR with a non-SIP URI\\n\", ast_sorcery_object_get_id(endpoint));\n\t\treturn PJ_TRUE;\n\t}\n\taor = find_registrar_aor(rdata, endpoint);\n\tif (!aor) {\n\t\t\n\t\treturn PJ_TRUE;\n\t}\n\taor_name = ast_sorcery_object_get_id(aor);\n\tif (!aor->max_contacts) {\n\t\t\n\t\tpjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);\n\t\tast_sip_report_req_no_support(endpoint, rdata, \"registrar_attempt_without_registration_permitted\");\n\t\tast_log(LOG_WARNING, \"AOR '%s' has no configured max_contacts. Endpoint '%s' unable to register\\n\",\n\t\t\taor_name, ast_sorcery_object_get_id(endpoint));\n\t} else {\n\t\tregister_aor(rdata, endpoint, aor, aor_name);\n\t}\n\tao2_ref(aor, -1);\n\treturn PJ_TRUE;\n}\n", "bug_type": null, "idx": 1402}
{"project": "Asterisk", "target": 0, "func": "\nstatic int setup_privacy_args(struct privacy_args *pa,\n\tstruct ast_flags64 *opts, char *opt_args[], struct ast_channel *chan)\n{\n\tchar callerid[60];\n\tint res;\n\tchar *l;\n\tif (ast_channel_caller(chan)->id.number.valid\n\t\t&& !ast_strlen_zero(ast_channel_caller(chan)->id.number.str)) {\n\t\tl = ast_strdupa(ast_channel_caller(chan)->id.number.str);\n\t\tast_shrink_phone_number(l);\n\t\tif (ast_test_flag64(opts, OPT_PRIVACY) ) {\n\t\t\tast_verb(3, \"Privacy DB is '%s', clid is '%s'\\n\", opt_args[OPT_ARG_PRIVACY], l);\n\t\t\tpa->privdb_val = ast_privacy_check(opt_args[OPT_ARG_PRIVACY], l);\n\t\t} else {\n\t\t\tast_verb(3, \"Privacy Screening, clid is '%s'\\n\", l);\n\t\t\tpa->privdb_val = AST_PRIVACY_UNKNOWN;\n\t\t}\n\t} else {\n\t\tchar *tnam, *tn2;\n\t\ttnam = ast_strdupa(ast_channel_name(chan));\n\t\t\n\t\tfor (tn2 = tnam; *tn2; tn2++) {\n\t\t\tif (*tn2 == '/')  \n\t\t\t\t*tn2 = '=';\n\t\t}\n\t\tast_verb(3, \"Privacy-- callerid is empty\\n\");\n\t\tsnprintf(callerid, sizeof(callerid), \"NOCALLERID_%s%s\", ast_channel_exten(chan), tnam);\n\t\tl = callerid;\n\t\tpa->privdb_val = AST_PRIVACY_UNKNOWN;\n\t}\n\tast_copy_string(pa->privcid, l, sizeof(pa->privcid));\n\tif (strncmp(pa->privcid, \"NOCALLERID\", 10) != 0 && ast_test_flag64(opts, OPT_SCREEN_NOCALLERID)) {\n\t\t\n\t\tast_verb(3, \"CallerID set (%s); N option set; Screening should be off\\n\", pa->privcid);\n\t\tpa->privdb_val = AST_PRIVACY_ALLOW;\n\t} else if (ast_test_flag64(opts, OPT_SCREEN_NOCALLERID) && strncmp(pa->privcid, \"NOCALLERID\", 10) == 0) {\n\t\tast_verb(3, \"CallerID blank; N option set; Screening should happen; dbval is %d\\n\", pa->privdb_val);\n\t}\n\tif (pa->privdb_val == AST_PRIVACY_DENY) {\n\t\tast_verb(3, \"Privacy DB reports PRIVACY_DENY for this callerid. Dial reports unavailable\\n\");\n\t\tast_copy_string(pa->status, \"NOANSWER\", sizeof(pa->status));\n\t\treturn 0;\n\t} else if (pa->privdb_val == AST_PRIVACY_KILL) {\n\t\tast_copy_string(pa->status, \"DONTCALL\", sizeof(pa->status));\n\t\treturn 0; \n\t} else if (pa->privdb_val == AST_PRIVACY_TORTURE) {\n\t\tast_copy_string(pa->status, \"TORTURE\", sizeof(pa->status));\n\t\treturn 0; \n\t} else if (pa->privdb_val == AST_PRIVACY_UNKNOWN) {\n\t\t\n\t\t\n\t\tsnprintf(pa->privintro, sizeof(pa->privintro), \"%s/sounds/priv-callerintros\", ast_config_AST_DATA_DIR);\n\t\tif ((res = ast_mkdir(pa->privintro, 0755))) {\n\t\t\tast_log(LOG_WARNING, \"privacy: can't create directory priv-callerintros: %s\\n\", strerror(res));\n\t\t\treturn -1;\n\t\t}\n\t\tsnprintf(pa->privintro, sizeof(pa->privintro), \"priv-callerintros/%s\", pa->privcid);\n\t\tif (ast_fileexists(pa->privintro, NULL, NULL ) > 0 && strncmp(pa->privcid, \"NOCALLERID\", 10) != 0) {\n\t\t\t\n\t\t} else {\n\t\t\tint duration; \n\t\t\t\n\t\t\t\n\t\t\tint silencethreshold = ast_dsp_get_threshold_from_settings(THRESHOLD_SILENCE);\n\t\t\tast_answer(chan);\n\t\t\tres = ast_play_and_record(chan, \"priv-recordintro\", pa->privintro, 4, \"sln\", &duration, NULL, silencethreshold, 2000, 0);  \n\t\t\t\t\t\t\t\t\t\n\t\t\tif (res == -1) {\n\t\t\t\t\n\t\t\t\tast_filedelete(pa->privintro, NULL);\n\t\t\t\tif (ast_fileexists(pa->privintro, NULL, NULL) > 0)\n\t\t\t\t\tast_log(LOG_NOTICE, \"privacy: ast_filedelete didn't do its job on %s\\n\", pa->privintro);\n\t\t\t\telse\n\t\t\t\t\tast_verb(3, \"Successfully deleted %s intro file\\n\", pa->privintro);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!ast_streamfile(chan, \"vm-dialout\", ast_channel_language(chan)) )\n\t\t\t\tast_waitstream(chan, \"\");\n\t\t}\n\t}\n\treturn 1; \n}\n", "bug_type": null, "idx": 1403}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(srv_resolve_single_record);\n\tAST_TEST_UNREGISTER(srv_resolve_sort_priority);\n\tAST_TEST_UNREGISTER(srv_resolve_same_priority_zero_weight);\n\tAST_TEST_UNREGISTER(srv_resolve_same_priority_different_weights);\n\tAST_TEST_UNREGISTER(srv_resolve_different_priorities_different_weights);\n\tAST_TEST_UNREGISTER(srv_resolve_record_missing_weight_port_host);\n\tAST_TEST_UNREGISTER(srv_resolve_record_missing_port_host);\n\tAST_TEST_UNREGISTER(srv_resolve_record_missing_host);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1404}
{"project": "Asterisk", "target": 0, "func": "\nstatic void set_queue_result(struct ast_channel *chan, enum queue_result res)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_LEN(queue_results); i++) {\n\t\tif (queue_results[i].id == res) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"QUEUESTATUS\", queue_results[i].text);\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1405}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int swapmode(int *used, int *total)\n{\n\tstruct swapent *swdev;\n\tint nswap, rnswap, i;\n\tnswap = swapctl(SWAP_NSWAP, 0, 0);\n\tif (nswap == 0)\n\t\treturn 0;\n\tswdev = ast_calloc(nswap, sizeof(*swdev));\n\tif (swdev == NULL)\n\t\treturn 0;\n\trnswap = swapctl(SWAP_STATS, swdev, nswap);\n\tif (rnswap == -1) {\n\t\tast_free(swdev);\n\t\treturn 0;\n\t}\n\t\n\t\n\t*total = *used = 0;\n\tfor (i = 0; i < nswap; i++) {\n\t\tif (swdev[i].se_flags & SWF_ENABLE) {\n\t\t\t*used += (swdev[i].se_inuse / (1024 / DEV_BSIZE));\n\t\t\t*total += (swdev[i].se_nblks / (1024 / DEV_BSIZE));\n\t\t}\n\t}\n\tast_free(swdev);\n\treturn 1;\n}\n#elif defined(HAVE_SYSCTL) && !defined(HAVE_SYSINFO)\nstatic int swapmode(int *used, int *total)\n{\n\t*used = *total = 0;\n\treturn 1;\n}\n", "bug_type": null, "idx": 1406}
{"project": "Asterisk", "target": 0, "func": "static void prune_peers(void)\n{\n\tstruct dundi_peer *peer;\n\tAST_LIST_LOCK(&peers);\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&peers, peer, list) {\n\t\tif (peer->dead) {\n\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\tdestroy_peer(peer);\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\tAST_LIST_UNLOCK(&peers);\n}\n", "bug_type": null, "idx": 1407}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tCHECK_PJSIP_MODULE_LOADED();\n\tif (!ast_module_check(\"res_hep.so\") || !hepv3_is_loaded()) {\n\t\tast_log(AST_LOG_WARNING, \"res_hep is not loaded or running; declining module load\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_sip_register_service(&logging_module);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1408}
{"project": "Asterisk", "target": 0, "func": "static int play_moh_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *parse;\n\tchar *class;\n\tint timeout = -1;\n\tint res;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(class);\n\t\tAST_APP_ARG(duration);\n\t);\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (!ast_strlen_zero(args.duration)) {\n\t\tif (sscanf(args.duration, \"%30d\", &timeout) == 1) {\n\t\t\ttimeout *= 1000;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Invalid MusicOnHold duration '%s'. Will wait indefinitely.\\n\", args.duration);\n\t\t}\n\t}\n\tclass = S_OR(args.class, NULL);\n\tif (ast_moh_start(chan, class, NULL)) {\n\t\tast_log(LOG_WARNING, \"Unable to start music on hold class '%s' on channel %s\\n\", class, ast_channel_name(chan));\n\t\treturn 0;\n\t}\n\tif (timeout > 0)\n\t\tres = ast_safe_sleep(chan, timeout);\n\telse {\n\t\twhile (!(res = ast_safe_sleep(chan, 10000)));\n\t}\n\tast_moh_stop(chan);\n\treturn res;\n}\n", "bug_type": null, "idx": 1409}
{"project": "Asterisk", "target": 0, "func": "pval *pvalContextWalkStatements( pval *p, pval **statements )\n{\n\tif (!pvalCheckType(p, \"pvalContextWalkStatements\", PV_CONTEXT))\n\t\treturn 0;\n\tif (!(*statements))\n\t\t*statements = p->u2.statements;\n\telse {\n\t\t*statements = (*statements)->next;\n\t}\n\treturn *statements;\n}\n", "bug_type": null, "idx": 1410}
{"project": "Asterisk", "target": 0, "func": "static int cli_list_subscriptions_outbound(struct sip_subscription_tree *sub_tree, void *arg)\n{\n\treturn sub_tree->role == AST_SIP_SUBSCRIBER\n\t\t? cli_list_subscriptions_detail(sub_tree, arg) : 0;\n}\n", "bug_type": null, "idx": 1411}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void sig_pri_moh_fsm_event(struct ast_channel *chan, struct sig_pri_chan *pvt, enum sig_pri_moh_event event)\n{\n\tenum sig_pri_moh_state orig_state;\n\tenum sig_pri_moh_state next_state;\n\tconst char *chan_name;\n\tif (chan) {\n\t\tchan_name = ast_strdupa(ast_channel_name(chan));\n\t} else {\n\t\tchan_name = \"Unknown\";\n\t}\n\torig_state = pvt->moh_state;\n\tast_debug(2, \"Channel '%s' MOH-Event: %s in state %s\\n\", chan_name,\n\t\tsig_pri_moh_event_str(event), sig_pri_moh_state_str(orig_state));\n\tif (orig_state < SIG_PRI_MOH_STATE_IDLE || SIG_PRI_MOH_STATE_NUM <= orig_state\n\t\t|| !sig_pri_moh_fsm[orig_state]) {\n\t\t\n\t\tast_log(LOG_ERROR, \"MOH state not implemented: %s(%u)\\n\",\n\t\t\tsig_pri_moh_state_str(orig_state), orig_state);\n\t\treturn;\n\t}\n\t\n\tnext_state = sig_pri_moh_fsm[orig_state](chan, pvt, event);\n\tast_debug(2, \"Channel '%s'  MOH-Next-State: %s\\n\", chan_name,\n\t\t(orig_state == next_state) ? \"$\" : sig_pri_moh_state_str(next_state));\n}\n", "bug_type": null, "idx": 1412}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tif (ast_format_interface_register(\"celt\", &celt_interface)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1413}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_api_provider_unregister(void)\n{\n\tapi_provider = NULL;\n}\n", "bug_type": null, "idx": 1414}
{"project": "Asterisk", "target": 0, "func": "static void wizard_reloaded_observer(const char *name,\n\tconst struct ast_sorcery_wizard *wizard, const char *object_type, int reloaded)\n{\n\tif (!strcmp(name, \"test\") && !strcmp(object_type, \"test_object_type\")\n\t\t&& reloaded) {\n\t\tevent_observed++;\n\t}\n}\n", "bug_type": null, "idx": 1415}
{"project": "Asterisk", "target": 0, "func": "static int analog_flash(struct analog_pvt *p)\n{\n\tif (analog_callbacks.flash) {\n\t\treturn analog_callbacks.flash(p->chan_pvt);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1416}
{"project": "Asterisk", "target": 0, "func": "\nstatic int sorcery_is_criteria_met(struct ast_variable *objset, struct ast_variable *criteria)\n{\n\tRAII_VAR(struct ast_variable *, diff, NULL, ast_variables_destroy);\n\treturn (!criteria || (!ast_sorcery_changeset_create(objset, criteria, &diff) && !diff)) ? 1 : 0;\n}\n", "bug_type": null, "idx": 1417}
{"project": "Asterisk", "target": 0, "func": "static int wav_write(struct ast_filestream *s, struct ast_frame *f)\n{\n\tint len;\n\tint size;\n\tstruct wavg_desc *fs = (struct wavg_desc *)s->_private;\n\t\n\tif (!(f->datalen % MSGSM_FRAME_SIZE)) {\n\t\tsize = MSGSM_FRAME_SIZE;\n\t\tfs->secondhalf = 0;\n\t} else {\n\t\tsize = GSM_FRAME_SIZE;\n\t}\n\tfor (len = 0; len < f->datalen ; len += size) {\n\t\tint res;\n\t\tunsigned char *src, msdata[MSGSM_FRAME_SIZE];\n\t\tif (fs->secondhalf) {\t\n\t\t\tmemcpy(s->buf + GSM_FRAME_SIZE, f->data.ptr + len, GSM_FRAME_SIZE);\n\t\t\tconv66((unsigned char *) s->buf, msdata);\n\t\t\tsrc = msdata;\n\t\t\tfs->secondhalf = 0;\n\t\t} else if (size == GSM_FRAME_SIZE) {\t\n\t\t\tmemcpy(s->buf, f->data.ptr + len, GSM_FRAME_SIZE);\n\t\t\tsrc = NULL;\t\n\t\t\tfs->secondhalf = 1;\n\t\t} else {\t\n\t\t\tsrc = f->data.ptr + len;\n\t\t}\n\t\tif (src && (res = fwrite(src, 1, MSGSM_FRAME_SIZE, s->f)) != MSGSM_FRAME_SIZE) {\n\t\t\tast_log(LOG_WARNING, \"Bad write (%d/65): %s\\n\", res, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1418}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_fd_isset(const struct ast_channel *chan, int which)\n{\n\treturn ast_channel_fd(chan, which) > -1;\n}\n", "bug_type": null, "idx": 1419}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int evaluate_not(struct operator *op, enum aco_option_type type, void *operand)\n{\n\tswitch (type) {\n\tcase OPT_BOOL_T:\n\tcase OPT_BOOLFLAG_T:\n\tcase OPT_INT_T:\n\tcase OPT_UINT_T:\n\t\treturn !(*(int *)operand);\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Cannot evaluate: invalid operand type for operator '%s'\\n\", op->symbol);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1420}
{"project": "Asterisk", "target": 0, "func": "int\nhistory_total_bytes(void)\n{\n\tHistEvent ev;\n\tint curr_num, size;\n\tif (history(h, &ev, H_CURR) != 0)\n\t\treturn (-1);\n\tcurr_num = ev.num;\n\thistory(h, &ev, H_FIRST);\n\tsize = 0;\n\tdo\n\t\tsize += strlen(ev.str);\n\twhile (history(h, &ev, H_NEXT) == 0);\n\t\n\thistory(h, &ev, H_PREV_EVENT, curr_num);\n\treturn (size);\n}\n", "bug_type": null, "idx": 1421}
{"project": "Asterisk", "target": 0, "func": "static void append_interface(char *iface, int maxlen, char *add)\n{\n\tint len = strlen(iface);\n\tif (strlen(add) + len < maxlen - 2) {\n\t\tif (strlen(iface)) {\n\t\t\tiface[len] = '&';\n\t\t\tstrcpy(iface + len + 1, add);\n\t\t} else\n\t\t\tstrcpy(iface, add);\n\t}\n}\n", "bug_type": null, "idx": 1422}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\twav49_f.format = ast_format_gsm;\n\tif (ast_format_def_register(&wav49_f))\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1423}
{"project": "Asterisk", "target": 0, "func": "static void mwi_subscription_shutdown(struct ast_sip_subscription *sub)\n{\n\tstruct mwi_subscription *mwi_sub;\n\tstruct ast_datastore *mwi_datastore;\n\tmwi_datastore = ast_sip_subscription_get_datastore(sub, MWI_DATASTORE);\n\tif (!mwi_datastore) {\n\t\treturn;\n\t}\n\tmwi_sub = mwi_datastore->data;\n\tao2_callback(mwi_sub->stasis_subs, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, unsubscribe_stasis, NULL);\n\tast_sip_subscription_remove_datastore(sub, MWI_DATASTORE);\n\tao2_ref(mwi_datastore, -1);\n}\n", "bug_type": null, "idx": 1424}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225_SeqOfH225RasUsageSpecification (OOCTXT* pctxt, H225_SeqOfH225RasUsageSpecification* pvalue)\n{\n   int stat = ASN_OK;\n   H225RasUsageSpecification* pdata;\n   ASN1UINT count = 0;\n   ASN1UINT xx1;\n   int lstat;\n   dListInit (pvalue);\n   for (;;) {\n      \n      lstat = decodeLength (pctxt, &count);\n      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {\n         return lstat;\n      }\n      \n      for (xx1 = 0; xx1 < count; xx1++) {\n         invokeStartElement (pctxt, \"elem\", xx1);\n         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225RasUsageSpecification);\n         stat = asn1PD_H225RasUsageSpecification (pctxt, pdata);\n         if (stat != ASN_OK) return stat;\n         invokeEndElement (pctxt, \"elem\", xx1);\n         dListAppendNode (pctxt, pvalue, pdata);\n      }\n      if(lstat == ASN_OK) break;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1425}
{"project": "Asterisk", "target": 0, "func": "static int softmix_mixing_array_init(struct softmix_mixing_array *mixing_array,\n\t\tunsigned int starting_num_entries, unsigned int binaural_active)\n{\n\tmemset(mixing_array, 0, sizeof(*mixing_array));\n\tmixing_array->max_num_entries = starting_num_entries;\n\tif (!(mixing_array->buffers = ast_calloc(mixing_array->max_num_entries, sizeof(int16_t *)))) {\n\t\tast_log(LOG_NOTICE, \"Failed to allocate softmix mixing structure.\\n\");\n\t\treturn -1;\n\t}\n\tif (binaural_active) {\n\t\tif (!(mixing_array->chan_pairs = ast_calloc(mixing_array->max_num_entries,\n\t\t\t\tsizeof(struct convolve_channel_pair *)))) {\n\t\t\tast_log(LOG_NOTICE, \"Failed to allocate softmix mixing structure.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1426}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hepv3_config_pre_apply(void)\n{\n\tstruct module_config *config = aco_pending_config(&cfg_info);\n\tif (!config->general->enabled) {\n\t\t\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(config->general->capture_address)) {\n\t\tast_log(AST_LOG_ERROR, \"Missing required configuration option 'capture_address'\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1427}
{"project": "Asterisk", "target": 0, "func": "static void exception_store_free(void *data)\n{\n\tstruct pbx_exception *exception = data;\n\tast_string_field_free_memory(exception);\n\tast_free(exception);\n}\n", "bug_type": null, "idx": 1428}
{"project": "Asterisk", "target": 0, "func": "\nconst struct ast_channel_tech *ast_get_channel_tech(const char *name)\n{\n\tstruct chanlist *chanls;\n\tconst struct ast_channel_tech *ret = NULL;\n\tAST_RWLIST_RDLOCK(&backends);\n\tAST_RWLIST_TRAVERSE(&backends, chanls, list) {\n\t\tif (!strcasecmp(name, chanls->tech->type)) {\n\t\t\tret = chanls->tech;\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&backends);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1429}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\treturn ast_custom_function_unregister(&sysinfo_function);\n}\n", "bug_type": null, "idx": 1430}
{"project": "Asterisk", "target": 0, "func": "static void skel_state_destructor(void *obj)\n{\n\treturn;\n}\n", "bug_type": null, "idx": 1431}
{"project": "Asterisk", "target": 0, "func": "\nstatic int is_variable_true(struct ast_variable *vars, const char *name)\n{\n\treturn ast_true(ast_variable_find_last_in_list(vars, name));\n}\n", "bug_type": null, "idx": 1432}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245EnhancementOptions (OOCTXT* pctxt, H245EnhancementOptions* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.sqcifMPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.qcifMPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.cifMPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.cif4MPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.cif16MPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.slowSqcifMPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.slowQcifMPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.slowCifMPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.slowCif4MPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.slowCif16MPIPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.h263OptionsPresent = optbit;\n   \n   if (pvalue->m.sqcifMPIPresent) {\n      invokeStartElement (pctxt, \"sqcifMPI\", -1);\n      stat = decodeConsUInt8 (pctxt, &pvalue->sqcifMPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->sqcifMPI);\n      invokeEndElement (pctxt, \"sqcifMPI\", -1);\n   }\n   \n   if (pvalue->m.qcifMPIPresent) {\n      invokeStartElement (pctxt, \"qcifMPI\", -1);\n      stat = decodeConsUInt8 (pctxt, &pvalue->qcifMPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->qcifMPI);\n      invokeEndElement (pctxt, \"qcifMPI\", -1);\n   }\n   \n   if (pvalue->m.cifMPIPresent) {\n      invokeStartElement (pctxt, \"cifMPI\", -1);\n      stat = decodeConsUInt8 (pctxt, &pvalue->cifMPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->cifMPI);\n      invokeEndElement (pctxt, \"cifMPI\", -1);\n   }\n   \n   if (pvalue->m.cif4MPIPresent) {\n      invokeStartElement (pctxt, \"cif4MPI\", -1);\n      stat = decodeConsUInt8 (pctxt, &pvalue->cif4MPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->cif4MPI);\n      invokeEndElement (pctxt, \"cif4MPI\", -1);\n   }\n   \n   if (pvalue->m.cif16MPIPresent) {\n      invokeStartElement (pctxt, \"cif16MPI\", -1);\n      stat = decodeConsUInt8 (pctxt, &pvalue->cif16MPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->cif16MPI);\n      invokeEndElement (pctxt, \"cif16MPI\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"maxBitRate\", -1);\n   stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 1U, 192400U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->maxBitRate);\n   invokeEndElement (pctxt, \"maxBitRate\", -1);\n   \n   invokeStartElement (pctxt, \"unrestrictedVector\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->unrestrictedVector);\n   invokeEndElement (pctxt, \"unrestrictedVector\", -1);\n   \n   invokeStartElement (pctxt, \"arithmeticCoding\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->arithmeticCoding);\n   invokeEndElement (pctxt, \"arithmeticCoding\", -1);\n   \n   invokeStartElement (pctxt, \"temporalSpatialTradeOffCapability\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->temporalSpatialTradeOffCapability);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->temporalSpatialTradeOffCapability);\n   invokeEndElement (pctxt, \"temporalSpatialTradeOffCapability\", -1);\n   \n   if (pvalue->m.slowSqcifMPIPresent) {\n      invokeStartElement (pctxt, \"slowSqcifMPI\", -1);\n      stat = decodeConsUInt16 (pctxt, &pvalue->slowSqcifMPI, 1U, 3600U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->slowSqcifMPI);\n      invokeEndElement (pctxt, \"slowSqcifMPI\", -1);\n   }\n   \n   if (pvalue->m.slowQcifMPIPresent) {\n      invokeStartElement (pctxt, \"slowQcifMPI\", -1);\n      stat = decodeConsUInt16 (pctxt, &pvalue->slowQcifMPI, 1U, 3600U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->slowQcifMPI);\n      invokeEndElement (pctxt, \"slowQcifMPI\", -1);\n   }\n   \n   if (pvalue->m.slowCifMPIPresent) {\n      invokeStartElement (pctxt, \"slowCifMPI\", -1);\n      stat = decodeConsUInt16 (pctxt, &pvalue->slowCifMPI, 1U, 3600U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->slowCifMPI);\n      invokeEndElement (pctxt, \"slowCifMPI\", -1);\n   }\n   \n   if (pvalue->m.slowCif4MPIPresent) {\n      invokeStartElement (pctxt, \"slowCif4MPI\", -1);\n      stat = decodeConsUInt16 (pctxt, &pvalue->slowCif4MPI, 1U, 3600U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->slowCif4MPI);\n      invokeEndElement (pctxt, \"slowCif4MPI\", -1);\n   }\n   \n   if (pvalue->m.slowCif16MPIPresent) {\n      invokeStartElement (pctxt, \"slowCif16MPI\", -1);\n      stat = decodeConsUInt16 (pctxt, &pvalue->slowCif16MPI, 1U, 3600U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->slowCif16MPI);\n      invokeEndElement (pctxt, \"slowCif16MPI\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"errorCompensation\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->errorCompensation);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->errorCompensation);\n   invokeEndElement (pctxt, \"errorCompensation\", -1);\n   \n   if (pvalue->m.h263OptionsPresent) {\n      invokeStartElement (pctxt, \"h263Options\", -1);\n      stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"h263Options\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1433}
{"project": "Asterisk", "target": 0, "func": "static char *cli_show_tasks(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ao2_iterator i;\n\tstruct ast_sip_sched_task *schtd;\n\tconst char *log_format = ast_logger_get_dateformat();\n\tstruct ast_tm tm;\n\tchar queued[32];\n\tchar last_start[32];\n\tchar next_start[32];\n\tint datelen;\n\tstruct timeval now = ast_tvnow();\n\tconst char *separator = \"======================================\";\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"pjsip show scheduled_tasks\";\n\t\te->usage = \"Usage: pjsip show scheduled_tasks\\n\"\n\t\t            \"      Show all scheduled tasks\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_localtime(&now, &tm, NULL);\n\tdatelen = ast_strftime(queued, sizeof(queued), log_format, &tm);\n\tast_cli(a->fd, \"PJSIP Scheduled Tasks:\\n\\n\");\n\tast_cli(a->fd, \" %1$-24s %2$-9s %3$-9s %4$-5s  %6$-*5$s  %7$-*5$s  %8$-*5$s %9$7s\\n\",\n\t\t\"Task Name\", \"Interval\", \"Times Run\", \"State\",\n\t\tdatelen, \"Queued\", \"Last Started\", \"Next Start\", \"( secs)\");\n\tast_cli(a->fd, \" %1$-24.24s %2$-9.9s %3$-9.9s %4$-5.5s  %6$-*5$.*5$s  %7$-*5$.*5$s  %9$-*8$.*8$s\\n\",\n\t\tseparator, separator, separator, separator,\n\t\tdatelen, separator, separator, datelen + 8, separator);\n\tao2_ref(tasks, +1);\n\tao2_rdlock(tasks);\n\ti = ao2_iterator_init(tasks, 0);\n\twhile ((schtd = ao2_iterator_next(&i))) {\n\t\tint next_run_sec = ast_sip_sched_task_get_next_run(schtd) / 1000;\n\t\tstruct timeval next = ast_tvadd(now, (struct timeval) {next_run_sec, 0});\n\t\tast_localtime(&schtd->when_queued, &tm, NULL);\n\t\tast_strftime(queued, sizeof(queued), log_format, &tm);\n\t\tif (ast_tvzero(schtd->last_start)) {\n\t\t\tstrcpy(last_start, \"not yet started\");\n\t\t} else {\n\t\t\tast_localtime(&schtd->last_start, &tm, NULL);\n\t\t\tast_strftime(last_start, sizeof(last_start), log_format, &tm);\n\t\t}\n\t\tast_localtime(&next, &tm, NULL);\n\t\tast_strftime(next_start, sizeof(next_start), log_format, &tm);\n\t\tast_cli(a->fd, \" %1$-24.24s %2$9.3f %3$9d %4$-5s  %6$-*5$s  %7$-*5$s  %8$-*5$s (%9$5d)\\n\",\n\t\t\tschtd->name,\n\t\t\tschtd->interval / 1000.0,\n\t\t\tschtd->run_count,\n\t\t\tschtd->is_running ? \"run\" : \"wait\",\n\t\t\tdatelen, queued, last_start,\n\t\t\tnext_start,\n\t\t\tnext_run_sec);\n\t\tao2_cleanup(schtd);\n\t}\n\tao2_iterator_destroy(&i);\n\tao2_unlock(tasks);\n\tao2_ref(tasks, -1);\n\tast_cli(a->fd, \"\\n\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1434}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tif (__ast_format_interface_register(\"opus\", &opus_interface, ast_module_info->self)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1435}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245NonStandardIdentifier (OOCTXT* pctxt, H245NonStandardIdentifier* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);\n   if (stat != ASN_OK) return stat;\n   else pvalue->t = ui + 1;\n   switch (ui) {\n      \n      case 0:\n         invokeStartElement (pctxt, \"object\", -1);\n         pvalue->u.object = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);\n         stat = decodeObjectIdentifier (pctxt, pvalue->u.object);\n         if (stat != ASN_OK) return stat;\n         invokeOidValue (pctxt, pvalue->u.object->numids, pvalue->u.object->subid);\n         invokeEndElement (pctxt, \"object\", -1);\n         break;\n      \n      case 1:\n         invokeStartElement (pctxt, \"h221NonStandard\", -1);\n         pvalue->u.h221NonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardIdentifier_h221NonStandard);\n         stat = asn1PD_H245NonStandardIdentifier_h221NonStandard (pctxt, pvalue->u.h221NonStandard);\n         if (stat != ASN_OK) return stat;\n         invokeEndElement (pctxt, \"h221NonStandard\", -1);\n         break;\n      default:\n         return ASN_E_INVOPT;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1436}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum ID_FIELD_STATUS party_name_write(struct ast_party_name *name, int argc, char *argv[], const char *value)\n{\n\tchar *val;\n\tenum ID_FIELD_STATUS status;\n\tstatus = ID_FIELD_VALID;\n\tif (argc == 0) {\n\t\t\n\t\tname->valid = 1;\n\t\tname->str = ast_strdup(value);\n\t\tast_trim_blanks(name->str);\n\t} else if (argc == 1 && !strcasecmp(\"valid\", argv[0])) {\n\t\tname->valid = atoi(value) ? 1 : 0;\n\t} else if (argc == 1 && !strcasecmp(\"charset\", argv[0])) {\n\t\tint char_set;\n\t\tval = ast_strdupa(value);\n\t\tast_trim_blanks(val);\n\t\tif (('0' <= val[0]) && (val[0] <= '9')) {\n\t\t\tchar_set = atoi(val);\n\t\t} else {\n\t\t\tchar_set = ast_party_name_charset_parse(val);\n\t\t}\n\t\tif (char_set < 0) {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Unknown name char-set '%s', value unchanged\\n\", val);\n\t\t\tstatus = ID_FIELD_INVALID;\n\t\t} else {\n\t\t\tname->char_set = char_set;\n\t\t}\n\t} else if (argc == 1 && !strncasecmp(\"pres\", argv[0], 4)) {\n\t\tint pres;\n\t\t\n\t\tval = ast_strdupa(value);\n\t\tast_trim_blanks(val);\n\t\tif (('0' <= val[0]) && (val[0] <= '9')) {\n\t\t\tpres = atoi(val);\n\t\t} else {\n\t\t\tpres = ast_parse_caller_presentation(val);\n\t\t}\n\t\tif (pres < 0) {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Unknown name presentation '%s', value unchanged\\n\", val);\n\t\t\tstatus = ID_FIELD_INVALID;\n\t\t} else {\n\t\t\tname->presentation = pres;\n\t\t}\n\t} else {\n\t\tstatus = ID_FIELD_UNKNOWN;\n\t}\n\treturn status;\n}\n", "bug_type": null, "idx": 1437}
{"project": "Asterisk", "target": 0, "func": "static gboolean delete_event(GtkWidget *widget, GdkEvent *event, gpointer data)\n{\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 1438}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1439}
{"project": "Asterisk", "target": 0, "func": "int ast_expr(char *expr, char *buf, int length, struct ast_channel *chan)\n{\n\tstruct parse_io io = { .string = expr, .chan = chan };\n\tint return_value = 0;\n\tast_yylex_init(&io.scanner);\n\tast_yy_scan_string(expr, io.scanner);\n\tast_yyparse ((void *) &io);\n\tast_yylex_destroy(io.scanner);\n\tif (!io.val) {\n\t\tif (length > 1) {\n\t\t\tstrcpy(buf, \"0\");\n\t\t\treturn_value = 1;\n\t\t}\n\t} else {\n\t\tif (io.val->type == AST_EXPR_number) {\n\t\t\tint res_length;\n\t\t\tres_length = snprintf(buf, length, FP___PRINTF, io.val->u.i);\n\t\t\treturn_value = (res_length <= length) ? res_length : length;\n\t\t} else {\n\t\t\tif (io.val->u.s)\n#if defined(STANDALONE) || defined(LOW_MEMORY) || defined(STANDALONE)\n\t\t\t\tstrncpy(buf, io.val->u.s, length - 1);\n#else \n\t\t\t\tast_copy_string(buf, io.val->u.s, length);\n#endif \n\t\t\telse\n\t\t\t\tbuf[0] = 0;\n\t\t\treturn_value = strlen(buf);\n\t\t\tfree(io.val->u.s);\n\t\t}\n\t\tfree(io.val);\n\t}\n\treturn return_value;\n}\n", "bug_type": null, "idx": 1440}
{"project": "Asterisk", "target": 0, "func": "static void destroy_all_mailbox_mappings(void)\n{\n\tstruct mailbox_mapping *mm;\n\tast_mutex_lock(&mwi_monitor.lock);\n\twhile ((mm = AST_LIST_REMOVE_HEAD(&mwi_monitor.mailbox_mappings, entry)))\n\t\tdestroy_mailbox_mapping(mm);\n\tast_mutex_unlock(&mwi_monitor.lock);\n}\n", "bug_type": null, "idx": 1441}
{"project": "Asterisk", "target": 0, "func": "static inline int right_node(int i)\n{\n\treturn 2 * i + 1;\n}\n", "bug_type": null, "idx": 1442}
{"project": "Asterisk", "target": 0, "func": "#if !defined(STANDALONE) && !defined(STANDALONE2)\nstatic char *compose_func_args(struct expr_node *arglist)\n{\n\tstruct expr_node *t = arglist;\n\tchar *argbuf;\n\tint total_len = 0;\n\twhile (t) {\n\t\tif (t != arglist)\n\t\t\ttotal_len += 1; \n\t\tif (t->val) {\n\t\t\tif (t->val->type == AST_EXPR_number)\n\t\t\t\ttotal_len += 25; \n\t\t\telse\n\t\t\t\ttotal_len += strlen(t->val->u.s);\n\t\t}\n\t\tt = t->right;\n\t}\n\ttotal_len++; \n\tast_log(LOG_NOTICE,\"argbuf allocated %d bytes;\\n\", total_len);\n\targbuf = malloc(total_len);\n\targbuf[0] = 0;\n\tt = arglist;\n\twhile (t) {\n\t\tchar numbuf[30];\n\t\tif (t != arglist)\n\t\t\tstrcat(argbuf,\",\");\n\t\tif (t->val) {\n\t\t\tif (t->val->type == AST_EXPR_number) {\n\t\t\t\tsprintf(numbuf,FP___PRINTF,t->val->u.i);\n\t\t\t\tstrcat(argbuf,numbuf);\n\t\t\t} else\n\t\t\t\tstrcat(argbuf,t->val->u.s);\n\t\t}\n\t\tt = t->right;\n\t}\n\tast_log(LOG_NOTICE,\"argbuf uses %d bytes;\\n\", (int) strlen(argbuf));\n\treturn argbuf;\n}\n", "bug_type": null, "idx": 1443}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_answertime_set(struct ast_channel *chan, struct timeval *value)\n{\n\tchan->answertime = *value;\n}\n", "bug_type": null, "idx": 1444}
{"project": "Asterisk", "target": 0, "func": "struct stasis_message *stasis_cache_entry_get_remote(struct stasis_cache_entry *entry, int idx)\n{\n\tif (idx < AST_VECTOR_SIZE(&entry->remote)) {\n\t\treturn AST_VECTOR_GET(&entry->remote, idx);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1445}
{"project": "Asterisk", "target": 0, "func": "static void dec_ie_connected_pn(unsigned char *p, Q931_info_t *qi, int *type, int *plan, int *present, int *screen, char *number, size_t number_len, int nt, struct misdn_bchannel *bc)\n{\n\t*type = -1;\n\t*plan = -1;\n\t*present = -1;\n\t*screen = -1;\n\t*number = '\\0';\n\tif (!nt)\n\t{\n\t\tp = NULL;\n\t\tif (qi->QI_ELEMENT(connected_nr))\n\t\t\tp = (unsigned char *)qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(connected_nr) + 1;\n\t}\n\tif (!p)\n\t\treturn;\n\tif (p[0] < 1)\n\t{\n\t\tprintf(\"%s: ERROR: IE too short (%d).\\n\", __FUNCTION__, p[0]);\n\t\treturn;\n\t}\n\t*type = (p[1]&0x70) >> 4;\n\t*plan = p[1] & 0xf;\n\tif (!(p[1] & 0x80))\n\t{\n\t\tif (p[0] < 2)\n\t\t{\n\t\t\tprintf(\"%s: ERROR: IE too short (%d).\\n\", __FUNCTION__, p[0]);\n\t\t\treturn;\n\t\t}\n\t\t*present = (p[2]&0x60) >> 5;\n\t\t*screen = p[2] & 0x3;\n\t\tstrnncpy(number, (char *)p+3, p[0]-2, number_len);\n\t} else\n\t{\n\t\tstrnncpy(number, (char *)p+2, p[0]-1, number_len);\n\t}\n\tif (MISDN_IE_DEBG) printf(\"    type=%d plan=%d present=%d screen=%d number='%s'\\n\", *type, *plan, *present, *screen, number);\n}\n", "bug_type": null, "idx": 1446}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_sip_unregister_publish_handler(&asterisk_devicestate_publication_handler);\n\tast_sip_unregister_publish_handler(&asterisk_mwi_publication_handler);\n\tast_sip_unregister_event_publisher_handler(&asterisk_devicestate_publisher_handler);\n\tast_sip_unregister_event_publisher_handler(&asterisk_mwi_publisher_handler);\n\tast_sorcery_object_unregister(ast_sip_get_sorcery(), \"asterisk-publication\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 1447}
{"project": "Asterisk", "target": 0, "func": "AST_THREADSTORAGE(ast_sockaddr_stringify_buf);\nchar *ast_sockaddr_stringify_fmt(const struct ast_sockaddr *sa, int format)\n{\n\tstruct ast_sockaddr sa_ipv4;\n\tconst struct ast_sockaddr *sa_tmp;\n\tchar host[NI_MAXHOST];\n\tchar port[NI_MAXSERV];\n\tstruct ast_str *str;\n\tint e;\n\tstatic const size_t size = sizeof(host) - 1 + sizeof(port) - 1 + 4;\n\tif (ast_sockaddr_isnull(sa)) {\n\t\treturn \"(null)\";\n\t}\n\tif (!(str = ast_str_thread_get(&ast_sockaddr_stringify_buf, size))) {\n\t\treturn \"\";\n\t}\n\tif (ast_sockaddr_ipv4_mapped(sa, &sa_ipv4)) {\n\t\tsa_tmp = &sa_ipv4;\n\t} else {\n\t\tsa_tmp = sa;\n\t}\n\tif ((e = getnameinfo((struct sockaddr *)&sa_tmp->ss, sa_tmp->len,\n\t\t\t     format & AST_SOCKADDR_STR_ADDR ? host : NULL,\n\t\t\t     format & AST_SOCKADDR_STR_ADDR ? sizeof(host) : 0,\n\t\t\t     format & AST_SOCKADDR_STR_PORT ? port : 0,\n\t\t\t     format & AST_SOCKADDR_STR_PORT ? sizeof(port): 0,\n\t\t\t     NI_NUMERICHOST | NI_NUMERICSERV))) {\n\t\tast_log(LOG_ERROR, \"getnameinfo(): %s\\n\", gai_strerror(e));\n\t\treturn \"\";\n\t}\n\tif ((format & AST_SOCKADDR_STR_REMOTE) == AST_SOCKADDR_STR_REMOTE) {\n\t\tchar *p;\n\t\tif (ast_sockaddr_is_ipv6_link_local(sa) && (p = strchr(host, '%'))) {\n\t\t\t*p = '\\0';\n\t\t}\n\t}\n\tswitch ((format & AST_SOCKADDR_STR_FORMAT_MASK))  {\n\tcase AST_SOCKADDR_STR_DEFAULT:\n\t\tast_str_set(&str, 0, sa_tmp->ss.ss_family == AF_INET6 ?\n\t\t\t\t\"[%s]:%s\" : \"%s:%s\", host, port);\n\t\tbreak;\n\tcase AST_SOCKADDR_STR_ADDR:\n\t\tast_str_set(&str, 0, \"%s\", host);\n\t\tbreak;\n\tcase AST_SOCKADDR_STR_HOST:\n\t\tast_str_set(&str, 0,\n\t\t\t    sa_tmp->ss.ss_family == AF_INET6 ? \"[%s]\" : \"%s\", host);\n\t\tbreak;\n\tcase AST_SOCKADDR_STR_PORT:\n\t\tast_str_set(&str, 0, \"%s\", port);\n\t\tbreak;\n\tdefault:\n\t\tast_log(LOG_ERROR, \"Invalid format\\n\");\n\t\treturn \"\";\n\t}\n\treturn ast_str_buffer(str);\n}\n", "bug_type": null, "idx": 1448}
{"project": "Asterisk", "target": 0, "func": "int AST_OPTIONAL_API_NAME(ast_websocket_write_string)\n\t(struct ast_websocket *ws, const char *buf)\n{\n\tuint64_t len = strlen(buf);\n\tast_debug(3, \"Writing websocket string of length %\" PRIu64 \"\\n\", len);\n\t\n\treturn ast_websocket_write(ws, AST_WEBSOCKET_OPCODE_TEXT,\n\t\t\t\t   (char *)buf, len);\n}\n", "bug_type": null, "idx": 1449}
{"project": "Asterisk", "target": 0, "func": "    *--------------------------------------------------------------*/\n   int main(int argc, char* argv[])\n   {\n       \n       float starttime;\n       float runtime;\n       float outtime;\n       FILE *ifileid,*efileid,*ofileid, *cfileid;\n       short data[BLOCKL_MAX];\n       short encoded_data[ILBCNOOFWORDS_MAX], decoded_data[BLOCKL_MAX];\n       int len;\n       short pli, mode;\n       int blockcount = 0;\n       int packetlosscount = 0;\n       \n       iLBC_Enc_Inst_t Enc_Inst;\n       iLBC_Dec_Inst_t Dec_Inst;\n       \n       if ((argc!=5) && (argc!=6)) {\n           fprintf(stderr,\n           \"\\n*-----------------------------------------------*\\n\");\n           fprintf(stderr,\n           \"   %s <20,30> input encoded decoded (channel)\\n\\n\",\n               argv[0]);\n           fprintf(stderr,\n           \"   mode    : Frame size for the encoding/decoding\\n\");\n           fprintf(stderr,\n           \"                 20 - 20 ms\\n\");\n           fprintf(stderr,\n           \"                 30 - 30 ms\\n\");\n           fprintf(stderr,\n           \"   input   : Speech for encoder (16-bit pcm file)\\n\");\n           fprintf(stderr,\n           \"   encoded : Encoded bit stream\\n\");\n           fprintf(stderr,\n           \"   decoded : Decoded speech (16-bit pcm file)\\n\");\n           fprintf(stderr,\n           \"   channel : Packet loss pattern, optional (16-bit)\\n\");\n           fprintf(stderr,\n           \"                  1 - Packet received correctly\\n\");\n           fprintf(stderr,\n           \"                  0 - Packet Lost\\n\");\n           fprintf(stderr,\n           \"*-----------------------------------------------*\\n\\n\");\n           exit(1);\n       }\n       mode=atoi(argv[1]);\n       if (mode != 20 && mode != 30) {\n           fprintf(stderr,\"Wrong mode %s, must be 20, or 30\\n\",\n               argv[1]);\n           exit(2);\n       }\n       if ( (ifileid=fopen(argv[2],\"rb\")) == NULL) {\n           fprintf(stderr,\"Cannot open input file %s\\n\", argv[2]);\n           exit(2);}\n       if ( (efileid=fopen(argv[3],\"wb\")) == NULL) {\n           fprintf(stderr, \"Cannot open encoded file %s\\n\",\n               argv[3]); exit(1);}\n       if ( (ofileid=fopen(argv[4],\"wb\")) == NULL) {\n           fprintf(stderr, \"Cannot open decoded file %s\\n\",\n               argv[4]); exit(1);}\n       if (argc==6) {\n           if( (cfileid=fopen(argv[5],\"rb\")) == NULL) {\n               fprintf(stderr, \"Cannot open channel file %s\\n\",\n                   argv[5]);\n               exit(1);\n           }\n       } else {\n           cfileid=NULL;\n       }\n       \n       fprintf(stderr, \"\\n\");\n       fprintf(stderr,\n           \"*---------------------------------------------------*\\n\");\n       fprintf(stderr,\n           \"*                                                   *\\n\");\n       fprintf(stderr,\n           \"*      iLBC test program                            *\\n\");\n       fprintf(stderr,\n           \"*                                                   *\\n\");\n       fprintf(stderr,\n           \"*                                                   *\\n\");\n       fprintf(stderr,\n           \"*---------------------------------------------------*\\n\");\n       fprintf(stderr,\"\\nMode           : %2d ms\\n\", mode);\n       fprintf(stderr,\"Input file     : %s\\n\", argv[2]);\n       fprintf(stderr,\"Encoded file   : %s\\n\", argv[3]);\n       fprintf(stderr,\"Output file    : %s\\n\", argv[4]);\n       if (argc==6) {\n           fprintf(stderr,\"Channel file   : %s\\n\", argv[5]);\n       }\n       fprintf(stderr,\"\\n\");\n       \n       initEncode(&Enc_Inst, mode);\n       initDecode(&Dec_Inst, mode, 1);\n       \n       starttime=clock()/(float)CLOCKS_PER_SEC;\n       \n       while (fread(data,sizeof(short),Enc_Inst.blockl,ifileid)==\n               Enc_Inst.blockl) {\n           blockcount++;\n           \n           fprintf(stderr, \"--- Encoding block %i --- \",blockcount);\n           len=encode(&Enc_Inst, encoded_data, data);\n           fprintf(stderr, \"\\r\");\n           \n           if (fwrite(encoded_data, sizeof(unsigned char), len, efileid) != len) {\n               fprintf(stderr, \"Failure in fwritef\\n\");\n           }\n           \n           if (argc==6) {\n               if (fread(&pli, sizeof(short), 1, cfileid)) {\n                   if ((pli!=0)&&(pli!=1)) {\n                       fprintf(stderr, \"Error in channel file\\n\");\n                       exit(0);\n                   }\n                   if (pli==0) {\n                       \n                       memset(encoded_data, 0,\n                           sizeof(short)*ILBCNOOFWORDS_MAX);\n                       packetlosscount++;\n                   }\n               } else {\n                   fprintf(stderr, \"Error. Channel file too short\\n\");\n                   exit(0);\n               }\n           } else {\n               pli=1;\n           }\n           \n           fprintf(stderr, \"--- Decoding block %i --- \",blockcount);\n           len=decode(&Dec_Inst, decoded_data, encoded_data, pli);\n           fprintf(stderr, \"\\r\");\n           \n           if (fwrite(decoded_data,sizeof(short),len,ofileid) != len) {\n               fprintf(stderr, \"Failure in fwritef\\n\");\n           }\n       }\n       \n       runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime);\n       outtime = (float)((float)blockcount*(float)mode/1000.0);\n       printf(\"\\n\\nLength of speech file: %.1f s\\n\", outtime);\n       printf(\"Packet loss          : %.1f%%\\n\",\n           100.0*(float)packetlosscount/(float)blockcount);\n       printf(\"Time to run iLBC     :\");\n       printf(\" %.1f s (%.1f %% of realtime)\\n\\n\", runtime,\n           (100*runtime/outtime));\n       \n       fclose(ifileid);  fclose(efileid); fclose(ofileid);\n       if (argc==6) {\n           fclose(cfileid);\n       }\n       return(0);\n   }\n", "bug_type": null, "idx": 1450}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225_SeqOfH225H245Security (OOCTXT* pctxt, H225_SeqOfH225H245Security* pvalue)\n{\n   int stat = ASN_OK;\n   H225H245Security* pdata;\n   ASN1UINT count = 0;\n   ASN1UINT xx1;\n   int lstat;\n   dListInit (pvalue);\n   for (;;) {\n      \n      lstat = decodeLength (pctxt, &count);\n      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {\n         return lstat;\n      }\n      \n      for (xx1 = 0; xx1 < count; xx1++) {\n         invokeStartElement (pctxt, \"elem\", xx1);\n         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225H245Security);\n         stat = asn1PD_H225H245Security (pctxt, pdata);\n         if (stat != ASN_OK) return stat;\n         invokeEndElement (pctxt, \"elem\", xx1);\n         dListAppendNode (pctxt, pvalue, pdata);\n      }\n      if(lstat == ASN_OK) break;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1451}
{"project": "Asterisk", "target": 0, "func": " */\nint SHA1Input(SHA1Context *context,\n\t\t\t  const uint8_t *message_array, unsigned length)\n{\n\tif (!context) {\n\t\treturn shaNull;\n\t}\n\tif (!length) {\n\t\treturn shaSuccess;\n\t}\n\tif (!message_array) {\n\t\treturn shaNull;\n\t}\n\tif (context->Computed) {\n\t\tcontext->Corrupted = shaStateError;\n\t\treturn shaStateError;\n\t}\n\tif (context->Corrupted) {\n\t\treturn context->Corrupted;\n\t}\n\twhile (length--) {\n\t\tcontext->Message_Block[context->Message_Block_Index++] =\n\t\t\t*message_array;\n\t\tif ((SHA1AddLength(context, 8) == shaSuccess) &&\n\t\t\t(context->Message_Block_Index == SHA1_Message_Block_Size))\n\t\t\tSHA1ProcessMessageBlock(context);\n\t\tmessage_array++;\n\t}\n\treturn context->Corrupted;\n}\n", "bug_type": null, "idx": 1452}
{"project": "Asterisk", "target": 0, "func": "void __ast_string_field_release_active(struct ast_string_field_pool *pool_head,\n\tconst ast_string_field ptr)\n{\n\tstruct ast_string_field_pool *pool, *prev;\n\tif (ptr == __ast_string_field_empty) {\n\t\treturn;\n\t}\n\tfor (pool = pool_head, prev = NULL; pool; prev = pool, pool = pool->prev) {\n\t\tif ((ptr >= pool->base) && (ptr <= (pool->base + pool->size))) {\n\t\t\tpool->active -= AST_STRING_FIELD_ALLOCATION(ptr);\n\t\t\tif (pool->active == 0) {\n\t\t\t\tif (prev) {\n\t\t\t\t\tprev->prev = pool->prev;\n\t\t\t\t\tast_free(pool);\n\t\t\t\t} else {\n\t\t\t\t\tpool->used = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1453}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int string_toupper(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t buflen)\n{\n\tchar *bufptr = buf, *dataptr = data;\n\twhile ((bufptr < buf + buflen - 1) && (*bufptr++ = toupper(*dataptr++)));\n\treturn 0;\n}\n", "bug_type": null, "idx": 1454}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_frame *create_video_frame(uint8_t *start, uint8_t *end,\n\t               int format, int head, struct ast_frame *prev)\n{\n\tint len = end-start;\n\tuint8_t *data;\n\tstruct ast_frame *f;\n\tdata = ast_calloc(1, len+head);\n\tf = ast_calloc(1, sizeof(*f));\n\tif (f == NULL || data == NULL) {\n\t\tast_log(LOG_WARNING, \"--- frame error f %p data %p len %d format %d\\n\",\n\t\t\t\tf, data, len, format);\n\t\tif (f)\n\t\t\tast_free(f);\n\t\tif (data)\n\t\t\tast_free(data);\n\t\treturn NULL;\n\t}\n\tmemcpy(data+head, start, len);\n\tf->data.ptr = data;\n\tf->mallocd = AST_MALLOCD_DATA | AST_MALLOCD_HDR;\n\t \n\t \n\tf->datalen = len+head;\n\tf->frametype = AST_FRAME_VIDEO;\n\tf->subclass = format;\n\tf->samples = 0;\n\tf->offset = 0;\n\tf->src = \"Console\";\n\tf->delivery.tv_sec = 0;\n\tf->delivery.tv_usec = 0;\n\tf->seqno = 0;\n\tAST_LIST_NEXT(f, frame_list) = NULL;\n\tif (prev)\n\t        AST_LIST_NEXT(prev, frame_list) = f;\n\treturn f;\n}\n", "bug_type": null, "idx": 1455}
{"project": "Asterisk", "target": 0, "func": "\nint ast_say_date_th(struct ast_channel *chan, time_t t, const char *ints, const char *lang)\n{\n\tstruct timeval when = { t, 0 };\n\tstruct ast_tm tm;\n\tchar fn[256];\n\tint res = 0;\n\tast_localtime(&when, &tm, NULL);\n\tif (!res) {\n\t\tsnprintf(fn, sizeof(fn), \"digits/day-%d\", tm.tm_wday);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tast_copy_string(fn, \"digits/tee\", sizeof(fn));\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res)\n\t\t\tres = ast_waitstream(chan, ints);\n\t}\n\tif (!res)\n\t\tres = ast_say_number(chan, tm.tm_mday, ints, lang, (char * ) NULL);\n\tif (!res)\n\t\tres = ast_waitstream(chan, ints);\n\tif (!res) {\n\t\tast_copy_string(fn, \"digits/duan\", sizeof(fn));\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tsnprintf(fn, sizeof(fn), \"digits/mon-%d\", tm.tm_mon);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res)\n\t\t\tres = ast_waitstream(chan, ints);\n\t}\n\tif (!res){\n\t\tast_copy_string(fn, \"digits/posor\", sizeof(fn));\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tres = ast_say_number(chan, tm.tm_year + 1900, ints, lang, (char *) NULL);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1456}
{"project": "Asterisk", "target": 0, "func": "int ooGenerateCallIdentifier(H225CallIdentifier *callid)\n{\n   ASN1INT64 timestamp;\n   int i=0;\n#ifdef _WIN32\n   SYSTEMTIME systemTime;\n   GetLocalTime(&systemTime);\n   SystemTimeToFileTime(&systemTime, (LPFILETIME)&timestamp);\n#else\n   struct timeval systemTime;\n   gettimeofday(&systemTime, NULL);\n   timestamp = systemTime.tv_sec * 10000000 + systemTime.tv_usec*10;\n#endif\n   callid->guid.numocts = 16;\n   callid->guid.data[0] = 'o';\n   callid->guid.data[1] = 'o';\n   callid->guid.data[2] = 'h';\n   callid->guid.data[3] = '3';\n   callid->guid.data[4] = '2';\n   callid->guid.data[5] = '3';\n   callid->guid.data[6] = 'c';\n   callid->guid.data[7] = '-';\n   for (i = 8; i < 16; i++)\n       callid->guid.data[i] = (ASN1OCTET)((timestamp>>((i-8+1)*8))&0xff);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1457}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_audiohook_volume_get(struct ast_channel *chan, enum ast_audiohook_direction direction)\n{\n\tstruct audiohook_volume *audiohook_volume = NULL;\n\tint adjustment = 0;\n\t\n\tif (!(audiohook_volume = audiohook_volume_get(chan, 0))) {\n\t\treturn 0;\n\t}\n\t\n\tif (direction == AST_AUDIOHOOK_DIRECTION_READ) {\n\t\tadjustment = audiohook_volume->read_adjustment;\n\t} else if (direction == AST_AUDIOHOOK_DIRECTION_WRITE) {\n\t\tadjustment = audiohook_volume->write_adjustment;\n\t}\n\treturn adjustment;\n}\n", "bug_type": null, "idx": 1458}
{"project": "Asterisk", "target": 0, "func": "static enum ast_test_result_state wait_for_empty_notice(struct ast_test *test, struct test_listener_data *tld)\n{\n\tstruct timeval start = ast_tvnow();\n\tstruct timespec end = {\n\t\t.tv_sec = start.tv_sec + 5,\n\t\t.tv_nsec = start.tv_usec * 1000\n\t};\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\tSCOPED_MUTEX(lock, &tld->lock);\n\twhile (!tld->empty_notice) {\n\t\tif (ast_cond_timedwait(&tld->cond, lock, &end) == ETIMEDOUT) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!tld->empty_notice) {\n\t\tast_test_status_update(test, \"Test listener not notified that threadpool is empty\\n\");\n\t\tres = AST_TEST_FAIL;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1459}
{"project": "Asterisk", "target": 0, "func": "static int acf_curlopt_helper(struct ast_channel *chan, const char *cmd, char *data, char *buf, struct ast_str **bufstr, ssize_t len)\n{\n\tstruct ast_datastore *store;\n\tstruct global_curl_info *list[2] = { &global_curl_info, NULL };\n\tstruct curl_settings *cur = NULL;\n\tCURLoption key;\n\tenum optiontype ot;\n\tint i;\n\tif (parse_curlopt_key(data, &key, &ot)) {\n\t\tast_log(LOG_ERROR, \"Unrecognized option: '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\tif (chan && (store = ast_channel_datastore_find(chan, &curl_info, NULL))) {\n\t\tlist[0] = store->data;\n\t\tlist[1] = &global_curl_info;\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!list[i]) {\n\t\t\tbreak;\n\t\t}\n\t\tAST_LIST_LOCK(list[i]);\n\t\tAST_LIST_TRAVERSE(list[i], cur, list) {\n\t\t\tif (cur->key == key) {\n\t\t\t\tif (ot == OT_BOOLEAN || ot == OT_INTEGER) {\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tsnprintf(buf, len, \"%ld\", (long) cur->value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_str_set(bufstr, len, \"%ld\", (long) cur->value);\n\t\t\t\t\t}\n\t\t\t\t} else if (ot == OT_INTEGER_MS) {\n\t\t\t\t\tif ((long) cur->value % 1000 == 0) {\n\t\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t\tsnprintf(buf, len, \"%ld\", (long)cur->value / 1000);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tast_str_set(bufstr, len, \"%ld\", (long) cur->value / 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t\tsnprintf(buf, len, \"%.3f\", (double) ((long) cur->value) / 1000.0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tast_str_set(bufstr, len, \"%.3f\", (double) ((long) cur->value) / 1000.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (ot == OT_STRING) {\n\t\t\t\t\tast_debug(1, \"Found entry %p, with key %d and value %p\\n\", cur, cur->key, cur->value);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tast_copy_string(buf, cur->value, len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_str_set(bufstr, 0, \"%s\", (char *) cur->value);\n\t\t\t\t\t}\n\t\t\t\t} else if (key == CURLOPT_PROXYTYPE) {\n\t\t\t\t\tconst char *strval = \"unknown\";\n\t\t\t\t\tif (0) {\n#if CURLVERSION_ATLEAST(7,15,2)\n\t\t\t\t\t} else if ((long)cur->value == CURLPROXY_SOCKS4) {\n\t\t\t\t\t\tstrval = \"socks4\";\n#endif\n#if CURLVERSION_ATLEAST(7,18,0)\n\t\t\t\t\t} else if ((long)cur->value == CURLPROXY_SOCKS4A) {\n\t\t\t\t\t\tstrval = \"socks4a\";\n#endif\n\t\t\t\t\t} else if ((long)cur->value == CURLPROXY_SOCKS5) {\n\t\t\t\t\t\tstrval = \"socks5\";\n#if CURLVERSION_ATLEAST(7,18,0)\n\t\t\t\t\t} else if ((long)cur->value == CURLPROXY_SOCKS5_HOSTNAME) {\n\t\t\t\t\t\tstrval = \"socks5hostname\";\n#endif\n#if CURLVERSION_ATLEAST(7,10,0)\n\t\t\t\t\t} else if ((long)cur->value == CURLPROXY_HTTP) {\n\t\t\t\t\t\tstrval = \"http\";\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tast_copy_string(buf, strval, len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_str_set(bufstr, 0, \"%s\", strval);\n\t\t\t\t\t}\n\t\t\t\t} else if (key == CURLOPT_SPECIAL_HASHCOMPAT) {\n\t\t\t\t\tconst char *strval = \"unknown\";\n\t\t\t\t\tif ((long) cur->value == HASHCOMPAT_LEGACY) {\n\t\t\t\t\t\tstrval = \"legacy\";\n\t\t\t\t\t} else if ((long) cur->value == HASHCOMPAT_YES) {\n\t\t\t\t\t\tstrval = \"yes\";\n\t\t\t\t\t} else if ((long) cur->value == HASHCOMPAT_NO) {\n\t\t\t\t\t\tstrval = \"no\";\n\t\t\t\t\t}\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tast_copy_string(buf, strval, len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_str_set(bufstr, 0, \"%s\", strval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tAST_LIST_UNLOCK(list[i]);\n\t\tif (cur) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn cur ? 0 : -1;\n}\n", "bug_type": null, "idx": 1460}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tstruct stasis_topic *manager_topic;\n\tmanager_topic = ast_manager_get_topic();\n\tif (!manager_topic) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\ttopic_forwarder = stasis_forward_all(ast_device_state_topic_all(), manager_topic);\n\tif (!topic_forwarder) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (ast_manager_register_xml(\"DeviceStateList\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING,\n\t\t                         action_devicestatelist)) {\n\t\ttopic_forwarder = stasis_forward_cancel(topic_forwarder);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1461}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum bridge_allow_merge bridges_allow_merge_optimization(struct ast_bridge *chan_bridge,\n\t\tstruct ast_bridge *peer_bridge, int num_kick_channels, struct merge_direction *merge)\n{\n\t*merge = bridge_merge_determine_direction(chan_bridge, peer_bridge);\n\tif (!merge->dest) {\n\t\treturn MERGE_PROHIBITED;\n\t}\n\tif (merge->src->num_channels < 2) {\n\t\treturn MERGE_NOT_ENOUGH_CHANNELS;\n\t} else if ((2 + num_kick_channels) < merge->dest->num_channels + merge->src->num_channels\n\t\t&& !(merge->dest->technology->capabilities & AST_BRIDGE_CAPABILITY_MULTIMIX)\n\t\t&& (!ast_test_flag(&merge->dest->feature_flags, AST_BRIDGE_FLAG_SMART)\n\t\t\t|| !(merge->dest->allowed_capabilities & AST_BRIDGE_CAPABILITY_MULTIMIX))) {\n\t\treturn MERGE_NO_MULTIMIX;\n\t}\n\treturn MERGE_ALLOWED;\n}\n", "bug_type": null, "idx": 1462}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct after_bridge_cb_ds *after_bridge_cb_find(struct ast_channel *chan)\n{\n\tstruct ast_datastore *datastore;\n\tSCOPED_CHANNELLOCK(lock, chan);\n\tdatastore = ast_channel_datastore_find(chan, &after_bridge_cb_info, NULL);\n\tif (!datastore) {\n\t\treturn NULL;\n\t}\n\treturn datastore->data;\n}\n", "bug_type": null, "idx": 1463}
{"project": "Asterisk", "target": 0, "func": "int *ast_io_change(struct io_context *ioc, int *id, int fd, ast_io_cb callback, short events, void *data)\n{\n\t\n\tif (*id > ioc->fdcnt)\n\t\treturn NULL;\n\tif (fd > -1)\n\t\tioc->fds[*id].fd = fd;\n\tif (callback)\n\t\tioc->ior[*id].callback = callback;\n\tif (events)\n\t\tioc->fds[*id].events = events;\n\tif (data)\n\t\tioc->ior[*id].data = data;\n\treturn id;\n}\n", "bug_type": null, "idx": 1464}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpDisableDTMFQ931Keypad()\n{\n   return ooCapabilityDisableDTMFQ931Keypad(NULL);\n}\n", "bug_type": null, "idx": 1465}
{"project": "Asterisk", "target": 0, "func": "static struct ast_dns_record *generic_record_alloc(struct ast_dns_query *query, const char *data, const size_t size)\n{\n\tstruct ast_dns_record *record;\n\trecord = ast_calloc(1, sizeof(*record) + size);\n\tif (!record) {\n\t\treturn NULL;\n\t}\n\trecord->data_ptr = record->data;\n\treturn record;\n}\n", "bug_type": null, "idx": 1466}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct chan_oss_pvt *store_config(struct ast_config *cfg, char *ctg)\n{\n\tstruct ast_variable *v;\n\tstruct chan_oss_pvt *o;\n\tif (ctg == NULL) {\n\t\to = &oss_default;\n\t\tctg = \"general\";\n\t} else {\n\t\tif (!(o = ast_calloc(1, sizeof(*o))))\n\t\t\treturn NULL;\n\t\t*o = oss_default;\n\t\t\n\t\tif (strcmp(ctg, \"general\") == 0) {\n\t\t\to->name = ast_strdup(\"dsp\");\n\t\t\toss_active = o->name;\n\t\t\tgoto openit;\n\t\t}\n\t\to->name = ast_strdup(ctg);\n\t}\n\tstrcpy(o->mohinterpret, \"default\");\n\to->lastopen = ast_tvnow();\t\n\t\n\tfor (v = ast_variable_browse(cfg, ctg); v; v = v->next) {\n\t\tstore_config_core(o, v->name, v->value);\n\t}\n\tif (ast_strlen_zero(o->device))\n\t\tast_copy_string(o->device, DEV_DSP, sizeof(o->device));\n\tif (o->mixer_cmd) {\n\t\tchar *cmd;\n\t\tif (ast_asprintf(&cmd, \"mixer %s\", o->mixer_cmd) >= 0) {\n\t\t\tast_log(LOG_WARNING, \"running [%s]\\n\", cmd);\n\t\t\tif (system(cmd) < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"system() failed: %s\\n\", strerror(errno));\n\t\t\t}\n\t\t\tast_free(cmd);\n\t\t}\n\t}\n\t\n\tif (get_gui_startup(o->env))\n\t\tconsole_video_start(o->env, NULL);\n\tif (o == &oss_default)\t\t\n\t\treturn NULL;\nopenit:\n#ifdef TRYOPEN\n\tif (setformat(o, O_RDWR) < 0) {\t\n\t\tast_verb(1, \"Device %s not detected\\n\", ctg);\n\t\tast_verb(1, \"Turn off OSS support by adding \" \"'noload=chan_oss.so' in /etc/asterisk/modules.conf\\n\");\n\t\tgoto error;\n\t}\n\tif (o->duplex != M_FULL)\n\t\tast_log(LOG_WARNING, \"XXX I don't work right with non \" \"full-duplex sound cards XXX\\n\");\n#endif \n\t\n\tif (o != &oss_default) {\n\t\to->next = oss_default.next;\n\t\toss_default.next = o;\n\t}\n\treturn o;\n#ifdef TRYOPEN\nerror:\n\tif (o != &oss_default)\n\t\tast_free(o);\n\treturn NULL;\n#endif\n}\n", "bug_type": null, "idx": 1467}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *bridge_channel_depart_thread(void *data)\n{\n\tstruct ast_bridge_channel *bridge_channel = data;\n\tint res = 0;\n\tif (bridge_channel->callid) {\n\t\tast_callid_threadassoc_add(bridge_channel->callid);\n\t}\n\tres = bridge_channel_internal_join(bridge_channel);\n\t\n\tao2_t_cleanup(bridge_channel->swap, \"Bridge complete: Departable impart join failed\");\n\tbridge_channel->swap = NULL;\n\tast_bridge_features_destroy(bridge_channel->features);\n\tbridge_channel->features = NULL;\n\tast_bridge_discard_after_callback(bridge_channel->chan,\n\t\tres ? AST_BRIDGE_AFTER_CB_REASON_IMPART_FAILED : AST_BRIDGE_AFTER_CB_REASON_DEPART);\n\t\n\tbridge_channel_impart_signal(bridge_channel->chan);\n\tast_bridge_discard_after_goto(bridge_channel->chan);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1468}
{"project": "Asterisk", "target": 0, "func": "int main(int argc, char *argv[])\n{\n\tchar *dbname;\n\tstruct stat dont_care;\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"%s takes the path of astdb as its only argument\\n\", basename(argv[0]));\n\t\texit(-1);\n\t}\n\tif (stat(argv[1], &dont_care)) {\n\t\tfprintf(stderr, \"Unable to open %s: %s\\n\", argv[1], strerror(errno));\n\t\texit(-1);\n\t}\n\tif (!(dbname = alloca(strlen(argv[1]) + sizeof(\".sqlite3\")))) {\n\t\texit(-1);\n\t}\n\tstrcpy(dbname, argv[1]);\n\tstrcat(dbname, \".sqlite3\");\n\tif (!stat(dbname, &dont_care)) {\n\t\tfprintf(stderr, \"%s already exists!\\n\", dbname);\n\t\texit(-1);\n\t}\n\tif (sql_db_init(dbname)) {\n\t\texit(-1);\n\t}\n\tif (convert_bdb_to_sqlite3(argv[1])) {\n\t\tfprintf(stderr, \"Database conversion failed!\\n\");\n\t\texit(-1);\n\t\tsqlite3_close(astdb);\n\t}\n\tsqlite3_close(astdb);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1469}
{"project": "Asterisk", "target": 0, "func": "static int mark_dirty_cb(void *obj, void *arg, int flags)\n{\n\tstruct realtime_sqlite3_db *db = obj;\n\tdb->dirty = 1;\n\treturn CMP_MATCH;\n}\n", "bug_type": null, "idx": 1470}
{"project": "Asterisk", "target": 0, "func": "int sig_pri_indicate(struct sig_pri_chan *p, struct ast_channel *chan, int condition, const void *data, size_t datalen)\n{\n\tint res = -1;\n\tswitch (condition) {\n\tcase AST_CONTROL_BUSY:\n\t\tif (p->priindication_oob || p->no_b_channel) {\n\t\t\tast_channel_hangupcause_set(chan, AST_CAUSE_USER_BUSY);\n\t\t\tast_channel_softhangup_internal_flag_add(chan, AST_SOFTHANGUP_DEV);\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tres = sig_pri_play_tone(p, SIG_PRI_TONE_BUSY);\n\t\tif (p->call_level < SIG_PRI_CALL_LEVEL_ALERTING && !p->outgoing) {\n\t\t\tast_channel_hangupcause_set(chan, AST_CAUSE_USER_BUSY);\n\t\t\tp->progress = 1;\n\t\t\tif (p->pri && p->pri->pri) {\n\t\t\t\tpri_grab(p, p->pri);\n#ifdef HAVE_PRI_PROG_W_CAUSE\n\t\t\t\tpri_progress_with_cause(p->pri->pri, p->call, PVT_TO_CHANNEL(p), 1, ast_channel_hangupcause(chan));\n#else\n\t\t\t\tpri_progress(p->pri->pri,p->call, PVT_TO_CHANNEL(p), 1);\n#endif\n\t\t\t\tpri_rel(p->pri);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_RINGING:\n\t\tif (p->call_level < SIG_PRI_CALL_LEVEL_ALERTING && !p->outgoing) {\n\t\t\tp->call_level = SIG_PRI_CALL_LEVEL_ALERTING;\n\t\t\tif (p->pri && p->pri->pri) {\n\t\t\t\tpri_grab(p, p->pri);\n\t\t\t\tpri_acknowledge(p->pri->pri,p->call, PVT_TO_CHANNEL(p),\n\t\t\t\t\tp->no_b_channel || p->digital ? 0 : 1);\n\t\t\t\tpri_rel(p->pri);\n\t\t\t}\n\t\t}\n\t\tres = sig_pri_play_tone(p, SIG_PRI_TONE_RINGTONE);\n\t\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\t\tif (ast_channel_state(chan) != AST_STATE_RING)\n\t\t\t\tast_setstate(chan, AST_STATE_RINGING);\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_PROCEEDING:\n\t\tast_debug(1, \"Received AST_CONTROL_PROCEEDING on %s\\n\",ast_channel_name(chan));\n\t\tif (p->call_level < SIG_PRI_CALL_LEVEL_PROCEEDING && !p->outgoing) {\n\t\t\tp->call_level = SIG_PRI_CALL_LEVEL_PROCEEDING;\n\t\t\tif (p->pri && p->pri->pri) {\n\t\t\t\tpri_grab(p, p->pri);\n\t\t\t\tpri_proceeding(p->pri->pri,p->call, PVT_TO_CHANNEL(p), 0);\n\t\t\t\tpri_rel(p->pri);\n\t\t\t}\n\t\t}\n\t\t\n\t\tres = 0;\n\t\tbreak;\n\tcase AST_CONTROL_PROGRESS:\n\t\tast_debug(1, \"Received AST_CONTROL_PROGRESS on %s\\n\",ast_channel_name(chan));\n\t\tsig_pri_set_digital(p, 0);\t\n\t\tif (!p->progress && p->call_level < SIG_PRI_CALL_LEVEL_ALERTING && !p->outgoing\n\t\t\t&& !p->no_b_channel) {\n\t\t\tp->progress = 1;\n\t\t\tif (p->pri && p->pri->pri) {\n\t\t\t\tpri_grab(p, p->pri);\n#ifdef HAVE_PRI_PROG_W_CAUSE\n\t\t\t\tpri_progress_with_cause(p->pri->pri,p->call, PVT_TO_CHANNEL(p), 1, -1);  \n#else\n\t\t\t\tpri_progress(p->pri->pri,p->call, PVT_TO_CHANNEL(p), 1);\n#endif\n\t\t\t\tpri_rel(p->pri);\n\t\t\t}\n\t\t}\n\t\t\n\t\tres = 0;\n\t\tbreak;\n\tcase AST_CONTROL_INCOMPLETE:\n\t\t\n\t\tif (p->call_level == SIG_PRI_CALL_LEVEL_CONNECT || (p->pri->overlapdial & DAHDI_OVERLAPDIAL_INCOMING)) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tast_channel_hangupcause_set(chan, AST_CAUSE_INVALID_NUMBER_FORMAT);\n\t\t\n\tcase AST_CONTROL_CONGESTION:\n\t\tif (p->priindication_oob || p->no_b_channel) {\n\t\t\t\n\t\t\tswitch (ast_channel_hangupcause(chan)) {\n\t\t\tcase AST_CAUSE_USER_BUSY:\n\t\t\tcase AST_CAUSE_NORMAL_CLEARING:\n\t\t\tcase 0:\n\t\t\t\t\n\t\t\t\tast_channel_hangupcause_set(chan, AST_CAUSE_SWITCH_CONGESTION);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_channel_softhangup_internal_flag_add(chan, AST_SOFTHANGUP_DEV);\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tres = sig_pri_play_tone(p, SIG_PRI_TONE_CONGESTION);\n\t\tif (p->call_level < SIG_PRI_CALL_LEVEL_ALERTING && !p->outgoing) {\n\t\t\t\n\t\t\tswitch (ast_channel_hangupcause(chan)) {\n\t\t\tcase AST_CAUSE_USER_BUSY:\n\t\t\tcase AST_CAUSE_NORMAL_CLEARING:\n\t\t\tcase 0:\n\t\t\t\t\n\t\t\t\tast_channel_hangupcause_set(chan, AST_CAUSE_SWITCH_CONGESTION);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp->progress = 1;\n\t\t\tif (p->pri && p->pri->pri) {\n\t\t\t\tpri_grab(p, p->pri);\n#ifdef HAVE_PRI_PROG_W_CAUSE\n\t\t\t\tpri_progress_with_cause(p->pri->pri, p->call, PVT_TO_CHANNEL(p), 1, ast_channel_hangupcause(chan));\n#else\n\t\t\t\tpri_progress(p->pri->pri,p->call, PVT_TO_CHANNEL(p), 1);\n#endif\n\t\t\t\tpri_rel(p->pri);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_HOLD:\n\t\tast_copy_string(p->moh_suggested, S_OR(data, \"\"), sizeof(p->moh_suggested));\n\t\tif (p->pri) {\n\t\t\tpri_grab(p, p->pri);\n\t\t\tsig_pri_moh_fsm_event(chan, p, SIG_PRI_MOH_EVENT_HOLD);\n\t\t\tpri_rel(p->pri);\n\t\t} else {\n\t\t\t\n\t\t\tast_moh_start(chan, data, p->mohinterpret);\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_UNHOLD:\n\t\tif (p->pri) {\n\t\t\tpri_grab(p, p->pri);\n\t\t\tsig_pri_moh_fsm_event(chan, p, SIG_PRI_MOH_EVENT_UNHOLD);\n\t\t\tpri_rel(p->pri);\n\t\t} else {\n\t\t\t\n\t\t\tast_moh_stop(chan);\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_SRCUPDATE:\n\t\tres = 0;\n\t\tbreak;\n\tcase -1:\n\t\tres = sig_pri_play_tone(p, -1);\n\t\tbreak;\n\tcase AST_CONTROL_CONNECTED_LINE:\n\t\tast_debug(1, \"Received AST_CONTROL_CONNECTED_LINE on %s\\n\", ast_channel_name(chan));\n\t\tif (p->pri) {\n\t\t\tstruct pri_party_connected_line connected;\n\t\t\tint dialplan;\n\t\t\tint prefix_strip;\n\t\t\tint colp_allowed = 0;\n\t\t\tstruct ast_party_id connected_id = ast_channel_connected_effective_id(chan);\n\t\t\tpri_grab(p, p->pri);\n\t\t\t\n\t\t\tswitch (p->pri->colp_send) {\n\t\t\tcase SIG_PRI_COLP_BLOCK:\n\t\t\t\tbreak;\n\t\t\tcase SIG_PRI_COLP_CONNECT:\n\t\t\t\t\n\t\t\t\tif (p->call_level <= SIG_PRI_CALL_LEVEL_ALERTING && !p->outgoing) {\n\t\t\t\t\tcolp_allowed = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SIG_PRI_COLP_UPDATE:\n\t\t\t\tcolp_allowed = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!colp_allowed) {\n\t\t\t\tpri_rel(p->pri);\n\t\t\t\tast_debug(1, \"Blocked AST_CONTROL_CONNECTED_LINE on %s\\n\",\n\t\t\t\t\tast_channel_name(chan));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset(&connected, 0, sizeof(connected));\n\t\t\tsig_pri_party_id_from_ast(&connected.id, &connected_id);\n\t\t\t\n\t\t\tswitch (p->pri->cpndialplan) {\n\t\t\tcase -2:\n\t\t\tcase -1:\n\t\t\t\t\n\t\t\t\tprefix_strip = 0;\n\t\t\t\tif (!strncmp(connected.id.number.str, p->pri->internationalprefix,\n\t\t\t\t\tstrlen(p->pri->internationalprefix))) {\n\t\t\t\t\tprefix_strip = strlen(p->pri->internationalprefix);\n\t\t\t\t\tdialplan = PRI_INTERNATIONAL_ISDN;\n\t\t\t\t} else if (!strncmp(connected.id.number.str, p->pri->nationalprefix,\n\t\t\t\t\tstrlen(p->pri->nationalprefix))) {\n\t\t\t\t\tprefix_strip = strlen(p->pri->nationalprefix);\n\t\t\t\t\tdialplan = PRI_NATIONAL_ISDN;\n\t\t\t\t} else {\n\t\t\t\t\tdialplan = PRI_LOCAL_ISDN;\n\t\t\t\t}\n\t\t\t\tconnected.id.number.plan = dialplan;\n\t\t\t\tif (prefix_strip && p->pri->cpndialplan != -2) {\n\t\t\t\t\t\n\t\t\t\t\tmemmove(connected.id.number.str,\n\t\t\t\t\t\tconnected.id.number.str + prefix_strip,\n\t\t\t\t\t\tstrlen(connected.id.number.str + prefix_strip) + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconnected.id.number.plan = p->pri->cpndialplan - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpri_connected_line_update(p->pri->pri, p->call, &connected);\n\t\t\tpri_rel(p->pri);\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_REDIRECTING:\n\t\tast_debug(1, \"Received AST_CONTROL_REDIRECTING on %s\\n\", ast_channel_name(chan));\n\t\tif (p->pri) {\n\t\t\tpri_grab(p, p->pri);\n\t\t\tsig_pri_redirecting_update(p, chan);\n\t\t\tpri_rel(p->pri);\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_AOC:\n#if defined(HAVE_PRI_AOC_EVENTS)\n\t\t{\n\t\t\tstruct ast_aoc_decoded *decoded\n\t\t\t\t= ast_aoc_decode((struct ast_aoc_encoded *) data, datalen, chan);\n\t\t\tast_debug(1, \"Received AST_CONTROL_AOC on %s\\n\", ast_channel_name(chan));\n\t\t\tif (decoded && p->pri) {\n\t\t\t\tpri_grab(p, p->pri);\n\t\t\t\tswitch (ast_aoc_get_msg_type(decoded)) {\n\t\t\t\tcase AST_AOC_S:\n\t\t\t\t\tif (p->pri->aoc_passthrough_flag & SIG_PRI_AOC_GRANT_S) {\n\t\t\t\t\t\tsig_pri_aoc_s_from_ast(p, decoded);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AST_AOC_D:\n\t\t\t\t\tif (p->pri->aoc_passthrough_flag & SIG_PRI_AOC_GRANT_D) {\n\t\t\t\t\t\tsig_pri_aoc_d_from_ast(p, decoded);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AST_AOC_E:\n\t\t\t\t\tif (p->pri->aoc_passthrough_flag & SIG_PRI_AOC_GRANT_E) {\n\t\t\t\t\t\tsig_pri_aoc_e_from_ast(p, decoded);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (p->waiting_for_aoce) {\n\t\t\t\t\t\tp->waiting_for_aoce = 0;\n\t\t\t\t\t\tast_debug(1,\n\t\t\t\t\t\t\t\"Received final AOC-E msg, continue with hangup on %s\\n\",\n\t\t\t\t\t\t\tast_channel_name(chan));\n\t\t\t\t\t\tast_queue_hangup(chan);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AST_AOC_REQUEST:\n\t\t\t\t\t\n\t\t\t\t\tif (ast_aoc_get_termination_request(decoded)) {\n\t\t\t\t\t\tpri_hangup(p->pri->pri, p->call, -1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpri_rel(p->pri);\n\t\t\t}\n\t\t\tast_aoc_destroy_decoded(decoded);\n\t\t}\n#endif\t\n\t\tbreak;\n#if defined(HAVE_PRI_MCID)\n\tcase AST_CONTROL_MCID:\n\t\tif (p->pri && p->pri->pri && p->pri->mcid_send) {\n\t\t\tpri_grab(p, p->pri);\n\t\t\tpri_mcid_req_send(p->pri->pri, p->call);\n\t\t\tpri_rel(p->pri);\n\t\t}\n\t\tbreak;\n#endif\t\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1471}
{"project": "Asterisk", "target": 0, "func": "static int saycountedadj_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *parse;\n\tint number;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(number);\n\t\tAST_APP_ARG(adjective);\n\t\tAST_APP_ARG(gender);\n\t);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"SayCountedAdj requires two or three arguments (<number>,<adjective>[,<gender>])\\n\");\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc < 2) {\n\t\tast_log(LOG_WARNING, \"SayCountedAdj requires at least two arguments\\n\");\n\t\treturn -1;\n\t}\n\tif (sscanf(args.number, \"%d\", &number) != 1) {\n\t\tast_log(LOG_WARNING, \"First argument must be a number between 0 and 2,147,483,647.\\n\");\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(args.gender)) {\n\t\tif (strchr(\"cCfFmMnN\", args.gender[0])) {\n\t\t\tast_log(LOG_WARNING, \"SayCountedAdj gender option must be one of 'f', 'm', 'c', or 'n'.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn ast_say_counted_adjective(chan, number, args.adjective, args.gender);\n}\n", "bug_type": null, "idx": 1472}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *app_to_json(const struct stasis_app *app)\n{\n\tRAII_VAR(struct ast_json *, json, NULL, ast_json_unref);\n\tstruct ast_json *channels;\n\tstruct ast_json *bridges;\n\tstruct ast_json *endpoints;\n\tstruct ao2_iterator i;\n\tvoid *obj;\n\tjson = ast_json_pack(\"{s: s, s: [], s: [], s: []}\",\n\t\t\"name\", app->name,\n\t\t\"channel_ids\", \"bridge_ids\", \"endpoint_ids\");\n\tchannels = ast_json_object_get(json, \"channel_ids\");\n\tbridges = ast_json_object_get(json, \"bridge_ids\");\n\tendpoints = ast_json_object_get(json, \"endpoint_ids\");\n\ti = ao2_iterator_init(app->forwards, 0);\n\twhile ((obj = ao2_iterator_next(&i))) {\n\t\tRAII_VAR(struct app_forwards *, forwards, obj, ao2_cleanup);\n\t\tRAII_VAR(struct ast_json *, id, NULL, ast_json_unref);\n\t\tint append_res = -1;\n\t\tid = ast_json_string_create(forwards->id);\n\t\tswitch (forwards->forward_type) {\n\t\tcase FORWARD_CHANNEL:\n\t\t\tappend_res = ast_json_array_append(channels,\n\t\t\t\tast_json_ref(id));\n\t\t\tbreak;\n\t\tcase FORWARD_BRIDGE:\n\t\t\tappend_res = ast_json_array_append(bridges,\n\t\t\t\tast_json_ref(id));\n\t\t\tbreak;\n\t\tcase FORWARD_ENDPOINT:\n\t\t\tappend_res = ast_json_array_append(endpoints,\n\t\t\t\tast_json_ref(id));\n\t\t\tbreak;\n\t\t}\n\t\tif (append_res != 0) {\n\t\t\tast_log(LOG_ERROR, \"Error building response\\n\");\n\t\t\tao2_iterator_destroy(&i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tao2_iterator_destroy(&i);\n\treturn ast_json_ref(json);\n}\n", "bug_type": null, "idx": 1473}
{"project": "Asterisk", "target": 0, "func": "static int retrieve_parked_user_targeted(void *obj, void *arg, int flags)\n{\n\tint *target = arg;\n\tstruct parked_user *user = obj;\n\tif (user->parking_space == *target) {\n\t\treturn CMP_MATCH;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1474}
{"project": "Asterisk", "target": 0, "func": "enum ast_pbx_result ast_pbx_run(struct ast_channel *c)\n{\n\treturn ast_pbx_run_args(c, NULL);\n}\n", "bug_type": null, "idx": 1475}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_stream_topology_changed(struct ast_channel *chan, struct ast_stream_topology *topology)\n{\n\tast_assert(chan != NULL);\n\tast_assert(topology != NULL);\n\tif (!ast_channel_is_multistream(chan) || !ast_channel_tech(chan)->indicate) {\n\t\treturn -1;\n\t}\n\treturn ast_channel_tech(chan)->indicate(chan, AST_CONTROL_STREAM_TOPOLOGY_CHANGED, topology, sizeof(topology));\n}\n", "bug_type": null, "idx": 1476}
{"project": "Asterisk", "target": 0, "func": "static int endelm(void *userdata, int state, const char *nspace, const char *name)\n{\n\tstruct xml_context *ctx = userdata;\n\tast_debug(5, \"EWS: XML: End:   %s\\n\", name);\n\tif (ctx->op == XML_OP_FIND || ctx->op == XML_OP_CREATE) {\n\t\treturn NE_XML_DECLINE;\n\t}\n\tif (!strcmp(name, \"Subject\")) {\n\t\t\n\t\tast_string_field_set(ctx->event, summary, ast_str_buffer(ctx->cdata));\n\t\tast_debug(3, \"EWS: XML: Summary: %s\\n\", ctx->event->summary);\n\t\tast_str_reset(ctx->cdata);\n\t} else if (!strcmp(name, \"Body\") && state == XML_EVENT_DESCRIPTION) {\n\t\t\n\t\tast_string_field_set(ctx->event, description, ast_str_buffer(ctx->cdata));\n\t\tast_debug(3, \"EWS: XML: Description: %s\\n\", ctx->event->description);\n\t\tast_str_reset(ctx->cdata);\n\t} else if (!strcmp(name, \"Organizer\")) {\n\t\t\n\t\tast_string_field_set(ctx->event, organizer, ast_str_buffer(ctx->cdata));\n\t\tast_debug(3, \"EWS: XML: Organizer: %s\\n\", ctx->event->organizer);\n\t\tast_str_reset(ctx->cdata);\n\t} else if (!strcmp(name, \"Location\")) {\n\t\t\n\t\tast_string_field_set(ctx->event, location, ast_str_buffer(ctx->cdata));\n\t\tast_debug(3, \"EWS: XML: Location: %s\\n\", ctx->event->location);\n\t\tast_str_reset(ctx->cdata);\n\t} else if (!strcmp(name, \"Categories\")) {\n\t\t\n\t\tast_string_field_set(ctx->event, categories, ast_str_buffer(ctx->cdata));\n\t\tast_debug(3, \"EWS: XML: Categories: %s\\n\", ctx->event->categories);\n\t\tast_str_reset(ctx->cdata);\n\t} else if (!strcmp(name, \"Importance\")) {\n\t\t\n\t\tif (!strcmp(ast_str_buffer(ctx->cdata), \"Low\")) {\n\t\t\tctx->event->priority = 9;\n\t\t} else if (!strcmp(ast_str_buffer(ctx->cdata), \"Normal\")) {\n\t\t\tctx->event->priority = 5;\n\t\t} else if (!strcmp(ast_str_buffer(ctx->cdata), \"High\")) {\n\t\t\tctx->event->priority = 1;\n\t\t}\n\t\tast_debug(3, \"EWS: XML: Importance: %s (%d)\\n\", ast_str_buffer(ctx->cdata), ctx->event->priority);\n\t\tast_str_reset(ctx->cdata);\n\t} else if (state == XML_EVENT_EMAIL_ADDRESS) {\n\t\tstruct ast_calendar_attendee *attendee;\n\t\tif (!(attendee = ast_calloc(1, sizeof(*attendee)))) {\n\t\t\tctx->event = ast_calendar_unref_event(ctx->event);\n\t\t\treturn  1;\n\t\t}\n\t\tif (ast_str_strlen(ctx->cdata)) {\n\t\t\tattendee->data = ast_strdup(ast_str_buffer(ctx->cdata));\n\t\t\tAST_LIST_INSERT_TAIL(&ctx->event->attendees, attendee, next);\n\t\t} else {\n\t\t\tast_free(attendee);\n\t\t}\n\t\tast_debug(3, \"EWS: XML: attendee address '%s'\\n\", ast_str_buffer(ctx->cdata));\n\t\tast_str_reset(ctx->cdata);\n\t} else if (!strcmp(name, \"CalendarItem\")) {\n\t\t\n\t\tast_debug(3, \"EWS: XML: </CalendarItem>\\n\");\n\t\tast_free(ctx->cdata);\n\t\tif (ctx->event) {\n\t\t\tao2_link(ctx->pvt->events, ctx->event);\n\t\t\tctx->event = ast_calendar_unref_event(ctx->event);\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Event data ended in XML, but event object does not exist!\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(name, \"Envelope\")) {\n\t\t\n\t\tast_debug(3, \"EWS: XML: %d of %u event(s) has been parsed\u00e2\u20ac\u00a6\\n\", ao2_container_count(ctx->pvt->events), ctx->pvt->items);\n\t\tif (ao2_container_count(ctx->pvt->events) >= ctx->pvt->items) {\n\t\t\tast_debug(3, \"EWS: XML: All events has been parsed, merging\u00e2\u20ac\u00a6\\n\");\n\t\t\tast_calendar_merge_events(ctx->pvt->owner, ctx->pvt->events);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1477}
{"project": "Asterisk", "target": 0, "func": "\nstatic void mwi_contact_changed(const struct ast_sip_contact *contact)\n{\n\tchar *id = ast_strdupa(ast_sorcery_object_get_id(contact));\n\tchar *aor = NULL;\n\tstruct ast_sip_endpoint *endpoint = NULL;\n\tif (contact->endpoint) {\n\t\tendpoint = ao2_bump(contact->endpoint);\n\t} else {\n\t\tif (!ast_strlen_zero(contact->endpoint_name)) {\n\t\t\tendpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"endpoint\", contact->endpoint_name);\n\t\t}\n\t}\n\tif (!endpoint || ast_strlen_zero(endpoint->subscription.mwi.mailboxes)) {\n\t\tao2_cleanup(endpoint);\n\t\treturn;\n\t}\n\tao2_lock(unsolicited_mwi);\n\tcreate_mwi_subscriptions_for_endpoint(endpoint, NULL, 0);\n\tao2_unlock(unsolicited_mwi);\n\tao2_cleanup(endpoint);\n\taor = strsep(&id, \";@\");\n\tao2_callback(unsolicited_mwi, OBJ_NODATA, send_contact_notify, aor);\n}\n", "bug_type": null, "idx": 1478}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int codec_handler_fn(const struct aco_option *opt, struct ast_variable *var, void *obj) {\n\tstruct ast_format_cap **cap = (struct ast_format_cap **)(obj + opt->args[0]);\n\treturn ast_format_cap_update_by_allow_disallow(*cap, var->value, opt->flags);\n}\n", "bug_type": null, "idx": 1479}
{"project": "Asterisk", "target": 0, "func": "struct ast_serializer_shutdown_group *ast_serializer_shutdown_group_alloc(void)\n{\n\tstruct ast_serializer_shutdown_group *shutdown_group;\n\tshutdown_group = ao2_alloc(sizeof(*shutdown_group), serializer_shutdown_group_dtor);\n\tif (!shutdown_group) {\n\t\treturn NULL;\n\t}\n\tast_cond_init(&shutdown_group->cond, NULL);\n\treturn shutdown_group;\n}\n", "bug_type": null, "idx": 1480}
{"project": "Asterisk", "target": 0, "func": "static int recording_stop(struct stasis_app_recording *recording)\n{\n\trecording->state = STASIS_APP_RECORDING_STATE_COMPLETE;\n\treturn stasis_app_control_queue_control(recording->control,\n\t\tAST_CONTROL_RECORD_STOP);\n}\n", "bug_type": null, "idx": 1481}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int dundi_query_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(number);\n\t\tAST_APP_ARG(context);\n\t\tAST_APP_ARG(options);\n\t);\n\tstruct ast_flags opts = { 0, };\n\tchar *parse;\n\tstruct dundi_result_datastore *drds;\n\tstruct ast_datastore *datastore;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"DUNDIQUERY requires an argument (number)\\n\");\n\t\treturn -1;\n\t}\n\tif (!chan) {\n\t\tast_log(LOG_ERROR, \"DUNDIQUERY can not be used without a channel!\\n\");\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (!ast_strlen_zero(args.options))\n\t\tast_app_parse_options(dundi_query_opts, &opts, NULL, args.options);\n\tif (ast_strlen_zero(args.context))\n\t\targs.context = \"e164\";\n\tif (!(drds = ast_calloc(1, sizeof(*drds)))) {\n\t\treturn -1;\n\t}\n\tdrds->id = ast_atomic_fetchadd_int((int *) &dundi_result_id, 1);\n\tsnprintf(buf, len, \"%u\", drds->id);\n\tif (!(datastore = ast_datastore_alloc(&dundi_result_datastore_info, buf))) {\n\t\tdrds_destroy(drds);\n\t\treturn -1;\n\t}\n\tdatastore->data = drds;\n\tdrds->num_results = dundi_lookup(drds->results, ARRAY_LEN(drds->results), NULL, args.context,\n\t\targs.number, ast_test_flag(&opts, OPT_BYPASS_CACHE));\n\tif (drds->num_results > 0)\n\t\tsort_results(drds->results, drds->num_results);\n\tast_channel_lock(chan);\n\tast_channel_datastore_add(chan, datastore);\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1482}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void cleanup_resource_list(struct resource_list *list)\n{\n\tif (!list) {\n\t\treturn;\n\t}\n\tast_sorcery_delete(ast_sip_get_sorcery(), list);\n\tao2_cleanup(list);\n}\n", "bug_type": null, "idx": 1483}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res;\n\tres = ast_register_application_xml(app_log, log_exec);\n\tres |= ast_register_application_xml(app_verbose, verbose_exec);\n\treturn res;\n}\n", "bug_type": null, "idx": 1484}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ss7_reset_linkset(struct sig_ss7_linkset *linkset)\n{\n\tint i, startcic, endcic, dpc;\n\tstruct sig_ss7_chan *p;\n\tif (linkset->numchans <= 0) {\n\t\treturn;\n\t}\n\tstartcic = linkset->pvts[0]->cic;\n\tp = linkset->pvts[0];\n\t\n\tdpc = linkset->pvts[0]->dpc;\n\tfor (i = 0; i < linkset->numchans; i++) {\n\t\tif (linkset->pvts[i+1]\n\t\t\t&& linkset->pvts[i+1]->dpc == dpc\n\t\t\t&& linkset->pvts[i+1]->cic - linkset->pvts[i]->cic == 1\n\t\t\t&& linkset->pvts[i]->cic - startcic < (linkset->type == SS7_ANSI ? 24 : 31)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tendcic = linkset->pvts[i]->cic;\n\t\t\tast_verb(1, \"Resetting CICs %d to %d\\n\", startcic, endcic);\n\t\t\tsig_ss7_lock_private(p);\n\t\t\tif (!ss7_find_alloc_call(p)) {\n\t\t\t\tast_log(LOG_ERROR, \"Unable to allocate new ss7call\\n\");\n\t\t\t} else if (!(endcic - startcic)) {\t\n\t\t\t\tisup_rsc(linkset->ss7, p->ss7call);\n\t\t\t} else {\n\t\t\t\tisup_grs(linkset->ss7, p->ss7call, endcic);\n\t\t\t}\n\t\t\tsig_ss7_unlock_private(p);\n\t\t\t\n\t\t\tif (linkset->pvts[i+1]) {\n\t\t\t\tstartcic = linkset->pvts[i+1]->cic;\n\t\t\t\tdpc = linkset->pvts[i+1]->dpc;\n\t\t\t\tp = linkset->pvts[i+1];\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1485}
{"project": "Asterisk", "target": 0, "func": "static void recalc_holdtime(struct queue_ent *qe, int newholdtime)\n{\n\tint oldvalue;\n\t\n\t\n\t\n\tao2_lock(qe->parent);\n\tif ((qe->parent->callscompleted + qe->parent->callsabandoned) == 0) {\n\t\tqe->parent->holdtime = newholdtime;\n\t} else {\n\t\toldvalue = qe->parent->holdtime;\n\t\tqe->parent->holdtime = (((oldvalue << 2) - oldvalue) + newholdtime) >> 2;\n\t}\n\tao2_unlock(qe->parent);\n}\n", "bug_type": null, "idx": 1486}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void pri_queue_for_destruction(struct sig_pri_span *pri)\n{\n\tstruct doomed_pri *entry;\n\tAST_LIST_LOCK(&doomed_pris);\n\tAST_LIST_TRAVERSE(&doomed_pris, entry, list) {\n\t\tif (entry->pri == pri) {\n\t\t\tAST_LIST_UNLOCK(&doomed_pris);\n\t\t\treturn;\n\t\t}\n\t}\n\tentry = ast_calloc(sizeof(struct doomed_pri), 1);\n\tif (!entry) {\n\t\t\n\t\tast_log(LOG_WARNING, \"Failed allocating memory for a doomed_pri.\\n\");\n\t\tAST_LIST_UNLOCK(&doomed_pris);\n\t\treturn;\n\t}\n\tentry->pri = pri;\n\tast_debug(4, \"Queue span %d for destruction.\\n\", pri->span);\n\tAST_LIST_INSERT_TAIL(&doomed_pris, entry, list);\n\tAST_LIST_UNLOCK(&doomed_pris);\n}\n", "bug_type": null, "idx": 1487}
{"project": "Asterisk", "target": 0, "func": "\nint ast_devstate_prov_add(const char *label, ast_devstate_prov_cb_type callback)\n{\n\tstruct devstate_prov *devcb;\n\tstruct devstate_prov *devprov;\n\tif (!callback || !(devprov = ast_calloc(1, sizeof(*devprov))))\n\t\treturn -1;\n\tdevprov->callback = callback;\n\tast_copy_string(devprov->label, label, sizeof(devprov->label));\n\tAST_RWLIST_WRLOCK(&devstate_provs);\n\tAST_RWLIST_TRAVERSE(&devstate_provs, devcb, list) {\n\t\tif (!strcasecmp(devcb->label, label)) {\n\t\t\tast_log(LOG_WARNING, \"Device state provider '%s' already registered\\n\", label);\n\t\t\tast_free(devprov);\n\t\t\tAST_RWLIST_UNLOCK(&devstate_provs);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tAST_RWLIST_INSERT_HEAD(&devstate_provs, devprov, list);\n\tAST_RWLIST_UNLOCK(&devstate_provs);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1488}
{"project": "Asterisk", "target": 0, "func": "struct ast_filestream *ast_channel_vstream(const struct ast_channel *chan)\n{\n\treturn chan->vstream;\n}\n", "bug_type": null, "idx": 1489}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void bridge_handle_actions(struct ast_bridge *bridge)\n{\n\tstruct ast_frame *action;\n\twhile ((action = AST_LIST_REMOVE_HEAD(&bridge->action_queue, frame_list))) {\n\t\tswitch (action->frametype) {\n\t\tcase AST_FRAME_BRIDGE_ACTION:\n\t\t\tbridge_action_bridge(bridge, action);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\n\t\t\tast_assert(0);\n\t\t\tbreak;\n\t\t}\n\t\tast_frfree(action);\n\t}\n}\n", "bug_type": null, "idx": 1490}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *ast_ext_ctx(struct console_pvt *pvt, const char *src, char **ext, char **ctx)\n{\n\tif (ext == NULL || ctx == NULL)\n\t\treturn NULL;\t\t\t\n\t*ext = *ctx = NULL;\n\tif (src && *src != '\\0')\n\t\t*ext = ast_strdup(src);\n\tif (*ext == NULL)\n\t\treturn NULL;\n\tif (!pvt->overridecontext) {\n\t\t\n\t\t*ctx = strrchr(*ext, '@');\n\t\tif (*ctx)\n\t\t\t*(*ctx)++ = '\\0';\n\t}\n\treturn *ext;\n}\n", "bug_type": null, "idx": 1491}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    ast_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) ast_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    \n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    ast_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );\n}\n", "bug_type": null, "idx": 1492}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int bridge_parking_push(struct ast_bridge_parking *self, struct ast_bridge_channel *bridge_channel, struct ast_bridge_channel *swap)\n{\n\tstruct parked_user *pu;\n\tconst char *blind_transfer;\n\tRAII_VAR(struct ast_channel *, parker, NULL, ao2_cleanup); \n\tRAII_VAR(struct park_common_datastore *, park_datastore, NULL, park_common_datastore_free);\n\tast_bridge_base_v_table.push(&self->base, bridge_channel, swap);\n\tast_assert(self->lot != NULL);\n\t\n\tif (ast_channel_state(bridge_channel->chan) != AST_STATE_UP) {\n\t\tast_answer(bridge_channel->chan);\n\t}\n\tif (swap) {\n\t\tint use_ringing = 0;\n\t\tast_bridge_channel_lock(swap);\n\t\tpu = swap->bridge_pvt;\n\t\tif (!pu) {\n\t\t\t\n\t\t\tpublish_parked_call_failure(bridge_channel->chan);\n\t\t\tast_bridge_channel_unlock(swap);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpu->chan = bridge_channel->chan;\n\t\tbridge_channel->bridge_pvt = pu;\n\t\tswap->bridge_pvt = NULL;\n\t\tif (ast_bridge_channel_has_role(swap, \"holding_participant\")) {\n\t\t\tconst char *idle_mode = ast_bridge_channel_get_role_option(swap, \"holding_participant\", \"idle_mode\");\n\t\t\tif (!ast_strlen_zero(idle_mode) && !strcmp(idle_mode, \"ringing\")) {\n\t\t\t\tuse_ringing = 1;\n\t\t\t}\n\t\t}\n\t\tast_bridge_channel_unlock(swap);\n\t\tparking_set_duration(bridge_channel->features, pu);\n\t\tif (parking_channel_set_roles(bridge_channel->chan, self->lot, use_ringing)) {\n\t\t\tast_log(LOG_WARNING, \"Failed to apply holding bridge roles to %s while joining the parking lot.\\n\",\n\t\t\t\tast_channel_name(bridge_channel->chan));\n\t\t}\n\t\tpublish_parked_call(pu, PARKED_CALL_SWAP);\n\t\treturn 0;\n\t}\n\tif (!(park_datastore = get_park_common_datastore_copy(bridge_channel->chan))) {\n\t\t\n\t\treturn -1;\n\t}\n\tparker = ast_channel_get_by_name(park_datastore->parker_uuid);\n\t\n\tast_channel_lock(bridge_channel->chan);\n\tblind_transfer = pbx_builtin_getvar_helper(bridge_channel->chan, \"BLINDTRANSFER\");\n\tblind_transfer = ast_strdupa(S_OR(blind_transfer, \"\"));\n\tast_channel_unlock(bridge_channel->chan);\n\tif ((!parker || parker == bridge_channel->chan)\n\t\t&& !ast_strlen_zero(blind_transfer)) {\n\t\tstruct ast_channel *real_parker = ast_channel_get_by_name(blind_transfer);\n\t\tif (real_parker) {\n\t\t\tao2_cleanup(parker);\n\t\t\tparker = real_parker;\n\t\t}\n\t}\n\tpu = generate_parked_user(self->lot, bridge_channel->chan, parker,\n\t\tpark_datastore->parker_dial_string, park_datastore->randomize, park_datastore->time_limit);\n\tif (!pu) {\n\t\tpublish_parked_call_failure(bridge_channel->chan);\n\t\treturn -1;\n\t}\n\t\n\tif (park_datastore->comeback_override) {\n\t\tast_copy_string(pu->comeback, park_datastore->comeback_override, sizeof(pu->comeback));\n\t}\n\t\n\tpublish_parked_call(pu, PARKED_CALL);\n\t\n\tif (ast_strlen_zero(blind_transfer) && !park_datastore->silence_announce) {\n\t\tchar saynum_buf[16];\n\t\tsnprintf(saynum_buf, sizeof(saynum_buf), \"%d %d\", 0, pu->parking_space);\n\t\tast_bridge_channel_queue_playfile(bridge_channel, say_parking_space, saynum_buf, NULL);\n\t}\n\t\n\tparking_set_duration(bridge_channel->features, pu);\n\t\n\tbridge_channel->bridge_pvt = pu;\n\tast_verb(3, \"Parking '\" COLORIZE_FMT \"' in '\" COLORIZE_FMT \"' at space %d\\n\",\n\t\tCOLORIZE(COLOR_BRMAGENTA, 0, ast_channel_name(bridge_channel->chan)),\n\t\tCOLORIZE(COLOR_BRMAGENTA, 0, self->lot->name),\n\t\tpu->parking_space);\n\tparking_notify_metermaids(pu->parking_space, self->lot->cfg->parking_con, AST_DEVICE_INUSE);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1493}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int stackpeek_read(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **str, ssize_t len)\n{\n\tstruct ast_datastore *stack_store;\n\tstruct gosub_stack_list *oldlist;\n\tstruct gosub_stack_frame *frame;\n\tint n;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(n);\n\t\tAST_APP_ARG(which);\n\t\tAST_APP_ARG(suppress);\n\t);\n\tif (!chan) {\n\t\tast_log(LOG_ERROR, \"STACK_PEEK must be called on an active channel\\n\");\n\t\treturn -1;\n\t}\n\tdata = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.n) || ast_strlen_zero(args.which)) {\n\t\tast_log(LOG_ERROR, \"STACK_PEEK requires parameters n and which\\n\");\n\t\treturn -1;\n\t}\n\tn = atoi(args.n);\n\tif (n <= 0) {\n\t\tast_log(LOG_ERROR, \"STACK_PEEK must be called with a positive peek value\\n\");\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\tif (!(stack_store = ast_channel_datastore_find(chan, &stack_info, NULL))) {\n\t\tif (!ast_true(args.suppress)) {\n\t\t\tast_log(LOG_ERROR, \"STACK_PEEK called on a channel without a gosub stack\\n\");\n\t\t}\n\t\tast_channel_unlock(chan);\n\t\treturn -1;\n\t}\n\toldlist = stack_store->data;\n\tAST_LIST_LOCK(oldlist);\n\tAST_LIST_TRAVERSE(oldlist, frame, entries) {\n\t\tif (--n == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!frame) {\n\t\t\n\t\tif (!ast_true(args.suppress)) {\n\t\t\tast_log(LOG_ERROR, \"Stack peek of '%s' is more stack frames than I have\\n\", args.n);\n\t\t}\n\t\tAST_LIST_UNLOCK(oldlist);\n\t\tast_channel_unlock(chan);\n\t\treturn -1;\n\t}\n\targs.which = ast_skip_blanks(args.which);\n\tswitch (args.which[0]) {\n\tcase 'l': \n\t\tast_str_set(str, len, \"%s,%s,%d\", frame->context, frame->extension, frame->priority - 1);\n\t\tbreak;\n\tcase 'c': \n\t\tast_str_set(str, len, \"%s\", frame->context);\n\t\tbreak;\n\tcase 'e': \n\t\tast_str_set(str, len, \"%s\", frame->extension);\n\t\tbreak;\n\tcase 'p': \n\t\tast_str_set(str, len, \"%d\", frame->priority - 1);\n\t\tbreak;\n\tdefault:\n\t\tast_log(LOG_ERROR, \"Unknown argument '%s' to STACK_PEEK\\n\", args.which);\n\t\tbreak;\n\t}\n\tAST_LIST_UNLOCK(oldlist);\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1494}
{"project": "Asterisk", "target": 0, "func": "static int testclient_exec(struct ast_channel *chan, const char *data)\n{\n\tint res = 0;\n\tconst char *testid=data;\n\tchar fn[80];\n\tchar serverver[80];\n\tFILE *f;\n\t\n\tif (ast_strlen_zero(testid)) {\n\t\tast_log(LOG_WARNING, \"TestClient requires an argument - the test id\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_channel_state(chan) != AST_STATE_UP)\n\t\tres = ast_answer(chan);\n\t\n\tres = ast_safe_sleep(chan, 3000);\n\t\n\tif (!res)\n\t\tres = ast_dtmf_stream(chan, NULL, \"8378*1#\", 0, 0);\n\tast_debug(1, \"Transmit client version\\n\");\n\t\n\tast_debug(1, \"Read server version\\n\");\n\tif (!res)\n\t\tres = ast_app_getdata(chan, NULL, serverver, sizeof(serverver) - 1, 0);\n\tif (res > 0)\n\t\tres = 0;\n\tast_debug(1, \"server version: %s\\n\", serverver);\n\tif (res > 0)\n\t\tres = 0;\n\tif (!res)\n\t\tres = ast_safe_sleep(chan, 1000);\n\t\n\tif (!res)\n\t\tres = ast_dtmf_stream(chan, NULL, testid, 0, 0);\n\tif (!res)\n\t\tres = ast_dtmf_stream(chan, NULL, \"#\", 0, 0);\n\tast_debug(1, \"send test identifier: %s\\n\", testid);\n\tif ((res >=0) && (!ast_strlen_zero(testid))) {\n\t\t\n\t\tsnprintf(fn, sizeof(fn), \"%s/testresults\", ast_config_AST_LOG_DIR);\n\t\tast_mkdir(fn, 0777);\n\t\tsnprintf(fn, sizeof(fn), \"%s/testresults/%s-client.txt\", ast_config_AST_LOG_DIR, testid);\n\t\tif ((f = fopen(fn, \"w+\"))) {\n\t\t\tsetlinebuf(f);\n\t\t\tfprintf(f, \"CLIENTCHAN:    %s\\n\", ast_channel_name(chan));\n\t\t\tfprintf(f, \"CLIENTTEST ID: %s\\n\", testid);\n\t\t\tfprintf(f, \"ANSWER:        PASS\\n\");\n\t\t\tres = 0;\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 2.  Wait DTMF 1\\n\");\n\t\t\t\tres = ast_waitfordigit(chan, 3000);\n\t\t\t\tfprintf(f, \"WAIT DTMF 1:   %s\\n\", (res != '1') ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res == '1')\n\t\t\t\t\tres = 0;\n\t\t\t\telse\n\t\t\t\t\tres = -1;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\tres = ast_safe_sleep(chan, 1000);\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 2.  Send DTMF 2\\n\");\n\t\t\t\tres = ast_dtmf_stream(chan, NULL, \"2\", 0, 0);\n\t\t\t\tfprintf(f, \"SEND DTMF 2:   %s\\n\", (res < 0) ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res > 0)\n\t\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 3.  Wait one second\\n\");\n\t\t\t\tres = ast_safe_sleep(chan, 1000);\n\t\t\t\tfprintf(f, \"WAIT 1 SEC:    %s\\n\", (res < 0) ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res > 0)\n\t\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 4.  Measure noise\\n\");\n\t\t\t\tres = measurenoise(chan, 5000, \"TestClient\");\n\t\t\t\tfprintf(f, \"MEASURENOISE:  %s (%d)\\n\", (res < 0) ? \"FAIL\" : \"PASS\", res);\n\t\t\t\tif (res > 0)\n\t\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 5.  Wait DTMF 4\\n\");\n\t\t\t\tres = ast_waitfordigit(chan, 3000);\n\t\t\t\tfprintf(f, \"WAIT DTMF 4:   %s\\n\", (res != '4') ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res == '4')\n\t\t\t\t\tres = 0;\n\t\t\t\telse\n\t\t\t\t\tres = -1;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 6.  Transmit tone\\n\");\n\t\t\t\tres = sendnoise(chan, 6000);\n\t\t\t\tfprintf(f, \"SENDTONE:      %s\\n\", (res < 0) ? \"FAIL\" : \"PASS\");\n\t\t\t}\n\t\t\tif (!res || (res == '5')) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 7.  Wait DTMF 5\\n\");\n\t\t\t\tif (!res)\n\t\t\t\t\tres = ast_waitfordigit(chan, 3000);\n\t\t\t\tfprintf(f, \"WAIT DTMF 5:   %s\\n\", (res != '5') ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res == '5')\n\t\t\t\t\tres = 0;\n\t\t\t\telse\n\t\t\t\t\tres = -1;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 8.  Wait one second\\n\");\n\t\t\t\tres = ast_safe_sleep(chan, 1000);\n\t\t\t\tfprintf(f, \"WAIT 1 SEC:    %s\\n\", (res < 0) ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res > 0)\n\t\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 9.  Measure tone\\n\");\n\t\t\t\tres = measurenoise(chan, 4000, \"TestClient\");\n\t\t\t\tfprintf(f, \"MEASURETONE:   %s (%d)\\n\", (res < 0) ? \"FAIL\" : \"PASS\", res);\n\t\t\t\tif (res > 0)\n\t\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 10.  Send DTMF 7\\n\");\n\t\t\t\tres = ast_dtmf_stream(chan, NULL, \"7\", 0, 0);\n\t\t\t\tfprintf(f, \"SEND DTMF 7:   %s\\n\", (res < 0) ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res > 0)\n\t\t\t\t\tres =0;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 11.  Wait DTMF 8\\n\");\n\t\t\t\tres = ast_waitfordigit(chan, 3000);\n\t\t\t\tfprintf(f, \"WAIT DTMF 8:   %s\\n\", (res != '8') ? \"FAIL\" : \"PASS\");\n\t\t\t\tif (res == '8')\n\t\t\t\t\tres = 0;\n\t\t\t\telse\n\t\t\t\t\tres = -1;\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\tres = ast_safe_sleep(chan, 1000);\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\t\n\t\t\t\tast_debug(1, \"TestClient: 12.  Hangup\\n\");\n\t\t\t}\n\t\t\tast_debug(1, \"-- TEST COMPLETE--\\n\");\n\t\t\tfprintf(f, \"-- END TEST--\\n\");\n\t\t\tfclose(f);\n\t\t\tres = -1;\n\t\t} else\n\t\t\tres = -1;\n\t} else {\n\t\tast_log(LOG_NOTICE, \"Did not read a test ID on '%s'\\n\", ast_channel_name(chan));\n\t\tres = -1;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1495}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245IS11172VideoCapability (OOCTXT* pctxt, H245IS11172VideoCapability* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.videoBadMBsCapPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.videoBitRatePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.vbvBufferSizePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.samplesPerLinePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.linesPerFramePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.pictureRatePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.luminanceSampleRatePresent);\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->constrainedBitstream);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.videoBitRatePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->videoBitRate, 0U, 1073741823U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.vbvBufferSizePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->vbvBufferSize, 0U, 262143U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.samplesPerLinePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->samplesPerLine, 0U, 16383U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.linesPerFramePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->linesPerFrame, 0U, 16383U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.pictureRatePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->pictureRate, 0U, 15U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.luminanceSampleRatePresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->luminanceSampleRate, 0U, ASN1UINT_MAX);\n      if (stat != ASN_OK) return stat;\n   }\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 0);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.videoBadMBsCapPresent);\n      \n      if (pvalue->m.videoBadMBsCapPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeBit (&lctxt, (ASN1BOOL)pvalue->videoBadMBsCap);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1496}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MultilinkResponse (OOCTXT* pctxt, H245MultilinkResponse* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 5);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 4);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245MultilinkResponse_callInformation (pctxt, pvalue->u.callInformation);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245MultilinkResponse_addConnection (pctxt, pvalue->u.addConnection);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = asn1PE_H245MultilinkResponse_removeConnection (pctxt, pvalue->u.removeConnection);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 5:\n            stat = asn1PE_H245MultilinkResponse_maximumHeaderInterval (pctxt, pvalue->u.maximumHeaderInterval);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 6);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1497}
{"project": "Asterisk", "target": 0, "func": "static int extension_presence_state_helper(struct ast_exten *e, char **subtype, char **message)\n{\n\tstruct ast_str *hint_app = ast_str_thread_get(&extensionstate_buf, 32);\n\tchar *presence_provider;\n\tconst char *app;\n\tif (!e || !hint_app) {\n\t\treturn -1;\n\t}\n\tapp = ast_get_extension_app(e);\n\tif (ast_strlen_zero(app)) {\n\t\treturn -1;\n\t}\n\tast_str_set(&hint_app, 0, \"%s\", app);\n\tpresence_provider = parse_hint_presence(hint_app);\n\tif (ast_strlen_zero(presence_provider)) {\n\t\t\n\t\treturn 0;\n\t}\n\treturn ast_presence_state(presence_provider, subtype, message);\n}\n", "bug_type": null, "idx": 1498}
{"project": "Asterisk", "target": 0, "func": "\nstatic int sorcery_observers_notify_update(void *data)\n{\n\tstruct sorcery_observer_invocation *invocation = data;\n\tao2_callback(invocation->object_type->observers, OBJ_NODATA, sorcery_observer_notify_update, invocation->object);\n\tao2_cleanup(invocation);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1499}
{"project": "Asterisk", "target": 0, "func": "struct ast_bridge_features *ast_bridge_features_new(void)\n{\n\tstruct ast_bridge_features *features;\n\tfeatures = ast_malloc(sizeof(*features));\n\tif (features) {\n\t\tif (ast_bridge_features_init(features)) {\n\t\t\tast_bridge_features_destroy(features);\n\t\t\tfeatures = NULL;\n\t\t}\n\t}\n\treturn features;\n}\n", "bug_type": null, "idx": 1500}
{"project": "Asterisk", "target": 0, "func": "private void\nmap_print_all_keys(EditLine *el)\n{\n\tint prev, i;\n\t(void) fprintf(el->el_outfile, \"Standard key bindings\\n\");\n\tprev = 0;\n\tfor (i = 0; i < N_KEYS; i++) {\n\t\tif (el->el_map.key[prev] == el->el_map.key[i])\n\t\t\tcontinue;\n\t\tmap_print_some_keys(el, el->el_map.key, prev, i - 1);\n\t\tprev = i;\n\t}\n\tmap_print_some_keys(el, el->el_map.key, prev, i - 1);\n\t(void) fprintf(el->el_outfile, \"Alternative key bindings\\n\");\n\tprev = 0;\n\tfor (i = 0; i < N_KEYS; i++) {\n\t\tif (el->el_map.alt[prev] == el->el_map.alt[i])\n\t\t\tcontinue;\n\t\tmap_print_some_keys(el, el->el_map.alt, prev, i - 1);\n\t\tprev = i;\n\t}\n\tmap_print_some_keys(el, el->el_map.alt, prev, i - 1);\n\t(void) fprintf(el->el_outfile, \"Multi-character bindings\\n\");\n\tkey_print(el, \"\");\n\t(void) fprintf(el->el_outfile, \"Arrow key bindings\\n\");\n\tterm_print_arrow(el, \"\");\n}\n", "bug_type": null, "idx": 1501}
{"project": "Asterisk", "target": 0, "func": "static struct ast_sip_publish_handler *find_pub_handler(const char *event)\n{\n\tstruct ast_sip_publish_handler *iter = NULL;\n\tAST_RWLIST_RDLOCK(&publish_handlers);\n\tAST_RWLIST_TRAVERSE(&publish_handlers, iter, next) {\n\t\tif (strcmp(event, iter->event_name)) {\n\t\t\tast_debug(3, \"Event %s does not match %s\\n\", event, iter->event_name);\n\t\t\tcontinue;\n\t\t}\n\t\tast_debug(3, \"Event name match: %s = %s\\n\", event, iter->event_name);\n\t\tbreak;\n\t}\n\tAST_RWLIST_UNLOCK(&publish_handlers);\n\treturn iter;\n}\n", "bug_type": null, "idx": 1502}
{"project": "Asterisk", "target": 0, "func": "static void update_initial_connected_line(struct ast_sip_session *session)\n{\n\tstruct ast_party_connected_line connected;\n\t\n\tast_channel_lock(session->channel);\n\tast_party_id_copy(&session->id, &ast_channel_caller(session->channel)->id);\n\tast_channel_unlock(session->channel);\n\t\n\tif (!session->id.number.valid && !session->id.name.valid) {\n\t\treturn;\n\t}\n\tast_party_connected_line_init(&connected);\n\tconnected.id = session->id;\n\tconnected.source = AST_CONNECTED_LINE_UPDATE_SOURCE_ANSWER;\n\tast_channel_queue_connected_line_update(session->channel, &connected, NULL);\n}\n", "bug_type": null, "idx": 1503}
{"project": "Asterisk", "target": 0, "func": "static int handle_bchan(msg_t *msg)\n{\n\tiframe_t *frm= (iframe_t*)msg->data;\n\tstruct misdn_bchannel *bc=find_bc_by_addr(frm->addr);\n\tstruct misdn_stack *stack;\n\tif (!bc) {\n\t\tcb_log(1,0,\"handle_bchan: BC not found for prim:%x with addr:%x dinfo:%x\\n\", frm->prim, frm->addr, frm->dinfo);\n\t\treturn 0 ;\n\t}\n\tstack = get_stack_by_bc(bc);\n\tif (!stack) {\n\t\tcb_log(0, bc->port,\"handle_bchan: STACK not found for prim:%x with addr:%x dinfo:%x\\n\", frm->prim, frm->addr, frm->dinfo);\n\t\treturn 0;\n\t}\n\tswitch (frm->prim) {\n\tcase MGR_SETSTACK| CONFIRM:\n\t\tcb_log(3, stack->port, \"BCHAN: MGR_SETSTACK|CONFIRM pid:%d\\n\",bc->pid);\n\t\tbreak;\n\tcase MGR_SETSTACK| INDICATION:\n\t\tcb_log(3, stack->port, \"BCHAN: MGR_SETSTACK|IND pid:%d\\n\",bc->pid);\n\tbreak;\n\tcase MGR_DELLAYER| INDICATION:\n\t\tcb_log(3, stack->port, \"BCHAN: MGR_DELLAYER|IND pid:%d\\n\",bc->pid);\n\t\tbreak;\n\tcase MGR_DELLAYER| CONFIRM:\n\t\tcb_log(3, stack->port, \"BCHAN: MGR_DELLAYER|CNF pid:%d\\n\",bc->pid);\n\t\tbc->pid=0;\n\t\tbc->addr=0;\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase PH_ACTIVATE | INDICATION:\n\tcase DL_ESTABLISH | INDICATION:\n\t\tcb_log(3, stack->port, \"BCHAN: ACT Ind pid:%d\\n\", bc->pid);\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase PH_ACTIVATE | CONFIRM:\n\tcase DL_ESTABLISH | CONFIRM:\n\t\tcb_log(3, stack->port, \"BCHAN: bchan ACT Confirm pid:%d\\n\",bc->pid);\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase DL_ESTABLISH | REQUEST:\n\t\t{\n\t\t\tchar buf[128];\n\t\t\tmISDN_write_frame(stack->midev, buf, bc->addr | FLG_MSG_TARGET | FLG_MSG_DOWN,  DL_ESTABLISH | CONFIRM, 0,0, NULL, TIMEOUT_1SEC);\n\t\t}\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase DL_RELEASE|REQUEST:\n\t\t{\n\t\t\tchar buf[128];\n\t\t\tmISDN_write_frame(stack->midev, buf, bc->addr | FLG_MSG_TARGET | FLG_MSG_DOWN,  DL_RELEASE| CONFIRM, 0,0, NULL, TIMEOUT_1SEC);\n\t\t}\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase PH_DEACTIVATE | INDICATION:\n\tcase DL_RELEASE | INDICATION:\n\t\tcb_log (3, stack->port, \"BCHAN: DeACT Ind pid:%d\\n\",bc->pid);\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase PH_DEACTIVATE | CONFIRM:\n\tcase DL_RELEASE | CONFIRM:\n\t\tcb_log(3, stack->port, \"BCHAN: DeACT Conf pid:%d\\n\",bc->pid);\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase PH_CONTROL|INDICATION:\n\t{\n\t\tunsigned int *cont = (unsigned int *) &frm->data.p;\n\t\tcb_log(4, stack->port,\n\t\t\t\"PH_CONTROL: channel:%d caller%d:\\\"%s\\\" <%s> dialed%d:%s \\n\",\n\t\t\tbc->channel,\n\t\t\tbc->caller.number_type,\n\t\t\tbc->caller.name,\n\t\t\tbc->caller.number,\n\t\t\tbc->dialed.number_type,\n\t\t\tbc->dialed.number);\n\t\tif ((*cont & ~DTMF_TONE_MASK) == DTMF_TONE_VAL) {\n\t\t\tint dtmf = *cont & DTMF_TONE_MASK;\n\t\t\tcb_log(4, stack->port, \" --> DTMF TONE: %c\\n\",dtmf);\n\t\t\tbc->dtmf=dtmf;\n\t\t\tcb_event(EVENT_DTMF_TONE, bc, glob_mgr->user_data);\n\t\t\tfree_msg(msg);\n\t\t\treturn 1;\n\t\t}\n\t\tif (*cont == BF_REJECT) {\n\t\t\tcb_log(4, stack->port, \" --> BF REJECT\\n\");\n\t\t\tfree_msg(msg);\n\t\t\treturn 1;\n\t\t}\n\t\tif (*cont == BF_ACCEPT) {\n\t\t\tcb_log(4, stack->port, \" --> BF ACCEPT\\n\");\n\t\t\tfree_msg(msg);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tbreak;\n\tcase PH_DATA|REQUEST:\n\tcase DL_DATA|REQUEST:\n\t\tcb_log(0, stack->port, \"DL_DATA REQUEST \\n\");\n\t\tdo_tone(bc, 64);\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase PH_DATA|INDICATION:\n\tcase DL_DATA|INDICATION:\n\t{\n\t\tbc->bframe = (void*)&frm->data.i;\n\t\tbc->bframe_len = frm->len;\n\t\t\n\t\tif ( misdn_cap_is_speech(bc->capability) )\n\t\t\tflip_buf_bits(bc->bframe, bc->bframe_len);\n\t\tif (!bc->bframe_len) {\n\t\t\tcb_log(2, stack->port, \"DL_DATA INDICATION bc->addr:%x frm->addr:%x\\n\", bc->addr, frm->addr);\n\t\t\tfree_msg(msg);\n\t\t\treturn 1;\n\t\t}\n\t\tif ( (bc->addr&STACK_ID_MASK) != (frm->addr&STACK_ID_MASK) ) {\n\t\t\tcb_log(2, stack->port, \"DL_DATA INDICATION bc->addr:%x frm->addr:%x\\n\", bc->addr, frm->addr);\n\t\t\tfree_msg(msg);\n\t\t\treturn 1;\n\t\t}\n#if MISDN_DEBUG\n\t\tcb_log(0, stack->port, \"DL_DATA INDICATION Len %d\\n\", frm->len);\n#endif\n\t\tif ( (bc->bc_state == BCHAN_ACTIVATED) && frm->len > 0) {\n\t\t\tint t;\n#ifdef MISDN_B_DEBUG\n\t\t\tcb_log(0,bc->port,\"do_tone START\\n\");\n#endif\n\t\t\tt=do_tone(bc,frm->len);\n#ifdef MISDN_B_DEBUG\n\t\t\tcb_log(0,bc->port,\"do_tone STOP (%d)\\n\",t);\n#endif\n\t\t\tif (  !t ) {\n\t\t\t\tint i;\n\t\t\t\tif ( misdn_cap_is_speech(bc->capability)) {\n\t\t\t\t\tif ( !bc->nojitter ) {\n#ifdef MISDN_B_DEBUG\n\t\t\t\t\t\tcb_log(0,bc->port,\"tx_jitter START\\n\");\n#endif\n\t\t\t\t\t\tmisdn_tx_jitter(bc,frm->len);\n#ifdef MISDN_B_DEBUG\n\t\t\t\t\t\tcb_log(0,bc->port,\"tx_jitter STOP\\n\");\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef MISDN_B_DEBUG\n\t\t\t\tcb_log(0,bc->port,\"EVENT_B_DATA START\\n\");\n#endif\n\t\t\t\ti = cb_event(EVENT_BCHAN_DATA, bc, glob_mgr->user_data);\n#ifdef MISDN_B_DEBUG\n\t\t\t\tcb_log(0,bc->port,\"EVENT_B_DATA STOP\\n\");\n#endif\n\t\t\t\tif (i<0) {\n\t\t\t\t\tcb_log(10,stack->port,\"cb_event returned <0\\n\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree_msg(msg);\n\t\treturn 1;\n\t}\n\tcase PH_CONTROL | CONFIRM:\n\t\tcb_log(4, stack->port, \"PH_CONTROL|CNF bc->addr:%x\\n\", frm->addr);\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase PH_DATA | CONFIRM:\n\tcase DL_DATA|CONFIRM:\n#if MISDN_DEBUG\n\t\tcb_log(0, stack->port, \"Data confirmed\\n\");\n#endif\n\t\tfree_msg(msg);\n\t\treturn 1;\n\tcase DL_DATA|RESPONSE:\n#if MISDN_DEBUG\n\t\tcb_log(0, stack->port, \"Data response\\n\");\n#endif\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1504}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_list(struct ast_json *json, int (*fn)(struct ast_json *))\n{\n\tint res = 1;\n\tsize_t i;\n\tif (!check_type(json, AST_JSON_ARRAY)) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < ast_json_array_size(json); ++i) {\n\t\tint member_res;\n\t\tmember_res = fn(ast_json_array_get(json, i));\n\t\tif (!member_res) {\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"Array member %zu failed validation\\n\", i);\n\t\t\tres = 0;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1505}
{"project": "Asterisk", "target": 0, "func": "static void sig_ss7_set_inservice(struct sig_ss7_chan *p, int is_inservice)\n{\n\tp->inservice = is_inservice;\n\tif (sig_ss7_callbacks.set_inservice) {\n\t\tsig_ss7_callbacks.set_inservice(p->chan_pvt, is_inservice);\n\t}\n}\n", "bug_type": null, "idx": 1506}
{"project": "Asterisk", "target": 0, "func": "\nstatic int lintog726aal2_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tstruct g726_coder_pvt *tmp = pvt->pvt;\n\tint16_t *src = f->data.ptr;\n\tunsigned int i;\n\tfor (i = 0; i < f->samples; i++) {\n\t\tunsigned char d = g726_encode(src[i], &tmp->g726); \n\t\tif (tmp->next_flag & 0x80) {\t\n\t\t\tpvt->outbuf.c[pvt->datalen++] = ((tmp->next_flag & 0xf)<< 4) | d;\n\t\t\tpvt->samples += 2;\t\n\t\t\ttmp->next_flag = 0;\n\t\t} else {\n\t\t\ttmp->next_flag = 0x80 | d;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1507}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int sip_transport_is_available(enum pjsip_transport_type_e transport)\n{\n\tenum sip_resolver_transport resolver_transport;\n\tif (transport == PJSIP_TRANSPORT_UDP) {\n\t\tresolver_transport = SIP_RESOLVER_TRANSPORT_UDP;\n\t} else if (transport == PJSIP_TRANSPORT_TCP) {\n\t\tresolver_transport = SIP_RESOLVER_TRANSPORT_TCP;\n\t} else if (transport == PJSIP_TRANSPORT_TLS) {\n\t\tresolver_transport = SIP_RESOLVER_TRANSPORT_TLS;\n\t} else if (transport == PJSIP_TRANSPORT_UDP6) {\n\t\tresolver_transport = SIP_RESOLVER_TRANSPORT_UDP6;\n\t} else if (transport == PJSIP_TRANSPORT_TCP6) {\n\t\tresolver_transport = SIP_RESOLVER_TRANSPORT_TCP6;\n\t} else if (transport == PJSIP_TRANSPORT_TLS6) {\n\t\tresolver_transport = SIP_RESOLVER_TRANSPORT_TLS6;\n\t} else {\n\t\treturn 0;\n\t}\n\treturn sip_available_transports[resolver_transport];\n}\n", "bug_type": null, "idx": 1508}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int buf_hash(const char *pos, size_t len)\n{\n\treturn buf_hash_add(pos, len, 5381);\n}\n", "bug_type": null, "idx": 1509}
{"project": "Asterisk", "target": 0, "func": "END_OPTIONS );\nstatic int hint_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tchar *exten, *context;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(exten);\n\t\tAST_APP_ARG(options);\n\t);\n\tstruct ast_flags opts = { 0, };\n\tint res;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"The HINT function requires an extension\\n\");\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.exten)) {\n\t\tast_log(LOG_WARNING, \"The HINT function requires an extension\\n\");\n\t\treturn -1;\n\t}\n\tcontext = exten = args.exten;\n\tstrsep(&context, \"@\");\n\tif (ast_strlen_zero(context))\n\t\tcontext = \"default\";\n\tif (!ast_strlen_zero(args.options))\n\t\tast_app_parse_options(hint_options, &opts, NULL, args.options);\n\tif (ast_test_flag(&opts, HINT_OPT_NAME))\n\t\tres = ast_get_hint(NULL, 0, buf, len, chan, context, exten);\n\telse\n\t\tres = ast_get_hint(buf, len, NULL, 0, chan, context, exten);\n\treturn !res; \n}\n", "bug_type": null, "idx": 1510}
{"project": "Asterisk", "target": 0, "func": "static int waitfor_exec(struct ast_channel *chan, const char *data, const struct wait_type *wait_for)\n{\n\tint res = 1;\n\tint timereqd = 1000;\n\tint timeout = 0;\n\tint iterations = 1, i;\n\ttime_t waitstart;\n\tchar *parse;\n\tstruct ast_silence_generator *silgen = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(timereqd);\n\t\tAST_APP_ARG(iterations);\n\t\tAST_APP_ARG(timeout);\n\t);\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (!ast_strlen_zero(args.timereqd)) {\n\t\tif (sscanf(args.timereqd, \"%30d\", &timereqd) != 1 || timereqd < 0) {\n\t\t\tast_log(LOG_ERROR, \"Argument '%srequired' must be an integer greater than or equal to zero.\\n\",\n\t\t\t\t\twait_for->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!ast_strlen_zero(args.iterations)) {\n\t\tif (sscanf(args.iterations, \"%30d\", &iterations) != 1 || iterations < 1) {\n\t\t\tast_log(LOG_ERROR, \"Argument 'iterations' must be an integer greater than 0.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!ast_strlen_zero(args.timeout)) {\n\t\tif (sscanf(args.timeout, \"%30d\", &timeout) != 1 || timeout < 0) {\n\t\t\tast_log(LOG_ERROR, \"Argument 'timeout' must be an integer greater than or equal to zero.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\tast_answer(chan); \n\t}\n\tast_verb(3, \"Waiting %d time(s) for %dms of %s with %ds timeout\\n\",\n\t\t\t iterations, timereqd, wait_for->name, timeout);\n\tif (ast_opt_transmit_silence) {\n\t\tsilgen = ast_channel_start_silence_generator(chan);\n\t}\n\ttime(&waitstart);\n\tfor (i = 0; i < iterations && res == 1; i++) {\n\t\tres = do_waiting(chan, timereqd, waitstart, timeout, wait_for);\n\t}\n\tif (silgen) {\n\t\tast_channel_stop_silence_generator(chan, silgen);\n\t}\n\treturn res > 0 ? 0 : res;\n}\n", "bug_type": null, "idx": 1511}
{"project": "Asterisk", "target": 0, "func": "int __ast_format_cap_append(struct ast_format_cap *cap, struct ast_format *format, unsigned int framing, const char *tag, const char *file, int line, const char *func)\n{\n\tstruct format_cap_framed *framed;\n\tast_assert(format != NULL);\n\tif (format_in_format_cap(cap, format)) {\n\t\treturn 0;\n\t}\n\tframed = ao2_alloc_options(sizeof(*framed), format_cap_framed_destroy, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!framed) {\n\t\treturn -1;\n\t}\n\t__ao2_ref(format, +1, tag, file, line, func);\n\tframed->format = format;\n\treturn format_cap_framed_init(framed, cap, format, framing);\n}\n", "bug_type": null, "idx": 1512}
{"project": "Asterisk", "target": 0, "func": "\nstatic void normalise_history(plc_state_t *s)\n{\n\tint16_t tmp[PLC_HISTORY_LEN];\n\tif (s->buf_ptr == 0)\n\t\treturn;\n\tmemcpy(tmp, s->history, sizeof(int16_t)*s->buf_ptr);\n\tmemcpy(s->history, s->history + s->buf_ptr, sizeof(int16_t) * (PLC_HISTORY_LEN - s->buf_ptr));\n\tmemcpy(s->history + PLC_HISTORY_LEN - s->buf_ptr, tmp, sizeof(int16_t) * s->buf_ptr);\n\ts->buf_ptr = 0;\n}\n", "bug_type": null, "idx": 1513}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_custom_function_register_escalating(&shell_function, AST_CFE_READ);\n}\n", "bug_type": null, "idx": 1514}
{"project": "Asterisk", "target": 0, "func": "static void dahdi_r2_on_os_error(openr2_chan_t *r2chan, int errorcode)\n{\n\tast_log(LOG_ERROR, \"OS error on chan %d: %s\\n\", openr2_chan_get_number(r2chan), strerror(errorcode));\n}\n", "bug_type": null, "idx": 1515}
{"project": "Asterisk", "target": 0, "func": "\nstatic void agi_destroy_commands_cb(void *data)\n{\n\tstruct agi_cmd *cmd;\n\tAST_LIST_HEAD(, agi_cmd) *chan_cmds = data;\n\tAST_LIST_LOCK(chan_cmds);\n\twhile ( (cmd = AST_LIST_REMOVE_HEAD(chan_cmds, entry)) ) {\n\t\tfree_agi_cmd(cmd);\n\t}\n\tAST_LIST_UNLOCK(chan_cmds);\n\tAST_LIST_HEAD_DESTROY(chan_cmds);\n\tast_free(chan_cmds);\n}\n", "bug_type": null, "idx": 1516}
{"project": "Asterisk", "target": 0, "func": "static struct ast_format *dahdi_format_to_cached(int format)\n{\n\tswitch (format) {\n\tcase DAHDI_FORMAT_G723_1:\n\t\treturn ast_format_g723;\n\tcase DAHDI_FORMAT_GSM:\n\t\treturn ast_format_gsm;\n\tcase DAHDI_FORMAT_ULAW:\n\t\treturn ast_format_ulaw;\n\tcase DAHDI_FORMAT_ALAW:\n\t\treturn ast_format_alaw;\n\tcase DAHDI_FORMAT_G726:\n\t\treturn ast_format_g726;\n\tcase DAHDI_FORMAT_ADPCM:\n\t\treturn ast_format_adpcm;\n\tcase DAHDI_FORMAT_SLINEAR:\n\t\treturn ast_format_slin;\n\tcase DAHDI_FORMAT_LPC10:\n\t\treturn ast_format_lpc10;\n\tcase DAHDI_FORMAT_G729A:\n\t\treturn ast_format_g729;\n\tcase DAHDI_FORMAT_SPEEX:\n\t\treturn ast_format_speex;\n\tcase DAHDI_FORMAT_ILBC:\n\t\treturn ast_format_ilbc;\n\t}\n\t\n\tast_assert(0);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1517}
{"project": "Asterisk", "target": 0, "func": "static int misdn_tasks_add_variable(int timeout, ast_sched_cb callback, const void *data)\n{\n\treturn _misdn_tasks_add_variable(timeout, callback, data, 1);\n}\n", "bug_type": null, "idx": 1518}
{"project": "Asterisk", "target": 0, "func": "void create_binaural_frame(struct ast_bridge_channel *bridge_channel,\n\t\tstruct softmix_channel *sc, int16_t *bin_buf, int16_t *ann_buf,\n\t\tunsigned int softmix_datalen, unsigned int softmix_samples, int16_t *buf)\n{\n\tunsigned int i;\n\tsc->write_frame.datalen = softmix_datalen * 2;\n\tsc->write_frame.samples = softmix_samples * 2;\n\tif (!bridge_channel->binaural_suspended) {\n\t\tsc->binaural_suspended = 0;\n\t\tif (sc->is_announcement) {\n\t\t\tmemcpy(sc->final_buf, ann_buf, softmix_datalen * 2);\n\t\t} else {\n\t\t\tmemcpy(sc->final_buf, bin_buf, softmix_datalen * 2);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tsc->binaural_suspended = 1;\n\tfor (i = 0; i < softmix_samples; i++) {\n\t\tsc->final_buf[i * 2] = buf[i];\n\t\tsc->final_buf[(i * 2) + 1] = buf[i];\n\t}\n}\n", "bug_type": null, "idx": 1519}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct hash_bucket_node *hash_ao2_iterator_next(struct ao2_container_hash *self, struct hash_bucket_node *node, enum ao2_iterator_flags flags)\n{\n\tint cur_bucket;\n\tif (flags & AO2_ITERATOR_DESCENDING) {\n\t\tif (node) {\n\t\t\tcur_bucket = node->my_bucket;\n\t\t\t\n\t\t\tfor (;;) {\n\t\t\t\tnode = AST_DLLIST_PREV(node, links);\n\t\t\t\tif (!node) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (node->common.obj) {\n\t\t\t\t\t\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tcur_bucket = self->n_buckets;\n\t\t}\n\t\t\n\t\twhile (0 <= --cur_bucket) {\n\t\t\tnode = AST_DLLIST_LAST(&self->buckets[cur_bucket].list);\n\t\t\twhile (node) {\n\t\t\t\tif (node->common.obj) {\n\t\t\t\t\t\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\tnode = AST_DLLIST_PREV(node, links);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (node) {\n\t\t\tcur_bucket = node->my_bucket;\n\t\t\t\n\t\t\tfor (;;) {\n\t\t\t\tnode = AST_DLLIST_NEXT(node, links);\n\t\t\t\tif (!node) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (node->common.obj) {\n\t\t\t\t\t\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tcur_bucket = -1;\n\t\t}\n\t\t\n\t\twhile (++cur_bucket < self->n_buckets) {\n\t\t\tnode = AST_DLLIST_FIRST(&self->buckets[cur_bucket].list);\n\t\t\twhile (node) {\n\t\t\t\tif (node->common.obj) {\n\t\t\t\t\t\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\tnode = AST_DLLIST_NEXT(node, links);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1520}
{"project": "Asterisk", "target": 0, "func": "OOStkCmdStat ooSetANI(const char *callToken, const char* ani)\n{\n   OOStackCommand cmd;\n   OOH323CallData *call;\n   if(!callToken)\n   {\n      return OO_STKCMD_INVALIDPARAM;\n   }\n   if(!(call = ooFindCallByToken(callToken))) {\n      return OO_STKCMD_INVALIDPARAM;\n   }\n   if(call->CmdChan == 0)\n   {\n      if(ooCreateCallCmdConnection(call) != OO_OK)\n         return OO_STKCMD_CONNECTIONERR;\n   }\n   memset(&cmd, 0, sizeof(OOStackCommand));\n   cmd.type = OO_CMD_SETANI;\n   cmd.param1 = ast_malloc(strlen(callToken)+1);\n   cmd.param2 = ast_malloc(strlen(ani)+1);\n   if(!cmd.param1 || !cmd.param2)\n   {\n      if(cmd.param1)   ast_free(cmd.param1); \n      if(cmd.param2)   ast_free(cmd.param2);\n      return OO_STKCMD_MEMERR;\n   }\n   strcpy((char*)cmd.param1, callToken);\n   cmd.plen1 = strlen(callToken);\n   strcpy((char*)cmd.param2, ani);\n   cmd.plen2 = strlen(ani);\n   if(ooWriteCallStackCommand(call,&cmd) != OO_OK)\n   {\n      ast_free(cmd.param1);\n      ast_free(cmd.param2);\n      return OO_STKCMD_WRITEERR;\n   }\n   ast_free(cmd.param1);\n   ast_free(cmd.param2);\n   return OO_STKCMD_SUCCESS;\n}\n", "bug_type": null, "idx": 1521}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int pthread_timer_cmp(void *obj, void *arg, int flags)\n{\n\tstruct pthread_timer *timer1 = obj, *timer2 = arg;\n\treturn (timer1->pipe[PIPE_READ] == timer2->pipe[PIPE_READ]) ? CMP_MATCH | CMP_STOP : 0;\n}\n", "bug_type": null, "idx": 1522}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245ResponseMessage (OOCTXT* pctxt, H245ResponseMessage* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 19);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 18);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245MasterSlaveDeterminationAck (pctxt, pvalue->u.masterSlaveDeterminationAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245MasterSlaveDeterminationReject (pctxt, pvalue->u.masterSlaveDeterminationReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = asn1PE_H245TerminalCapabilitySetAck (pctxt, pvalue->u.terminalCapabilitySetAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 5:\n            stat = asn1PE_H245TerminalCapabilitySetReject (pctxt, pvalue->u.terminalCapabilitySetReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 6:\n            stat = asn1PE_H245OpenLogicalChannelAck (pctxt, pvalue->u.openLogicalChannelAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 7:\n            stat = asn1PE_H245OpenLogicalChannelReject (pctxt, pvalue->u.openLogicalChannelReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 8:\n            stat = asn1PE_H245CloseLogicalChannelAck (pctxt, pvalue->u.closeLogicalChannelAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 9:\n            stat = asn1PE_H245RequestChannelCloseAck (pctxt, pvalue->u.requestChannelCloseAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 10:\n            stat = asn1PE_H245RequestChannelCloseReject (pctxt, pvalue->u.requestChannelCloseReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 11:\n            stat = asn1PE_H245MultiplexEntrySendAck (pctxt, pvalue->u.multiplexEntrySendAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 12:\n            stat = asn1PE_H245MultiplexEntrySendReject (pctxt, pvalue->u.multiplexEntrySendReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 13:\n            stat = asn1PE_H245RequestMultiplexEntryAck (pctxt, pvalue->u.requestMultiplexEntryAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 14:\n            stat = asn1PE_H245RequestMultiplexEntryReject (pctxt, pvalue->u.requestMultiplexEntryReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 15:\n            stat = asn1PE_H245RequestModeAck (pctxt, pvalue->u.requestModeAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 16:\n            stat = asn1PE_H245RequestModeReject (pctxt, pvalue->u.requestModeReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 17:\n            stat = asn1PE_H245RoundTripDelayResponse (pctxt, pvalue->u.roundTripDelayResponse);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 18:\n            stat = asn1PE_H245MaintenanceLoopAck (pctxt, pvalue->u.maintenanceLoopAck);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 19:\n            stat = asn1PE_H245MaintenanceLoopReject (pctxt, pvalue->u.maintenanceLoopReject);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 20);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 20:\n            stat = asn1PE_H245CommunicationModeResponse (&lctxt, pvalue->u.communicationModeResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 21:\n            stat = asn1PE_H245ConferenceResponse (&lctxt, pvalue->u.conferenceResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 22:\n            stat = asn1PE_H245MultilinkResponse (&lctxt, pvalue->u.multilinkResponse);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 23:\n            stat = asn1PE_H245LogicalChannelRateAcknowledge (&lctxt, pvalue->u.logicalChannelRateAcknowledge);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 24:\n            stat = asn1PE_H245LogicalChannelRateReject (&lctxt, pvalue->u.logicalChannelRateReject);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1523}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245UnicastAddress_netBios (OOCTXT* pctxt, H245UnicastAddress_netBios* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeOctetString (pctxt,\n                          &pvalue->numocts,\n                          pvalue->data,\n                          sizeof(pvalue->data));\n   if (stat != ASN_OK) return stat;\n   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);\n   return (stat);\n}\n", "bug_type": null, "idx": 1524}
{"project": "Asterisk", "target": 0, "func": " */\nvoid misdn_cfg_get_ports_string (char *ports)\n{\n\tchar tmp[16];\n\tint l, i;\n\tint gn = map[MISDN_CFG_GROUPNAME];\n\t*ports = 0;\n\tmisdn_cfg_lock();\n\tfor (i = 1; i <= max_ports; i++) {\n\t\tif (port_cfg[i][gn].str) {\n\t\t\tif (ptp[i])\n\t\t\t\tsprintf(tmp, \"%dptp,\", i);\n\t\t\telse\n\t\t\t\tsprintf(tmp, \"%d,\", i);\n\t\t\tstrcat(ports, tmp);\n\t\t}\n\t}\n\tmisdn_cfg_unlock();\n\tif ((l = strlen(ports))) {\n\t\t\n\t\tports[l-1] = 0;\n\t}\n}\n", "bug_type": null, "idx": 1525}
{"project": "Asterisk", "target": 0, "func": "static void aor_deleted_observer(const void *object)\n{\n\tconst struct ast_sip_aor *aor = object;\n\tconst char *aor_id = ast_sorcery_object_get_id(object);\n\t\n\tchar regex[strlen(aor_id) + 4];\n\tstruct ao2_container *contacts;\n\tif (aor->permanent_contacts) {\n\t\tao2_callback(aor->permanent_contacts, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK, destroy_contact, NULL);\n\t}\n\tsnprintf(regex, sizeof(regex), \"^%s;@\", aor_id);\n\tif (!(contacts = ast_sorcery_retrieve_by_regex(ast_sip_get_sorcery(), \"contact\", regex))) {\n\t\treturn;\n\t}\n\t\n\tao2_callback(contacts, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK, destroy_contact, NULL);\n\tao2_ref(contacts, -1);\n}\n", "bug_type": null, "idx": 1526}
{"project": "Asterisk", "target": 0, "func": "void softmix_process_write_binaural_audio(struct softmix_channel *sc,\n\t\tunsigned int default_sample_size)\n{\n\tunsigned int i;\n\tif (sc->write_frame.samples % default_sample_size != 0) {\n\t\treturn;\n\t}\n\t\n\tif (sc->binaural_suspended) {\n\t\tfor (i = 0; i < default_sample_size; i++) {\n\t\t\tast_slinear_saturated_subtract(&sc->final_buf[i * 2], &sc->our_buf[i]);\n\t\t\tast_slinear_saturated_subtract(&sc->final_buf[(i * 2) + 1], &sc->our_buf[i]);\n\t\t}\n\t\treturn;\n\t}\n  \n\tfor (i = 0; i < default_sample_size; i++) {\n\t\tast_slinear_saturated_subtract(&sc->final_buf[i * 2],\n\t\t\t\t&sc->our_chan_pair->chan_left.out_data[i]);\n\t\tast_slinear_saturated_subtract(&sc->final_buf[(i * 2) + 1],\n\t\t\t\t&sc->our_chan_pair->chan_right.out_data[i]);\n\t}\n}\n", "bug_type": null, "idx": 1527}
{"project": "Asterisk", "target": 0, "func": "static void destroy_callback(void *data)\n{\n\tif (data) {\n\t\tao2_ref(data, -1);\n\t}\n}\n", "bug_type": null, "idx": 1528}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_bridges_play_parse_body(\n\tstruct ast_json *body,\n\tstruct ast_ari_bridges_play_args *args)\n{\n\tstruct ast_json *field;\n\t\n\tfield = ast_json_object_get(body, \"media\");\n\tif (field) {\n\t\t\n\t\tast_free(args->media);\n\t\tif (ast_json_typeof(field) == AST_JSON_ARRAY) {\n\t\t\t\n\t\t\tsize_t i;\n\t\t\targs->media_count = ast_json_array_size(field);\n\t\t\targs->media = ast_malloc(sizeof(*args->media) * args->media_count);\n\t\t\tif (!args->media) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < args->media_count; ++i) {\n\t\t\t\targs->media[i] = ast_json_string_get(ast_json_array_get(field, i));\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\targs->media_count = 1;\n\t\t\targs->media = ast_malloc(sizeof(*args->media) * args->media_count);\n\t\t\tif (!args->media) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\targs->media[0] = ast_json_string_get(field);\n\t\t}\n\t}\n\tfield = ast_json_object_get(body, \"lang\");\n\tif (field) {\n\t\targs->lang = ast_json_string_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"offsetms\");\n\tif (field) {\n\t\targs->offsetms = ast_json_integer_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"skipms\");\n\tif (field) {\n\t\targs->skipms = ast_json_integer_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"playbackId\");\n\tif (field) {\n\t\targs->playback_id = ast_json_string_get(field);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1529}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_set_tpselector_from_transport(const struct ast_sip_transport *transport, pjsip_tpselector *selector)\n{\n\tRAII_VAR(struct ast_sip_transport_state *, transport_state, NULL, ao2_cleanup);\n\ttransport_state = ast_sip_get_transport_state(ast_sorcery_object_get_id(transport));\n\tif (!transport_state) {\n\t\tast_log(LOG_ERROR, \"Unable to retrieve PJSIP transport state for '%s'\\n\",\n\t\t\tast_sorcery_object_get_id(transport));\n\t\treturn -1;\n\t}\n\tif (transport_state->transport) {\n\t\tselector->type = PJSIP_TPSELECTOR_TRANSPORT;\n\t\tselector->u.transport = transport_state->transport;\n\t} else if (transport_state->factory) {\n\t\tselector->type = PJSIP_TPSELECTOR_LISTENER;\n\t\tselector->u.listener = transport_state->factory;\n\t} else if (transport->type == AST_TRANSPORT_WS || transport->type == AST_TRANSPORT_WSS) {\n\t\t\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1530}
{"project": "Asterisk", "target": 0, "func": "static int pidf_generate_body_content(void *body, void *data)\n{\n\tpjpidf_tuple *tuple;\n\tpj_str_t note, id, contact, priority;\n\tchar *statestring = NULL, *pidfstate = NULL, *pidfnote = NULL;\n\tenum ast_sip_pidf_state local_state;\n\tchar sanitized[PJSIP_MAX_URL_SIZE];\n\tpjpidf_pres *pres = body;\n\tstruct ast_sip_exten_state_data *state_data = data;\n\tast_sip_presence_exten_state_to_str(state_data->exten_state, &statestring,\n\t\t\t&pidfstate, &pidfnote, &local_state, 0);\n\tif (!pjpidf_pres_add_note(state_data->pool, pres, pj_cstr(&note, pidfnote))) {\n\t\tast_log(LOG_WARNING, \"Unable to add note to PIDF presence\\n\");\n\t\treturn -1;\n\t}\n\tif (!(tuple = pjpidf_pres_add_tuple(state_data->pool, pres,\n\t\t\t\t\tpj_cstr(&id, state_data->exten)))) {\n\t\tast_log(LOG_WARNING, \"Unable to create PIDF tuple\\n\");\n\t\treturn -1;\n\t}\n\tast_sip_sanitize_xml(state_data->remote, sanitized, sizeof(sanitized));\n\tpjpidf_tuple_set_contact(state_data->pool, tuple, pj_cstr(&contact, sanitized));\n\tpjpidf_tuple_set_contact_prio(state_data->pool, tuple, pj_cstr(&priority, \"1\"));\n\tpjpidf_status_set_basic_open(pjpidf_tuple_get_status(tuple),\n\t\t\tlocal_state == NOTIFY_OPEN || local_state == NOTIFY_INUSE);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1531}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void sig_pri_queue_hangup(struct sig_pri_span *pri, int chanpos)\n{\n\tif (sig_pri_callbacks.queue_control) {\n\t\tsig_pri_callbacks.queue_control(pri->pvts[chanpos]->chan_pvt, AST_CONTROL_HANGUP);\n\t}\n\tsig_pri_lock_owner(pri, chanpos);\n\tif (pri->pvts[chanpos]->owner) {\n\t\tast_queue_hangup(pri->pvts[chanpos]->owner);\n\t\tast_channel_unlock(pri->pvts[chanpos]->owner);\n\t}\n}\n", "bug_type": null, "idx": 1532}
{"project": "Asterisk", "target": 0, "func": "struct stasis_app_control *stasis_app_control_create(struct ast_channel *chan)\n{\n\treturn control_create(chan, NULL);\n}\n", "bug_type": null, "idx": 1533}
{"project": "Asterisk", "target": 0, "func": "static void set_ecm(t30_state_t *state, int ecm)\n{\n\tt30_set_ecm_capability(state, ecm);\n\tt30_set_supported_compressions(state, T30_SUPPORT_T4_1D_COMPRESSION | T30_SUPPORT_T4_2D_COMPRESSION | T30_SUPPORT_T6_COMPRESSION);\n}\n", "bug_type": null, "idx": 1534}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_smdi_md_message_push(struct ast_smdi_interface *iface, struct ast_smdi_md_message *md_msg)\n{\n\tast_mutex_lock(&iface->md_q_lock);\n\tao2_link(iface->md_q, md_msg);\n\tast_cond_broadcast(&iface->md_q_cond);\n\tast_mutex_unlock(&iface->md_q_lock);\n}\n", "bug_type": null, "idx": 1535}
{"project": "Asterisk", "target": 0, "func": "static int mock_channel_indicate(struct ast_channel *chan, int condition, const void *data, size_t datalen)\n{\n\tstruct mock_channel_pvt *pvt = ast_channel_tech_pvt(chan);\n\tif (condition == AST_CONTROL_STREAM_TOPOLOGY_REQUEST_CHANGE) {\n\t\tpvt->indicated_change_request = 1;\n\t} else if (condition == AST_CONTROL_STREAM_TOPOLOGY_CHANGED) {\n\t\tpvt->indicated_changed = 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1536}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int extension_match_core(const char *pattern, const char *data, enum ext_match_t mode)\n{\n\tint i;\n\tstatic int prof_id = -2;\t\n\tif (prof_id == -2) {\n\t\tprof_id = ast_add_profile(\"ext_match\", 0);\n\t}\n\tast_mark(prof_id, 1);\n\ti = _extension_match_core(ast_strlen_zero(pattern) ? \"\" : pattern, ast_strlen_zero(data) ? \"\" : data, mode);\n\tast_mark(prof_id, 0);\n\treturn i;\n}\n", "bug_type": null, "idx": 1537}
{"project": "Asterisk", "target": 0, "func": "static int reload_module(void)\n{\n\tast_phoneprov_provider_unregister(AST_MODULE);\n\tif (ast_phoneprov_provider_register(AST_MODULE, load_users)) {\n\t\tast_log(LOG_ERROR, \"Unable to register pjsip phoneprov provider.\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1538}
{"project": "Asterisk", "target": 0, "func": "int ast_heap_verify(struct ast_heap *h)\n{\n\tunsigned int i;\n\tfor (i = 1; i <= (h->cur_len / 2); i++) {\n\t\tint l = left_node(i);\n\t\tint r = right_node(i);\n\t\tif (l <= h->cur_len) {\n\t\t\tif (h->cmp_fn(heap_get(h, i), heap_get(h, l)) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (r <= h->cur_len) {\n\t\t\tif (h->cmp_fn(heap_get(h, i), heap_get(h, r)) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1539}
{"project": "Asterisk", "target": 0, "func": "protected void\nre_putc(EditLine *el, int c, int shift)\n{\n\tELRE_DEBUG(1, (__F, \"printing %3.3o '%c'\\r\\n\", c, c));\n\tel->el_vdisplay[el->el_refresh.r_cursor.v][el->el_refresh.r_cursor.h] = c;\n\tif (!shift)\n\t\treturn;\n\tel->el_refresh.r_cursor.h++;\t\n\tif (el->el_refresh.r_cursor.h >= el->el_term.t_size.h) {\n\t\tel->el_vdisplay[el->el_refresh.r_cursor.v][el->el_term.t_size.h] = '\\0';\n\t\t\n\t\tel->el_refresh.r_cursor.h = 0;\t\n\t\t\n\t\tif (el->el_refresh.r_cursor.v + 1 >= el->el_term.t_size.v) {\n\t\t\tint i, lins = el->el_term.t_size.v;\n\t\t\tchar *firstline = el->el_vdisplay[0];\n\t\t\tfor(i=1; i < lins; i++)\n\t\t\t\tel->el_vdisplay[i-1] = el->el_vdisplay[i];\n\t\t\tfirstline[0] = '\\0';\t\t\t\n\t\t\tel->el_vdisplay[i-1] = firstline;\n\t\t} else\n\t\t\tel->el_refresh.r_cursor.v++;\n\t\tELRE_ASSERT(el->el_refresh.r_cursor.v >= el->el_term.t_size.v,\n\t\t    (__F, \"\\r\\nre_putc: overflow! r_cursor.v == %d > %d\\r\\n\",\n\t\t    el->el_refresh.r_cursor.v, el->el_term.t_size.v),\n\t\t    abort());\n\t}\n}\n", "bug_type": null, "idx": 1540}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_cel_backend_unregister(RADIUS_BACKEND_NAME);\n\tif (rh) {\n\t\trc_destroy(rh);\n\t\trh = NULL;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1541}
{"project": "Asterisk", "target": 0, "func": "\nstatic int encoding_format_handler(const struct aco_option *opt,\n\tstruct ast_variable *var, void *obj)\n{\n\tstruct ast_ari_conf_general *general = obj;\n\tif (!strcasecmp(var->name, \"pretty\")) {\n\t\tgeneral->format = ast_true(var->value) ?\n\t\t\tAST_JSON_PRETTY : AST_JSON_COMPACT;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1542}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_register_application_xml(app, transfer_exec);\n}\n", "bug_type": null, "idx": 1543}
{"project": "Asterisk", "target": 0, "func": "static struct pjmedia_sdp_session *create_local_sdp(pjsip_inv_session *inv, struct ast_sip_session *session, const pjmedia_sdp_session *offer)\n{\n\tstatic const pj_str_t STR_IN = { \"IN\", 2 };\n\tstatic const pj_str_t STR_IP4 = { \"IP4\", 3 };\n\tstatic const pj_str_t STR_IP6 = { \"IP6\", 3 };\n\tpjmedia_sdp_session *local;\n\tint i;\n\tint stream;\n\tif (inv->state == PJSIP_INV_STATE_DISCONNECTED) {\n\t\tast_log(LOG_ERROR, \"Failed to create session SDP. Session has been already disconnected\\n\");\n\t\treturn NULL;\n\t}\n\tif (!inv->pool_prov || !(local = PJ_POOL_ZALLOC_T(inv->pool_prov, pjmedia_sdp_session))) {\n\t\treturn NULL;\n\t}\n\tif (!offer) {\n\t\tlocal->origin.version = local->origin.id = (pj_uint32_t)(ast_random());\n\t} else {\n\t\tlocal->origin.version = offer->origin.version + 1;\n\t\tlocal->origin.id = offer->origin.id;\n\t}\n\tpj_strdup2(inv->pool_prov, &local->origin.user, session->endpoint->media.sdpowner);\n\tpj_strdup2(inv->pool_prov, &local->name, session->endpoint->media.sdpsession);\n\tif (!session->pending_media_state->topology || !ast_stream_topology_get_count(session->pending_media_state->topology)) {\n\t\t\n\t\tast_stream_topology_free(session->pending_media_state->topology);\n\t\tsession->pending_media_state->topology = ast_stream_topology_clone(session->endpoint->media.topology);\n\t\tif (!session->pending_media_state->topology) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tfor (i = 0; i < ast_stream_topology_get_count(session->pending_media_state->topology); ++i) {\n\t\tstruct ast_sip_session_media *session_media;\n\t\tstruct ast_stream *stream;\n\t\tunsigned int streams = local->media_count;\n\t\t\n\t\tstream = ast_stream_topology_get_stream(session->pending_media_state->topology, i);\n\t\tsession_media = ast_sip_session_media_state_add(session, session->pending_media_state, ast_stream_get_type(stream), i);\n\t\tif (!session_media) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (add_sdp_streams(session_media, session, local, offer, stream)) {\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tif (streams != local->media_count) {\n\t\t\tpjmedia_sdp_media *media = local->media[streams];\n\t\t\tpj_str_t stmp;\n\t\t\tpjmedia_sdp_attr *attr;\n\t\t\t\n\t\t\tif (!ast_strlen_zero(session_media->mid)) {\n\t\t\t\tattr = pjmedia_sdp_attr_create(inv->pool_prov, \"mid\", pj_cstr(&stmp, session_media->mid));\n\t\t\t\tpjmedia_sdp_attr_add(&media->attr_count, media->attr, attr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (local->media_count == PJMEDIA_MAX_SDP_MEDIA) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (add_bundle_groups(session, inv->pool_prov, local)) {\n\t\treturn NULL;\n\t}\n\t\n\tfor (stream = 0; stream < local->media_count; stream++) {\n\t\tif (!local->media[stream]->conn) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (local->conn) {\n\t\t\tif (!pj_strcmp(&local->conn->net_type, &local->media[stream]->conn->net_type) &&\n\t\t\t\t!pj_strcmp(&local->conn->addr_type, &local->media[stream]->conn->addr_type) &&\n\t\t\t\t!pj_strcmp(&local->conn->addr, &local->media[stream]->conn->addr)) {\n\t\t\t\tlocal->media[stream]->conn = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tlocal->conn = local->media[stream]->conn;\n\t\tlocal->media[stream]->conn = NULL;\n\t\tcontinue;\n\t}\n\t\n\tif (!local->conn) {\n\t\tlocal->conn = pj_pool_zalloc(inv->pool_prov, sizeof(struct pjmedia_sdp_conn));\n\t\tlocal->conn->net_type = STR_IN;\n\t\tlocal->conn->addr_type = session->endpoint->media.rtp.ipv6 ? STR_IP6 : STR_IP4;\n\t\tif (!ast_strlen_zero(session->endpoint->media.address)) {\n\t\t\tpj_strdup2(inv->pool_prov, &local->conn->addr, session->endpoint->media.address);\n\t\t} else {\n\t\t\tpj_strdup2(inv->pool_prov, &local->conn->addr, ast_sip_get_host_ip_string(session->endpoint->media.rtp.ipv6 ? pj_AF_INET6() : pj_AF_INET()));\n\t\t}\n\t}\n\tpj_strassign(&local->origin.net_type, &local->conn->net_type);\n\tpj_strassign(&local->origin.addr_type, &local->conn->addr_type);\n\tpj_strassign(&local->origin.addr, &local->conn->addr);\n\treturn local;\n}\n", "bug_type": null, "idx": 1544}
{"project": "Asterisk", "target": 0, "func": "static int client_bitfield_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct ast_xmpp_client_config *cfg = obj;\n\tif (!strcasecmp(var->name, \"debug\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_DEBUG);\n\t} else if (!strcasecmp(var->name, \"type\")) {\n\t\tast_set2_flag(&cfg->flags, !strcasecmp(var->value, \"component\") ? 1 : 0, XMPP_COMPONENT);\n\t} else if (!strcasecmp(var->name, \"distribute_events\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_DISTRIBUTE_EVENTS);\n\t} else if (!strcasecmp(var->name, \"usetls\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_USETLS);\n\t} else if (!strcasecmp(var->name, \"usesasl\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_USESASL);\n\t} else if (!strcasecmp(var->name, \"forceoldssl\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_FORCESSL);\n\t} else if (!strcasecmp(var->name, \"keepalive\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_KEEPALIVE);\n\t} else if (!strcasecmp(var->name, \"autoprune\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_AUTOPRUNE);\n\t\tast_set2_flag(&cfg->mod_flags, 1, XMPP_AUTOPRUNE);\n\t} else if (!strcasecmp(var->name, \"autoregister\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_AUTOREGISTER);\n\t\tast_set2_flag(&cfg->mod_flags, 1, XMPP_AUTOREGISTER);\n\t} else if (!strcasecmp(var->name, \"auth_policy\")) {\n\t\tast_set2_flag(&cfg->flags, !strcasecmp(var->value, \"accept\") ? 1 : 0, XMPP_AUTOACCEPT);\n\t\tast_set2_flag(&cfg->mod_flags, 1, XMPP_AUTOACCEPT);\n\t} else if (!strcasecmp(var->name, \"sendtodialplan\")) {\n\t\tast_set2_flag(&cfg->flags, ast_true(var->value), XMPP_SEND_TO_DIALPLAN);\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1545}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int bridge_sort_cmp(const void *obj_left, const void *obj_right, int flags)\n{\n\tconst struct ast_bridge *bridge_left = obj_left;\n\tconst struct ast_bridge *bridge_right = obj_right;\n\tconst char *right_key = obj_right;\n\tint cmp;\n\tswitch (flags & (OBJ_POINTER | OBJ_KEY | OBJ_PARTIAL_KEY)) {\n\tdefault:\n\tcase OBJ_POINTER:\n\t\tright_key = bridge_right->uniqueid;\n\t\t\n\tcase OBJ_KEY:\n\t\tcmp = strcmp(bridge_left->uniqueid, right_key);\n\t\tbreak;\n\tcase OBJ_PARTIAL_KEY:\n\t\tcmp = strncmp(bridge_left->uniqueid, right_key, strlen(right_key));\n\t\tbreak;\n\t}\n\treturn cmp;\n}\n", "bug_type": null, "idx": 1546}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_hashtab_hash_int(const int x)\n{\n\treturn x;\n}\n", "bug_type": null, "idx": 1547}
{"project": "Asterisk", "target": 0, "func": "static void parse_disconnect (struct isdn_msg msgs[], msg_t *msg, struct misdn_bchannel *bc, int nt)\n{\n\tint HEADER_LEN = nt?mISDNUSER_HEAD_SIZE:mISDN_HEADER_LEN;\n\tDISCONNECT_t *disconnect = (DISCONNECT_t *) (msg->data + HEADER_LEN);\n\tint location;\n \tint cause;\n\tdec_ie_cause(disconnect->CAUSE, (Q931_info_t *)(disconnect), &location, &cause, nt,bc);\n\tif (cause>0) bc->cause=cause;\n\tdec_ie_facility(disconnect->FACILITY, (Q931_info_t *) disconnect, &bc->fac_in, nt, bc);\n\tdec_ie_progress(disconnect->PROGRESS, (Q931_info_t *)disconnect, &bc->progress_coding, &bc->progress_location, &bc->progress_indicator, nt, bc);\n#ifdef DEBUG\n\tprintf(\"Parsing DISCONNECT Msg\\n\");\n#endif\n}\n", "bug_type": null, "idx": 1548}
{"project": "Asterisk", "target": 0, "func": "static int agi_exec_full(struct ast_channel *chan, const char *data, int enhanced, int dead)\n{\n\tenum agi_result res;\n\tchar *buf;\n\tint fds[2], efd = -1, pid = -1;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(arg)[MAX_ARGS];\n\t);\n\tAGI agi;\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"AGI requires an argument (script)\\n\");\n\t\treturn -1;\n\t}\n\tif (dead)\n\t\tast_debug(3, \"Hungup channel detected, running agi in dead mode.\\n\");\n\tmemset(&agi, 0, sizeof(agi));\n\tbuf = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, buf);\n\targs.argv[args.argc] = NULL;\n#if 0\n\t \n\tif (chan->_state != AST_STATE_UP) {\n\t\tif (ast_answer(chan))\n\t\t\treturn -1;\n\t}\n#endif\n\tres = launch_script(chan, args.argv[0], args.argc, args.argv, fds, enhanced ? &efd : NULL, &pid);\n\t\n\tif (res == AGI_RESULT_SUCCESS || res == AGI_RESULT_SUCCESS_FAST) {\n\t\tint status = 0;\n\t\tagi.fd = fds[1];\n\t\tagi.ctrl = fds[0];\n\t\tagi.audio = efd;\n\t\tagi.fast = (res == AGI_RESULT_SUCCESS_FAST) ? 1 : 0;\n\t\tres = run_agi(chan, args.argv[0], &agi, pid, &status, dead, args.argc, args.argv);\n\t\t\n\t\tif ((res == AGI_RESULT_SUCCESS || res == AGI_RESULT_SUCCESS_FAST) && status)\n\t\t\tres = AGI_RESULT_FAILURE;\n\t\tif (fds[1] != fds[0])\n\t\t\tclose(fds[1]);\n\t\tif (efd > -1)\n\t\t\tclose(efd);\n\t}\n\tast_safe_fork_cleanup();\n\tswitch (res) {\n\tcase AGI_RESULT_SUCCESS:\n\tcase AGI_RESULT_SUCCESS_FAST:\n\tcase AGI_RESULT_SUCCESS_ASYNC:\n\t\tpbx_builtin_setvar_helper(chan, \"AGISTATUS\", \"SUCCESS\");\n\t\tbreak;\n\tcase AGI_RESULT_FAILURE:\n\t\tpbx_builtin_setvar_helper(chan, \"AGISTATUS\", \"FAILURE\");\n\t\tbreak;\n\tcase AGI_RESULT_NOTFOUND:\n\t\tpbx_builtin_setvar_helper(chan, \"AGISTATUS\", \"NOTFOUND\");\n\t\tbreak;\n\tcase AGI_RESULT_HANGUP:\n\t\tpbx_builtin_setvar_helper(chan, \"AGISTATUS\", \"HANGUP\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1549}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct user *build_user(const char *mac, struct phone_profile *profile, char *provider_name)\n{\n\tstruct user *user;\n\tif (!(user = ao2_alloc(sizeof(*user), user_destructor))) {\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(user, 64)) {\n\t\tuser = unref_user(user);\n\t\treturn NULL;\n\t}\n\tast_string_field_set(user, macaddress, mac);\n\tast_string_field_set(user, provider_name, provider_name);\n\tuser->profile = profile;\n\tao2_ref(profile, 1);\n\treturn user;\n}\n", "bug_type": null, "idx": 1550}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245RequestMultiplexEntry (OOCTXT* pctxt, H245RequestMultiplexEntry* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"entryNumbers\", -1);\n   stat = asn1PD_H245RequestMultiplexEntry_entryNumbers (pctxt, &pvalue->entryNumbers);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"entryNumbers\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1551}
{"project": "Asterisk", "target": 0, "func": "AST_RWLIST_HEAD_STATIC(publish_handlers, ast_sip_publish_handler);\nstatic int publication_hash_fn(const void *obj, const int flags)\n{\n\tconst struct ast_sip_publication *publication = obj;\n\tconst int *entity_tag = obj;\n\treturn flags & OBJ_KEY ? *entity_tag : publication->entity_tag;\n}\n", "bug_type": null, "idx": 1552}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_pjsip, ARRAY_LEN(cli_pjsip));\n\tast_sip_unregister_service(&logging_module);\n\tast_sip_push_task_synchronous(NULL, clear_history_entries, NULL);\n\tAST_VECTOR_FREE(&vector_history);\n\tpj_caching_pool_destroy(&cachingpool);\n\tif (log_level != -1) {\n\t\tast_logger_unregister_level(\"PJSIP_HISTORY\");\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1553}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel *ast_channel_get_by_exten(const char *exten, const char *context)\n{\n\tchar *l_exten = (char *) exten;\n\tchar *l_context = (char *) context;\n\treturn ast_channel_callback(ast_channel_by_exten_cb, l_context, l_exten, 0);\n}\n", "bug_type": null, "idx": 1554}
{"project": "Asterisk", "target": 0, "func": "void check_binaural_position_change(struct ast_bridge *bridge,\n\t\tstruct softmix_bridge_data *softmix_data, struct ast_bridge_channel *bridge_channel)\n{\n\tunsigned int pos_change;\n\t\n\tif (!(bridge->softmix.binaural_active && softmix_data->convolve.binaural_active)) {\n\t\treturn;\n\t}\n\t\n\tpos_change = 0;\n\tAST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {\n\t\tif (!bridge_channel->binaural_pos_change) {\n\t\t\tcontinue;\n\t\t}\n\t\tast_bridge_channel_lock_bridge(bridge_channel);\n\t\tbridge_channel->binaural_pos_change = 0;\n\t\tast_bridge_unlock(bridge_channel->bridge);\n\t\tpos_change = 1;\n\t}\n\tif (pos_change) {\n\t\trandom_binaural_pos_change(softmix_data);\n\t}\n}\n", "bug_type": null, "idx": 1555}
{"project": "Asterisk", "target": 0, "func": "struct ast_blind_transfer_message *ast_blind_transfer_message_create(int is_external,\n\t\tstruct ast_channel *transferer, const char *exten, const char *context)\n{\n\tstruct ast_blind_transfer_message *msg;\n\tmsg = ao2_alloc(sizeof(*msg), blind_transfer_dtor);\n\tif (!msg) {\n\t\treturn NULL;\n\t}\n\tmsg->transferer = ast_channel_snapshot_get_latest(ast_channel_uniqueid(transferer));\n\tif (!msg->transferer) {\n\t\tao2_cleanup(msg);\n\t\treturn NULL;\n\t}\n\tmsg->is_external = is_external;\n\tast_copy_string(msg->context, context, sizeof(msg->context));\n\tast_copy_string(msg->exten, exten, sizeof(msg->exten));\n\treturn msg;\n}\n", "bug_type": null, "idx": 1556}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225UnregRejectReason (OOCTXT* pctxt, H225UnregRejectReason* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 3);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 2);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            \n            break;\n         \n         case 2:\n            \n            break;\n         \n         case 3:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 4);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 4:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 5:\n            \n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 6:\n            stat = asn1PE_H225SecurityErrors2 (&lctxt, pvalue->u.securityError);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1557}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_register_application_xml(app, app_exec);\n}\n", "bug_type": null, "idx": 1558}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245H235Media_mediaType (OOCTXT* pctxt, H245H235Media_mediaType* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 4);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 3);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245VideoCapability (pctxt, pvalue->u.videoData);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245AudioCapability (pctxt, pvalue->u.audioData);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = asn1PE_H245DataApplicationCapability (pctxt, pvalue->u.data);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 5);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 5:\n            stat = asn1PE_H245RedundancyEncoding (&lctxt, pvalue->u.redundancyEncoding);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 6:\n            stat = asn1PE_H245MultiplePayloadStream (&lctxt, pvalue->u.multiplePayloadStream);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 7:\n            stat = asn1PE_H245FECData (&lctxt, pvalue->u.fec);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1559}
{"project": "Asterisk", "target": 0, "func": "\nstatic void send_cursor_pos(struct unistimsession *pte, unsigned char pos)\n{\n\tBUFFSEND;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending set cursor position\\n\");\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_set_pos_cursor,\n\t\t   sizeof(packet_send_set_pos_cursor));\n\tbuffsend[11] = pos;\n\tsend_client(SIZE_HEADER + sizeof(packet_send_set_pos_cursor), buffsend, pte);\n\treturn;\n}\n", "bug_type": null, "idx": 1560}
{"project": "Asterisk", "target": 0, "func": "struct stasis_caching_topic *stasis_caching_topic_create(struct stasis_topic *original_topic, struct stasis_cache *cache)\n{\n\tRAII_VAR(struct stasis_caching_topic *, caching_topic, NULL, ao2_cleanup);\n\tstruct stasis_subscription *sub;\n\tRAII_VAR(char *, new_name, NULL, ast_free);\n\tint ret;\n\tret = ast_asprintf(&new_name, \"%s-cached\", stasis_topic_name(original_topic));\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\tcaching_topic = ao2_alloc_options(sizeof(*caching_topic),\n\t\tstasis_caching_topic_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (caching_topic == NULL) {\n\t\treturn NULL;\n\t}\n\tcaching_topic->topic = stasis_topic_create(new_name);\n\tif (caching_topic->topic == NULL) {\n\t\treturn NULL;\n\t}\n\tao2_ref(cache, +1);\n\tcaching_topic->cache = cache;\n\tsub = internal_stasis_subscribe(original_topic, caching_topic_exec, caching_topic, 0, 0);\n\tif (sub == NULL) {\n\t\treturn NULL;\n\t}\n\tao2_ref(original_topic, +1);\n\tcaching_topic->original_topic = original_topic;\n\t\n\tao2_ref(caching_topic, +1);\n\tcaching_topic->sub = sub;\n\t\n\treturn caching_topic;\n}\n", "bug_type": null, "idx": 1561}
{"project": "Asterisk", "target": 0, "func": "int ast_check_timing2(const struct ast_timing *i, const struct timeval tv)\n{\n\tstruct ast_tm tm;\n\tast_localtime(&tv, &tm, i->timezone);\n\t\n\tif (!(i->monthmask & (1 << tm.tm_mon)))\n\t\treturn 0;\n\t\n\t\n\tif (!(i->daymask & (1 << (tm.tm_mday-1))))\n\t\treturn 0;\n\t\n\tif (!(i->dowmask & (1 << tm.tm_wday)))\n\t\treturn 0;\n\t\n\tif ((tm.tm_hour < 0) || (tm.tm_hour > 23)) {\n\t\tast_log(LOG_WARNING, \"Insane time...\\n\");\n\t\treturn 0;\n\t}\n\t\n\tif (!(i->minmask[tm.tm_hour * 2 + (tm.tm_min >= 30 ? 1 : 0)] & (1 << (tm.tm_min >= 30 ? tm.tm_min - 30 : tm.tm_min))))\n\t\treturn 0;\n\t\n\treturn 1;\n}\n", "bug_type": null, "idx": 1562}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245ResponseMessage (OOCTXT* pctxt, H245ResponseMessage* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   OOCTXT lctxt;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 18);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"nonStandard\", -1);\n            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);\n            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"nonStandard\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"masterSlaveDeterminationAck\", -1);\n            pvalue->u.masterSlaveDeterminationAck = ALLOC_ASN1ELEM (pctxt, H245MasterSlaveDeterminationAck);\n            stat = asn1PD_H245MasterSlaveDeterminationAck (pctxt, pvalue->u.masterSlaveDeterminationAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"masterSlaveDeterminationAck\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"masterSlaveDeterminationReject\", -1);\n            pvalue->u.masterSlaveDeterminationReject = ALLOC_ASN1ELEM (pctxt, H245MasterSlaveDeterminationReject);\n            stat = asn1PD_H245MasterSlaveDeterminationReject (pctxt, pvalue->u.masterSlaveDeterminationReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"masterSlaveDeterminationReject\", -1);\n            break;\n         \n         case 3:\n            invokeStartElement (pctxt, \"terminalCapabilitySetAck\", -1);\n            pvalue->u.terminalCapabilitySetAck = ALLOC_ASN1ELEM (pctxt, H245TerminalCapabilitySetAck);\n            stat = asn1PD_H245TerminalCapabilitySetAck (pctxt, pvalue->u.terminalCapabilitySetAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"terminalCapabilitySetAck\", -1);\n            break;\n         \n         case 4:\n            invokeStartElement (pctxt, \"terminalCapabilitySetReject\", -1);\n            pvalue->u.terminalCapabilitySetReject = ALLOC_ASN1ELEM (pctxt, H245TerminalCapabilitySetReject);\n            stat = asn1PD_H245TerminalCapabilitySetReject (pctxt, pvalue->u.terminalCapabilitySetReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"terminalCapabilitySetReject\", -1);\n            break;\n         \n         case 5:\n            invokeStartElement (pctxt, \"openLogicalChannelAck\", -1);\n            pvalue->u.openLogicalChannelAck = ALLOC_ASN1ELEM (pctxt, H245OpenLogicalChannelAck);\n            stat = asn1PD_H245OpenLogicalChannelAck (pctxt, pvalue->u.openLogicalChannelAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"openLogicalChannelAck\", -1);\n            break;\n         \n         case 6:\n            invokeStartElement (pctxt, \"openLogicalChannelReject\", -1);\n            pvalue->u.openLogicalChannelReject = ALLOC_ASN1ELEM (pctxt, H245OpenLogicalChannelReject);\n            stat = asn1PD_H245OpenLogicalChannelReject (pctxt, pvalue->u.openLogicalChannelReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"openLogicalChannelReject\", -1);\n            break;\n         \n         case 7:\n            invokeStartElement (pctxt, \"closeLogicalChannelAck\", -1);\n            pvalue->u.closeLogicalChannelAck = ALLOC_ASN1ELEM (pctxt, H245CloseLogicalChannelAck);\n            stat = asn1PD_H245CloseLogicalChannelAck (pctxt, pvalue->u.closeLogicalChannelAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"closeLogicalChannelAck\", -1);\n            break;\n         \n         case 8:\n            invokeStartElement (pctxt, \"requestChannelCloseAck\", -1);\n            pvalue->u.requestChannelCloseAck = ALLOC_ASN1ELEM (pctxt, H245RequestChannelCloseAck);\n            stat = asn1PD_H245RequestChannelCloseAck (pctxt, pvalue->u.requestChannelCloseAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"requestChannelCloseAck\", -1);\n            break;\n         \n         case 9:\n            invokeStartElement (pctxt, \"requestChannelCloseReject\", -1);\n            pvalue->u.requestChannelCloseReject = ALLOC_ASN1ELEM (pctxt, H245RequestChannelCloseReject);\n            stat = asn1PD_H245RequestChannelCloseReject (pctxt, pvalue->u.requestChannelCloseReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"requestChannelCloseReject\", -1);\n            break;\n         \n         case 10:\n            invokeStartElement (pctxt, \"multiplexEntrySendAck\", -1);\n            pvalue->u.multiplexEntrySendAck = ALLOC_ASN1ELEM (pctxt, H245MultiplexEntrySendAck);\n            stat = asn1PD_H245MultiplexEntrySendAck (pctxt, pvalue->u.multiplexEntrySendAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"multiplexEntrySendAck\", -1);\n            break;\n         \n         case 11:\n            invokeStartElement (pctxt, \"multiplexEntrySendReject\", -1);\n            pvalue->u.multiplexEntrySendReject = ALLOC_ASN1ELEM (pctxt, H245MultiplexEntrySendReject);\n            stat = asn1PD_H245MultiplexEntrySendReject (pctxt, pvalue->u.multiplexEntrySendReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"multiplexEntrySendReject\", -1);\n            break;\n         \n         case 12:\n            invokeStartElement (pctxt, \"requestMultiplexEntryAck\", -1);\n            pvalue->u.requestMultiplexEntryAck = ALLOC_ASN1ELEM (pctxt, H245RequestMultiplexEntryAck);\n            stat = asn1PD_H245RequestMultiplexEntryAck (pctxt, pvalue->u.requestMultiplexEntryAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"requestMultiplexEntryAck\", -1);\n            break;\n         \n         case 13:\n            invokeStartElement (pctxt, \"requestMultiplexEntryReject\", -1);\n            pvalue->u.requestMultiplexEntryReject = ALLOC_ASN1ELEM (pctxt, H245RequestMultiplexEntryReject);\n            stat = asn1PD_H245RequestMultiplexEntryReject (pctxt, pvalue->u.requestMultiplexEntryReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"requestMultiplexEntryReject\", -1);\n            break;\n         \n         case 14:\n            invokeStartElement (pctxt, \"requestModeAck\", -1);\n            pvalue->u.requestModeAck = ALLOC_ASN1ELEM (pctxt, H245RequestModeAck);\n            stat = asn1PD_H245RequestModeAck (pctxt, pvalue->u.requestModeAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"requestModeAck\", -1);\n            break;\n         \n         case 15:\n            invokeStartElement (pctxt, \"requestModeReject\", -1);\n            pvalue->u.requestModeReject = ALLOC_ASN1ELEM (pctxt, H245RequestModeReject);\n            stat = asn1PD_H245RequestModeReject (pctxt, pvalue->u.requestModeReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"requestModeReject\", -1);\n            break;\n         \n         case 16:\n            invokeStartElement (pctxt, \"roundTripDelayResponse\", -1);\n            pvalue->u.roundTripDelayResponse = ALLOC_ASN1ELEM (pctxt, H245RoundTripDelayResponse);\n            stat = asn1PD_H245RoundTripDelayResponse (pctxt, pvalue->u.roundTripDelayResponse);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"roundTripDelayResponse\", -1);\n            break;\n         \n         case 17:\n            invokeStartElement (pctxt, \"maintenanceLoopAck\", -1);\n            pvalue->u.maintenanceLoopAck = ALLOC_ASN1ELEM (pctxt, H245MaintenanceLoopAck);\n            stat = asn1PD_H245MaintenanceLoopAck (pctxt, pvalue->u.maintenanceLoopAck);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"maintenanceLoopAck\", -1);\n            break;\n         \n         case 18:\n            invokeStartElement (pctxt, \"maintenanceLoopReject\", -1);\n            pvalue->u.maintenanceLoopReject = ALLOC_ASN1ELEM (pctxt, H245MaintenanceLoopReject);\n            stat = asn1PD_H245MaintenanceLoopReject (pctxt, pvalue->u.maintenanceLoopReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"maintenanceLoopReject\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 20;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n      copyContext (&lctxt, pctxt);\n      initContextBuffer (pctxt, openType.data, openType.numocts);\n      switch (pvalue->t) {\n         \n         case 20:\n            invokeStartElement (pctxt, \"communicationModeResponse\", -1);\n            pvalue->u.communicationModeResponse = ALLOC_ASN1ELEM (pctxt, H245CommunicationModeResponse);\n            stat = asn1PD_H245CommunicationModeResponse (pctxt, pvalue->u.communicationModeResponse);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"communicationModeResponse\", -1);\n            break;\n         \n         case 21:\n            invokeStartElement (pctxt, \"conferenceResponse\", -1);\n            pvalue->u.conferenceResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse);\n            stat = asn1PD_H245ConferenceResponse (pctxt, pvalue->u.conferenceResponse);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"conferenceResponse\", -1);\n            break;\n         \n         case 22:\n            invokeStartElement (pctxt, \"multilinkResponse\", -1);\n            pvalue->u.multilinkResponse = ALLOC_ASN1ELEM (pctxt, H245MultilinkResponse);\n            stat = asn1PD_H245MultilinkResponse (pctxt, pvalue->u.multilinkResponse);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"multilinkResponse\", -1);\n            break;\n         \n         case 23:\n            invokeStartElement (pctxt, \"logicalChannelRateAcknowledge\", -1);\n            pvalue->u.logicalChannelRateAcknowledge = ALLOC_ASN1ELEM (pctxt, H245LogicalChannelRateAcknowledge);\n            stat = asn1PD_H245LogicalChannelRateAcknowledge (pctxt, pvalue->u.logicalChannelRateAcknowledge);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"logicalChannelRateAcknowledge\", -1);\n            break;\n         \n         case 24:\n            invokeStartElement (pctxt, \"logicalChannelRateReject\", -1);\n            pvalue->u.logicalChannelRateReject = ALLOC_ASN1ELEM (pctxt, H245LogicalChannelRateReject);\n            stat = asn1PD_H245LogicalChannelRateReject (pctxt, pvalue->u.logicalChannelRateReject);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"logicalChannelRateReject\", -1);\n            break;\n         default:;\n      }\n      copyContext (pctxt, &lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1563}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_context_remove_include(const char *context, const char *include, const char *registrar)\n{\n\tint ret = -1;\n\tstruct ast_context *c;\n\tc = find_context_locked(context);\n\tif (c) {\n\t\t\n\t\tret = ast_context_remove_include2(c, include, registrar);\n\t\tast_unlock_contexts();\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 1564}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int media_cache_cmp(void *obj, void *arg, int flags)\n{\n\tstruct ast_bucket_file *left = obj;\n\tstruct ast_bucket_file *right = arg;\n\tconst char *right_key = arg;\n\tint cmp;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_OBJECT:\n\t\tright_key = ast_sorcery_object_get_id(right);\n\t\t\n\tcase OBJ_SEARCH_KEY:\n\t\tcmp = strcmp(ast_sorcery_object_get_id(left), right_key);\n\t\tbreak;\n\tcase OBJ_SEARCH_PARTIAL_KEY:\n\t\tcmp = strncmp(ast_sorcery_object_get_id(left), right_key, strlen(right_key));\n\t\tbreak;\n\tdefault:\n\t\tast_assert(0);\n\t\tcmp = 0;\n\t\tbreak;\n\t}\n\treturn cmp ? 0 : CMP_MATCH | CMP_STOP;\n}\n", "bug_type": null, "idx": 1565}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_channel *ooh323_request(const char *type, struct ast_format_cap *cap,\n\t\tconst struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause)\n{\n\tstruct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\tstruct ast_channel *chan = NULL;\n\tstruct ooh323_pvt *p = NULL;\n\tstruct ooh323_peer *peer = NULL;\n\tchar *dest = NULL; \n\tchar *ext = NULL;\n\tchar tmp[256];\n\tint port = 0;\n\tif (gH323Debug) {\n\t\tast_verb(0, \"---   ooh323_request - data %s format %s\\n\", data, ast_format_cap_get_names(cap, &codec_buf));\n\t}\n\tif (!(ast_format_cap_has_type(cap, AST_MEDIA_TYPE_AUDIO))) {\n\t\tast_log(LOG_NOTICE, \"Asked to get a channel of unsupported format '%s'\\n\", ast_format_cap_get_names(cap, &codec_buf));\n\t\treturn NULL;\n\t}\n\tp = ooh323_alloc(0,0); \n\tif (!p) {\n\t\tast_log(LOG_WARNING, \"Unable to build pvt data for '%s'\\n\", data);\n\t\treturn NULL;\n\t}\n\tast_mutex_lock(&p->lock);\n\t\n\tast_set_flag(p, H323_OUTGOING);\n   \tast_copy_string(tmp, data, sizeof(tmp));\n\tdest = strchr(tmp, '/');\n\tif (dest) {  \n\t\t*dest = '\\0';\n\t\tdest++;\n\t\text = dest;\n\t\tdest = tmp;\n\t} else if ((dest = strchr(tmp, '@'))) {\n\t\t*dest = '\\0';\n\t\tdest++;\n\t\text = tmp;\n\t} else {\n\t\tdest = tmp;\n\t\text = NULL;\n\t}\n#if 0\n\tif ((sport = strchr(dest, ':'))) {\n\t\t*sport = '\\0';\n\t\tsport++;\n\t\tport = atoi(sport);\n\t}\n#endif\n\tif (dest) {\n\t\tpeer = find_peer(dest, port);\n\t} else{\n\t\tast_mutex_lock(&iflock);\n\t\tast_mutex_unlock(&p->lock);\n\t\tooh323_destroy(p);\n\t\tast_mutex_unlock(&iflock);\n\t\tast_log(LOG_ERROR, \"Destination format is not supported\\n\");\n\t\t*cause = AST_CAUSE_INVALID_NUMBER_FORMAT;\n\t\treturn NULL;\n\t}\n\tif (peer) {\n\t\tp->username = ast_strdup(peer->name);\n\t\tp->host = ast_strdup(peer->ip);\n\t\tp->port = peer->port;\n\t\t\n\t\t\n\t\tif (ext)\n\t\t\tast_copy_string(p->exten, ext, sizeof(p->exten));\n\t\tast_format_cap_append_from_cap(p->cap, peer->cap, AST_MEDIA_TYPE_UNKNOWN);\n\t\tp->g729onlyA = peer->g729onlyA;\n\t\tp->dtmfmode |= peer->dtmfmode;\n\t\tp->dtmfcodec  = peer->dtmfcodec;\n\t\tp->faxdetect = peer->faxdetect;\n\t\tp->t38support = peer->t38support;\n\t\tp->rtptimeout = peer->rtptimeout;\n\t\tp->nat = peer->nat;\n\t\tp->faststart = peer->faststart;\n\t\tp->h245tunneling = peer->h245tunneling;\n\t\tp->directrtp = peer->directrtp;\n\t\tp->earlydirect = peer->earlydirect;\n\t\tif (peer->rtpmask && peer->rtpmaskstr[0]) {\n\t\t\tp->rtpmask = peer->rtpmask;\n\t\t\tast_copy_string(p->rtpmaskstr, peer->rtpmaskstr, sizeof(p->rtpmaskstr));\n\t\t}\n\t\tif (peer->rtdrinterval) {\n\t\t\tp->rtdrinterval = peer->rtdrinterval;\n\t\t\tp->rtdrcount = peer->rtdrcount;\n\t\t}\n\t\tast_copy_string(p->accountcode, peer->accountcode, sizeof(p->accountcode));\n\t\tp->amaflags = peer->amaflags;\n\t} else {\n\t\tif (gRasGkMode ==  RasNoGatekeeper) {\n\t\t\t\n\t\t\tast_log(LOG_ERROR, \"Call to undefined peer %s\", dest);\n\t\t\tast_mutex_lock(&iflock);\n\t\t\tast_mutex_unlock(&p->lock);\n\t\t\tooh323_destroy(p);\n\t\t\tast_mutex_unlock(&iflock);\n\t\t\treturn NULL;\n\t\t} else if (!gH323ep.gkClient || (gH323ep.gkClient && gH323ep.gkClient->state != GkClientRegistered)) {\n\t\t\tast_log(LOG_ERROR, \"Gatekeeper client is configured but not registered\\n\");\n\t\t\t*cause = AST_CAUSE_NORMAL_TEMPORARY_FAILURE;\n\t\t\treturn NULL;\n\t\t}\n\t\tp->g729onlyA = g729onlyA;\n\t\tp->dtmfmode = gDTMFMode;\n\t\tp->dtmfcodec = gDTMFCodec;\n\t\tp->faxdetect = gFAXdetect;\n\t\tp->t38support = gT38Support;\n\t\tp->rtptimeout = gRTPTimeout;\n\t\tp->nat = gNat;\n\t\tast_format_cap_append_from_cap(p->cap, gCap, AST_MEDIA_TYPE_UNKNOWN);\n\t\tp->rtdrinterval = gRTDRInterval;\n\t\tp->rtdrcount = gRTDRCount;\n\t\tp->faststart = gFastStart;\n\t\tp->h245tunneling = gTunneling;\n\t\tp->directrtp = gDirectRTP;\n\t\tp->earlydirect = gEarlyDirect;\n\t\tp->username = ast_strdup(dest);\n\t\tp->host = ast_strdup(dest);\n\t\tif (port > 0) {\n\t\t\tp->port = port;\n\t\t}\n\t\tif (ext) {\n\t\t\tast_copy_string(p->exten, ext, sizeof(p->exten));\n\t\t}\n\t}\n\tchan = ooh323_new(p, AST_STATE_DOWN, p->username, cap,\n\t\t\t\t assignedids, requestor);\n\tast_mutex_unlock(&p->lock);\n\tif (!chan) {\n\t\tast_mutex_lock(&iflock);\n\t\tooh323_destroy(p);\n\t\tast_mutex_unlock(&iflock);\n   \t} else {\n      \t\tast_mutex_lock(&p->lock);\n      \t\tp->callToken = (char*)ast_calloc(1, AST_MAX_EXTENSION);\n      \t\tif(!p->callToken) {\n       \t\t\tast_mutex_unlock(&p->lock);\n       \t\t\tast_mutex_lock(&iflock);\n       \t\t\tooh323_destroy(p);\n       \t\t\tast_mutex_unlock(&iflock);\n       \t\t\tast_log(LOG_ERROR, \"Failed to allocate memory for callToken\\n\");\n       \t\t\treturn NULL;\n      \t\t}\n\t\tast_cond_init(&p->rtpcond, NULL);\n      \t\tooMakeCall(data, p->callToken, AST_MAX_EXTENSION, NULL);\n\t\tif (!p->rtp) {\n\t\t\tast_cond_wait(&p->rtpcond, &p->lock);\n\t\t}\n\t\tast_mutex_unlock(&p->lock);\n\t\tast_cond_destroy(&p->rtpcond);\n\t}\n\trestart_monitor();\n\tif (gH323Debug)\n\t\tast_verb(0, \"+++   ooh323_request\\n\");\n\treturn chan;\n}\n", "bug_type": null, "idx": 1566}
{"project": "Asterisk", "target": 0, "func": " */\nstatic inline int calc_monitor_jump(int samples, int sample_rate, int seek_rate)\n{\n\tint diff = sample_rate - seek_rate;\n\tif (diff > 0) {\n\t\tsamples = samples / (float) (sample_rate / seek_rate);\n\t} else if (diff < 0) {\n\t\tsamples = samples * (float) (seek_rate / sample_rate);\n\t}\n\treturn samples;\n}\n", "bug_type": null, "idx": 1567}
{"project": "Asterisk", "target": 0, "func": "static int delay_request(struct ast_sip_session *session,\n\tast_sip_session_request_creation_cb on_request,\n\tast_sip_session_sdp_creation_cb on_sdp_creation,\n\tast_sip_session_response_cb on_response,\n\tint generate_new_sdp,\n\tenum delayed_method method,\n\tstruct ast_sip_session_media_state *media_state)\n{\n\tstruct ast_sip_session_delayed_request *delay = delayed_request_alloc(method,\n\t\t\ton_request, on_sdp_creation, on_response, generate_new_sdp, media_state);\n\tif (!delay) {\n\t\tast_sip_session_media_state_free(media_state);\n\t\treturn -1;\n\t}\n\tif (method == DELAYED_METHOD_BYE) {\n\t\t\n\t\tAST_LIST_INSERT_HEAD(&session->delayed_requests, delay, next);\n\t} else {\n\t\tAST_LIST_INSERT_TAIL(&session->delayed_requests, delay, next);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1568}
{"project": "Asterisk", "target": 0, "func": "void ast_translate_available_formats(struct ast_format_cap *dest, struct ast_format_cap *src, struct ast_format_cap *result)\n{\n\tstruct ast_format *cur_dest, *cur_src;\n\tint index;\n\tfor (index = 0; index < ast_format_cap_count(dest); ++index) {\n\t\tif (!(cur_dest = ast_format_cap_get_format(dest, index))) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif ((cur_src = ast_format_cap_get_compatible_format(src, cur_dest))) {\n\t\t\tast_format_cap_append(result, cur_src, 0);\n\t\t\tao2_ref(cur_src, -1);\n\t\t} else {\n\t\t\t\n\t\t\tast_format_cap_append(result, cur_dest, 0);\n\t\t}\n\t\tao2_ref(cur_dest, -1);\n\t}\n\t\n\tif (!src) {\n\t\treturn;\n\t}\n\tfor (index = 0; index < ast_format_cap_count(src); ++index) {\n\t\tif (!(cur_src = ast_format_cap_get_format(src, index))) {\n\t\t\tcontinue;\n\t\t}\n\t\tAST_RWLIST_RDLOCK(&translators);\n\t\tcheck_translation_path(dest, src, result,\n\t\t\t\t       cur_src, AST_MEDIA_TYPE_AUDIO);\n\t\tcheck_translation_path(dest, src, result,\n\t\t\t\t       cur_src, AST_MEDIA_TYPE_VIDEO);\n\t\tAST_RWLIST_UNLOCK(&translators);\n\t\tao2_ref(cur_src, -1);\n\t}\n}\n", "bug_type": null, "idx": 1569}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel *ast_channel_get_by_name_prefix(const char *name, size_t name_len)\n{\n\tstruct ast_channel *chan;\n\tchar *l_name = (char *) name;\n\tchan = ast_channel_callback(ast_channel_by_name_cb, l_name, &name_len,\n\t\t(name_len == 0)  ? OBJ_KEY : 0);\n\tif (chan) {\n\t\treturn chan;\n\t}\n\tif (ast_strlen_zero(l_name)) {\n\t\t\n\t\treturn NULL;\n\t}\n\t\n\treturn ast_channel_callback(ast_channel_by_uniqueid_cb, l_name, &name_len, 0);\n}\n", "bug_type": null, "idx": 1570}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245EncryptionMode (OOCTXT* pctxt, H245EncryptionMode* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 2);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 1);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 3);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1571}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225H323_UU_PDU_h323_message_body (OOCTXT* pctxt, H225H323_UU_PDU_h323_message_body* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   OOCTXT lctxt;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"setup\", -1);\n            pvalue->u.setup = ALLOC_ASN1ELEM (pctxt, H225Setup_UUIE);\n            stat = asn1PD_H225Setup_UUIE (pctxt, pvalue->u.setup);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"setup\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"callProceeding\", -1);\n            pvalue->u.callProceeding = ALLOC_ASN1ELEM (pctxt, H225CallProceeding_UUIE);\n            stat = asn1PD_H225CallProceeding_UUIE (pctxt, pvalue->u.callProceeding);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"callProceeding\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"connect\", -1);\n            pvalue->u.connect = ALLOC_ASN1ELEM (pctxt, H225Connect_UUIE);\n            stat = asn1PD_H225Connect_UUIE (pctxt, pvalue->u.connect);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"connect\", -1);\n            break;\n         \n         case 3:\n            invokeStartElement (pctxt, \"alerting\", -1);\n            pvalue->u.alerting = ALLOC_ASN1ELEM (pctxt, H225Alerting_UUIE);\n            stat = asn1PD_H225Alerting_UUIE (pctxt, pvalue->u.alerting);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"alerting\", -1);\n            break;\n         \n         case 4:\n            invokeStartElement (pctxt, \"information\", -1);\n            pvalue->u.information = ALLOC_ASN1ELEM (pctxt, H225Information_UUIE);\n            stat = asn1PD_H225Information_UUIE (pctxt, pvalue->u.information);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"information\", -1);\n            break;\n         \n         case 5:\n            invokeStartElement (pctxt, \"releaseComplete\", -1);\n            pvalue->u.releaseComplete = ALLOC_ASN1ELEM (pctxt, H225ReleaseComplete_UUIE);\n            stat = asn1PD_H225ReleaseComplete_UUIE (pctxt, pvalue->u.releaseComplete);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"releaseComplete\", -1);\n            break;\n         \n         case 6:\n            invokeStartElement (pctxt, \"facility\", -1);\n            pvalue->u.facility = ALLOC_ASN1ELEM (pctxt, H225Facility_UUIE);\n            stat = asn1PD_H225Facility_UUIE (pctxt, pvalue->u.facility);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"facility\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 8;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n      copyContext (&lctxt, pctxt);\n      initContextBuffer (pctxt, openType.data, openType.numocts);\n      switch (pvalue->t) {\n         \n         case 8:\n            invokeStartElement (pctxt, \"progress\", -1);\n            pvalue->u.progress = ALLOC_ASN1ELEM (pctxt, H225Progress_UUIE);\n            stat = asn1PD_H225Progress_UUIE (pctxt, pvalue->u.progress);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"progress\", -1);\n            break;\n         \n         case 9:\n            invokeStartElement (pctxt, \"empty\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"empty\", -1);\n            break;\n         \n         case 10:\n            invokeStartElement (pctxt, \"status\", -1);\n            pvalue->u.status = ALLOC_ASN1ELEM (pctxt, H225Status_UUIE);\n            stat = asn1PD_H225Status_UUIE (pctxt, pvalue->u.status);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"status\", -1);\n            break;\n         \n         case 11:\n            invokeStartElement (pctxt, \"statusInquiry\", -1);\n            pvalue->u.statusInquiry = ALLOC_ASN1ELEM (pctxt, H225StatusInquiry_UUIE);\n            stat = asn1PD_H225StatusInquiry_UUIE (pctxt, pvalue->u.statusInquiry);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"statusInquiry\", -1);\n            break;\n         \n         case 12:\n            invokeStartElement (pctxt, \"setupAcknowledge\", -1);\n            pvalue->u.setupAcknowledge = ALLOC_ASN1ELEM (pctxt, H225SetupAcknowledge_UUIE);\n            stat = asn1PD_H225SetupAcknowledge_UUIE (pctxt, pvalue->u.setupAcknowledge);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"setupAcknowledge\", -1);\n            break;\n         \n         case 13:\n            invokeStartElement (pctxt, \"notify\", -1);\n            pvalue->u.notify = ALLOC_ASN1ELEM (pctxt, H225Notify_UUIE);\n            stat = asn1PD_H225Notify_UUIE (pctxt, pvalue->u.notify);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"notify\", -1);\n            break;\n         default:;\n      }\n      copyContext (pctxt, &lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1572}
{"project": "Asterisk", "target": 0, "func": "static void send_dtmf_end_event(struct ast_channel *chan,\n\tenum DtmfDirection direction, const char digit, long duration_ms)\n{\n\tRAII_VAR(struct ast_json *, blob, NULL, ast_json_unref);\n\tchar digit_str[] = { digit, '\\0' };\n\tblob = ast_json_pack(\"{ s: s, s: s, s: i }\",\n\t\t\"digit\", digit_str,\n\t\t\"direction\", dtmf_direction_to_string(direction),\n\t\t\"duration_ms\", duration_ms);\n\tif (!blob) {\n\t\treturn;\n\t}\n\tast_channel_publish_cached_blob(chan, ast_channel_dtmf_end_type(), blob);\n}\n", "bug_type": null, "idx": 1573}
{"project": "Asterisk", "target": 0, "func": "void ast_smoother_reconfigure(struct ast_smoother *s, int bytes)\n{\n\t\n\tif (s->size == bytes) {\n\t\treturn;\n\t}\n\t\n\ts->size = bytes;\n\t\n\tif (!s->opt) {\n\t\treturn;\n\t}\n\t\n\tsmoother_frame_feed(s, s->opt, s->opt_needs_swap);\n\ts->opt = NULL;\n}\n", "bug_type": null, "idx": 1574}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void websocket_session_dtor(void *obj)\n{\n\tstruct ast_ari_websocket_session *session = obj;\n\tast_websocket_unref(session->ws_session);\n\tsession->ws_session = NULL;\n}\n", "bug_type": null, "idx": 1575}
{"project": "Asterisk", "target": 0, "func": "const char *ast_channel_exten(const struct ast_channel *chan)\n{\n\treturn chan->exten;\n}\n", "bug_type": null, "idx": 1576}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct sip_subscription_tree *create_subscription_tree(const struct ast_sip_subscription_handler *handler,\n\t\tstruct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, const char *resource,\n\t\tstruct ast_sip_pubsub_body_generator *generator, struct resource_tree *tree,\n\t\tpj_status_t *dlg_status)\n{\n\tstruct sip_subscription_tree *sub_tree;\n\tpjsip_dialog *dlg;\n\tstruct subscription_persistence *persistence;\n\tsub_tree = allocate_subscription_tree(endpoint, rdata);\n\tif (!sub_tree) {\n\t\t*dlg_status = PJ_ENOMEM;\n\t\treturn NULL;\n\t}\n\tsub_tree->role = AST_SIP_NOTIFIER;\n\tdlg = ast_sip_create_dialog_uas(endpoint, rdata, dlg_status);\n\tif (!dlg) {\n\t\tif (*dlg_status != PJ_EEXISTS) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create dialog for SIP subscription\\n\");\n\t\t}\n\t\tao2_ref(sub_tree, -1);\n\t\treturn NULL;\n\t}\n\tpersistence = ast_sip_mod_data_get(rdata->endpt_info.mod_data,\n\t\t\tpubsub_module.id, MOD_DATA_PERSISTENCE);\n\tif (persistence) {\n\t\t\n\t\tpjsip_ua_unregister_dlg(pjsip_ua_instance(), dlg);\n\t\tpj_strdup2(dlg->pool, &dlg->local.info->tag, persistence->tag);\n\t\tdlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);\n\t\tpjsip_ua_register_dlg(pjsip_ua_instance(), dlg);\n\t\tdlg->local.cseq = persistence->cseq;\n\t}\n\tpjsip_evsub_create_uas(dlg, &pubsub_cb, rdata, 0, &sub_tree->evsub);\n\tsubscription_setup_dialog(sub_tree, dlg);\n#ifdef HAVE_PJSIP_EVSUB_GRP_LOCK\n\tpjsip_evsub_add_ref(sub_tree->evsub);\n#endif\n\tast_sip_mod_data_set(dlg->pool, dlg->mod_data, pubsub_module.id, MOD_DATA_MSG,\n\t\t\tpjsip_msg_clone(dlg->pool, rdata->msg_info.msg));\n\tsub_tree->notification_batch_interval = tree->notification_batch_interval;\n\tsub_tree->root = create_virtual_subscriptions(handler, resource, generator, sub_tree, tree->root);\n\tif (AST_VECTOR_SIZE(&sub_tree->root->children) > 0) {\n\t\tsub_tree->is_list = 1;\n\t}\n\tadd_subscription(sub_tree);\n\treturn sub_tree;\n}\n", "bug_type": null, "idx": 1577}
{"project": "Asterisk", "target": 0, "func": "\nint ast_say_datetime_th(struct ast_channel *chan, time_t t, const char *ints, const char *lang)\n{\n\tstruct timeval when = { t, 0 };\n\tstruct ast_tm tm;\n\tchar fn[256];\n\tint res = 0;\n\tint hour;\n\tast_localtime(&when, &tm, NULL);\n\tif (!res) {\n\t\tsnprintf(fn, sizeof(fn), \"digits/day-%d\", tm.tm_wday);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res)\n\t\t\tres = ast_waitstream(chan, ints);\n\t}\n\tif (!res) {\n\t\tsnprintf(fn, sizeof(fn), \"digits/mon-%d\", tm.tm_mon);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res)\n\t\t\tres = ast_waitstream(chan, ints);\n\t}\n\tif (!res){\n\t\tast_copy_string(fn, \"digits/posor\", sizeof(fn));\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tres = ast_say_number(chan, tm.tm_year + 1900 + 543, ints, lang, (char *) NULL);\n\t}\n\tif (!res)\n\t\tres = ast_say_number(chan, tm.tm_mday, ints, lang, (char *) NULL);\n\thour = tm.tm_hour;\n\tif (!hour)\n\t\thour = 24;\n\tif (!res){\n\t\tast_copy_string(fn, \"digits/wela\", sizeof(fn));\n\t\tres = ast_streamfile(chan, fn, lang);\n\t}\n\tif (!res)\n\t\tres = ast_say_number(chan, hour, ints, lang, (char *) NULL);\n\tif (!res)\n\t\tres = ast_say_number(chan, tm.tm_min, ints, lang, (char *) NULL);\n\treturn res;\n}\n", "bug_type": null, "idx": 1578}
{"project": "Asterisk", "target": 0, "func": "#if !defined(HAVE_STRNDUP) && !defined(__AST_DEBUG_MALLOC)\nchar *strndup(const char *s, size_t n)\n{\n\tsize_t len = strnlen(s, n);\n\tchar *new = malloc(len + 1);\n\tif (!new)\n\t\treturn NULL;\n\tnew[len] = '\\0';\n\treturn memcpy(new, s, len);\n}\n", "bug_type": null, "idx": 1579}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_get_default_from_user(char *from_user, size_t size)\n{\n\tstruct global_config *cfg;\n\tcfg = get_global_cfg();\n\tif (!cfg) {\n\t\tast_copy_string(from_user, DEFAULT_FROM_USER, size);\n\t} else {\n\t\tast_copy_string(from_user, cfg->default_from_user, size);\n\t\tao2_ref(cfg, -1);\n\t}\n}\n", "bug_type": null, "idx": 1580}
{"project": "Asterisk", "target": 0, "func": "#ifdef HAVE_BKTR\nvoid ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr, struct ast_bt *bt);\nvoid ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr, struct ast_bt *bt)\n{\n    \n}\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr, struct ast_bt *bt);\nvoid ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr, struct ast_bt *bt)\n{\n    \n}\n#else\nvoid ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr);\nvoid ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr)\n{\n    \n}\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr);\nvoid ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\t\t        int line_num, const char *func, const char *lock_name, void *lock_addr)\n{\n    \n}\n", "bug_type": null, "idx": 1581}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int math(struct ast_channel *chan, const char *cmd, char *parse,\n\t\tchar *buf, size_t len)\n{\n\tdouble fnum1;\n\tdouble fnum2;\n\tdouble ftmp = 0;\n\tchar *op;\n\tint iaction = -1;\n\tint type_of_result = FLOAT_RESULT;\n\tchar *mvalue1, *mvalue2 = NULL, *mtype_of_result;\n\tint negvalue1 = 0;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t     AST_APP_ARG(argv0);\n\t\t\t     AST_APP_ARG(argv1);\n\t);\n\tif (ast_strlen_zero(parse)) {\n\t\tast_log(LOG_WARNING, \"Syntax: MATH(<number1><op><number 2>[,<type_of_result>]) - missing argument!\\n\");\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc < 1) {\n\t\tast_log(LOG_WARNING, \"Syntax: MATH(<number1><op><number 2>[,<type_of_result>]) - missing argument!\\n\");\n\t\treturn -1;\n\t}\n\tmvalue1 = args.argv0;\n\tif (mvalue1[0] == '-') {\n\t\tnegvalue1 = 1;\n\t\tmvalue1++;\n\t}\n\tif ((op = strchr(mvalue1, '*'))) {\n\t\tiaction = MULTIPLYFUNCTION;\n\t\t*op = '\\0';\n\t} else if ((op = strchr(mvalue1, '/'))) {\n\t\tiaction = DIVIDEFUNCTION;\n\t\t*op = '\\0';\n\t} else if ((op = strchr(mvalue1, '%'))) {\n\t\tiaction = MODULUSFUNCTION;\n\t\t*op = '\\0';\n\t} else if ((op = strchr(mvalue1, '^'))) {\n\t\tiaction = POWFUNCTION;\n\t\t*op = '\\0';\n\t} else if ((op = strstr(mvalue1, \"AND\"))) {\n\t\tiaction = BITWISEANDFUNCTION;\n\t\t*op = '\\0';\n\t\top += 2;\n\t} else if ((op = strstr(mvalue1, \"XOR\"))) {\n\t\tiaction = BITWISEXORFUNCTION;\n\t\t*op = '\\0';\n\t\top += 2;\n\t} else if ((op = strstr(mvalue1, \"OR\"))) {\n\t\tiaction = BITWISEORFUNCTION;\n\t\t*op = '\\0';\n\t\t++op;\n\t} else if ((op = strchr(mvalue1, '>'))) {\n\t\tiaction = GTFUNCTION;\n\t\t*op = '\\0';\n\t\tif (*(op + 1) == '=') {\n\t\t\tiaction = GTEFUNCTION;\n\t\t\t++op;\n\t\t} else if (*(op + 1) == '>') {\n\t\t\tiaction = SHRIGHTFUNCTION;\n\t\t\t++op;\n\t\t}\n\t} else if ((op = strchr(mvalue1, '<'))) {\n\t\tiaction = LTFUNCTION;\n\t\t*op = '\\0';\n\t\tif (*(op + 1) == '=') {\n\t\t\tiaction = LTEFUNCTION;\n\t\t\t++op;\n\t\t} else if (*(op + 1) == '<') {\n\t\t\tiaction = SHLEFTFUNCTION;\n\t\t\t++op;\n\t\t}\n\t} else if ((op = strchr(mvalue1, '='))) {\n\t\t*op = '\\0';\n\t\tif (*(op + 1) == '=') {\n\t\t\tiaction = EQFUNCTION;\n\t\t\t++op;\n\t\t} else\n\t\t\top = NULL;\n\t} else if ((op = strchr(mvalue1, '+'))) {\n\t\tiaction = ADDFUNCTION;\n\t\t*op = '\\0';\n\t} else if ((op = strchr(mvalue1, '-'))) { \n\t\tiaction = SUBTRACTFUNCTION;\n\t\t*op = '\\0';\n\t}\n\tif (op)\n\t\tmvalue2 = op + 1;\n\t\n\tmtype_of_result = args.argv1;\n\tif (mtype_of_result) {\n\t\tif (!strcasecmp(mtype_of_result, \"float\")\n\t\t    || !strcasecmp(mtype_of_result, \"f\"))\n\t\t\ttype_of_result = FLOAT_RESULT;\n\t\telse if (!strcasecmp(mtype_of_result, \"int\")\n\t\t\t || !strcasecmp(mtype_of_result, \"i\"))\n\t\t\ttype_of_result = INT_RESULT;\n\t\telse if (!strcasecmp(mtype_of_result, \"hex\")\n\t\t\t || !strcasecmp(mtype_of_result, \"h\"))\n\t\t\ttype_of_result = HEX_RESULT;\n\t\telse if (!strcasecmp(mtype_of_result, \"char\")\n\t\t\t || !strcasecmp(mtype_of_result, \"c\"))\n\t\t\ttype_of_result = CHAR_RESULT;\n\t\telse {\n\t\t\tast_log(LOG_WARNING, \"Unknown type of result requested '%s'.\\n\",\n\t\t\t\t\tmtype_of_result);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!mvalue2) {\n\t\tast_log(LOG_WARNING,\n\t\t\t\t\"Supply all the parameters - just this once, please\\n\");\n\t\treturn -1;\n\t}\n\tif (sscanf(mvalue1, \"%30lf\", &fnum1) != 1) {\n\t\tast_log(LOG_WARNING, \"'%s' is not a valid number\\n\", mvalue1);\n\t\treturn -1;\n\t}\n\tif (sscanf(mvalue2, \"%30lf\", &fnum2) != 1) {\n\t\tast_log(LOG_WARNING, \"'%s' is not a valid number\\n\", mvalue2);\n\t\treturn -1;\n\t}\n\tif (negvalue1)\n\t\tfnum1 = 0 - fnum1;\n\tswitch (iaction) {\n\tcase ADDFUNCTION:\n\t\tftmp = fnum1 + fnum2;\n\t\tbreak;\n\tcase DIVIDEFUNCTION:\n\t\tif (fnum2 <= 0)\n\t\t\tftmp = 0;\t\t\t\n\t\telse\n\t\t\tftmp = (fnum1 / fnum2);\n\t\tbreak;\n\tcase MULTIPLYFUNCTION:\n\t\tftmp = (fnum1 * fnum2);\n\t\tbreak;\n\tcase SUBTRACTFUNCTION:\n\t\tftmp = (fnum1 - fnum2);\n\t\tbreak;\n\tcase MODULUSFUNCTION:\n\t\t{\n\t\t\tint inum1 = fnum1;\n\t\t\tint inum2 = fnum2;\n\t\t\tif (inum2 == 0) {\n\t\t\t\tftmp = 0;\n\t\t\t} else {\n\t\t\t\tftmp = (inum1 % inum2);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase POWFUNCTION:\n\t\tftmp = pow(fnum1, fnum2);\n\t\tbreak;\n\tcase SHLEFTFUNCTION:\n\t\t{\n\t\t\tint inum1 = fnum1;\n\t\t\tint inum2 = fnum2;\n\t\t\tftmp = (inum1 << inum2);\n\t\t\tbreak;\n\t\t}\n\tcase SHRIGHTFUNCTION:\n\t\t{\n\t\t\tint inum1 = fnum1;\n\t\t\tint inum2 = fnum2;\n\t\t\tftmp = (inum1 >> inum2);\n\t\t\tbreak;\n\t\t}\n\tcase BITWISEANDFUNCTION:\n\t\t{\n\t\t\tint inum1 = fnum1;\n\t\t\tint inum2 = fnum2;\n\t\t\tftmp = (inum1 & inum2);\n\t\t\tbreak;\n\t\t}\n\tcase BITWISEXORFUNCTION:\n\t\t{\n\t\t\tint inum1 = fnum1;\n\t\t\tint inum2 = fnum2;\n\t\t\tftmp = (inum1 ^ inum2);\n\t\t\tbreak;\n\t\t}\n\tcase BITWISEORFUNCTION:\n\t\t{\n\t\t\tint inum1 = fnum1;\n\t\t\tint inum2 = fnum2;\n\t\t\tftmp = (inum1 | inum2);\n\t\t\tbreak;\n\t\t}\n\tcase GTFUNCTION:\n\t\tast_copy_string(buf, (fnum1 > fnum2) ? \"TRUE\" : \"FALSE\", len);\n\t\tbreak;\n\tcase LTFUNCTION:\n\t\tast_copy_string(buf, (fnum1 < fnum2) ? \"TRUE\" : \"FALSE\", len);\n\t\tbreak;\n\tcase GTEFUNCTION:\n\t\tast_copy_string(buf, (fnum1 >= fnum2) ? \"TRUE\" : \"FALSE\", len);\n\t\tbreak;\n\tcase LTEFUNCTION:\n\t\tast_copy_string(buf, (fnum1 <= fnum2) ? \"TRUE\" : \"FALSE\", len);\n\t\tbreak;\n\tcase EQFUNCTION:\n\t\tast_copy_string(buf, (fnum1 == fnum2) ? \"TRUE\" : \"FALSE\", len);\n\t\tbreak;\n\tdefault:\n\t\tast_log(LOG_WARNING,\n\t\t\t\t\"Something happened that neither of us should be proud of %d\\n\",\n\t\t\t\tiaction);\n\t\treturn -1;\n\t}\n\tif (iaction < GTFUNCTION || iaction > EQFUNCTION) {\n\t\tif (type_of_result == FLOAT_RESULT)\n\t\t\tsnprintf(buf, len, \"%f\", ftmp);\n\t\telse if (type_of_result == INT_RESULT)\n\t\t\tsnprintf(buf, len, \"%i\", (int) ftmp);\n\t\telse if (type_of_result == HEX_RESULT)\n\t\t\tsnprintf(buf, len, \"%x\", (unsigned int) ftmp);\n\t\telse if (type_of_result == CHAR_RESULT)\n\t\t\tsnprintf(buf, len, \"%c\", (unsigned char) ftmp);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1582}
{"project": "Asterisk", "target": 0, "func": "static int reload_module(void)\n{\n\tast_sorcery_reload_object(ast_sip_get_sorcery(), \"identify\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 1583}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int volume_callback(struct ast_audiohook *audiohook, struct ast_channel *chan, struct ast_frame *frame, enum ast_audiohook_direction direction)\n{\n\tstruct ast_datastore *datastore = NULL;\n\tstruct volume_information *vi = NULL;\n\tint *gain = NULL;\n\t\n\tif (audiohook->status == AST_AUDIOHOOK_STATUS_DONE)\n\t\treturn 0;\n\t\n\tif (!(datastore = ast_channel_datastore_find(chan, &volume_datastore, NULL)))\n\t\treturn 0;\n\tvi = datastore->data;\n\t\n\tif (ast_test_flag(vi, VOLUMEFLAG_CHANGE)) {\n\t\tif (frame->frametype == AST_FRAME_DTMF) {\n\t\t\t\n\t\t\tif (direction != AST_AUDIOHOOK_DIRECTION_READ)\n\t\t\t\treturn 0; \n\t\t\tif (frame->subclass.integer == '*') {\n\t\t\t\tvi->tx_gain += 1;\n\t\t\t\tvi->rx_gain += 1;\n\t\t\t} else if (frame->subclass.integer == '#') {\n\t\t\t\tvi->tx_gain -= 1;\n\t\t\t\tvi->rx_gain -= 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (frame->frametype == AST_FRAME_VOICE) {\n\t\t\n\t\tif (!(gain = (direction == AST_AUDIOHOOK_DIRECTION_READ) ? &vi->rx_gain : &vi->tx_gain) || !*gain)\n\t\t\treturn 0;\n\t\t\n\t\tast_frame_adjust_volume(frame, *gain);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1584}
{"project": "Asterisk", "target": 0, "func": "static void stasis_bridging_cleanup(void)\n{\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_bridge_snapshot_type);\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_bridge_merge_message_type);\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_channel_entered_bridge_type);\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_channel_left_bridge_type);\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_blind_transfer_type);\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_attended_transfer_type);\n\tao2_cleanup(bridge_cache_all);\n\tbridge_cache_all = NULL;\n}\n", "bug_type": null, "idx": 1585}
{"project": "Asterisk", "target": 0, "func": "\nDListNode* dListInsertAfter \n(OOCTXT* pctxt, DList* pList, DListNode* node, const void* pData)\n{\n   DListNode* pListNode = (DListNode*) memAlloc (pctxt, sizeof(DListNode));\n   if (0 != pListNode) {\n      pListNode->data = (void*)pData;\n      if (node == 0) { \n         pListNode->next = pList->head;\n         pListNode->prev = (DListNode*) 0;\n         if (pList->head != 0) {\n            pList->head->prev = pListNode;\n         }\n         if (pList->tail == 0) {\n            pList->tail = pListNode;\n         }\n         pList->head = pListNode;\n      }\n      else if (node == pList->tail) { \n         pListNode->next = (DListNode*) 0;\n         if (0 != pList->tail) {\n            pList->tail->next = pListNode;\n            pListNode->prev = pList->tail;\n         }\n         if (0 == pList->head) {\n            pList->head = pListNode;\n            pListNode->prev = (DListNode*) 0;\n         }\n         pList->tail = pListNode;\n      }\n      else { \n         pListNode->next = node->next;\n         pListNode->prev = node;\n         node->next = pListNode;\n         \n         pListNode->next->prev = pListNode;\n      }\n      pList->count++;\n   }\n   return pListNode;\n}\n", "bug_type": null, "idx": 1586}
{"project": "Asterisk", "target": 0, "func": "static void destroy_parked_user(void *obj)\n{\n\tstruct parked_user *pu = obj;\n\tao2_cleanup(pu->lot);\n\tao2_cleanup(pu->retriever);\n\tast_free(pu->parker_dial_string);\n}\n", "bug_type": null, "idx": 1587}
{"project": "Asterisk", "target": 0, "func": "static int analog_alloc_sub(struct analog_pvt *p, enum analog_sub x)\n{\n\tif (analog_callbacks.allocate_sub) {\n\t\tint res;\n\t\tres = analog_callbacks.allocate_sub(p->chan_pvt, x);\n\t\tif (!res) {\n\t\t\tp->subs[x].allocd = 1;\n\t\t}\n\t\treturn res;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1588}
{"project": "Asterisk", "target": 0, "func": "#if defined(HAVE_SS7)\nstatic char *handle_ss7_mtp3_restart(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint linkset;\n\tunsigned int slc = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"ss7 restart mtp3\";\n\t\te->usage =\n\t\t\t\"Usage: ss7 restart mtp3 <linkset> <slc>\\n\"\n\t\t\t\"       Restart link\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc < 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tlinkset = atoi(a->argv[3]);\n\tif ((linkset < 1) || (linkset > NUM_SPANS)) {\n\t\tast_cli(a->fd, \"Invalid linkset %s.  Should be a number %d to %d\\n\", a->argv[2], 1, NUM_SPANS);\n\t\treturn CLI_SUCCESS;\n\t}\n\tif (!linksets[linkset-1].ss7.ss7) {\n\t\tast_cli(a->fd, \"No SS7 running on linkset %d\\n\", linkset);\n\t\treturn CLI_SUCCESS;\n\t}\n\tslc = atoi(a->argv[4]);\n\tast_mutex_lock(&linksets[linkset-1].ss7.lock);\n\tmtp3_init_restart(linksets[linkset-1].ss7.ss7, slc);\n\tast_mutex_unlock(&linksets[linkset-1].ss7.lock);\n\t\n\tif (linksets[linkset-1].ss7.master != AST_PTHREADT_NULL) {\n\t\tpthread_kill(linksets[linkset-1].ss7.master, SIGURG);\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1589}
{"project": "Asterisk", "target": 0, "func": "\nstatic int ast_channel_cmp_cb(void *obj, void *arg, int flags)\n{\n\tast_log(LOG_ERROR, \"BUG! Should never be called!\\n\");\n\treturn CMP_STOP;\n}\n", "bug_type": null, "idx": 1590}
{"project": "Asterisk", "target": 0, "func": "static void cache_update_cb(void *data, struct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tstruct stasis_cache_update *update = stasis_message_data(message);\n\tstruct ast_endpoint_snapshot *old_snapshot;\n\tstruct ast_endpoint_snapshot *new_snapshot;\n\tif (ast_endpoint_snapshot_type() != update->type) {\n\t\treturn;\n\t}\n\told_snapshot = stasis_message_data(update->old_snapshot);\n\tnew_snapshot = stasis_message_data(update->new_snapshot);\n\thandle_endpoint_update(old_snapshot, new_snapshot);\n}\n", "bug_type": null, "idx": 1591}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpEnableDTMFH245Signal()\n{\n   return ooCapabilityEnableDTMFH245Signal(NULL);\n}\n", "bug_type": null, "idx": 1592}
{"project": "Asterisk", "target": 0, "func": "struct ast_filestream *ast_channel_stream(const struct ast_channel *chan)\n{\n\treturn chan->stream;\n}\n", "bug_type": null, "idx": 1593}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_channels_play_with_id_parse_body(\n\tstruct ast_json *body,\n\tstruct ast_ari_channels_play_with_id_args *args)\n{\n\tstruct ast_json *field;\n\t\n\tfield = ast_json_object_get(body, \"media\");\n\tif (field) {\n\t\t\n\t\tast_free(args->media);\n\t\tif (ast_json_typeof(field) == AST_JSON_ARRAY) {\n\t\t\t\n\t\t\tsize_t i;\n\t\t\targs->media_count = ast_json_array_size(field);\n\t\t\targs->media = ast_malloc(sizeof(*args->media) * args->media_count);\n\t\t\tif (!args->media) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < args->media_count; ++i) {\n\t\t\t\targs->media[i] = ast_json_string_get(ast_json_array_get(field, i));\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\targs->media_count = 1;\n\t\t\targs->media = ast_malloc(sizeof(*args->media) * args->media_count);\n\t\t\tif (!args->media) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\targs->media[0] = ast_json_string_get(field);\n\t\t}\n\t}\n\tfield = ast_json_object_get(body, \"lang\");\n\tif (field) {\n\t\targs->lang = ast_json_string_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"offsetms\");\n\tif (field) {\n\t\targs->offsetms = ast_json_integer_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"skipms\");\n\tif (field) {\n\t\targs->skipms = ast_json_integer_get(field);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1594}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_sched_is_task_running(struct ast_sip_sched_task *schtd)\n{\n\tif (!schtd) {\n\t\treturn 0;\n\t}\n\treturn schtd->is_running;\n}\n", "bug_type": null, "idx": 1595}
{"project": "Asterisk", "target": 0, "func": "static int unbound_config_preapply(struct unbound_config *cfg)\n{\n\tint res = 0;\n\tcfg->global->state = ao2_alloc_options(sizeof(*cfg->global->state), unbound_config_state_destructor,\n\t\tAO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!cfg->global->state) {\n\t\tast_log(LOG_ERROR, \"Could not allocate unbound resolver state structure\\n\");\n\t\treturn -1;\n\t}\n\tcfg->global->state->resolver = unbound_resolver_alloc();\n\tif (!cfg->global->state->resolver) {\n\t\tast_log(LOG_ERROR, \"Could not create an unbound resolver\\n\");\n\t\treturn -1;\n\t}\n\tub_ctx_debuglevel(cfg->global->state->resolver->context, cfg->global->debug);\n\tif (!strcmp(cfg->global->hosts, \"system\")) {\n\t\tres = ub_ctx_hosts(cfg->global->state->resolver->context, NULL);\n\t} else if (!ast_strlen_zero(cfg->global->hosts)) {\n\t\tres = ub_ctx_hosts(cfg->global->state->resolver->context, (UNBOUND_CHAR *)cfg->global->hosts);\n\t}\n\tif (res) {\n\t\tast_log(LOG_ERROR, \"Failed to set hosts file to '%s' in unbound resolver: %s\\n\",\n\t\t\tcfg->global->hosts, ub_strerror(res));\n\t\treturn -1;\n\t}\n\tif (cfg->global->nameservers) {\n\t\tstruct ao2_iterator it_nameservers;\n\t\tconst char *nameserver;\n\t\tit_nameservers = ao2_iterator_init(cfg->global->nameservers, 0);\n\t\twhile ((nameserver = ao2_iterator_next(&it_nameservers))) {\n\t\t\tres = ub_ctx_set_fwd(cfg->global->state->resolver->context, (UNBOUND_CHAR *)nameserver);\n\t\t\tif (res) {\n\t\t\t\tast_log(LOG_ERROR, \"Failed to add nameserver '%s' to unbound resolver: %s\\n\",\n\t\t\t\t\tnameserver, ub_strerror(res));\n\t\t\t\tao2_iterator_destroy(&it_nameservers);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tao2_iterator_destroy(&it_nameservers);\n\t}\n\tif (!strcmp(cfg->global->resolv, \"system\")) {\n\t\tres = ub_ctx_resolvconf(cfg->global->state->resolver->context, NULL);\n\t} else if (!ast_strlen_zero(cfg->global->resolv)) {\n\t\tres = ub_ctx_resolvconf(cfg->global->state->resolver->context, (UNBOUND_CHAR *)cfg->global->resolv);\n\t}\n\tif (res) {\n\t\tast_log(LOG_ERROR, \"Failed to set resolv.conf file to '%s' in unbound resolver: %s\\n\",\n\t\t\tcfg->global->resolv, ub_strerror(res));\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(cfg->global->ta_file)) {\n\t\tres = ub_ctx_add_ta_file(cfg->global->state->resolver->context, (UNBOUND_CHAR *)cfg->global->ta_file);\n\t\tif (res) {\n\t\t\tast_log(LOG_ERROR, \"Failed to set trusted anchor file to '%s' in unbound resolver: %s\\n\",\n\t\t\t\tcfg->global->ta_file, ub_strerror(res));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (unbound_resolver_start(cfg->global->state->resolver)) {\n\t\tast_log(LOG_ERROR, \"Could not start unbound resolver thread\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1596}
{"project": "Asterisk", "target": 0, "func": "static void dahdi_close_sub(struct dahdi_pvt *chan_pvt, int sub_num)\n{\n\tdahdi_close(chan_pvt->subs[sub_num].dfd);\n\tchan_pvt->subs[sub_num].dfd = -1;\n}\n", "bug_type": null, "idx": 1597}
{"project": "Asterisk", "target": 0, "func": "private int\nhistory_def_enter(ptr_t p, HistEvent *ev, const char *str)\n{\n\thistory_t *h = (history_t *) p;\n\tif (history_def_insert(h, ev, str) == -1)\n\t\treturn (-1);\t\n\t\n\twhile (h->cur > h->max && h->cur > 0)\n\t\thistory_def_delete(h, ev, h->list.prev);\n\treturn (0);\n}\n", "bug_type": null, "idx": 1598}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225GatekeeperRequest_algorithmOIDs (OOCTXT* pctxt, H225GatekeeperRequest_algorithmOIDs* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT xx1;\n   \n   stat = decodeLength (pctxt, &pvalue->n);\n   if (stat != ASN_OK) return stat;\n   \n   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1OBJID);\n   for (xx1 = 0; xx1 < pvalue->n; xx1++) {\n      invokeStartElement (pctxt, \"elem\", xx1);\n      stat = decodeObjectIdentifier (pctxt, &pvalue->elem[xx1]);\n      if (stat != ASN_OK) return stat;\n      invokeOidValue (pctxt, pvalue->elem[xx1].numids, pvalue->elem[xx1].subid);\n      invokeEndElement (pctxt, \"elem\", xx1);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1599}
{"project": "Asterisk", "target": 0, "func": "\nstatic int show_dialplan_helper(int fd, const char *context, const char *exten, struct dialplan_counters *dpc, const struct ast_include *rinclude, int includecount, const char *includes[])\n{\n\tstruct ast_context *c = NULL;\n\tint res = 0, old_total_exten = dpc->total_exten;\n\tast_rdlock_contexts();\n\t\n\twhile ( (c = ast_walk_contexts(c)) ) {\n\t\tint idx;\n\t\tstruct ast_exten *e;\n#ifndef LOW_MEMORY\n\t\tchar buf[1024], buf2[1024];\n#else\n\t\tchar buf[256], buf2[256];\n#endif\n\t\tint context_info_printed = 0;\n\t\tif (context && strcmp(ast_get_context_name(c), context))\n\t\t\tcontinue;\t\n\t\tdpc->context_existence = 1;\n\t\tast_rdlock_context(c);\n\t\t\n\t\tif (!exten) {\n\t\t\tdpc->total_context++;\n\t\t\tast_cli(fd, \"[ Context '%s' created by '%s' ]\\n\",\n\t\t\t\tast_get_context_name(c), ast_get_context_registrar(c));\n\t\t\tif (c->autohints) {\n\t\t\t\tast_cli(fd, \"Autohints support enabled\\n\");\n\t\t\t}\n\t\t\tcontext_info_printed = 1;\n\t\t}\n\t\t\n\t\te = NULL;\n\t\twhile ( (e = ast_walk_context_extensions(c, e)) ) {\n\t\t\tstruct ast_exten *p;\n\t\t\tif (exten && !ast_extension_match(ast_get_extension_name(e), exten))\n\t\t\t\tcontinue;\t\n\t\t\tdpc->extension_existence = 1;\n\t\t\t\n\t\t\tif (!context_info_printed) {\n\t\t\t\tdpc->total_context++;\n\t\t\t\tif (rinclude) { \n\t\t\t\t\tast_cli(fd, \"[ Included context '%s' created by '%s' ]\\n\",\n\t\t\t\t\t\tast_get_context_name(c), ast_get_context_registrar(c));\n\t\t\t\t} else {\n\t\t\t\t\tast_cli(fd, \"[ Context '%s' created by '%s' ]\\n\",\n\t\t\t\t\t\tast_get_context_name(c), ast_get_context_registrar(c));\n\t\t\t\t\tif (c->autohints) {\n\t\t\t\t\t\tast_cli(fd, \"Autohints support enabled\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontext_info_printed = 1;\n\t\t\t}\n\t\t\tdpc->total_prio++;\n\t\t\t\n\t\t\tif (e->matchcid == AST_EXT_MATCHCID_ON)\n\t\t\t\tsnprintf(buf, sizeof(buf), \"'%s' (CID match '%s') => \", ast_get_extension_name(e), e->cidmatch);\n\t\t\telse\n\t\t\t\tsnprintf(buf, sizeof(buf), \"'%s' =>\", ast_get_extension_name(e));\n\t\t\tprint_ext(e, buf2, sizeof(buf2));\n\t\t\tshow_dialplan_helper_extension_output(fd, buf, buf2, e);\n\t\t\tdpc->total_exten++;\n\t\t\t\n\t\t\tp = e;\t\n\t\t\twhile ( (p = ast_walk_extension_priorities(e, p)) ) {\n\t\t\t\tconst char *el = ast_get_extension_label(p);\n\t\t\t\tdpc->total_prio++;\n\t\t\t\tif (el)\n\t\t\t\t\tsnprintf(buf, sizeof(buf), \"   [%s]\", el);\n\t\t\t\telse\n\t\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tprint_ext(p, buf2, sizeof(buf2));\n\t\t\t\tshow_dialplan_helper_extension_output(fd, buf, buf2, p);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (idx = 0; idx < ast_context_includes_count(c); idx++) {\n\t\t\tconst struct ast_include *i = ast_context_includes_get(c, idx);\n\t\t\tsnprintf(buf, sizeof(buf), \"'%s'\", ast_get_include_name(i));\n\t\t\tif (exten) {\n\t\t\t\t\n\t\t\t\tif (includecount >= AST_PBX_MAX_STACK) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Maximum include depth exceeded!\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint dupe = 0;\n\t\t\t\t\tint x;\n\t\t\t\t\tfor (x = 0; x < includecount; x++) {\n\t\t\t\t\t\tif (!strcasecmp(includes[x], ast_get_include_name(i))) {\n\t\t\t\t\t\t\tdupe++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!dupe) {\n\t\t\t\t\t\tincludes[includecount] = ast_get_include_name(i);\n\t\t\t\t\t\tshow_dialplan_helper(fd, ast_get_include_name(i), exten, dpc, i, includecount + 1, includes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Avoiding circular include of %s within %s\\n\", ast_get_include_name(i), context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_cli(fd, \"  Include =>        %-45s [%s]\\n\",\n\t\t\t\t\tbuf, ast_get_include_registrar(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (idx = 0; idx < ast_context_ignorepats_count(c); idx++) {\n\t\t\tconst struct ast_ignorepat *ip = ast_context_ignorepats_get(c, idx);\n\t\t\tconst char *ipname = ast_get_ignorepat_name(ip);\n\t\t\tchar ignorepat[AST_MAX_EXTENSION];\n\t\t\tsnprintf(buf, sizeof(buf), \"'%s'\", ipname);\n\t\t\tsnprintf(ignorepat, sizeof(ignorepat), \"_%s.\", ipname);\n\t\t\tif (!exten || ast_extension_match(ignorepat, exten)) {\n\t\t\t\tast_cli(fd, \"  Ignore pattern => %-45s [%s]\\n\",\n\t\t\t\t\tbuf, ast_get_ignorepat_registrar(ip));\n\t\t\t}\n\t\t}\n\t\tif (!rinclude) {\n\t\t\tfor (idx = 0; idx < ast_context_switches_count(c); idx++) {\n\t\t\t\tconst struct ast_sw *sw = ast_context_switches_get(c, idx);\n\t\t\t\tsnprintf(buf, sizeof(buf), \"'%s/%s'\",\n\t\t\t\t\tast_get_switch_name(sw),\n\t\t\t\t\tast_get_switch_data(sw));\n\t\t\t\tast_cli(fd, \"  Alt. Switch =>    %-45s [%s]\\n\",\n\t\t\t\t\tbuf, ast_get_switch_registrar(sw));\n\t\t\t}\n\t\t}\n\t\tast_unlock_context(c);\n\t\t\n\t\tif (context_info_printed)\n\t\t\tast_cli(fd, \"\\n\");\n\t}\n\tast_unlock_contexts();\n\treturn (dpc->total_exten == old_total_exten) ? -1 : res;\n}\n", "bug_type": null, "idx": 1600}
{"project": "Asterisk", "target": 0, "func": "static void qualify_data_destroy(struct qualify_data *qual_data)\n{\n\tao2_cleanup(qual_data->endpoint);\n\tast_free(qual_data);\n}\n", "bug_type": null, "idx": 1601}
{"project": "Asterisk", "target": 0, "func": "const char *ast_sdp_srtp_get_attrib(struct ast_sdp_srtp *srtp, int dtls_enabled, int default_taglen_32)\n{\n\tif (!sdp_crypto_api) {\n\t\treturn NULL;\n\t}\n\treturn sdp_crypto_api->get_attr(srtp, dtls_enabled, default_taglen_32);\n}\n", "bug_type": null, "idx": 1602}
{"project": "Asterisk", "target": 0, "func": "static struct ast_config_include *ast_include_find(struct ast_config *conf, const char *included_file)\n{\n\tstruct ast_config_include *x;\n\tfor (x=conf->includes;x;x=x->next)\n\t{\n\t\tif (strcmp(x->included_file,included_file) == 0)\n\t\t\treturn x;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1603}
{"project": "Asterisk", "target": 0, "func": "static int user_set_unmuted_cb(void *obj, void *check_admin_arg, int flags)\n{\n\tstruct ast_conf_user *user = obj;\n\t\n\tif (!check_admin_arg || !ast_test_flag64(&user->userflags, CONFFLAG_ADMIN)) {\n\t\tuser->adminflags &= ~(ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED | ADMINFLAG_T_REQUEST);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1604}
{"project": "Asterisk", "target": 0, "func": "static void wait_for_digits(struct chan_list *ch, struct misdn_bchannel *bc, struct ast_channel *chan)\n{\n\tch->state = MISDN_WAITING4DIGS;\n\tmisdn_lib_send_event(bc, EVENT_SETUP_ACKNOWLEDGE);\n\tif (bc->nt && !bc->dialed.number[0]) {\n\t\tdialtone_indicate(ch);\n\t}\n}\n", "bug_type": null, "idx": 1605}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225ServiceControlSession (OOCTXT* pctxt, H225ServiceControlSession* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.contentsPresent = optbit;\n   \n   invokeStartElement (pctxt, \"sessionId\", -1);\n   stat = decodeConsUInt8 (pctxt, &pvalue->sessionId, 0U, 255U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->sessionId);\n   invokeEndElement (pctxt, \"sessionId\", -1);\n   \n   if (pvalue->m.contentsPresent) {\n      invokeStartElement (pctxt, \"contents\", -1);\n      stat = asn1PD_H225ServiceControlDescriptor (pctxt, &pvalue->contents);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"contents\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"reason\", -1);\n   stat = asn1PD_H225ServiceControlSession_reason (pctxt, &pvalue->reason);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"reason\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1606}
{"project": "Asterisk", "target": 0, "func": "    *---------------------------------------------------------------*/\n   void index_conv_enc(\n       int *index          \n   ){\n       int k;\n       for (k=1; k<CB_NSTAGES; k++) {\n           if ((index[k]>=108)&&(index[k]<172)) {\n               index[k]-=64;\n           } else if (index[k]>=236) {\n               index[k]-=128;\n           } else {\n               \n           }\n       }\n   }\n", "bug_type": null, "idx": 1607}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tif (timing_funcs_handle) {\n\t\treturn ast_unregister_timing_interface(timing_funcs_handle);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1608}
{"project": "Asterisk", "target": 0, "func": "static int bridge_basic_push(struct ast_bridge *self, struct ast_bridge_channel *bridge_channel, struct ast_bridge_channel *swap)\n{\n\tstruct bridge_basic_personality *personality = self->personality;\n\tast_assert(personality != NULL);\n\tif (personality->details[personality->current].v_table->push\n\t\t&& personality->details[personality->current].v_table->push(self, bridge_channel, swap)) {\n\t\treturn -1;\n\t}\n\tast_bridge_channel_update_linkedids(bridge_channel, swap);\n\tast_bridge_channel_update_accountcodes(bridge_channel, swap);\n\treturn ast_bridge_base_v_table.push(self, bridge_channel, swap);\n}\n", "bug_type": null, "idx": 1609}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tint num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!yyg->yy_buffer_stack) {\n\t\t\n\t\tnum_to_alloc = 1;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)ast_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in ast_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\t\t\n\t\tint grow_size = 8 ;\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)ast_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in ast_yyensure_buffer_stack()\" );\n\t\t\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}\n", "bug_type": null, "idx": 1610}
{"project": "Asterisk", "target": 0, "func": " */\nstatic const char *counted_noun_ending_slavic(int num)\n{\n\tif (num < 0) {\n\t    num *= -1;\n\t}\n\tnum %= 100;\t\t\t\n\tif (num >= 20) {\t\t\n\t    num %= 10;\n\t}\n\tif (num == 1) {\t\t\t\n\t    return \"\";\n\t}\n\tif (num > 0 && num < 5) {\t\n\t    return \"x1\";\n\t} else {\t\t\t\n\t    return \"x2\";\n\t}\n}\n", "bug_type": null, "idx": 1611}
{"project": "Asterisk", "target": 0, "func": "static struct ast_category *next_available_category(struct ast_category *cat)\n{\n\tfor (; cat && cat->ignored; cat = cat->next);\n\treturn cat;\n}\n", "bug_type": null, "idx": 1612}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1613}
{"project": "Asterisk", "target": 0, "func": "static void dec_ie_redir_nr(unsigned char *p, Q931_info_t *qi, int *type, int *plan, int *present, int *screen, int *reason, char *number, size_t number_len, int nt, struct misdn_bchannel *bc)\n{\n\t*type = -1;\n\t*plan = -1;\n\t*present = -1;\n\t*screen = -1;\n\t*reason = -1;\n\t*number = '\\0';\n\tif (!nt)\n\t{\n\t\tp = NULL;\n\t\tif (qi->QI_ELEMENT(redirect_nr))\n\t\t\tp = (unsigned char *)qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(redirect_nr) + 1;\n\t}\n\tif (!p)\n\t\treturn;\n\tif (p[0] < 1)\n\t{\n\t\tprintf(\"%s: ERROR: IE too short (%d).\\n\", __FUNCTION__, p[0]);\n\t\treturn;\n\t}\n\t*type = (p[1]&0x70) >> 4;\n\t*plan = p[1] & 0xf;\n\tif (!(p[1] & 0x80))\n\t{\n\t\t*present = (p[2]&0x60) >> 5;\n\t\t*screen = p[2] & 0x3;\n\t\tif (!(p[2] & 0x80))\n\t\t{\n\t\t\t*reason = p[3] & 0x0f;\n\t\t\tstrnncpy(number, (char *)p+4, p[0]-3, number_len);\n\t\t} else\n\t\t{\n\t\t\tstrnncpy(number, (char *)p+3, p[0]-2, number_len);\n\t\t}\n\t} else\n\t{\n\t\tstrnncpy(number, (char *)p+2, p[0]-1, number_len);\n\t}\n\tif (MISDN_IE_DEBG) printf(\"    type=%d plan=%d present=%d screen=%d reason=%d number='%s'\\n\", *type, *plan, *present, *screen, *reason, number);\n}\n", "bug_type": null, "idx": 1614}
{"project": "Asterisk", "target": 0, "func": "static int find_matching_endwhile(struct ast_channel *chan)\n{\n\tstruct ast_context *c;\n\tint res=-1;\n\tif (ast_rdlock_contexts()) {\n\t\tast_log(LOG_ERROR, \"Failed to lock contexts list\\n\");\n\t\treturn -1;\n\t}\n\tfor (c=ast_walk_contexts(NULL); c; c=ast_walk_contexts(c)) {\n\t\tstruct ast_exten *e;\n\t\tif (!ast_rdlock_context(c)) {\n\t\t\tif (!strcmp(ast_get_context_name(c), ast_channel_context(chan))) {\n\t\t\t\t\n\t\t\t\tint cur_priority = ast_channel_priority(chan) + 1, level=1;\n\t\t\t\tfor (e = find_matching_priority(c, ast_channel_exten(chan), cur_priority,\n\t\t\t\t\tS_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL));\n\t\t\t\t\te;\n\t\t\t\t\te = find_matching_priority(c, ast_channel_exten(chan), ++cur_priority,\n\t\t\t\t\t\tS_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL))) {\n\t\t\t\t\tif (!strcasecmp(ast_get_extension_app(e), \"WHILE\")) {\n\t\t\t\t\t\tlevel++;\n\t\t\t\t\t} else if (!strcasecmp(ast_get_extension_app(e), \"ENDWHILE\")) {\n\t\t\t\t\t\tlevel--;\n\t\t\t\t\t}\n\t\t\t\t\tif (level == 0) {\n\t\t\t\t\t\tres = cur_priority;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_unlock_context(c);\n\t\t\tif (res > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tast_unlock_contexts();\n\treturn res;\n}\n", "bug_type": null, "idx": 1615}
{"project": "Asterisk", "target": 0, "func": "void *ast_aoc_destroy_encoded(struct ast_aoc_encoded *encoded)\n{\n\tast_free(encoded);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1616}
{"project": "Asterisk", "target": 0, "func": "static int parse_dtls_attrib(struct ast_sip_session_media *session_media,\n\tconst struct pjmedia_sdp_session *sdp,\n\tconst struct pjmedia_sdp_media *stream)\n{\n\tint i;\n\tfor (i = 0; i < sdp->attr_count; i++) {\n\t\tapply_dtls_attrib(session_media, sdp->attr[i]);\n\t}\n\tfor (i = 0; i < stream->attr_count; i++) {\n\t\tapply_dtls_attrib(session_media, stream->attr[i]);\n\t}\n\tast_set_flag(session_media->srtp, AST_SRTP_CRYPTO_OFFER_OK);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1617}
{"project": "Asterisk", "target": 0, "func": "const struct ast_eid *stasis_message_eid(const struct stasis_message *msg)\n{\n\tif (msg == NULL) {\n\t\treturn NULL;\n\t}\n\treturn msg->eid_ptr;\n}\n", "bug_type": null, "idx": 1618}
{"project": "Asterisk", "target": 0, "func": "int ooGetIpPortFromH245TransportAddress\n   (OOH323CallData *call, H245TransportAddress *h245Address, char *ip, \n    int *port)\n{\n   H245UnicastAddress *unicastAddress = NULL;\n   H245UnicastAddress_iPAddress *ipAddress = NULL;\n   H245UnicastAddress_iP6Address *ip6Address = NULL;\n   regmatch_t pmatch[1];\n   if(h245Address->t != T_H245TransportAddress_unicastAddress)\n   {\n      OOTRACEERR3(\"ERROR:Unsupported H245 address type \"\n                           \"(%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n   } \n   unicastAddress = h245Address->u.unicastAddress;\n   if (call->versionIP == 6) {\n\tif (unicastAddress->t != T_H245UnicastAddress_iP6Address) {\n      \t\tOOTRACEERR3(\"ERROR:H245 Address type is not IP6\"\n                   \"(%s, %s)\\n\", call->callType, call->callToken);\n      \t\treturn OO_FAILED;\n\t}\n\tip6Address = unicastAddress->u.iP6Address;\n\t*port = ip6Address->tsapIdentifier;\n\tinet_ntop(AF_INET6, ip6Address->network.data, ip, INET6_ADDRSTRLEN);\n   } else { if(unicastAddress->t != T_H245UnicastAddress_iPAddress)\n   {\n      OOTRACEERR3(\"ERROR:H245 Address type is not IP\"\n                   \"(%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   ipAddress = unicastAddress->u.iPAddress;\n   *port = ipAddress->tsapIdentifier;\n   inet_ntop(AF_INET,  ipAddress->network.data, ip, INET_ADDRSTRLEN);\n   }\n   if (call->rtpMaskStr[0]) {\n     if (regexec(&call->rtpMask->regex, ip, 1, pmatch, 0)) {\n\t\tOOTRACEERR5(\"ERROR:H245 Address is not matched with filter %s/%s\"\n\t\t\t\"(%s, %s)\\n\", ip, call->rtpMaskStr, call->callType, call->callToken);\n\t return OO_FAILED;\n\t}\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1619}
{"project": "Asterisk", "target": 0, "func": "void ast_res_pjsip_cleanup_options_handling(void)\n{\n\tast_cli_unregister_multiple(cli_options, ARRAY_LEN(cli_options));\n\tast_manager_unregister(\"PJSIPQualify\");\n\tinternal_sip_unregister_endpoint_formatter(&contact_status_formatter);\n\tast_sorcery_observer_remove(ast_sip_get_sorcery(), \"aor\", &observer_callbacks_options);\n\tpjsip_endpt_unregister_module(ast_sip_get_pjsip_endpoint(), &options_module);\n\tao2_cleanup(sched_qualifies);\n\tsched_qualifies = NULL;\n}\n", "bug_type": null, "idx": 1620}
{"project": "Asterisk", "target": 0, "func": "static int reload(void)\n{\n\tif (aco_process_config(&cfg_info, 1) == ACO_PROCESS_ERROR) {\n\t\t\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1621}
{"project": "Asterisk", "target": 0, "func": "static struct ast_context *ast_context_find_or_create(struct ast_context **extcontexts, void *tab, const char *name, const char *registrar)\n{\n\treturn __ast_context_create(extcontexts, name, registrar, 1);\n}\n", "bug_type": null, "idx": 1622}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_features_remove(struct ast_bridge_features *features, enum ast_bridge_hook_remove_flags remove_flags)\n{\n\thooks_remove_container(features->dtmf_hooks, remove_flags);\n\thooks_remove_container(features->other_hooks, remove_flags);\n\thooks_remove_heap(features->interval_hooks, remove_flags);\n}\n", "bug_type": null, "idx": 1623}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_frame *lintogsm_frameout(struct ast_trans_pvt *pvt)\n{\n\tstruct gsm_translator_pvt *tmp = pvt->pvt;\n\tstruct ast_frame *result = NULL;\n\tstruct ast_frame *last = NULL;\n\tint samples = 0; \n\twhile (pvt->samples >= GSM_SAMPLES) {\n\t\tstruct ast_frame *current;\n\t\t\n\t\tgsm_encode(tmp->gsm, tmp->buf + samples, (gsm_byte *) pvt->outbuf.c);\n\t\tsamples += GSM_SAMPLES;\n\t\tpvt->samples -= GSM_SAMPLES;\n\t\tcurrent = ast_trans_frameout(pvt, GSM_FRAME_LEN, GSM_SAMPLES);\n\t\tif (!current) {\n\t\t\tcontinue;\n\t\t} else if (last) {\n\t\t\tAST_LIST_NEXT(last, frame_list) = current;\n\t\t} else {\n\t\t\tresult = current;\n\t\t}\n\t\tlast = current;\n\t}\n\t\n\tif (samples) {\n\t\tmemmove(tmp->buf, tmp->buf + samples, pvt->samples * 2);\n\t}\n\treturn result;\n}\n", "bug_type": null, "idx": 1624}
{"project": "Asterisk", "target": 0, "func": "static void destroy_hooks(struct ast_channel *chan)\n{\n\tif (ast_channel_audiohooks(chan)) {\n\t\tast_audiohook_detach_list(ast_channel_audiohooks(chan));\n\t\tast_channel_audiohooks_set(chan, NULL);\n\t}\n\tast_framehook_list_destroy(chan);\n}\n", "bug_type": null, "idx": 1625}
{"project": "Asterisk", "target": 0, "func": "static void rtp_ice_wrap_stop(struct ast_rtp_instance *instance)\n{\n\tao2_lock(instance);\n\tinstance->engine->ice->stop(instance);\n\tao2_unlock(instance);\n}\n", "bug_type": null, "idx": 1626}
{"project": "Asterisk", "target": 0, "func": "static struct ast_sorcery *alloc_and_initialize_sorcery(char *table)\n{\n\tstruct ast_sorcery *sorcery;\n\tif (!(sorcery = ast_sorcery_open())) {\n\t\treturn NULL;\n\t}\n\tif ((ast_sorcery_apply_default(sorcery, \"test\", \"realtime\", table) != AST_SORCERY_APPLY_SUCCESS) ||\n\t\tast_sorcery_internal_object_register(sorcery, \"test\", test_sorcery_object_alloc, NULL, NULL) ||\n\t\t!(realtime_objects = ast_config_new())) {\n\t\tast_sorcery_unref(sorcery);\n\t\treturn NULL;\n\t}\n\tast_sorcery_object_field_register_nodoc(sorcery, \"test\", \"bob\", \"5\", OPT_UINT_T, 0, FLDSET(struct test_sorcery_object, bob));\n\tast_sorcery_object_field_register_nodoc(sorcery, \"test\", \"joe\", \"10\", OPT_UINT_T, 0, FLDSET(struct test_sorcery_object, joe));\n\treturn sorcery;\n}\n", "bug_type": null, "idx": 1627}
{"project": "Asterisk", "target": 0, "func": "struct ast_readq_list *ast_channel_readq(struct ast_channel *chan)\n{\n\treturn &chan->readq;\n}\n", "bug_type": null, "idx": 1628}
{"project": "Asterisk", "target": 0, "func": "static void session_inv_on_rx_offer(pjsip_inv_session *inv, const pjmedia_sdp_session *offer)\n{\n\tstruct ast_sip_session *session = inv->mod_data[session_module.id];\n\tpjmedia_sdp_session *answer;\n\tif (handle_incoming_sdp(session, offer)) {\n\t\treturn;\n\t}\n\tif ((answer = create_local_sdp(inv, session, offer))) {\n\t\tpjsip_inv_set_sdp_answer(inv, answer);\n\t}\n}\n", "bug_type": null, "idx": 1629}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int pbx_builtin_proceeding(struct ast_channel *chan, const char *data)\n{\n\tast_indicate(chan, AST_CONTROL_PROCEEDING);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1630}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *ast_json_boolean(int value)\n{\n#if JANSSON_VERSION_HEX >= 0x020400\n\treturn (struct ast_json *)json_boolean(value);\n#else\n\treturn value ? ast_json_true() : ast_json_false();\n#endif\n}\n", "bug_type": null, "idx": 1631}
{"project": "Asterisk", "target": 0, "func": "#if defined(HAVE_PRI)\nstatic void dahdi_close_pri_fd(struct dahdi_pri *pri, int fd_num)\n{\n\tdahdi_close(pri->pri.fds[fd_num]);\n\tpri->pri.fds[fd_num] = -1;\n}\n", "bug_type": null, "idx": 1632}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_visible_indication_set(struct ast_channel *chan, int value)\n{\n\tchan->visible_indication = value;\n}\n", "bug_type": null, "idx": 1633}
{"project": "Asterisk", "target": 0, "func": "#define MAX_STRING_GROWTHS 5\nstatic void xpidf_to_string(void *body, struct ast_str **str)\n{\n\tpjxpidf_pres *pres = body;\n\tint growths = 0;\n\tint size;\n\tdo {\n\t\tsize = pjxpidf_print(pres, ast_str_buffer(*str), ast_str_size(*str) - 1);\n\t\tif (size <= AST_PJSIP_XML_PROLOG_LEN) {\n\t\t\tast_str_make_space(str, ast_str_size(*str) * 2);\n\t\t\t++growths;\n\t\t}\n\t} while (size <= AST_PJSIP_XML_PROLOG_LEN && growths < MAX_STRING_GROWTHS);\n\tif (size <= AST_PJSIP_XML_PROLOG_LEN) {\n\t\tast_log(LOG_WARNING, \"XPIDF body text too large\\n\");\n\t\treturn;\n\t}\n\t*(ast_str_buffer(*str) + size) = '\\0';\n\tast_str_update(*str);\n}\n", "bug_type": null, "idx": 1634}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_channels_get(struct ast_variable *headers,\n\tstruct ast_ari_channels_get_args *args,\n\tstruct ast_ari_response *response)\n{\n\tRAII_VAR(struct stasis_message *, msg, NULL, ao2_cleanup);\n\tstruct stasis_cache *cache;\n\tstruct ast_channel_snapshot *snapshot;\n\tcache = ast_channel_cache();\n\tif (!cache) {\n\t\tast_ari_response_error(\n\t\t\tresponse, 500, \"Internal Server Error\",\n\t\t\t\"Message bus not initialized\");\n\t\treturn;\n\t}\n\tmsg = stasis_cache_get(cache, ast_channel_snapshot_type(),\n\t\t\t\t   args->channel_id);\n\tif (!msg) {\n\t\tast_ari_response_error(\n\t\t\tresponse, 404, \"Not Found\",\n\t\t\t\"Channel not found\");\n\t\treturn;\n\t}\n\tsnapshot = stasis_message_data(msg);\n\tast_assert(snapshot != NULL);\n\tast_ari_response_ok(response,\n\t\t\t\tast_channel_snapshot_to_json(snapshot, NULL));\n}\n", "bug_type": null, "idx": 1635}
{"project": "Asterisk", "target": 0, "func": "static int long_normalize_overflow(long *tensptr, int *unitsptr, const int base)\n{\n\tint\ttensdelta;\n\ttensdelta = (*unitsptr >= 0) ?\n\t\t(*unitsptr / base) :\n\t\t(-1 - (-1 - *unitsptr) / base);\n\t*unitsptr -= tensdelta * base;\n\treturn long_increment_overflow(tensptr, tensdelta);\n}\n", "bug_type": null, "idx": 1636}
{"project": "Asterisk", "target": 0, "func": "static int manager_log(struct ast_cdr *cdr)\n{\n\tstruct ast_tm timeresult;\n\tchar strStartTime[80] = \"\";\n\tchar strAnswerTime[80] = \"\";\n\tchar strEndTime[80] = \"\";\n\tchar buf[CUSTOM_FIELDS_BUF_SIZE];\n\tif (!enablecdr)\n\t\treturn 0;\n\tast_localtime(&cdr->start, &timeresult, NULL);\n\tast_strftime(strStartTime, sizeof(strStartTime), DATE_FORMAT, &timeresult);\n\tif (cdr->answer.tv_sec)\t{\n\t\tast_localtime(&cdr->answer, &timeresult, NULL);\n\t\tast_strftime(strAnswerTime, sizeof(strAnswerTime), DATE_FORMAT, &timeresult);\n\t}\n\tast_localtime(&cdr->end, &timeresult, NULL);\n\tast_strftime(strEndTime, sizeof(strEndTime), DATE_FORMAT, &timeresult);\n\tbuf[0] = '\\0';\n\tast_rwlock_rdlock(&customfields_lock);\n\tif (customfields && ast_str_strlen(customfields)) {\n\t\tstruct ast_channel *dummy = ast_dummy_channel_alloc();\n\t\tif (!dummy) {\n\t\t\tast_log(LOG_ERROR, \"Unable to allocate channel for variable substitution.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tast_channel_cdr_set(dummy, ast_cdr_dup(cdr));\n\t\tpbx_substitute_variables_helper(dummy, ast_str_buffer(customfields), buf, sizeof(buf) - 1);\n\t\tast_channel_unref(dummy);\n\t}\n\tast_rwlock_unlock(&customfields_lock);\n\tmanager_event(EVENT_FLAG_CDR, \"Cdr\",\n\t    \"AccountCode: %s\\r\\n\"\n\t    \"Source: %s\\r\\n\"\n\t    \"Destination: %s\\r\\n\"\n\t    \"DestinationContext: %s\\r\\n\"\n\t    \"CallerID: %s\\r\\n\"\n\t    \"Channel: %s\\r\\n\"\n\t    \"DestinationChannel: %s\\r\\n\"\n\t    \"LastApplication: %s\\r\\n\"\n\t    \"LastData: %s\\r\\n\"\n\t    \"StartTime: %s\\r\\n\"\n\t    \"AnswerTime: %s\\r\\n\"\n\t    \"EndTime: %s\\r\\n\"\n\t    \"Duration: %ld\\r\\n\"\n\t    \"BillableSeconds: %ld\\r\\n\"\n\t    \"Disposition: %s\\r\\n\"\n\t    \"AMAFlags: %s\\r\\n\"\n\t    \"UniqueID: %s\\r\\n\"\n\t    \"UserField: %s\\r\\n\"\n\t    \"%s\",\n\t    cdr->accountcode, cdr->src, cdr->dst, cdr->dcontext, cdr->clid, cdr->channel,\n\t    cdr->dstchannel, cdr->lastapp, cdr->lastdata, strStartTime, strAnswerTime, strEndTime,\n\t    cdr->duration, cdr->billsec, ast_cdr_disp2str(cdr->disposition),\n\t    ast_channel_amaflags2string(cdr->amaflags), cdr->uniqueid, cdr->userfield,buf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1637}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_endpoint(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_channel_ids = 0;\n\tint has_resource = 0;\n\tint has_technology = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"channel_ids\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_channel_ids = 1;\n\t\t\tprop_is_valid = ast_ari_validate_list(\n\t\t\t\tast_json_object_iter_value(iter),\n\t\t\t\tast_ari_validate_string);\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Endpoint field channel_ids failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"resource\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_resource = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Endpoint field resource failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"state\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Endpoint field state failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"technology\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_technology = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Endpoint field technology failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI Endpoint has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_channel_ids) {\n\t\tast_log(LOG_ERROR, \"ARI Endpoint missing required field channel_ids\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_resource) {\n\t\tast_log(LOG_ERROR, \"ARI Endpoint missing required field resource\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_technology) {\n\t\tast_log(LOG_ERROR, \"ARI Endpoint missing required field technology\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1638}
{"project": "Asterisk", "target": 0, "func": "struct ast_flags *ast_bridge_features_ds_get(struct ast_channel *chan)\n{\n\tstruct ast_datastore *datastore;\n\tdatastore = ast_channel_datastore_find(chan, &dtmf_features_info, NULL);\n\tif (!datastore) {\n\t\treturn NULL;\n\t}\n\treturn datastore->data;\n}\n", "bug_type": null, "idx": 1639}
{"project": "Asterisk", "target": 0, "func": "static int show_message(char *title, char *msg)\n{\n\tnewtComponent form;\n\tnewtComponent label;\n\tnewtComponent ok;\n\tstruct newtExitStruct es;\n\tnewtCenteredWindow(60,7, title);\n\tlabel = newtLabel(4,1,msg);\n\tok = newtButton(27, 3, \"OK\");\n\tform = newtForm(NULL, NULL, 0);\n\tnewtFormAddComponents(form, label, ok, NULL);\n\tnewtFormRun(form, &es);\n\tnewtPopWindow();\n\tnewtFormDestroy(form);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1640}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic struct ast_key *try_load_key(const char *dir, const char *fname, int ifd, int ofd, int *not2)\n{\n\tint ktype = 0, found = 0;\n\tchar *c = NULL, ffname[256];\n\tunsigned char digest[16];\n\tFILE *f;\n\tstruct MD5Context md5;\n\tstruct ast_key *key;\n\tstatic int notice = 0;\n\t\n\tif ((c = strstr(fname, \".pub\")) && !strcmp(c, \".pub\")) {\n\t\tktype = AST_KEY_PUBLIC;\n\t} else if ((c = strstr(fname, \".key\")) && !strcmp(c, \".key\")) {\n\t\tktype = AST_KEY_PRIVATE;\n\t} else {\n\t\treturn NULL;\n\t}\n\t\n\tsnprintf(ffname, sizeof(ffname), \"%s/%s\", dir, fname);\n\t\n\tif (!(f = fopen(ffname, \"r\"))) {\n\t\tast_log(LOG_WARNING, \"Unable to open key file %s: %s\\n\", ffname, strerror(errno));\n\t\treturn NULL;\n\t}\n\tMD5Init(&md5);\n\twhile (!feof(f)) {\n\t\t\n\t\tchar buf[256] = \"\";\n\t\tif (!fgets(buf, sizeof(buf), f)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!feof(f)) {\n\t\t\tMD5Update(&md5, (unsigned char *) buf, strlen(buf));\n\t\t}\n\t}\n\tMD5Final(digest, &md5);\n\t\n\tAST_RWLIST_TRAVERSE(&keys, key, list) {\n\t\tif (!strcasecmp(key->fn, ffname)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (key) {\n\t\t\n\t\tif (!memcmp(digest, key->digest, 16) &&\n\t\t    !(key->ktype & KEY_NEEDS_PASSCODE)) {\n\t\t\tfclose(f);\n\t\t\tkey->delme = 0;\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t\n\t\t\tktype = key->ktype;\n\t\t\t\n\t\t\tfound++;\n\t\t}\n\t}\n\t\n\t*c = '\\0';\n\tif (!key) {\n\t\tif (!(key = ast_calloc(1, sizeof(*key)))) {\n\t\t\tfclose(f);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t\n\tast_copy_string(key->fn, ffname, sizeof(key->fn));\n\t\n\tast_copy_string(key->name, fname, sizeof(key->name));\n\tkey->ktype = ktype;\n\t\n\tkey->delme = 1;\n\t\n\tmemcpy(key->digest, digest, 16);\n\t\n\tkey->infd = ifd;\n\tkey->outfd = ofd;\n\t\n\trewind(f);\n\t\n\tif (ktype == AST_KEY_PUBLIC) {\n\t\tkey->rsa = PEM_read_RSA_PUBKEY(f, NULL, pw_cb, key);\n\t} else {\n\t\tkey->rsa = PEM_read_RSAPrivateKey(f, NULL, pw_cb, key);\n\t}\n\tfclose(f);\n\tif (key->rsa) {\n\t\tif (RSA_size(key->rsa) == 128) {\n\t\t\t\n\t\t\tkey->ktype &= ~KEY_NEEDS_PASSCODE;\n\t\t\tast_verb(3, \"Loaded %s key '%s'\\n\", key->ktype == AST_KEY_PUBLIC ? \"PUBLIC\" : \"PRIVATE\", key->name);\n\t\t\tast_debug(1, \"Key '%s' loaded OK\\n\", key->name);\n\t\t\tkey->delme = 0;\n\t\t} else {\n\t\t\tast_log(LOG_NOTICE, \"Key '%s' is not expected size.\\n\", key->name);\n\t\t}\n\t} else if (key->infd != -2) {\n\t\tast_log(LOG_WARNING, \"Key load %s '%s' failed\\n\",key->ktype == AST_KEY_PUBLIC ? \"PUBLIC\" : \"PRIVATE\", key->name);\n\t\tif (ofd > -1) {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t} else {\n\t\tast_log(LOG_NOTICE, \"Key '%s' needs passcode.\\n\", key->name);\n\t\tkey->ktype |= KEY_NEEDS_PASSCODE;\n\t\tif (!notice) {\n\t\t\tif (!ast_opt_init_keys) {\n\t\t\t\tast_log(LOG_NOTICE, \"Add the '-i' flag to the asterisk command line if you want to automatically initialize passcodes at launch.\\n\");\n\t\t\t}\n\t\t\tnotice++;\n\t\t}\n\t\t\n\t\tkey->delme = 0;\n\t\t\n\t\t*not2 = 1;\n\t}\n\t\n\tif (!found) {\n\t\tAST_RWLIST_INSERT_TAIL(&keys, key, list);\n\t}\n\treturn key;\n}\n", "bug_type": null, "idx": 1641}
{"project": "Asterisk", "target": 0, "func": "static int process_xml_ref_node(xmlNode *node, struct member *mem, struct reference_list *refs)\n{\n\tstruct reference *ref;\n\tconst char *tmp;\n\tif (!(ref = calloc(1, sizeof(*ref)))) {\n\t\tfree_member(mem);\n\t\treturn -1;\n\t}\n\tif ((tmp = (const char *) xmlGetProp(node, BAD_CAST \"name\"))) {\n\t\tif (!strlen_zero(tmp)) {\n\t\t\tref->name = tmp;\n\t\t}\n\t}\n\tif ((tmp = (const char *) xmlGetProp(node, BAD_CAST \"autoselect\"))) {\n\t\tref->autoselect = !strcasecmp(tmp, \"yes\");\n\t}\n\ttmp = (const char *) xmlNodeGetContent(node);\n\tif (tmp && !strlen_zero(tmp)) {\n\t\tref->displayname = tmp;\n\t\tif (!ref->name) {\n\t\t\tref->name = ref->displayname;\n\t\t}\n\t\tAST_LIST_INSERT_TAIL(refs, ref, list);\n\t} else {\n\t\tfree_reference(ref);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1642}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_format_lang_pair(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_format = 0;\n\tint has_language = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"format\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_format = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI FormatLangPair field format failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"language\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_language = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI FormatLangPair field language failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI FormatLangPair has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_format) {\n\t\tast_log(LOG_ERROR, \"ARI FormatLangPair missing required field format\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_language) {\n\t\tast_log(LOG_ERROR, \"ARI FormatLangPair missing required field language\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1643}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hfp_send_atd(struct hfp_pvt *hfp, const char *number)\n{\n\tchar cmd[64];\n\tsnprintf(cmd, sizeof(cmd), \"ATD%s;\\r\", number);\n\treturn rfcomm_write(hfp->rsock, cmd);\n}\n", "bug_type": null, "idx": 1644}
{"project": "Asterisk", "target": 0, "func": "static int set_member_value_help_members(struct call_queue *q, const char *interface, int property, int value)\n{\n\tswitch(property) {\n\tcase MEMBER_PENALTY:\n\t\treturn set_member_penalty_help_members(q, interface, value);\n\tcase MEMBER_RINGINUSE:\n\t\treturn set_member_ringinuse_help_members(q, interface, value);\n\tdefault:\n\t\tast_log(LOG_ERROR, \"Attempted to set invalid property\\n\");\n\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 1645}
{"project": "Asterisk", "target": 0, "func": ");\nstatic int recording_hash(const void *obj, int flags)\n{\n\tconst struct stasis_app_recording *recording = obj;\n\tconst char *id = flags & OBJ_KEY ? obj : recording->options->name;\n\treturn ast_str_hash(id);\n}\n", "bug_type": null, "idx": 1646}
{"project": "Asterisk", "target": 0, "func": "int ast_json_array_set(struct ast_json *array, size_t index, struct ast_json *value)\n{\n\treturn json_array_set_new((json_t *)array, index, (json_t *)value);\n}\n", "bug_type": null, "idx": 1647}
{"project": "Asterisk", "target": 0, "func": "\nstatic int handler_wait_for_message(struct ast_test *test)\n{\n\tint error = 0;\n\tstruct timeval wait = ast_tvadd(ast_tvnow(), ast_tv(5 , 0));\n\tstruct timespec wait_time = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000 };\n\tast_mutex_lock(&handler_lock);\n\twhile (!handler_received_message) {\n\t\terror = ast_cond_timedwait(&handler_cond, &handler_lock, &wait_time);\n\t\tif (error == ETIMEDOUT) {\n\t\t\tast_test_status_update(test, \"Test timed out while waiting for handler to get message\\n\");\n\t\t\tast_test_set_result(test, AST_TEST_FAIL);\n\t\t\tbreak;\n\t\t}\n\t}\n\tast_mutex_unlock(&handler_lock);\n\treturn (error != ETIMEDOUT);\n}\n", "bug_type": null, "idx": 1648}
{"project": "Asterisk", "target": 0, "func": "void ast_pbx_hangup_handler_destroy(struct ast_channel *chan)\n{\n\tstruct ast_hangup_handler_list *handlers;\n\tstruct ast_hangup_handler *h_handler;\n\tast_channel_lock(chan);\n\t\n\thandlers = ast_channel_hangup_handlers(chan);\n\twhile ((h_handler = AST_LIST_REMOVE_HEAD(handlers, node))) {\n\t\tast_free(h_handler);\n\t}\n\tast_channel_unlock(chan);\n}\n", "bug_type": null, "idx": 1649}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225BandwidthRequest (OOCTXT* pctxt, H225BandwidthRequest* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.callIdentifierPresent ||\n   pvalue->m.gatekeeperIdentifierPresent ||\n   pvalue->m.tokensPresent ||\n   pvalue->m.cryptoTokensPresent ||\n   pvalue->m.integrityCheckValuePresent ||\n   pvalue->m.answeredCallPresent ||\n   pvalue->m.callLinkagePresent ||\n   pvalue->m.capacityPresent ||\n   pvalue->m.usageInformationPresent ||\n   pvalue->m.bandwidthDetailsPresent ||\n   pvalue->m.genericDataPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.callTypePresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.nonStandardDataPresent);\n   \n   stat = asn1PE_H225RequestSeqNum (pctxt, pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225EndpointIdentifier (pctxt, pvalue->endpointIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225ConferenceIdentifier (pctxt, &pvalue->conferenceID);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225CallReferenceValue (pctxt, pvalue->callReferenceValue);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.callTypePresent) {\n      stat = asn1PE_H225CallType (pctxt, &pvalue->callType);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = asn1PE_H225BandWidth (pctxt, pvalue->bandWidth);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      stat = asn1PE_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n   }\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 10);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.callIdentifierPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.gatekeeperIdentifierPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.tokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.cryptoTokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.integrityCheckValuePresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.answeredCallPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.callLinkagePresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.capacityPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.usageInformationPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.bandwidthDetailsPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.genericDataPresent);\n      \n      if (pvalue->m.callIdentifierPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225CallIdentifier (&lctxt, &pvalue->callIdentifier);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.gatekeeperIdentifierPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225GatekeeperIdentifier (&lctxt, pvalue->gatekeeperIdentifier);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.tokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225ClearToken (&lctxt, &pvalue->tokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.cryptoTokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225CryptoH323Token (&lctxt, &pvalue->cryptoTokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.integrityCheckValuePresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225ICV (&lctxt, &pvalue->integrityCheckValue);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.answeredCallPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeBit (&lctxt, (ASN1BOOL)pvalue->answeredCall);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.callLinkagePresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225CallLinkage (&lctxt, &pvalue->callLinkage);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.capacityPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225CallCapacity (&lctxt, &pvalue->capacity);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.usageInformationPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225RasUsageInformation (&lctxt, &pvalue->usageInformation);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.bandwidthDetailsPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225BandwidthDetails (&lctxt, &pvalue->bandwidthDetails);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.genericDataPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225GenericData (&lctxt, &pvalue->genericData);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1650}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_emulate_dtmf_duration_set(struct ast_channel *chan, unsigned int value)\n{\n\tchan->emulate_dtmf_duration = value;\n}\n", "bug_type": null, "idx": 1651}
{"project": "Asterisk", "target": 0, "func": "struct ast_sdp_c_line *ast_sdp_c_alloc(const char *address_type, const char *address)\n{\n\tstruct ast_sdp_c_line *c_line;\n\tsize_t len;\n\tchar *p;\n\tast_assert(!ast_strlen_zero(address_type) && !ast_strlen_zero(address));\n\tlen = sizeof(*c_line) + strlen(address_type) + strlen(address) + 2;\n\tc_line = ast_calloc(1, len);\n\tif (!c_line) {\n\t\treturn NULL;\n\t}\n\tp = ((char *)c_line) + sizeof(*c_line);\n\tCOPY_STR_AND_ADVANCE(p, c_line->address_type, address_type);\n\tCOPY_STR_AND_ADVANCE(p, c_line->address, address);\n\treturn c_line;\n}\n", "bug_type": null, "idx": 1652}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic void update_status(struct call_queue *q, struct member *m, const int status)\n{\n\tif (m->status != status) {\n\t\t\n\t\tif (status == AST_DEVICE_NOT_INUSE) {\n\t\t\tupdate_queue(q, m, m->callcompletedinsl, m->starttime);\n\t\t}\n\t\tm->status = status;\n\t\t\n\t\tpending_members_remove(m);\n\t}\n\tqueue_publish_member_blob(queue_member_status_type(), queue_member_blob_create(q, m));\n}\n", "bug_type": null, "idx": 1653}
{"project": "Asterisk", "target": 0, "func": "static struct phoneprov_provider *find_provider(char *name)\n{\n\treturn ao2_find(providers, name, OBJ_SEARCH_KEY);\n}\n", "bug_type": null, "idx": 1654}
{"project": "Asterisk", "target": 0, "func": "char *__ast_strndup(const char *s, size_t n, const char *file, int lineno, const char *func)\n{\n\treturn strndup(s, n);\n}\n", "bug_type": null, "idx": 1655}
{"project": "Asterisk", "target": 0, "func": "static u_char *ast_var_indications_table(struct variable *vp, oid *name, size_t *length,\n\t\t\t\t\t\t\t\t\t   int exact, size_t *var_len, WriteMethod **write_method)\n{\n\tstatic unsigned long long_ret;\n\tstatic char ret_buf[256];\n\tstruct ast_tone_zone *tz = NULL;\n\tint i;\n\tstruct ao2_iterator iter;\n\tif (header_simple_table(vp, name, length, exact, var_len, write_method, -1)) {\n\t\treturn NULL;\n\t}\n\ti = name[*length - 1] - 1;\n\titer = ast_tone_zone_iterator_init();\n\twhile ((tz = ao2_iterator_next(&iter)) && i) {\n\t\ttz = ast_tone_zone_unref(tz);\n\t\ti--;\n\t}\n\tao2_iterator_destroy(&iter);\n\tif (tz == NULL) {\n\t\treturn NULL;\n\t}\n\tswitch (vp->magic) {\n\tcase ASTINDINDEX:\n\t\tast_tone_zone_unref(tz);\n\t\tlong_ret = name[*length - 1];\n\t\treturn (u_char *)&long_ret;\n\tcase ASTINDCOUNTRY:\n\t\tast_copy_string(ret_buf, tz->country, sizeof(ret_buf));\n\t\tast_tone_zone_unref(tz);\n\t\t*var_len = strlen(ret_buf);\n\t\treturn (u_char *) ret_buf;\n\tcase ASTINDALIAS:\n\t\t\n\t\tast_tone_zone_unref(tz);\n\t\treturn NULL;\n\tcase ASTINDDESCRIPTION:\n\t\tast_tone_zone_lock(tz);\n\t\tast_copy_string(ret_buf, tz->description, sizeof(ret_buf));\n\t\tast_tone_zone_unlock(tz);\n\t\tast_tone_zone_unref(tz);\n\t\t*var_len = strlen(ret_buf);\n\t\treturn (u_char *) ret_buf;\n\tdefault:\n\t\tast_tone_zone_unref(tz);\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1656}
{"project": "Asterisk", "target": 0, "func": "#endif\nstatic void dec_ie_cause(unsigned char *p, Q931_info_t *qi, int *location, int *cause, int nt, struct misdn_bchannel *bc)\n{\n\t*location = -1;\n\t*cause = -1;\n\tif (!nt)\n\t{\n\t\tp = NULL;\n\t\tif (qi->QI_ELEMENT(cause))\n\t\t\tp = (unsigned char *)qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(cause) + 1;\n\t}\n\tif (!p)\n\t\treturn;\n\tif (p[0] < 2)\n\t{\n\t\tprintf(\"%s: ERROR: IE too short (%d).\\n\", __FUNCTION__, p[0]);\n\t\treturn;\n\t}\n\t*location = p[1] & 0x0f;\n\t*cause = p[2] & 0x7f;\n\tif (MISDN_IE_DEBG) printf(\"    location=%d cause=%d\\n\", *location, *cause);\n}\n", "bug_type": null, "idx": 1657}
{"project": "Asterisk", "target": 0, "func": "static void pickup_copy(struct ast_features_pickup_config *dest, const struct ast_features_pickup_config *src)\n{\n\tast_string_fields_copy(dest, src);\n}\n", "bug_type": null, "idx": 1658}
{"project": "Asterisk", "target": 0, "func": "static void agent_after_bridge_cb(struct ast_channel *chan, void *data)\n{\n\tstruct agent_pvt *agent;\n\tagent = ao2_find(agents, chan, 0);\n\tif (!agent) {\n\t\treturn;\n\t}\n\tast_debug(1, \"Agent %s: New agent channel %s.\\n\",\n\t\tagent->username, ast_channel_name(chan));\n\tagent_run(agent, chan);\n\tao2_ref(agent, -1);\n}\n", "bug_type": null, "idx": 1659}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int test_expected_duplicates(int res, struct ao2_container *container,\n\tenum search_flags flags, int number,\n\tconst int *vector, int count, const char *prefix, struct ast_test *test)\n{\n\tstruct ao2_iterator *mult_iter;\n\tstruct test_obj *obj;\n\tint idx;\n\tmult_iter = ao2_find(container, &number, flags | OBJ_MULTIPLE | OBJ_KEY);\n\tif (!mult_iter) {\n\t\tast_test_status_update(test, \"%s: Did not return iterator.\\n\", prefix);\n\t\treturn AST_TEST_FAIL;\n\t}\n\t\n\tfor (idx = 0; idx < count; ++idx) {\n\t\tobj = ao2_iterator_next(mult_iter);\n\t\tif (!obj) {\n\t\t\tast_test_status_update(test, \"%s: Too few objects found.\\n\", prefix);\n\t\t\tres = AST_TEST_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tif (number != obj->i) {\n\t\t\tast_test_status_update(test, \"%s: Object %d != %d.\\n\",\n\t\t\t\tprefix, obj->i, number);\n\t\t\tres = AST_TEST_FAIL;\n\t\t}\n\t\tif (vector[idx] != obj->dup_number) {\n\t\t\tast_test_status_update(test, \"%s: Object dup id %d != vector[%d] %d.\\n\",\n\t\t\t\tprefix, obj->dup_number, idx, vector[idx]);\n\t\t\tres = AST_TEST_FAIL;\n\t\t}\n\t\tao2_ref(obj, -1); \n\t}\n\tobj = ao2_iterator_next(mult_iter);\n\tif (obj) {\n\t\tast_test_status_update(test,\n\t\t\t\"%s: Too many objects found.  Object %d, dup id %d\\n\",\n\t\t\tprefix, obj->i, obj->dup_number);\n\t\tao2_ref(obj, -1); \n\t\tres = AST_TEST_FAIL;\n\t}\n\tao2_iterator_destroy(mult_iter);\n\treturn res;\n}\n", "bug_type": null, "idx": 1660}
{"project": "Asterisk", "target": 0, "func": "#define VAR_SIZE 64\nstatic const char *get_index(struct ast_channel *chan, const char *prefix, int idx) {\n\tchar varname[VAR_SIZE];\n\tsnprintf(varname, VAR_SIZE, \"%s_%d\", prefix, idx);\n\treturn pbx_builtin_getvar_helper(chan, varname);\n}\n", "bug_type": null, "idx": 1661}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225_SeqOfH225H245Security (OOCTXT* pctxt, H225_SeqOfH225H245Security* pvalue)\n{\n   int stat = ASN_OK;\n   DListNode* pnode;\n   ASN1UINT xx1;\n   ASN1UINT enclen, fraglen;\n   enclen = fraglen = xx1 = 0;\n   pnode = pvalue->head;\n   for (;;) {\n      \n      stat = encodeLength (pctxt, (pvalue->count - enclen));\n      if (stat < 0) return stat;\n      fraglen = stat;\n      enclen += fraglen;\n      \n      for (; xx1 < enclen; xx1++) {\n         stat = asn1PE_H225H245Security (pctxt, ((H225H245Security*)pnode->data));\n         if (stat != ASN_OK) return stat;\n         pnode = pnode->next;\n      }\n      if ( pvalue->count == enclen && fraglen < 16384) {\n         break;\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1662}
{"project": "Asterisk", "target": 0, "func": "void free_convolve_channel(struct convolve_channel *cchan)\n{\n#ifdef BINAURAL_RENDERING\n\tfftw_free(cchan->fftw_out);\n\tfftw_free(cchan->fftw_in);\n\tfftw_free(cchan->hrtf);\n\tast_free(cchan->overlap_add);\n\tast_free(cchan->out_data);\n\tfftw_destroy_plan(cchan->fftw_plan);\n\tfftw_destroy_plan(cchan->fftw_plan_inverse);\n#endif\n}\n", "bug_type": null, "idx": 1663}
{"project": "Asterisk", "target": 0, "func": "static char *dahdi_set_dnd(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint channel;\n\tint on;\n\tstruct dahdi_pvt *dahdi_chan = NULL;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"dahdi set dnd\";\n\t\te->usage =\n\t\t\t\"Usage: dahdi set dnd <chan#> <on|off>\\n\"\n\t\t\t\"\tSets/resets DND (Do Not Disturb) mode on a channel.\\n\"\n\t\t\t\"\tChanges take effect immediately.\\n\"\n\t\t\t\"\t<chan num> is the channel number\\n\"\n\t\t\t\" \t<on|off> Enable or disable DND mode?\\n\"\n\t\t\t;\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 5)\n\t\treturn CLI_SHOWUSAGE;\n\tif ((channel = atoi(a->argv[3])) <= 0) {\n\t\tast_cli(a->fd, \"Expected channel number, got '%s'\\n\", a->argv[3]);\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (ast_true(a->argv[4]))\n\t\ton = 1;\n\telse if (ast_false(a->argv[4]))\n\t\ton = 0;\n\telse {\n\t\tast_cli(a->fd, \"Expected 'on' or 'off', got '%s'\\n\", a->argv[4]);\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_mutex_lock(&iflock);\n\tfor (dahdi_chan = iflist; dahdi_chan; dahdi_chan = dahdi_chan->next) {\n\t\tif (dahdi_chan->channel != channel)\n\t\t\tcontinue;\n\t\t\n\t\tdahdi_dnd(dahdi_chan, on);\n\t\tbreak;\n\t}\n\tast_mutex_unlock(&iflock);\n\tif (!dahdi_chan) {\n\t\tast_cli(a->fd, \"Unable to find given channel %d\\n\", channel);\n\t\treturn CLI_FAILURE;\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1664}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245CapabilityTableEntry (OOCTXT* pctxt, H245CapabilityTableEntry* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL optbit = 0;\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.capabilityPresent = optbit;\n   \n   invokeStartElement (pctxt, \"capabilityTableEntryNumber\", -1);\n   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->capabilityTableEntryNumber);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"capabilityTableEntryNumber\", -1);\n   \n   if (pvalue->m.capabilityPresent) {\n      invokeStartElement (pctxt, \"capability\", -1);\n      stat = asn1PD_H245Capability (pctxt, &pvalue->capability);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"capability\", -1);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1665}
{"project": "Asterisk", "target": 0, "func": "static int phone_fixup(struct ast_channel *old, struct ast_channel *new)\n{\n\tstruct phone_pvt *pvt = ast_channel_tech_pvt(old);\n\tif (pvt && pvt->owner == old)\n\t\tpvt->owner = new;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1666}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tif ((LOG_SECURITY = ast_logger_register_level(LOG_SECURITY_NAME)) == -1) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (!(security_stasis_sub = stasis_subscribe(ast_security_topic(), security_stasis_cb, NULL))) {\n\t\tast_logger_unregister_level(LOG_SECURITY_NAME);\n\t\tLOG_SECURITY = -1;\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_verb(3, \"Security Logging Enabled\\n\");\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1667}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct bridge_roles_datastore *fetch_or_create_bridge_roles_datastore(struct ast_channel *chan)\n{\n\tstruct bridge_roles_datastore *roles_datastore;\n\tast_channel_lock(chan);\n\troles_datastore = fetch_bridge_roles_datastore(chan);\n\tif (!roles_datastore) {\n\t\troles_datastore = setup_bridge_roles_datastore(chan);\n\t}\n\tast_channel_unlock(chan);\n\treturn roles_datastore;\n}\n", "bug_type": null, "idx": 1668}
{"project": "Asterisk", "target": 0, "func": "static int policy_cmp_fn(void *obj, void *arg, int flags)\n{\n\tconst struct ast_srtp_policy *one = obj, *two = arg;\n\treturn one->sp.ssrc.type == two->sp.ssrc.type && one->sp.ssrc.value == two->sp.ssrc.value;\n}\n", "bug_type": null, "idx": 1669}
{"project": "Asterisk", "target": 0, "func": " * \\brief read character from file to buffer (base64 conversion) */\nstatic int b64_inchar(struct b64_baseio *bio, FILE *fi)\n{\n\tif (bio->iocp >= bio->iolen) {\n\t\tif (!b64_inbuf(bio, fi))\n\t\t\treturn EOF;\n\t}\n\treturn bio->iobuf[bio->iocp++];\n}\n", "bug_type": null, "idx": 1670}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum ast_transfer_result two_bridge_attended_transfer(struct ast_channel *to_transferee,\n\t\tstruct ast_bridge_channel *to_transferee_bridge_channel,\n\t\tstruct ast_channel *to_transfer_target,\n\t\tstruct ast_bridge_channel *to_target_bridge_channel,\n\t\tstruct ast_bridge *to_transferee_bridge, struct ast_bridge *to_target_bridge,\n\t\tstruct ast_attended_transfer_message *transfer_msg)\n{\n\tstruct ast_bridge_channel *kick_me[] = {\n\t\t\tto_transferee_bridge_channel,\n\t\t\tto_target_bridge_channel,\n\t};\n\tenum ast_transfer_result res;\n\tstruct ast_bridge *final_bridge = NULL;\n\tRAII_VAR(struct ao2_container *, channels, NULL, ao2_cleanup);\n\tchannels = ast_bridge_peers_nolock(to_transferee_bridge);\n\tif (!channels) {\n\t\tres = AST_BRIDGE_TRANSFER_FAIL;\n\t\tgoto end;\n\t}\n\tset_transfer_variables_all(to_transferee, channels, 1);\n\tswitch (ast_bridges_allow_optimization(to_transferee_bridge, to_target_bridge)) {\n\tcase AST_BRIDGE_OPTIMIZE_SWAP_TO_CHAN_BRIDGE:\n\t\tfinal_bridge = to_transferee_bridge;\n\t\tres = bridge_swap_attended_transfer(to_transferee_bridge, to_target_bridge_channel, to_transferee);\n\t\tgoto end;\n\tcase AST_BRIDGE_OPTIMIZE_SWAP_TO_PEER_BRIDGE:\n\t\tfinal_bridge = to_target_bridge;\n\t\tres = bridge_swap_attended_transfer(to_target_bridge, to_transferee_bridge_channel, to_transfer_target);\n\t\tgoto end;\n\tcase AST_BRIDGE_OPTIMIZE_MERGE_TO_CHAN_BRIDGE:\n\t\tfinal_bridge = to_transferee_bridge;\n\t\tbridge_do_merge(to_transferee_bridge, to_target_bridge, kick_me, ARRAY_LEN(kick_me), 0);\n\t\tres = AST_BRIDGE_TRANSFER_SUCCESS;\n\t\tgoto end;\n\tcase AST_BRIDGE_OPTIMIZE_MERGE_TO_PEER_BRIDGE:\n\t\tfinal_bridge = to_target_bridge;\n\t\tbridge_do_merge(to_target_bridge, to_transferee_bridge, kick_me, ARRAY_LEN(kick_me), 0);\n\t\tres = AST_BRIDGE_TRANSFER_SUCCESS;\n\t\tgoto end;\n\tcase AST_BRIDGE_OPTIMIZE_PROHIBITED:\n\tdefault:\n\t\t\n\t\tif (to_transferee_bridge->inhibit_merge || to_transferee_bridge->dissolved ||\n\t\t\t\tto_target_bridge->inhibit_merge || to_target_bridge->dissolved) {\n\t\t\treturn AST_BRIDGE_TRANSFER_INVALID;\n\t\t}\n\t\treturn attended_transfer_bridge(to_transferee, to_transfer_target,\n\t\t\tto_transferee_bridge, to_target_bridge, transfer_msg);\n\t}\nend:\n\tif (res == AST_BRIDGE_TRANSFER_SUCCESS) {\n\t\tast_attended_transfer_message_add_merge(transfer_msg, final_bridge);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1671}
{"project": "Asterisk", "target": 0, "func": "static const char *cli_unid_get_id(const void *obj)\n{\n\tconst struct unidentified_request *unid = obj;\n\treturn unid->src_name;\n}\n", "bug_type": null, "idx": 1672}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void resolver_data_cleanup(void)\n{\n\tast_mutex_destroy(&test_resolver_data.lock);\n\tast_cond_destroy(&test_resolver_data.cancel_cond);\n}\n", "bug_type": null, "idx": 1673}
{"project": "Asterisk", "target": 0, "func": "int misdn_lib_get_maxchans(int port)\n{\n\tstruct misdn_stack *stack=get_misdn_stack();\n\tfor ( ; stack; stack=stack->next) {\n\t\tif (stack->port == port) {\n\t\t\tif (stack->pri)\n\t\t\t\treturn 30;\n\t\t\telse\n\t\t\t\treturn 2;\n\t\t}\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1674}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235TimeStamp (OOCTXT* pctxt, H235TimeStamp value)\n{\n   int stat = ASN_OK;\n   stat = encodeConsUnsigned (pctxt, value, 1U, ASN1UINT_MAX);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1675}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tif (ast_cdr_unregister(name)) {\n\t\treturn -1;\n\t}\n\tif (AST_RWLIST_WRLOCK(&sinks)) {\n\t\tast_cdr_register(name, ast_module_info->description, custom_log);\n\t\tast_log(LOG_ERROR, \"Unable to lock sink list.  Unload failed.\\n\");\n\t\treturn -1;\n\t}\n\tfree_config();\n\tAST_RWLIST_UNLOCK(&sinks);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1676}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_channels_ring_stop(struct ast_variable *headers,\n\tstruct ast_ari_channels_ring_stop_args *args,\n\tstruct ast_ari_response *response)\n{\n\tRAII_VAR(struct stasis_app_control *, control, NULL, ao2_cleanup);\n\tcontrol = find_control(response, args->channel_id);\n\tif (control == NULL) {\n\t\treturn;\n\t}\n\tif (channel_state_invalid(control, response)) {\n\t\treturn;\n\t}\n\tstasis_app_control_ring_stop(control);\n\tast_ari_response_no_content(response);\n}\n", "bug_type": null, "idx": 1677}
{"project": "Asterisk", "target": 0, "func": "enum ast_transfer_result ast_bridge_transfer_blind(int is_external,\n\t\tstruct ast_channel *transferer, const char *exten, const char *context,\n\t\ttransfer_channel_cb new_channel_cb, void *user_data)\n{\n\tRAII_VAR(struct ast_bridge *, bridge, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_bridge_channel *, bridge_channel, NULL, ao2_cleanup);\n\tRAII_VAR(struct ao2_container *, channels, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_channel *, transferee, NULL, ast_channel_cleanup);\n\tRAII_VAR(struct transfer_channel_data *, user_data_wrapper, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_blind_transfer_message *, transfer_message, NULL, ao2_cleanup);\n\tint do_bridge_transfer;\n\tint transfer_prohibited;\n\tenum ast_transfer_result transfer_result;\n\ttransfer_message = ast_blind_transfer_message_create(is_external, transferer, exten, context);\n\tif (!transfer_message) {\n\t\t\n\t\tast_log(LOG_ERROR, \"Unable to allocate memory for blind transfer publication from %s\\n\",\n\t\t\t\tast_channel_name(transferer));\n\t\treturn AST_BRIDGE_TRANSFER_FAIL;\n\t}\n\tbridge = acquire_bridge(transferer);\n\tif (!bridge) {\n\t\ttransfer_result = AST_BRIDGE_TRANSFER_INVALID;\n\t\tgoto publish;\n\t}\n\tast_bridge_lock(bridge);\n\ttransfer_message->bridge = ast_bridge_snapshot_create(bridge);\n\tast_bridge_unlock(bridge);\n\tif (!transfer_message->bridge) {\n\t\ttransfer_result = AST_BRIDGE_TRANSFER_FAIL;\n\t\tgoto publish;\n\t}\n\ttransferee = ast_bridge_peer(bridge, transferer);\n\tif (transferee) {\n\t\ttransfer_message->transferee = ast_channel_snapshot_get_latest(ast_channel_uniqueid(transferee));\n\t\tif (!transfer_message->transferee) {\n\t\t\ttransfer_result = AST_BRIDGE_TRANSFER_FAIL;\n\t\t\tgoto publish;\n\t\t}\n\t}\n\tast_channel_lock(transferer);\n\tbridge_channel = ast_channel_get_bridge_channel(transferer);\n\tast_channel_unlock(transferer);\n\tif (!bridge_channel) {\n\t\ttransfer_result = AST_BRIDGE_TRANSFER_INVALID;\n\t\tgoto publish;\n\t}\n\tuser_data_wrapper = ao2_alloc(sizeof(*user_data_wrapper), NULL);\n\tif (!user_data_wrapper) {\n\t\ttransfer_result = AST_BRIDGE_TRANSFER_FAIL;\n\t\tgoto publish;\n\t}\n\tuser_data_wrapper->data = user_data;\n\t\n\tast_bridge_channel_write_unhold(bridge_channel);\n\ttransfer_result = try_parking(transferer, context, exten, new_channel_cb, user_data_wrapper);\n\tif (transfer_result == AST_BRIDGE_TRANSFER_SUCCESS) {\n\t\tgoto publish;\n\t}\n\t\n\tuser_data_wrapper->completed = 1;\n\t{\n\t\tSCOPED_LOCK(lock, bridge, ast_bridge_lock, ast_bridge_unlock);\n\t\tchannels = ast_bridge_peers_nolock(bridge);\n\t\tif (!channels) {\n\t\t\ttransfer_result = AST_BRIDGE_TRANSFER_FAIL;\n\t\t\tgoto publish;\n\t\t}\n\t\tif (ao2_container_count(channels) <= 1) {\n\t\t\ttransfer_result = AST_BRIDGE_TRANSFER_INVALID;\n\t\t\tgoto publish;\n\t\t}\n\t\ttransfer_prohibited = ast_test_flag(&bridge->feature_flags,\n\t\t\t\tAST_BRIDGE_FLAG_TRANSFER_PROHIBITED);\n\t\tdo_bridge_transfer = ast_test_flag(&bridge->feature_flags,\n\t\t\t\tAST_BRIDGE_FLAG_TRANSFER_BRIDGE_ONLY) ||\n\t\t\t\tao2_container_count(channels) > 2;\n\t}\n\tif (transfer_prohibited) {\n\t\ttransfer_result = AST_BRIDGE_TRANSFER_NOT_PERMITTED;\n\t\tgoto publish;\n\t}\n\tset_transfer_variables_all(transferer, channels, 0);\n\tif (do_bridge_transfer) {\n\t\ttransfer_result = blind_transfer_bridge(is_external, transferer, bridge,\n\t\t\texten, context, transferee, new_channel_cb, user_data_wrapper, transfer_message);\n\t\tgoto publish;\n\t}\n\t\n\tif (!transferee) {\n\t\ttransfer_result = AST_BRIDGE_TRANSFER_FAIL;\n\t\tgoto publish;\n\t}\n\tif (bridge_channel_internal_queue_blind_transfer(transferee, exten, context,\n\t\t\t\tnew_channel_cb, user_data_wrapper)) {\n\t\ttransfer_result = AST_BRIDGE_TRANSFER_FAIL;\n\t\tgoto publish;\n\t}\n\tast_bridge_remove(bridge, transferer);\n\ttransfer_result = AST_BRIDGE_TRANSFER_SUCCESS;\npublish:\n\ttransfer_message->result = transfer_result;\n\tast_bridge_publish_blind_transfer(transfer_message);\n\treturn transfer_result;\n}\n", "bug_type": null, "idx": 1678}
{"project": "Asterisk", "target": 0, "func": "void ast_rtp_instance_get_incoming_source_address(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t  struct ast_sockaddr *address)\n{\n\tao2_lock(instance);\n\tast_sockaddr_copy(address, &instance->incoming_source_address);\n\tao2_unlock(instance);\n}\n", "bug_type": null, "idx": 1679}
{"project": "Asterisk", "target": 0, "func": "static int caller_id_tag_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\tendpoint->id.self.tag = ast_strdup(var->value);\n\treturn endpoint->id.self.tag ? 0 : -1;\n}\n", "bug_type": null, "idx": 1680}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void fill_bridgepeer_buf(char *buf, unsigned int cur_idx, const char *names[], unsigned int num_names)\n{\n\tint need_separator = 0;\n\tunsigned int idx;\n\tconst char *src;\n\tchar *pos;\n\tpos = buf;\n\tfor (idx = 0; idx < num_names; ++idx) {\n\t\tif (idx == cur_idx) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (need_separator) {\n\t\t\t*pos++ = ',';\n\t\t}\n\t\tneed_separator = 1;\n\t\t\n\t\tsrc = names[idx];\n\t\twhile (*src) {\n\t\t\t*pos++ = *src++;\n\t\t}\n\t}\n\t*pos = '\\0';\n}\n", "bug_type": null, "idx": 1681}
{"project": "Asterisk", "target": 0, "func": "static void destroy(GtkWidget *widget, gpointer data)\n{\n\tGtkWidget *dialog;\n\tgint response;\n\tif (!main_res || !change_made) {\n\t\tgtk_main_quit();\n\t\treturn;\n\t}\n\tdialog = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_MODAL,\n\t\t\tGTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, \"Save before quit?\");\n\tresponse = gtk_dialog_run(GTK_DIALOG(dialog));\n\tgtk_widget_destroy(dialog);\n\tif (response == GTK_RESPONSE_YES)\n\t\tmain_res = 0;\n\tgtk_main_quit();\n}\n", "bug_type": null, "idx": 1682}
{"project": "Asterisk", "target": 0, "func": "static int pbx_outgoing_attempt(const char *type, struct ast_format_cap *cap,\n\tconst char *addr, int timeout, const char *context, const char *exten, int priority,\n\tconst char *app, const char *appdata, int *reason, int synchronous,\n\tconst char *cid_num, const char *cid_name, struct ast_variable *vars,\n\tconst char *account, struct ast_channel **locked_channel, int early_media,\n\tconst struct ast_assigned_ids *assignedids, const char *predial_callee)\n{\n\tRAII_VAR(struct pbx_outgoing *, outgoing, NULL, ao2_cleanup);\n\tstruct ast_channel *dialed;\n\tpthread_t thread;\n\tchar tmp_cid_name[128];\n\tchar tmp_cid_num[128];\n\toutgoing = ao2_alloc(sizeof(*outgoing), pbx_outgoing_destroy);\n\tif (!outgoing) {\n\t\treturn -1;\n\t}\n\tast_cond_init(&outgoing->cond, NULL);\n\tif (!ast_strlen_zero(app)) {\n\t\tast_copy_string(outgoing->app, app, sizeof(outgoing->app));\n\t\toutgoing->appdata = ast_strdup(appdata);\n\t} else {\n\t\tast_copy_string(outgoing->context, context, sizeof(outgoing->context));\n\t\tast_copy_string(outgoing->exten, exten, sizeof(outgoing->exten));\n\t\toutgoing->priority = priority;\n\t}\n\tif (!(outgoing->dial = ast_dial_create())) {\n\t\treturn -1;\n\t}\n\tif (ast_dial_append(outgoing->dial, type, addr, assignedids)) {\n\t\treturn -1;\n\t}\n\tast_dial_set_global_timeout(outgoing->dial, timeout);\n\tif (!ast_strlen_zero(predial_callee)) {\n\t\t\n\t\tast_dial_option_global_enable(outgoing->dial, AST_DIAL_OPTION_PREDIAL, (void *)predial_callee);\n\t}\n\tif (ast_dial_prerun(outgoing->dial, NULL, cap)) {\n\t\tif (synchronous && reason) {\n\t\t\t*reason = pbx_dial_reason(AST_DIAL_RESULT_FAILED,\n\t\t\t\tast_dial_reason(outgoing->dial, 0));\n\t\t}\n\t\treturn -1;\n\t}\n\tdialed = ast_dial_get_channel(outgoing->dial, 0);\n\tif (!dialed) {\n\t\treturn -1;\n\t}\n\tast_channel_lock(dialed);\n\tif (vars) {\n\t\tast_set_variables(dialed, vars);\n\t}\n\tif (!ast_strlen_zero(account)) {\n\t\tast_channel_stage_snapshot(dialed);\n\t\tast_channel_accountcode_set(dialed, account);\n\t\tast_channel_peeraccount_set(dialed, account);\n\t\tast_channel_stage_snapshot_done(dialed);\n\t}\n\tast_set_flag(ast_channel_flags(dialed), AST_FLAG_ORIGINATED);\n\tif (!ast_strlen_zero(predial_callee)) {\n\t\tchar *tmp = NULL;\n\t\t\n\t\ttmp = S_COR(ast_channel_caller(dialed)->id.number.valid, ast_channel_caller(dialed)->id.number.str, NULL);\n\t\tif (tmp) {\n\t\t\tast_copy_string(tmp_cid_num, tmp, sizeof(tmp_cid_num));\n\t\t\tcid_num = tmp_cid_num;\n\t\t}\n\t\ttmp = S_COR(ast_channel_caller(dialed)->id.name.valid, ast_channel_caller(dialed)->id.name.str, NULL);\n\t\tif (tmp) {\n\t\t\tast_copy_string(tmp_cid_name, tmp, sizeof(tmp_cid_name));\n\t\t\tcid_name = tmp_cid_name;\n\t\t}\n\t}\n\tast_channel_unlock(dialed);\n\tif (!ast_strlen_zero(cid_num) || !ast_strlen_zero(cid_name)) {\n\t\tstruct ast_party_connected_line connected;\n\t\t\n\t\tast_set_callerid(dialed, cid_num, cid_name, cid_num);\n\t\tast_party_connected_line_set_init(&connected, ast_channel_connected(dialed));\n\t\tif (!ast_strlen_zero(cid_num)) {\n\t\t\tconnected.id.number.valid = 1;\n\t\t\tconnected.id.number.str = (char *) cid_num;\n\t\t\tconnected.id.number.presentation = AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED;\n\t\t}\n\t\tif (!ast_strlen_zero(cid_name)) {\n\t\t\tconnected.id.name.valid = 1;\n\t\t\tconnected.id.name.str = (char *) cid_name;\n\t\t\tconnected.id.name.presentation = AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED;\n\t\t}\n\t\tast_channel_set_connected_line(dialed, &connected, NULL);\n\t}\n\tif (early_media) {\n\t\tast_dial_set_state_callback(outgoing->dial, pbx_outgoing_state_callback);\n\t}\n\tif (locked_channel) {\n\t\t\n\t\tast_channel_ref(dialed);\n\t\tif (!synchronous) {\n\t\t\t\n\t\t\tast_channel_lock(dialed);\n\t\t}\n\t}\n\t\n\tao2_ref(outgoing, +1);\n\tif (synchronous == AST_OUTGOING_WAIT_COMPLETE) {\n\t\t\n\t\tpbx_outgoing_exec(outgoing);\n\t} else {\n\t\toutgoing->in_separate_thread = 1;\n\t\tif (ast_pthread_create_detached(&thread, NULL, pbx_outgoing_exec, outgoing)) {\n\t\t\tast_log(LOG_WARNING, \"Unable to spawn dialing thread for '%s/%s'\\n\", type, addr);\n\t\t\tao2_ref(outgoing, -1);\n\t\t\tif (locked_channel) {\n\t\t\t\tif (!synchronous) {\n\t\t\t\t\tast_channel_unlock(dialed);\n\t\t\t\t}\n\t\t\t\tast_channel_unref(dialed);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (synchronous) {\n\t\t\tao2_lock(outgoing);\n\t\t\t\n\t\t\twhile (!outgoing->dialed) {\n\t\t\t\tast_cond_wait(&outgoing->cond, ao2_object_get_lockaddr(outgoing));\n\t\t\t}\n\t\t\tao2_unlock(outgoing);\n\t\t}\n\t}\n\tif (synchronous) {\n\t\t\n\t\tif (reason) {\n\t\t\t*reason = pbx_dial_reason(outgoing->dial_res,\n\t\t\t\tast_dial_reason(outgoing->dial, 0));\n\t\t}\n\t\tif (outgoing->dial_res != AST_DIAL_RESULT_ANSWERED) {\n\t\t\t\n\t\t\tif (locked_channel) {\n\t\t\t\tast_channel_unref(dialed);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (locked_channel) {\n\t\t\tast_channel_lock(dialed);\n\t\t}\n\t}\n\tif (locked_channel) {\n\t\t*locked_channel = dialed;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1683}
{"project": "Asterisk", "target": 0, "func": "static struct ast_json *simple_bridge_channel_event(\n\tconst char *type,\n\tstruct ast_bridge_snapshot *bridge_snapshot,\n\tstruct ast_channel_snapshot *channel_snapshot,\n\tconst struct timeval *tv,\n\tconst struct stasis_message_sanitizer *sanitize)\n{\n\tRAII_VAR(struct ast_json *, json_bridge,\n\t\tast_bridge_snapshot_to_json(bridge_snapshot, sanitize), ast_json_unref);\n\tRAII_VAR(struct ast_json *, json_channel,\n\t\tast_channel_snapshot_to_json(channel_snapshot, sanitize), ast_json_unref);\n\tif (!json_bridge || !json_channel) {\n\t\treturn NULL;\n\t}\n\treturn ast_json_pack(\"{s: s, s: o, s: O, s: O}\",\n\t\t\"type\", type,\n\t\t\"timestamp\", ast_json_timeval(*tv, NULL),\n\t\t\"bridge\", json_bridge,\n\t\t\"channel\", json_channel);\n}\n", "bug_type": null, "idx": 1684}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *cli_contact_get_container(const char *regex)\n{\n\tRAII_VAR(struct ao2_container *, parent_container, NULL, ao2_cleanup);\n\tstruct ao2_container *child_container;\n\tregex_t regexbuf;\n\tparent_container = cli_aor_get_container(\"\");\n\tif (!parent_container) {\n\t\treturn NULL;\n\t}\n\tchild_container = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_NOLOCK, 0,\n\t\tcli_contact_sort, cli_contact_compare);\n\tif (!child_container) {\n\t\treturn NULL;\n\t}\n\tao2_callback(parent_container, OBJ_NODATA, cli_aor_gather_contacts, child_container);\n\tif (!ast_strlen_zero(regex)) {\n\t\tif (regcomp(&regexbuf, regex, REG_EXTENDED | REG_NOSUB)) {\n\t\t\tao2_ref(child_container, -1);\n\t\t\treturn NULL;\n\t\t}\n\t\tao2_callback(child_container, OBJ_UNLINK | OBJ_MULTIPLE | OBJ_NODATA, cli_filter_contacts, &regexbuf);\n\t\tregfree(&regexbuf);\n\t}\n\treturn child_container;\n}\n", "bug_type": null, "idx": 1685}
{"project": "Asterisk", "target": 0, "func": "\nstatic inline void insert_entry(struct call_queue *q, struct queue_ent *prev, struct queue_ent *new, int *pos)\n{\n\tstruct queue_ent *cur;\n\tif (!q || !new)\n\t\treturn;\n\tif (prev) {\n\t\tcur = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tcur = q->head;\n\t\tq->head = new;\n\t}\n\tnew->next = cur;\n\t\n\tqueue_ref(q);\n\tnew->parent = q;\n\tnew->pos = ++(*pos);\n\tnew->opos = *pos;\n}\n", "bug_type": null, "idx": 1686}
{"project": "Asterisk", "target": 0, "func": "static struct ast_manager_event_blob *queue_caller_join_to_ami(struct stasis_message *message)\n{\n\treturn queue_channel_to_ami(\"QueueCallerJoin\", message);\n}\n", "bug_type": null, "idx": 1687}
{"project": "Asterisk", "target": 0, "func": "struct ast_module_user *__ast_module_user_add(struct ast_module *mod, struct ast_channel *chan)\n{\n\tstruct ast_module_user *u;\n\tu = ast_calloc(1, sizeof(*u));\n\tif (!u) {\n\t\treturn NULL;\n\t}\n\tu->chan = chan;\n\tAST_LIST_LOCK(&mod->users);\n\tAST_LIST_INSERT_HEAD(&mod->users, u, entry);\n\tAST_LIST_UNLOCK(&mod->users);\n\tif (mod->ref_debug) {\n\t\tao2_ref(mod->ref_debug, +1);\n\t}\n\tast_atomic_fetchadd_int(&mod->usecount, +1);\n\tast_update_use_count();\n\treturn u;\n}\n", "bug_type": null, "idx": 1688}
{"project": "Asterisk", "target": 0, "func": "char* pvalCasePatGetVal( pval *p )\n{\n\treturn p->u1.str;\n}\n", "bug_type": null, "idx": 1689}
{"project": "Asterisk", "target": 0, "func": "\nstruct stasis_cache *ast_bridge_cache(void)\n{\n\treturn stasis_cp_all_cache(bridge_cache_all);\n}\n", "bug_type": null, "idx": 1690}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *hash_test_shrink(void *d)\n{\n\tconst struct hash_test *data = d;\n\tint i;\n\tfor (i = 1; i < data->preload; ++i) {\n\t\tchar *obj = ht_new(-i);\n\t\tchar *from_hashtab;\n\t\tint deleted;\n\t\tif (obj == NULL) {\n\t\t\treturn \"Allocation failed\";\n\t\t}\n\t\tfrom_hashtab = ast_hashtab_remove_object_via_lookup(data->to_be_thrashed, obj);\n\t\tdeleted = from_hashtab != NULL;\n\t\tht_delete(obj);\n\t\tht_delete(from_hashtab);\n\t\tif (!deleted) {\n\t\t\treturn \"could not delete object\";\n\t\t}\n\t\tif (is_timed_out(data)) {\n\t\t\treturn \"Shrink timed out\";\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1691}
{"project": "Asterisk", "target": 0, "func": "\nint ast_waitfor_n_fd(int *fds, int n, int *ms, int *exception)\n{\n\tint winner = -1;\n\tast_waitfor_nandfds(NULL, 0, fds, n, exception, &winner, ms);\n\treturn winner;\n}\n", "bug_type": null, "idx": 1692}
{"project": "Asterisk", "target": 0, "func": "static void timerfd_timer_close(void *data)\n{\n\tao2_ref(data, -1);\n}\n", "bug_type": null, "idx": 1693}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int acl_handler_fn(const struct aco_option *opt, struct ast_variable *var, void *obj) {\n\tstruct ast_ha **ha = (struct ast_ha **)(obj + opt->args[0]);\n\tint error = 0;\n\t*ha = ast_append_ha(opt->flags ? \"permit\" : \"deny\", var->value, *ha, &error);\n\treturn error;\n}\n", "bug_type": null, "idx": 1694}
{"project": "Asterisk", "target": 0, "func": "static int conf_del(struct dahdi_pvt *p, struct dahdi_subchannel *c, int index);\nstatic int my_conf_del(void *pvt, enum analog_sub sub)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tint x = analogsub_to_dahdisub(sub);\n\treturn conf_del(p, &p->subs[x], x);\n}\n", "bug_type": null, "idx": 1695}
{"project": "Asterisk", "target": 0, "func": "void ast_localtime_wakeup_monitor(struct ast_test *info)\n{\n\tstruct timeval wait_now = ast_tvnow();\n\tstruct timespec wait_time = { .tv_sec = wait_now.tv_sec + 2, .tv_nsec = wait_now.tv_usec * 1000 };\n\tif (inotify_thread != AST_PTHREADT_NULL) {\n\t\tAST_LIST_LOCK(&zonelist);\n#ifdef TEST_FRAMEWORK\n\t\ttest = info;\n#endif\n\t\tpthread_kill(inotify_thread, SIGURG);\n\t\tast_cond_timedwait(&initialization, &(&zonelist)->lock, &wait_time);\n#ifdef TEST_FRAMEWORK\n\t\ttest = NULL;\n#endif\n\t\tAST_LIST_UNLOCK(&zonelist);\n\t}\n}\n", "bug_type": null, "idx": 1696}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *pbx_outgoing_exec(void *data)\n{\n\tRAII_VAR(struct pbx_outgoing *, outgoing, data, ao2_cleanup);\n\tenum ast_dial_result res;\n\tres = ast_dial_run(outgoing->dial, NULL, 0);\n\tif (outgoing->in_separate_thread) {\n\t\t\n\t\tao2_lock(outgoing);\n\t\toutgoing->dial_res = res;\n\t\toutgoing->dialed = 1;\n\t\tast_cond_signal(&outgoing->cond);\n\t\tao2_unlock(outgoing);\n\t} else {\n\t\t\n\t\toutgoing->dial_res = res;\n\t}\n\t\n\tif (res != AST_DIAL_RESULT_ANSWERED) {\n\t\treturn NULL;\n\t}\n\tif (!ast_strlen_zero(outgoing->app)) {\n\t\tstruct ast_app *app = pbx_findapp(outgoing->app);\n\t\tif (app) {\n\t\t\tast_verb(4, \"Launching %s(%s) on %s\\n\", outgoing->app, S_OR(outgoing->appdata, \"\"),\n\t\t\t\tast_channel_name(ast_dial_answered(outgoing->dial)));\n\t\t\tpbx_exec(ast_dial_answered(outgoing->dial), app, outgoing->appdata);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"No such application '%s'\\n\", outgoing->app);\n\t\t}\n\t} else {\n\t\tstruct ast_channel *answered = ast_dial_answered(outgoing->dial);\n\t\tif (!ast_strlen_zero(outgoing->context)) {\n\t\t\tast_channel_context_set(answered, outgoing->context);\n\t\t}\n\t\tif (!ast_strlen_zero(outgoing->exten)) {\n\t\t\tast_channel_exten_set(answered, outgoing->exten);\n\t\t}\n\t\tif (outgoing->priority > 0) {\n\t\t\tast_channel_priority_set(answered, outgoing->priority);\n\t\t}\n\t\tif (ast_pbx_run(answered)) {\n\t\t\tast_log(LOG_ERROR, \"Failed to start PBX on %s\\n\", ast_channel_name(answered));\n\t\t} else {\n\t\t\t\n\t\t\tast_dial_answered_steal(outgoing->dial);\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1697}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_dns_test_write_domain(const char *string, char *buf)\n{\n\tchar *copy = ast_strdupa(string);\n\tchar *part;\n\tchar *ptr = buf;\n\tstatic const struct ast_dns_test_string null_label = {\n\t\t.len = 0,\n\t\t.val = \"\",\n\t};\n\twhile (1) {\n\t\tstruct ast_dns_test_string dns_str;\n\t\tpart = strsep(&copy, \".\");\n\t\tif (ast_strlen_zero(part)) {\n\t\t\tbreak;\n\t\t}\n\t\tdns_str.len = strlen(part);\n\t\tdns_str.val = part;\n\t\tptr += ast_dns_test_write_string(&dns_str, ptr);\n\t}\n\tptr += ast_dns_test_write_string(&null_label, ptr);\n\treturn ptr - buf;\n}\n}\nint ast_dns_test_write_domain(const char *string, char *buf)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1698}
{"project": "Asterisk", "target": 0, "func": "static SQLHSTMT silent_execute(struct odbc_obj *obj, void *data)\n{\n\treturn execute(obj, data, 1);\n}\n", "bug_type": null, "idx": 1699}
{"project": "Asterisk", "target": 0, "func": "static void analog_set_outgoing(struct analog_pvt *p, int is_outgoing)\n{\n\tp->outgoing = is_outgoing;\n\tif (analog_callbacks.set_outgoing) {\n\t\tanalog_callbacks.set_outgoing(p->chan_pvt, is_outgoing);\n\t}\n}\n", "bug_type": null, "idx": 1700}
{"project": "Asterisk", "target": 0, "func": "static int reload(void)\n{\n\treload_config();\n\treturn 0;\n}\n", "bug_type": null, "idx": 1701}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void mwi_mailbox_delete(struct ast_mwi_mailbox_object *mailbox)\n{\n\tast_sorcery_delete(mwi_sorcery, mailbox);\n}\n", "bug_type": null, "idx": 1702}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(sample_test);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1703}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn my_unload_module(0);\n}\n", "bug_type": null, "idx": 1704}
{"project": "Asterisk", "target": 0, "func": "static struct ast_channel *phone_request(const char *type, struct ast_format_cap *cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause)\n{\n\tstruct phone_pvt *p;\n\tstruct ast_channel *tmp = NULL;\n\tconst char *name = data;\n\t\n\tif (ast_mutex_lock(&iflock)) {\n\t\tast_log(LOG_ERROR, \"Unable to lock interface list???\\n\");\n\t\treturn NULL;\n\t}\n\tp = iflist;\n\twhile(p) {\n\t\tif (p->mode == MODE_FXS || (ast_format_cap_iscompatible(cap, phone_tech.capabilities))) {\n\t\t\tsize_t length = strlen(p->dev + 5);\n    \t\tif (strncmp(name, p->dev + 5, length) == 0 &&\n    \t\t    !isalnum(name[length])) {\n    \t\t    if (!p->owner) {\n                     tmp = phone_new(p, AST_STATE_DOWN, p->context, assignedids, requestor);\n                     break;\n                } else\n                     *cause = AST_CAUSE_BUSY;\n            }\n\t\t}\n\t\tp = p->next;\n\t}\n\tast_mutex_unlock(&iflock);\n\trestart_monitor();\n\tif (tmp == NULL) {\n\t\tif (!(ast_format_cap_iscompatible(cap, phone_tech.capabilities))) {\n\t\t\tstruct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\t\t\tast_log(LOG_NOTICE, \"Asked to get a channel of unsupported format '%s'\\n\",\n\t\t\t\tast_format_cap_get_names(cap, &codec_buf));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn tmp;\n}\n", "bug_type": null, "idx": 1705}
{"project": "Asterisk", "target": 0, "func": "\nstatic int valid_priv_reply(struct ast_flags64 *opts, int res)\n{\n\tif (res < '1')\n\t\treturn 0;\n\tif (ast_test_flag64(opts, OPT_PRIVACY) && res <= '5')\n\t\treturn 1;\n\tif (ast_test_flag64(opts, OPT_SCREENING) && res <= '4')\n\t\treturn 1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1706}
{"project": "Asterisk", "target": 0, "func": "\nstatic void jingle_send_session_info(struct jingle_session *session, const char *info)\n{\n\tiks *iq = NULL, *jingle = NULL, *text = NULL;\n\t\n\tif (session->transport == JINGLE_TRANSPORT_GOOGLE_V1) {\n\t\treturn;\n\t}\n\tif (!(iq = iks_new(\"iq\")) || !(jingle = iks_new(\"jingle\")) || !(text = iks_new(info))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate stanzas for session-info message on session '%s'\\n\", session->sid);\n\t\tgoto end;\n\t}\n\tiks_insert_attrib(iq, \"to\", session->remote);\n\tiks_insert_attrib(iq, \"type\", \"set\");\n\tiks_insert_attrib(iq, \"id\", session->connection->mid);\n\tast_xmpp_increment_mid(session->connection->mid);\n\tiks_insert_attrib(jingle, \"action\", \"session-info\");\n\tiks_insert_attrib(jingle, \"sid\", session->sid);\n\tiks_insert_attrib(jingle, \"xmlns\", JINGLE_NS);\n\tiks_insert_node(iq, jingle);\n\tiks_insert_node(jingle, text);\n\tast_xmpp_client_send(session->connection, iq);\nend:\n\tiks_delete(text);\n\tiks_delete(jingle);\n\tiks_delete(iq);\n}\n", "bug_type": null, "idx": 1707}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245RedundancyEncodingMode (OOCTXT* pctxt, H245RedundancyEncodingMode* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.secondaryEncodingPresent);\n   \n   stat = asn1PE_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.secondaryEncodingPresent) {\n      stat = asn1PE_H245RedundancyEncodingMode_secondaryEncoding (pctxt, &pvalue->secondaryEncoding);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1708}
{"project": "Asterisk", "target": 0, "func": "int ooUpdateAllLogicalChannels(OOH323CallData *call, char* localIP, int port)\n{\n   ooLogicalChannel *temp;\n   OOMediaInfo *pMediaInfo = NULL;\n   char *lIP = localIP;\n   OOBOOL eTCS = FALSE;\n   if (!lIP || !lIP[0]) {\n      lIP = call->localIP;\n   }\n\n   temp = call->logicalChans;\n   while (temp) {\n      if (temp->state == OO_LOGICALCHAN_ESTABLISHED) {\n          \n         if (!strcmp(temp->dir, \"transmit\")) {\n\t    if (call->h245SessionState != OO_H245SESSION_IDLE) {\n              ooSendCloseLogicalChannel(call, temp);\n            } else {\n              ooClearLogicalChannel(call, temp->channelNo);\n            }\n         } else if (!eTCS && call->h245SessionState != OO_H245SESSION_IDLE) {\n            ooSendEmptyTermCapMsg(call);\n            eTCS = TRUE;\n         }\n      }\n      temp = temp->next;\n   }\n\n   if (call->mediaInfo) {\n      pMediaInfo = call->mediaInfo;\n      while (pMediaInfo) {\n         strcpy(pMediaInfo->lMediaIP, lIP);\n         pMediaInfo->lMediaRedirPort = port;\n         pMediaInfo->lMediaRedirCPort = port + 1;\n         pMediaInfo = pMediaInfo->next;\n      }\n   }\n   if (call->h245SessionState == OO_H245SESSION_IDLE) {\n      if (call->fsSent) {\n         ooSendFSUpdate(call);\n      }\n   } else {\n      call->TCSPending = TRUE;\n   }\n\n\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1709}
{"project": "Asterisk", "target": 0, "func": "static void *bridge_find(const struct stasis_app *app, const char *id)\n{\n\treturn stasis_app_bridge_find_by_id(id);\n}\n", "bug_type": null, "idx": 1710}
{"project": "Asterisk", "target": 0, "func": "int ooh323c_set_capability_for_call\n   (ooCallData *call, struct ast_format_cap *cap, int dtmf, int dtmfcodec,\n\t\t int t38support, int g729onlyA)\n{\n   int ret = 0, x, txframes;\n   if (gH323Debug) {\n     ast_verb(0, \"\\tAdding capabilities to call(%s, %s)\\n\", call->callType, \n                                                            call->callToken);\n   }\n   if(dtmf & H323_DTMF_CISCO || 1)\n      ret |= ooCallEnableDTMFCISCO(call,dtmfcodec);\n   if(dtmf & H323_DTMF_RFC2833 || 1)\n      ret |= ooCallEnableDTMFRFC2833(call,dtmfcodec);\n   if(dtmf & H323_DTMF_H245ALPHANUMERIC || 1)\n      ret |= ooCallEnableDTMFH245Alphanumeric(call);\n   if(dtmf & H323_DTMF_H245SIGNAL || 1)\n      ret |= ooCallEnableDTMFH245Signal(call);\n   if (t38support)\n   \tooCapabilityAddT38Capability(call, OO_T38, OORXANDTX, \n\t\t\t\t\t&ooh323c_start_receive_datachannel,\n\t\t\t\t\t&ooh323c_start_transmit_datachannel,\n\t\t\t\t\t&ooh323c_stop_receive_datachannel,\n\t\t\t\t\t&ooh323c_stop_transmit_datachannel,\n\t\t\t\t\t0);\n   for(x=0; x<ast_format_cap_count(cap); x++)\n   {\n    struct ast_format *format = ast_format_cap_get_format(cap, x);\n      if(ast_format_cmp(format, ast_format_ulaw) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g711 ulaw capability to call(%s, %s)\\n\", \n                                              call->callType, call->callToken);\n\t }\n\t txframes = ast_format_cap_get_format_framing(cap, format);\n         ret= ooCallAddG711Capability(call, OO_G711ULAW64K, txframes, \n                                      txframes, OORXANDTX, \n                                      &ooh323c_start_receive_channel,\n                                      &ooh323c_start_transmit_channel,\n                                      &ooh323c_stop_receive_channel, \n                                      &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_alaw) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g711 alaw capability to call(%s, %s)\\n\",\n                                            call->callType, call->callToken);\n\t }\n         txframes = ast_format_cap_get_format_framing(cap, format);\n         ret= ooCallAddG711Capability(call, OO_G711ALAW64K, txframes, \n                                     txframes, OORXANDTX, \n                                     &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_g726) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g726 capability to call (%s, %s)\\n\",\n                                           call->callType, call->callToken);\n\t }\n\t txframes = ast_format_cap_get_format_framing(cap, format);\n         ret = ooCallAddG726Capability(call, OO_G726, txframes, grxframes, FALSE,\n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_g726_aal2) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g726aal2 capability to call (%s, %s)\\n\",\n                                           call->callType, call->callToken);\n\t }\n\t txframes = ast_format_cap_get_format_framing(cap, format);\n         ret = ooCallAddG726Capability(call, OO_G726AAL2, txframes, grxframes, FALSE,\n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_g729) == AST_FORMAT_CMP_EQUAL)\n      {\n         txframes = (ast_format_cap_get_format_framing(cap, format))/10;\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g729A capability to call(%s, %s)\\n\",\n                                            call->callType, call->callToken);\n\t }\n         ret= ooCallAddG729Capability(call, OO_G729A, txframes, txframes, \n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n\t if (g729onlyA)\n\t\tcontinue;\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g729 capability to call(%s, %s)\\n\",\n                                            call->callType, call->callToken);\n\t }\n         ret|= ooCallAddG729Capability(call, OO_G729, txframes, txframes, \n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g729B capability to call(%s, %s)\\n\",\n                                            call->callType, call->callToken);\n\t }\n         ret|= ooCallAddG729Capability(call, OO_G729B, txframes, txframes, \n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_g723) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding g7231 capability to call (%s, %s)\\n\",\n                                           call->callType, call->callToken);\n\t }\n         ret = ooCallAddG7231Capability(call, OO_G7231, 1, 1, FALSE, \n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_h263) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding h263 capability to call (%s, %s)\\n\",\n                                           call->callType, call->callToken);\n\t }\n         ret = ooCallAddH263VideoCapability(call, OO_H263VIDEO, 1, 0, 0, 0, 0, 320*1024, \n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_gsm) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding gsm capability to call(%s, %s)\\n\", \n                                             call->callType, call->callToken);\n\t }\n         ret = ooCallAddGSMCapability(call, OO_GSMFULLRATE, 4, FALSE, FALSE, \n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      if(ast_format_cmp(format, ast_format_speex) == AST_FORMAT_CMP_EQUAL)\n      {\n         if (gH323Debug) {\n            ast_verb(0, \"\\tAdding Speex capability to call(%s, %s)\\n\", \n                                             call->callType, call->callToken);\n\t }\n         ret = ooCallAddSpeexCapability(call, OO_SPEEX, 4, 4, FALSE, \n                                     OORXANDTX, &ooh323c_start_receive_channel,\n                                     &ooh323c_start_transmit_channel,\n                                     &ooh323c_stop_receive_channel, \n                                     &ooh323c_stop_transmit_channel);\n      }\n      ao2_ref(format, -1);\n   }\n   return ret;\n}\n", "bug_type": null, "idx": 1711}
{"project": "Asterisk", "target": 0, "func": "static void start_automixmonitor(struct ast_bridge_channel *bridge_channel, struct ast_channel *peer_chan, struct ast_features_general_config *features_cfg, const char *start_message)\n{\n\tchar *touch_filename;\n\tsize_t len;\n\tint x;\n\tenum set_touch_variables_res set_touch_res;\n\tRAII_VAR(char *, touch_format, NULL, ast_free);\n\tRAII_VAR(char *, touch_monitor, NULL, ast_free);\n\tRAII_VAR(char *, touch_monitor_prefix, NULL, ast_free);\n\tset_touch_res = set_touch_variables(bridge_channel->chan, 1, &touch_format,\n\t\t&touch_monitor, &touch_monitor_prefix);\n\tswitch (set_touch_res) {\n\tcase SET_TOUCH_SUCCESS:\n\t\tbreak;\n\tcase SET_TOUCH_UNSET:\n\t\tset_touch_res = set_touch_variables(peer_chan, 1, &touch_format, &touch_monitor,\n\t\t\t&touch_monitor_prefix);\n\t\tif (set_touch_res == SET_TOUCH_ALLOC_FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SET_TOUCH_ALLOC_FAILURE:\n\t\treturn;\n\t}\n\tif (!ast_strlen_zero(touch_monitor)) {\n\t\tlen = strlen(touch_monitor) + 50;\n\t\ttouch_filename = ast_alloca(len);\n\t\tsnprintf(touch_filename, len, \"%s-%ld-%s.%s\",\n\t\t\tS_OR(touch_monitor_prefix, \"auto\"),\n\t\t\t(long) time(NULL),\n\t\t\ttouch_monitor,\n\t\t\tS_OR(touch_format, \"wav\"));\n\t} else {\n\t\tchar *caller_chan_id;\n\t\tchar *peer_chan_id;\n\t\tcaller_chan_id = ast_strdupa(S_COR(ast_channel_caller(bridge_channel->chan)->id.number.valid,\n\t\t\tast_channel_caller(bridge_channel->chan)->id.number.str, ast_channel_name(bridge_channel->chan)));\n\t\tpeer_chan_id = ast_strdupa(S_COR(ast_channel_caller(peer_chan)->id.number.valid,\n\t\t\tast_channel_caller(peer_chan)->id.number.str, ast_channel_name(peer_chan)));\n\t\tlen = strlen(caller_chan_id) + strlen(peer_chan_id) + 50;\n\t\ttouch_filename = ast_alloca(len);\n\t\tsnprintf(touch_filename, len, \"%s-%ld-%s-%s.%s\",\n\t\t\tS_OR(touch_monitor_prefix, \"auto\"),\n\t\t\t(long) time(NULL),\n\t\t\tcaller_chan_id,\n\t\t\tpeer_chan_id,\n\t\t\tS_OR(touch_format, \"wav\"));\n\t}\n\tfor (x = 0; x < strlen(touch_filename); x++) {\n\t\tif (touch_filename[x] == '/') {\n\t\t\ttouch_filename[x] = '-';\n\t\t}\n\t}\n\tast_verb(4, \"AutoMixMonitor used to record call. Filename: %s\\n\", touch_filename);\n\tif (ast_start_mixmonitor(peer_chan, touch_filename, \"b\")) {\n\t\tast_verb(4, \"AutoMixMonitor feature was tried by '%s' but MixMonitor failed to start.\\n\",\n\t\t\tast_channel_name(bridge_channel->chan));\n\t\tif (features_cfg && !ast_strlen_zero(features_cfg->recordingfailsound)) {\n\t\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, features_cfg->recordingfailsound, NULL);\n\t\t}\n\t\treturn;\n\t}\n\tif (features_cfg && !ast_strlen_zero(features_cfg->courtesytone)) {\n\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, features_cfg->courtesytone, NULL);\n\t\tast_bridge_channel_write_playfile(bridge_channel, NULL, features_cfg->courtesytone, NULL);\n\t}\n\tif (!ast_strlen_zero(start_message)) {\n\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, start_message, NULL);\n\t\tast_bridge_channel_write_playfile(bridge_channel, NULL, start_message, NULL);\n\t}\n\tpbx_builtin_setvar_helper(peer_chan, \"TOUCH_MIXMONITOR_OUTPUT\", touch_filename);\n}\n", "bug_type": null, "idx": 1712}
{"project": "Asterisk", "target": 0, "func": "int ast_dial_prerun(struct ast_dial *dial, struct ast_channel *chan, struct ast_format_cap *cap)\n{\n\tstruct ast_dial_channel *channel;\n\tint res = -1;\n\tchar *predial_string = dial->options[AST_DIAL_OPTION_PREDIAL];\n\tAST_LIST_LOCK(&dial->channels);\n\tAST_LIST_TRAVERSE(&dial->channels, channel, list) {\n\t\tif ((res = begin_dial_prerun(channel, chan, cap, predial_string))) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(&dial->channels);\n\treturn res;\n}\n", "bug_type": null, "idx": 1713}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H235ECKASDH_eckasdhp (OOCTXT* pctxt, H235ECKASDH_eckasdhp* pvalue)\n{\n   int stat = ASN_OK;\n   \n   invokeStartElement (pctxt, \"public_key\", -1);\n   stat = asn1PD_H235ECpoint (pctxt, &pvalue->public_key);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"public_key\", -1);\n   \n   invokeStartElement (pctxt, \"modulus\", -1);\n   stat = asn1PD_H235ECKASDH_eckasdhp_modulus (pctxt, &pvalue->modulus);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"modulus\", -1);\n   \n   invokeStartElement (pctxt, \"base\", -1);\n   stat = asn1PD_H235ECpoint (pctxt, &pvalue->base);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"base\", -1);\n   \n   invokeStartElement (pctxt, \"weierstrassA\", -1);\n   stat = asn1PD_H235ECKASDH_eckasdhp_weierstrassA (pctxt, &pvalue->weierstrassA);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"weierstrassA\", -1);\n   \n   invokeStartElement (pctxt, \"weierstrassB\", -1);\n   stat = asn1PD_H235ECKASDH_eckasdhp_weierstrassB (pctxt, &pvalue->weierstrassB);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"weierstrassB\", -1);\n   return (stat);\n}\n", "bug_type": null, "idx": 1714}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245JitterIndication_scope (OOCTXT* pctxt, H245JitterIndication_scope* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);\n   if (stat != ASN_OK) return stat;\n   else pvalue->t = ui + 1;\n   switch (ui) {\n      \n      case 0:\n         invokeStartElement (pctxt, \"logicalChannelNumber\", -1);\n         stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelNumber);\n         if (stat != ASN_OK) return stat;\n         invokeEndElement (pctxt, \"logicalChannelNumber\", -1);\n         break;\n      \n      case 1:\n         invokeStartElement (pctxt, \"resourceID\", -1);\n         stat = decodeConsUInt16 (pctxt, &pvalue->u.resourceID, 0U, 65535U);\n         if (stat != ASN_OK) return stat;\n         invokeUIntValue (pctxt, pvalue->u.resourceID);\n         invokeEndElement (pctxt, \"resourceID\", -1);\n         break;\n      \n      case 2:\n         invokeStartElement (pctxt, \"wholeMultiplex\", -1);\n         \n         invokeNullValue (pctxt);\n         invokeEndElement (pctxt, \"wholeMultiplex\", -1);\n         break;\n      default:\n         return ASN_E_INVOPT;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1715}
{"project": "Asterisk", "target": 0, "func": "static int showkeys(char *buf, char *name, int id, char *args, struct adsi_script *state, const char *script, int lineno)\n{\n\tchar *tok, newkey[80];\n\tint bytes, x, flagid = 0;\n\tunsigned char keyid[6];\n\tstruct adsi_soft_key *key;\n\tstruct adsi_flag *flag;\n\tfor (x = 0; x < 7; x++) {\n\t\t\n\t\tif (!(tok = get_token(&args, script, lineno)))\n\t\t\tbreak;\n\t\tif (!strcasecmp(tok, \"UNLESS\")) {\n\t\t\t\n\t\t\tif (!(tok = get_token(&args, script, lineno)))\n\t\t\t\tast_log(LOG_WARNING, \"Missing argument for UNLESS clause at line %d of %s\\n\", lineno, script);\n\t\t\telse if (process_token(newkey, tok, sizeof(newkey) - 1, ARG_STRING))\n\t\t\t\tast_log(LOG_WARNING, \"Invalid flag name '%s' at line %d of %s\\n\", tok, lineno, script);\n\t\t\telse if (!(flag = getflagbyname(state, newkey, script, lineno, 0)))\n\t\t\t\tast_log(LOG_WARNING, \"Flag '%s' is undeclared at line %d of %s\\n\", newkey, lineno, script);\n\t\t\telse\n\t\t\t\tflagid = flag->id;\n\t\t\tif ((tok = get_token(&args, script, lineno)))\n\t\t\t\tast_log(LOG_WARNING, \"Extra arguments after UNLESS clause: '%s' at line %d of %s\\n\", tok, lineno, script);\n\t\t\tbreak;\n\t\t}\n\t\tif (x > 5) {\n\t\t\tast_log(LOG_WARNING, \"Only 6 keys can be defined, ignoring '%s' at line %d of %s\\n\", tok, lineno, script);\n\t\t\tbreak;\n\t\t}\n\t\tif (process_token(newkey, tok, sizeof(newkey) - 1, ARG_STRING)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid token for key name: %s\\n\", tok);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(key = getkeybyname(state, newkey, script, lineno)))\n\t\t\tbreak;\n\t\tkeyid[x] = key->id;\n\t}\n\tbuf[0] = id;\n\tbuf[1] = (flagid & 0x7) << 3 | (x & 0x7);\n\tfor (bytes = 0; bytes < x; bytes++)\n\t\tbuf[bytes + 2] = keyid[bytes];\n\treturn 2 + x;\n}\n", "bug_type": null, "idx": 1716}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void mock_retrieve_multiple(const struct ast_sorcery *sorcery, void *data,\n\t\tconst char *type, struct ao2_container *objects, const struct ast_variable *fields)\n{\n\tint i;\n\tif (fields) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < real_backend_data->exists; ++i) {\n\t\tchar uuid[AST_UUID_STR_LEN];\n\t\tstruct test_data *b_data;\n\t\tb_data = ast_sorcery_alloc(sorcery, type, ast_uuid_generate_str(uuid, sizeof(uuid)));\n\t\tif (!b_data) {\n\t\t\tcontinue;\n\t\t}\n\t\tb_data->salt = real_backend_data->salt;\n\t\tb_data->pepper = real_backend_data->pepper;\n\t\tao2_link(objects, b_data);\n\t\tao2_ref(b_data, -1);\n\t}\n}\n", "bug_type": null, "idx": 1717}
{"project": "Asterisk", "target": 0, "func": "static msg_t *build_retrieve_reject (struct isdn_msg msgs[], struct misdn_bchannel *bc, int nt)\n{\n\tmsg_t *msg =(msg_t*)create_l3msg(CC_RETRIEVE_REJECT | REQUEST, MT_RETRIEVE_REJECT,  bc?bc->l3_id:-1, sizeof(RETRIEVE_REJECT_t) ,nt);\n#ifdef DEBUG\n\tprintf(\"Building RETRIEVE_REJECT Msg\\n\");\n#endif\n\treturn msg;\n}\n", "bug_type": null, "idx": 1718}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_frame *lintoadpcm_frameout(struct ast_trans_pvt *pvt)\n{\n\tstruct adpcm_encoder_pvt *tmp = pvt->pvt;\n\tstruct ast_frame *f;\n\tint i;\n\tint samples = pvt->samples;\t\n\tif (samples < 2)\n\t\treturn NULL;\n\tpvt->samples &= ~1; \n\tfor (i = 0; i < pvt->samples; i += 2) {\n\t\tpvt->outbuf.c[i/2] =\n\t\t\t(adpcm(tmp->inbuf[i  ], &tmp->state) << 4) |\n\t\t\t(adpcm(tmp->inbuf[i+1], &tmp->state)     );\n\t};\n\tf = ast_trans_frameout(pvt, pvt->samples/2, 0);\n\t\n\tif (samples & 1) {\t\n\t\ttmp->inbuf[0] = tmp->inbuf[samples - 1];\n\t\tpvt->samples = 1;\n\t}\n\treturn f;\n}\n", "bug_type": null, "idx": 1719}
{"project": "Asterisk", "target": 0, "func": "static int format_contact_status_for_aor(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_aor *aor = obj;\n\treturn ast_sip_for_each_contact(aor, ast_sip_format_contact_ami, arg);\n}\n", "bug_type": null, "idx": 1720}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void native_rtp_bridge_suspend(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)\n{\n\tast_debug(2, \"Bridge '%s'.  Channel '%s' is suspending from bridge tech\\n\",\n\t\tbridge->uniqueid, ast_channel_name(bridge_channel->chan));\n\tnative_rtp_bridge_leave(bridge, bridge_channel);\n}\n", "bug_type": null, "idx": 1721}
{"project": "Asterisk", "target": 0, "func": "static int featuremap_get(struct ast_featuremap_config *featuremap, const char *field,\n\t\tchar *buf, size_t len)\n{\n\tint res = 0;\n\tif (!strcasecmp(field, \"blindxfer\")) {\n\t\tast_copy_string(buf, featuremap->blindxfer, len);\n\t} else if (!strcasecmp(field, \"disconnect\")) {\n\t\tast_copy_string(buf, featuremap->disconnect, len);\n\t} else if (!strcasecmp(field, \"automon\")) {\n\t\tast_copy_string(buf, featuremap->automon, len);\n\t} else if (!strcasecmp(field, \"atxfer\")) {\n\t\tast_copy_string(buf, featuremap->atxfer, len);\n\t} else if (!strcasecmp(field, \"automixmon\")) {\n\t\tast_copy_string(buf, featuremap->automixmon, len);\n\t} else if (!strcasecmp(field, \"parkcall\")) {\n\t\tast_copy_string(buf, featuremap->parkcall, len);\n\t} else {\n\t\t\n\t\tres = -1;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1722}
{"project": "Asterisk", "target": 0, "func": "static void route_destructor(void *obj)\n{\n\tstruct http_route *route = obj;\n\tast_string_field_free_memory(route);\n}\n", "bug_type": null, "idx": 1723}
{"project": "Asterisk", "target": 1, "func": "\nstatic int sip_uri_headers_cmp(const char *input1, const char *input2)\n{\n\tchar *headers1 = ast_strdupa(input1);\n\tchar *headers2 = ast_strdupa(input2);\n\tint zerolength1 = ast_strlen_zero(headers1);\n\tint zerolength2 = ast_strlen_zero(headers2);\n\tint different = 0;\n\tchar *header1;\n\tif ((zerolength1 && !zerolength2) ||\n\t\t\t(zerolength2 && !zerolength1))\n\t\treturn 1;\n\tif (zerolength1 && zerolength2)\n\t\treturn 0;\n\t\n\tif (strlen(headers1) != strlen(headers2)) {\n\t\treturn 1;\n\t}\n\tfor (header1 = strsep(&headers1, \"&\"); header1; header1 = strsep(&headers1, \"&\")) {\n\t\tif (!strcasestr(headers2, header1)) {\n\t\t\tdifferent = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn different;\n}\n\t\n\tif (sip_uri_headers_cmp(headers1, headers2)) {\n\t\treturn 1;\n\t}\n", "bug_type": "CVE-2009-0871-1", "idx": 1724}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int smoother_frame_feed(struct ast_smoother *s, struct ast_frame *f, int swap)\n{\n\tif (s->flags & AST_SMOOTHER_FLAG_G729) {\n\t\tif (s->len % 10) {\n\t\t\tast_log(LOG_NOTICE, \"Dropping extra frame of G.729 since we already have a VAD frame at the end\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (swap) {\n\t\tast_swapcopy_samples(s->data + s->len, f->data.ptr, f->samples);\n\t} else {\n\t\tmemcpy(s->data + s->len, f->data.ptr, f->datalen);\n\t}\n\t\n\tif (!s->len || ast_tvzero(f->delivery) || ast_tvzero(s->delivery)) {\t\n\t\ts->delivery = f->delivery;\n\t}\n\ts->len += f->datalen;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1725}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_frame *chan_pjsip_cng_tone_detected(struct ast_sip_session *session, struct ast_frame *f)\n{\n\tconst char *target_context;\n\tint exists;\n\tint dsp_features;\n\tdsp_features = ast_dsp_get_features(session->dsp);\n\tdsp_features &= ~DSP_FEATURE_FAX_DETECT;\n\tif (dsp_features) {\n\t\tast_dsp_set_features(session->dsp, dsp_features);\n\t} else {\n\t\tast_dsp_free(session->dsp);\n\t\tsession->dsp = NULL;\n\t}\n\t\n\tif (!strcmp(ast_channel_exten(session->channel), \"fax\")) {\n\t\treturn f;\n\t}\n\ttarget_context = S_OR(ast_channel_macrocontext(session->channel), ast_channel_context(session->channel));\n\t\n\tast_channel_unlock(session->channel);\n\tast_frfree(f);\n\tf = &ast_null_frame;\n\texists = ast_exists_extension(session->channel, target_context, \"fax\", 1,\n\t\tS_COR(ast_channel_caller(session->channel)->id.number.valid,\n\t\t\tast_channel_caller(session->channel)->id.number.str, NULL));\n\tif (exists) {\n\t\tast_verb(2, \"Redirecting '%s' to fax extension due to CNG detection\\n\",\n\t\t\tast_channel_name(session->channel));\n\t\tpbx_builtin_setvar_helper(session->channel, \"FAXEXTEN\", ast_channel_exten(session->channel));\n\t\tif (ast_async_goto(session->channel, target_context, \"fax\", 1)) {\n\t\t\tast_log(LOG_ERROR, \"Failed to async goto '%s' into fax extension in '%s'\\n\",\n\t\t\t\tast_channel_name(session->channel), target_context);\n\t\t}\n\t} else {\n\t\tast_log(LOG_NOTICE, \"FAX CNG detected on '%s' but no fax extension in '%s'\\n\",\n\t\t\tast_channel_name(session->channel), target_context);\n\t}\n\tast_channel_lock(session->channel);\n\treturn f;\n}\n", "bug_type": null, "idx": 1726}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tstruct lock_frame *current;\n\t\n\tunloading = 1;\n\tAST_LIST_LOCK(&locklist);\n\twhile ((current = AST_LIST_REMOVE_HEAD(&locklist, entries))) {\n\t\t\n\t\tif (current->owner || ao2_container_count(current->requesters)) {\n\t\t\t\n\t\t\tAST_LIST_INSERT_HEAD(&locklist, current, entries);\n\t\t\tAST_LIST_UNLOCK(&locklist);\n\t\t\tunloading = 0;\n\t\t\treturn -1;\n\t\t}\n\t\tast_mutex_destroy(&current->mutex);\n\t\tao2_ref(current->requesters, -1);\n\t\tast_free(current);\n\t}\n\t\n\tast_custom_function_unregister(&lock_function);\n\tast_custom_function_unregister(&trylock_function);\n\tast_custom_function_unregister(&unlock_function);\n\tif (broker_tid != AST_PTHREADT_NULL) {\n\t\tpthread_cancel(broker_tid);\n\t\tpthread_kill(broker_tid, SIGURG);\n\t\tpthread_join(broker_tid, NULL);\n\t}\n\tAST_LIST_UNLOCK(&locklist);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1727}
{"project": "Asterisk", "target": 0, "func": "static inline int __ast_pthread_mutex_trylock(const char *filename, int lineno, const char *func,\n                                              const char* mutex_name, ast_mutex_t *t)\n{\n\tint res;\n\tint canlog = strcmp(filename, \"logger.c\");\n#if defined(AST_MUTEX_INIT_W_CONSTRUCTORS)\n\tif ((t->mutex) == ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)) {\n\t\t__ast_mutex_logger(\"%s line %d (%s): Error: mutex '%s' is uninitialized.\\n\",\n\t\t\t\t   filename, lineno, func, mutex_name);\n\t\tast_mutex_init(t);\n\t}\n#endif \n\tif (!(res = pthread_mutex_trylock(&t->mutex))) {\n\t\tif (t->reentrancy < AST_MAX_REENTRANCY) {\n\t\t\tt->file[t->reentrancy] = filename;\n\t\t\tt->lineno[t->reentrancy] = lineno;\n\t\t\tt->func[t->reentrancy] = func;\n\t\t\tt->thread[t->reentrancy] = pthread_self();\n\t\t\tt->reentrancy++;\n\t\t} else {\n\t\t\t__ast_mutex_logger(\"%s line %d (%s): '%s' really deep reentrancy!\\n\",\n\t\t\t\t\t   filename, lineno, func, mutex_name);\n\t\t}\n\t} else {\n\t\t__ast_mutex_logger(\"%s line %d (%s): Warning: '%s' was locked here.\\n\",\n                                   t->file[t->reentrancy-1], t->lineno[t->reentrancy-1], t->func[t->reentrancy-1], mutex_name);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1728}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225_SeqOfH225RTPSession (OOCTXT* pctxt, H225_SeqOfH225RTPSession* pvalue)\n{\n   int stat = ASN_OK;\n   DListNode* pnode;\n   ASN1UINT xx1;\n   ASN1UINT enclen, fraglen;\n   enclen = fraglen = xx1 = 0;\n   pnode = pvalue->head;\n   for (;;) {\n      \n      stat = encodeLength (pctxt, (pvalue->count - enclen));\n      if (stat < 0) return stat;\n      fraglen = stat;\n      enclen += fraglen;\n      \n      for (; xx1 < enclen; xx1++) {\n         stat = asn1PE_H225RTPSession (pctxt, ((H225RTPSession*)pnode->data));\n         if (stat != ASN_OK) return stat;\n         pnode = pnode->next;\n      }\n      if ( pvalue->count == enclen && fraglen < 16384) {\n         break;\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1729}
{"project": "Asterisk", "target": 0, "func": "static struct ast_json *d_to_json(const struct ast_aoc_decoded *decoded)\n{\n\treturn ast_json_pack(\"{s:o}\", \"Charge\", charge_to_json(decoded));\n}\n", "bug_type": null, "idx": 1730}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int task(void *data)\n{\n\tstruct task_data *task_data = data;\n\tSCOPED_MUTEX(lock, &task_data->lock);\n\ttask_data->task_complete = 1;\n\tast_cond_signal(&task_data->cond);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1731}
{"project": "Asterisk", "target": 0, "func": "static int message_received_handler(const char *endpoint_id, struct ast_json *json_msg, void *pvt)\n{\n\tRAII_VAR(struct ast_endpoint_snapshot *, snapshot, NULL, ao2_cleanup);\n\tstruct ast_json *json_endpoint;\n\tstruct stasis_app *app = pvt;\n\tchar *tech;\n\tchar *resource;\n\ttech = ast_strdupa(endpoint_id);\n\tresource = strchr(tech, '/');\n\tif (resource) {\n\t\tresource[0] = '\\0';\n\t\tresource++;\n\t}\n\tif (ast_strlen_zero(tech) || ast_strlen_zero(resource)) {\n\t\treturn -1;\n\t}\n\tsnapshot = ast_endpoint_latest_snapshot(tech, resource);\n\tif (!snapshot) {\n\t\treturn -1;\n\t}\n\tjson_endpoint = ast_endpoint_snapshot_to_json(snapshot, stasis_app_get_sanitizer());\n\tif (!json_endpoint) {\n\t\treturn -1;\n\t}\n\tapp_send(app, ast_json_pack(\"{s: s, s: o, s: o, s: o}\",\n\t\t\"type\", \"TextMessageReceived\",\n\t\t\"timestamp\", ast_json_timeval(ast_tvnow(), NULL),\n\t\t\"endpoint\", json_endpoint,\n\t\t\"message\", ast_json_ref(json_msg)));\n\treturn 0;\n}\n", "bug_type": null, "idx": 1732}
{"project": "Asterisk", "target": 0, "func": "struct stasis_topic *ast_bridge_topic_all_cached(void)\n{\n\treturn stasis_cp_all_topic_cached(bridge_cache_all);\n}\n", "bug_type": null, "idx": 1733}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int sla_check_inuse_station(const struct sla_station *station)\n{\n\tstruct sla_trunk_ref *trunk_ref;\n\tAST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {\n\t\tif (trunk_ref->chan)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1734}
{"project": "Asterisk", "target": 0, "func": "static int rlmi_print_body(struct pjsip_msg_body *msg_body, char *buf, pj_size_t size)\n{\n\tint num_printed;\n\tpj_xml_node *rlmi = msg_body->data;\n\tnum_printed = pj_xml_print(rlmi, buf, size, PJ_TRUE);\n\tif (num_printed <= AST_PJSIP_XML_PROLOG_LEN) {\n\t\treturn -1;\n\t}\n\treturn num_printed;\n}\n", "bug_type": null, "idx": 1735}
{"project": "Asterisk", "target": 0, "func": " */\nint tdd_gen_holdtone(unsigned char *buf)\n{\n\tint bytes = 0;\n\tfloat scont = 0.0, cr = 1.0, ci=0.0;\n\twhile (scont < tddsb * 10.0) {\n\t\tPUT_AUDIO_SAMPLE(tdd_getcarrier(&cr, &ci, 1));\n\t\tscont += 1.0;\n\t}\n\treturn bytes;\n}\n", "bug_type": null, "idx": 1736}
{"project": "Asterisk", "target": 0, "func": "static pjsip_fromto_hdr *get_diversion_header(pjsip_rx_data *rdata)\n{\n\tstatic const pj_str_t from_name = { \"From\", 4 };\n\tpjsip_generic_string_hdr *hdr;\n\tpj_str_t value;\n\tint size;\n\tif (!(hdr = pjsip_msg_find_hdr_by_name(rdata->msg_info.msg, &diversion_name, NULL))) {\n\t\treturn NULL;\n\t}\n\tpj_strdup_with_null(rdata->tp_info.pool, &value, &hdr->hvalue);\n\t\n\treturn pjsip_parse_hdr(rdata->tp_info.pool, &from_name, value.ptr,\n\t\t\t       pj_strlen(&value), &size);\n}\n", "bug_type": null, "idx": 1737}
{"project": "Asterisk", "target": 0, "func": "const char *ast_syslog_priority_name(int priority)\n{\n\tint index;\n\tfor (index = 0; index < ARRAY_LEN(priority_map); index++) {\n\t\tif (priority_map[index].value == priority) {\n\t\t\treturn priority_map[index].name;\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1738}
{"project": "Asterisk", "target": 0, "func": "\nstatic void asterisk_mwi_publisher_state_destroy(void *obj)\n{\n\tstruct asterisk_mwi_publisher_state *publisher_state = obj;\n\tao2_cleanup(publisher_state->client);\n\tif (publisher_state->mailbox_state_filter) {\n\t\tregfree(&publisher_state->mailbox_state_regex);\n\t}\n}\n", "bug_type": null, "idx": 1739}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(app_group)\n{\n\tstruct ast_channel *test_channel1 = NULL;\n\tstruct ast_channel *test_channel2 = NULL;\n\tstruct ast_channel *test_channel3 = NULL;\n\tstruct ast_channel *test_channel4 = NULL;\n\tstatic const char group1_full[] = BASE_GROUP \"groupgroup\";\n\tstatic const char group2_full[] = BASE_GROUP \"Groupgroup\";\n\tstatic const char regex1[] = \"gr\"; \n\tstatic const char regex2[] = \"(group){2}$\"; \n\tstatic const char regex3[] = \"[:ascii:]\"; \n\tstatic const char regex4[] = \"^(NOMATCH)\"; \n\tstatic const char category1_full[] = BASE_GROUP \"@a_category\"; \n\tstatic const char category2_full[] = BASE_GROUP \"@another!Category\";\n\tstatic const char regex5[] = \"(gory)$\"; \n\tstatic const char regex6[] = \"[A-Z]+\"; \n\tstatic const char regex7[] = \"[[\"; \n\tstatic enum ast_test_result_state res = AST_TEST_PASS;\n\tstatic const struct group_test_params {\n\t\tconst char *groupmatch;\n\t\tconst char *category;\n\t\tint expected;\n\t} subtests[] = {\n\t\t{ regex1, \"\", 4 },\n\t\t{ regex2, \"\", 1 },\n\t\t{ regex3, \"\", 4 },\n\t\t{ regex4, \"\", 0 },\n\t\t{ BASE_GROUP, regex5, 2 },\n\t\t{ BASE_GROUP, regex6, 1 },\n\t\t\n\t\t{ BASE_GROUP, regex7, 0 }\n\t};\n\tint i;\n\tint returned_count;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"app_group\";\n\t\tinfo->category = \"/main/app/\";\n\t\tinfo->summary = \"App group unit test\";\n\t\tinfo->description =\n\t\t\t\"This tests various app group functionality\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tast_test_status_update(test, \"Creating test channels with the following groups:\\n\"\n\t\t\"'%s', '%s', '%s', '%s'\\n\", group1_full, group2_full, category1_full, category2_full);\n\tif (!(test_channel1 = ast_channel_alloc(0, AST_STATE_DOWN, NULL, NULL, NULL,\n\t\tNULL, NULL, NULL, NULL, 0, \"TestChannel1\"))) {\n\t\tgoto exit_group_test;\n\t}\n\tast_channel_unlock(test_channel1);\n\tif (!(test_channel2 = ast_channel_alloc(0, AST_STATE_DOWN, NULL, NULL, NULL,\n\t\tNULL, NULL, NULL, NULL, 0, \"TestChannel2\"))) {\n\t\tgoto exit_group_test;\n\t}\n\tast_channel_unlock(test_channel2);\n\tif (!(test_channel3 = ast_channel_alloc(0, AST_STATE_DOWN, NULL, NULL, NULL,\n\t\tNULL, NULL, NULL, NULL, 0, \"TestChannel3\"))) {\n\t\tgoto exit_group_test;\n\t}\n\tast_channel_unlock(test_channel3);\n\tif (!(test_channel4 = ast_channel_alloc(0, AST_STATE_DOWN, NULL, NULL, NULL,\n\t\tNULL, NULL, NULL, NULL, 0, \"TestChannel4\"))) {\n\t\tgoto exit_group_test;\n\t}\n\tast_channel_unlock(test_channel4);\n\tast_app_group_set_channel(test_channel1, group1_full);\n\tast_app_group_set_channel(test_channel2, group2_full);\n\tast_app_group_set_channel(test_channel3, category1_full);\n\tast_app_group_set_channel(test_channel4, category2_full);\n\tfor (i = 0; i < ARRAY_LEN(subtests); i++) {\n\t\tast_assert(subtests[i].groupmatch != NULL || subtests[i].category != NULL);\n\t\treturned_count = ast_app_group_match_get_count(subtests[i].groupmatch, subtests[i].category);\n\t\tif (subtests[i].expected != returned_count) {\n\t\t\tast_test_status_update(test, \"(Subtest %d) Expected %d matches but found %d when examining group:'%s' category:'%s'\\n\",\n\t\t\t\ti + 1, subtests[i].expected, returned_count, subtests[i].groupmatch, subtests[i].category);\n\t\t\tres = AST_TEST_FAIL;\n\t\t\tgoto exit_group_test;\n\t\t} else {\n\t\t\tast_test_status_update(test, \"(Subtest %d) Found %d matches as expected when examining group:'%s' category:'%s'\\n\",\n\t\t\t\ti + 1, subtests[i].expected, subtests[i].groupmatch, subtests[i].category);\n\t\t}\n\t}\nexit_group_test:\n\tast_hangup(test_channel1);\n\tast_hangup(test_channel2);\n\tast_hangup(test_channel3);\n\tast_hangup(test_channel4);\n\treturn res;\n}\n", "bug_type": null, "idx": 1740}
{"project": "Asterisk", "target": 0, "func": "\nstatic void monitored_transport_destroy(void *obj)\n{\n\tstruct monitored_transport *monitored = obj;\n\tpjsip_transport_dec_ref(monitored->transport);\n}\n", "bug_type": null, "idx": 1741}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_report_auth_challenge_sent(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, pjsip_tx_data *tdata)\n{\n\tpjsip_www_authenticate_hdr *auth = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_WWW_AUTHENTICATE, NULL);\n\tenum ast_transport transport = security_event_get_transport(rdata);\n\tchar nonce[64] = \"\", call_id[pj_strlen(&rdata->msg_info.cid->id) + 1];\n\tstruct ast_sockaddr local, remote;\n\tstruct ast_security_event_chal_sent chal_sent = {\n\t\t\t.common.event_type = AST_SECURITY_EVENT_CHAL_SENT,\n\t\t\t.common.version    = AST_SECURITY_EVENT_CHAL_SENT_VERSION,\n\t\t\t.common.service    = \"PJSIP\",\n\t\t\t.common.account_id = get_account_id(endpoint),\n\t\t\t.common.local_addr = {\n\t\t\t\t\t.addr      = &local,\n\t\t\t\t\t.transport = transport,\n\t\t\t},\n\t\t\t.common.remote_addr = {\n\t\t\t\t\t.addr      = &remote,\n\t\t\t\t\t.transport = transport,\n\t\t\t},\n\t\t\t.common.session_id = call_id,\n\t\t\t.challenge         = nonce,\n\t};\n\tif (auth && !pj_strcmp2(&auth->scheme, \"digest\")) {\n\t\tast_copy_pj_str(nonce, &auth->challenge.digest.nonce, sizeof(nonce));\n\t}\n\tsecurity_event_populate(rdata, call_id, sizeof(call_id), &local, &remote);\n\tast_security_event_report(AST_SEC_EVT(&chal_sent));\n}\n", "bug_type": null, "idx": 1742}
{"project": "Asterisk", "target": 0, "func": "enum ast_json_to_ast_vars_code ast_json_to_ast_variables(struct ast_json *json_variables, struct ast_variable **variables)\n{\n\tstruct ast_json_iter *it_json_var;\n\t*variables = NULL;\n\tfor (it_json_var = ast_json_object_iter(json_variables); it_json_var;\n\t\tit_json_var = ast_json_object_iter_next(json_variables, it_json_var)) {\n\t\tstruct ast_variable *new_var;\n\t\tconst char *key = ast_json_object_iter_key(it_json_var);\n\t\tconst char *value;\n\t\tstruct ast_json *json_value;\n\t\tif (ast_strlen_zero(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tjson_value = ast_json_object_iter_value(it_json_var);\n\t\tif (ast_json_typeof(json_value) != AST_JSON_STRING) {\n\t\t\t\n\t\t\tast_variables_destroy(*variables);\n\t\t\t*variables = NULL;\n\t\t\treturn AST_JSON_TO_AST_VARS_CODE_INVALID_TYPE;\n\t\t}\n\t\tvalue = ast_json_string_get(json_value);\n\t\t\n\t\tast_assert(value != NULL);\n\t\tif (!value) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tnew_var = ast_variable_new(key, value, \"\");\n\t\tif (!new_var) {\n\t\t\t\n\t\t\tast_variables_destroy(*variables);\n\t\t\t*variables = NULL;\n\t\t\treturn AST_JSON_TO_AST_VARS_CODE_OOM;\n\t\t}\n\t\tast_variable_list_append(variables, new_var);\n\t}\n\treturn AST_JSON_TO_AST_VARS_CODE_SUCCESS;\n}\n", "bug_type": null, "idx": 1743}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int handle_options(struct jack_data *jack_data, const char *__options_str)\n{\n\tstruct ast_flags options = { 0, };\n\tchar *option_args[OPT_ARG_ARRAY_SIZE];\n\tchar *options_str;\n\toptions_str = ast_strdupa(__options_str);\n\tast_app_parse_options(jack_exec_options, &options, option_args, options_str);\n\tif (ast_test_flag(&options, OPT_SERVER_NAME)) {\n\t\tif (!ast_strlen_zero(option_args[OPT_ARG_SERVER_NAME]))\n\t\t\tast_string_field_set(jack_data, server_name, option_args[OPT_ARG_SERVER_NAME]);\n\t\telse {\n\t\t\tast_log(LOG_ERROR, \"A server name must be provided with the s() option\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (ast_test_flag(&options, OPT_CLIENT_NAME)) {\n\t\tif (!ast_strlen_zero(option_args[OPT_ARG_CLIENT_NAME]))\n\t\t\tast_string_field_set(jack_data, client_name, option_args[OPT_ARG_CLIENT_NAME]);\n\t\telse {\n\t\t\tast_log(LOG_ERROR, \"A client name must be provided with the c() option\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (ast_test_flag(&options, OPT_INPUT_PORT)) {\n\t\tif (!ast_strlen_zero(option_args[OPT_ARG_INPUT_PORT]))\n\t\t\tast_string_field_set(jack_data, connect_input_port, option_args[OPT_ARG_INPUT_PORT]);\n\t\telse {\n\t\t\tast_log(LOG_ERROR, \"A name must be provided with the i() option\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (ast_test_flag(&options, OPT_OUTPUT_PORT)) {\n\t\tif (!ast_strlen_zero(option_args[OPT_ARG_OUTPUT_PORT]))\n\t\t\tast_string_field_set(jack_data, connect_output_port, option_args[OPT_ARG_OUTPUT_PORT]);\n\t\telse {\n\t\t\tast_log(LOG_ERROR, \"A name must be provided with the o() option\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjack_data->no_start_server = ast_test_flag(&options, OPT_NOSTART_SERVER) ? 1 : 0;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1744}
{"project": "Asterisk", "target": 0, "func": "\t} while (0)\nstatic void safe_channel_release(struct ast_channel *chan)\n{\n\tif (!chan) {\n\t\treturn;\n\t}\n\tast_channel_release(chan);\n}\n", "bug_type": null, "idx": 1745}
{"project": "Asterisk", "target": 0, "func": "void *ao2_object_get_lockaddr(void *user_data)\n{\n\tstruct astobj2 *obj;\n\tstruct astobj2_lock *obj_mutex;\n\tobj = INTERNAL_OBJ_CHECK(user_data);\n\tif (obj == NULL) {\n\t\treturn NULL;\n\t}\n\tswitch (obj->priv_data.options & AO2_ALLOC_OPT_LOCK_MASK) {\n\tcase AO2_ALLOC_OPT_LOCK_MUTEX:\n\t\tobj_mutex = INTERNAL_OBJ_MUTEX(user_data);\n\t\treturn &obj_mutex->mutex.lock;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1746}
{"project": "Asterisk", "target": 0, "func": "static void kqueue_timer_close(void *data)\n{\n\tstruct kqueue_timer *timer = data;\n\tast_debug(5, \"[%d]: Timer Close\\n\", timer->handle);\n\tao2_ref(timer, -1);\n}\n", "bug_type": null, "idx": 1747}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tstruct ast_db_entry *dbtree, *tmp;\n\tchar groupname[AST_MAX_EXTENSION], *ptr;\n\tif ((group_container = ao2_container_alloc(37, group_hash_fn, group_cmp_fn))) {\n\t\t\n\t\tif ((dbtree = ast_db_gettree(\"dialgroup\", NULL))) {\n\t\t\tfor (tmp = dbtree; tmp; tmp = tmp->next) {\n\t\t\t\tast_copy_string(groupname, tmp->key, sizeof(groupname));\n\t\t\t\tif ((ptr = strrchr(groupname, '/'))) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tdialgroup_write(NULL, \"\", ptr, tmp->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_db_freetree(dbtree);\n\t\t}\n\t\treturn ast_custom_function_register(&dialgroup_function);\n\t} else {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n}\n", "bug_type": null, "idx": 1748}
{"project": "Asterisk", "target": 0, "func": "int ast_callerid_callwaiting_generate(unsigned char *buf, const char *name, const char *number, struct ast_format *codec)\n{\n\treturn __ast_callerid_generate(buf, name, number, 1, codec);\n}\n", "bug_type": null, "idx": 1749}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int rb_ao2_integrity(struct ao2_container_rbtree *self)\n{\n\tint res;\n\tint count_node;\n\tint count_obj;\n\tvoid *obj_last;\n\tstruct rbtree_node *node;\n\tres = 0;\n\tcount_node = 0;\n\tcount_obj = 0;\n\t\n\tif (self->root) {\n\t\t\n\t\tif (self->root->parent) {\n\t\t\tif (self->root->parent == self->root) {\n\t\t\t\tast_log(LOG_ERROR, \"Tree root parent pointer points to itself!\\n\");\n\t\t\t} else {\n\t\t\t\tast_log(LOG_ERROR, \"Tree root is not a root node!\\n\");\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (self->root->is_red) {\n\t\t\t\n\t\t\tast_log(LOG_ERROR, \"Tree root is red!\\n\");\n\t\t\tres = -1;\n\t\t}\n\t\tnode = self->root;\n\t\tdo {\n\t\t\tif (node->left) {\n\t\t\t\tif (node->left == node) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Tree node's left pointer points to itself!\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (node->left->parent != node) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Tree node's left child does not link back!\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node->right) {\n\t\t\t\tif (node->right == node) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Tree node's right pointer points to itself!\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (node->right->parent != node) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Tree node's right child does not link back!\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (node->is_red) {\n\t\t\t\t\n\t\t\t\tif (node->left && node->right) {\n\t\t\t\t\t\n\t\t\t\t\tif (node->left->is_red) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tast_log(LOG_ERROR, \"Tree node is red and its left child is red!\\n\");\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (node->right->is_red) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tast_log(LOG_ERROR, \"Tree node is red and its right child is red!\\n\");\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t} else if (node->left || node->right) {\n\t\t\t\t\t\n\t\t\t\t\tast_log(LOG_ERROR, \"Tree node is red and it only has one child!\\n\");\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (node->left && node->right) {\n\t\t\t\t\t\n\t\t\t\t\tif (node->left->is_red != node->right->is_red) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tstruct rbtree_node *red;\n\t\t\t\t\t\tif (node->left->is_red) {\n\t\t\t\t\t\t\tred = node->left;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tred = node->right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!red->left || !red->right) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\t\t\t\t\"Tree node is black and the red child does not have two children!\\n\");\n\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ((node->left && !node->left->is_red)\n\t\t\t\t\t|| (node->right && !node->right->is_red)) {\n\t\t\t\t\t\n\t\t\t\t\tast_log(LOG_ERROR, \"Tree node is black and its only child is black!\\n\");\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t++count_node;\n\t\t\tif (node->common.obj) {\n\t\t\t\t++count_obj;\n\t\t\t}\n\t\t\tnode = rb_node_pre(node);\n\t\t} while (node);\n\t\t\n\t\tobj_last = NULL;\n\t\tfor (node = rb_node_most_left(self->root); node; node = rb_node_next(node)) {\n\t\t\tif (!node->common.obj) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (obj_last) {\n\t\t\t\tif (self->common.sort_fn(obj_last, node->common.obj, OBJ_SEARCH_OBJECT) > 0) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Tree nodes are out of sorted order!\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj_last = node->common.obj;\n\t\t}\n\t\t\n\t\tif (!res && rb_check_black_height(self->root) < 0) {\n\t\t\t\n\t\t\tres = -1;\n\t\t}\n\t}\n\t\n\tif (count_obj != ao2_container_count(&self->common)) {\n\t\tast_log(LOG_ERROR, \"Total object count does not match ao2_container_count()!\\n\");\n\t\treturn -1;\n\t}\n\t\n\tif (count_node != self->common.nodes) {\n\t\tast_log(LOG_ERROR, \"Total node count of %d does not match stat of %d!\\n\",\n\t\t\tcount_node, self->common.nodes);\n\t\treturn -1;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1750}
{"project": "Asterisk", "target": 0, "func": "enum ast_presence_state ast_presence_state_nocache(const char *presence_provider, char **subtype, char **message)\n{\n\treturn ast_presence_state_helper(presence_provider, subtype, message, 0);\n}\n", "bug_type": null, "idx": 1751}
{"project": "Asterisk", "target": 0, "func": " ***/\nstatic int acf_rand_exec(struct ast_channel *chan, const char *cmd,\n\t\t\t char *parse, char *buffer, size_t buflen)\n{\n\tint min_int, response_int, max_int;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t     AST_APP_ARG(min);\n\t\t\t     AST_APP_ARG(max);\n\t);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (ast_strlen_zero(args.min) || sscanf(args.min, \"%30d\", &min_int) != 1)\n\t\tmin_int = 0;\n\tif (ast_strlen_zero(args.max) || sscanf(args.max, \"%30d\", &max_int) != 1)\n\t\tmax_int = RAND_MAX;\n\tif (max_int < min_int) {\n\t\tint tmp = max_int;\n\t\tmax_int = min_int;\n\t\tmin_int = tmp;\n\t\tast_debug(1, \"max<min\\n\");\n\t}\n\tresponse_int = min_int + (ast_random() % (max_int - min_int + 1));\n\tast_debug(1, \"%d was the lucky number in range [%d,%d]\\n\", response_int, min_int, max_int);\n\tsnprintf(buffer, buflen, \"%d\", response_int);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1752}
{"project": "Asterisk", "target": 0, "func": "void stasis_publish_sync(struct stasis_subscription *sub, struct stasis_message *message)\n{\n\tast_assert(sub != NULL);\n\tpublish_msg(sub->topic, message, sub);\n}\n", "bug_type": null, "idx": 1753}
{"project": "Asterisk", "target": 0, "func": "static int consumer_should_stay(struct consumer *consumer, size_t expected_len)\n{\n\tstruct timeval start = ast_tvnow();\n\tstruct timeval diff = {\n\t\t.tv_sec = 0,\n\t\t.tv_usec = 100000 \n\t};\n\tstruct timeval end_tv = ast_tvadd(start, diff);\n\tstruct timespec end = {\n\t\t.tv_sec = end_tv.tv_sec,\n\t\t.tv_nsec = end_tv.tv_usec * 1000\n\t};\n\tSCOPED_AO2LOCK(lock, consumer);\n\twhile (consumer->messages_rxed_len == expected_len) {\n\t\tint r = ast_cond_timedwait(&consumer->out, ao2_object_get_lockaddr(consumer), &end);\n\t\tif (r == ETIMEDOUT) {\n\t\t\tbreak;\n\t\t}\n\t\tast_assert(r == 0); \n\t}\n\treturn consumer->messages_rxed_len;\n}\n", "bug_type": null, "idx": 1754}
{"project": "Asterisk", "target": 0, "func": "int ast_unreal_indicate(struct ast_channel *ast, int condition, const void *data, size_t datalen)\n{\n\tstruct ast_unreal_pvt *p = ast_channel_tech_pvt(ast);\n\tint res = 0;\n\tif (!p) {\n\t\treturn -1;\n\t}\n\tao2_ref(p, 1); \n\tswitch (condition) {\n\tcase AST_CONTROL_MASQUERADE_NOTIFY:\n\t\t\n\t\tbreak;\n\tcase AST_CONTROL_CONNECTED_LINE:\n\tcase AST_CONTROL_REDIRECTING:\n\t\tres = unreal_colp_redirect_indicate(p, ast, condition);\n\t\tbreak;\n\tcase AST_CONTROL_HOLD:\n\t\tif (ast_test_flag(p, AST_UNREAL_MOH_INTERCEPT)) {\n\t\t\tast_moh_start(ast, data, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tres = unreal_queue_indicate(p, ast, condition, data, datalen);\n\t\tbreak;\n\tcase AST_CONTROL_UNHOLD:\n\t\tif (ast_test_flag(p, AST_UNREAL_MOH_INTERCEPT)) {\n\t\t\tast_moh_stop(ast);\n\t\t\tbreak;\n\t\t}\n\t\tres = unreal_queue_indicate(p, ast, condition, data, datalen);\n\t\tbreak;\n\tcase AST_CONTROL_RINGING:\n\t\t\n\t\tif (ast_channel_state(ast) == AST_STATE_RING) {\n\t\t\tres = unreal_queue_indicate(p, ast, condition, data, datalen);\n\t\t} else {\n\t\t\tres = -1;\n\t\t}\n\t\tbreak;\n\tcase AST_CONTROL_PVT_CAUSE_CODE:\n\t\t\n\t\tunreal_queue_indicate(p, ast, condition, data, datalen);\n\t\tres = -1;\n\t\tbreak;\n\tdefault:\n\t\tres = unreal_queue_indicate(p, ast, condition, data, datalen);\n\t\tbreak;\n\t}\n\tao2_ref(p, -1);\n\treturn res;\n}\n", "bug_type": null, "idx": 1755}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int acf_fetch(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tstruct ast_datastore *store;\n\tstruct odbc_datastore *resultset;\n\tstruct odbc_datastore_row *row;\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\tstore = ast_channel_datastore_find(chan, &odbc_info, data);\n\tif (!store) {\n\t\tast_channel_unlock(chan);\n\t\tpbx_builtin_setvar_helper(chan, \"ODBC_FETCH_STATUS\", \"FAILURE\");\n\t\treturn -1;\n\t}\n\tresultset = store->data;\n\tAST_LIST_LOCK(resultset);\n\trow = AST_LIST_REMOVE_HEAD(resultset, list);\n\tAST_LIST_UNLOCK(resultset);\n\tif (!row) {\n\t\t\n\t\tast_channel_datastore_remove(chan, store);\n\t\tast_datastore_free(store);\n\t\tast_channel_unlock(chan);\n\t\tpbx_builtin_setvar_helper(chan, \"ODBC_FETCH_STATUS\", \"FAILURE\");\n\t\treturn -1;\n\t}\n\tpbx_builtin_setvar_helper(chan, \"~ODBCFIELDS~\", resultset->names);\n\tast_channel_unlock(chan);\n\tast_copy_string(buf, row->data, len);\n\tast_free(row);\n\tpbx_builtin_setvar_helper(chan, \"ODBC_FETCH_STATUS\", \"SUCCESS\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 1756}
{"project": "Asterisk", "target": 0, "func": "static void analog_cb_handle_dtmf(struct analog_pvt *p, struct ast_channel *ast, enum analog_sub analog_index, struct ast_frame **dest)\n{\n\tif (analog_callbacks.handle_dtmf) {\n\t\tanalog_callbacks.handle_dtmf(p->chan_pvt, ast, analog_index, dest);\n\t}\n}\n", "bug_type": null, "idx": 1757}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct stasis_topic *corosync_topic(void)\n{\n\treturn corosync_aggregate_topic;\n}\n", "bug_type": null, "idx": 1758}
{"project": "Asterisk", "target": 0, "func": "\nstatic int unload_module(void)\n{\n\tao2_callback(cli_aliases, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, alias_unregister_cb, NULL);\n\tif (ao2_container_count(cli_aliases)) {\n\t\tast_log(LOG_ERROR, \"Could not unregister all CLI aliases\\n\");\n\t\treturn -1;\n\t}\n\tao2_ref(cli_aliases, -1);\n\tast_cli_unregister_multiple(cli_alias, ARRAY_LEN(cli_alias));\n\treturn 0;\n}\n", "bug_type": null, "idx": 1759}
{"project": "Asterisk", "target": 0, "func": "void ast_sched_clean_by_callback(struct ast_sched_context *con, ast_sched_cb match, ast_sched_cb cleanup_cb)\n{\n\tint i = 1;\n\tstruct sched *current;\n\tast_mutex_lock(&con->lock);\n\twhile ((current = ast_heap_peek(con->sched_heap, i))) {\n\t\tif (current->callback != match) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tast_heap_remove(con->sched_heap, current);\n\t\tcleanup_cb(current->data);\n\t\tsched_release(con, current);\n\t}\n\tast_mutex_unlock(&con->lock);\n}\n", "bug_type": null, "idx": 1760}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int mwi_has_voicemail(const char *mailboxes, const char *folder)\n{\n\tchar *parse;\n\tchar *mailbox_id;\n\tenum folder_map which_folder;\n\twhich_folder = mwi_folder_map(folder);\n\tif (which_folder == FOLDER_INVALID) {\n\t\treturn 0;\n\t}\n\t\n\tparse = ast_strdupa(mailboxes);\n\twhile ((mailbox_id = strsep(&parse, \",&\"))) {\n\t\tconst struct ast_mwi_mailbox_object *mailbox;\n\t\tint num_msgs;\n\t\t\n\t\tmailbox = ast_mwi_mailbox_get(mailbox_id);\n\t\tif (!mailbox) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tnum_msgs = 0;\n\t\tswitch (which_folder) {\n\t\tcase FOLDER_INVALID:\n\t\t\tbreak;\n\t\tcase FOLDER_INBOX:\n\t\t\tnum_msgs = mailbox->msgs_new;\n\t\t\tbreak;\n\t\tcase FOLDER_OLD:\n\t\t\tnum_msgs = mailbox->msgs_old;\n\t\t\tbreak;\n\t\t}\n\t\tast_mwi_mailbox_unref(mailbox);\n\t\tif (num_msgs) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1761}
{"project": "Asterisk", "target": 0, "func": "static struct ast_format *vp8_parse_sdp_fmtp(const struct ast_format *format, const char *attributes)\n{\n\tstruct ast_format *cloned;\n\tstruct vp8_attr *attr;\n\tconst char *kvp;\n\tunsigned int val;\n\tcloned = ast_format_clone(format);\n\tif (!cloned) {\n\t\treturn NULL;\n\t}\n\tattr = ast_format_get_attribute_data(cloned);\n\tif ((kvp = strstr(attributes, \"max-fr\")) && sscanf(kvp, \"max-fr=%30u\", &val) == 1) {\n\t\tattr->maximum_frame_rate = val;\n\t} else {\n\t\tattr->maximum_frame_rate = UINT_MAX;\n\t}\n\tif ((kvp = strstr(attributes, \"max-fs\")) && sscanf(kvp, \"max-fs=%30u\", &val) == 1) {\n\t\tattr->maximum_frame_size = val;\n\t} else {\n\t\tattr->maximum_frame_size = UINT_MAX;\n\t}\n\treturn cloned;\n}\n", "bug_type": null, "idx": 1762}
{"project": "Asterisk", "target": 0, "func": "static int internal_feature_write(struct ast_channel *chan, const char *cmd, char *data,\n\t\tconst char *value)\n{\n\tint res;\n\tRAII_VAR(struct features_config *, cfg, NULL, ao2_cleanup);\n\tSCOPED_CHANNELLOCK(lock, chan);\n\tif (!strcasecmp(data, \"inherit\")) {\n\t\tstruct ast_datastore *ds = get_feature_chan_ds(chan);\n\t\tif (ds) {\n\t\t\tds->inheritance = ast_true(value) ? DATASTORE_INHERIT_FOREVER : 0;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!(cfg = get_feature_ds(chan))) {\n\t\treturn -1;\n\t}\n\tres = general_set(cfg->global->general, data, value) &&\n\t\txfer_set(cfg->global->xfer, data, value) &&\n\t\tpickup_set(cfg->global->pickup, data, value);\n\tif (res) {\n\t\tast_log(LOG_WARNING, \"Invalid argument '%s' to FEATURE()\\n\", data);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1763}
{"project": "Asterisk", "target": 0, "func": "static char *run_command(char *command)\n{\n\tfprintf(stdout, \"%s\\n\", command);\n\treturn wait_result();\n}\n", "bug_type": null, "idx": 1764}
{"project": "Asterisk", "target": 0, "func": "static int alsa_write(struct ast_channel *chan, struct ast_frame *f)\n{\n\tstatic char sizbuf[8000];\n\tstatic int sizpos = 0;\n\tint len = sizpos;\n\tint res = 0;\n\t\n\tsnd_pcm_state_t state;\n\tast_mutex_lock(&alsalock);\n\t\n\tif (f->datalen > sizeof(sizbuf) - sizpos) {\n\t\tast_log(LOG_WARNING, \"Frame too large\\n\");\n\t\tres = -1;\n\t} else {\n\t\tmemcpy(sizbuf + sizpos, f->data.ptr, f->datalen);\n\t\tlen += f->datalen;\n\t\tstate = snd_pcm_state(alsa.ocard);\n\t\tif (state == SND_PCM_STATE_XRUN)\n\t\t\tsnd_pcm_prepare(alsa.ocard);\n\t\twhile ((res = snd_pcm_writei(alsa.ocard, sizbuf, len / 2)) == -EAGAIN) {\n\t\t\tusleep(1);\n\t\t}\n\t\tif (res == -EPIPE) {\n#if DEBUG\n\t\t\tast_debug(1, \"XRUN write\\n\");\n#endif\n\t\t\tsnd_pcm_prepare(alsa.ocard);\n\t\t\twhile ((res = snd_pcm_writei(alsa.ocard, sizbuf, len / 2)) == -EAGAIN) {\n\t\t\t\tusleep(1);\n\t\t\t}\n\t\t\tif (res != len / 2) {\n\t\t\t\tast_log(LOG_ERROR, \"Write error: %s\\n\", snd_strerror(res));\n\t\t\t\tres = -1;\n\t\t\t} else if (res < 0) {\n\t\t\t\tast_log(LOG_ERROR, \"Write error %s\\n\", snd_strerror(res));\n\t\t\t\tres = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (res == -ESTRPIPE)\n\t\t\t\tast_log(LOG_ERROR, \"You've got some big problems\\n\");\n\t\t\telse if (res < 0)\n\t\t\t\tast_log(LOG_NOTICE, \"Error %d on write\\n\", res);\n\t\t}\n\t}\n\tast_mutex_unlock(&alsalock);\n\treturn res >= 0 ? 0 : res;\n}\n", "bug_type": null, "idx": 1765}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int function_eval(struct ast_channel *chan, const char *cmd, char *data,\n\t\t\t char *buf, size_t buflen)\n{\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"EVAL requires an argument: EVAL(<string>)\\n\");\n\t\treturn -1;\n\t}\n\tpbx_substitute_variables_helper(chan, data, buf, buflen - 1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1766}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void pbx_retrieve_variable(struct ast_channel *c, const char *var, char **ret, char *workspace, int workspacelen, struct varshead *headp)\n{\n\tconst char not_found = '\\0';\n\tchar *tmpvar;\n\tconst char *s;\t\n\tint offset, length;\n\tint i, need_substring;\n\tstruct varshead *places[2] = { headp, &globals };\t\n\t\n\ttmpvar = ast_strdupa(var);\t\n\tneed_substring = parse_variable_name(tmpvar, &offset, &length, &i );\n\t\n\ts = &not_found;\t\n\tif (s == &not_found) { \n\t\tif (!strcmp(var, \"EPOCH\")) {\n\t\t\tsnprintf(workspace, workspacelen, \"%u\",(int)time(NULL));\n\t\t}\n\t\ts = workspace;\n\t}\n\t\n\tfor (i = 0; s == &not_found && i < (sizeof(places) / sizeof(places[0])); i++) {\n\t\tstruct ast_var_t *variables;\n\t\tif (!places[i])\n\t\t\tcontinue;\n\t\tif (places[i] == &globals)\n\t\t\tast_rwlock_rdlock(&globalslock);\n\t\tAST_LIST_TRAVERSE(places[i], variables, entries) {\n\t\t\tif (strcasecmp(ast_var_name(variables), var)==0) {\n\t\t\t\ts = ast_var_value(variables);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (places[i] == &globals)\n\t\t\tast_rwlock_unlock(&globalslock);\n\t}\n\tif (s == &not_found || s == NULL)\n\t\t*ret = NULL;\n\telse {\n\t\tif (s != workspace)\n\t\t\tast_copy_string(workspace, s, workspacelen);\n\t\t*ret = workspace;\n\t\tif (need_substring)\n\t\t\t*ret = substring(*ret, offset, length, workspace, workspacelen);\n\t}\n}\n", "bug_type": null, "idx": 1767}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *wav_read(struct ast_filestream *s, int *whennext)\n{\n\t\n\tstruct wavg_desc *fs = (struct wavg_desc *)s->_private;\n\ts->fr.samples = GSM_SAMPLES;\n\tAST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, GSM_FRAME_SIZE);\n\tif (fs->secondhalf) {\n\t\t\n\t\ts->fr.data.ptr = (char *)s->fr.data.ptr + GSM_FRAME_SIZE;\n\t\ts->fr.offset += GSM_FRAME_SIZE;\n\t} else {\n\t\t\n\t\tunsigned char msdata[MSGSM_FRAME_SIZE];\n\t\tsize_t res;\n\t\tif ((res = fread(msdata, 1, MSGSM_FRAME_SIZE, s->f)) != MSGSM_FRAME_SIZE) {\n\t\t\tif (res && res != 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Short read of %s data (expected %d bytes, read %zu): %s\\n\",\n\t\t\t\t\t\tast_format_get_name(s->fr.subclass.format), MSGSM_FRAME_SIZE, res,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tconv65(msdata, s->fr.data.ptr);\n\t}\n\tfs->secondhalf = !fs->secondhalf;\n\t*whennext = GSM_SAMPLES;\n\treturn &s->fr;\n}\n", "bug_type": null, "idx": 1768}
{"project": "Asterisk", "target": 0, "func": "int ooAddRemoteAudioCapability(OOH323CallData *call, \n                               H245AudioCapability *audioCap,\n                               int dir)\n{\n   int rxframes=0, txframes=0;\n   switch(audioCap->t)\n   {\n   case T_H245AudioCapability_g711Alaw64k:\n      if(dir&OOTX) txframes = audioCap->u.g711Alaw64k;\n      else if(dir&OORX) rxframes = audioCap->u.g711Alaw64k;\n      else{ \n         txframes = audioCap->u.g711Alaw64k; \n         rxframes = audioCap->u.g711Alaw64k; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G711ALAW64K, txframes, \n                            rxframes, FALSE, dir, NULL, NULL, NULL, NULL,TRUE);\n   case T_H245AudioCapability_g711Alaw56k:\n      if(dir&OOTX) txframes = audioCap->u.g711Alaw56k;\n      else if(dir&OORX) rxframes = audioCap->u.g711Alaw56k;\n      else{ \n         txframes = audioCap->u.g711Alaw56k; \n         rxframes = audioCap->u.g711Alaw56k; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G711ALAW56K, txframes, \n                           rxframes, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_g711Ulaw64k:\n      if(dir&OOTX) txframes = audioCap->u.g711Ulaw64k;\n      else if(dir&OORX) rxframes = audioCap->u.g711Ulaw64k;\n      else{ \n         txframes = audioCap->u.g711Ulaw64k; \n         rxframes = audioCap->u.g711Ulaw64k; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G711ULAW64K, txframes, \n                           rxframes, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_g711Ulaw56k:\n      if(dir&OOTX) txframes = audioCap->u.g711Ulaw56k;\n      else if(dir&OORX) rxframes = audioCap->u.g711Ulaw56k;\n      else{ \n         txframes = audioCap->u.g711Ulaw56k; \n         rxframes = audioCap->u.g711Ulaw56k; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G711ULAW56K, txframes, \n                           rxframes, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n\n   case T_H245AudioCapability_nonStandard:\n      if (audioCap->u.nonStandard && \n          audioCap->u.nonStandard->nonStandardIdentifier.t == \n           T_H245NonStandardIdentifier_h221NonStandard &&\n          audioCap->u.nonStandard->data.numocts == sizeof(\"G.726-32k\")-1 &&\n          !strncmp((char *)audioCap->u.nonStandard->data.data, \"G.726-32k\", \n                   audioCap->u.nonStandard->data.numocts))\n      return ooCapabilityAddSimpleCapability(call, OO_G726, 20, \n                           240, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n      if (audioCap->u.nonStandard && \n          audioCap->u.nonStandard->nonStandardIdentifier.t == \n           T_H245NonStandardIdentifier_h221NonStandard &&\n          audioCap->u.nonStandard->data.numocts == sizeof(\"G726r32\")-1 &&\n          !strncmp((char *)audioCap->u.nonStandard->data.data, \"G726r32\", \n                   audioCap->u.nonStandard->data.numocts))\n      return ooCapabilityAddSimpleCapability(call, OO_G726AAL2, 20, \n                           240, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n      if (audioCap->u.nonStandard && \n          audioCap->u.nonStandard->nonStandardIdentifier.t == \n           T_H245NonStandardIdentifier_h221NonStandard &&\n          audioCap->u.nonStandard->data.numocts == sizeof(\"AMRNB\")-1 &&\n          !strncmp((char *)audioCap->u.nonStandard->data.data, \"AMRNB\", \n                   audioCap->u.nonStandard->data.numocts))\n      return ooCapabilityAddSimpleCapability(call, OO_AMRNB, 4, \n                           4, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n      if (audioCap->u.nonStandard && \n          audioCap->u.nonStandard->nonStandardIdentifier.t == \n           T_H245NonStandardIdentifier_h221NonStandard &&\n          audioCap->u.nonStandard->data.numocts == sizeof(\"Speex\")-1 &&\n          !strncmp((char *)audioCap->u.nonStandard->data.data, \"Speex\", \n                   audioCap->u.nonStandard->data.numocts))\n      return ooCapabilityAddSimpleCapability(call, OO_SPEEX, 4, \n                           4, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n      break;\n   case T_H245AudioCapability_g728:\n      if(dir&OOTX) txframes = audioCap->u.g728;\n      else if(dir&OORX) rxframes = audioCap->u.g728;\n      else{ \n         txframes = audioCap->u.g728; \n         rxframes = audioCap->u.g728; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G728, txframes, \n                           rxframes, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_g729:\n      if(dir&OOTX) txframes = audioCap->u.g729;\n      else if(dir&OORX) rxframes = audioCap->u.g729;\n      else{ \n         txframes = audioCap->u.g729; \n         rxframes = audioCap->u.g729; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G729, txframes, \n                           rxframes, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_g729AnnexA:\n      if(dir&OOTX) txframes = audioCap->u.g729AnnexA;\n      else if(dir&OORX) rxframes = audioCap->u.g729AnnexA;\n      else{ \n         txframes = audioCap->u.g729AnnexA; \n         rxframes = audioCap->u.g729AnnexA; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G729A, txframes, \n                           rxframes, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_g729wAnnexB:\n      if(dir&OOTX) txframes = audioCap->u.g729wAnnexB;\n      else if(dir&OORX) rxframes = audioCap->u.g729wAnnexB;\n      else{ \n         txframes = audioCap->u.g729wAnnexB; \n         rxframes = audioCap->u.g729wAnnexB; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G729B, txframes, \n                           rxframes, FALSE, dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_g7231:\n      if(dir&OOTX) txframes = audioCap->u.g7231->maxAl_sduAudioFrames;\n      else if(dir&OORX) rxframes = audioCap->u.g7231->maxAl_sduAudioFrames;\n      else{ \n         txframes = audioCap->u.g7231->maxAl_sduAudioFrames; \n         rxframes = audioCap->u.g7231->maxAl_sduAudioFrames; \n      }\n      return ooCapabilityAddSimpleCapability(call, OO_G7231, txframes,rxframes,\n                                         audioCap->u.g7231->silenceSuppression,\n                                         dir, NULL, NULL, NULL, NULL, TRUE); \n   case T_H245AudioCapability_gsmFullRate:\n      return ooCapabilityAddGSMCapability(call, OO_GSMFULLRATE, \n            (unsigned)(audioCap->u.gsmFullRate->audioUnitSize/OO_GSMFRAMESIZE),\n                                        audioCap->u.gsmFullRate->comfortNoise,\n                                        audioCap->u.gsmFullRate->scrambled, \n                                        dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_gsmHalfRate:\n      return ooCapabilityAddGSMCapability(call, OO_GSMHALFRATE,\n            (unsigned)(audioCap->u.gsmHalfRate->audioUnitSize/OO_GSMFRAMESIZE),\n                                        audioCap->u.gsmHalfRate->comfortNoise,\n                                        audioCap->u.gsmHalfRate->scrambled, \n                                        dir, NULL, NULL, NULL, NULL, TRUE);\n   case T_H245AudioCapability_gsmEnhancedFullRate:\n      return ooCapabilityAddGSMCapability(call, OO_GSMENHANCEDFULLRATE, \n   (unsigned)(audioCap->u.gsmEnhancedFullRate->audioUnitSize/OO_GSMFRAMESIZE),\n                                audioCap->u.gsmEnhancedFullRate->comfortNoise,\n                                audioCap->u.gsmEnhancedFullRate->scrambled, \n                                dir, NULL, NULL, NULL, NULL, TRUE);\n   default:\n     OOTRACEDBGA1(\"Unsupported audio capability type\\n\");\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1769}
{"project": "Asterisk", "target": 0, "func": "int ast_local_init(void)\n{\n\tif (STASIS_MESSAGE_TYPE_INIT(ast_local_optimization_begin_type)) {\n\t\treturn -1;\n\t}\n\tif (STASIS_MESSAGE_TYPE_INIT(ast_local_optimization_end_type)) {\n\t\treturn -1;\n\t}\n\tif (STASIS_MESSAGE_TYPE_INIT(ast_local_bridge_type)) {\n\t\treturn -1;\n\t}\n\tif (!(local_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {\n\t\treturn -1;\n\t}\n\tast_format_cap_append_by_type(local_tech.capabilities, AST_MEDIA_TYPE_UNKNOWN);\n\tlocals = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, locals_cmp_cb);\n\tif (!locals) {\n\t\tao2_cleanup(local_tech.capabilities);\n\t\tlocal_tech.capabilities = NULL;\n\t\treturn -1;\n\t}\n\t\n\tif (ast_channel_register(&local_tech)) {\n\t\tast_log(LOG_ERROR, \"Unable to register channel class 'Local'\\n\");\n\t\tao2_ref(locals, -1);\n\t\tao2_cleanup(local_tech.capabilities);\n\t\tlocal_tech.capabilities = NULL;\n\t\treturn -1;\n\t}\n\tast_cli_register_multiple(cli_local, ARRAY_LEN(cli_local));\n\tast_manager_register_xml_core(\"LocalOptimizeAway\", EVENT_FLAG_SYSTEM|EVENT_FLAG_CALL, manager_optimize_away);\n\tast_register_cleanup(local_shutdown);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1770}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpSetCallerID (const char* callerID)\n{\n   if (0 != callerID) {\n      char* pstr = (char*) memAlloc (&gH323ep.ctxt, strlen(callerID)+1);\n      strcpy (pstr, callerID);\n      if(gH323ep.callerid)\n         memFreePtr(&gH323ep.ctxt, gH323ep.callerid);\n      gH323ep.callerid = pstr;\n      return OO_OK;\n   }\n   else return OO_FAILED;\n}\n", "bug_type": null, "idx": 1771}
{"project": "Asterisk", "target": 0, "func": "static int analog_start(struct analog_pvt *p)\n{\n\tif (analog_callbacks.start) {\n\t\treturn analog_callbacks.start(p->chan_pvt);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1772}
{"project": "Asterisk", "target": 1, "func": "\nstatic void to_ami(struct ast_sip_subscription *sub,\n\t\t   struct ast_str **buf)\n{\n\tstruct exten_state_subscription *exten_state_sub =\n\t\tget_exten_state_sub(sub);\n\tast_str_append(buf, 0, \"SubscriptionType: extension_state\\r\\n\"\n\t\t       \"Extension: %s\\r\\nExtensionStates: %s\\r\\n\",\n\t\t       exten_state_sub->exten, ast_extension_state2str(\n\t\t\t       exten_state_sub->last_exten_state));\n}\n", "bug_type": "CVE-2014-2289-2", "idx": 1773}
{"project": "Asterisk", "target": 1, "func": "\nstatic int handle_request_update(struct sip_pvt *p, struct sip_request *req)\n{\n\tif (ast_strlen_zero(get_header(req, \"X-Asterisk-rpid-update\"))) {\n\t\ttransmit_response(p, \"501 Method Not Implemented\", req);\n\t\treturn 0;\n\t}\n\tif (get_rpid(p, req)) {\n\t\tstruct ast_party_connected_line connected;\n\t\tstruct ast_set_party_connected_line update_connected;\n\t\tast_party_connected_line_init(&connected);\n\t\tmemset(&update_connected, 0, sizeof(update_connected));\n\t\tif (p->cid_num) {\n\t\t\tupdate_connected.id.number = 1;\n\t\t\tconnected.id.number.valid = 1;\n\t\t\tconnected.id.number.str = (char *) p->cid_num;\n\t\t\tconnected.id.number.presentation = p->callingpres;\n\t\t}\n\t\tif (p->cid_name) {\n\t\t\tupdate_connected.id.name = 1;\n\t\t\tconnected.id.name.valid = 1;\n\t\t\tconnected.id.name.str = (char *) p->cid_name;\n\t\t\tconnected.id.name.presentation = p->callingpres;\n\t\t}\n\t\tconnected.id.tag = (char *) p->cid_tag;\n\t\tconnected.source = AST_CONNECTED_LINE_UPDATE_SOURCE_TRANSFER;\n\t\tast_channel_queue_connected_line_update(p->owner, &connected, &update_connected);\n\t}\n\ttransmit_response(p, \"200 OK\", req);\n\treturn 0;\n}\n", "bug_type": "CVE-2012-2947", "idx": 1774}
{"project": "Asterisk", "target": 0, "func": "int ooCallSetCallerId(OOH323CallData* call, const char* callerid)\n{\n   if(!call || !callerid) return OO_FAILED;\n   strncpy(call->ourCallerId, callerid, sizeof(call->ourCallerId)-1);\n   call->ourCallerId[sizeof(call->ourCallerId)-1]='\\0';\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1775}
{"project": "Asterisk", "target": 0, "func": " */\nint *ast_io_add(struct io_context *ioc, int fd, ast_io_cb callback, short events, void *data)\n{\n\tint *ret;\n\tDEBUG(ast_debug(1, \"ast_io_add()\\n\"));\n\tif (ioc->fdcnt >= ioc->maxfdcnt) {\n\t\t\n\t\tif (io_grow(ioc))\n\t\t\treturn NULL;\n\t}\n\t\n\tioc->fds[ioc->fdcnt].fd = fd;\n\tioc->fds[ioc->fdcnt].events = events;\n\tioc->fds[ioc->fdcnt].revents = 0;\n\tioc->ior[ioc->fdcnt].callback = callback;\n\tioc->ior[ioc->fdcnt].data = data;\n\tif (!(ioc->ior[ioc->fdcnt].id = ast_malloc(sizeof(*ioc->ior[ioc->fdcnt].id)))) {\n\t\t\n\t\treturn NULL;\n\t}\n\t*(ioc->ior[ioc->fdcnt].id) = ioc->fdcnt;\n\tret = ioc->ior[ioc->fdcnt].id;\n\tioc->fdcnt++;\n\treturn ret;\n}\n", "bug_type": null, "idx": 1776}
{"project": "Asterisk", "target": 0, "func": "int messaging_init(void)\n{\n\tendpoint_subscriptions = ao2_t_container_alloc_hash(AO2_ALLOC_OPT_LOCK_RWLOCK, 0,\n\t\tENDPOINTS_NUM_BUCKETS, message_subscription_hash_cb, NULL,\n\t\tmessage_subscription_compare_cb, \"Endpoint messaging subscription container creation\");\n\tif (!endpoint_subscriptions) {\n\t\treturn -1;\n\t}\n\tif (AST_VECTOR_INIT(&tech_subscriptions, 4)) {\n\t\tao2_ref(endpoint_subscriptions, -1);\n\t\treturn -1;\n\t}\n\tif (ast_rwlock_init(&tech_subscriptions_lock)) {\n\t\tao2_ref(endpoint_subscriptions, -1);\n\t\tAST_VECTOR_FREE(&tech_subscriptions);\n\t\treturn -1;\n\t}\n\tif (ast_msg_handler_register(&ari_msg_handler)) {\n\t\tao2_ref(endpoint_subscriptions, -1);\n\t\tAST_VECTOR_FREE(&tech_subscriptions);\n\t\tast_rwlock_destroy(&tech_subscriptions_lock);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1777}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(uri_default_http_secure);\n\tAST_TEST_UNREGISTER(uri_default_http);\n\tAST_TEST_UNREGISTER(uri_parse);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1778}
{"project": "Asterisk", "target": 0, "func": "static int local_task_exe(struct ast_taskprocessor_local *local)\n{\n\tint *local_data = local->local_data;\n\tstruct task_data *task_data = local->data;\n\t*local_data = 1;\n\ttask(task_data);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1779}
{"project": "Asterisk", "target": 0, "func": "static const char *channel_snapshot_get_name(struct stasis_message *message)\n{\n\tstruct ast_channel_snapshot *snapshot;\n\tif (ast_channel_snapshot_type() != stasis_message_type(message)) {\n\t\treturn NULL;\n\t}\n\tsnapshot = stasis_message_data(message);\n\treturn snapshot->name;\n}\n", "bug_type": null, "idx": 1780}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_ssl_init(void)\n{\n\tunsigned int i;\n\tint (*real_SSL_library_init)(void);\n\tvoid (*real_CRYPTO_set_id_callback)(unsigned long (*)(void));\n\tvoid (*real_CRYPTO_set_locking_callback)(void (*)(int, int, const char *, int));\n\tvoid (*real_SSL_load_error_strings)(void);\n\tconst char *errstr;\n\t\n\tdlerror();\n\tget_OpenSSL_function(SSL_library_init);\n\tif ((errstr = dlerror()) != NULL) {\n\t\tast_debug(1, \"unable to get real address of SSL_library_init: %s\\n\", errstr);\n\t\t\n\t\treturn -1;\n\t} else {\n\t\treal_SSL_library_init();\n\t}\n\t\n\tdlerror();\n\tget_OpenSSL_function(CRYPTO_set_id_callback);\n\tif ((errstr = dlerror()) != NULL) {\n\t\tast_debug(1, \"unable to get real address of CRYPTO_set_id_callback: %s\\n\", errstr);\n\t\t\n\t\treturn -1;\n\t} else {\n\t\treal_CRYPTO_set_id_callback(ssl_threadid);\n\t}\n\tdlerror();\n\tget_OpenSSL_function(CRYPTO_set_locking_callback);\n\tif ((errstr = dlerror()) != NULL) {\n\t\tast_debug(1, \"unable to get real address of CRYPTO_set_locking_callback: %s\\n\", errstr);\n\t\t\n\t\treturn -1;\n\t} else {\n\t\tssl_num_locks = CRYPTO_num_locks();\n\t\tif (!(ssl_locks = ast_calloc(ssl_num_locks, sizeof(ssl_locks[0])))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < ssl_num_locks; i++) {\n\t\t\tast_mutex_init(&ssl_locks[i]);\n\t\t}\n\t\treal_CRYPTO_set_locking_callback(ssl_lock);\n\t}\n\t\n\tget_OpenSSL_function(SSL_load_error_strings);\n\treal_SSL_load_error_strings();\n\tstartup_complete = 1;\n\treturn 0;\n}\n#else\nint ast_ssl_init(void)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1781}
{"project": "Asterisk", "target": 0, "func": "\nstatic void endpoint_cache_clear(void *data,\n\tstruct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tstruct ast_endpoint *endpoint = data;\n\tstruct stasis_message *clear_msg = stasis_message_data(message);\n\tstruct ast_channel_snapshot *clear_snapshot;\n\tif (stasis_message_type(clear_msg) != ast_channel_snapshot_type()) {\n\t\treturn;\n\t}\n\tclear_snapshot = stasis_message_data(clear_msg);\n\tast_assert(endpoint != NULL);\n\tao2_lock(endpoint);\n\tast_str_container_remove(endpoint->channel_ids, clear_snapshot->uniqueid);\n\tao2_unlock(endpoint);\n\tendpoint_publish_snapshot(endpoint);\n}\n", "bug_type": null, "idx": 1782}
{"project": "Asterisk", "target": 0, "func": "static int pbx_load_module(void)\n{\n\tstruct ast_context *con;\n\tast_mutex_lock(&reload_lock);\n\tif (!local_table)\n\t\tlocal_table = ast_hashtab_create(17, ast_hashtab_compare_contexts, ast_hashtab_resize_java, ast_hashtab_newsize_java, ast_hashtab_hash_contexts, 0);\n\tif (!pbx_load_config(config)) {\n\t\tast_mutex_unlock(&reload_lock);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tpbx_load_users();\n\tast_merge_contexts_and_delete(&local_contexts, local_table, registrar);\n\tlocal_table = NULL; \n\tlocal_contexts = NULL;\n\tast_mutex_unlock(&reload_lock);\n\tfor (con = NULL; (con = ast_walk_contexts(con));)\n\t\tast_context_verify_includes(con);\n\tpbx_set_overrideswitch(overrideswitch_config);\n\tpbx_set_autofallthrough(autofallthrough_config);\n\tpbx_set_extenpatternmatchnew(extenpatternmatchnew_config);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1783}
{"project": "Asterisk", "target": 0, "func": "STASIS_MESSAGE_TYPE_DEFN(ast_format_unregister_type);\nstatic struct ast_json *json_array_from_list(const char *list, const char *sep)\n{\n\tRAII_VAR(struct ast_json *, array, ast_json_array_create(), ast_json_unref);\n\tchar *stringp, *ext;\n\tstringp = ast_strdupa(list);\t\n\tif (!array || !stringp) {\n\t\treturn NULL;\n\t}\n\twhile ((ext = strsep(&stringp, sep))) {\n\t\tif (ast_json_array_append(array, ast_json_string_create(ext))) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ast_json_ref(array);\n}\n", "bug_type": null, "idx": 1784}
{"project": "Asterisk", "target": 0, "func": "const char *ast_endpoint_get_resource(const struct ast_endpoint *endpoint)\n{\n\tif (!endpoint) {\n\t\treturn NULL;\n\t}\n\treturn endpoint->resource;\n}\n", "bug_type": null, "idx": 1785}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hintdevice_cmp_multiple(void *obj, void *arg, int flags)\n{\n\tstruct ast_hintdevice *left = obj;\n\tstruct ast_hintdevice *right = arg;\n\tconst char *right_key = arg;\n\tint cmp;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_OBJECT:\n\t\tright_key = right->hintdevice;\n\t\t\n\tcase OBJ_SEARCH_KEY:\n\t\tcmp = strcasecmp(left->hintdevice, right_key);\n\t\tbreak;\n\tcase OBJ_SEARCH_PARTIAL_KEY:\n\t\t\n\t\tcmp = strncmp(left->hintdevice, right_key, strlen(right_key));\n\t\tbreak;\n\tdefault:\n\t\tast_assert(0);\n\t\tcmp = 0;\n\t\tbreak;\n\t}\n\treturn cmp ? 0 : CMP_MATCH;\n}\n", "bug_type": null, "idx": 1786}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\t\n\trouter = stasis_message_router_create(\n\t\tast_channel_topic_all_cached());\n\tif (!router) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tstasis_message_router_add(router, stasis_cache_update_type(),\n\t\tupdates, NULL);\n\tstasis_message_router_set_default(router, default_route, NULL);\n\t\n\tsub = stasis_subscribe(ast_channel_topic_all(), statsmaker, NULL);\n\tif (!sub) {\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1787}
{"project": "Asterisk", "target": 0, "func": "\nint ast_unreal_queryoption(struct ast_channel *ast, int option, void *data, int *datalen)\n{\n\tstruct ast_unreal_pvt *p;\n\tstruct ast_channel *peer;\n\tstruct ast_channel *other;\n\tint res = 0;\n\tif (option != AST_OPTION_T38_STATE) {\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tif (!(p = ast_channel_tech_pvt(ast))) {\n\t\treturn -1;\n\t}\n\tao2_lock(p);\n\tother = AST_UNREAL_IS_OUTBOUND(ast, p) ? p->owner : p->chan;\n\tif (!other) {\n\t\tao2_unlock(p);\n\t\treturn -1;\n\t}\n\tast_channel_ref(other);\n\tao2_unlock(p);\n\tast_channel_unlock(ast); \n\tpeer = ast_channel_bridge_peer(other);\n\tif (peer) {\n\t\tres = ast_channel_queryoption(peer, option, data, datalen, 0);\n\t\tast_channel_unref(peer);\n\t}\n\tast_channel_unref(other);\n\tast_channel_lock(ast); \n\treturn res;\n}\n", "bug_type": null, "idx": 1788}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_ari_channels_create_cb(\n\tstruct ast_tcptls_session_instance *ser,\n\tstruct ast_variable *get_params, struct ast_variable *path_vars,\n\tstruct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)\n{\n\tstruct ast_ari_channels_create_args args = {};\n\tstruct ast_variable *i;\n#if defined(AST_DEVMODE)\n\tint is_valid;\n\tint code;\n#endif \n\tfor (i = get_params; i; i = i->next) {\n\t\tif (strcmp(i->name, \"endpoint\") == 0) {\n\t\t\targs.endpoint = (i->value);\n\t\t} else\n\t\tif (strcmp(i->name, \"app\") == 0) {\n\t\t\targs.app = (i->value);\n\t\t} else\n\t\tif (strcmp(i->name, \"appArgs\") == 0) {\n\t\t\targs.app_args = (i->value);\n\t\t} else\n\t\tif (strcmp(i->name, \"channelId\") == 0) {\n\t\t\targs.channel_id = (i->value);\n\t\t} else\n\t\tif (strcmp(i->name, \"otherChannelId\") == 0) {\n\t\t\targs.other_channel_id = (i->value);\n\t\t} else\n\t\tif (strcmp(i->name, \"originator\") == 0) {\n\t\t\targs.originator = (i->value);\n\t\t} else\n\t\tif (strcmp(i->name, \"formats\") == 0) {\n\t\t\targs.formats = (i->value);\n\t\t} else\n\t\t{}\n\t}\n\tif (ast_ari_channels_create_parse_body(body, &args)) {\n\t\tast_ari_response_alloc_failed(response);\n\t\tgoto fin;\n\t}\n\tast_ari_channels_create(headers, &args, response);\n#if defined(AST_DEVMODE)\n\tcode = response->response_code;\n\tswitch (code) {\n\tcase 0: \n\t\tis_valid = response->message == NULL;\n\t\tbreak;\n\tcase 500: \n\tcase 501: \n\tcase 409: \n\t\tis_valid = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (200 <= code && code <= 299) {\n\t\t\tis_valid = ast_ari_validate_channel(\n\t\t\t\tresponse->message);\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Invalid error response %d for /channels/create\\n\", code);\n\t\t\tis_valid = 0;\n\t\t}\n\t}\n\tif (!is_valid) {\n\t\tast_log(LOG_ERROR, \"Response validation failed for /channels/create\\n\");\n\t\tast_ari_response_error(response, 500,\n\t\t\t\"Internal Server Error\", \"Response validation failed\");\n\t}\n#endif \nfin: __attribute__((unused))\n\treturn;\n}\n", "bug_type": null, "idx": 1789}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic char *handle_cli_file_convert(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tchar *ret = CLI_FAILURE;\n\tstruct ast_filestream *fs_in = NULL, *fs_out = NULL;\n\tstruct ast_frame *f;\n\tstruct timeval start;\n\tint cost;\n\tchar *file_in = NULL, *file_out = NULL;\n\tchar *name_in, *ext_in, *name_out, *ext_out;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"file convert\";\n\t\te->usage =\n\t\t\t\"Usage: file convert <file_in> <file_out>\\n\"\n\t\t\t\"       Convert from file_in to file_out. If an absolute path\\n\"\n\t\t\t\"       is not given, the default Asterisk sounds directory\\n\"\n\t\t\t\"       will be used.\\n\\n\"\n\t\t\t\"       Example:\\n\"\n\t\t\t\"           file convert tt-weasels.gsm tt-weasels.ulaw\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4 || ast_strlen_zero(a->argv[2]) || ast_strlen_zero(a->argv[3])) {\n\t\tret = CLI_SHOWUSAGE;\n\t\tgoto fail_out;\t\n\t}\n\tfile_in = ast_strdupa(a->argv[2]);\n\tfile_out = ast_strdupa(a->argv[3]);\n\tif (split_ext(file_in, &name_in, &ext_in)) {\n\t\tast_cli(a->fd, \"'%s' is an invalid filename!\\n\", a->argv[2]);\n\t\tgoto fail_out;\n\t}\n\tif (!(fs_in = ast_readfile(name_in, ext_in, NULL, O_RDONLY, 0, 0))) {\n\t\tast_cli(a->fd, \"Unable to open input file: %s\\n\", a->argv[2]);\n\t\tgoto fail_out;\n\t}\n\tif (split_ext(file_out, &name_out, &ext_out)) {\n\t\tast_cli(a->fd, \"'%s' is an invalid filename!\\n\", a->argv[3]);\n\t\tgoto fail_out;\n\t}\n\tif (!(fs_out = ast_writefile(name_out, ext_out, NULL, O_CREAT|O_TRUNC|O_WRONLY, 0, AST_FILE_MODE))) {\n\t\tast_cli(a->fd, \"Unable to open output file: %s\\n\", a->argv[3]);\n\t\tgoto fail_out;\n\t}\n\tstart = ast_tvnow();\n\twhile ((f = ast_readframe(fs_in))) {\n\t\tif (ast_writestream(fs_out, f)) {\n\t\t\tast_frfree(f);\n\t\t\tast_cli(a->fd, \"Failed to convert %s.%s to %s.%s!\\n\", name_in, ext_in, name_out, ext_out);\n\t\t\tgoto fail_out;\n\t\t}\n\t\tast_frfree(f);\n\t}\n\tcost = ast_tvdiff_ms(ast_tvnow(), start);\n\tast_cli(a->fd, \"Converted %s.%s to %s.%s in %dms\\n\", name_in, ext_in, name_out, ext_out, cost);\n\tret = CLI_SUCCESS;\nfail_out:\n\tif (fs_out) {\n\t\tast_closestream(fs_out);\n\t\tif (ret != CLI_SUCCESS)\n\t\t\tast_filedelete(name_out, ext_out);\n\t}\n\tif (fs_in) \n\t\tast_closestream(fs_in);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1790}
{"project": "Asterisk", "target": 0, "func": "static int check_events(struct ast_test *test, struct ao2_container *local_expected, struct ao2_container *local_received)\n{\n\tstruct ao2_iterator received_it;\n\tstruct ao2_iterator expected_it;\n\tRAII_VAR(struct ast_event *, rx_event, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_event *, ex_event, NULL, ao2_cleanup);\n\tint debug = 0;\n\tif (ao2_container_count(local_expected) != ao2_container_count(local_received)) {\n\t\tast_test_status_update(test, \"Increasing verbosity since the number of expected events (%d)\"\n\t\t\t\" did not match number of received events (%d).\\n\",\n\t\t\tao2_container_count(local_expected),\n\t\t\tao2_container_count(local_received));\n\t\tdebug = 1;\n\t}\n\treceived_it = ao2_iterator_init(local_received, 0);\n\texpected_it = ao2_iterator_init(local_expected, 0);\n\trx_event = ao2_iterator_next(&received_it);\n\tex_event = ao2_iterator_next(&expected_it);\n\twhile (rx_event && ex_event) {\n\t\tif (!events_are_equal(test, rx_event, ex_event)) {\n\t\t\tao2_iterator_destroy(&received_it);\n\t\t\tao2_iterator_destroy(&expected_it);\n\t\t\tast_test_status_update(test, \"Received event:\\n\");\n\t\t\tdump_event(test, rx_event);\n\t\t\tast_test_status_update(test, \"Expected event:\\n\");\n\t\t\tdump_event(test, ex_event);\n\t\t\treturn -1;\n\t\t}\n\t\tif (debug) {\n\t\t\tast_test_status_update(test, \"Compared events successfully%s\\n\",\n\t\t\t\tast_event_get_type(ex_event) == AST_EVENT_CUSTOM\n\t\t\t\t\t? \" (wildcard match)\" : \"\");\n\t\t\tdump_event(test, rx_event);\n\t\t}\n\t\tao2_cleanup(rx_event);\n\t\tao2_cleanup(ex_event);\n\t\trx_event = ao2_iterator_next(&received_it);\n\t\tex_event = ao2_iterator_next(&expected_it);\n\t}\n\tao2_iterator_destroy(&received_it);\n\tao2_iterator_destroy(&expected_it);\n\tif (rx_event) {\n\t\tast_test_status_update(test, \"Received event:\\n\");\n\t\tdump_event(test, rx_event);\n\t\treturn -1;\n\t}\n\tif (ex_event) {\n\t\tast_test_status_update(test, \"Expected event:\\n\");\n\t\tdump_event(test, ex_event);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1791}
{"project": "Asterisk", "target": 0, "func": "static int analog_train_echocanceller(struct analog_pvt *p)\n{\n\tif (analog_callbacks.train_echocanceller) {\n\t\treturn analog_callbacks.train_echocanceller(p->chan_pvt);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 1792}
{"project": "Asterisk", "target": 0, "func": "void __attribute__((format(printf, 1, 2))) ast_verbose(const char *fmt, ...)\n{\n\tva_list vars;\n\tva_start(vars,fmt);\n\tprintf(\"VERBOSE: \");\n\tvprintf(fmt, vars);\n\tfflush(stdout);\n\tva_end(vars);\n}\n", "bug_type": null, "idx": 1793}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_sqlite_show_tables(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct sqlite_cache_tables *tbl;\n\tstruct sqlite_cache_columns *col;\n\tint found = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"sqlite show tables\";\n\t\te->usage =\n\t\t\t\"Usage: sqlite show tables\\n\"\n\t\t\t\"       Show table information about the SQLite 2 driver\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3)\n\t\treturn CLI_SHOWUSAGE;\n\tAST_RWLIST_RDLOCK(&sqlite_tables);\n\tAST_RWLIST_TRAVERSE(&sqlite_tables, tbl, list) {\n\t\tfound++;\n\t\tast_cli(a->fd, \"Table %s:\\n\", tbl->name);\n\t\tAST_RWLIST_TRAVERSE(&(tbl->columns), col, list) {\n\t\t\tfprintf(stderr, \"%s\\n\", col->name);\n\t\t\tast_cli(a->fd, \"  %20.20s  %-30.30s\\n\", col->name, col->type);\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&sqlite_tables);\n\tif (!found) {\n\t\tast_cli(a->fd, \"No tables currently in cache\\n\");\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1794}
{"project": "Asterisk", "target": 0, "func": "static int cel_track_app(const char *const_app)\n{\n\tRAII_VAR(struct cel_config *, cfg, ao2_global_obj_ref(cel_configs), ao2_cleanup);\n\tRAII_VAR(char *, app, NULL, ao2_cleanup);\n\tchar *app_lower;\n\tif (!cfg || !cfg->general) {\n\t\treturn 0;\n\t}\n\tapp_lower = ast_str_to_lower(ast_strdupa(const_app));\n\tapp = ao2_find(cfg->general->apps, app_lower, OBJ_SEARCH_KEY);\n\tif (!app) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 1795}
{"project": "Asterisk", "target": 0, "func": "} say_args_t;\nstatic int s_streamwait3(const say_args_t *a, const char *fn)\n{\n\tint res = ast_streamfile(a->chan, fn, a->language);\n\tif (res) {\n\t\tast_log(LOG_WARNING, \"Unable to play message %s\\n\", fn);\n\t\treturn res;\n\t}\n\tres = (a->audiofd  > -1 && a->ctrlfd > -1) ?\n\tast_waitstream_full(a->chan, a->ints, a->audiofd, a->ctrlfd) :\n\tast_waitstream(a->chan, a->ints);\n\tast_stopstream(a->chan);\n\treturn res;  \n}\n", "bug_type": null, "idx": 1796}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225LocationReject (OOCTXT* pctxt, H225LocationReject* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   \n   invokeStartElement (pctxt, \"requestSeqNum\", -1);\n   stat = asn1PD_H225RequestSeqNum (pctxt, &pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"requestSeqNum\", -1);\n   \n   invokeStartElement (pctxt, \"rejectReason\", -1);\n   stat = asn1PD_H225LocationRejectReason (pctxt, &pvalue->rejectReason);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"rejectReason\", -1);\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 7 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.altGKInfoPresent = 1;\n                     invokeStartElement (pctxt, \"altGKInfo\", -1);\n                     stat = asn1PD_H225AltGKInfo (pctxt, &pvalue->altGKInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"altGKInfo\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.tokensPresent = 1;\n                     invokeStartElement (pctxt, \"tokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"tokens\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.cryptoTokensPresent = 1;\n                     invokeStartElement (pctxt, \"cryptoTokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"cryptoTokens\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.integrityCheckValuePresent = 1;\n                     invokeStartElement (pctxt, \"integrityCheckValue\", -1);\n                     stat = asn1PD_H225ICV (pctxt, &pvalue->integrityCheckValue);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"integrityCheckValue\", -1);\n                     break;\n                  case 4:\n                     pvalue->m.featureSetPresent = 1;\n                     invokeStartElement (pctxt, \"featureSet\", -1);\n                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"featureSet\", -1);\n                     break;\n                  case 5:\n                     pvalue->m.genericDataPresent = 1;\n                     invokeStartElement (pctxt, \"genericData\", -1);\n                     stat = asn1PD_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"genericData\", -1);\n                     break;\n                  case 6:\n                     pvalue->m.serviceControlPresent = 1;\n                     invokeStartElement (pctxt, \"serviceControl\", -1);\n                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"serviceControl\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1797}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_transport_monitor_unregister_all(ast_transport_monitor_shutdown_cb cb)\n{\n\tstruct ao2_container *transports;\n\ttransports = ao2_global_obj_ref(active_transports);\n\tif (!transports) {\n\t\treturn;\n\t}\n\tao2_callback(transports, OBJ_MULTIPLE | OBJ_NODATA, transport_monitor_unregister_all,\n\t\tcb);\n\tao2_ref(transports, -1);\n}\n", "bug_type": null, "idx": 1798}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum sig_pri_moh_state sig_pri_moh_fsm_retrieve_req(struct ast_channel *chan, struct sig_pri_chan *pvt, enum sig_pri_moh_event event)\n{\n\tenum sig_pri_moh_state next_state;\n\tnext_state = pvt->moh_state;\n\tswitch (event) {\n\tcase SIG_PRI_MOH_EVENT_RESET:\n\t\tnext_state = SIG_PRI_MOH_STATE_IDLE;\n\t\tbreak;\n\tcase SIG_PRI_MOH_EVENT_HOLD:\n\t\tnext_state = SIG_PRI_MOH_STATE_PEND_HOLD;\n\t\tbreak;\n\tcase SIG_PRI_MOH_EVENT_RETRIEVE_ACK:\n\tcase SIG_PRI_MOH_EVENT_REMOTE_RETRIEVE_ACK:\n\t\tnext_state = SIG_PRI_MOH_STATE_IDLE;\n\t\tbreak;\n\tcase SIG_PRI_MOH_EVENT_RETRIEVE_REJ:\n\t\tnext_state = SIG_PRI_MOH_STATE_RETRIEVE_FAIL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tpvt->moh_state = next_state;\n\treturn next_state;\n}\n", "bug_type": null, "idx": 1799}
{"project": "Asterisk", "target": 0, "func": "static int analog_dsp_reset_and_flush_digits(struct analog_pvt *p)\n{\n\tif (analog_callbacks.dsp_reset_and_flush_digits) {\n\t\treturn analog_callbacks.dsp_reset_and_flush_digits(p->chan_pvt);\n\t}\n\t\n\treturn 0;\n}\n", "bug_type": null, "idx": 1800}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245T38FaxProfile (OOCTXT* pctxt, H245T38FaxProfile* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   \n   invokeStartElement (pctxt, \"fillBitRemoval\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->fillBitRemoval);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->fillBitRemoval);\n   invokeEndElement (pctxt, \"fillBitRemoval\", -1);\n   \n   invokeStartElement (pctxt, \"transcodingJBIG\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->transcodingJBIG);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->transcodingJBIG);\n   invokeEndElement (pctxt, \"transcodingJBIG\", -1);\n   \n   invokeStartElement (pctxt, \"transcodingMMR\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->transcodingMMR);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->transcodingMMR);\n   invokeEndElement (pctxt, \"transcodingMMR\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 4 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.versionPresent = 1;\n                     invokeStartElement (pctxt, \"version\", -1);\n                     stat = decodeConsUInt8 (pctxt, &pvalue->version, 0U, 255U);\n                     if (stat != ASN_OK) return stat;\n                     invokeUIntValue (pctxt, pvalue->version);\n                     invokeEndElement (pctxt, \"version\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.t38FaxRateManagementPresent = 1;\n                     invokeStartElement (pctxt, \"t38FaxRateManagement\", -1);\n                     stat = asn1PD_H245T38FaxRateManagement (pctxt, &pvalue->t38FaxRateManagement);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"t38FaxRateManagement\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.t38FaxUdpOptionsPresent = 1;\n                     invokeStartElement (pctxt, \"t38FaxUdpOptions\", -1);\n                     stat = asn1PD_H245T38FaxUdpOptions (pctxt, &pvalue->t38FaxUdpOptions);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"t38FaxUdpOptions\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.t38FaxTcpOptionsPresent = 1;\n                     invokeStartElement (pctxt, \"t38FaxTcpOptions\", -1);\n                     stat = asn1PD_H245T38FaxTcpOptions (pctxt, &pvalue->t38FaxTcpOptions);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"t38FaxTcpOptions\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1801}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct qualify_data *qualify_data_alloc(struct ast_sip_endpoint *endpoint, int cli_fd)\n{\n\tstruct qualify_data *qual_data;\n\tqual_data = ast_malloc(sizeof(*qual_data));\n\tif (!qual_data) {\n\t\treturn NULL;\n\t}\n\tqual_data->endpoint = ao2_bump(endpoint);\n\tqual_data->cli_fd = cli_fd;\n\treturn qual_data;\n}\n", "bug_type": null, "idx": 1802}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function odbc_function = {\n\t.name = \"ODBC\",\n\t.read = acf_transaction_read,\n\t.write = acf_transaction_write,\n};\n", "bug_type": null, "idx": 1803}
{"project": "Asterisk", "target": 0, "func": "int __ast_string_field_ptr_grow(struct ast_string_field_mgr *mgr,\n\tstruct ast_string_field_pool **pool_head, size_t needed, const ast_string_field *ptr)\n{\n\tssize_t grow = needed - AST_STRING_FIELD_ALLOCATION(*ptr);\n\tsize_t space = (*pool_head)->size - (*pool_head)->used;\n\tif (*ptr != mgr->last_alloc) {\n\t\treturn 1;\n\t}\n\tif (space < grow) {\n\t\treturn 1;\n\t}\n\t(*pool_head)->used += grow;\n\t(*pool_head)->active += grow;\n\tAST_STRING_FIELD_ALLOCATION(*ptr) += grow;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1804}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int mark_transaction_active(struct ast_channel *chan, struct odbc_txn_frame *tx)\n{\n\tstruct ast_datastore *txn_store;\n\tAST_LIST_HEAD(, odbc_txn_frame) *oldlist;\n\tstruct odbc_txn_frame *active = NULL, *txn;\n\tif (!chan) {\n\t\treturn -1;\n\t}\n\tast_channel_lock(chan);\n\tif (!(txn_store = ast_channel_datastore_find(chan, &txn_info, NULL))) {\n\t\tast_channel_unlock(chan);\n\t\treturn -1;\n\t}\n\toldlist = txn_store->data;\n\tAST_LIST_LOCK(oldlist);\n\tAST_LIST_TRAVERSE(oldlist, txn, list) {\n\t\tif (txn == tx) {\n\t\t\ttxn->active = 1;\n\t\t\tactive = txn;\n\t\t} else {\n\t\t\ttxn->active = 0;\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(oldlist);\n\tast_channel_unlock(chan);\n\treturn active ? 0 : -1;\n}\n", "bug_type": null, "idx": 1805}
{"project": "Asterisk", "target": 0, "func": "static int kqueue_timer_ack(void *data, unsigned int quantity)\n{\n\tstatic struct timespec ts_nowait = { 0, 0 };\n\tstruct kqueue_timer *timer = data;\n\tstruct kevent kev[2];\n\tint i, retval;\n\tao2_lock(timer);\n\tretval = kevent(timer->handle, NULL, 0, kev, 2, &ts_nowait);\n\tif (retval == -1) {\n\t\tast_log(LOG_ERROR, \"[%d]: Error sampling kqueue: %s\\n\",\n\t\t\ttimer->handle, strerror(errno));\n\t\tao2_unlock(timer);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < retval; i++) {\n\t\tswitch (kev[i].filter) {\n\t\tcase EVFILT_TIMER:\n\t\t\tif (kev[i].data > quantity) {\n\t\t\t\tast_log(LOG_ERROR, \"[%d]: Missed %ju\\n\",\n\t\t\t\t\ttimer->handle,\n\t\t\t\t\t(uintmax_t)kev[i].data - quantity);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONTINUOUS_EVFILT_TYPE:\n\t\t\tif (!timer->is_continuous) {\n\t\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\t\"[%d]: Spurious user event\\n\",\n\t\t\t\t\ttimer->handle);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_ERROR, \"[%d]: Spurious kevent type %d.\\n\",\n\t\t\t\ttimer->handle, kev[i].filter);\n\t\t}\n\t}\n\tao2_unlock(timer);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1806}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int create_routes(void)\n{\n\tint ret = 0;\n\tcel_state_router = stasis_message_router_create(cel_aggregation_topic);\n\tif (!cel_state_router) {\n\t\treturn -1;\n\t}\n\tstasis_message_router_set_congestion_limits(cel_state_router, -1,\n\t\t6 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tstasis_cache_update_type(),\n\t\tcel_snapshot_update_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_channel_dial_type(),\n\t\tcel_dial_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_channel_entered_bridge_type(),\n\t\tcel_bridge_enter_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_channel_left_bridge_type(),\n\t\tcel_bridge_leave_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_parked_call_type(),\n\t\tcel_parking_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tcel_generic_type(),\n\t\tcel_generic_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_blind_transfer_type(),\n\t\tcel_blind_transfer_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_attended_transfer_type(),\n\t\tcel_attended_transfer_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_call_pickup_type(),\n\t\tcel_pickup_cb,\n\t\tNULL);\n\tret |= stasis_message_router_add(cel_state_router,\n\t\tast_local_optimization_end_type(),\n\t\tcel_local_cb,\n\t\tNULL);\n\tif (ret) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to register for Stasis messages\\n\");\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 1807}
{"project": "Asterisk", "target": 0, "func": "static int append_source_streams(struct ast_stream_topology *dest,\n\tconst char *channel_name,\n\tconst struct ast_stream_topology *source)\n{\n\tint i;\n\tfor (i = 0; i < ast_stream_topology_get_count(source); ++i) {\n\t\tstruct ast_stream *stream;\n\t\tstruct ast_stream *stream_clone;\n\t\tchar *stream_clone_name = NULL;\n\t\tstream = ast_stream_topology_get_stream(source, i);\n\t\tif (!is_video_source(stream)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ast_asprintf(&stream_clone_name, \"%s_%s_%s\", SOFTBRIDGE_VIDEO_DEST_PREFIX,\n\t\t\tchannel_name, ast_stream_get_name(stream)) < 0) {\n\t\t\tast_free(stream_clone_name);\n\t\t\treturn -1;\n\t\t}\n\t\tstream_clone = ast_stream_clone(stream, stream_clone_name);\n\t\tast_free(stream_clone_name);\n\t\tif (!stream_clone) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (ast_stream_topology_append_stream(dest, stream_clone) < 0) {\n\t\t\tast_stream_free(stream_clone);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1808}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int sort_subroutine(const void *arg1, const void *arg2)\n{\n\tconst struct sortable_keys *one=arg1, *two=arg2;\n\tif (one->value < two->value)\n\t\treturn -1;\n\telse if (one->value == two->value)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n", "bug_type": null, "idx": 1809}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(srv_resolve_record_missing_host)\n{\n\tstruct srv_record records[] = {\n\t\t{ 10, 10, 5060, \"tacos.com\", 0, 0, 0, 1 },\n\t};\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"srv_resolve_record_missing_host\";\n\t\tinfo->category = \"/main/dns/srv/\";\n\t\tinfo->summary = \"Test an SRV lookup which returns a single invalid record\";\n\t\tinfo->description = \"This test defines a single SRV record and performs a\\n\"\n\t\t\t\"resolution of the domain to which they belong. The test ensures that the\\n\"\n\t\t\t\"record is determined to be corrupt as it contains only a priority, weight,\\n\"\n\t\t\t\"and port\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\treturn invalid_record_test(test, records, ARRAY_LEN(records));\n}\n", "bug_type": null, "idx": 1810}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tif (!(pthread_timers = ao2_container_alloc(PTHREAD_TIMER_BUCKETS,\n\t\tpthread_timer_hash, pthread_timer_cmp))) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (init_timing_thread()) {\n\t\tao2_ref(pthread_timers, -1);\n\t\tpthread_timers = NULL;\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn (timing_funcs_handle = ast_register_timing_interface(&pthread_timing)) ?\n\t\tAST_MODULE_LOAD_SUCCESS : AST_MODULE_LOAD_DECLINE;\n}\n", "bug_type": null, "idx": 1811}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245VideoCapability (OOCTXT* pctxt, H245VideoCapability* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 5);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 4);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245H261VideoCapability (pctxt, pvalue->u.h261VideoCapability);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245H262VideoCapability (pctxt, pvalue->u.h262VideoCapability);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 4:\n            stat = asn1PE_H245H263VideoCapability (pctxt, pvalue->u.h263VideoCapability);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 5:\n            stat = asn1PE_H245IS11172VideoCapability (pctxt, pvalue->u.is11172VideoCapability);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 6);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 6:\n            stat = asn1PE_H245GenericCapability (&lctxt, pvalue->u.genericVideoCapability);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1812}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tint res = ast_custom_function_unregister(&isexten_function);\n\tres |= ast_custom_function_unregister(&acf_isexten);\n\treturn res;\n}\n", "bug_type": null, "idx": 1813}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int shift_pop(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n#define beginning\t(cmd[0] == 'S') \n\tchar *after, delimiter[2] = \",\", *varsubst;\n\tsize_t unused;\n\tstruct ast_str *before = ast_str_thread_get(&result_buf, 16);\n\tchar *(*search_func)(const char *s, int c) = (beginning ? strchr : strrchr);\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(var);\n\t\tAST_APP_ARG(delimiter);\n\t);\n\tif (!before) {\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.var)) {\n\t\tast_log(LOG_WARNING, \"%s requires a variable name\\n\", cmd);\n\t\treturn -1;\n\t}\n\tvarsubst = ast_alloca(strlen(args.var) + 4);\n\tsprintf(varsubst, \"${%s}\", args.var);\n\tast_str_substitute_variables(&before, 0, chan, varsubst);\n\tif (args.argc > 1 && !ast_strlen_zero(args.delimiter)) {\n\t\tast_get_encoded_char(args.delimiter, delimiter, &unused);\n\t}\n\tif (!ast_str_strlen(before)) {\n\t\t\n\t\treturn -1;\n\t}\n\tif (!(after = search_func(ast_str_buffer(before), delimiter[0]))) {\n\t\t\n\t\tast_str_set(buf, len, \"%s\", ast_str_buffer(before));\n\t\tpbx_builtin_setvar_helper(chan, args.var, \"\");\n\t} else {\n\t\t*after++ = '\\0';\n\t\tast_str_set(buf, len, \"%s\", beginning ? ast_str_buffer(before) : after);\n\t\tpbx_builtin_setvar_helper(chan, args.var, beginning ? after : ast_str_buffer(before));\n\t}\n\treturn 0;\n#undef beginning\n}\n", "bug_type": null, "idx": 1814}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void schedule_qualify(struct ast_sip_contact *contact, int initial_interval)\n{\n\tstruct sched_data *data;\n\tdata = sched_data_create(contact);\n\tif (!data) {\n\t\treturn;\n\t}\n\tast_assert(contact->qualify_frequency != 0);\n\tao2_t_ref(data, +1, \"Ref for qualify_contact_sched() scheduler entry\");\n\tdata->id = ast_sched_add_variable(sched, initial_interval,\n\t\tqualify_contact_sched, data, 1);\n\tif (data->id < 0) {\n\t\tao2_t_ref(data, -1, \"Cleanup failed scheduler add\");\n\t\tast_log(LOG_ERROR, \"Unable to schedule qualify for contact %s\\n\",\n\t\t\tcontact->uri);\n\t} else if (!ao2_link(sched_qualifies, data)) {\n\t\tAST_SCHED_DEL_UNREF(sched, data->id,\n\t\t\tao2_t_ref(data, -1, \"Cleanup scheduler for failed ao2_link\"));\n\t}\n\tao2_t_ref(data, -1, \"Done setting up scheduler entry\");\n}\n", "bug_type": null, "idx": 1815}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(exists_nominal);\n\tAST_TEST_UNREGISTER(exists_off_nominal);\n\tAST_TEST_UNREGISTER(create_update_nominal);\n\tAST_TEST_UNREGISTER(create_update_metadata);\n\tAST_TEST_UNREGISTER(create_update_off_nominal);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1816}
{"project": "Asterisk", "target": 0, "func": "\nstatic inline float filterM(fsk_data *fskd,float in)\n{\n\tint i, j;\n\tdouble s;\n\tdouble *pc;\n\tpc = &coef_in[fskd->f_mark_idx][fskd->bw][0];\n\tfskd->fmxv[(fskd->fmp+6)&7] = in*(*pc++);\n\ts = (fskd->fmxv[(fskd->fmp + 6) & 7] - fskd->fmxv[fskd->fmp]) + 3 * (fskd->fmxv[(fskd->fmp + 2) & 7] - fskd->fmxv[(fskd->fmp + 4) & 7]);\n\tfor (i = 0, j = fskd->fmp; i < 6; i++, j++)\n\t\ts += fskd->fmyv[j&7]*(*pc++);\n\tfskd->fmyv[j&7] = s;\n\tfskd->fmp++;\n\tfskd->fmp &= 7;\n\treturn s;\n}\n", "bug_type": null, "idx": 1817}
{"project": "Asterisk", "target": 0, "func": "\ned_kill_line(EditLine *el, int c)\n{\n\tchar *kp, *cp;\n\tcp = el->el_line.cursor;\n\tkp = el->el_chared.c_kill.buf;\n\twhile (cp < el->el_line.lastchar)\n\t\t*kp++ = *cp++;\t\n\tel->el_chared.c_kill.last = kp;\n\t\t\t\n\tel->el_line.lastchar = el->el_line.cursor;\n\treturn (CC_REFRESH);\n}\n", "bug_type": null, "idx": 1818}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int acf_jabberreceive_read(struct ast_channel *chan, const char *name, char *data, char *buf, size_t buflen)\n{\n\tRAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);\n\tRAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);\n\tchar *parse = NULL;\n\tint timeout, jidlen, resourcelen, found = 0;\n\tstruct timeval start;\n\tlong diff = 0;\n\tstruct ast_xmpp_message *message;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t     AST_APP_ARG(account);\n\t\t\t     AST_APP_ARG(jid);\n\t\t\t     AST_APP_ARG(timeout);\n\t\t);\n\tAST_DECLARE_APP_ARGS(jid,\n\t\t\t     AST_APP_ARG(screenname);\n\t\t\t     AST_APP_ARG(resource);\n\t\t);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"%s requires arguments (account,jid[,timeout])\\n\", name);\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc < 2 || args.argc > 3) {\n\t\tast_log(LOG_WARNING, \"%s requires arguments (account,jid[,timeout])\\n\", name);\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(args.jid);\n\tAST_NONSTANDARD_APP_ARGS(jid, parse, '/');\n\tif (jid.argc < 1 || jid.argc > 2 || strlen(args.jid) > XMPP_MAX_JIDLEN) {\n\t\tast_log(LOG_WARNING, \"Invalid JID : %s\\n\", parse);\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.timeout)) {\n\t\ttimeout = 20;\n\t} else {\n\t\tsscanf(args.timeout, \"%d\", &timeout);\n\t\tif (timeout <= 0) {\n\t\t\tast_log(LOG_WARNING, \"Invalid timeout specified: '%s'\\n\", args.timeout);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjidlen = strlen(jid.screenname);\n\tresourcelen = ast_strlen_zero(jid.resource) ? 0 : strlen(jid.resource);\n\tif (!cfg || !cfg->clients || !(clientcfg = xmpp_config_find(cfg->clients, args.account))) {\n\t\tast_log(LOG_WARNING, \"Could not find client %s, exiting\\n\", args.account);\n\t\treturn -1;\n\t}\n\tast_debug(3, \"Waiting for an XMPP message from %s\\n\", args.jid);\n\tstart = ast_tvnow();\n\tif (chan && ast_autoservice_start(chan) < 0) {\n\t\tast_log(LOG_WARNING, \"Cannot start autoservice for channel %s\\n\", ast_channel_name(chan));\n\t\treturn -1;\n\t}\n\t\n\twhile (diff < timeout) {\n\t\tstruct timespec ts = { 0, };\n\t\tstruct timeval wait;\n\t\tint res = 0;\n\t\twait = ast_tvadd(start, ast_tv(timeout, 0));\n\t\tts.tv_sec = wait.tv_sec;\n\t\tts.tv_nsec = wait.tv_usec * 1000;\n\t\t\n\t\tast_mutex_lock(&messagelock);\n\t\tif (AST_LIST_EMPTY(&clientcfg->client->messages)) {\n\t\t\tres = ast_cond_timedwait(&message_received_condition, &messagelock, &ts);\n\t\t}\n\t\tast_mutex_unlock(&messagelock);\n\t\tif (res == ETIMEDOUT) {\n\t\t\tast_debug(3, \"No message received from %s in %d seconds\\n\", args.jid, timeout);\n\t\t\tbreak;\n\t\t}\n\t\tAST_LIST_LOCK(&clientcfg->client->messages);\n\t\tAST_LIST_TRAVERSE_SAFE_BEGIN(&clientcfg->client->messages, message, list) {\n\t\t\tif (jid.argc == 1) {\n\t\t\t\t\n\t\t\t\tif (strncasecmp(jid.screenname, message->from, jidlen)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tchar *resource = strchr(message->from, '/');\n\t\t\t\tif (!resource || strlen(resource) == 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Remote JID has no resource : %s\\n\", message->from);\n\t\t\t\t\tif (strncasecmp(jid.screenname, message->from, jidlen)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresource ++;\n\t\t\t\t\tif (strncasecmp(jid.screenname, message->from, jidlen) || strncmp(jid.resource, resource, resourcelen)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ast_tvdiff_sec(ast_tvnow(), message->arrived) >= clientcfg->message_timeout) {\n\t\t\t\tast_debug(3, \"Found old message from %s, deleting it\\n\", message->from);\n\t\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\t\txmpp_message_destroy(message);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tast_copy_string(buf, message->message, buflen);\n\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\txmpp_message_destroy(message);\n\t\t\tbreak;\n\t\t}\n\t\tAST_LIST_TRAVERSE_SAFE_END;\n\t\tAST_LIST_UNLOCK(&clientcfg->client->messages);\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdiff = ast_tvdiff_ms(ast_tvnow(), start);\n\t}\n\tif (chan && ast_autoservice_stop(chan) < 0) {\n\t\tast_log(LOG_WARNING, \"Cannot stop autoservice for channel %s\\n\", ast_channel_name(chan));\n\t}\n\t\n\tif (!found) {\n\t\tast_log(LOG_NOTICE, \"Timed out : no message received from %s\\n\", args.jid);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1819}
{"project": "Asterisk", "target": 0, "func": "static void find_pval_goto_item(pval *item, int lev)\n{\n\tstruct pval *p4;\n\tif (lev>100) {\n\t\tast_log(LOG_ERROR,\"find_pval_goto in infinite loop! item_type: %u\\n\\n\", item->type);\n\t\treturn;\n\t}\n\tswitch ( item->type ) {\n\tcase PV_MACRO:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u3.macro_statements,lev+1); \n\t\tbreak;\n\tcase PV_CONTEXT:\n\t\t\n\t\tbreak;\n\tcase PV_CASE:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u2.statements,lev+1);\n\t\tbreak;\n\tcase PV_PATTERN:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u2.statements,lev+1);\n\t\tbreak;\n\tcase PV_DEFAULT:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u2.statements,lev+1);\n\t\tbreak;\n\tcase PV_CATCH:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u2.statements,lev+1);\n\t\tbreak;\n\tcase PV_STATEMENTBLOCK:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u1.list,lev+1);\n\t\tbreak;\n\tcase PV_GOTO:\n\t\t\n\t\tcheck_goto(item);  \n\t\tbreak;\n\tcase PV_INCLUDES:\n\t\t\n\t\tfor (p4=item->u1.list; p4; p4=p4->next) {\n\t\t\t\n\t\t\tchar *incl_context = p4->u1.str;\n\t\t\t\n\t\t\tstruct pval *that_context = find_context(incl_context);\n\t\t\tif (that_context && that_context->u2.statements) {\n\t\t\t\t\n\t\t\t\tfind_pval_gotos(that_context->u2.statements,lev+1); \n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PV_FOR:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u4.for_statements,lev+1);\n\t\tbreak;\n\tcase PV_WHILE:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u2.statements,lev+1);\n\t\tbreak;\n\tcase PV_RANDOM:\n\t\t\n\tcase PV_IFTIME:\n\t\t\n\tcase PV_IF:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u2.statements,lev+1);\n\t\tif (item->u3.else_statements) {\n\t\t\t\n\t\t\tfind_pval_gotos(item->u3.else_statements,lev+1);\n\t\t}\n\t\tbreak;\n\tcase PV_SWITCH:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u3.else_statements,lev+1);\n\t\tbreak;\n\tcase PV_EXTENSION:\n\t\t\n\t\t\n\t\tfind_pval_gotos(item->u2.statements,lev+1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1820}
{"project": "Asterisk", "target": 0, "func": "const char *ast_sip_publication_get_resource(const struct ast_sip_publication *pub)\n{\n\treturn pub->resource;\n}\n", "bug_type": null, "idx": 1821}
{"project": "Asterisk", "target": 0, "func": "static void instance_destructor(void *obj)\n{\n\tstruct ast_rtp_instance *instance = obj;\n\t\n\tif (instance->data) {\n\t\t\n\t\tao2_lock(instance);\n\t\tinstance->engine->destroy(instance);\n\t\tao2_unlock(instance);\n\t}\n\tif (instance->srtp) {\n\t\tres_srtp->destroy(instance->srtp);\n\t}\n\tif (instance->rtcp_srtp) {\n\t\tres_srtp->destroy(instance->rtcp_srtp);\n\t}\n\tast_rtp_codecs_payloads_destroy(&instance->codecs);\n\t\n\tast_module_unref(instance->engine->mod);\n\tast_debug(1, \"Destroyed RTP instance '%p'\\n\", instance);\n}\n", "bug_type": null, "idx": 1822}
{"project": "Asterisk", "target": 0, "func": "\nstatic void wizard_mapped_observer(const char *name, struct ast_sorcery *sorcery,\n\tconst char *object_type, struct ast_sorcery_wizard *wizard,\n\tconst char *wizard_args, void *wizard_data)\n{\n\tstruct object_type_wizard *otw;\n\tif (!is_one_of(object_type, object_types)) {\n\t\t\n\t\treturn;\n\t}\n\t\n\tif (wizard_args && !strcmp(wizard_args, \"pjsip_wizard\")) {\n\t\totw = ast_malloc(sizeof(*otw) + strlen(object_type) + 1);\n\t\totw->sorcery = sorcery;\n\t\totw->wizard = wizard;\n\t\totw->wizard_data = wizard_data;\n\t\totw->last_config = NULL;\n\t\tstrcpy(otw->object_type, object_type); \n\t\tAST_VECTOR_RW_WRLOCK(&object_type_wizards);\n\t\tAST_VECTOR_APPEND(&object_type_wizards, otw);\n\t\tAST_VECTOR_RW_UNLOCK(&object_type_wizards);\n\t\tast_debug(1, \"Wizard mapped for object_type '%s'\\n\", object_type);\n\t}\n}\n", "bug_type": null, "idx": 1823}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_mobile_search(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct adapter_pvt *adapter;\n\tinquiry_info *ii = NULL;\n\tint max_rsp, num_rsp;\n\tint len, flags;\n\tint i, phport, hsport;\n\tchar addr[19] = {0};\n\tchar name[31] = {0};\n#define FORMAT1 \"%-17.17s %-30.30s %-6.6s %-7.7s %-4.4s\\n\"\n#define FORMAT2 \"%-17.17s %-30.30s %-6.6s %-7.7s %d\\n\"\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"mobile search\";\n\t\te->usage =\n\t\t\t\"Usage: mobile search\\n\"\n\t\t\t\"       Searches for Bluetooth Cell / Mobile devices in range.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 2)\n\t\treturn CLI_SHOWUSAGE;\n\t\n\tAST_RWLIST_RDLOCK(&adapters);\n\tAST_RWLIST_TRAVERSE(&adapters, adapter, entry) {\n\t\tif (!adapter->inuse)\n\t\t\tbreak;\n\t}\n\tAST_RWLIST_UNLOCK(&adapters);\n\tif (!adapter) {\n\t\tast_cli(a->fd, \"All Bluetooth adapters are in use at this time.\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\tlen  = 8;\n\tmax_rsp = 255;\n\tflags = IREQ_CACHE_FLUSH;\n\tii = ast_alloca(max_rsp * sizeof(inquiry_info));\n\tnum_rsp = hci_inquiry(adapter->dev_id, len, max_rsp, NULL, &ii, flags);\n\tif (num_rsp > 0) {\n\t\tast_cli(a->fd, FORMAT1, \"Address\", \"Name\", \"Usable\", \"Type\", \"Port\");\n\t\tfor (i = 0; i < num_rsp; i++) {\n\t\t\tba2str(&(ii + i)->bdaddr, addr);\n\t\t\tname[0] = 0x00;\n\t\t\tif (hci_read_remote_name(adapter->hci_socket, &(ii + i)->bdaddr, sizeof(name) - 1, name, 0) < 0)\n\t\t\t\tstrcpy(name, \"[unknown]\");\n\t\t\tphport = sdp_search(addr, HANDSFREE_AGW_PROFILE_ID);\n\t\t\tif (!phport)\n\t\t\t\thsport = sdp_search(addr, HEADSET_PROFILE_ID);\n\t\t\telse\n\t\t\t\thsport = 0;\n\t\t\tast_cli(a->fd, FORMAT2, addr, name, (phport > 0 || hsport > 0) ? \"Yes\" : \"No\",\n\t\t\t\t(phport > 0) ? \"Phone\" : \"Headset\", (phport > 0) ? phport : hsport);\n\t\t}\n\t} else\n\t\tast_cli(a->fd, \"No Bluetooth Cell / Mobile devices found.\\n\");\n#undef FORMAT1\n#undef FORMAT2\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1824}
{"project": "Asterisk", "target": 0, "func": "static void bridge_config_set_limits_warning_values(struct ast_bridge_config *config, struct ast_bridge_features_limits *limits)\n{\n\tif (config->end_sound) {\n\t\tast_string_field_set(limits, duration_sound, config->end_sound);\n\t}\n\tif (config->warning_sound) {\n\t\tast_string_field_set(limits, warning_sound, config->warning_sound);\n\t}\n\tif (config->start_sound) {\n\t\tast_string_field_set(limits, connect_sound, config->start_sound);\n\t}\n\tlimits->frequency = config->warning_freq;\n\tlimits->warning = config->play_warning;\n}\n", "bug_type": null, "idx": 1825}
{"project": "Asterisk", "target": 0, "func": "SQLHSTMT ast_odbc_prepare_and_execute(struct odbc_obj *obj, SQLHSTMT (*prepare_cb)(struct odbc_obj *obj, void *data), void *data)\n{\n\tint res = 0;\n\tSQLHSTMT stmt;\n\t\n\tstmt = prepare_cb(obj, data);\n\tif (!stmt) {\n\t\treturn NULL;\n\t}\n\tres = SQLExecute(stmt);\n\tif ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO) && (res != SQL_NO_DATA)) {\n\t\tif (res == SQL_ERROR) {\n\t\t\tast_odbc_print_errors(SQL_HANDLE_STMT, stmt, \"SQL Execute\");\n\t\t}\n\t\tast_log(LOG_WARNING, \"SQL Execute error %d!\\n\", res);\n\t\tSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n\t\tstmt = NULL;\n\t}\n\treturn stmt;\n}\n", "bug_type": null, "idx": 1826}
{"project": "Asterisk", "target": 0, "func": "static int check_for_conference(struct dahdi_pvt *p)\n{\n\tstruct dahdi_confinfo ci;\n\t\n\tif (p->master || (p->confno > -1))\n\t\treturn 0;\n\tmemset(&ci, 0, sizeof(ci));\n\tif (ioctl(p->subs[SUB_REAL].dfd, DAHDI_GETCONF, &ci)) {\n\t\tast_log(LOG_WARNING, \"Failed to get conference info on channel %d: %s\\n\", p->channel, strerror(errno));\n\t\treturn 0;\n\t}\n\t\n\tif ((p->subs[SUB_REAL].curconf.confno != ci.confno) || (p->subs[SUB_REAL].curconf.confmode != ci.confmode)) {\n\t\tast_verb(3, \"Avoiding 3-way call when in an external conference\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1827}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *restore_dialstring(struct ast_channel *chan)\n{\n\tstruct ast_datastore *datastore;\n\tdatastore = ast_channel_datastore_find(chan, &dialstring_info, NULL);\n\tif (!datastore) {\n\t\treturn NULL;\n\t}\n\treturn datastore->data;\n}\n", "bug_type": null, "idx": 1828}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void send_rasterisk_connect_commands(void)\n{\n\tchar buf[80];\n\t\n\tif (option_verbose) {\n\t\tsnprintf(buf, sizeof(buf), \"core set verbose atleast %d silent\", option_verbose);\n\t\tfdsend(ast_consock, buf);\n\t}\n\tif (option_debug) {\n\t\tsnprintf(buf, sizeof(buf), \"core set debug atleast %d\", option_debug);\n\t\tfdsend(ast_consock, buf);\n\t}\n\tif (!ast_opt_mute) {\n\t\tfdsend(ast_consock, \"logger mute silent\");\n\t} else {\n\t\tprintf(\"log and verbose output currently muted ('logger mute' to unmute)\\n\");\n\t}\n}\n", "bug_type": null, "idx": 1829}
{"project": "Asterisk", "target": 0, "func": "static int dahdi_decoder_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tstruct codec_dahdi_pvt *dahdip = pvt->pvt;\n\tif (!f->subclass.format) {\n\t\t\n\t\tdahdip->fake = 2;\n\t\tpvt->samples = f->samples;\n\t\treturn 0;\n\t}\n\tif (!f->datalen) {\n\t\tif (f->samples != dahdip->required_samples) {\n\t\t\tast_log(LOG_ERROR, \"%d != %d %d\\n\", f->samples, dahdip->required_samples, f->datalen);\n\t\t}\n\t}\n\tdahdi_write_frame(dahdip, f->data.ptr, f->datalen);\n\tdahdip->samples_written_to_hardware += f->samples;\n\tpvt->samples += f->samples;\n\tpvt->datalen = 0;\n\treturn -1;\n}\n", "bug_type": null, "idx": 1830}
{"project": "Asterisk", "target": 0, "func": "};\nconst char *ast_get_switch_name(const struct ast_sw *sw)\n{\n\treturn sw ? sw->name : NULL;\n}\n", "bug_type": null, "idx": 1831}
{"project": "Asterisk", "target": 0, "func": "***/\nstatic int pjsip_endpoint_function_read(struct ast_channel *chan,\n\tconst char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\tstruct ast_sorcery *pjsip_sorcery;\n\tchar *parsed_data = ast_strdupa(data);\n\tRAII_VAR(void *, endpoint_obj, NULL, ao2_cleanup);\n\tstruct ast_variable *change_set;\n\tstruct ast_variable *it_change_set;\n\tint res;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(endpoint_name);\n\t\tAST_APP_ARG(field_name);\n\t);\n\t\n\tif (ast_strlen_zero(parsed_data)) {\n\t\tast_log(AST_LOG_ERROR, \"Cannot call %s without arguments\\n\", cmd);\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, parsed_data);\n\tif (ast_strlen_zero(args.endpoint_name)) {\n\t\tast_log(AST_LOG_ERROR, \"Cannot call %s without an endpoint name to query\\n\", cmd);\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.field_name)) {\n\t\tast_log(AST_LOG_ERROR, \"Cannot call %s with an empty field name to query\\n\", cmd);\n\t\treturn -1;\n\t}\n\tpjsip_sorcery = ast_sip_get_sorcery();\n\tif (!pjsip_sorcery) {\n\t\tast_log(AST_LOG_ERROR, \"Unable to retrieve PJSIP configuration: sorcery object is NULL\\n\");\n\t\treturn -1;\n\t}\n\tendpoint_obj = ast_sorcery_retrieve_by_id(pjsip_sorcery, \"endpoint\", args.endpoint_name);\n\tif (!endpoint_obj) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to retrieve information for endpoint '%s'\\n\", args.endpoint_name);\n\t\treturn -1;\n\t}\n\tchange_set = ast_sorcery_objectset_create(pjsip_sorcery, endpoint_obj);\n\tif (!change_set) {\n\t\tast_log(AST_LOG_WARNING, \"Failed to retrieve information for endpoint '%s': change set is NULL\\n\", args.endpoint_name);\n\t\treturn -1;\n\t}\n\tfor (it_change_set = change_set; it_change_set; it_change_set = it_change_set->next) {\n\t\tif (!strcmp(it_change_set->name, args.field_name)) {\n\t\t\tif (!strcmp(it_change_set->name, \"disallow\")) {\n\t\t\t\tast_str_set(buf, len, \"!%s\", it_change_set->value);\n\t\t\t} else {\n\t\t\t\tast_str_set(buf, len, \"%s\", it_change_set->value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tres = it_change_set ? 0 : 1;\n\tif (res) {\n\t\tast_log(AST_LOG_WARNING, \"Unknown property '%s' for PJSIP endpoint\\n\", args.field_name);\n\t}\n\tast_variables_destroy(change_set);\n\treturn res;\n}\n", "bug_type": null, "idx": 1832}
{"project": "Asterisk", "target": 0, "func": "const char* ooGetMsgTypeText (int msgType)\n{\n   static const char *msgTypeText[]={\n      \"OOQ931MSG\",\n      \"OOH245MSG\",\n      \"OOSetup\",\n      \"OOCallProceeding\",\n      \"OOAlert\",\n      \"OOConnect\",\n      \"OOReleaseComplete\",\n      \"OOFacility\",\n      \"OOInformation\",\n      \"OOMasterSlaveDetermination\",\n      \"OOMasterSlaveAck\",\n      \"OOMasterSlaveReject\",\n      \"OOMasterSlaveRelease\",\n      \"OOTerminalCapabilitySet\",\n      \"OOTerminalCapabilitySetAck\",\n      \"OOTerminalCapabilitySetReject\",\n      \"OOTerminalCapabilitySetRelease\",\n      \"OOOpenLogicalChannel\",\n      \"OOOpenLogicalChannelAck\",\n      \"OOOpenLogicalChannelReject\",\n      \"OOOpenLogicalChannelRelease\",\n      \"OOOpenLogicalChannelConfirm\",\n      \"OOCloseLogicalChannel\",\n      \"OOCloseLogicalChannelAck\",\n      \"OORequestChannelClose\",\n      \"OORequestChannelCloseAck\",\n      \"OORequestChannelCloseReject\",\n      \"OORequestChannelCloseRelease\",\n      \"OOEndSessionCommand\",\n      \"OOUserInputIndication\",\n      \"OORequestModeAck\",\n      \"OORequestModeReject\",\n      \"OORequestMode\",\n      \"OORequestDelayResponse\",\n      \"OORequestDelayRequest\"\n   };\n   int idx = msgType - OO_MSGTYPE_MIN;\n   return ooUtilsGetText (idx, msgTypeText, OONUMBEROF(msgTypeText));\n}\n", "bug_type": null, "idx": 1833}
{"project": "Asterisk", "target": 0, "func": "static int moh_classes_delete_marked(void *obj, void *arg, int flags)\n{\n\tstruct mohclass *class = obj;\n\treturn class->delete ? CMP_MATCH : 0;\n}\n", "bug_type": null, "idx": 1834}
{"project": "Asterisk", "target": 0, "func": "int ast_msg_set_exten(struct ast_msg *msg, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tast_string_field_build_va(msg, exten, fmt, ap);\n\tva_end(ap);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1835}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum ao2_container_insert hash_ao2_insert_node(struct ao2_container_hash *self,\n\tstruct hash_bucket_node *node)\n{\n\tint cmp;\n\tstruct hash_bucket *bucket;\n\tstruct hash_bucket_node *cur;\n\tao2_sort_fn *sort_fn;\n\tuint32_t options;\n\tbucket = &self->buckets[node->my_bucket];\n\tsort_fn = self->common.sort_fn;\n\toptions = self->common.options;\n\tif (options & AO2_CONTAINER_ALLOC_OPT_INSERT_BEGIN) {\n\t\tif (sort_fn) {\n\t\t\tAST_DLLIST_TRAVERSE_BACKWARDS_SAFE_BEGIN(&bucket->list, cur, links) {\n\t\t\t\tcmp = sort_fn(cur->common.obj, node->common.obj, OBJ_SEARCH_OBJECT);\n\t\t\t\tif (cmp > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmp < 0) {\n\t\t\t\t\tAST_DLLIST_INSERT_AFTER_CURRENT(node, links);\n\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_INSERTED;\n\t\t\t\t}\n\t\t\t\tswitch (options & AO2_CONTAINER_ALLOC_OPT_DUPS_MASK) {\n\t\t\t\tdefault:\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_ALLOW:\n\t\t\t\t\tbreak;\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_REJECT:\n\t\t\t\t\t\n\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_REJECTED;\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_OBJ_REJECT:\n\t\t\t\t\tif (cur->common.obj == node->common.obj) {\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_REJECTED;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE:\n\t\t\t\t\tSWAP(cur->common.obj, node->common.obj);\n\t\t\t\t\tao2_t_ref(node, -1, NULL);\n\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_OBJ_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAST_DLLIST_TRAVERSE_BACKWARDS_SAFE_END;\n\t\t}\n\t\tAST_DLLIST_INSERT_HEAD(&bucket->list, node, links);\n\t} else {\n\t\tif (sort_fn) {\n\t\t\tAST_DLLIST_TRAVERSE_SAFE_BEGIN(&bucket->list, cur, links) {\n\t\t\t\tcmp = sort_fn(cur->common.obj, node->common.obj, OBJ_SEARCH_OBJECT);\n\t\t\t\tif (cmp < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmp > 0) {\n\t\t\t\t\tAST_DLLIST_INSERT_BEFORE_CURRENT(node, links);\n\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_INSERTED;\n\t\t\t\t}\n\t\t\t\tswitch (options & AO2_CONTAINER_ALLOC_OPT_DUPS_MASK) {\n\t\t\t\tdefault:\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_ALLOW:\n\t\t\t\t\tbreak;\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_REJECT:\n\t\t\t\t\t\n\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_REJECTED;\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_OBJ_REJECT:\n\t\t\t\t\tif (cur->common.obj == node->common.obj) {\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_REJECTED;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE:\n\t\t\t\t\tSWAP(cur->common.obj, node->common.obj);\n\t\t\t\t\tao2_t_ref(node, -1, NULL);\n\t\t\t\t\treturn AO2_CONTAINER_INSERT_NODE_OBJ_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAST_DLLIST_TRAVERSE_SAFE_END;\n\t\t}\n\t\tAST_DLLIST_INSERT_TAIL(&bucket->list, node, links);\n\t}\n\treturn AO2_CONTAINER_INSERT_NODE_INSERTED;\n}\n", "bug_type": null, "idx": 1836}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225_SeqOfH225DataRate (OOCTXT* pctxt, H225_SeqOfH225DataRate* pvalue)\n{\n   int stat = ASN_OK;\n   H225DataRate* pdata;\n   ASN1UINT count = 0;\n   ASN1UINT xx1;\n   int lstat;\n   dListInit (pvalue);\n   for (;;) {\n      \n      lstat = decodeLength (pctxt, &count);\n      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {\n         return lstat;\n      }\n      \n      for (xx1 = 0; xx1 < count; xx1++) {\n         invokeStartElement (pctxt, \"elem\", xx1);\n         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225DataRate);\n         stat = asn1PD_H225DataRate (pctxt, pdata);\n         if (stat != ASN_OK) return stat;\n         invokeEndElement (pctxt, \"elem\", xx1);\n         dListAppendNode (pctxt, pvalue, pdata);\n      }\n      if(lstat == ASN_OK) break;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1837}
{"project": "Asterisk", "target": 0, "func": "struct stasis_app *stasis_app_get_by_name(const char *name)\n{\n\treturn find_app_by_name(name);\n}\n", "bug_type": null, "idx": 1838}
{"project": "Asterisk", "target": 0, "func": "#endif\nstatic void *scan_thread(void *unused)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\ttime_t now;\n\tstruct timespec ts = { .tv_sec = 1 };\n#ifdef HAVE_INOTIFY\n\tssize_t res;\n\tint inotify_fd = inotify_init();\n\tstruct inotify_event *iev;\n\tchar buf[8192] __attribute__((aligned (sizeof(int))));\n\tstruct pollfd pfd = { .fd = inotify_fd, .events = POLLIN };\n#else\n\tstruct timespec nowait = { .tv_sec = 0, .tv_nsec = 1 };\n\tint inotify_fd = kqueue();\n\tstruct kevent kev;\n\tstruct kevent event;\n#endif\n\tstruct direntry *cur;\n\twhile (!ast_fully_booted) {\n\t\tnanosleep(&ts, NULL);\n\t}\n\tif (inotify_fd < 0) {\n\t\tast_log(LOG_ERROR, \"Unable to initialize \"\n#ifdef HAVE_INOTIFY\n\t\t\t\"inotify(7)\"\n#else\n\t\t\t\"kqueue(2)\"\n#endif\n\t\t\t\"\\n\");\n\t\treturn NULL;\n\t}\n#ifdef HAVE_INOTIFY\n\tinotify_add_watch(inotify_fd, qdir, IN_CREATE | IN_OPEN | IN_CLOSE_WRITE | IN_MOVED_TO);\n#endif\n\t\n\tif (!(dir = opendir(qdir))) {\n\t\tast_log(LOG_ERROR, \"Unable to open directory %s: %s\\n\", qdir, strerror(errno));\n\t\treturn NULL;\n\t}\n#ifndef HAVE_INOTIFY\n\tEV_SET(&kev, dirfd(dir), EVFILT_VNODE, EV_ADD | EV_ENABLE | EV_CLEAR, NOTE_WRITE, 0, NULL);\n\tif (kevent(inotify_fd, &kev, 1, &event, 1, &nowait) < 0 && errno != 0) {\n\t\tast_log(LOG_ERROR, \"Unable to watch directory %s: %s\\n\", qdir, strerror(errno));\n\t}\n#endif\n\tnow = time(NULL);\n\twhile ((de = readdir(dir))) {\n\t\tqueue_file(de->d_name, 0);\n\t}\n#ifdef HAVE_INOTIFY\n\t\n\tclosedir(dir);\n#endif\n\t\n\tfor (;;) {\n\t\ttime_t next = AST_LIST_EMPTY(&dirlist) ? INT_MAX : AST_LIST_FIRST(&dirlist)->mtime;\n\t\ttime(&now);\n\t\tif (next > now) {\n#ifdef HAVE_INOTIFY\n\t\t\tint stage = 0;\n\t\t\t\n\t\t\tint waittime = next == INT_MAX ? -1 : (next - now) * 1000;\n\t\t\tif (!AST_LIST_EMPTY(&createlist)) {\n\t\t\t\twaittime = 1000;\n\t\t\t}\n\t\t\t\n\t\t\tif ((res = poll(&pfd, 1, waittime)) > 0 && (stage = 1) &&\n\t\t\t\t(res = read(inotify_fd, &buf, sizeof(buf))) >= sizeof(*iev)) {\n\t\t\t\tssize_t len = 0;\n\t\t\t\t\n\t\t\t\tfor (iev = (void *) buf; res >= sizeof(*iev); iev = (struct inotify_event *) (((char *) iev) + len)) {\n\t\t\t\t\t\n\t\t\t\t\tif (iev->mask & IN_CREATE) {\n\t\t\t\t\t\tqueue_file_create(iev->name);\n\t\t\t\t\t} else if (iev->mask & IN_OPEN) {\n\t\t\t\t\t\tqueue_file_open(iev->name);\n\t\t\t\t\t} else if (iev->mask & IN_CLOSE_WRITE) {\n\t\t\t\t\t\tqueue_file_write(iev->name);\n\t\t\t\t\t} else if (iev->mask & IN_MOVED_TO) {\n\t\t\t\t\t\tqueue_file(iev->name, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_log(LOG_ERROR, \"Unexpected event %d for file '%s'\\n\", (int) iev->mask, iev->name);\n\t\t\t\t\t}\n\t\t\t\t\tlen = sizeof(*iev) + iev->len;\n\t\t\t\t\tres -= len;\n\t\t\t\t}\n\t\t\t} else if (res < 0 && errno != EINTR && errno != EAGAIN) {\n\t\t\t\tast_debug(1, \"Got an error back from %s(2): %s\\n\", stage ? \"read\" : \"poll\", strerror(errno));\n\t\t\t}\n\t\t\ttime(&now);\n\t\t}\n\t\tqueue_created_files();\n#else\n\t\t\tint num_events;\n\t\t\t\n\t\t\tif (next == INT_MAX) {\n\t\t\t\tnum_events = kevent(inotify_fd, &kev, 1, &event, 1, NULL);\n\t\t\t} else {\n\t\t\t\tstruct timespec ts2 = { .tv_sec = (unsigned long int)(next - now), .tv_nsec = 0 };\n\t\t\t\tnum_events = kevent(inotify_fd, &kev, 1, &event, 1, &ts2);\n\t\t\t}\n\t\t\tif ((num_events < 0) || (event.flags == EV_ERROR)) {\n\t\t\t\tast_debug(10, \"KEvent error %s\\n\", strerror(errno));\n\t\t\t\tcontinue;\n\t\t\t} else if (num_events == 0) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\trewinddir(dir);\n\t\t\t\twhile ((de = readdir(dir))) {\n\t\t\t\t\tqueue_file(de->d_name, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime(&now);\n\t\t}\n#endif\n\t\t\n\t\tAST_LIST_LOCK(&dirlist);\n\t\twhile (!AST_LIST_EMPTY(&dirlist) && AST_LIST_FIRST(&dirlist)->mtime <= now) {\n\t\t\tcur = AST_LIST_REMOVE_HEAD(&dirlist, list);\n\t\t\tqueue_file(cur->name, cur->mtime);\n\t\t\tast_free(cur);\n\t\t}\n\t\tAST_LIST_UNLOCK(&dirlist);\n\t}\n#else\nstatic void *scan_thread(void *unused)\n{\n\tstruct stat st;\n\tDIR *dir;\n\tstruct dirent *de;\n\tchar fn[256];\n\tint res;\n\tint force_poll = 1;\n\ttime_t last = 0;\n\ttime_t next = 0;\n\ttime_t now;\n\tstruct timespec ts = { .tv_sec = 1 };\n\twhile (!ast_fully_booted) {\n\t\tnanosleep(&ts, NULL);\n\t}\n\tfor (;;) {\n\t\t\n\t\tnanosleep(&ts, NULL);\n\t\ttime(&now);\n\t\tif (stat(qdir, &st)) {\n\t\t\tast_log(LOG_WARNING, \"Unable to stat %s\\n\", qdir);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!force_poll && st.st_mtime == last && (!next || now < next)) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n#if 0\n\t\tprintf(\"atime: %ld, mtime: %ld, ctime: %ld\\n\", st.st_atime, st.st_mtime, st.st_ctime);\n\t\tprintf(\"Ooh, something changed / timeout\\n\");\n#endif\n\t\tif (!(dir = opendir(qdir))) {\n\t\t\tast_log(LOG_WARNING, \"Unable to open directory %s: %s\\n\", qdir, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tforce_poll = (st.st_mtime == now);\n\t\tnext = 0;\n\t\tlast = st.st_mtime;\n\t\twhile ((de = readdir(dir))) {\n\t\t\tsnprintf(fn, sizeof(fn), \"%s/%s\", qdir, de->d_name);\n\t\t\tif (stat(fn, &st)) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to stat %s: %s\\n\", fn, strerror(errno));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!S_ISREG(st.st_mode)) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (st.st_mtime <= now) {\n\t\t\t\tres = scan_service(fn, now);\n\t\t\t\tif (res > 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (!next || res < next) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext = res;\n\t\t\t\t\t}\n\t\t\t\t} else if (res) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Failed to scan service '%s'\\n\", fn);\n\t\t\t\t} else if (!next) {\n\t\t\t\t\t\n\t\t\t\t\tnext = st.st_mtime;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (!next || st.st_mtime < next) {\n\t\t\t\t\t\n\t\t\t\t\tnext = st.st_mtime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir(dir);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1839}
{"project": "Asterisk", "target": 0, "func": "ast_callid ast_channel_callid(const struct ast_channel *chan)\n{\n\treturn chan->callid;\n}\n", "bug_type": null, "idx": 1840}
{"project": "Asterisk", "target": 0, "func": "static int has_call_feature(pjsip_rx_data *rdata)\n{\n\tstatic const pj_str_t call_feature_str = { \"X-Digium-Call-Feature\", 21 };\n\tpjsip_generic_string_hdr *hdr = pjsip_msg_find_hdr_by_name(\n\t\trdata->msg_info.msg, &call_feature_str, NULL);\n\treturn hdr && !pj_stricmp2(&hdr->hvalue, SEND_TO_VM_HEADER_VALUE);\n}\n", "bug_type": null, "idx": 1841}
{"project": "Asterisk", "target": 0, "func": "static void g729_generate_sdp_fmtp(const struct ast_format *format, unsigned int payload, struct ast_str **str)\n{\n\t\n\tast_str_append(str, 0, \"a=fmtp:%u annexb=no\\r\\n\", payload);\n}\n", "bug_type": null, "idx": 1842}
{"project": "Asterisk", "target": 0, "func": " ***/\nstatic int chanavail_exec(struct ast_channel *chan, const char *data)\n{\n\tint inuse=-1, option_state=0, string_compare=0, option_all_avail=0;\n\tint status;\n\tchar *info, tmp[512], trychan[512], *peers, *tech, *number, *rest, *cur;\n\tstruct ast_str *tmp_availchan = ast_str_alloca(2048);\n\tstruct ast_str *tmp_availorig = ast_str_alloca(2048);\n\tstruct ast_str *tmp_availstat = ast_str_alloca(2048);\n\tstruct ast_str *tmp_availcause = ast_str_alloca(2048);\n\tstruct ast_channel *tempchan;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(reqchans);\n\t\tAST_APP_ARG(options);\n\t);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"ChanIsAvail requires an argument (DAHDI/1&DAHDI/2)\\n\");\n\t\treturn -1;\n\t}\n\tinfo = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, info);\n\tif (args.options) {\n\t\tif (strchr(args.options, 'a')) {\n\t\t\toption_all_avail = 1;\n\t\t}\n\t\tif (strchr(args.options, 's')) {\n\t\t\toption_state = 1;\n\t\t}\n\t\tif (strchr(args.options, 't')) {\n\t\t\tstring_compare = 1;\n\t\t}\n\t}\n\tpeers = args.reqchans;\n\tif (peers) {\n\t\tcur = peers;\n\t\tdo {\n\t\t\t\n\t\t\trest = strchr(cur, '&');\n\t\t\tif (rest) {\n\t\t\t\t*rest = 0;\n\t\t\t\trest++;\n\t\t\t}\n\t\t\ttech = cur;\n\t\t\tnumber = strchr(tech, '/');\n\t\t\tif (!number) {\n\t\t\t\tast_log(LOG_WARNING, \"ChanIsAvail argument takes format ([technology]/[device])\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*number = '\\0';\n\t\t\tnumber++;\n\t\t\tstatus = AST_DEVICE_UNKNOWN;\n\t\t\tif (string_compare) {\n\t\t\t\t\n\t\t\t\tsnprintf(trychan, sizeof(trychan), \"%s/%s\",cur,number);\n\t\t\t\tstatus = inuse = ast_parse_device_state(trychan);\n\t\t\t} else if (option_state) {\n\t\t\t\t\n\t\t\t\tsnprintf(trychan, sizeof(trychan), \"%s/%s\",cur,number);\n\t\t\t\tstatus = inuse = ast_device_state(trychan);\n\t\t\t}\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%d\", status);\n\t\t\tast_str_append(&tmp_availstat, 0, \"%s%s\", ast_str_strlen(tmp_availstat) ? \"&\" : \"\", tmp);\n\t\t\tif ((inuse <= 1) && (tempchan = ast_request(tech, ast_channel_nativeformats(chan), NULL, chan, number, &status))) {\n\t\t\t\t\tast_str_append(&tmp_availchan, 0, \"%s%s\", ast_str_strlen(tmp_availchan) ? \"&\" : \"\", ast_channel_name(tempchan));\n\t\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%s/%s\", tech, number);\n\t\t\t\t\tast_str_append(&tmp_availorig, 0, \"%s%s\", ast_str_strlen(tmp_availorig) ? \"&\" : \"\", tmp);\n\t\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%d\", status);\n\t\t\t\t\tast_str_append(&tmp_availcause, 0, \"%s%s\", ast_str_strlen(tmp_availcause) ? \"&\" : \"\", tmp);\n\t\t\t\t\tast_hangup(tempchan);\n\t\t\t\t\ttempchan = NULL;\n\t\t\t\t\tif (!option_all_avail) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tcur = rest;\n\t\t} while (cur);\n\t}\n\tpbx_builtin_setvar_helper(chan, \"AVAILCHAN\", ast_str_buffer(tmp_availchan));\n\t\n\tpbx_builtin_setvar_helper(chan, \"AVAILORIGCHAN\", ast_str_buffer(tmp_availorig));\n\tpbx_builtin_setvar_helper(chan, \"AVAILSTATUS\", ast_str_buffer(tmp_availstat));\n\tpbx_builtin_setvar_helper(chan, \"AVAILCAUSECODE\", ast_str_buffer(tmp_availcause));\n\treturn 0;\n}\n", "bug_type": null, "idx": 1843}
{"project": "Asterisk", "target": 0, "func": "static int t38udptl_ec_handler(const struct aco_option *opt,\n\tstruct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\tif (!strcmp(var->value, \"none\")) {\n\t\tendpoint->media.t38.error_correction = UDPTL_ERROR_CORRECTION_NONE;\n\t} else if (!strcmp(var->value, \"fec\")) {\n\t\tendpoint->media.t38.error_correction = UDPTL_ERROR_CORRECTION_FEC;\n\t} else if (!strcmp(var->value, \"redundancy\")) {\n\t\tendpoint->media.t38.error_correction = UDPTL_ERROR_CORRECTION_REDUNDANCY;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1844}
{"project": "Asterisk", "target": 0, "func": "\nstatic int speextolin_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tstruct speex_coder_pvt *tmp = pvt->pvt;\n\t\n\tint x;\n\tint res;\n\tint16_t *dst = pvt->outbuf.i16;\n\t\n#ifdef _SPEEX_TYPES_H\n\tspx_int16_t fout[1024];\n#else\n\tfloat fout[1024];\n#endif\n\tif (f->datalen == 0) {  \n\t\tif (pvt->samples + tmp->framesize > BUFFER_SAMPLES) {\n\t\t\tast_log(LOG_WARNING, \"Out of buffer space\\n\");\n\t\t\treturn -1;\n\t\t}\n#ifdef _SPEEX_TYPES_H\n\t\tspeex_decode_int(tmp->speex, NULL, dst + pvt->samples);\n#else\n\t\tspeex_decode(tmp->speex, NULL, fout);\n\t\tfor (x=0;x<tmp->framesize;x++) {\n\t\t\tdst[pvt->samples + x] = (int16_t)fout[x];\n\t\t}\n#endif\n\t\tpvt->samples += tmp->framesize;\n\t\tpvt->datalen += 2 * tmp->framesize; \n\t\treturn 0;\n\t}\n\t\n\tspeex_bits_read_from(&tmp->bits, f->data.ptr, f->datalen);\n\tfor (;;) {\n#ifdef _SPEEX_TYPES_H\n\t\tres = speex_decode_int(tmp->speex, &tmp->bits, fout);\n#else\n\t\tres = speex_decode(tmp->speex, &tmp->bits, fout);\n#endif\n\t\tif (res < 0)\n\t\t\tbreak;\n\t\tif (pvt->samples + tmp->framesize > BUFFER_SAMPLES) {\n\t\t\tast_log(LOG_WARNING, \"Out of buffer space\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 0 ; x < tmp->framesize; x++)\n\t\t\tdst[pvt->samples + x] = (int16_t)fout[x];\n\t\tpvt->samples += tmp->framesize;\n\t\tpvt->datalen += 2 * tmp->framesize; \n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1845}
{"project": "Asterisk", "target": 0, "func": "\nem_yank(EditLine *el, int c)\n{\n\tchar *kp, *cp;\n\tif (el->el_chared.c_kill.last == el->el_chared.c_kill.buf) {\n\t\tif (!ch_enlargebufs(el, 1))\n\t\t\treturn (CC_ERROR);\n\t}\n\tif (el->el_line.lastchar +\n\t    (el->el_chared.c_kill.last - el->el_chared.c_kill.buf) >=\n\t    el->el_line.limit)\n\t\treturn (CC_ERROR);\n\tel->el_chared.c_kill.mark = el->el_line.cursor;\n\tcp = el->el_line.cursor;\n\t\n\tc_insert(el, el->el_chared.c_kill.last - el->el_chared.c_kill.buf);\n\t\n\tfor (kp = el->el_chared.c_kill.buf; kp < el->el_chared.c_kill.last; kp++)\n\t\t*cp++ = *kp;\n\t\n\tif (el->el_state.argument == 1)\n\t\tel->el_line.cursor = cp;\n\treturn (CC_REFRESH);\n}\n", "bug_type": null, "idx": 1846}
{"project": "Asterisk", "target": 0, "func": ");\nstatic void destroy_config(void)\n{\n\tao2_global_obj_release(cfg_handle);\n\taco_info_destroy(&cfg_info);\n}\n", "bug_type": null, "idx": 1847}
{"project": "Asterisk", "target": 0, "func": "\nstatic int publish_hint_change(struct ast_hint *hint, struct ast_exten *ne)\n{\n\tstruct stasis_message *message;\n\tif (!hint_change_message_type()) {\n\t\treturn -1;\n\t}\n\t\n\tif (!(message = stasis_message_create(hint_change_message_type(), ao2_bump(hint)))) {\n\t\tao2_ref(hint, -1);\n\t\treturn -1;\n\t}\n\tstasis_publish(ast_device_state_topic_all(), message);\n\tstasis_publish(ast_presence_state_topic_all(), message);\n\tao2_ref(message, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1848}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_session_media_state_reset(struct ast_sip_session_media_state *media_state)\n{\n\tint index;\n\tif (!media_state) {\n\t\treturn;\n\t}\n\tAST_VECTOR_RESET(&media_state->sessions, ao2_cleanup);\n\tAST_VECTOR_RESET(&media_state->read_callbacks, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\tfor (index = 0; index < AST_MEDIA_TYPE_END; ++index) {\n\t\tmedia_state->default_session[index] = NULL;\n\t}\n\tast_stream_topology_free(media_state->topology);\n\tmedia_state->topology = NULL;\n}\n", "bug_type": null, "idx": 1849}
{"project": "Asterisk", "target": 0, "func": "static void my_deadlock_avoidance_private(void *pvt)\n{\n\tstruct dahdi_pvt *p = pvt;\n\tDEADLOCK_AVOIDANCE(&p->lock);\n}\n", "bug_type": null, "idx": 1850}
{"project": "Asterisk", "target": 0, "func": "\nstatic void asterisk_publication_config_destroy(void *obj)\n{\n\tstruct asterisk_publication_config *config = obj;\n\tast_string_field_free_memory(config);\n}\n", "bug_type": null, "idx": 1851}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tCHECK_PJSIP_SESSION_MODULE_LOADED();\n\tast_sip_session_register_supplement(&caller_id_supplement);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1852}
{"project": "Asterisk", "target": 0, "func": "static int move_aliens(void)\n{\n\tstruct blip *cur;\n\tstruct blip *current_barrier;\n\tAST_LIST_TRAVERSE(&blips, cur, entry) {\n\t\tif (cur->type != BLIP_ALIEN) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tif (cur->goingleft && (cur->x == 0)) {\n\t\t\tcur->y++;\n\t\t\tcur->goingleft = 0;\n\t\t} else if (!cur->goingleft && cur->x == (max_x - 1)) {\n\t\t\tcur->y++;\n\t\t\tcur->goingleft = 1;\n\t\t} else if (cur->goingleft) {\n\t\t\tcur->x--;\n\t\t} else {\n\t\t\tcur->x++;\n\t\t}\n\t\t\n\t\tif (cur->x == tank->x && cur->y == tank->y)\n\t\t\treturn 1;\n\t\tAST_LIST_TRAVERSE(&blips, current_barrier, entry){\n\t\t\tif(current_barrier->type!=BLIP_BARRIER)\n\t\t\t\tcontinue;\n\t\t\tif(cur->y == current_barrier->y && cur->x == current_barrier -> x)\n\t\t\t\tremove_blip(current_barrier);\n\t\t}\n\t\tif (random() % 100 < BOMB_PROB && cur->y != max_y) {\n\t\t\tstruct blip *bomb = calloc(1, sizeof(struct blip));\n\t\t\tif (!bomb)\n\t\t\t\tcontinue;\n\t\t\tbomb->type = BLIP_BOMB;\n\t\t\tbomb->x = cur->x;\n\t\t\tbomb->y = cur->y + 1;\n\t\t\tAST_LIST_INSERT_HEAD(&blips, bomb, entry);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1853}
{"project": "Asterisk", "target": 0, "func": "    *---------------------------------------------------------------*/\n   float xCorrCoef(\n       float *target,      \n       float *regressor,   \n       int subl        \n   ){\n       int i;\n       float ftmp1, ftmp2;\n       ftmp1 = 0.0;\n       ftmp2 = 0.0;\n       for (i=0; i<subl; i++) {\n           ftmp1 += target[i]*regressor[i];\n           ftmp2 += regressor[i]*regressor[i];\n       }\n       if (ftmp1 > 0.0) {\n           return (float)(ftmp1*ftmp1/ftmp2);\n       }\n       else {\n           return (float)0.0;\n       }\n   }\n", "bug_type": null, "idx": 1854}
{"project": "Asterisk", "target": 0, "func": "\nstatic int jingle_interpret_ice_udp_transport(struct jingle_session *session, iks *transport, struct ast_rtp_instance *rtp)\n{\n\tstruct ast_rtp_engine_ice *ice = ast_rtp_instance_get_ice(rtp);\n\tchar *ufrag = iks_find_attrib(transport, \"ufrag\"), *pwd = iks_find_attrib(transport, \"pwd\");\n\tiks *candidate;\n\tif (!ice) {\n\t\tjingle_queue_hangup_with_cause(session, AST_CAUSE_SWITCH_CONGESTION);\n\t\tast_log(LOG_ERROR, \"Received ICE-UDP transport information on session '%s' but ICE support not available\\n\", session->sid);\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(ufrag) && !ast_strlen_zero(pwd)) {\n\t\tice->set_authentication(rtp, ufrag, pwd);\n\t}\n\tfor (candidate = iks_child(transport); candidate; candidate = iks_next(candidate)) {\n\t\tchar *component = iks_find_attrib(candidate, \"component\"), *foundation = iks_find_attrib(candidate, \"foundation\");\n\t\tchar *generation = iks_find_attrib(candidate, \"generation\"), *id = iks_find_attrib(candidate, \"id\");\n\t\tchar *ip = iks_find_attrib(candidate, \"ip\"), *port = iks_find_attrib(candidate, \"port\");\n\t\tchar *priority = iks_find_attrib(candidate, \"priority\"), *protocol = iks_find_attrib(candidate, \"protocol\");\n\t\tchar *type = iks_find_attrib(candidate, \"type\");\n\t\tstruct ast_rtp_engine_ice_candidate local_candidate = { 0, };\n\t\tint real_port;\n\t\tstruct ast_sockaddr remote_address = { { 0, } };\n\t\t\n\t\tif (ast_strlen_zero(component) || ast_strlen_zero(foundation) || ast_strlen_zero(generation) || ast_strlen_zero(id) ||\n\t\t    ast_strlen_zero(ip) || ast_strlen_zero(port) || ast_strlen_zero(priority) ||\n\t\t    ast_strlen_zero(protocol) || ast_strlen_zero(type)) {\n\t\t\tjingle_queue_hangup_with_cause(session, AST_CAUSE_PROTOCOL_ERROR);\n\t\t\tast_log(LOG_ERROR, \"Incomplete ICE-UDP candidate received on session '%s'\\n\", session->sid);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((sscanf(component, \"%30u\", &local_candidate.id) != 1) ||\n\t\t    (sscanf(priority, \"%30u\", (unsigned *)&local_candidate.priority) != 1) ||\n\t\t    (sscanf(port, \"%30d\", &real_port) != 1)) {\n\t\t\tjingle_queue_hangup_with_cause(session, AST_CAUSE_PROTOCOL_ERROR);\n\t\t\tast_log(LOG_ERROR, \"Invalid ICE-UDP candidate information received on session '%s'\\n\", session->sid);\n\t\t\treturn -1;\n\t\t}\n\t\tlocal_candidate.foundation = foundation;\n\t\tlocal_candidate.transport = protocol;\n\t\tast_sockaddr_parse(&local_candidate.address, ip, PARSE_PORT_FORBID);\n\t\t\n\t\tif (!ast_sockaddr_is_ipv4(&local_candidate.address)) {\n\t\t\tcontinue;\n\t\t}\n\t\tast_sockaddr_set_port(&local_candidate.address, real_port);\n\t\tif (!strcasecmp(type, \"host\")) {\n\t\t\tlocal_candidate.type = AST_RTP_ICE_CANDIDATE_TYPE_HOST;\n\t\t} else if (!strcasecmp(type, \"srflx\")) {\n\t\t\tlocal_candidate.type = AST_RTP_ICE_CANDIDATE_TYPE_SRFLX;\n\t\t} else if (!strcasecmp(type, \"relay\")) {\n\t\t\tlocal_candidate.type = AST_RTP_ICE_CANDIDATE_TYPE_RELAYED;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tast_rtp_instance_get_remote_address(rtp, &remote_address);\n\t\tif (ast_sockaddr_is_ipv4(&local_candidate.address) && ast_sockaddr_isnull(&remote_address)) {\n\t\t\tast_rtp_instance_set_remote_address(rtp, &local_candidate.address);\n\t\t}\n\t\tice->add_remote_candidate(rtp, &local_candidate);\n\t}\n\tice->start(rtp);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1855}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function isexten_function = {\n\t.name = \"DIALPLAN_EXISTS\",\n\t.read = isexten_function_read,\n\t.read_max = 2,\n};\n", "bug_type": null, "idx": 1856}
{"project": "Asterisk", "target": 0, "func": "static void safe_channel_release(struct ast_channel *chan)\n{\n\tif (!chan) {\n\t\treturn;\n\t}\n\tast_channel_release(chan);\n}\n", "bug_type": null, "idx": 1857}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225Alerting_UUIE (OOCTXT* pctxt, H225Alerting_UUIE* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.callIdentifierPresent ||\n   pvalue->m.h245SecurityModePresent ||\n   pvalue->m.tokensPresent ||\n   pvalue->m.cryptoTokensPresent ||\n   pvalue->m.fastStartPresent ||\n   pvalue->m.multipleCallsPresent ||\n   pvalue->m.maintainConnectionPresent ||\n   pvalue->m.alertingAddressPresent ||\n   pvalue->m.presentationIndicatorPresent ||\n   pvalue->m.screeningIndicatorPresent ||\n   pvalue->m.fastConnectRefusedPresent ||\n   pvalue->m.serviceControlPresent ||\n   pvalue->m.capacityPresent ||\n   pvalue->m.featureSetPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.h245AddressPresent);\n   \n   stat = asn1PE_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225EndpointType (pctxt, &pvalue->destinationInfo);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.h245AddressPresent) {\n      stat = asn1PE_H225TransportAddress (pctxt, &pvalue->h245Address);\n      if (stat != ASN_OK) return stat;\n   }\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 13);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.callIdentifierPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.h245SecurityModePresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.tokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.cryptoTokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.fastStartPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.multipleCallsPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.maintainConnectionPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.alertingAddressPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.presentationIndicatorPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.screeningIndicatorPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.fastConnectRefusedPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.serviceControlPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.capacityPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.featureSetPresent);\n      \n      if (pvalue->m.callIdentifierPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225CallIdentifier (&lctxt, &pvalue->callIdentifier);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.h245SecurityModePresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225H245Security (&lctxt, &pvalue->h245SecurityMode);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.tokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225ClearToken (&lctxt, &pvalue->tokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.cryptoTokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225CryptoH323Token (&lctxt, &pvalue->cryptoTokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.fastStartPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225Alerting_UUIE_fastStart (&lctxt, &pvalue->fastStart);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.multipleCallsPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeBit (&lctxt, (ASN1BOOL)pvalue->multipleCalls);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.maintainConnectionPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeBit (&lctxt, (ASN1BOOL)pvalue->maintainConnection);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.alertingAddressPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225AliasAddress (&lctxt, &pvalue->alertingAddress);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.presentationIndicatorPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225PresentationIndicator (&lctxt, &pvalue->presentationIndicator);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.screeningIndicatorPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225ScreeningIndicator (&lctxt, pvalue->screeningIndicator);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.fastConnectRefusedPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         \n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.serviceControlPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225ServiceControlSession (&lctxt, &pvalue->serviceControl);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.capacityPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225CallCapacity (&lctxt, &pvalue->capacity);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.featureSetPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225FeatureSet (&lctxt, &pvalue->featureSet);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1858}
{"project": "Asterisk", "target": 0, "func": "struct ao2_container *users;\nSIMPLE_HASH_FN(user_hash_fn, user, macaddress)\nSIMPLE_CMP_FN(user_cmp_fn, user, macaddress)\n\nstruct http_route {\n\tAST_DECLARE_STRING_FIELDS(\n\t\tAST_STRING_FIELD(uri);\t\n\t);\n\tstruct phoneprov_file *file;\t\n\tstruct user *user;\t\n\tstruct phone_profile *profile;\n};\n", "bug_type": null, "idx": 1859}
{"project": "Asterisk", "target": 0, "func": "#define SIG_PRI_SC_LINE\t\t \"%4d %4d %-4s %-4s %-10s %-4s %s\"\nvoid sig_pri_cli_show_channels_header(int fd)\n{\n\tast_cli(fd, SIG_PRI_SC_HEADER, \"PRI\",  \"\",     \"B\",    \"Chan\", \"Call\",  \"PRI\",  \"Channel\");\n\tast_cli(fd, SIG_PRI_SC_HEADER, \"Span\", \"Chan\", \"Chan\", \"Idle\", \"Level\", \"Call\", \"Name\");\n}\n", "bug_type": null, "idx": 1860}
{"project": "Asterisk", "target": 0, "func": "static int process_xml_member_data_node(xmlNode *node, struct member *mem)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 1861}
{"project": "Asterisk", "target": 0, "func": "static int playtones_generator(struct ast_channel *chan, void *data, int len, int samples)\n{\n\tstruct playtones_state *ps = data;\n\tstruct playtones_item *pi;\n\tint x;\n\t\n\tlen = samples * 2;\n\tif (len > sizeof(ps->data) / 2 - 1) {\n\t\tast_log(LOG_WARNING, \"Can't generate that much data!\\n\");\n\t\treturn -1;\n\t}\n\tmemset(&ps->f, 0, sizeof(ps->f));\n\tpi = &ps->items[ps->npos];\n\tif (ps->oldnpos != ps->npos) {\n\t\t\n\t\tps->v1_1 = 0;\n\t\tps->v2_1 = pi->init_v2_1;\n\t\tps->v3_1 = pi->init_v3_1;\n\t\tps->v1_2 = 0;\n\t\tps->v2_2 = pi->init_v2_2;\n\t\tps->v3_2 = pi->init_v3_2;\n\t\tps->oldnpos = ps->npos;\n\t}\n\tfor (x = 0; x < samples; x++) {\n\t\tps->v1_1 = ps->v2_1;\n\t\tps->v2_1 = ps->v3_1;\n\t\tps->v3_1 = (pi->fac1 * ps->v2_1 >> 15) - ps->v1_1;\n\t\tps->v1_2 = ps->v2_2;\n\t\tps->v2_2 = ps->v3_2;\n\t\tps->v3_2 = (pi->fac2 * ps->v2_2 >> 15) - ps->v1_2;\n\t\tif (pi->modulate) {\n\t\t\tint p;\n\t\t\tp = ps->v3_2 - 32768;\n\t\t\tif (p < 0) {\n\t\t\t\tp = -p;\n\t\t\t}\n\t\t\tp = ((p * 9) / 10) + 1;\n\t\t\tps->data[x] = (ps->v3_1 * p) >> 15;\n\t\t} else {\n\t\t\tps->data[x] = ps->v3_1 + ps->v3_2;\n\t\t}\n\t}\n\tps->f.frametype = AST_FRAME_VOICE;\n\tps->f.subclass.format = ast_format_slin;\n\tps->f.datalen = len;\n\tps->f.samples = samples;\n\tps->f.offset = AST_FRIENDLY_OFFSET;\n\tps->f.data.ptr = ps->data;\n\tif (ast_write(chan, &ps->f)) {\n\t\treturn -1;\n\t}\n\tps->pos += x;\n\tif (pi->duration && ps->pos >= pi->duration * 8) {\t\n\t\tps->pos = 0;\t\t\t\t\t\n\t\tps->npos++;\n\t\tif (ps->npos >= ps->nitems) {\t\t\t\n\t\t\tif (ps->reppos == -1) {\t\t\t\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tps->npos = ps->reppos;\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1862}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_sound(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_formats = 0;\n\tint has_id = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"formats\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_formats = 1;\n\t\t\tprop_is_valid = ast_ari_validate_list(\n\t\t\t\tast_json_object_iter_value(iter),\n\t\t\t\tast_ari_validate_format_lang_pair);\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Sound field formats failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"id\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_id = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Sound field id failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"text\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI Sound field text failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI Sound has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_formats) {\n\t\tast_log(LOG_ERROR, \"ARI Sound missing required field formats\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_id) {\n\t\tast_log(LOG_ERROR, \"ARI Sound missing required field id\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1863}
{"project": "Asterisk", "target": 0, "func": "void control_wait(struct stasis_app_control *control)\n{\n\tif (!control) {\n\t\treturn;\n\t}\n\tast_assert(control->command_queue != NULL);\n\tao2_lock(control->command_queue);\n\twhile (ao2_container_count(control->command_queue) == 0) {\n\t\tint res = ast_cond_wait(&control->wait_cond,\n\t\t\tao2_object_get_lockaddr(control->command_queue));\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_ERROR, \"Error waiting on command queue\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tao2_unlock(control->command_queue);\n}\n", "bug_type": null, "idx": 1864}
{"project": "Asterisk", "target": 0, "func": "int ast_extension_state_add(const char *context, const char *exten,\n\tast_state_cb_type change_cb, void *data)\n{\n\treturn extension_state_add_destroy(context, exten, change_cb, NULL, data, 0);\n}\n", "bug_type": null, "idx": 1865}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_ari_channels_list_cb(\n\tstruct ast_tcptls_session_instance *ser,\n\tstruct ast_variable *get_params, struct ast_variable *path_vars,\n\tstruct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)\n{\n\tstruct ast_ari_channels_list_args args = {};\n#if defined(AST_DEVMODE)\n\tint is_valid;\n\tint code;\n#endif \n\tast_ari_channels_list(headers, &args, response);\n#if defined(AST_DEVMODE)\n\tcode = response->response_code;\n\tswitch (code) {\n\tcase 0: \n\t\tis_valid = response->message == NULL;\n\t\tbreak;\n\tcase 500: \n\tcase 501: \n\t\tis_valid = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (200 <= code && code <= 299) {\n\t\t\tis_valid = ast_ari_validate_list(response->message,\n\t\t\t\tast_ari_validate_channel_fn());\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Invalid error response %d for /channels\\n\", code);\n\t\t\tis_valid = 0;\n\t\t}\n\t}\n\tif (!is_valid) {\n\t\tast_log(LOG_ERROR, \"Response validation failed for /channels\\n\");\n\t\tast_ari_response_error(response, 500,\n\t\t\t\"Internal Server Error\", \"Response validation failed\");\n\t}\n#endif \nfin: __attribute__((unused))\n\treturn;\n}\n", "bug_type": null, "idx": 1866}
{"project": "Asterisk", "target": 0, "func": "\nstatic void run_externnotify(struct ast_channel *chan, struct minivm_account *vmu)\n{\n\tchar fquser[AST_MAX_CONTEXT * 2];\n\tchar *argv[5] = { NULL };\n\tstruct ast_party_caller *caller;\n\tchar *cid;\n\tint idx;\n\tif (ast_strlen_zero(vmu->externnotify) && ast_strlen_zero(global_externnotify)) {\n\t\treturn;\n\t}\n\tsnprintf(fquser, sizeof(fquser), \"%s@%s\", vmu->username, vmu->domain);\n\tcaller = ast_channel_caller(chan);\n\tidx = 0;\n\targv[idx++] = ast_strlen_zero(vmu->externnotify) ? global_externnotify : vmu->externnotify;\n\targv[idx++] = fquser;\n\tcid = S_COR(caller->id.name.valid, caller->id.name.str, NULL);\n\tif (cid) {\n\t\targv[idx++] = cid;\n\t}\n\tcid = S_COR(caller->id.number.valid, caller->id.number.str, NULL);\n\tif (cid) {\n\t\targv[idx++] = cid;\n\t}\n\targv[idx] = NULL;\n\tast_debug(1, \"Executing: %s %s %s %s\\n\",\n\t\targv[0], argv[1], argv[2] ?: \"\", argv[3] ?: \"\");\n\tast_safe_execvp(1, argv[0], argv);\n}\n", "bug_type": null, "idx": 1867}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int load_module(void)\n{\n\tint res;\n#if defined(HAVE_PRI) || defined(HAVE_SS7)\n\tint y;\n#endif\t\n\tif (STASIS_MESSAGE_TYPE_INIT(dahdichannel_type)) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (!(dahdi_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tast_format_cap_append(dahdi_tech.capabilities, ast_format_slin, 0);\n\tast_format_cap_append(dahdi_tech.capabilities, ast_format_ulaw, 0);\n\tast_format_cap_append(dahdi_tech.capabilities, ast_format_alaw, 0);\n\tif (dahdi_native_load(&dahdi_tech)) {\n\t\tao2_ref(dahdi_tech.capabilities, -1);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n#ifdef HAVE_PRI\n\tmemset(pris, 0, sizeof(pris));\n\tfor (y = 0; y < NUM_SPANS; y++) {\n\t\tsig_pri_init_pri(&pris[y].pri);\n\t}\n\tpri_set_error(dahdi_pri_error);\n\tpri_set_message(dahdi_pri_message);\n\tast_register_application_xml(dahdi_send_keypad_facility_app, dahdi_send_keypad_facility_exec);\n#ifdef HAVE_PRI_PROG_W_CAUSE\n\tast_register_application_xml(dahdi_send_callrerouting_facility_app, dahdi_send_callrerouting_facility_exec);\n#endif\n#if defined(HAVE_PRI_CCSS)\n\tif (ast_cc_agent_register(&dahdi_pri_cc_agent_callbacks)\n\t\t|| ast_cc_monitor_register(&dahdi_pri_cc_monitor_callbacks)) {\n\t\t__unload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n#endif\t\n\tif (sig_pri_load(\n#if defined(HAVE_PRI_CCSS)\n\t\tdahdi_pri_cc_type\n#else\n\t\tNULL\n#endif\t\n\t\t)) {\n\t\t__unload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n#endif\n#if defined(HAVE_SS7)\n\tmemset(linksets, 0, sizeof(linksets));\n\tfor (y = 0; y < NUM_SPANS; y++) {\n\t\tsig_ss7_init_linkset(&linksets[y].ss7);\n\t}\n\tss7_set_error(dahdi_ss7_error);\n\tss7_set_message(dahdi_ss7_message);\n\tss7_set_hangup(sig_ss7_cb_hangup);\n\tss7_set_notinservice(sig_ss7_cb_notinservice);\n\tss7_set_call_null(sig_ss7_cb_call_null);\n#endif\t\n\tres = setup_dahdi(0);\n\t\n\tif (res) {\n\t\t__unload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tif (ast_channel_register(&dahdi_tech)) {\n\t\tast_log(LOG_ERROR, \"Unable to register channel class 'DAHDI'\\n\");\n\t\t__unload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n#ifdef HAVE_PRI\n\tast_cli_register_multiple(dahdi_pri_cli, ARRAY_LEN(dahdi_pri_cli));\n#endif\n#if defined(HAVE_SS7)\n\tast_cli_register_multiple(dahdi_ss7_cli, ARRAY_LEN(dahdi_ss7_cli));\n#endif\t\n#ifdef HAVE_OPENR2\n\tast_cli_register_multiple(dahdi_mfcr2_cli, ARRAY_LEN(dahdi_mfcr2_cli));\n\tast_register_application_xml(dahdi_accept_r2_call_app, dahdi_accept_r2_call_exec);\n#endif\n\tast_cli_register_multiple(dahdi_cli, ARRAY_LEN(dahdi_cli));\n\tmemset(round_robin, 0, sizeof(round_robin));\n\tast_manager_register_xml(\"DAHDITransfer\", 0, action_transfer);\n\tast_manager_register_xml(\"DAHDIHangup\", 0, action_transferhangup);\n\tast_manager_register_xml(\"DAHDIDialOffhook\", 0, action_dahdidialoffhook);\n\tast_manager_register_xml(\"DAHDIDNDon\", 0, action_dahdidndon);\n\tast_manager_register_xml(\"DAHDIDNDoff\", 0, action_dahdidndoff);\n\tast_manager_register_xml(\"DAHDIShowChannels\", 0, action_dahdishowchannels);\n\tast_manager_register_xml(\"DAHDIRestart\", 0, action_dahdirestart);\n#if defined(HAVE_PRI)\n\tast_manager_register_xml(\"PRIShowSpans\", 0, action_prishowspans);\n\tast_manager_register_xml(\"PRIDebugSet\", 0, action_pri_debug_set);\n\tast_manager_register_xml(\"PRIDebugFileSet\", EVENT_FLAG_SYSTEM, action_pri_debug_file_set);\n\tast_manager_register_xml(\"PRIDebugFileUnset\", 0, action_pri_debug_file_unset);\n#endif\t\n\tast_cond_init(&ss_thread_complete, NULL);\n\treturn res;\n}\n", "bug_type": null, "idx": 1868}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245H263VideoMode (OOCTXT* pctxt, H245H263VideoMode* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   \n   invokeStartElement (pctxt, \"resolution\", -1);\n   stat = asn1PD_H245H263VideoMode_resolution (pctxt, &pvalue->resolution);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"resolution\", -1);\n   \n   invokeStartElement (pctxt, \"bitRate\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 19200U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->bitRate);\n   invokeEndElement (pctxt, \"bitRate\", -1);\n   \n   invokeStartElement (pctxt, \"unrestrictedVector\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->unrestrictedVector);\n   invokeEndElement (pctxt, \"unrestrictedVector\", -1);\n   \n   invokeStartElement (pctxt, \"arithmeticCoding\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->arithmeticCoding);\n   invokeEndElement (pctxt, \"arithmeticCoding\", -1);\n   \n   invokeStartElement (pctxt, \"advancedPrediction\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->advancedPrediction);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->advancedPrediction);\n   invokeEndElement (pctxt, \"advancedPrediction\", -1);\n   \n   invokeStartElement (pctxt, \"pbFrames\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->pbFrames);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->pbFrames);\n   invokeEndElement (pctxt, \"pbFrames\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 3 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.errorCompensationPresent = 1;\n                     invokeStartElement (pctxt, \"errorCompensation\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->errorCompensation);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->errorCompensation);\n                     invokeEndElement (pctxt, \"errorCompensation\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.enhancementLayerInfoPresent = 1;\n                     invokeStartElement (pctxt, \"enhancementLayerInfo\", -1);\n                     stat = asn1PD_H245EnhancementLayerInfo (pctxt, &pvalue->enhancementLayerInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"enhancementLayerInfo\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.h263OptionsPresent = 1;\n                     invokeStartElement (pctxt, \"h263Options\", -1);\n                     stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"h263Options\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1869}
{"project": "Asterisk", "target": 0, "func": "static int volume_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tstruct ast_datastore *datastore = NULL;\n\tstruct volume_information *vi = NULL;\n\tint is_new = 0;\n\t\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(direction);\n\t\tAST_APP_ARG(options);\n\t);\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"No channel was provided to %s function.\\n\", cmd);\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tast_channel_lock(chan);\n\tif (!(datastore = ast_channel_datastore_find(chan, &volume_datastore, NULL))) {\n\t\tast_channel_unlock(chan);\n\t\t\n\t\tif (!(datastore = ast_datastore_alloc(&volume_datastore, NULL)))\n\t\t\treturn 0;\n\t\tif (!(vi = ast_calloc(1, sizeof(*vi)))) {\n\t\t\tast_datastore_free(datastore);\n\t\t\treturn 0;\n\t\t}\n\t\tast_audiohook_init(&vi->audiohook, AST_AUDIOHOOK_TYPE_MANIPULATE, \"Volume\", AST_AUDIOHOOK_MANIPULATE_ALL_RATES);\n\t\tvi->audiohook.manipulate_callback = volume_callback;\n\t\tast_set_flag(&vi->audiohook, AST_AUDIOHOOK_WANTS_DTMF);\n\t\tis_new = 1;\n\t} else {\n\t\tast_channel_unlock(chan);\n\t\tvi = datastore->data;\n\t}\n\t\n\tif (ast_strlen_zero(args.direction)) {\n\t\tast_log(LOG_ERROR, \"Direction must be specified for VOLUME function\\n\");\n\t\treturn -1;\n\t}\n\tif (!strcasecmp(args.direction, \"tx\")) { \n\t\tvi->tx_gain = atoi(value); \n\t} else if (!strcasecmp(args.direction, \"rx\")) {\n\t\tvi->rx_gain = atoi(value);\n\t} else {\n\t\tast_log(LOG_ERROR, \"Direction must be either RX or TX\\n\");\n\t}\n\tif (is_new) {\n\t\tdatastore->data = vi;\n\t\tast_channel_lock(chan);\n\t\tast_channel_datastore_add(chan, datastore);\n\t\tast_channel_unlock(chan);\n\t\tast_audiohook_attach(chan, &vi->audiohook);\n\t}\n\t\n\tif (!ast_strlen_zero(args.options)) {\n\t\tstruct ast_flags flags = { 0 };\n\t\tast_app_parse_options(volume_opts, &flags, NULL, args.options);\n\t\tvi->flags = flags.flags;\n\t} else { \n\t\tvi->flags = 0; \n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1870}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct merge_direction bridge_merge_determine_direction(struct ast_bridge *bridge1, struct ast_bridge *bridge2)\n{\n\tstruct merge_direction merge = { NULL, NULL };\n\tint bridge1_priority;\n\tint bridge2_priority;\n\tif (!ast_test_flag(&bridge1->feature_flags,\n\t\t\tAST_BRIDGE_FLAG_MERGE_INHIBIT_TO | AST_BRIDGE_FLAG_MERGE_INHIBIT_FROM)\n\t\t&& !ast_test_flag(&bridge2->feature_flags,\n\t\t\tAST_BRIDGE_FLAG_MERGE_INHIBIT_TO | AST_BRIDGE_FLAG_MERGE_INHIBIT_FROM)) {\n\t\t\n\t\tbridge1_priority = bridge1->v_table->get_merge_priority(bridge1);\n\t\tbridge2_priority = bridge2->v_table->get_merge_priority(bridge2);\n\t\tif (bridge2_priority < bridge1_priority) {\n\t\t\tmerge.dest = bridge1;\n\t\t\tmerge.src = bridge2;\n\t\t} else if (bridge1_priority < bridge2_priority) {\n\t\t\tmerge.dest = bridge2;\n\t\t\tmerge.src = bridge1;\n\t\t} else {\n\t\t\t\n\t\t\tif (bridge2->num_channels <= bridge1->num_channels) {\n\t\t\t\tmerge.dest = bridge1;\n\t\t\t\tmerge.src = bridge2;\n\t\t\t} else {\n\t\t\t\tmerge.dest = bridge2;\n\t\t\t\tmerge.src = bridge1;\n\t\t\t}\n\t\t}\n\t} else if (!ast_test_flag(&bridge1->feature_flags, AST_BRIDGE_FLAG_MERGE_INHIBIT_TO)\n\t\t&& !ast_test_flag(&bridge2->feature_flags, AST_BRIDGE_FLAG_MERGE_INHIBIT_FROM)) {\n\t\t\n\t\tmerge.dest = bridge1;\n\t\tmerge.src = bridge2;\n\t} else if (!ast_test_flag(&bridge2->feature_flags, AST_BRIDGE_FLAG_MERGE_INHIBIT_TO)\n\t\t&& !ast_test_flag(&bridge1->feature_flags, AST_BRIDGE_FLAG_MERGE_INHIBIT_FROM)) {\n\t\t\n\t\tmerge.dest = bridge2;\n\t\tmerge.src = bridge1;\n\t}\n\treturn merge;\n}\n", "bug_type": null, "idx": 1871}
{"project": "Asterisk", "target": 0, "func": "static int cc_core_instance_cmp_fn(void *obj, void *arg, int flags)\n{\n\tstruct cc_core_instance *core_instance1 = obj;\n\tstruct cc_core_instance *core_instance2 = arg;\n\treturn core_instance1->core_id == core_instance2->core_id ? CMP_MATCH | CMP_STOP : 0;\n}\n", "bug_type": null, "idx": 1872}
{"project": "Asterisk", "target": 0, "func": "\nem_inc_search_next(EditLine *el, int c)\n{\n\tel->el_search.patlen = 0;\n\treturn (ce_inc_search(el, ED_SEARCH_NEXT_HISTORY));\n}\n", "bug_type": null, "idx": 1873}
{"project": "Asterisk", "target": 0, "func": "#if defined(MWI_DEBUG_CLI)\nstatic char *handle_mwi_delete_like(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tconst char *regex;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"mwi delete like\";\n\t\te->usage =\n\t\t\t\"Usage: mwi delete like <pattern>\\n\"\n\t\t\t\"       Delete external MWI mailboxes matching a regular expression.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tregex = a->argv[3];\n\tast_mwi_mailbox_delete_by_regex(regex);\n\tast_cli(a->fd, \"Deleted external MWI mailboxes matching '%s'.\\n\", regex);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1874}
{"project": "Asterisk", "target": 0, "func": "static void get_general_options(struct fax_options *options)\n{\n\tast_rwlock_rdlock(&options_lock);\n\t*options = general_options;\n\tast_rwlock_unlock(&options_lock);\n}\n", "bug_type": null, "idx": 1875}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *_ast_xmldoc_build_synopsis(struct ast_xml_node *node)\n{\n\treturn _xmldoc_build_field(node, \"synopsis\", 1);\n}\n", "bug_type": null, "idx": 1876}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct unistimsession *create_client(const struct sockaddr_in *addr_from)\n{\n\tint tmp;\n\tstruct unistimsession *s;\n\tif (!(s = ast_calloc(1, sizeof(*s))))\n\t\treturn NULL;\n\tmemcpy(&s->sin, addr_from, sizeof(struct sockaddr_in));\n\tget_to_address(unistimsock, &s->sout);\n\ts->sout.sin_family = AF_INET;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Creating a new entry for the phone from %s received via server ip %s\\n\",\n\t\t\t ast_inet_ntoa(addr_from->sin_addr), ast_inet_ntoa(s->sout.sin_addr));\n\t}\n\tast_mutex_init(&s->lock);\n\tast_mutex_lock(&sessionlock);\n\ts->next = sessions;\n\tsessions = s;\n\ts->timeout = get_tick_count() + RETRANSMIT_TIMER;\n\ts->state = STATE_INIT;\n\ts->tick_next_ping = get_tick_count() + unistim_keepalive;\n\t\n\tfor (tmp = 0; tmp < MAX_BUF_NUMBER; tmp++) {\n\t\ts->wsabufsend[tmp].buf = s->buf[tmp];\n\t}\n\tast_mutex_unlock(&sessionlock);\n\treturn s;\n}\n", "bug_type": null, "idx": 1877}
{"project": "Asterisk", "target": 0, "func": "static int lin16tog722_new(struct ast_trans_pvt *pvt)\n{\n\tstruct g722_encoder_pvt *tmp = pvt->pvt;\n\tg722_encode_init(&tmp->g722, 64000, 0);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1878}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tif (ast_cdr_unregister(name)) {\n\t\treturn -1;\n\t}\n\tif (dsn) {\n\t\tast_free(dsn);\n\t}\n\tif (table) {\n\t\tast_free(table);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1879}
{"project": "Asterisk", "target": 0, "func": "struct ast_party_id ast_channel_redirecting_effective_from(struct ast_channel *chan)\n{\n\treturn ast_party_id_merge(&chan->redirecting.from, &chan->redirecting.priv_from);\n}\n", "bug_type": null, "idx": 1880}
{"project": "Asterisk", "target": 0, "func": "static int pp_each_extension_read2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\treturn pp_each_extension_helper(chan, cmd, data, NULL, buf, len);\n}\n", "bug_type": null, "idx": 1881}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void update_ice(const struct ast_sdp_state *state, struct ast_rtp_instance *rtp, const struct ast_sdp_options *options,\n\tconst struct ast_sdp *remote_sdp, const struct ast_sdp_m_line *remote_m_line)\n{\n\tstruct ast_rtp_engine_ice *ice;\n\tconst struct ast_sdp_a_line *attr;\n\tconst struct ast_sdp_a_line *attr_rtcp_mux;\n\tunsigned int attr_i;\n\t\n\tif (ast_sdp_options_get_ice(options) != AST_SDP_ICE_ENABLED_STANDARD || !(ice = ast_rtp_instance_get_ice(rtp))) {\n\t\treturn;\n\t}\n\tattr = ast_sdp_m_find_attribute(remote_m_line, \"ice-ufrag\", -1);\n\tif (!attr) {\n\t\tattr = ast_sdp_find_attribute(remote_sdp, \"ice-ufrag\", -1);\n\t}\n\tif (attr) {\n\t\tice->set_authentication(rtp, attr->value, NULL);\n\t} else {\n\t\treturn;\n\t}\n\tattr = ast_sdp_m_find_attribute(remote_m_line, \"ice-pwd\", -1);\n\tif (!attr) {\n\t\tattr = ast_sdp_find_attribute(remote_sdp, \"ice-pwd\", -1);\n\t}\n\tif (attr) {\n\t\tice->set_authentication(rtp, NULL, attr->value);\n\t} else {\n\t\treturn;\n\t}\n\tif (ast_sdp_find_attribute(remote_sdp, \"ice-lite\", -1)) {\n\t\tice->ice_lite(rtp);\n\t}\n\tattr_rtcp_mux = ast_sdp_m_find_attribute(remote_m_line, \"rtcp-mux\", -1);\n\t\n\tfor (attr_i = 0; attr_i < ast_sdp_m_get_a_count(remote_m_line); ++attr_i) {\n\t\tchar foundation[32];\n\t\tchar transport[32];\n\t\tchar address[INET6_ADDRSTRLEN + 1];\n\t\tchar cand_type[6];\n\t\tchar relay_address[INET6_ADDRSTRLEN + 1] = \"\";\n\t\tunsigned int port;\n\t\tunsigned int relay_port = 0;\n\t\tstruct ast_rtp_engine_ice_candidate candidate = { 0, };\n\t\tattr = ast_sdp_m_get_a(remote_m_line, attr_i);\n\t\t\n\t\tif (strcmp(attr->name, \"candidate\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf(attr->value, \"%31s %30u %31s %30u %46s %30u typ %5s %*s %23s %*s %30u\",\n\t\t\tfoundation, &candidate.id, transport, (unsigned *)&candidate.priority, address,\n\t\t\t&port, cand_type, relay_address, &relay_port) < 7) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tif (candidate.id > 1\n\t\t\t&& attr_rtcp_mux\n\t\t\t&& ast_sdp_options_get_rtcp_mux(options)) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tcandidate.foundation = foundation;\n\t\tcandidate.transport = transport;\n\t\tast_sockaddr_parse(&candidate.address, address, PARSE_PORT_FORBID);\n\t\tast_sockaddr_set_port(&candidate.address, port);\n\t\tif (!strcasecmp(cand_type, \"host\")) {\n\t\t\tcandidate.type = AST_RTP_ICE_CANDIDATE_TYPE_HOST;\n\t\t} else if (!strcasecmp(cand_type, \"srflx\")) {\n\t\t\tcandidate.type = AST_RTP_ICE_CANDIDATE_TYPE_SRFLX;\n\t\t} else if (!strcasecmp(cand_type, \"relay\")) {\n\t\t\tcandidate.type = AST_RTP_ICE_CANDIDATE_TYPE_RELAYED;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ast_strlen_zero(relay_address)) {\n\t\t\tast_sockaddr_parse(&candidate.relay_address, relay_address, PARSE_PORT_FORBID);\n\t\t}\n\t\tif (relay_port) {\n\t\t\tast_sockaddr_set_port(&candidate.relay_address, relay_port);\n\t\t}\n\t\tice->add_remote_candidate(rtp, &candidate);\n\t}\n\tif (state->role == SDP_ROLE_OFFERER) {\n\t\tice->set_role(rtp, AST_RTP_ICE_ROLE_CONTROLLING);\n\t} else {\n\t\tice->set_role(rtp, AST_RTP_ICE_ROLE_CONTROLLED);\n\t}\n\tice->start(rtp);\n}\n", "bug_type": null, "idx": 1882}
{"project": "Asterisk", "target": 0, "func": "struct ast_xml_node *ast_xml_new_node(const char *name)\n{\n\txmlNode *node;\n\tif (!name) {\n\t\treturn NULL;\n\t}\n\tnode = xmlNewNode(NULL, (const xmlChar *) name);\n\treturn (struct ast_xml_node *) node;\n}\n", "bug_type": null, "idx": 1883}
{"project": "Asterisk", "target": 0, "func": "\nem_exchange_mark(EditLine *el, int c)\n{\n\tchar *cp;\n\tcp = el->el_line.cursor;\n\tel->el_line.cursor = el->el_chared.c_kill.mark;\n\tel->el_chared.c_kill.mark = cp;\n\treturn (CC_CURSOR);\n}\n", "bug_type": null, "idx": 1884}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *ast_json_stringf(const char *format, ...)\n{\n\tstruct ast_json *ret;\n\tva_list args;\n\tva_start(args, format);\n\tret = ast_json_vstringf(format, args);\n\tva_end(args);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1885}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct notify_data* notify_ami_data_create(\n\tstruct ast_sip_endpoint *endpoint, void *info)\n{\n\tstruct notify_data *data = ao2_alloc(sizeof(*data),\n\t\t\t\t\t     notify_ami_data_destroy);\n\tif (!data) {\n\t\treturn NULL;\n\t}\n\tdata->endpoint = endpoint;\n\tao2_ref(data->endpoint, +1);\n\tdata->info = info;\n\tdata->build_notify = build_ami_notify;\n\treturn data;\n}\n", "bug_type": null, "idx": 1886}
{"project": "Asterisk", "target": 0, "func": "\nint ast_say_time_de(struct ast_channel *chan, time_t t, const char *ints, const char *lang)\n{\n\tstruct timeval when = { t, 0 };\n\tstruct ast_tm tm;\n\tint res = 0;\n\tast_localtime(&when, &tm, NULL);\n\tif (!res)\n\t\tres = ast_say_number(chan, tm.tm_hour, ints, lang, \"n\");\n\tif (!res)\n\t\tres = ast_streamfile(chan, \"digits/oclock\", lang);\n\tif (!res)\n\t\tres = ast_waitstream(chan, ints);\n\tif (!res)\n\t    if (tm.tm_min > 0)\n\t\tres = ast_say_number(chan, tm.tm_min, ints, lang, \"f\");\n\treturn res;\n}\n", "bug_type": null, "idx": 1887}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_devstate_list(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_db_entry *db_entry, *db_tree;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"devstate list\";\n\t\te->usage =\n\t\t\t\"Usage: devstate list\\n\"\n\t\t\t\"       List all custom device states that have been set by using\\n\"\n\t\t\t\"       the DEVICE_STATE dialplan function.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != e->args)\n\t\treturn CLI_SHOWUSAGE;\n\tast_cli(a->fd, \"\\n\"\n\t        \"---------------------------------------------------------------------\\n\"\n\t        \"--- Custom Device States --------------------------------------------\\n\"\n\t        \"---------------------------------------------------------------------\\n\"\n\t        \"---\\n\");\n\tdb_entry = db_tree = ast_db_gettree(astdb_family, NULL);\n\tfor (; db_entry; db_entry = db_entry->next) {\n\t\tconst char *dev_name = strrchr(db_entry->key, '/') + 1;\n\t\tif (dev_name <= (const char *) 1)\n\t\t\tcontinue;\n\t\tast_cli(a->fd, \"--- Name: 'Custom:%s'  State: '%s'\\n\"\n\t\t               \"---\\n\", dev_name, db_entry->data);\n\t}\n\tast_db_freetree(db_tree);\n\tdb_tree = NULL;\n\tast_cli(a->fd,\n\t        \"---------------------------------------------------------------------\\n\"\n\t        \"---------------------------------------------------------------------\\n\"\n\t        \"\\n\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1888}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct optional_api *get_api(const char *symname)\n{\n\tstruct optional_api *api;\n\tsize_t i;\n\t\n\tif (apis.list) {\n\t\tfor (i = 0; i < apis.len; ++i) {\n\t\t\tif (strcmp(symname, apis.list[i]->symname) == 0) {\n\t\t\t\treturn apis.list[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tapi = optional_api_create(symname);\n\tif (!api) {\n\t\treturn NULL;\n\t}\n\t\n\tif (apis.len + 1 > apis.maxlen) {\n\t\tsize_t new_maxlen = apis.maxlen ? 2 * apis.maxlen : 1;\n\t\tstruct optional_api **new_list;\n\t\tnew_list = ast_std_realloc(apis.list, new_maxlen * sizeof(*new_list));\n\t\tif (!new_list) {\n\t\t\toptional_api_destroy(api);\n\t\t\tast_log(LOG_ERROR, \"Failed to allocate api list\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tapis.maxlen = new_maxlen;\n\t\tapis.list = new_list;\n\t}\n\tapis.list[apis.len++] = api;\n\treturn api;\n}\n", "bug_type": null, "idx": 1889}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_unregister_outbound_authenticator(struct ast_sip_outbound_authenticator *auth)\n{\n\tif (registered_outbound_authenticator != auth) {\n\t\tast_log(LOG_WARNING, \"Trying to unregister outbound authenticator %p but outbound authenticator %p registered\\n\",\n\t\t\t\tauth, registered_outbound_authenticator);\n\t\treturn;\n\t}\n\tregistered_outbound_authenticator = NULL;\n\tast_debug(1, \"Unregistered SIP outbound authenticator %p\\n\", auth);\n\tast_module_unref(ast_module_info->self);\n}\n", "bug_type": null, "idx": 1890}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int silk_samples(struct ast_frame *frame)\n{\n\t\n\treturn ast_format_get_sample_rate(frame->subclass.format) / 50;\n}\n", "bug_type": null, "idx": 1891}
{"project": "Asterisk", "target": 0, "func": "static char *media_cache_handle_show_item(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n#define FORMAT_ROW \"\\t%20s: %-40.40s\\n\"\n\tstruct ast_bucket_file *bucket_file;\n\tstruct ao2_iterator it_metadata;\n\tstruct ast_bucket_metadata *metadata;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"media cache show\";\n\t\te->usage =\n\t\t\t\"Usage: media cache show <uri>\\n\"\n\t\t\t\"       Display all information about a particular\\n\"\n\t\t\t\"       item in the media cache.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn cli_complete_uri(a->word, a->n);\n\t}\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tbucket_file = ao2_find(media_cache, a->argv[3], OBJ_SEARCH_KEY);\n\tif (!bucket_file) {\n\t\tast_cli(a->fd, \"Unable to find '%s' in the media cache\\n\", a->argv[3]);\n\t\treturn CLI_SUCCESS;\n\t}\n\tast_cli(a->fd, \"URI: %s\\n\", ast_sorcery_object_get_id(bucket_file));\n\tast_cli(a->fd, \"%s\\n\", \"----------------------------------------\");\n\tast_cli(a->fd, FORMAT_ROW, \"Path\", bucket_file->path);\n\tit_metadata = ao2_iterator_init(bucket_file->metadata, 0);\n\twhile ((metadata = ao2_iterator_next(&it_metadata))) {\n\t\tast_cli(a->fd, FORMAT_ROW, metadata->name, metadata->value);\n\t\tao2_ref(metadata, -1);\n\t}\n\tao2_iterator_destroy(&it_metadata);\n\tao2_ref(bucket_file, -1);\n#undef FORMAT_ROW\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1892}
{"project": "Asterisk", "target": 0, "func": "\nstatic int ast_remove_hint(struct ast_exten *e)\n{\n\t\n\tstruct ast_hint *hint;\n\tif (!e) {\n\t\treturn -1;\n\t}\n\thint = ao2_find(hints, e, OBJ_UNLINK);\n\tif (!hint) {\n\t\treturn -1;\n\t}\n\tremove_hintdevice(hint);\n\t\n\tao2_lock(hint);\n\tast_copy_string(hint->context_name,\n\t\tast_get_context_name(ast_get_extension_context(hint->exten)),\n\t\tsizeof(hint->context_name));\n\tast_copy_string(hint->exten_name, ast_get_extension_name(hint->exten),\n\t\tsizeof(hint->exten_name));\n\thint->exten = NULL;\n\tao2_unlock(hint);\n\tao2_ref(hint, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1893}
{"project": "Asterisk", "target": 0, "func": "struct ast_featuremap_config *ast_get_chan_featuremap_config(struct ast_channel *chan)\n{\n\tRAII_VAR(struct features_config *, cfg, NULL, ao2_cleanup);\n\tif (chan) {\n\t\tcfg = get_feature_ds(chan);\n\t} else {\n\t\tcfg = ao2_global_obj_ref(globals);\n\t}\n\tif (!cfg) {\n\t\treturn NULL;\n\t}\n\tast_assert(cfg->featuremap != NULL);\n\tao2_ref(cfg->featuremap, +1);\n\treturn cfg->featuremap;\n}\n", "bug_type": null, "idx": 1894}
{"project": "Asterisk", "target": 0, "func": "void ast_moh_cleanup(struct ast_channel *chan)\n{\n\tif (ast_moh_cleanup_ptr)\n\t\tast_moh_cleanup_ptr(chan);\n}\n", "bug_type": null, "idx": 1895}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void misdn_Address_fill(struct FacAddress *Address, const struct misdn_party_id *id)\n{\n\tmisdn_PartyNumber_fill(&Address->Party, id);\n\t\n\tAddress->Subaddress.Length = 0;\n}\n", "bug_type": null, "idx": 1896}
{"project": "Asterisk", "target": 0, "func": "static int check_request(struct dundi_request *dr)\n{\n\tstruct dundi_request *cur;\n\tAST_LIST_LOCK(&peers);\n\tAST_LIST_TRAVERSE(&requests, cur, list) {\n\t\tif (cur == dr)\n\t\t\tbreak;\n\t}\n\tAST_LIST_UNLOCK(&peers);\n\treturn cur ? 1 : 0;\n}\n", "bug_type": null, "idx": 1897}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225AdmissionRejectReason (OOCTXT* pctxt, H225AdmissionRejectReason* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   OOCTXT lctxt;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"calledPartyNotRegistered\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"calledPartyNotRegistered\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"invalidPermission\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"invalidPermission\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"requestDenied\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"requestDenied\", -1);\n            break;\n         \n         case 3:\n            invokeStartElement (pctxt, \"undefinedReason\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"undefinedReason\", -1);\n            break;\n         \n         case 4:\n            invokeStartElement (pctxt, \"callerNotRegistered\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"callerNotRegistered\", -1);\n            break;\n         \n         case 5:\n            invokeStartElement (pctxt, \"routeCallToGatekeeper\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"routeCallToGatekeeper\", -1);\n            break;\n         \n         case 6:\n            invokeStartElement (pctxt, \"invalidEndpointIdentifier\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"invalidEndpointIdentifier\", -1);\n            break;\n         \n         case 7:\n            invokeStartElement (pctxt, \"resourceUnavailable\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"resourceUnavailable\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 9;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n      copyContext (&lctxt, pctxt);\n      initContextBuffer (pctxt, openType.data, openType.numocts);\n      switch (pvalue->t) {\n         \n         case 9:\n            invokeStartElement (pctxt, \"securityDenial\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"securityDenial\", -1);\n            break;\n         \n         case 10:\n            invokeStartElement (pctxt, \"qosControlNotSupported\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"qosControlNotSupported\", -1);\n            break;\n         \n         case 11:\n            invokeStartElement (pctxt, \"incompleteAddress\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"incompleteAddress\", -1);\n            break;\n         \n         case 12:\n            invokeStartElement (pctxt, \"aliasesInconsistent\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"aliasesInconsistent\", -1);\n            break;\n         \n         case 13:\n            invokeStartElement (pctxt, \"routeCallToSCN\", -1);\n            pvalue->u.routeCallToSCN = ALLOC_ASN1ELEM (pctxt, H225_SeqOfH225PartyNumber);\n            stat = asn1PD_H225_SeqOfH225PartyNumber (pctxt, pvalue->u.routeCallToSCN);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"routeCallToSCN\", -1);\n            break;\n         \n         case 14:\n            invokeStartElement (pctxt, \"exceedsCallCapacity\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"exceedsCallCapacity\", -1);\n            break;\n         \n         case 15:\n            invokeStartElement (pctxt, \"collectDestination\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"collectDestination\", -1);\n            break;\n         \n         case 16:\n            invokeStartElement (pctxt, \"collectPIN\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"collectPIN\", -1);\n            break;\n         \n         case 17:\n            invokeStartElement (pctxt, \"genericDataReason\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"genericDataReason\", -1);\n            break;\n         \n         case 18:\n            invokeStartElement (pctxt, \"neededFeatureNotSupported\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"neededFeatureNotSupported\", -1);\n            break;\n         \n         case 19:\n            invokeStartElement (pctxt, \"securityErrors\", -1);\n            pvalue->u.securityErrors = ALLOC_ASN1ELEM (pctxt, H225SecurityErrors2);\n            stat = asn1PD_H225SecurityErrors2 (pctxt, pvalue->u.securityErrors);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"securityErrors\", -1);\n            break;\n         \n         case 20:\n            invokeStartElement (pctxt, \"securityDHmismatch\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"securityDHmismatch\", -1);\n            break;\n         \n         case 21:\n            invokeStartElement (pctxt, \"noRouteToDestination\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"noRouteToDestination\", -1);\n            break;\n         \n         case 22:\n            invokeStartElement (pctxt, \"unallocatedNumber\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"unallocatedNumber\", -1);\n            break;\n         default:;\n      }\n      copyContext (pctxt, &lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1898}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_float(struct ast_json *json)\n{\n\treturn check_type(json, AST_JSON_REAL);\n}\n", "bug_type": null, "idx": 1899}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245TransparencyParameters (OOCTXT* pctxt, H245TransparencyParameters* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"presentationOrder\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->presentationOrder, 1U, 256U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->presentationOrder);\n   invokeEndElement (pctxt, \"presentationOrder\", -1);\n   \n   invokeStartElement (pctxt, \"offset_x\", -1);\n   stat = decodeConsInteger (pctxt, &pvalue->offset_x, -262144, 262143);\n   if (stat != ASN_OK) return stat;\n   invokeIntValue (pctxt, pvalue->offset_x);\n   invokeEndElement (pctxt, \"offset_x\", -1);\n   \n   invokeStartElement (pctxt, \"offset_y\", -1);\n   stat = decodeConsInteger (pctxt, &pvalue->offset_y, -262144, 262143);\n   if (stat != ASN_OK) return stat;\n   invokeIntValue (pctxt, pvalue->offset_y);\n   invokeEndElement (pctxt, \"offset_y\", -1);\n   \n   invokeStartElement (pctxt, \"scale_x\", -1);\n   stat = decodeConsUInt8 (pctxt, &pvalue->scale_x, 1U, 255U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->scale_x);\n   invokeEndElement (pctxt, \"scale_x\", -1);\n   \n   invokeStartElement (pctxt, \"scale_y\", -1);\n   stat = decodeConsUInt8 (pctxt, &pvalue->scale_y, 1U, 255U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->scale_y);\n   invokeEndElement (pctxt, \"scale_y\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1900}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_stored_recording(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_format = 0;\n\tint has_name = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"format\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_format = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI StoredRecording field format failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"name\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_name = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI StoredRecording field name failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI StoredRecording has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_format) {\n\t\tast_log(LOG_ERROR, \"ARI StoredRecording missing required field format\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_name) {\n\t\tast_log(LOG_ERROR, \"ARI StoredRecording missing required field name\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1901}
{"project": "Asterisk", "target": 0, "func": "static int extension_matches(pval *here, const char *exten, const char *pattern)\n{\n\tint err1;\n\tregex_t preg;\n\t\n\tif (strcmp(pattern,exten) == 0)\n\t\treturn 1;\n\tif (pattern[0] == '_') {\n\t\tchar reg1[2000];\n\t\tconst char *p;\n\t\tchar *r = reg1;\n\t\tif ( strlen(pattern)*5 >= 2000 )  {\n\t\t\tast_log(LOG_ERROR,\"Error: The pattern %s is way too big. Pattern matching cancelled.\\n\",\n\t\t\t\t\tpattern);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t*r++ = '^'; \n\t\t*r++ = '_'; \n\t\t*r++ = '?';\n\t\tfor (p=pattern+1; *p; p++) {\n\t\t\tswitch ( *p ) {\n\t\t\tcase 'X':\n\t\t\t\t*r++ = '[';\n\t\t\t\t*r++ = '0';\n\t\t\t\t*r++ = '-';\n\t\t\t\t*r++ = '9';\n\t\t\t\t*r++ = 'X';\n\t\t\t\t*r++ = ']';\n\t\t\t\tbreak;\n\t\t\tcase 'Z':\n\t\t\t\t*r++ = '[';\n\t\t\t\t*r++ = '1';\n\t\t\t\t*r++ = '-';\n\t\t\t\t*r++ = '9';\n\t\t\t\t*r++ = 'Z';\n\t\t\t\t*r++ = ']';\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\t*r++ = '[';\n\t\t\t\t*r++ = '2';\n\t\t\t\t*r++ = '-';\n\t\t\t\t*r++ = '9';\n\t\t\t\t*r++ = 'N';\n\t\t\t\t*r++ = ']';\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\twhile ( *p && *p != ']' ) {\n\t\t\t\t\t*r++ = *p++;\n\t\t\t\t}\n\t\t\t\t*r++ = ']';\n\t\t\t\tif ( *p != ']') {\n\t\t\t\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The extension pattern '%s' is missing a closing bracket \\n\",\n\t\t\t\t\t\t\there->filename, here->startline, here->endline, pattern);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\tcase '!':\n\t\t\t\t*r++ = '.';\n\t\t\t\t*r++ = '*';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\t*r++ = '\\\\';\n\t\t\t\t*r++ = '*';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*r++ = *p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*r++ = '$'; \n\t\t*r++ = *p++; \n\t\terr1 = regcomp(&preg, reg1, REG_NOSUB|REG_EXTENDED);\n\t\tif ( err1 ) {\n\t\t\tchar errmess[500];\n\t\t\tregerror(err1,&preg,errmess,sizeof(errmess));\n\t\t\tregfree(&preg);\n\t\t\tast_log(LOG_WARNING, \"Regcomp of %s failed, error code %d\\n\",\n\t\t\t\t\treg1, err1);\n\t\t\treturn 0;\n\t\t}\n\t\terr1 = regexec(&preg, exten, 0, 0, 0);\n\t\tregfree(&preg);\n\t\tif ( err1 ) {\n\t\t\t\n\t\t\treturn 0; \n\t\t} else {\n\t\t\t\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif ( strcmp(exten,pattern) == 0 ) {\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 1902}
{"project": "Asterisk", "target": 0, "func": "void pri_event_noalarm(struct sig_pri_span *pri, int index, int before_start_pri)\n{\n\tpri->dchanavail[index] |= DCHAN_NOTINALARM;\n\tif (!before_start_pri)\n\t\tpri_restart(pri->dchans[index]);\n}\n", "bug_type": null, "idx": 1903}
{"project": "Asterisk", "target": 0, "func": "\nstatic int registrar_add_contact(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_contact *contact = obj;\n\tpjsip_tx_data *tdata = arg;\n\tpjsip_contact_hdr *hdr = pjsip_contact_hdr_create(tdata->pool);\n\tpj_str_t uri;\n\tpj_strdup2_with_null(tdata->pool, &uri, contact->uri);\n\thdr->uri = pjsip_parse_uri(tdata->pool, uri.ptr, uri.slen, PJSIP_PARSE_URI_AS_NAMEADDR);\n\thdr->expires = ast_tvdiff_ms(contact->expiration_time, ast_tvnow()) / 1000;\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hdr);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1904}
{"project": "Asterisk", "target": 0, "func": "    *---------------------------------------------------------------*/\n   void smath(\n       float *odata,   \n       float *sseq,\n       int hl,         \n       float alpha0\n   ){\n       int i,k;\n       float w00,w10,w11,A,B,C,*psseq,err,errs;\n       float surround[BLOCKL_MAX]; \n       float wt[2*ENH_HL+1];       \n       float denom;\n       \n       for (i=1; i<=2*hl+1; i++) {\n           wt[i-1] = (float)0.5*(1 - (float)cos(2*PI*i/(2*hl+2)));\n       }\n       wt[hl]=0.0; \n       for (i=0; i<ENH_BLOCKL; i++) {\n           surround[i]=sseq[i]*wt[0];\n       }\n       for (k=1; k<hl; k++) {\n           psseq=sseq+k*ENH_BLOCKL;\n           for(i=0;i<ENH_BLOCKL; i++) {\n               surround[i]+=psseq[i]*wt[k];\n           }\n       }\n       for (k=hl+1; k<=2*hl; k++) {\n           psseq=sseq+k*ENH_BLOCKL;\n           for(i=0;i<ENH_BLOCKL; i++) {\n               surround[i]+=psseq[i]*wt[k];\n           }\n       }\n       \n       w00 = w10 = w11 = 0.0;\n       psseq=sseq+hl*ENH_BLOCKL; \n       for (i=0; i<ENH_BLOCKL;i++) {\n           w00+=psseq[i]*psseq[i];\n           w11+=surround[i]*surround[i];\n           w10+=surround[i]*psseq[i];\n       }\n       if (fabs(w11) < 1.0) {\n           w11=1.0;\n       }\n       C = (float)sqrt( w00/w11);\n       \n       errs=0.0;\n       psseq=sseq+hl*ENH_BLOCKL;\n       for (i=0; i<ENH_BLOCKL; i++) {\n           odata[i]=C*surround[i];\n           err=psseq[i]-odata[i];\n           errs+=err*err;\n       }\n       \n       if (errs > alpha0 * w00) {\n           if ( w00 < 1) {\n               w00=1;\n           }\n           denom = (w11*w00-w10*w10)/(w00*w00);\n           if (denom > 0.0001) { \n               A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom);\n               B = -alpha0/2 - A * w10/w00;\n               B = B+1;\n           }\n           else { \n               A= 0.0;\n               B= 1.0;\n           }\n           \n           psseq=sseq+hl*ENH_BLOCKL;\n           for (i=0; i<ENH_BLOCKL; i++) {\n               odata[i]=A*surround[i]+B*psseq[i];\n           }\n       }\n   }\n", "bug_type": null, "idx": 1905}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int builtin_feature_get_exten(struct ast_channel *chan, const char *feature_name, char *buf, size_t len)\n{\n\tSCOPED_CHANNELLOCK(lock, chan);\n\treturn ast_get_builtin_feature(chan, feature_name, buf, len);\n}\n", "bug_type": null, "idx": 1906}
{"project": "Asterisk", "target": 0, "func": "static struct ast_json *channel_connected_line(\n\tstruct ast_channel_snapshot *old_snapshot,\n\tstruct ast_channel_snapshot *new_snapshot,\n\tconst struct timeval *tv)\n{\n\tstruct ast_json *json_channel;\n\t\n\tif (!old_snapshot || !new_snapshot) {\n\t\treturn NULL;\n\t}\n\tif (ast_channel_snapshot_connected_line_equal(old_snapshot, new_snapshot)) {\n\t\treturn NULL;\n\t}\n\tjson_channel = ast_channel_snapshot_to_json(new_snapshot, stasis_app_get_sanitizer());\n\tif (!json_channel) {\n\t\treturn NULL;\n\t}\n\treturn ast_json_pack(\"{s: s, s: o, s: o}\",\n\t\t\"type\", \"ChannelConnectedLine\",\n\t\t\"timestamp\", ast_json_timeval(*tv, NULL),\n\t\t\"channel\", json_channel);\n}\n", "bug_type": null, "idx": 1907}
{"project": "Asterisk", "target": 0, "func": "int ooH323EpAddAliasTransportID(const char * ipaddress)\n{\n   ooAliases * psNewAlias=NULL;\n   psNewAlias = (ooAliases*)memAlloc(&gH323ep.ctxt, sizeof(ooAliases));\n   if(!psNewAlias)\n   {\n      OOTRACEERR1(\"Error: Failed to allocate memory for new Transport-ID \"\n                  \"alias\\n\");\n      return OO_FAILED;\n   }\n   psNewAlias->type = T_H225AliasAddress_transportID;\n   psNewAlias->registered = FALSE;\n   psNewAlias->value = (char*) memAlloc(&gH323ep.ctxt, strlen(ipaddress)+1);\n   if(!psNewAlias->value)\n   {\n      OOTRACEERR1(\"Error: Failed to allocate memory for the new Transport-ID \"\n                  \"alias value\\n\");\n      memFreePtr(&gH323ep.ctxt, psNewAlias);\n      return OO_FAILED;\n   }\n   strcpy(psNewAlias->value, ipaddress);\n   psNewAlias->next = gH323ep.aliases;\n   gH323ep.aliases = psNewAlias;\n   OOTRACEDBGA2(\"Added alias: Transport-ID - %s\\n\", ipaddress);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 1908}
{"project": "Asterisk", "target": 0, "func": "\nint plc_fillin(plc_state_t *s, int16_t amp[], int len)\n{\n\tint i;\n\tint pitch_overlap;\n\tfloat old_step;\n\tfloat new_step;\n\tfloat old_weight;\n\tfloat new_weight;\n\tfloat gain;\n\tint orig_len;\n\torig_len = len;\n\tif (s->missing_samples == 0) {\n\t\t\n\t\tnormalise_history(s);\n\t\ts->pitch = amdf_pitch(PLC_PITCH_MIN, PLC_PITCH_MAX, s->history + PLC_HISTORY_LEN - CORRELATION_SPAN - PLC_PITCH_MIN, CORRELATION_SPAN);\n\t\t\n\t\tpitch_overlap = s->pitch >> 2;\n\t\t\n\t\t\n\t\tfor (i = 0;  i < s->pitch - pitch_overlap;  i++)\n\t\t\ts->pitchbuf[i] = s->history[PLC_HISTORY_LEN - s->pitch + i];\n\t\t\n\t\tnew_step = 1.0/pitch_overlap;\n\t\tnew_weight = new_step;\n\t\tfor ( ; i < s->pitch; i++) {\n\t\t\ts->pitchbuf[i] = s->history[PLC_HISTORY_LEN - s->pitch + i] * (1.0 - new_weight) + s->history[PLC_HISTORY_LEN - 2 * s->pitch + i]*new_weight;\n\t\t\tnew_weight += new_step;\n\t\t}\n\t\t\n\t\t\n\t\tgain = 1.0;\n\t\tnew_step = 1.0 / pitch_overlap;\n\t\told_step = new_step;\n\t\tnew_weight = new_step;\n\t\told_weight = 1.0 - new_step;\n\t\tfor (i = 0; i < pitch_overlap; i++) {\n\t\t\tamp[i] = fsaturate(old_weight * s->history[PLC_HISTORY_LEN - 1 - i] + new_weight * s->pitchbuf[i]);\n\t\t\tnew_weight += new_step;\n\t\t\told_weight -= old_step;\n\t\t\tif (old_weight < 0.0)\n\t\t\t\told_weight = 0.0;\n\t\t}\n\t\ts->pitch_offset = i;\n\t} else {\n\t\tgain = 1.0 - s->missing_samples*ATTENUATION_INCREMENT;\n\t\ti = 0;\n\t}\n\tfor ( ; gain > 0.0 && i < len; i++) {\n\t\tamp[i] = s->pitchbuf[s->pitch_offset] * gain;\n\t\tgain -= ATTENUATION_INCREMENT;\n\t\tif (++s->pitch_offset >= s->pitch)\n\t\t\ts->pitch_offset = 0;\n\t}\n\tfor ( ; i < len; i++)\n\t\tamp[i] = 0;\n\ts->missing_samples += orig_len;\n\tsave_history(s, amp, len);\n\treturn len;\n}\n", "bug_type": null, "idx": 1909}
{"project": "Asterisk", "target": 0, "func": "void ast_hashtab_destroylock(struct ast_hashtab *tab)\n{\n\tast_rwlock_destroy(&tab->lock);\n}\n", "bug_type": null, "idx": 1910}
{"project": "Asterisk", "target": 0, "func": "static int rt_extend_conf(const char *confno)\n{\n\tchar currenttime[32];\n\tchar endtime[32];\n\tstruct timeval now;\n\tstruct ast_tm tm;\n\tstruct ast_variable *var, *orig_var;\n\tchar bookid[51];\n\tif (!extendby) {\n\t\treturn 0;\n\t}\n\tnow = ast_tvnow();\n\tast_localtime(&now, &tm, NULL);\n\tast_strftime(currenttime, sizeof(currenttime), DATE_FORMAT, &tm);\n\tvar = ast_load_realtime(\"meetme\", \"confno\",\n\t\tconfno, \"startTime<= \", currenttime,\n\t\t\"endtime>= \", currenttime, NULL);\n\torig_var = var;\n\t\n\twhile (var) {\n\t\tif (!strcasecmp(var->name, \"bookid\")) {\n\t\t\tast_copy_string(bookid, var->value, sizeof(bookid));\n\t\t}\n\t\tif (!strcasecmp(var->name, \"endtime\")) {\n\t\t\tast_copy_string(endtime, var->value, sizeof(endtime));\n\t\t}\n\t\tvar = var->next;\n\t}\n\tast_variables_destroy(orig_var);\n\tast_strptime(endtime, DATE_FORMAT, &tm);\n\tnow = ast_mktime(&tm, NULL);\n\tnow.tv_sec += extendby;\n\tast_localtime(&now, &tm, NULL);\n\tast_strftime(currenttime, sizeof(currenttime), DATE_FORMAT, &tm);\n\tstrcat(currenttime, \"0\"); \n\tvar = ast_load_realtime(\"meetme\", \"confno\",\n\t\tconfno, \"startTime<= \", currenttime,\n\t\t\"endtime>= \", currenttime, NULL);\n\t\n\tif (!var) {\n\t\tast_debug(3, \"Trying to update the endtime of Conference %s to %s\\n\", confno, currenttime);\n\t\tast_update_realtime(\"meetme\", \"bookid\", bookid, \"endtime\", currenttime, NULL);\n\t\treturn 0;\n\t}\n\tast_variables_destroy(var);\n\treturn -1;\n}\n", "bug_type": null, "idx": 1911}
{"project": "Asterisk", "target": 0, "func": "   We assume that this was called while holding conflock. */\nstatic int conf_free(struct ast_conference *conf)\n{\n\tint x;\n\tstruct announce_listitem *item;\n\tAST_LIST_REMOVE(&confs, conf, list);\n\tmeetme_stasis_generate_msg(conf, NULL, NULL, meetme_end_type(), NULL);\n\tif (conf->recording == MEETME_RECORD_ACTIVE) {\n\t\tconf->recording = MEETME_RECORD_TERMINATE;\n\t\tAST_LIST_UNLOCK(&confs);\n\t\twhile (1) {\n\t\t\tusleep(1);\n\t\t\tAST_LIST_LOCK(&confs);\n\t\t\tif (conf->recording == MEETME_RECORD_OFF)\n\t\t\t\tbreak;\n\t\t\tAST_LIST_UNLOCK(&confs);\n\t\t}\n\t}\n\tfor (x = 0; x < AST_FRAME_BITS; x++) {\n\t\tif (conf->transframe[x])\n\t\t\tast_frfree(conf->transframe[x]);\n\t\tif (conf->transpath[x])\n\t\t\tast_translator_free_path(conf->transpath[x]);\n\t}\n\tif (conf->announcethread != AST_PTHREADT_NULL) {\n\t\tast_mutex_lock(&conf->announcelistlock);\n\t\tconf->announcethread_stop = 1;\n\t\tast_softhangup(conf->chan, AST_SOFTHANGUP_EXPLICIT);\n\t\tast_cond_signal(&conf->announcelist_addition);\n\t\tast_mutex_unlock(&conf->announcelistlock);\n\t\tpthread_join(conf->announcethread, NULL);\n\t\twhile ((item = AST_LIST_REMOVE_HEAD(&conf->announcelist, entry))) {\n\t\t\t\n\t\t\tif (!item->vmrec){\n\t\t\t\tast_filedelete(item->namerecloc, NULL);\n\t\t\t}\n\t\t\tao2_ref(item, -1);\n\t\t}\n\t\tast_mutex_destroy(&conf->announcelistlock);\n\t}\n\tif (conf->origframe)\n\t\tast_frfree(conf->origframe);\n\tast_hangup(conf->lchan);\n\tast_hangup(conf->chan);\n\tif (conf->fd >= 0)\n\t\tclose(conf->fd);\n\tif (conf->recordingfilename) {\n\t\tast_free(conf->recordingfilename);\n\t}\n\tif (conf->usercontainer) {\n\t\tao2_ref(conf->usercontainer, -1);\n\t}\n\tif (conf->recordingformat) {\n\t\tast_free(conf->recordingformat);\n\t}\n\tast_mutex_destroy(&conf->playlock);\n\tast_mutex_destroy(&conf->listenlock);\n\tast_mutex_destroy(&conf->recordthreadlock);\n\tast_mutex_destroy(&conf->announcethreadlock);\n\tast_free(conf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1912}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225AdmissionConfirm (OOCTXT* pctxt, H225AdmissionConfirm* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.irrFrequencyPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   \n   invokeStartElement (pctxt, \"requestSeqNum\", -1);\n   stat = asn1PD_H225RequestSeqNum (pctxt, &pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"requestSeqNum\", -1);\n   \n   invokeStartElement (pctxt, \"bandWidth\", -1);\n   stat = asn1PD_H225BandWidth (pctxt, &pvalue->bandWidth);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"bandWidth\", -1);\n   \n   invokeStartElement (pctxt, \"callModel\", -1);\n   stat = asn1PD_H225CallModel (pctxt, &pvalue->callModel);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"callModel\", -1);\n   \n   invokeStartElement (pctxt, \"destCallSignalAddress\", -1);\n   stat = asn1PD_H225TransportAddress (pctxt, &pvalue->destCallSignalAddress);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"destCallSignalAddress\", -1);\n   \n   if (pvalue->m.irrFrequencyPresent) {\n      invokeStartElement (pctxt, \"irrFrequency\", -1);\n      stat = decodeConsUInt16 (pctxt, &pvalue->irrFrequency, 1U, 65535U);\n      if (stat != ASN_OK) return stat;\n      invokeUIntValue (pctxt, pvalue->irrFrequency);\n      invokeEndElement (pctxt, \"irrFrequency\", -1);\n   }\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 22 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.destinationInfoPresent = 1;\n                     invokeStartElement (pctxt, \"destinationInfo\", -1);\n                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destinationInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"destinationInfo\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.destExtraCallInfoPresent = 1;\n                     invokeStartElement (pctxt, \"destExtraCallInfo\", -1);\n                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destExtraCallInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"destExtraCallInfo\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.destinationTypePresent = 1;\n                     invokeStartElement (pctxt, \"destinationType\", -1);\n                     stat = asn1PD_H225EndpointType (pctxt, &pvalue->destinationType);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"destinationType\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.remoteExtensionAddressPresent = 1;\n                     invokeStartElement (pctxt, \"remoteExtensionAddress\", -1);\n                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->remoteExtensionAddress);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"remoteExtensionAddress\", -1);\n                     break;\n                  case 4:\n                     pvalue->m.alternateEndpointsPresent = 1;\n                     invokeStartElement (pctxt, \"alternateEndpoints\", -1);\n                     stat = asn1PD_H225_SeqOfH225Endpoint (pctxt, &pvalue->alternateEndpoints);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"alternateEndpoints\", -1);\n                     break;\n                  case 5:\n                     pvalue->m.tokensPresent = 1;\n                     invokeStartElement (pctxt, \"tokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"tokens\", -1);\n                     break;\n                  case 6:\n                     pvalue->m.cryptoTokensPresent = 1;\n                     invokeStartElement (pctxt, \"cryptoTokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"cryptoTokens\", -1);\n                     break;\n                  case 7:\n                     pvalue->m.integrityCheckValuePresent = 1;\n                     invokeStartElement (pctxt, \"integrityCheckValue\", -1);\n                     stat = asn1PD_H225ICV (pctxt, &pvalue->integrityCheckValue);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"integrityCheckValue\", -1);\n                     break;\n                  case 8:\n                     pvalue->m.transportQOSPresent = 1;\n                     invokeStartElement (pctxt, \"transportQOS\", -1);\n                     stat = asn1PD_H225TransportQOS (pctxt, &pvalue->transportQOS);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"transportQOS\", -1);\n                     break;\n                  case 9:\n                     pvalue->m.willRespondToIRRPresent = 1;\n                     invokeStartElement (pctxt, \"willRespondToIRR\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->willRespondToIRR);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->willRespondToIRR);\n                     invokeEndElement (pctxt, \"willRespondToIRR\", -1);\n                     break;\n                  case 10:\n                     pvalue->m.uuiesRequestedPresent = 1;\n                     invokeStartElement (pctxt, \"uuiesRequested\", -1);\n                     stat = asn1PD_H225UUIEsRequested (pctxt, &pvalue->uuiesRequested);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"uuiesRequested\", -1);\n                     break;\n                  case 11:\n                     pvalue->m.languagePresent = 1;\n                     invokeStartElement (pctxt, \"language\", -1);\n                     stat = asn1PD_H225AdmissionConfirm_language (pctxt, &pvalue->language);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"language\", -1);\n                     break;\n                  case 12:\n                     pvalue->m.alternateTransportAddressesPresent = 1;\n                     invokeStartElement (pctxt, \"alternateTransportAddresses\", -1);\n                     stat = asn1PD_H225AlternateTransportAddresses (pctxt, &pvalue->alternateTransportAddresses);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"alternateTransportAddresses\", -1);\n                     break;\n                  case 13:\n                     pvalue->m.useSpecifiedTransportPresent = 1;\n                     invokeStartElement (pctxt, \"useSpecifiedTransport\", -1);\n                     stat = asn1PD_H225UseSpecifiedTransport (pctxt, &pvalue->useSpecifiedTransport);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"useSpecifiedTransport\", -1);\n                     break;\n                  case 14:\n                     pvalue->m.circuitInfoPresent = 1;\n                     invokeStartElement (pctxt, \"circuitInfo\", -1);\n                     stat = asn1PD_H225CircuitInfo (pctxt, &pvalue->circuitInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"circuitInfo\", -1);\n                     break;\n                  case 15:\n                     pvalue->m.usageSpecPresent = 1;\n                     invokeStartElement (pctxt, \"usageSpec\", -1);\n                     stat = asn1PD_H225_SeqOfH225RasUsageSpecification (pctxt, &pvalue->usageSpec);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"usageSpec\", -1);\n                     break;\n                  case 16:\n                     pvalue->m.supportedProtocolsPresent = 1;\n                     invokeStartElement (pctxt, \"supportedProtocols\", -1);\n                     stat = asn1PD_H225_SeqOfH225SupportedProtocols (pctxt, &pvalue->supportedProtocols);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"supportedProtocols\", -1);\n                     break;\n                  case 17:\n                     pvalue->m.serviceControlPresent = 1;\n                     invokeStartElement (pctxt, \"serviceControl\", -1);\n                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"serviceControl\", -1);\n                     break;\n                  case 18:\n                     pvalue->m.multipleCallsPresent = 1;\n                     invokeStartElement (pctxt, \"multipleCalls\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->multipleCalls);\n                     invokeEndElement (pctxt, \"multipleCalls\", -1);\n                     break;\n                  case 19:\n                     pvalue->m.featureSetPresent = 1;\n                     invokeStartElement (pctxt, \"featureSet\", -1);\n                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"featureSet\", -1);\n                     break;\n                  case 20:\n                     pvalue->m.genericDataPresent = 1;\n                     invokeStartElement (pctxt, \"genericData\", -1);\n                     stat = asn1PD_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"genericData\", -1);\n                     break;\n                  case 21:\n                     pvalue->m.modifiedSrcInfoPresent = 1;\n                     invokeStartElement (pctxt, \"modifiedSrcInfo\", -1);\n                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->modifiedSrcInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"modifiedSrcInfo\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1913}
{"project": "Asterisk", "target": 0, "func": "int load_pbx_builtins(void)\n{\n\tint x;\n\t\n\tfor (x = 0; x < ARRAY_LEN(builtins); x++) {\n\t\tif (ast_register_application2(builtins[x].name, builtins[x].execute, NULL, NULL, NULL)) {\n\t\t\tast_log(LOG_ERROR, \"Unable to register builtin application '%s'\\n\", builtins[x].name);\n\t\t\tunload_pbx_builtins();\n\t\t\treturn -1;\n\t\t}\n\t}\n\tast_register_cleanup(unload_pbx_builtins);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1914}
{"project": "Asterisk", "target": 0, "func": "void *ast_hashtab_next(struct ast_hashtab_iter *it)\n{\n\t\n\tstruct ast_hashtab_bucket *retval;\n\tif (it && it->next) { \n\t\tretval = it->next;\n\t\tit->next = retval->tnext;\n\t\treturn (void *) retval->object;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1915}
{"project": "Asterisk", "target": 0, "func": "void *ast_sorcery_lockable_alloc(size_t size, ao2_destructor_fn destructor, void *lockobj)\n{\n\tvoid *object = ao2_alloc_with_lockobj(size + sizeof(struct ast_sorcery_object),\n\t\tsorcery_object_destructor, lockobj, \"\");\n\tstruct ast_sorcery_object_details *details = object;\n\tif (!object) {\n\t\treturn NULL;\n\t}\n\tdetails->object = object + size;\n\tdetails->object->destructor = destructor;\n\treturn object;\n}\n", "bug_type": null, "idx": 1916}
{"project": "Asterisk", "target": 0, "func": "\nstatic int app_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *parse = NULL;\n\tint ret = -1;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(app_name);\n\t\tAST_APP_ARG(app_argv)[MAX_ARGS];\n\t);\n\tast_assert(chan != NULL);\n\tast_assert(data != NULL);\n\tpbx_builtin_setvar_helper(chan, \"STASISSTATUS\", \"\");\n\t\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc < 1) {\n\t\tast_log(LOG_WARNING, \"Stasis app_name argument missing\\n\");\n\t} else {\n\t\tret = stasis_app_exec(chan,\n\t\t                      args.app_name,\n\t\t                      args.argc - 1,\n\t\t                      args.app_argv);\n\t}\n\tif (ret) {\n\t\t\n\t\tif (!ast_check_hangup(chan)) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tpbx_builtin_setvar_helper(chan, \"STASISSTATUS\", \"FAILED\");\n\t} else {\n\t\tpbx_builtin_setvar_helper(chan, \"STASISSTATUS\", \"SUCCESS\");\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 1917}
{"project": "Asterisk", "target": 0, "func": "void ast_bucket_observer_remove(const struct ast_sorcery_observer *callbacks)\n{\n\tast_sorcery_observer_remove(bucket_sorcery, \"bucket\", callbacks);\n}\n", "bug_type": null, "idx": 1918}
{"project": "Asterisk", "target": 0, "func": " */\nint ooGkClientHandleRASMessage(ooGkClient *pGkClient, H225RasMessage *pRasMsg)\n{\n   int iRet = OO_OK;   \n   switch( pRasMsg->t)\n   {\n   case T_H225RasMessage_gatekeeperConfirm:\n      OOTRACEINFO1(\"Gatekeeper Confirmed (GCF) message received.\\n\");\n      iRet = ooGkClientHandleGatekeeperConfirm(pGkClient, \n                                          pRasMsg->u.gatekeeperConfirm);\n      break;\n   case T_H225RasMessage_gatekeeperReject: \n      OOTRACEINFO1(\"Gatekeeper Reject (GRJ) message received\\n\");\n      iRet = ooGkClientHandleGatekeeperReject(pGkClient, \n                                              pRasMsg->u.gatekeeperReject);\n      break;\n   case T_H225RasMessage_registrationConfirm:   \n      OOTRACEINFO1(\"Registration Confirm (RCF) message received\\n\");\n      iRet = ooGkClientHandleRegistrationConfirm(pGkClient,  \n                                              pRasMsg->u.registrationConfirm );\n      break;\n   case T_H225RasMessage_registrationReject:\n      OOTRACEINFO1(\"Registration Reject (RRJ) message received.\\n\");\n      iRet = ooGkClientHandleRegistrationReject(pGkClient, \n                                                pRasMsg->u.registrationReject);\n      break;\n   case T_H225RasMessage_infoRequest:  \n       \n      break;\n   case T_H225RasMessage_admissionConfirm:\n      OOTRACEINFO1(\"Admission Confirm (ACF) message received\\n\");\n      iRet = ooGkClientHandleAdmissionConfirm(pGkClient, \n                                              pRasMsg->u.admissionConfirm);\n      break;\n   case T_H225RasMessage_unregistrationRequest:\n      OOTRACEINFO1(\"UnRegistration Request (URQ) message received.\\n\");\n      iRet = ooGkClientHandleUnregistrationRequest(pGkClient, \n                                            pRasMsg->u.unregistrationRequest);\n      break;\n   case T_H225RasMessage_unregistrationConfirm:\n      OOTRACEINFO1(\"UnRegistration Confirm (UCF) message received.\\n\");\n      break;\n   case T_H225RasMessage_unregistrationReject:\n      OOTRACEINFO1(\"UnRegistration Reject (URJ) message received.\\n\");\n      break;\n   case T_H225RasMessage_admissionReject:\n      OOTRACEINFO1(\"Admission Reject (ARJ) message received.\\n\");\n      iRet = ooGkClientHandleAdmissionReject(pGkClient, \n                                                   pRasMsg->u.admissionReject);\n      break;\n   case T_H225RasMessage_disengageConfirm:\n      iRet = ooGkClientHandleDisengageConfirm(pGkClient, \n                                              pRasMsg->u.disengageConfirm);\n      break;\n   case T_H225RasMessage_disengageReject:\n   case T_H225RasMessage_bandwidthConfirm:\n   case T_H225RasMessage_bandwidthReject:\n   case T_H225RasMessage_locationRequest:\n   case T_H225RasMessage_locationConfirm:\n   case T_H225RasMessage_locationReject:\n   case T_H225RasMessage_infoRequestResponse:\n   case T_H225RasMessage_nonStandardMessage:\n   case T_H225RasMessage_unknownMessageResponse:\n   case T_H225RasMessage_requestInProgress:\n   case T_H225RasMessage_resourcesAvailableIndicate:\n   case T_H225RasMessage_resourcesAvailableConfirm:\n   case T_H225RasMessage_infoRequestAck:\n   case T_H225RasMessage_infoRequestNak:\n   case T_H225RasMessage_serviceControlIndication:\n   case T_H225RasMessage_serviceControlResponse:\n   case T_H225RasMessage_admissionConfirmSequence:\n   default:\n      \n      iRet= OO_OK;\n   }\n   return iRet;\n}\n", "bug_type": null, "idx": 1919}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int test_new_subscribe(struct ast_sip_endpoint *endpoint, const char *resource)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_LEN(bad_resources); ++i) {\n\t\tif (!strcmp(resource, bad_resources[i])) {\n\t\t\treturn 400;\n\t\t}\n\t}\n\treturn 200;\n}\n", "bug_type": null, "idx": 1920}
{"project": "Asterisk", "target": 0, "func": "int ast_xml_doc_dump_file(FILE *output, struct ast_xml_doc *doc)\n{\n\treturn xmlDocDump(output, (xmlDocPtr)doc);\n}\n", "bug_type": null, "idx": 1921}
{"project": "Asterisk", "target": 0, "func": "static int get_message_count(void *obj, void *arg, int flags)\n{\n\tstruct stasis_message *msg;\n\tstruct mwi_stasis_subscription *mwi_stasis = obj;\n\tstruct ast_sip_message_accumulator *counter = arg;\n\tstruct ast_mwi_state *mwi_state;\n\tmsg = stasis_cache_get(ast_mwi_state_cache(), ast_mwi_state_type(), mwi_stasis->mailbox);\n\tif (!msg) {\n\t\treturn 0;\n\t}\n\tmwi_state = stasis_message_data(msg);\n\tcounter->old_msgs += mwi_state->old_msgs;\n\tcounter->new_msgs += mwi_state->new_msgs;\n\tao2_ref(msg, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1922}
{"project": "Asterisk", "target": 0, "func": "\nvi_add(EditLine *el, int c)\n{\n\tint ret;\n\tel->el_map.current = el->el_map.key;\n\tif (el->el_line.cursor < el->el_line.lastchar) {\n\t\tel->el_line.cursor++;\n\t\tif (el->el_line.cursor > el->el_line.lastchar)\n\t\t\tel->el_line.cursor = el->el_line.lastchar;\n\t\tret = CC_CURSOR;\n\t} else\n\t\tret = CC_NORM;\n\tel->el_chared.c_vcmd.ins = el->el_line.cursor;\n\tel->el_chared.c_undo.ptr = el->el_line.cursor;\n\tel->el_chared.c_undo.action = DELETE;\n\treturn (ret);\n}\n", "bug_type": null, "idx": 1923}
{"project": "Asterisk", "target": 0, "func": "void ast_free_ptr(void *ptr)\n{\n\tast_free(ptr);\n}\n", "bug_type": null, "idx": 1924}
{"project": "Asterisk", "target": 0, "func": "struct stasis_topic *ast_device_state_topic_all(void)\n{\n\treturn device_state_topic_all;\n}\n", "bug_type": null, "idx": 1925}
{"project": "Asterisk", "target": 0, "func": "static int vp8_clone(const struct ast_format *src, struct ast_format *dst)\n{\n\tstruct vp8_attr *original = ast_format_get_attribute_data(src);\n\tstruct vp8_attr *attr = ast_malloc(sizeof(*attr));\n\tif (!attr) {\n\t\treturn -1;\n\t}\n\tif (original) {\n\t\t*attr = *original;\n\t} else {\n\t\t*attr = default_vp8_attr;\n\t}\n\tast_format_set_attribute_data(dst, attr);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1926}
{"project": "Asterisk", "target": 0, "func": "const char *ast_sip_get_contact_short_status_label(const enum ast_sip_contact_status_type status)\n{\n\treturn short_status_map[status];\n}\n", "bug_type": null, "idx": 1927}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_register(&math_function);\n\tres |= ast_custom_function_register(&increment_function);\n\tres |= ast_custom_function_register(&decrement_function);\n\tAST_TEST_REGISTER(test_MATH_function);\n\treturn res;\n}\n", "bug_type": null, "idx": 1928}
{"project": "Asterisk", "target": 0, "func": "char *pvalWordGetString( pval *p )\n{\n\tif (!pvalCheckType(p, \"pvalWordGetString\", PV_WORD))\n\t\treturn 0;\n\treturn p->u1.str;\n}\n", "bug_type": null, "idx": 1929}
{"project": "Asterisk", "target": 0, "func": "#define ast_toggle_flag(it,flag) if(ast_test_flag(it, flag)) ast_clear_flag(it, flag); else ast_set_flag(it, flag)\nstatic int play_and_wait(struct ast_channel *chan, char *file, char *digits)\n{\n\tint res = -1;\n\tif (!ast_streamfile(chan, file, ast_channel_language(chan))) {\n\t\tres = ast_waitstream(chan, digits);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 1930}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(aoc_encode_decode_test);\n\tAST_TEST_UNREGISTER(aoc_event_generation_test);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1931}
{"project": "Asterisk", "target": 0, "func": "static struct ast_manager_event_blob *queue_member_added_to_ami(struct stasis_message *message)\n{\n\treturn queue_member_to_ami(\"QueueMemberAdded\", message);\n}\n", "bug_type": null, "idx": 1932}
{"project": "Asterisk", "target": 0, "func": "static struct ast_sip_pubsub_body_generator *find_body_generator(char accept[AST_SIP_MAX_ACCEPT][64],\n\t\tsize_t num_accept, const char *body_type)\n{\n\tint i;\n\tstruct ast_sip_pubsub_body_generator *generator = NULL;\n\tfor (i = 0; i < num_accept; ++i) {\n\t\tgenerator = find_body_generator_accept(accept[i]);\n\t\tif (generator) {\n\t\t\tast_debug(3, \"Body generator %p found for accept type %s\\n\", generator, accept[i]);\n\t\t\tif (strcmp(generator->body_type, body_type)) {\n\t\t\t\tast_log(LOG_WARNING, \"Body generator '%s/%s'(%p) does not accept the type of data this event generates\\n\",\n\t\t\t\t\t\tgenerator->type, generator->subtype, generator);\n\t\t\t\tgenerator = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tast_debug(3, \"No body generator found for accept type %s\\n\", accept[i]);\n\t\t}\n\t}\n\treturn generator;\n}\n", "bug_type": null, "idx": 1933}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(test_features_channel_interval)\n{\n\tRAII_VAR(struct ast_channel *, chan_alice, NULL, safe_channel_release);\n\tRAII_VAR(struct ast_channel *, chan_bob, NULL, safe_channel_release);\n\tRAII_VAR(struct ast_bridge *, bridge1, NULL, safe_bridge_destroy);\n\tRAII_VAR(struct ast_bridge *, bridge2, NULL, safe_bridge_destroy);\n\tstruct ast_bridge_features features;\n\tint callback_executed = 0;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = __func__;\n\t\tinfo->category = TEST_CATEGORY;\n\t\tinfo->summary = \"Test running interval hooks on a channel via the feature hooks mechanism\";\n\t\tinfo->description =\n\t\t\t\"This test creates two channels, adds an interval hook to one, places them\\n\"\n\t\t\t\"into a bridge, and verifies that the interval hook added to the channel\\n\"\n\t\t\t\"feature hooks is triggered once the channel is bridged.\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\t\n\tbridge1 = ast_bridge_basic_new();\n\tast_test_validate(test, bridge1 != NULL);\n\tbridge2 = ast_bridge_basic_new();\n\tast_test_validate(test, bridge2 != NULL);\n\t\n\tSTART_ALICE(chan_alice);\n\tSTART_BOB(chan_bob);\n\t\n\tast_bridge_features_init(&features);\n\tast_test_validate(test, !ast_bridge_interval_hook(&features, 0, 1000, feature_callback, &callback_executed, NULL, 0));\n\tast_test_validate(test, !ast_channel_feature_hooks_append(chan_alice, &features));\n\tast_bridge_features_cleanup(&features);\n\t\n\tast_test_validate(test, !ast_bridge_impart(bridge1, chan_alice, NULL, NULL, AST_BRIDGE_IMPART_CHAN_DEPARTABLE));\n\tast_test_validate(test, !ast_bridge_impart(bridge1, chan_bob, NULL, NULL, AST_BRIDGE_IMPART_CHAN_DEPARTABLE));\n\twait_for_bridged(chan_alice);\n\t\n\ttest_nanosleep(1, 500000000);\n\t\n\tast_test_validate(test, !ast_bridge_depart(chan_alice));\n\tast_test_validate(test, !ast_bridge_depart(chan_bob));\n\twait_for_unbridged(chan_alice);\n\tast_test_validate(test, callback_executed >= 1);\n\tcallback_executed = 0;\n\t\n\tast_test_validate(test, !ast_bridge_impart(bridge2, chan_alice, NULL, NULL, AST_BRIDGE_IMPART_CHAN_DEPARTABLE));\n\tast_test_validate(test, !ast_bridge_impart(bridge2, chan_bob, NULL, NULL, AST_BRIDGE_IMPART_CHAN_DEPARTABLE));\n\twait_for_bridged(chan_alice);\n\t\n\ttest_nanosleep(1, 500000000);\n\t\n\tast_test_validate(test, !ast_bridge_depart(chan_alice));\n\tast_test_validate(test, !ast_bridge_depart(chan_bob));\n\t\n\tHANGUP_CHANNEL(chan_alice);\n\tHANGUP_CHANNEL(chan_bob);\n\tast_test_validate(test, callback_executed >= 1);\n\treturn AST_TEST_PASS;\n}\n", "bug_type": null, "idx": 1934}
{"project": "Asterisk", "target": 0, "func": "\t\tchar *data, const char *value);\nstatic struct ast_custom_function msg_data_function = {\n\t.name = \"MESSAGE_DATA\",\n\t.read = msg_data_func_read,\n\t.write = msg_data_func_write,\n};\n", "bug_type": null, "idx": 1935}
{"project": "Asterisk", "target": 0, "func": "static int deactivate_silence_generator(struct ast_channel *chan)\n{\n\tast_channel_lock(chan);\n\tif (!ast_channel_generatordata(chan)) {\n\t\tast_debug(1, \"Trying to stop silence generator when there is no generator on '%s'\\n\",\n\t\t\tast_channel_name(chan));\n\t\tast_channel_unlock(chan);\n\t\treturn 0;\n\t}\n\tif (ast_channel_generator(chan) != &silence_generator) {\n\t\tast_debug(1, \"Trying to stop silence generator when it is not the current generator on '%s'\\n\",\n\t\t\tast_channel_name(chan));\n\t\tast_channel_unlock(chan);\n\t\treturn 0;\n\t}\n\tdeactivate_generator_nolock(chan);\n\tast_channel_unlock(chan);\n\treturn 1;\n}\n", "bug_type": null, "idx": 1936}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MasterSlaveDetermination (OOCTXT* pctxt, H245MasterSlaveDetermination* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->terminalType, 0U, 255U);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->statusDeterminationNumber, 0U, 16777215U);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1937}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245Q2931Address_address (OOCTXT* pctxt, H245Q2931Address_address* pvalue)\n{\n   static Asn1SizeCnst internationalNumber_lsize1 = { 0, 1, 16, 0 };\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"internationalNumber\", -1);\n            addSizeConstraint (pctxt, &internationalNumber_lsize1);\n            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.internationalNumber, NUM_CANSET, 4, 4, 4);\n            if (stat != ASN_OK) return stat;\n            invokeCharStrValue (pctxt, pvalue->u.internationalNumber);\n            invokeEndElement (pctxt, \"internationalNumber\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"nsapAddress\", -1);\n            pvalue->u.nsapAddress = ALLOC_ASN1ELEM (pctxt, H245Q2931Address_address_nsapAddress);\n            stat = asn1PD_H245Q2931Address_address_nsapAddress (pctxt, pvalue->u.nsapAddress);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"nsapAddress\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 3;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1938}
{"project": "Asterisk", "target": 0, "func": "\nstatic void context_table_create_autohints(struct ast_hashtab *table)\n{\n\tstruct ast_context *con;\n\tstruct ast_hashtab_iter *iter;\n\t\n\tao2_callback(autohints, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);\n\titer = ast_hashtab_start_traversal(table);\n\twhile ((con = ast_hashtab_next(iter))) {\n\t\tsize_t name_len = strlen(con->name) + 1;\n\t\tsize_t registrar_len = strlen(con->registrar) + 1;\n\t\tstruct ast_autohint *autohint;\n\t\tif (!con->autohints) {\n\t\t\tcontinue;\n\t\t}\n\t\tautohint = ao2_alloc_options(sizeof(*autohint) + name_len + registrar_len, NULL, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\t\tif (!autohint) {\n\t\t\tcontinue;\n\t\t}\n\t\tast_copy_string(autohint->context, con->name, name_len);\n\t\tautohint->registrar = autohint->context + name_len;\n\t\tast_copy_string(autohint->registrar, con->registrar, registrar_len);\n\t\tao2_link(autohints, autohint);\n\t\tao2_ref(autohint, -1);\n\t\tast_verb(3, \"Enabled autohints support on context '%s'\\n\", con->name);\n\t}\n\tast_hashtab_end_traversal(iter);\n}\n", "bug_type": null, "idx": 1939}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *read_frame(struct ast_filestream *s, int *whennext)\n{\n\tstruct ast_frame *fr, *new_fr;\n\tif (!s || !s->fmt) {\n\t\treturn NULL;\n\t}\n\tif (!(fr = s->fmt->read(s, whennext))) {\n\t\treturn NULL;\n\t}\n\tif (!(new_fr = ast_frisolate(fr))) {\n\t\tast_frfree(fr);\n\t\treturn NULL;\n\t}\n\tif (new_fr != fr) {\n\t\tast_frfree(fr);\n\t\tfr = new_fr;\n\t}\n\treturn fr;\n}\n", "bug_type": null, "idx": 1940}
{"project": "Asterisk", "target": 0, "func": "extern EXTERN const char* gs_H323_MESSAGES_GSM_UIM_vplmn_CharSet;\nEXTERN int asn1PD_H225GSM_UIM (OOCTXT* pctxt, H225GSM_UIM* pvalue)\n{\n   static Asn1SizeCnst imsi_lsize1 = { 0, 3, 16, 0 };\n   static Asn1SizeCnst msisdn_lsize1 = { 0, 3, 16, 0 };\n   static Asn1SizeCnst imei_lsize1 = { 0, 15, 16, 0 };\n   static Asn1SizeCnst hplmn_lsize1 = { 0, 1, 4, 0 };\n   static Asn1SizeCnst vplmn_lsize1 = { 0, 1, 4, 0 };\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.imsiPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.tmsiPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.msisdnPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.imeiPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.hplmnPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.vplmnPresent = optbit;\n   \n   if (pvalue->m.imsiPresent) {\n      invokeStartElement (pctxt, \"imsi\", -1);\n      addSizeConstraint (pctxt, &imsi_lsize1);\n      stat = decodeConstrainedStringEx (pctxt, &pvalue->imsi, gs_H323_MESSAGES_GSM_UIM_imsi_CharSet, 4, 4, 7);\n      if (stat != ASN_OK) return stat;\n      invokeCharStrValue (pctxt, pvalue->imsi);\n      invokeEndElement (pctxt, \"imsi\", -1);\n   }\n   \n   if (pvalue->m.tmsiPresent) {\n      invokeStartElement (pctxt, \"tmsi\", -1);\n      stat = asn1PD_H225GSM_UIM_tmsi (pctxt, &pvalue->tmsi);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"tmsi\", -1);\n   }\n   \n   if (pvalue->m.msisdnPresent) {\n      invokeStartElement (pctxt, \"msisdn\", -1);\n      addSizeConstraint (pctxt, &msisdn_lsize1);\n      stat = decodeConstrainedStringEx (pctxt, &pvalue->msisdn, gs_H323_MESSAGES_GSM_UIM_msisdn_CharSet, 4, 4, 7);\n      if (stat != ASN_OK) return stat;\n      invokeCharStrValue (pctxt, pvalue->msisdn);\n      invokeEndElement (pctxt, \"msisdn\", -1);\n   }\n   \n   if (pvalue->m.imeiPresent) {\n      invokeStartElement (pctxt, \"imei\", -1);\n      addSizeConstraint (pctxt, &imei_lsize1);\n      stat = decodeConstrainedStringEx (pctxt, &pvalue->imei, gs_H323_MESSAGES_GSM_UIM_imei_CharSet, 4, 4, 7);\n      if (stat != ASN_OK) return stat;\n      invokeCharStrValue (pctxt, pvalue->imei);\n      invokeEndElement (pctxt, \"imei\", -1);\n   }\n   \n   if (pvalue->m.hplmnPresent) {\n      invokeStartElement (pctxt, \"hplmn\", -1);\n      addSizeConstraint (pctxt, &hplmn_lsize1);\n      stat = decodeConstrainedStringEx (pctxt, &pvalue->hplmn, gs_H323_MESSAGES_GSM_UIM_hplmn_CharSet, 4, 4, 7);\n      if (stat != ASN_OK) return stat;\n      invokeCharStrValue (pctxt, pvalue->hplmn);\n      invokeEndElement (pctxt, \"hplmn\", -1);\n   }\n   \n   if (pvalue->m.vplmnPresent) {\n      invokeStartElement (pctxt, \"vplmn\", -1);\n      addSizeConstraint (pctxt, &vplmn_lsize1);\n      stat = decodeConstrainedStringEx (pctxt, &pvalue->vplmn, gs_H323_MESSAGES_GSM_UIM_vplmn_CharSet, 4, 4, 7);\n      if (stat != ASN_OK) return stat;\n      invokeCharStrValue (pctxt, pvalue->vplmn);\n      invokeEndElement (pctxt, \"vplmn\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1941}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_has_audio_frame_or_monitor(struct ast_channel *chan)\n{\n\treturn ast_channel_monitor(chan)\n\t\t|| !ast_audiohook_write_list_empty(ast_channel_audiohooks(chan))\n\t\t|| !ast_framehook_list_contains_no_active(ast_channel_framehooks(chan));\n}\n", "bug_type": null, "idx": 1942}
{"project": "Asterisk", "target": 0, "func": "static void end_bridge_callback(void *data)\n{\n\tstruct queue_end_bridge *qeb = data;\n\tstruct call_queue *q = qeb->q;\n\tstruct ast_channel *chan = qeb->chan;\n\tif (ao2_ref(qeb, -1) == 1) {\n\t\tset_queue_variables(q, chan);\n\t\t\n\t\tqueue_t_unref(q, \"Expire bridge_config reference\");\n\t}\n}\n", "bug_type": null, "idx": 1943}
{"project": "Asterisk", "target": 0, "func": "struct stasis_app_stored_recording *stasis_app_stored_recording_find_by_name(\n\tconst char *name)\n{\n\tRAII_VAR(struct stasis_app_stored_recording *, recording, NULL,\n\t\tao2_cleanup);\n\tRAII_VAR(char *, dir, NULL, ast_free);\n\tRAII_VAR(char *, file, NULL, ast_free);\n\tRAII_VAR(char *, file_with_ext, NULL, ast_free);\n\tint res;\n\tstruct stat file_stat;\n\terrno = 0;\n\tif (!name) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\trecording = recording_alloc();\n\tif (!recording) {\n\t\treturn NULL;\n\t}\n\tres = split_path(name, &dir, &file);\n\tif (res != 0) {\n\t\treturn NULL;\n\t}\n\tast_string_field_build(recording, file, \"%s/%s\", dir, file);\n\tif (!ast_begins_with(dir, ast_config_AST_RECORDING_DIR)) {\n\t\t\n\t\tast_log(LOG_WARNING, \"Attempt to access invalid recording %s\\n\",\n\t\t\tname);\n\t\terrno = EACCES;\n\t\treturn NULL;\n\t}\n\t\n\tast_string_field_set(recording, name,\n\t\trecording->file + strlen(ast_config_AST_RECORDING_DIR) + 1);\n\tfile_with_ext = find_recording(dir, file);\n\tif (!file_with_ext) {\n\t\treturn NULL;\n\t}\n\tast_string_field_set(recording, file_with_ext, file_with_ext);\n\trecording->format = strrchr(recording->file_with_ext, '.');\n\tif (!recording->format) {\n\t\treturn NULL;\n\t}\n\t++(recording->format);\n\tres = stat(file_with_ext, &file_stat);\n\tif (res != 0) {\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(file_stat.st_mode)) {\n\t\t\n\t\terrno = EACCES;\n\t\treturn NULL;\n\t}\n\tao2_ref(recording, +1);\n\treturn recording;\n}\n", "bug_type": null, "idx": 1944}
{"project": "Asterisk", "target": 0, "func": "\nvoid write_buf(int desc, char* buf, int size)\n{\n\tint ret;\n\t\n\tif(be!=bs)\n\t{\n\t\tif(be>bs)\n\t\t{\n\t\t\tret=write_amap(desc,bs,be-bs);\n\t\t\tbs+=ret;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret=write_amap(desc,bs,end-bs);\n\t\t\tif(ret==end-bs)\n\t\t\t{\n\t\t\t\tret=write_amap(desc,winbuf,be-winbuf);\n\t\t\t\tbs=winbuf+ret;\n\t\t\t}\n\t\t\telse bs+=ret;\n\t\t}\n\t}\n\tif(be==bs)\n\t{\n\t\tret=write_amap(desc,buf,size);\n\t\tbuf+=ret;\n\t\tsize-=ret;\n\t}\n\tif(size)\n\t{\n\t\tif(be>=bs)\n\t\t{\n\t\t\tif(size>end-be)\n\t\t\t{\n\t\t\t\tsize-=end-be;\n\t\t\t\tmemcpy(be,buf,end-be);\n\t\t\t\tbe=winbuf;\n\t\t\t\tbuf+=end-be;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(be,buf,size);\n\t\t\t\tbe+=size;\n\t\t\t\tif(be>=end)\n\t\t\t\t\tbe=winbuf;\n\t\t\t\tsize=0;\n\t\t\t}\n\t\t}\n\t\tif(size)\n\t\t{\n\t\t\tif(size>=bs-be)\n\t\t\t{\n\t\t\t\tfprintf(stderr,\"Buffer overflow!\\n\");\n\t\t\t\tsize=bs-be-1;\n\t\t\t}\n\t\t\tif(size)\n\t\t\t{\n\t\t\t\tmemcpy(be,buf,size);\n\t\t\t\tbe+=size;\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1945}
{"project": "Asterisk", "target": 0, "func": "static void aoc_create_ie_data(struct ast_aoc_decoded *decoded, struct aoc_ie_data *ied)\n{\n\tied->pos = 0;\n\tif (decoded->currency_amount) {\n\t\tstruct aoc_ie_currency ie = {\n\t\t\t.amount = htonl(decoded->currency_amount),\n\t\t\t.multiplier = decoded->multiplier, \n\t\t\t.name = { 0, },\n\t\t};\n\t\tif (!ast_strlen_zero(decoded->currency_name)) {\n\t\t\tast_copy_string(ie.name, decoded->currency_name, sizeof(ie.name));\n\t\t}\n\t\taoc_append_ie(ied, AOC_IE_CURRENCY, (const void *) &ie, sizeof(ie));\n\t}\n\tif (decoded->unit_count) {\n\t\tstruct aoc_ie_unit ie = { 0 };\n\t\tint i;\n\t\tfor (i = 0; i < decoded->unit_count; i++) {\n\t\t\tie.valid_amount = decoded->unit_list[i].valid_amount; \n\t\t\tie.amount = htonl(decoded->unit_list[i].amount);\n\t\t\tie.valid_type = decoded->unit_list[i].valid_type; \n\t\t\tie.type = decoded->unit_list[i].type; \n\t\t\taoc_append_ie(ied, AOC_IE_UNIT, (const void *) &ie, sizeof(ie));\n\t\t}\n\t}\n\tif (decoded->billing_id) {\n\t\tstruct aoc_ie_billing ie;\n\t\tie.id = decoded->billing_id; \n\t\taoc_append_ie(ied, AOC_IE_BILLING, (const void *) &ie, sizeof(ie));\n\t}\n\tif (decoded->charging_association.charging_type != AST_AOC_CHARGING_ASSOCIATION_NA) {\n\t\tstruct aoc_ie_charging_association ie;\n\t\tmemset(&ie, 0, sizeof(ie));\n\t\tie.ca.charging_type = decoded->charging_association.charging_type;   \n\t\tif (decoded->charging_association.charging_type == AST_AOC_CHARGING_ASSOCIATION_NUMBER) {\n\t\t\tie.ca.charge.number.plan = decoded->charging_association.charge.number.plan; \n\t\t\tast_copy_string(ie.ca.charge.number.number,\n\t\t\t\tdecoded->charging_association.charge.number.number,\n\t\t\t\tsizeof(ie.ca.charge.number.number));\n\t\t} else if (decoded->charging_association.charging_type == AST_AOC_CHARGING_ASSOCIATION_ID) {\n\t\t\tie.ca.charge.id = htonl(decoded->charging_association.charge.id);\n\t\t}\n\t\taoc_append_ie(ied, AOC_IE_CHARGING_ASSOCIATION, (const void *) &ie, sizeof(ie));\n\t}\n\tif (decoded->aoc_s_count) {\n\t\tstruct aoc_ie_charging_rate ie;\n\t\tint i;\n\t\tfor (i = 0; i < decoded->aoc_s_count; i++) {\n\t\t\tmemset(&ie, 0, sizeof(ie));\n\t\t\taoc_create_ie_data_charging_rate(&decoded->aoc_s_entries[i], &ie);\n\t\t\taoc_append_ie(ied, AOC_IE_RATE, (const void *) &ie, sizeof(ie));\n\t\t}\n\t}\n\tif (decoded->termination_request) {\n\t\taoc_append_ie(ied, AOC_IE_TERMINATION_REQUEST, NULL, 0);\n\t}\n}\n", "bug_type": null, "idx": 1946}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_get_cc_max_agents(struct ast_cc_config_params *config)\n{\n\treturn config->cc_max_agents;\n}\n", "bug_type": null, "idx": 1947}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int connectedline_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tstruct ast_party_connected_line connected;\n\tchar *val;\n\tchar *parms;\n\tvoid (*set_it)(struct ast_channel *chan, const struct ast_party_connected_line *connected, const struct ast_set_party_connected_line *update);\n\tstruct ast_party_func_args args;\n\tstruct ast_party_members member;\n\tstruct ast_flags opts;\n\tchar *opt_args[CONNECTED_LINE_OPT_ARG_ARRAY_SIZE];\n\tenum ID_FIELD_STATUS status;\n\tif (!value || !chan) {\n\t\treturn -1;\n\t}\n\tparms = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parms);\n\tif (args.argc == 0) {\n\t\t\n\t\treturn -1;\n\t}\n\tAST_NONSTANDARD_APP_ARGS(member, args.member, '-');\n\tif (member.argc == 0 || ARRAY_LEN(member.subnames) <= member.argc) {\n\t\t\n\t\treturn -1;\n\t}\n\tif (ast_app_parse_options(connectedline_opts, &opts, opt_args, args.opts)) {\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tif (ast_test_flag(&opts, CONNECTED_LINE_OPT_INHIBIT)) {\n\t\tset_it = ast_channel_set_connected_line;\n\t} else {\n\t\tset_it = ast_channel_update_connected_line;\n\t}\n\tast_channel_lock(chan);\n\tast_party_connected_line_set_init(&connected, ast_channel_connected(chan));\n\tast_channel_unlock(chan);\n\tvalue = ast_skip_blanks(value);\n\tif (member.argc == 1 && !strcasecmp(\"source\", member.argv[0])) {\n\t\tint source;\n\t\tval = ast_strdupa(value);\n\t\tast_trim_blanks(val);\n\t\tif (('0' <= val[0]) && (val[0] <= '9')) {\n\t\t\tsource = atoi(val);\n\t\t} else {\n\t\t\tsource = ast_connected_line_source_parse(val);\n\t\t}\n\t\tif (source < 0) {\n\t\t\tast_log(LOG_ERROR, \"Unknown connectedline source '%s', value unchanged\\n\", val);\n\t\t} else {\n\t\t\tconnected.source = source;\n\t\t\tset_it(chan, &connected, NULL);\n\t\t}\n\t} else if (!strcasecmp(\"priv\", member.argv[0])) {\n\t\tstatus = party_id_write(&connected.priv, member.argc - 1, member.argv + 1, value);\n\t\tswitch (status) {\n\t\tcase ID_FIELD_VALID:\n\t\t\tset_it(chan, &connected, NULL);\n\t\t\tbreak;\n\t\tcase ID_FIELD_INVALID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_ERROR, \"Unknown connectedline data type '%s'.\\n\", data);\n\t\t\tbreak;\n\t\t}\n\t\tast_party_connected_line_free(&connected);\n\t} else {\n\t\tstatus = party_id_write(&connected.id, member.argc, member.argv, value);\n\t\tswitch (status) {\n\t\tcase ID_FIELD_VALID:\n\t\t\tset_it(chan, &connected, NULL);\n\t\t\tbreak;\n\t\tcase ID_FIELD_INVALID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_log(LOG_ERROR, \"Unknown connectedline data type '%s'.\\n\", data);\n\t\t\tbreak;\n\t\t}\n\t\tast_party_connected_line_free(&connected);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1948}
{"project": "Asterisk", "target": 0, "func": "};\nstruct ast_bridge_features *ast_channel_feature_hooks_get(struct ast_channel *chan)\n{\n\tstruct ast_datastore *datastore;\n\tdatastore = ast_channel_datastore_find(chan, &bridge_features_info, NULL);\n\tif (!datastore) {\n\t\treturn NULL;\n\t}\n\treturn datastore->data;\n}\n", "bug_type": null, "idx": 1949}
{"project": "Asterisk", "target": 0, "func": "ari_validator ast_ari_validate_stasis_end_fn(void)\n{\n\treturn ast_ari_validate_stasis_end;\n}\n", "bug_type": null, "idx": 1950}
{"project": "Asterisk", "target": 0, "func": "const char *ast_get_extension_label(struct ast_exten *exten)\n{\n\treturn exten ? exten->label : NULL;\n}\n", "bug_type": null, "idx": 1951}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_internal_swap_stream_topology(struct ast_channel *chan1,\n\tstruct ast_channel *chan2)\n{\n\tstruct ast_stream_topology *tmp_topology;\n\tast_assert(chan1 != NULL && chan2 != NULL);\n\ttmp_topology = chan1->stream_topology;\n\tchan1->stream_topology = chan2->stream_topology;\n\tchan2->stream_topology = tmp_topology;\n\tchannel_set_default_streams(chan1);\n\tchannel_set_default_streams(chan2);\n}\n", "bug_type": null, "idx": 1952}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *handle_astobj2_stats(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"astobj2 show stats\";\n\t\te->usage = \"Usage: astobj2 show stats\\n\"\n\t\t\t   \"       Show astobj2 show stats\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tast_cli(a->fd, \"Objects    : %d\\n\", ao2.total_objects);\n\tast_cli(a->fd, \"Containers : %d\\n\", ao2.total_containers);\n\tast_cli(a->fd, \"Memory     : %d\\n\", ao2.total_mem);\n\tast_cli(a->fd, \"Locked     : %d\\n\", ao2.total_locked);\n\tast_cli(a->fd, \"Refs       : %d\\n\", ao2.total_refs);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 1953}
{"project": "Asterisk", "target": 0, "func": "int ast_rtp_dtls_cfg_parse(struct ast_rtp_dtls_cfg *dtls_cfg, const char *name, const char *value)\n{\n\tif (!strcasecmp(name, \"dtlsenable\")) {\n\t\tdtls_cfg->enabled = ast_true(value) ? 1 : 0;\n\t} else if (!strcasecmp(name, \"dtlsverify\")) {\n\t\tif (!strcasecmp(value, \"yes\")) {\n\t\t\tdtls_cfg->verify = AST_RTP_DTLS_VERIFY_FINGERPRINT | AST_RTP_DTLS_VERIFY_CERTIFICATE;\n\t\t} else if (!strcasecmp(value, \"fingerprint\")) {\n\t\t\tdtls_cfg->verify = AST_RTP_DTLS_VERIFY_FINGERPRINT;\n\t\t} else if (!strcasecmp(value, \"certificate\")) {\n\t\t\tdtls_cfg->verify = AST_RTP_DTLS_VERIFY_CERTIFICATE;\n\t\t} else if (!strcasecmp(value, \"no\")) {\n\t\t\tdtls_cfg->verify = AST_RTP_DTLS_VERIFY_NONE;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcasecmp(name, \"dtlsrekey\")) {\n\t\tif (sscanf(value, \"%30u\", &dtls_cfg->rekey) != 1) {\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcasecmp(name, \"dtlscertfile\")) {\n\t\tif (!ast_strlen_zero(value) && !ast_file_is_readable(value)) {\n\t\t\tast_log(LOG_ERROR, \"%s file %s does not exist or is not readable\\n\", name, value);\n\t\t\treturn -1;\n\t\t}\n\t\tast_free(dtls_cfg->certfile);\n\t\tdtls_cfg->certfile = ast_strdup(value);\n\t} else if (!strcasecmp(name, \"dtlsprivatekey\")) {\n\t\tif (!ast_strlen_zero(value) && !ast_file_is_readable(value)) {\n\t\t\tast_log(LOG_ERROR, \"%s file %s does not exist or is not readable\\n\", name, value);\n\t\t\treturn -1;\n\t\t}\n\t\tast_free(dtls_cfg->pvtfile);\n\t\tdtls_cfg->pvtfile = ast_strdup(value);\n\t} else if (!strcasecmp(name, \"dtlscipher\")) {\n\t\tast_free(dtls_cfg->cipher);\n\t\tdtls_cfg->cipher = ast_strdup(value);\n\t} else if (!strcasecmp(name, \"dtlscafile\")) {\n\t\tif (!ast_strlen_zero(value) && !ast_file_is_readable(value)) {\n\t\t\tast_log(LOG_ERROR, \"%s file %s does not exist or is not readable\\n\", name, value);\n\t\t\treturn -1;\n\t\t}\n\t\tast_free(dtls_cfg->cafile);\n\t\tdtls_cfg->cafile = ast_strdup(value);\n\t} else if (!strcasecmp(name, \"dtlscapath\") || !strcasecmp(name, \"dtlscadir\")) {\n\t\tif (!ast_strlen_zero(value) && !ast_file_is_readable(value)) {\n\t\t\tast_log(LOG_ERROR, \"%s file %s does not exist or is not readable\\n\", name, value);\n\t\t\treturn -1;\n\t\t}\n\t\tast_free(dtls_cfg->capath);\n\t\tdtls_cfg->capath = ast_strdup(value);\n\t} else if (!strcasecmp(name, \"dtlssetup\")) {\n\t\tif (!strcasecmp(value, \"active\")) {\n\t\t\tdtls_cfg->default_setup = AST_RTP_DTLS_SETUP_ACTIVE;\n\t\t} else if (!strcasecmp(value, \"passive\")) {\n\t\t\tdtls_cfg->default_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\t} else if (!strcasecmp(value, \"actpass\")) {\n\t\t\tdtls_cfg->default_setup = AST_RTP_DTLS_SETUP_ACTPASS;\n\t\t}\n\t} else if (!strcasecmp(name, \"dtlsfingerprint\")) {\n\t\tif (!strcasecmp(value, \"sha-256\")) {\n\t\t\tdtls_cfg->hash = AST_RTP_DTLS_HASH_SHA256;\n\t\t} else if (!strcasecmp(value, \"sha-1\")) {\n\t\t\tdtls_cfg->hash = AST_RTP_DTLS_HASH_SHA1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1954}
{"project": "Asterisk", "target": 0, "func": "static int unistim_register(struct unistimsession *s)\n{\n\tstruct unistim_device *d;\n\tast_mutex_lock(&devicelock);\n\td = devices;\n\twhile (d) {\n\t\tif (!strcasecmp(s->macaddr, d->id)) {\n\t\t\t\n\t\t\ts->device = d;\n\t\t\td->session = s;\n\t\t\td->codec_number = DEFAULT_CODEC;\n\t\t\td->missed_call = 0;\n\t\t\td->receiver_state = STATE_ONHOOK;\n\t\t\tbreak;\n\t\t}\n\t\td = d->next;\n\t}\n\tast_mutex_unlock(&devicelock);\n\tif (!d) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 1955}
{"project": "Asterisk", "target": 0, "func": "static struct unistim_line *unistim_line_destroy(struct unistim_line *l)\n{\n\tif (!l) {\n\t\treturn NULL;\n\t}\n\tao2_ref(l->cap, -1);\n\tast_free(l);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1956}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tAST_TEST_REGISTER(uuid);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 1957}
{"project": "Asterisk", "target": 0, "func": "struct ast_channel *ast_local_get_peer(struct ast_channel *ast)\n{\n\tstruct local_pvt *p = ast_channel_tech_pvt(ast);\n\tstruct local_pvt *found;\n\tstruct ast_channel *peer;\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\tfound = p ? ao2_find(locals, p, 0) : NULL;\n\tif (!found) {\n\t\t\n\t\treturn NULL;\n\t}\n\tao2_lock(found);\n\tif (ast == p->base.owner) {\n\t\tpeer = p->base.chan;\n\t} else if (ast == p->base.chan) {\n\t\tpeer = p->base.owner;\n\t} else {\n\t\tpeer = NULL;\n\t}\n\tif (peer) {\n\t\tast_channel_ref(peer);\n\t}\n\tao2_unlock(found);\n\tao2_ref(found, -1);\n\treturn peer;\n}\n", "bug_type": null, "idx": 1958}
{"project": "Asterisk", "target": 0, "func": "static int misdn_fixup(struct ast_channel *oldast, struct ast_channel *ast)\n{\n\tstruct chan_list *p;\n\tif (!ast || !(p = MISDN_ASTERISK_TECH_PVT(ast))) {\n\t\treturn -1;\n\t}\n\tchan_misdn_log(1, p->bc ? p->bc->port : 0, \"* IND: Got Fixup State:%s L3id:%x\\n\", misdn_get_ch_state(p), p->l3id);\n\tp->ast = ast;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1959}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245UserInputIndication (OOCTXT* pctxt, H245UserInputIndication* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 2);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 1);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = encodeVarWidthCharString (pctxt, pvalue->u.alphanumeric);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 3);\n      if (stat != ASN_OK) return stat;\n      \n      initContext (&lctxt);\n      stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      switch (pvalue->t)\n      {\n         \n         case 3:\n            stat = asn1PE_H245UserInputIndication_userInputSupportIndication (&lctxt, pvalue->u.userInputSupportIndication);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 4:\n            stat = asn1PE_H245UserInputIndication_signal (&lctxt, pvalue->u.signal);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 5:\n            stat = asn1PE_H245UserInputIndication_signalUpdate (&lctxt, pvalue->u.signalUpdate);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         \n         case 6:\n            stat = asn1PE_H245UserInputIndication_extendedAlphanumeric (&lctxt, pvalue->u.extendedAlphanumeric);\n            if (stat != ASN_OK) return freeContext (&lctxt), stat;\n            openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n            break;\n         default:\n            ;\n      }\n      stat = encodeByteAlign (pctxt);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n      if (stat != ASN_OK) return freeContext (&lctxt), stat;\n      freeContext (&lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1960}
{"project": "Asterisk", "target": 0, "func": "void pvalRandomSetCondition( pval *p, char *percent )\n{\n\tif (!pvalCheckType(p, \"pvalRandomSetCondition\", PV_RANDOM))\n\t\treturn;\n\tp->u1.str = percent;\n}\n", "bug_type": null, "idx": 1961}
{"project": "Asterisk", "target": 0, "func": "static void jb_destroy_adaptive(void *jb)\n{\n\tjitterbuf *adaptivejb = (jitterbuf *) jb;\n\tjb_destroy(adaptivejb);\n}\n", "bug_type": null, "idx": 1962}
{"project": "Asterisk", "target": 0, "func": "\nstatic pj_status_t registration_client_send(struct sip_outbound_registration_client_state *client_state,\n\tpjsip_tx_data *tdata)\n{\n\tpj_status_t status;\n\tint *callback_invoked;\n\tpjsip_tpselector selector = { .type = PJSIP_TPSELECTOR_NONE, };\n\tcallback_invoked = ast_threadstorage_get(&register_callback_invoked, sizeof(int));\n\tif (!callback_invoked) {\n\t\tpjsip_tx_data_dec_ref(tdata);\n\t\treturn PJ_ENOMEM;\n\t}\n\t*callback_invoked = 0;\n\t\n\tao2_ref(client_state, +1);\n\t\n\tast_sip_set_tpselector_from_transport_name(client_state->transport_name, &selector);\n\tpjsip_regc_set_transport(client_state->client, &selector);\n\tstatus = pjsip_regc_send(client_state->client, tdata);\n\t\n\tif ((status != PJ_SUCCESS) && !(*callback_invoked)) {\n\t\tao2_ref(client_state, -1);\n\t}\n\treturn status;\n}\n", "bug_type": null, "idx": 1963}
{"project": "Asterisk", "target": 0, "func": "struct ao2_container *ast_calendar_event_container_alloc(void)\n{\n\treturn ao2_container_alloc(CALENDAR_BUCKETS, event_hash_fn, event_cmp_fn);\n}\n", "bug_type": null, "idx": 1964}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245EscrowData (OOCTXT* pctxt, H245EscrowData* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   \n   stat = encodeObjectIdentifier (pctxt, &pvalue->escrowID);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H245EscrowData_escrowValue (pctxt, &pvalue->escrowValue);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 1965}
{"project": "Asterisk", "target": 0, "func": "#endif\nvoid gsm_destroy P1((S), gsm S)\n{\n\tfree((char *)S);\n}\n", "bug_type": null, "idx": 1966}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int json_to_ast_variables(struct ast_ari_response *response, struct ast_json *json_variables, struct ast_variable **variables)\n{\n\tenum ast_json_to_ast_vars_code res;\n\tres = ast_json_to_ast_variables(json_variables, variables);\n\tswitch (res) {\n\tcase AST_JSON_TO_AST_VARS_CODE_SUCCESS:\n\t\treturn 0;\n\tcase AST_JSON_TO_AST_VARS_CODE_INVALID_TYPE:\n\t\tast_ari_response_error(response, 400, \"Bad Request\",\n\t\t\t\"Only string values in the 'variables' object allowed\");\n\t\tbreak;\n\tcase AST_JSON_TO_AST_VARS_CODE_OOM:\n\t\tast_ari_response_alloc_failed(response);\n\t\tbreak;\n\t}\n\tast_log(AST_LOG_ERROR, \"Unable to convert 'variables' in JSON body to Asterisk variables\\n\");\n\treturn -1;\n}\n", "bug_type": null, "idx": 1967}
{"project": "Asterisk", "target": 0, "func": "static void sip_subscription_to_ami(struct sip_subscription_tree *sub_tree,\n\t\t\t\t    struct ast_str **buf)\n{\n\tchar str[256];\n\tstruct ast_sip_endpoint_id_configuration *id = &sub_tree->endpoint->id;\n\tast_str_append(buf, 0, \"Role: %s\\r\\n\",\n\t\t       sip_subscription_roles_map[sub_tree->role]);\n\tast_str_append(buf, 0, \"Endpoint: %s\\r\\n\",\n\t\t       ast_sorcery_object_get_id(sub_tree->endpoint));\n\tif (sub_tree->dlg) {\n\t\tast_copy_pj_str(str, &sub_tree->dlg->call_id->id, sizeof(str));\n\t} else {\n\t\tast_copy_string(str, \"<unknown>\", sizeof(str));\n\t}\n\tast_str_append(buf, 0, \"Callid: %s\\r\\n\", str);\n\tast_str_append(buf, 0, \"State: %s\\r\\n\", pjsip_evsub_get_state_name(sub_tree->evsub));\n\tast_callerid_merge(str, sizeof(str),\n\t\t\t   S_COR(id->self.name.valid, id->self.name.str, NULL),\n\t\t\t   S_COR(id->self.number.valid, id->self.number.str, NULL),\n\t\t\t   \"Unknown\");\n\tast_str_append(buf, 0, \"Callerid: %s\\r\\n\", str);\n\t\n\tif (sub_tree->root->handler->to_ami) {\n\t\tsub_tree->root->handler->to_ami(sub_tree->root, buf);\n\t}\n}\n", "bug_type": null, "idx": 1968}
{"project": "Asterisk", "target": 0, "func": "static char *console_mute(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint toggle = 0;\n\tchar *res = CLI_SUCCESS;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"console {mute|unmute} [toggle]\";\n\t\te->usage =\n\t\t\t\"Usage: console {mute|unmute} [toggle]\\n\"\n\t\t\t\"       Mute/unmute the microphone.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc > 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (a->argc == 3) {\n\t\tif (strcasecmp(a->argv[2], \"toggle\"))\n\t\t\treturn CLI_SHOWUSAGE;\n\t\ttoggle = 1;\n\t}\n\tif (a->argc < 2) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (!strcasecmp(a->argv[1], \"mute\")) {\n\t\tmute = toggle ? !mute : 1;\n\t} else if (!strcasecmp(a->argv[1], \"unmute\")) {\n\t\tmute = toggle ? !mute : 0;\n\t} else {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_cli(a->fd, \"Console mic is %s\\n\", mute ? \"off\" : \"on\");\n\treturn res;\n}\n", "bug_type": null, "idx": 1969}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_endpoint *ast_sip_dialog_get_endpoint(pjsip_dialog *dlg)\n{\n\tstruct distributor_dialog_data *dist;\n\tstruct ast_sip_endpoint *endpoint;\n\tdist = ao2_find(dialog_associations, dlg, OBJ_SEARCH_KEY);\n\tif (dist) {\n\t\tao2_lock(dist);\n\t\tendpoint = ao2_bump(dist->endpoint);\n\t\tao2_unlock(dist);\n\t\tao2_ref(dist, -1);\n\t} else {\n\t\tendpoint = NULL;\n\t}\n\treturn endpoint;\n}\n", "bug_type": null, "idx": 1970}
{"project": "Asterisk", "target": 0, "func": "enum misdn_cfg_elements misdn_cfg_get_elem(const char *name)\n{\n\tint pos;\n\t\n\tif (!strcmp(name, \"ports\"))\n\t\treturn MISDN_CFG_GROUPNAME;\n\tif (!strcmp(name, \"name\"))\n\t\treturn MISDN_CFG_FIRST;\n\tpos = get_cfg_position(name, PORT_CFG);\n\tif (pos >= 0)\n\t\treturn port_spec[pos].elem;\n\tpos = get_cfg_position(name, GEN_CFG);\n\tif (pos >= 0)\n\t\treturn gen_spec[pos].elem;\n\treturn MISDN_CFG_FIRST;\n}\n", "bug_type": null, "idx": 1971}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int handle_response_cind(struct mbl_pvt *pvt, char *buf)\n{\n\tstruct msg_queue_entry *entry;\n\tif ((entry = msg_queue_head(pvt)) && entry->expected == AT_CIND) {\n\t\tswitch (entry->response_to) {\n\t\tcase AT_CIND_TEST:\n\t\t\tif (hfp_parse_cind_test(pvt->hfp, buf) || msg_queue_push(pvt, AT_OK, AT_CIND_TEST)) {\n\t\t\t\tast_debug(1, \"[%s] error performing CIND test\\n\", pvt->id);\n\t\t\t\tgoto e_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AT_CIND:\n\t\t\tif (hfp_parse_cind(pvt->hfp, buf) || msg_queue_push(pvt, AT_OK, AT_CIND)) {\n\t\t\t\tast_debug(1, \"[%s] error getting CIND state\\n\", pvt->id);\n\t\t\t\tgoto e_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_debug(1, \"[%s] error getting CIND state\\n\", pvt->id);\n\t\t\tgoto e_return;\n\t\t}\n\t\tmsg_queue_free_and_pop(pvt);\n\t} else if (entry) {\n\t\tast_debug(1, \"[%s] received unexpected AT message 'CIND' when expecting %s, ignoring\\n\", pvt->id, at_msg2str(entry->expected));\n\t} else {\n\t\tast_debug(1, \"[%s] received unexpected AT message 'CIND'\\n\", pvt->id);\n\t}\n\treturn 0;\ne_return:\n\tmsg_queue_free_and_pop(pvt);\n\treturn -1;\n}\n", "bug_type": null, "idx": 1972}
{"project": "Asterisk", "target": 0, "func": "static void analog_set_ringtimeout(struct analog_pvt *p, int ringt)\n{\n\tp->ringt = ringt;\n\tif (analog_callbacks.set_ringtimeout) {\n\t\tanalog_callbacks.set_ringtimeout(p->chan_pvt, ringt);\n\t}\n}\n", "bug_type": null, "idx": 1973}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void features_shutdown(void)\n{\n\tast_features_config_shutdown();\n\tast_manager_unregister(\"Bridge\");\n\tast_unregister_application(app_bridge);\n}\n", "bug_type": null, "idx": 1974}
{"project": "Asterisk", "target": 0, "func": "static struct ast_channel *phone_new(struct phone_pvt *i, int state, char *cntx, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor)\n{\n\tstruct ast_format_cap *caps = NULL;\n\tstruct ast_channel *tmp;\n\tstruct phone_codec_data queried_codec;\n\tstruct ast_format *tmpfmt;\n\tcaps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\ttmp = ast_channel_alloc(1, state, i->cid_num, i->cid_name, \"\", i->ext, i->context, assignedids, requestor, 0, \"Phone/%s\", i->dev + 5);\n\tif (tmp && caps) {\n\t\tast_channel_lock(tmp);\n\t\tast_channel_tech_set(tmp, cur_tech);\n\t\tast_channel_set_fd(tmp, 0, i->fd);\n\t\t\n\t\tif (i->mode == MODE_FXS &&\n\t\t    ioctl(i->fd, PHONE_QUERY_CODEC, &queried_codec) == 0) {\n\t\t\tif (queried_codec.type == LINEAR16) {\n\t\t\t\tast_format_cap_append(caps, ast_format_slin, 0);\n\t\t\t} else {\n\t\t\t\tast_format_cap_remove(prefcap, ast_format_slin);\n\t\t\t\tast_format_cap_append_from_cap(caps, prefcap, AST_MEDIA_TYPE_UNKNOWN);\n\t\t\t}\n\t\t} else {\n\t\t\tast_format_cap_append_from_cap(caps, prefcap, AST_MEDIA_TYPE_UNKNOWN);\n\t\t}\n\t\ttmpfmt = ast_format_cap_get_format(caps, 0);\n\t\tast_channel_nativeformats_set(tmp, caps);\n\t\tao2_ref(caps, -1);\n\t\tast_channel_set_rawreadformat(tmp, tmpfmt);\n\t\tast_channel_set_rawwriteformat(tmp, tmpfmt);\n\t\tao2_ref(tmpfmt, -1);\n\t\t\n\t\tif (state == AST_STATE_RING)\n\t\t\tast_channel_rings_set(tmp, 1);\n\t\tast_channel_tech_pvt_set(tmp, i);\n\t\tast_channel_context_set(tmp, cntx);\n\t\tif (!ast_strlen_zero(i->ext))\n\t\t\tast_channel_exten_set(tmp, i->ext);\n\t\telse\n\t\t\tast_channel_exten_set(tmp, \"s\");\n\t\tif (!ast_strlen_zero(i->language))\n\t\t\tast_channel_language_set(tmp, i->language);\n\t\t\n\t\tif (!ast_strlen_zero(i->cid_num)) {\n\t\t\tast_channel_caller(tmp)->ani.number.valid = 1;\n\t\t\tast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);\n\t\t}\n\t\ti->owner = tmp;\n\t\tast_module_ref(ast_module_info->self);\n\t\tast_channel_unlock(tmp);\n\t\tif (state != AST_STATE_DOWN) {\n\t\t\tif (state == AST_STATE_RING) {\n\t\t\t\tioctl(ast_channel_fd(tmp, 0), PHONE_RINGBACK);\n\t\t\t\ti->cpt = 1;\n\t\t\t}\n\t\t\tif (ast_pbx_start(tmp)) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to start PBX on %s\\n\", ast_channel_name(tmp));\n\t\t\t\tast_hangup(tmp);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tao2_cleanup(caps);\n\t\tast_log(LOG_WARNING, \"Unable to allocate channel structure\\n\");\n\t}\n\treturn tmp;\n}\n", "bug_type": null, "idx": 1975}
{"project": "Asterisk", "target": 0, "func": "int ast_device_state_changed_literal(const char *dev)\n{\n\treturn ast_devstate_changed_literal(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, dev);\n}\n", "bug_type": null, "idx": 1976}
{"project": "Asterisk", "target": 0, "func": "static int ast_fax_modem_to_str(enum ast_fax_modems bits, char *tbuf, size_t bufsize)\n{\n\tint count = 0;\n\tif (bits & AST_FAX_MODEM_V17) {\n\t\tstrcat(tbuf, \"V17\");\n\t\tcount++;\n\t}\n\tif (bits & AST_FAX_MODEM_V27TER) {\n\t\tif (count) {\n\t\t\tstrcat(tbuf, \",\");\n\t\t}\n\t\tstrcat(tbuf, \"V27\");\n\t\tcount++;\n\t}\n\tif (bits & AST_FAX_MODEM_V29) {\n\t\tif (count) {\n\t\t\tstrcat(tbuf, \",\");\n\t\t}\n\t\tstrcat(tbuf, \"V29\");\n\t\tcount++;\n\t}\n\tif (bits & AST_FAX_MODEM_V34) {\n\t\tif (count) {\n\t\t\tstrcat(tbuf, \",\");\n\t\t}\n\t\tstrcat(tbuf, \"V34\");\n\t\tcount++;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1977}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225CapacityReportingCapability (OOCTXT* pctxt, H225CapacityReportingCapability* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"canReportCallCapacity\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->canReportCallCapacity);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->canReportCallCapacity);\n   invokeEndElement (pctxt, \"canReportCallCapacity\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1978}
{"project": "Asterisk", "target": 0, "func": "*/\nint ooSendStatus(OOH323CallData *call)\n{\n   int ret;    \n   H225Status_UUIE *status;\n   Q931Message *q931msg=NULL;\n   \n   OOCTXT *pctxt = call->msgctxt;\n   OOTRACEDBGC3(\"Building StatusMsg (%s, %s)\\n\", call->callType, \n                 call->callToken);\n   ret = ooCreateQ931Message(pctxt, &q931msg, Q931StatusMsg);\n   if(ret != OO_OK)\n   {      \n      OOTRACEERR1(\"Error: In allocating memory for - H225 Status \"\n                           \"message\\n\");\n      return OO_FAILED;\n   }\n   q931msg->callReference = call->callReference;\n   q931msg->userInfo = (H225H323_UserInformation*)memAllocZ(pctxt,\n                             sizeof(H225H323_UserInformation));\n   if(!q931msg->userInfo)\n   {\n      OOTRACEERR1(\"ERROR:Memory - ooSendStatus - userInfo\\n\");\n      return OO_FAILED;\n   }\n   q931msg->userInfo->h323_uu_pdu.m.h245TunnelingPresent=1; \n   q931msg->userInfo->h323_uu_pdu.h245Tunneling = \n                                   OO_TESTFLAG(call->flags, OO_M_TUNNELING); \n   q931msg->userInfo->h323_uu_pdu.h323_message_body.t = \n         T_H225H323_UU_PDU_h323_message_body_status;\n   status = (H225Status_UUIE*)memAllocZ(pctxt,\n                                             sizeof(H225Status_UUIE));\n   if(!status)\n   {\n      OOTRACEERR1(\"ERROR:Memory - ooSendStatus \\n\");\n      return OO_FAILED;\n   }\n   q931msg->userInfo->h323_uu_pdu.h323_message_body.u.status = status;\n   status->callIdentifier.guid.numocts = \n                                   call->callIdentifier.guid.numocts;\n   memcpy(status->callIdentifier.guid.data, \n          call->callIdentifier.guid.data, \n          call->callIdentifier.guid.numocts);\n   status->protocolIdentifier = gProtocolID;  \n   ooQ931SetCauseIE(pctxt, q931msg, Q931StatusEnquiryResponse, 0, 0);\n   ooQ931SetCallStateIE(pctxt, q931msg, 10);\n   OOTRACEDBGA3(\"Built Status (%s, %s)\\n\", call->callType, \n                 call->callToken);   \n   ret = ooSendH225Msg(call, q931msg);\n   if(ret != OO_OK)\n   {\n      OOTRACEERR3(\"Error:Failed to enqueue Status message to outbound queue.(%s, %s)\\n\", call->callType, call->callToken);\n   }\n   \n   memReset(call->msgctxt);\n   return ret;\n}\n", "bug_type": null, "idx": 1979}
{"project": "Asterisk", "target": 0, "func": "int dundi_query_eid(struct dundi_entity_info *dei, const char *dcontext, dundi_eid eid)\n{\n\tdundi_eid *avoid[1] = { NULL, };\n\tstruct dundi_hint_metadata hmd;\n\tmemset(&hmd, 0, sizeof(hmd));\n\treturn dundi_query_eid_internal(dei, dcontext, &eid, &hmd, dundi_ttl, 0, avoid);\n}\n", "bug_type": null, "idx": 1980}
{"project": "Asterisk", "target": 0, "func": "const void *ast_event_get_ie_raw(const struct ast_event *event, enum ast_event_ie_type ie_type)\n{\n\tstruct ast_event_iterator iterator;\n\tint res;\n\tfor (res = ast_event_iterator_init(&iterator, event); !res; res = ast_event_iterator_next(&iterator)) {\n\t\tif (ast_event_iterator_get_ie_type(&iterator) == ie_type) {\n\t\t\treturn event_iterator_get_ie_raw(&iterator);\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1981}
{"project": "Asterisk", "target": 0, "func": "const char *stasis_app_stored_recording_get_filename(\n\tstruct stasis_app_stored_recording *recording)\n{\n\tif (!recording) {\n\t\treturn NULL;\n\t}\n\treturn recording->file_with_ext;\n}\n", "bug_type": null, "idx": 1982}
{"project": "Asterisk", "target": 0, "func": "static int manager_bridge_kick(struct mansession *s, const struct message *m)\n{\n\tconst char *bridge_uniqueid = astman_get_header(m, \"BridgeUniqueid\");\n\tconst char *channel_name = astman_get_header(m, \"Channel\");\n\tRAII_VAR(struct ast_bridge *, bridge, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_channel *, channel, NULL, ao2_cleanup);\n\tif (ast_strlen_zero(channel_name)) {\n\t\tastman_send_error(s, m, \"Channel must be provided\");\n\t\treturn 0;\n\t}\n\tchannel = ast_channel_get_by_name(channel_name);\n\tif (!channel) {\n\t\tastman_send_error(s, m, \"Channel does not exist\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(bridge_uniqueid)) {\n\t\t\n\t\tast_channel_lock(channel);\n\t\tbridge = ast_channel_get_bridge(channel);\n\t\tast_channel_unlock(channel);\n\t\tif (!bridge) {\n\t\t\tastman_send_error(s, m, \"Channel is not in a bridge\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tbridge = ast_bridge_find_by_id(bridge_uniqueid);\n\t\tif (!bridge || ast_test_flag(&bridge->feature_flags, AST_BRIDGE_FLAG_INVISIBLE)) {\n\t\t\tastman_send_error(s, m, \"Bridge not found\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (ast_bridge_kick(bridge, channel)) {\n\t\tastman_send_error(s, m, \"Channel kick from bridge failed\");\n\t\treturn 0;\n\t}\n\tastman_send_ack(s, m, \"Channel has been kicked\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 1983}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void asterisk_publisher_devstate_cb(void *data, struct stasis_subscription *sub, struct stasis_message *msg)\n{\n\tstruct ast_datastore *datastore = data;\n\tstruct asterisk_devicestate_publisher_state *publisher_state = datastore->data;\n\tstruct ast_device_state_message *dev_state;\n\tchar eid_str[20];\n\tstruct ast_json *json;\n\tchar *text;\n\tstruct ast_sip_body body = {\n\t\t.type = \"application\",\n\t\t.subtype = \"json\",\n\t};\n\tif (!stasis_subscription_is_subscribed(sub) || ast_device_state_message_type() != stasis_message_type(msg)) {\n\t\treturn;\n\t}\n\tdev_state = stasis_message_data(msg);\n\tif (!dev_state->eid || ast_eid_cmp(&ast_eid_default, dev_state->eid)) {\n\t\t\n\t\treturn;\n\t}\n\tif (publisher_state->device_state_filter && regexec(&publisher_state->device_state_regex, dev_state->device, 0, NULL, 0)) {\n\t\t\n\t\treturn;\n\t}\n\tast_eid_to_str(eid_str, sizeof(eid_str), &ast_eid_default);\n\tjson = ast_json_pack(\n\t\t\"{ s: s, s: s, s: s, s: i, s:s }\",\n\t\t\"type\", \"devicestate\",\n\t\t\"device\", dev_state->device,\n\t\t\"state\", ast_devstate_str(dev_state->state),\n\t\t\"cachable\", dev_state->cachable,\n\t\t\"eid\", eid_str);\n\tif (!json) {\n\t\treturn;\n\t}\n\ttext = ast_json_dump_string(json);\n\tif (!text) {\n\t\tast_json_unref(json);\n\t\treturn;\n\t}\n\tbody.body_text = text;\n\tast_sip_publish_client_send(publisher_state->client, &body);\n\tast_json_free(text);\n\tast_json_unref(json);\n}\n", "bug_type": null, "idx": 1984}
{"project": "Asterisk", "target": 0, "func": "static int dahdi_hangup(struct ast_channel *ast)\n{\n\tint res = 0;\n\tint idx,x;\n\tint law;\n\t\n\tstruct dahdi_pvt *p = ast_channel_tech_pvt(ast);\n\tstruct dahdi_params par;\n\tast_debug(1, \"dahdi_hangup(%s)\\n\", ast_channel_name(ast));\n\tif (!ast_channel_tech_pvt(ast)) {\n\t\tast_log(LOG_WARNING, \"Asked to hangup channel not connected\\n\");\n\t\treturn 0;\n\t}\n\tast_mutex_lock(&p->lock);\n\tp->exten[0] = '\\0';\n\tif (dahdi_analog_lib_handles(p->sig, p->radio, p->oprmode)) {\n\t\tdahdi_confmute(p, 0);\n\t\trestore_gains(p);\n\t\tp->ignoredtmf = 0;\n\t\tp->waitingfordt.tv_sec = 0;\n\t\tres = analog_hangup(p->sig_pvt, ast);\n\t\trevert_fax_buffers(p, ast);\n\t\tgoto hangup_out;\n\t} else {\n\t\tp->cid_num[0] = '\\0';\n\t\tp->cid_name[0] = '\\0';\n\t\tp->cid_subaddr[0] = '\\0';\n\t}\n#if defined(HAVE_PRI)\n\tif (dahdi_sig_pri_lib_handles(p->sig)) {\n\t\tx = 1;\n\t\tast_channel_setoption(ast, AST_OPTION_AUDIO_MODE, &x, sizeof(char), 0);\n\t\tdahdi_confmute(p, 0);\n\t\tp->muting = 0;\n\t\trestore_gains(p);\n\t\tif (p->dsp) {\n\t\t\tast_dsp_free(p->dsp);\n\t\t\tp->dsp = NULL;\n\t\t}\n\t\tp->ignoredtmf = 0;\n\t\t\n\t\tp->subs[SUB_REAL].owner = NULL;\n\t\tp->subs[SUB_REAL].needbusy = 0;\n\t\tdahdi_setlinear(p->subs[SUB_REAL].dfd, 0);\n\t\tp->owner = NULL;\n\t\tp->cid_tag[0] = '\\0';\n\t\tp->ringt = 0;\n\t\tp->distinctivering = 0;\n\t\tp->confirmanswer = 0;\n\t\tp->outgoing = 0;\n\t\tp->digital = 0;\n\t\tp->faxhandled = 0;\n\t\tp->pulsedial = 0;\n\t\trevert_fax_buffers(p, ast);\n\t\tp->law = p->law_default;\n\t\tlaw = p->law_default;\n\t\tres = ioctl(p->subs[SUB_REAL].dfd, DAHDI_SETLAW, &law);\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_WARNING, \"Unable to set law on channel %d to default: %s\\n\",\n\t\t\t\tp->channel, strerror(errno));\n\t\t}\n\t\tsig_pri_hangup(p->sig_pvt, ast);\n\t\ttone_zone_play_tone(p->subs[SUB_REAL].dfd, -1);\n\t\tdahdi_ec_disable(p);\n\t\tx = 0;\n\t\tast_channel_setoption(ast, AST_OPTION_TDD, &x, sizeof(char), 0);\n\t\tp->didtdd = 0;\n\t\tp->rdnis[0] = '\\0';\n\t\tdahdi_conf_update(p);\n\t\treset_conf(p);\n\t\t\n\t\tx = 0;\n\t\tast_channel_setoption(ast, AST_OPTION_AUDIO_MODE, &x, sizeof(char), 0);\n\t\tif (num_restart_pending == 0) {\n\t\t\trestart_monitor();\n\t\t}\n\t\tgoto hangup_out;\n\t}\n#endif\t\n#if defined(HAVE_SS7)\n\tif (p->sig == SIG_SS7) {\n\t\tx = 1;\n\t\tast_channel_setoption(ast, AST_OPTION_AUDIO_MODE, &x, sizeof(char), 0);\n\t\tdahdi_confmute(p, 0);\n\t\tp->muting = 0;\n\t\trestore_gains(p);\n\t\tif (p->dsp) {\n\t\t\tast_dsp_free(p->dsp);\n\t\t\tp->dsp = NULL;\n\t\t}\n\t\tp->ignoredtmf = 0;\n\t\t\n\t\tp->subs[SUB_REAL].owner = NULL;\n\t\tp->subs[SUB_REAL].needbusy = 0;\n\t\tdahdi_setlinear(p->subs[SUB_REAL].dfd, 0);\n\t\tp->owner = NULL;\n\t\tp->ringt = 0;\n\t\tp->distinctivering = 0;\n\t\tp->confirmanswer = 0;\n\t\tp->outgoing = 0;\n\t\tp->digital = 0;\n\t\tp->faxhandled = 0;\n\t\tp->pulsedial = 0;\n\t\trevert_fax_buffers(p, ast);\n\t\tp->law = p->law_default;\n\t\tlaw = p->law_default;\n\t\tres = ioctl(p->subs[SUB_REAL].dfd, DAHDI_SETLAW, &law);\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_WARNING, \"Unable to set law on channel %d to default: %s\\n\",\n\t\t\t\tp->channel, strerror(errno));\n\t\t}\n\t\tsig_ss7_hangup(p->sig_pvt, ast);\n\t\ttone_zone_play_tone(p->subs[SUB_REAL].dfd, -1);\n\t\tdahdi_ec_disable(p);\n\t\tx = 0;\n\t\tast_channel_setoption(ast, AST_OPTION_TDD, &x, sizeof(char), 0);\n\t\tp->didtdd = 0;\n\t\tdahdi_conf_update(p);\n\t\treset_conf(p);\n\t\t\n\t\tx = 0;\n\t\tast_channel_setoption(ast, AST_OPTION_AUDIO_MODE, &x, sizeof(char), 0);\n\t\tif (num_restart_pending == 0) {\n\t\t\trestart_monitor();\n\t\t}\n\t\tgoto hangup_out;\n\t}\n#endif\t\n\tidx = dahdi_get_index(ast, p, 1);\n\tdahdi_confmute(p, 0);\n\tp->muting = 0;\n\trestore_gains(p);\n\tif (p->origcid_num) {\n\t\tast_copy_string(p->cid_num, p->origcid_num, sizeof(p->cid_num));\n\t\tast_free(p->origcid_num);\n\t\tp->origcid_num = NULL;\n\t}\n\tif (p->origcid_name) {\n\t\tast_copy_string(p->cid_name, p->origcid_name, sizeof(p->cid_name));\n\t\tast_free(p->origcid_name);\n\t\tp->origcid_name = NULL;\n\t}\n\tif (p->dsp)\n\t\tast_dsp_set_digitmode(p->dsp, DSP_DIGITMODE_DTMF | p->dtmfrelax);\n\tast_debug(1, \"Hangup: channel: %d index = %d, normal = %d, callwait = %d, thirdcall = %d\\n\",\n\t\tp->channel, idx, p->subs[SUB_REAL].dfd, p->subs[SUB_CALLWAIT].dfd, p->subs[SUB_THREEWAY].dfd);\n\tp->ignoredtmf = 0;\n\tif (idx > -1) {\n\t\t\n\t\tp->subs[idx].owner = NULL;\n\t\tp->subs[idx].needanswer = 0;\n\t\tp->subs[idx].needflash = 0;\n\t\tp->subs[idx].needringing = 0;\n\t\tp->subs[idx].needbusy = 0;\n\t\tp->subs[idx].needcongestion = 0;\n\t\tp->subs[idx].linear = 0;\n\t\tp->polarity = POLARITY_IDLE;\n\t\tdahdi_setlinear(p->subs[idx].dfd, 0);\n\t\tif (idx == SUB_REAL) {\n\t\t\tif ((p->subs[SUB_CALLWAIT].dfd > -1) && (p->subs[SUB_THREEWAY].dfd > -1)) {\n\t\t\t\tast_debug(1, \"Normal call hung up with both three way call and a call waiting call in place?\\n\");\n\t\t\t\tif (p->subs[SUB_CALLWAIT].inthreeway) {\n\t\t\t\t\t\n\t\t\t\t\tast_debug(1, \"We were flipped over to the callwait, moving back and unowning.\\n\");\n\t\t\t\t\t\n\t\t\t\t\tswap_subs(p, SUB_CALLWAIT, SUB_REAL);\n\t\t\t\t\tunalloc_sub(p, SUB_CALLWAIT);\n\t\t\t\t\tp->owner = NULL;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tast_debug(1, \"We were in the threeway and have a callwait still.  Ditching the threeway.\\n\");\n\t\t\t\t\tswap_subs(p, SUB_THREEWAY, SUB_REAL);\n\t\t\t\t\tunalloc_sub(p, SUB_THREEWAY);\n\t\t\t\t\tif (p->subs[SUB_REAL].inthreeway) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tast_debug(1, \"Call was complete, setting owner to former third call\\n\");\n\t\t\t\t\t\tp->owner = p->subs[SUB_REAL].owner;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tast_debug(1, \"Call was incomplete, setting owner to NULL\\n\");\n\t\t\t\t\t\tp->owner = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tp->subs[SUB_REAL].inthreeway = 0;\n\t\t\t\t}\n\t\t\t} else if (p->subs[SUB_CALLWAIT].dfd > -1) {\n\t\t\t\t\n\t\t\t\tswap_subs(p, SUB_CALLWAIT, SUB_REAL);\n\t\t\t\tunalloc_sub(p, SUB_CALLWAIT);\n\t\t\t\tp->owner = p->subs[SUB_REAL].owner;\n\t\t\t\tif (ast_channel_state(p->owner) != AST_STATE_UP)\n\t\t\t\t\tp->subs[SUB_REAL].needanswer = 1;\n\t\t\t\tast_queue_unhold(p->subs[SUB_REAL].owner);\n\t\t\t} else if (p->subs[SUB_THREEWAY].dfd > -1) {\n\t\t\t\tswap_subs(p, SUB_THREEWAY, SUB_REAL);\n\t\t\t\tunalloc_sub(p, SUB_THREEWAY);\n\t\t\t\tif (p->subs[SUB_REAL].inthreeway) {\n\t\t\t\t\t\n\t\t\t\t\tast_debug(1, \"Call was complete, setting owner to former third call\\n\");\n\t\t\t\t\tp->owner = p->subs[SUB_REAL].owner;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tast_debug(1, \"Call was incomplete, setting owner to NULL\\n\");\n\t\t\t\t\tp->owner = NULL;\n\t\t\t\t}\n\t\t\t\tp->subs[SUB_REAL].inthreeway = 0;\n\t\t\t}\n\t\t} else if (idx == SUB_CALLWAIT) {\n\t\t\t\n\t\t\tif (p->subs[SUB_CALLWAIT].inthreeway) {\n\t\t\t\t\n\t\t\t\tif (p->subs[SUB_THREEWAY].owner) {\n\t\t\t\t\tast_queue_hold(p->subs[SUB_THREEWAY].owner, p->mohsuggest);\n\t\t\t\t}\n\t\t\t\tp->subs[SUB_THREEWAY].inthreeway = 0;\n\t\t\t\t\n\t\t\t\tswap_subs(p, SUB_CALLWAIT, SUB_THREEWAY);\n\t\t\t\tunalloc_sub(p, SUB_THREEWAY);\n\t\t\t} else\n\t\t\t\tunalloc_sub(p, SUB_CALLWAIT);\n\t\t} else if (idx == SUB_THREEWAY) {\n\t\t\tif (p->subs[SUB_CALLWAIT].inthreeway) {\n\t\t\t\t\n\t\t\t\tif (p->subs[SUB_CALLWAIT].owner) {\n\t\t\t\t\tast_queue_hold(p->subs[SUB_CALLWAIT].owner, p->mohsuggest);\n\t\t\t\t}\n\t\t\t\tp->subs[SUB_CALLWAIT].inthreeway = 0;\n\t\t\t}\n\t\t\tp->subs[SUB_REAL].inthreeway = 0;\n\t\t\t\n\t\t\tunalloc_sub(p, SUB_THREEWAY);\n\t\t} else {\n\t\t\t\n\t\t\tast_log(LOG_WARNING, \"Index found but not any type of call?\\n\");\n\t\t}\n\t}\n\tif (!p->subs[SUB_REAL].owner && !p->subs[SUB_CALLWAIT].owner && !p->subs[SUB_THREEWAY].owner) {\n\t\tp->owner = NULL;\n\t\tp->ringt = 0;\n\t\tp->distinctivering = 0;\n\t\tp->confirmanswer = 0;\n\t\tp->outgoing = 0;\n\t\tp->digital = 0;\n\t\tp->faxhandled = 0;\n\t\tp->pulsedial = 0;\n\t\tif (p->dsp) {\n\t\t\tast_dsp_free(p->dsp);\n\t\t\tp->dsp = NULL;\n\t\t}\n\t\trevert_fax_buffers(p, ast);\n\t\tp->law = p->law_default;\n\t\tlaw = p->law_default;\n\t\tres = ioctl(p->subs[SUB_REAL].dfd, DAHDI_SETLAW, &law);\n\t\tif (res < 0)\n\t\t\tast_log(LOG_WARNING, \"Unable to set law on channel %d to default: %s\\n\", p->channel, strerror(errno));\n\t\t\n#ifdef HAVE_OPENR2\n\t\tif (p->mfcr2 && p->mfcr2call && openr2_chan_get_direction(p->r2chan) != OR2_DIR_STOPPED) {\n\t\t\tast_debug(1, \"disconnecting MFC/R2 call on chan %d\\n\", p->channel);\n\t\t\t\n\t\t\tif (openr2_chan_get_direction(p->r2chan) == OR2_DIR_BACKWARD && p->mfcr2_forced_release) {\n\t\t\t\tdahdi_r2_disconnect_call(p, OR2_CAUSE_FORCED_RELEASE);\n\t\t\t} else {\n\t\t\t\tconst char *r2causestr = pbx_builtin_getvar_helper(ast, \"MFCR2_CAUSE\");\n\t\t\t\tint r2cause_user = r2causestr ? atoi(r2causestr) : 0;\n\t\t\t\topenr2_call_disconnect_cause_t r2cause = r2cause_user ? dahdi_ast_cause_to_r2_cause(r2cause_user)\n\t\t\t\t\t                                              : dahdi_ast_cause_to_r2_cause(ast_channel_hangupcause(ast));\n\t\t\t\tdahdi_r2_disconnect_call(p, r2cause);\n\t\t\t}\n\t\t} else if (p->mfcr2call) {\n\t\t\tast_debug(1, \"Clearing call request on channel %d\\n\", p->channel);\n\t\t\t\n\t\t\tp->mfcr2call = 0;\n\t\t}\n#endif\n\t\tswitch (p->sig) {\n\t\tcase SIG_SS7:\n\t\tcase SIG_MFCR2:\n\t\tcase SIG_PRI_LIB_HANDLE_CASES:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = dahdi_set_hook(p->subs[SUB_REAL].dfd, DAHDI_ONHOOK);\n\t\t\tbreak;\n\t\t}\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_WARNING, \"Unable to hangup line %s\\n\", ast_channel_name(ast));\n\t\t}\n\t\tswitch (p->sig) {\n\t\tcase SIG_FXOGS:\n\t\tcase SIG_FXOLS:\n\t\tcase SIG_FXOKS:\n\t\t\tmemset(&par, 0, sizeof(par));\n\t\t\tres = ioctl(p->subs[SUB_REAL].dfd, DAHDI_GET_PARAMS, &par);\n\t\t\tif (!res) {\n\t\t\t\tstruct analog_pvt *analog_p = p->sig_pvt;\n#if 0\n\t\t\t\tast_debug(1, \"Hanging up channel %d, offhook = %d\\n\", p->channel, par.rxisoffhook);\n#endif\n\t\t\t\t\n\t\t\t\tif ((par.rxisoffhook) && (!(p->radio || (p->oprmode < 0))))\n\t\t\t\t\ttone_zone_play_tone(p->subs[SUB_REAL].dfd, DAHDI_TONE_CONGESTION);\n\t\t\t\telse\n\t\t\t\t\ttone_zone_play_tone(p->subs[SUB_REAL].dfd, -1);\n\t\t\t\tanalog_p->fxsoffhookstate = par.rxisoffhook;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG_FXSGS:\n\t\tcase SIG_FXSLS:\n\t\tcase SIG_FXSKS:\n\t\t\t\n\t\t\tif (ast_channel_state(ast) != AST_STATE_RESERVED) {\n\t\t\t\ttime(&p->guardtime);\n\t\t\t\tp->guardtime += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttone_zone_play_tone(p->subs[SUB_REAL].dfd, -1);\n\t\t\tbreak;\n\t\t}\n\t\tif (p->sig)\n\t\t\tdahdi_ec_disable(p);\n\t\tx = 0;\n\t\tast_channel_setoption(ast,AST_OPTION_TONE_VERIFY,&x,sizeof(char),0);\n\t\tast_channel_setoption(ast,AST_OPTION_TDD,&x,sizeof(char),0);\n\t\tp->didtdd = 0;\n\t\tp->callwaitcas = 0;\n\t\tp->callwaiting = p->permcallwaiting;\n\t\tp->hidecallerid = p->permhidecallerid;\n\t\tp->waitingfordt.tv_sec = 0;\n\t\tp->dialing = 0;\n\t\tp->rdnis[0] = '\\0';\n\t\tdahdi_conf_update(p);\n\t\treset_conf(p);\n\t\t\n\t\tswitch (p->sig) {\n\t\tcase SIG_PRI_LIB_HANDLE_CASES:\n\t\tcase SIG_SS7:\n\t\t\tx = 0;\n\t\t\tast_channel_setoption(ast,AST_OPTION_AUDIO_MODE,&x,sizeof(char),0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (num_restart_pending == 0)\n\t\t\trestart_monitor();\n\t}\n\tp->callwaitingrepeat = 0;\n\tp->cidcwexpire = 0;\n\tp->cid_suppress_expire = 0;\n\tp->oprmode = 0;\nhangup_out:\n\tast_channel_tech_pvt_set(ast, NULL);\n\tast_free(p->cidspill);\n\tp->cidspill = NULL;\n\tast_mutex_unlock(&p->lock);\n\tast_verb(3, \"Hungup '%s'\\n\", ast_channel_name(ast));\n\tast_mutex_lock(&iflock);\n\tif (p->restartpending) {\n\t\tnum_restart_pending--;\n\t}\n\tif (p->destroy) {\n\t\tdestroy_channel(p, 0);\n\t}\n\tast_mutex_unlock(&iflock);\n\tast_module_unref(ast_module_info->self);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1985}
{"project": "Asterisk", "target": 0, "func": "int ooSendMasterSlaveDeterminationRelease(OOH323CallData * call)\n{\n   int ret=0;\n   H245IndicationMessage* indication=NULL;\n   H245Message *ph245msg=NULL;\n   \n   OOCTXT *pctxt=call->msgctxt;\n   ret = ooCreateH245Message\n      (call, &ph245msg, T_H245MultimediaSystemControlMessage_indication);\n   if (ret != OO_OK) {\n      OOTRACEERR3(\"Error:H245 message creation failed for - MasterSlave \"\n                  \"Determination Release (%s, %s)\\n\",call->callType, \n                  call->callToken);\n      return OO_FAILED;\n   }\n   ph245msg->msgType = OOMasterSlaveRelease;\n   indication = ph245msg->h245Msg.u.indication;\n   indication->t = T_H245IndicationMessage_masterSlaveDeterminationRelease;\n   indication->u.masterSlaveDeterminationRelease = \n      (H245MasterSlaveDeterminationRelease*)\n      memAlloc (pctxt, sizeof(H245MasterSlaveDeterminationRelease));\n   if(!indication->u.masterSlaveDeterminationRelease)\n   {\n      OOTRACEERR3(\"Error: Failed to allocate memory for MSDRelease message.\"\n                  \" (%s, %s)\\n\", call->callType, call->callToken);\n      ooFreeH245Message(call, ph245msg);\n      return OO_FAILED;\n   }\n   OOTRACEDBGA3 (\"Built MasterSlave determination Release (%s, %s)\\n\", \n                 call->callType, call->callToken);\n   ret = ooSendH245Msg (call, ph245msg);\n   if (ret != OO_OK) {\n      OOTRACEERR3 \n        (\"Error:Failed to enqueue MasterSlaveDeterminationRelease \"\n        \"message to outbound queue.(%s, %s)\\n\", call->callType, \n        call->callToken);\n   }\n   ooFreeH245Message (call, ph245msg);\n   return ret;\n}\n", "bug_type": null, "idx": 1986}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245ModeElementType (OOCTXT* pctxt, H245ModeElementType* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   OOCTXT lctxt;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"nonStandard\", -1);\n            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);\n            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"nonStandard\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"videoMode\", -1);\n            pvalue->u.videoMode = ALLOC_ASN1ELEM (pctxt, H245VideoMode);\n            stat = asn1PD_H245VideoMode (pctxt, pvalue->u.videoMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"videoMode\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"audioMode\", -1);\n            pvalue->u.audioMode = ALLOC_ASN1ELEM (pctxt, H245AudioMode);\n            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"audioMode\", -1);\n            break;\n         \n         case 3:\n            invokeStartElement (pctxt, \"dataMode\", -1);\n            pvalue->u.dataMode = ALLOC_ASN1ELEM (pctxt, H245DataMode);\n            stat = asn1PD_H245DataMode (pctxt, pvalue->u.dataMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"dataMode\", -1);\n            break;\n         \n         case 4:\n            invokeStartElement (pctxt, \"encryptionMode\", -1);\n            pvalue->u.encryptionMode = ALLOC_ASN1ELEM (pctxt, H245EncryptionMode);\n            stat = asn1PD_H245EncryptionMode (pctxt, pvalue->u.encryptionMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"encryptionMode\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 6;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n      copyContext (&lctxt, pctxt);\n      initContextBuffer (pctxt, openType.data, openType.numocts);\n      switch (pvalue->t) {\n         \n         case 6:\n            invokeStartElement (pctxt, \"h235Mode\", -1);\n            pvalue->u.h235Mode = ALLOC_ASN1ELEM (pctxt, H245H235Mode);\n            stat = asn1PD_H245H235Mode (pctxt, pvalue->u.h235Mode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"h235Mode\", -1);\n            break;\n         \n         case 7:\n            invokeStartElement (pctxt, \"multiplexedStreamMode\", -1);\n            pvalue->u.multiplexedStreamMode = ALLOC_ASN1ELEM (pctxt, H245MultiplexedStreamParameter);\n            stat = asn1PD_H245MultiplexedStreamParameter (pctxt, pvalue->u.multiplexedStreamMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"multiplexedStreamMode\", -1);\n            break;\n         \n         case 8:\n            invokeStartElement (pctxt, \"redundancyEncodingDTMode\", -1);\n            pvalue->u.redundancyEncodingDTMode = ALLOC_ASN1ELEM (pctxt, H245RedundancyEncodingDTMode);\n            stat = asn1PD_H245RedundancyEncodingDTMode (pctxt, pvalue->u.redundancyEncodingDTMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"redundancyEncodingDTMode\", -1);\n            break;\n         \n         case 9:\n            invokeStartElement (pctxt, \"multiplePayloadStreamMode\", -1);\n            pvalue->u.multiplePayloadStreamMode = ALLOC_ASN1ELEM (pctxt, H245MultiplePayloadStreamMode);\n            stat = asn1PD_H245MultiplePayloadStreamMode (pctxt, pvalue->u.multiplePayloadStreamMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"multiplePayloadStreamMode\", -1);\n            break;\n         \n         case 10:\n            invokeStartElement (pctxt, \"fecMode\", -1);\n            pvalue->u.fecMode = ALLOC_ASN1ELEM (pctxt, H245FECMode);\n            stat = asn1PD_H245FECMode (pctxt, pvalue->u.fecMode);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"fecMode\", -1);\n            break;\n         default:;\n      }\n      copyContext (pctxt, &lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1987}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void notify_cli_data_destroy(void *obj)\n{\n\tstruct notify_data *data = obj;\n\tao2_cleanup(data->endpoint);\n\tao2_cleanup(data->info);\n}\n", "bug_type": null, "idx": 1988}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245CompressionType (OOCTXT* pctxt, H245CompressionType* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"v42bis\", -1);\n            pvalue->u.v42bis = ALLOC_ASN1ELEM (pctxt, H245V42bis);\n            stat = asn1PD_H245V42bis (pctxt, pvalue->u.v42bis);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"v42bis\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 2;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 1989}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int find_by_name(void *obj, void *arg, void *data, int flags)\n{\n\tstruct ast_channel *target = obj;\n\tstruct pickup_by_name_args *args = data;\n\tif (args->chan == target) {\n\t\t\n\t\treturn 0;\n\t}\n\tast_channel_lock(target);\n\tif (!strncasecmp(ast_channel_name(target), args->name, args->len)\n\t\t&& ast_can_pickup(target)) {\n\t\t\n\t\treturn CMP_MATCH | CMP_STOP;\n\t}\n\tast_channel_unlock(target);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1990}
{"project": "Asterisk", "target": 0, "func": "};\nvoid ast_features_config_shutdown(void)\n{\n\tast_custom_function_unregister(&featuremap_function);\n\tast_custom_function_unregister(&feature_function);\n\tast_cli_unregister_multiple(cli_features_config, ARRAY_LEN(cli_features_config));\n\taco_info_destroy(&cfg_info);\n\tao2_global_obj_release(globals);\n}\n", "bug_type": null, "idx": 1991}
{"project": "Asterisk", "target": 0, "func": "enum hep_uuid_type hepv3_get_uuid_type(void)\n{\n\tRAII_VAR(struct module_config *, config, ao2_global_obj_ref(global_config), ao2_cleanup);\n\tif (!config) {\n\t\t\n\t\treturn HEP_UUID_TYPE_CALL_ID;\n\t}\n\treturn config->general->uuid_type;\n}\n", "bug_type": null, "idx": 1992}
{"project": "Asterisk", "target": 0, "func": " * \\brief Build message template from configuration */\nstatic int message_template_build(const char *name, struct ast_variable *var)\n{\n\tstruct minivm_template *template;\n\tint error = 0;\n\ttemplate = message_template_create(name);\n\tif (!template) {\n\t\tast_log(LOG_ERROR, \"Out of memory, can't allocate message template object %s.\\n\", name);\n\t\treturn -1;\n\t}\n\twhile (var) {\n\t\tast_debug(3, \"Configuring template option %s = \\\"%s\\\" for template %s\\n\", var->name, var->value, name);\n\t\tif (!strcasecmp(var->name, \"fromaddress\")) {\n\t\t\tast_copy_string(template->fromaddress, var->value, sizeof(template->fromaddress));\n\t\t} else if (!strcasecmp(var->name, \"fromemail\")) {\n\t\t\tast_copy_string(template->serveremail, var->value, sizeof(template->serveremail));\n\t\t} else if (!strcasecmp(var->name, \"subject\")) {\n\t\t\tast_copy_string(template->subject, var->value, sizeof(template->subject));\n\t\t} else if (!strcasecmp(var->name, \"locale\")) {\n\t\t\tast_copy_string(template->locale, var->value, sizeof(template->locale));\n\t\t} else if (!strcasecmp(var->name, \"attachmedia\")) {\n\t\t\ttemplate->attachment = ast_true(var->value);\n\t\t} else if (!strcasecmp(var->name, \"dateformat\")) {\n\t\t\tast_copy_string(template->dateformat, var->value, sizeof(template->dateformat));\n\t\t} else if (!strcasecmp(var->name, \"charset\")) {\n\t\t\tast_copy_string(template->charset, var->value, sizeof(template->charset));\n\t\t} else if (!strcasecmp(var->name, \"templatefile\")) {\n\t\t\tif (template->body) \n\t\t\t\tast_free(template->body);\n\t\t\ttemplate->body = message_template_parse_filebody(var->value);\n\t\t\tif (!template->body) {\n\t\t\t\tast_log(LOG_ERROR, \"Error reading message body definition file %s\\n\", var->value);\n\t\t\t\terror++;\n\t\t\t}\n\t\t} else if (!strcasecmp(var->name, \"messagebody\")) {\n\t\t\tif (template->body) \n\t\t\t\tast_free(template->body);\n\t\t\ttemplate->body = message_template_parse_emailbody(var->value);\n\t\t\tif (!template->body) {\n\t\t\t\tast_log(LOG_ERROR, \"Error parsing message body definition:\\n          %s\\n\", var->value);\n\t\t\t\terror++;\n\t\t\t}\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Unknown message template configuration option \\\"%s=%s\\\"\\n\", var->name, var->value);\n\t\t\terror++;\n\t\t}\n\t\tvar = var->next;\n\t}\n\tif (error)\n\t\tast_log(LOG_ERROR, \"-- %d errors found parsing message template definition %s\\n\", error, name);\n\tAST_LIST_LOCK(&message_templates);\n\tAST_LIST_INSERT_TAIL(&message_templates, template, list);\n\tAST_LIST_UNLOCK(&message_templates);\n\tglobal_stats.templates++;\n\treturn error;\n}\n", "bug_type": null, "idx": 1993}
{"project": "Asterisk", "target": 0, "func": " void speex_resampler_get_quality(SpeexResamplerState *st, int *quality)\n{\n   *quality = st->quality;\n}\n", "bug_type": null, "idx": 1994}
{"project": "Asterisk", "target": 0, "func": "static int select_entry(struct ast_channel *chan, const char *dialcontext, const struct directory_item *item, struct ast_flags *flags)\n{\n\tast_debug(1, \"Selecting '%s' - %s@%s\\n\", item->name, item->exten, S_OR(dialcontext, item->context));\n\tif (ast_test_flag(flags, OPT_FROMVOICEMAIL)) {\n\t\t\n\t\tast_channel_exten_set(chan, item->exten);\n\t} else if (ast_goto_if_exists(chan, S_OR(dialcontext, item->context), item->exten, 1)) {\n\t\tast_log(LOG_WARNING,\n\t\t\t\"Can't find extension '%s' in context '%s'.  \"\n\t\t\t\"Did you pass the wrong context to Directory?\\n\",\n\t\t\titem->exten, S_OR(dialcontext, item->context));\n\t\treturn -1;\n\t}\n\tpbx_builtin_setvar_helper(chan, \"DIRECTORY_RESULT\", \"SELECTED\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 1995}
{"project": "Asterisk", "target": 0, "func": "static char *app = \"PrivacyManager\";\nstatic int privacy_exec(struct ast_channel *chan, const char *data)\n{\n\tint res=0;\n\tint retries;\n\tint maxretries = 3;\n\tint minlength = 10;\n\tint x = 0;\n\tchar phone[30];\n\tchar *parse = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(maxretries);\n\t\tAST_APP_ARG(minlength);\n\t\tAST_APP_ARG(options);\n\t\tAST_APP_ARG(checkcontext);\n\t);\n\tif (ast_channel_caller(chan)->id.number.valid\n\t\t&& !ast_strlen_zero(ast_channel_caller(chan)->id.number.str)) {\n\t\tast_verb(3, \"CallerID number present: Skipping\\n\");\n\t} else {\n\t\t\n\t\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\t\tif ((res = ast_answer(chan))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tparse = ast_strdupa(data);\n\t\tAST_STANDARD_APP_ARGS(args, parse);\n\t\tif (!ast_strlen_zero(args.maxretries)) {\n\t\t\tif (sscanf(args.maxretries, \"%30d\", &x) == 1 && x > 0) {\n\t\t\t\tmaxretries = x;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid max retries argument: '%s'\\n\", args.maxretries);\n\t\t\t}\n\t\t}\n\t\tif (!ast_strlen_zero(args.minlength)) {\n\t\t\tif (sscanf(args.minlength, \"%30d\", &x) == 1 && x > 0) {\n\t\t\t\tminlength = x;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid min length argument: '%s'\\n\", args.minlength);\n\t\t\t}\n\t\t}\n\t\t\n\t\tres = ast_safe_sleep(chan, 1000);\n\t\tif (!res) {\n\t\t\tres = ast_streamfile(chan, \"privacy-unident\", ast_channel_language(chan));\n\t\t}\n\t\tif (!res) {\n\t\t\tres = ast_waitstream(chan, \"\");\n\t\t}\n\t\t\n\t\tfor (retries = 0; retries < maxretries; retries++) {\n\t\t\tif (!res) {\n\t\t\t\tres = ast_streamfile(chan, \"privacy-prompt\", ast_channel_language(chan));\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\tres = ast_waitstream(chan, \"\");\n\t\t\t}\n\t\t\tif (!res) {\n\t\t\t\tres = ast_readstring(chan, phone, sizeof(phone) - 1,  3200,  5000, \"#\");\n\t\t\t}\n\t\t\tif (res < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (strlen(phone) >= minlength ) {\n\t\t\t\t\n\t\t\t\tif (!ast_strlen_zero(args.checkcontext)) {\n\t\t\t\t\tif (!ast_exists_extension(NULL, args.checkcontext, phone, 1, NULL)) {\n\t\t\t\t\t\tres = ast_streamfile(chan, \"privacy-incorrect\", ast_channel_language(chan));\n\t\t\t\t\t\tif (!res) {\n\t\t\t\t\t\t\tres = ast_waitstream(chan, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres = ast_streamfile(chan, \"privacy-incorrect\", ast_channel_language(chan));\n\t\t\t\tif (!res) {\n\t\t\t\t\tres = ast_waitstream(chan, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ((retries < maxretries) && res >= 0) {\n\t\t\tres = ast_streamfile(chan, \"privacy-thankyou\", ast_channel_language(chan));\n\t\t\tif (!res) {\n\t\t\t\tres = ast_waitstream(chan, \"\");\n\t\t\t}\n\t\t\t\n\t\t\tast_channel_caller(chan)->id.name.presentation = AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED;\n\t\t\tast_channel_caller(chan)->id.number.presentation = AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED;\n\t\t\tast_channel_caller(chan)->id.number.plan = 0;\n\t\t\tast_set_callerid(chan, phone, \"Privacy Manager\", NULL);\n\t\t\tast_verb(3, \"Changed Caller*ID number to '%s'\\n\", phone);\n\t\t\tpbx_builtin_setvar_helper(chan, \"PRIVACYMGRSTATUS\", \"SUCCESS\");\n\t\t} else {\n\t\t\tpbx_builtin_setvar_helper(chan, \"PRIVACYMGRSTATUS\", \"FAILED\");\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1996}
{"project": "Asterisk", "target": 0, "func": "static struct sla_trunk_ref *create_trunk_ref(struct sla_trunk *trunk)\n{\n\tstruct sla_trunk_ref *trunk_ref;\n\tif (!(trunk_ref = ao2_alloc(sizeof(*trunk_ref), sla_trunk_ref_destructor))) {\n\t\treturn NULL;\n\t}\n\tao2_ref(trunk, 1);\n\ttrunk_ref->trunk = trunk;\n\treturn trunk_ref;\n}\n", "bug_type": null, "idx": 1997}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_region *region_find(void *ptr)\n{\n\tint hash;\n\tstruct ast_region *reg;\n\thash = HASH(ptr);\n\tfor (reg = regions[hash]; reg; reg = AST_LIST_NEXT(reg, node)) {\n\t\tif (reg->data == ptr) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn reg;\n}\n", "bug_type": null, "idx": 1998}
{"project": "Asterisk", "target": 0, "func": "static struct val *\nop_gt (struct val *a, struct val *b)\n{\n\tstruct val *r;\n\tif (isstring (a) || isstring (b)) {\n\t\tto_string (a);\n\t\tto_string (b);\n\t\tr = make_number ((FP___TYPE)(strcoll (a->u.s, b->u.s) > 0));\n\t} else {\n\t\t(void)to_number(a);\n\t\t(void)to_number(b);\n\t\tr = make_number ((FP___TYPE)(a->u.i > b->u.i));\n\t}\n\tfree_value (a);\n\tfree_value (b);\n\treturn r;\n}\n", "bug_type": null, "idx": 1999}
{"project": "Asterisk", "target": 0, "func": "void *ast_hashtab_remove_object_via_lookup_nolock(struct ast_hashtab *tab, void *obj)\n{\n\t\n\tunsigned int h;\n\tstruct ast_hashtab_bucket *b;\n\tif (!tab || !obj)\n\t\treturn 0;\n\th = (*tab->hash)(obj) % tab->hash_tab_size;\n\tfor (b = tab->array[h]; b; b = b->next) {\n\t\tif (!(*tab->compare)(obj, b->object)) {\n\t\t\tconst void *obj2;\n\t\t\tobj2 = ast_hashtab_remove_object_internal(tab, b, h);\n\t\t\treturn (void *) obj2; \n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2000}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void sig_ss7_open_media(struct sig_ss7_chan *p)\n{\n\tif (sig_ss7_callbacks.open_media) {\n\t\tsig_ss7_callbacks.open_media(p->chan_pvt);\n\t}\n}\n", "bug_type": null, "idx": 2001}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic char *__queues_show(struct mansession *s, int fd, int argc, const char * const *argv)\n{\n\tstruct call_queue *q;\n\tstruct ast_str *out = ast_str_alloca(512);\n\tint found = 0;\n\ttime_t now = time(NULL);\n\tstruct ao2_iterator queue_iter;\n\tstruct ao2_iterator mem_iter;\n\tif (argc != 2 && argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (argc == 3)\t{ \n\t\tif ((q = find_load_queue_rt_friendly(argv[2]))) {\n\t\t\tqueue_t_unref(q, \"Done with temporary pointer\");\n\t\t}\n\t} else if (ast_check_realtime(\"queues\")) {\n\t\t\n\t\tstruct ast_config *cfg = ast_load_realtime_multientry(\"queues\", \"name LIKE\", \"%\", SENTINEL);\n\t\tif (cfg) {\n\t\t\tchar *category = NULL;\n\t\t\twhile ((category = ast_category_browse(cfg, category))) {\n\t\t\t\tconst char *queuename = ast_variable_retrieve(cfg, category, \"name\");\n\t\t\t\tif ((q = find_load_queue_rt_friendly(queuename))) {\n\t\t\t\t\tqueue_t_unref(q, \"Done with temporary pointer\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_config_destroy(cfg);\n\t\t}\n\t}\n\tao2_lock(queues);\n\tqueue_iter = ao2_iterator_init(queues, AO2_ITERATOR_DONTLOCK);\n\twhile ((q = ao2_t_iterator_next(&queue_iter, \"Iterate through queues\"))) {\n\t\tfloat sl;\n\t\tfloat sl2;\n\t\tstruct call_queue *realtime_queue = NULL;\n\t\tao2_lock(q);\n\t\t\n\t\tif (argc < 3 && q->realtime) {\n\t\t\trealtime_queue = find_load_queue_rt_friendly(q->name);\n\t\t\tif (!realtime_queue) {\n\t\t\t\tao2_unlock(q);\n\t\t\t\tqueue_t_unref(q, \"Done with iterator\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue_t_unref(realtime_queue, \"Queue is already in memory\");\n\t\t}\n\t\tif (argc == 3 && strcasecmp(q->name, argv[2])) {\n\t\t\tao2_unlock(q);\n\t\t\tqueue_t_unref(q, \"Done with iterator\");\n\t\t\tcontinue;\n\t\t}\n\t\tfound = 1;\n\t\tast_str_set(&out, 0, \"%s has %d calls (max \", q->name, q->count);\n\t\tif (q->maxlen) {\n\t\t\tast_str_append(&out, 0, \"%d\", q->maxlen);\n\t\t} else {\n\t\t\tast_str_append(&out, 0, \"unlimited\");\n\t\t}\n\t\tsl = 0;\n\t\tsl2 = 0;\n\t\tif (q->callscompleted > 0) {\n\t\t\tsl = 100 * ((float) q->callscompletedinsl / (float) q->callscompleted);\n\t\t}\n\t\tif (q->callscompleted + q->callsabandoned > 0) {\n\t\t\tsl2 =100 * (((float)q->callsabandonedinsl + (float)q->callscompletedinsl) / ((float)q->callsabandoned + (float)q->callscompleted));\n\t\t}\n\t\tast_str_append(&out, 0, \") in '%s' strategy (%ds holdtime, %ds talktime), W:%d, C:%d, A:%d, SL:%2.1f%%, SL2:%2.1f%% within %ds\",\n\t\t\tint2strat(q->strategy), q->holdtime, q->talktime, q->weight, q->callscompleted, q->callsabandoned, sl, sl2, q->servicelevel);\n\t\tdo_print(s, fd, ast_str_buffer(out));\n\t\tif (!ao2_container_count(q->members)) {\n\t\t\tdo_print(s, fd, \"   No Members\");\n\t\t} else {\n\t\t\tstruct member *mem;\n\t\t\tdo_print(s, fd, \"   Members: \");\n\t\t\tmem_iter = ao2_iterator_init(q->members, 0);\n\t\t\twhile ((mem = ao2_iterator_next(&mem_iter))) {\n\t\t\t\tast_str_set(&out, 0, \"      %s\", mem->membername);\n\t\t\t\tif (strcasecmp(mem->membername, mem->interface)) {\n\t\t\t\t\tast_str_append(&out, 0, \" (%s\", mem->interface);\n\t\t\t\t\tif (!ast_strlen_zero(mem->state_interface)\n\t\t\t\t\t\t&& strcmp(mem->state_interface, mem->interface)) {\n\t\t\t\t\t\tast_str_append(&out, 0, \" from %s\", mem->state_interface);\n\t\t\t\t\t}\n\t\t\t\t\tast_str_append(&out, 0, \")\");\n\t\t\t\t}\n\t\t\t\tif (mem->penalty) {\n\t\t\t\t\tast_str_append(&out, 0, \" with penalty %d\", mem->penalty);\n\t\t\t\t}\n\t\t\t\tast_str_append(&out, 0, \" (ringinuse %s)\", mem->ringinuse ? \"enabled\" : \"disabled\");\n\t\t\t\tast_str_append(&out, 0, \"%s%s%s%s%s%s%s%s%s\",\n\t\t\t\t\tmem->dynamic ? ast_term_color(COLOR_CYAN, COLOR_BLACK) : \"\", mem->dynamic ? \" (dynamic)\" : \"\", ast_term_reset(),\n\t\t\t\t\tmem->realtime ? ast_term_color(COLOR_MAGENTA, COLOR_BLACK) : \"\", mem->realtime ? \" (realtime)\" : \"\", ast_term_reset(),\n\t\t\t\t\tmem->starttime ? ast_term_color(COLOR_BROWN, COLOR_BLACK) : \"\", mem->starttime ? \" (in call)\" : \"\", ast_term_reset());\n\t\t\t\tif (mem->paused) {\n\t\t\t\t\tif (ast_strlen_zero(mem->reason_paused)) {\n\t\t\t\t\t\tast_str_append(&out, 0, \" %s(paused was %ld secs ago)%s\",\n\t\t\t\t\t\t\tast_term_color(COLOR_BROWN, COLOR_BLACK), (long) (time(NULL) - mem->lastpause), ast_term_reset());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_str_append(&out, 0, \" %s(paused:%s was %ld secs ago)%s\", ast_term_color(COLOR_BROWN, COLOR_BLACK),\n\t\t\t\t\t\t\tmem->reason_paused,  (long) (time(NULL) - mem->lastcall), ast_term_reset());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tast_str_append(&out, 0, \" (%s%s%s)\",\n\t\t\t\t\tast_term_color(\n\t\t\t\t\t\tmem->status == AST_DEVICE_UNAVAILABLE || mem->status == AST_DEVICE_UNKNOWN ?\n\t\t\t\t\t\t\tCOLOR_RED : COLOR_GREEN, COLOR_BLACK),\n\t\t\t\t\t\tast_devstate2str(mem->status), ast_term_reset());\n\t\t\t\tif (mem->calls) {\n\t\t\t\t\tast_str_append(&out, 0, \" has taken %d calls (last was %ld secs ago)\",\n\t\t\t\t\t\tmem->calls, (long) (time(NULL) - mem->lastcall));\n\t\t\t\t} else {\n\t\t\t\t\tast_str_append(&out, 0, \" has taken no calls yet\");\n\t\t\t\t}\n\t\t\t\tdo_print(s, fd, ast_str_buffer(out));\n\t\t\t\tao2_ref(mem, -1);\n\t\t\t}\n\t\t\tao2_iterator_destroy(&mem_iter);\n\t\t}\n\t\tif (!q->head) {\n\t\t\tdo_print(s, fd, \"   No Callers\");\n\t\t} else {\n\t\t\tstruct queue_ent *qe;\n\t\t\tint pos = 1;\n\t\t\tdo_print(s, fd, \"   Callers: \");\n\t\t\tfor (qe = q->head; qe; qe = qe->next) {\n\t\t\t\tast_str_set(&out, 0, \"      %d. %s (wait: %ld:%2.2ld, prio: %d)\",\n\t\t\t\t\tpos++, ast_channel_name(qe->chan), (long) (now - qe->start) / 60,\n\t\t\t\t\t(long) (now - qe->start) % 60, qe->prio);\n\t\t\t\tdo_print(s, fd, ast_str_buffer(out));\n\t\t\t}\n\t\t}\n\t\tdo_print(s, fd, \"\");\t\n\t\tao2_unlock(q);\n\t\tqueue_t_unref(q, \"Done with iterator\"); \n\t}\n\tao2_iterator_destroy(&queue_iter);\n\tao2_unlock(queues);\n\tif (!found) {\n\t\tif (argc == 3) {\n\t\t\tast_str_set(&out, 0, \"No such queue: %s.\", argv[2]);\n\t\t} else {\n\t\t\tast_str_set(&out, 0, \"No queues.\");\n\t\t}\n\t\tdo_print(s, fd, ast_str_buffer(out));\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2002}
{"project": "Asterisk", "target": 0, "func": "static struct ast_channel *prepare_bridge_media_channel(const char *type)\n{\n\tRAII_VAR(struct ast_format_cap *, cap, NULL, ao2_cleanup);\n\tstruct ast_channel *chan;\n\tcap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\tif (!cap) {\n\t\treturn NULL;\n\t}\n\tast_format_cap_append(cap, ast_format_slin, 0);\n\tchan = ast_request(type, cap, NULL, NULL, \"ARI\", NULL);\n\tif (!chan) {\n\t\treturn NULL;\n\t}\n\tif (stasis_app_channel_unreal_set_internal(chan)) {\n\t\tast_channel_cleanup(chan);\n\t\treturn NULL;\n\t}\n\treturn chan;\n}\n", "bug_type": null, "idx": 2003}
{"project": "Asterisk", "target": 0, "func": "static void sub_stop_silence(struct unistimsession *pte, struct unistim_subchannel *sub)\n{\n\t\n\tif (pte->device->silence_generator) {\n\t\tif (unistimdebug) {\n\t\t\tast_verb(0, \"Stopping silence generator\\n\");\n\t\t}\n\t\tif (sub->owner) {\n\t\t\tast_channel_stop_silence_generator(sub->owner, pte->device->silence_generator);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Trying to stop silence generator on a null channel!\\n\");\n\t\t}\n\t\tpte->device->silence_generator = NULL;\n\t}\n}\n", "bug_type": null, "idx": 2004}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_test_unregister(threadpool_push);\n\tast_test_unregister(threadpool_initial_threads);\n\tast_test_unregister(threadpool_thread_creation);\n\tast_test_unregister(threadpool_thread_destruction);\n\tast_test_unregister(threadpool_thread_timeout);\n\tast_test_unregister(threadpool_thread_timeout_thrash);\n\tast_test_unregister(threadpool_one_task_one_thread);\n\tast_test_unregister(threadpool_one_thread_one_task);\n\tast_test_unregister(threadpool_one_thread_multiple_tasks);\n\tast_test_unregister(threadpool_auto_increment);\n\tast_test_unregister(threadpool_max_size);\n\tast_test_unregister(threadpool_reactivation);\n\tast_test_unregister(threadpool_task_distribution);\n\tast_test_unregister(threadpool_more_destruction);\n\tast_test_unregister(threadpool_serializer);\n\tast_test_unregister(threadpool_serializer_dupe);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2005}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_register_publish_handler(struct ast_sip_publish_handler *handler)\n{\n\tif (ast_strlen_zero(handler->event_name)) {\n\t\tast_log(LOG_ERROR, \"No event package specified for publish handler. Cannot register\\n\");\n\t\treturn -1;\n\t}\n\tif (!(handler->publications = ao2_container_alloc(PUBLICATIONS_BUCKETS,\n\t\tpublication_hash_fn, publication_cmp_fn))) {\n\t\tast_log(LOG_ERROR, \"Could not allocate publications container for event '%s'\\n\",\n\t\t\thandler->event_name);\n\t\treturn -1;\n\t}\n\tpublish_add_handler(handler);\n\tast_module_ref(ast_module_info->self);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2006}
{"project": "Asterisk", "target": 0, "func": "struct ast_attended_transfer_message *ast_attended_transfer_message_create(int is_external,\n\t\tstruct ast_channel *to_transferee, struct ast_bridge *transferee_bridge,\n\t\tstruct ast_channel *to_transfer_target, struct ast_bridge *target_bridge,\n\t\tstruct ast_channel *transferee, struct ast_channel *transfer_target)\n{\n\tstruct ast_attended_transfer_message *transfer_msg;\n\ttransfer_msg = ao2_alloc(sizeof(*transfer_msg), attended_transfer_dtor);\n\tif (!transfer_msg) {\n\t\treturn NULL;\n\t}\n\tif (bridge_channel_snapshot_pair_init(to_transferee, transferee_bridge, &transfer_msg->to_transferee) ||\n\t\t\tbridge_channel_snapshot_pair_init(to_transfer_target, target_bridge, &transfer_msg->to_transfer_target)) {\n\t\tao2_cleanup(transfer_msg);\n\t\treturn NULL;\n\t}\n\tif (transferee) {\n\t\ttransfer_msg->transferee = ast_channel_snapshot_get_latest(ast_channel_uniqueid(transferee));\n\t\tif (!transfer_msg->transferee) {\n\t\t\tao2_cleanup(transfer_msg);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (transferee_bridge) {\n\t\ttransferee = ast_bridge_peer(transferee_bridge, to_transferee);\n\t\tif (transferee) {\n\t\t\ttransfer_msg->transferee = ast_channel_snapshot_get_latest(ast_channel_uniqueid(transferee));\n\t\t\tao2_cleanup(transferee);\n\t\t\tif (!transfer_msg->transferee) {\n\t\t\t\tao2_cleanup(transfer_msg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (transfer_target) {\n\t\ttransfer_msg->target = ast_channel_snapshot_get_latest(ast_channel_uniqueid(transfer_target));\n\t\tif (!transfer_msg->target) {\n\t\t\tao2_cleanup(transfer_msg);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (target_bridge) {\n\t\ttransfer_target = ast_bridge_peer(target_bridge, to_transfer_target);\n\t\tif (transfer_target) {\n\t\t\ttransfer_msg->target = ast_channel_snapshot_get_latest(ast_channel_uniqueid(transfer_target));\n\t\t\tao2_cleanup(transfer_target);\n\t\t\tif (!transfer_msg->target) {\n\t\t\t\tao2_cleanup(transfer_msg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn transfer_msg;\n}\n}\nstruct ast_attended_transfer_message *ast_attended_transfer_message_create(int is_external,\n\t\tstruct ast_channel *to_transferee, struct ast_bridge *transferee_bridge,\n\t\tstruct ast_channel *to_transfer_target, struct ast_bridge *target_bridge,\n\t\tstruct ast_channel *transferee, struct ast_channel *transfer_target)\n{\n\tstruct ast_attended_transfer_message *transfer_msg;\n\ttransfer_msg = ao2_alloc(sizeof(*transfer_msg), attended_transfer_dtor);\n\tif (!transfer_msg) {\n\t\treturn NULL;\n\t}\n", "bug_type": null, "idx": 2007}
{"project": "Asterisk", "target": 0, "func": "int ast_sdp_state_reset(struct ast_sdp_state *sdp_state)\n{\n\tast_assert(sdp_state != NULL);\n\tast_sdp_free(sdp_state->local_sdp);\n\tsdp_state->local_sdp = NULL;\n\tset_proposed_capabilities(sdp_state, NULL);\n\tsdp_state->role = SDP_ROLE_NOT_SET;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2008}
{"project": "Asterisk", "target": 0, "func": "ooH323EpCapability* ooIsVideoDataTypeSupported\n   (OOH323CallData *call, H245VideoCapability* pVideoCap, int dir)\n{\n   switch(pVideoCap->t)   \n   {\n   case T_H245VideoCapability_h263VideoCapability:\n      if(pVideoCap->u.h263VideoCapability->m.sqcifMPIPresent)\n         return ooIsVideoDataTypeH263Supported(call, \n                    pVideoCap->u.h263VideoCapability, dir, OO_PICFORMAT_SQCIF);\n      else if(pVideoCap->u.h263VideoCapability->m.qcifMPIPresent)\n         return ooIsVideoDataTypeH263Supported(call, \n                     pVideoCap->u.h263VideoCapability, dir, OO_PICFORMAT_QCIF);\n      else if(pVideoCap->u.h263VideoCapability->m.cifMPIPresent)\n        return ooIsVideoDataTypeH263Supported(call, \n                      pVideoCap->u.h263VideoCapability, dir, OO_PICFORMAT_CIF);\n      else if(pVideoCap->u.h263VideoCapability->m.cif4MPIPresent)\n        return ooIsVideoDataTypeH263Supported(call, \n                     pVideoCap->u.h263VideoCapability, dir, OO_PICFORMAT_CIF4);\n      else if(pVideoCap->u.h263VideoCapability->m.cif16MPIPresent)\n        return ooIsVideoDataTypeH263Supported(call, \n                    pVideoCap->u.h263VideoCapability, dir, OO_PICFORMAT_CIF16);\n      break;  \n   case T_H245VideoCapability_nonStandard:\n   case T_H245VideoCapability_h261VideoCapability:\n   case T_H245VideoCapability_h262VideoCapability:\n   case T_H245VideoCapability_is11172VideoCapability:\n   case T_H245VideoCapability_genericVideoCapability:\n   case T_H245VideoCapability_extElem1:\n   default:\n     OOTRACEDBGA1(\"Unsupported video capability type in \"\n                  \"ooIsVideoDataTypeSupported\\n\");\n      return NULL;\n   }\n   return NULL;\n}\n", "bug_type": null, "idx": 2009}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ldap_table_config_add_attribute(struct ldap_table_config *table_config,\n\tconst char *attribute_name, const char *attribute_value)\n{\n\tstruct ast_variable *var;\n\tif (ast_strlen_zero(attribute_name) || ast_strlen_zero(attribute_value)) {\n\t\treturn;\n\t}\n\tif (!(var = ast_variable_new(attribute_name, attribute_value, table_config->table_name))) {\n\t\treturn;\n\t}\n\tif (table_config->attributes) {\n\t\tvar->next = table_config->attributes;\n\t}\n\ttable_config->attributes = var;\n}\n", "bug_type": null, "idx": 2010}
{"project": "Asterisk", "target": 0, "func": "static const void *opus_get(const struct ast_format *format, const char *name)\n{\n\tstruct opus_attr *attr = ast_format_get_attribute_data(format);\n\tint *val = NULL;\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tif (!strcasecmp(name, CODEC_OPUS_ATTR_DATA)) {\n\t\treturn ao2_bump(attr->data);\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PLAYBACK_RATE)) {\n\t\tval = &attr->maxplayrate;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_MAX_CAPTURE_RATE)) {\n\t\tval = &attr->spropmaxcapturerate;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PTIME)) {\n\t\tval = &attr->maxptime;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_PTIME)) {\n\t\tval = &attr->ptime;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_AVERAGE_BITRATE)) {\n\t\tval = &attr->maxbitrate;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_STEREO)) {\n\t\tval = &attr->stereo;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_STEREO)) {\n\t\tval = &attr->spropstereo;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_CBR)) {\n\t\tval = &attr->cbr;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_FEC)) {\n\t\tval = &attr->fec;\n\t} else if (!strcasecmp(name, CODEC_OPUS_ATTR_DTX)) {\n\t\tval = &attr->dtx;\n\t} else {\n\t\tast_log(LOG_WARNING, \"unknown attribute type %s\\n\", name);\n\t}\n\treturn val;\n}\n", "bug_type": null, "idx": 2011}
{"project": "Asterisk", "target": 0, "func": "int ooSocketSelect(int nfds, fd_set *readfds, fd_set *writefds, \n                     fd_set *exceptfds, struct timeval * timeout)\n{\n   int ret;   \n#if defined (_WIN32)\n  ret = select(nfds, readfds, writefds, exceptfds, \n             (const struct timeval *) timeout);\n#else\n   ret = select(nfds, readfds, writefds, exceptfds, timeout);\n#endif\n   return ret;\n}\n", "bug_type": null, "idx": 2012}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void clear_stimulus_queue(struct attended_transfer_properties *props)\n{\n\tstruct stimulus_list *list;\n\tSCOPED_AO2LOCK(lock, props);\n\twhile ((list = AST_LIST_REMOVE_HEAD(&props->stimulus_queue, next))) {\n\t\tast_free(list);\n\t}\n}\n", "bug_type": null, "idx": 2013}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_frame *h264_encap(struct fbuf_t *b, int mtu,\n\tstruct ast_frame **tail)\n{\n\tstruct ast_frame *f = NULL, *cur = NULL, *first = NULL;\n\tuint8_t *d, *start = b->data;\n\tuint8_t *end = start + b->used;\n\t\n#define HAVE_NAL(x) (x[-4] == 0 && x[-3] == 0 && x[-2] == 0 && x[-1] == 1)\n\tfor (start += 4; start < end; start++) {\n\t\tint ty = start[0] & 0x1f;\n\t\tif (HAVE_NAL(start) && ty != 0 && ty != 31)\n\t\t\tbreak;\n\t}\n\t\n\t\n   for (;start < end - 4; start = d) {\n\tint size;\t\t\n\tuint8_t hdr[2];\t\t\n\tint ty = 0;\n\t\n\tfor (d = start + 4; d < end; d++) {\n\t\tty = d[0] & 0x1f;\n\t\tif (HAVE_NAL(d))\n\t\t\tbreak;\t\n\t}\n\t\n\tif (d >= end) {\t\n\t\td = end + 4;\n\t} else if (ty == 0 || ty == 31) { \n\t\tast_log(LOG_WARNING, \"skip invalid nal type %d at %d of %d\\n\",\n\t\t\tty, d - (uint8_t *)b->data, b->used);\n\t\tcontinue;\n\t}\n\tsize = d - start - 4;\t\n\tif (size < mtu) {\t \n\t\t \n\t\tf = create_video_frame(start, d - 4, AST_FORMAT_H264, 0, cur);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!first)\n\t\t\tfirst = f;\n\t\tcur = f;\n\t\tcontinue;\n\t}\n\t \n\thdr[0] = (*start & 0xe0) | 28;\t\n\thdr[1] = (*start++ & 0x1f) | 0x80 ;\t\n\tsize--;\t\t\n\twhile (size) {\n\t\tuint8_t *data;\n\t\tint frag_size = MIN(size, mtu);\n\t\tf = create_video_frame(start, start+frag_size, AST_FORMAT_H264, 2, cur);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tsize -= frag_size;\t\n\t\tstart += frag_size;\n\t\tdata = f->data.ptr;\n\t\tdata[0] = hdr[0];\n\t\tdata[1] = hdr[1] | (size == 0 ? 0x40 : 0);\t\n\t\thdr[1] &= ~0x80;\t\n\t\tif (!first)\n\t\t\tfirst = f;\n\t\tcur = f;\n\t}\n    }\n\tif (cur)\n\t\tcur->subclass |= 1;      \n\t*tail = cur;\n\treturn first;\n}\n", "bug_type": null, "idx": 2014}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int cc_do_state_change(void *datap)\n{\n\tstruct cc_state_change_args *args = datap;\n\tstruct cc_core_instance *core_instance;\n\tenum cc_state previous_state;\n\tint res;\n\tast_log_dynamic_level(cc_logger_level, \"Core %d: State change to %u requested. Reason: %s\\n\",\n\t\t\targs->core_id, args->state, args->debug);\n\tcore_instance = args->core_instance;\n\tif (!is_state_change_valid(core_instance->current_state, args->state, core_instance->agent)) {\n\t\tast_log_dynamic_level(cc_logger_level, \"Core %d: Invalid state change requested. Cannot go from %s to %s\\n\",\n\t\t\t\targs->core_id, cc_state_to_string(core_instance->current_state), cc_state_to_string(args->state));\n\t\tif (args->state == CC_CALLER_REQUESTED) {\n\t\t\t\n\t\t\tcore_instance->agent->callbacks->respond(core_instance->agent,\n\t\t\t\tAST_CC_AGENT_RESPONSE_FAILURE_INVALID);\n\t\t}\n\t\tast_free(args);\n\t\tcc_unref(core_instance, \"Unref core instance from when it was found earlier\");\n\t\treturn -1;\n\t}\n\t\n\tprevious_state = core_instance->current_state;\n\tcore_instance->current_state = args->state;\n\tres = state_change_funcs[core_instance->current_state](core_instance, args, previous_state);\n\t\n\tif (!res && !strcmp(core_instance->agent->callbacks->type, \"generic\")) {\n\t\tccss_notify_device_state_change(core_instance->agent->device_name, core_instance->current_state);\n\t}\n\tast_free(args);\n\tcc_unref(core_instance, \"Unref since state change has completed\"); \n\treturn res;\n}\n", "bug_type": null, "idx": 2015}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245H223Capability (OOCTXT* pctxt, H245H223Capability* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   \n   invokeStartElement (pctxt, \"transportWithI_frames\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->transportWithI_frames);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->transportWithI_frames);\n   invokeEndElement (pctxt, \"transportWithI_frames\", -1);\n   \n   invokeStartElement (pctxt, \"videoWithAL1\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->videoWithAL1);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->videoWithAL1);\n   invokeEndElement (pctxt, \"videoWithAL1\", -1);\n   \n   invokeStartElement (pctxt, \"videoWithAL2\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->videoWithAL2);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->videoWithAL2);\n   invokeEndElement (pctxt, \"videoWithAL2\", -1);\n   \n   invokeStartElement (pctxt, \"videoWithAL3\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->videoWithAL3);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->videoWithAL3);\n   invokeEndElement (pctxt, \"videoWithAL3\", -1);\n   \n   invokeStartElement (pctxt, \"audioWithAL1\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->audioWithAL1);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->audioWithAL1);\n   invokeEndElement (pctxt, \"audioWithAL1\", -1);\n   \n   invokeStartElement (pctxt, \"audioWithAL2\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->audioWithAL2);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->audioWithAL2);\n   invokeEndElement (pctxt, \"audioWithAL2\", -1);\n   \n   invokeStartElement (pctxt, \"audioWithAL3\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->audioWithAL3);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->audioWithAL3);\n   invokeEndElement (pctxt, \"audioWithAL3\", -1);\n   \n   invokeStartElement (pctxt, \"dataWithAL1\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->dataWithAL1);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->dataWithAL1);\n   invokeEndElement (pctxt, \"dataWithAL1\", -1);\n   \n   invokeStartElement (pctxt, \"dataWithAL2\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->dataWithAL2);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->dataWithAL2);\n   invokeEndElement (pctxt, \"dataWithAL2\", -1);\n   \n   invokeStartElement (pctxt, \"dataWithAL3\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->dataWithAL3);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->dataWithAL3);\n   invokeEndElement (pctxt, \"dataWithAL3\", -1);\n   \n   invokeStartElement (pctxt, \"maximumAl2SDUSize\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAl2SDUSize, 0U, 65535U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->maximumAl2SDUSize);\n   invokeEndElement (pctxt, \"maximumAl2SDUSize\", -1);\n   \n   invokeStartElement (pctxt, \"maximumAl3SDUSize\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAl3SDUSize, 0U, 65535U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->maximumAl3SDUSize);\n   invokeEndElement (pctxt, \"maximumAl3SDUSize\", -1);\n   \n   invokeStartElement (pctxt, \"maximumDelayJitter\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->maximumDelayJitter, 0U, 1023U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->maximumDelayJitter);\n   invokeEndElement (pctxt, \"maximumDelayJitter\", -1);\n   \n   invokeStartElement (pctxt, \"h223MultiplexTableCapability\", -1);\n   stat = asn1PD_H245H223Capability_h223MultiplexTableCapability (pctxt, &pvalue->h223MultiplexTableCapability);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"h223MultiplexTableCapability\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 6 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.maxMUXPDUSizeCapabilityPresent = 1;\n                     invokeStartElement (pctxt, \"maxMUXPDUSizeCapability\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->maxMUXPDUSizeCapability);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->maxMUXPDUSizeCapability);\n                     invokeEndElement (pctxt, \"maxMUXPDUSizeCapability\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.nsrpSupportPresent = 1;\n                     invokeStartElement (pctxt, \"nsrpSupport\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->nsrpSupport);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->nsrpSupport);\n                     invokeEndElement (pctxt, \"nsrpSupport\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.mobileOperationTransmitCapabilityPresent = 1;\n                     invokeStartElement (pctxt, \"mobileOperationTransmitCapability\", -1);\n                     stat = asn1PD_H245H223Capability_mobileOperationTransmitCapability (pctxt, &pvalue->mobileOperationTransmitCapability);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"mobileOperationTransmitCapability\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.h223AnnexCCapabilityPresent = 1;\n                     invokeStartElement (pctxt, \"h223AnnexCCapability\", -1);\n                     stat = asn1PD_H245H223AnnexCCapability (pctxt, &pvalue->h223AnnexCCapability);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"h223AnnexCCapability\", -1);\n                     break;\n                  case 4:\n                     pvalue->m.bitRatePresent = 1;\n                     invokeStartElement (pctxt, \"bitRate\", -1);\n                     stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 19200U);\n                     if (stat != ASN_OK) return stat;\n                     invokeUIntValue (pctxt, pvalue->bitRate);\n                     invokeEndElement (pctxt, \"bitRate\", -1);\n                     break;\n                  case 5:\n                     pvalue->m.mobileMultilinkFrameCapabilityPresent = 1;\n                     invokeStartElement (pctxt, \"mobileMultilinkFrameCapability\", -1);\n                     stat = asn1PD_H245H223Capability_mobileMultilinkFrameCapability (pctxt, &pvalue->mobileMultilinkFrameCapability);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"mobileMultilinkFrameCapability\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2016}
{"project": "Asterisk", "target": 0, "func": "static int adsi_load_soft_key(unsigned char *buf, int key, const char *llabel, const char *slabel, char *ret, int data)\n{\n\tint bytes = 0;\n\t\n\tif ((key < 2) || (key > 33)) {\n\t\treturn -1;\n\t}\n\tbuf[bytes++] = ADSI_LOAD_SOFTKEY;\n\t\n\tbytes++;\n\t\n\tbuf[bytes++] = key;\n\t\n\tbytes += ccopy(buf + bytes, (const unsigned char *)llabel, 18);\n\t\n\tbuf[bytes++] = 0xff;\n\t\n\tbytes += ccopy(buf + bytes, (const unsigned char *)slabel, 7);\n\t\n\tif (ret) {\n\t\t\n\t\tbuf[bytes++] = 0xff;\n\t\tif (data) {\n\t\t\tbuf[bytes++] = ADSI_SWITCH_TO_DATA2;\n\t\t}\n\t\t\n\t\tbytes += ccopy(buf + bytes, (const unsigned char *)ret, 20);\n\t}\n\t\n\tbuf[1] = bytes - 2;\n\treturn bytes;\n}\n", "bug_type": null, "idx": 2017}
{"project": "Asterisk", "target": 0, "func": "#endif\nint ast_iostream_get_fd(struct ast_iostream *stream)\n{\n\treturn stream->fd;\n}\n", "bug_type": null, "idx": 2018}
{"project": "Asterisk", "target": 0, "func": "static void rebuild_channels(newtComponent c)\n{\n\tvoid *prev = NULL;\n\tstruct ast_chan *chan;\n\tchar tmpn[sizeof(chan->name) + sizeof(chan->callerid) + 3 - 1];\n\tchar tmp[256];\n\tint x=0;\n\tprev = newtListboxGetCurrent(c);\n\tnewtListboxClear(c);\n\tAST_LIST_TRAVERSE(&chans, chan, list) {\n\t\tsnprintf(tmpn, sizeof(tmpn), \"%s (%s)\", chan->name, chan->callerid);\n\t\tif (strlen(chan->exten))\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%-30s %8s -> %s@%s:%s\",\n\t\t\t\ttmpn, chan->state,\n\t\t\t\tchan->exten, chan->context, chan->priority);\n\t\telse\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%-30s %8s\",\n\t\t\t\ttmpn, chan->state);\n\t\tnewtListboxAppendEntry(c, tmp, chan);\n\t\tx++;\n\t}\n\tif (!x)\n\t\tnewtListboxAppendEntry(c, \" << No Active Channels >> \", NULL);\n\tnewtListboxSetCurrentByKey(c, prev);\n}\n", "bug_type": null, "idx": 2019}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int PresentedNumberUnscreened_to_misdn_pres(unsigned type)\n{\n\tint presentation;\n\tswitch (type) {\n\tdefault:\n\tcase 0:\n\t\tpresentation = 0;\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tpresentation = 1;\n\t\tbreak;\n\tcase 2:\n\t\tpresentation = 2;\n\t\tbreak;\n\t}\n\treturn presentation;\n}\n", "bug_type": null, "idx": 2020}
{"project": "Asterisk", "target": 0, "func": "static int namedgroup_match(void *obj, void *arg, int flags)\n{\n\tvoid *match;\n\tmatch = ao2_find(arg, obj, OBJ_POINTER);\n\tao2_cleanup(match);\n\treturn match ? CMP_MATCH | CMP_STOP : 0;\n}\n", "bug_type": null, "idx": 2021}
{"project": "Asterisk", "target": 0, "func": "\n int analys_(real *speech, integer *voice, integer \n\t*pitch, real *rms, real *rc, struct lpc10_encoder_state *st)\n{\n    \n    static integer tau[60] = { 20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,\n\t    35,36,37,38,39,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,\n\t    74,76,78,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,\n\t    140,144,148,152,156 };\n    static integer buflim[4] = { 181,720,25,720 };\n    static real precoef = .9375f;\n    \n    integer i__1;\n    \n    real amdf[60];\n    integer half;\n    real abuf[156];\n    real *bias;\n    extern  int tbdm_(real *, integer *, integer *, integer *,\n\t     real *, integer *, integer *, integer *);\n    integer *awin;\n    integer midx, ewin[6]\t;\n    real ivrc[2], temp;\n    real *zpre;\n    integer *vwin;\n    integer i__, j, lanal;\n    extern  int rcchk_(integer *, real *, real *), mload_(\n\t    integer *, integer *, integer *, real *, real *, real *);\n    real *inbuf, *pebuf;\n    real *lpbuf, *ivbuf;\n    real *rcbuf;\n    integer *osbuf;\n    extern  int onset_(real *, integer *, integer *, integer *\n\t    , integer *, integer *, integer *, struct lpc10_encoder_state *);\n    integer *osptr;\n    extern int dcbias_(integer *, real *, real *);\n    integer ipitch;\n    integer *obound;\n    extern  int preemp_(real *, real *, integer *, real *, \n\t    real *), voicin_(integer *, real *, real *, integer *, integer *, \n\t    real *, real *, integer *, real *, integer *, integer *, integer *,\n\t    struct lpc10_encoder_state *);\n    integer *voibuf;\n    integer mintau;\n    real *rmsbuf;\n    extern  int lpfilt_(real *, real *, integer *, integer *),\n\t     ivfilt_(real *, real *, integer *, integer *, real *), energy_(\n\t    integer *, real *, real *), invert_(integer *, real *, real *, \n\t    real *);\n    integer minptr, maxptr;\n    extern  int dyptrk_(real *, integer *, integer *, integer \n\t    *, integer *, integer *, struct lpc10_encoder_state *);\n    real phi[100]\t, psi[10];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    if (speech) {\n\t--speech;\n\t}\n    if (voice) {\n\t--voice;\n\t}\n    if (rc) {\n\t--rc;\n\t}\n    \n\n\n\n\n    inbuf = &(st->inbuf[0]);\n    pebuf = &(st->pebuf[0]);\n    lpbuf = &(st->lpbuf[0]);\n    ivbuf = &(st->ivbuf[0]);\n    bias = &(st->bias);\n    osbuf = &(st->osbuf[0]);\n    osptr = &(st->osptr);\n    obound = &(st->obound[0]);\n    vwin = &(st->vwin[0]);\n    awin = &(st->awin[0]);\n    voibuf = &(st->voibuf[0]);\n    rmsbuf = &(st->rmsbuf[0]);\n    rcbuf = &(st->rcbuf[0]);\n    zpre = &(st->zpre);\n    i__1 = 720 - contrl_1.lframe;\n    for (i__ = 181; i__ <= i__1; ++i__) {\n\tinbuf[i__ - 181] = inbuf[contrl_1.lframe + i__ - 181];\n\tpebuf[i__ - 181] = pebuf[contrl_1.lframe + i__ - 181];\n    }\n    i__1 = 540 - contrl_1.lframe;\n    for (i__ = 229; i__ <= i__1; ++i__) {\n\tivbuf[i__ - 229] = ivbuf[contrl_1.lframe + i__ - 229];\n    }\n    i__1 = 720 - contrl_1.lframe;\n    for (i__ = 25; i__ <= i__1; ++i__) {\n\tlpbuf[i__ - 25] = lpbuf[contrl_1.lframe + i__ - 25];\n    }\n    j = 1;\n    i__1 = (*osptr) - 1;\n    for (i__ = 1; i__ <= i__1; ++i__) {\n\tif (osbuf[i__ - 1] > contrl_1.lframe) {\n\t    osbuf[j - 1] = osbuf[i__ - 1] - contrl_1.lframe;\n\t    ++j;\n\t}\n    }\n    *osptr = j;\n    voibuf[0] = voibuf[2];\n    voibuf[1] = voibuf[3];\n    for (i__ = 1; i__ <= 2; ++i__) {\n\tvwin[(i__ << 1) - 2] = vwin[((i__ + 1) << 1) - 2] - contrl_1.lframe;\n\tvwin[(i__ << 1) - 1] = vwin[((i__ + 1) << 1) - 1] - contrl_1.lframe;\n\tawin[(i__ << 1) - 2] = awin[((i__ + 1) << 1) - 2] - contrl_1.lframe;\n\tawin[(i__ << 1) - 1] = awin[((i__ + 1) << 1) - 1] - contrl_1.lframe;\n\n\n\n\n\n\n\tobound[i__ - 1] = obound[i__];\n\tvoibuf[i__ * 2] = voibuf[(i__ + 1) * 2];\n\tvoibuf[(i__ << 1) + 1] = voibuf[((i__ + 1) << 1) + 1];\n\trmsbuf[i__ - 1] = rmsbuf[i__];\n\ti__1 = contrl_1.order;\n\tfor (j = 1; j <= i__1; ++j) {\n\t    rcbuf[j + i__ * 10 - 11] = rcbuf[j + (i__ + 1) * 10 - 11];\n\t}\n    }\n\n\n\n\n\n\n\n    temp = 0.f;\n    i__1 = contrl_1.lframe;\n    for (i__ = 1; i__ <= i__1; ++i__) {\n\tinbuf[720 - contrl_1.lframe + i__ - 181] = speech[i__] * 4096.f - \n\t\t(*bias);\n\ttemp += inbuf[720 - contrl_1.lframe + i__ - 181];\n    }\n    if (temp > (real) contrl_1.lframe) {\n\t*bias += 1;\n    }\n    if (temp < (real) (-contrl_1.lframe)) {\n\t*bias += -1;\n    }\n\n    i__ = 721 - contrl_1.lframe;\n    preemp_(&inbuf[i__ - 181], &pebuf[i__ - 181], &contrl_1.lframe, &precoef, \n\t    zpre);\n    onset_(pebuf, osbuf, osptr, &c__10, &c__181, &c__720, &contrl_1.lframe, st);\n\n\n    placev_(osbuf, osptr, &c__10, &obound[2], vwin, &c__3, &contrl_1.lframe, \n\t    &c__90, &c__156, &c__307, &c__462);\n\n\n\n\n\n\n\n\n\n\n\n\n    lpfilt_(&inbuf[228], &lpbuf[384], &c__312, &contrl_1.lframe);\n\n\n\n    ivfilt_(&lpbuf[204], ivbuf, &c__312, &contrl_1.lframe, ivrc);\n\n\n\n    tbdm_(ivbuf, &c__156, tau, &c__60, amdf, &minptr, &maxptr, &mintau);\n\n\n\n\n\n\n\n\n\n\n\n\n    for (half = 1; half <= 2; ++half) {\n\tvoicin_(&vwin[4], inbuf, lpbuf, buflim, &half, &amdf[minptr - 1], &\n\t\tamdf[maxptr - 1], &mintau, ivrc, obound, voibuf, &c__3, st);\n    }\n\n\n    dyptrk_(amdf, &c__60, &minptr, &voibuf[7], pitch, &midx, st);\n    ipitch = tau[midx - 1];\n\n    placea_(&ipitch, voibuf, &obound[2], &c__3, vwin, awin, ewin, &\n\t    contrl_1.lframe, &c__156);\n\n    lanal = awin[5] + 1 - awin[4];\n    dcbias_(&lanal, &pebuf[awin[4] - 181], abuf);\n\n\n\n\n\n\n    i__1 = ewin[5] - ewin[4] + 1;\n    energy_(&i__1, &abuf[ewin[4] - awin[4]], &rmsbuf[2]);\n\n    mload_(&contrl_1.order, &c__1, &lanal, abuf, phi, psi);\n    invert_(&contrl_1.order, phi, psi, &rcbuf[20]);\n    rcchk_(&contrl_1.order, &rcbuf[10], &rcbuf[20]);\n\n    voice[1] = voibuf[2];\n    voice[2] = voibuf[3];\n    *rms = rmsbuf[0];\n    i__1 = contrl_1.order;\n    for (i__ = 1; i__ <= i__1; ++i__) {\n\trc[i__] = rcbuf[i__ - 1];\n    }\n    return 0;\n} \n", "bug_type": null, "idx": 2022}
{"project": "Asterisk", "target": 0, "func": "static int cli_unid_print_body(void *obj, void *arg, int flags)\n{\n\tstruct unidentified_request *unid = obj;\n\tstruct ast_sip_cli_context *context = arg;\n\tint indent;\n\tint flexwidth;\n\tint64_t ms = ast_tvdiff_ms(ast_tvnow(), unid->first_seen);\n\tast_assert(context->output_buffer != NULL);\n\tindent = CLI_INDENT_TO_SPACES(context->indent_level);\n\tflexwidth = CLI_LAST_TABSTOP - 4;\n\tast_str_append(&context->output_buffer, 0, \"%*s:  %-*.*s  %7d %10.3f\\n\",\n\t\tindent,\n\t\t\"Request\",\n\t\tflexwidth, flexwidth,\n\t\tunid->src_name, unid->count,  ms / 1000.0);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2023}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tint res;\n\tif (!ast_context_find_or_create(NULL, NULL, context_name, AST_MODULE)) {\n\t\tast_log(LOG_ERROR, \"Failed to create %s dialplan context.\\n\", context_name);\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\t\n\tast_add_extension(context_name, 1, exten_name, 1, \"\", \"\",\n\t\t\t\"Set\", \"EncodedChannel=${CUT(HOOK_CHANNEL,-,1-2)}\",\n\t\t\tNULL, AST_MODULE);\n\tast_add_extension(context_name, 1, exten_name, 2, \"\", \"\",\n\t\t\t\"Set\", \"GROUP_NAME=${EncodedChannel}${HOOK_ID}\",\n\t\t\tNULL, AST_MODULE);\n\tast_add_extension(context_name, 1, exten_name, 3, \"\", \"\",\n\t\t\t\"Set\", \"GROUP(periodic-hook)=${GROUP_NAME}\",\n\t\t\tNULL, AST_MODULE);\n\tast_add_extension(context_name, 1, exten_name, 4, \"\", \"\", \"ExecIf\",\n\t\t\t\"$[${GROUP_COUNT(${GROUP_NAME}@periodic-hook)} > 1]?Hangup()\",\n\t\t\tNULL, AST_MODULE);\n\tast_add_extension(context_name, 1, exten_name, 5, \"\", \"\",\n\t\t\t\"Set\", \"ChannelToSpy=${URIDECODE(${EncodedChannel})}\",\n\t\t\tNULL, AST_MODULE);\n\tast_add_extension(context_name, 1, exten_name, 6, \"\", \"\",\n\t\t\t\"ChanSpy\", \"${ChannelToSpy},qEB\", NULL, AST_MODULE);\n\tres = ast_add_extension(context_name, 1, beep_exten, 1, \"\", \"\",\n\t\t\t\"Answer\", \"\", NULL, AST_MODULE);\n\tres |= ast_add_extension(context_name, 1, beep_exten, 2, \"\", \"\",\n\t\t\t\"Playback\", \"beep\", NULL, AST_MODULE);\n\tres = ast_custom_function_register_escalating(&hook_function, AST_CFE_BOTH);\n\treturn res ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 2024}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245H263VideoCapability (OOCTXT* pctxt, H245H263VideoCapability* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.slowSqcifMPIPresent ||\n   pvalue->m.slowQcifMPIPresent ||\n   pvalue->m.slowCifMPIPresent ||\n   pvalue->m.slowCif4MPIPresent ||\n   pvalue->m.slowCif16MPIPresent ||\n   pvalue->m.errorCompensationPresent ||\n   pvalue->m.enhancementLayerInfoPresent ||\n   pvalue->m.h263OptionsPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.sqcifMPIPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.qcifMPIPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.cifMPIPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.cif4MPIPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.cif16MPIPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.hrd_BPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.bppMaxKbPresent);\n   \n   if (pvalue->m.sqcifMPIPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->sqcifMPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.qcifMPIPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->qcifMPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.cifMPIPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->cifMPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.cif4MPIPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->cif4MPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.cif16MPIPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->cif16MPI, 1U, 32U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->maxBitRate, 1U, 192400U);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->unrestrictedVector);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->arithmeticCoding);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->advancedPrediction);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->pbFrames);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->temporalSpatialTradeOffCapability);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.hrd_BPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->hrd_B, 0U, 524287U);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.bppMaxKbPresent) {\n      stat = encodeConsUnsigned (pctxt, pvalue->bppMaxKb, 0U, 65535U);\n      if (stat != ASN_OK) return stat;\n   }\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 7);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.slowSqcifMPIPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.slowQcifMPIPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.slowCifMPIPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.slowCif4MPIPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.slowCif16MPIPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.errorCompensationPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.enhancementLayerInfoPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.h263OptionsPresent);\n      \n      if (pvalue->m.slowSqcifMPIPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeConsUnsigned (&lctxt, pvalue->slowSqcifMPI, 1U, 3600U);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.slowQcifMPIPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeConsUnsigned (&lctxt, pvalue->slowQcifMPI, 1U, 3600U);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.slowCifMPIPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeConsUnsigned (&lctxt, pvalue->slowCifMPI, 1U, 3600U);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.slowCif4MPIPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeConsUnsigned (&lctxt, pvalue->slowCif4MPI, 1U, 3600U);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.slowCif16MPIPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeConsUnsigned (&lctxt, pvalue->slowCif16MPI, 1U, 3600U);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.errorCompensationPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeBit (&lctxt, (ASN1BOOL)pvalue->errorCompensation);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.enhancementLayerInfoPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H245EnhancementLayerInfo (&lctxt, &pvalue->enhancementLayerInfo);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.h263OptionsPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H245H263Options (&lctxt, &pvalue->h263Options);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2025}
{"project": "Asterisk", "target": 0, "func": "HIST_ENTRY *\nhistory_get(int num)\n{\n\tstatic HIST_ENTRY she;\n\tHistEvent ev;\n\tint i = 1, curr_num;\n\tif (h == NULL || e == NULL)\n\t\trl_initialize();\n\t\n\tif (history(h, &ev, H_CURR) != 0)\n\t\treturn (NULL);\n\tcurr_num = ev.num;\n\tif (history(h, &ev, H_LAST) != 0)\n\t\treturn (NULL);\t\n\twhile (i < num && history(h, &ev, H_PREV) == 0)\n\t\ti++;\n\tif (i != num)\n\t\treturn (NULL);\t\n\tshe.line = ev.str;\n\tshe.data = NULL;\n\t\n\t(void) history(h, &ev, H_FIRST);\n\t(void) history(h, &ev, H_NEXT_EVENT, curr_num);\n\treturn (&she);\n}\n", "bug_type": null, "idx": 2026}
{"project": "Asterisk", "target": 0, "func": "static int inbound_auth_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\treturn ast_sip_auth_vector_init(&endpoint->inbound_auths, var->value);\n}\n", "bug_type": null, "idx": 2027}
{"project": "Asterisk", "target": 0, "func": "int ast_format_cap_identical(const struct ast_format_cap *cap1, const struct ast_format_cap *cap2)\n{\n\tif (AST_VECTOR_SIZE(&cap1->preference_order) != AST_VECTOR_SIZE(&cap2->preference_order)) {\n\t\treturn 0; \n\t}\n\tif (!internal_format_cap_identical(cap1, cap2)) {\n\t\treturn 0;\n\t}\n\treturn internal_format_cap_identical(cap2, cap1);\n}\n", "bug_type": null, "idx": 2028}
{"project": "Asterisk", "target": 0, "func": "static void populate_cache(void)\n{\n\tRAII_VAR(struct ast_db_entry *, tree,\n\t\t ast_db_gettree(DEVICE_STATE_FAMILY, NULL), ast_db_freetree);\n\tstruct ast_db_entry *entry;\n\tfor (entry = tree; entry; entry = entry->next) {\n\t\tconst char *name = strrchr(entry->key, '/');\n\t\tif (!ast_strlen_zero(name)) {\n\t\t\tast_devstate_changed(\n\t\t\t\tast_devstate_val(entry->data),\n\t\t\t\tAST_DEVSTATE_CACHABLE, \"%s%s\\n\",\n\t\t\t\tDEVICE_STATE_SCHEME_STASIS, name + 1);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2029}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225VendorIdentifier_productId (OOCTXT* pctxt, H225VendorIdentifier_productId* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = encodeOctetString (pctxt, pvalue->numocts, pvalue->data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2030}
{"project": "Asterisk", "target": 0, "func": "\n int deemp_(real *x, integer *n, struct lpc10_decoder_state *st)\n{\n    \n    real *dei1;\n    real *dei2;\n    real *deo1;\n    real *deo2;\n    real *deo3;\n    \n    integer i__1;\n    real r__1;\n    \n    integer k;\n    real dei0;\n\n\n\n\n\n    \n    if (x) {\n\t--x;\n\t}\n    \n    dei1 = &(st->dei1);\n    dei2 = &(st->dei2);\n    deo1 = &(st->deo1);\n    deo2 = &(st->deo2);\n    deo3 = &(st->deo3);\n    i__1 = *n;\n    for (k = 1; k <= i__1; ++k) {\n\tdei0 = x[k];\n\tr__1 = x[k] - *dei1 * 1.9998f + *dei2;\n\tx[k] = r__1 + *deo1 * 2.5f - *deo2 * 2.0925f + *deo3 * .585f;\n\t*dei2 = *dei1;\n\t*dei1 = dei0;\n\t*deo3 = *deo2;\n\t*deo2 = *deo1;\n\t*deo1 = x[k];\n    }\n    return 0;\n} \n", "bug_type": null, "idx": 2031}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_subscription_get_remote_uri(struct ast_sip_subscription *sub, char *buf, size_t size)\n{\n\tpjsip_dialog *dlg;\n\tdlg = sub->tree->dlg;\n\tast_copy_pj_str(buf, &dlg->remote.info_str, size);\n}\n", "bug_type": null, "idx": 2032}
{"project": "Asterisk", "target": 0, "func": "void iax2_codec_pref_remove_missing(struct iax2_codec_pref *pref, uint64_t bitfield)\n{\n\tint idx;\n\tif (!pref->order[0]) {\n\t\treturn;\n\t}\n\t\n\tfor (idx = ARRAY_LEN(pref->order); idx--;) {\n\t\tuint64_t pref_bitfield;\n\t\tpref_bitfield = iax2_codec_pref_order_value_to_format_bitfield(pref->order[idx]);\n\t\tif (!pref_bitfield) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!(pref_bitfield & bitfield)) {\n\t\t\tcodec_pref_remove_index(pref, idx);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2033}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245V75Capability (OOCTXT* pctxt, H245V75Capability* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"audioHeader\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->audioHeader);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->audioHeader);\n   invokeEndElement (pctxt, \"audioHeader\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2034}
{"project": "Asterisk", "target": 0, "func": "static void *menu_find(struct ao2_container *container, const char *category)\n{\n\treturn ao2_find(container, category, OBJ_KEY);\n}\n", "bug_type": null, "idx": 2035}
{"project": "Asterisk", "target": 0, "func": "static int load_general_config(struct ast_config *cfg)\n{\n\tstruct ast_variable *v;\n\tint res = 0;\n\tunsigned int i;\n\tast_rwlock_wrlock(&event_types_lock);\n\tfor (i = 0; i < ARRAY_LEN(event_types); i++) {\n\t\tevent_types[i].publish = event_types[i].publish_default;\n\t\tevent_types[i].subscribe = event_types[i].subscribe_default;\n\t}\n\tfor (v = ast_variable_browse(cfg, \"general\"); v && !res; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"publish_event\")) {\n\t\t\tres = set_event(v->value, PUBLISH);\n\t\t} else if (!strcasecmp(v->name, \"subscribe_event\")) {\n\t\t\tres = set_event(v->value, SUBSCRIBE);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown option '%s'\\n\", v->name);\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_LEN(event_types); i++) {\n\t\tif (event_types[i].publish && !event_types[i].sub) {\n\t\t\tevent_types[i].sub = stasis_forward_all(event_types[i].topic_fn(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tcorosync_topic());\n\t\t\tstasis_message_router_add(stasis_router,\n\t\t\t                          event_types[i].message_type_fn(),\n\t\t\t                          stasis_message_cb,\n\t\t\t                          NULL);\n\t\t} else if (!event_types[i].publish && event_types[i].sub) {\n\t\t\tevent_types[i].sub = stasis_forward_cancel(event_types[i].sub);\n\t\t\tstasis_message_router_remove(stasis_router,\n\t\t\t                             event_types[i].message_type_fn());\n\t\t}\n\t}\n\tast_rwlock_unlock(&event_types_lock);\n\treturn res;\n}\n", "bug_type": null, "idx": 2036}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/event.h\"\nstatic int check_event(struct ast_event *event, struct ast_test *test,\n\t\tenum ast_event_type expected_type, const char *type_name,\n\t\tconst char *str, uint32_t uint)\n{\n\tenum ast_event_type type;\n\tconst void *foo;\n\t\n\ttype = ast_event_get_type(event);\n\tif (ast_event_get_type(event) != type) {\n\t\tast_test_status_update(test, \"Expected event type: '%u', got '%u'\\n\",\n\t\t\t\texpected_type, type);\n\t\treturn -1;\n\t}\n\t\n\tif (strcmp(str, ast_event_get_ie_str(event, AST_EVENT_IE_CEL_USEREVENT_NAME))) {\n\t\tast_test_status_update(test, \"Failed to get string IE.\\n\");\n\t\treturn -1;\n\t}\n\t\n\tif (uint != ast_event_get_ie_uint(event, AST_EVENT_IE_CEL_AMAFLAGS)) {\n\t\tast_test_status_update(test, \"Failed to get uint IE.\\n\");\n\t\treturn -1;\n\t}\n\t\n\tif ((foo = ast_event_get_ie_str(event, AST_EVENT_IE_CEL_CIDNAME))) {\n\t\tast_test_status_update(test, \"CEL_CIDNAME IE check returned non-NULL %p\\n\", foo);\n\t\treturn -1;\n\t}\n\t\n\tif (ast_event_get_ie_uint(event, AST_EVENT_IE_CEL_EVENT_TIME_USEC)) {\n\t\tast_test_status_update(test, \"UNIQUEID IE should be 0\\n\");\n\t\treturn -1;\n\t}\n\tast_test_status_update(test, \"Event looks good.\\n\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 2037}
{"project": "Asterisk", "target": 0, "func": "int ooGkClientHandleAdmissionReject\n   (ooGkClient *pGkClient, H225AdmissionReject *pAdmissionReject)\n{\n   RasCallAdmissionInfo* pCallAdmInfo=NULL;\n   unsigned int x, y;\n   DListNode *pNode=NULL, *pNode1=NULL;\n   OOH323CallData *call=NULL;\n   OOTimer *pTimer = NULL;\n   ast_mutex_lock(&pGkClient->Lock);\n   \n   for(x=0 ; x<pGkClient->callsPendingList.count; x++)\n   {\n      pNode = dListFindByIndex(&pGkClient->callsPendingList, x);\n      pCallAdmInfo = (RasCallAdmissionInfo*) pNode->data;\n      if(pCallAdmInfo->requestSeqNum == pAdmissionReject->requestSeqNum)\n         break;\n      pNode = NULL;\n      pCallAdmInfo = NULL;\n   }\n   if(!pCallAdmInfo)\n   {\n      OOTRACEWARN2(\"Received admission reject with request number %d can not\"\n                   \" be matched with any pending call.\\n\", \n                   pAdmissionReject->requestSeqNum);\n      ast_mutex_unlock(&pGkClient->Lock);\n      return OO_OK;\n   }\n   else{\n      call = pCallAdmInfo->call;\n      dListRemove(&pGkClient->callsPendingList, pNode);\n      memFreePtr(&pGkClient->ctxt, pCallAdmInfo);\n      memFreePtr(&pGkClient->ctxt, pNode);\n   }\n   ast_mutex_lock(&pCallAdmInfo->call->GkLock);\n   \n   for(y=0; y<pGkClient->timerList.count; y++)\n   {\n     pNode1 =  dListFindByIndex(&pGkClient->timerList, y);\n     pTimer = (OOTimer*)pNode1->data;\n     if(((ooGkClientTimerCb*)pTimer->cbData)->timerType & OO_ARQ_TIMER)\n     {\n               if(((ooGkClientTimerCb*)pTimer->cbData)->pAdmInfo == \n                                                                 pCallAdmInfo)\n               {\n                  memFreePtr(&pGkClient->ctxt, pTimer->cbData);\n                  ooTimerDelete(&pGkClient->ctxt, &pGkClient->timerList, \n                                                                       pTimer);\n                  OOTRACEDBGA1(\"Deleted ARQ Timer.\\n\");\n                  break;\n               }\n     }\n   }       \n   OOTRACEINFO4(\"Admission Reject message received with reason code %d for \"\n                \"(%s, %s)\\n\", pAdmissionReject->rejectReason.t, call->callType,\n                 call->callToken);\n   call->callState = OO_CALL_CLEARED;\n   switch(pAdmissionReject->rejectReason.t)\n   {\n      case T_H225AdmissionRejectReason_calledPartyNotRegistered:\n         call->callEndReason = OO_REASON_GK_NOCALLEDUSER;\n         break;\n      case T_H225AdmissionRejectReason_invalidPermission:\n      case T_H225AdmissionRejectReason_requestDenied:\n      case T_H225AdmissionRejectReason_undefinedReason:\n         call->callEndReason = OO_REASON_GK_CLEARED;\n         break;\n      case T_H225AdmissionRejectReason_callerNotRegistered:\n         call->callEndReason = OO_REASON_GK_NOCALLERUSER;\n         break;\n      case T_H225AdmissionRejectReason_exceedsCallCapacity:\n      case T_H225AdmissionRejectReason_resourceUnavailable:\n         call->callEndReason = OO_REASON_GK_NORESOURCES;\n         break;\n      case T_H225AdmissionRejectReason_noRouteToDestination:\n      case T_H225AdmissionRejectReason_unallocatedNumber:\n         call->callEndReason = OO_REASON_GK_UNREACHABLE;\n         break;\n      case T_H225AdmissionRejectReason_routeCallToGatekeeper:\n      case T_H225AdmissionRejectReason_invalidEndpointIdentifier:\n      case T_H225AdmissionRejectReason_securityDenial:\n      case T_H225AdmissionRejectReason_qosControlNotSupported:\n      case T_H225AdmissionRejectReason_incompleteAddress:\n      case T_H225AdmissionRejectReason_aliasesInconsistent:\n      case T_H225AdmissionRejectReason_routeCallToSCN:\n      case T_H225AdmissionRejectReason_collectDestination:\n      case T_H225AdmissionRejectReason_collectPIN:\n      case T_H225AdmissionRejectReason_genericDataReason:\n      case T_H225AdmissionRejectReason_neededFeatureNotSupported:\n      case T_H225AdmissionRejectReason_securityErrors:\n      case T_H225AdmissionRejectReason_securityDHmismatch:\n      case T_H225AdmissionRejectReason_extElem1:\n         call->callEndReason = OO_REASON_GK_CLEARED;\n         break;\n   }\n   ast_mutex_unlock(&pCallAdmInfo->call->GkLock);\n   ast_mutex_unlock(&pGkClient->Lock);\n   ast_cond_signal(&pCallAdmInfo->call->gkWait);\n   return OO_OK;   \n}\n", "bug_type": null, "idx": 2038}
{"project": "Asterisk", "target": 0, "func": " */\nstatic unsigned int ext_strncpy(char *dst, const char *src, size_t dst_size, int nofluff)\n{\n\tunsigned int count;\n\tunsigned int insquares;\n\tunsigned int is_pattern;\n\tif (!dst_size--) {\n\t\t\n\t\treturn 0;\n\t}\n\tcount = 0;\n\tinsquares = 0;\n\tis_pattern = *src == '_';\n\twhile (*src && count < dst_size) {\n\t\tif (*src == '[') {\n\t\t\tif (is_pattern) {\n\t\t\t\tinsquares = 1;\n\t\t\t}\n\t\t} else if (*src == ']') {\n\t\t\tinsquares = 0;\n\t\t} else if (*src == ' ' && !insquares) {\n\t\t\t++src;\n\t\t\tcontinue;\n\t\t} else if (*src == '-' && !insquares && nofluff) {\n\t\t\t++src;\n\t\t\tcontinue;\n\t\t}\n\t\t*dst++ = *src++;\n\t\t++count;\n\t}\n\t*dst = '\\0';\n\treturn count + 1;\n}\n", "bug_type": null, "idx": 2039}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225CallProceeding_UUIE_fastStart (OOCTXT* pctxt, H225CallProceeding_UUIE_fastStart* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT xx1;\n   \n   stat = encodeLength (pctxt, pvalue->n);\n   if (stat < 0) return stat;\n   \n   for (xx1 = 0; xx1 < pvalue->n; xx1++) {\n      stat = encodeOctetString (pctxt, pvalue->elem[xx1].numocts, pvalue->elem[xx1].data);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2040}
{"project": "Asterisk", "target": 0, "func": "int initContextBuffer \n(OOCTXT* pctxt, const ASN1OCTET* bufaddr, ASN1UINT bufsiz)\n{\n   if (bufaddr == 0) {\n      \n      if (bufsiz == 0) bufsiz = ASN_K_ENCBUFSIZ;\n      pctxt->buffer.data = (ASN1OCTET*) \n         memHeapAlloc (&pctxt->pMsgMemHeap, bufsiz);\n      if (!pctxt->buffer.data) return ASN_E_NOMEM;\n      pctxt->buffer.size = bufsiz;\n      pctxt->buffer.dynamic = TRUE;\n   }\n   else {\n      \n      pctxt->buffer.data = (ASN1OCTET*) bufaddr;\n      pctxt->buffer.size = bufsiz;\n      pctxt->buffer.dynamic = FALSE;\n   }\n   pctxt->buffer.byteIndex = 0;\n   pctxt->buffer.bitOffset = 8;\n   return ASN_OK;\n}\n", "bug_type": null, "idx": 2041}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *mbl_read(struct ast_channel *ast)\n{\n\tstruct mbl_pvt *pvt = ast_channel_tech_pvt(ast);\n\tstruct ast_frame *fr = &ast_null_frame;\n\tint r;\n\tast_debug(3, \"*** mbl_read()\\n\");\n\twhile (ast_mutex_trylock(&pvt->lock)) {\n\t\tCHANNEL_DEADLOCK_AVOIDANCE(ast);\n\t}\n\tif (!pvt->owner || pvt->sco_socket == -1) {\n\t\tgoto e_return;\n\t}\n\tmemset(&pvt->fr, 0x00, sizeof(struct ast_frame));\n\tpvt->fr.frametype = AST_FRAME_VOICE;\n\tpvt->fr.subclass.format = DEVICE_FRAME_FORMAT;\n\tpvt->fr.src = \"Mobile\";\n\tpvt->fr.offset = AST_FRIENDLY_OFFSET;\n\tpvt->fr.mallocd = 0;\n\tpvt->fr.delivery.tv_sec = 0;\n\tpvt->fr.delivery.tv_usec = 0;\n\tpvt->fr.data.ptr = pvt->io_buf + AST_FRIENDLY_OFFSET;\n\tif ((r = read(pvt->sco_socket, pvt->fr.data.ptr, DEVICE_FRAME_SIZE)) == -1) {\n\t\tif (errno != EAGAIN && errno != EINTR) {\n\t\t\tast_debug(1, \"[%s] read error %d, going to wait for new connection\\n\", pvt->id, errno);\n\t\t\tclose(pvt->sco_socket);\n\t\t\tpvt->sco_socket = -1;\n\t\t\tast_channel_set_fd(ast, 0, -1);\n\t\t}\n\t\tgoto e_return;\n\t}\n\tpvt->fr.datalen = r;\n\tpvt->fr.samples = r / 2;\n\tif (pvt->do_alignment_detection)\n\t\tdo_alignment_detection(pvt, pvt->fr.data.ptr, r);\n\tfr = ast_dsp_process(ast, pvt->dsp, &pvt->fr);\n\tast_mutex_unlock(&pvt->lock);\n\treturn fr;\ne_return:\n\tast_mutex_unlock(&pvt->lock);\n\treturn fr;\n}\n", "bug_type": null, "idx": 2042}
{"project": "Asterisk", "target": 0, "func": "int ast_hashtab_newsize_none(struct ast_hashtab *tab) \n{\n\treturn tab->hash_tab_size;\n}\n", "bug_type": null, "idx": 2043}
{"project": "Asterisk", "target": 0, "func": "void ast_restore_lock_info(void *lock_addr)\n{\n}\n", "bug_type": null, "idx": 2044}
{"project": "Asterisk", "target": 0, "func": "void invokeNullValue (OOCTXT* pctxt)\n{\n   if (0 != pctxt->pEventHandler) {\n      pctxt->pEventHandler->nullValue ();\n   }\n}\n", "bug_type": null, "idx": 2045}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245UnicastAddress_iPAddress (OOCTXT* pctxt, H245UnicastAddress_iPAddress* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   \n   stat = asn1PE_H245UnicastAddress_iPAddress_network (pctxt, &pvalue->network);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->tsapIdentifier, 0U, 65535U);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2046}
{"project": "Asterisk", "target": 0, "func": "char* pvalLabelGetName( pval *p )\n{\n\tif (!pvalCheckType(p, \"pvalLabelGetName\", PV_LABEL))\n\t\treturn 0;\n\treturn p->u1.str;\n}\n", "bug_type": null, "idx": 2047}
{"project": "Asterisk", "target": 0, "func": "static int analog_dial_digits(struct analog_pvt *p, enum analog_sub sub, struct analog_dialoperation *dop)\n{\n\tif (analog_callbacks.dial_digits) {\n\t\treturn analog_callbacks.dial_digits(p->chan_pvt, sub, dop);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 2048}
{"project": "Asterisk", "target": 0, "func": "struct ast_json *ast_json_object_create(void)\n{\n\treturn (struct ast_json *)json_object();\n}\n", "bug_type": null, "idx": 2049}
{"project": "Asterisk", "target": 0, "func": "protected int\ntty_rawmode(EditLine *el)\n{\n\tif (el->el_tty.t_mode == ED_IO || el->el_tty.t_mode == QU_IO)\n\t\treturn (0);\n\tif (el->el_flags & EDIT_DISABLED)\n\t\treturn (0);\n\tif (tty_getty(el, &el->el_tty.t_ts) == -1) {\n#ifdef DEBUG_TTY\n\t\t(void) fprintf(el->el_errfile, \"tty_rawmode: tty_getty: %s\\n\",\n\t\t    strerror(errno));\n#endif \n\t\treturn (-1);\n\t}\n\t\n\tel->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ts);\n\tel->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ts);\n\tif (tty__getspeed(&el->el_tty.t_ex) != el->el_tty.t_speed ||\n\t    tty__getspeed(&el->el_tty.t_ed) != el->el_tty.t_speed) {\n\t\t(void) cfsetispeed(&el->el_tty.t_ex, el->el_tty.t_speed);\n\t\t(void) cfsetospeed(&el->el_tty.t_ex, el->el_tty.t_speed);\n\t\t(void) cfsetispeed(&el->el_tty.t_ed, el->el_tty.t_speed);\n\t\t(void) cfsetospeed(&el->el_tty.t_ed, el->el_tty.t_speed);\n\t}\n\tif (tty__cooked_mode(&el->el_tty.t_ts)) {\n\t\tif (el->el_tty.t_ts.c_cflag != el->el_tty.t_ex.c_cflag) {\n\t\t\tel->el_tty.t_ex.c_cflag =\n\t\t\t    el->el_tty.t_ts.c_cflag;\n\t\t\tel->el_tty.t_ex.c_cflag &=\n\t\t\t    ~el->el_tty.t_t[EX_IO][MD_CTL].t_clrmask;\n\t\t\tel->el_tty.t_ex.c_cflag |=\n\t\t\t    el->el_tty.t_t[EX_IO][MD_CTL].t_setmask;\n\t\t\tel->el_tty.t_ed.c_cflag =\n\t\t\t    el->el_tty.t_ts.c_cflag;\n\t\t\tel->el_tty.t_ed.c_cflag &=\n\t\t\t    ~el->el_tty.t_t[ED_IO][MD_CTL].t_clrmask;\n\t\t\tel->el_tty.t_ed.c_cflag |=\n\t\t\t    el->el_tty.t_t[ED_IO][MD_CTL].t_setmask;\n\t\t}\n\t\tif ((el->el_tty.t_ts.c_lflag != el->el_tty.t_ex.c_lflag) &&\n\t\t    (el->el_tty.t_ts.c_lflag != el->el_tty.t_ed.c_lflag)) {\n\t\t\tel->el_tty.t_ex.c_lflag =\n\t\t\t    el->el_tty.t_ts.c_lflag;\n\t\t\tel->el_tty.t_ex.c_lflag &=\n\t\t\t    ~el->el_tty.t_t[EX_IO][MD_LIN].t_clrmask;\n\t\t\tel->el_tty.t_ex.c_lflag |=\n\t\t\t    el->el_tty.t_t[EX_IO][MD_LIN].t_setmask;\n\t\t\tel->el_tty.t_ed.c_lflag =\n\t\t\t    el->el_tty.t_ts.c_lflag;\n\t\t\tel->el_tty.t_ed.c_lflag &=\n\t\t\t    ~el->el_tty.t_t[ED_IO][MD_LIN].t_clrmask;\n\t\t\tel->el_tty.t_ed.c_lflag |=\n\t\t\t    el->el_tty.t_t[ED_IO][MD_LIN].t_setmask;\n\t\t}\n\t\tif ((el->el_tty.t_ts.c_iflag != el->el_tty.t_ex.c_iflag) &&\n\t\t    (el->el_tty.t_ts.c_iflag != el->el_tty.t_ed.c_iflag)) {\n\t\t\tel->el_tty.t_ex.c_iflag =\n\t\t\t    el->el_tty.t_ts.c_iflag;\n\t\t\tel->el_tty.t_ex.c_iflag &=\n\t\t\t    ~el->el_tty.t_t[EX_IO][MD_INP].t_clrmask;\n\t\t\tel->el_tty.t_ex.c_iflag |=\n\t\t\t    el->el_tty.t_t[EX_IO][MD_INP].t_setmask;\n\t\t\tel->el_tty.t_ed.c_iflag =\n\t\t\t    el->el_tty.t_ts.c_iflag;\n\t\t\tel->el_tty.t_ed.c_iflag &=\n\t\t\t    ~el->el_tty.t_t[ED_IO][MD_INP].t_clrmask;\n\t\t\tel->el_tty.t_ed.c_iflag |=\n\t\t\t    el->el_tty.t_t[ED_IO][MD_INP].t_setmask;\n\t\t}\n\t\tif ((el->el_tty.t_ts.c_oflag != el->el_tty.t_ex.c_oflag) &&\n\t\t    (el->el_tty.t_ts.c_oflag != el->el_tty.t_ed.c_oflag)) {\n\t\t\tel->el_tty.t_ex.c_oflag =\n\t\t\t    el->el_tty.t_ts.c_oflag;\n\t\t\tel->el_tty.t_ex.c_oflag &=\n\t\t\t    ~el->el_tty.t_t[EX_IO][MD_OUT].t_clrmask;\n\t\t\tel->el_tty.t_ex.c_oflag |=\n\t\t\t    el->el_tty.t_t[EX_IO][MD_OUT].t_setmask;\n\t\t\tel->el_tty.t_ed.c_oflag =\n\t\t\t    el->el_tty.t_ts.c_oflag;\n\t\t\tel->el_tty.t_ed.c_oflag &=\n\t\t\t    ~el->el_tty.t_t[ED_IO][MD_OUT].t_clrmask;\n\t\t\tel->el_tty.t_ed.c_oflag |=\n\t\t\t    el->el_tty.t_t[ED_IO][MD_OUT].t_setmask;\n\t\t}\n\t\tif (tty__gettabs(&el->el_tty.t_ex) == 0)\n\t\t\tel->el_tty.t_tabs = 0;\n\t\telse\n\t\t\tel->el_tty.t_tabs = EL_CAN_TAB ? 1 : 0;\n\t\t{\n\t\t\tint i;\n\t\t\ttty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);\n\t\t\t\n\t\t\tfor (i = 0; i < C_NCC; i++)\n\t\t\t\tif (el->el_tty.t_c[TS_IO][i] !=\n\t\t\t\t    el->el_tty.t_c[EX_IO][i])\n\t\t\t\t\tbreak;\n\t\t\tif (i != C_NCC) {\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < C_NCC; i++) {\n\t\t\t\t\tif (!((el->el_tty.t_t[ED_IO][MD_CHAR].t_setmask & C_SH(i)))\n\t\t\t\t\t    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))\n\t\t\t\t\t\tel->el_tty.t_c[ED_IO][i] = el->el_tty.t_c[TS_IO][i];\n\t\t\t\t\tif (el->el_tty.t_t[ED_IO][MD_CHAR].t_clrmask & C_SH(i))\n\t\t\t\t\t\tel->el_tty.t_c[ED_IO][i] = el->el_tty.t_vdisable;\n\t\t\t\t}\n\t\t\t\ttty_bind_char(el, 0);\n\t\t\t\ttty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);\n\t\t\t\tfor (i = 0; i < C_NCC; i++) {\n\t\t\t\t\tif (!((el->el_tty.t_t[EX_IO][MD_CHAR].t_setmask & C_SH(i)))\n\t\t\t\t\t    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))\n\t\t\t\t\t\tel->el_tty.t_c[EX_IO][i] = el->el_tty.t_c[TS_IO][i];\n\t\t\t\t\tif (el->el_tty.t_t[EX_IO][MD_CHAR].t_clrmask & C_SH(i))\n\t\t\t\t\t\tel->el_tty.t_c[EX_IO][i] = el->el_tty.t_vdisable;\n\t\t\t\t}\n\t\t\t\ttty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);\n\t\t\t}\n\t\t}\n\t}\n\tif (tty_setty(el, &el->el_tty.t_ed) == -1) {\n#ifdef DEBUG_TTY\n\t\t(void) fprintf(el->el_errfile, \"tty_rawmode: tty_setty: %s\\n\",\n\t\t    strerror(errno));\n#endif \n\t\treturn (-1);\n\t}\n\tel->el_tty.t_mode = ED_IO;\n\treturn (0);\n}\n", "bug_type": null, "idx": 2050}
{"project": "Asterisk", "target": 0, "func": "static void handle_cli_recalc(struct ast_cli_args *a)\n{\n\tint time = a->argv[4] ? atoi(a->argv[4]) : 1;\n\tif (time <= 0) {\n\t\tast_cli(a->fd, \"         Recalc must be greater than 0.  Defaulting to 1.\\n\");\n\t\ttime = 1;\n\t}\n\tif (time > MAX_RECALC) {\n\t\tast_cli(a->fd, \"         Maximum limit of recalc exceeded by %d, truncating value to %d\\n\", time - MAX_RECALC, MAX_RECALC);\n\t\ttime = MAX_RECALC;\n\t}\n\tast_cli(a->fd, \"         Recalculating Codec Translation (number of sample seconds: %d)\\n\\n\", time);\n\tAST_RWLIST_WRLOCK(&translators);\n\tmatrix_rebuild(time);\n\tAST_RWLIST_UNLOCK(&translators);\n}\n", "bug_type": null, "idx": 2051}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void dial_masquerade_breakdown(void *data, struct ast_channel *old_chan, struct ast_channel *new_chan)\n{\n\tstruct dial_masquerade_datastore *masq_data = data;\n\tstruct dial_target *cur;\n\tao2_lock(masq_data);\n\tif (!masq_data->caller) {\n\t\tao2_unlock(masq_data);\n\t\treturn;\n\t}\n\tif (masq_data->caller == new_chan) {\n\t\t\n\t\tast_debug(1, \"Caller channel %s being masqueraded into by %s (is_empty:%d)\\n\",\n\t\t\tast_channel_name(old_chan), ast_channel_name(new_chan),\n\t\t\tAST_LIST_EMPTY(&masq_data->dialed_peers));\n\t\tAST_LIST_TRAVERSE(&masq_data->dialed_peers, cur, list) {\n\t\t\tast_channel_publish_dial_internal(old_chan, cur->peer, NULL,\n\t\t\t\tcur->dialstring, \"NOANSWER\", NULL);\n\t\t\tast_channel_publish_dial_internal(new_chan, cur->peer, NULL,\n\t\t\t\tcur->dialstring, NULL, NULL);\n\t\t}\n\t\tao2_unlock(masq_data);\n\t\treturn;\n\t}\n\t\n\tAST_LIST_TRAVERSE(&masq_data->dialed_peers, cur, list) {\n\t\tif (cur->peer == new_chan) {\n\t\t\tast_debug(1, \"Peer channel %s being masqueraded into by %s\\n\",\n\t\t\t\tast_channel_name(old_chan), ast_channel_name(new_chan));\n\t\t\tast_channel_publish_dial_internal(masq_data->caller, old_chan, NULL,\n\t\t\t\tcur->dialstring, \"CANCEL\", NULL);\n\t\t\tast_channel_publish_dial_internal(masq_data->caller, new_chan, NULL,\n\t\t\t\tcur->dialstring, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\tao2_unlock(masq_data);\n}\n", "bug_type": null, "idx": 2052}
{"project": "Asterisk", "target": 0, "func": " */\nstatic const char *fac2str(enum FacFunction facility)\n{\n\tstatic const struct {\n\t\tenum FacFunction facility;\n\t\tchar *name;\n\t} arr[] = {\n\n\t\t{ Fac_None, \"Fac_None\" },\n#if defined(AST_MISDN_ENHANCEMENTS)\n\t\t{ Fac_ERROR, \"Fac_ERROR\" },\n\t\t{ Fac_RESULT, \"Fac_RESULT\" },\n\t\t{ Fac_REJECT, \"Fac_REJECT\" },\n\t\t{ Fac_ActivationDiversion, \"Fac_ActivationDiversion\" },\n\t\t{ Fac_DeactivationDiversion, \"Fac_DeactivationDiversion\" },\n\t\t{ Fac_ActivationStatusNotificationDiv, \"Fac_ActivationStatusNotificationDiv\" },\n\t\t{ Fac_DeactivationStatusNotificationDiv, \"Fac_DeactivationStatusNotificationDiv\" },\n\t\t{ Fac_InterrogationDiversion, \"Fac_InterrogationDiversion\" },\n\t\t{ Fac_DiversionInformation, \"Fac_DiversionInformation\" },\n\t\t{ Fac_CallDeflection, \"Fac_CallDeflection\" },\n\t\t{ Fac_CallRerouteing, \"Fac_CallRerouteing\" },\n\t\t{ Fac_DivertingLegInformation2, \"Fac_DivertingLegInformation2\" },\n\t\t{ Fac_InterrogateServedUserNumbers, \"Fac_InterrogateServedUserNumbers\" },\n\t\t{ Fac_DivertingLegInformation1, \"Fac_DivertingLegInformation1\" },\n\t\t{ Fac_DivertingLegInformation3, \"Fac_DivertingLegInformation3\" },\n\t\t{ Fac_EctExecute, \"Fac_EctExecute\" },\n\t\t{ Fac_ExplicitEctExecute, \"Fac_ExplicitEctExecute\" },\n\t\t{ Fac_RequestSubaddress, \"Fac_RequestSubaddress\" },\n\t\t{ Fac_SubaddressTransfer, \"Fac_SubaddressTransfer\" },\n\t\t{ Fac_EctLinkIdRequest, \"Fac_EctLinkIdRequest\" },\n\t\t{ Fac_EctInform, \"Fac_EctInform\" },\n\t\t{ Fac_EctLoopTest, \"Fac_EctLoopTest\" },\n\t\t{ Fac_ChargingRequest, \"Fac_ChargingRequest\" },\n\t\t{ Fac_AOCSCurrency, \"Fac_AOCSCurrency\" },\n\t\t{ Fac_AOCSSpecialArr, \"Fac_AOCSSpecialArr\" },\n\t\t{ Fac_AOCDCurrency, \"Fac_AOCDCurrency\" },\n\t\t{ Fac_AOCDChargingUnit, \"Fac_AOCDChargingUnit\" },\n\t\t{ Fac_AOCECurrency, \"Fac_AOCECurrency\" },\n\t\t{ Fac_AOCEChargingUnit, \"Fac_AOCEChargingUnit\" },\n\t\t{ Fac_StatusRequest, \"Fac_StatusRequest\" },\n\t\t{ Fac_CallInfoRetain, \"Fac_CallInfoRetain\" },\n\t\t{ Fac_EraseCallLinkageID, \"Fac_EraseCallLinkageID\" },\n\t\t{ Fac_CCBSDeactivate, \"Fac_CCBSDeactivate\" },\n\t\t{ Fac_CCBSErase, \"Fac_CCBSErase\" },\n\t\t{ Fac_CCBSRemoteUserFree, \"Fac_CCBSRemoteUserFree\" },\n\t\t{ Fac_CCBSCall, \"Fac_CCBSCall\" },\n\t\t{ Fac_CCBSStatusRequest, \"Fac_CCBSStatusRequest\" },\n\t\t{ Fac_CCBSBFree, \"Fac_CCBSBFree\" },\n\t\t{ Fac_CCBSStopAlerting, \"Fac_CCBSStopAlerting\" },\n\t\t{ Fac_CCBSRequest, \"Fac_CCBSRequest\" },\n\t\t{ Fac_CCBSInterrogate, \"Fac_CCBSInterrogate\" },\n\t\t{ Fac_CCNRRequest, \"Fac_CCNRRequest\" },\n\t\t{ Fac_CCNRInterrogate, \"Fac_CCNRInterrogate\" },\n\t\t{ Fac_CCBS_T_Call, \"Fac_CCBS_T_Call\" },\n\t\t{ Fac_CCBS_T_Suspend, \"Fac_CCBS_T_Suspend\" },\n\t\t{ Fac_CCBS_T_Resume, \"Fac_CCBS_T_Resume\" },\n\t\t{ Fac_CCBS_T_RemoteUserFree, \"Fac_CCBS_T_RemoteUserFree\" },\n\t\t{ Fac_CCBS_T_Available, \"Fac_CCBS_T_Available\" },\n\t\t{ Fac_CCBS_T_Request, \"Fac_CCBS_T_Request\" },\n\t\t{ Fac_CCNR_T_Request, \"Fac_CCNR_T_Request\" },\n#else\n\t\t{ Fac_CFActivate, \"Fac_CFActivate\" },\n\t\t{ Fac_CFDeactivate, \"Fac_CFDeactivate\" },\n\t\t{ Fac_CD, \"Fac_CD\" },\n\t\t{ Fac_AOCDCurrency, \"Fac_AOCDCurrency\" },\n\t\t{ Fac_AOCDChargingUnit, \"Fac_AOCDChargingUnit\" },\n#endif\t\n\n\t};\n\tunsigned index;\n\tfor (index = 0; index < ARRAY_LEN(arr); ++index) {\n\t\tif (arr[index].facility == facility) {\n\t\t\treturn arr[index].name;\n\t\t}\n\t}\n\treturn \"unknown\";\n}\n", "bug_type": null, "idx": 2053}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *audiohook_list_translate_to_slin(struct ast_audiohook_list *audiohook_list,\n\tenum ast_audiohook_direction direction, struct ast_frame *frame)\n{\n\tstruct ast_audiohook_translate *in_translate = (direction == AST_AUDIOHOOK_DIRECTION_READ ?\n\t\t&audiohook_list->in_translate[0] : &audiohook_list->in_translate[1]);\n\tstruct ast_frame *new_frame = frame;\n\tstruct ast_format *slin;\n\t\n\taudiohook_list->list_internal_samp_rate =\n\t\tMAX(ast_format_get_sample_rate(frame->subclass.format), audiohook_list->list_internal_samp_rate);\n\tslin = ast_format_cache_get_slin_by_rate(audiohook_list->list_internal_samp_rate);\n\tif (ast_format_cmp(frame->subclass.format, slin) == AST_FORMAT_CMP_EQUAL) {\n\t\treturn new_frame;\n\t}\n\tif (!in_translate->format ||\n\t\tast_format_cmp(frame->subclass.format, in_translate->format) != AST_FORMAT_CMP_EQUAL) {\n\t\tstruct ast_trans_pvt *new_trans;\n\t\tnew_trans = ast_translator_build_path(slin, frame->subclass.format);\n\t\tif (!new_trans) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (in_translate->trans_pvt) {\n\t\t\tast_translator_free_path(in_translate->trans_pvt);\n\t\t}\n\t\tin_translate->trans_pvt = new_trans;\n\t\tao2_replace(in_translate->format, frame->subclass.format);\n\t}\n\tif (!(new_frame = ast_translate(in_translate->trans_pvt, frame, 0))) {\n\t\treturn NULL;\n\t}\n\treturn new_frame;\n}\n", "bug_type": null, "idx": 2054}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(config_save);\n\tAST_TEST_UNREGISTER(config_basic_ops);\n\tAST_TEST_UNREGISTER(config_filtered_ops);\n\tAST_TEST_UNREGISTER(config_template_ops);\n\tAST_TEST_UNREGISTER(copy_config);\n\tAST_TEST_UNREGISTER(config_hook);\n\tAST_TEST_UNREGISTER(ast_parse_arg_test);\n\tAST_TEST_UNREGISTER(config_options_test);\n\tAST_TEST_UNREGISTER(config_dialplan_function);\n\tAST_TEST_UNREGISTER(variable_lists_match);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2055}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MultilinkIndication (OOCTXT* pctxt, H245MultilinkIndication* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 3);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 2);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H245MultilinkIndication_crcDesired (pctxt, pvalue->u.crcDesired);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 3:\n            stat = asn1PE_H245MultilinkIndication_excessiveError (pctxt, pvalue->u.excessiveError);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 4);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2056}
{"project": "Asterisk", "target": 0, "func": "static void check_timerange(pval *p)\n{\n\tchar *times;\n\tchar *e;\n\tint s1, s2;\n\tint e1, e2;\n\ttimes = ast_strdupa(p->u1.str);\n\t\n\tif (ast_strlen_zero(times) || !strcmp(times, \"*\")) {\n\t\treturn;\n\t}\n\t\n\te = strchr(times, '-');\n\tif (!e) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The time range format (%s) requires a '-' surrounded by two 24-hour times of day!\\n\",\n\t\t\t\tp->filename, p->startline, p->endline, times);\n\t\twarns++;\n\t\treturn;\n\t}\n\t*e = '\\0';\n\te++;\n\twhile (*e && !isdigit(*e)) \n\t\te++;\n\tif (!*e) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The time range format (%s) is missing the end time!\\n\",\n\t\t\t\tp->filename, p->startline, p->endline, p->u1.str);\n\t\twarns++;\n\t}\n\tif (sscanf(times, \"%2d:%2d\", &s1, &s2) != 2) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The start time (%s) isn't quite right!\\n\",\n\t\t\t\tp->filename, p->startline, p->endline, times);\n\t\twarns++;\n\t}\n\tif (sscanf(e, \"%2d:%2d\", &e1, &e2) != 2) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The end time (%s) isn't quite right!\\n\",\n\t\t\t\tp->filename, p->startline, p->endline, times);\n\t\twarns++;\n\t}\n\ts1 = s1 * 30 + s2/2;\n\tif ((s1 < 0) || (s1 >= 24*30)) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The start time (%s) is out of range!\\n\",\n\t\t\t\tp->filename, p->startline, p->endline, times);\n\t\twarns++;\n\t}\n\te1 = e1 * 30 + e2/2;\n\tif ((e1 < 0) || (e1 >= 24*30)) {\n\t\tast_log(LOG_WARNING, \"Warning: file %s, line %d-%d: The end time (%s) is out of range!\\n\",\n\t\t\t\tp->filename, p->startline, p->endline, e);\n\t\twarns++;\n\t}\n\treturn;\n}\n", "bug_type": null, "idx": 2057}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int function_fieldnum_helper(struct ast_channel *chan, const char *cmd,\n\t\t\t\tchar *parse, char *buf, struct ast_str **sbuf, ssize_t len)\n{\n\tchar *varsubst, *field;\n\tstruct ast_str *str = ast_str_thread_get(&result_buf, 16);\n\tint fieldindex = 0, res = 0;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(varname);\n\t\tAST_APP_ARG(delim);\n\t\tAST_APP_ARG(field);\n\t);\n\tchar delim[2] = \"\";\n\tsize_t delim_used;\n\tif (!str) {\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc < 3) {\n\t\tast_log(LOG_ERROR, \"Usage: FIELDNUM(<listname>,<delimiter>,<fieldvalue>)\\n\");\n\t\tres = -1;\n\t} else {\n\t\tvarsubst = ast_alloca(strlen(args.varname) + 4);\n\t\tsprintf(varsubst, \"${%s}\", args.varname);\n\t\tast_str_substitute_variables(&str, 0, chan, varsubst);\n\t\tif (ast_str_strlen(str) == 0 || ast_strlen_zero(args.delim)) {\n\t\t\tfieldindex = 0;\n\t\t} else if (ast_get_encoded_char(args.delim, delim, &delim_used) == -1) {\n\t\t\tres = -1;\n\t\t} else {\n\t\t\tchar *varval = ast_str_buffer(str);\n\t\t\twhile ((field = strsep(&varval, delim)) != NULL) {\n\t\t\t\tfieldindex++;\n\t\t\t\tif (!strcasecmp(field, args.field)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!field) {\n\t\t\t\tfieldindex = 0;\n\t\t\t}\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (sbuf) {\n\t\tast_str_set(sbuf, len, \"%d\", fieldindex);\n\t} else {\n\t\tsnprintf(buf, len, \"%d\", fieldindex);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2058}
{"project": "Asterisk", "target": 0, "func": "struct ast_exten *ast_walk_context_extensions(struct ast_context *con, struct ast_exten *exten);\nstruct ast_exten *ast_walk_context_extensions(struct ast_context *con, struct ast_exten *exten)\n{\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2059}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245RequestModeReject_cause (OOCTXT* pctxt, H245RequestModeReject_cause* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 3);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 2);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            \n            break;\n         \n         case 2:\n            \n            break;\n         \n         case 3:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 4);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2060}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int json_to_ast_variables(struct ast_ari_response *response, struct ast_json *json_variables, struct ast_variable **variables)\n{\n\tenum ast_json_to_ast_vars_code res;\n\tres = ast_json_to_ast_variables(json_variables, variables);\n\tswitch (res) {\n\tcase AST_JSON_TO_AST_VARS_CODE_SUCCESS:\n\t\treturn 0;\n\tcase AST_JSON_TO_AST_VARS_CODE_INVALID_TYPE:\n\t\tast_ari_response_error(response, 400, \"Bad Request\",\n\t\t\t\"Only string values in the 'variables' object allowed\");\n\t\tbreak;\n\tcase AST_JSON_TO_AST_VARS_CODE_OOM:\n\t\tast_ari_response_alloc_failed(response);\n\t\tbreak;\n\t}\n\tast_log(AST_LOG_ERROR, \"Unable to convert 'variables' in JSON body to channel variables\\n\");\n\treturn -1;\n}\n", "bug_type": null, "idx": 2061}
{"project": "Asterisk", "target": 0, "func": "static void dump_versioned_codec(char *output, int maxlen, void *value, int len)\n{\n\tchar *version = (char *) value;\n\tif (version[0] == 0) {\n\t\tif (len == (int) (sizeof(iax2_format) + sizeof(char))) {\n\t\t\tiax2_format codec = ntohll(get_unaligned_uint64(value + 1));\n\t\t\tast_copy_string(output, iax2_getformatname(codec), maxlen);\n\t\t} else {\n\t\t\tast_copy_string(output, \"Invalid length!\", maxlen);\n\t\t}\n\t} else {\n\t\tast_copy_string(output, \"Unknown version!\", maxlen);\n\t}\n}\n", "bug_type": null, "idx": 2062}
{"project": "Asterisk", "target": 0, "func": "int ast_unreal_channel_push_to_bridge(struct ast_channel *ast, struct ast_bridge *bridge, unsigned int flags)\n{\n\tstruct ast_bridge_features *features;\n\tstruct ast_channel *chan;\n\tstruct ast_channel *owner;\n\tast_callid bridge_callid;\n\tRAII_VAR(struct ast_unreal_pvt *, p, NULL, ao2_cleanup);\n\tast_bridge_lock(bridge);\n\tbridge_callid = bridge->callid;\n\tast_bridge_unlock(bridge);\n\t{\n\t\tSCOPED_CHANNELLOCK(lock, ast);\n\t\tp = ast_channel_tech_pvt(ast);\n\t\tif (!p) {\n\t\t\treturn -1;\n\t\t}\n\t\tao2_ref(p, +1);\n\t}\n\t{\n\t\tSCOPED_AO2LOCK(lock, p);\n\t\tchan = p->chan;\n\t\tif (!chan) {\n\t\t\treturn -1;\n\t\t}\n\t\towner = p->owner;\n\t\tif (!owner) {\n\t\t\treturn -1;\n\t\t}\n\t\tast_channel_ref(chan);\n\t\tast_channel_ref(owner);\n\t}\n\tif (bridge_callid) {\n\t\tast_callid chan_callid;\n\t\tast_callid owner_callid;\n\t\t\n\t\tast_channel_lock(chan);\n\t\tchan_callid = ast_channel_callid(chan);\n\t\tif (!chan_callid) {\n\t\t\tast_channel_callid_set(chan, bridge_callid);\n\t\t}\n\t\tast_channel_unlock(chan);\n\t\t\n\t\tast_channel_lock(owner);\n\t\towner_callid = ast_channel_callid(owner);\n\t\tif (!owner_callid) {\n\t\t\tast_channel_callid_set(owner, bridge_callid);\n\t\t}\n\t\tast_channel_unlock(owner);\n\t}\n\t\n\tast_channel_unref(owner);\n\towner = NULL;\n\tfeatures = ast_bridge_features_new();\n\tif (!features) {\n\t\tast_channel_unref(chan);\n\t\treturn -1;\n\t}\n\tast_set_flag(&features->feature_flags, flags);\n\t\n\tif (ast_bridge_impart(bridge, chan, NULL, features,\n\t\tAST_BRIDGE_IMPART_CHAN_INDEPENDENT)) {\n\t\tast_channel_unref(chan);\n\t\treturn -1;\n\t}\n\t\n\tao2_lock(p);\n\tast_set_flag(p, AST_UNREAL_CARETAKER_THREAD);\n\tao2_unlock(p);\n\tast_channel_unref(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2063}
{"project": "Asterisk", "target": 0, "func": "void ast_cc_extension_monitor_add_dialstring(struct ast_channel *incoming, const char * const dialstring, const char * const device_name)\n{\n\tstruct ast_datastore *cc_datastore;\n\tstruct dialed_cc_interfaces *cc_interfaces;\n\tstruct ast_cc_monitor *monitor;\n\tstruct extension_monitor_pvt *extension_pvt;\n\tstruct extension_child_dialstring *child_dialstring;\n\tstruct cc_monitor_tree *interface_tree;\n\tint id;\n\tast_channel_lock(incoming);\n\tif (!(cc_datastore = ast_channel_datastore_find(incoming, &dialed_cc_interfaces_info, NULL))) {\n\t\tast_channel_unlock(incoming);\n\t\treturn;\n\t}\n\tcc_interfaces = cc_datastore->data;\n\tinterface_tree = cc_interfaces->interface_tree;\n\tid = cc_interfaces->dial_parent_id;\n\tast_channel_unlock(incoming);\n\tAST_LIST_LOCK(interface_tree);\n\tAST_LIST_TRAVERSE(interface_tree, monitor, next) {\n\t\tif (monitor->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!monitor) {\n\t\tAST_LIST_UNLOCK(interface_tree);\n\t\treturn;\n\t}\n\textension_pvt = monitor->private_data;\n\tif (!(child_dialstring = ast_calloc(1, sizeof(*child_dialstring)))) {\n\t\tAST_LIST_UNLOCK(interface_tree);\n\t\treturn;\n\t}\n\tast_copy_string(child_dialstring->original_dialstring, dialstring, sizeof(child_dialstring->original_dialstring));\n\tast_copy_string(child_dialstring->device_name, device_name, sizeof(child_dialstring->device_name));\n\tchild_dialstring->is_valid = 1;\n\tAST_LIST_INSERT_TAIL(&extension_pvt->child_dialstrings, child_dialstring, next);\n\tAST_LIST_UNLOCK(interface_tree);\n}\n", "bug_type": null, "idx": 2064}
{"project": "Asterisk", "target": 0, "func": "static int init_blips(void)\n{\n\tint i, j;\n\tstruct blip *cur;\n\tint offset = 4;\n\tsrandom(time(NULL) + getpid());\n\t\n\tcur = calloc(1, sizeof(struct blip));\n\tif (!cur)\n\t\treturn -1;\n\tcur->type = BLIP_TANK;\n\tcur->x = max_x / 2;\n\tcur->y = max_y - 1;\n\tAST_LIST_INSERT_HEAD(&blips, cur, entry);\n\ttank = cur;\n\t\n\tnum_aliens = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tcur = calloc(1, sizeof(struct blip));\n\t\t\tif (!cur)\n\t\t\t\treturn -1;\n\t\t\tcur->type = BLIP_ALIEN;\n\t\t\tcur->x = (j * 2) + 1;\n\t\t\tcur->y = (i * 2) + 2;\n\t\t\tAST_LIST_INSERT_HEAD(&blips, cur, entry);\n\t\t\tnum_aliens++;\n\t\t}\n\t}\n\tfor(i=0; i < 4; i++) {\n\t\tif (i > 0)\n\t\t\toffset += 5 + ((max_x) -28) / 3;\n\t\tadd_barrier(offset + 1, 6);\n\t\tadd_barrier(offset + 2, 6);\n\t\tadd_barrier(offset + 3, 6);\n\t\tadd_barrier(offset, 5);\n\t\tadd_barrier(offset + 1, 5);\n\t\tadd_barrier(offset + 2, 5);\n\t\tadd_barrier(offset + 3, 5);\n\t\tadd_barrier(offset + 4, 5);\n\t\tadd_barrier(offset, 4);\n\t\tadd_barrier(offset + 1, 4);\n\t\tadd_barrier(offset + 3, 4);\n\t\tadd_barrier(offset + 4, 4);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2065}
{"project": "Asterisk", "target": 0, "func": " int speex_resampler_set_rate(SpeexResamplerState *st, spx_uint32_t in_rate, spx_uint32_t out_rate)\n{\n   return speex_resampler_set_rate_frac(st, in_rate, out_rate, in_rate, out_rate);\n}\n", "bug_type": null, "idx": 2066}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225_SeqOfH225PartyNumber (OOCTXT* pctxt, H225_SeqOfH225PartyNumber* pvalue)\n{\n   int stat = ASN_OK;\n   H225PartyNumber* pdata;\n   ASN1UINT count = 0;\n   ASN1UINT xx1;\n   int lstat;\n   dListInit (pvalue);\n   for (;;) {\n      \n      lstat = decodeLength (pctxt, &count);\n      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {\n         return lstat;\n      }\n      \n      for (xx1 = 0; xx1 < count; xx1++) {\n         invokeStartElement (pctxt, \"elem\", xx1);\n         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225PartyNumber);\n         stat = asn1PD_H225PartyNumber (pctxt, pdata);\n         if (stat != ASN_OK) return stat;\n         invokeEndElement (pctxt, \"elem\", xx1);\n         dListAppendNode (pctxt, pvalue, pdata);\n      }\n      if(lstat == ASN_OK) break;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2067}
{"project": "Asterisk", "target": 0, "func": "\nint ast_say_date_en(struct ast_channel *chan, time_t t, const char *ints, const char *lang)\n{\n\tstruct ast_tm tm;\n\tstruct timeval when = { t, 0 };\n\tchar fn[256];\n\tint res = 0;\n\tast_localtime(&when, &tm, NULL);\n\tif (!res) {\n\t\tsnprintf(fn, sizeof(fn), \"digits/day-%d\", tm.tm_wday);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res)\n\t\t\tres = ast_waitstream(chan, ints);\n\t}\n\tif (!res) {\n\t\tsnprintf(fn, sizeof(fn), \"digits/mon-%d\", tm.tm_mon);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res)\n\t\t\tres = ast_waitstream(chan, ints);\n\t}\n\tif (!res)\n\t\tres = ast_say_number(chan, tm.tm_mday, ints, lang, (char * ) NULL);\n\tif (!res)\n\t\tres = ast_waitstream(chan, ints);\n\tif (!res)\n\t\tres = ast_say_number(chan, tm.tm_year + 1900, ints, lang, (char *) NULL);\n\treturn res;\n}\n", "bug_type": null, "idx": 2068}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(sched_test_order)\n{\n\tstruct ast_sched_context *con;\n\tenum ast_test_result_state res = AST_TEST_FAIL;\n\tint id1, id2, id3, wait;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"sched_test_order\";\n\t\tinfo->category = \"/main/sched/\";\n\t\tinfo->summary = \"Test ordering of events in the scheduler API\";\n\t\tinfo->description =\n\t\t\t\"This test ensures that events are properly ordered by the \"\n\t\t\t\"time they are scheduled to execute in the scheduler API.\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tif (!(con = ast_sched_context_create())) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"Test failed - could not create scheduler context\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\t\n\tif ((wait = ast_sched_wait(con)) != -1) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned -1, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\tif ((id1 = ast_sched_add(con, 100000, sched_cb, NULL)) == -1) {\n\t\tast_test_status_update(test, \"Failed to add scheduler entry\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tif ((wait = ast_sched_wait(con)) > 100000) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned <= 100000, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\tif ((id2 = ast_sched_add(con, 10000, sched_cb, NULL)) == -1) {\n\t\tast_test_status_update(test, \"Failed to add scheduler entry\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tif ((wait = ast_sched_wait(con)) > 10000) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned <= 10000, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\tif ((id3 = ast_sched_add(con, 1000, sched_cb, NULL)) == -1) {\n\t\tast_test_status_update(test, \"Failed to add scheduler entry\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tif ((wait = ast_sched_wait(con)) > 1000) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned <= 1000, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\tif (ast_sched_del(con, id3) == -1) {\n\t\tast_test_status_update(test, \"Failed to remove scheduler entry\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tif ((wait = ast_sched_wait(con)) <= 1000) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned > 1000, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\tif (ast_sched_del(con, id2) == -1) {\n\t\tast_test_status_update(test, \"Failed to remove scheduler entry\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tif ((wait = ast_sched_wait(con)) <= 10000) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned > 10000, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\tif (ast_sched_del(con, id1) == -1) {\n\t\tast_test_status_update(test, \"Failed to remove scheduler entry\\n\");\n\t\tgoto return_cleanup;\n\t}\n\tif ((wait = ast_sched_wait(con)) != -1) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned -1, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\t\n#define DELAYED_SAME_EXPIRE\t\t300 \n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_1_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, 0, sched_order_1_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_2_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, 0, sched_order_2_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_3_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, 0, sched_order_3_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_4_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, 0, sched_order_4_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_5_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, 0, sched_order_5_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_6_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, 0, sched_order_6_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_7_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, 0, sched_order_7_cb, test), res, return_cleanup);\n\tast_test_validate_cleanup(test, -1 < ast_sched_add(con, DELAYED_SAME_EXPIRE, sched_order_8_cb, test), res, return_cleanup);\n\t\n\torder_check = 0;\n\torder_check_failed = 0;\n\tusleep(50 * 1000);\n\tast_test_validate_cleanup(test, 7 == ast_sched_runq(con), res, return_cleanup);\n\tast_test_validate_cleanup(test, !order_check_failed, res, return_cleanup);\n\t\n\torder_check = 0;\n\torder_check_failed = 0;\n\tusleep((DELAYED_SAME_EXPIRE + 50) * 1000);\n\tast_test_validate_cleanup(test, 8 == ast_sched_runq(con), res, return_cleanup);\n\tast_test_validate_cleanup(test, !order_check_failed, res, return_cleanup);\n\tif ((wait = ast_sched_wait(con)) != -1) {\n\t\tast_test_status_update(test,\n\t\t\t\t\"ast_sched_wait() should have returned -1, returned '%d'\\n\",\n\t\t\t\twait);\n\t\tgoto return_cleanup;\n\t}\n\tres = AST_TEST_PASS;\nreturn_cleanup:\n\tast_sched_context_destroy(con);\n\treturn res;\n}\n", "bug_type": null, "idx": 2069}
{"project": "Asterisk", "target": 0, "func": "char *ast_sdp_get_rtp_profile(unsigned int sdes_active, struct ast_rtp_instance *instance, unsigned int using_avpf,\n\tunsigned int force_avp)\n{\n\tstruct ast_rtp_engine_dtls *dtls;\n\tif ((dtls = ast_rtp_instance_get_dtls(instance)) && dtls->active(instance)) {\n\t\tif (force_avp) {\n\t\t\treturn using_avpf ? \"RTP/SAVPF\" : \"RTP/SAVP\";\n\t\t} else {\n\t\t\treturn using_avpf ? \"UDP/TLS/RTP/SAVPF\" : \"UDP/TLS/RTP/SAVP\";\n\t\t}\n\t} else {\n\t\tif (using_avpf) {\n\t\t\treturn sdes_active ? \"RTP/SAVPF\" : \"RTP/AVPF\";\n\t\t} else {\n\t\t\treturn sdes_active ? \"RTP/SAVP\" : \"RTP/AVP\";\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2070}
{"project": "Asterisk", "target": 0, "func": "int ooSetCmdFDSETs(struct pollfd *pfds, int *nfds)\n{\n   if(gH323ep.cmdSock)\n   {\n      pfds[*nfds].fd = gH323ep.cmdSock;\n      pfds[*nfds].events = POLLIN;\n      (*nfds)++;\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 2071}
{"project": "Asterisk", "target": 0, "func": "static int message_received;\nstatic int test_msg_send(const struct ast_msg *msg, const char *to, const char *from)\n{\n\tmessage_received = 1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2072}
{"project": "Asterisk", "target": 0, "func": "int load_pbx_variables(void)\n{\n\tint res = 0;\n\tres |= ast_cli_register_multiple(vars_cli, ARRAY_LEN(vars_cli));\n\tres |= ast_register_application2(\"Set\", pbx_builtin_setvar, NULL, NULL, NULL);\n\tres |= ast_register_application2(\"MSet\", pbx_builtin_setvar_multiple, NULL, NULL, NULL);\n\tast_register_cleanup(unload_pbx_variables);\n\treturn res;\n}\n", "bug_type": null, "idx": 2073}
{"project": "Asterisk", "target": 0, "func": "static inline void release_jb_frame(struct fixed_jb *jb, struct fixed_jb_frame *frame)\n{\n\tast_free(frame);\n}\n", "bug_type": null, "idx": 2074}
{"project": "Asterisk", "target": 0, "func": "static int bridge_stasis_moving(struct ast_bridge_channel *bridge_channel, void *hook_pvt,\n\t\tstruct ast_bridge *src, struct ast_bridge *dst)\n{\n\tif (src->v_table == &bridge_stasis_v_table &&\n\t\t\tdst->v_table != &bridge_stasis_v_table) {\n\t\tRAII_VAR(struct stasis_app_control *, control, NULL, ao2_cleanup);\n\t\tstruct ast_channel *chan;\n\t\tchan = bridge_channel->chan;\n\t\tast_assert(chan != NULL);\n\t\tcontrol = stasis_app_control_find_by_channel(chan);\n\t\tif (!control) {\n\t\t\treturn -1;\n\t\t}\n\t\tstasis_app_channel_set_stasis_end_published(chan);\n\t\tapp_send_end_msg(control_app(control), chan);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 2075}
{"project": "Asterisk", "target": 0, "func": "\nstatic void ast_xmpp_client_config_destructor(void *obj)\n{\n\tstruct ast_xmpp_client_config *cfg = obj;\n\tast_string_field_free_memory(cfg);\n\tao2_cleanup(cfg->client);\n\tao2_cleanup(cfg->buddies);\n}\n", "bug_type": null, "idx": 2076}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int stringfield_handler_fn(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tast_string_field *field = (const char **)(obj + opt->args[0]);\n\tstruct ast_string_field_pool **pool = (struct ast_string_field_pool **)(obj + opt->args[1]);\n\tstruct ast_string_field_mgr *mgr = (struct ast_string_field_mgr *)(obj + opt->args[2]);\n\tif (opt->flags && ast_strlen_zero(var->value)) {\n\t\treturn -1;\n\t}\n\tast_string_field_ptr_set_by_fields(*pool, *mgr, field, var->value);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2077}
{"project": "Asterisk", "target": 0, "func": "static void session_media_dtor(void *obj)\n{\n\tstruct ast_sip_session_media *session_media = obj;\n\t\n\tao2_callback(sdp_handlers, 0, stream_destroy, session_media);\n\tif (session_media->srtp) {\n\t\tast_sdp_srtp_destroy(session_media->srtp);\n\t}\n\tast_free(session_media->mid);\n}\n", "bug_type": null, "idx": 2078}
{"project": "Asterisk", "target": 0, "func": "static struct ast_json *channel_dialplan(\n\tstruct ast_channel_snapshot *old_snapshot,\n\tstruct ast_channel_snapshot *new_snapshot,\n\tconst struct timeval *tv)\n{\n\tstruct ast_json *json_channel;\n\t\n\tif (!old_snapshot || !new_snapshot) {\n\t\treturn NULL;\n\t}\n\t\n\tif (ast_strlen_zero(new_snapshot->appl)) {\n\t\treturn NULL;\n\t}\n\tif (ast_channel_snapshot_cep_equal(old_snapshot, new_snapshot)) {\n\t\treturn NULL;\n\t}\n\tjson_channel = ast_channel_snapshot_to_json(new_snapshot, stasis_app_get_sanitizer());\n\tif (!json_channel) {\n\t\treturn NULL;\n\t}\n\treturn ast_json_pack(\"{s: s, s: o, s: s, s: s, s: o}\",\n\t\t\"type\", \"ChannelDialplan\",\n\t\t\"timestamp\", ast_json_timeval(*tv, NULL),\n\t\t\"dialplan_app\", new_snapshot->appl,\n\t\t\"dialplan_app_data\", AST_JSON_UTF8_VALIDATE(new_snapshot->data),\n\t\t\"channel\", json_channel);\n}\n", "bug_type": null, "idx": 2079}
{"project": "Asterisk", "target": 0, "func": "int ast_get_extension_registrar_line(struct ast_exten *e)\n{\n\treturn e ? e->registrar_line : 0;\n}\n", "bug_type": null, "idx": 2080}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int mysql_log(struct ast_cdr *cdr)\n{\n\tstruct ast_str *sql1 = ast_str_thread_get(&sql1_buf, 1024), *sql2 = ast_str_thread_get(&sql2_buf, 1024);\n\tint retries = 5;\n#if MYSQL_VERSION_ID >= 50013\n\tmy_bool my_bool_true = 1;\n#endif\n\tif (!sql1 || !sql2) {\n\t\tast_log(LOG_ERROR, \"Memory error\\n\");\n\t\treturn -1;\n\t}\n\tast_mutex_lock(&mysql_lock);\ndb_reconnect:\n\tif ((!connected) && (hostname || dbsock) && dbuser && password && dbname && dbtable ) {\n\t\t\n\t\tmysql_init(&mysql);\n\t\t\n\t\tif (timeout && mysql_options(&mysql, MYSQL_OPT_CONNECT_TIMEOUT, (char *)&timeout) != 0) {\n\t\t\tast_log(LOG_ERROR, \"mysql_options returned (%d) %s\\n\", mysql_errno(&mysql), mysql_error(&mysql));\n\t\t}\n#if MYSQL_VERSION_ID >= 50013\n\t\t\n\t\tif (mysql_options(&mysql, MYSQL_OPT_RECONNECT, &my_bool_true) != 0) {\n\t\t\tast_log(LOG_ERROR, \"mysql_options returned (%d) %s\\n\", mysql_errno(&mysql), mysql_error(&mysql));\n\t\t}\n#endif\n\t\tif (ssl_ca || ssl_cert || ssl_key) {\n\t\t\tmysql_ssl_set(&mysql, ssl_key ? ast_str_buffer(ssl_key) : NULL, ssl_cert ? ast_str_buffer(ssl_cert) : NULL, ssl_ca ? ast_str_buffer(ssl_ca) : NULL, NULL, NULL);\n\t\t}\n\t\tif (mysql_real_connect(&mysql, ast_str_buffer(hostname), ast_str_buffer(dbuser), ast_str_buffer(password), ast_str_buffer(dbname), dbport, dbsock && ast_str_strlen(dbsock) ? ast_str_buffer(dbsock) : NULL, ssl_ca ? CLIENT_SSL : 0)) {\n\t\t\tconnected = 1;\n\t\t\tconnect_time = time(NULL);\n\t\t\trecords = 0;\n\t\t\tif (dbcharset) {\n\t\t\t\tast_str_set(&sql1, 0, \"SET NAMES '%s'\", ast_str_buffer(dbcharset));\n\t\t\t\tmysql_real_query(&mysql, ast_str_buffer(sql1), ast_str_strlen(sql1));\n\t\t\t\tast_debug(1, \"SQL command as follows: %s\\n\", ast_str_buffer(sql1));\n\t\t\t}\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Cannot connect to database server %s: (%d) %s\\n\", ast_str_buffer(hostname), mysql_errno(&mysql), mysql_error(&mysql));\n\t\t\tconnected = 0;\n\t\t}\n\t} else {\n\t\t\n\t\tint error;\n\t\tif ((error = mysql_ping(&mysql))) {\n\t\t\tconnected = 0;\n\t\t\trecords = 0;\n\t\t\tswitch (mysql_errno(&mysql)) {\n\t\t\t\tcase CR_SERVER_GONE_ERROR:\n\t\t\t\tcase CR_SERVER_LOST:\n\t\t\t\t\tast_log(LOG_ERROR, \"Server has gone away. Attempting to reconnect.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tast_log(LOG_ERROR, \"Unknown connection error: (%d) %s\\n\", mysql_errno(&mysql), mysql_error(&mysql));\n\t\t\t}\n\t\t\tretries--;\n\t\t\tif (retries) {\n\t\t\t\tgoto db_reconnect;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_ERROR, \"Retried to connect five times, giving up.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif (connected) {\n\t\tint column_count = 0;\n\t\tchar *cdrname;\n\t\tchar workspace[2048], *value = NULL;\n\t\tstruct column *entry;\n\t\tstruct ast_str *escape = ast_str_thread_get(&escape_buf, 16);\n\t\tast_str_set(&sql1, 0, \"INSERT INTO %s (\", AS_OR(dbtable, \"cdr\"));\n\t\tast_str_set(&sql2, 0, \") VALUES (\");\n\t\tAST_RWLIST_RDLOCK(&columns);\n\t\tAST_RWLIST_TRAVERSE(&columns, entry, list) {\n\t\t\tif (!strcmp(entry->name, \"calldate\")) {\n\t\t\t\t\n\t\t\t\tif (calldate_compat) {\n\t\t\t\t\tstruct timeval tv = ast_tvnow();\n\t\t\t\t\tstruct ast_tm tm;\n\t\t\t\t\tchar timestr[128];\n\t\t\t\t\tast_localtime(&tv, &tm, ast_str_strlen(cdrzone) ? ast_str_buffer(cdrzone) : NULL);\n\t\t\t\t\tast_strftime(timestr, sizeof(timestr), DATE_FORMAT, &tm);\n\t\t\t\t\tvalue = ast_strdupa(timestr);\n\t\t\t\t\tcdrname = \"calldate\";\n\t\t\t\t} else {\n\t\t\t\t\tcdrname = \"start\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcdrname = entry->cdrname;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif (entry->staticvalue) {\n\t\t\t\tvalue = ast_strdupa(entry->staticvalue);\n\t\t\t} else if ((!strcmp(cdrname, \"disposition\") ||\n\t\t\t\t !strcmp(cdrname, \"amaflags\")) &&\n\t\t\t\t(strstr(entry->type, \"int\") ||\n\t\t\t\t strstr(entry->type, \"dec\") ||\n\t\t\t\t strstr(entry->type, \"float\") ||\n\t\t\t\t strstr(entry->type, \"double\") ||\n\t\t\t\t strstr(entry->type, \"real\") ||\n\t\t\t\t strstr(entry->type, \"numeric\") ||\n\t\t\t\t strstr(entry->type, \"fixed\"))) {\n\t\t\t\tast_cdr_format_var(cdr, cdrname, &value, workspace, sizeof(workspace), 1);\n\t\t\t} else if (!strcmp(cdrname, \"start\") || !strcmp(cdrname, \"answer\") ||\n\t\t\t\t !strcmp(cdrname, \"end\")) {\n\t\t\t\tstruct ast_tm tm;\n\t\t\t\tchar timestr[128];\n\t\t\t\tast_localtime(&cdr->start, &tm, ast_str_strlen(cdrzone) ? ast_str_buffer(cdrzone) : NULL);\n\t\t\t\tast_strftime(timestr, sizeof(timestr), DATE_FORMAT, &tm);\n\t\t\t\tvalue = ast_strdupa(timestr);\n\t\t\t} else if (!strcmp(cdrname, \"calldate\")) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tast_cdr_format_var(cdr, cdrname, &value, workspace, sizeof(workspace), 0);\n\t\t\t}\n\t\t\tif (value) {\n\t\t\t\tsize_t valsz;\n\t\t\t\tif (column_count++) {\n\t\t\t\t\tast_str_append(&sql1, 0, \",\");\n\t\t\t\t\tast_str_append(&sql2, 0, \",\");\n\t\t\t\t}\n\t\t\t\tif (!strcasecmp(cdrname, \"billsec\") &&\n\t\t\t\t\t(strstr(entry->type, \"float\") ||\n\t\t\t\t\tstrstr(entry->type, \"double\") ||\n\t\t\t\t\tstrstr(entry->type, \"decimal\") ||\n\t\t\t\t\tstrstr(entry->type, \"numeric\") ||\n\t\t\t\t\tstrstr(entry->type, \"real\"))) {\n\t\t\t\t\tif (!ast_tvzero(cdr->answer)) {\n\t\t\t\t\t\tsnprintf(workspace, sizeof(workspace), \"%lf\",\n\t\t\t\t\t\t\t(double) (ast_tvdiff_us(cdr->end, cdr->answer) / 1000000.0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_copy_string(workspace, \"0\", sizeof(workspace));\n\t\t\t\t\t}\n\t\t\t\t\tif (!ast_strlen_zero(workspace)) {\n\t\t\t\t\t\tvalue = workspace;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!strcasecmp(cdrname, \"duration\") &&\n\t\t\t\t\t(strstr(entry->type, \"float\") ||\n\t\t\t\t\tstrstr(entry->type, \"double\") ||\n\t\t\t\t\tstrstr(entry->type, \"decimal\") ||\n\t\t\t\t\tstrstr(entry->type, \"numeric\") ||\n\t\t\t\t\tstrstr(entry->type, \"real\"))) {\n\t\t\t\t\tsnprintf(workspace, sizeof(workspace), \"%lf\",\n\t\t\t\t\t\t(double) (ast_tvdiff_us(cdr->end, cdr->start) / 1000000.0));\n\t\t\t\t\tif (!ast_strlen_zero(workspace)) {\n\t\t\t\t\t\tvalue = workspace;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tast_str_make_space(&escape, (valsz = strlen(value)) * 2 + 1);\n\t\t\t\tmysql_real_escape_string(&mysql, ast_str_buffer(escape), value, valsz);\n\t\t\t\tast_str_append(&sql1, 0, \"`%s`\", entry->name);\n\t\t\t\tast_str_append(&sql2, 0, \"'%s'\", ast_str_buffer(escape));\n\t\t\t}\n\t\t}\n\t\tAST_RWLIST_UNLOCK(&columns);\n\t\tast_debug(1, \"Inserting a CDR record.\\n\");\n\t\tast_str_append(&sql1, 0, \"%s)\", ast_str_buffer(sql2));\n\t\tast_debug(1, \"SQL command as follows: %s\\n\", ast_str_buffer(sql1));\n\t\tif (mysql_real_query(&mysql, ast_str_buffer(sql1), ast_str_strlen(sql1))) {\n\t\t\tast_log(LOG_ERROR, \"Failed to insert into database: (%d) %s\\n\", mysql_errno(&mysql), mysql_error(&mysql));\n\t\t\tmysql_close(&mysql);\n\t\t\tconnected = 0;\n\t\t} else {\n\t\t\trecords++;\n\t\t\ttotalrecords++;\n\t\t}\n\t}\n\tast_mutex_unlock(&mysql_lock);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2081}
{"project": "Asterisk", "target": 0, "func": "\nstatic char *ht_new(int i)\n{\n\tconst int buflen = 12;\n\tchar *keybuf = ao2_alloc(buflen, ht_delete);\n\tint needed;\n\tif (keybuf == NULL) {\n\t\treturn NULL;\n\t}\n\tneeded = snprintf(keybuf, buflen, \"key%08x\", (unsigned)i);\n\tast_atomic_fetchadd_int(&alloc_count, 1);\n\tast_assert(needed + 1 <= buflen);\n\treturn keybuf;\n}\n", "bug_type": null, "idx": 2082}
{"project": "Asterisk", "target": 0, "func": "AST_TEST_DEFINE(invoke_not_found)\n{\n\tRAII_VAR(void *, fixture, NULL, tear_down_invocation_test);\n\tRAII_VAR(struct ast_ari_response *, response, NULL, response_free);\n\tstruct ast_variable *get_params = NULL;\n\tstruct ast_variable *headers = NULL;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = __func__;\n\t\tinfo->category = \"/res/ari/\";\n\t\tinfo->summary = \"Test GET on a resource that does not exist.\";\n\t\tinfo->description = \"Test ARI binding logic.\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tfixture = setup_invocation_test();\n\tresponse = response_alloc();\n\tast_ari_invoke(NULL, \"foo/fizzle/i-am-not-a-resource\", AST_HTTP_GET, get_params, headers,\n\t\tast_json_null(), response);\n\tast_test_validate(test, 0 == invocation_count);\n\tast_test_validate(test, 404 == response->response_code);\n\treturn AST_TEST_PASS;\n}\n", "bug_type": null, "idx": 2083}
{"project": "Asterisk", "target": 0, "func": "static struct ast_sip_cli_formatter_entry *cli_formatter;\nstruct ast_sip_transport_state *ast_sip_get_transport_state(const char *transport_id)\n{\n\tstruct internal_state *state = NULL;\n\tstruct ast_sip_transport_state *trans_state;\n\tif (!transport_states) {\n\t\treturn NULL;\n\t}\n\tstate = ao2_find(transport_states, transport_id, OBJ_SEARCH_KEY);\n\tif (!state) {\n\t\treturn NULL;\n\t}\n\ttrans_state = ao2_bump(state->state);\n\tao2_ref(state, -1);\n\treturn trans_state;\n}\n", "bug_type": null, "idx": 2084}
{"project": "Asterisk", "target": 0, "func": "protected int\nel_read_setfn(EditLine *el, el_rfunc_t rc)\n{\n\tel->el_read.read_char = (rc == EL_BUILTIN_GETCFN) ? read_char : rc;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2085}
{"project": "Asterisk", "target": 0, "func": "\nstatic int multicast_rtp_destroy(struct ast_rtp_instance *instance)\n{\n\tstruct multicast_rtp *multicast = ast_rtp_instance_get_data(instance);\n\tif (multicast->type == MULTICAST_TYPE_LINKSYS) {\n\t\tmulticast_send_control_packet(instance, multicast, LINKSYS_MCAST_STOPCMD);\n\t}\n\tif (multicast->smoother) {\n\t\tast_smoother_free(multicast->smoother);\n\t}\n\tclose(multicast->socket);\n\tast_free(multicast);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2086}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225_SeqOfH225SupportedProtocols (OOCTXT* pctxt, H225_SeqOfH225SupportedProtocols* pvalue)\n{\n   int stat = ASN_OK;\n   DListNode* pnode;\n   ASN1UINT xx1;\n   ASN1UINT enclen, fraglen;\n   enclen = fraglen = xx1 = 0;\n   pnode = pvalue->head;\n   for (;;) {\n      \n      stat = encodeLength (pctxt, (pvalue->count - enclen));\n      if (stat < 0) return stat;\n      fraglen = stat;\n      enclen += fraglen;\n      \n      for (; xx1 < enclen; xx1++) {\n         stat = asn1PE_H225SupportedProtocols (pctxt, ((H225SupportedProtocols*)pnode->data));\n         if (stat != ASN_OK) return stat;\n         pnode = pnode->next;\n      }\n      if ( pvalue->count == enclen && fraglen < 16384) {\n         break;\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2087}
{"project": "Asterisk", "target": 0, "func": "void ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\tint line_num, const char *func, const char *lock_name, void *lock_addr, struct ast_bt *bt)\n{\n}\n}\nvoid ast_store_lock_info(enum ast_lock_type type, const char *filename,\n\tint line_num, const char *func, const char *lock_name, void *lock_addr)\n{\n}\n", "bug_type": null, "idx": 2088}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int process_token(void *out, char *src, int maxlen, int argtype)\n{\n\tif ((strlen(src) > 1) && src[0] == '\\\"') {\n\t\t\n\t\tif (!(argtype & ARG_STRING))\n\t\t\treturn -1;\n\t\tsrc++;\n\t\t\n\t\tif (maxlen > strlen(src) - 1)\n\t\t\tmaxlen = strlen(src) - 1;\n\t\tmemcpy(out, src, maxlen);\n\t\t((char *)out)[maxlen] = '\\0';\n\t} else if (!ast_strlen_zero(src) && (src[0] == '\\\\')) {\n\t\tif (!(argtype & ARG_NUMBER))\n\t\t\treturn -1;\n\t\t\n\t\tif (sscanf(src, \"%30o\", (unsigned *)out) != 1)\n\t\t\treturn -1;\n\t\tif (argtype & ARG_STRING) {\n\t\t\t\n\t\t\t*((unsigned int *)out) = htonl(*((unsigned int *)out));\n\t\t}\n\t} else if ((strlen(src) > 2) && (src[0] == '0') && (tolower(src[1]) == 'x')) {\n\t\tif (!(argtype & ARG_NUMBER))\n\t\t\treturn -1;\n\t\t\n\t\tif (sscanf(src + 2, \"%30x\", (unsigned int *)out) != 1)\n\t\t\treturn -1;\n\t\tif (argtype & ARG_STRING) {\n\t\t\t\n\t\t\t*((unsigned int *)out) = htonl(*((unsigned int *)out));\n\t\t}\n\t} else if ((!ast_strlen_zero(src) && isdigit(src[0]))) {\n\t\tif (!(argtype & ARG_NUMBER))\n\t\t\treturn -1;\n\t\t\n\t\tif (sscanf(src, \"%30d\", (int *)out) != 1)\n\t\t\treturn -1;\n\t\tif (argtype & ARG_STRING) {\n\t\t\t\n\t\t\t*((unsigned int *)out) = htonl(*((unsigned int *)out));\n\t\t}\n\t} else\n\t\treturn -1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2089}
{"project": "Asterisk", "target": 0, "func": "static void *monmp3thread(void *data)\n{\n#define\tMOH_MS_INTERVAL\t\t100\n\tstruct mohclass *class = data;\n\tstruct mohdata *moh;\n\tshort sbuf[8192];\n\tint res = 0, res2;\n\tint len;\n\tstruct timeval deadline, tv_tmp;\n\tdeadline.tv_sec = 0;\n\tdeadline.tv_usec = 0;\n\tfor(;;) {\n\t\tpthread_testcancel();\n\t\t\n\t\tif (class->srcfd < 0) {\n\t\t\tif ((class->srcfd = spawn_mp3(class)) < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to spawn mp3player\\n\");\n\t\t\t\t\n\t\t\t\tsleep(500);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (class->timer) {\n\t\t\tstruct pollfd pfd = { .fd = ast_timer_fd(class->timer), .events = POLLIN | POLLPRI, };\n#ifdef SOLARIS\n\t\t\tthr_yield();\n#endif\n\t\t\t\n\t\t\tif (ast_poll(&pfd, 1, -1) > 0) {\n\t\t\t\tif (ast_timer_ack(class->timer, 1) < 0) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Failed to acknowledge timer for mp3player\\n\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tres = 320; \n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"poll() failed: %s\\n\", strerror(errno));\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tpthread_testcancel();\n\t\t} else {\n\t\t\tlong delta;\n\t\t\t\n\t\t\ttv_tmp = ast_tvnow();\n\t\t\tif (ast_tvzero(deadline))\n\t\t\t\tdeadline = tv_tmp;\n\t\t\tdelta = ast_tvdiff_ms(tv_tmp, deadline);\n\t\t\tif (delta < MOH_MS_INTERVAL) {\t\n\t\t\t\tdeadline = ast_tvadd(deadline, ast_samp2tv(MOH_MS_INTERVAL, 1000));\t\n\t\t\t\tusleep(1000 * (MOH_MS_INTERVAL - delta));\n\t\t\t\tpthread_testcancel();\n\t\t\t} else {\n\t\t\t\tast_log(LOG_NOTICE, \"Request to schedule in the past?!?!\\n\");\n\t\t\t\tdeadline = tv_tmp;\n\t\t\t}\n\t\t\t\n\t\t\tres = 8 * MOH_MS_INTERVAL; \n\t\t}\n\t\t\n\t\tres = res * ast_format_get_sample_rate(class->format) / 8000;\n\t\tif ((strncasecmp(class->dir, \"http://\", 7) && strcasecmp(class->dir, \"nodir\")) && AST_LIST_EMPTY(&class->members))\n\t\t\tcontinue;\n\t\t\n\t\tlen = ast_format_determine_length(class->format, res);\n\t\tif ((res2 = read(class->srcfd, sbuf, len)) != len) {\n\t\t\tif (!res2) {\n\t\t\t\tclose(class->srcfd);\n\t\t\t\tclass->srcfd = -1;\n\t\t\t\tpthread_testcancel();\n\t\t\t\tif (class->pid > 1) {\n\t\t\t\t\tkillpid(class->pid, class->kill_delay, class->kill_method);\n\t\t\t\t\tclass->pid = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_debug(1, \"Read %d bytes of audio while expecting %d\\n\", res2, len);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tpthread_testcancel();\n\t\tao2_lock(class);\n\t\tAST_LIST_TRAVERSE(&class->members, moh, list) {\n\t\t\t\n\t\t\tif ((res = write(moh->pipe[1], sbuf, res2)) != res2) {\n\t\t\t\tast_debug(1, \"Only wrote %d of %d bytes to pipe\\n\", res, res2);\n\t\t\t}\n\t\t}\n\t\tao2_unlock(class);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2090}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *moh_files_readframe(struct ast_channel *chan)\n{\n\tstruct ast_frame *f = NULL;\n\tif (!(ast_channel_stream(chan) && (f = ast_readframe(ast_channel_stream(chan))))) {\n\t\tif (!ast_moh_files_next(chan))\n\t\t\tf = ast_readframe(ast_channel_stream(chan));\n\t}\n\treturn f;\n}\n", "bug_type": null, "idx": 2091}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_pubsub_generate_body_content(const char *type, const char *subtype,\n\t\tstruct ast_sip_body_data *data, struct ast_str **str)\n{\n\tstruct ast_sip_pubsub_body_supplement *supplement;\n\tstruct ast_sip_pubsub_body_generator *generator;\n\tint res = 0;\n\tvoid *body;\n\tgenerator = find_body_generator_type_subtype(type, subtype);\n\tif (!generator) {\n\t\tast_log(LOG_WARNING, \"Unable to find a body generator for %s/%s\\n\",\n\t\t\t\ttype, subtype);\n\t\treturn -1;\n\t}\n\tif (strcmp(data->body_type, generator->body_type)) {\n\t\tast_log(LOG_WARNING, \"%s/%s body generator does not accept the type of data provided\\n\",\n\t\t\ttype, subtype);\n\t\treturn -1;\n\t}\n\tbody = generator->allocate_body(data->body_data);\n\tif (!body) {\n\t\tast_log(LOG_WARNING, \"%s/%s body generator could not to allocate a body\\n\",\n\t\t\ttype, subtype);\n\t\treturn -1;\n\t}\n\tif (generator->generate_body_content(body, data->body_data)) {\n\t\tres = -1;\n\t\tgoto end;\n\t}\n\tAST_RWLIST_RDLOCK(&body_supplements);\n\tAST_RWLIST_TRAVERSE(&body_supplements, supplement, list) {\n\t\tif (!strcmp(generator->type, supplement->type) &&\n\t\t\t\t!strcmp(generator->subtype, supplement->subtype)) {\n\t\t\tres = supplement->supplement_body(body, data->body_data);\n\t\t\tif (res) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&body_supplements);\n\tif (!res) {\n\t\tgenerator->to_string(body, str);\n\t}\nend:\n\tif (generator->destroy_body) {\n\t\tgenerator->destroy_body(body);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2092}
{"project": "Asterisk", "target": 0, "func": "static int cc_stop_ringing(void *data)\n{\n\tstruct cc_core_instance *core_instance = data;\n\tint res = 0;\n\tif (core_instance->agent->callbacks->stop_ringing) {\n\t\tres = core_instance->agent->callbacks->stop_ringing(core_instance->agent);\n\t}\n\t\n\tast_cc_monitor_request_acked(core_instance->core_id, \"Agent %s asked to stop ringing. Be prepared to be recalled again.\",\n\t\t\tcore_instance->agent->device_name);\n\tcc_unref(core_instance, \"Stop ringing finished. Unref core_instance\");\n\treturn res;\n}\n", "bug_type": null, "idx": 2093}
{"project": "Asterisk", "target": 0, "func": "void check_switch_expr(pval *item, struct argapp *apps)\n{\n#ifdef AAL_ARGCHECK\n\t\n\tchar *buff1, *p;\n\tstruct argapp *a,*a2;\n\tstruct appsetvar *v,*v2;\n\tstruct argchoice *c;\n\tpval *t;\n\tp = item->u1.str;\n\twhile (p && *p && (*p == ' ' || *p == '\\t' || *p == '$' || *p == '{' ) )\n\t\tp++;\n\tbuff1 = ast_strdupa(p);\n\twhile (strlen(buff1) > 0 && ( buff1[strlen(buff1)-1] == '}' || buff1[strlen(buff1)-1] == ' ' || buff1[strlen(buff1)-1] == '\\t'))\n\t\tbuff1[strlen(buff1)-1] = 0;\n\t\n\tv = 0;\n\tfor (a=apps; a; a=a->next) {\n\t\tfor (v=a->setvars;v;v=v->next) {\n\t\t\tif (strcmp(v->name,buff1) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( v )\n\t\t\tbreak;\n\t}\n\tif (v && v->vals) {\n\t\t\n\t\tint def= 0;\n\t\tint pat = 0;\n\t\tint f1 = 0;\n\t\t\n\t\tfor (t=item->u2.statements; t; t=t->next) {\n\t\t\tif (t->type == PV_DEFAULT) {\n\t\t\t\tdef =1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->type == PV_PATTERN) {\n\t\t\t\tpat++;\n\t\t\t}\n\t\t}\n\t\tif (def || pat) \n\t\t\treturn;\n\t\tfor (c=v->vals; c; c=c->next) {\n\t\t\tf1 = 0;\n\t\t\tfor (t=item->u2.statements; t; t=t->next) {\n\t\t\t\tif (t->type == PV_CASE || t->type == PV_PATTERN) {\n\t\t\t\t\tif (!strcmp(t->u1.str,c->name)) {\n\t\t\t\t\t\tf1 = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f1) {\n\t\t\t\tast_log(LOG_WARNING,\"Warning: file %s, line %d-%d: switch with expression(%s) does not handle the case of %s !\\n\",\n\t\t\t\t\t\titem->filename, item->startline, item->endline, item->u1.str, c->name);\n\t\t\t\twarns++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tf1 = 0;\n\t\tt = current_extension->u2.statements;\n\t\tif ( t && t->type == PV_STATEMENTBLOCK )\n\t\t\tt = t->u1.statements;\n\t\tfor (; t && t != item; t=t->next) {\n\t\t\tif (t->type == PV_APPLICATION_CALL) {\n\t\t\t\t\n\t\t\t\tfor (a2=apps; a2; a2=a2->next) {\n\t\t\t\t\tif (strcasecmp(a2->name, t->u1.str)==0) {\n\t\t\t\t\t\tfor (v2=a2->setvars; v2; v2=v2->next) {\n\t\t\t\t\t\t\tif (strcmp(v2->name, buff1) == 0) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tf1 = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f1)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (!f1) {\n\t\t\tast_log(LOG_WARNING,\"Warning: file %s, line %d-%d: Couldn't find an application call in this extension that sets the  expression (%s) value!\\n\",\n\t\t\t\t\titem->filename, item->startline, item->endline, item->u1.str);\n\t\t\twarns++;\n\t\t}\n\t}\n#else\n\tpval *t,*tl=0,*p2;\n\tint def= 0;\n\t\n\tfor (t=item->u2.statements; t; t=t->next) {\n\t\tif (t->type == PV_DEFAULT) {\n\t\t\tdef =1;\n\t\t\tbreak;\n\t\t}\n\t\ttl = t;\n\t}\n\tif (def) \n\t\treturn;\n\t\n\tp2 = tl->next = calloc(1, sizeof(struct pval));\n\tp2->type = PV_DEFAULT;\n\tp2->startline = tl->startline;\n\tp2->endline = tl->endline;\n\tp2->startcol = tl->startcol;\n\tp2->endcol = tl->endcol;\n\tp2->filename = strdup(tl->filename);\n\tast_log(LOG_WARNING,\"Warning: file %s, line %d-%d: A default case was automatically added to the switch.\\n\",\n\t\t\tp2->filename, p2->startline, p2->endline);\n\twarns++;\n#endif\n}\n", "bug_type": null, "idx": 2094}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_sip_get_keep_alive_interval(void)\n{\n\tunsigned int interval;\n\tstruct global_config *cfg;\n\tcfg = get_global_cfg();\n\tif (!cfg) {\n\t\treturn DEFAULT_KEEPALIVE_INTERVAL;\n\t}\n\tinterval = cfg->keep_alive_interval;\n\tao2_ref(cfg, -1);\n\treturn interval;\n}\n", "bug_type": null, "idx": 2095}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_send_out_of_dialog_request(pjsip_tx_data *tdata,\n\tstruct ast_sip_endpoint *endpoint, int timeout, void *token,\n\tvoid (*callback)(void *token, pjsip_event *e))\n{\n\tstruct ast_sip_supplement *supplement;\n\tstruct send_request_data *req_data;\n\tstruct ast_sip_contact *contact;\n\treq_data = send_request_data_alloc(endpoint, token, callback);\n\tif (!req_data) {\n\t\tpjsip_tx_data_dec_ref(tdata);\n\t\treturn -1;\n\t}\n\tcontact = ast_sip_mod_data_get(tdata->mod_data, supplement_module.id, MOD_DATA_CONTACT);\n\tAST_RWLIST_RDLOCK(&supplements);\n\tAST_LIST_TRAVERSE(&supplements, supplement, next) {\n\t\tif (supplement->outgoing_request\n\t\t\t&& does_method_match(&tdata->msg->line.req.method.name, supplement->method)) {\n\t\t\tsupplement->outgoing_request(endpoint, contact, tdata);\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&supplements);\n\tast_sip_mod_data_set(tdata->pool, tdata->mod_data, supplement_module.id, MOD_DATA_CONTACT, NULL);\n\tao2_cleanup(contact);\n\tif (endpt_send_request(endpoint, tdata, timeout, req_data, send_request_cb)\n\t\t!= PJ_SUCCESS) {\n\t\tao2_cleanup(req_data);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2096}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void sorcery_memory_cache_load(void *data, const struct ast_sorcery *sorcery, const char *type)\n{\n\tstruct sorcery_memory_cache *cache = data;\n\t\n\tif (ast_strlen_zero(cache->name)) {\n\t\tast_asprintf(&cache->name, \"%s/%s\", ast_sorcery_get_module(sorcery), type);\n\t}\n\tao2_link(caches, cache);\n\tast_debug(1, \"Memory cache '%s' associated with sorcery instance '%p' of module '%s' with object type '%s'\\n\",\n\t\tcache->name, sorcery, ast_sorcery_get_module(sorcery), type);\n\tcache->sorcery = sorcery;\n\tcache->object_type = ast_strdup(type);\n}\n", "bug_type": null, "idx": 2097}
{"project": "Asterisk", "target": 0, "func": "int control_is_done(struct stasis_app_control *control)\n{\n\t\n\treturn control->is_done;\n}\n", "bug_type": null, "idx": 2098}
{"project": "Asterisk", "target": 0, "func": "\nstatic void mwi_contact_updated(const void *object)\n{\n\tmwi_contact_changed(object);\n}\n", "bug_type": null, "idx": 2099}
{"project": "Asterisk", "target": 0, "func": "int ast_sip_pubsub_is_body_generator_registered(const char *type, const char *subtype)\n{\n\treturn !!find_body_generator_type_subtype(type, subtype);\n}\n", "bug_type": null, "idx": 2100}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct tree_node *tree_node_alloc(const char *resource, struct resources *visited, unsigned int full_state)\n{\n\tstruct tree_node *node;\n\tnode = ast_calloc(1, sizeof(*node) + strlen(resource) + 1);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tstrcpy(node->resource, resource);\n\tif (AST_VECTOR_INIT(&node->children, 4)) {\n\t\tast_free(node);\n\t\treturn NULL;\n\t}\n\tnode->full_state = full_state;\n\tif (visited) {\n\t\tAST_VECTOR_APPEND(visited, resource);\n\t}\n\treturn node;\n}\n", "bug_type": null, "idx": 2101}
{"project": "Asterisk", "target": 0, "func": "static char *complete_confno(const char *word, int state)\n{\n\tstruct ast_conference *cnf;\n\tchar *ret = NULL;\n\tint which = 0;\n\tint len = strlen(word);\n\tAST_LIST_LOCK(&confs);\n\tAST_LIST_TRAVERSE(&confs, cnf, list) {\n\t\tif (!strncmp(word, cnf->confno, len) && ++which > state) {\n\t\t\t\n\t\t\tret = ast_strdup(cnf->confno);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(&confs);\n\treturn ret;\n}\n", "bug_type": null, "idx": 2102}
{"project": "Asterisk", "target": 0, "func": "\nint ast_get_enum(struct ast_channel *chan, const char *number, char *dst, int dstlen, char *tech, int techlen, char* suffix, char* options, unsigned int record, struct enum_context **argcontext)\n{\n\tstruct enum_context *context;\n\tchar tmp[512];\n\tchar domain[256];\n\tchar left[128];\n\tchar middle[128];\n\tchar naptrinput[128];\n\tchar apex[128] = \"\";\n\tint ret = -1;\n\t\n\tchar *p1 = NULL;\n\tchar *p2 = NULL;\n\tchar *p3 = NULL;\n\tint k = 0;\n\tint i = 0;\n\tint z = 0;\n\tint spaceleft = 0;\n\tstruct timeval time_start, time_end;\n\tif (ast_strlen_zero(suffix)) {\n\t\tast_log(LOG_WARNING, \"ast_get_enum need a suffix parameter now.\\n\");\n\t\treturn -1;\n\t}\n\tast_debug(2, \"num='%s', tech='%s', suffix='%s', options='%s', record=%u\\n\", number, tech, suffix, options, record);\n\n\n\tast_copy_string(naptrinput, number[0] == 'n' ? number + 1 : number, sizeof(naptrinput));\n\tif (number[0] == '+') {\n\t\tnumber++;\n\t}\n\tif (!(context = ast_calloc(1, sizeof(*context)))) {\n\t\treturn -1;\n\t}\n\tif ((p3 = strchr(naptrinput, '*'))) {\n\t\t*p3='\\0';\n\t}\n\tcontext->naptrinput = naptrinput;\t\n\tcontext->dst = dst;\t\t\t\n\tcontext->dstlen = dstlen;\n\tcontext->tech = tech;\n\tcontext->techlen = techlen;\n\tcontext->options = 0;\n\tcontext->position = record > 0 ? record : 1;\n\tcontext->count = 0;\n\tcontext->naptr_rrs = NULL;\n\tcontext->naptr_rrs_count = 0;\n\t\n\tif (options != NULL) {\n\t\tif (strchr(options,'s')) {\n\t\t\tcontext->options |= ENUMLOOKUP_OPTIONS_ISN;\n\t\t} else if (strchr(options,'i')) {\n\t\t\tcontext->options |= ENUMLOOKUP_OPTIONS_IENUM;\n\t\t} else if (strchr(options,'d')) {\n\t\t\tcontext->options |= ENUMLOOKUP_OPTIONS_DIRECT;\n\t\t}\n\t\tif (strchr(options,'c')) {\n\t\t\tcontext->options |= ENUMLOOKUP_OPTIONS_COUNT;\n\t\t}\n\t\tif (strchr(number,'*')) {\n\t\t\tcontext->options |= ENUMLOOKUP_OPTIONS_ISN;\n\t\t}\n\t}\n\tast_debug(2, \"ENUM options(%s): pos=%d, options='%d'\\n\", options, context->position, context->options);\n\tast_debug(1, \"n='%s', tech='%s', suffix='%s', options='%d', record='%d'\\n\",\n\t\t\tnumber, tech, suffix, context->options, context->position);\n\t\n\t\n\tast_copy_string(left, number, sizeof(left));\n\tmiddle[0] = '\\0';\n\t\n\tast_copy_string(apex, suffix, sizeof(apex));\n\t\n\tif ((context->options & ENUMLOOKUP_OPTIONS_ISN) && (p1 = strchr(number, '*'))) {\n\t\t*p1++ = '\\0';\n\t\tast_copy_string(left, number, sizeof(left));\n\t\tast_copy_string(middle, p1, sizeof(middle) - 1);\n\t\tstrcat(middle, \".\");\n\t\tast_debug(2, \"ISN ENUM: left=%s, middle='%s'\\n\", left, middle);\n\t\n\t} else if (context->options & ENUMLOOKUP_OPTIONS_DIRECT) {\n\t\tleft[0] = 0; \n\t\tast_copy_string(middle, number, sizeof(middle) - 1);\n\t\tstrcat(middle, \".\");\n\t\tast_debug(2, \"DIRECT ENUM:  middle='%s'\\n\", middle);\n\t\n\t} else if (context->options & ENUMLOOKUP_OPTIONS_IENUM) {\n\t\tint sdl = 0;\n\t\tchar cc[8];\n\t\tchar sep[256], n_apex[256];\n\t\tint cc_len = cclen(number);\n\t\tsdl = cc_len;\n\t\tast_mutex_lock(&enumlock);\n\t\tast_copy_string(sep, ienum_branchlabel, sizeof(sep)); \n\t\tast_mutex_unlock(&enumlock);\n\t\tswitch (ebl_alg) {\n\t\tcase ENUMLOOKUP_BLR_EBL:\n\t\t\tast_copy_string(cc, number, cc_len); \n\t\t\tsdl = blr_ebl(cc, suffix, sep, sizeof(sep) - 1, n_apex, sizeof(n_apex) - 1);\n\t\t\tif (sdl >= 0) {\n\t\t\t\tast_copy_string(apex, n_apex, sizeof(apex));\n\t\t\t\tast_debug(2, \"EBL ENUM: sep=%s, apex='%s'\\n\", sep, n_apex);\n\t\t\t} else {\n\t\t\t\tsdl = cc_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENUMLOOKUP_BLR_TXT:\n\t\t\tast_copy_string(cc, number, cc_len); \n\t\t\tsdl = blr_txt(cc, suffix);\n\t\t\tif (sdl < 0) {\n\t\t\t\tsdl = cc_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENUMLOOKUP_BLR_CC:\t\n\t\tdefault:\n\t\t\tsdl = cc_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (sdl > strlen(number)) {\t\n\t\t\tast_log(LOG_WARNING, \"I-ENUM: subdomain location %d behind number %s\\n\", sdl, number);\n\t\t\tast_free(context);\n\t\t\treturn 0;\n\t\t}\n\t\tast_copy_string(left, number + sdl, sizeof(left));\n\t\tast_mutex_lock(&enumlock);\n\t\tast_copy_string(middle, sep, sizeof(middle) - 1);\n\t\tstrcat(middle, \".\");\n\t\tast_mutex_unlock(&enumlock);\n\t\t\n\t\tif ((sdl * 2 + strlen(middle) + 2) > sizeof(middle)) {\n\t\t\tast_log(LOG_WARNING, \"ast_get_enum: not enough space for I-ENUM rewrite.\\n\");\n\t\t\tast_free(context);\n\t\t\treturn -1;\n\t\t}\n\t\tp1 = middle + strlen(middle);\n\t\tfor (p2 = (char *) number + sdl - 1; p2 >= number; p2--) {\n\t\t\tif (isdigit(*p2)) {\n\t\t\t\t*p1++ = *p2;\n\t\t\t\t*p1++ = '.';\n\t\t\t}\n\t\t}\n\t\t*p1 = '\\0';\n\t\tast_debug(2, \"I-ENUM: cclen=%d, left=%s, middle='%s', apex='%s'\\n\", cc_len, left, middle, apex);\n\t}\n\tif (strlen(left) * 2 + 2 > sizeof(domain)) {\n\t\tast_log(LOG_WARNING, \"string to long in ast_get_enum\\n\");\n\t\tast_free(context);\n\t\treturn -1;\n\t}\n\t\n\tp1 = domain;\n\tfor (p2 = left + strlen(left); p2 >= left; p2--) {\n\t\tif (isdigit(*p2)) {\n\t\t\t*p1++ = *p2;\n\t\t\t*p1++ = '.';\n\t\t}\n\t}\n\t*p1 = '\\0';\n\tif (chan && ast_autoservice_start(chan) < 0) {\n\t\tast_free(context);\n\t\treturn -1;\n\t}\n\tspaceleft = sizeof(tmp) - 2;\n\tast_copy_string(tmp, domain, spaceleft);\n\tspaceleft -= strlen(domain);\n\tif (*middle) {\n\t\tstrncat(tmp, middle, spaceleft);\n\t\tspaceleft -= strlen(middle);\n\t}\n\tstrncat(tmp,apex,spaceleft);\n\ttime_start = ast_tvnow();\n\tret = ast_search_dns(context, tmp, C_IN, T_NAPTR, enum_callback);\n\ttime_end = ast_tvnow();\n\tast_debug(2, \"profiling: %s, %s, %\" PRIi64 \" ms\\n\",\n\t\t\t(ret == 0) ? \"OK\" : \"FAIL\", tmp, ast_tvdiff_ms(time_end, time_start));\n\tif (ret < 0) {\n\t\tast_debug(1, \"No such number found: %s (%s)\\n\", tmp, strerror(errno));\n\t\tcontext->naptr_rrs_count = -1;\n\t\tstrcpy(dst, \"0\");\n\t\tret = 0;\n\t}\n\tif (context->naptr_rrs_count >= context->position && ! (context->options & ENUMLOOKUP_OPTIONS_COUNT)) {\n\t\t\n\t\tfor (k = 0; k < context->naptr_rrs_count; k++) {\n\t\t\tfor (i = 0; i < context->naptr_rrs_count; i++) {\n\t\t\t\t\n\t\t\t\tif ((ntohs(context->naptr_rrs[k].naptr.order) < ntohs(context->naptr_rrs[i].naptr.order)\n\t\t\t\t     && context->naptr_rrs[k].sort_pos > context->naptr_rrs[i].sort_pos)\n\t\t\t\t     || (ntohs(context->naptr_rrs[k].naptr.order) > ntohs(context->naptr_rrs[i].naptr.order)\n\t\t\t\t     && context->naptr_rrs[k].sort_pos < context->naptr_rrs[i].sort_pos)) {\n\t\t\t\t\tz = context->naptr_rrs[k].sort_pos;\n\t\t\t\t\tcontext->naptr_rrs[k].sort_pos = context->naptr_rrs[i].sort_pos;\n\t\t\t\t\tcontext->naptr_rrs[i].sort_pos = z;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ntohs(context->naptr_rrs[k].naptr.order) == ntohs(context->naptr_rrs[i].naptr.order)) {\n\t\t\t\t\tif ((ntohs(context->naptr_rrs[k].naptr.pref) < ntohs(context->naptr_rrs[i].naptr.pref)\n\t\t\t\t\t     && context->naptr_rrs[k].sort_pos > context->naptr_rrs[i].sort_pos)\n\t\t\t\t\t     || (ntohs(context->naptr_rrs[k].naptr.pref) > ntohs(context->naptr_rrs[i].naptr.pref)\n\t\t\t\t\t     && context->naptr_rrs[k].sort_pos < context->naptr_rrs[i].sort_pos)) {\n\t\t\t\t\t\tz = context->naptr_rrs[k].sort_pos;\n\t\t\t\t\t\tcontext->naptr_rrs[k].sort_pos = context->naptr_rrs[i].sort_pos;\n\t\t\t\t\t\tcontext->naptr_rrs[i].sort_pos = z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < context->naptr_rrs_count; k++) {\n\t\t\tif (context->naptr_rrs[k].sort_pos == context->position - 1) {\n\t\t\t\tast_copy_string(context->dst, context->naptr_rrs[k].result, dstlen);\n\t\t\t\tast_copy_string(context->tech, context->naptr_rrs[k].tech, techlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!(context->options & ENUMLOOKUP_OPTIONS_COUNT)) {\n\t\tcontext->dst[0] = 0;\n\t} else if ((context->options & ENUMLOOKUP_OPTIONS_COUNT)) {\n\t\tsnprintf(context->dst, context->dstlen, \"%d\", context->naptr_rrs_count + context->count);\n\t}\n\tif (chan) {\n\t\tret |= ast_autoservice_stop(chan);\n\t}\n\tif (!argcontext) {\n\t\tfor (k = 0; k < context->naptr_rrs_count; k++) {\n\t\t\tast_free(context->naptr_rrs[k].result);\n\t\t\tast_free(context->naptr_rrs[k].tech);\n\t\t}\n\t\tast_free(context->naptr_rrs);\n\t\tast_free(context);\n\t} else {\n\t\t*argcontext = context;\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 2103}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_ooh323_set_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"ooh323 set debug [off]\";\n\t\te->usage =\n\t\t\t\"Usage: ooh323 set debug [off]\\n\"\n\t\t\t\"\t\t Enables/Disables debugging of OOH323 channel driver\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc < 3 || a->argc > 4)\n\t\treturn CLI_SHOWUSAGE;\n\tif (a->argc == 4 && strcasecmp(a->argv[3], \"off\"))\n\t\treturn CLI_SHOWUSAGE;\n\tgH323Debug = (a->argc == 4) ? FALSE : TRUE;\n\tast_cli(a->fd, \"OOH323 Debugging %s\\n\", gH323Debug ? \"Enabled\" : \"Disabled\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2104}
{"project": "Asterisk", "target": 0, "func": "\ned_tty_sigtstp(EditLine *el, int c)\n{\n\treturn (CC_NORM);\n}\n", "bug_type": null, "idx": 2105}
{"project": "Asterisk", "target": 0, "func": "static struct ast_sorcery *system_sorcery;\nstatic void *system_alloc(const char *name)\n{\n\tstruct system_config *system = ast_sorcery_generic_alloc(sizeof(*system), NULL);\n\tif (!system) {\n\t\treturn NULL;\n\t}\n\treturn system;\n}\n", "bug_type": null, "idx": 2106}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int hfp_send_cmer(struct hfp_pvt *hfp, int status)\n{\n\tchar cmd[32];\n\tsnprintf(cmd, sizeof(cmd), \"AT+CMER=3,0,0,%d\\r\", status ? 1 : 0);\n\treturn rfcomm_write(hfp->rsock, cmd);\n}\n", "bug_type": null, "idx": 2107}
{"project": "Asterisk", "target": 0, "func": "static void odbc_class_destructor(void *data)\n{\n\tstruct odbc_class *class = data;\n\tstruct odbc_obj *obj;\n\t\n\tif (class->username) {\n\t\tast_free(class->username);\n\t}\n\tif (class->password) {\n\t\tast_free(class->password);\n\t}\n\tif (class->sanitysql) {\n\t\tast_free(class->sanitysql);\n\t}\n\twhile ((obj = AST_LIST_REMOVE_HEAD(&class->connections, list))) {\n\t\tao2_ref(obj, -1);\n\t}\n\tSQLFreeHandle(SQL_HANDLE_ENV, class->env);\n\tast_mutex_destroy(&class->lock);\n\tast_cond_destroy(&class->cond);\n}\n", "bug_type": null, "idx": 2108}
{"project": "Asterisk", "target": 0, "func": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  YYSIZE_T yysize1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  \n  const char *yyformat = 0;\n  \n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  \n  int yycount = 0;\n  \n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          \n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          \n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n                if (! (yysize <= yysize1\n                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                yysize = yysize1;\n              }\n        }\n    }\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n  yysize1 = yysize + yystrlen (yyformat);\n  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  yysize = yysize1;\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n  \n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}\n", "bug_type": null, "idx": 2109}
{"project": "Asterisk", "target": 0, "func": "static void extract_bits(INT32 *bits, unsigned char *c)\n{\n\tint x;\n\tfor (x=0;x<LPC10_BITS_IN_COMPRESSED_FRAME;x++) {\n\t\tif (*c & (0x80 >> (x & 7)))\n\t\t\tbits[x] = 1;\n\t\telse\n\t\t\tbits[x] = 0;\n\t\tif ((x & 7) == 7)\n\t\t\tc++;\n\t}\n}\n", "bug_type": null, "idx": 2110}
{"project": "Asterisk", "target": 0, "func": "static void rtp_ice_wrap_add_remote_candidate(struct ast_rtp_instance *instance, const struct ast_rtp_engine_ice_candidate *candidate)\n{\n\tao2_lock(instance);\n\tinstance->engine->ice->add_remote_candidate(instance, candidate);\n\tao2_unlock(instance);\n}\n", "bug_type": null, "idx": 2111}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_pubsub_unregister_body_generator(struct ast_sip_pubsub_body_generator *generator)\n{\n\tstruct ast_sip_pubsub_body_generator *iter;\n\tAST_RWLIST_WRLOCK(&body_generators);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&body_generators, iter, list) {\n\t\tif (iter == generator) {\n\t\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&body_generators);\n}\n", "bug_type": null, "idx": 2112}
{"project": "Asterisk", "target": 0, "func": "AST_THREADSTORAGE(buf3);\nstatic int function_realtime_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tstruct ast_variable *var, *head;\n\tstruct ast_str *out;\n\tsize_t resultslen;\n\tint n;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(family);\n\t\tAST_APP_ARG(fieldmatch);\n\t\tAST_APP_ARG(value);\n\t\tAST_APP_ARG(delim1);\n\t\tAST_APP_ARG(delim2);\n\t);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"Syntax: REALTIME(family,fieldmatch[,matchvalue[,delim1[,delim2]]]) - missing argument!\\n\");\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (!args.delim1)\n\t\targs.delim1 = \",\";\n\tif (!args.delim2)\n\t\targs.delim2 = \"=\";\n\tif (chan)\n\t\tast_autoservice_start(chan);\n\thead = ast_load_realtime_all(args.family, args.fieldmatch, args.value, SENTINEL);\n\tif (!head) {\n\t\tif (chan)\n\t\t\tast_autoservice_stop(chan);\n\t\treturn -1;\n\t}\n\tresultslen = 0;\n\tn = 0;\n\tfor (var = head; var; n++, var = var->next)\n\t\tresultslen += strlen(var->name) + strlen(var->value);\n\t\n\tresultslen += n * (strlen(args.delim1) + strlen(args.delim2)) + 1;\n\tif (resultslen > len) {\n\t\tast_log(LOG_WARNING, \"Failed to fetch. Realtime data is too large: need %zu, have %zu.\\n\", resultslen, len);\n\t\treturn -1;\n\t}\n\t\n\tout = ast_str_alloca(resultslen);\n\tfor (var = head; var; var = var->next)\n\t\tast_str_append(&out, 0, \"%s%s%s%s\", var->name, args.delim2, var->value, args.delim1);\n\tast_copy_string(buf, ast_str_buffer(out), len);\n\tast_variables_destroy(head);\n\tif (chan)\n\t\tast_autoservice_stop(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2113}
{"project": "Asterisk", "target": 0, "func": "static void odbc_obj_destructor(void *data)\n{\n\tstruct odbc_obj *obj = data;\n\todbc_obj_disconnect(obj);\n}\n", "bug_type": null, "idx": 2114}
{"project": "Asterisk", "target": 0, "func": "static void sig_ss7_set_remotelyblocked(struct sig_ss7_chan *p, int is_blocked, int type)\n{\n\tif (is_blocked) {\n\t\tp->remotelyblocked |= type;\n\t} else {\n\t\tp->remotelyblocked &= ~type;\n\t}\n\tif (sig_ss7_callbacks.set_remotelyblocked) {\n\t\tsig_ss7_callbacks.set_remotelyblocked(p->chan_pvt, p->remotelyblocked);\n\t}\n}\n", "bug_type": null, "idx": 2115}
{"project": "Asterisk", "target": 0, "func": "void conf_default_leave_waitmarked(struct confbridge_user *user)\n{\n\tconf_remove_user_waiting(user->conference, user);\n\tif (user->playing_moh) {\n\t\tconf_moh_stop(user);\n\t}\n}\n", "bug_type": null, "idx": 2116}
{"project": "Asterisk", "target": 0, "func": "void pvalIncludesAddInclude( pval *p, const char *include )\n{\n\tpval *s;\n\tif (!pvalCheckType(p, \"pvalIncludesAddSwitch\", PV_INCLUDES))\n\t\treturn;\n\ts = pvalCreateNode(PV_WORD);\n\ts->u1.str = (char *)include;\n\tp->u1.list = linku1(p->u1.list, s);\n}\n", "bug_type": null, "idx": 2117}
{"project": "Asterisk", "target": 0, "func": "static int find_transport_state_in_use(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_transport_state *transport_state = obj;\n\tpjsip_rx_data *rdata = arg;\n\tif (transport_state && ((transport_state->transport == rdata->tp_info.transport) ||\n\t\t(transport_state->factory && !pj_strcmp(&transport_state->factory->addr_name.host, &rdata->tp_info.transport->local_name.host) &&\n\t\t\ttransport_state->factory->addr_name.port == rdata->tp_info.transport->local_name.port))) {\n\t\treturn CMP_MATCH | CMP_STOP;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2118}
{"project": "Asterisk", "target": 0, "func": "struct ast_netsock *ast_netsock_bind(struct ast_netsock_list *list, struct io_context *ioc, const char *bindinfo, int defaultport, int tos, int cos, ast_io_cb callback, void *data)\n{\n\tstruct ast_sockaddr addr;\n\tif (ast_sockaddr_parse(&addr, bindinfo, 0)) {\n\t\tif (!ast_sockaddr_port(&addr)) {\n\t\t\tast_sockaddr_set_port(&addr, defaultport);\n\t\t}\n\t\treturn ast_netsock_bindaddr(list, ioc, &addr, tos, cos, callback, data);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2119}
{"project": "Asterisk", "target": 0, "func": "\nvi_change_meta(EditLine *el, int c)\n{\n\t\n\treturn (cv_action(el, DELETE | INSERT));\n}\n", "bug_type": null, "idx": 2120}
{"project": "Asterisk", "target": 0, "func": "static int event_hangup(struct ast_mansession *s, struct message *m)\n{\n\tdel_chan(get_header(m, \"Channel\"));\n\treturn 0;\n}\n", "bug_type": null, "idx": 2121}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic int ast_say_date_ka(struct ast_channel *chan, time_t t, const char *ints, const char *lang)\n{\n\tstruct timeval when = { t, 0 };\n\tstruct ast_tm tm;\n\tchar fn[256];\n\tint res = 0;\n\tast_localtime(&when, &tm, NULL);\n\tif (!res) {\n\t\tres = ast_say_number(chan, tm.tm_year + 1900, ints, lang, (char *) NULL);\n\t}\n\tif (!res) {\n\t\tsnprintf(fn, sizeof(fn), \"digits/tslis %d\", tm.tm_wday);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res) {\n\t\t\tres = ast_waitstream(chan, ints);\n\t\t}\n\t}\n\tif (!res) {\n\t\tres = ast_say_number(chan, tm.tm_mday, ints, lang, (char * ) NULL);\n\n\t}\n\tif (!res) {\n\t\tsnprintf(fn, sizeof(fn), \"digits/mon-%d\", tm.tm_mon);\n\t\tres = ast_streamfile(chan, fn, lang);\n\t\tif (!res) {\n\t\t\tres = ast_waitstream(chan, ints);\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2122}
{"project": "Asterisk", "target": 0, "func": "struct ast_endpoint *ast_endpoint_create(const char *tech, const char *resource)\n{\n\tif (ast_strlen_zero(tech)) {\n\t\tast_log(LOG_ERROR, \"Endpoint tech cannot be empty\\n\");\n\t\treturn NULL;\n\t}\n\tif (ast_strlen_zero(resource)) {\n\t\tast_log(LOG_ERROR, \"Endpoint resource cannot be empty\\n\");\n\t\treturn NULL;\n\t}\n\treturn endpoint_internal_create(tech, resource);\n}\n", "bug_type": null, "idx": 2123}
{"project": "Asterisk", "target": 0, "func": "static int macro_exec(struct ast_channel *chan, const char *data)\n{\n\treturn _macro_exec(chan, data, 0);\n}\n", "bug_type": null, "idx": 2124}
{"project": "Asterisk", "target": 0, "func": " */\nvoid ast_handle_cc_control_frame(struct ast_channel *inbound, struct ast_channel *outbound, void *frame_data)\n{\n\tchar *device_name;\n\tchar *dialstring;\n\tstruct ast_cc_monitor *monitor;\n\tstruct ast_datastore *cc_datastore;\n\tstruct dialed_cc_interfaces *cc_interfaces;\n\tstruct cc_control_payload *cc_data = frame_data;\n\tstruct cc_core_instance *core_instance;\n\tdevice_name = cc_data->device_name;\n\tdialstring = cc_data->dialstring;\n\tast_channel_lock(inbound);\n\tif (!(cc_datastore = ast_channel_datastore_find(inbound, &dialed_cc_interfaces_info, NULL))) {\n\t\tast_log(LOG_WARNING, \"Unable to retrieve CC datastore while processing CC frame from '%s'. CC services will be unavailable.\\n\", device_name);\n\t\tast_channel_unlock(inbound);\n\t\tcall_destructor_with_no_monitor(cc_data->monitor_type, cc_data->private_data);\n\t\treturn;\n\t}\n\tcc_interfaces = cc_datastore->data;\n\tif (cc_interfaces->ignore) {\n\t\tast_channel_unlock(inbound);\n\t\tcall_destructor_with_no_monitor(cc_data->monitor_type, cc_data->private_data);\n\t\treturn;\n\t}\n\tif (!cc_interfaces->is_original_caller) {\n\t\t\n\t\tast_channel_unlock(inbound);\n\t\tast_indicate_data(inbound, AST_CONTROL_CC, cc_data, sizeof(*cc_data));\n\t\treturn;\n\t}\n\tcore_instance = find_cc_core_instance(cc_interfaces->core_id);\n\tif (!core_instance) {\n\t\tcore_instance = cc_core_init_instance(inbound, cc_interfaces->interface_tree,\n\t\t\tcc_interfaces->core_id, cc_data);\n\t\tif (!core_instance) {\n\t\t\tcc_interfaces->ignore = 1;\n\t\t\tast_channel_unlock(inbound);\n\t\t\tcall_destructor_with_no_monitor(cc_data->monitor_type, cc_data->private_data);\n\t\t\treturn;\n\t\t}\n\t}\n\tast_channel_unlock(inbound);\n\t\n\tAST_LIST_LOCK(cc_interfaces->interface_tree);\n\tAST_LIST_TRAVERSE(cc_interfaces->interface_tree, monitor, next) {\n\t\tif (!strcmp(monitor->interface->device_name, device_name)) {\n\t\t\tast_log_dynamic_level(cc_logger_level, \"Core %d: Device %s sent us multiple CC control frames. Ignoring those beyond the first.\\n\",\n\t\t\t\t\tcore_instance->core_id, device_name);\n\t\t\tAST_LIST_UNLOCK(cc_interfaces->interface_tree);\n\t\t\tcc_unref(core_instance, \"Returning early from ast_handle_cc_control_frame. Unref core_instance\");\n\t\t\tcall_destructor_with_no_monitor(cc_data->monitor_type, cc_data->private_data);\n\t\t\treturn;\n\t\t}\n\t}\n\tAST_LIST_UNLOCK(cc_interfaces->interface_tree);\n\tif (!(monitor = cc_device_monitor_init(device_name, dialstring, cc_data, core_instance->core_id))) {\n\t\tast_log(LOG_WARNING, \"Unable to create CC device interface for '%s'. CC services will be unavailable on this interface.\\n\", device_name);\n\t\tcc_unref(core_instance, \"Returning early from ast_handle_cc_control_frame. Unref core_instance\");\n\t\tcall_destructor_with_no_monitor(cc_data->monitor_type, cc_data->private_data);\n\t\treturn;\n\t}\n\tAST_LIST_LOCK(cc_interfaces->interface_tree);\n\tcc_ref(monitor, \"monitor tree's reference to the monitor\");\n\tAST_LIST_INSERT_TAIL(cc_interfaces->interface_tree, monitor, next);\n\tAST_LIST_UNLOCK(cc_interfaces->interface_tree);\n\tcc_extension_monitor_change_is_valid(core_instance, monitor->parent_id, monitor->interface->device_name, 0);\n\tcc_publish_available(cc_interfaces->core_id, device_name, cc_service_to_string(cc_data->service));\n\tcc_unref(core_instance, \"Done with core_instance after handling CC control frame\");\n\tcc_unref(monitor, \"Unref reference from allocating monitor\");\n}\n", "bug_type": null, "idx": 2125}
{"project": "Asterisk", "target": 0, "func": "static enum ast_test_result_state wait_for_complex_completion(struct complex_task_data *ctd)\n{\n\tstruct timeval start = ast_tvnow();\n\tstruct timespec end = {\n\t\t.tv_sec = start.tv_sec + 5,\n\t\t.tv_nsec = start.tv_usec * 1000\n\t};\n\tenum ast_test_result_state res = AST_TEST_PASS;\n\tSCOPED_MUTEX(lock, &ctd->lock);\n\twhile (!ctd->task_executed) {\n\t\tif (ast_cond_timedwait(&ctd->notify_cond, lock, &end) == ETIMEDOUT) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ctd->task_executed) {\n\t\tres = AST_TEST_FAIL;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2126}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct misdn_cc_record *misdn_cc_new(void)\n{\n\tstruct misdn_cc_record *cc_record;\n\tlong record_id;\n\tmisdn_cc_remove_old();\n\tcc_record = ast_calloc(1, sizeof(*cc_record));\n\tif (cc_record) {\n\t\trecord_id = misdn_cc_record_id_new();\n\t\tif (record_id < 0) {\n\t\t\tast_free(cc_record);\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tcc_record->record_id = record_id;\n\t\tcc_record->port = -1;\n\t\tcc_record->invoke_id = ++misdn_invoke_id;\n\t\tcc_record->party_a_free = 1;\n\t\tcc_record->error_code = FacError_None;\n\t\tcc_record->reject_code = FacReject_None;\n\t\tcc_record->time_created = time(NULL);\n\t\t\n\t\tAST_LIST_INSERT_HEAD(&misdn_cc_records_db, cc_record, list);\n\t}\n\treturn cc_record;\n}\n", "bug_type": null, "idx": 2127}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tAST_TEST_UNREGISTER(uri_encode_decode_test);\n\tAST_TEST_UNREGISTER(quoted_escape_test);\n\tAST_TEST_UNREGISTER(md5_test);\n\tAST_TEST_UNREGISTER(sha1_test);\n\tAST_TEST_UNREGISTER(base64_test);\n\tAST_TEST_UNREGISTER(crypto_loaded_test);\n\tAST_TEST_UNREGISTER(adsi_loaded_test);\n\tAST_TEST_UNREGISTER(agi_loaded_test);\n\tAST_TEST_UNREGISTER(safe_mkdir_test);\n\tAST_TEST_UNREGISTER(crypt_test);\n\tAST_TEST_UNREGISTER(quote_mutation);\n\tAST_TEST_UNREGISTER(quote_unescaping);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2128}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_transcoder_show(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct channel_usage copy;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"transcoder show\";\n\t\te->usage =\n\t\t\t\"Usage: transcoder show\\n\"\n\t\t\t\"       Displays channel utilization of DAHDI transcoder(s).\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 2)\n\t\treturn CLI_SHOWUSAGE;\n\tcopy = channels;\n\tif (copy.total == 0)\n\t\tast_cli(a->fd, \"No DAHDI transcoders found.\\n\");\n\telse\n\t\tast_cli(a->fd, \"%d/%d encoders/decoders of %d channels are in use.\\n\", copy.encoders, copy.decoders, copy.total);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2129}
{"project": "Asterisk", "target": 0, "func": "\nstatic int t38_reinvite_response_cb(struct ast_sip_session *session, pjsip_rx_data *rdata)\n{\n\tstruct pjsip_status_line status = rdata->msg_info.msg->line.status;\n\tstruct t38_state *state;\n\tstruct ast_sip_session_media *session_media = NULL;\n\tif (status.code == 100) {\n\t\treturn 0;\n\t}\n\tstate = t38_state_get_or_alloc(session);\n\tif (!session->channel || !state) {\n\t\tast_log(LOG_WARNING, \"Received response to T.38 re-invite on '%s' but state unavailable\\n\",\n\t\t\tsession->channel ? ast_channel_name(session->channel) : \"unknown channel\");\n\t\treturn 0;\n\t}\n\tif (status.code == 200) {\n\t\tint index;\n\t\tsession_media = session->active_media_state->default_session[AST_MEDIA_TYPE_IMAGE];\n\t\tt38_change_state(session, session_media, state, T38_ENABLED);\n\t\t\n\t\tfor (index = 0; index < AST_VECTOR_SIZE(&state->media_state->sessions); ++index) {\n\t\t\tstruct ast_sip_session_media *session_media = AST_VECTOR_GET(&state->media_state->sessions, index);\n\t\t\tif (session_media && session_media->handler && session_media->handler->stream_stop) {\n\t\t\t\tsession_media->handler->stream_stop(session_media);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsession_media = session->pending_media_state->default_session[AST_MEDIA_TYPE_IMAGE];\n\t\tt38_change_state(session, session_media, state, T38_REJECTED);\n\t\t\n\t\tast_sip_session_media_state_free(state->media_state);\n\t\tstate->media_state = NULL;\n\t\tast_sip_session_media_state_reset(session->pending_media_state);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2130}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245T38FaxRateManagement (OOCTXT* pctxt, H245T38FaxRateManagement* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"localTCF\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"localTCF\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"transferredTCF\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"transferredTCF\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 3;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2131}
{"project": "Asterisk", "target": 0, "func": "\nstatic void send_cluster_notify(void)\n{\n\tstruct ast_event *event;\n\tunsigned int node_id;\n\tcs_error_t cs_err;\n\tcorosync_cfg_node_address_t corosync_addr;\n\tint num_addrs = 0;\n\tstruct sockaddr *sa;\n\tsize_t sa_len;\n\tchar buf[128];\n\tint res;\n\tif ((cs_err = corosync_cfg_local_get(cfg_handle, &node_id)) != CS_OK) {\n\t\tast_log(LOG_WARNING, \"Failed to extract Corosync node ID for this node. Not informing cluster of existance.\\n\");\n\t\treturn;\n\t}\n\tif (((cs_err = corosync_cfg_get_node_addrs(cfg_handle, node_id, 1, &num_addrs, &corosync_addr)) != CS_OK) || (num_addrs < 1)) {\n\t\tast_log(LOG_WARNING, \"Failed to get local Corosync address. Not informing cluster of existance.\\n\");\n\t\treturn;\n\t}\n\tsa = (struct sockaddr *)corosync_addr.address;\n\tsa_len = (size_t)corosync_addr.address_length;\n\tif ((res = getnameinfo(sa, sa_len, buf, sizeof(buf), NULL, 0, NI_NUMERICHOST))) {\n\t\tast_log(LOG_WARNING, \"Failed to determine name of local Corosync address: %s (%d). Not informing cluster of existance.\\n\",\n\t\t\tgai_strerror(res), res);\n\t\treturn;\n\t}\n\tevent = ast_event_new(AST_EVENT_CLUSTER_DISCOVERY,\n\t\t\t\t    AST_EVENT_IE_NODE_ID, AST_EVENT_IE_PLTYPE_UINT, node_id,\n\t\t\t\t    AST_EVENT_IE_LOCAL_ADDR, AST_EVENT_IE_PLTYPE_STR, buf,\n\t\t\t\t    AST_EVENT_IE_END);\n\tpublish_event_to_corosync(event);\n\tast_free(event);\n}\n", "bug_type": null, "idx": 2132}
{"project": "Asterisk", "target": 0, "func": "static int mp3_queue(struct ast_filestream *s)\n{\n\tstruct mp3_private *p = s->_private;\n\tint res = 0, bytes = 0;\n\tif(p->seek) {\n\t\tExitMP3(&p->mp);\n\t\tInitMP3(&p->mp, OUTSCALE);\n\t\tfseek(s->f, 0, SEEK_SET);\n\t\tp->sbuflen = p->dbuflen = p->offset = 0;\n\t\twhile(p->offset < p->seek) {\n\t\t\tif(mp3_squeue(s))\n\t\t\t\treturn -1;\n\t\t\twhile(p->offset < p->seek && ((res = mp3_dqueue(s))) == MP3_OK) {\n\t\t\t\tfor(bytes = 0 ; bytes < p->dbuflen ; bytes++) {\n\t\t\t\t\tp->dbufoffset++;\n\t\t\t\t\tp->offset++;\n\t\t\t\t\tif(p->offset >= p->seek)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res == MP3_ERR)\n\t\t\t\treturn -1;\n\t\t}\n\t\tp->seek = 0;\n\t\treturn 0;\n\t}\n\tif(p->dbuflen == 0) {\n\t\tif(p->sbuflen) {\n\t\t\tres = mp3_dqueue(s);\n\t\t\tif(res == MP3_ERR)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif(! p->sbuflen || res != MP3_OK) {\n\t\t\tif(mp3_squeue(s))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2133}
{"project": "Asterisk", "target": 0, "func": "int ooCallSetCalledPartyNumber(OOH323CallData *call, const char *number)\n{\n   if(call->calledPartyNumber) \n      memFreePtr(call->pctxt, call->calledPartyNumber);\n   call->calledPartyNumber = (char*) memAlloc(call->pctxt, strlen(number)+1);\n   if(call->calledPartyNumber)\n   {\n     strcpy(call->calledPartyNumber, number);\n   }\n   else{\n      OOTRACEERR3(\"Error:Memory - ooCallSetCalledPartyNumber - \"\n                  \"calledPartyNumber.(%s, %s)\\n\", call->callType, \n                  call->callToken);\n      return OO_FAILED;\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 2134}
{"project": "Asterisk", "target": 0, "func": "\nstatic int stop_monitor_action(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c = NULL;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tint res;\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn AMI_SUCCESS;\n\t}\n\tif (!(c = ast_channel_get_by_name(name))) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn AMI_SUCCESS;\n\t}\n\tres = ast_monitor_stop(c, 1);\n\tc = ast_channel_unref(c);\n\tif (res) {\n\t\tastman_send_error(s, m, \"Could not stop monitoring channel\");\n\t\treturn AMI_SUCCESS;\n\t}\n\tastman_send_ack(s, m, \"Stopped monitoring channel\");\n\treturn AMI_SUCCESS;\n}\n", "bug_type": null, "idx": 2135}
{"project": "Asterisk", "target": 0, "func": "int ooCloseLogicalChannelTimerExpired(void *pdata)\n{\n   ooTimerCallback *cbData = (ooTimerCallback*)pdata;\n   OOH323CallData *call = cbData->call;\n   OOTRACEINFO3(\"CloseLogicalChannelTimer expired. (%s, %s)\\n\", call->callType,\n                 call->callToken);\n   ooClearLogicalChannel(call, cbData->channelNumber);\n   if(call->callState < OO_CALL_CLEAR)\n   {\n      call->callState = OO_CALL_CLEAR;\n      call->callEndReason = OO_REASON_LOCAL_CLEARED;\n   }\n   ASN1MEMFREEPTR(call->pctxt, cbData);\n   return OO_OK;\n}\n", "bug_type": null, "idx": 2136}
{"project": "Asterisk", "target": 0, "func": "int checkSizeConstraint(OOCTXT* pctxt, int size)\n{\n   Asn1SizeCnst* pSize;\n   ASN1UINT upper;\n   ASN1BOOL extbit;\n   int      stat;\n   \n   \n   if (isExtendableSize(pctxt->pSizeConstraint)) {\n      stat = DE_BIT (pctxt, &extbit);\n      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);\n   }\n   else extbit = 0;\n   \n   \n   pSize = getSizeConstraint (pctxt, extbit);\n   upper = (pSize) ? pSize->upper : ASN1UINT_MAX;\n   if (upper < (ASN1UINT)size) {\n      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);\n   }\n   return ASN_OK;\n}\n", "bug_type": null, "idx": 2137}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void subscription_invoke(struct stasis_subscription *sub,\n\t\t\t\t  struct stasis_message *message)\n{\n\t\n\tif (stasis_subscription_final_message(sub, message)) {\n\t\tSCOPED_AO2LOCK(lock, sub);\n\t\tsub->final_message_rxed = 1;\n\t\tast_cond_signal(&sub->join_cond);\n\t}\n\t\n\tsub->callback(sub->data, sub, message);\n\t\n\tif (stasis_subscription_final_message(sub, message)) {\n\t\tSCOPED_AO2LOCK(lock, sub);\n\t\tsub->final_message_processed = 1;\n\t\tast_cond_signal(&sub->join_cond);\n\t}\n}\n", "bug_type": null, "idx": 2138}
{"project": "Asterisk", "target": 0, "func": "\nstatic int feature_blind_transfer(struct ast_bridge_channel *bridge_channel, void *hook_pvt)\n{\n\tchar xfer_exten[AST_MAX_EXTENSION] = \"\";\n\tstruct ast_bridge_features_blind_transfer *blind_transfer = hook_pvt;\n\tconst char *xfer_context;\n\tchar *goto_on_blindxfr;\n\tast_bridge_channel_write_hold(bridge_channel, NULL);\n\tast_channel_lock(bridge_channel->chan);\n\txfer_context = ast_strdupa(get_transfer_context(bridge_channel->chan,\n\t\tblind_transfer ? blind_transfer->context : NULL));\n\tgoto_on_blindxfr = ast_strdupa(S_OR(pbx_builtin_getvar_helper(bridge_channel->chan,\n\t\t\"GOTO_ON_BLINDXFR\"), \"\"));\n\tast_channel_unlock(bridge_channel->chan);\n\t\n\tif (grab_transfer(bridge_channel->chan, xfer_exten, sizeof(xfer_exten), xfer_context)) {\n\t\tast_bridge_channel_write_unhold(bridge_channel);\n\t\treturn 0;\n\t}\n\tif (!ast_strlen_zero(goto_on_blindxfr)) {\n\t\tconst char *chan_context;\n\t\tconst char *chan_exten;\n\t\tint chan_priority;\n\t\tast_debug(1, \"After transfer, transferer %s goes to %s\\n\",\n\t\t\t\tast_channel_name(bridge_channel->chan), goto_on_blindxfr);\n\t\tast_channel_lock(bridge_channel->chan);\n\t\tchan_context = ast_strdupa(ast_channel_context(bridge_channel->chan));\n\t\tchan_exten = ast_strdupa(ast_channel_exten(bridge_channel->chan));\n\t\tchan_priority = ast_channel_priority(bridge_channel->chan);\n\t\tast_channel_unlock(bridge_channel->chan);\n\t\tast_bridge_set_after_go_on(bridge_channel->chan,\n\t\t\tchan_context, chan_exten, chan_priority, goto_on_blindxfr);\n\t}\n\tif (ast_bridge_transfer_blind(0, bridge_channel->chan, xfer_exten, xfer_context,\n\t\tblind_transfer_cb, bridge_channel->chan) != AST_BRIDGE_TRANSFER_SUCCESS\n\t\t&& !ast_strlen_zero(goto_on_blindxfr)) {\n\t\tast_bridge_discard_after_goto(bridge_channel->chan);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2139}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int h261_decap(struct fbuf_t *b, uint8_t *data, int len)\n{\n\tint ebit, sbit;\n\tif (len < 8) {\n\t\tast_log(LOG_WARNING, \"invalid framesize %d\\n\", len);\n\t\treturn 1;\n\t}\n\tsbit = (data[0] >> 5) & 7;\n\tebit = (data[0] >> 2) & 7;\n\tlen -= 4;\n\tdata += 4;\n\treturn fbuf_append(b, data, len, sbit, ebit);\n}\n", "bug_type": null, "idx": 2140}
{"project": "Asterisk", "target": 0, "func": "static void *sorcery_config_retrieve_id(const struct ast_sorcery *sorcery, void *data, const char *type, const char *id)\n{\n\tstruct sorcery_config *config = data;\n\tRAII_VAR(struct ao2_container *, objects, ao2_global_obj_ref(config->objects), ao2_cleanup);\n\treturn objects ? ao2_find(objects, id, OBJ_SEARCH_KEY) : NULL;\n}\n", "bug_type": null, "idx": 2141}
{"project": "Asterisk", "target": 0, "func": "#endif \nstatic void cfg_shutdown_cb(corosync_cfg_handle_t cfg_handle,\n\t\tcorosync_cfg_shutdown_flags_t flags);\nstatic corosync_cfg_callbacks_t cfg_callbacks = {\n#ifdef HAVE_COROSYNC_CFG_STATE_TRACK\n\t.corosync_cfg_state_track_callback = cfg_state_track_cb,\n#endif \n\t.corosync_cfg_shutdown_callback = cfg_shutdown_cb,\n};\n#endif \nstatic void cfg_shutdown_cb(corosync_cfg_handle_t cfg_handle,\n\t\tcorosync_cfg_shutdown_flags_t flags)\n{\n}\n", "bug_type": null, "idx": 2142}
{"project": "Asterisk", "target": 0, "func": "int ooCreateH225Connection(OOH323CallData *call)\n{\n   int ret=0, i;\n   OOSOCKET channelSocket=0;\n   for (i=0;i<3;i++) {\n   if((ret=ooSocketCreate (&channelSocket, call->versionIP))!=ASN_OK)\n   {\n      OOTRACEERR3(\"Failed to create socket for transmit H2250 channel (%s, %s)\"\n                  \"\\n\", call->callType, call->callToken);\n      if(call->callState < OO_CALL_CLEAR)\n      {\n         call->callState = OO_CALL_CLEAR;\n         call->callEndReason = OO_REASON_TRANSPORTFAILURE;\n      }\n      return OO_FAILED;\n   }\n   else\n   {\n      \n#ifndef _WIN32\n      ret = ooBindPort(OOTCP,channelSocket, call->localIP); \n#else\n      ret = ooBindOSAllocatedPort(channelSocket, call->localIP);\n#endif\n      if(ret == OO_FAILED)\n      {\n         OOTRACEERR3(\"Error:Unable to bind to a TCP port (%s, %s)\\n\", \n         call->callType, call->callToken);\n         if(call->callState < OO_CALL_CLEAR)\n         {\n            call->callState = OO_CALL_CLEAR;\n            call->callEndReason = OO_REASON_TRANSPORTFAILURE;\n         }\n         return OO_FAILED;\n      }\n      if (0 == call->pH225Channel) {\n         call->pH225Channel = \n            (OOH323Channel*) memAllocZ (call->pctxt, sizeof(OOH323Channel));\n      }\n      call->pH225Channel->port = ret;\n      OOTRACEINFO6(\"Trying to connect to remote endpoint(%s:%d) (IPv%d) to setup \"\n                   \"H2250 channel (%s, %s)\\n\", call->remoteIP, \n                   call->remotePort, call->versionIP, call->callType, call->callToken);\n      if((ret=ooSocketConnect(channelSocket, call->remoteIP,\n                              call->remotePort))==ASN_OK)\n      {\n         call->pH225Channel->sock = channelSocket;\n         OOTRACEINFO3(\"H2250 transmiter channel creation - successful \"\n                      \"(%s, %s)\\n\", call->callType, call->callToken);\n         \n         if(!strcmp(call->localIP, \"0.0.0.0\") || !strcmp(call->localIP, \"::\"))\n         {\n            OOTRACEDBGA3(\"Determining IP address for outgoing call in \"\n                         \"multihomed mode. (%s, %s)\\n\", call->callType, \n                          call->callToken);\n            ret = ooSocketGetIpAndPort(channelSocket, call->localIP, 2+8*4+7, \n                                       &call->pH225Channel->port, NULL);\n            if(ret != ASN_OK)\n            {\n               OOTRACEERR3(\"ERROR:Failed to retrieve local ip and port from \"\n                           \"socket for multihomed mode.(%s, %s)\\n\", \n                            call->callType, call->callToken);\n               if(call->callState < OO_CALL_CLEAR)\n               {  \n                  call->callState = OO_CALL_CLEAR;\n                  call->callEndReason = OO_REASON_TRANSPORTFAILURE;\n               }\n               return OO_FAILED;\n            }\n            OOTRACEDBGA4(\"Using local ip %s for outgoing call(multihomedMode).\"\n                         \" (%s, %s)\\n\", call->localIP, call->callType, \n                         call->callToken);\n         }\n         return OO_OK;\n      }\n      else\n      {\n         OOTRACEERR5(\"ERROR:Failed to connect to remote destination for \"\n                    \"transmit H2250 channel(%s, %s, %d, %s)\\n\",call->callType,\n                     call->callToken, channelSocket, call->localIP);\n\t close(channelSocket);\n         if(call->callState < OO_CALL_CLEAR)\n         {  \n            call->callState = OO_CALL_CLEAR;\n            call->callEndReason = OO_REASON_NOUSER;\n         }\n         if (i>=2) return OO_FAILED; else continue;\n      }\n      return OO_FAILED;\n    }\n  }\n  return OO_FAILED;\n}\n", "bug_type": null, "idx": 2143}
{"project": "Asterisk", "target": 0, "func": "static jb_output_function_t warnf, errf, dbgf;\nvoid jb_setoutput(jb_output_function_t err, jb_output_function_t warn, jb_output_function_t dbg)\n{\n\terrf = err;\n\twarnf = warn;\n\tdbgf = dbg;\n}\n", "bug_type": null, "idx": 2144}
{"project": "Asterisk", "target": 0, "func": "static int ami_subscription_detail_inbound(struct sip_subscription_tree *sub_tree, void *arg)\n{\n\treturn sub_tree->role == AST_SIP_NOTIFIER ? ami_subscription_detail(\n\t\tsub_tree, arg, \"InboundSubscriptionDetail\") : 0;\n}\n", "bug_type": null, "idx": 2145}
{"project": "Asterisk", "target": 0, "func": "int ast_rtp_engine_init(void)\n{\n\tast_rwlock_init(&mime_types_lock);\n\tast_rwlock_init(&static_RTP_PT_lock);\n\trtp_topic = stasis_topic_create(\"rtp_topic\");\n\tif (!rtp_topic) {\n\t\treturn -1;\n\t}\n\tSTASIS_MESSAGE_TYPE_INIT(ast_rtp_rtcp_sent_type);\n\tSTASIS_MESSAGE_TYPE_INIT(ast_rtp_rtcp_received_type);\n\tast_register_cleanup(rtp_engine_shutdown);\n\t\n\tset_next_mime_type(ast_format_g723, 0, \"audio\", \"G723\", 8000);\n\tset_next_mime_type(ast_format_gsm, 0, \"audio\", \"GSM\", 8000);\n\tset_next_mime_type(ast_format_ulaw, 0, \"audio\", \"PCMU\", 8000);\n\tset_next_mime_type(ast_format_ulaw, 0, \"audio\", \"G711U\", 8000);\n\tset_next_mime_type(ast_format_alaw, 0, \"audio\", \"PCMA\", 8000);\n\tset_next_mime_type(ast_format_alaw, 0, \"audio\", \"G711A\", 8000);\n\tset_next_mime_type(ast_format_g726, 0, \"audio\", \"G726-32\", 8000);\n\tset_next_mime_type(ast_format_adpcm, 0, \"audio\", \"DVI4\", 8000);\n\tset_next_mime_type(ast_format_slin, 0, \"audio\", \"L16\", 8000);\n\tset_next_mime_type(ast_format_slin16, 0, \"audio\", \"L16\", 16000);\n\tset_next_mime_type(ast_format_slin16, 0, \"audio\", \"L16-256\", 16000);\n\tset_next_mime_type(ast_format_slin12, 0, \"audio\", \"L16\", 12000);\n\tset_next_mime_type(ast_format_slin24, 0, \"audio\", \"L16\", 24000);\n\tset_next_mime_type(ast_format_slin32, 0, \"audio\", \"L16\", 32000);\n\tset_next_mime_type(ast_format_slin44, 0, \"audio\", \"L16\", 44000);\n\tset_next_mime_type(ast_format_slin48, 0, \"audio\", \"L16\", 48000);\n\tset_next_mime_type(ast_format_slin96, 0, \"audio\", \"L16\", 96000);\n\tset_next_mime_type(ast_format_slin192, 0, \"audio\", \"L16\", 192000);\n\tset_next_mime_type(ast_format_lpc10, 0, \"audio\", \"LPC\", 8000);\n\tset_next_mime_type(ast_format_g729, 0, \"audio\", \"G729\", 8000);\n\tset_next_mime_type(ast_format_g729, 0, \"audio\", \"G729A\", 8000);\n\tset_next_mime_type(ast_format_g729, 0, \"audio\", \"G.729\", 8000);\n\tset_next_mime_type(ast_format_speex, 0, \"audio\", \"speex\", 8000);\n\tset_next_mime_type(ast_format_speex16, 0,  \"audio\", \"speex\", 16000);\n\tset_next_mime_type(ast_format_speex32, 0,  \"audio\", \"speex\", 32000);\n\tset_next_mime_type(ast_format_ilbc, 0, \"audio\", \"iLBC\", 8000);\n\t\n\tset_next_mime_type(ast_format_g722, 0, \"audio\", \"G722\", 8000);\n\tset_next_mime_type(ast_format_g726_aal2, 0, \"audio\", \"AAL2-G726-32\", 8000);\n\tset_next_mime_type(NULL, AST_RTP_DTMF, \"audio\", \"telephone-event\", 8000);\n\tset_next_mime_type(NULL, AST_RTP_CISCO_DTMF, \"audio\", \"cisco-telephone-event\", 8000);\n\tset_next_mime_type(NULL, AST_RTP_CN, \"audio\", \"CN\", 8000);\n\tset_next_mime_type(ast_format_jpeg, 0, \"video\", \"JPEG\", 90000);\n\tset_next_mime_type(ast_format_png, 0, \"video\", \"PNG\", 90000);\n\tset_next_mime_type(ast_format_h261, 0, \"video\", \"H261\", 90000);\n\tset_next_mime_type(ast_format_h263, 0, \"video\", \"H263\", 90000);\n\tset_next_mime_type(ast_format_h263p, 0, \"video\", \"h263-1998\", 90000);\n\tset_next_mime_type(ast_format_h264, 0, \"video\", \"H264\", 90000);\n\tset_next_mime_type(ast_format_mp4, 0, \"video\", \"MP4V-ES\", 90000);\n\tset_next_mime_type(ast_format_t140_red, 0, \"text\", \"RED\", 1000);\n\tset_next_mime_type(ast_format_t140, 0, \"text\", \"T140\", 1000);\n\tset_next_mime_type(ast_format_siren7, 0, \"audio\", \"G7221\", 16000);\n\tset_next_mime_type(ast_format_siren14, 0, \"audio\", \"G7221\", 32000);\n\tset_next_mime_type(ast_format_g719, 0, \"audio\", \"G719\", 48000);\n\t\n\tset_next_mime_type(ast_format_opus, 0,  \"audio\", \"opus\", 48000);\n\tset_next_mime_type(ast_format_vp8, 0,  \"video\", \"VP8\", 90000);\n\tset_next_mime_type(ast_format_vp9, 0, \"video\", \"VP9\", 90000);\n\t\n\tadd_static_payload(0, ast_format_ulaw, 0);\n\t#ifdef USE_DEPRECATED_G726\n\tadd_static_payload(2, ast_format_g726, 0);\n\t#endif\n\tadd_static_payload(3, ast_format_gsm, 0);\n\tadd_static_payload(4, ast_format_g723, 0);\n\tadd_static_payload(5, ast_format_adpcm, 0);\n\tadd_static_payload(6, ast_format_adpcm, 0); \n\tadd_static_payload(7, ast_format_lpc10, 0);\n\tadd_static_payload(8, ast_format_alaw, 0);\n\tadd_static_payload(9, ast_format_g722, 0);\n\tadd_static_payload(10, ast_format_slin, 0); \n\tadd_static_payload(11, ast_format_slin, 0); \n\tadd_static_payload(13, NULL, AST_RTP_CN);\n\tadd_static_payload(16, ast_format_adpcm, 0); \n\tadd_static_payload(17, ast_format_adpcm, 0); \n\tadd_static_payload(18, ast_format_g729, 0);\n\tadd_static_payload(19, NULL, AST_RTP_CN);         \n\tadd_static_payload(26, ast_format_jpeg, 0);\n\tadd_static_payload(31, ast_format_h261, 0);\n\tadd_static_payload(34, ast_format_h263, 0);\n\t\n\tadd_static_payload(96, ast_format_slin192, 0);\n\tadd_static_payload(97, ast_format_ilbc, 0);\n\tadd_static_payload(98, ast_format_h263p, 0);\n\tadd_static_payload(99, ast_format_h264, 0);\n\tadd_static_payload(100, ast_format_vp8, 0);\n\tadd_static_payload(101, NULL, AST_RTP_DTMF);\n\tadd_static_payload(102, ast_format_siren7, 0);\n\tadd_static_payload(103, ast_format_h263p, 0);\n\tadd_static_payload(104, ast_format_mp4, 0);\n\tadd_static_payload(105, ast_format_t140_red, 0);   \n\tadd_static_payload(106, ast_format_t140, 0);     \n\tadd_static_payload(107, ast_format_opus, 0);\n\tadd_static_payload(108, ast_format_vp9, 0);\n\tadd_static_payload(110, ast_format_speex, 0);\n\tadd_static_payload(111, ast_format_g726, 0);\n\tadd_static_payload(112, ast_format_g726_aal2, 0);\n\tadd_static_payload(115, ast_format_siren14, 0);\n\tadd_static_payload(116, ast_format_g719, 0);\n\tadd_static_payload(117, ast_format_speex16, 0);\n\tadd_static_payload(118, ast_format_slin16, 0); \n\tadd_static_payload(119, ast_format_speex32, 0);\n\tadd_static_payload(121, NULL, AST_RTP_CISCO_DTMF);   \n\tadd_static_payload(122, ast_format_slin12, 0);\n\tadd_static_payload(123, ast_format_slin24, 0);\n\tadd_static_payload(124, ast_format_slin32, 0);\n\tadd_static_payload(125, ast_format_slin44, 0);\n\tadd_static_payload(126, ast_format_slin48, 0);\n\tadd_static_payload(127, ast_format_slin96, 0);\n\t\n\treturn 0;\n}\n", "bug_type": null, "idx": 2146}
{"project": "Asterisk", "target": 0, "func": "void ast_publish_channel_state(struct ast_channel *chan)\n{\n\tRAII_VAR(struct ast_channel_snapshot *, snapshot, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tif (!ast_channel_snapshot_type()) {\n\t\treturn;\n\t}\n\tast_assert(chan != NULL);\n\tif (!chan) {\n\t\treturn;\n\t}\n\tsnapshot = ast_channel_snapshot_create(chan);\n\tif (!snapshot) {\n\t\treturn;\n\t}\n\tmessage = stasis_message_create(ast_channel_snapshot_type(), snapshot);\n\tif (!message) {\n\t\treturn;\n\t}\n\tast_assert(ast_channel_topic(chan) != NULL);\n\tstasis_publish(ast_channel_topic(chan), message);\n}\n", "bug_type": null, "idx": 2147}
{"project": "Asterisk", "target": 0, "func": "int ast_json_object_del(struct ast_json *object, const char *key)\n{\n\treturn json_object_del((json_t *)object, key);\n}\n", "bug_type": null, "idx": 2148}
{"project": "Asterisk", "target": 0, "func": " * \\param data framehook data (gateway data)*/\nstatic void fax_gateway_framehook_destroy(void *data)\n{\n\tstruct fax_gateway *gateway = data;\n\tif (gateway->s) {\n\t\tswitch (gateway->s->state) {\n\t\tcase AST_FAX_STATE_INITIALIZED:\n\t\tcase AST_FAX_STATE_OPEN:\n\t\tcase AST_FAX_STATE_ACTIVE:\n\t\tcase AST_FAX_STATE_COMPLETE:\n\t\t\tif (gateway->s->tech->cancel_session) {\n\t\t\t\tgateway->s->tech->cancel_session(gateway->s);\n\t\t\t}\n\t\t\t\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tao2_ref(gateway, -1);\n}\n", "bug_type": null, "idx": 2149}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225SIPCaps (OOCTXT* pctxt, H225SIPCaps* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.nonStandardDataPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.dataRatesSupportedPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.supportedPrefixesPresent);\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      stat = asn1PE_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.dataRatesSupportedPresent) {\n      stat = asn1PE_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.supportedPrefixesPresent) {\n      stat = asn1PE_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2150}
{"project": "Asterisk", "target": 0, "func": "int __ast_rwlock_tryrdlock(const char *filename, int line, const char *func, ast_rwlock_t *t, const char *name)\n{\n\tint res;\n#ifdef DEBUG_THREADS\n\tstruct ast_lock_track *lt = NULL;\n#ifdef HAVE_BKTR\n\tstruct ast_bt *bt = NULL;\n#endif\n\tif (t->tracking) {\n\t\tlt = ast_get_reentrancy(&t->track);\n\t}\n\tif (lt) {\n#ifdef HAVE_BKTR\n\t\tstruct ast_bt tmp;\n\t\t\n\t\tast_bt_get_addresses(&tmp);\n\t\tast_reentrancy_lock(lt);\n\t\tif (lt->reentrancy < AST_MAX_REENTRANCY) {\n\t\t\tlt->backtrace[lt->reentrancy] = tmp;\n\t\t\tbt = &lt->backtrace[lt->reentrancy];\n\t\t}\n\t\tast_reentrancy_unlock(lt);\n\t\tast_store_lock_info(AST_RDLOCK, filename, line, func, name, t, bt);\n#else\n\t\tast_store_lock_info(AST_RDLOCK, filename, line, func, name, t);\n#endif\n\t}\n#endif \n\tres = pthread_rwlock_tryrdlock(&t->lock);\n#ifdef DEBUG_THREADS\n\tif (!res && lt) {\n\t\tast_reentrancy_lock(lt);\n\t\tif (lt->reentrancy < AST_MAX_REENTRANCY) {\n\t\t\tlt->file[lt->reentrancy] = filename;\n\t\t\tlt->lineno[lt->reentrancy] = line;\n\t\t\tlt->func[lt->reentrancy] = func;\n\t\t\tlt->thread_id[lt->reentrancy] = pthread_self();\n\t\t\tlt->reentrancy++;\n\t\t}\n\t\tast_reentrancy_unlock(lt);\n\t\tast_mark_lock_acquired(t);\n\t} else if (lt) {\n\t\tast_mark_lock_failed(t);\n\t}\n#endif \n\treturn res;\n}\n", "bug_type": null, "idx": 2151}
{"project": "Asterisk", "target": 0, "func": "int set_binaural_data_join(struct convolve_data *data, unsigned int default_sample_size)\n{\n\tstruct convolve_channel_pair **cchan_pair_tmp;\n\tunsigned int i;\n\tint *pos_ids_tmp;\n\t\n\tdata->number_channels++;\n\t\n\t\n\tif (data->chan_size < data->number_channels)  {\n\t\tdata->chan_size += 1;\n\t\tpos_ids_tmp = ast_realloc(data->pos_ids, data->chan_size * sizeof(int));\n\t\tif (pos_ids_tmp) {\n\t\t\tdata->pos_ids = pos_ids_tmp;\n\t\t} else {\n\t\t\tgoto binaural_join_fails;\n\t\t}\n\t\tdata->pos_ids[data->chan_size - 1] = 0;\n\t\tcchan_pair_tmp = ast_realloc(data->cchan_pair,\n\t\t\t\tdata->chan_size * sizeof(struct convolve_channel_pair *));\n\t\tif (cchan_pair_tmp) {\n\t\t\tdata->cchan_pair = cchan_pair_tmp;\n\t\t} else {\n\t\t\tgoto binaural_join_fails;\n\t\t}\n\t\tdata->cchan_pair[data->chan_size - 1] = ast_malloc(sizeof(struct convolve_channel_pair));\n\t\tif (data->cchan_pair[data->chan_size - 1] == NULL) {\n\t\t\tgoto binaural_join_fails;\n\t\t}\n\t\ti = init_convolve_channel_pair(data->cchan_pair[data->chan_size - 1], data->hrtf_length,\n\t\t\t\tdata->chan_size - 1, default_sample_size);\n\t\tif (i == -1) {\n\t\t\tgoto binaural_join_fails;\n\t\t}\n\t}\n\tfor (i = 0; i < data->chan_size; i++) {\n\t\tif (data->pos_ids[i] == 0) {\n\t\t\tdata->pos_ids[i] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\nbinaural_join_fails:\n\tdata->number_channels--;\n\tdata->chan_size -= 1;\n\treturn -1;\n}\n", "bug_type": null, "idx": 2152}
{"project": "Asterisk", "target": 0, "func": "static int test_law_samples(struct ast_frame *frame)\n{\n\treturn frame->datalen;\n}\n", "bug_type": null, "idx": 2153}
{"project": "Asterisk", "target": 0, "func": "static long queue_next(jitterbuf *jb)\n{\n\tif (jb->frames)\n\t\treturn jb->frames->ts;\n\telse\n\t\treturn -1;\n}\n", "bug_type": null, "idx": 2154}
{"project": "Asterisk", "target": 0, "func": "static int analog_send_callerid(struct analog_pvt *p, int cwcid, struct ast_party_caller *caller)\n{\n\tast_debug(1, \"Sending callerid.  CID_NAME: '%s' CID_NUM: '%s'\\n\",\n\t\tcaller->id.name.str,\n\t\tcaller->id.number.str);\n\tif (cwcid) {\n\t\tp->callwaitcas = 0;\n\t}\n\tif (analog_callbacks.send_callerid) {\n\t\treturn analog_callbacks.send_callerid(p->chan_pvt, cwcid, caller);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2155}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int unload_module(void)\n{\n\tint res;\n\tres = ast_custom_function_unregister(&hangupcause_function);\n\tres |= ast_custom_function_unregister(&hangupcause_keys_function);\n\tres |= ast_unregister_application(app);\n\treturn res;\n}\n", "bug_type": null, "idx": 2156}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_performance_test(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tunsigned int level;\n\tunsigned int test;\n\tstruct test tests[] = {\n\t\t{ .name = \"Log 10,000 messages\",\n\t\t},\n\t};\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"logger test performance\";\n\t\te->usage = \"\"\n\t\t\t\"Usage: logger test performance\\n\"\n\t\t\t\"\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tfor (test = 0; test < ARRAY_LEN(tests); test++) {\n\t\tast_cli(a->fd, \"Test %u: %s.\\n\", test + 1, tests[test].name);\n\t\tswitch (test) {\n\t\tcase 0:\n\t\t\tif ((level = ast_logger_register_level(\"perftest\")) != -1) {\n\t\t\t\tunsigned int x;\n\t\t\t\tstruct timeval start, end;\n\t\t\t\tint elapsed;\n\t\t\t\tast_cli(a->fd, \"Test: got level %u\\n\", level);\n\t\t\t\tstart = ast_tvnow();\n\t\t\t\tfor (x = 0; x < 10000; x++) {\n\t\t\t\t\tast_log_dynamic_level(level, \"Performance test log message\\n\");\n\t\t\t\t}\n\t\t\t\tend = ast_tvnow();\n\t\t\t\telapsed = ast_tvdiff_ms(end, start);\n\t\t\t\tast_cli(a->fd, \"Test: 10,000 messages in %f seconds.\\n\", (float) elapsed / 1000);\n\t\t\t\tast_logger_unregister_level(\"perftest\");\n\t\t\t\ttests[test].x_success++;\n\t\t\t} else {\n\t\t\t\tast_cli(a->fd, \"Test: Failed, could not register level 'perftest'.\\n\");\n\t\t\t\ttests[test].u_failure++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\toutput_tests(tests, ARRAY_LEN(tests), a->fd);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2157}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_audiohook_attach(struct ast_channel *chan, struct ast_audiohook *audiohook)\n{\n\tast_channel_lock(chan);\n\tif (!ast_channel_audiohooks(chan)) {\n\t\tstruct ast_audiohook_list *ahlist;\n\t\t\n\t\tif (!(ahlist = ast_calloc(1, sizeof(*ahlist)))) {\n\t\t\tast_channel_unlock(chan);\n\t\t\treturn -1;\n\t\t}\n\t\tast_channel_audiohooks_set(chan, ahlist);\n\t\tAST_LIST_HEAD_INIT_NOLOCK(&ast_channel_audiohooks(chan)->spy_list);\n\t\tAST_LIST_HEAD_INIT_NOLOCK(&ast_channel_audiohooks(chan)->whisper_list);\n\t\tAST_LIST_HEAD_INIT_NOLOCK(&ast_channel_audiohooks(chan)->manipulate_list);\n\t\t\n\t\tast_channel_audiohooks(chan)->list_internal_samp_rate = DEFAULT_INTERNAL_SAMPLE_RATE;\n\t}\n\t\n\tif (audiohook->type == AST_AUDIOHOOK_TYPE_SPY) {\n\t\tAST_LIST_INSERT_TAIL(&ast_channel_audiohooks(chan)->spy_list, audiohook, list);\n\t} else if (audiohook->type == AST_AUDIOHOOK_TYPE_WHISPER) {\n\t\tAST_LIST_INSERT_TAIL(&ast_channel_audiohooks(chan)->whisper_list, audiohook, list);\n\t} else if (audiohook->type == AST_AUDIOHOOK_TYPE_MANIPULATE) {\n\t\tAST_LIST_INSERT_TAIL(&ast_channel_audiohooks(chan)->manipulate_list, audiohook, list);\n\t}\n\t\n\taudiohook_set_internal_rate(audiohook, DEFAULT_INTERNAL_SAMPLE_RATE, 1);\n\taudiohook_list_set_samplerate_compatibility(ast_channel_audiohooks(chan));\n\t\n\tast_audiohook_update_status(audiohook, AST_AUDIOHOOK_STATUS_RUNNING);\n\tif (ast_channel_is_bridged(chan)) {\n\t\tast_channel_set_unbridged_nolock(chan, 1);\n\t}\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2158}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void spandsp_log(int level, const char *msg)\n{\n\tif (level == SPAN_LOG_ERROR) {\n\t\tast_log(LOG_ERROR, \"%s\", msg);\n\t} else if (level == SPAN_LOG_WARNING) {\n\t\tast_log(LOG_WARNING, \"%s\", msg);\n\t} else {\n\t\tast_fax_log(LOG_DEBUG, msg);\n\t}\n}\n", "bug_type": null, "idx": 2159}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_priority(const struct ast_channel *chan)\n{\n\treturn chan->priority;\n}\n", "bug_type": null, "idx": 2160}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_format_get_channel_count(const struct ast_format *format)\n{\n\treturn format->channel_count;\n}\n", "bug_type": null, "idx": 2161}
{"project": "Asterisk", "target": 0, "func": "AST_LIST_HEAD_NOLOCK(load_order, load_order_entry);\nstatic struct load_order_entry *add_to_load_order(const char *resource, struct load_order *load_order, int required)\n{\n\tstruct load_order_entry *order;\n\tAST_LIST_TRAVERSE(load_order, order, entry) {\n\t\tif (!resource_name_match(order->resource, resource)) {\n\t\t\t\n\t\t\torder->required |= required;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (!(order = ast_calloc(1, sizeof(*order))))\n\t\treturn NULL;\n\torder->resource = ast_strdup(resource);\n\torder->required = required;\n\tAST_LIST_INSERT_TAIL(load_order, order, entry);\n\treturn order;\n}\n", "bug_type": null, "idx": 2162}
{"project": "Asterisk", "target": 0, "func": "OOBOOL ooCapabilityCheckCompatibility_Video\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245VideoCapability* videoCap, int dir)\n{\n   switch(videoCap->t)\n   {\n   case T_H245VideoCapability_h263VideoCapability:\n      return ooCapabilityCheckCompatibility_H263Video(call, epCap, \n                                                              videoCap, dir);\n   default:\n     OOTRACEDBGC3(\"ooCapabilityCheckCompatibility_Video - Unsupported video \"\n                  \"capability. (%s, %s)\\n\", call->callType, call->callToken);\n   }\n   return FALSE;\n}\n}\nOOBOOL ooCapabilityCheckCompatibility_Video\n   (OOH323CallData *call, ooH323EpCapability* epCap, \n    H245VideoCapability* videoCap, int dir)\n{\n   switch(videoCap->t)\n   {\n   case T_H245VideoCapability_h263VideoCapability:\n      return ooCapabilityCheckCompatibility_H263Video(call, epCap, \n                                                              videoCap, dir);\n   default:\n     OOTRACEDBGC3(\"ooCapabilityCheckCompatibility_Video - Unsupported video \"\n                  \"capability. (%s, %s)\\n\", call->callType, call->callToken);\n   }\n", "bug_type": null, "idx": 2163}
{"project": "Asterisk", "target": 0, "func": "static int applicationmap_handler(const struct aco_option *opt,\n\t\tstruct ast_variable *var, void *obj)\n{\n\tRAII_VAR(struct ast_applicationmap_item *, item, NULL, ao2_cleanup);\n\tstruct ao2_container *applicationmap = obj;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(dtmf);\n\t\tAST_APP_ARG(activate_on);\n\t\tAST_APP_ARG(app);\n\t\tAST_APP_ARG(app_data);\n\t\tAST_APP_ARG(moh_class);\n\t);\n\tchar *parse = ast_strdupa(var->value);\n\tchar *slash;\n\tchar *paren;\n\tunsigned int activate_on_self;\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (ast_strlen_zero(args.dtmf) ||\n\t\t\tast_strlen_zero(args.activate_on) ||\n\t\t\tast_strlen_zero(args.app)) {\n\t\tast_log(LOG_WARNING, \"Invalid applicationmap syntax for '%s'. Missing required argument\\n\", var->name);\n\t\treturn -1;\n\t}\n\t\n\tslash = strchr(args.activate_on, '/');\n\tif (slash) {\n\t\t*slash = '\\0';\n\t}\n\t\n\tif (!args.app_data) {\n\t\targs.app_data = \"\";\n\t}\n\t\n\tparen = strchr(args.app, '(');\n\tif (paren) {\n\t\t\n\t\tchar *close_paren;\n\t\targs.moh_class = args.app_data;\n\t\t*paren++ = '\\0';\n\t\tclose_paren = strrchr(paren, ')');\n\t\tif (close_paren) {\n\t\t\t*close_paren = '\\0';\n\t\t}\n\t\targs.app_data = paren;\n\t\t\n\t\tif (ast_strlen_zero(args.app)) {\n\t\t\tast_log(LOG_WARNING, \"Applicationmap item '%s' does not contain an application name.\\n\", var->name);\n\t\t\treturn -1;\n\t\t}\n\t} else if (strchr(args.app_data, '\"')) {\n\t\targs.app_data = ast_strip_quoted(args.app_data, \"\\\"\", \"\\\"\");\n\t}\n\t\n\tif (!strcasecmp(args.activate_on, \"self\") || !strcasecmp(args.activate_on, \"caller\")) {\n\t\tactivate_on_self = 1;\n\t} else if (!strcasecmp(args.activate_on, \"peer\") || !strcasecmp(args.activate_on, \"callee\")) {\n\t\tactivate_on_self = 0;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Invalid 'activate_on' value %s for applicationmap item %s\\n\",\n\t\t\targs.activate_on, var->name);\n\t\treturn -1;\n\t}\n\tast_debug(1, \"Allocating applicationmap item: dtmf = %s, app = %s, app_data = %s, moh_class = %s\\n\",\n\t\t\targs.dtmf, args.app, args.app_data, args.moh_class);\n\titem = applicationmap_item_alloc(var->name, args.app, args.app_data,\n\t\t\targs.moh_class, args.dtmf, activate_on_self);\n\tif (!item) {\n\t\treturn -1;\n\t}\n\tif (!ao2_link(applicationmap, item)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2164}
{"project": "Asterisk", "target": 0, "func": "static int refer_incoming_blind_request(struct ast_sip_session *session, pjsip_rx_data *rdata, pjsip_sip_uri *target,\n\tstruct refer_progress *progress)\n{\n\tconst char *context;\n\tchar exten[AST_MAX_EXTENSION];\n\tstruct refer_blind refer = { 0, };\n\tint response;\n\t\n\tDETERMINE_TRANSFER_CONTEXT(context, session);\n\t\n\tast_copy_pj_str(exten, &target->user, sizeof(exten));\n\t\n\tAST_SIP_USER_OPTIONS_TRUNCATE_CHECK(exten);\n\t\n\tif (ast_strlen_zero(exten)) {\n\t\tast_copy_string(exten, \"s\", sizeof(exten));\n\t\tast_debug(3, \"Channel '%s' from endpoint '%s' attempted blind transfer to a target without extension. Target was set to 's@%s'\\n\",\n\t\t\tast_channel_name(session->channel), ast_sorcery_object_get_id(session->endpoint), context);\n\t}\n\tif (!ast_exists_extension(NULL, context, exten, 1, NULL)) {\n\t\tast_log(LOG_ERROR, \"Channel '%s' from endpoint '%s' attempted blind transfer to '%s@%s' but target does not exist\\n\",\n\t\t\tast_channel_name(session->channel), ast_sorcery_object_get_id(session->endpoint), exten, context);\n\t\treturn 404;\n\t}\n\trefer.context = context;\n\trefer.progress = progress;\n\trefer.rdata = rdata;\n\trefer.refer_to = target;\n\trefer.attended = 0;\n\tif (ast_sip_session_defer_termination(session)) {\n\t\tast_log(LOG_ERROR, \"Channel '%s' from endpoint '%s' attempted blind transfer but could not defer termination, rejecting\\n\",\n\t\t\tast_channel_name(session->channel),\n\t\t\tast_sorcery_object_get_id(session->endpoint));\n\t\treturn 500;\n\t}\n\tresponse = xfer_response_code2sip(ast_bridge_transfer_blind(1, session->channel,\n\t\texten, context, refer_blind_callback, &refer));\n\tast_sip_session_end_if_deferred(session);\n\tif (response != 200) {\n\t\tast_sip_session_defer_termination_cancel(session);\n\t}\n\treturn response;\n}\n", "bug_type": null, "idx": 2165}
{"project": "Asterisk", "target": 0, "func": "\nvi_change_to_eol(EditLine *el, int c)\n{\n\t(void) ed_kill_line(el, 0);\n\tel->el_map.current = el->el_map.key;\n\treturn (CC_REFRESH);\n}\n", "bug_type": null, "idx": 2166}
{"project": "Asterisk", "target": 0, "func": "#if defined(mISDN_NATIVE_BRIDGING)\nstatic enum ast_bridge_result misdn_bridge(struct ast_channel *c0,\n\tstruct ast_channel *c1, int flags,\n\tstruct ast_frame **fo,\n\tstruct ast_channel **rc,\n\tint timeoutms)\n{\n\tstruct chan_list *ch1, *ch2;\n\tstruct ast_channel *carr[2], *who;\n\tint to = -1;\n\tstruct ast_frame *f;\n\tint p1_b, p2_b;\n\tint bridging;\n\tmisdn_cfg_get(0, MISDN_GEN_BRIDGING, &bridging, sizeof(bridging));\n\tif (!bridging) {\n\t\t\n\t\treturn AST_BRIDGE_FAILED_NOWARN;\n\t}\n\tch1 = get_chan_by_ast(c0);\n\tif (!ch1) {\n\t\treturn AST_BRIDGE_FAILED;\n\t}\n\tch2 = get_chan_by_ast(c1);\n\tif (!ch2) {\n\t\tchan_list_unref(ch1, \"Failed to find ch2\");\n\t\treturn AST_BRIDGE_FAILED;\n\t}\n\tcarr[0] = c0;\n\tcarr[1] = c1;\n\tmisdn_cfg_get(ch1->bc->port, MISDN_CFG_BRIDGING, &p1_b, sizeof(p1_b));\n\tmisdn_cfg_get(ch2->bc->port, MISDN_CFG_BRIDGING, &p2_b, sizeof(p2_b));\n\tif (!p1_b || !p2_b) {\n\t\tast_log(LOG_NOTICE, \"Falling back to Asterisk bridging\\n\");\n\t\tchan_list_unref(ch1, \"Bridge fallback ch1\");\n\t\tchan_list_unref(ch2, \"Bridge fallback ch2\");\n\t\treturn AST_BRIDGE_FAILED_NOWARN;\n\t}\n\t\n\tchan_misdn_log(1, ch1->bc->port, \"I SEND: Making conference with Number:%d\\n\", ch1->bc->pid + 1);\n\tmisdn_lib_bridge(ch1->bc, ch2->bc);\n\tast_verb(3, \"Native bridging %s and %s\\n\", ast_channel_name(c0), ast_channel_name(c1));\n\tchan_misdn_log(1, ch1->bc->port, \"* Making Native Bridge between \\\"%s\\\" <%s> and \\\"%s\\\" <%s>\\n\",\n\t\tch1->bc->caller.name,\n\t\tch1->bc->caller.number,\n\t\tch2->bc->caller.name,\n\t\tch2->bc->caller.number);\n\tif (!(flags & AST_BRIDGE_DTMF_CHANNEL_0)) {\n\t\tch1->ignore_dtmf = 1;\n\t}\n\tif (!(flags & AST_BRIDGE_DTMF_CHANNEL_1)) {\n\t\tch2->ignore_dtmf = 1;\n\t}\n\tfor (;;) {\n\t\tto = -1;\n\t\twho = ast_waitfor_n(carr, 2, &to);\n\t\tif (!who) {\n\t\t\tast_log(LOG_NOTICE, \"misdn_bridge: empty read, breaking out\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tf = ast_read(who);\n\t\tif (!f || (f->frametype == AST_FRAME_CONTROL && f->subclass.integer != AST_CONTROL_PVT_CAUSE_CODE)) {\n\t\t\t\n\t\t\tif (!f) {\n\t\t\t\tchan_misdn_log(4, ch1->bc->port, \"Read Null Frame\\n\");\n\t\t\t} else {\n\t\t\t\tchan_misdn_log(4, ch1->bc->port, \"Read Frame Control class:%d\\n\", f->subclass.integer);\n\t\t\t}\n\t\t\t*fo = f;\n\t\t\t*rc = who;\n\t\t\tbreak;\n\t\t}\n\t\tif (f->frametype == AST_FRAME_DTMF) {\n\t\t\tchan_misdn_log(1, 0, \"Read DTMF %d from %s\\n\", f->subclass.integer, ast_channel_exten(who));\n\t\t\t*fo = f;\n\t\t\t*rc = who;\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\tif (f->frametype == AST_FRAME_VOICE) {\n\t\t\tchan_misdn_log(1, ch1->bc->port, \"I SEND: Splitting conference with Number:%d\\n\", ch1->bc->pid +1);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (f->frametype == AST_FRAME_CONTROL && f->subclass.integer == AST_CONTROL_PVT_CAUSE_CODE) {\n\t\t\tast_channel_hangupcause_hash_set((who == c0) ? c1 : c0, f->data.ptr, f->datalen);\n\t\t} else {\n\t\t\tast_write((who == c0) ? c1 : c0, f);\n\t\t}\n\t}\n\tchan_misdn_log(1, ch1->bc->port, \"I SEND: Splitting conference with Number:%d\\n\", ch1->bc->pid + 1);\n\tmisdn_lib_split_bridge(ch1->bc, ch2->bc);\n\tchan_list_unref(ch1, \"Bridge complete ch1\");\n\tchan_list_unref(ch2, \"Bridge complete ch2\");\n\treturn AST_BRIDGE_COMPLETE;\n}\n", "bug_type": null, "idx": 2167}
{"project": "Asterisk", "target": 0, "func": "struct stasis_app_recording_options *stasis_app_recording_options_create(\n\tconst char *name, const char *format)\n{\n\tRAII_VAR(struct stasis_app_recording_options *, options, NULL,\n\t\tao2_cleanup);\n\toptions = ao2_alloc(sizeof(*options), recording_options_dtor);\n\tif (!options || ast_string_field_init(options, 128)) {\n\t\treturn NULL;\n\t}\n\tast_string_field_set(options, name, name);\n\tast_string_field_set(options, format, format);\n\tao2_ref(options, +1);\n\treturn options;\n}\n", "bug_type": null, "idx": 2168}
{"project": "Asterisk", "target": 0, "func": "static void send_charset_update(struct unistimsession *pte, int charset)\n{\n\tconst unsigned char* packet_send_charset;\n\tint packet_size;\n\tBUFFSEND;\n\tif (unistimdebug) {\n\t\tast_verb(0, \"Sending set default charset\\n\");\n\t}\n\tif (charset == LANG_DEFAULT) {\n\t\tcharset = options_languages[find_language(pte->device->language)].encoding;\n\t}\n\tswitch (charset) {\n\tcase ISO_8859_2:\n\t\tpacket_send_charset = packet_send_charset_iso_8859_2;\n\t\tpacket_size = sizeof(packet_send_charset_iso_8859_2);\n\t\tbreak;\n\tcase ISO_8859_4:\n\t\tpacket_send_charset = packet_send_charset_iso_8859_4;\n\t\tpacket_size = sizeof(packet_send_charset_iso_8859_4);\n\t\tbreak;\n\tcase ISO_8859_5:\n\t\tpacket_send_charset = packet_send_charset_iso_8859_5;\n\t\tpacket_size = sizeof(packet_send_charset_iso_8859_5);\n\t\tbreak;\n\tcase ISO_2022_JP:\n\t\tpacket_send_charset = packet_send_charset_iso_2022_jp;\n\t\tpacket_size = sizeof(packet_send_charset_iso_2022_jp);\n\t\tbreak;\n\tcase ISO_8859_1:\n\tdefault:\n\t\tpacket_send_charset = packet_send_charset_iso_8859_1;\n\t\tpacket_size = sizeof(packet_send_charset_iso_8859_1);\n\t}\n\tmemcpy(buffsend + SIZE_HEADER, packet_send_charset, packet_size);\n\tsend_client(SIZE_HEADER + packet_size, buffsend, pte);\n\treturn;\n}\n", "bug_type": null, "idx": 2169}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225H322Caps (OOCTXT* pctxt, H225H322Caps* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.nonStandardDataPresent = optbit;\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      invokeStartElement (pctxt, \"nonStandardData\", -1);\n      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"nonStandardData\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 2 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.dataRatesSupportedPresent = 1;\n                     invokeStartElement (pctxt, \"dataRatesSupported\", -1);\n                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"dataRatesSupported\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.supportedPrefixesPresent = 1;\n                     invokeStartElement (pctxt, \"supportedPrefixes\", -1);\n                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"supportedPrefixes\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2170}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225CallCreditCapability (OOCTXT* pctxt, H225CallCreditCapability* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.canDisplayAmountStringPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.canEnforceDurationLimitPresent);\n   \n   if (pvalue->m.canDisplayAmountStringPresent) {\n      stat = encodeBit (pctxt, (ASN1BOOL)pvalue->canDisplayAmountString);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   if (pvalue->m.canEnforceDurationLimitPresent) {\n      stat = encodeBit (pctxt, (ASN1BOOL)pvalue->canEnforceDurationLimit);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2171}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *xmpp_cli_purge_pubsub_nodes(struct ast_cli_entry *e, int cmd, struct\n\t\t\t\t\t ast_cli_args *a)\n{\n\tRAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);\n\tRAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);\n\tconst char *name;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"xmpp purge nodes\";\n\t\te->usage =\n\t\t\t\"Usage: xmpp purge nodes <connection> <node>\\n\"\n\t\t\t\"       Purges nodes on PubSub server\\n\"\n\t\t\t\"       as configured in xmpp.conf.\\n\";\n\t\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tname = a->argv[3];\n\tif (!cfg || !cfg->clients || !(clientcfg = xmpp_config_find(cfg->clients, name))) {\n\t\tast_cli(a->fd, \"Unable to find client '%s'!\\n\", name);\n\t\treturn CLI_FAILURE;\n\t}\n\tif (ast_test_flag(&cfg->global->pubsub, XMPP_XEP0248)) {\n\t\txmpp_pubsub_purge_nodes(clientcfg->client, a->argv[4]);\n\t} else {\n\t\txmpp_pubsub_delete_node(clientcfg->client, a->argv[4]);\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2172}
{"project": "Asterisk", "target": 0, "func": "static int tds_message_handler(DBPROCESS *dbproc, DBINT msgno, int msgstate, int severity, char *msgtext, char *srvname, char *procname, int line)\n{\n\tast_debug(1, \"Msg %d, Level %d, State %d, Line %d\\n\", msgno, severity, msgstate, line);\n\tast_log(LOG_NOTICE, \"%s\\n\", msgtext);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2173}
{"project": "Asterisk", "target": 0, "func": "struct ooh323_peer *find_friend(const char *name, int port)\n{\n\tstruct ooh323_peer *peer;  \n\tif (gH323Debug)\n\t\tast_verb(0, \"---   find_friend \\\"%s\\\"\\n\", name);\n\tast_mutex_lock(&peerl.lock);\n\tfor (peer = peerl.peers; peer; peer = peer->next) {\n\t\tif (gH323Debug) {\n\t\t\tast_verb(0, \"\t\tcomparing with \\\"%s\\\"\\n\", peer->ip);\n\t\t}\n\t\tif (!strcmp(peer->ip, name)) {\n\t\t\tif (port <= 0 || (port > 0 && peer->port == port)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tast_mutex_unlock(&peerl.lock);\n\tif (gH323Debug) {\n\t\tif (peer) {\n\t\t\tast_verb(0, \"\t\tfound matching friend\\n\");\n\t\t}\n\t\tast_verb(0, \"+++   find_friend \\\"%s\\\"\\n\", name);\n\t}\n\treturn peer;\t\t\n}\n", "bug_type": null, "idx": 2174}
{"project": "Asterisk", "target": 0, "func": "\nstatic int t38_reinvite_sdp_cb(struct ast_sip_session *session, pjmedia_sdp_session *sdp)\n{\n\tstruct t38_state *state;\n\tstate = t38_state_get_or_alloc(session);\n\tif (!state) {\n\t\treturn -1;\n\t}\n\tstate->media_state = ast_sip_session_media_state_clone(session->active_media_state);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2175}
{"project": "Asterisk", "target": 0, "func": "static char *meetme_show_cmd(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\t\n\tstruct ast_conf_user *user;\n\tstruct ast_conference *cnf;\n\tint hr, min, sec;\n\tint total = 0;\n\ttime_t now;\n#define MC_HEADER_FORMAT \"%-14s %-14s %-10s %-8s  %-8s  %-6s\\n\"\n#define MC_DATA_FORMAT \"%-12.12s   %4.4d\t      %4.4s       %02d:%02d:%02d  %-8s  %-6s\\n\"\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"meetme list\";\n\t\te->usage =\n\t\t\t\"Usage: meetme list [<confno>] [\" STR_CONCISE \"]\\n\"\n\t\t\t\"       List all conferences or a specific conference.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn complete_meetmecmd_list(a->line, a->word, a->pos, a->n);\n\t}\n\tif (a->argc == 2 || (a->argc == 3 && !strcasecmp(a->argv[2], STR_CONCISE))) {\n\t\t\n\t\tint concise = (a->argc == 3);\n\t\tstruct ast_str *marked_users;\n\t\tif (!(marked_users = ast_str_create(30))) {\n\t\t\treturn CLI_FAILURE;\n\t\t}\n\t\tnow = time(NULL);\n\t\tAST_LIST_LOCK(&confs);\n\t\tif (AST_LIST_EMPTY(&confs)) {\n\t\t\tif (!concise) {\n\t\t\t\tast_cli(a->fd, \"No active MeetMe conferences.\\n\");\n\t\t\t}\n\t\t\tAST_LIST_UNLOCK(&confs);\n\t\t\tast_free(marked_users);\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t\tif (!concise) {\n\t\t\tast_cli(a->fd, MC_HEADER_FORMAT, \"Conf Num\", \"Parties\", \"Marked\", \"Activity\", \"Creation\", \"Locked\");\n\t\t}\n\t\tAST_LIST_TRAVERSE(&confs, cnf, list) {\n\t\t\thr = (now - cnf->start) / 3600;\n\t\t\tmin = ((now - cnf->start) % 3600) / 60;\n\t\t\tsec = (now - cnf->start) % 60;\n\t\t\tif (!concise) {\n\t\t\t\tif (cnf->markedusers == 0) {\n\t\t\t\t\tast_str_set(&marked_users, 0, \"N/A \");\n\t\t\t\t} else {\n\t\t\t\t\tast_str_set(&marked_users, 0, \"%4.4d\", cnf->markedusers);\n\t\t\t\t}\n\t\t\t\tast_cli(a->fd, MC_DATA_FORMAT, cnf->confno, cnf->users,\n\t\t\t\t\tast_str_buffer(marked_users), hr, min, sec,\n\t\t\t\t\tcnf->isdynamic ? \"Dynamic\" : \"Static\", cnf->locked ? \"Yes\" : \"No\");\n\t\t\t} else {\n\t\t\t\tast_cli(a->fd, \"%s!%d!%d!%02d:%02d:%02d!%d!%d\\n\",\n\t\t\t\t\tcnf->confno,\n\t\t\t\t\tcnf->users,\n\t\t\t\t\tcnf->markedusers,\n\t\t\t\t\thr, min, sec,\n\t\t\t\t\tcnf->isdynamic,\n\t\t\t\t\tcnf->locked);\n\t\t\t}\n\t\t\ttotal += cnf->users;\n\t\t}\n\t\tAST_LIST_UNLOCK(&confs);\n\t\tif (!concise) {\n\t\t\tast_cli(a->fd, \"* Total number of MeetMe users: %d\\n\", total);\n\t\t}\n\t\tast_free(marked_users);\n\t\treturn CLI_SUCCESS;\n\t}\n\tif (a->argc == 3 || (a->argc == 4 && !strcasecmp(a->argv[3], STR_CONCISE))) {\n\t\tstruct ao2_iterator user_iter;\n\t\tint concise = (a->argc == 4);\n\t\t\n\t\tif (AST_LIST_EMPTY(&confs)) {\n\t\t\tif (!concise) {\n\t\t\t\tast_cli(a->fd, \"No active MeetMe conferences.\\n\");\n\t\t\t}\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t\t\n\t\tAST_LIST_LOCK(&confs);\n\t\tAST_LIST_TRAVERSE(&confs, cnf, list) {\n\t\t\tif (strcmp(cnf->confno, a->argv[2]) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cnf) {\n\t\t\tif (!concise)\n\t\t\t\tast_cli(a->fd, \"No such conference: %s.\\n\", a->argv[2]);\n\t\t\tAST_LIST_UNLOCK(&confs);\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t\t\n\t\ttime(&now);\n\t\tuser_iter = ao2_iterator_init(cnf->usercontainer, 0);\n\t\twhile((user = ao2_iterator_next(&user_iter))) {\n\t\t\thr = (now - user->jointime) / 3600;\n\t\t\tmin = ((now - user->jointime) % 3600) / 60;\n\t\t\tsec = (now - user->jointime) % 60;\n\t\t\tif (!concise) {\n\t\t\t\tast_cli(a->fd, \"User #: %-2.2d %12.12s %-20.20s Channel: %s %s %s %s %s %s %02d:%02d:%02d\\n\",\n\t\t\t\t\tuser->user_no,\n\t\t\t\t\tS_COR(ast_channel_caller(user->chan)->id.number.valid, ast_channel_caller(user->chan)->id.number.str, \"<unknown>\"),\n\t\t\t\t\tS_COR(ast_channel_caller(user->chan)->id.name.valid, ast_channel_caller(user->chan)->id.name.str, \"<no name>\"),\n\t\t\t\t\tast_channel_name(user->chan),\n\t\t\t\t\tast_test_flag64(&user->userflags, CONFFLAG_ADMIN) ? \"(Admin)\" : \"\",\n\t\t\t\t\tast_test_flag64(&user->userflags, CONFFLAG_MONITOR) ? \"(Listen only)\" : \"\",\n\t\t\t\t\tuser->adminflags & ADMINFLAG_MUTED ? \"(Admin Muted)\" : user->adminflags & ADMINFLAG_SELFMUTED ? \"(Muted)\" : \"\",\n\t\t\t\t\tuser->adminflags & ADMINFLAG_T_REQUEST ? \"(Request to Talk)\" : \"\",\n\t\t\t\t\tistalking(user->talking), hr, min, sec); \n\t\t\t} else {\n\t\t\t\tast_cli(a->fd, \"%d!%s!%s!%s!%s!%s!%s!%s!%d!%02d:%02d:%02d\\n\",\n\t\t\t\t\tuser->user_no,\n\t\t\t\t\tS_COR(ast_channel_caller(user->chan)->id.number.valid, ast_channel_caller(user->chan)->id.number.str, \"\"),\n\t\t\t\t\tS_COR(ast_channel_caller(user->chan)->id.name.valid, ast_channel_caller(user->chan)->id.name.str, \"\"),\n\t\t\t\t\tast_channel_name(user->chan),\n\t\t\t\t\tast_test_flag64(&user->userflags, CONFFLAG_ADMIN) ? \"1\" : \"\",\n\t\t\t\t\tast_test_flag64(&user->userflags, CONFFLAG_MONITOR) ? \"1\" : \"\",\n\t\t\t\t\tuser->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED) ? \"1\" : \"\",\n\t\t\t\t\tuser->adminflags & ADMINFLAG_T_REQUEST ? \"1\" : \"\",\n\t\t\t\t\tuser->talking, hr, min, sec);\n\t\t\t}\n\t\t\tao2_ref(user, -1);\n\t\t}\n\t\tao2_iterator_destroy(&user_iter);\n\t\tif (!concise) {\n\t\t\tast_cli(a->fd, \"%d users in that conference.\\n\", cnf->users);\n\t\t}\n\t\tAST_LIST_UNLOCK(&confs);\n\t\treturn CLI_SUCCESS;\n\t}\n\treturn CLI_SHOWUSAGE;\n}\n", "bug_type": null, "idx": 2176}
{"project": "Asterisk", "target": 0, "func": "static void misdn_send_unlock(struct misdn_bchannel *bc)\n{\n\t \n\tif (bc->send_lock)\n\t\tpthread_mutex_unlock(&bc->send_lock->lock);\n}\n", "bug_type": null, "idx": 2177}
{"project": "Asterisk", "target": 0, "func": "static int tos_handler(const struct aco_option *opt,\n\tstruct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\tunsigned int value;\n\tif (ast_str2tos(var->value, &value)) {\n\t\tast_log(LOG_ERROR, \"Error configuring endpoint '%s' - Could not \"\n\t\t\t\"interpret '%s' value '%s'\\n\",\n\t\t\tast_sorcery_object_get_id(endpoint), var->name, var->value);\n\t\treturn -1;\n\t}\n\tif (!strcmp(var->name, \"tos_audio\")) {\n\t\tendpoint->media.tos_audio = value;\n\t} else if (!strcmp(var->name, \"tos_video\")) {\n\t\tendpoint->media.tos_video = value;\n\t} else {\n\t\t\n\t\tast_assert(0);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2178}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int internal_extension_state_extended(struct ast_channel *c, const char *context, const char *exten,\n\tstruct ao2_container *device_state_info)\n{\n\tstruct ast_exten *e;\n\tif (!(e = ast_hint_extension(c, context, exten))) {  \n\t\treturn -1;                   \n\t}\n\tif (e->exten[0] == '_') {\n\t\t\n\t\tast_add_extension(e->parent->name, 0, exten, e->priority, e->label,\n\t\t\te->matchcid ? e->cidmatch : NULL, e->app, ast_strdup(e->data), ast_free_ptr,\n\t\t\te->registrar);\n\t\tif (!(e = ast_hint_extension(c, context, exten))) {\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn ast_extension_state2(e, device_state_info);  \n}\n", "bug_type": null, "idx": 2179}
{"project": "Asterisk", "target": 0, "func": "static void ast_category_append(struct ast_config *config, struct ast_category *category);\nstatic void ast_category_append(struct ast_config *config, struct ast_category *category)\n{\n\tif (config->last)\n\t\tconfig->last->next = category;\n\telse\n\t\tconfig->root = category;\n\tconfig->last = category;\n\tconfig->current = category;\n}\n", "bug_type": null, "idx": 2180}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225CallModel (OOCTXT* pctxt, H225CallModel* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"direct\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"direct\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"gatekeeperRouted\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"gatekeeperRouted\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 3;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2181}
{"project": "Asterisk", "target": 0, "func": " * \\brief Dialplan function to record voicemail */\nstatic int minivm_record_exec(struct ast_channel *chan, const char *data)\n{\n\tint res = 0;\n\tchar *tmp;\n\tstruct leave_vm_options leave_options;\n\tint argc;\n\tchar *argv[2];\n\tstruct ast_flags flags = { 0 };\n\tchar *opts[OPT_ARG_ARRAY_SIZE];\n\tmemset(&leave_options, 0, sizeof(leave_options));\n\t\n\tif (ast_channel_state(chan) != AST_STATE_UP)\n\t\tast_answer(chan);\n\tif (ast_strlen_zero(data))  {\n\t\tast_log(LOG_ERROR, \"Minivm needs at least an account argument \\n\");\n\t\treturn -1;\n\t}\n\ttmp = ast_strdupa((char *)data);\n\targc = ast_app_separate_args(tmp, ',', argv, ARRAY_LEN(argv));\n\tif (argc == 2) {\n\t\tif (ast_app_parse_options(minivm_app_options, &flags, opts, argv[1])) {\n\t\t\treturn -1;\n\t\t}\n\t\tast_copy_flags(&leave_options, &flags, OPT_SILENT | OPT_BUSY_GREETING | OPT_UNAVAIL_GREETING );\n\t\tif (ast_test_flag(&flags, OPT_RECORDGAIN)) {\n\t\t\tint gain;\n\t\t\tif (sscanf(opts[OPT_ARG_RECORDGAIN], \"%30d\", &gain) != 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid value '%s' provided for record gain option\\n\", opts[OPT_ARG_RECORDGAIN]);\n\t\t\t\treturn -1;\n\t\t\t} else \n\t\t\t\tleave_options.record_gain = (signed char) gain;\n\t\t}\n\t} \n\t\n\tres = leave_voicemail(chan, argv[0], &leave_options);\n\tif (res == ERROR_LOCK_PATH) {\n\t\tast_log(LOG_ERROR, \"Could not leave voicemail. The path is already locked.\\n\");\n\t\tpbx_builtin_setvar_helper(chan, \"MVM_RECORD_STATUS\", \"FAILED\");\n\t\tres = 0;\n\t}\n\tpbx_builtin_setvar_helper(chan, \"MVM_RECORD_STATUS\", \"SUCCESS\");\n\treturn res;\n}\n", "bug_type": null, "idx": 2182}
{"project": "Asterisk", "target": 0, "func": "int ooCapabilityUpdateJointCapabilitiesVideoH263\n   (OOH323CallData *call, H245H263VideoCapability *pH263Cap, int dir)\n{\n   ooH323EpCapability *epCap = NULL, *cur = NULL;\n   if(pH263Cap->m.sqcifMPIPresent)\n   {\n      epCap =  ooIsVideoDataTypeH263Supported(call, pH263Cap, dir, \n                                                          OO_PICFORMAT_SQCIF);\n      if(epCap)\n      {\n         OOTRACEDBGC3(\"Adding H263-SQCIF to joint capabilities(%s, %s)\\n\",\n                      call->callType, call->callToken);\n         \n         if(!call->jointCaps)\n            call->jointCaps = epCap;\n         else {\n            cur = call->jointCaps;\n            while(cur->next) cur = cur->next;\n            cur->next = epCap;\n         }\n      }     \n   }\n   epCap = NULL;\n   if(pH263Cap->m.qcifMPIPresent)\n   {\n      epCap =  ooIsVideoDataTypeH263Supported(call, pH263Cap, dir, \n                                                          OO_PICFORMAT_QCIF);\n      if(epCap)\n      {\n         OOTRACEDBGC3(\"Adding H263-QCIF to joint capabilities(%s, %s)\\n\",\n                      call->callType, call->callToken);\n         \n         if(!call->jointCaps)\n            call->jointCaps = epCap;\n         else {\n            cur = call->jointCaps;\n            while(cur->next) cur = cur->next;\n            cur->next = epCap;\n         }\n      }     \n   }\n   epCap = NULL;\n   if(pH263Cap->m.cifMPIPresent)\n   {\n      epCap =  ooIsVideoDataTypeH263Supported(call, pH263Cap, dir, \n                                                          OO_PICFORMAT_CIF);\n      if(epCap)\n      {\n         OOTRACEDBGC3(\"Adding H263-CIF to joint capabilities(%s, %s)\\n\",\n                      call->callType, call->callToken);\n         \n         if(!call->jointCaps)\n            call->jointCaps = epCap;\n         else {\n            cur = call->jointCaps;\n            while(cur->next) cur = cur->next;\n            cur->next = epCap;\n         }\n      }     \n   }\n   epCap = NULL;\n   if(pH263Cap->m.cif4MPIPresent)\n   {\n      epCap =  ooIsVideoDataTypeH263Supported(call, pH263Cap, dir, \n                                                          OO_PICFORMAT_CIF4);\n      if(epCap)\n      {\n         OOTRACEDBGC3(\"Adding H263-CIF4 to joint capabilities(%s, %s)\\n\",\n                      call->callType, call->callToken);\n         \n         if(!call->jointCaps)\n            call->jointCaps = epCap;\n         else {\n            cur = call->jointCaps;\n            while(cur->next) cur = cur->next;\n            cur->next = epCap;\n         }\n      }     \n   }\n   epCap = NULL;\n   if(pH263Cap->m.cif16MPIPresent)\n   {\n      epCap =  ooIsVideoDataTypeH263Supported(call, pH263Cap, dir, \n                                                          OO_PICFORMAT_CIF16);\n      if(epCap)\n      {\n         OOTRACEDBGC3(\"Adding H263-CIF16 to joint capabilities(%s, %s)\\n\",\n                      call->callType, call->callToken);\n         \n         if(!call->jointCaps)\n            call->jointCaps = epCap;\n         else {\n            cur = call->jointCaps;\n            while(cur->next) cur = cur->next;\n            cur->next = epCap;\n         }\n      }     \n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 2183}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_channel_queue_control_data(struct ast_bridge_channel *bridge_channel, enum ast_control_frame_type control, const void *data, size_t datalen)\n{\n\tstruct ast_frame frame = {\n\t\t.frametype = AST_FRAME_CONTROL,\n\t\t.subclass.integer = control,\n\t\t.datalen = datalen,\n\t\t.data.ptr = (void *) data,\n\t};\n\treturn ast_bridge_channel_queue_frame(bridge_channel, &frame);\n}\n", "bug_type": null, "idx": 2184}
{"project": "Asterisk", "target": 0, "func": "static int feature_automixmonitor(struct ast_bridge_channel *bridge_channel, void *hook_pvt)\n{\n\tstatic const char *mixmonitor_spy_type = \"MixMonitor\";\n\tconst char *stop_message;\n\tconst char *start_message;\n\tstruct ast_bridge_features_automixmonitor *options = hook_pvt;\n\tenum ast_bridge_features_monitor start_stop = options ? options->start_stop : AUTO_MONITOR_TOGGLE;\n\tint is_monitoring;\n\tRAII_VAR(struct ast_channel *, peer_chan, NULL, ast_channel_cleanup);\n\tRAII_VAR(struct ast_features_general_config *, features_cfg, NULL, ao2_cleanup);\n\tast_channel_lock(bridge_channel->chan);\n\tfeatures_cfg = ast_get_chan_features_general_config(bridge_channel->chan);\n\tast_channel_unlock(bridge_channel->chan);\n\tast_bridge_channel_lock_bridge(bridge_channel);\n\tpeer_chan = ast_bridge_peer_nolock(bridge_channel->bridge, bridge_channel->chan);\n\tast_bridge_unlock(bridge_channel->bridge);\n\tif (!peer_chan) {\n\t\tast_verb(4, \"Cannot start AutoMixMonitor for %s - cannot determine peer in bridge.\\n\",\n\t\t\tast_channel_name(bridge_channel->chan));\n\t\tif (features_cfg && !ast_strlen_zero(features_cfg->recordingfailsound)) {\n\t\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, features_cfg->recordingfailsound, NULL);\n\t\t}\n\t\treturn 0;\n\t}\n\tast_channel_lock(bridge_channel->chan);\n\tstart_message = pbx_builtin_getvar_helper(bridge_channel->chan,\n\t\t\"TOUCH_MIXMONITOR_MESSAGE_START\");\n\tstart_message = ast_strdupa(S_OR(start_message, \"\"));\n\tstop_message = pbx_builtin_getvar_helper(bridge_channel->chan,\n\t\t\"TOUCH_MIXMONITOR_MESSAGE_STOP\");\n\tstop_message = ast_strdupa(S_OR(stop_message, \"\"));\n\tast_channel_unlock(bridge_channel->chan);\n\tis_monitoring =\n\t\t0 < ast_channel_audiohook_count_by_source(peer_chan, mixmonitor_spy_type, AST_AUDIOHOOK_TYPE_SPY);\n\tswitch (start_stop) {\n\tcase AUTO_MONITOR_TOGGLE:\n\t\tif (is_monitoring) {\n\t\t\tstop_automixmonitor(bridge_channel, peer_chan, features_cfg, stop_message);\n\t\t} else {\n\t\t\tstart_automixmonitor(bridge_channel, peer_chan, features_cfg, start_message);\n\t\t}\n\t\treturn 0;\n\tcase AUTO_MONITOR_START:\n\t\tif (!is_monitoring) {\n\t\t\tstart_automixmonitor(bridge_channel, peer_chan, features_cfg, start_message);\n\t\t\treturn 0;\n\t\t}\n\t\tast_verb(4, \"AutoMixMonitor already recording call.\\n\");\n\t\tbreak;\n\tcase AUTO_MONITOR_STOP:\n\t\tif (is_monitoring) {\n\t\t\tstop_automixmonitor(bridge_channel, peer_chan, features_cfg, stop_message);\n\t\t\treturn 0;\n\t\t}\n\t\tast_verb(4, \"AutoMixMonitor already stopped on call.\\n\");\n\t\tbreak;\n\t}\n\t\n\tif (features_cfg && !ast_strlen_zero(features_cfg->courtesytone)) {\n\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, features_cfg->courtesytone, NULL);\n\t}\n\tif (is_monitoring) {\n\t\tif (!ast_strlen_zero(start_message)) {\n\t\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, start_message, NULL);\n\t\t}\n\t} else {\n\t\tif (!ast_strlen_zero(stop_message)) {\n\t\t\tast_bridge_channel_queue_playfile(bridge_channel, NULL, stop_message, NULL);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2185}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225TimeToLive (OOCTXT* pctxt, H225TimeToLive* pvalue)\n{\n   int stat = ASN_OK;\n   stat = decodeConsUnsigned (pctxt, pvalue, 1U, ASN1UINT_MAX);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, *pvalue);\n   return (stat);\n}\n", "bug_type": null, "idx": 2186}
{"project": "Asterisk", "target": 0, "func": "#if defined(AO2_DEBUG)\nstatic void ao2_reg_destructor(void *v_doomed)\n{\n\tstruct ao2_reg_container *doomed = v_doomed;\n\tif (doomed->registered) {\n\t\tao2_t_ref(doomed->registered, -1, \"Releasing registered container.\");\n\t}\n}\n", "bug_type": null, "idx": 2187}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_publish_snapshot(struct ast_channel *chan)\n{\n\tRAII_VAR(struct ast_channel_snapshot *, snapshot, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tif (!ast_channel_snapshot_type()) {\n\t\treturn;\n\t}\n\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_SNAPSHOT_STAGE)) {\n\t\treturn;\n\t}\n\tsnapshot = ast_channel_snapshot_create(chan);\n\tif (!snapshot) {\n\t\treturn;\n\t}\n\tmessage = stasis_message_create(ast_channel_snapshot_type(), snapshot);\n\tif (!message) {\n\t\treturn;\n\t}\n\tast_assert(ast_channel_topic(chan) != NULL);\n\tstasis_publish(ast_channel_topic(chan), message);\n}\n", "bug_type": null, "idx": 2188}
{"project": "Asterisk", "target": 0, "func": "static void ss7_apply_plan_to_number(char *buf, size_t size, const struct sig_ss7_linkset *ss7, const char *number, const unsigned nai)\n{\n\tif (ast_strlen_zero(number)) { \n\t\tif (size) {\n\t\t\t*buf = '\\0';\n\t\t}\n\t\treturn;\n\t}\n\tswitch (nai) {\n\tcase SS7_NAI_INTERNATIONAL:\n\t\tsnprintf(buf, size, \"%s%s\", ss7->internationalprefix, number);\n\t\tbreak;\n\tcase SS7_NAI_NATIONAL:\n\t\tsnprintf(buf, size, \"%s%s\", ss7->nationalprefix, number);\n\t\tbreak;\n\tcase SS7_NAI_SUBSCRIBER:\n\t\tsnprintf(buf, size, \"%s%s\", ss7->subscriberprefix, number);\n\t\tbreak;\n\tcase SS7_NAI_UNKNOWN:\n\t\tsnprintf(buf, size, \"%s%s\", ss7->unknownprefix, number);\n\t\tbreak;\n\tcase SS7_NAI_NETWORKROUTED:\n\t\tsnprintf(buf, size, \"%s%s\", ss7->networkroutedprefix, number);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(buf, size, \"%s\", number);\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 2189}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void ewscal_destructor(void *obj)\n{\n\tstruct ewscal_pvt *pvt = obj;\n\tast_debug(1, \"Destroying pvt for Exchange Web Service calendar %s\\n\", \"pvt->owner->name\");\n\tif (pvt->session) {\n\t\tne_session_destroy(pvt->session);\n\t}\n\tast_string_field_free_memory(pvt);\n\tao2_callback(pvt->events, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);\n\tao2_ref(pvt->events, -1);\n}\n", "bug_type": null, "idx": 2190}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_unregister(&env_function);\n\tres |= ast_custom_function_unregister(&stat_function);\n\tres |= ast_custom_function_unregister(&file_function);\n\tres |= ast_custom_function_unregister(&file_count_line_function);\n\tres |= ast_custom_function_unregister(&file_format_function);\n\treturn res;\n}\n", "bug_type": null, "idx": 2191}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum sip_get_destination_result get_destination(struct ast_sip_session *session, pjsip_rx_data *rdata)\n{\n\tpjsip_uri *ruri = rdata->msg_info.msg->line.req.uri;\n\tpjsip_sip_uri *sip_ruri;\n\tstruct ast_features_pickup_config *pickup_cfg;\n\tconst char *pickupexten;\n\tif (!PJSIP_URI_SCHEME_IS_SIP(ruri) && !PJSIP_URI_SCHEME_IS_SIPS(ruri)) {\n\t\treturn SIP_GET_DEST_UNSUPPORTED_URI;\n\t}\n\tsip_ruri = pjsip_uri_get_uri(ruri);\n\tast_copy_pj_str(session->exten, &sip_ruri->user, sizeof(session->exten));\n\t\n\tAST_SIP_USER_OPTIONS_TRUNCATE_CHECK(session->exten);\n\tpickup_cfg = ast_get_chan_features_pickup_config(session->channel);\n\tif (!pickup_cfg) {\n\t\tast_log(LOG_ERROR, \"Unable to retrieve pickup configuration options. Unable to detect call pickup extension\\n\");\n\t\tpickupexten = \"\";\n\t} else {\n\t\tpickupexten = ast_strdupa(pickup_cfg->pickupexten);\n\t\tao2_ref(pickup_cfg, -1);\n\t}\n\tif (!strcmp(session->exten, pickupexten) ||\n\t\tast_exists_extension(NULL, session->endpoint->context, session->exten, 1, NULL)) {\n\t\tsize_t size = pj_strlen(&sip_ruri->host) + 1;\n\t\tchar *domain = ast_alloca(size);\n\t\tast_copy_pj_str(domain, &sip_ruri->host, size);\n\t\tpbx_builtin_setvar_helper(session->channel, \"SIPDOMAIN\", domain);\n\t\treturn SIP_GET_DEST_EXTEN_FOUND;\n\t}\n\t\n\tif (session->endpoint->allow_overlap && (\n\t\t!strncmp(session->exten, pickupexten, strlen(session->exten)) ||\n\t\tast_canmatch_extension(NULL, session->endpoint->context, session->exten, 1, NULL))) {\n\t\t\n\t\treturn SIP_GET_DEST_EXTEN_PARTIAL;\n\t}\n\treturn SIP_GET_DEST_EXTEN_NOT_FOUND;\n}\n", "bug_type": null, "idx": 2192}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int url_is_vulnerable(const char *url)\n{\n\tif (strpbrk(url, \"\\r\\n\")) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2193}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int send_bridge_list_item_cb(void *obj, void *arg, void *data, int flags)\n{\n\tstruct ast_bridge_snapshot *snapshot = stasis_message_data(obj);\n\tstruct mansession *s = arg;\n\tstruct bridge_list_data *list_data = data;\n\tRAII_VAR(struct ast_str *, bridge_info, ast_manager_build_bridge_state_string(snapshot), ast_free);\n\tif (!bridge_info) {\n\t\treturn 0;\n\t}\n\tastman_append(s,\n\t\t\"Event: BridgeListItem\\r\\n\"\n\t\t\"%s\"\n\t\t\"%s\"\n\t\t\"\\r\\n\",\n\t\tlist_data->id_text,\n\t\tast_str_buffer(bridge_info));\n\t++list_data->count;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2194}
{"project": "Asterisk", "target": 0, "func": "static MYSQL mysql = { { NULL }, };\nstatic char *handle_cli_cdr_mysql_status(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"cdr mysql status\";\n\t\te->usage =\n\t\t\t\"Usage: cdr mysql status\\n\"\n\t\t\t\"       Shows current connection status for cdr_mysql\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3)\n\t\treturn CLI_SHOWUSAGE;\n\tif (connected) {\n\t\tchar status[256];\n\t\tchar status2[100] = \"\";\n\t\tchar buf[362]; \n\t\tint ctime = time(NULL) - connect_time;\n\t\tif (dbport)\n\t\t\tsnprintf(status, 255, \"Connected to %s@%s, port %d\", ast_str_buffer(dbname), ast_str_buffer(hostname), dbport);\n\t\telse if (dbsock)\n\t\t\tsnprintf(status, 255, \"Connected to %s on socket file %s\", ast_str_buffer(dbname), S_OR(ast_str_buffer(dbsock), \"default\"));\n\t\telse\n\t\t\tsnprintf(status, 255, \"Connected to %s@%s\", ast_str_buffer(dbname), ast_str_buffer(hostname));\n\t\tif (!ast_strlen_zero(ast_str_buffer(dbuser)))\n\t\t\tsnprintf(status2, 99, \" with username %s\", ast_str_buffer(dbuser));\n\t\tif (ast_str_strlen(dbtable))\n\t\t\tsnprintf(status2, 99, \" using table %s\", ast_str_buffer(dbtable));\n\t\tsnprintf(buf, sizeof(buf), \"%s%s for \", status, status2);\n\t\tast_cli_print_timestr_fromseconds(a->fd, ctime, buf);\n\t\tif (records == totalrecords)\n\t\t\tast_cli(a->fd, \"  Wrote %d records since last restart.\\n\", totalrecords);\n\t\telse\n\t\t\tast_cli(a->fd, \"  Wrote %d records since last restart and %d records since last reconnect.\\n\", totalrecords, records);\n\t} else {\n\t\tast_cli(a->fd, \"Not currently connected to a MySQL server.\\n\");\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2195}
{"project": "Asterisk", "target": 0, "func": "#endif\nstatic void new_find_extension(const char *str, struct scoreboard *score, struct match_char *tree, int length, int spec, const char *callerid, const char *label, enum ext_match_t action)\n{\n\tstruct match_char *p; \n\tstruct ast_exten pattern = { .label = label };\n#ifdef DEBUG_THIS\n\tif (tree)\n\t\tast_log(LOG_NOTICE,\"new_find_extension called with %s on (sub)tree %s action=%s\\n\", str, tree->x, action2str(action));\n\telse\n\t\tast_log(LOG_NOTICE,\"new_find_extension called with %s on (sub)tree NULL action=%s\\n\", str, action2str(action));\n#endif\n\tfor (p = tree; p; p = p->alt_char) {\n\t\tif (p->is_pattern) {\n\t\t\tif (p->x[0] == 'N') {\n\t\t\t\tif (p->x[1] == 0 && *str >= '2' && *str <= '9' ) {\n#define\tNEW_MATCHER_CHK_MATCH\t       \\\n\t\t\t\t\tif (p->exten && !(*(str + 1))) {              \\\n\t\t\t\t\t\tif (action == E_MATCH || action == E_SPAWN || action == E_FINDLABEL) {    \\\n\t\t\t\t\t\t\tupdate_scoreboard(score, length + 1, spec + p->specificity, p->exten, 0, callerid, p->deleted, p);                 \\\n\t\t\t\t\t\t\tif (!p->deleted) {                                                                                           \\\n\t\t\t\t\t\t\t\tif (action == E_FINDLABEL) {                                                                             \\\n\t\t\t\t\t\t\t\t\tif (ast_hashtab_lookup(score->exten->peer_label_table, &pattern)) {                                  \\\n\t\t\t\t\t\t\t\t\t\tast_debug(4, \"Found label in preferred extension\\n\");                                            \\\n\t\t\t\t\t\t\t\t\t\treturn;                                                                                          \\\n\t\t\t\t\t\t\t\t\t}                                                                                                    \\\n\t\t\t\t\t\t\t\t} else {                                                                                                 \\\n\t\t\t\t\t\t\t\t\tast_debug(4, \"returning an exact match-- first found-- %s\\n\", p->exten->name);                       \\\n\t\t\t\t\t\t\t\t\treturn;            \\\n\t\t\t\t\t\t\t\t}                                                                                                        \\\n\t\t\t\t\t\t\t}                                                                                                            \\\n\t\t\t\t\t\t}                                                                                                                \\\n\t\t\t\t\t}\n#define\tNEW_MATCHER_RECURSE\t           \\\n\t\t\t\t\tif (p->next_char && (*(str + 1) || (p->next_char->x[0] == '/' && p->next_char->x[1] == 0)                 \\\n\t\t                                       || p->next_char->x[0] == '!')) {                                          \\\n\t\t\t\t\t\tif (*(str + 1) || p->next_char->x[0] == '!') {                                                         \\\n\t\t\t\t\t\t\tnew_find_extension(str + 1, score, p->next_char, length + 1, spec + p->specificity, callerid, label, action); \\\n\t\t\t\t\t\t\tif (score->exten)  {                                                                             \\\n\t\t\t\t\t\t        ast_debug(4 ,\"returning an exact match-- %s\\n\", score->exten->name);                         \\\n\t\t\t\t\t\t\t\treturn;                                                  \\\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t                                                 \\\n\t\t\t\t\t\t} else {                                                                                             \\\n\t\t\t\t\t\t\tnew_find_extension(\"/\", score, p->next_char, length + 1, spec + p->specificity, callerid, label, action);\t \\\n\t\t\t\t\t\t\tif (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {      \\\n\t\t\t\t\t\t        ast_debug(4,\"returning a (can/more) match--- %s\\n\", score->exten ? score->exten->name :      \\\n\t\t                               \"NULL\");                                                                        \\\n\t\t\t\t\t\t\t\treturn;                                                  \\\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t                                                 \\\n\t\t\t\t\t\t}                                                                                                    \\\n\t\t\t\t\t} else if ((p->next_char || action == E_CANMATCH) && !*(str + 1)) {                                                                  \\\n\t\t\t\t\t\tscore->canmatch = 1;                                                                                 \\\n\t\t\t\t\t\tscore->canmatch_exten = get_canmatch_exten(p);                                                       \\\n\t\t\t\t\t\tif (action == E_CANMATCH || action == E_MATCHMORE) {                                                 \\\n\t\t\t\t\t        ast_debug(4, \"returning a canmatch/matchmore--- str=%s\\n\", str);                                  \\\n\t\t\t\t\t\t\treturn;                                                                                          \\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t                                                     \\\n\t\t\t\t\t}\n\t\t\t\t\tNEW_MATCHER_CHK_MATCH;\n\t\t\t\t\tNEW_MATCHER_RECURSE;\n\t\t\t\t}\n\t\t\t} else if (p->x[0] == 'Z') {\n\t\t\t\tif (p->x[1] == 0 && *str >= '1' && *str <= '9' ) {\n\t\t\t\t\tNEW_MATCHER_CHK_MATCH;\n\t\t\t\t\tNEW_MATCHER_RECURSE;\n\t\t\t\t}\n\t\t\t} else if (p->x[0] == 'X') {\n\t\t\t\tif (p->x[1] == 0 && *str >= '0' && *str <= '9' ) {\n\t\t\t\t\tNEW_MATCHER_CHK_MATCH;\n\t\t\t\t\tNEW_MATCHER_RECURSE;\n\t\t\t\t}\n\t\t\t} else if (p->x[0] == '.' && p->x[1] == 0) {\n\t\t\t\t\n\t\t\t\tint i = 0;\n\t\t\t\tconst char *str2 = str;\n\t\t\t\twhile (*str2 && *str2 != '/') {\n\t\t\t\t\tstr2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif (p->exten && *str2 != '/') {\n\t\t\t\t\tupdate_scoreboard(score, length + i, spec + (i * p->specificity), p->exten, '.', callerid, p->deleted, p);\n\t\t\t\t\tif (score->exten) {\n\t\t\t\t\t\tast_debug(4, \"return because scoreboard has a match with '/'--- %s\\n\",\n\t\t\t\t\t\t\tscore->exten->name);\n\t\t\t\t\t\treturn; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p->next_char && p->next_char->x[0] == '/' && p->next_char->x[1] == 0) {\n\t\t\t\t\tnew_find_extension(\"/\", score, p->next_char, length + i, spec+(p->specificity*i), callerid, label, action);\n\t\t\t\t\tif (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {\n\t\t\t\t\t\tast_debug(4, \"return because scoreboard has exact match OR \"\n\t\t\t\t\t\t\t\"CANMATCH/MATCHMORE & canmatch set--- %s\\n\",\n\t\t\t\t\t\t\tscore->exten ? score->exten->name : \"NULL\");\n\t\t\t\t\t\treturn; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (p->x[0] == '!' && p->x[1] == 0) {\n\t\t\t\t\n\t\t\t\tint i = 1;\n\t\t\t\tconst char *str2 = str;\n\t\t\t\twhile (*str2 && *str2 != '/') {\n\t\t\t\t\tstr2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif (p->exten && *str2 != '/') {\n\t\t\t\t\tupdate_scoreboard(score, length + 1, spec + (p->specificity * i), p->exten, '!', callerid, p->deleted, p);\n\t\t\t\t\tif (score->exten) {\n\t\t\t\t\t\tast_debug(4, \"return because scoreboard has a '!' match--- %s\\n\",\n\t\t\t\t\t\t\tscore->exten->name);\n\t\t\t\t\t\treturn; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p->next_char && p->next_char->x[0] == '/' && p->next_char->x[1] == 0) {\n\t\t\t\t\tnew_find_extension(\"/\", score, p->next_char, length + i, spec + (p->specificity * i), callerid, label, action);\n\t\t\t\t\tif (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {\n\t\t\t\t\t\tast_debug(4, \"return because scoreboard has exact match OR \"\n\t\t\t\t\t\t\t\"CANMATCH/MATCHMORE & canmatch set with '/' and '!'--- %s\\n\",\n\t\t\t\t\t\t\tscore->exten ? score->exten->name : \"NULL\");\n\t\t\t\t\t\treturn; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (p->x[0] == '/' && p->x[1] == 0) {\n\t\t\t\t\n\t\t\t\tif (p->next_char && callerid && *callerid) {\n\t\t\t\t\tnew_find_extension(callerid, score, p->next_char, length + 1, spec, callerid, label, action);\n\t\t\t\t\tif (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {\n\t\t\t\t\t\tast_debug(4, \"return because scoreboard has exact match OR \"\n\t\t\t\t\t\t\t\"CANMATCH/MATCHMORE & canmatch set with '/'--- %s\\n\",\n\t\t\t\t\t\t\tscore->exten ? score->exten->name : \"NULL\");\n\t\t\t\t\t\treturn; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (strchr(p->x, *str)) {\n\t\t\t\tast_debug(4, \"Nothing strange about this match\\n\");\n\t\t\t\tNEW_MATCHER_CHK_MATCH;\n\t\t\t\tNEW_MATCHER_RECURSE;\n\t\t\t}\n\t\t} else if (strchr(p->x, *str)) {\n\t\t\tast_debug(4, \"Nothing strange about this match\\n\");\n\t\t\tNEW_MATCHER_CHK_MATCH;\n\t\t\tNEW_MATCHER_RECURSE;\n\t\t}\n\t}\n\tast_debug(4, \"return at end of func\\n\");\n}\n", "bug_type": null, "idx": 2196}
{"project": "Asterisk", "target": 0, "func": "static inline int is_text(const struct odbc_cache_columns *column)\n{\n\treturn column->type == SQL_CHAR || column->type == SQL_VARCHAR || column->type == SQL_LONGVARCHAR\n\t\t|| column->type == SQL_WCHAR || column->type == SQL_WVARCHAR || column->type == SQL_WLONGVARCHAR;\n}\n", "bug_type": null, "idx": 2197}
{"project": "Asterisk", "target": 0, "func": "static int lang_cmp_fn(void *obj, void *arg, int flags)\n{\n\tstruct ustm_lang_entry *entry1 = obj;\n\tstruct ustm_lang_entry *entry2 = arg;\n\treturn (!strcmp(entry1->str_orig, entry2->str_orig)) ? (CMP_MATCH | CMP_STOP) : 0;\n}\n", "bug_type": null, "idx": 2198}
{"project": "Asterisk", "target": 0, "func": "static int write_header(FILE *f, int writehz)\n{\n\tunsigned int hz;\n\tunsigned int bhz;\n\tunsigned int hs = htoll(16);\n\tunsigned short fmt = htols(1);\n\tunsigned short chans = htols(1);\n\tunsigned short bysam = htols(2);\n\tunsigned short bisam = htols(16);\n\tunsigned int size = htoll(0);\n\tif (writehz == 16000) {\n\t\thz = htoll(16000);\n\t\tbhz = htoll(32000);\n\t} else {\n\t\thz = htoll(8000);\n\t\tbhz = htoll(16000);\n\t}\n\t\n\tfseek(f,0,SEEK_SET);\n\tif (fwrite(\"RIFF\", 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&size, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(\"WAVEfmt \", 1, 8, f) != 8) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&hs, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&fmt, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&chans, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&hz, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&bhz, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&bysam, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&bisam, 1, 2, f) != 2) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(\"data\", 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\tif (fwrite(&size, 1, 4, f) != 4) {\n\t\tast_log(LOG_WARNING, \"Unable to write header\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2199}
{"project": "Asterisk", "target": 0, "func": "static void parking_lot_destructor(void *obj)\n{\n\tstruct parking_lot *lot = obj;\n\tif (lot->parking_bridge) {\n\t\tast_bridge_destroy(lot->parking_bridge, 0);\n\t}\n\tao2_cleanup(lot->parked_users);\n\tao2_cleanup(lot->cfg);\n\tast_string_field_free_memory(lot);\n}\n", "bug_type": null, "idx": 2200}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_presence_exten_state_to_str(int state, char **statestring, char **pidfstate,\n\t\t\t       char **pidfnote, enum ast_sip_pidf_state *local_state,\n\t\t\t       unsigned int notify_early_inuse_ringing)\n{\n\tswitch (state) {\n\tcase AST_EXTENSION_RINGING:\n\t\t*statestring = \"early\";\n\t\t*local_state = NOTIFY_INUSE;\n\t\t*pidfstate = \"on-the-phone\";\n\t\t*pidfnote = \"Ringing\";\n\t\tbreak;\n\tcase (AST_EXTENSION_INUSE | AST_EXTENSION_RINGING):\n\t\tif (notify_early_inuse_ringing) {\n\t\t\t*statestring = \"early\";\n\t\t} else {\n\t\t\t*statestring = \"confirmed\";\n\t\t}\n\t\t*local_state = NOTIFY_INUSE;\n\t\t*pidfstate = \"on-the-phone\";\n\t\t*pidfnote = \"Ringing\";\n\t\tbreak;\n\tcase AST_EXTENSION_INUSE:\n\t\t*statestring = \"confirmed\";\n\t\t*local_state = NOTIFY_INUSE;\n\t\t*pidfstate = \"on-the-phone\";\n\t\t*pidfnote = \"On the phone\";\n\t\tbreak;\n\tcase AST_EXTENSION_BUSY:\n\t\t*statestring = \"confirmed\";\n\t\t*local_state = NOTIFY_INUSE;\n\t\t*pidfstate = \"on-the-phone\";\n\t\t*pidfnote = \"On the phone\";\n\t\tbreak;\n\tcase AST_EXTENSION_UNAVAILABLE:\n\t\t*statestring = \"terminated\";\n\t\t*local_state = NOTIFY_CLOSED;\n\t\t*pidfstate = \"--\";\n\t\t*pidfnote = \"Unavailable\";\n\t\tbreak;\n\tcase AST_EXTENSION_ONHOLD:\n\t\t*statestring = \"confirmed\";\n\t\t*local_state = NOTIFY_INUSE;\n\t\t*pidfstate = \"on-the-phone\";\n\t\t*pidfnote = \"On hold\";\n\t\tbreak;\n\tcase AST_EXTENSION_NOT_INUSE:\n\tdefault:\n\t\t\n\t\t*statestring = \"terminated\";\n\t\t*local_state = NOTIFY_OPEN;\n\t\t*pidfstate = \"--\";\n\t\t*pidfnote = \"Ready\";\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 2201}
{"project": "Asterisk", "target": 0, "func": "static off_t g726_tell(struct ast_filestream *fs)\n{\n\treturn -1;\n}\n", "bug_type": null, "idx": 2202}
{"project": "Asterisk", "target": 0, "func": "static void info_configuration_destroy(struct ast_sip_endpoint_info_configuration *info)\n{\n\tast_string_field_free_memory(&info->recording);\n}\n", "bug_type": null, "idx": 2203}
{"project": "Asterisk", "target": 0, "func": "void ast_std_free(void *ptr)\n{\n\tfree(ptr);\n}\n", "bug_type": null, "idx": 2204}
{"project": "Asterisk", "target": 0, "func": "static int process_xml_supportlevel_node(xmlNode *node, struct member *mem)\n{\n\tconst char *tmp = (const char *) xmlNodeGetContent(node);\n\tif (tmp && !strlen_zero(tmp)) {\n\t\txmlFree((void *) mem->support_level);\n\t\tmem->support_level = tmp;\n\t\tprint_debug(\"Set support_level for %s to %s\\n\", mem->name, mem->support_level);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2205}
{"project": "Asterisk", "target": 0, "func": "void ast_unregister_thread(void *id)\n{\n\tstruct thread_list_t *x;\n\tAST_RWLIST_WRLOCK(&thread_list);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&thread_list, x, list) {\n\t\tif ((void *) x->id == id) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&thread_list);\n\tif (x) {\n\t\tast_free(x->name);\n\t\tast_free(x);\n\t}\n}\n", "bug_type": null, "idx": 2206}
{"project": "Asterisk", "target": 0, "func": "#define PROC_DAHDI_OPT_NOWARN  (1 << 1)\nstatic void parse_busy_pattern(struct ast_variable *v, struct ast_dsp_busy_pattern *busy_cadence)\n{\n\tint count_pattern = 0;\n\tint norval = 0;\n\tchar *temp = NULL;\n\tfor (; ;) {\n\t\t\n\t\tif (!sscanf(v->value, \"%30d\", &norval) && count_pattern == 0) {\n\t\t\tast_log(LOG_ERROR, \"busypattern= expects either busypattern=tonelength,quietlength or busypattern=t1length, q1length, t2length, q2length at line %d.\\n\", v->lineno);\n\t\t\tbreak;\n\t\t}\n\t\tbusy_cadence->pattern[count_pattern] = norval;\n\t\tcount_pattern++;\n\t\tif (count_pattern == 4) {\n\t\t\tbreak;\n\t\t}\n\t\ttemp = strchr(v->value, ',');\n\t\tif (temp == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tv->value = temp + 1;\n\t}\n\tbusy_cadence->length = count_pattern;\n\tif (count_pattern % 2 != 0) {\n\t\t\n\t\tast_log(LOG_ERROR, \"busypattern= expects either busypattern=tonelength,quietlength or busypattern=t1length, q1length, t2length, q2length at line %d.\\n\", v->lineno);\n\t}\n}\n", "bug_type": null, "idx": 2207}
{"project": "Asterisk", "target": 0, "func": "static void page_state_callback(struct ast_dial *dial)\n{\n\tstruct ast_channel *chan;\n\tstruct page_options *options;\n\tif (ast_dial_state(dial) != AST_DIAL_RESULT_ANSWERED ||\n\t    !(chan = ast_dial_answered(dial)) ||\n\t    !(options = ast_dial_get_user_data(dial))) {\n\t\treturn;\n\t}\n\tsetup_profile_bridge(chan, options);\n\tsetup_profile_paged(chan, options);\n}\n", "bug_type": null, "idx": 2208}
{"project": "Asterisk", "target": 0, "func": "\nast_group_t ast_channel_callgroup(const struct ast_channel *chan)\n{\n\treturn chan->callgroup;\n}\n", "bug_type": null, "idx": 2209}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int nominal_sync_run(struct ast_test *test, const char *domain, int rr_type,\n\t\tint rr_class, struct dns_record *records, size_t num_records)\n{\n\tRAII_VAR(struct ast_dns_result *, result, NULL, ast_dns_result_free);\n\tconst struct ast_dns_record *record;\n\tint i;\n\t\n\tfor (i = 0; i < num_records; ++i) {\n\t\trecords[i].visited = 0;\n\t}\n\tast_test_status_update(test, \"Performing DNS query '%s', type %d\\n\", domain, rr_type);\n\tif (ast_dns_resolve(domain, rr_type, rr_class, &result)) {\n\t\tast_test_status_update(test, \"Failed to perform synchronous resolution of domain %s\\n\", domain);\n\t\treturn -1;\n\t}\n\tif (!result) {\n\t\tast_test_status_update(test, \"Successful synchronous resolution of domain %s gave NULL result\\n\", domain);\n\t\treturn -1;\n\t}\n\tfor (record = ast_dns_result_get_records(result); record; record = ast_dns_record_get_next(record)) {\n\t\tint match = 0;\n\t\t\n\t\tfor (i = 0; i < num_records; ++i) {\n\t\t\tif (ast_dns_record_get_rr_type(record) == records[i].rr_type &&\n\t\t\t\t\tast_dns_record_get_rr_class(record) == records[i].rr_class &&\n\t\t\t\t\tast_dns_record_get_ttl(record) == records[i].ttl &&\n\t\t\t\t\t!memcmp(ast_dns_record_get_data(record), records[i].buf, records[i].bufsize)) {\n\t\t\t\tmatch = 1;\n\t\t\t\trecords[i].visited = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!match) {\n\t\t\tast_test_status_update(test, \"Unknown DNS record returned from domain %s\\n\", domain);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2210}
{"project": "Asterisk", "target": 0, "func": "static int show_cli_help(void)\n{\n\tprintf(\"Asterisk %s, Copyright (C) 1999 - 2016, Digium, Inc. and others.\\n\", ast_get_version());\n\tprintf(\"Usage: asterisk [OPTIONS]\\n\");\n\tprintf(\"Valid Options:\\n\");\n\tprintf(\"   -V              Display version number and exit\\n\");\n\tprintf(\"   -C <configfile> Use an alternate configuration file\\n\");\n\tprintf(\"   -G <group>      Run as a group other than the caller\\n\");\n\tprintf(\"   -U <user>       Run as a user other than the caller\\n\");\n\tprintf(\"   -c              Provide console CLI\\n\");\n\tprintf(\"   -d              Increase debugging (multiple d's = more debugging)\\n\");\n#if HAVE_WORKING_FORK\n\tprintf(\"   -f              Do not fork\\n\");\n\tprintf(\"   -F              Always fork\\n\");\n#endif\n\tprintf(\"   -g              Dump core in case of a crash\\n\");\n\tprintf(\"   -h              This help screen\\n\");\n\tprintf(\"   -i              Initialize crypto keys at startup\\n\");\n\tprintf(\"   -L <load>       Limit the maximum load average before rejecting new calls\\n\");\n\tprintf(\"   -M <value>      Limit the maximum number of calls to the specified value\\n\");\n\tprintf(\"   -m              Mute debugging and console output on the console\\n\");\n\tprintf(\"   -n              Disable console colorization\\n\");\n\tprintf(\"   -p              Run as pseudo-realtime thread\\n\");\n\tprintf(\"   -q              Quiet mode (suppress output)\\n\");\n\tprintf(\"   -r              Connect to Asterisk on this machine\\n\");\n\tprintf(\"   -R              Same as -r, except attempt to reconnect if disconnected\\n\");\n\tprintf(\"   -s <socket>     Connect to Asterisk via socket <socket> (only valid with -r)\\n\");\n\tprintf(\"   -t              Record soundfiles in /var/tmp and move them where they\\n\");\n\tprintf(\"                   belong after they are done\\n\");\n\tprintf(\"   -T              Display the time in [Mmm dd hh:mm:ss] format for each line\\n\");\n\tprintf(\"                   of output to the CLI\\n\");\n\tprintf(\"   -v              Increase verbosity (multiple v's = more verbose)\\n\");\n\tprintf(\"   -x <cmd>        Execute command <cmd> (implies -r)\\n\");\n\tprintf(\"   -X              Enable use of #exec in asterisk.conf\\n\");\n\tprintf(\"   -W              Adjust terminal colors to compensate for a light background\\n\");\n\tprintf(\"\\n\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 2211}
{"project": "Asterisk", "target": 0, "func": "\nint ast_speech_get_setting(struct ast_speech *speech, const char *name, char *buf, size_t len)\n{\n\treturn (speech->engine->get_setting ? speech->engine->get_setting(speech, name, buf, len) : -1);\n}\n", "bug_type": null, "idx": 2212}
{"project": "Asterisk", "target": 0, "func": "int analog_dnd(struct analog_pvt *p, int flag)\n{\n\tif (flag == -1) {\n\t\treturn p->dnd;\n\t}\n\tp->dnd = flag;\n\tast_verb(3, \"%s DND on channel %d\\n\",\n\t\t\tflag ? \"Enabled\" : \"Disabled\",\n\t\t\tp->channel);\n\tanalog_publish_dnd_state(p->channel, flag ? \"enabled\" : \"disabled\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 2213}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int test_exten(const struct pbx_test_pattern *test_pattern, struct ast_test *test, int new_engine)\n{\n\tstruct pbx_find_info pfi = { { 0 }, };\n\tstruct ast_exten *exten;\n\tif (!(exten = pbx_find_extension(NULL, NULL, &pfi, test_pattern->context,\n\t\t\t\t\ttest_pattern->test_exten, test_pattern->priority, NULL,\n\t\t\t\t\ttest_pattern->test_cid, E_MATCH))) {\n\t\tast_test_status_update(test, \"Cannot find extension %s in context %s with the %s pattern match engine. \"\n\t\t\t\t\"Test failed.\\n\", test_pattern->test_exten, test_pattern->context, (new_engine ? \"new\" : \"old\"));\n\t\treturn -1;\n\t}\n\tif (strcmp(ast_get_extension_name(exten), test_pattern->exten->exten)) {\n\t\tast_test_status_update(test, \"Expected extension %s but got extension %s instead with the %s pattern match engine. \"\n\t\t\t\t\"Test failed.\\n\", test_pattern->exten->exten, ast_get_extension_name(exten), (new_engine ? \"new\" : \"old\"));\n\t\treturn -1;\n\t}\n\tif (test_pattern->test_cid && strcmp(ast_get_extension_cidmatch(exten), test_pattern->test_cid)) {\n\t\tast_test_status_update(test, \"Expected CID match %s but got CID match %s instead with the %s pattern match engine. \"\n\t\t\t\t\"Test failed.\\n\", test_pattern->exten->cid, ast_get_extension_cidmatch(exten), (new_engine ? \"new\" : \"old\"));\n\t\treturn -1;\n\t}\n\tif (!ast_canmatch_extension(NULL, test_pattern->context, test_pattern->test_exten,\n\t\t\t\t\ttest_pattern->priority, test_pattern->test_cid)) {\n\t\tast_test_status_update(test, \"Partial match failed for extension %s in context %s with the %s pattern match engine. \"\n\t\t\t\t\"Test failed.\\n\", test_pattern->test_exten, test_pattern->context, (new_engine ? \"new\" : \"old\"));\n\t\treturn -1;\n\t}\n\tast_test_status_update(test, \"Successfully matched %s to exten %s in context %s with the %s pattern match engine\\n\",\n\t\t\ttest_pattern->test_exten, test_pattern->exten->exten, test_pattern->context, (new_engine ? \"new\" : \"old\"));\n\treturn 0;\n}\n", "bug_type": null, "idx": 2214}
{"project": "Asterisk", "target": 0, "func": "\nstatic int acf_faxopt_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tint res = 0;\n\tstruct ast_fax_session_details *details;\n\tif (!(details = find_or_create_details(chan))) {\n\t\tast_log(LOG_WARNING, \"channel '%s' can't set FAXOPT(%s) to '%s' because it failed to create a datastore.\\n\", ast_channel_name(chan), data, value);\n\t\treturn -1;\n\t}\n\tast_debug(3, \"channel '%s' setting FAXOPT(%s) to '%s'\\n\", ast_channel_name(chan), data, value);\n\tif (!strcasecmp(data, \"ecm\")) {\n\t\tconst char *val = ast_skip_blanks(value);\n\t\tif (ast_true(val)) {\n\t\t\tdetails->option.ecm = AST_FAX_OPTFLAG_TRUE;\n\t\t} else if (ast_false(val)) {\n\t\t\tdetails->option.ecm = AST_FAX_OPTFLAG_FALSE;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unsupported value '%s' passed to FAXOPT(ecm).\\n\", value);\n\t\t}\n\t} else if (!strcasecmp(data, \"t38gateway\") || !strcasecmp(data, \"gateway\") ||\n\t\t   !strcasecmp(data, \"t38_gateway\") || !strcasecmp(data, \"faxgateway\")) {\n\t\tconst char *val = ast_skip_blanks(value);\n\t\tchar *timeout = strchr(val, ',');\n\t\tif (timeout) {\n\t\t\t*timeout++ = '\\0';\n\t\t}\n\t\tif (ast_true(val)) {\n\t\t\tif (details->gateway_id < 0) {\n\t\t\t\tdetails->gateway_timeout = 0;\n\t\t\t\tif (timeout) {\n\t\t\t\t\tunsigned int gwtimeout;\n\t\t\t\t\tif (sscanf(timeout, \"%30u\", &gwtimeout) == 1) {\n\t\t\t\t\t\tif (gwtimeout >= 0) {\n\t\t\t\t\t\t\tdetails->gateway_timeout = gwtimeout * 1000;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"%s(%s) timeout cannot be negative.  Ignoring timeout\\n\",\n\t\t\t\t\t\t\t\tcmd, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Unsupported timeout '%s' passed to FAXOPT(%s).\\n\", timeout, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdetails->gateway_id = fax_gateway_attach(chan, details);\n\t\t\t\tif (details->gateway_id < 0) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Error attaching T.38 gateway to channel %s.\\n\", ast_channel_name(chan));\n\t\t\t\t\tres = -1;\n\t\t\t\t} else {\n\t\t\t\t\tast_debug(1, \"Attached T.38 gateway to channel %s.\\n\", ast_channel_name(chan));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Attempt to attach a T.38 gateway on channel (%s) with gateway already running.\\n\", ast_channel_name(chan));\n\t\t\t}\n\t\t} else if (ast_false(val)) {\n\t\t\tast_channel_lock(chan);\n\t\t\tast_framehook_detach(chan, details->gateway_id);\n\t\t\tast_channel_unlock(chan);\n\t\t\tdetails->gateway_id = -1;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unsupported value '%s' passed to FAXOPT(%s).\\n\", value, data);\n\t\t}\n\t} else if (!strcasecmp(data, \"faxdetect\")) {\n\t\tconst char *val = ast_skip_blanks(value);\n\t\tchar *timeout = strchr(val, ',');\n\t\tunsigned int fdtimeout = 0;\n\t\tint flags;\n\t\tint faxdetect;\n\t\tif (timeout) {\n\t\t\t*timeout++ = '\\0';\n\t\t}\n\t\tif (ast_true(val) || !strcasecmp(val, \"t38\") || !strcasecmp(val, \"cng\")) {\n\t\t\tif (details->faxdetect_id < 0) {\n\t\t\t\tif (timeout) {\n\t\t\t\t\tif (sscanf(timeout, \"%30u\", &fdtimeout) == 1) {\n\t\t\t\t\t\tif (fdtimeout >= 0) {\n\t\t\t\t\t\t\tfdtimeout *= 1000;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tast_log(LOG_WARNING, \"%s(%s) timeout cannot be negative.  Ignoring timeout\\n\",\n\t\t\t\t\t\t\t\tcmd, data);\n\t\t\t\t\t\t\tfdtimeout = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Unsupported timeout '%s' passed to FAXOPT(%s).\\n\",\n\t\t\t\t\t\t\ttimeout, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!strcasecmp(val, \"t38\")) {\n\t\t\t\t\tflags = FAX_DETECT_MODE_T38;\n\t\t\t\t} else if (!strcasecmp(val, \"cng\")) {\n\t\t\t\t\tflags = FAX_DETECT_MODE_CNG;\n\t\t\t\t} else {\n\t\t\t\t\tflags = FAX_DETECT_MODE_BOTH;\n\t\t\t\t}\n\t\t\t\tfaxdetect = fax_detect_attach(chan, fdtimeout, flags);\n\t\t\t\tif (faxdetect < 0) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Error attaching FAX detect to channel %s.\\n\", ast_channel_name(chan));\n\t\t\t\t\tres = -1;\n\t\t\t\t} else {\n\t\t\t\t\tast_debug(1, \"Attached FAX detect to channel %s.\\n\", ast_channel_name(chan));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Attempt to attach a FAX detect on channel (%s) with FAX detect already running.\\n\", ast_channel_name(chan));\n\t\t\t}\n\t\t} else if (ast_false(val)) {\n\t\t\tast_channel_lock(chan);\n\t\t\tast_framehook_detach(chan, details->faxdetect_id);\n\t\t\tast_channel_unlock(chan);\n\t\t\tdetails->faxdetect_id = -1;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unsupported value '%s' passed to FAXOPT(%s).\\n\", value, data);\n\t\t}\n\t} else if (!strcasecmp(data, \"headerinfo\")) {\n\t\tast_string_field_set(details, headerinfo, value);\n\t} else if (!strcasecmp(data, \"localstationid\")) {\n\t\tast_string_field_set(details, localstationid, value);\n\t} else if (!strcasecmp(data, \"maxrate\")) {\n\t\tdetails->maxrate = fax_rate_str_to_int(value);\n\t\tif (!details->maxrate) {\n\t\t\tdetails->maxrate = ast_fax_maxrate();\n\t\t}\n\t} else if (!strcasecmp(data, \"minrate\")) {\n\t\tdetails->minrate = fax_rate_str_to_int(value);\n\t\tif (!details->minrate) {\n\t\t\tdetails->minrate = ast_fax_minrate();\n\t\t}\n\t} else if (!strcasecmp(data, \"t38timeout\")) {\n\t\tif (set_t38timeout(value, &details->t38timeout)) {\n\t\t\tres = -1;\n\t\t}\n\t} else if ((!strcasecmp(data, \"modem\")) || (!strcasecmp(data, \"modems\"))) {\n\t\tupdate_modem_bits(&details->modems, value);\n\t} else {\n\t\tast_log(LOG_WARNING, \"channel '%s' set FAXOPT(%s) to '%s' is unhandled!\\n\", ast_channel_name(chan), data, value);\n\t\tres = -1;\n\t}\n\tao2_ref(details, -1);\n\treturn res;\n}\n", "bug_type": null, "idx": 2215}
{"project": "Asterisk", "target": 0, "func": "\nstatic int chan_pjsip_sendtext(struct ast_channel *ast, const char *text)\n{\n\tstruct ast_sip_channel_pvt *channel = ast_channel_tech_pvt(ast);\n\tstruct sendtext_data *data = sendtext_data_create(channel->session, text);\n\tif (!data) {\n\t\treturn -1;\n\t}\n#ifdef HAVE_PJSIP_INV_SESSION_REF\n\tif (pjsip_inv_add_ref(data->session->inv_session) != PJ_SUCCESS) {\n\t\tast_log(LOG_ERROR, \"Can't increase the session reference counter\\n\");\n\t\tao2_ref(data, -1);\n\t\treturn -1;\n\t}\n#endif\n\tif (ast_sip_push_task(channel->session->serializer, sendtext, data)) {\n#ifdef HAVE_PJSIP_INV_SESSION_REF\n\t\tpjsip_inv_dec_ref(data->session->inv_session);\n#endif\n\t\tao2_ref(data, -1);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2216}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225Facility_UUIE (OOCTXT* pctxt, H225Facility_UUIE* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.alternativeAddressPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.alternativeAliasAddressPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.conferenceIDPresent = optbit;\n   \n   invokeStartElement (pctxt, \"protocolIdentifier\", -1);\n   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"protocolIdentifier\", -1);\n   \n   if (pvalue->m.alternativeAddressPresent) {\n      invokeStartElement (pctxt, \"alternativeAddress\", -1);\n      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->alternativeAddress);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"alternativeAddress\", -1);\n   }\n   \n   if (pvalue->m.alternativeAliasAddressPresent) {\n      invokeStartElement (pctxt, \"alternativeAliasAddress\", -1);\n      stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->alternativeAliasAddress);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"alternativeAliasAddress\", -1);\n   }\n   \n   if (pvalue->m.conferenceIDPresent) {\n      invokeStartElement (pctxt, \"conferenceID\", -1);\n      stat = asn1PD_H225ConferenceIdentifier (pctxt, &pvalue->conferenceID);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"conferenceID\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"reason\", -1);\n   stat = asn1PD_H225FacilityReason (pctxt, &pvalue->reason);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"reason\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 16 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.callIdentifierPresent = 1;\n                     invokeStartElement (pctxt, \"callIdentifier\", -1);\n                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"callIdentifier\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.destExtraCallInfoPresent = 1;\n                     invokeStartElement (pctxt, \"destExtraCallInfo\", -1);\n                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destExtraCallInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"destExtraCallInfo\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.remoteExtensionAddressPresent = 1;\n                     invokeStartElement (pctxt, \"remoteExtensionAddress\", -1);\n                     stat = asn1PD_H225AliasAddress (pctxt, &pvalue->remoteExtensionAddress);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"remoteExtensionAddress\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.tokensPresent = 1;\n                     invokeStartElement (pctxt, \"tokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"tokens\", -1);\n                     break;\n                  case 4:\n                     pvalue->m.cryptoTokensPresent = 1;\n                     invokeStartElement (pctxt, \"cryptoTokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"cryptoTokens\", -1);\n                     break;\n                  case 5:\n                     pvalue->m.conferencesPresent = 1;\n                     invokeStartElement (pctxt, \"conferences\", -1);\n                     stat = asn1PD_H225_SeqOfH225ConferenceList (pctxt, &pvalue->conferences);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"conferences\", -1);\n                     break;\n                  case 6:\n                     pvalue->m.h245AddressPresent = 1;\n                     invokeStartElement (pctxt, \"h245Address\", -1);\n                     stat = asn1PD_H225TransportAddress (pctxt, &pvalue->h245Address);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"h245Address\", -1);\n                     break;\n                  case 7:\n                     pvalue->m.fastStartPresent = 1;\n                     invokeStartElement (pctxt, \"fastStart\", -1);\n                     stat = asn1PD_H225Facility_UUIE_fastStart (pctxt, &pvalue->fastStart);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"fastStart\", -1);\n                     break;\n                  case 8:\n                     pvalue->m.multipleCallsPresent = 1;\n                     invokeStartElement (pctxt, \"multipleCalls\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->multipleCalls);\n                     invokeEndElement (pctxt, \"multipleCalls\", -1);\n                     break;\n                  case 9:\n                     pvalue->m.maintainConnectionPresent = 1;\n                     invokeStartElement (pctxt, \"maintainConnection\", -1);\n                     stat = DECODEBIT (pctxt, &pvalue->maintainConnection);\n                     if (stat != ASN_OK) return stat;\n                     invokeBoolValue (pctxt, pvalue->maintainConnection);\n                     invokeEndElement (pctxt, \"maintainConnection\", -1);\n                     break;\n                  case 10:\n                     pvalue->m.fastConnectRefusedPresent = 1;\n                     invokeStartElement (pctxt, \"fastConnectRefused\", -1);\n                     \n                     invokeNullValue (pctxt);\n                     invokeEndElement (pctxt, \"fastConnectRefused\", -1);\n                     break;\n                  case 11:\n                     pvalue->m.serviceControlPresent = 1;\n                     invokeStartElement (pctxt, \"serviceControl\", -1);\n                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"serviceControl\", -1);\n                     break;\n                  case 12:\n                     pvalue->m.circuitInfoPresent = 1;\n                     invokeStartElement (pctxt, \"circuitInfo\", -1);\n                     stat = asn1PD_H225CircuitInfo (pctxt, &pvalue->circuitInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"circuitInfo\", -1);\n                     break;\n                  case 13:\n                     pvalue->m.featureSetPresent = 1;\n                     invokeStartElement (pctxt, \"featureSet\", -1);\n                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"featureSet\", -1);\n                     break;\n                  case 14:\n                     pvalue->m.destinationInfoPresent = 1;\n                     invokeStartElement (pctxt, \"destinationInfo\", -1);\n                     stat = asn1PD_H225EndpointType (pctxt, &pvalue->destinationInfo);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"destinationInfo\", -1);\n                     break;\n                  case 15:\n                     pvalue->m.h245SecurityModePresent = 1;\n                     invokeStartElement (pctxt, \"h245SecurityMode\", -1);\n                     stat = asn1PD_H225H245Security (pctxt, &pvalue->h245SecurityMode);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"h245SecurityMode\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2217}
{"project": "Asterisk", "target": 0, "func": "static int cops_connect(char *host, char *port)\n{\n\tint s, sfd = -1, flags;\n\tstruct addrinfo hints;\n\tstruct addrinfo *rp;\n\tstruct addrinfo *result;\n#ifdef HAVE_SO_NOSIGPIPE\n\tint trueval = 1;\n#endif\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = AF_UNSPEC;    \n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = 0;\n\thints.ai_protocol = 0;\n\ts = getaddrinfo(host, port, &hints, &result);\n\tif (s != 0) {\n\t\tast_log(LOG_WARNING, \"COPS: getaddrinfo: %s\\n\", gai_strerror(s));\n\t\treturn -1;\n\t}\n\tfor (rp = result; rp != NULL; rp = rp->ai_next) {\n\t\tsfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n\t\tif (sfd == -1) {\n\t\t\tast_log(LOG_WARNING, \"Failed socket\\n\");\n\t\t}\n\t\tflags = fcntl(sfd, F_GETFL);\n\t\tfcntl(sfd, F_SETFL, flags | O_NONBLOCK);\n#ifdef HAVE_SO_NOSIGPIPE\n\t\tsetsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, &trueval, sizeof(trueval));\n#endif\n\t\tconnect(sfd, rp->ai_addr, rp->ai_addrlen);\n\t\tif (sfd == -1) {\n\t\t\tast_log(LOG_WARNING, \"Failed connect\\n\");\n\t\t}\n\t}\n\tfreeaddrinfo(result);\n\tast_debug(3, \"Connecting to cmts:  %s:%s\\n\", host, port);\n\treturn(sfd);\n}\n", "bug_type": null, "idx": 2218}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *cli_get_container(const char *regex)\n{\n\tRAII_VAR(struct ao2_container *, container, NULL, ao2_cleanup);\n\tstruct ao2_container *s_container;\n\tcontainer =  ast_sorcery_retrieve_by_regex(ast_sip_get_sorcery(), \"identify\", regex);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\ts_container = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_NOLOCK, 0,\n\t\tast_sorcery_object_id_sort, ast_sorcery_object_id_compare);\n\tif (!s_container) {\n\t\treturn NULL;\n\t}\n\tif (ao2_container_dup(s_container, container, 0)) {\n\t\tao2_ref(s_container, -1);\n\t\treturn NULL;\n\t}\n\treturn s_container;\n}\n", "bug_type": null, "idx": 2219}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tne_sock_init();\n\tif (ast_calendar_register(&exchangecal_tech)) {\n\t\tne_sock_exit();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 2220}
{"project": "Asterisk", "target": 0, "func": "\nstatic char *bearer2str(int cap) {\n\tstatic char *bearers[]={\n\t\t\"Speech\",\n\t\t\"Audio 3.1k\",\n\t\t\"Unres Digital\",\n\t\t\"Res Digital\",\n\t\t\"Unknown Bearer\"\n\t};\n\tswitch (cap) {\n\tcase INFO_CAPABILITY_SPEECH:\n\t\treturn bearers[0];\n\t\tbreak;\n\tcase INFO_CAPABILITY_AUDIO_3_1K:\n\t\treturn bearers[1];\n\t\tbreak;\n\tcase INFO_CAPABILITY_DIGITAL_UNRESTRICTED:\n\t\treturn bearers[2];\n\t\tbreak;\n\tcase INFO_CAPABILITY_DIGITAL_RESTRICTED:\n\t\treturn bearers[3];\n\t\tbreak;\n\tdefault:\n\t\treturn bearers[4];\n\t\tbreak;\n\t}\n}\n\nstatic char *bearer2str(int cap) {\n\tstatic char *bearers[]={\n\t\t\"Speech\",\n\t\t\"Audio 3.1k\",\n\t\t\"Unres Digital\",\n\t\t\"Res Digital\",\n\t\t\"Unknown Bearer\"\n\t};\n\tswitch (cap) {\n\tcase INFO_CAPABILITY_SPEECH:\n\t\treturn bearers[0];\n\t\tbreak;\n\tcase INFO_CAPABILITY_AUDIO_3_1K:\n\t\treturn bearers[1];\n\t\tbreak;\n\tcase INFO_CAPABILITY_DIGITAL_UNRESTRICTED:\n\t\treturn bearers[2];\n\t\tbreak;\n\tcase INFO_CAPABILITY_DIGITAL_RESTRICTED:\n\t\treturn bearers[3];\n\t\tbreak;\n\tdefault:\n\t\treturn bearers[4];\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 2221}
{"project": "Asterisk", "target": 0, "func": "static enum ast_pbx_result __ast_pbx_run(struct ast_channel *c,\n\t\tstruct ast_pbx_args *args)\n{\n\tint found = 0;\t\n\tint res = 0;\n\tint autoloopflag;\n\tint error = 0;\t\t\n\tstruct ast_pbx *pbx;\n\tast_callid callid;\n\t\n\tif (ast_channel_pbx(c)) {\n\t\tast_log(LOG_WARNING, \"%s already has PBX structure??\\n\", ast_channel_name(c));\n\t\t\n\t\tast_free(ast_channel_pbx(c));\n\t}\n\tif (!(pbx = ast_calloc(1, sizeof(*pbx)))) {\n\t\treturn AST_PBX_FAILED;\n\t}\n\tcallid = ast_read_threadstorage_callid();\n\t\n\tif (!callid) {\n\t\t\n\t\tcallid = ast_channel_callid(c);\n\t\tif (!callid) {\n\t\t\tcallid = ast_create_callid();\n\t\t\tif (callid) {\n\t\t\t\tast_channel_lock(c);\n\t\t\t\tast_channel_callid_set(c, callid);\n\t\t\t\tast_channel_unlock(c);\n\t\t\t}\n\t\t}\n\t\tast_callid_threadassoc_add(callid);\n\t\tcallid = 0;\n\t}\n\tast_channel_pbx_set(c, pbx);\n\t\n\tast_channel_pbx(c)->rtimeoutms = 10000;\n\tast_channel_pbx(c)->dtimeoutms = 5000;\n\tast_channel_lock(c);\n\tautoloopflag = ast_test_flag(ast_channel_flags(c), AST_FLAG_IN_AUTOLOOP);\t\n\tast_set_flag(ast_channel_flags(c), AST_FLAG_IN_AUTOLOOP);\n\tast_channel_unlock(c);\n\tif (ast_strlen_zero(ast_channel_exten(c))) {\n\t\t\n\t\tast_verb(2, \"Starting %s at %s,%s,%d failed so falling back to exten 's'\\n\", ast_channel_name(c), ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c));\n\t\t\n\t\tset_ext_pri(c, \"s\", 1);\n\t}\n\tfor (;;) {\n\t\tchar dst_exten[256];\t\n\t\tint pos = 0;\t\t\n\t\tint digit = 0;\n\t\tint invalid = 0;\n\t\tint timeout = 0;\n\t\t\n\t\tdst_exten[pos] = '\\0';\n\t\t\n\t\twhile (!(res = ast_spawn_extension(c, ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c),\n\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL),\n\t\t\t&found, 1))) {\n\t\t\tif (!ast_check_hangup(c)) {\n\t\t\t\tast_channel_priority_set(c, ast_channel_priority(c) + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (ast_channel_softhangup_internal_flag(c) & AST_SOFTHANGUP_ASYNCGOTO) {\n\t\t\t\tast_channel_clear_softhangup(c, AST_SOFTHANGUP_ASYNCGOTO);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ast_channel_softhangup_internal_flag(c) & AST_SOFTHANGUP_TIMEOUT) {\n\t\t\t\tif (ast_exists_extension(c, ast_channel_context(c), \"T\", 1,\n\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\tset_ext_pri(c, \"T\", 1);\n\t\t\t\t\t\n\t\t\t\t\tmemset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));\n\t\t\t\t\tast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ast_exists_extension(c, ast_channel_context(c), \"e\", 1,\n\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\traise_exception(c, \"ABSOLUTETIMEOUT\", 1);\n\t\t\t\t\t\n\t\t\t\t\tmemset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));\n\t\t\t\t\tast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\terror = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_debug(1, \"Extension %s, priority %d returned normally even though call was hung up\\n\",\n\t\t\t\tast_channel_exten(c), ast_channel_priority(c));\n\t\t\terror = 1;\n\t\t\tbreak;\n\t\t} \n\t\tif (found && res) {\n\t\t\t\n\t\t\tif (strchr(\"0123456789ABCDEF*#\", res)) {\n\t\t\t\tast_debug(1, \"Oooh, got something to jump out with ('%c')!\\n\", res);\n\t\t\t\tpos = 0;\n\t\t\t\tdst_exten[pos++] = digit = res;\n\t\t\t\tdst_exten[pos] = '\\0';\n\t\t\t} else if (res == AST_PBX_INCOMPLETE) {\n\t\t\t\tast_debug(1, \"Spawn extension (%s,%s,%d) exited INCOMPLETE on '%s'\\n\", ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));\n\t\t\t\tast_verb(2, \"Spawn extension (%s, %s, %d) exited INCOMPLETE on '%s'\\n\", ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));\n\t\t\t\t\n\t\t\t\tif (!ast_matchmore_extension(c, ast_channel_context(c), ast_channel_exten(c), 1,\n\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\tinvalid = 1;\n\t\t\t\t} else {\n\t\t\t\t\tast_copy_string(dst_exten, ast_channel_exten(c), sizeof(dst_exten));\n\t\t\t\t\tdigit = 1;\n\t\t\t\t\tpos = strlen(dst_exten);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_debug(1, \"Spawn extension (%s,%s,%d) exited non-zero on '%s'\\n\", ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));\n\t\t\t\tast_verb(2, \"Spawn extension (%s, %s, %d) exited non-zero on '%s'\\n\", ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));\n\t\t\t\tif ((res == AST_PBX_ERROR)\n\t\t\t\t\t&& ast_exists_extension(c, ast_channel_context(c), \"e\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\t\n\t\t\t\t\tif (!strcmp(ast_channel_exten(c), \"e\")) {\n\t\t\t\t\t\tast_verb(2, \"Spawn extension (%s, %s, %d) exited ERROR while already on 'e' exten on '%s'\\n\", ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\traise_exception(c, \"ERROR\", 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ast_channel_softhangup_internal_flag(c) & AST_SOFTHANGUP_ASYNCGOTO) {\n\t\t\t\t\tast_channel_clear_softhangup(c, AST_SOFTHANGUP_ASYNCGOTO);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ast_channel_softhangup_internal_flag(c) & AST_SOFTHANGUP_TIMEOUT) {\n\t\t\t\t\tif (ast_exists_extension(c, ast_channel_context(c), \"T\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\t\tset_ext_pri(c, \"T\", 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));\n\t\t\t\t\t\tast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (ast_exists_extension(c, ast_channel_context(c), \"e\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\t\traise_exception(c, \"ABSOLUTETIMEOUT\", 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));\n\t\t\t\t\t\tast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\terror = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (error)\n\t\t\tbreak;\n\t\t\n\t\tif (invalid\n\t\t\t|| (ast_strlen_zero(dst_exten) &&\n\t\t\t\t!ast_exists_extension(c, ast_channel_context(c), ast_channel_exten(c), 1,\n\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL)))) {\n\t\t\t\n\t\t\tif (ast_exists_extension(c, ast_channel_context(c), \"i\", 1,\n\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\tast_verb(3, \"Channel '%s' sent to invalid extension: context,exten,priority=%s,%s,%d\\n\",\n\t\t\t\t\tast_channel_name(c), ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c));\n\t\t\t\tpbx_builtin_setvar_helper(c, \"INVALID_EXTEN\", ast_channel_exten(c));\n\t\t\t\tset_ext_pri(c, \"i\", 1);\n\t\t\t} else if (ast_exists_extension(c, ast_channel_context(c), \"e\", 1,\n\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\traise_exception(c, \"INVALID\", 1);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Channel '%s' sent to invalid extension but no invalid handler: context,exten,priority=%s,%s,%d\\n\",\n\t\t\t\t\tast_channel_name(c), ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c));\n\t\t\t\terror = 1; \n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ast_channel_softhangup_internal_flag(c) & AST_SOFTHANGUP_TIMEOUT) {\n\t\t\t\n\t\t\tast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);\n\t\t} else {\t\n\t\t\tint waittime = 0;\n\t\t\tif (digit)\n\t\t\t\twaittime = ast_channel_pbx(c)->dtimeoutms;\n\t\t\telse if (!autofallthrough)\n\t\t\t\twaittime = ast_channel_pbx(c)->rtimeoutms;\n\t\t\tif (!waittime) {\n\t\t\t\tconst char *status = pbx_builtin_getvar_helper(c, \"DIALSTATUS\");\n\t\t\t\tif (!status)\n\t\t\t\t\tstatus = \"UNKNOWN\";\n\t\t\t\tast_verb(3, \"Auto fallthrough, channel '%s' status is '%s'\\n\", ast_channel_name(c), status);\n\t\t\t\tif (!strcasecmp(status, \"CONGESTION\"))\n\t\t\t\t\tres = indicate_congestion(c, \"10\");\n\t\t\t\telse if (!strcasecmp(status, \"CHANUNAVAIL\"))\n\t\t\t\t\tres = indicate_congestion(c, \"10\");\n\t\t\t\telse if (!strcasecmp(status, \"BUSY\"))\n\t\t\t\t\tres = indicate_busy(c, \"10\");\n\t\t\t\terror = 1; \n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tif (collect_digits(c, waittime, dst_exten, sizeof(dst_exten), pos))\n\t\t\t\tbreak;\n\t\t\tif (res == AST_PBX_INCOMPLETE && ast_strlen_zero(&dst_exten[pos]))\n\t\t\t\ttimeout = 1;\n\t\t\tif (!timeout\n\t\t\t\t&& ast_exists_extension(c, ast_channel_context(c), dst_exten, 1,\n\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) { \n\t\t\t\tset_ext_pri(c, dst_exten, 1);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (!timeout && !ast_strlen_zero(dst_exten)) {\n\t\t\t\t\t\n\t\t\t\t\tif (ast_exists_extension(c, ast_channel_context(c), \"i\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\t\tast_verb(3, \"Invalid extension '%s' in context '%s' on %s\\n\", dst_exten, ast_channel_context(c), ast_channel_name(c));\n\t\t\t\t\t\tpbx_builtin_setvar_helper(c, \"INVALID_EXTEN\", dst_exten);\n\t\t\t\t\t\tset_ext_pri(c, \"i\", 1);\n\t\t\t\t\t} else if (ast_exists_extension(c, ast_channel_context(c), \"e\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\t\traise_exception(c, \"INVALID\", 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"Invalid extension '%s', but no rule 'i' or 'e' in context '%s'\\n\",\n\t\t\t\t\t\t\tdst_exten, ast_channel_context(c));\n\t\t\t\t\t\tfound = 1; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tif (ast_exists_extension(c, ast_channel_context(c), \"t\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\t\tast_verb(3, \"Timeout on %s\\n\", ast_channel_name(c));\n\t\t\t\t\t\tset_ext_pri(c, \"t\", 1);\n\t\t\t\t\t} else if (ast_exists_extension(c, ast_channel_context(c), \"e\", 1,\n\t\t\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\t\t\traise_exception(c, \"RESPONSETIMEOUT\", 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\t\t\"Timeout, but no rule 't' or 'e' in context '%s'\\n\",\n\t\t\t\t\t\t\tast_channel_context(c));\n\t\t\t\t\t\tfound = 1; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!found && !error) {\n\t\tast_log(LOG_WARNING, \"Don't know what to do with '%s'\\n\", ast_channel_name(c));\n\t}\n\tif (!args || !args->no_hangup_chan) {\n\t\tast_softhangup(c, AST_SOFTHANGUP_APPUNLOAD);\n\t\tif (!ast_test_flag(ast_channel_flags(c), AST_FLAG_BRIDGE_HANGUP_RUN)\n\t\t\t&& ast_exists_extension(c, ast_channel_context(c), \"h\", 1,\n\t\t\t\tS_COR(ast_channel_caller(c)->id.number.valid,\n\t\t\t\t\tast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\tast_pbx_h_exten_run(c, ast_channel_context(c));\n\t\t}\n\t\tast_pbx_hangup_handler_run(c);\n\t}\n\tast_channel_lock(c);\n\tast_set2_flag(ast_channel_flags(c), autoloopflag, AST_FLAG_IN_AUTOLOOP);\n\tast_clear_flag(ast_channel_flags(c), AST_FLAG_BRIDGE_HANGUP_RUN); \n\tast_channel_unlock(c);\n\tpbx_destroy(ast_channel_pbx(c));\n\tast_channel_pbx_set(c, NULL);\n\tif (!args || !args->no_hangup_chan) {\n\t\tast_hangup(c);\n\t}\n\treturn AST_PBX_SUCCESS;\n}\n", "bug_type": null, "idx": 2222}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_discard_after_goto(struct ast_channel *chan)\n{\n\tstruct ast_datastore *datastore;\n\tdatastore = after_bridge_goto_remove(chan);\n\tif (datastore) {\n\t\tast_datastore_free(datastore);\n\t}\n}\n", "bug_type": null, "idx": 2223}
{"project": "Asterisk", "target": 0, "func": "static int load_tech_calendars(struct ast_calendar_tech *tech)\n{\n\tstruct ast_calendar *cal;\n\tconst char *cat = NULL;\n\tconst char *val;\n\tif (!calendar_config) {\n\t\tast_log(LOG_WARNING, \"Calendar support disabled, not loading %s calendar module\\n\", tech->type);\n\t\treturn -1;\n\t}\n\tast_rwlock_wrlock(&config_lock);\n\twhile ((cat = ast_category_browse(calendar_config, cat))) {\n\t\tif (!strcasecmp(cat, \"general\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(val = ast_variable_retrieve(calendar_config, cat, \"type\")) || strcasecmp(val, tech->type)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!(cal = build_calendar(calendar_config, cat, tech))) {\n\t\t\tast_calendar_unregister(tech);\n\t\t\tast_rwlock_unlock(&config_lock);\n\t\t\treturn -1;\n\t\t}\n\t\tcal = unref_calendar(cal);\n\t}\n\tast_rwlock_unlock(&config_lock);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2224}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic struct call_queue *find_queue_by_name_rt(const char *queuename, struct ast_variable *queue_vars, struct ast_config *member_config)\n{\n\tstruct ast_variable *v;\n\tstruct call_queue *q, tmpq = {\n\t\t.name = queuename,\n\t};\n\tstruct member *m;\n\tstruct ao2_iterator mem_iter;\n\tchar *category = NULL;\n\tconst char *tmp_name;\n\tchar *tmp;\n\tchar tmpbuf[64];\t\n\t\n\tif ((q = ao2_t_find(queues, &tmpq, OBJ_POINTER, \"Check if static queue exists\"))) {\n\t\tao2_lock(q);\n\t\tif (!q->realtime) {\n\t\t\tif (q->dead) {\n\t\t\t\tao2_unlock(q);\n\t\t\t\tqueue_t_unref(q, \"Queue is dead; can't return it\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tast_log(LOG_WARNING, \"Static queue '%s' already exists. Not loading from realtime\\n\", q->name);\n\t\t\tao2_unlock(q);\n\t\t\treturn q;\n\t\t}\n\t} else if (!member_config) {\n\t\t\n\t\treturn NULL;\n\t}\n\t\n\tif (!queue_vars) {\n\t\t\n\t\tif (q) {\n\t\t\t\n\t\t\tast_debug(1, \"Queue %s not found in realtime.\\n\", queuename);\n\t\t\tq->dead = 1;\n\t\t\t\n\t\t\tqueues_t_unlink(queues, q, \"Unused; removing from container\");\n\t\t\tao2_unlock(q);\n\t\t\tqueue_t_unref(q, \"Queue is dead; can't return it\");\n\t\t}\n\t\treturn NULL;\n\t}\n\t\n\tif (!q) {\n\t\tstruct ast_variable *tmpvar = NULL;\n\t\tif (!(q = alloc_queue(queuename))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tao2_lock(q);\n\t\tclear_queue(q);\n\t\tq->realtime = 1;\n\t\t\n\t\tfor (tmpvar = queue_vars; tmpvar; tmpvar = tmpvar->next) {\n\t\t\tif (!strcasecmp(tmpvar->name, \"strategy\")) {\n\t\t\t\tq->strategy = strat2int(tmpvar->value);\n\t\t\t\tif (q->strategy < 0) {\n\t\t\t\t\tast_log(LOG_WARNING, \"'%s' isn't a valid strategy for queue '%s', using ringall instead\\n\",\n\t\t\t\t\ttmpvar->value, q->name);\n\t\t\t\t\tq->strategy = QUEUE_STRATEGY_RINGALL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!tmpvar) {\n\t\t\tq->strategy = QUEUE_STRATEGY_RINGALL;\n\t\t}\n\t\tqueues_t_link(queues, q, \"Add queue to container\");\n\t}\n\tinit_queue(q);\t\t\n\tmemset(tmpbuf, 0, sizeof(tmpbuf));\n\tfor (v = queue_vars; v; v = v->next) {\n\t\t\n\t\tif (strchr(v->name, '_')) {\n\t\t\tast_copy_string(tmpbuf, v->name, sizeof(tmpbuf));\n\t\t\ttmp_name = tmpbuf;\n\t\t\ttmp = tmpbuf;\n\t\t\twhile ((tmp = strchr(tmp, '_'))) {\n\t\t\t\t*tmp++ = '-';\n\t\t\t}\n\t\t} else {\n\t\t\ttmp_name = v->name;\n\t\t}\n\t\t\n\t\tqueue_set_param(q, tmp_name, v->value, -1, 0);\n\t}\n\t\n\tmem_iter = ao2_iterator_init(q->members, 0);\n\twhile ((m = ao2_iterator_next(&mem_iter))) {\n\t\tif (m->realtime) {\n\t\t\tm->dead = 1;\n\t\t}\n\t\tao2_ref(m, -1);\n\t}\n\tao2_iterator_destroy(&mem_iter);\n\twhile ((category = ast_category_browse(member_config, category))) {\n\t\trt_handle_member_record(q, category, member_config);\n\t}\n\t\n\tmem_iter = ao2_iterator_init(q->members, 0);\n\twhile ((m = ao2_iterator_next(&mem_iter))) {\n\t\tif (m->dead) {\n\t\t\tif (ast_strlen_zero(m->membername) || !log_membername_as_agent) {\n\t\t\t\tast_queue_log(q->name, \"REALTIME\", m->interface, \"REMOVEMEMBER\", \"%s\", \"\");\n\t\t\t} else {\n\t\t\t\tast_queue_log(q->name, \"REALTIME\", m->membername, \"REMOVEMEMBER\", \"%s\", \"\");\n\t\t\t}\n\t\t\tmember_remove_from_queue(q, m);\n\t\t}\n\t\tao2_ref(m, -1);\n\t}\n\tao2_iterator_destroy(&mem_iter);\n\tao2_unlock(q);\n\treturn q;\n}\n", "bug_type": null, "idx": 2225}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int srv_result_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tstruct srv_result_datastore *srds;\n\tstruct ast_datastore *datastore;\n\tstruct srv_context *srv_context;\n\tchar *parse;\n\tconst char *host;\n\tunsigned short port, priority, weight;\n\tunsigned int num;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(id);\n\t\tAST_APP_ARG(resultnum);\n\t\tAST_APP_ARG(field);\n\t);\n\tif (!chan) {\n\t\tast_log(LOG_WARNING, \"%s cannot be used without a channel\\n\", cmd);\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"%s requires two arguments (id and resultnum)\\n\", cmd);\n\t\treturn -1;\n\t}\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tast_channel_lock(chan);\n\tdatastore = ast_channel_datastore_find(chan, &srv_result_datastore_info, args.id);\n\tast_channel_unlock(chan);\n\tif (!datastore) {\n\t\t\n\t\tsrv_context = srv_datastore_setup(args.id, chan);\n\t\tif (!srv_context) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tsrds = datastore->data;\n\t\tsrv_context = srds->context;\n\t}\n\tif (!strcasecmp(args.resultnum, \"getnum\")) {\n\t\tsnprintf(buf, len, \"%u\", ast_srv_get_record_count(srv_context));\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(args.field)) {\n\t\tast_log(LOG_ERROR, \"A field must be provided when requesting SRV data\\n\");\n\t\treturn -1;\n\t}\n\tif (sscanf(args.resultnum, \"%30u\", &num) != 1) {\n\t\tast_log(LOG_ERROR, \"Invalid value '%s' for resultnum to %s\\n\", args.resultnum, cmd);\n\t\treturn -1;\n\t}\n\tif (ast_srv_get_nth_record(srv_context, num, &host, &port, &priority, &weight)) {\n\t\tast_log(LOG_ERROR, \"Failed to get record number %u for %s\\n\", num, cmd);\n\t\treturn -1;\n\t}\n\tif (!strcasecmp(args.field, \"host\")) {\n\t\tast_copy_string(buf, host, len);\n\t} else if (!strcasecmp(args.field, \"port\")) {\n\t\tsnprintf(buf, len, \"%d\", port);\n\t} else if (!strcasecmp(args.field, \"priority\")) {\n\t\tsnprintf(buf, len, \"%d\", priority);\n\t} else if (!strcasecmp(args.field, \"weight\")) {\n\t\tsnprintf(buf, len, \"%d\", weight);\n\t} else {\n\t\tast_log(LOG_WARNING, \"Unrecognized SRV field '%s'\\n\", args.field);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2226}
{"project": "Asterisk", "target": 0, "func": "struct ast_srtp *ast_rtp_instance_get_srtp(struct ast_rtp_instance *instance, int rtcp)\n{\n\tif (rtcp && instance->rtcp_srtp) {\n\t\treturn instance->rtcp_srtp;\n\t} else {\n\t\treturn instance->srtp;\n\t}\n}\n", "bug_type": null, "idx": 2227}
{"project": "Asterisk", "target": 0, "func": "static int parse_cdata(void *data, char *value, size_t len)\n{\n\tchar *str;\n\tstruct xmlstate *state = data;\n\tstruct ast_calendar_event *event = state->ptr;\n\tstr = ast_skip_blanks(value);\n\tif (str == value + len)\n\t\treturn IKS_OK;\n\tif (!(str = ast_calloc(1, len + 1))) {\n\t\treturn IKS_NOMEM;\n\t}\n\tmemcpy(str, value, len);\n\tif (!(state->in_response && state->in_propstat && state->in_prop)) {\n\t\tast_free(str);\n\t\treturn IKS_OK;\n\t}\n\t\n\tif (!strcasecmp(state->tag, \"subject\")) {\n\t\tast_string_field_build(event, summary, \"%s%s\", event->summary, str);\n\t} else if (!strcasecmp(state->tag, \"location\")) {\n\t\tast_string_field_build(event, location, \"%s%s\", event->location, str);\n\t} else if (!strcasecmp(state->tag, \"uid\")) {\n\t\tast_string_field_build(event, uid, \"%s%s\", event->location, str);\n\t} else if (!strcasecmp(state->tag, \"organizer\")) {\n\t\tast_string_field_build(event, organizer, \"%s%s\", event->organizer, str);\n\t} else if (!strcasecmp(state->tag, \"textdescription\")) {\n\t\tast_string_field_build(event, description, \"%s%s\", event->description, str);\n\t} else if (!strcasecmp(state->tag, \"dtstart\")) {\n\t\tevent->start = mstime_to_time_t(str);\n\t} else if (!strcasecmp(state->tag, \"dtend\")) {\n\t\tevent->end = mstime_to_time_t(str);\n\t} else if (!strcasecmp(state->tag, \"busystatus\")) {\n\t\tevent->busy_state = msbusy_to_bs(str);\n\t} else if (!strcasecmp(state->tag, \"reminderoffset\")) {\n\t\t\n\t\tevent->alarm = event->start - atoi(str);\n\t}\n\tast_free(str);\n\treturn IKS_OK;\n}\n", "bug_type": null, "idx": 2228}
{"project": "Asterisk", "target": 0, "func": "static int auth_credentials(void *userdata, const char *realm, int attempts, char *username, char *secret)\n{\n\tstruct caldav_pvt *pvt = userdata;\n\tif (attempts > 1) {\n\t\tast_log(LOG_WARNING, \"Invalid username or password for CalDAV calendar '%s'\\n\", pvt->owner->name);\n\t\treturn -1;\n\t}\n\tne_strnzcpy(username, pvt->user, NE_ABUFSIZ);\n\tne_strnzcpy(secret, pvt->secret, NE_ABUFSIZ);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2229}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void *bucket_http_test_wizard_retrieve_id(const struct ast_sorcery *sorcery,\n\tvoid *data, const char *type, const char *id)\n{\n\tstruct ast_bucket_file *bucket_file;\n\tif (!strcmp(type, \"file\") && !strcmp(id, VALID_RESOURCE)) {\n\t\tbucket_file = ast_bucket_file_alloc(id);\n\t\tif (!bucket_file) {\n\t\t\treturn NULL;\n\t\t}\n\t\tast_bucket_file_temporary_create(bucket_file);\n\t\treturn bucket_file;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2230}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225CicInfo_pointCode (OOCTXT* pctxt, H225CicInfo_pointCode* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 2, 5, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = encodeOctetString (pctxt, pvalue->numocts, pvalue->data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2231}
{"project": "Asterisk", "target": 0, "func": " ***/\nstatic int acf_vmcount_exec(struct ast_channel *chan, const char *cmd, char *argsstr, char *buf, size_t len)\n{\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(vmbox);\n\t\tAST_APP_ARG(folder);\n\t);\n\tbuf[0] = '\\0';\n\tif (ast_strlen_zero(argsstr))\n\t\treturn -1;\n\tAST_STANDARD_APP_ARGS(args, argsstr);\n\tif (ast_strlen_zero(args.vmbox)) {\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.folder)) {\n\t\targs.folder = \"INBOX\";\n\t}\n\tsnprintf(buf, len, \"%d\", ast_app_messagecount(args.vmbox, args.folder));\n\treturn 0;\n}\n", "bug_type": null, "idx": 2232}
{"project": "Asterisk", "target": 0, "func": "\nstatic int subscription_persistence_recreate(void *obj, void *arg, int flags)\n{\n\tstruct subscription_persistence *persistence = obj;\n\tpj_pool_t *pool = arg;\n\tstruct ast_taskprocessor *serializer;\n\tpjsip_rx_data rdata;\n\tstruct persistence_recreate_data recreate_data;\n\t\n\tif (ast_tvdiff_ms(persistence->expires, ast_tvnow()) <= 0) {\n\t\tast_debug(3, \"Expired subscription retrived from persistent store '%s' %s\\n\",\n\t\t\tpersistence->endpoint, persistence->tag);\n\t\tast_sorcery_delete(ast_sip_get_sorcery(), persistence);\n\t\treturn 0;\n\t}\n\tmemset(&rdata, 0, sizeof(rdata));\n\tpj_pool_reset(pool);\n\trdata.tp_info.pool = pool;\n\tif (ast_sip_create_rdata_with_contact(&rdata, persistence->packet, persistence->src_name,\n\t\tpersistence->src_port, persistence->transport_key, persistence->local_name,\n\t\tpersistence->local_port, persistence->contact_uri)) {\n\t\tast_log(LOG_WARNING, \"Failed recreating '%s' subscription: The message could not be parsed\\n\",\n\t\t\tpersistence->endpoint);\n\t\tast_sorcery_delete(ast_sip_get_sorcery(), persistence);\n\t\treturn 0;\n\t}\n\tif (rdata.msg_info.msg->type != PJSIP_REQUEST_MSG) {\n\t\tast_log(LOG_NOTICE, \"Failed recreating '%s' subscription: Stored a SIP response instead of a request.\\n\",\n\t\t\tpersistence->endpoint);\n\t\tast_sorcery_delete(ast_sip_get_sorcery(), persistence);\n\t\treturn 0;\n\t}\n\t\n\tserializer = ast_sip_get_distributor_serializer(&rdata);\n\tif (!serializer) {\n\t\tast_log(LOG_WARNING, \"Failed recreating '%s' subscription: Could not get distributor serializer.\\n\",\n\t\t\tpersistence->endpoint);\n\t\tast_sorcery_delete(ast_sip_get_sorcery(), persistence);\n\t\treturn 0;\n\t}\n\trecreate_data.persistence = persistence;\n\trecreate_data.rdata = &rdata;\n\tif (ast_sip_push_task_synchronous(serializer, sub_persistence_recreate, &recreate_data)) {\n\t\tast_log(LOG_WARNING, \"Failed recreating '%s' subscription: Could not continue under distributor serializer.\\n\",\n\t\t\tpersistence->endpoint);\n\t\tast_sorcery_delete(ast_sip_get_sorcery(), persistence);\n\t}\n\tast_taskprocessor_unreference(serializer);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2233}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_contact *ast_sip_location_retrieve_contact(const char *contact_name)\n{\n\treturn ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"contact\", contact_name);\n}\n", "bug_type": null, "idx": 2234}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void bucket_file_update_path(struct ast_bucket_file *bucket_file,\n\tconst char *preferred_file_name)\n{\n\tchar *ext;\n\tif (!ast_strlen_zero(preferred_file_name) && strcmp(bucket_file->path, preferred_file_name)) {\n\t\t\n\t\trename(bucket_file->path, preferred_file_name);\n\t\tast_copy_string(bucket_file->path, preferred_file_name,\n\t\t\tsizeof(bucket_file->path));\n\t} else if (!strchr(bucket_file->path, '.') && (ext = strrchr(ast_sorcery_object_get_id(bucket_file), '.'))) {\n\t\t\n\t\tchar new_path[PATH_MAX];\n\t\tast_bucket_file_metadata_set(bucket_file, \"ext\", ext);\n\t\tsnprintf(new_path, sizeof(new_path), \"%s%s\", bucket_file->path, ext);\n\t\trename(bucket_file->path, new_path);\n\t\tast_copy_string(bucket_file->path, new_path, sizeof(bucket_file->path));\n\t}\n}\n", "bug_type": null, "idx": 2235}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct ast_speech_engine *find_engine(const char *engine_name)\n{\n\tstruct ast_speech_engine *engine = NULL;\n\t\n\tif (ast_strlen_zero(engine_name))\n\t\treturn default_engine;\n\tAST_RWLIST_RDLOCK(&engines);\n\tAST_RWLIST_TRAVERSE(&engines, engine, list) {\n\t\tif (!strcasecmp(engine->name, engine_name)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&engines);\n\treturn engine;\n}\n", "bug_type": null, "idx": 2236}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225BandwidthConfirm (OOCTXT* pctxt, H225BandwidthConfirm* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.tokensPresent ||\n   pvalue->m.cryptoTokensPresent ||\n   pvalue->m.integrityCheckValuePresent ||\n   pvalue->m.capacityPresent ||\n   pvalue->m.genericDataPresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.nonStandardDataPresent);\n   \n   stat = asn1PE_H225RequestSeqNum (pctxt, pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   \n   stat = asn1PE_H225BandWidth (pctxt, pvalue->bandWidth);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.nonStandardDataPresent) {\n      stat = asn1PE_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n      if (stat != ASN_OK) return stat;\n   }\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 4);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.tokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.cryptoTokensPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.integrityCheckValuePresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.capacityPresent);\n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.genericDataPresent);\n      \n      if (pvalue->m.tokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225ClearToken (&lctxt, &pvalue->tokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.cryptoTokensPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225CryptoH323Token (&lctxt, &pvalue->cryptoTokens);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.integrityCheckValuePresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225ICV (&lctxt, &pvalue->integrityCheckValue);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.capacityPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225CallCapacity (&lctxt, &pvalue->capacity);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n      if (pvalue->m.genericDataPresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H225_SeqOfH225GenericData (&lctxt, &pvalue->genericData);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2237}
{"project": "Asterisk", "target": 0, "func": "static int writefile_account(char *s, char *acc)\n{\n\tchar file_account[PATH_MAX];\n\tif (strchr(acc, '/') || (acc[0] == '.')) {\n\t\tast_log(LOG_WARNING, \"Account code '%s' insecure for writing file\\n\", acc);\n\t\treturn -1;\n\t}\n\tsnprintf(file_account, sizeof(file_account), \"%s/%s/%s.csv\", ast_config_AST_LOG_DIR,CSV_LOG_DIR, acc);\n\treturn writefile(s, file_account);\n}\n", "bug_type": null, "idx": 2238}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct expression_token *build_expression_queue(struct ast_cli_args *a)\n{\n\tAST_VECTOR(, struct operator *) operators; \n\tstruct expression_token *output = NULL;    \n\tstruct expression_token *head = NULL;      \n\tint i;\n#define APPEND_TO_OUTPUT(output, token) do { \\\n\tif ((output)) { \\\n\t\t(output)->next = (token); \\\n\t\t(output) = (token); \\\n\t} else { \\\n\t\t(output) = (token); \\\n\t\thead = (output); \\\n\t} \\\n} while (0)\n\tif (AST_VECTOR_INIT(&operators, 8)) {\n\t\treturn NULL;\n\t}\n\tfor (i = 4; i < a->argc; i++) {\n\t\tstruct expression_token *out_token;\n\t\tchar *token = ast_strdupa(a->argv[i]);\n\t\tint j;\n\t\t\n\t\tif (token[0] == '(') {\n\t\t\tAST_VECTOR_APPEND(&operators, &left_paren);\n\t\t\tif (!token[1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttoken = &token[1];\n\t\t}\n\t\t\n\t\tfor (j = 0; j < ARRAY_LEN(allowed_operators); j++) {\n\t\t\tint k;\n\t\t\tif (strcasecmp(token, allowed_operators[j].symbol)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = AST_VECTOR_SIZE(&operators) - 1; k >= 0; k--) {\n\t\t\t\tstruct operator *top = AST_VECTOR_GET(&operators, k);\n\t\t\t\t\n\t\t\t\tif ((allowed_operators[j].right_to_left && allowed_operators[j].precedence >= top->precedence)\n\t\t\t\t\t|| (!allowed_operators[j].right_to_left && allowed_operators[j].precedence > top->precedence)) {\n\t\t\t\t\tif (!(out_token = expression_token_alloc(TOKEN_TYPE_OPERATOR, top))) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tAPPEND_TO_OUTPUT(output, out_token);\n\t\t\t\t\tAST_VECTOR_REMOVE(&operators, k, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tAST_VECTOR_APPEND(&operators, &allowed_operators[j]);\n\t\t\ttoken = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (!token) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (token[0] == ')' || token[strlen(token) - 1] == ')') {\n\t\t\tif (token[strlen(token) - 1] == ')') {\n\t\t\t\ttoken[strlen(token) - 1] = '\\0';\n\t\t\t\tif (!(out_token = expression_token_alloc(TOKEN_TYPE_FIELD, token))) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tAPPEND_TO_OUTPUT(output, out_token);\n\t\t\t\ttoken = NULL;\n\t\t\t}\n\t\t\tfor (j = AST_VECTOR_SIZE(&operators) - 1; j >= 0; j--) {\n\t\t\t\tstruct operator *top = AST_VECTOR_GET(&operators, j);\n\t\t\t\tAST_VECTOR_REMOVE(&operators, j, 1);\n\t\t\t\tif (top == &left_paren) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(out_token = expression_token_alloc(TOKEN_TYPE_OPERATOR, top))) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tAPPEND_TO_OUTPUT(output, out_token);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (token) {\n\t\t\tif (!(out_token = expression_token_alloc(TOKEN_TYPE_FIELD, token))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tAPPEND_TO_OUTPUT(output, out_token);\n\t\t}\n\t}\n\t\n\tfor (i = AST_VECTOR_SIZE(&operators) - 1; i >= 0; i--) {\n\t\tstruct operator *top = AST_VECTOR_GET(&operators, i);\n\t\tstruct expression_token *out_token;\n\t\tAST_VECTOR_REMOVE(&operators, i, 1);\n\t\tif (top == &left_paren) {\n\t\t\tast_log(LOG_WARNING, \"Unbalanced '(' parentheses in expression!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(out_token = expression_token_alloc(TOKEN_TYPE_OPERATOR, top))) {\n\t\t\tgoto error;\n\t\t}\n\t\tAPPEND_TO_OUTPUT(output, out_token);\n\t}\n\tAST_VECTOR_FREE(&operators);\n\treturn head;\nerror:\n\tAST_VECTOR_FREE(&operators);\n\texpression_token_free(output);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2239}
{"project": "Asterisk", "target": 0, "func": "struct ao2_container *__ao2_container_alloc_hash(unsigned int ao2_options,\n\tunsigned int container_options, unsigned int n_buckets, ao2_hash_fn *hash_fn,\n\tao2_sort_fn *sort_fn, ao2_callback_fn *cmp_fn,\n\tconst char *tag, const char *file, int line, const char *func)\n{\n\tunsigned int num_buckets;\n\tsize_t container_size;\n\tstruct ao2_container_hash *self;\n\tnum_buckets = hash_fn ? n_buckets : 1;\n\tcontainer_size = sizeof(struct ao2_container_hash) + num_buckets * sizeof(struct hash_bucket);\n\tself = __ao2_alloc(container_size, container_destruct, ao2_options,\n\t\ttag ?: __PRETTY_FUNCTION__, file, line, func);\n\treturn hash_ao2_container_init(self, container_options, num_buckets, hash_fn,\n\t\tsort_fn, cmp_fn);\n}\n", "bug_type": null, "idx": 2240}
{"project": "Asterisk", "target": 0, "func": "void ast_bridge_set_internal_sample_rate(struct ast_bridge *bridge, unsigned int sample_rate)\n{\n\tast_bridge_lock(bridge);\n\tbridge->softmix.internal_sample_rate = sample_rate;\n\tast_bridge_unlock(bridge);\n}\n", "bug_type": null, "idx": 2241}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int native_rtp_bridge_compatible(struct ast_bridge *bridge)\n{\n\tstruct ast_bridge_channel *bc0;\n\tstruct ast_bridge_channel *bc1;\n\tint is_compatible;\n\t\n\tif (bridge->num_channels != 2) {\n\t\tast_debug(1, \"Bridge '%s' can not use native RTP bridge as two channels are required\\n\",\n\t\t\tbridge->uniqueid);\n\t\treturn 0;\n\t}\n\tbc0 = AST_LIST_FIRST(&bridge->channels);\n\tbc1 = AST_LIST_LAST(&bridge->channels);\n\tast_channel_lock_both(bc0->chan, bc1->chan);\n\tis_compatible = native_rtp_bridge_compatible_check(bridge, bc0, bc1);\n\tast_channel_unlock(bc0->chan);\n\tast_channel_unlock(bc1->chan);\n\treturn is_compatible;\n}\n", "bug_type": null, "idx": 2242}
{"project": "Asterisk", "target": 0, "func": "struct ast_xml_node *ast_xml_xpath_get_first_result(struct ast_xml_xpath_results *results)\n{\n\treturn (struct ast_xml_node *) ((xmlXPathObjectPtr) results)->nodesetval->nodeTab[0];\n}\n", "bug_type": null, "idx": 2243}
{"project": "Asterisk", "target": 0, "func": "struct varshead *ast_channel_get_vars(struct ast_channel *chan)\n{\n\tRAII_VAR(struct varshead *, ret, NULL, ao2_cleanup);\n\tstruct ast_var_t *cv;\n\tret = ao2_alloc(sizeof(*ret), varshead_dtor);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tAST_LIST_TRAVERSE(ast_channel_varshead(chan), cv, entries) {\n\t\tstruct ast_var_t *var = ast_var_assign(ast_var_name(cv), ast_var_value(cv));\n\t\tif (!var) {\n\t\t\treturn NULL;\n\t\t}\n\t\tAST_LIST_INSERT_TAIL(ret, var, entries);\n\t}\n\tao2_ref(ret, +1);\n\treturn ret;\n}\n", "bug_type": null, "idx": 2244}
{"project": "Asterisk", "target": 0, "func": "static int misdn_send_text(struct ast_channel *chan, const char *text)\n{\n\tstruct chan_list *tmp = MISDN_ASTERISK_TECH_PVT(chan);\n\tif (tmp && tmp->bc) {\n\t\tast_copy_string(tmp->bc->display, text, sizeof(tmp->bc->display));\n\t\tmisdn_lib_send_event(tmp->bc, EVENT_INFORMATION);\n\t} else {\n\t\tast_log(LOG_WARNING, \"No chan_list but send_text request?\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2245}
{"project": "Asterisk", "target": 0, "func": "struct ast_jb *ast_channel_jb(struct ast_channel *chan)\n{\n\treturn &chan->jb;\n}\n", "bug_type": null, "idx": 2246}
{"project": "Asterisk", "target": 0, "func": "static void sig_ss7_set_outgoing(struct sig_ss7_chan *p, int is_outgoing)\n{\n\tp->outgoing = is_outgoing;\n\tif (sig_ss7_callbacks.set_outgoing) {\n\t\tsig_ss7_callbacks.set_outgoing(p->chan_pvt, is_outgoing);\n\t}\n}\n", "bug_type": null, "idx": 2247}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_ari_channels_ring_cb(\n\tstruct ast_tcptls_session_instance *ser,\n\tstruct ast_variable *get_params, struct ast_variable *path_vars,\n\tstruct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)\n{\n\tstruct ast_ari_channels_ring_args args = {};\n\tstruct ast_variable *i;\n#if defined(AST_DEVMODE)\n\tint is_valid;\n\tint code;\n#endif \n\tfor (i = path_vars; i; i = i->next) {\n\t\tif (strcmp(i->name, \"channelId\") == 0) {\n\t\t\targs.channel_id = (i->value);\n\t\t} else\n\t\t{}\n\t}\n\tast_ari_channels_ring(headers, &args, response);\n#if defined(AST_DEVMODE)\n\tcode = response->response_code;\n\tswitch (code) {\n\tcase 0: \n\t\tis_valid = response->message == NULL;\n\t\tbreak;\n\tcase 500: \n\tcase 501: \n\tcase 404: \n\tcase 409: \n\tcase 412: \n\t\tis_valid = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (200 <= code && code <= 299) {\n\t\t\tis_valid = ast_ari_validate_void(\n\t\t\t\tresponse->message);\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Invalid error response %d for /channels/{channelId}/ring\\n\", code);\n\t\t\tis_valid = 0;\n\t\t}\n\t}\n\tif (!is_valid) {\n\t\tast_log(LOG_ERROR, \"Response validation failed for /channels/{channelId}/ring\\n\");\n\t\tast_ari_response_error(response, 500,\n\t\t\t\"Internal Server Error\", \"Response validation failed\");\n\t}\n#endif \nfin: __attribute__((unused))\n\treturn;\n}\n", "bug_type": null, "idx": 2248}
{"project": "Asterisk", "target": 0, "func": "int ast_json_array_insert(struct ast_json *array, size_t index, struct ast_json *value)\n{\n\treturn json_array_insert_new((json_t *)array, index, (json_t *)value);\n}\n", "bug_type": null, "idx": 2249}
{"project": "Asterisk", "target": 0, "func": "\nstatic int pp_each_user_helper(struct ast_channel *chan, char *data, char *buf, struct ast_str **bufstr, int len)\n{\n\tchar *tmp;\n\tstruct ao2_iterator i;\n\tstruct user *user;\n\tstruct ast_str *str;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(string);\n\t\tAST_APP_ARG(exclude_mac);\n\t);\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (!(str = ast_str_create(16))) {\n\t\treturn -1;\n\t}\n\t\n\twhile ((tmp = strstr(args.string, \"%{\")))\n\t\t*tmp = '$';\n\ti = ao2_iterator_init(users, 0);\n\twhile ((user = ao2_iterator_next(&i))) {\n\t\tif (!ast_strlen_zero(args.exclude_mac) && !strcasecmp(user->macaddress, args.exclude_mac)) {\n\t\t\tcontinue;\n\t\t}\n\t\tast_str_substitute_variables_varshead(&str, len, AST_LIST_FIRST(&user->extensions)->headp, args.string);\n\t\tif (buf) {\n\t\t\tsize_t slen = len;\n\t\t\tast_build_string(&buf, &slen, \"%s\", ast_str_buffer(str));\n\t\t} else {\n\t\t\tast_str_append(bufstr, len, \"%s\", ast_str_buffer(str));\n\t\t}\n\t\tuser = unref_user(user);\n\t}\n\tao2_iterator_destroy(&i);\n\tast_free(str);\n\treturn 0;\n}\nstatic int pp_each_user_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\treturn pp_each_user_helper(chan, data, buf, NULL, len);\n}\nstatic int pp_each_user_read2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\treturn pp_each_user_helper(chan, data, NULL, buf, len);\n}\nstatic struct ast_custom_function pp_each_user_function = {\n\t.name = \"PP_EACH_USER\",\n\t.read = pp_each_user_read,\n\t.read2 = pp_each_user_read2,\n};\n\nstatic int pp_each_extension_helper(struct ast_channel *chan, const char *cmd, char *data, char *buf, struct ast_str **bufstr, int len)\n{\n\tstruct user *user;\n\tstruct extension *exten;\n\tchar path[PATH_MAX];\n\tchar *file;\n\tint filelen;\n\tstruct ast_str *str;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(mac);\n\t\tAST_APP_ARG(template);\n\t);\n\tAST_STANDARD_APP_ARGS(args, data);\n\tif (ast_strlen_zero(args.mac) || ast_strlen_zero(args.template)) {\n\t\tast_log(LOG_WARNING, \"PP_EACH_EXTENSION requries both a macaddress and template filename.\\n\");\n\t\treturn 0;\n\t}\n\tif (!(user = find_user(args.mac))) {\n\t\tast_log(LOG_WARNING, \"Could not find user with mac = '%s'\\n\", args.mac);\n\t\treturn 0;\n\t}\n\tsnprintf(path, sizeof(path), \"%s/phoneprov/%s\", ast_config_AST_DATA_DIR, args.template);\n\tfilelen = load_file(path, &file);\n\tif (filelen < 0) {\n\t\tast_log(LOG_WARNING, \"Could not load file: %s (%d)\\n\", path, filelen);\n\t\tif (file) {\n\t\t\tast_free(file);\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!file) {\n\t\treturn 0;\n\t}\n\tif (!(str = ast_str_create(filelen))) {\n\t\treturn 0;\n\t}\n\tAST_LIST_TRAVERSE(&user->extensions, exten, entry) {\n\t\tast_str_substitute_variables_varshead(&str, 0, exten->headp, file);\n\t\tif (buf) {\n\t\t\tsize_t slen = len;\n\t\t\tast_build_string(&buf, &slen, \"%s\", ast_str_buffer(str));\n\t\t} else {\n\t\t\tast_str_append(bufstr, len, \"%s\", ast_str_buffer(str));\n\t\t}\n\t}\n\tast_free(file);\n\tast_free(str);\n\tuser = unref_user(user);\n\treturn 0;\n}\nstatic int pp_each_extension_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\treturn pp_each_extension_helper(chan, cmd, data, buf, NULL, len);\n}\nstatic int pp_each_extension_read2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\treturn pp_each_extension_helper(chan, cmd, data, NULL, buf, len);\n}\nstatic struct ast_custom_function pp_each_extension_function = {\n\t.name = \"PP_EACH_EXTENSION\",\n\t.read = pp_each_extension_read,\n\t.read2 = pp_each_extension_read2,\n};\n#define FORMATS \"%-20.20s %-40.40s  %-30.30s\\n\"\n#define FORMATD \"%-20.20s %-20.20s %-40.40s  %-30.30s\\n\"\nstatic int route_list_cb(void *obj, void *arg, void *data, int flags)\n{\n\tint fd = *(int *)arg;\n\tstruct http_route *route = obj;\n\tif (data && route->user) {\n\t\tast_cli(fd, FORMATD, route->user->provider_name, route->profile->name, route->uri, route->file->template);\n\t}\n\tif (!data && !route->user) {\n\t\tast_cli(fd, FORMATS, route->profile->name, route->uri, route->file->template);\n\t}\n\treturn CMP_MATCH;\n}\n\nstatic char *handle_show_routes(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint fd = a->fd;\n\tswitch(cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"phoneprov show routes\";\n\t\te->usage =\n\t\t\t\"Usage: phoneprov show routes\\n\"\n\t\t\t\"       Lists all registered phoneprov http routes.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\t\n\tast_cli(a->fd, \"Static routes\\n\\n\");\n\tast_cli(a->fd, FORMATS, \"Profile\", \"Relative URI\", \"Physical location\");\n\tao2_callback_data(http_routes, OBJ_NODATA | OBJ_MULTIPLE, route_list_cb, &fd, NULL);\n\tast_cli(a->fd, \"\\nDynamic routes\\n\\n\");\n\tast_cli(a->fd, FORMATD, \"Provider\", \"Profile\", \"Relative URI\", \"Template\");\n\tao2_callback_data(http_routes, OBJ_NODATA | OBJ_MULTIPLE, route_list_cb, &fd, (void *)1);\n\treturn CLI_SUCCESS;\n}\nstatic struct ast_cli_entry pp_cli[] = {\n\tAST_CLI_DEFINE(handle_show_routes, \"Show registered phoneprov http routes\"),\n};\nstatic struct ast_http_uri phoneprovuri = {\n\t.callback = phoneprov_callback,\n\t.description = \"Asterisk HTTP Phone Provisioning Tool\",\n\t.uri = \"phoneprov\",\n\t.has_subtree = 1,\n\t.data = NULL,\n\t.key = __FILE__,\n};\nstatic struct varshead *get_defaults(void)\n{\n\tstruct ast_config *phoneprov_cfg, *cfg = CONFIG_STATUS_FILEINVALID;\n\tconst char *value;\n\tstruct ast_variable *v;\n\tstruct ast_var_t *var;\n\tstruct ast_flags config_flags = { 0 };\n\tstruct varshead *defaults = ast_var_list_create();\n\tif (!defaults) {\n\t\tast_log(LOG_ERROR, \"Unable to create default var list.\\n\");\n\t\treturn NULL;\n\t}\n\tif (!(phoneprov_cfg = ast_config_load(\"phoneprov.conf\", config_flags))\n\t\t|| phoneprov_cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Unable to load config phoneprov.conf\\n\");\n\t\tast_var_list_destroy(defaults);\n\t\treturn NULL;\n\t}\n\tvalue = ast_variable_retrieve(phoneprov_cfg, \"general\", pp_general_lookup[AST_PHONEPROV_STD_SERVER]);\n\tif (!value) {\n\t\tstruct in_addr addr;\n\t\tvalue = ast_variable_retrieve(phoneprov_cfg, \"general\", pp_general_lookup[AST_PHONEPROV_STD_SERVER_IFACE]);\n\t\tif (value) {\n\t\t\tlookup_iface(value, &addr);\n\t\t\tvalue = ast_inet_ntoa(addr);\n\t\t}\n\t}\n\tif (value) {\n\t\tvar = ast_var_assign(variable_lookup[AST_PHONEPROV_STD_SERVER], value);\n\t\tAST_VAR_LIST_INSERT_TAIL(defaults, var);\n\t} else {\n\t\tast_log(LOG_WARNING, \"Unable to find a valid server address or name.\\n\");\n\t}\n\tvalue = ast_variable_retrieve(phoneprov_cfg, \"general\", pp_general_lookup[AST_PHONEPROV_STD_SERVER_PORT]);\n\tif (!value) {\n\t\tif ((cfg = ast_config_load(\"sip.conf\", config_flags)) && cfg != CONFIG_STATUS_FILEINVALID) {\n\t\t\tvalue = ast_variable_retrieve(cfg, \"general\", \"bindport\");\n\t\t}\n\t}\n\tvar = ast_var_assign(variable_lookup[AST_PHONEPROV_STD_SERVER_PORT], S_OR(value, \"5060\"));\n\tif (cfg && cfg != CONFIG_STATUS_FILEINVALID) {\n\t\tast_config_destroy(cfg);\n\t}\n\tAST_VAR_LIST_INSERT_TAIL(defaults, var);\n\tvalue = ast_variable_retrieve(phoneprov_cfg, \"general\", pp_general_lookup[AST_PHONEPROV_STD_PROFILE]);\n\tif (!value) {\n\t\tast_log(LOG_ERROR, \"Unable to load default profile.\\n\");\n\t\tast_config_destroy(phoneprov_cfg);\n\t\tast_var_list_destroy(defaults);\n\t\treturn NULL;\n\t}\n\tvar = ast_var_assign(variable_lookup[AST_PHONEPROV_STD_PROFILE], value);\n\tAST_VAR_LIST_INSERT_TAIL(defaults, var);\n\tast_config_destroy(phoneprov_cfg);\n\tif (!(cfg = ast_config_load(\"users.conf\", config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Unable to load users.conf\\n\");\n\t\tast_var_list_destroy(defaults);\n\t\treturn NULL;\n\t}\n\t\n\tfor (v = ast_variable_browse(cfg, \"general\"); v; v = v->next) {\n\t\tif (!strcasecmp(v->name, pp_user_lookup[AST_PHONEPROV_STD_VOICEMAIL_EXTEN])) {\n\t\t\tvar = ast_var_assign(variable_lookup[AST_PHONEPROV_STD_VOICEMAIL_EXTEN], v->value);\n\t\t\tAST_VAR_LIST_INSERT_TAIL(defaults, var);\n\t\t}\n\t\tif (!strcasecmp(v->name, pp_user_lookup[AST_PHONEPROV_STD_EXTENSION_LENGTH])) {\n\t\t\tvar = ast_var_assign(variable_lookup[AST_PHONEPROV_STD_EXTENSION_LENGTH], v->value);\n\t\t\tAST_VAR_LIST_INSERT_TAIL(defaults, var);\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n\treturn defaults;\n}\nstatic int load_users(void)\n{\n\tstruct ast_config *cfg;\n\tchar *cat;\n\tconst char *value;\n\tstruct ast_flags config_flags = { 0 };\n\tstruct varshead *defaults = get_defaults();\n\tif (!defaults) {\n\t\tast_log(LOG_WARNING, \"Unable to load default variables.\\n\");\n\t\treturn -1;\n\t}\n\tif (!(cfg = ast_config_load(\"users.conf\", config_flags))\n\t\t|| cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_WARNING, \"Unable to load users.conf\\n\");\n\t\tast_var_list_destroy(defaults);\n\t\treturn -1;\n\t}\n\tcat = NULL;\n\twhile ((cat = ast_category_browse(cfg, cat))) {\n\t\tconst char *tmp;\n\t\tint i;\n\t\tstruct ast_var_t *varx;\n\t\tstruct ast_var_t *vard;\n\t\tif (strcasecmp(cat, \"general\") && strcasecmp(cat, \"authentication\")) {\n\t\t\tstruct varshead *variables = ast_var_list_create();\n\t\t\tif (!((tmp = ast_variable_retrieve(cfg, cat, \"autoprov\")) && ast_true(tmp))) {\n\t\t\t\tast_var_list_destroy(variables);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < AST_PHONEPROV_STD_VAR_LIST_LENGTH; i++) {\n\t\t\t\tif (pp_user_lookup[i]) {\n\t\t\t\t\tvalue = ast_variable_retrieve(cfg, cat, pp_user_lookup[i]);\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tvarx = ast_var_assign(variable_lookup[i],\n\t\t\t\t\t\t\tvalue);\n\t\t\t\t\t\tAST_VAR_LIST_INSERT_TAIL(variables, varx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ast_var_find(variables, variable_lookup[AST_PHONEPROV_STD_MAC])) {\n\t\t\t\tast_log(LOG_WARNING, \"autoprov set for %s, but no mac address - skipping.\\n\", cat);\n\t\t\t\tast_var_list_destroy(variables);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tAST_VAR_LIST_TRAVERSE(defaults, vard) {\n\t\t\t\tif (ast_var_find(variables, vard->name)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvarx = ast_var_assign(vard->name, vard->value);\n\t\t\t\tAST_VAR_LIST_INSERT_TAIL(variables, varx);\n\t\t\t}\n\t\t\tast_phoneprov_add_extension(SIPUSERS_PROVIDER_NAME, variables);\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n\tast_var_list_destroy(defaults);\n\treturn 0;\n}\nstatic int load_common(void)\n{\n\tstruct ast_config *phoneprov_cfg;\n\tstruct ast_flags config_flags = { 0 };\n\tchar *cat;\n\tif (!(phoneprov_cfg = ast_config_load(\"phoneprov.conf\", config_flags))\n\t\t|| phoneprov_cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_ERROR, \"Unable to load config phoneprov.conf\\n\");\n\t\treturn -1;\n\t}\n\tcat = NULL;\n\twhile ((cat = ast_category_browse(phoneprov_cfg, cat))) {\n\t\tif (!strcasecmp(cat, \"general\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tbuild_profile(cat, ast_variable_browse(phoneprov_cfg, cat));\n\t}\n\tast_config_destroy(phoneprov_cfg);\n\tif (!ao2_container_count(profiles)) {\n\t\tast_log(LOG_ERROR, \"There are no provisioning profiles in phoneprov.conf.\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nstatic int unload_module(void)\n{\n\tast_http_uri_unlink(&phoneprovuri);\n\tast_custom_function_unregister(&pp_each_user_function);\n\tast_custom_function_unregister(&pp_each_extension_function);\n\tast_cli_unregister_multiple(pp_cli, ARRAY_LEN(pp_cli));\n\t\n\tast_phoneprov_provider_unregister(SIPUSERS_PROVIDER_NAME);\n\t\n\tdelete_profiles();\n\tao2_cleanup(profiles);\n\tprofiles = NULL;\n\tdelete_routes();\n\tdelete_users();\n\tao2_cleanup(http_routes);\n\thttp_routes = NULL;\n\tao2_cleanup(users);\n\tusers = NULL;\n\tdelete_providers();\n\tao2_cleanup(providers);\n\tproviders = NULL;\n\treturn 0;\n}\n\nstatic int load_module(void)\n{\n\tprofiles = ao2_container_alloc(MAX_PROFILE_BUCKETS, phone_profile_hash_fn, phone_profile_cmp_fn);\n\tif (!profiles) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate profiles container.\\n\");\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\thttp_routes = ao2_container_alloc(MAX_ROUTE_BUCKETS, http_route_hash_fn, http_route_cmp_fn);\n\tif (!http_routes) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate routes container.\\n\");\n\t\tgoto error;\n\t}\n\tif (load_common()) {\n\t\tast_log(LOG_ERROR, \"Unable to load provisioning profiles.\\n\");\n\t\tgoto error;\n\t}\n\tusers = ao2_container_alloc(MAX_USER_BUCKETS, user_hash_fn, user_cmp_fn);\n\tif (!users) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate users container.\\n\");\n\t\tgoto error;\n\t}\n\tproviders = ao2_container_alloc(MAX_PROVIDER_BUCKETS, phoneprov_provider_hash_fn, phoneprov_provider_cmp_fn);\n\tif (!providers) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate providers container.\\n\");\n\t\tgoto error;\n\t}\n\t\n\tif (ast_phoneprov_provider_register(SIPUSERS_PROVIDER_NAME, load_users)) {\n\t\tast_log(LOG_WARNING, \"Unable register sip/users config provider.  Others may succeed.\\n\");\n\t}\n\tast_http_uri_link(&phoneprovuri);\n\tast_custom_function_register(&pp_each_user_function);\n\tast_custom_function_register(&pp_each_extension_function);\n\tast_cli_register_multiple(pp_cli, ARRAY_LEN(pp_cli));\n\treturn AST_MODULE_LOAD_SUCCESS;\nerror:\n\tunload_module();\n\treturn AST_MODULE_LOAD_DECLINE;\n}\nstatic int reload(void)\n{\n\tstruct ao2_iterator i;\n\tstruct phoneprov_provider *provider;\n\t\n\tdelete_routes();\n\tdelete_users();\n\tdelete_profiles();\n\t\n\tif (load_common()) {\n\t\tast_log(LOG_ERROR, \"Unable to reload provisioning profiles.\\n\");\n\t\tunload_module();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\t\n\tao2_lock(providers);\n\ti = ao2_iterator_init(providers, 0);\n\tfor(; (provider = ao2_iterator_next(&i)); ao2_ref(provider, -1)) {\n\t\tif (provider->load_users()) {\n\t\t\tast_log(LOG_ERROR, \"Unable to load provider '%s' users. Reload aborted.\\n\", provider->provider_name);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tao2_iterator_destroy(&i);\n\tao2_unlock(providers);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER, \"HTTP Phone Provisioning\",\n\t.support_level = AST_MODULE_SUPPORT_EXTENDED,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.reload = reload,\n\t.load_pri = AST_MODPRI_CHANNEL_DEPEND,\n);\n\nconst char *ast_phoneprov_std_variable_lookup(enum ast_phoneprov_std_variables var)\n{\n\tif (var >= AST_PHONEPROV_STD_VAR_LIST_LENGTH) {\n\t\treturn NULL;\n\t}\n\treturn variable_lookup[var];\n}\nint ast_phoneprov_provider_register(char *provider_name,\n\tast_phoneprov_load_users_cb load_users)\n{\n\tstruct phoneprov_provider *provider;\n\tif (ast_strlen_zero(provider_name)) {\n\t\tast_log(LOG_ERROR, \"Provider name can't be empty.\\n\");\n\t\treturn -1;\n\t}\n\tif (!providers) {\n\t\tast_log(LOG_WARNING, \"Provider '%s' cannot be registered: res_phoneprov not loaded.\\n\", provider_name);\n\t\treturn -1;\n\t}\n\tprovider = find_provider(provider_name);\n\tif (provider) {\n\t\tast_log(LOG_ERROR, \"There is already a provider registered named '%s'.\\n\", provider_name);\n\t\tao2_ref(provider, -1);\n\t\treturn -1;\n\t}\n\tprovider = ao2_alloc(sizeof(struct phoneprov_provider), provider_destructor);\n\tif (!provider) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate sufficient memory for provider '%s'.\\n\", provider_name);\n\t\treturn -1;\n\t}\n\tif (ast_string_field_init(provider, 32)) {\n\t\tao2_ref(provider, -1);\n\t\tast_log(LOG_ERROR, \"Unable to allocate sufficient memory for provider '%s' stringfields.\\n\", provider_name);\n\t\treturn -1;\n\t}\n\tast_string_field_set(provider, provider_name, provider_name);\n\tprovider->load_users = load_users;\n\tao2_link(providers, provider);\n\tao2_ref(provider, -1);\n\tif (provider->load_users()) {\n\t\tast_log(LOG_ERROR, \"Unable to load provider '%s' users. Register aborted.\\n\", provider_name);\n\t\tast_phoneprov_provider_unregister(provider_name);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nstatic int extensions_delete_cb(void *obj, void *arg, int flags)\n{\n\tchar *provider_name = arg;\n\tstruct user *user = obj;\n\tif (strcmp(user->provider_name, provider_name)) {\n\t\treturn 0;\n\t}\n\treturn CMP_MATCH;\n}\nstatic int extension_delete_cb(void *obj, void *arg, void *data, int flags)\n{\n\tstruct user *user = obj;\n\tchar *provider_name = data;\n\tchar *macaddress = arg;\n\tif (!strcmp(user->provider_name, provider_name) && !strcasecmp(user->macaddress, macaddress)) {\n\t\treturn CMP_MATCH;\n\t}\n\treturn 0;\n}\nvoid ast_phoneprov_delete_extension(char *provider_name, char *macaddress)\n{\n\tif (!users) {\n\t\treturn;\n\t}\n\tao2_callback_data(users, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE | OBJ_SEARCH_KEY,\n\t\textension_delete_cb, macaddress, provider_name);\n}\nvoid ast_phoneprov_delete_extensions(char *provider_name)\n{\n\tif (!users) {\n\t\treturn;\n\t}\n\tao2_callback(users, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, extensions_delete_cb, provider_name);\n}\nvoid ast_phoneprov_provider_unregister(char *provider_name)\n{\n\tif (!providers) {\n\t\treturn;\n\t}\n\tast_phoneprov_delete_extensions(provider_name);\n\tao2_find(providers, provider_name, OBJ_SEARCH_KEY | OBJ_NODATA | OBJ_UNLINK);\n}\nint ast_phoneprov_add_extension(char *provider_name, struct varshead *vars)\n{\n\tRAII_VAR(struct phoneprov_provider *, provider, NULL, ao2_cleanup);\n\tRAII_VAR(struct user *, user, NULL, ao2_cleanup);\n\tRAII_VAR(struct phone_profile *, profile, NULL, ao2_cleanup);\n\tstruct extension *exten;\n\tchar *profile_name;\n\tchar *mac;\n\tchar *username;\n\tif (ast_strlen_zero(provider_name)) {\n\t\tast_log(LOG_ERROR, \"Provider name can't be empty.\\n\");\n\t\treturn -1;\n\t}\n\tif (!vars) {\n\t\tast_log(LOG_ERROR, \"Variable list can't be empty.\\n\");\n\t\treturn -1;\n\t}\n\tusername = ast_var_find(vars, variable_lookup[AST_PHONEPROV_STD_USERNAME]);\n\tif (!username) {\n\t\tast_log(LOG_ERROR, \"Extension name can't be empty.\\n\");\n\t\treturn -1;\n\t}\n\tmac = ast_var_find(vars, variable_lookup[AST_PHONEPROV_STD_MAC]);\n\tif (!mac) {\n\t\tast_log(LOG_ERROR, \"MAC Address can't be empty.\\n\");\n\t\treturn -1;\n\t}\n\tprovider = find_provider(provider_name);\n\tif (!provider) {\n\t\tast_log(LOG_ERROR, \"Provider '%s' wasn't found in the registry.\\n\", provider_name);\n\t\treturn -1;\n\t}\n\tprofile_name = ast_var_find(vars,\n\t\tvariable_lookup[AST_PHONEPROV_STD_PROFILE]);\n\tif (!profile_name) {\n\t\tast_log(LOG_ERROR, \"No profile could be found for user '%s' - skipping.\\n\", username);\n\t\treturn -1;\n\t}\n\tif (!(profile = find_profile(profile_name))) {\n\t\tast_log(LOG_ERROR, \"Could not look up profile '%s' - skipping.\\n\", profile_name);\n\t\treturn -1;\n\t}\n\tif (!(user = find_user(mac))) {\n\t\tif (!(user = build_user(mac, profile, provider_name))) {\n\t\t\tast_log(LOG_ERROR, \"Could not create user for '%s' - skipping\\n\", mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(exten = build_extension(username, vars))) {\n\t\t\tast_log(LOG_ERROR, \"Could not create extension for '%s' - skipping\\n\", user->macaddress);\n\t\t\treturn -1;\n\t\t}\n\t\tif (add_user_extension(user, exten)) {\n\t\t\tast_log(LOG_WARNING, \"Could not add extension '%s' to user '%s'\\n\", exten->name, user->macaddress);\n\t\t\texten = delete_extension(exten);\n\t\t\treturn -1;\n\t\t}\n\t\tif (build_user_routes(user)) {\n\t\t\tast_log(LOG_WARNING, \"Could not create http routes for '%s' - skipping\\n\", user->macaddress);\n\t\t\treturn -1;\n\t\t}\n\t\tao2_link(users, user);\n\t} else {\n\t\tif (strcmp(provider_name, user->provider_name)) {\n\t\t\tast_log(LOG_ERROR, \"MAC address '%s' was already added by provider '%s' - skipping\\n\", user->macaddress, user->provider_name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(exten = build_extension(username, vars))) {\n\t\t\tast_log(LOG_ERROR, \"Could not create extension for '%s' - skipping\\n\", user->macaddress);\n\t\t\treturn -1;\n\t\t}\n\t\tif (add_user_extension(user, exten)) {\n\t\t\tast_log(LOG_WARNING, \"Could not add extension '%s' to user '%s'\\n\", exten->name, user->macaddress);\n\t\t\texten = delete_extension(exten);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2250}
{"project": "Asterisk", "target": 0, "func": "static int au_trunc(struct ast_filestream *fs)\n{\n\tint fd;\n\toff_t cur;\n\tif ((fd = fileno(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine file descriptor for au filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((cur = ftello(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine current position in au filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\t\n\tif (ftruncate(fd, cur)) {\n\t\treturn -1;\n\t}\n\treturn update_header(fs);\n}\n", "bug_type": null, "idx": 2251}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\treturn ast_register_application_xml(app, softhangup_exec);\n}\n", "bug_type": null, "idx": 2252}
{"project": "Asterisk", "target": 0, "func": "static int cli_contact_iterate(void *container, ao2_callback_fn callback, void *args)\n{\n\treturn ast_sip_for_each_contact(container, callback, args);\n}\n", "bug_type": null, "idx": 2253}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int named_locks_hash(const void *obj, const int flags)\n{\n\tconst struct named_lock_proxy *lock = obj;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_KEY:\n\t\treturn ast_str_hash(obj);\n\tcase OBJ_SEARCH_OBJECT:\n\t\treturn ast_str_hash(lock->key);\n\tdefault:\n\t\t\n\t\tast_assert(0);\n\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 2254}
{"project": "Asterisk", "target": 0, "func": "static void cancel_request(struct dundi_request *dr)\n{\n\tstruct dundi_transaction *trans;\n\tAST_LIST_LOCK(&peers);\n\twhile ((trans = AST_LIST_REMOVE_HEAD(&dr->trans, parentlist))) {\n\t\t\n\t\ttrans->parent = NULL;\n\t\t\n\t\tdundi_send(trans, DUNDI_COMMAND_CANCEL, 0, 1, NULL);\n\t}\n\tAST_LIST_UNLOCK(&peers);\n}\n", "bug_type": null, "idx": 2255}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_custom_function file_format_function = {\n\t.name = \"FILE_FORMAT\",\n\t.read2 = file_format,\n\t.read_max = 2,\n};\n};\nstatic struct ast_custom_function file_format_function = {\n\t.name = \"FILE_FORMAT\",\n\t.read2 = file_format,\n\t.read_max = 2,\n};\nstatic int unload_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_unregister(&env_function);\n\tres |= ast_custom_function_unregister(&stat_function);\n\tres |= ast_custom_function_unregister(&file_function);\n\tres |= ast_custom_function_unregister(&file_count_line_function);\n\tres |= ast_custom_function_unregister(&file_format_function);\n\treturn res;\n}\nstatic int load_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_register(&env_function);\n\tres |= ast_custom_function_register_escalating(&stat_function, AST_CFE_READ);\n\tres |= ast_custom_function_register_escalating(&file_function, AST_CFE_BOTH);\n\tres |= ast_custom_function_register_escalating(&file_count_line_function, AST_CFE_READ);\n\tres |= ast_custom_function_register_escalating(&file_format_function, AST_CFE_READ);\n\treturn res;\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"Environment/filesystem dialplan functions\");\n", "bug_type": null, "idx": 2256}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tparking_lot_container = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX,\n\t\tAO2_CONTAINER_ALLOC_OPT_DUPS_REJECT,\n\t\tparking_lot_sort_fn,\n\t\tNULL);\n\tif (!parking_lot_container) {\n\t\tgoto error;\n\t}\n\tif (aco_info_init(&cfg_info)) {\n\t\tgoto error;\n\t}\n\t\n\taco_option_register(&cfg_info, \"parkeddynamic\", ACO_EXACT, global_options, \"no\", OPT_BOOL_T, 1, FLDSET(struct parking_global_config, parkeddynamic));\n\t\n\taco_option_register(&cfg_info, \"parkext\", ACO_EXACT, parking_lot_types, \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct parking_lot_cfg, parkext));\n\taco_option_register(&cfg_info, \"context\", ACO_EXACT, parking_lot_types, \"parkedcalls\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct parking_lot_cfg, parking_con));\n\taco_option_register(&cfg_info, \"parkingtime\", ACO_EXACT, parking_lot_types, \"45\", OPT_UINT_T, 0, FLDSET(struct parking_lot_cfg, parkingtime));\n\taco_option_register(&cfg_info, \"comebacktoorigin\", ACO_EXACT, parking_lot_types, \"yes\", OPT_BOOL_T, 1, FLDSET(struct parking_lot_cfg, comebacktoorigin));\n\taco_option_register(&cfg_info, \"comebackcontext\", ACO_EXACT, parking_lot_types, \"parkedcallstimeout\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct parking_lot_cfg, comebackcontext));\n\taco_option_register(&cfg_info, \"comebackdialtime\", ACO_EXACT, parking_lot_types, \"30\", OPT_UINT_T, 0, FLDSET(struct parking_lot_cfg, comebackdialtime));\n\taco_option_register(&cfg_info, \"parkedmusicclass\", ACO_EXACT, parking_lot_types, \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct parking_lot_cfg, mohclass));\n\taco_option_register(&cfg_info, \"parkext_exclusive\", ACO_EXACT, parking_lot_types, \"no\", OPT_BOOL_T, 1, FLDSET(struct parking_lot_cfg, parkext_exclusive));\n\taco_option_register(&cfg_info, \"parkinghints\", ACO_EXACT, parking_lot_types, \"no\", OPT_BOOL_T, 1, FLDSET(struct parking_lot_cfg, parkaddhints));\n\taco_option_register(&cfg_info, \"courtesytone\", ACO_EXACT, parking_lot_types, \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct parking_lot_cfg, courtesytone));\n\t\n\taco_option_register_custom(&cfg_info, \"parkpos\", ACO_EXACT, parking_lot_types, \"701-750\", option_handler_parkpos, 0);\n\taco_option_register_custom(&cfg_info, \"findslot\", ACO_EXACT, parking_lot_types, \"first\", option_handler_findslot, 0);\n\taco_option_register_custom(&cfg_info, \"parkedplay\", ACO_EXACT, parking_lot_types, \"caller\", option_handler_parkedfeature, OPT_PARKEDPLAY);\n\taco_option_register_custom(&cfg_info, \"parkedcalltransfers\", ACO_EXACT, parking_lot_types, \"no\", option_handler_parkedfeature, OPT_PARKEDTRANSFERS);\n\taco_option_register_custom(&cfg_info, \"parkedcallreparking\", ACO_EXACT, parking_lot_types, \"no\", option_handler_parkedfeature, OPT_PARKEDREPARKING);\n\taco_option_register_custom(&cfg_info, \"parkedcallhangup\", ACO_EXACT, parking_lot_types, \"no\", option_handler_parkedfeature, OPT_PARKEDHANGUP);\n\taco_option_register_custom(&cfg_info, \"parkedcallrecording\", ACO_EXACT, parking_lot_types, \"no\", option_handler_parkedfeature, OPT_PARKEDRECORDING);\n\tif (aco_process_config(&cfg_info, 0) == ACO_PROCESS_ERROR) {\n\t\tgoto error;\n\t}\n\tif (load_parking_applications()) {\n\t\tgoto error;\n\t}\n\tif (load_parking_ui()) {\n\t\tgoto error;\n\t}\n\tif (load_parking_manager()) {\n\t\tgoto error;\n\t}\n\tif (load_parking_bridge_features()) {\n\t\tgoto error;\n\t}\n\tif (load_parking_devstate()) {\n\t\tgoto error;\n\t}\n\tif (load_parking_tests()) {\n\t\tgoto error;\n\t}\n\treturn AST_MODULE_LOAD_SUCCESS;\nerror:\n\tunload_module();\n\treturn AST_MODULE_LOAD_DECLINE;\n}\n", "bug_type": null, "idx": 2257}
{"project": "Asterisk", "target": 0, "func": "static int handle_endpoint(const struct ast_sorcery *sorcery, struct object_type_wizard *otw,\n\tstruct ast_category *wiz)\n{\n\tstruct ast_variable *wizvars = ast_category_first(wiz);\n\tstruct ast_sorcery_object *obj = NULL;\n\tconst char *id = ast_category_get_name(wiz);\n\tconst char *outbound_proxy = ast_variable_find_last_in_list(wizvars, \"outbound_proxy\");\n\tconst char *transport = ast_variable_find_last_in_list(wizvars, \"transport\");\n\tconst char *hint_context = hint_context = ast_variable_find_last_in_list(wizvars, \"hint_context\");\n\tconst char *hint_exten = ast_variable_find_last_in_list(wizvars, \"hint_exten\");\n\tconst char *hint_application= ast_variable_find_last_in_list(wizvars, \"hint_application\");\n\tchar new_id[strlen(id) + MAX_ID_SUFFIX];\n\tRAII_VAR(struct ast_variable *, vars, get_object_variables(wizvars, \"endpoint/\"), ast_variables_destroy);\n\tvariable_list_append_return(&vars, \"@pjsip_wizard\", id);\n\tvariable_list_append_return(&vars, \"aors\", id);\n\tif (!ast_strlen_zero(outbound_proxy)) {\n\t\tvariable_list_append_return(&vars, \"outbound_proxy\", outbound_proxy);\n\t}\n\tif (ast_strlen_zero(hint_context)) {\n\t\thint_context = ast_variable_find_last_in_list(vars, \"context\");\n\t}\n\tif (ast_strlen_zero(hint_context)) {\n\t\thint_context = \"default\";\n\t}\n\tif (!ast_strlen_zero(hint_exten)) {\n\t\t\n\t\tvariable_list_append_return(&vars, \"@hint_context\", hint_context);\n\t\tvariable_list_append_return(&vars, \"@hint_exten\", hint_exten);\n\t}\n\tif (!ast_strlen_zero(transport)) {\n\t\tvariable_list_append_return(&vars, \"transport\", transport);\n\t}\n\tif (is_variable_true(wizvars, \"sends_auth\")) {\n\t\tsnprintf(new_id, sizeof(new_id), \"%s-oauth\", id);\n\t\tvariable_list_append_return(&vars, \"outbound_auth\", new_id);\n\t}\n\tif (is_variable_true(wizvars, \"accepts_auth\")) {\n\t\tsnprintf(new_id, sizeof(new_id), \"%s-iauth\", id);\n\t\tvariable_list_append_return(&vars, \"auth\", new_id);\n\t}\n\tobj = create_object(sorcery, id, \"endpoint\", vars);\n\tif (!obj) {\n\t\treturn -1;\n\t}\n\tif (otw->wizard->update(sorcery, otw->wizard_data, obj)) {\n\t\totw->wizard->create(sorcery, otw->wizard_data, obj);\n\t}\n\tao2_ref(obj, -1);\n\tif (!ast_strlen_zero(hint_exten)) {\n\t\tif (is_variable_true(wizvars, \"has_hint\")) {\n\t\t\tadd_hints(hint_context, hint_exten, hint_application, id);\n\t\t} else {\n\t\t\tdelete_extens(hint_context, hint_exten);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2258}
{"project": "Asterisk", "target": 0, "func": "static int config_can_be_inherited(const char *key)\n{\n\tint i;\n\tstatic const char * const config[] = {\n\t\t\"basedn\", \"host\", \"pass\", \"port\", \"protocol\", \"url\", \"user\", \"version\", NULL\n\t};\n\tfor (i = 0; config[i]; i++) {\n\t\tif (!strcasecmp(key, config[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 2259}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_call_with_flags(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, unsigned int flags)\n{\n\tint res;\n\tstruct ast_bridge *bridge;\n\tstruct ast_bridge_features chan_features;\n\tstruct ast_bridge_features *peer_features;\n\t\n\tres = ast_bridge_features_init(&chan_features);\n\tpeer_features = ast_bridge_features_new();\n\tif (res || !peer_features) {\n\t\tast_bridge_features_destroy(peer_features);\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\tbridge_failed_peer_goto(chan, peer);\n\t\treturn -1;\n\t}\n\tif (pre_bridge_setup(chan, peer, config, &chan_features, peer_features)) {\n\t\tast_bridge_features_destroy(peer_features);\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\tbridge_failed_peer_goto(chan, peer);\n\t\treturn -1;\n\t}\n\t\n\tbridge = ast_bridge_basic_new();\n\tif (!bridge) {\n\t\tast_bridge_features_destroy(peer_features);\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\tbridge_failed_peer_goto(chan, peer);\n\t\treturn -1;\n\t}\n\tast_bridge_basic_set_flags(bridge, flags);\n\t\n\tif (ast_bridge_impart(bridge, peer, NULL, peer_features,\n\t\tAST_BRIDGE_IMPART_CHAN_INDEPENDENT | AST_BRIDGE_IMPART_INHIBIT_JOIN_COLP)) {\n\t\tast_bridge_destroy(bridge, 0);\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\tbridge_failed_peer_goto(chan, peer);\n\t\treturn -1;\n\t}\n\t\n\tast_bridge_join(bridge, chan, NULL, &chan_features, NULL,\n\t\tAST_BRIDGE_JOIN_PASS_REFERENCE | AST_BRIDGE_JOIN_INHIBIT_JOIN_COLP);\n\t\n\tres = -1;\n\tast_channel_lock(chan);\n\tif (ast_channel_softhangup_internal_flag(chan) & AST_SOFTHANGUP_ASYNCGOTO) {\n\t\tres = 0;\n\t}\n\tast_channel_unlock(chan);\n\tast_bridge_features_cleanup(&chan_features);\n\tif (res && config->end_bridge_callback) {\n\t\tconfig->end_bridge_callback(config->end_bridge_callback_data);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2260}
{"project": "Asterisk", "target": 0, "func": "\nstatic int create_mwi_subscriptions_for_endpoint(void *obj, void *arg, int flags)\n{\n\tRAII_VAR(struct mwi_subscription *, aggregate_sub, NULL, ao2_cleanup);\n\tstruct ast_sip_endpoint *endpoint = obj;\n\tchar *mailboxes, *mailbox;\n\tif (ast_strlen_zero(endpoint->subscription.mwi.mailboxes)) {\n\t\treturn 0;\n\t}\n\tif (endpoint->subscription.mwi.aggregate) {\n\t\tconst char *endpoint_id = ast_sorcery_object_get_id(endpoint);\n\t\t\n\t\taggregate_sub = ao2_find(unsolicited_mwi, endpoint_id, OBJ_SEARCH_KEY | OBJ_NOLOCK);\n\t\tif (aggregate_sub) {\n\t\t\treturn 0;\n\t\t}\n\t\taggregate_sub = mwi_subscription_alloc(endpoint, 0, NULL);\n\t\tif (!aggregate_sub) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmailboxes = ast_strdupa(endpoint->subscription.mwi.mailboxes);\n\twhile ((mailbox = ast_strip(strsep(&mailboxes, \",\")))) {\n\t\tstruct mwi_subscription *sub;\n\t\tstruct mwi_stasis_subscription *mwi_stasis_sub;\n\t\t\n\t\tif (ast_strlen_zero(mailbox) ||\n\t\t\t(!aggregate_sub && endpoint_receives_unsolicited_mwi_for_mailbox(endpoint, mailbox))) {\n\t\t\tcontinue;\n\t\t}\n\t\tsub = aggregate_sub ?: mwi_subscription_alloc(endpoint, 0, NULL);\n\t\tmwi_stasis_sub = mwi_stasis_subscription_alloc(mailbox, sub);\n\t\tif (mwi_stasis_sub) {\n\t\t\tao2_link(sub->stasis_subs, mwi_stasis_sub);\n\t\t\tao2_ref(mwi_stasis_sub, -1);\n\t\t}\n\t\tif (!aggregate_sub && sub) {\n\t\t\tao2_link_flags(unsolicited_mwi, sub, OBJ_NOLOCK);\n\t\t\tao2_ref(sub, -1);\n\t\t}\n\t}\n\tif (aggregate_sub) {\n\t\tao2_link_flags(unsolicited_mwi, aggregate_sub, OBJ_NOLOCK);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2261}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_custom_function_unregister(&pjsip_header_function);\n\tast_sip_session_unregister_supplement(&header_funcs_supplement);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2262}
{"project": "Asterisk", "target": 0, "func": "static int while_end_exec(struct ast_channel *chan, const char *data) {\n\treturn _while_exec(chan, data, 1);\n}\n", "bug_type": null, "idx": 2263}
{"project": "Asterisk", "target": 0, "func": "static void gather_softmix_stats(struct softmix_stats *stats,\n\tconst struct softmix_bridge_data *softmix_data,\n\tstruct ast_bridge_channel *bridge_channel)\n{\n\tint channel_native_rate;\n\t\n\tast_channel_lock(bridge_channel->chan);\n\tchannel_native_rate = MAX(SOFTMIX_MIN_SAMPLE_RATE,\n\t\tast_format_get_sample_rate(ast_channel_rawreadformat(bridge_channel->chan)));\n\tast_channel_unlock(bridge_channel->chan);\n\tif (stats->highest_supported_rate < channel_native_rate) {\n\t\tstats->highest_supported_rate = channel_native_rate;\n\t}\n\tif (softmix_data->internal_rate < channel_native_rate) {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_LEN(stats->sample_rates); i++) {\n\t\t\tif (stats->sample_rates[i] == channel_native_rate) {\n\t\t\t\tstats->num_channels[i]++;\n\t\t\t\tbreak;\n\t\t\t} else if (!stats->sample_rates[i]) {\n\t\t\t\tstats->sample_rates[i] = channel_native_rate;\n\t\t\t\tstats->num_channels[i]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstats->num_above_internal_rate++;\n\t} else if (softmix_data->internal_rate == channel_native_rate) {\n\t\tstats->num_at_internal_rate++;\n\t}\n}\n", "bug_type": null, "idx": 2264}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tast_ari_remove_handler(&playbacks);\n\tstasis_app_unref();\n\treturn 0;\n}\n", "bug_type": null, "idx": 2265}
{"project": "Asterisk", "target": 0, "func": "};\nint app_subscribe_endpoint(struct stasis_app *app, struct ast_endpoint *endpoint)\n{\n\tstruct app_forwards *forwards;\n\tSCOPED_AO2LOCK(lock, app->forwards);\n\tif (!app) {\n\t\treturn -1;\n\t}\n\t\n\tforwards = ao2_find(app->forwards, ENDPOINT_ALL, OBJ_SEARCH_KEY | OBJ_NOLOCK);\n\tif (forwards) {\n\t\tao2_ref(forwards, -1);\n\t\treturn 0;\n\t}\n\tforwards = ao2_find(app->forwards,\n\t\tendpoint ? ast_endpoint_get_id(endpoint) : ENDPOINT_ALL,\n\t\tOBJ_SEARCH_KEY | OBJ_NOLOCK);\n\tif (!forwards) {\n\t\t\n\t\tforwards = forwards_create_endpoint(app, endpoint);\n\t\tif (!forwards) {\n\t\t\treturn -1;\n\t\t}\n\t\tao2_link_flags(app->forwards, forwards, OBJ_NOLOCK);\n\t\t\n\t\tmessaging_app_subscribe_endpoint(app->name, endpoint, &message_received_handler, app);\n\t}\n\t++forwards->interested;\n\tast_debug(3, \"Endpoint '%s' is %d interested in %s\\n\",\n\t\tendpoint ? ast_endpoint_get_id(endpoint) : \"ALL\",\n\t\tforwards->interested,\n\t\tapp->name);\n\tao2_ref(forwards, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2266}
{"project": "Asterisk", "target": 0, "func": "static struct ast_format *ilbc_parse_sdp_fmtp(const struct ast_format *format, const char *attributes)\n{\n\tstruct ast_format *cloned;\n\tstruct ilbc_attr *attr;\n\tconst char *kvp;\n\tunsigned int val;\n\tcloned = ast_format_clone(format);\n\tif (!cloned) {\n\t\treturn NULL;\n\t}\n\tattr = ast_format_get_attribute_data(cloned);\n\tif ((kvp = strstr(attributes, \"mode\")) && sscanf(kvp, \"mode=%30u\", &val) == 1) {\n\t\tattr->mode = val;\n\t} else {\n\t\tattr->mode = 30; \n\t}\n\treturn cloned;\n}\n", "bug_type": null, "idx": 2267}
{"project": "Asterisk", "target": 0, "func": "static void copy_o_line_pjmedia(pj_pool_t *pool, pjmedia_sdp_session *pjmedia_sdp,\n\tstruct ast_sdp_o_line *o_line)\n{\n\tpjmedia_sdp->origin.id = o_line->session_id;\n\tpjmedia_sdp->origin.version = o_line->session_version;\n\tpj_strdup2(pool, &pjmedia_sdp->origin.user, o_line->username);\n\tpj_strdup2(pool, &pjmedia_sdp->origin.addr_type, o_line->address_type);\n\tpj_strdup2(pool, &pjmedia_sdp->origin.addr, o_line->address);\n\tpj_strdup2(pool, &pjmedia_sdp->origin.net_type, \"IN\");\n}\n", "bug_type": null, "idx": 2268}
{"project": "Asterisk", "target": 0, "func": "static int hash_write(struct ast_channel *chan, const char *cmd, char *var, const char *value)\n{\n\tchar varname[256];\n\tAST_DECLARE_APP_ARGS(arg,\n\t\tAST_APP_ARG(hashname);\n\t\tAST_APP_ARG(hashkey);\n\t);\n\tif (!strchr(var, ',')) {\n\t\t\n\t\treturn array(chan, \"HASH\", var, value);\n\t}\n\tAST_STANDARD_APP_ARGS(arg, var);\n\tif (arg.hashname[0] == '_') {\n\t\tif (arg.hashname[1] == '_') {\n\t\t\tsnprintf(varname, sizeof(varname), \"__\" HASH_FORMAT, arg.hashname + 2, arg.hashkey);\n\t\t} else {\n\t\t\tsnprintf(varname, sizeof(varname), \"_\" HASH_FORMAT, arg.hashname + 1, arg.hashkey);\n\t\t}\n\t} else {\n\t\tsnprintf(varname, sizeof(varname), HASH_FORMAT, arg.hashname, arg.hashkey);\n\t}\n\tpbx_builtin_setvar_helper(chan, varname, value);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2269}
{"project": "Asterisk", "target": 0, "func": "void iax_firmware_unload(void)\n{\n\tstruct iax_firmware *cur = NULL;\n\tAST_LIST_LOCK(&firmwares);\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&firmwares, cur, list) {\n\t\tAST_LIST_REMOVE_CURRENT(list);\n\t\tdestroy_firmware(cur);\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\tAST_LIST_UNLOCK(&firmwares);\n}\n", "bug_type": null, "idx": 2270}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_unbridged(struct ast_channel *chan)\n{\n\tint res;\n\tast_channel_lock(chan);\n\tres = ast_channel_unbridged_nolock(chan);\n\tast_channel_unlock(chan);\n\treturn res;\n}\n", "bug_type": null, "idx": 2271}
{"project": "Asterisk", "target": 0, "func": "static void moh_class_destructor(void *obj)\n{\n\tstruct mohclass *class = obj;\n\tstruct mohdata *member;\n\tpthread_t tid = 0;\n\tast_debug(1, \"Destroying MOH class '%s'\\n\", class->name);\n\tao2_lock(class);\n\twhile ((member = AST_LIST_REMOVE_HEAD(&class->members, list))) {\n\t\tast_free(member);\n\t}\n\tao2_unlock(class);\n\t\n\tif (class->thread != AST_PTHREADT_NULL && class->thread != 0) {\n\t\ttid = class->thread;\n\t\tclass->thread = AST_PTHREADT_NULL;\n\t\tpthread_cancel(tid);\n\t\t\n\t}\n\tif (class->pid > 1) {\n\t\tchar buff[8192];\n\t\tint bytes, tbytes = 0, stime = 0;\n\t\tast_debug(1, \"killing %d!\\n\", class->pid);\n\t\tstime = time(NULL) + 2;\n\t\tkillpid(class->pid, class->kill_delay, class->kill_method);\n\t\twhile ((ast_wait_for_input(class->srcfd, 100) > 0) && \n\t\t\t\t(bytes = read(class->srcfd, buff, 8192)) && time(NULL) < stime) {\n\t\t\ttbytes = tbytes + bytes;\n\t\t}\n\t\tast_debug(1, \"mpg123 pid %d and child died after %d bytes read\\n\",\n\t\t\tclass->pid, tbytes);\n\t\tclass->pid = 0;\n\t\tclose(class->srcfd);\n\t\tclass->srcfd = -1;\n\t}\n\tif (class->filearray) {\n\t\tint i;\n\t\tfor (i = 0; i < class->total_files; i++) {\n\t\t\tast_free(class->filearray[i]);\n\t\t}\n\t\tast_free(class->filearray);\n\t\tclass->filearray = NULL;\n\t}\n\tif (class->timer) {\n\t\tast_timer_close(class->timer);\n\t\tclass->timer = NULL;\n\t}\n\tao2_cleanup(class->format);\n\t\n\tif (tid > 0) {\n\t\tpthread_join(tid, NULL);\n\t}\n}\n", "bug_type": null, "idx": 2272}
{"project": "Asterisk", "target": 0, "func": "static int dumpchan_exec(struct ast_channel *chan, const char *data)\n{\n\tstruct ast_str *vars = ast_str_thread_get(&ast_str_thread_global_buf, 16);\n\tchar info[2048];\n\tint level = 0;\n\tstatic char *line = \"================================================================================\";\n\tif (!ast_strlen_zero(data))\n\t\tlevel = atoi(data);\n\tif (VERBOSITY_ATLEAST(level)) {\n\t\tserialize_showchan(chan, info, sizeof(info));\n\t\tpbx_builtin_serialize_variables(chan, &vars);\n\t\tast_verb(level, \"\\n\"\n\t\t\t\"Dumping Info For Channel: %s:\\n\"\n\t\t\t\"%s\\n\"\n\t\t\t\"Info:\\n\"\n\t\t\t\"%s\\n\"\n\t\t\t\"Variables:\\n\"\n\t\t\t\"%s%s\\n\", ast_channel_name(chan), line, info, ast_str_buffer(vars), line);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2273}
{"project": "Asterisk", "target": 0, "func": "void ast_channel_set_rawwriteformat(struct ast_channel *chan, struct ast_format *format)\n{\n\tao2_replace(chan->rawwriteformat, format);\n}\n", "bug_type": null, "idx": 2274}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void bridge_manager_service_req(struct ast_bridge *bridge)\n{\n\tstruct bridge_manager_request *request;\n\tao2_lock(bridge_manager);\n\tif (bridge_manager->stop) {\n\t\tao2_unlock(bridge_manager);\n\t\treturn;\n\t}\n\t\n\trequest = ast_calloc(1, sizeof(*request));\n\tif (!request) {\n\t\t\n\t\tao2_unlock(bridge_manager);\n\t\treturn;\n\t}\n\tao2_ref(bridge, +1);\n\trequest->bridge = bridge;\n\t\n\tAST_LIST_INSERT_TAIL(&bridge_manager->service_requests, request, node);\n\tast_cond_signal(&bridge_manager->cond);\n\tao2_unlock(bridge_manager);\n}\n", "bug_type": null, "idx": 2275}
{"project": "Asterisk", "target": 0, "func": "void misdn_lib_bridge( struct misdn_bchannel * bc1, struct misdn_bchannel *bc2)\n{\n\tint conf_id = bc1->pid + 1;\n\tstruct misdn_bchannel *bc_list[] = { bc1, bc2, NULL };\n\tstruct misdn_bchannel **bc;\n\tcb_log(4, bc1->port, \"I Send: BRIDGE from:%d to:%d\\n\",bc1->port,bc2->port);\n\tfor (bc=bc_list; *bc;  bc++) {\n\t\t(*bc)->conf_id=conf_id;\n\t\tcb_log(4, (*bc)->port, \" --> bc_addr:%x\\n\",(*bc)->addr);\n\t\tswitch((*bc)->bc_state) {\n\t\t\tcase BCHAN_ACTIVATED:\n\t\t\t\tmisdn_join_conf(*bc,conf_id);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbc_next_state_change(*bc,BCHAN_BRIDGED);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2276}
{"project": "Asterisk", "target": 0, "func": "int\nhistory(History *h, HistEvent *ev, int fun, ...)\n{\n\tva_list va;\n\tconst char *str;\n\tint retval;\n\tva_start(va, fun);\n\the_seterrev(ev, _HE_OK);\n\tswitch (fun) {\n\tcase H_GETSIZE:\n\t\tretval = history_getsize(h, ev);\n\t\tbreak;\n\tcase H_SETSIZE:\n\t\tretval = history_setsize(h, ev, va_arg(va, int));\n\t\tbreak;\n\tcase H_ADD:\n\t\tstr = va_arg(va, const char *);\n\t\tretval = HADD(h, ev, str);\n\t\tbreak;\n\tcase H_ENTER:\n\t\tstr = va_arg(va, const char *);\n\t\tif ((retval = HENTER(h, ev, str)) != -1)\n\t\t\th->h_ent = ev->num;\n\t\tbreak;\n\tcase H_APPEND:\n\t\tstr = va_arg(va, const char *);\n\t\tif ((retval = HSET(h, ev, h->h_ent)) != -1)\n\t\t\tretval = HADD(h, ev, str);\n\t\tbreak;\n\tcase H_FIRST:\n\t\tretval = HFIRST(h, ev);\n\t\tbreak;\n\tcase H_NEXT:\n\t\tretval = HNEXT(h, ev);\n\t\tbreak;\n\tcase H_LAST:\n\t\tretval = HLAST(h, ev);\n\t\tbreak;\n\tcase H_PREV:\n\t\tretval = HPREV(h, ev);\n\t\tbreak;\n\tcase H_CURR:\n\t\tretval = HCURR(h, ev);\n\t\tbreak;\n\tcase H_SET:\n\t\tretval = HSET(h, ev, va_arg(va, const int));\n\t\tbreak;\n\tcase H_CLEAR:\n\t\tHCLEAR(h, ev);\n\t\tretval = 0;\n\t\tbreak;\n\tcase H_LOAD:\n\t\tretval = history_load(h, va_arg(va, const char *));\n\t\tif (retval == -1)\n\t\t\the_seterrev(ev, _HE_HIST_READ);\n\t\tbreak;\n\tcase H_SAVE:\n\t\tretval = history_save(h, va_arg(va, const char *));\n\t\tif (retval == -1)\n\t\t\the_seterrev(ev, _HE_HIST_WRITE);\n\t\tbreak;\n\tcase H_PREV_EVENT:\n\t\tretval = history_prev_event(h, ev, va_arg(va, int));\n\t\tbreak;\n\tcase H_NEXT_EVENT:\n\t\tretval = history_next_event(h, ev, va_arg(va, int));\n\t\tbreak;\n\tcase H_PREV_STR:\n\t\tretval = history_prev_string(h, ev, va_arg(va, const char *));\n\t\tbreak;\n\tcase H_NEXT_STR:\n\t\tretval = history_next_string(h, ev, va_arg(va, const char *));\n\t\tbreak;\n\tcase H_FUNC:\n\t{\n\t\tHistory hf;\n\t\thf.h_ref = va_arg(va, ptr_t);\n\t\th->h_ent = -1;\n\t\thf.h_first = va_arg(va, history_gfun_t);\n\t\thf.h_next = va_arg(va, history_gfun_t);\n\t\thf.h_last = va_arg(va, history_gfun_t);\n\t\thf.h_prev = va_arg(va, history_gfun_t);\n\t\thf.h_curr = va_arg(va, history_gfun_t);\n\t\thf.h_set = va_arg(va, history_sfun_t);\n\t\thf.h_clear = va_arg(va, history_vfun_t);\n\t\thf.h_enter = va_arg(va, history_efun_t);\n\t\thf.h_add = va_arg(va, history_efun_t);\n\t\tif ((retval = history_set_fun(h, &hf)) == -1)\n\t\t\the_seterrev(ev, _HE_PARAM_MISSING);\n\t\tbreak;\n\t}\n\tcase H_END:\n\t\thistory_end(h);\n\t\tretval = 0;\n\t\tbreak;\n\tdefault:\n\t\tretval = -1;\n\t\the_seterrev(ev, _HE_UNKNOWN);\n\t\tbreak;\n\t}\n\tva_end(va);\n\treturn (retval);\n}\n", "bug_type": null, "idx": 2277}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function timeout_function = {\n\t.name = \"TIMEOUT\",\n\t.read = timeout_read,\n\t.read_max = 22,\n\t.write = timeout_write,\n};\n}\nstatic struct ast_custom_function timeout_function = {\n\t.name = \"TIMEOUT\",\n\t.read = timeout_read,\n\t.read_max = 22,\n\t.write = timeout_write,\n};\nstatic int unload_module(void)\n{\n\treturn ast_custom_function_unregister(&timeout_function);\n}\nstatic int load_module(void)\n{\n\treturn ast_custom_function_register(&timeout_function);\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"Channel timeout dialplan functions\");\n", "bug_type": null, "idx": 2278}
{"project": "Asterisk", "target": 0, "func": "static int create_parked_subscription_full(struct ast_channel *chan, const char *parkee_uuid, int hangup_after,\n\tstruct transfer_channel_data *parked_channel_data)\n{\n\tstruct ast_datastore *datastore;\n\tstruct parked_subscription_datastore *parked_datastore;\n\tstruct parked_subscription_data *subscription_data;\n\tchar *parker_uuid = ast_strdupa(ast_channel_uniqueid(chan));\n\tsize_t parker_uuid_size = strlen(parker_uuid) + 1;\n\t\n\twipe_subscription_datastore(chan);\n\tif (!(datastore = ast_datastore_alloc(&parked_subscription_info, NULL))) {\n\t\treturn -1;\n\t}\n\tif (!(parked_datastore = ast_calloc(1, sizeof(*parked_datastore)))) {\n\t\tast_datastore_free(datastore);\n\t\treturn -1;\n\t}\n\tif (!(subscription_data = ast_calloc(1, sizeof(*subscription_data) + parker_uuid_size +\n\t\t\tstrlen(parkee_uuid) + 1))) {\n\t\tast_datastore_free(datastore);\n\t\tast_free(parked_datastore);\n\t\treturn -1;\n\t}\n\tif (parked_channel_data) {\n\t\tsubscription_data->transfer_data = parked_channel_data;\n\t\tao2_ref(parked_channel_data, +1);\n\t}\n\tsubscription_data->hangup_after = hangup_after;\n\tsubscription_data->parkee_uuid = subscription_data->parker_uuid + parker_uuid_size;\n\tstrcpy(subscription_data->parkee_uuid, parkee_uuid);\n\tstrcpy(subscription_data->parker_uuid, parker_uuid);\n\tif (!(parked_datastore->parked_subscription = stasis_subscribe_pool(ast_parking_topic(), parker_update_cb, subscription_data))) {\n\t\treturn -1;\n\t}\n\tdatastore->data = parked_datastore;\n\tast_channel_lock(chan);\n\tast_channel_datastore_add(chan, datastore);\n\tast_channel_unlock(chan);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2279}
{"project": "Asterisk", "target": 0, "func": "#ifndef yytext_ptr\nstatic void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}\n", "bug_type": null, "idx": 2280}
{"project": "Asterisk", "target": 0, "func": "static struct ast_config *config_mysql(const char *database, const char *table, const char *file, struct ast_config *cfg, struct ast_flags config_flags, const char *unused, const char *who_asked)\n{\n\tstruct mysql_conn *dbh;\n\tMYSQL_RES *result;\n\tMYSQL_ROW row;\n\tmy_ulonglong num_rows;\n\tstruct ast_variable *new_v;\n\tstruct ast_category *cur_cat = NULL;\n\tstruct ast_str *sql = ast_str_thread_get(&sql_buf, 200);\n\tchar last[80] = \"\";\n\tint last_cat_metric = 0;\n\tast_clear_flag(&config_flags, CONFIG_FLAG_FILEUNCHANGED);\n\tif (!file || !strcmp(file, RES_CONFIG_MYSQL_CONF)) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Cannot configure myself.\\n\");\n\t\treturn NULL;\n\t}\n\tif (!(dbh = find_database(database, 0))) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Invalid database specified: '%s' (check res_mysql.conf)\\n\", database);\n\t\treturn NULL;\n\t}\n\tast_str_set(&sql, 0, \"SELECT category, var_name, var_val, cat_metric FROM %s WHERE filename='%s' and commented=0 ORDER BY filename, category, cat_metric desc, var_metric asc, var_name, var_val, id\", table, file);\n\tast_debug(1, \"MySQL RealTime: Static SQL: %s\\n\", ast_str_buffer(sql));\n\t\n\tif (!mysql_reconnect(dbh)) {\n\t\treturn NULL;\n\t}\n\tif (mysql_real_query(&dbh->handle, ast_str_buffer(sql), ast_str_strlen(sql))) {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Failed to query database. Check debug for more info.\\n\");\n\t\tast_debug(1, \"MySQL RealTime: Query: %s\\n\", ast_str_buffer(sql));\n\t\tast_debug(1, \"MySQL RealTime: Query Failed because: %s\\n\", mysql_error(&dbh->handle));\n\t\trelease_database(dbh);\n\t\treturn NULL;\n\t}\n\tif ((result = mysql_store_result(&dbh->handle))) {\n\t\tnum_rows = mysql_num_rows(result);\n\t\tast_debug(1, \"MySQL RealTime: Found %llu rows.\\n\", num_rows);\n\t\t\n\t\twhile ((row = mysql_fetch_row(result))) {\n\t\t\tif (!strcmp(row[1], \"#include\")) {\n\t\t\t\tif (!ast_config_internal_load(row[2], cfg, config_flags, \"\", who_asked)) {\n\t\t\t\t\tmysql_free_result(result);\n\t\t\t\t\trelease_database(dbh);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(last, row[0]) || last_cat_metric != atoi(row[3])) {\n\t\t\t\tcur_cat = ast_category_new_dynamic(row[0]);\n\t\t\t\tif (!cur_cat) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy(last, row[0]);\n\t\t\t\tlast_cat_metric = atoi(row[3]);\n\t\t\t\tast_category_append(cfg, cur_cat);\n\t\t\t}\n\t\t\tnew_v = ast_variable_new(row[1], row[2], \"\");\n\t\t\tif (cur_cat)\n\t\t\t\tast_variable_append(cur_cat, new_v);\n\t\t}\n\t} else {\n\t\tast_log(LOG_WARNING, \"MySQL RealTime: Could not find config '%s' in database.\\n\", file);\n\t}\n\tmysql_free_result(result);\n\trelease_database(dbh);\n\treturn cfg;\n}\n", "bug_type": null, "idx": 2281}
{"project": "Asterisk", "target": 0, "func": "struct ast_format *ast_rtp_codecs_get_payload_format(struct ast_rtp_codecs *codecs, int payload)\n{\n\tstruct ast_rtp_payload_type *type;\n\tstruct ast_format *format = NULL;\n\tif (payload < 0 || payload >= AST_RTP_MAX_PT) {\n\t\treturn NULL;\n\t}\n\tast_rwlock_rdlock(&codecs->codecs_lock);\n\tif (payload < AST_VECTOR_SIZE(&codecs->payload_mapping_tx)) {\n\t\ttype = AST_VECTOR_GET(&codecs->payload_mapping_tx, payload);\n\t\tif (type && type->asterisk_format) {\n\t\t\tformat = ao2_bump(type->format);\n\t\t}\n\t}\n\tast_rwlock_unlock(&codecs->codecs_lock);\n\treturn format;\n}\n", "bug_type": null, "idx": 2282}
{"project": "Asterisk", "target": 0, "func": "static char flip_table[256];\nstatic void init_flip_bits(void)\n{\n\tint i,k;\n\tfor (i = 0 ; i < 256 ; i++) {\n\t\tunsigned char sample = 0 ;\n\t\tfor (k = 0; k<8; k++) {\n\t\t\tif ( i & 1 << k ) sample |= 0x80 >>  k;\n\t\t}\n\t\tflip_table[i] = sample;\n\t}\n}\n", "bug_type": null, "idx": 2283}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225AdmissionConfirm_language (OOCTXT* pctxt, H225AdmissionConfirm_language* pvalue)\n{\n   static Asn1SizeCnst element_lsize1 = { 0, 1, 32, 0 };\n   int stat = ASN_OK;\n   ASN1UINT xx1;\n   \n   stat = encodeLength (pctxt, pvalue->n);\n   if (stat < 0) return stat;\n   \n   for (xx1 = 0; xx1 < pvalue->n; xx1++) {\n      addSizeConstraint (pctxt, &element_lsize1);\n      stat = encodeConstrainedStringEx (pctxt, pvalue->elem[xx1], 0, 8, 7, 7);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2284}
{"project": "Asterisk", "target": 0, "func": "\nstatic void wrap_hook(struct ast_bridge_features *features, struct ast_bridge_hook_timer *hook)\n{\n\t\n\tif (hook->generic.callback == interval_wrapper_cb) {\n\t\thook = hook->generic.hook_pvt;\n\t}\n\tast_bridge_interval_hook(features, hook->timer.flags, hook->timer.interval,\n\t\tinterval_wrapper_cb, ao2_bump(hook), interval_wrapper_pvt_dtor,\n\t\thook->generic.remove_flags.flags);\n}\n", "bug_type": null, "idx": 2285}
{"project": "Asterisk", "target": 0, "func": "char **__ast_bt_get_symbols(void **addresses, size_t num_frames)\n{\n\tchar **strings;\n#if defined(BETTER_BACKTRACES)\n\tint stackfr;\n\tbfd *bfdobj;           \n\tDl_info dli;           \n\tlong allocsize;\n\tasymbol **syms = NULL; \n\tbfd_vma offset;        \n\tconst char *lastslash;\n\tasection *section;\n\tconst char *file, *func;\n\tunsigned int line;\n\tchar address_str[128];\n\tchar msg[1024];\n\tsize_t strings_size;\n\tsize_t *eachlen;\n#endif\n#if defined(BETTER_BACKTRACES)\n\tstrings_size = num_frames * sizeof(*strings);\n\teachlen = ast_std_calloc(num_frames, sizeof(*eachlen));\n\tstrings = ast_std_calloc(num_frames, sizeof(*strings));\n\tif (!eachlen || !strings) {\n\t\tast_std_free(eachlen);\n\t\tast_std_free(strings);\n\t\treturn NULL;\n\t}\n\tfor (stackfr = 0; stackfr < num_frames; stackfr++) {\n\t\tint found = 0, symbolcount;\n\t\tmsg[0] = '\\0';\n\t\tif (!dladdr(addresses[stackfr], &dli)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(dli.dli_fname, \"asterisk\") == 0) {\n\t\t\tchar asteriskpath[256];\n\t\t\tif (!(dli.dli_fname = ast_utils_which(\"asterisk\", asteriskpath, sizeof(asteriskpath)))) {\n\t\t\t\t\n\t\t\t\tdli.dli_fname = \"asterisk\";\n\t\t\t}\n\t\t}\n\t\tlastslash = strrchr(dli.dli_fname, '/');\n\t\tif ((bfdobj = bfd_openr(dli.dli_fname, NULL)) &&\n\t\t\tbfd_check_format(bfdobj, bfd_object) &&\n\t\t\t(allocsize = bfd_get_symtab_upper_bound(bfdobj)) > 0 &&\n\t\t\t(syms = ast_std_malloc(allocsize)) &&\n\t\t\t(symbolcount = bfd_canonicalize_symtab(bfdobj, syms))) {\n\t\t\tif (bfdobj->flags & DYNAMIC) {\n\t\t\t\toffset = addresses[stackfr] - dli.dli_fbase;\n\t\t\t} else {\n\t\t\t\toffset = addresses[stackfr] - (void *) 0;\n\t\t\t}\n\t\t\tfor (section = bfdobj->sections; section; section = section->next) {\n\t\t\t\tif (!bfd_get_section_flags(bfdobj, section) & SEC_ALLOC ||\n\t\t\t\t\tsection->vma > offset ||\n\t\t\t\t\tsection->size + section->vma < offset) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!bfd_find_nearest_line(bfdobj, section, syms, offset - section->vma, &file, &func, &line)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfile = file ? file : \"\";\n\t\t\t\t\n\t\t\t\tfound++;\n\t\t\t\tif ((lastslash = strrchr(file, '/'))) {\n\t\t\t\t\tconst char *prevslash;\n\t\t\t\t\tfor (prevslash = lastslash - 1; *prevslash != '/' && prevslash >= file; prevslash--) {\n\t\t\t\t\t}\n\t\t\t\t\tif (prevslash >= file) {\n\t\t\t\t\t\tlastslash = prevslash;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dli.dli_saddr == NULL) {\n\t\t\t\t\taddress_str[0] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(address_str, sizeof(address_str), \" (%p+%lX)\",\n\t\t\t\t\t\tdli.dli_saddr,\n\t\t\t\t\t\t(unsigned long) (addresses[stackfr] - dli.dli_saddr));\n\t\t\t\t}\n\t\t\t\tsnprintf(msg, sizeof(msg), \"%s:%u %s()%s\",\n\t\t\t\t\tlastslash ? lastslash + 1 : file, line,\n\t\t\t\t\tS_OR(func, \"???\"),\n\t\t\t\t\taddress_str);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tif (bfdobj) {\n\t\t\tbfd_close(bfdobj);\n\t\t\tast_std_free(syms);\n\t\t}\n\t\t\n\t\tif (!found) {\n\t\t\tif (dli.dli_saddr == NULL) {\n\t\t\t\taddress_str[0] = '\\0';\n\t\t\t} else {\n\t\t\t\tsnprintf(address_str, sizeof(address_str), \" (%p+%lX)\",\n\t\t\t\t\tdli.dli_saddr,\n\t\t\t\t\t(unsigned long) (addresses[stackfr] - dli.dli_saddr));\n\t\t\t}\n\t\t\tsnprintf(msg, sizeof(msg), \"%s %s()%s\",\n\t\t\t\tlastslash ? lastslash + 1 : dli.dli_fname,\n\t\t\t\tS_OR(dli.dli_sname, \"<unknown>\"),\n\t\t\t\taddress_str);\n\t\t}\n\t\tif (!ast_strlen_zero(msg)) {\n\t\t\tchar **tmp;\n\t\t\teachlen[stackfr] = strlen(msg) + 1;\n\t\t\tif (!(tmp = ast_std_realloc(strings, strings_size + eachlen[stackfr]))) {\n\t\t\t\tast_std_free(strings);\n\t\t\t\tstrings = NULL;\n\t\t\t\tbreak; \n\t\t\t}\n\t\t\tstrings = tmp;\n\t\t\tstrings[stackfr] = (char *) strings + strings_size;\n\t\t\tstrcpy(strings[stackfr], msg);\n\t\t\tstrings_size += eachlen[stackfr];\n\t\t}\n\t}\n\tif (strings) {\n\t\t\n\t\tstrings[0] = (char *) strings + num_frames * sizeof(*strings);\n\t\tfor (stackfr = 1; stackfr < num_frames; stackfr++) {\n\t\t\tstrings[stackfr] = strings[stackfr - 1] + eachlen[stackfr - 1];\n\t\t}\n\t}\n\tast_std_free(eachlen);\n#else \n\tstrings = backtrace_symbols(addresses, num_frames);\n#endif \n\treturn strings;\n}\n", "bug_type": null, "idx": 2286}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245MCLocationIndication (OOCTXT* pctxt, H245MCLocationIndication* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   \n   stat = asn1PE_H245TransportAddress (pctxt, &pvalue->signalAddress);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2287}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225FastStartToken (OOCTXT* pctxt, H225FastStartToken* pvalue)\n{\n   int stat = ASN_OK;\n   stat = asn1PE_H235ClearToken (pctxt, pvalue);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2288}
{"project": "Asterisk", "target": 0, "func": "static void adsi_load(int reload)\n{\n\tint x = 0;\n\tstruct ast_config *conf = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\tchar *name, *sname;\n\tinit_state();\n\tconf = ast_config_load(\"adsi.conf\", config_flags);\n\tif (conf == CONFIG_STATUS_FILEMISSING || conf == CONFIG_STATUS_FILEUNCHANGED || conf == CONFIG_STATUS_FILEINVALID) {\n\t\treturn;\n\t}\n\tfor (v = ast_variable_browse(conf, \"intro\"); v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"alignment\")) {\n\t\t\talignment = str2align(v->value);\n\t\t} else if (!strcasecmp(v->name, \"greeting\")) {\n\t\t\tif (x < ADSI_MAX_INTRO) {\n\t\t\t\taligns[x] = alignment;\n\t\t\t\tast_copy_string(intro[x], v->value, sizeof(intro[x]));\n\t\t\t\tx++;\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"maxretries\")) {\n\t\t\tif (atoi(v->value) > 0) {\n\t\t\t\tmaxretries = atoi(v->value);\n\t\t\t}\n\t\t}\n\t}\n\tif (x) {\n\t\ttotal = x;\n\t}\n\tx = 0;\n\tfor (v = ast_variable_browse(conf, \"speeddial\"); v; v = v->next) {\n\t\tchar buf[3 * SPEEDDIAL_MAX_LEN];\n\t\tchar *stringp = buf;\n\t\tast_copy_string(buf, v->value, sizeof(buf));\n\t\tname = strsep(&stringp, \",\");\n\t\tsname = strsep(&stringp, \",\");\n\t\tif (!sname) {\n\t\t\tsname = name;\n\t\t}\n\t\tif (x < ADSI_MAX_SPEED_DIAL) {\n\t\t\tast_copy_string(speeddial[x][0], v->name, sizeof(speeddial[x][0]));\n\t\t\tast_copy_string(speeddial[x][1], name, 18);\n\t\t\tast_copy_string(speeddial[x][2], sname, 7);\n\t\t\tx++;\n\t\t}\n\t}\n\tif (x) {\n\t\tspeeds = x;\n\t}\n\tast_config_destroy(conf);\n\treturn;\n}\n", "bug_type": null, "idx": 2289}
{"project": "Asterisk", "target": 0, "func": "struct ooh323_peer *find_peer(const char * name, int port)\n{\n\tstruct ooh323_peer *peer;\n\tif (gH323Debug)\n\t\tast_verb(0, \"---   find_peer \\\"%s\\\"\\n\", name);\n\tast_mutex_lock(&peerl.lock);\n\tfor (peer = peerl.peers; peer; peer = peer->next) {\n\t\tif (gH323Debug) {\n\t\t\tast_verb(0, \"\t\tcomparing with \\\"%s\\\"\\n\", peer->ip);\n\t\t}\n\t\tif (!strcasecmp(peer->name, name))\n\t\t\tbreak;\n\t\tif (peer->h323id && !strcasecmp(peer->h323id, name))\n\t\t\tbreak;\n\t\tif (peer->e164 && !strcasecmp(peer->e164, name))\n\t\t\tbreak;\n\t\t\n\t}\n\tast_mutex_unlock(&peerl.lock);\n\tif (gH323Debug) {\n\t\tif (peer) {\n\t\t\tast_verb(0, \"\t\tfound matching peer\\n\");\n\t\t}\n\t\tast_verb(0, \"+++   find_peer \\\"%s\\\"\\n\", name);\n\t}\n\treturn peer;\t\t\n}\n", "bug_type": null, "idx": 2290}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245SequenceNumber (OOCTXT* pctxt, H245SequenceNumber* pvalue)\n{\n   int stat = ASN_OK;\n   stat = decodeConsUInt8 (pctxt, pvalue, 0U, 255U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, *pvalue);\n   return (stat);\n}\n", "bug_type": null, "idx": 2291}
{"project": "Asterisk", "target": 0, "func": "static int siren7trunc(struct ast_filestream *fs)\n{\n\tint fd;\n\toff_t cur;\n\tif ((fd = fileno(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine file descriptor for siren7 filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((cur = ftello(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine current position in siren7 filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\t\n\treturn ftruncate(fd, cur);\n}\n", "bug_type": null, "idx": 2292}
{"project": "Asterisk", "target": 0, "func": "static void pubsub_on_client_refresh(pjsip_evsub *evsub)\n{\n\tstruct sip_subscription_tree *sub_tree;\n\tif (!(sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id))) {\n\t\treturn;\n\t}\n\tif (ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_client_refresh, ao2_bump(sub_tree))) {\n\t\tao2_cleanup(sub_tree);\n\t}\n}\n", "bug_type": null, "idx": 2293}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_mixmonitor(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_channel *chan;\n\tstruct ast_datastore *datastore = NULL;\n\tstruct mixmonitor_ds *mixmonitor_ds = NULL;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"mixmonitor {start|stop|list}\";\n\t\te->usage =\n\t\t\t\"Usage: mixmonitor start <chan_name> [args]\\n\"\n\t\t\t\"         The optional arguments are passed to the MixMonitor application.\\n\"\n\t\t\t\"       mixmonitor stop <chan_name> [args]\\n\"\n\t\t\t\"         The optional arguments are passed to the StopMixMonitor application.\\n\"\n\t\t\t\"       mixmonitor list <chan_name>\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn ast_complete_channels(a->line, a->word, a->pos, a->n, 2);\n\t}\n\tif (a->argc < 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (!(chan = ast_channel_get_by_name_prefix(a->argv[2], strlen(a->argv[2])))) {\n\t\tast_cli(a->fd, \"No channel matching '%s' found.\\n\", a->argv[2]);\n\t\t\n\t\treturn CLI_SUCCESS;\n\t}\n\tif (!strcasecmp(a->argv[1], \"start\")) {\n\t\tmixmonitor_exec(chan, (a->argc >= 4) ? a->argv[3] : \"\");\n\t} else if (!strcasecmp(a->argv[1], \"stop\")){\n\t\tstop_mixmonitor_exec(chan, (a->argc >= 4) ? a->argv[3] : \"\");\n\t} else if (!strcasecmp(a->argv[1], \"list\")) {\n\t\tast_cli(a->fd, \"MixMonitor ID\\tFile\\tReceive File\\tTransmit File\\n\");\n\t\tast_cli(a->fd, \"=========================================================================\\n\");\n\t\tast_channel_lock(chan);\n\t\tAST_LIST_TRAVERSE(ast_channel_datastores(chan), datastore, entry) {\n\t\t\tif (datastore->info == &mixmonitor_ds_info) {\n\t\t\t\tchar *filename = \"\";\n\t\t\t\tchar *filename_read = \"\";\n\t\t\t\tchar *filename_write = \"\";\n\t\t\t\tmixmonitor_ds = datastore->data;\n\t\t\t\tif (mixmonitor_ds->fs) {\n\t\t\t\t\tfilename = mixmonitor_ds->fs->filename;\n\t\t\t\t}\n\t\t\t\tif (mixmonitor_ds->fs_read) {\n\t\t\t\t\tfilename_read = mixmonitor_ds->fs_read->filename;\n\t\t\t\t}\n\t\t\t\tif (mixmonitor_ds->fs_write) {\n\t\t\t\t\tfilename_write = mixmonitor_ds->fs_write->filename;\n\t\t\t\t}\n\t\t\t\tast_cli(a->fd, \"%p\\t%s\\t%s\\t%s\\n\", mixmonitor_ds, filename, filename_read, filename_write);\n\t\t\t}\n\t\t}\n\t\tast_channel_unlock(chan);\n\t} else {\n\t\tchan = ast_channel_unref(chan);\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tchan = ast_channel_unref(chan);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2294}
{"project": "Asterisk", "target": 0, "func": "\nstatic void *ari_originate_dial(void *data)\n{\n\tstruct ast_dial *dial = data;\n\tstruct ari_origination *origination = ast_dial_get_user_data(dial);\n\tenum ast_dial_result res;\n\tres = ast_dial_run(dial, NULL, 0);\n\tif (res != AST_DIAL_RESULT_ANSWERED) {\n\t\tgoto end;\n\t}\n\tif (!ast_strlen_zero(origination->appdata)) {\n\t\tstruct ast_app *app = pbx_findapp(\"Stasis\");\n\t\tif (app) {\n\t\t\tast_verb(4, \"Launching Stasis(%s) on %s\\n\", origination->appdata,\n\t\t\t\tast_channel_name(ast_dial_answered(dial)));\n\t\t\tpbx_exec(ast_dial_answered(dial), app, origination->appdata);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"No such application 'Stasis'\\n\");\n\t\t}\n\t} else {\n\t\tstruct ast_channel *answered = ast_dial_answered(dial);\n\t\tif (!ast_strlen_zero(origination->context)) {\n\t\t\tast_channel_context_set(answered, origination->context);\n\t\t}\n\t\tif (!ast_strlen_zero(origination->exten)) {\n\t\t\tast_channel_exten_set(answered, origination->exten);\n\t\t}\n\t\tif (origination->priority > 0) {\n\t\t\tast_channel_priority_set(answered, origination->priority);\n\t\t}\n\t\tif (ast_pbx_run(answered)) {\n\t\t\tast_log(LOG_ERROR, \"Failed to start PBX on %s\\n\", ast_channel_name(answered));\n\t\t} else {\n\t\t\t\n\t\t\tast_dial_answered_steal(dial);\n\t\t}\n\t}\nend:\n\tast_dial_destroy(dial);\n\tast_free(origination);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2295}
{"project": "Asterisk", "target": 0, "func": " */\nint main()\n{\n\tint ret;\n\tatexit(finalize);\n\tsetlinebuf(stdin);\n\tsetlinebuf(stdout);\n\twinbuf=(char*)malloc(WINSIZE*WINBUF_NUM);\n\tend=winbuf+WINSIZE*WINBUF_NUM;\n\tbs=be=winbuf;\n\tspeech_desc=connect_to_host(\"localhost\",SIGNAL_PORT);\n\tif(speech_desc<0) \n\t{\n\t\tperror(\"signal socket\");\n\t\treturn -1;\n\t}\n\tcommand_desc=connect_to_host(\"localhost\",COMMAND_PORT);\n\tif(command_desc<0) \n\t{\n\t\tperror(\"command socket\");\n\t\treturn -1;\n\t}\n\tpthread_mutex_init(&command_mutex,NULL);\n\tpthread_create(&stdin_thread,NULL,readStdin,NULL);\n\tpthread_create(&signal_thread,NULL,readSignal,NULL);\n\twhile(connected)\n\t{\t\n\t\tpthread_mutex_lock(&command_mutex);\n\t\tret=read_some(command_desc,buf,BUFSIZE);\n\t\tpthread_mutex_unlock(&command_mutex);\n\t\tif(ret>0)\n\t\t{\n\t\t\tbuf[ret]=0;\n\t\t\tprintf(\"%s\",buf);\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2296}
{"project": "Asterisk", "target": 0, "func": "static void *auth_alloc(const char *name)\n{\n\tstruct ast_sip_auth *auth = ast_sorcery_generic_alloc(sizeof(*auth), auth_destroy);\n\tif (!auth) {\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(auth, 64)) {\n\t\tao2_cleanup(auth);\n\t\treturn NULL;\n\t}\n\treturn auth;\n}\n", "bug_type": null, "idx": 2297}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225_SeqOfH225CicInfo_cic_element (OOCTXT* pctxt, H225_SeqOfH225CicInfo_cic_element* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT xx1;\n   \n   stat = decodeLength (pctxt, &pvalue->n);\n   if (stat != ASN_OK) return stat;\n   \n   ALLOC_ASN1ARRAY (pctxt, pvalue, H225CicInfo_cic_element);\n   for (xx1 = 0; xx1 < pvalue->n; xx1++) {\n      invokeStartElement (pctxt, \"elem\", xx1);\n      stat = asn1PD_H225CicInfo_cic_element (pctxt, &pvalue->elem[xx1]);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"elem\", xx1);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2298}
{"project": "Asterisk", "target": 0, "func": "int ast_privacy_set(char *dest, char *cid, int status)\n{\n\tchar tmp[256] = \"\";\n\tchar *trimcid = \"\";\n\tchar *n, *l;\n\tint res;\n\tchar key[256];\n\tif (cid)\n\t\tast_copy_string(tmp, cid, sizeof(tmp));\n\tast_callerid_parse(tmp, &n, &l);\n\tif (l) {\n\t\tast_shrink_phone_number(l);\n\t\ttrimcid = l;\n\t}\n\tif (ast_strlen_zero(trimcid)) {\n\t\t\n\t\treturn 0;\n\t}\n\tsnprintf(key, sizeof(key), \"%s/%s\", dest, trimcid);\n\tif (status == AST_PRIVACY_UNKNOWN)\n\t\tres = ast_db_del(\"privacy\", key);\n\telse if (status == AST_PRIVACY_ALLOW)\n\t\tres = ast_db_put(\"privacy\", key, \"allow\");\n\telse if (status == AST_PRIVACY_DENY)\n\t\tres = ast_db_put(\"privacy\", key, \"deny\");\n\telse if (status == AST_PRIVACY_KILL)\n\t\tres = ast_db_put(\"privacy\", key, \"kill\");\n\telse if (status == AST_PRIVACY_TORTURE)\n\t\tres = ast_db_put(\"privacy\", key, \"torture\");\n\telse\n\t\tres = -1;\n\treturn res;\n}\n", "bug_type": null, "idx": 2299}
{"project": "Asterisk", "target": 0, "func": "static int analog_off_hook(struct analog_pvt *p)\n{\n\tif (analog_callbacks.off_hook) {\n\t\treturn analog_callbacks.off_hook(p->chan_pvt);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 2300}
{"project": "Asterisk", "target": 0, "func": "static int gsm_trunc(struct ast_filestream *fs)\n{\n\tint fd;\n\toff_t cur;\n\tif ((fd = fileno(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine file descriptor for gsm filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((cur = ftello(fs->f)) < 0) {\n\t\tast_log(AST_LOG_WARNING, \"Unable to determine current position in gsm filestream %p: %s\\n\", fs, strerror(errno));\n\t\treturn -1;\n\t}\n\t\n\treturn ftruncate(fd, cur);\n}\n", "bug_type": null, "idx": 2301}
{"project": "Asterisk", "target": 0, "func": "char *__ast_strndup(const char *s, size_t n, const char *file, int lineno, const char *func)\n{\n\tsize_t len;\n\tchar *ptr;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tlen = strnlen(s, n);\n\tif ((ptr = __ast_alloc_region(len + 1, FUNC_STRNDUP, file, lineno, func, 0))) {\n\t\tmemcpy(ptr, s, len);\n\t\tptr[len] = '\\0';\n\t}\n\treturn ptr;\n}\n", "bug_type": null, "idx": 2302}
{"project": "Asterisk", "target": 0, "func": "void db_start_batch(struct realtime_sqlite3_db *db)\n{\n\tif (db->batch) {\n\t\tast_cond_init(&db->cond, NULL);\n\t\tao2_ref(db, +1);\n\t\tast_pthread_create_background(&db->syncthread, NULL, db_sync_thread, db);\n\t}\n}\n", "bug_type": null, "idx": 2303}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_misdn_show_config(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tchar buffer[BUFFERSIZE];\n\tenum misdn_cfg_elements elem;\n\tint linebreak;\n\tint onlyport = -1;\n\tint ok = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"misdn show config\";\n\t\te->usage =\n\t\t\t\"Usage: misdn show config [<port> | description <config element> | descriptions [general|ports]]\\n\"\n\t\t\t\"       Use 0 for <port> to only print the general config.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn complete_show_config(a);\n\t}\n\tif (a->argc >= 4) {\n\t\tif (!strcmp(a->argv[3], \"description\")) {\n\t\t\tif (a->argc == 5) {\n\t\t\t\tenum misdn_cfg_elements elem = misdn_cfg_get_elem(a->argv[4]);\n\t\t\t\tif (elem == MISDN_CFG_FIRST) {\n\t\t\t\t\tast_cli(a->fd, \"Unknown element: %s\\n\", a->argv[4]);\n\t\t\t\t} else {\n\t\t\t\t\tshow_config_description(a->fd, elem);\n\t\t\t\t}\n\t\t\t\treturn CLI_SUCCESS;\n\t\t\t}\n\t\t\treturn CLI_SHOWUSAGE;\n\t\t} else if (!strcmp(a->argv[3], \"descriptions\")) {\n\t\t\tif ((a->argc == 4) || ((a->argc == 5) && !strcmp(a->argv[4], \"general\"))) {\n\t\t\t\tfor (elem = MISDN_GEN_FIRST + 1; elem < MISDN_GEN_LAST; ++elem) {\n\t\t\t\t\tshow_config_description(a->fd, elem);\n\t\t\t\t\tast_cli(a->fd, \"\\n\");\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif ((a->argc == 4) || ((a->argc == 5) && !strcmp(a->argv[4], \"ports\"))) {\n\t\t\t\tfor (elem = MISDN_CFG_FIRST + 1; elem < MISDN_CFG_LAST - 1 ; ++elem) {\n\t\t\t\t\tshow_config_description(a->fd, elem);\n\t\t\t\t\tast_cli(a->fd, \"\\n\");\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\treturn ok ? CLI_SUCCESS : CLI_SHOWUSAGE;\n\t\t} else if (!sscanf(a->argv[3], \"%5d\", &onlyport) || onlyport < 0) {\n\t\t\tast_cli(a->fd, \"Unknown option: %s\\n\", a->argv[3]);\n\t\t\treturn CLI_SHOWUSAGE;\n\t\t}\n\t}\n\tif (a->argc == 3 || onlyport == 0) {\n\t\tast_cli(a->fd, \"mISDN General-Config:\\n\");\n\t\tfor (elem = MISDN_GEN_FIRST + 1, linebreak = 1; elem < MISDN_GEN_LAST; elem++, linebreak++) {\n\t\t\tmisdn_cfg_get_config_string(0, elem, buffer, sizeof(buffer));\n\t\t\tast_cli(a->fd, \"%-36s%s\", buffer, !(linebreak % 2) ? \"\\n\" : \"\");\n\t\t}\n\t\tast_cli(a->fd, \"\\n\");\n\t}\n\tif (onlyport < 0) {\n\t\tint port = misdn_cfg_get_next_port(0);\n\t\tfor (; port > 0; port = misdn_cfg_get_next_port(port)) {\n\t\t\tast_cli(a->fd, \"\\n[PORT %d]\\n\", port);\n\t\t\tfor (elem = MISDN_CFG_FIRST + 1, linebreak = 1; elem < MISDN_CFG_LAST; elem++, linebreak++) {\n\t\t\t\tmisdn_cfg_get_config_string(port, elem, buffer, sizeof(buffer));\n\t\t\t\tast_cli(a->fd, \"%-36s%s\", buffer, !(linebreak % 2) ? \"\\n\" : \"\");\n\t\t\t}\n\t\t\tast_cli(a->fd, \"\\n\");\n\t\t}\n\t}\n\tif (onlyport > 0) {\n\t\tif (misdn_cfg_is_port_valid(onlyport)) {\n\t\t\tast_cli(a->fd, \"[PORT %d]\\n\", onlyport);\n\t\t\tfor (elem = MISDN_CFG_FIRST + 1, linebreak = 1; elem < MISDN_CFG_LAST; elem++, linebreak++) {\n\t\t\t\tmisdn_cfg_get_config_string(onlyport, elem, buffer, sizeof(buffer));\n\t\t\t\tast_cli(a->fd, \"%-36s%s\", buffer, !(linebreak % 2) ? \"\\n\" : \"\");\n\t\t\t}\n\t\t\tast_cli(a->fd, \"\\n\");\n\t\t} else {\n\t\t\tast_cli(a->fd, \"Port %d is not active!\\n\", onlyport);\n\t\t}\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2304}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void hook_thread_arg_destroy(struct hook_thread_arg *arg)\n{\n\tast_free(arg->hook_id);\n\tast_free(arg->chan_name);\n\tast_free(arg->context);\n\tast_free(arg->exten);\n\tast_free(arg);\n}\n", "bug_type": null, "idx": 2305}
{"project": "Asterisk", "target": 0, "func": "static void *notify_option_alloc(const char *category)\n{\n\tint category_size = strlen(category) + 1;\n\tstruct notify_option *option = ao2_alloc(\n\t\tsizeof(*option) + category_size, notify_option_destroy);\n\tif (!option) {\n\t\treturn NULL;\n\t}\n\tast_copy_string(option->name, category, category_size);\n\tif (!(option->items = ao2_container_alloc_list(\n\t\t      AO2_ALLOC_OPT_LOCK_NOLOCK,\n\t\t      AO2_CONTAINER_ALLOC_OPT_DUPS_ALLOW, NULL, NULL))) {\n\t\tao2_cleanup(option);\n\t\treturn NULL;\n\t}\n\treturn option;\n}\n", "bug_type": null, "idx": 2306}
{"project": "Asterisk", "target": 0, "func": "char *parsefilearg( int argcount, char *args[])\n{\n  int i;\n  char *result = NULL;\n   for (i = 1; i < argcount; i++)\n   {\n      if (args[i][0] != '\\0' &&\n\t  (!isoptionchar (args[i][0]) || args[i][1] == '\\0' ))\n      {\n\t\n\tresult = malloc( strlen( args[i]) + 1);\n\tif (result == NULL)\n\t    fatalperror( \"Couldn't allocate memory for filename\\n\");\n\tstrcpy( result, args[i]);\n\targs[i][0] = '\\0';                    \n\tbreak;\n      }\n   }\n   return result;\n}\n", "bug_type": null, "idx": 2307}
{"project": "Asterisk", "target": 0, "func": "static AST_RWLIST_HEAD_STATIC(switches, ast_switch);\nstruct ast_switch *pbx_findswitch(const char *sw)\n{\n\tstruct ast_switch *asw;\n\tAST_RWLIST_RDLOCK(&switches);\n\tAST_RWLIST_TRAVERSE(&switches, asw, list) {\n\t\tif (!strcasecmp(asw->name, sw))\n\t\t\tbreak;\n\t}\n\tAST_RWLIST_UNLOCK(&switches);\n\treturn asw;\n}\n", "bug_type": null, "idx": 2308}
{"project": "Asterisk", "target": 0, "func": "static void clear_unanswered_calls(struct findme_user_listptr *findme_user_list) \n{\n\tstruct findme_user *tmpuser;\n\tAST_LIST_TRAVERSE(findme_user_list, tmpuser, entry) {\n\t\tif (!tmpuser->answered) {\n\t\t\tclear_caller(tmpuser);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2309}
{"project": "Asterisk", "target": 0, "func": "static int cc_generic_agent_stop_ringing(struct ast_cc_agent *agent)\n{\n\tstruct ast_channel *recall_chan = ast_channel_get_by_name_prefix(agent->device_name, strlen(agent->device_name));\n\tif (!recall_chan) {\n\t\treturn 0;\n\t}\n\tast_softhangup(recall_chan, AST_SOFTHANGUP_EXPLICIT);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2310}
{"project": "Asterisk", "target": 0, "func": "static int custom_log(struct ast_cdr *cdr)\n{\n\tstruct ast_channel *dummy;\n\tstruct ast_str *str;\n\tstruct cdr_custom_config *config;\n\t\n\tif (!(str = ast_str_thread_get(&custom_buf, 16))) {\n\t\treturn -1;\n\t}\n\tdummy = ast_dummy_channel_alloc();\n\tif (!dummy) {\n\t\tast_log(LOG_ERROR, \"Unable to allocate channel for variable subsitution.\\n\");\n\t\treturn -1;\n\t}\n\t\n\tast_channel_cdr_set(dummy, ast_cdr_dup(cdr));\n\tAST_RWLIST_RDLOCK(&sinks);\n\tAST_LIST_TRAVERSE(&sinks, config, list) {\n\t\tFILE *out;\n\t\tast_str_substitute_variables(&str, 0, dummy, config->format);\n\t\t\n\t\tast_mutex_lock(&config->lock);\n\t\t\n\t\tif ((out = fopen(config->filename, \"a\"))) {\n\t\t\tfputs(ast_str_buffer(str), out);\n\t\t\tfflush(out); \n\t\t\tfclose(out);\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Unable to re-open master file %s : %s\\n\", config->filename, strerror(errno));\n\t\t}\n\t\tast_mutex_unlock(&config->lock);\n\t}\n\tAST_RWLIST_UNLOCK(&sinks);\n\tast_channel_unref(dummy);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2311}
{"project": "Asterisk", "target": 0, "func": "static u_char *ast_var_indications(struct variable *vp, oid *name, size_t *length,\n\t\t\t\t\t\t\t\t  int exact, size_t *var_len, WriteMethod **write_method)\n{\n\tstatic unsigned long long_ret;\n\tstatic char ret_buf[128];\n\tstruct ast_tone_zone *tz = NULL;\n\tif (header_generic(vp, name, length, exact, var_len, write_method))\n\t\treturn NULL;\n\tswitch (vp->magic) {\n\tcase ASTINDCOUNT:\n\t{\n\t\tstruct ao2_iterator i;\n\t\tlong_ret = 0;\n\t\ti = ast_tone_zone_iterator_init();\n\t\twhile ((tz = ao2_iterator_next(&i))) {\n\t\t\ttz = ast_tone_zone_unref(tz);\n\t\t\tlong_ret++;\n\t\t}\n\t\tao2_iterator_destroy(&i);\n\t\treturn (u_char *) &long_ret;\n\t}\n\tcase ASTINDCURRENT:\n\t\ttz = ast_get_indication_zone(NULL);\n\t\tif (tz) {\n\t\t\tast_copy_string(ret_buf, tz->country, sizeof(ret_buf));\n\t\t\t*var_len = strlen(ret_buf);\n\t\t\ttz = ast_tone_zone_unref(tz);\n\t\t\treturn (u_char *) ret_buf;\n\t\t}\n\t\t*var_len = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2312}
{"project": "Asterisk", "target": 0, "func": "#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\treturn n;\n}\n", "bug_type": null, "idx": 2313}
{"project": "Asterisk", "target": 0, "func": "\nstatic int conf_exec(struct ast_channel *chan, const char *data)\n{\n\tint res = -1;\n\tchar confno[MAX_CONFNUM] = \"\";\n\tint allowretry = 0;\n\tint retrycnt = 0;\n\tstruct ast_conference *cnf = NULL;\n\tstruct ast_flags64 confflags = {0};\n\tstruct ast_flags config_flags = { 0 };\n\tint dynamic = 0;\n\tint empty = 0, empty_no_pin = 0;\n\tint always_prompt = 0;\n\tconst char *notdata;\n\tchar *info, the_pin[MAX_PIN] = \"\";\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(confno);\n\t\tAST_APP_ARG(options);\n\t\tAST_APP_ARG(pin);\n\t);\n\tchar *optargs[OPT_ARG_ARRAY_SIZE] = { NULL, };\n\tif (ast_strlen_zero(data)) {\n\t\tallowretry = 1;\n\t\tnotdata = \"\";\n\t} else {\n\t\tnotdata = data;\n\t}\n\tif (ast_channel_state(chan) != AST_STATE_UP)\n\t\tast_answer(chan);\n\tinfo = ast_strdupa(notdata);\n\tAST_STANDARD_APP_ARGS(args, info);\t\n\tif (args.confno) {\n\t\tast_copy_string(confno, args.confno, sizeof(confno));\n\t\tif (ast_strlen_zero(confno)) {\n\t\t\tallowretry = 1;\n\t\t}\n\t}\n\tif (args.pin)\n\t\tast_copy_string(the_pin, args.pin, sizeof(the_pin));\n\tif (args.options) {\n\t\tast_app_parse_options64(meetme_opts, &confflags, optargs, args.options);\n\t\tdynamic = ast_test_flag64(&confflags, CONFFLAG_DYNAMIC | CONFFLAG_DYNAMICPIN);\n\t\tif (ast_test_flag64(&confflags, CONFFLAG_DYNAMICPIN) && ast_strlen_zero(args.pin))\n\t\t\tstrcpy(the_pin, \"q\");\n\t\tempty = ast_test_flag64(&confflags, CONFFLAG_EMPTY | CONFFLAG_EMPTYNOPIN);\n\t\tempty_no_pin = ast_test_flag64(&confflags, CONFFLAG_EMPTYNOPIN);\n\t\talways_prompt = ast_test_flag64(&confflags, CONFFLAG_ALWAYSPROMPT | CONFFLAG_DYNAMICPIN);\n\t}\n\tdo {\n\t\tif (retrycnt > 3)\n\t\t\tallowretry = 0;\n\t\tif (empty) {\n\t\t\tint i;\n\t\t\tstruct ast_config *cfg;\n\t\t\tstruct ast_variable *var;\n\t\t\tint confno_int;\n\t\t\t\n\t\t\tif ((empty_no_pin) || (!dynamic)) {\n\t\t\t\tcfg = ast_config_load(CONFIG_FILE_NAME, config_flags);\n\t\t\t\tif (cfg && cfg != CONFIG_STATUS_FILEINVALID) {\n\t\t\t\t\tvar = ast_variable_browse(cfg, \"rooms\");\n\t\t\t\t\twhile (var) {\n\t\t\t\t\t\tchar parse[MAX_SETTINGS], *stringp = parse, *confno_tmp;\n\t\t\t\t\t\tif (!strcasecmp(var->name, \"conf\")) {\n\t\t\t\t\t\t\tint found = 0;\n\t\t\t\t\t\t\tast_copy_string(parse, var->value, sizeof(parse));\n\t\t\t\t\t\t\tconfno_tmp = strsep(&stringp, \"|,\");\n\t\t\t\t\t\t\tif (!dynamic) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tAST_LIST_LOCK(&confs);\n\t\t\t\t\t\t\t\tAST_LIST_TRAVERSE(&confs, cnf, list) {\n\t\t\t\t\t\t\t\t\tif (!strcmp(confno_tmp, cnf->confno)) {\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tAST_LIST_UNLOCK(&confs);\n\t\t\t\t\t\t\t\tcnf = NULL;\n\t\t\t\t\t\t\t\tif (!found) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif ((empty_no_pin && ast_strlen_zero(stringp)) || (!empty_no_pin)) {\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tast_copy_string(confno, confno_tmp, sizeof(confno));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar = var->next;\n\t\t\t\t\t}\n\t\t\t\t\tast_config_destroy(cfg);\n\t\t\t\t}\n\t\t\t\tif (ast_strlen_zero(confno) && (cfg = ast_load_realtime_multientry(\"meetme\", \"confno LIKE\", \"%\", SENTINEL))) {\n\t\t\t\t\tconst char *catg;\n\t\t\t\t\tfor (catg = ast_category_browse(cfg, NULL); catg; catg = ast_category_browse(cfg, catg)) {\n\t\t\t\t\t\tconst char *confno_tmp = ast_variable_retrieve(cfg, catg, \"confno\");\n\t\t\t\t\t\tconst char *pin_tmp = ast_variable_retrieve(cfg, catg, \"pin\");\n\t\t\t\t\t\tif (ast_strlen_zero(confno_tmp)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dynamic) {\n\t\t\t\t\t\t\tint found = 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tAST_LIST_LOCK(&confs);\n\t\t\t\t\t\t\tAST_LIST_TRAVERSE(&confs, cnf, list) {\n\t\t\t\t\t\t\t\tif (!strcmp(confno_tmp, cnf->confno)) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAST_LIST_UNLOCK(&confs);\n\t\t\t\t\t\t\tif (!found) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((empty_no_pin && ast_strlen_zero(pin_tmp)) || (!empty_no_pin)) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tast_copy_string(confno, confno_tmp, sizeof(confno));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tast_config_destroy(cfg);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ast_strlen_zero(confno) && dynamic) {\n\t\t\t\tAST_LIST_LOCK(&confs);\n\t\t\t\tfor (i = 0; i < ARRAY_LEN(conf_map); i++) {\n\t\t\t\t\tif (!conf_map[i]) {\n\t\t\t\t\t\tsnprintf(confno, sizeof(confno), \"%d\", i);\n\t\t\t\t\t\tconf_map[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAST_LIST_UNLOCK(&confs);\n\t\t\t}\n\t\t\t\n\t\t\tif (ast_strlen_zero(confno)) {\n\t\t\t\tres = ast_streamfile(chan, \"conf-noempty\", ast_channel_language(chan));\n\t\t\t\tast_test_suite_event_notify(\"PLAYBACK\", \"Message: conf-noempty\");\n\t\t\t\tif (!res)\n\t\t\t\t\tast_waitstream(chan, \"\");\n\t\t\t} else {\n\t\t\t\tif (sscanf(confno, \"%30d\", &confno_int) == 1) {\n\t\t\t\t\tif (!ast_test_flag64(&confflags, CONFFLAG_QUIET)) {\n\t\t\t\t\t\tres = ast_streamfile(chan, \"conf-enteringno\", ast_channel_language(chan));\n\t\t\t\t\t\tif (!res) {\n\t\t\t\t\t\t\tast_waitstream(chan, \"\");\n\t\t\t\t\t\t\tres = ast_say_digits(chan, confno_int, \"\", ast_channel_language(chan));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tast_log(LOG_ERROR, \"Could not scan confno '%s'\\n\", confno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (allowretry && (ast_strlen_zero(confno)) && (++retrycnt < 4)) {\n\t\t\t\n\t\t\tres = ast_app_getdata(chan, \"conf-getconfno\", confno, sizeof(confno) - 1, 0);\n\t\t\tif (res < 0) {\n\t\t\t\t\n\t\t\t\tconfno[0] = '\\0';\n\t\t\t\tallowretry = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ast_strlen_zero(confno)) {\n\t\t\t\n\t\t\tcnf = find_conf(chan, confno, 1, dynamic, the_pin, \n\t\t\t\tsizeof(the_pin), 1, &confflags);\n\t\t\tif (!cnf) {\n\t\t\t\tint too_early = 0;\n\t\t\t\tcnf = find_conf_realtime(chan, confno, 1, dynamic, \n\t\t\t\t\tthe_pin, sizeof(the_pin), 1, &confflags, &too_early, optargs);\n\t\t\t\tif (rt_schedule && too_early)\n\t\t\t\t\tallowretry = 0;\n\t\t\t}\n\t\t\tif (!cnf) {\n\t\t\t\tif (allowretry) {\n\t\t\t\t\tconfno[0] = '\\0';\n\t\t\t\t\tres = ast_streamfile(chan, \"conf-invalid\", ast_channel_language(chan));\n\t\t\t\t\tif (!res)\n\t\t\t\t\t\tast_waitstream(chan, \"\");\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tint req_pin = !ast_strlen_zero(cnf->pin) ||\n\t\t\t\t\t(!ast_strlen_zero(cnf->pinadmin) &&\n\t\t\t\t\t\tast_test_flag64(&confflags, CONFFLAG_ADMIN));\n\t\t\t\t\n\t\t\t\tint not_exempt = !cnf->isdynamic;\n\t\t\t\tnot_exempt = not_exempt || (!ast_strlen_zero(args.pin) && ast_test_flag64(&confflags, CONFFLAG_ALWAYSPROMPT));\n\t\t\t\tnot_exempt = not_exempt || (ast_strlen_zero(args.pin) && cnf->users);\n\t\t\t\tif (req_pin && not_exempt) {\n\t\t\t\t\tchar pin[MAX_PIN] = \"\";\n\t\t\t\t\tint j;\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (*the_pin && (always_prompt == 0)) {\n\t\t\t\t\t\t\tast_copy_string(pin, the_pin, sizeof(pin));\n\t\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tast_test_suite_event_notify(\"PLAYBACK\", \"Message: conf-getpin\\r\\n\"\n\t\t\t\t\t\t\t\t\"Channel: %s\",\n\t\t\t\t\t\t\t\tast_channel_name(chan));\n\t\t\t\t\t\t\tres = ast_app_getdata(chan, \"conf-getpin\", pin + strlen(pin), sizeof(pin) - 1 - strlen(pin), 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (res >= 0) {\n\t\t\t\t\t\t\tif ((!strcasecmp(pin, cnf->pin) &&\n\t\t\t\t\t\t\t     (ast_strlen_zero(cnf->pinadmin) ||\n\t\t\t\t\t\t\t      !ast_test_flag64(&confflags, CONFFLAG_ADMIN))) ||\n\t\t\t\t\t\t\t     (!ast_strlen_zero(cnf->pinadmin) &&\n\t\t\t\t\t\t\t      !strcasecmp(pin, cnf->pinadmin))) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tallowretry = 0;\n\t\t\t\t\t\t\t\tif (!ast_strlen_zero(cnf->pinadmin) && !strcasecmp(pin, cnf->pinadmin)) {\n\t\t\t\t\t\t\t\t\tif (!ast_strlen_zero(cnf->adminopts)) {\n\t\t\t\t\t\t\t\t\t\tchar *opts = ast_strdupa(cnf->adminopts);\n\t\t\t\t\t\t\t\t\t\tast_app_parse_options64(meetme_opts, &confflags, optargs, opts);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (!ast_strlen_zero(cnf->useropts)) {\n\t\t\t\t\t\t\t\t\t\tchar *opts = ast_strdupa(cnf->useropts);\n\t\t\t\t\t\t\t\t\t\tast_app_parse_options64(meetme_opts, &confflags, optargs, opts);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tast_verb(4, \"Starting recording of MeetMe Conference %s into file %s.%s.\\n\", cnf->confno, cnf->recordingfilename, cnf->recordingformat);\n\t\t\t\t\t\t\t\tres = conf_run(chan, cnf, &confflags, optargs);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (!ast_streamfile(chan, \"conf-invalidpin\", ast_channel_language(chan))) {\n\t\t\t\t\t\t\t\t\tres = ast_waitstream(chan, AST_DIGIT_ANY);\n\t\t\t\t\t\t\t\t\tast_stopstream(chan);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tast_log(LOG_WARNING, \"Couldn't play invalid pin msg!\\n\");\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (res < 0)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tpin[0] = res;\n\t\t\t\t\t\t\t\tpin[1] = '\\0';\n\t\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\t\t\tif (allowretry)\n\t\t\t\t\t\t\t\t\tconfno[0] = '\\0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\t\tallowretry = 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (*the_pin && (always_prompt == 0)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tallowretry = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (!ast_strlen_zero(cnf->useropts)) {\n\t\t\t\t\t\tchar *opts = ast_strdupa(cnf->useropts);\n\t\t\t\t\t\tast_app_parse_options64(meetme_opts, &confflags, optargs, opts);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tres = conf_run(chan, cnf, &confflags, optargs);\n\t\t\t\t}\n\t\t\t\tdispose_conf(cnf);\n\t\t\t\tcnf = NULL;\n\t\t\t}\n\t\t}\n\t} while (allowretry);\n\tif (cnf)\n\t\tdispose_conf(cnf);\n\treturn res;\n}\n", "bug_type": null, "idx": 2314}
{"project": "Asterisk", "target": 0, "func": "static int test_law_clone(const struct ast_format *src, struct ast_format *dst)\n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 2315}
{"project": "Asterisk", "target": 0, "func": "int ooh323c_set_aliases(ooAliases * aliases);\nvoid* ooh323c_stack_thread(void* dummy)\n{\n  ooMonitorChannels();\n  return dummy;\n}\n", "bug_type": null, "idx": 2316}
{"project": "Asterisk", "target": 0, "func": "static struct sig_ss7_chan *ss7_find_pvt(struct ss7 *ss7, int cic, unsigned int dpc)\n{\n\tint chanpos;\n\tstruct sig_ss7_linkset *winner;\n\twinner = sig_ss7_find_linkset(ss7);\n\tif (winner && (chanpos = sig_ss7_find_cic(winner, cic, dpc)) > -1) {\n\t\treturn winner->pvts[chanpos];\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2317}
{"project": "Asterisk", "target": 0, "func": "static void build_main_menu()\n{\n\tstruct category *cat;\n\tchar buf[64];\n\tint i = 1;\n\tnewtListboxClear(rootOptions);\n\tAST_LIST_TRAVERSE(&categories, cat, list) {\n\t\tif (!strlen_zero(cat->displayname))\n\t\t\tsnprintf(buf, sizeof(buf), \" %s \", cat->displayname);\n\t\telse\n\t\t\tsnprintf(buf, sizeof(buf), \" %s \", cat->name);\n\t\tnewtListboxAppendEntry(rootOptions, buf, cat);\n\t\ti++;\n\t}\n}\n", "bug_type": null, "idx": 2318}
{"project": "Asterisk", "target": 0, "func": "void pvalVarDecSetVarname( pval *p, char *name )\n{\n\tif (!pvalCheckType(p, \"pvalVarDecSetVarname\", PV_VARDEC))\n\t\treturn;\n\tp->u1.str = name;\n}\n", "bug_type": null, "idx": 2319}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void mark_all_as_stale_in_cache(struct sorcery_memory_cache *cache)\n{\n\tao2_callback(cache->objects, OBJ_NOLOCK | OBJ_NODATA | OBJ_MULTIPLE, object_stale_callback, cache);\n}\n", "bug_type": null, "idx": 2320}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int pri_find_principle_by_call(struct sig_pri_span *pri, q931_call *call)\n{\n\tint idx;\n\tif (!call) {\n\t\t\n\t\treturn -1;\n\t}\n\tfor (idx = 0; idx < pri->numchans; ++idx) {\n\t\tif (pri->pvts[idx] && pri->pvts[idx]->call == call) {\n\t\t\t\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 2321}
{"project": "Asterisk", "target": 0, "func": "int ast_stream_topology_append_stream(struct ast_stream_topology *topology, struct ast_stream *stream)\n{\n\tast_assert(topology && stream);\n\tif (AST_VECTOR_APPEND(&topology->streams, stream)) {\n\t\treturn -1;\n\t}\n\tstream->position = AST_VECTOR_SIZE(&topology->streams) - 1;\n\treturn AST_VECTOR_SIZE(&topology->streams) - 1;\n}\n", "bug_type": null, "idx": 2322}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225SecurityServiceMode (OOCTXT* pctxt, H225SecurityServiceMode* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 3);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 2);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = asn1PE_H225NonStandardParameter (pctxt, pvalue->u.nonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            \n            break;\n         \n         case 3:\n            \n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 4);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2323}
{"project": "Asterisk", "target": 0, "func": "static int killer(pid_t pid, int signum, enum kill_methods kill_method)\n{\n\tswitch (kill_method) {\n\tcase KILL_METHOD_PROCESS_GROUP:\n\t\treturn killpg(pid, signum);\n\tcase KILL_METHOD_PROCESS:\n\t\treturn kill(pid, signum);\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 2324}
{"project": "Asterisk", "target": 0, "func": "\nint ast_speech_change_state(struct ast_speech *speech, int state)\n{\n\tint res = 0;\n\tswitch (state) {\n\tcase AST_SPEECH_STATE_WAIT:\n\t\t\n\t\tast_set_flag(speech, AST_SPEECH_SPOKE);\n\tdefault:\n\t\tspeech->state = state;\n\t\tbreak;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2325}
{"project": "Asterisk", "target": 0, "func": "static void *do_monitor_headset(void *data)\n{\n\tstruct mbl_pvt *pvt = (struct mbl_pvt *)data;\n\tchar buf[256];\n\tint t;\n\tat_message_t at_msg;\n\tstruct ast_channel *chan = NULL;\n\tast_verb(3, \"Bluetooth Device %s initialised and ready.\\n\", pvt->id);\n\twhile (!check_unloading()) {\n\t\tt = ast_sched_wait(pvt->sched);\n\t\tif (t == -1) {\n\t\t\tt = 6000;\n\t\t}\n\t\tast_sched_runq(pvt->sched);\n\t\tif (rfcomm_wait(pvt->rfcomm_socket, &t) == 0)\n\t\t\tcontinue;\n\t\tif ((at_msg = at_read_full(pvt->rfcomm_socket, buf, sizeof(buf))) < 0) {\n\t\t\tast_debug(1, \"[%s] error reading from device: %s (%d)\\n\", pvt->id, strerror(errno), errno);\n\t\t\tgoto e_cleanup;\n\t\t}\n\t\tast_debug(1, \"[%s] %s\\n\", pvt->id, buf);\n\t\tswitch (at_msg) {\n\t\tcase AT_VGS:\n\t\tcase AT_VGM:\n\t\t\t\n\t\t\tif (hsp_send_ok(pvt->rfcomm_socket)) {\n\t\t\t\tast_debug(1, \"[%s] error sending AT message 'OK'\\n\", pvt->id);\n\t\t\t\tgoto e_cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AT_CKPD:\n\t\t\tast_mutex_lock(&pvt->lock);\n\t\t\tif (pvt->outgoing) {\n\t\t\t\tpvt->needring = 0;\n\t\t\t\thsp_send_ok(pvt->rfcomm_socket);\n\t\t\t\tif (pvt->answered) {\n\t\t\t\t\t\n\t\t\t\t\tmbl_queue_hangup(pvt);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tif ((pvt->sco_socket = sco_connect(pvt->adapter->addr, pvt->addr)) == -1) {\n\t\t\t\t\t\tast_log(LOG_ERROR, \"[%s] unable to create audio connection\\n\", pvt->id);\n\t\t\t\t\t\tmbl_queue_hangup(pvt);\n\t\t\t\t\t\tast_mutex_unlock(&pvt->lock);\n\t\t\t\t\t\tgoto e_cleanup;\n\t\t\t\t\t}\n\t\t\t\t\tast_channel_set_fd(pvt->owner, 0, pvt->sco_socket);\n\t\t\t\t\tmbl_queue_control(pvt, AST_CONTROL_ANSWER);\n\t\t\t\t\tpvt->answered = 1;\n\t\t\t\t\tif (hsp_send_vgs(pvt->rfcomm_socket, 13) || hsp_send_vgm(pvt->rfcomm_socket, 13)) {\n\t\t\t\t\t\tast_debug(1, \"[%s] error sending VGS/VGM\\n\", pvt->id);\n\t\t\t\t\t\tmbl_queue_hangup(pvt);\n\t\t\t\t\t\tast_mutex_unlock(&pvt->lock);\n\t\t\t\t\t\tgoto e_cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (pvt->incoming) {\n\t\t\t\t\n\t\t\t\tmbl_queue_hangup(pvt);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\thsp_send_ok(pvt->rfcomm_socket);\n\t\t\t\tif ((pvt->sco_socket = sco_connect(pvt->adapter->addr, pvt->addr)) == -1) {\n\t\t\t\t\tast_log(LOG_ERROR, \"[%s] unable to create audio connection\\n\", pvt->id);\n\t\t\t\t\tast_mutex_unlock(&pvt->lock);\n\t\t\t\t\tgoto e_cleanup;\n\t\t\t\t}\n\t\t\t\tpvt->incoming = 1;\n\t\t\t\tif (!(chan = mbl_new(AST_STATE_UP, pvt, NULL, NULL, NULL))) {\n\t\t\t\t\tast_log(LOG_ERROR, \"[%s] unable to allocate channel for incoming call\\n\", pvt->id);\n\t\t\t\t\tast_mutex_unlock(&pvt->lock);\n\t\t\t\t\tgoto e_cleanup;\n\t\t\t\t}\n\t\t\t\tast_channel_set_fd(chan, 0, pvt->sco_socket);\n\t\t\t\tast_channel_exten_set(chan, \"s\");\n\t\t\t\tif (ast_pbx_start(chan)) {\n\t\t\t\t\tast_log(LOG_ERROR, \"[%s] unable to start pbx on incoming call\\n\", pvt->id);\n\t\t\t\t\tast_hangup(chan);\n\t\t\t\t\tast_mutex_unlock(&pvt->lock);\n\t\t\t\t\tgoto e_cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&pvt->lock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_debug(1, \"[%s] received unknown AT command: %s (%s)\\n\", pvt->id, buf, at_msg2str(at_msg));\n\t\t\tif (hsp_send_error(pvt->rfcomm_socket)) {\n\t\t\t\tast_debug(1, \"[%s] error sending AT message 'ERROR'\\n\", pvt->id);\n\t\t\t\tgoto e_cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\ne_cleanup:\n\tast_mutex_lock(&pvt->lock);\n\tif (pvt->owner) {\n\t\tast_debug(1, \"[%s] device disconnected, hanging up owner\\n\", pvt->id);\n\t\tmbl_queue_hangup(pvt);\n\t}\n\tclose(pvt->rfcomm_socket);\n\tclose(pvt->sco_socket);\n\tpvt->sco_socket = -1;\n\tpvt->connected = 0;\n\tpvt->needring = 0;\n\tpvt->outgoing = 0;\n\tpvt->incoming = 0;\n\tpvt->adapter->inuse = 0;\n\tast_mutex_unlock(&pvt->lock);\n\tmanager_event(EVENT_FLAG_SYSTEM, \"MobileStatus\", \"Status: Disconnect\\r\\nDevice: %s\\r\\n\", pvt->id);\n\tast_verb(3, \"Bluetooth Device %s has disconnected\\n\", pvt->id);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2326}
{"project": "Asterisk", "target": 0, "func": "static int start_moh_exec(struct ast_channel *chan, const char *data)\n{\n\tchar *parse;\n\tchar *class;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(class);\n\t);\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tclass = S_OR(args.class, NULL);\n\tif (ast_moh_start(chan, class, NULL)) \n\t\tast_log(LOG_WARNING, \"Unable to start music on hold class '%s' on channel %s\\n\", class, ast_channel_name(chan));\n\treturn 0;\n}\n", "bug_type": null, "idx": 2327}
{"project": "Asterisk", "target": 0, "func": "static int copy_menu_entry(struct conf_menu_entry *dst, struct conf_menu_entry *src)\n{\n\tstruct conf_menu_action *menu_action;\n\tstruct conf_menu_action *new_menu_action;\n\tast_copy_string(dst->dtmf, src->dtmf, sizeof(dst->dtmf));\n\tAST_LIST_HEAD_INIT_NOLOCK(&dst->actions);\n\tAST_LIST_TRAVERSE(&src->actions, menu_action, action) {\n\t\tif (!(new_menu_action = ast_calloc(1, sizeof(*new_menu_action)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(new_menu_action, menu_action, sizeof(*new_menu_action));\n\t\tAST_LIST_NEXT(new_menu_action, action) = NULL;\n\t\tAST_LIST_INSERT_TAIL(&dst->actions, new_menu_action, action);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2328}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void call_destructor_with_no_monitor(const char * const monitor_type, void *private_data)\n{\n\tconst struct ast_cc_monitor_callbacks *monitor_callbacks = find_monitor_callbacks(monitor_type);\n\tif (!monitor_callbacks) {\n\t\treturn;\n\t}\n\tmonitor_callbacks->destructor(private_data);\n}\n", "bug_type": null, "idx": 2329}
{"project": "Asterisk", "target": 0, "func": "int load_parking_devstate(void)\n{\n\treturn ast_devstate_prov_add(\"Park\", metermaidstate);\n}\n", "bug_type": null, "idx": 2330}
{"project": "Asterisk", "target": 0, "func": "\nstatic int parked_call_app_exec(struct ast_channel *chan, const char *data)\n{\n\tRAII_VAR(struct parking_lot *, lot, NULL, ao2_cleanup);\n\tRAII_VAR(struct parked_user *, pu, NULL, ao2_cleanup); \n\tstruct ast_bridge *retrieval_bridge;\n\tint res;\n\tint target_space = -1;\n\tstruct ast_bridge_features chan_features;\n\tchar *parse;\n\tconst char *lot_name;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(lot_name);\n\t\tAST_APP_ARG(parking_space);\n\t\tAST_APP_ARG(other);\t\n\t);\n\tparse = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\t\n\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\tast_answer(chan);\n\t}\n\tlot_name = args.lot_name;\n\t\n\tif (ast_strlen_zero(lot_name)) {\n\t\tast_channel_lock(chan);\n\t\tlot_name = ast_strdupa(find_channel_parking_lot_name(chan));\n\t\tast_channel_unlock(chan);\n\t}\n\tlot = parking_lot_find_by_name(lot_name);\n\tif (!lot) {\n\t\tast_log(LOG_ERROR, \"Could not find the requested parking lot\\n\");\n\t\tast_stream_and_wait(chan, \"pbx-invalidpark\", \"\");\n\t\treturn -1;\n\t}\n\tif (!ast_strlen_zero(args.parking_space)) {\n\t\tif (sscanf(args.parking_space, \"%d\", &target_space) != 1 || target_space < 0) {\n\t\t\tast_stream_and_wait(chan, \"pbx-invalidpark\", \"\");\n\t\t\tast_log(LOG_ERROR, \"value '%s' for parking_space argument is invalid. Must be an integer greater than 0.\\n\", args.parking_space);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tpu = parking_lot_retrieve_parked_user(lot, target_space);\n\tif (!pu) {\n\t\tast_stream_and_wait(chan, \"pbx-invalidpark\", \"\");\n\t\treturn -1;\n\t}\n\t\n\tast_assert(pu->retriever == NULL);\n\tpu->retriever = ast_channel_snapshot_create(chan);\n\t\n\tretrieval_bridge = ast_bridge_basic_new();\n\tif (!retrieval_bridge) {\n\t\treturn -1;\n\t}\n\t\n\tif (ast_bridge_move(retrieval_bridge, lot->parking_bridge, pu->chan, NULL, 0)) {\n\t\tast_bridge_destroy(retrieval_bridge, 0);\n\t\treturn -1;\n\t}\n\t\n\tres = ast_bridge_features_init(&chan_features);\n\tif (res) {\n\t\tast_bridge_destroy(retrieval_bridge, 0);\n\t\tast_bridge_features_cleanup(&chan_features);\n\t\treturn -1;\n\t}\n\t\n\tparked_call_retrieve_enable_features(chan, lot, AST_FEATURE_FLAG_BYCALLER);\n\t\n\tif (lot->cfg->parkedplay & AST_FEATURE_FLAG_BYCALLER) {\n\t\tast_stream_and_wait(chan, lot->cfg->courtesytone, NULL);\n\t}\n\t\n\tast_bridge_join(retrieval_bridge, chan, NULL, &chan_features, NULL,\n\t\tAST_BRIDGE_JOIN_PASS_REFERENCE);\n\tast_bridge_features_cleanup(&chan_features);\n\t\n\treturn -1;\n}\n", "bug_type": null, "idx": 2331}
{"project": "Asterisk", "target": 0, "func": "static const char *mstime(time_t t, char *buf, size_t buflen)\n{\n\tstruct timeval tv = {\n\t\t.tv_sec = t,\n\t};\n\tstruct ast_tm tm;\n\tast_localtime(&tv, &tm, \"utc\");\n\tast_strftime(buf, buflen, \"%FT%TZ\", &tm);\n\treturn S_OR(buf, \"\");\n}\n", "bug_type": null, "idx": 2332}
{"project": "Asterisk", "target": 0, "func": " * \\return -1 on error 0 on sucess*/\nstatic int spandsp_fax_gateway_start(struct ast_fax_session *s)\n{\n\tstruct spandsp_pvt *p = s->tech_pvt;\n\tstruct ast_fax_t38_parameters *t38_param;\n\tint i;\n\tRAII_VAR(struct ast_channel *, peer, NULL, ao2_cleanup);\n\tstatic struct ast_generator t30_gen = {\n\t\t.alloc = spandsp_fax_gw_gen_alloc,\n\t\t.release = spandsp_fax_gw_gen_release,\n\t\t.generate = spandsp_fax_gw_t30_gen,\n\t};\n#if SPANDSP_RELEASE_DATE >= 20081012\n\t\n\tp->t38_core_state=&p->t38_gw_state.t38x.t38;\n#else\n\t\n\tp->t38_core_state=&p->t38_gw_state.t38;\n#endif\n\tif (!t38_gateway_init(&p->t38_gw_state, t38_tx_packet_handler, s)) {\n\t\treturn -1;\n\t}\n\tp->ist38 = 1;\n\tp->ast_t38_state = ast_channel_get_t38_state(s->chan);\n\tpeer = ast_channel_bridge_peer(s->chan);\n\tif (!peer) {\n\t\treturn -1;\n\t}\n\t\n\tif (p->ast_t38_state == T38_STATE_NEGOTIATING) {\n\t\tp->ast_t38_state = T38_STATE_NEGOTIATED;\n\t}\n\tast_activate_generator(p->ast_t38_state == T38_STATE_NEGOTIATED ? peer : s->chan, &t30_gen , s);\n\tset_logging(&p->t38_gw_state.logging, s->details);\n\tset_logging(&p->t38_core_state->logging, s->details);\n\tt38_param = (p->ast_t38_state == T38_STATE_NEGOTIATED) ? &s->details->our_t38_parameters : &s->details->their_t38_parameters;\n\tt38_set_t38_version(p->t38_core_state, t38_param->version);\n\tt38_gateway_set_ecm_capability(&p->t38_gw_state, s->details->option.ecm);\n\tt38_set_max_datagram_size(p->t38_core_state, t38_param->max_ifp);\n\tt38_set_fill_bit_removal(p->t38_core_state, t38_param->fill_bit_removal);\n\tt38_set_mmr_transcoding(p->t38_core_state, t38_param->transcoding_mmr);\n\tt38_set_jbig_transcoding(p->t38_core_state, t38_param->transcoding_jbig);\n\tt38_set_data_rate_management_method(p->t38_core_state, \n\t\t\t(t38_param->rate_management == AST_T38_RATE_MANAGEMENT_TRANSFERRED_TCF)? 1 : 2);\n\tt38_gateway_set_transmit_on_idle(&p->t38_gw_state, TRUE);\n\tt38_set_sequence_number_handling(p->t38_core_state, TRUE);\n\tt38_gateway_set_supported_modems(&p->t38_gw_state, spandsp_modems(s->details));\n\t\n\tfor (i=0; i < SPANDSP_ENGAGE_UDPTL_NAT_RETRY; i++) {\n#if SPANDSP_RELEASE_DATE >= 20091228\n\t\tt38_core_send_indicator(&p->t38_gw_state.t38x.t38, T38_IND_NO_SIGNAL);\n#elif SPANDSP_RELEASE_DATE >= 20081012\n\t\tt38_core_send_indicator(&p->t38_gw_state.t38x.t38, T38_IND_NO_SIGNAL, p->t38_gw_state.t38x.t38.indicator_tx_count);\n#else\n\t\tt38_core_send_indicator(&p->t38_gw_state.t38, T38_IND_NO_SIGNAL, p->t38_gw_state.t38.indicator_tx_count);\n#endif\n\t}\n\ts->state = AST_FAX_STATE_ACTIVE;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2333}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245CustomPictureFormat (OOCTXT* pctxt, H245CustomPictureFormat* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"maxCustomPictureWidth\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->maxCustomPictureWidth, 1U, 2048U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->maxCustomPictureWidth);\n   invokeEndElement (pctxt, \"maxCustomPictureWidth\", -1);\n   \n   invokeStartElement (pctxt, \"maxCustomPictureHeight\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->maxCustomPictureHeight, 1U, 2048U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->maxCustomPictureHeight);\n   invokeEndElement (pctxt, \"maxCustomPictureHeight\", -1);\n   \n   invokeStartElement (pctxt, \"minCustomPictureWidth\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->minCustomPictureWidth, 1U, 2048U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->minCustomPictureWidth);\n   invokeEndElement (pctxt, \"minCustomPictureWidth\", -1);\n   \n   invokeStartElement (pctxt, \"minCustomPictureHeight\", -1);\n   stat = decodeConsUInt16 (pctxt, &pvalue->minCustomPictureHeight, 1U, 2048U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->minCustomPictureHeight);\n   invokeEndElement (pctxt, \"minCustomPictureHeight\", -1);\n   \n   invokeStartElement (pctxt, \"mPI\", -1);\n   stat = asn1PD_H245CustomPictureFormat_mPI (pctxt, &pvalue->mPI);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"mPI\", -1);\n   \n   invokeStartElement (pctxt, \"pixelAspectInformation\", -1);\n   stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation (pctxt, &pvalue->pixelAspectInformation);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"pixelAspectInformation\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2334}
{"project": "Asterisk", "target": 0, "func": "static void analog_increase_ss_count(void)\n{\n\tif (analog_callbacks.increase_ss_count) {\n\t\tanalog_callbacks.increase_ss_count();\n\t}\n}\n", "bug_type": null, "idx": 2335}
{"project": "Asterisk", "target": 0, "func": "static void schedule_retry(struct registration_response *response, unsigned int interval,\n\t\t\t   const char *server_uri, const char *client_uri)\n{\n\tupdate_client_state_status(response->client_state, SIP_REGISTRATION_REJECTED_TEMPORARY);\n\tschedule_registration(response->client_state, interval);\n\tif (response->rdata) {\n\t\tast_log(LOG_WARNING, \"Temporal response '%d' received from '%s' on \"\n\t\t\t\"registration attempt to '%s', retrying in '%u'\\n\",\n\t\t\tresponse->code, server_uri, client_uri, interval);\n\t} else {\n\t\tast_log(LOG_WARNING, \"No response received from '%s' on \"\n\t\t\t\"registration attempt to '%s', retrying in '%u'\\n\",\n\t\t\tserver_uri, client_uri, interval);\n\t}\n}\n", "bug_type": null, "idx": 2336}
{"project": "Asterisk", "target": 0, "func": "};\nstatic struct ast_sip_session_delayed_request *delayed_request_alloc(\n\tenum delayed_method method,\n\tast_sip_session_request_creation_cb on_request_creation,\n\tast_sip_session_sdp_creation_cb on_sdp_creation,\n\tast_sip_session_response_cb on_response,\n\tint generate_new_sdp,\n\tstruct ast_sip_session_media_state *media_state)\n{\n\tstruct ast_sip_session_delayed_request *delay = ast_calloc(1, sizeof(*delay));\n\tif (!delay) {\n\t\treturn NULL;\n\t}\n\tdelay->method = method;\n\tdelay->on_request_creation = on_request_creation;\n\tdelay->on_sdp_creation = on_sdp_creation;\n\tdelay->on_response = on_response;\n\tdelay->generate_new_sdp = generate_new_sdp;\n\tdelay->media_state = media_state;\n\treturn delay;\n}\n", "bug_type": null, "idx": 2337}
{"project": "Asterisk", "target": 0, "func": "void ast_xmpp_increment_mid(char *mid)\n{\n\tint i = 0;\n\tfor (i = strlen(mid) - 1; i >= 0; i--) {\n\t\tif (mid[i] != 'z') {\n\t\t\tmid[i] = mid[i] + 1;\n\t\t\ti = 0;\n\t\t} else {\n\t\t\tmid[i] = 'a';\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2338}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic int ast_say_number_full_ru(struct ast_channel *chan, int num, const char *ints, const char *language, const char *options, int audiofd, int ctrlfd)\n{\n\tint res = 0;\n\tint lastdigits = 0;\n\tchar fn[256] = \"\";\n\tif (!num)\n\t\treturn ast_say_digits_full(chan, 0, ints, language, audiofd, ctrlfd);\n\twhile (!res && (num)) {\n\t\tif (num < 0) {\n\t\t\tast_copy_string(fn, \"digits/minus\", sizeof(fn));\n\t\t\tif ( num > INT_MIN ) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t} else\tif (num < 20) {\n\t\t\tif (options && strlen(options) == 1 && num < 3) {\n\t\t\t    snprintf(fn, sizeof(fn), \"digits/%d%s\", num, options);\n\t\t\t} else {\n\t\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num);\n\t\t\t}\n\t\t\tnum = 0;\n\t\t} else if (num < 100) {\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num - (num % 10));\n\t\t\tnum %= 10;\n\t\t} else if (num < 1000){\n\t\t\tsnprintf(fn, sizeof(fn), \"digits/%d\", num - (num % 100));\n\t\t\tnum %= 100;\n\t\t} else if (num < 1000000) { \n\t\t\tlastdigits = get_lastdigits_ru(num / 1000);\n\t\t\t\n\t\t\tif (lastdigits < 3) {\n\t\t\t\tres = ast_say_number_full_ru(chan, num / 1000, ints, language, \"f\", audiofd, ctrlfd);\n\t\t\t} else {\n\t\t\t\tres = ast_say_number_full_ru(chan, num / 1000, ints, language, NULL, audiofd, ctrlfd);\n\t\t\t}\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tif (lastdigits == 1) {\n\t\t\t\tast_copy_string(fn, \"digits/thousand\", sizeof(fn));\n\t\t\t} else if (lastdigits > 1 && lastdigits < 5) {\n\t\t\t\tast_copy_string(fn, \"digits/thousands-i\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tast_copy_string(fn, \"digits/thousands\", sizeof(fn));\n\t\t\t}\n\t\t\tnum %= 1000;\n\t\t} else if (num < 1000000000) {\t\n\t\t\tlastdigits = get_lastdigits_ru(num / 1000000);\n\t\t\t\n\t\t\tres = ast_say_number_full_ru(chan, num / 1000000, ints, language, NULL, audiofd, ctrlfd);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tif (lastdigits == 1) {\n\t\t\t\tast_copy_string(fn, \"digits/million\", sizeof(fn));\n\t\t\t} else if (lastdigits > 1 && lastdigits < 5) {\n\t\t\t\tast_copy_string(fn, \"digits/million-a\", sizeof(fn));\n\t\t\t} else {\n\t\t\t\tast_copy_string(fn, \"digits/millions\", sizeof(fn));\n\t\t\t}\n\t\t\tnum %= 1000000;\n\t\t} else {\n\t\t\tast_debug(1, \"Number '%d' is too big for me\\n\", num);\n\t\t\tres = -1;\n\t\t}\n\t\tif (!res) {\n\t\t\tif (!ast_streamfile(chan, fn, language)) {\n\t\t\t\tif ((audiofd  > -1) && (ctrlfd > -1))\n\t\t\t\t\tres = ast_waitstream_full(chan, ints, audiofd, ctrlfd);\n\t\t\t\telse\n\t\t\t\t\tres = ast_waitstream(chan, ints);\n\t\t\t}\n\t\t\tast_stopstream(chan);\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2339}
{"project": "Asterisk", "target": 0, "func": "static enum ast_rtp_glue_result unistim_get_rtp_peer(struct ast_channel *chan, struct ast_rtp_instance **instance)\n{\n\tstruct unistim_subchannel *sub = ast_channel_tech_pvt(chan);\n\tif (!sub) {\n\t\treturn AST_RTP_GLUE_RESULT_FORBID;\n\t}\n\tif (!sub->rtp) {\n\t\treturn AST_RTP_GLUE_RESULT_FORBID;\n\t}\n\tao2_ref(sub->rtp, +1);\n\t*instance = sub->rtp;\n\treturn AST_RTP_GLUE_RESULT_LOCAL;\n}\n", "bug_type": null, "idx": 2340}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_channel_emulate_dtmf_duration(const struct ast_channel *chan)\n{\n\treturn chan->emulate_dtmf_duration;\n}\n", "bug_type": null, "idx": 2341}
{"project": "Asterisk", "target": 0, "func": "enum analog_cid_start analog_str_to_cidstart(const char *value)\n{\n\tif (!strcasecmp(value, \"ring\")) {\n\t\treturn ANALOG_CID_START_RING;\n\t} else if (!strcasecmp(value, \"polarity\")) {\n\t\treturn ANALOG_CID_START_POLARITY;\n\t} else if (!strcasecmp(value, \"polarity_in\")) {\n\t\treturn ANALOG_CID_START_POLARITY_IN;\n\t} else if (!strcasecmp(value, \"dtmf\")) {\n\t\treturn ANALOG_CID_START_DTMF_NOALERT;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2342}
{"project": "Asterisk", "target": 0, "func": "void ael2_print(char *fname, pval *tree)\n{\n\tFILE *fin = fopen(fname,\"w\");\n\tif ( !fin ) {\n\t\tast_log(LOG_ERROR, \"Couldn't open %s for writing.\\n\", fname);\n\t\treturn;\n\t}\n\tprint_pval_list(fin, tree, 0);\n\tfclose(fin);\n}\n", "bug_type": null, "idx": 2343}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_bridges_play_with_id_parse_body(\n\tstruct ast_json *body,\n\tstruct ast_ari_bridges_play_with_id_args *args)\n{\n\tstruct ast_json *field;\n\t\n\tfield = ast_json_object_get(body, \"media\");\n\tif (field) {\n\t\t\n\t\tast_free(args->media);\n\t\tif (ast_json_typeof(field) == AST_JSON_ARRAY) {\n\t\t\t\n\t\t\tsize_t i;\n\t\t\targs->media_count = ast_json_array_size(field);\n\t\t\targs->media = ast_malloc(sizeof(*args->media) * args->media_count);\n\t\t\tif (!args->media) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < args->media_count; ++i) {\n\t\t\t\targs->media[i] = ast_json_string_get(ast_json_array_get(field, i));\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\targs->media_count = 1;\n\t\t\targs->media = ast_malloc(sizeof(*args->media) * args->media_count);\n\t\t\tif (!args->media) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\targs->media[0] = ast_json_string_get(field);\n\t\t}\n\t}\n\tfield = ast_json_object_get(body, \"lang\");\n\tif (field) {\n\t\targs->lang = ast_json_string_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"offsetms\");\n\tif (field) {\n\t\targs->offsetms = ast_json_integer_get(field);\n\t}\n\tfield = ast_json_object_get(body, \"skipms\");\n\tif (field) {\n\t\targs->skipms = ast_json_integer_get(field);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2344}
{"project": "Asterisk", "target": 0, "func": "static int prack_to_str(const void *obj, const intptr_t *args, char **buf)\n{\n\tconst struct ast_sip_endpoint *endpoint = obj;\n\tif (endpoint->extensions.flags & PJSIP_INV_REQUIRE_100REL) {\n\t\t*buf = \"required\";\n\t} else if (endpoint->extensions.flags & PJSIP_INV_SUPPORT_100REL) {\n\t\t*buf = \"yes\";\n\t} else {\n\t\t*buf = \"no\";\n\t}\n\t*buf = ast_strdup(*buf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2345}
{"project": "Asterisk", "target": 0, "func": "static int dahdi_timer_ack(void *data, unsigned int quantity)\n{\n\tstruct dahdi_timer *timer = data;\n\treturn ioctl(timer->fd, DAHDI_TIMERACK, &quantity) ? -1 : 0;\n}\n", "bug_type": null, "idx": 2346}
{"project": "Asterisk", "target": 0, "func": "struct ast_features_pickup_config *ast_get_chan_features_pickup_config(struct ast_channel *chan)\n{\n\tRAII_VAR(struct features_config *, cfg, NULL, ao2_cleanup);\n\tif (chan) {\n\t\tcfg = get_feature_ds(chan);\n\t} else {\n\t\tcfg = ao2_global_obj_ref(globals);\n\t}\n\tif (!cfg) {\n\t\treturn NULL;\n\t}\n\tast_assert(cfg->global && cfg->global->pickup);\n\tao2_ref(cfg->global->pickup, +1);\n\treturn cfg->global->pickup;\n}\n", "bug_type": null, "idx": 2347}
{"project": "Asterisk", "target": 0, "func": "\nstatic void publish_cluster_discovery_to_stasis(struct ast_event *event)\n{\n\tstruct corosync_node *node;\n\tint id = ast_event_get_ie_uint(event, AST_EVENT_IE_NODE_ID);\n\tstruct ast_eid *event_eid;\n\tast_assert(ast_event_get_type(event) == AST_EVENT_CLUSTER_DISCOVERY);\n\tevent_eid = (struct ast_eid *)ast_event_get_ie_raw(event, AST_EVENT_IE_EID);\n\tif (!ast_eid_cmp(&ast_eid_default, event_eid)) {\n\t\t\n\t\treturn;\n\t}\n\tao2_lock(nodes);\n\tnode = ao2_find(nodes, &id, OBJ_SEARCH_KEY | OBJ_NOLOCK);\n\tif (node) {\n\t\t\n\t\tao2_unlock(nodes);\n\t\tao2_ref(node, -1);\n\t\treturn;\n\t}\n\tnode = corosync_node_alloc(event);\n\tif (!node) {\n\t\tao2_unlock(nodes);\n\t\treturn;\n\t}\n\tao2_link_flags(nodes, node, OBJ_NOLOCK);\n\tao2_unlock(nodes);\n\tpublish_cluster_discovery_to_stasis_full(node, 1);\n\tao2_ref(node, -1);\n\t\n\tsend_cluster_notify();\n}\n", "bug_type": null, "idx": 2348}
{"project": "Asterisk", "target": 0, "func": "\ned_start_over(EditLine *el, int c)\n{\n\tch_reset(el);\n\treturn (CC_REFRESH);\n}\n", "bug_type": null, "idx": 2349}
{"project": "Asterisk", "target": 0, "func": "int __ast_vasprintf(char **strp, const char *format, va_list ap, const char *file, int lineno, const char *func)\n{\n\treturn vasprintf(strp, format, ap);\n}\n", "bug_type": null, "idx": 2350}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235ECKASDH_eckasdh2_fieldSize (OOCTXT* pctxt, H235ECKASDH_eckasdh2_fieldSize* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 0, 511, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = encodeBitString (pctxt, pvalue->numbits, pvalue->data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2351}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225AddressPattern (OOCTXT* pctxt, H225AddressPattern* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"wildcard\", -1);\n            pvalue->u.wildcard = ALLOC_ASN1ELEM (pctxt, H225AliasAddress);\n            stat = asn1PD_H225AliasAddress (pctxt, pvalue->u.wildcard);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"wildcard\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"range\", -1);\n            pvalue->u.range = ALLOC_ASN1ELEM (pctxt, H225AddressPattern_range);\n            stat = asn1PD_H225AddressPattern_range (pctxt, pvalue->u.range);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"range\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 3;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2352}
{"project": "Asterisk", "target": 0, "func": "int ast_aoc_decoded2str(const struct ast_aoc_decoded *decoded, struct ast_str **msg)\n{\n\tif (!decoded || !msg) {\n\t\treturn -1;\n\t}\n\tswitch (decoded->msg_type) {\n\tcase AST_AOC_S:\n\t\tast_str_append(msg, 0, \"AOC-S\\r\\n\");\n\t\taoc_s_event(decoded, msg);\n\t\tbreak;\n\tcase AST_AOC_D:\n\t\tast_str_append(msg, 0, \"AOC-D\\r\\n\");\n\t\taoc_d_event(decoded, msg);\n\t\tbreak;\n\tcase AST_AOC_E:\n\t\tast_str_append(msg, 0, \"AOC-E\\r\\n\");\n\t\taoc_e_event(decoded, msg);\n\t\tbreak;\n\tcase AST_AOC_REQUEST:\n\t\tast_str_append(msg, 0, \"AOC-Request\\r\\n\");\n\t\taoc_request_event(decoded, msg);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2353}
{"project": "Asterisk", "target": 0, "func": "static struct ast_bridge *bridge_create_common(const char *type, const char *name, const char *id, int invisible)\n{\n\tstruct ast_bridge *bridge;\n\tchar *requested_type, *requested_types = ast_strdupa(S_OR(type, \"mixing\"));\n\tint capabilities = 0;\n\tint flags = AST_BRIDGE_FLAG_MERGE_INHIBIT_FROM | AST_BRIDGE_FLAG_MERGE_INHIBIT_TO\n\t\t| AST_BRIDGE_FLAG_SWAP_INHIBIT_FROM | AST_BRIDGE_FLAG_SWAP_INHIBIT_TO\n\t\t| AST_BRIDGE_FLAG_TRANSFER_BRIDGE_ONLY;\n\tenum ast_bridge_video_mode_type video_mode = AST_BRIDGE_VIDEO_MODE_TALKER_SRC;\n\tif (invisible) {\n\t\tflags |= AST_BRIDGE_FLAG_INVISIBLE;\n\t}\n\twhile ((requested_type = strsep(&requested_types, \",\"))) {\n\t\trequested_type = ast_strip(requested_type);\n\t\tif (!strcmp(requested_type, \"mixing\")) {\n\t\t\tcapabilities |= STASIS_BRIDGE_MIXING_CAPABILITIES;\n\t\t\tflags |= AST_BRIDGE_FLAG_SMART;\n\t\t} else if (!strcmp(requested_type, \"holding\")) {\n\t\t\tcapabilities |= AST_BRIDGE_CAPABILITY_HOLDING;\n\t\t} else if (!strcmp(requested_type, \"dtmf_events\") ||\n\t\t\t!strcmp(requested_type, \"proxy_media\")) {\n\t\t\tcapabilities &= ~AST_BRIDGE_CAPABILITY_NATIVE;\n\t\t} else if (!strcmp(requested_type, \"video_sfu\")) {\n\t\t\tvideo_mode = AST_BRIDGE_VIDEO_MODE_SFU;\n\t\t}\n\t}\n\t\n\tif (video_mode == AST_BRIDGE_VIDEO_MODE_SFU) {\n\t\tcapabilities = AST_BRIDGE_CAPABILITY_MULTIMIX;\n\t\tflags &= ~AST_BRIDGE_FLAG_SMART;\n\t}\n\tif (!capabilities\n\t\t\n\t\t|| ((capabilities & AST_BRIDGE_CAPABILITY_HOLDING)\n\t\t\t&& (capabilities & (STASIS_BRIDGE_MIXING_CAPABILITIES)))) {\n\t\treturn NULL;\n\t}\n\tbridge = bridge_stasis_new(capabilities, flags, name, id);\n\tif (bridge) {\n\t\tif (video_mode == AST_BRIDGE_VIDEO_MODE_SFU) {\n\t\t\tast_bridge_set_sfu_video_mode(bridge);\n\t\t\t\n\t\t\tast_bridge_set_video_update_discard(bridge, 5);\n\t\t} else {\n\t\t\tast_bridge_set_talker_src_video_mode(bridge);\n\t\t}\n\t\tif (!ao2_link(app_bridges, bridge)) {\n\t\t\tast_bridge_destroy(bridge, 0);\n\t\t\tbridge = NULL;\n\t\t}\n\t}\n\treturn bridge;\n}\n", "bug_type": null, "idx": 2354}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void calendar_join_attendees(struct ast_calendar_event *event, char *buf, size_t len)\n{\n\tstruct ast_str *tmp;\n\tstruct ast_calendar_attendee *attendee;\n\tif (!(tmp = ast_str_create(32))) {\n\t\tast_log(LOG_ERROR, \"Could not allocate memory for attendees!\\n\");\n\t\treturn;\n\t}\n\tAST_LIST_TRAVERSE(&event->attendees, attendee, next) {\n\t\tast_str_append(&tmp, 0, \"%s%s\", attendee == AST_LIST_FIRST(&event->attendees) ? \"\" : \",\", attendee->data);\n\t}\n\tast_copy_string(buf, ast_str_buffer(tmp), len);\n\tast_free(tmp);\n}\n", "bug_type": null, "idx": 2355}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int unload_module(void)\n{\n\tint res;\n\tres = ast_unregister_translator(&lintoilbc);\n\tres |= ast_unregister_translator(&ilbctolin);\n\treturn res;\n}\n", "bug_type": null, "idx": 2356}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245CertSelectionCriteria (OOCTXT* pctxt, H245CertSelectionCriteria* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };\n   int stat = ASN_OK;\n   H245Criteria* pdata;\n   ASN1UINT count = 0;\n   ASN1UINT xx1;\n   \n   addSizeConstraint (pctxt, &lsize1);\n   stat = decodeLength (pctxt, &count);\n   if (stat != ASN_OK) return stat;\n   \n   dListInit (pvalue);\n   for (xx1 = 0; xx1 < count; xx1++) {\n      invokeStartElement (pctxt, \"elem\", xx1);\n      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245Criteria);\n      stat = asn1PD_H245Criteria (pctxt, pdata);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"elem\", xx1);\n      dListAppendNode (pctxt, pvalue, pdata);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2357}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245NetworkAccessParameters (OOCTXT* pctxt, H245NetworkAccessParameters* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.distributionPresent = optbit;\n   DECODEBIT (pctxt, &optbit);\n   pvalue->m.externalReferencePresent = optbit;\n   \n   if (pvalue->m.distributionPresent) {\n      invokeStartElement (pctxt, \"distribution\", -1);\n      stat = asn1PD_H245NetworkAccessParameters_distribution (pctxt, &pvalue->distribution);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"distribution\", -1);\n   }\n   \n   invokeStartElement (pctxt, \"networkAddress\", -1);\n   stat = asn1PD_H245NetworkAccessParameters_networkAddress (pctxt, &pvalue->networkAddress);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"networkAddress\", -1);\n   \n   invokeStartElement (pctxt, \"associateConference\", -1);\n   stat = DECODEBIT (pctxt, &pvalue->associateConference);\n   if (stat != ASN_OK) return stat;\n   invokeBoolValue (pctxt, pvalue->associateConference);\n   invokeEndElement (pctxt, \"associateConference\", -1);\n   \n   if (pvalue->m.externalReferencePresent) {\n      invokeStartElement (pctxt, \"externalReference\", -1);\n      stat = asn1PD_H245NetworkAccessParameters_externalReference (pctxt, &pvalue->externalReference);\n      if (stat != ASN_OK) return stat;\n      invokeEndElement (pctxt, \"externalReference\", -1);\n   }\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 1 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.t120SetupProcedurePresent = 1;\n                     invokeStartElement (pctxt, \"t120SetupProcedure\", -1);\n                     stat = asn1PD_H245NetworkAccessParameters_t120SetupProcedure (pctxt, &pvalue->t120SetupProcedure);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"t120SetupProcedure\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2358}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_channel_created(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_type = 0;\n\tint has_application = 0;\n\tint has_channel = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"asterisk_id\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelCreated field asterisk_id failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"type\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_type = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelCreated field type failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"application\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_application = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelCreated field application failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"timestamp\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\tprop_is_valid = ast_ari_validate_date(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelCreated field timestamp failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"channel\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_channel = 1;\n\t\t\tprop_is_valid = ast_ari_validate_channel(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI ChannelCreated field channel failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI ChannelCreated has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_type) {\n\t\tast_log(LOG_ERROR, \"ARI ChannelCreated missing required field type\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_application) {\n\t\tast_log(LOG_ERROR, \"ARI ChannelCreated missing required field application\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_channel) {\n\t\tast_log(LOG_ERROR, \"ARI ChannelCreated missing required field channel\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2359}
{"project": "Asterisk", "target": 0, "func": "static void smb_fft(float *fft_buffer, long fft_frame_size, long sign)\n{\n\tfloat wr, wi, arg, *p1, *p2, temp;\n\tfloat tr, ti, ur, ui, *p1r, *p1i, *p2r, *p2i;\n\tlong i, bitm, j, le, le2, k;\n\tfor (i = 2; i < 2 * fft_frame_size - 2; i += 2) {\n\t\tfor (bitm = 2, j = 0; bitm < 2 * fft_frame_size; bitm <<= 1) {\n\t\t\tif (i & bitm) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tj <<= 1;\n\t\t}\n\t\tif (i < j) {\n\t\t\tp1 = fft_buffer + i; p2 = fft_buffer + j;\n\t\t\ttemp = *p1; *(p1++) = *p2;\n\t\t\t*(p2++) = temp; temp = *p1;\n\t\t\t*p1 = *p2; *p2 = temp;\n\t\t}\n\t}\n\tfor (k = 0, le = 2; k < (long) (log(fft_frame_size) / log(2.) + .5); k++) {\n\t\tle <<= 1;\n\t\tle2 = le>>1;\n\t\tur = 1.0;\n\t\tui = 0.0;\n\t\targ = M_PI / (le2>>1);\n\t\twr = cos(arg);\n\t\twi = sign * sin(arg);\n\t\tfor (j = 0; j < le2; j += 2) {\n\t\t\tp1r = fft_buffer+j; p1i = p1r + 1;\n\t\t\tp2r = p1r + le2; p2i = p2r + 1;\n\t\t\tfor (i = j; i < 2 * fft_frame_size; i += le) {\n\t\t\t\ttr = *p2r * ur - *p2i * ui;\n\t\t\t\tti = *p2r * ui + *p2i * ur;\n\t\t\t\t*p2r = *p1r - tr; *p2i = *p1i - ti;\n\t\t\t\t*p1r += tr; *p1i += ti;\n\t\t\t\tp1r += le; p1i += le;\n\t\t\t\tp2r += le; p2i += le;\n\t\t\t}\n\t\t\ttr = ur * wr - ui * wi;\n\t\t\tui = ur * wi + ui * wr;\n\t\t\tur = tr;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2360}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct rbtree_node *rb_ao2_iterator_next(struct ao2_container_rbtree *self, struct rbtree_node *node, enum ao2_iterator_flags flags)\n{\n\tif (flags & AO2_ITERATOR_DESCENDING) {\n\t\tif (!node) {\n\t\t\t\n\t\t\tif (!self->root) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tnode = rb_node_most_right(self->root);\n\t\t\tif (node->common.obj) {\n\t\t\t\t\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnode = rb_node_prev_full(node);\n\t} else {\n\t\tif (!node) {\n\t\t\t\n\t\t\tif (!self->root) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tnode = rb_node_most_left(self->root);\n\t\t\tif (node->common.obj) {\n\t\t\t\t\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnode = rb_node_next_full(node);\n\t}\n\treturn node;\n}\n", "bug_type": null, "idx": 2361}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/astobj2.h\"\nvoid ast_slinfactory_init(struct ast_slinfactory *sf)\n{\n\tmemset(sf, 0, sizeof(*sf));\n\tsf->offset = sf->hold;\n\tsf->output_format = ao2_bump(ast_format_slin);\n}\n", "bug_type": null, "idx": 2362}
{"project": "Asterisk", "target": 0, "func": "void ast_sip_session_unregister_supplement(struct ast_sip_session_supplement *supplement)\n{\n\tif (!internal_sip_session_unregister_supplement(supplement)) {\n\t\tast_module_unref(AST_MODULE_SELF);\n\t}\n}\n", "bug_type": null, "idx": 2363}
{"project": "Asterisk", "target": 0, "func": "struct confbridge_state *CONF_STATE_SINGLE = &STATE_SINGLE;\nstatic void join_unmarked(struct confbridge_user *user)\n{\n\tconf_add_user_active(user->conference, user);\n\tconf_handle_second_active(user->conference);\n\tconf_update_user_mute(user);\n\tconf_change_state(user, CONF_STATE_MULTI);\n}\n", "bug_type": null, "idx": 2364}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int load_module(void)\n{\n\tvorbis_f.format = ast_format_slin;\n\tif (ast_format_def_register(&vorbis_f))\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 2365}
{"project": "Asterisk", "target": 0, "func": "#endif\t\nstatic void *do_idle_thread(void *v_pvt)\n{\n\tstruct sig_pri_chan *pvt = v_pvt;\n\tstruct ast_channel *chan = pvt->owner;\n\tstruct ast_frame *f;\n\tchar ex[128];\n\t\n\tint timeout_ms = 30000;\n\tint ms;\n\tstruct timeval start;\n\tast_callid callid;\n\tif ((callid = ast_channel_callid(chan))) {\n\t\tast_callid_threadassoc_add(callid);\n\t}\n\tast_verb(3, \"Initiating idle call on channel %s\\n\", ast_channel_name(chan));\n\tsnprintf(ex, sizeof(ex), \"%d/%s\", pvt->channel, pvt->pri->idledial);\n\tif (ast_call(chan, ex, 0)) {\n\t\tast_log(LOG_WARNING, \"Idle dial failed on '%s' to '%s'\\n\", ast_channel_name(chan), ex);\n\t\tast_hangup(chan);\n\t\treturn NULL;\n\t}\n\tstart = ast_tvnow();\n\twhile ((ms = ast_remaining_ms(start, timeout_ms))) {\n\t\tif (ast_waitfor(chan, ms) <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tf = ast_read(chan);\n\t\tif (!f) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tif (f->frametype == AST_FRAME_CONTROL) {\n\t\t\tswitch (f->subclass.integer) {\n\t\t\tcase AST_CONTROL_ANSWER:\n\t\t\t\t\n\t\t\t\tast_channel_exten_set(chan, pvt->pri->idleext);\n\t\t\t\tast_channel_context_set(chan, pvt->pri->idlecontext);\n\t\t\t\tast_channel_priority_set(chan, 1);\n\t\t\t\tast_verb(4, \"Idle channel '%s' answered, sending to %s@%s\\n\", ast_channel_name(chan), ast_channel_exten(chan), ast_channel_context(chan));\n\t\t\t\tast_pbx_run(chan);\n\t\t\t\t\n\t\t\t\treturn NULL;\n\t\t\tcase AST_CONTROL_BUSY:\n\t\t\t\tast_verb(4, \"Idle channel '%s' busy, waiting...\\n\", ast_channel_name(chan));\n\t\t\t\tbreak;\n\t\t\tcase AST_CONTROL_CONGESTION:\n\t\t\t\tast_verb(4, \"Idle channel '%s' congested, waiting...\\n\", ast_channel_name(chan));\n\t\t\t\tbreak;\n\t\t\t};\n\t\t}\n\t\tast_frfree(f);\n\t}\n\t\n\tast_hangup(chan);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2366}
{"project": "Asterisk", "target": 0, "func": "static int rtt_start_to_str(const void *obj, const intptr_t *args, char **buf)\n{\n\tconst struct ast_sip_contact_status *status = obj;\n\tif (ast_asprintf(buf, \"%ld.%06ld\", (long)status->rtt_start.tv_sec, (long)status->rtt_start.tv_usec) == -1) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2367}
{"project": "Asterisk", "target": 0, "func": "static int create_in_dialog_request(const pjsip_method *method, struct pjsip_dialog *dlg, pjsip_tx_data **tdata)\n{\n\tif (pjsip_dlg_create_request(dlg, method, -1, tdata) != PJ_SUCCESS) {\n\t\tast_log(LOG_WARNING, \"Unable to create in-dialog request.\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2368}
{"project": "Asterisk", "target": 0, "func": "static int register_aor(pjsip_rx_data *rdata,\n\tstruct ast_sip_endpoint *endpoint,\n\tstruct ast_sip_aor *aor,\n\tconst char *aor_name)\n{\n\tint res;\n\tstruct ao2_container *contacts = NULL;\n\tao2_lock(aor);\n\tcontacts = ast_sip_location_retrieve_aor_contacts_nolock(aor);\n\tif (!contacts) {\n\t\tao2_unlock(aor);\n\t\treturn PJ_TRUE;\n\t}\n\tres = register_aor_core(rdata, endpoint, aor, aor_name, contacts);\n\tao2_cleanup(contacts);\n\tao2_unlock(aor);\n\treturn res;\n}\n", "bug_type": null, "idx": 2369}
{"project": "Asterisk", "target": 0, "func": "static int asterisk_start_devicestate_publishing(struct ast_sip_outbound_publish *configuration,\n\tstruct ast_sip_outbound_publish_client *client)\n{\n\tRAII_VAR(struct ast_datastore *, datastore, NULL, ao2_cleanup);\n\tstruct asterisk_devicestate_publisher_state *publisher_state;\n\tconst char *value;\n\tstruct ao2_container *cached;\n\tdatastore = ast_sip_publish_client_alloc_datastore(&asterisk_devicestate_publisher_state_datastore,\n\t\t\"asterisk-devicestate-publisher\");\n\tif (!datastore) {\n\t\treturn -1;\n\t}\n\tpublisher_state = ast_calloc(1, sizeof(struct asterisk_devicestate_publisher_state));\n\tif (!publisher_state) {\n\t\treturn -1;\n\t}\n\tdatastore->data = publisher_state;\n\tvalue = ast_sorcery_object_get_extended(configuration, \"device_state_filter\");\n\tif (!ast_strlen_zero(value)) {\n\t\tif (build_regex(&publisher_state->device_state_regex, value)) {\n\t\t\treturn -1;\n\t\t}\n\t\tpublisher_state->device_state_filter = 1;\n\t}\n\tpublisher_state->client = ao2_bump(client);\n\tif (ast_sip_publish_client_add_datastore(client, datastore)) {\n\t\treturn -1;\n\t}\n\tpublisher_state->device_state_subscription = stasis_subscribe(ast_device_state_topic_all(),\n\t\tasterisk_publisher_devstate_cb, ao2_bump(datastore));\n\tif (!publisher_state->device_state_subscription) {\n\t\tast_sip_publish_client_remove_datastore(client, \"asterisk-devicestate-publisher\");\n\t\tao2_ref(datastore, -1);\n\t\treturn -1;\n\t}\n\tcached = stasis_cache_dump(ast_device_state_cache(), NULL);\n\tao2_callback(cached, OBJ_NODATA, cached_devstate_cb, datastore);\n\tao2_ref(cached, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2370}
{"project": "Asterisk", "target": 0, "func": "int ast_sdp_find_a_first(const struct ast_sdp *sdp, const char *attr_name, int payload)\n{\n\treturn sdp_find_a_common(sdp->a_lines, -1, attr_name, payload);\n}\n", "bug_type": null, "idx": 2371}
{"project": "Asterisk", "target": 0, "func": "static void consumer_wait_for(struct consumer *consumer)\n{\n\tint res;\n\tstruct timeval start = ast_tvnow();\n\tstruct timespec end = {\n\t\t.tv_sec = start.tv_sec + 10,\n\t\t.tv_nsec = start.tv_usec * 1000\n\t};\n\tSCOPED_AO2LOCK(lock, consumer);\n\twhile (!consumer->already_out) {\n\t\tres = ast_cond_timedwait(&consumer->out, ao2_object_get_lockaddr(consumer), &end);\n\t\tif (!res || res == ETIMEDOUT) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2372}
{"project": "Asterisk", "target": 0, "func": "static int stream_echo_write(struct ast_channel *chan, struct ast_frame *frame,\n\tenum ast_media_type type, int one_to_one)\n{\n\tint i;\n\tint num;\n\tstruct ast_stream_topology *topology;\n\t\n\tnum = ast_channel_is_multistream(chan) ? frame->stream_num : -1;\n\tif (ast_write_stream(chan, num, frame)) {\n\t\treturn stream_echo_write_error(chan, frame, num);\n\t}\n\t\n\tif (one_to_one || !frame->subclass.format ||\n\t    ast_format_get_type(frame->subclass.format) != type) {\n\t\treturn 0;\n\t}\n\t\n\ttopology = ast_channel_get_stream_topology(chan);\n\tfor (i = 0; i < ast_stream_topology_get_count(topology); ++i) {\n\t\tstruct ast_stream *stream = ast_stream_topology_get_stream(topology, i);\n\t\tif (num != i && ast_stream_get_type(stream) == type) {\n\t\t\tif (ast_write_stream(chan, i, frame)) {\n\t\t\t\treturn stream_echo_write_error(chan, frame, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2373}
{"project": "Asterisk", "target": 0, "func": "\nstatic struct app_forwards *forwards_create_bridge(struct stasis_app *app,\n\tstruct ast_bridge *bridge)\n{\n\tstruct app_forwards *forwards;\n\tif (!app) {\n\t\treturn NULL;\n\t}\n\tforwards = forwards_create(app, bridge ? bridge->uniqueid : BRIDGE_ALL);\n\tif (!forwards) {\n\t\treturn NULL;\n\t}\n\tforwards->forward_type = FORWARD_BRIDGE;\n\tif (bridge) {\n\t\tforwards->topic_forward = stasis_forward_all(ast_bridge_topic(bridge),\n\t\t\tapp->topic);\n\t}\n\tforwards->topic_cached_forward = stasis_forward_all(\n\t\tbridge ? ast_bridge_topic_cached(bridge) : ast_bridge_topic_all_cached(),\n\t\tapp->topic);\n\tif ((!forwards->topic_forward && bridge) || !forwards->topic_cached_forward) {\n\t\t\n\t\tforwards_unsubscribe(forwards);\n\t\tao2_ref(forwards, -1);\n\t\treturn NULL;\n\t}\n\treturn forwards;\n}\n", "bug_type": null, "idx": 2374}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245FunctionNotUnderstood (OOCTXT* pctxt, H245FunctionNotUnderstood* pvalue)\n{\n   int stat = ASN_OK;\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 2);\n   if (stat != ASN_OK) return stat;\n   \n   switch (pvalue->t)\n   {\n      \n      case 1:\n         stat = asn1PE_H245RequestMessage (pctxt, pvalue->u.request);\n         if (stat != ASN_OK) return stat;\n         break;\n      \n      case 2:\n         stat = asn1PE_H245ResponseMessage (pctxt, pvalue->u.response);\n         if (stat != ASN_OK) return stat;\n         break;\n      \n      case 3:\n         stat = asn1PE_H245CommandMessage (pctxt, pvalue->u.command);\n         if (stat != ASN_OK) return stat;\n         break;\n      default:\n         return ASN_E_INVOPT;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2375}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void setup_profile_paged(struct ast_channel *chan, struct page_options *options)\n{\n\t\n\tast_func_write(chan, \"CONFBRIDGE(user,template)\", \"\");\n\tast_func_write(chan, \"CONFBRIDGE(user,quiet)\", \"yes\");\n\tast_func_write(chan, \"CONFBRIDGE(user,end_marked)\", \"yes\");\n\tif (!ast_test_flag(&options->flags, PAGE_DUPLEX)) {\n\t\tast_func_write(chan, \"CONFBRIDGE(user,startmuted)\", \"yes\");\n\t}\n\tif (ast_test_flag(&options->flags, PAGE_ANNOUNCE)\n\t\t&& !ast_strlen_zero(options->opts[OPT_ARG_ANNOUNCE])) {\n\t\tast_func_write(chan, \"CONFBRIDGE(user,announcement)\", options->opts[OPT_ARG_ANNOUNCE]);\n\t}\n}\n", "bug_type": null, "idx": 2376}
{"project": "Asterisk", "target": 0, "func": " void speex_resampler_set_output_stride(SpeexResamplerState *st, spx_uint32_t stride)\n{\n   st->out_stride = stride;\n}\n", "bug_type": null, "idx": 2377}
{"project": "Asterisk", "target": 0, "func": "static void dec_ie_progress(unsigned char *p, Q931_info_t *qi, int *coding, int *location, int *progress, int nt, struct misdn_bchannel *bc)\n{\n\t*coding = -1;\n\t*location = -1;\n\t \n\t*progress = 0;\n\tif (!nt)\n\t{\n\t\tp = NULL;\n\t\tif (qi->QI_ELEMENT(progress))\n\t\t\tp = (unsigned char *)qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(progress) + 1;\n\t}\n\tif (!p)\n\t\treturn;\n\tif (p[0] < 1)\n\t{\n\t\tprintf(\"%s: ERROR: IE too short (%d).\\n\", __FUNCTION__, p[0]);\n\t\treturn;\n\t}\n\t*coding = (p[1]&0x60) >> 5;\n\t*location = p[1] & 0x0f;\n\t*progress = p[2] & 0x7f;\n\tif (MISDN_IE_DEBG) printf(\"    coding=%d location=%d progress=%d\\n\", *coding, *location, *progress);\n}\n", "bug_type": null, "idx": 2378}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *handle_show_hangup_channel(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_channel *chan;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"core show hanguphandlers\";\n\t\te->usage =\n\t\t\t\"Usage: core show hanguphandlers <channel>\\n\"\n\t\t\t\"       Show hangup handlers of a specified channel.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn ast_complete_channels(a->line, a->word, a->pos, a->n, e->args);\n\t}\n\tif (a->argc < 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tchan = ast_channel_get_by_name(a->argv[3]);\n\tif (!chan) {\n\t\tast_cli(a->fd, \"Channel does not exist.\\n\");\n\t\treturn CLI_FAILURE;\n\t}\n\tast_pbx_hangup_handler_headers(a->fd);\n\tast_pbx_hangup_handler_show(a->fd, chan);\n\tast_channel_unref(chan);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2379}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int native_bridge_create(struct ast_bridge *bridge)\n{\n\tstruct native_pvt_bridge *tech_pvt;\n\tast_assert(!bridge->tech_pvt);\n\ttech_pvt = ast_calloc(1, sizeof(*tech_pvt));\n\tif (!tech_pvt) {\n\t\treturn -1;\n\t}\n\tbridge->tech_pvt = tech_pvt;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2380}
{"project": "Asterisk", "target": 0, "func": "\nstatic int registrar_delete_contact(void *obj, void *arg, int flags)\n{\n\tstruct ast_sip_contact *contact = obj;\n\tconst char *aor_name = arg;\n\tast_sip_location_delete_contact(contact);\n\tif (!ast_strlen_zero(aor_name)) {\n\t\tast_verb(3, \"Removed contact '%s' from AOR '%s' due to request\\n\", contact->uri, aor_name);\n\t\tast_test_suite_event_notify(\"AOR_CONTACT_REMOVED\",\n\t\t\t\t\"Contact: %s\\r\\n\"\n\t\t\t\t\"AOR: %s\\r\\n\"\n\t\t\t\t\"UserAgent: %s\",\n\t\t\t\tcontact->uri,\n\t\t\t\taor_name,\n\t\t\t\tcontact->user_agent);\n\t}\n\treturn CMP_MATCH;\n}\n", "bug_type": null, "idx": 2381}
{"project": "Asterisk", "target": 0, "func": "int ooSocketGetIpAndPort(OOSOCKET socket, char *ip, int len, int *port, int *family)\n{\n   int ret=ASN_OK;\n   struct ast_sockaddr addr;\n   const char *host=NULL;\n   ret = ast_getsockname(socket, &addr);\n   if(ret != 0)\n      return ASN_E_INVSOCKET;\n   host = ast_sockaddr_stringify_addr(&addr);\n   if(host && strlen(host) < (unsigned)len)\n      strcpy(ip, host);   \n   else{\n     OOTRACEERR1(\"Error:Insufficient buffer for ip address - \"\n                 \"ooSocketGetIpAndPort\\n\");\n      return -1;\n   }\n   *port = ast_sockaddr_port(&addr);\n   if (family) {\n\tif (ast_sockaddr_is_ipv6(&addr) && !ast_sockaddr_is_ipv4_mapped(&addr))\n\t\t*family = 6;\n\telse\n\t\t*family = 4;\n   }\n   return ASN_OK;\n}\n", "bug_type": null, "idx": 2382}
{"project": "Asterisk", "target": 0, "func": "static int dialgroup_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tstruct ao2_iterator i;\n\tstruct group *grhead = ao2_find(group_container, data, 0);\n\tstruct group_entry *entry;\n\tsize_t bufused = 0;\n\tint trunc_warning = 0;\n\tint res = 0;\n\tif (!grhead) {\n\t\tif (!ast_strlen_zero(cmd)) {\n\t\t\tast_log(LOG_WARNING, \"No such dialgroup '%s'\\n\", data);\n\t\t}\n\t\treturn -1;\n\t}\n\tbuf[0] = '\\0';\n\ti = ao2_iterator_init(grhead->entries, 0);\n\twhile ((entry = ao2_iterator_next(&i))) {\n\t\tint tmp = strlen(entry->name);\n\t\t\n\t\tif (len - bufused > tmp + 2) {\n\t\t\tif (bufused != 0)\n\t\t\t\tbuf[bufused++] = '&';\n\t\t\tast_copy_string(buf + bufused, entry->name, len - bufused);\n\t\t\tbufused += tmp;\n\t\t} else if (trunc_warning++ == 0) {\n\t\t\tif (!ast_strlen_zero(cmd)) {\n\t\t\t\tast_log(LOG_WARNING, \"Dialgroup '%s' is too large.  Truncating list.\\n\", data);\n\t\t\t} else {\n\t\t\t\tres = 1;\n\t\t\t\tao2_ref(entry, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tao2_ref(entry, -1);\n\t}\n\tao2_iterator_destroy(&i);\n\tao2_ref(grhead, -1);\n\treturn res;\n}\n", "bug_type": null, "idx": 2383}
{"project": "Asterisk", "target": 0, "func": "static int load_stream_readqueue(struct ast_channel *chan, int frames)\n{\n\tstruct mock_channel_pvt *pvt = ast_channel_tech_pvt(chan);\n\tstruct ast_frame f = { 0, };\n\tstruct ast_frame *frame = NULL;\n\tint i;\n\twhile ((frame = AST_LIST_REMOVE_HEAD(ast_channel_readq(chan), frame_list)))\n\t\t\tast_frfree(frame);\n\tfor (i = 0; i < frames; i++) {\n\t\tif (pvt->frame_count % 2 == 0) {\n\t\t\tf.frametype = AST_FRAME_VOICE;\n\t\t\tf.subclass.format = ast_format_ulaw;\n\t\t} else {\n\t\t\tf.frametype = AST_FRAME_VIDEO;\n\t\t\tf.subclass.format = ast_format_h264;\n\t\t}\n\t\tf.stream_num = pvt->frame_count % pvt->streams;\n\t\tf.seqno = pvt->frame_count;\n\t\tast_queue_frame(chan, &f);\n\t\tpvt->frame_count++;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2384}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *xmldoc_get_syntax_fun(struct ast_xml_node *rootnode, const char *rootname, const char *childname, int printparenthesis, int printrootname)\n{\n#define GOTONEXT(__rev, __a) (__rev ? ast_xml_node_get_prev(__a) : ast_xml_node_get_next(__a))\n#define ISLAST(__rev, __a)  (__rev == 1 ? (ast_xml_node_get_prev(__a) ? 0 : 1) : (ast_xml_node_get_next(__a) ? 0 : 1))\n#define MP(__a) ((multiple ? __a : \"\"))\n\tstruct ast_xml_node *node = NULL, *firstparam = NULL, *lastparam = NULL;\n\tconst char *paramtype, *multipletype, *paramnameattr, *attrargsep, *parenthesis, *argname;\n\tint reverse, required, paramcount = 0, openbrackets = 0, len = 0, hasparams=0;\n\tint reqfinode = 0, reqlanode = 0, optmidnode = 0, prnparenthesis, multiple;\n\tchar *syntax = NULL, *argsep, *paramname;\n\tif (ast_strlen_zero(rootname) || ast_strlen_zero(childname)) {\n\t\tast_log(LOG_WARNING, \"Tried to look in XML tree with faulty rootname or childname while creating a syntax.\\n\");\n\t\treturn NULL;\n\t}\n\tif (!rootnode || !ast_xml_node_get_children(rootnode)) {\n\t\t\n\t\tif (ast_asprintf(&syntax, \"%s%s\", (printrootname ? rootname : \"\"), (printparenthesis ? \"()\" : \"\")) < 0) {\n\t\t\tsyntax = NULL;\n\t\t}\n\t\treturn syntax;\n\t}\n\t\n\tattrargsep = ast_xml_get_attribute(rootnode, \"argsep\");\n\tif (attrargsep) {\n\t\targsep = ast_strdupa(attrargsep);\n\t\tast_xml_free_attr(attrargsep);\n\t} else {\n\t\targsep = ast_strdupa(\",\");\n\t}\n\t\n\tfor (node = ast_xml_node_get_children(rootnode); node; node = ast_xml_node_get_next(node)) {\n\t\tif (strcasecmp(ast_xml_node_get_name(node), childname)) {\n\t\t\tcontinue;\n\t\t}\n\t\trequired = 0;\n\t\thasparams = 1;\n\t\tif ((paramtype = ast_xml_get_attribute(node, \"required\"))) {\n\t\t\tif (ast_true(paramtype)) {\n\t\t\t\trequired = 1;\n\t\t\t}\n\t\t\tast_xml_free_attr(paramtype);\n\t\t}\n\t\tlastparam = node;\n\t\treqlanode = required;\n\t\tif (!firstparam) {\n\t\t\t\n\t\t\tfirstparam = node;\n\t\t\treqfinode = required;\n\t\t}\n\t}\n\tif (!hasparams) {\n\t\t\n\t\tif (ast_asprintf(&syntax, \"%s%s\", (printrootname ? rootname : \"\"), (printparenthesis ? \"()\" : \"\")) < 0) {\n\t\t\tsyntax = NULL;\n\t\t}\n\t\treturn syntax;\n\t}\n\tif (reqfinode && reqlanode) {\n\t\t\n\t\tfor (node = ast_xml_node_get_children(rootnode); node; node = ast_xml_node_get_next(node)) {\n\t\t\tif (strcasecmp(ast_xml_node_get_name(node), childname)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (node != firstparam && node != lastparam) {\n\t\t\t\tif ((paramtype = ast_xml_get_attribute(node, \"required\"))) {\n\t\t\t\t\tif (!ast_true(paramtype)) {\n\t\t\t\t\t\toptmidnode = 1;\n\t\t\t\t\t\tast_xml_free_attr(paramtype);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tast_xml_free_attr(paramtype);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ((!reqfinode && reqlanode) || (reqfinode && reqlanode && optmidnode)) {\n\t\treverse = 1;\n\t\tnode = lastparam;\n\t} else {\n\t\treverse = 0;\n\t\tnode = firstparam;\n\t}\n\t\n\tif (reverse) {\n\t\txmldoc_reverse_helper(reverse, &len, &syntax,\n\t\t\t(printrootname ? (printrootname == 2 ? \")]\" : \")\"): \"\"));\n\t} else {\n\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s%s\", (printrootname ? rootname : \"\"),\n\t\t\t(printrootname ? (printrootname == 2 ? \"[(\" : \"(\") : \"\"));\n\t}\n\tfor (; node; node = GOTONEXT(reverse, node)) {\n\t\tif (strcasecmp(ast_xml_node_get_name(node), childname)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (xmldoc_has_inside(node, \"argument\")) {\n\t\t\tparenthesis = ast_xml_get_attribute(node, \"hasparams\");\n\t\t\tprnparenthesis = 0;\n\t\t\tif (parenthesis) {\n\t\t\t\tprnparenthesis = ast_true(parenthesis);\n\t\t\t\tif (!strcasecmp(parenthesis, \"optional\")) {\n\t\t\t\t\tprnparenthesis = 2;\n\t\t\t\t}\n\t\t\t\tast_xml_free_attr(parenthesis);\n\t\t\t}\n\t\t\targname = ast_xml_get_attribute(node, \"name\");\n\t\t\tif (argname) {\n\t\t\t\tparamname = xmldoc_get_syntax_fun(node, argname, \"argument\", prnparenthesis, prnparenthesis);\n\t\t\t\tast_xml_free_attr(argname);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tparamname = ast_strdup(\"**unknown**\");\n\t\t\t}\n\t\t} else {\n\t\t\tparamnameattr = ast_xml_get_attribute(node, \"name\");\n\t\t\tif (!paramnameattr) {\n\t\t\t\tast_log(LOG_WARNING, \"Malformed XML %s: no %s name\\n\", rootname, childname);\n\t\t\t\tif (syntax) {\n\t\t\t\t\t\n\t\t\t\t\tast_free(syntax);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ast_asprintf(&syntax, \"%s%s\", (printrootname ? rootname : \"\"), (printparenthesis ? \"()\" : \"\")) < 0) {\n\t\t\t\t\tsyntax = NULL;\n\t\t\t\t}\n\t\t\t\treturn syntax;\n\t\t\t}\n\t\t\tparamname = ast_strdup(paramnameattr);\n\t\t\tast_xml_free_attr(paramnameattr);\n\t\t}\n\t\tif (!paramname) {\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tmultiple = 0;\n\t\tif ((multipletype = ast_xml_get_attribute(node, \"multiple\"))) {\n\t\t\tif (ast_true(multipletype)) {\n\t\t\t\tmultiple = 1;\n\t\t\t}\n\t\t\tast_xml_free_attr(multipletype);\n\t\t}\n\t\trequired = 0;\t\n\t\tif ((paramtype = ast_xml_get_attribute(node, \"required\"))) {\n\t\t\tif (ast_true(paramtype)) {\n\t\t\t\trequired = 1;\n\t\t\t}\n\t\t\tast_xml_free_attr(paramtype);\n\t\t}\n\t\t\n\t\tif (required) {\n\t\t\t\n\t\t\tif (!paramcount) {\n\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s%s%s%s\", paramname, MP(\"[\"), MP(argsep), MP(\"...]\"));\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\twhile (openbrackets > 0) {\n\t\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, (reverse ? \"[\" : \"]\"));\n\t\t\t\t\topenbrackets--;\n\t\t\t\t}\n\t\t\t\tif (reverse) {\n\t\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s%s\", paramname, argsep);\n\t\t\t\t} else {\n\t\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s%s\", argsep, paramname);\n\t\t\t\t}\n\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s%s%s\", MP(\"[\"), MP(argsep), MP(\"...]\"));\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tif (!paramcount) {\n\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"[%s%s%s%s]\", paramname, MP(\"[\"), MP(argsep), MP(\"...]\"));\n\t\t\t} else {\n\t\t\t\tif (ISLAST(reverse, node)) {\n\t\t\t\t\t\n\t\t\t\t\tif (reverse) {\n\t\t\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"[%s%s%s%s]%s\", paramname,\n\t\t\t\t\t\t\t\t\tMP(\"[\"), MP(argsep), MP(\"...]\"), argsep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s[%s%s%s%s]\", argsep, paramname,\n\t\t\t\t\t\t\t\t\tMP(\"[\"), MP(argsep), MP(\"...]\"));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (reverse) {\n\t\t\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s%s%s%s%s]\", paramname, argsep,\n\t\t\t\t\t\t\t\t\tMP(\"[\"), MP(argsep), MP(\"...]\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"[%s%s%s%s%s\", argsep, paramname,\n\t\t\t\t\t\t\t\t\tMP(\"[\"), MP(argsep), MP(\"...]\"));\n\t\t\t\t\t}\n\t\t\t\t\topenbrackets++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tast_free(paramname);\n\t\tparamcount++;\n\t}\n\t\n\twhile (openbrackets > 0) {\n\t\txmldoc_reverse_helper(reverse, &len, &syntax, (reverse ? \"[\" : \"]\"));\n\t\topenbrackets--;\n\t}\n\t\n\tif (reverse) {\n\t\txmldoc_reverse_helper(reverse, &len, &syntax, \"%s%s\", (printrootname ? rootname : \"\"),\n\t\t\t(printrootname ? (printrootname == 2 ? \"[(\" : \"(\") : \"\"));\n\t} else {\n\t\txmldoc_reverse_helper(reverse, &len, &syntax, (printrootname ? (printrootname == 2 ? \")]\" : \")\") : \"\"));\n\t}\n\treturn syntax;\n#undef ISLAST\n#undef GOTONEXT\n#undef MP\n}\n", "bug_type": null, "idx": 2385}
{"project": "Asterisk", "target": 0, "func": "\nstatic int alias_hash_cb(const void *obj, const int flags)\n{\n\tconst struct cli_alias *alias = obj;\n\treturn ast_str_hash(alias->cli_entry.command);\n}\n", "bug_type": null, "idx": 2386}
{"project": "Asterisk", "target": 0, "func": "static int string_tolower2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t buflen)\n{\n\tchar *bufptr, *dataptr = data;\n\tif (buflen > -1) {\n\t\tast_str_make_space(buf, buflen > 0 ? buflen : strlen(data) + 1);\n\t}\n\tbufptr = ast_str_buffer(*buf);\n\twhile ((bufptr < ast_str_buffer(*buf) + ast_str_size(*buf) - 1) && (*bufptr++ = tolower(*dataptr++)));\n\tast_str_update(*buf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2387}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int eivr_comm(struct ast_channel *chan, struct ivr_localuser *u, \n\tstruct ast_iostream *eivr_events,\n\tstruct ast_iostream *eivr_commands,\n\tstruct ast_iostream *eivr_errors,\n\tconst struct ast_str *args, const struct ast_flags flags);\nstatic void send_eivr_event(struct ast_iostream *stream, const char event, const char *data,\n\tconst struct ast_channel *chan)\n{\n\tstruct ast_str *tmp = ast_str_create(12);\n\tast_str_append(&tmp, 0, \"%c,%10d\", event, (int)time(NULL));\n\tif (data) {\n\t\tast_str_append(&tmp, 0, \",%s\", data);\n\t}\n\tast_str_append(&tmp, 0, \"\\n\");\n\tast_iostream_write(stream, ast_str_buffer(tmp), strlen(ast_str_buffer(tmp)));\n\tast_str_truncate(tmp, -1);\n\tast_debug(1, \"sent '%s'\", ast_str_buffer(tmp));\n\tast_free(tmp);\n}\n}\nstatic int eivr_comm(struct ast_channel *chan, struct ivr_localuser *u, \n\t\t\t\tstruct ast_iostream *eivr_events,\n\t\t\t\tstruct ast_iostream *eivr_commands,\n\t\t\t\tstruct ast_iostream *eivr_errors,\n\t\t\t\tconst struct ast_str *args, const struct ast_flags flags)\n{\n\tchar input[1024];\n\tstruct playlist_entry *entry;\n\tstruct ast_frame *f;\n\tint ms;\n \tint exception;\n \tint ready_fd;\n\tint waitfds[2];\n\tint r;\n \tstruct ast_channel *rchan;\n \tint res = -1;\n\tint hangup_info_sent = 0;\n\twaitfds[0] = ast_iostream_get_fd(eivr_commands);\n\twaitfds[1] = eivr_errors ? ast_iostream_get_fd(eivr_errors) : -1;\n\twhile (1) {\n\t\tif (ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE)) {\n\t\t\tast_chan_log(LOG_ERROR, chan, \"Is a zombie\\n\");\n \t\t\tbreak;\n \t\t}\n \t\tif (!hangup_info_sent && !(ast_test_flag(&flags, run_dead)) && ast_check_hangup(chan)) {\n\t\t\tif (ast_test_flag(&flags, ignore_hangup)) {\n\t\t\t\tast_verb(3, \"Got check_hangup, but ignore_hangup set so sending 'I' command\\n\");\n\t\t\t\tsend_eivr_event(eivr_events, 'I', \"HANGUP\", chan);\n\t\t\t\thangup_info_sent = 1;\n\t\t\t} else {\n \t\t\t\tast_verb(3, \"Got check_hangup\\n\");\n \t\t\t\tsend_eivr_event(eivr_events, 'H', NULL, chan);\n\t \t\t\tbreak;\n\t\t\t}\n \t\t}\n \t\tready_fd = 0;\n \t\tms = 100;\n \t\terrno = 0;\n \t\texception = 0;\n\t\trchan = ast_waitfor_nandfds(&chan, 1, waitfds, (eivr_errors) ? 2 : 1, &exception, &ready_fd, &ms);\n \t\tif (ast_channel_state(chan) == AST_STATE_UP && !AST_LIST_EMPTY(&u->finishlist)) {\n \t\t\tAST_LIST_LOCK(&u->finishlist);\n \t\t\twhile ((entry = AST_LIST_REMOVE_HEAD(&u->finishlist, list))) {\n \t\t\t\tsend_eivr_event(eivr_events, 'F', entry->filename, chan);\n \t\t\t\tast_free(entry);\n \t\t\t}\n \t\t\tAST_LIST_UNLOCK(&u->finishlist);\n \t\t}\n \t\tif (ast_channel_state(chan) == AST_STATE_UP && !(ast_check_hangup(chan)) && rchan) {\n \t\t\t\n \t\t\tf = ast_read(chan);\n \t\t\tif (!f) {\n \t\t\t\tast_verb(3, \"Returned no frame\\n\");\n \t\t\t\tsend_eivr_event(eivr_events, 'H', NULL, chan);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tif (f->frametype == AST_FRAME_DTMF) {\n \t\t\t\tsend_eivr_event(eivr_events, f->subclass.integer, NULL, chan);\n \t\t\t\tif (u->option_autoclear) {\n  \t\t\t\t\tAST_LIST_LOCK(&u->playlist);\n  \t\t\t\t\tif (!u->abort_current_sound && !u->playing_silence) {\n\t\t\t\t\t\t\n \t\t\t\t\t\tif ((entry = AST_LIST_REMOVE_HEAD(&u->playlist, list))) {\n\t \t\t\t\t\t\tsend_eivr_event(eivr_events, 'T', entry->filename, chan);\n\t\t\t\t\t\t\tast_free(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n  \t\t\t\t\twhile ((entry = AST_LIST_REMOVE_HEAD(&u->playlist, list))) {\n \t\t\t\t\t\tsend_eivr_event(eivr_events, 'D', entry->filename, chan);\n  \t\t\t\t\t\tast_free(entry);\n  \t\t\t\t\t}\n  \t\t\t\t\tif (!u->playing_silence)\n  \t\t\t\t\t\tu->abort_current_sound = 1;\n  \t\t\t\t\tAST_LIST_UNLOCK(&u->playlist);\n  \t\t\t\t}\n \t\t\t} else if ((f->frametype == AST_FRAME_CONTROL) && (f->subclass.integer == AST_CONTROL_HANGUP)) {\n \t\t\t\tast_verb(3, \"Got AST_CONTROL_HANGUP\\n\");\n \t\t\t\tsend_eivr_event(eivr_events, 'H', NULL, chan);\n\t\t\t\tif (f->data.uint32) {\n\t\t\t\t\tast_channel_hangupcause_set(chan, f->data.uint32);\n\t\t\t\t}\n \t\t\t\tast_frfree(f);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tast_frfree(f);\n \t\t} else if (ready_fd == waitfds[0]) {\n \t\t\tif (exception) {\n \t\t\t\tast_chan_log(LOG_ERROR, chan, \"Child process went away\\n\");\n  \t\t\t\tbreak;\n  \t\t\t}\n\t\t\tr = ast_iostream_gets(eivr_commands, input, sizeof(input));\n\t\t\tif (r <= 0) {\n\t\t\t\tif (r == 0) {\n\t\t\t\t\tast_chan_log(LOG_ERROR, chan, \"Child process went away\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tast_strip(input);\n\t\t\tast_verb(4, \"got command '%s'\\n\", input);\n\t\t\tif (strlen(input) < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (input[0] == EIVR_CMD_PARM) {\n\t\t\t\tstruct ast_str *tmp = (struct ast_str *) args;\n\t\t\t\tsend_eivr_event(eivr_events, 'P', ast_str_buffer(tmp), chan);\n\t\t\t} else if (input[0] == EIVR_CMD_DTMF) {\n\t\t\t\tast_verb(4, \"Sending DTMF: %s\\n\", &input[2]);\n\t\t\t\tast_eivr_senddtmf(chan, &input[2]);\n\t\t\t} else if (input[0] == EIVR_CMD_ANS) {\n\t\t\t\tast_verb(3, \"Answering channel if needed and starting generator\\n\");\n\t\t\t\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\t\t\t\tif (ast_test_flag(&flags, run_dead)) {\n\t\t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Running ExternalIVR with 'd'ead flag on non-hungup channel isn't supported\\n\");\n\t\t\t\t\t\tsend_eivr_event(eivr_events, 'Z', \"ANSWER_FAILURE\", chan);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ast_answer(chan)) {\n\t\t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Failed to answer channel\\n\");\n\t\t\t\t\t\tsend_eivr_event(eivr_events, 'Z', \"ANSWER_FAILURE\", chan);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(u->gen_active)) {\n\t\t\t\t\tif (ast_activate_generator(chan, &gen, u) < 0) {\n\t\t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Failed to activate generator\\n\");\n\t\t\t\t\t\tsend_eivr_event(eivr_events, 'Z', \"GENERATOR_FAILURE\", chan);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu->gen_active = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (input[0] == EIVR_CMD_IRPT) {\n\t\t\t\tif (ast_channel_state(chan) != AST_STATE_UP || ast_check_hangup(chan)) {\n\t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Queue 'I'nterrupt called on unanswered channel\\n\");\n\t\t\t\t\tsend_eivr_event(eivr_events, 'Z', NULL, chan);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tAST_LIST_LOCK(&u->playlist);\n\t\t\t\tif (!u->abort_current_sound && !u->playing_silence) {\n\t\t\t\t\t\n\t\t\t\t\tif ((entry = AST_LIST_REMOVE_HEAD(&u->playlist, list))) {\n\t\t\t\t\t\tsend_eivr_event(eivr_events, 'T', entry->filename, chan);\n\t\t\t\t\t\tast_free(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ((entry = AST_LIST_REMOVE_HEAD(&u->playlist, list))) {\n\t\t\t\t\tsend_eivr_event(eivr_events, 'D', entry->filename, chan);\n\t\t\t\t\tast_free(entry);\n\t\t\t\t}\n\t\t\t\tif (!u->playing_silence) {\n\t\t\t\t\tu->abort_current_sound = 1;\n\t\t\t\t}\n\t\t\t\tAST_LIST_UNLOCK(&u->playlist);\n \t\t\t} else if (input[0] == EIVR_CMD_SQUE) {\n\t\t\t\tif (ast_channel_state(chan) != AST_STATE_UP || ast_check_hangup(chan)) {\n\t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Queue re'S'et called on unanswered channel\\n\");\n\t\t\t\t\tsend_eivr_event(eivr_events, 'Z', NULL, chan);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n \t\t\t\tif (!ast_fileexists(&input[2], NULL, ast_channel_language(u->chan))) {\n \t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Unknown file requested '%s'\\n\", &input[2]);\n \t\t\t\t\tsend_eivr_event(eivr_events, 'Z', &input[2], chan);\n \t\t\t\t} else {\n \t\t\t\t\tAST_LIST_LOCK(&u->playlist);\n\t \t\t\t\tif (!u->abort_current_sound && !u->playing_silence) {\n\t\t\t\t\t\t\n \t\t\t\t\t\tif ((entry = AST_LIST_REMOVE_HEAD(&u->playlist, list))) {\n\t \t\t\t\t\t\tsend_eivr_event(eivr_events, 'T', entry->filename, chan);\n\t\t\t\t\t\t\tast_free(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n \t\t\t\t\twhile ((entry = AST_LIST_REMOVE_HEAD(&u->playlist, list))) {\n \t\t\t\t\t\tsend_eivr_event(eivr_events, 'D', entry->filename, chan);\n \t\t\t\t\t\tast_free(entry);\n\t\t\t\t\t}\n\t \t\t\t\tif (!u->playing_silence) {\n \t\t\t\t\t\tu->abort_current_sound = 1;\n\t\t\t\t\t}\n \t\t\t\t\tentry = make_entry(&input[2]);\n \t\t\t\t\tif (entry) {\n \t\t\t\t\t\tAST_LIST_INSERT_TAIL(&u->playlist, entry, list);\n\t\t\t\t\t}\n\t \t\t\t\tAST_LIST_UNLOCK(&u->playlist);\n\t\t\t\t}\n \t\t\t} else if (input[0] == EIVR_CMD_APND) {\n\t\t\t\tif (ast_channel_state(chan) != AST_STATE_UP || ast_check_hangup(chan)) {\n\t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Queue 'A'ppend called on unanswered channel\\n\");\n\t\t\t\t\tsend_eivr_event(eivr_events, 'Z', NULL, chan);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n \t\t\t\tif (!ast_fileexists(&input[2], NULL, ast_channel_language(u->chan))) {\n \t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Unknown file requested '%s'\\n\", &input[2]);\n \t\t\t\t\tsend_eivr_event(eivr_events, 'Z', &input[2], chan);\n \t\t\t\t} else {\n\t \t\t\t\tentry = make_entry(&input[2]);\n \t\t\t\t\tif (entry) {\n \t\t\t\t\t\tAST_LIST_LOCK(&u->playlist);\n \t\t\t\t\t\tAST_LIST_INSERT_TAIL(&u->playlist, entry, list);\n \t\t\t\t\t\tAST_LIST_UNLOCK(&u->playlist);\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else if (input[0] == EIVR_CMD_GET) {\n \t\t\t\tchar response[2048];\n\t\t\t\tast_verb(4, \"Retriving Variables from channel: %s\\n\", &input[2]);\n \t\t\t\tast_eivr_getvariable(chan, &input[2], response, sizeof(response));\n \t\t\t\tsend_eivr_event(eivr_events, 'G', response, chan);\n \t\t\t} else if (input[0] == EIVR_CMD_SVAR) {\n\t\t\t\tast_verb(4, \"Setting Variables in channel: %s\\n\", &input[2]);\n \t\t\t\tast_eivr_setvariable(chan, &input[2]);\n \t\t\t} else if (input[0] == EIVR_CMD_LOG) {\n \t\t\t\tast_chan_log(LOG_NOTICE, chan, \"Log message from EIVR: %s\\n\", &input[2]);\n \t\t\t} else if (input[0] == EIVR_CMD_XIT) {\n \t\t\t\tast_chan_log(LOG_NOTICE, chan, \"Exiting: %s\\n\", &input[2]);\n\t\t\t\tast_chan_log(LOG_WARNING, chan, \"e'X'it command is depricated, use 'E'xit instead\\n\");\n \t\t\t\tres = 0;\n \t\t\t\tbreak;\n\t\t\t} else if (input[0] == EIVR_CMD_EXIT) {\n \t\t\t\tast_chan_log(LOG_NOTICE, chan, \"Exiting: %s\\n\", &input[2]);\n \t\t\t\tsend_eivr_event(eivr_events, 'E', NULL, chan);\n \t\t\t\tres = 0;\n \t\t\t\tbreak;\n \t\t\t} else if (input[0] == EIVR_CMD_HGUP) {\n \t\t\t\tast_chan_log(LOG_NOTICE, chan, \"Hanging up: %s\\n\", &input[2]);\n \t\t\t\tsend_eivr_event(eivr_events, 'H', NULL, chan);\n \t\t\t\tbreak;\n \t\t\t} else if (input[0] == EIVR_CMD_OPT) {\n\t\t\t\tif (ast_channel_state(chan) != AST_STATE_UP || ast_check_hangup(chan)) {\n\t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Option called on unanswered channel\\n\");\n\t\t\t\t\tsend_eivr_event(eivr_events, 'Z', NULL, chan);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n \t\t\t\tif (!strcasecmp(&input[2], \"autoclear\"))\n \t\t\t\t\tu->option_autoclear = 1;\n \t\t\t\telse if (!strcasecmp(&input[2], \"noautoclear\"))\n \t\t\t\t\tu->option_autoclear = 0;\n \t\t\t\telse\n \t\t\t\t\tast_chan_log(LOG_WARNING, chan, \"Unknown option requested: %s\\n\", &input[2]);\n \t\t\t}\n \t\t} else if (ready_fd == waitfds[1]) {\n \t\t\tif (exception) {\n \t\t\t\tast_chan_log(LOG_ERROR, chan, \"Child process went away\\n\");\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tr = ast_iostream_gets(eivr_errors, input, sizeof(input));\n \t\t\tif (r > 0) {\n \t\t\t\tast_chan_log(LOG_NOTICE, chan, \"stderr: %s\\n\", ast_strip(input));\n \t\t\t} else if (r == 0) {\n \t\t\t\tast_chan_log(LOG_ERROR, chan, \"Child process went away\\n\");\n \t\t\t\tbreak;\n\t\t\t}\n \t\t} else if ((ready_fd < 0) && ms) { \n \t\t\tif (errno == 0 || errno == EINTR)\n \t\t\t\tcontinue;\n \t\t\tast_chan_log(LOG_ERROR, chan, \"Wait failed (%s)\\n\", strerror(errno));\n \t\t\tbreak;\n \t\t}\n \t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2388}
{"project": "Asterisk", "target": 0, "func": "static int cache_lookup_internal(time_t now, struct dundi_request *req, char *key, char *eid_str_full, int *lowexpiration)\n{\n\tchar data[1024];\n\tchar *ptr, *term, *src;\n\tint tech;\n\tstruct ast_flags flags;\n\tint weight;\n\tint length;\n\tint z;\n\tchar fs[256];\n\t\n\tif (!ast_db_get(\"dundi/cache\", key, data, sizeof(data))) {\n\t\ttime_t timeout;\n\t\tptr = data;\n\t\tif (!ast_get_time_t(ptr, &timeout, 0, &length)) {\n\t\t\tint expiration = timeout - now;\n\t\t\tif (expiration > 0) {\n\t\t\t\tast_debug(1, \"Found cache expiring in %d seconds!\\n\", expiration);\n\t\t\t\tptr += length + 1;\n\t\t\t\twhile((sscanf(ptr, \"%30d/%30d/%30d/%n\", (int *)&(flags.flags), &weight, &tech, &length) == 3)) {\n\t\t\t\t\tptr += length;\n\t\t\t\t\tterm = strchr(ptr, '|');\n\t\t\t\t\tif (term) {\n\t\t\t\t\t\t*term = '\\0';\n\t\t\t\t\t\tsrc = strrchr(ptr, '/');\n\t\t\t\t\t\tif (src) {\n\t\t\t\t\t\t\t*src = '\\0';\n\t\t\t\t\t\t\tsrc++;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tsrc = \"\";\n\t\t\t\t\t\tast_debug(1, \"Found cached answer '%s/%s' originally from '%s' with flags '%s' on behalf of '%s'\\n\",\n\t\t\t\t\t\t\ttech2str(tech), ptr, src, dundi_flags2str(fs, sizeof(fs), flags.flags), eid_str_full);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (z=0;z<req->respcount;z++) {\n\t\t\t\t\t\t\tif ((req->dr[z].techint == tech) &&\n\t\t\t\t\t\t\t    !strcmp(req->dr[z].dest, ptr))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (z == req->respcount) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tast_copy_flags(&(req->dr[req->respcount]), &flags, AST_FLAGS_ALL);\n\t\t\t\t\t\t\treq->dr[req->respcount].weight = weight;\n\t\t\t\t\t\t\treq->dr[req->respcount].techint = tech;\n\t\t\t\t\t\t\treq->dr[req->respcount].expiration = expiration;\n\t\t\t\t\t\t\tdundi_str_short_to_eid(&req->dr[req->respcount].eid, src);\n\t\t\t\t\t\t\tast_eid_to_str(req->dr[req->respcount].eid_str,\n\t\t\t\t\t\t\t\tsizeof(req->dr[req->respcount].eid_str), &req->dr[req->respcount].eid);\n\t\t\t\t\t\t\tast_copy_string(req->dr[req->respcount].dest, ptr,\n\t\t\t\t\t\t\t\tsizeof(req->dr[req->respcount].dest));\n\t\t\t\t\t\t\tast_copy_string(req->dr[req->respcount].tech, tech2str(tech),\n\t\t\t\t\t\t\t\tsizeof(req->dr[req->respcount].tech));\n\t\t\t\t\t\t\treq->respcount++;\n\t\t\t\t\t\t\tast_clear_flag_nonstd(req->hmd, DUNDI_HINT_DONT_ASK);\n\t\t\t\t\t\t} else if (req->dr[z].weight > weight)\n\t\t\t\t\t\t\treq->dr[z].weight = weight;\n\t\t\t\t\t\tptr = term + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (expiration < *lowexpiration)\n\t\t\t\t\t*lowexpiration = expiration;\n\t\t\t\treturn 1;\n\t\t\t} else\n\t\t\t\tast_db_del(\"dundi/cache\", key);\n\t\t} else\n\t\t\tast_db_del(\"dundi/cache\", key);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2389}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void sla_add_trunk_to_station(struct sla_station *station, struct ast_variable *var)\n{\n\tRAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);\n\tstruct sla_trunk_ref *trunk_ref = NULL;\n\tstruct sla_station_ref *station_ref;\n\tchar *trunk_name, *options, *cur;\n\tint existing_trunk_ref = 0;\n\tint existing_station_ref = 0;\n\toptions = ast_strdupa(var->value);\n\ttrunk_name = strsep(&options, \",\");\n\ttrunk = sla_find_trunk(trunk_name);\n\tif (!trunk) {\n\t\tast_log(LOG_ERROR, \"Trunk '%s' not found!\\n\", var->value);\n\t\treturn;\n\t}\n\tAST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {\n\t\tif (trunk_ref->trunk == trunk) {\n\t\t\ttrunk_ref->mark = 0;\n\t\t\texisting_trunk_ref = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!trunk_ref && !(trunk_ref = create_trunk_ref(trunk))) {\n\t\treturn;\n\t}\n\ttrunk_ref->state = SLA_TRUNK_STATE_IDLE;\n\twhile ((cur = strsep(&options, \",\"))) {\n\t\tchar *name, *value = cur;\n\t\tname = strsep(&value, \"=\");\n\t\tif (!strcasecmp(name, \"ringtimeout\")) {\n\t\t\tif (sscanf(value, \"%30u\", &trunk_ref->ring_timeout) != 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid ringtimeout value '%s' for \"\n\t\t\t\t\t\"trunk '%s' on station '%s'\\n\", value, trunk->name, station->name);\n\t\t\t\ttrunk_ref->ring_timeout = 0;\n\t\t\t}\n\t\t} else if (!strcasecmp(name, \"ringdelay\")) {\n\t\t\tif (sscanf(value, \"%30u\", &trunk_ref->ring_delay) != 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid ringdelay value '%s' for \"\n\t\t\t\t\t\"trunk '%s' on station '%s'\\n\", value, trunk->name, station->name);\n\t\t\t\ttrunk_ref->ring_delay = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Invalid option '%s' for \"\n\t\t\t\t\"trunk '%s' on station '%s'\\n\", name, trunk->name, station->name);\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {\n\t\tif (station_ref->station == station) {\n\t\t\tstation_ref->mark = 0;\n\t\t\texisting_station_ref = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!station_ref && !(station_ref = sla_create_station_ref(station))) {\n\t\tif (!existing_trunk_ref) {\n\t\t\tao2_ref(trunk_ref, -1);\n\t\t} else {\n\t\t\ttrunk_ref->mark = 1;\n\t\t}\n\t\treturn;\n\t}\n\tif (!existing_station_ref) {\n\t\tao2_lock(trunk);\n\t\tAST_LIST_INSERT_TAIL(&trunk->stations, station_ref, entry);\n\t\tast_atomic_fetchadd_int((int *) &trunk->num_stations, 1);\n\t\tao2_unlock(trunk);\n\t}\n\tif (!existing_trunk_ref) {\n\t\tao2_lock(station);\n\t\tAST_LIST_INSERT_TAIL(&station->trunks, trunk_ref, entry);\n\t\tao2_unlock(station);\n\t}\n}\n", "bug_type": null, "idx": 2390}
{"project": "Asterisk", "target": 0, "func": "\nem_kill_line(EditLine *el, int c)\n{\n\tchar *kp, *cp;\n\tcp = el->el_line.buffer;\n\tkp = el->el_chared.c_kill.buf;\n\twhile (cp < el->el_line.lastchar)\n\t\t*kp++ = *cp++;\t\n\tel->el_chared.c_kill.last = kp;\n\t\t\t\t\n\tel->el_line.lastchar = el->el_line.buffer;\n\tel->el_line.cursor = el->el_line.buffer;\n\treturn (CC_REFRESH);\n}\n", "bug_type": null, "idx": 2391}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void command_dtor(void *obj)\n{\n\tstruct stasis_app_command *command = obj;\n\tif (command->data_destructor) {\n\t\tcommand->data_destructor(command->data);\n\t}\n\tast_mutex_destroy(&command->lock);\n\tast_cond_destroy(&command->condition);\n}\n", "bug_type": null, "idx": 2392}
{"project": "Asterisk", "target": 0, "func": "#include \"asterisk/test.h\"\nAST_TEST_DEFINE(sample_test)\n{\n\tvoid *ptr;\n\tswitch (cmd) {\n\tcase TEST_INIT:\n\t\tinfo->name = \"sample_test\";\n\t\tinfo->category = \"/main/sample/\";\n\t\tinfo->summary = \"sample unit test\";\n\t\tinfo->description =\n\t\t\t\"This demonstrates what is required to implement \"\n\t\t\t\"a unit test.\";\n\t\treturn AST_TEST_NOT_RUN;\n\tcase TEST_EXECUTE:\n\t\tbreak;\n\t}\n\tast_test_status_update(test, \"Executing sample test...\\n\");\n\tif (!(ptr = ast_malloc(8))) {\n\t\tast_test_status_update(test, \"ast_malloc() failed\\n\");\n\t\treturn AST_TEST_FAIL;\n\t}\n\tast_free(ptr);\n\treturn AST_TEST_PASS;\n}\n", "bug_type": null, "idx": 2393}
{"project": "Asterisk", "target": 0, "func": "#if defined(HAVE_SS7)\nstatic char *handle_ss7_group_reset(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint linkset, cic, range;\n\tunsigned int dpc;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"ss7 reset group\";\n\t\te->usage =\n\t\t\t\"Usage: ss7 reset group <linkset> <dpc> <1st CIC> <range>\\n\"\n\t\t\t\"       Send a GRS for the given CIC range on the specified linkset\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc == 7) {\n\t\tlinkset = atoi(a->argv[3]);\n\t} else {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif ((linkset < 1) || (linkset > NUM_SPANS)) {\n\t\tast_cli(a->fd, \"Invalid linkset %s.  Should be a number %d to %d\\n\", a->argv[4], 1, NUM_SPANS);\n\t\treturn CLI_SUCCESS;\n\t}\n\tif (!linksets[linkset-1].ss7.ss7) {\n\t\tast_cli(a->fd, \"No SS7 running on linkset %d\\n\", linkset);\n\t\treturn CLI_SUCCESS;\n\t}\n\tcic = atoi(a->argv[5]);\n\tif (cic < 1) {\n\t\tast_cli(a->fd, \"Invalid CIC specified!\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\trange = atoi(a->argv[6]);\n\tif (range < 1 || range > (linksets[linkset - 1].ss7.type == SS7_ANSI ? 24 : 31)) {\n\t\tast_cli(a->fd, \"Invalid range specified!\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\tdpc = atoi(a->argv[4]);\n\tif (dpc < 1) {\n\t\tast_cli(a->fd, \"Invalid DPC specified!\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\tast_mutex_lock(&linksets[linkset-1].ss7.lock);\n\tif (!sig_ss7_find_cic_range(&linksets[linkset-1].ss7, cic, cic + range, dpc)) {\n\t\tast_mutex_unlock(&linksets[linkset-1].ss7.lock);\n\t\tast_cli(a->fd, \"Invalid CIC/RANGE\\n\");\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (sig_ss7_reset_group(&linksets[linkset-1].ss7, cic, dpc, range)) {\n\t\tast_cli(a->fd, \"Unable to allocate new ss7call\\n\");\n\t} else {\n\t\tast_cli(a->fd, \"GRS sent ... \\n\");\n\t}\n\tast_mutex_unlock(&linksets[linkset-1].ss7.lock);\n\t\n\tif (linksets[linkset-1].ss7.master != AST_PTHREADT_NULL) {\n\t\tpthread_kill(linksets[linkset-1].ss7.master, SIGURG);\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2394}
{"project": "Asterisk", "target": 0, "func": "};\nconst char *ast_get_include_name(const struct ast_include *inc)\n{\n\treturn inc ? inc->name : NULL;\n}\n", "bug_type": null, "idx": 2395}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct sla_trunk_ref *sla_find_trunk_ref_byname(const struct sla_station *station,\n\tconst char *name)\n{\n\tstruct sla_trunk_ref *trunk_ref = NULL;\n\tAST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {\n\t\tif (strcasecmp(trunk_ref->trunk->name, name))\n\t\t\tcontinue;\n\t\tif ( (trunk_ref->trunk->barge_disabled \n\t\t\t&& trunk_ref->state == SLA_TRUNK_STATE_UP) ||\n\t\t\t(trunk_ref->trunk->hold_stations \n\t\t\t&& trunk_ref->trunk->hold_access == SLA_HOLD_PRIVATE\n\t\t\t&& trunk_ref->state != SLA_TRUNK_STATE_ONHOLD_BYME) ||\n\t\t\tsla_check_station_hold_access(trunk_ref->trunk, station) ) \n\t\t{\n\t\t\ttrunk_ref = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\tif (trunk_ref) {\n\t\tao2_ref(trunk_ref, 1);\n\t}\n\treturn trunk_ref;\n}\n", "bug_type": null, "idx": 2396}
{"project": "Asterisk", "target": 0, "func": "static int test_semi(char *string1, char *string2, int test_len)\n{\n\tchar *test2 = NULL;\n\tif (test_len > 0) {\n\t\ttest2 = ast_alloca(test_len);\n\t\t*test2 = '\\0';\n\t} else if (test_len == 0) {\n\t\ttest2 = \"\";\n\t}\n\tast_escape_semicolons(string1, test2, test_len);\n\tif (test2 != NULL && strcmp(string2, test2) == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 2397}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void ast_ari_recordings_delete_stored_cb(\n\tstruct ast_tcptls_session_instance *ser,\n\tstruct ast_variable *get_params, struct ast_variable *path_vars,\n\tstruct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)\n{\n\tstruct ast_ari_recordings_delete_stored_args args = {};\n\tstruct ast_variable *i;\n#if defined(AST_DEVMODE)\n\tint is_valid;\n\tint code;\n#endif \n\tfor (i = path_vars; i; i = i->next) {\n\t\tif (strcmp(i->name, \"recordingName\") == 0) {\n\t\t\targs.recording_name = (i->value);\n\t\t} else\n\t\t{}\n\t}\n\tast_ari_recordings_delete_stored(headers, &args, response);\n#if defined(AST_DEVMODE)\n\tcode = response->response_code;\n\tswitch (code) {\n\tcase 0: \n\t\tis_valid = response->message == NULL;\n\t\tbreak;\n\tcase 500: \n\tcase 501: \n\tcase 404: \n\t\tis_valid = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (200 <= code && code <= 299) {\n\t\t\tis_valid = ast_ari_validate_void(\n\t\t\t\tresponse->message);\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Invalid error response %d for /recordings/stored/{recordingName}\\n\", code);\n\t\t\tis_valid = 0;\n\t\t}\n\t}\n\tif (!is_valid) {\n\t\tast_log(LOG_ERROR, \"Response validation failed for /recordings/stored/{recordingName}\\n\");\n\t\tast_ari_response_error(response, 500,\n\t\t\t\"Internal Server Error\", \"Response validation failed\");\n\t}\n#endif \nfin: __attribute__((unused))\n\treturn;\n}\n", "bug_type": null, "idx": 2398}
{"project": "Asterisk", "target": 0, "func": "static struct ast_custom_function group_list_function = {\n\t.name = \"GROUP_LIST\",\n\t.read = group_list_function_read,\n\t.write = NULL,\n};\n}\nstatic struct ast_custom_function group_list_function = {\n\t.name = \"GROUP_LIST\",\n\t.read = group_list_function_read,\n\t.write = NULL,\n};\nstatic int unload_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_unregister(&group_count_function);\n\tres |= ast_custom_function_unregister(&group_match_count_function);\n\tres |= ast_custom_function_unregister(&group_list_function);\n\tres |= ast_custom_function_unregister(&group_function);\n\treturn res;\n}\nstatic int load_module(void)\n{\n\tint res = 0;\n\tres |= ast_custom_function_register(&group_count_function);\n\tres |= ast_custom_function_register(&group_match_count_function);\n\tres |= ast_custom_function_register(&group_list_function);\n\tres |= ast_custom_function_register(&group_function);\n\treturn res;\n}\nAST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, \"Channel group dialplan functions\");\n", "bug_type": null, "idx": 2399}
{"project": "Asterisk", "target": 0, "func": "int ast_rtp_instance_get_and_cmp_local_address(struct ast_rtp_instance *instance,\n\t\tstruct ast_sockaddr *address)\n{\n\tao2_lock(instance);\n\tif (ast_sockaddr_cmp(address, &instance->local_address) != 0) {\n\t\tast_sockaddr_copy(address, &instance->local_address);\n\t\tao2_unlock(instance);\n\t\treturn 1;\n\t}\n\tao2_unlock(instance);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2400}
{"project": "Asterisk", "target": 0, "func": "static int validate_ssrc(struct ast_test *test, struct ast_sdp_m_line *m_line,\n\tstruct ast_rtp_instance *rtp)\n{\n\tunsigned int ssrc;\n\tconst char *cname;\n\tstruct ast_sdp_a_line *a_line;\n\tchar attr_value[128];\n\tssrc = ast_rtp_instance_get_ssrc(rtp);\n\tcname = ast_rtp_instance_get_cname(rtp);\n\tsnprintf(attr_value, sizeof(attr_value), \"%u cname:%s\", ssrc, cname);\n\ta_line = ast_sdp_m_find_attribute(m_line, \"ssrc\", -1);\n\tif (!a_line) {\n\t\tast_test_status_update(test, \"Could not find 'ssrc' attribute\\n\");\n\t\treturn -1;\n\t}\n\tif (strcmp(a_line->value, attr_value)) {\n\t\tast_test_status_update(test, \"SDP attribute '%s' did not match expected attribute '%s'\\n\",\n\t\t\ta_line->value, attr_value);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2401}
{"project": "Asterisk", "target": 0, "func": "int misdn_cfg_is_port_valid (int port)\n{\n\tint gn = map[MISDN_CFG_GROUPNAME];\n\treturn (port >= 1 && port <= max_ports && port_cfg[port][gn].str);\n}\n", "bug_type": null, "idx": 2402}
{"project": "Asterisk", "target": 0, "func": "static int yy_init_globals (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    \n    yyg->yy_buffer_stack = 0;\n    yyg->yy_buffer_stack_top = 0;\n    yyg->yy_buffer_stack_max = 0;\n    yyg->yy_c_buf_p = (char *) 0;\n    yyg->yy_init = 0;\n    yyg->yy_start = 0;\n    yyg->yy_start_stack_ptr = 0;\n    yyg->yy_start_stack_depth = 0;\n    yyg->yy_start_stack =  NULL;\n\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n    \n    return 0;\n}\n", "bug_type": null, "idx": 2403}
{"project": "Asterisk", "target": 0, "func": "pthread_t ast_channel_blocker(const struct ast_channel *chan)\n{\n\treturn chan->blocker;\n}\n", "bug_type": null, "idx": 2404}
{"project": "Asterisk", "target": 0, "func": "struct ast_cc_config_params *__ast_cc_config_params_init(const char *file, int line, const char *function)\n{\n\tstruct ast_cc_config_params *params = __ast_malloc(sizeof(*params), file, line, function);\n\tif (!params) {\n\t\treturn NULL;\n\t}\n\tast_cc_default_config_params(params);\n\treturn params;\n}\n", "bug_type": null, "idx": 2405}
{"project": "Asterisk", "target": 0, "func": "static struct pval *find_label_in_current_extension(const char *label, pval *curr_ext)\n{\n\t\n\tcount_labels = 0;\n\treturn_on_context_match = 0;\n\tmatch_context = \"*\";\n\tmatch_exten = \"*\";\n\tmatch_label = label;\n\treturn match_pval(curr_ext);\n}\n", "bug_type": null, "idx": 2406}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int find_unused_payload(const struct ast_rtp_codecs *codecs)\n{\n\tint res;\n\t\n\tres = find_unused_payload_in_range(\n\t\tcodecs, AST_RTP_PT_FIRST_DYNAMIC, AST_RTP_MAX_PT, static_RTP_PT);\n\tif (res != -1) {\n\t\treturn res;\n\t}\n\tif (ast_option_rtpusedynamic) {\n\t\t\n\t\tstatic struct ast_rtp_payload_type *ignore[AST_RTP_MAX_PT] = {0};\n\t\tignore[101] = static_RTP_PT[101];\n\t\tignore[121] = static_RTP_PT[121];\n\t\tres = find_unused_payload_in_range(\n\t\t\tcodecs, AST_RTP_PT_FIRST_DYNAMIC, AST_RTP_MAX_PT, ignore);\n\t\tif (res != -1) {\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tres = find_unused_payload_in_range(\n\t\tcodecs, MAX(ast_option_rtpptdynamic, AST_RTP_PT_LAST_STATIC + 1),\n\t\tAST_RTP_PT_LAST_REASSIGN, static_RTP_PT);\n\tif (res != -1) {\n\t\treturn res;\n\t}\n\t\n\tres = find_unused_payload_in_range(\n\t\tcodecs, MAX(ast_option_rtpptdynamic, 20),\n\t\tAST_RTP_PT_LAST_STATIC + 1, static_RTP_PT);\n\tif (res != -1) {\n\t\treturn res;\n\t}\n\treturn find_unused_payload_in_range(\n\t\tcodecs, MAX(ast_option_rtpptdynamic, 0),\n\t\t20, static_RTP_PT);\n}\n", "bug_type": null, "idx": 2407}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int console_state_init(void *ptr)\n{\n\tstruct console_state_data *state = ptr;\n\tstate->verbose_line_level = 0;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2408}
{"project": "Asterisk", "target": 0, "func": "static int parse_args(char *s, int *max, const char *argv[])\n{\n\tint x = 0, quoted = 0, escaped = 0, whitespace = 1;\n\tchar *cur;\n\tcur = s;\n\twhile(*s) {\n\t\tswitch(*s) {\n\t\tcase '\"':\n\t\t\t\n\t\t\tif (escaped)\n\t\t\t\tgoto normal;\n\t\t\telse\n\t\t\t\tquoted = !quoted;\n\t\t\tif (quoted && whitespace) {\n\t\t\t\t\n\t\t\t\targv[x++] = cur;\n\t\t\t\twhitespace=0;\n\t\t\t}\n\t\t\tescaped = 0;\n\t\tbreak;\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t\tif (!quoted && !escaped) {\n\t\t\t\t\n\t\t\t\twhitespace = 1;\n\t\t\t\t*(cur++) = '\\0';\n\t\t\t} else\n\t\t\t\t\n\t\t\t\tgoto normal;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t\n\t\t\tif (escaped) {\n\t\t\t\tgoto normal;\n\t\t\t} else {\n\t\t\t\tescaped=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\nnormal:\n\t\t\tif (whitespace) {\n\t\t\t\tif (x >= MAX_ARGS -1) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Too many arguments, truncating\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\targv[x++] = cur;\n\t\t\t\twhitespace=0;\n\t\t\t}\n\t\t\t*(cur++) = *s;\n\t\t\tescaped=0;\n\t\t}\n\t\ts++;\n\t}\n\t\n\t*(cur++) = '\\0';\n\targv[x] = NULL;\n\t*max = x;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2409}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225NonStandardMessage (OOCTXT* pctxt, H225NonStandardMessage* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   OOCTXT lctxt2;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   memset (&pvalue->m, 0, sizeof(pvalue->m));\n   \n   invokeStartElement (pctxt, \"requestSeqNum\", -1);\n   stat = asn1PD_H225RequestSeqNum (pctxt, &pvalue->requestSeqNum);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"requestSeqNum\", -1);\n   \n   invokeStartElement (pctxt, \"nonStandardData\", -1);\n   stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"nonStandardData\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            if (i < 5 && openType.numocts > 0) {  \n               copyContext (&lctxt2, pctxt);\n               initContextBuffer (pctxt, openType.data, openType.numocts);\n               switch (i) {\n                  case 0:\n                     pvalue->m.tokensPresent = 1;\n                     invokeStartElement (pctxt, \"tokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"tokens\", -1);\n                     break;\n                  case 1:\n                     pvalue->m.cryptoTokensPresent = 1;\n                     invokeStartElement (pctxt, \"cryptoTokens\", -1);\n                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"cryptoTokens\", -1);\n                     break;\n                  case 2:\n                     pvalue->m.integrityCheckValuePresent = 1;\n                     invokeStartElement (pctxt, \"integrityCheckValue\", -1);\n                     stat = asn1PD_H225ICV (pctxt, &pvalue->integrityCheckValue);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"integrityCheckValue\", -1);\n                     break;\n                  case 3:\n                     pvalue->m.featureSetPresent = 1;\n                     invokeStartElement (pctxt, \"featureSet\", -1);\n                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"featureSet\", -1);\n                     break;\n                  case 4:\n                     pvalue->m.genericDataPresent = 1;\n                     invokeStartElement (pctxt, \"genericData\", -1);\n                     stat = asn1PD_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);\n                     if (stat != ASN_OK) return stat;\n                     invokeEndElement (pctxt, \"genericData\", -1);\n                     break;\n                  default:\n                     pctxt->buffer.byteIndex += openType.numocts;\n               }\n               copyContext (pctxt, &lctxt2);\n            }\n            else {  \n               pctxt->buffer.byteIndex += openType.numocts;\n            }\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2410}
{"project": "Asterisk", "target": 0, "func": "   capabilities */\nint ooCallAddG726Capability(OOH323CallData *call, int cap, int txframes, \n                            int rxframes, OOBOOL silenceSuppression, int dir,\n                            cb_StartReceiveChannel startReceiveChannel,\n                            cb_StartTransmitChannel startTransmitChannel,\n                            cb_StopReceiveChannel stopReceiveChannel,\n                            cb_StopTransmitChannel stopTransmitChannel)\n{\n   return ooCapabilityAddSimpleCapability(call, cap, txframes, rxframes, \n                                silenceSuppression, dir, startReceiveChannel, \n                                startTransmitChannel, stopReceiveChannel, \n                                stopTransmitChannel, FALSE);\n}\n/*\nint ooCallAddG726Capability(OOH323CallData *call, int cap, int txframes, \n                            int rxframes, int dir,\n                            cb_StartReceiveChannel startReceiveChannel,\n                            cb_StartTransmitChannel startTransmitChannel,\n                            cb_StopReceiveChannel stopReceiveChannel,\n                            cb_StopTransmitChannel stopTransmitChannel)\n{\n   return ooCapabilityAddSimpleCapability(call, cap, txframes, rxframes, FALSE,\n                          dir, startReceiveChannel, startTransmitChannel, \n                          stopReceiveChannel, stopTransmitChannel, FALSE);\n}\n", "bug_type": null, "idx": 2411}
{"project": "Asterisk", "target": 0, "func": "static void *softmix_translate_helper_free_entry(struct softmix_translate_helper_entry *entry)\n{\n\tao2_cleanup(entry->dst_format);\n\tif (entry->trans_pvt) {\n\t\tast_translator_free_path(entry->trans_pvt);\n\t}\n\tif (entry->out_frame) {\n\t\tast_frfree(entry->out_frame);\n\t}\n\tast_free(entry);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2412}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_frame *native_rtp_framehook(struct ast_channel *chan,\n\tstruct ast_frame *f, enum ast_framehook_event event, void *data)\n{\n\tstruct ast_bridge *bridge;\n\tstruct native_rtp_framehook_data *native_data = data;\n\tif (!f\n\t\t|| f->frametype != AST_FRAME_CONTROL\n\t\t|| event != AST_FRAMEHOOK_EVENT_WRITE) {\n\t\treturn f;\n\t}\n\tbridge = ast_channel_get_bridge(chan);\n\tif (bridge) {\n\t\t\n\t\tast_channel_unlock(chan);\n\t\tast_bridge_lock(bridge);\n\t\tif (!native_data->detached) {\n\t\t\tswitch (f->subclass.integer) {\n\t\t\tcase AST_CONTROL_HOLD:\n\t\t\t\tnative_rtp_bridge_stop(bridge, chan);\n\t\t\t\tbreak;\n\t\t\tcase AST_CONTROL_UNHOLD:\n\t\t\tcase AST_CONTROL_UPDATE_RTP_PEER:\n\t\t\t\tnative_rtp_bridge_start(bridge, chan);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tast_bridge_unlock(bridge);\n\t\tao2_ref(bridge, -1);\n\t\tast_channel_lock(chan);\n\t}\n\treturn f;\n}\n", "bug_type": null, "idx": 2413}
{"project": "Asterisk", "target": 0, "func": "int ooCreateQ931Message(OOCTXT* pctxt, Q931Message **q931msg, int msgType)\n{\n   \n   *q931msg = (Q931Message*)memAllocZ(pctxt, sizeof(Q931Message));\n   if(!*q931msg)\n   {\n      OOTRACEERR1(\"Error:Memory -  ooCreateQ931Message - q931msg\\n\");\n      return OO_FAILED;\n   }\n   else\n   {\n      (*q931msg)->protocolDiscriminator = 8;\n      (*q931msg)->fromDestination = FALSE;\n      (*q931msg)->messageType = msgType;\n      (*q931msg)->tunneledMsgType = msgType;\n      (*q931msg)->logicalChannelNo = 0;\n      (*q931msg)->bearerCapabilityIE = NULL;\n      (*q931msg)->callingPartyNumberIE = NULL;\n      (*q931msg)->calledPartyNumberIE = NULL;\n      (*q931msg)->causeIE = NULL;\n      (*q931msg)->callstateIE = NULL;\n      return OO_OK;\n   }\n}\n", "bug_type": null, "idx": 2414}
{"project": "Asterisk", "target": 0, "func": "static char *handle_cli_osp_show(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tint i;\n\tint found = 0;\n\tstruct osp_provider* provider;\n\tconst char* name = NULL;\n\tconst char* tokenalgo;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"osp show\";\n\t\te->usage =\n\t\t\t\"Usage: osp show\\n\"\n\t\t\t\"       Displays information on Open Settlement Protocol support\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif ((a->argc < 2) || (a->argc > 3)) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tif (a->argc > 2) {\n\t\tname = a->argv[2];\n\t}\n\tif (!name) {\n\t\tswitch (osp_tokenformat) {\n\t\tcase TOKEN_ALGO_BOTH:\n\t\t\ttokenalgo = \"Both\";\n\t\t\tbreak;\n\t\tcase TOKEN_ALGO_UNSIGNED:\n\t\t\ttokenalgo = \"Unsigned\";\n\t\t\tbreak;\n\t\tcase TOKEN_ALGO_SIGNED:\n\t\tdefault:\n\t\t\ttokenalgo = \"Signed\";\n\t\t\tbreak;\n\t\t}\n\t\tast_cli(a->fd, \"OSP: %s/%s/%s/%s\\n\",\n\t\t\tosp_initialized ? \"Initialized\" : \"Uninitialized\",\n\t\t\tosp_hardware ? \"Accelerated\" : \"Normal\",\n\t\t\tosp_security ? \"Enabled\" : \"Disabled\",\n\t\t\ttokenalgo);\n\t}\n\tast_mutex_lock(&osp_lock);\n\tfor (provider = osp_providers; provider; provider = provider->next) {\n\t\tif (!name || !strcasecmp(provider->name, name)) {\n\t\t\tif (found) {\n\t\t\t\tast_cli(a->fd, \"\\n\");\n\t\t\t}\n\t\t\tast_cli(a->fd, \" == OSP Provider '%s' == \\n\", provider->name);\n\t\t\tif (osp_security) {\n\t\t\t\tast_cli(a->fd, \"Local Private Key: %s\\n\", provider->privatekey);\n\t\t\t\tast_cli(a->fd, \"Local Certificate: %s\\n\", provider->localcert);\n\t\t\t\tfor (i = 0; i < provider->canum; i++) {\n\t\t\t\t\tast_cli(a->fd, \"CA Certificate %d:  %s\\n\", i + 1, provider->cacerts[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < provider->spnum; i++) {\n\t\t\t\tast_cli(a->fd, \"Service Point %d:   %s\\n\", i + 1, provider->spoints[i]);\n\t\t\t}\n\t\t\tast_cli(a->fd, \"Max Connections:   %d\\n\", provider->maxconnect);\n\t\t\tast_cli(a->fd, \"Retry Delay:       %d seconds\\n\", provider->retrydelay);\n\t\t\tast_cli(a->fd, \"Retry Limit:       %d\\n\", provider->retrylimit);\n\t\t\tast_cli(a->fd, \"Timeout:           %d milliseconds\\n\", provider->timeout);\n\t\t\tast_cli(a->fd, \"Source:            %s\\n\", strlen(provider->source) ? provider->source : \"<unspecified>\");\n\t\t\tast_cli(a->fd, \"Auth Policy        %d\\n\", provider->authpolicy);\n\t\t\tast_cli(a->fd, \"Default protocol   %s\\n\", provider->defprotocol);\n\t\t\tast_cli(a->fd, \"Work mode          %d\\n\", provider->workmode);\n\t\t\tast_cli(a->fd, \"Service type       %d\\n\", provider->srvtype);\n\t\t\tast_cli(a->fd, \"OSP Handle:        %d\\n\", provider->handle);\n\t\t\tfound++;\n\t\t}\n\t}\n\tast_mutex_unlock(&osp_lock);\n\tif (!found) {\n\t\tif (name) {\n\t\t\tast_cli(a->fd, \"Unable to find OSP provider '%s'\\n\", name);\n\t\t} else {\n\t\t\tast_cli(a->fd, \"No OSP providers configured\\n\");\n\t\t}\n\t}\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2415}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H225UnregRejectReason (OOCTXT* pctxt, H225UnregRejectReason* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   OOCTXT lctxt;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"notCurrentlyRegistered\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"notCurrentlyRegistered\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"callInProgress\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"callInProgress\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"undefinedReason\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"undefinedReason\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 4;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n      copyContext (&lctxt, pctxt);\n      initContextBuffer (pctxt, openType.data, openType.numocts);\n      switch (pvalue->t) {\n         \n         case 4:\n            invokeStartElement (pctxt, \"permissionDenied\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"permissionDenied\", -1);\n            break;\n         \n         case 5:\n            invokeStartElement (pctxt, \"securityDenial\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"securityDenial\", -1);\n            break;\n         \n         case 6:\n            invokeStartElement (pctxt, \"securityError\", -1);\n            pvalue->u.securityError = ALLOC_ASN1ELEM (pctxt, H225SecurityErrors2);\n            stat = asn1PD_H225SecurityErrors2 (pctxt, pvalue->u.securityError);\n            if (stat != ASN_OK) return stat;\n            invokeEndElement (pctxt, \"securityError\", -1);\n            break;\n         default:;\n      }\n      copyContext (pctxt, &lctxt);\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2416}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void bridge_action_bridge(struct ast_bridge *bridge, struct ast_frame *action)\n{\n#if 0\t\n\tint in_destructor = !ao2_ref(bridge, 0);\n#endif\n\tswitch (action->subclass.integer) {\n\tcase BRIDGE_CHANNEL_ACTION_DEFERRED_TECH_DESTROY:\n\t\tast_bridge_unlock(bridge);\n\t\tbridge_tech_deferred_destroy(bridge, action);\n\t\tast_bridge_lock(bridge);\n\t\tbreak;\n\tcase BRIDGE_CHANNEL_ACTION_DEFERRED_DISSOLVING:\n\t\tast_bridge_unlock(bridge);\n\t\tbridge->v_table->dissolving(bridge);\n\t\tast_bridge_lock(bridge);\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tast_assert(0);\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 2417}
{"project": "Asterisk", "target": 0, "func": "\n int ham84_(integer *input, integer *output, integer *errcnt)\n{\n    \n    static integer dactab[128] = { 16,0,0,3,0,5,14,7,0,9,14,11,14,13,30,14,0,\n\t    9,2,7,4,7,7,23,9,25,10,9,12,9,14,7,0,5,2,11,5,21,6,5,8,11,11,27,\n\t    12,5,14,11,2,1,18,2,12,5,2,7,12,9,2,11,28,12,12,15,0,3,3,19,4,13,\n\t    6,3,8,13,10,3,13,29,14,13,4,1,10,3,20,4,4,7,10,9,26,10,4,13,10,15,\n\t    8,1,6,3,6,5,22,6,24,8,8,11,8,13,6,15,1,17,2,1,4,1,6,15,8,1,10,15,\n\t    12,15,15,31 };\n    integer i__, j, parity;\n\n\n\n\n    parity = *input & 255;\n    parity ^= parity / 16;\n    parity ^= parity / 4;\n    parity ^= parity / 2;\n    parity &= 1;\n    i__ = dactab[*input & 127];\n    *output = i__ & 15;\n    j = i__ & 16;\n    if (j != 0) {\n\n\tif (parity != 0) {\n\t    ++(*errcnt);\n\t}\n    } else {\n\n\t++(*errcnt);\n\tif (parity == 0) {\n\n\t    ++(*errcnt);\n\t    *output = -1;\n\t}\n    }\n    return 0;\n} \n", "bug_type": null, "idx": 2418}
{"project": "Asterisk", "target": 0, "func": "static enum ast_device_state devstate_prov_cb(const char *data)\n{\n\treturn current_device_state;\n}\n", "bug_type": null, "idx": 2419}
{"project": "Asterisk", "target": 0, "func": "\ned_tty_stop_output(EditLine *el, int c)\n{\n\treturn (CC_NORM);\n}\n", "bug_type": null, "idx": 2420}
{"project": "Asterisk", "target": 0, "func": "int AST_OPTIONAL_API_NAME(ast_websocket_remove_protocol)(const char *name, ast_websocket_callback callback)\n{\n\tint res = websocket_remove_protocol_internal(name, callback);\n\tif (res == 0) {\n\t\tast_module_unref(ast_module_info->self);\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2421}
{"project": "Asterisk", "target": 0, "func": "\nenum ast_sorcery_apply_result __ast_sorcery_insert_wizard_mapping(struct ast_sorcery *sorcery,\n\t\tconst char *type, const char *module, const char *name, const char *data,\n\t\tunsigned int caching, int position)\n{\n\tRAII_VAR(struct ast_sorcery_object_type *, object_type, ao2_find(sorcery->types, type, OBJ_KEY), ao2_cleanup);\n\tRAII_VAR(struct ast_sorcery_internal_wizard *, wizard, ao2_find(wizards, name, OBJ_KEY), ao2_cleanup);\n\tRAII_VAR(struct ast_sorcery_object_wizard *, object_wizard, ao2_alloc(sizeof(*object_wizard), sorcery_object_wizard_destructor), ao2_cleanup);\n\tint created = 0;\n\tif (!wizard) {\n\t\tast_log(LOG_ERROR, \"Wizard '%s' could not be applied to object type '%s' as it was not found\\n\",\n\t\t\tname, type);\n\t\treturn AST_SORCERY_APPLY_FAIL;\n\t} else if (!object_wizard) {\n\t\treturn AST_SORCERY_APPLY_FAIL;\n\t}\n\tif (!object_type) {\n\t\tif (!(object_type = sorcery_object_type_alloc(type, module))) {\n\t\t\treturn AST_SORCERY_APPLY_FAIL;\n\t\t}\n\t\tcreated = 1;\n\t}\n\tAST_VECTOR_RW_WRLOCK(&object_type->wizards);\n\tif (!created) {\n\t\tstruct ast_sorcery_object_wizard *found;\n#define WIZARD_COMPARE(a, b) ((a)->wizard == (b))\n\t\tfound = AST_VECTOR_GET_CMP(&object_type->wizards, wizard, WIZARD_COMPARE);\n#undef WIZARD_COMPARE\n\t\tif (found) {\n\t\t\tast_debug(1, \"Wizard %s already applied to object type %s\\n\",\n\t\t\t\t\twizard->callbacks.name, object_type->name);\n\t\t\tAST_VECTOR_RW_UNLOCK(&object_type->wizards);\n\t\t\treturn AST_SORCERY_APPLY_DUPLICATE;\n\t\t}\n\t}\n\tast_debug(5, \"Calling wizard %s open callback on object type %s\\n\",\n\t\tname, object_type->name);\n\tif (wizard->callbacks.open && !(object_wizard->data = wizard->callbacks.open(data))) {\n\t\tast_log(LOG_WARNING, \"Wizard '%s' failed to open mapping for object type '%s' with data: %s\\n\",\n\t\t\tname, object_type->name, S_OR(data, \"\"));\n\t\tAST_VECTOR_RW_UNLOCK(&object_type->wizards);\n\t\treturn AST_SORCERY_APPLY_FAIL;\n\t}\n\tast_module_ref(wizard->callbacks.module);\n\tobject_wizard->wizard = ao2_bump(wizard);\n\tobject_wizard->caching = caching;\n\tif (position == AST_SORCERY_WIZARD_POSITION_LAST) {\n\t\tposition = AST_VECTOR_SIZE(&object_type->wizards);\n\t}\n\tif (AST_VECTOR_INSERT_AT(&object_type->wizards, position, object_wizard) != 0) {\n\t\tAST_VECTOR_RW_UNLOCK(&object_type->wizards);\n\t\treturn AST_SORCERY_APPLY_FAIL;\n\t}\n\tAST_VECTOR_RW_UNLOCK(&object_type->wizards);\n\tao2_bump(object_wizard);\n\tif (created) {\n\t\tao2_link(sorcery->types, object_type);\n\t}\n\tNOTIFY_INSTANCE_OBSERVERS(sorcery->observers, wizard_mapped,\n\t\tsorcery->module_name, sorcery, type, &wizard->callbacks, data, object_wizard->data);\n\treturn AST_SORCERY_APPLY_SUCCESS;\n}\n", "bug_type": null, "idx": 2422}
{"project": "Asterisk", "target": 0, "func": "void ast_set_hangupsource(struct ast_channel *chan, const char *source, int force)\n{\n\tRAII_VAR(struct ast_channel *, bridge, ast_channel_bridge_peer(chan), ast_channel_cleanup);\n\tast_channel_lock(chan);\n\tif (force || ast_strlen_zero(ast_channel_hangupsource(chan))) {\n\t\tast_channel_hangupsource_set(chan, source);\n\t}\n\tast_channel_unlock(chan);\n\tif (bridge) {\n\t\tast_channel_lock(bridge);\n\t\tif (force || ast_strlen_zero(ast_channel_hangupsource(bridge))) {\n\t\t\tast_channel_hangupsource_set(bridge, source);\n\t\t}\n\t\tast_channel_unlock(bridge);\n\t}\n}\n", "bug_type": null, "idx": 2423}
{"project": "Asterisk", "target": 0, "func": "int ast_loader_register(int (*updater)(void))\n{\n\treturn 1;\n}\n", "bug_type": null, "idx": 2424}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_format_get_maximum_ms(const struct ast_format *format)\n{\n\treturn format->codec->maximum_ms;\n}\n", "bug_type": null, "idx": 2425}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void do_forward(struct chanlist *o, struct cause_args *num,\n\tstruct ast_flags64 *peerflags, int single, int caller_entertained, int *to,\n\tstruct ast_party_id *forced_clid, struct ast_party_id *stored_clid)\n{\n\tchar tmpchan[256];\n\tchar forwarder[AST_CHANNEL_NAME];\n\tstruct ast_channel *original = o->chan;\n\tstruct ast_channel *c = o->chan; \n\tstruct ast_channel *in = num->chan; \n\tchar *stuff;\n\tchar *tech;\n\tint cause;\n\tstruct ast_party_caller caller;\n\tast_copy_string(forwarder, ast_channel_name(c), sizeof(forwarder));\n\tast_copy_string(tmpchan, ast_channel_call_forward(c), sizeof(tmpchan));\n\tif ((stuff = strchr(tmpchan, '/'))) {\n\t\t*stuff++ = '\\0';\n\t\ttech = tmpchan;\n\t} else {\n\t\tconst char *forward_context;\n\t\tast_channel_lock(c);\n\t\tforward_context = pbx_builtin_getvar_helper(c, \"FORWARD_CONTEXT\");\n\t\tif (ast_strlen_zero(forward_context)) {\n\t\t\tforward_context = NULL;\n\t\t}\n\t\tsnprintf(tmpchan, sizeof(tmpchan), \"%s@%s\", ast_channel_call_forward(c), forward_context ? forward_context : ast_channel_context(c));\n\t\tast_channel_unlock(c);\n\t\tstuff = tmpchan;\n\t\ttech = \"Local\";\n\t}\n\tif (!strcasecmp(tech, \"Local\")) {\n\t\t\n\t\tast_clear_flag64(o, OPT_IGNORE_CONNECTEDLINE);\n\t}\n\t\n\tast_verb(3, \"Now forwarding %s to '%s/%s' (thanks to %s)\\n\", ast_channel_name(in), tech, stuff, ast_channel_name(c));\n\t\n\tif (ast_test_flag64(peerflags, OPT_IGNORE_FORWARDING)) {\n\t\tast_verb(3, \"Forwarding %s to '%s/%s' prevented.\\n\", ast_channel_name(in), tech, stuff);\n\t\tast_channel_publish_dial_forward(in, original, NULL, NULL, \"CANCEL\",\n\t\t\tast_channel_call_forward(original));\n\t\tc = o->chan = NULL;\n\t\tcause = AST_CAUSE_BUSY;\n\t} else {\n\t\tstruct ast_stream_topology *topology;\n\t\tast_channel_lock(in);\n\t\ttopology = ast_stream_topology_clone(ast_channel_get_stream_topology(in));\n\t\tast_channel_unlock(in);\n\t\t\n\t\tc = o->chan = ast_request_with_stream_topology(tech, topology, NULL, in, stuff, &cause);\n\t\tast_stream_topology_free(topology);\n\t\tif (c) {\n\t\t\tif (single && !caller_entertained) {\n\t\t\t\tast_channel_make_compatible(in, o->chan);\n\t\t\t}\n\t\t\tast_channel_lock_both(in, o->chan);\n\t\t\tast_channel_inherit_variables(in, o->chan);\n\t\t\tast_channel_datastore_inherit(in, o->chan);\n\t\t\tpbx_builtin_setvar_helper(o->chan, \"FORWARDERNAME\", forwarder);\n\t\t\tast_max_forwards_decrement(o->chan);\n\t\t\tast_channel_unlock(in);\n\t\t\tast_channel_unlock(o->chan);\n\t\t\t\n\t\t\tast_ignore_cc(o->chan);\n\t\t\tast_log(LOG_NOTICE, \"Not accepting call completion offers from call-forward recipient %s\\n\", ast_channel_name(o->chan));\n\t\t} else\n\t\t\tast_log(LOG_NOTICE,\n\t\t\t\t\"Forwarding failed to create channel to dial '%s/%s' (cause = %d)\\n\",\n\t\t\t\ttech, stuff, cause);\n\t}\n\tif (!c) {\n\t\tast_channel_publish_dial(in, original, stuff, \"BUSY\");\n\t\tast_clear_flag64(o, DIAL_STILLGOING);\n\t\thandle_cause(cause, num);\n\t\tast_hangup(original);\n\t} else {\n\t\tast_channel_lock_both(c, original);\n\t\tast_party_redirecting_copy(ast_channel_redirecting(c),\n\t\t\tast_channel_redirecting(original));\n\t\tast_channel_unlock(c);\n\t\tast_channel_unlock(original);\n\t\tast_channel_lock_both(c, in);\n\t\tif (single && !caller_entertained && CAN_EARLY_BRIDGE(peerflags, c, in)) {\n\t\t\tast_rtp_instance_early_bridge_make_compatible(c, in);\n\t\t}\n\t\tif (!ast_channel_redirecting(c)->from.number.valid\n\t\t\t|| ast_strlen_zero(ast_channel_redirecting(c)->from.number.str)) {\n\t\t\t\n\t\t\tast_party_number_free(&ast_channel_redirecting(c)->from.number);\n\t\t\tast_party_number_init(&ast_channel_redirecting(c)->from.number);\n\t\t\tast_channel_redirecting(c)->from.number.valid = 1;\n\t\t\tast_channel_redirecting(c)->from.number.str =\n\t\t\t\tast_strdup(S_OR(ast_channel_macroexten(in), ast_channel_exten(in)));\n\t\t}\n\t\tast_channel_dialed(c)->transit_network_select = ast_channel_dialed(in)->transit_network_select;\n\t\t\n\t\tast_party_caller_set_init(&caller, ast_channel_caller(c));\n\t\tif (ast_test_flag64(peerflags, OPT_ORIGINAL_CLID)) {\n\t\t\tcaller.id = *stored_clid;\n\t\t\tast_channel_set_caller_event(c, &caller, NULL);\n\t\t\tast_set_flag64(o, DIAL_CALLERID_ABSENT);\n\t\t} else if (ast_strlen_zero(S_COR(ast_channel_caller(c)->id.number.valid,\n\t\t\tast_channel_caller(c)->id.number.str, NULL))) {\n\t\t\t\n\t\t\tcaller.id = *stored_clid;\n\t\t\tast_channel_set_caller_event(c, &caller, NULL);\n\t\t\tast_set_flag64(o, DIAL_CALLERID_ABSENT);\n\t\t} else {\n\t\t\tast_clear_flag64(o, DIAL_CALLERID_ABSENT);\n\t\t}\n\t\t\n\t\tif (ast_test_flag64(o, OPT_FORCECLID)) {\n\t\t\tstruct ast_party_connected_line connected;\n\t\t\tast_party_connected_line_init(&connected);\n\t\t\tconnected.id = *forced_clid;\n\t\t\tast_party_connected_line_copy(ast_channel_connected(c), &connected);\n\t\t} else {\n\t\t\tast_connected_line_copy_from_caller(ast_channel_connected(c), ast_channel_caller(in));\n\t\t}\n\t\tast_channel_req_accountcodes(c, in, AST_CHANNEL_REQUESTOR_BRIDGE_PEER);\n\t\tast_channel_appl_set(c, \"AppDial\");\n\t\tast_channel_data_set(c, \"(Outgoing Line)\");\n\t\tast_channel_publish_snapshot(c);\n\t\tast_channel_unlock(in);\n\t\tif (single && !ast_test_flag64(o, OPT_IGNORE_CONNECTEDLINE)) {\n\t\t\tstruct ast_party_redirecting redirecting;\n\t\t\t\n\t\t\tast_party_redirecting_init(&redirecting);\n\t\t\tast_party_redirecting_copy(&redirecting, ast_channel_redirecting(c));\n\t\t\tast_channel_unlock(c);\n\t\t\tif (ast_channel_redirecting_sub(c, in, &redirecting, 0) &&\n\t\t\t\tast_channel_redirecting_macro(c, in, &redirecting, 1, 0)) {\n\t\t\t\tast_channel_update_redirecting(in, &redirecting, NULL);\n\t\t\t}\n\t\t\tast_party_redirecting_free(&redirecting);\n\t\t} else {\n\t\t\tast_channel_unlock(c);\n\t\t}\n\t\tif (ast_test_flag64(peerflags, OPT_CANCEL_TIMEOUT)) {\n\t\t\t*to = -1;\n\t\t}\n\t\tif (ast_call(c, stuff, 0)) {\n\t\t\tast_log(LOG_NOTICE, \"Forwarding failed to dial '%s/%s'\\n\",\n\t\t\t\ttech, stuff);\n\t\t\tast_channel_publish_dial(in, original, stuff, \"CONGESTION\");\n\t\t\tast_clear_flag64(o, DIAL_STILLGOING);\n\t\t\tast_hangup(original);\n\t\t\tast_hangup(c);\n\t\t\tc = o->chan = NULL;\n\t\t\tnum->nochan++;\n\t\t} else {\n\t\t\tast_channel_publish_dial_forward(in, original, c, NULL, \"CANCEL\",\n\t\t\t\tast_channel_call_forward(original));\n\t\t\tast_channel_publish_dial(in, c, stuff, NULL);\n\t\t\t\n\t\t\tast_hangup(original);\n\t\t}\n\t\tif (single && !caller_entertained) {\n\t\t\tast_indicate(in, -1);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 2426}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int chan_pjsip_add_hold(const char *chan_uid)\n{\n\tRAII_VAR(char *, hold_uid, NULL, ao2_cleanup);\n\thold_uid = ao2_find(pjsip_uids_onhold, chan_uid, OBJ_SEARCH_KEY);\n\tif (hold_uid) {\n\t\t\n\t\treturn 0;\n\t}\n\t\n\thold_uid = ao2_alloc_options(strlen(chan_uid) + 1, NULL,\n\t\tAO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!hold_uid) {\n\t\treturn -1;\n\t}\n\tast_copy_string(hold_uid, chan_uid, strlen(chan_uid) + 1);\n\tif (ao2_link(pjsip_uids_onhold, hold_uid) == 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2427}
{"project": "Asterisk", "target": 0, "func": "static void generate_or_link_lots_to_configs(void)\n{\n\tRAII_VAR(struct parking_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);\n\tstruct parking_lot_cfg *lot_cfg;\n\tstruct ao2_iterator iter;\n\titer = ao2_iterator_init(cfg->parking_lots, 0);\n\tfor (; (lot_cfg = ao2_iterator_next(&iter)); ao2_ref(lot_cfg, -1)) {\n\t\tao2_cleanup(parking_lot_build_or_update(lot_cfg, 0));\n\t}\n\tao2_iterator_destroy(&iter);\n}\n", "bug_type": null, "idx": 2428}
{"project": "Asterisk", "target": 0, "func": "char* pvalForGetInc( pval *p )\n{\n\tif (!pvalCheckType(p, \"pvalForGetInc\", PV_FOR))\n\t\treturn 0;\n\treturn p->u3.for_inc;\n}\n", "bug_type": null, "idx": 2429}
{"project": "Asterisk", "target": 0, "func": "static void generic_monitor_instance_list_destructor(void *obj)\n{\n\tstruct generic_monitor_instance_list *generic_list = obj;\n\tstruct generic_monitor_instance *generic_instance;\n\tgeneric_list->sub = stasis_unsubscribe(generic_list->sub);\n\twhile ((generic_instance = AST_LIST_REMOVE_HEAD(&generic_list->list, next))) {\n\t\tast_free(generic_instance);\n\t}\n\tast_free((char *)generic_list->device_name);\n}\n", "bug_type": null, "idx": 2430}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void jb_framedata_destroy(struct jb_framedata *framedata)\n{\n\tif (framedata->timer) {\n\t\tast_timer_close(framedata->timer);\n\t\tframedata->timer = NULL;\n\t}\n\tif (framedata->jb_impl && framedata->jb_obj) {\n\t\tstruct ast_frame *f;\n\t\twhile (framedata->jb_impl->remove(framedata->jb_obj, &f) == AST_JB_IMPL_OK) {\n\t\t\tast_frfree(f);\n\t\t}\n\t\tframedata->jb_impl->destroy(framedata->jb_obj);\n\t\tframedata->jb_obj = NULL;\n\t}\n\tao2_cleanup(framedata->last_format);\n\tast_free(framedata);\n}\n", "bug_type": null, "idx": 2431}
{"project": "Asterisk", "target": 0, "func": "static void loopback_parse(char **newexten, char **newcontext, int *priority, char **newpattern, char *buf)\n{\n\tchar *con;\n\tchar *pri;\n\t*newpattern = strchr(buf, '/');\n\tif (*newpattern)\n\t\t*(*newpattern)++ = '\\0';\n\tcon = strchr(buf, '@');\n\tif (con) {\n\t\t*con++ = '\\0';\n\t\tpri = strchr(con, ':');\n\t} else\n\t\tpri = strchr(buf, ':');\n\tif (!ast_strlen_zero(buf))\n\t\t*newexten = buf;\n\tif (!ast_strlen_zero(con))\n\t\t*newcontext = con;\n\tif (!ast_strlen_zero(pri))\n\t\tsscanf(pri, \"%30d\", priority);\n}\n", "bug_type": null, "idx": 2432}
{"project": "Asterisk", "target": 0, "func": "int ast_channel_connected_line_macro(struct ast_channel *autoservice_chan, struct ast_channel *macro_chan, const void *connected_info, int is_caller, int is_frame)\n{\n\tstatic int deprecation_warning = 0;\n\tconst char *macro;\n\tconst char *macro_args;\n\tint retval;\n\tast_channel_lock(macro_chan);\n\tmacro = pbx_builtin_getvar_helper(macro_chan, is_caller\n\t\t? \"CONNECTED_LINE_CALLER_SEND_MACRO\" : \"CONNECTED_LINE_CALLEE_SEND_MACRO\");\n\tmacro = ast_strdupa(S_OR(macro, \"\"));\n\tmacro_args = pbx_builtin_getvar_helper(macro_chan, is_caller\n\t\t? \"CONNECTED_LINE_CALLER_SEND_MACRO_ARGS\" : \"CONNECTED_LINE_CALLEE_SEND_MACRO_ARGS\");\n\tmacro_args = ast_strdupa(S_OR(macro_args, \"\"));\n\tif (ast_strlen_zero(macro)) {\n\t\tast_channel_unlock(macro_chan);\n\t\treturn -1;\n\t}\n\tif (!deprecation_warning) {\n\t\tdeprecation_warning = 1;\n\t\tast_log(LOG_WARNING, \"Usage of CONNECTED_LINE_CALLE[ER]_SEND_MACRO is deprecated.  Please use CONNECTED_LINE_SEND_SUB instead.\\n\");\n\t}\n\tif (is_frame) {\n\t\tconst struct ast_frame *frame = connected_info;\n\t\tast_connected_line_parse_data(frame->data.ptr, frame->datalen, ast_channel_connected(macro_chan));\n\t} else {\n\t\tconst struct ast_party_connected_line *connected = connected_info;\n\t\tast_party_connected_line_copy(ast_channel_connected(macro_chan), connected);\n\t}\n\tast_channel_unlock(macro_chan);\n\tchannel_set_intercept_mode(1);\n\tretval = ast_app_run_macro(autoservice_chan, macro_chan, macro, macro_args);\n\tchannel_set_intercept_mode(0);\n\tif (!retval) {\n\t\tstruct ast_party_connected_line saved_connected;\n\t\tast_party_connected_line_init(&saved_connected);\n\t\tast_channel_lock(macro_chan);\n\t\tast_party_connected_line_copy(&saved_connected, ast_channel_connected(macro_chan));\n\t\tast_channel_unlock(macro_chan);\n\t\tast_channel_update_connected_line(macro_chan, &saved_connected, NULL);\n\t\tast_party_connected_line_free(&saved_connected);\n\t}\n\treturn retval;\n}\n", "bug_type": null, "idx": 2433}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245CRCLength (OOCTXT* pctxt, H245CRCLength* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1UINT ui;\n   ASN1OpenType openType;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   if (!extbit) {\n      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 1;\n      switch (ui) {\n         \n         case 0:\n            invokeStartElement (pctxt, \"crc8bit\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"crc8bit\", -1);\n            break;\n         \n         case 1:\n            invokeStartElement (pctxt, \"crc16bit\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"crc16bit\", -1);\n            break;\n         \n         case 2:\n            invokeStartElement (pctxt, \"crc32bit\", -1);\n            \n            invokeNullValue (pctxt);\n            invokeEndElement (pctxt, \"crc32bit\", -1);\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);\n      if (stat != ASN_OK) return stat;\n      else pvalue->t = ui + 4;\n      stat = decodeByteAlign (pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n      if (stat != ASN_OK) return stat;\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2434}
{"project": "Asterisk", "target": 0, "func": "static void dahdi_r2_on_call_disconnect(openr2_chan_t *r2chan, openr2_call_disconnect_cause_t cause)\n{\n\tstruct dahdi_pvt *p = openr2_chan_get_client_data(r2chan);\n\tchar cause_str[50];\n\tstruct ast_control_pvt_cause_code *cause_code;\n\tint datalen = sizeof(*cause_code);\n\tast_verbose(\"MFC/R2 call disconnected on channel %d\\n\", openr2_chan_get_number(r2chan));\n\tast_mutex_lock(&p->lock);\n\tif (!p->owner) {\n\t\tast_mutex_unlock(&p->lock);\n\t\t\n\t\tdahdi_r2_disconnect_call(p, OR2_CAUSE_NORMAL_CLEARING);\n\t\treturn;\n\t}\n\tsnprintf(cause_str, sizeof(cause_str), \"R2 DISCONNECT (%s)\", openr2_proto_get_disconnect_string(cause));\n\tdatalen += strlen(cause_str);\n\tcause_code = ast_alloca(datalen);\n\tmemset(cause_code, 0, datalen);\n\tcause_code->ast_cause = dahdi_r2_cause_to_ast_cause(cause);\n\tast_copy_string(cause_code->chan_name, ast_channel_name(p->owner), AST_CHANNEL_NAME);\n\tast_copy_string(cause_code->code, cause_str, datalen + 1 - sizeof(*cause_code));\n\tast_queue_control_data(p->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, datalen);\n\tast_channel_hangupcause_hash_set(p->owner, cause_code, datalen);\n\t\n\tif (ast_channel_state(p->owner) == AST_STATE_UP) {\n\t\tast_channel_softhangup_internal_flag_add(p->owner, AST_SOFTHANGUP_DEV);\n\t\tast_mutex_unlock(&p->lock);\n\t} else if (openr2_chan_get_direction(r2chan) == OR2_DIR_FORWARD) {\n\t\t\n\t\tswitch (cause) {\n\t\tcase OR2_CAUSE_BUSY_NUMBER:\n\t\t\tp->subs[SUB_REAL].needbusy = 1;\n\t\t\tbreak;\n\t\tcase OR2_CAUSE_NETWORK_CONGESTION:\n\t\tcase OR2_CAUSE_OUT_OF_ORDER:\n\t\tcase OR2_CAUSE_UNALLOCATED_NUMBER:\n\t\tcase OR2_CAUSE_NO_ANSWER:\n\t\tcase OR2_CAUSE_UNSPECIFIED:\n\t\tcase OR2_CAUSE_NORMAL_CLEARING:\n\t\t\tp->subs[SUB_REAL].needcongestion = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_channel_softhangup_internal_flag_add(p->owner, AST_SOFTHANGUP_DEV);\n\t\t}\n\t\tast_mutex_unlock(&p->lock);\n\t} else {\n\t\tast_mutex_unlock(&p->lock);\n\t\t\n\t\t\n\t\tast_queue_hangup_with_cause(p->owner, dahdi_r2_cause_to_ast_cause(cause));\n\t}\n}\n", "bug_type": null, "idx": 2435}
{"project": "Asterisk", "target": 0, "func": "static const char *ast_get_context_name(struct ast_context *con);\nstatic const char *ast_get_context_name(struct ast_context *con)\n{\n\treturn con ? con->name : NULL;\n}\n", "bug_type": null, "idx": 2436}
{"project": "Asterisk", "target": 0, "func": "static int caller_id_privacy_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)\n{\n\tstruct ast_sip_endpoint *endpoint = obj;\n\tint callingpres = ast_parse_caller_presentation(var->value);\n\tif (callingpres == -1 && sscanf(var->value, \"%d\", &callingpres) != 1) {\n\t\treturn -1;\n\t}\n\tendpoint->id.self.number.presentation = callingpres;\n\tendpoint->id.self.name.presentation = callingpres;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2437}
{"project": "Asterisk", "target": 0, "func": "static int g726_32_rewrite(struct ast_filestream *s, const char *comment)\n{\n\treturn g726_open(s, RATE_32);\n}\n", "bug_type": null, "idx": 2438}
{"project": "Asterisk", "target": 0, "func": "struct ast_sdp_payload *ast_sdp_m_get_payload(const struct ast_sdp_m_line *m_line, int index)\n{\n\tast_assert(m_line != NULL);\n\treturn AST_VECTOR_GET(m_line->payloads, index);\n}\n", "bug_type": null, "idx": 2439}
{"project": "Asterisk", "target": 0, "func": "static void dundi_precache_full(void)\n{\n\tstruct dundi_mapping *cur;\n\tstruct ast_context *con;\n\tstruct ast_exten *e;\n\tAST_LIST_TRAVERSE(&mappings, cur, list) {\n\t\tast_log(LOG_NOTICE, \"Should precache context '%s'\\n\", cur->dcontext);\n\t\tast_rdlock_contexts();\n\t\tcon = NULL;\n\t\twhile ((con = ast_walk_contexts(con))) {\n\t\t\tif (strcasecmp(cur->lcontext, ast_get_context_name(con)))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tast_rdlock_context(con);\n\t\t\te = NULL;\n\t\t\twhile ((e = ast_walk_context_extensions(con, e)))\n\t\t\t\treschedule_precache(ast_get_extension_name(e), cur->dcontext, 0);\n\t\t\tast_unlock_context(con);\n\t\t}\n\t\tast_unlock_contexts();\n\t}\n}\n", "bug_type": null, "idx": 2440}
{"project": "Asterisk", "target": 0, "func": "static char *sla_show_stations(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ao2_iterator i;\n\tstruct sla_station *station;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"sla show stations\";\n\t\te->usage =\n\t\t\t\"Usage: sla show stations\\n\"\n\t\t\t\"       This will list all stations defined in sla.conf\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tast_cli(a->fd, \"\\n\" \n\t            \"=============================================================\\n\"\n\t            \"=== Configured SLA Stations =================================\\n\"\n\t            \"=============================================================\\n\"\n\t            \"===\\n\");\n\ti = ao2_iterator_init(sla_stations, 0);\n\tfor (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {\n\t\tstruct sla_trunk_ref *trunk_ref;\n\t\tchar ring_timeout[16] = \"(none)\";\n\t\tchar ring_delay[16] = \"(none)\";\n\t\tao2_lock(station);\n\t\tif (station->ring_timeout) {\n\t\t\tsnprintf(ring_timeout, sizeof(ring_timeout), \n\t\t\t\t\"%u\", station->ring_timeout);\n\t\t}\n\t\tif (station->ring_delay) {\n\t\t\tsnprintf(ring_delay, sizeof(ring_delay), \n\t\t\t\t\"%u\", station->ring_delay);\n\t\t}\n\t\tast_cli(a->fd, \"=== ---------------------------------------------------------\\n\"\n\t\t            \"=== Station Name:    %s\\n\"\n\t\t            \"=== ==> Device:      %s\\n\"\n\t\t            \"=== ==> AutoContext: %s\\n\"\n\t\t            \"=== ==> RingTimeout: %s\\n\"\n\t\t            \"=== ==> RingDelay:   %s\\n\"\n\t\t            \"=== ==> HoldAccess:  %s\\n\"\n\t\t            \"=== ==> Trunks ...\\n\",\n\t\t            station->name, station->device,\n\t\t            S_OR(station->autocontext, \"(none)\"), \n\t\t            ring_timeout, ring_delay,\n\t\t            sla_hold_str(station->hold_access));\n\t\tAST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {\n\t\t\tif (trunk_ref->ring_timeout) {\n\t\t\t\tsnprintf(ring_timeout, sizeof(ring_timeout),\n\t\t\t\t\t\"%u\", trunk_ref->ring_timeout);\n\t\t\t} else {\n\t\t\t\tstrcpy(ring_timeout, \"(none)\");\n\t\t\t}\n\t\t\tif (trunk_ref->ring_delay) {\n\t\t\t\tsnprintf(ring_delay, sizeof(ring_delay),\n\t\t\t\t\t\"%u\", trunk_ref->ring_delay);\n\t\t\t} else {\n\t\t\t\tstrcpy(ring_delay, \"(none)\");\n\t\t\t}\n\t\t\tast_cli(a->fd, \"===    ==> Trunk Name: %s\\n\"\n\t            \"===       ==> State:       %s\\n\"\n\t            \"===       ==> RingTimeout: %s\\n\"\n\t            \"===       ==> RingDelay:   %s\\n\",\n\t            trunk_ref->trunk->name,\n\t            trunkstate2str(trunk_ref->state),\n\t            ring_timeout, ring_delay);\n\t\t}\n\t\tast_cli(a->fd, \"=== ---------------------------------------------------------\\n\"\n\t\t            \"===\\n\");\n\t\tao2_unlock(station);\n\t}\n\tao2_iterator_destroy(&i);\n\tast_cli(a->fd, \"============================================================\\n\"\n\t            \"\\n\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2441}
{"project": "Asterisk", "target": 0, "func": "\nstatic char *handle_show_parking_lot_cmd(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"parking show\";\n\t\te->usage =\n\t\t\t\"Usage: parking show [name]\\n\"\n\t\t\t\"\tShows a list of parking lots or details of a specific parking lot.\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tif (a->pos == 2) {\n\t\t\treturn complete_parking_lot(a->word, a->n);\n\t\t}\n\t\treturn NULL;\n\t}\n\tast_cli(a->fd, \"\\n\");\n\tif (a->argc == 2) {\n\t\tcli_display_parking_global(a->fd);\n\t\tcli_display_parking_lot_list(a->fd);\n\t\treturn CLI_SUCCESS;\n\t}\n\tif (a->argc == 3) {\n\t\tcli_display_parking_lot(a->fd, a->argv[2]);\n\t\treturn CLI_SUCCESS;\n\t}\n\treturn CLI_SHOWUSAGE;\n}\n", "bug_type": null, "idx": 2442}
{"project": "Asterisk", "target": 0, "func": "static struct ast_sip_subscription_handler *find_sub_handler_for_event_name(const char *event_name)\n{\n\tstruct ast_sip_subscription_handler *iter;\n\tAST_RWLIST_RDLOCK(&subscription_handlers);\n\tAST_RWLIST_TRAVERSE(&subscription_handlers, iter, next) {\n\t\tif (!strcmp(iter->event_name, event_name)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&subscription_handlers);\n\treturn iter;\n}\n", "bug_type": null, "idx": 2443}
{"project": "Asterisk", "target": 0, "func": "static void ss7_connected_line_update(struct sig_ss7_chan *p, struct ast_party_connected_line *connected)\n{\n\tint connected_strip = 0;\n\tchar connected_nai;\n\tunsigned char connected_pres;\n\tunsigned char connected_screen;\n\tconst char *connected_num;\n\tif (!connected->id.number.valid) {\n\t\treturn;\n\t}\n\tconnected_num = S_OR(connected->id.number.str, \"\");\n\tif (p->ss7->called_nai ==  SS7_NAI_DYNAMIC) {\n\t\tconnected_strip = ss7_parse_prefix(p, connected_num, &connected_nai);\n\t} else {\n\t\tconnected_nai = p->ss7->called_nai;\n\t}\n\tconnected_pres = cid_pres2ss7pres(connected->id.number.presentation);\n\tconnected_screen = cid_pres2ss7screen(connected->id.number.presentation);\n\tisup_set_connected(p->ss7call, connected_num + connected_strip, connected_nai, connected_pres, connected_screen);\n}\n", "bug_type": null, "idx": 2444}
{"project": "Asterisk", "target": 0, "func": "int ooSendRequestModeReject(OOH323CallData* call,\n                                      H245SequenceNumber sequenceNumber)\n{\n   int ret=0;\n   H245ResponseMessage* response=NULL;\n   H245Message *ph245msg=NULL;\n   OOCTXT *pctxt=call->msgctxt;\n   ret = ooCreateH245Message(call, &ph245msg, \n                      T_H245MultimediaSystemControlMessage_response);\n   if(ret != OO_OK)\n   {\n      OOTRACEERR3(\"Error:H245 message creation failed for - RequstMode \"\n                  \"Reject (%s, %s)\\n\",call->callType, \n                  call->callToken);\n      return OO_FAILED;\n   }\n   ph245msg->msgType = OORequestModeReject;\n   response = ph245msg->h245Msg.u.response;\n   memset(response, 0, sizeof(H245ResponseMessage));\n   response->t = T_H245ResponseMessage_requestModeReject;\n   response->u.requestModeReject = (H245RequestModeReject *)\n                   ASN1MALLOC(pctxt, sizeof(H245RequestModeReject));\n   memset(response->u.requestModeReject, 0, \n                             sizeof(H245RequestModeReject));\n   response->u.requestModeReject->sequenceNumber = sequenceNumber;\n   response->u.requestModeReject->cause.t = \n\t\tT_H245RequestModeReject_cause_modeUnavailable;\n   OOTRACEDBGA3(\"Built RequestModeReject (%s, %s)\\n\", \n                call->callType, call->callToken);\n   ret = ooSendH245Msg(call, ph245msg);\n   if(ret != OO_OK)\n   {\n      OOTRACEERR3(\"Error:Failed to enqueue RequestModeReject message\"\n                  \" to outbound queue. (%s, %s)\\n\", call->callType, \n                  call->callToken);\n   }\n   ooFreeH245Message(call, ph245msg);\n   return ret;\n}\n", "bug_type": null, "idx": 2445}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *cli_channel_get_container(const char *regex)\n{\n\treturn get_container(regex, cli_channel_sort, cli_channel_compare);\n}\n", "bug_type": null, "idx": 2446}
{"project": "Asterisk", "target": 0, "func": "int ast_write(struct ast_channel *chan, struct ast_frame *fr)\n{\n\treturn ast_write_stream(chan, -1, fr);\n}\n", "bug_type": null, "idx": 2447}
{"project": "Asterisk", "target": 0, "func": "static void set_fn(char *fn, int fn_size, const char *file, const char *configfile)\n{\n\tif (!file || file[0] == 0) {\n\t\tif (configfile[0] == '/')\n\t\t\tast_copy_string(fn, configfile, fn_size);\n\t\telse\n\t\t\tsnprintf(fn, fn_size, \"%s/%s\", ast_config_AST_CONFIG_DIR, configfile);\n\t} else if (file[0] == '/')\n\t\tast_copy_string(fn, file, fn_size);\n\telse\n\t\tsnprintf(fn, fn_size, \"%s/%s\", ast_config_AST_CONFIG_DIR, file);\n}\n", "bug_type": null, "idx": 2448}
{"project": "Asterisk", "target": 0, "func": "int ast_crypt_validate(const char *key, const char *expected)\n{\n\tstruct crypt_data data = {};\n\treturn strcmp(expected, crypt_r(key, expected, &data)) == 0;\n}\n}\nint ast_crypt_validate(const char *key, const char *expected)\n{\n\tSCOPED_MUTEX(lock, &crypt_mutex);\n\treturn strcmp(expected, crypt(key, expected)) == 0;\n}\n}\nint ast_crypt_validate(const char *key, const char *expected)\n{\n\tast_log(LOG_WARNING,\n\t\t\"crypt() support not available; cannot validate password\\n\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 2449}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void minimal_callback(const struct ast_dns_query *query)\n{\n\tstruct async_minimal_data *adata = ast_dns_query_get_data(query);\n\tast_mutex_lock(&adata->lock);\n\tadata->complete = 1;\n\tast_cond_signal(&adata->cond);\n\tast_mutex_unlock(&adata->lock);\n}\n", "bug_type": null, "idx": 2450}
{"project": "Asterisk", "target": 0, "func": "static int g722tolin_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tstruct g722_decoder_pvt *tmp = pvt->pvt;\n\tint out_samples;\n\tint in_samples;\n\t\n\tin_samples = f->samples / 2;\n\tout_samples = g722_decode(&tmp->g722, &pvt->outbuf.i16[pvt->samples * sizeof(int16_t)], \n\t\t(uint8_t *) f->data.ptr, in_samples);\n\tpvt->samples += out_samples;\n\tpvt->datalen += (out_samples * sizeof(int16_t));\n\treturn 0;\n}\n", "bug_type": null, "idx": 2451}
{"project": "Asterisk", "target": 0, "func": "struct ast_sdp_s_line *ast_sdp_s_alloc(const char *session_name)\n{\n\tstruct ast_sdp_s_line *s_line;\n\tsize_t len;\n\tif (ast_strlen_zero(session_name)) {\n\t\tsession_name = \" \";\n\t}\n\tlen = sizeof(*s_line) + strlen(session_name) + 1;\n\ts_line = ast_calloc(1, len);\n\tif (!s_line) {\n\t\treturn NULL;\n\t}\n\ts_line->session_name = ((char *)s_line) + sizeof(*s_line);\n\tstrcpy(s_line->session_name, session_name);  \n\treturn s_line;\n}\n", "bug_type": null, "idx": 2452}
{"project": "Asterisk", "target": 0, "func": "private void\nterm_free_display(EditLine *el)\n{\n\tchar **b;\n\tchar **bufp;\n\tb = el->el_display;\n\tel->el_display = NULL;\n\tif (b != NULL) {\n\t\tfor (bufp = b; *bufp != NULL; bufp++)\n\t\t\tel_free((ptr_t) * bufp);\n\t\tel_free((ptr_t) b);\n\t}\n\tb = el->el_vdisplay;\n\tel->el_vdisplay = NULL;\n\tif (b != NULL) {\n\t\tfor (bufp = b; *bufp != NULL; bufp++)\n\t\t\tel_free((ptr_t) * bufp);\n\t\tel_free((ptr_t) b);\n\t}\n}\n", "bug_type": null, "idx": 2453}
{"project": "Asterisk", "target": 0, "func": "static int pbx_builtin_saynumber(struct ast_channel *chan, const char *data)\n{\n\tchar tmp[256];\n\tchar *number = tmp;\n\tint number_val;\n\tchar *options;\n\tint res;\n\tint interrupt = 0;\n\tconst char *interrupt_string;\n\tast_channel_lock(chan);\n\tinterrupt_string = pbx_builtin_getvar_helper(chan, \"SAY_DTMF_INTERRUPT\");\n\tif (ast_true(interrupt_string)) {\n\t\tinterrupt = 1;\n\t}\n\tast_channel_unlock(chan);\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"SayNumber requires an argument (number)\\n\");\n\t\treturn -1;\n\t}\n\tast_copy_string(tmp, data, sizeof(tmp));\n\tstrsep(&number, \",\");\n\tif (sscanf(tmp, \"%d\", &number_val) != 1) {\n\t\tast_log(LOG_WARNING, \"argument '%s' to SayNumber could not be parsed as a number.\\n\", tmp);\n\t\treturn 0;\n\t}\n\toptions = strsep(&number, \",\");\n\tif (options) {\n\t\tif ( strcasecmp(options, \"f\") && strcasecmp(options, \"m\") &&\n\t\t\tstrcasecmp(options, \"c\") && strcasecmp(options, \"n\") ) {\n\t\t\tast_log(LOG_WARNING, \"SayNumber gender option is either 'f', 'm', 'c' or 'n'\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tres = ast_say_number(chan, number_val, interrupt ? AST_DIGIT_ANY : \"\", ast_channel_language(chan), options);\n\tif (res < 0) {\n\t\tast_log(LOG_WARNING, \"We were unable to say the number %s, is it too large?\\n\", tmp);\n\t}\n\treturn interrupt ? res : 0;\n}\n", "bug_type": null, "idx": 2454}
{"project": "Asterisk", "target": 0, "func": "static void *exchangecal_load_calendar(void *void_data)\n{\n\tstruct exchangecal_pvt *pvt;\n\tconst struct ast_config *cfg;\n\tstruct ast_variable *v;\n\tstruct ast_calendar *cal = void_data;\n\tast_mutex_t refreshlock;\n\tif (!(cal && (cfg = ast_calendar_config_acquire()))) {\n\t\tast_log(LOG_ERROR, \"You must enable calendar support for res_exchangecal to load\\n\");\n\t\treturn NULL;\n\t}\n\tif (ao2_trylock(cal)) {\n\t\tif (cal->unloading) {\n\t\t\tast_log(LOG_WARNING, \"Unloading module, load_calendar cancelled.\\n\");\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Could not lock calendar, aborting!\\n\");\n\t\t}\n\t\tast_calendar_config_release();\n\t\treturn NULL;\n\t}\n\tif (!(pvt = ao2_alloc(sizeof(*pvt), exchangecal_destructor))) {\n\t\tast_log(LOG_ERROR, \"Could not allocate exchangecal_pvt structure for calendar: %s\\n\", cal->name);\n\t\tast_calendar_config_release();\n\t\treturn NULL;\n\t}\n\tpvt->owner = cal;\n\tif (!(pvt->events = ast_calendar_event_container_alloc())) {\n\t\tast_log(LOG_ERROR, \"Could not allocate space for fetching events for calendar: %s\\n\", cal->name);\n\t\tpvt = unref_exchangecal(pvt);\n\t\tao2_unlock(cal);\n\t\tast_calendar_config_release();\n\t\treturn NULL;\n\t}\n\tif (ast_string_field_init(pvt, 32)) {\n\t\tast_log(LOG_ERROR, \"Couldn't allocate string field space for calendar: %s\\n\", cal->name);\n\t\tpvt = unref_exchangecal(pvt);\n\t\tao2_unlock(cal);\n\t\tast_calendar_config_release();\n\t\treturn NULL;\n\t}\n\tfor (v = ast_variable_browse(cfg, cal->name); v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"url\")) {\n\t\t\tast_string_field_set(pvt, url, v->value);\n\t\t} else if (!strcasecmp(v->name, \"user\")) {\n\t\t\tast_string_field_set(pvt, user, v->value);\n\t\t} else if (!strcasecmp(v->name, \"secret\")) {\n\t\t\tast_string_field_set(pvt, secret, v->value);\n\t\t}\n\t}\n\tast_calendar_config_release();\n\tif (ast_strlen_zero(pvt->url)) {\n\t\tast_log(LOG_WARNING, \"No URL was specified for Exchange calendar '%s' - skipping.\\n\", cal->name);\n\t\tpvt = unref_exchangecal(pvt);\n\t\tao2_unlock(cal);\n\t\treturn NULL;\n\t}\n\tif (ne_uri_parse(pvt->url, &pvt->uri) || pvt->uri.host == NULL || pvt->uri.path == NULL) {\n\t\tast_log(LOG_WARNING, \"Could not parse url '%s' for Exchange calendar '%s' - skipping.\\n\", pvt->url, cal->name);\n\t\tpvt = unref_exchangecal(pvt);\n\t\tao2_unlock(cal);\n\t\treturn NULL;\n\t}\n\tif (pvt->uri.scheme == NULL) {\n\t\tpvt->uri.scheme = \"http\";\n\t}\n\tif (pvt->uri.port == 0) {\n\t\tpvt->uri.port = ne_uri_defaultport(pvt->uri.scheme);\n\t}\n\tpvt->session = ne_session_create(pvt->uri.scheme, pvt->uri.host, pvt->uri.port);\n\tne_redirect_register(pvt->session);\n\tne_set_server_auth(pvt->session, auth_credentials, pvt);\n\tif (!strcasecmp(pvt->uri.scheme, \"https\")) {\n\t\tne_ssl_trust_default_ca(pvt->session);\n\t}\n\tcal->tech_pvt = pvt;\n\tast_mutex_init(&refreshlock);\n\t\n\tupdate_exchangecal(pvt);\n\tao2_unlock(cal);\n\t\n\tfor (;;) {\n\t\tstruct timeval tv = ast_tvnow();\n\t\tstruct timespec ts = {0,};\n\t\tts.tv_sec = tv.tv_sec + (60 * pvt->owner->refresh);\n\t\tast_mutex_lock(&refreshlock);\n\t\twhile (!pvt->owner->unloading) {\n\t\t\tif (ast_cond_timedwait(&pvt->owner->unload, &refreshlock, &ts) == ETIMEDOUT) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&refreshlock);\n\t\tif (pvt->owner->unloading) {\n\t\t\tast_debug(10, \"Skipping refresh since we got a shutdown signal\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tast_debug(10, \"Refreshing after %d minute timeout\\n\", pvt->owner->refresh);\n\t\tupdate_exchangecal(pvt);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2455}
{"project": "Asterisk", "target": 0, "func": "static HIST_ENTRY *\n_move_history(int op)\n{\n\tHistEvent ev;\n\tstatic HIST_ENTRY rl_he;\n\tif (history(h, &ev, op) != 0)\n\t\treturn (HIST_ENTRY *) NULL;\n\trl_he.line = ev.str;\n\trl_he.data = \"\";\n\treturn (&rl_he);\n}\n", "bug_type": null, "idx": 2456}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void after_bridge_cb_run_discard(struct after_bridge_cb_ds *after_bridge, enum ast_bridge_after_cb_reason reason)\n{\n\tstruct after_bridge_cb_node *node;\n\tfor (;;) {\n\t\tAST_LIST_LOCK(&after_bridge->callbacks);\n\t\tnode = AST_LIST_REMOVE_HEAD(&after_bridge->callbacks, list);\n\t\tAST_LIST_UNLOCK(&after_bridge->callbacks);\n\t\tif (!node) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!node->reason) {\n\t\t\tnode->reason = reason;\n\t\t}\n\t\tafter_bridge_cb_failed(node);\n\t\tast_free(node);\n\t}\n}\n", "bug_type": null, "idx": 2457}
{"project": "Asterisk", "target": 0, "func": "static void store_callerid(struct console_pvt *pvt, const char *value)\n{\n\tchar cid_name[256];\n\tchar cid_num[256];\n\tast_callerid_split(value, cid_name, sizeof(cid_name), \n\t\tcid_num, sizeof(cid_num));\n\tast_string_field_set(pvt, cid_name, cid_name);\n\tast_string_field_set(pvt, cid_num, cid_num);\n}\n", "bug_type": null, "idx": 2458}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void *cc_recall_ds_duplicate(void *data)\n{\n\tstruct cc_recall_ds_data *old_data = data;\n\tstruct cc_recall_ds_data *new_data = ast_calloc(1, sizeof(*new_data));\n\tif (!new_data) {\n\t\treturn NULL;\n\t}\n\tnew_data->interface_tree = cc_ref(old_data->interface_tree, \"Bump refcount of monitor tree for recall datastore duplicate\");\n\tnew_data->core_id = old_data->core_id;\n\tnew_data->nested = 1;\n\treturn new_data;\n}\n", "bug_type": null, "idx": 2459}
{"project": "Asterisk", "target": 0, "func": "static SQLHSTMT config_odbc_prepare(struct odbc_obj *obj, void *data)\n{\n\tstruct config_odbc_obj *q = data;\n\tSQLHSTMT sth;\n\tint res;\n\tres = SQLAllocHandle(SQL_HANDLE_STMT, obj->con, &sth);\n\tif ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {\n\t\tast_verb(4, \"Failure in AllocStatement %d\\n\", res);\n\t\treturn NULL;\n\t}\n\tres = SQLPrepare(sth, (unsigned char *)q->sql, SQL_NTS);\n\tif ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {\n\t\tast_verb(4, \"Error in PREPARE %d\\n\", res);\n\t\tSQLFreeHandle(SQL_HANDLE_STMT, sth);\n\t\treturn NULL;\n\t}\n\tSQLBindCol(sth, 1, SQL_C_ULONG, &q->cat_metric, sizeof(q->cat_metric), &q->err);\n\tSQLBindCol(sth, 2, SQL_C_CHAR, q->category, sizeof(q->category), &q->err);\n\tSQLBindCol(sth, 3, SQL_C_CHAR, q->var_name, sizeof(q->var_name), &q->err);\n\tSQLBindCol(sth, 4, SQL_C_CHAR, q->var_val, q->var_val_size, &q->err);\n\treturn sth;\n}\n", "bug_type": null, "idx": 2460}
{"project": "Asterisk", "target": 0, "func": " */\nstatic enum syntaxtype xmldoc_get_syntax_type(const char *type)\n{\n\tint i;\n\tfor (i=0; i < ARRAY_LEN(stxtype); i++) {\n\t\tif (!strcasecmp(stxtype[i].type, type)) {\n\t\t\treturn stxtype[i].stxtype;\n\t\t}\n\t}\n\treturn FUNCTION_SYNTAX;\n}\n", "bug_type": null, "idx": 2461}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int unschedule_all_cb(void *obj, void *arg, int flags)\n{\n\tstruct sched_data *data = obj;\n\tAST_SCHED_DEL_UNREF(sched, data->id, ao2_ref(data, -1));\n\treturn CMP_MATCH;\n}\n", "bug_type": null, "idx": 2462}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_unregister_application(app);\n}\n", "bug_type": null, "idx": 2463}
{"project": "Asterisk", "target": 0, "func": "#define RESOURCE_LIST_INIT_SIZE 4\nstatic void resource_list_destructor(void *obj)\n{\n\tstruct resource_list *list = obj;\n\tint i;\n\tfor (i = 0; i < AST_VECTOR_SIZE(&list->items); ++i) {\n\t\tast_free((char *) AST_VECTOR_GET(&list->items, i));\n\t}\n\tAST_VECTOR_FREE(&list->items);\n}\n", "bug_type": null, "idx": 2464}
{"project": "Asterisk", "target": 0, "func": "static int process_xml_defaultenabled_node(xmlNode *node, struct member *mem)\n{\n\tconst char *tmp = (const char *) xmlNodeGetContent(node);\n\tif (tmp && !strlen_zero(tmp)) {\n\t\tmem->defaultenabled = tmp;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2465}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_bridges_remove_channel_parse_body(\n\tstruct ast_json *body,\n\tstruct ast_ari_bridges_remove_channel_args *args)\n{\n\tstruct ast_json *field;\n\t\n\tfield = ast_json_object_get(body, \"channel\");\n\tif (field) {\n\t\t\n\t\tast_free(args->channel);\n\t\tif (ast_json_typeof(field) == AST_JSON_ARRAY) {\n\t\t\t\n\t\t\tsize_t i;\n\t\t\targs->channel_count = ast_json_array_size(field);\n\t\t\targs->channel = ast_malloc(sizeof(*args->channel) * args->channel_count);\n\t\t\tif (!args->channel) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < args->channel_count; ++i) {\n\t\t\t\targs->channel[i] = ast_json_string_get(ast_json_array_get(field, i));\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\targs->channel_count = 1;\n\t\t\targs->channel = ast_malloc(sizeof(*args->channel) * args->channel_count);\n\t\t\tif (!args->channel) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\targs->channel[0] = ast_json_string_get(field);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2466}
{"project": "Asterisk", "target": 0, "func": "protected void\nkey_end(EditLine *el)\n{\n\tel_free((ptr_t) el->el_key.buf);\n\tel->el_key.buf = NULL;\n\tnode__put(el, el->el_key.map);\n\tel->el_key.map = NULL;\n}\n", "bug_type": null, "idx": 2467}
{"project": "Asterisk", "target": 0, "func": "\nvoid sip_dialplan_function_unregister_tests(void)\n{\n\tAST_TEST_UNREGISTER(test_sip_rtpqos_1);\n}\n", "bug_type": null, "idx": 2468}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void contact_updated(const void *obj)\n{\n\tupdate_contact_status(obj, AVAILABLE, 1);\n}\n", "bug_type": null, "idx": 2469}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int check_state(void *obj, void *arg, int flags)\n{\n\tstruct sip_outbound_registration_state *state = obj;\n\tstruct sip_outbound_registration *registration;\n\tregistration = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), \"registration\",\n\t\tast_sorcery_object_get_id(state->registration));\n\tif (!registration) {\n\t\t\n\t\treturn CMP_MATCH;\n\t}\n\tao2_ref(registration, -1);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2470}
{"project": "Asterisk", "target": 0, "func": " */\nstatic struct ast_frame *chan_msg_read(struct ast_channel *chan)\n{\n\treturn &ast_null_frame;\n}\n", "bug_type": null, "idx": 2471}
{"project": "Asterisk", "target": 0, "func": "static int acf_cut_exec2(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len)\n{\n\tint ret = -1;\n\tswitch (cut_internal(chan, data, buf, len)) {\n\tcase ERROR_NOARG:\n\t\tast_log(LOG_ERROR, \"Syntax: CUT(<varname>,<char-delim>,<range-spec>) - missing argument!\\n\");\n\t\tbreak;\n\tcase ERROR_NOMEM:\n\t\tast_log(LOG_ERROR, \"Out of memory\\n\");\n\t\tbreak;\n\tcase ERROR_USAGE:\n\t\tast_log(LOG_ERROR, \"Usage: CUT(<varname>,<char-delim>,<range-spec>)\\n\");\n\t\tbreak;\n\tcase 0:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tast_log(LOG_ERROR, \"Unknown internal error\\n\");\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 2472}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *kill_exception(struct ast_channel *chan)\n{\n\t\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2473}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int mwi_mailbox_update(struct mansession *s, const struct message *m)\n{\n\tconst char *mailbox_id = astman_get_header(m, \"Mailbox\");\n\tconst char *msgs_old = astman_get_header(m, \"OldMessages\");\n\tconst char *msgs_new = astman_get_header(m, \"NewMessages\");\n\tstruct ast_mwi_mailbox_object *mailbox;\n\tunsigned int num_old;\n\tunsigned int num_new;\n\tif (ast_strlen_zero(mailbox_id)) {\n\t\tastman_send_error(s, m, \"Missing mailbox parameter in request\");\n\t\treturn 0;\n\t}\n\tnum_old = 0;\n\tif (!ast_strlen_zero(msgs_old)) {\n\t\tif (sscanf(msgs_old, \"%u\", &num_old) != 1) {\n\t\t\tastman_send_error_va(s, m, \"Invalid OldMessages: %s\", msgs_old);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tnum_new = 0;\n\tif (!ast_strlen_zero(msgs_new)) {\n\t\tif (sscanf(msgs_new, \"%u\", &num_new) != 1) {\n\t\t\tastman_send_error_va(s, m, \"Invalid NewMessages: %s\", msgs_new);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmailbox = ast_mwi_mailbox_alloc(mailbox_id);\n\tif (!mailbox) {\n\t\tastman_send_error(s, m, \"Mailbox object creation failure\");\n\t\treturn 0;\n\t}\n\t\n\tast_mwi_mailbox_set_msgs_old(mailbox, num_old);\n\tast_mwi_mailbox_set_msgs_new(mailbox, num_new);\n\tif (ast_mwi_mailbox_update(mailbox)) {\n\t\tastman_send_error(s, m, \"Update attempt failed\");\n\t} else {\n\t\tastman_send_ack(s, m, NULL);\n\t}\n\tast_mwi_mailbox_unref(mailbox);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2474}
{"project": "Asterisk", "target": 0, "func": "#endif \nstatic void map_select_results(struct pollfd *pArray, unsigned long n_fds,\n\t\t\t  ast_fdset *pReadSet, ast_fdset *pWriteSet, ast_fdset *pExceptSet)\n{\n\tregister unsigned long  i;    \n\tregister struct pollfd *pCur; \n\tfor (i = 0, pCur = pArray; i < n_fds; i++, pCur++) {\n\t\t\n\t\tif (pCur->fd < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpCur->revents = 0;\n\t\tif (FD_ISSET(pCur->fd, (fd_set *) pExceptSet)) {\n\t\t\tpCur->revents |= POLLPRI;\n\t\t} else if (FD_ISSET(pCur->fd, (fd_set *) pReadSet)) {\n\t\t\tpCur->revents |= POLLIN;\n\t\t}\n\t\tif (FD_ISSET(pCur->fd, (fd_set *) pWriteSet)) {\n\t\t\tpCur->revents |= POLLOUT;\n\t\t}\n\t}\n\treturn;\n}\n", "bug_type": null, "idx": 2475}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245MultiplexEntrySendReject (OOCTXT* pctxt, H245MultiplexEntrySendReject* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"sequenceNumber\", -1);\n   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"sequenceNumber\", -1);\n   \n   invokeStartElement (pctxt, \"rejectionDescriptions\", -1);\n   stat = asn1PD_H245MultiplexEntrySendReject_rejectionDescriptions (pctxt, &pvalue->rejectionDescriptions);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"rejectionDescriptions\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2476}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void misdn_cc_handle_b_free(int port, const struct FacParm *facility)\n{\n\tstruct misdn_cc_record *cc_record;\n\tstruct misdn_cc_notify notify;\n\tlong record_id;\n\tAST_LIST_LOCK(&misdn_cc_records_db);\n\tcc_record = misdn_cc_find_by_reference(port, facility->u.CCBSBFree.CCBSReference);\n\tif (cc_record && cc_record->b_free.context[0]) {\n\t\t\n\t\tnotify = cc_record->b_free;\n\t\trecord_id = cc_record->record_id;\n\t\tAST_LIST_UNLOCK(&misdn_cc_records_db);\n\t\tmisdn_cc_pbx_notify(record_id, &notify);\n\t} else {\n\t\tAST_LIST_UNLOCK(&misdn_cc_records_db);\n\t}\n}\n", "bug_type": null, "idx": 2477}
{"project": "Asterisk", "target": 0, "func": "static void rtp_dtls_wrap_stop(struct ast_rtp_instance *instance)\n{\n\tao2_lock(instance);\n\tinstance->engine->dtls->stop(instance);\n\tao2_unlock(instance);\n}\n", "bug_type": null, "idx": 2478}
{"project": "Asterisk", "target": 0, "func": "void* readSignal(void* ptr)\n{\n\twhile(connected)\n\t{\n\t\tread_full(3,window,WINSIZE);\n\t\twrite_buf(speech_desc,window,WINSIZE);\n\t}\n\tpthread_exit(NULL);\n}\n", "bug_type": null, "idx": 2479}
{"project": "Asterisk", "target": 0, "func": "\nstatic int rtp_write(struct ast_channel *ast, struct ast_frame *f)\n{\n\tstruct ast_rtp_instance *instance = ast_channel_tech_pvt(ast);\n\treturn ast_rtp_instance_write(instance, f);\n}\n", "bug_type": null, "idx": 2480}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *mp3_read(struct ast_filestream *s, int *whennext)\n{\n\tstruct mp3_private *p = s->_private;\n\tint delay =0;\n\tint save=0;\n\t\n\tif (mp3_queue(s)) {\n\t\treturn NULL;\n\t}\n\tif (p->dbuflen) {\n\t\t\n\t\tfor (p->buflen = 0; p->buflen < MP3_BUFLEN && p->buflen < p->dbuflen; p->buflen++) {\n\t\t\ts->buf[p->buflen + AST_FRIENDLY_OFFSET] = p->dbuf[p->buflen + p->dbufoffset];\n\t\t}\n\t\tp->dbufoffset += p->buflen;\n\t\tp->dbuflen -= p->buflen;\n\t}\n\tif (p->buflen < MP3_BUFLEN) {\n\t\t\n\t\tp->dbuflen = p->dbufoffset = 0;\n\t\tif (mp3_queue(s)) {\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tif (p->dbuflen >= (MP3_BUFLEN - p->buflen)) {\n\t\t\tfor (save = p->buflen; p->buflen < MP3_BUFLEN; p->buflen++) {\n\t\t\t\ts->buf[p->buflen + AST_FRIENDLY_OFFSET] = p->dbuf[(p->buflen - save) + p->dbufoffset];\n\t\t\t}\n\t\t\tp->dbufoffset += (MP3_BUFLEN - save);\n\t\t\tp->dbuflen -= (MP3_BUFLEN - save);\n\t\t}\n\t}\n\tp->offset += p->buflen;\n\tdelay = p->buflen / 2;\n\tAST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, p->buflen);\n\ts->fr.samples = delay;\n\t*whennext = delay;\n\treturn &s->fr;\n}\n", "bug_type": null, "idx": 2481}
{"project": "Asterisk", "target": 0, "func": "static int NBScat_exec(struct ast_channel *chan, const char *data)\n{\n\tint res=0;\n\tint fds[2];\n\tint ms = -1;\n\tint pid = -1;\n\tstruct ast_format *owriteformat;\n\tstruct timeval next;\n\tstruct ast_frame *f;\n\tstruct myframe {\n\t\tstruct ast_frame f;\n\t\tchar offset[AST_FRIENDLY_OFFSET];\n\t\tshort frdata[160];\n\t} myf;\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, fds)) {\n\t\tast_log(LOG_WARNING, \"Unable to create socketpair\\n\");\n\t\treturn -1;\n\t}\n\tast_stopstream(chan);\n\towriteformat = ao2_bump(ast_channel_writeformat(chan));\n\tres = ast_set_write_format(chan, ast_format_slin);\n\tif (res < 0) {\n\t\tast_log(LOG_WARNING, \"Unable to set write format to signed linear\\n\");\n\t\tao2_cleanup(owriteformat);\n\t\treturn -1;\n\t}\n\tmyf.f.frametype = AST_FRAME_VOICE;\n\tmyf.f.subclass.format = ast_format_slin;\n\tmyf.f.mallocd = 0;\n\tmyf.f.offset = AST_FRIENDLY_OFFSET;\n\tmyf.f.src = __PRETTY_FUNCTION__;\n\tmyf.f.delivery.tv_sec = 0;\n\tmyf.f.delivery.tv_usec = 0;\n\tmyf.f.data.ptr = myf.frdata;\n\tres = NBScatplay(fds[1]);\n\t\n\tnext = ast_tvnow();\n\tnext.tv_sec += 1;\n\tif (res >= 0) {\n\t\tpid = res;\n\t\t\n\t\tfor (;;) {\n\t\t\tms = ast_tvdiff_ms(next, ast_tvnow());\n\t\t\tif (ms <= 0) {\n\t\t\t\tres = timed_read(fds[0], myf.frdata, sizeof(myf.frdata));\n\t\t\t\tif (res > 0) {\n\t\t\t\t\tmyf.f.datalen = res;\n\t\t\t\t\tmyf.f.samples = res / 2;\n\t\t\t\t\tif (ast_write(chan, &myf.f) < 0) {\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tast_debug(1, \"No more mp3\\n\");\n\t\t\t\t\tres = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext = ast_tvadd(next, ast_samp2tv(myf.f.samples, 8000));\n\t\t\t} else {\n\t\t\t\tms = ast_waitfor(chan, ms);\n\t\t\t\tif (ms < 0) {\n\t\t\t\t\tast_debug(1, \"Hangup detected\\n\");\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ms) {\n\t\t\t\t\tf = ast_read(chan);\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tast_debug(1, \"Null frame == hangup() detected\\n\");\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (f->frametype == AST_FRAME_DTMF) {\n\t\t\t\t\t\tast_debug(1, \"User pressed a key\\n\");\n\t\t\t\t\t\tast_frfree(f);\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tast_frfree(f);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tast_frfree(&myf.f);\n\tif (pid > -1)\n\t\tkill(pid, SIGKILL);\n\tif (!res && owriteformat)\n\t\tast_set_write_format(chan, owriteformat);\n\tao2_cleanup(owriteformat);\n\treturn res;\n}\n", "bug_type": null, "idx": 2482}
{"project": "Asterisk", "target": 0, "func": "int ast_hashtab_resize_none(struct ast_hashtab *tab) \n{\n\treturn 0;\n}\n", "bug_type": null, "idx": 2483}
{"project": "Asterisk", "target": 0, "func": "static u_char *ast_var_channel_types_table(struct variable *vp, oid *name, size_t *length,\n\t\t\t\t\t\t\t\t\t\tint exact, size_t *var_len, WriteMethod **write_method)\n{\n\tconst struct ast_channel_tech *tech = NULL;\n\tstruct ast_variable *channel_types, *next;\n\tstatic unsigned long long_ret;\n\tstruct ast_channel *chan;\n\tu_long i;\n\tif (header_simple_table(vp, name, length, exact, var_len, write_method, -1))\n\t\treturn NULL;\n\tchannel_types = ast_channeltype_list();\n\tfor (i = 1, next = channel_types; next && i != name[*length - 1]; next = next->next, i++)\n\t\t;\n\tif (next != NULL)\n\t\ttech = ast_get_channel_tech(next->name);\n\tast_variables_destroy(channel_types);\n\tif (next == NULL || tech == NULL)\n\t\treturn NULL;\n\tswitch (vp->magic) {\n\tcase ASTCHANTYPEINDEX:\n\t\tlong_ret = name[*length - 1];\n\t\treturn (u_char *)&long_ret;\n\tcase ASTCHANTYPENAME:\n\t\t*var_len = strlen(tech->type);\n\t\treturn (u_char *)tech->type;\n\tcase ASTCHANTYPEDESC:\n\t\t*var_len = strlen(tech->description);\n\t\treturn (u_char *)tech->description;\n\tcase ASTCHANTYPEDEVSTATE:\n\t\tlong_ret = tech->devicestate ? 1 : 2;\n\t\treturn (u_char *)&long_ret;\n\tcase ASTCHANTYPEINDICATIONS:\n\t\tlong_ret = tech->indicate ? 1 : 2;\n\t\treturn (u_char *)&long_ret;\n\tcase ASTCHANTYPETRANSFER:\n\t\tlong_ret = tech->transfer ? 1 : 2;\n\t\treturn (u_char *)&long_ret;\n\tcase ASTCHANTYPECHANNELS:\n\t{\n\t\tstruct ast_channel_iterator *iter;\n\t\tlong_ret = 0;\n\t\tif (!(iter = ast_channel_iterator_all_new())) {\n\t\t\treturn NULL;\n\t\t}\n\t\twhile ((chan = ast_channel_iterator_next(iter))) {\n\t\t\tif (ast_channel_tech(chan) == tech) {\n\t\t\t\tlong_ret++;\n\t\t\t}\n\t\t\tchan = ast_channel_unref(chan);\n\t\t}\n\t\tast_channel_iterator_destroy(iter);\n\t\treturn (u_char *)&long_ret;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 2484}
{"project": "Asterisk", "target": 0, "func": "int ast_cc_get_param(struct ast_cc_config_params *params, const char * const name,\n\t\tchar *buf, size_t buf_len)\n{\n\tconst char *value = NULL;\n\tif (!strcasecmp(name, \"cc_callback_macro\")) {\n\t\tvalue = ast_get_cc_callback_macro(params);\n\t} else if (!strcasecmp(name, \"cc_callback_sub\")) {\n\t\tvalue = ast_get_cc_callback_sub(params);\n\t} else if (!strcasecmp(name, \"cc_agent_policy\")) {\n\t\tvalue = agent_policy_to_str(ast_get_cc_agent_policy(params));\n\t} else if (!strcasecmp(name, \"cc_monitor_policy\")) {\n\t\tvalue = monitor_policy_to_str(ast_get_cc_monitor_policy(params));\n\t} else if (!strcasecmp(name, \"cc_agent_dialstring\")) {\n\t\tvalue = ast_get_cc_agent_dialstring(params);\n\t}\n\tif (value) {\n\t\tast_copy_string(buf, value, buf_len);\n\t\treturn 0;\n\t}\n\t\n\tif (!strcasecmp(name, \"cc_offer_timer\")) {\n\t\tsnprintf(buf, buf_len, \"%u\", ast_get_cc_offer_timer(params));\n\t} else if (!strcasecmp(name, \"ccnr_available_timer\")) {\n\t\tsnprintf(buf, buf_len, \"%u\", ast_get_ccnr_available_timer(params));\n\t} else if (!strcasecmp(name, \"ccbs_available_timer\")) {\n\t\tsnprintf(buf, buf_len, \"%u\", ast_get_ccbs_available_timer(params));\n\t} else if (!strcasecmp(name, \"cc_max_agents\")) {\n\t\tsnprintf(buf, buf_len, \"%u\", ast_get_cc_max_agents(params));\n\t} else if (!strcasecmp(name, \"cc_max_monitors\")) {\n\t\tsnprintf(buf, buf_len, \"%u\", ast_get_cc_max_monitors(params));\n\t} else if (!strcasecmp(name, \"cc_recall_timer\")) {\n\t\tsnprintf(buf, buf_len, \"%u\", ast_get_cc_recall_timer(params));\n\t} else {\n\t\tast_log(LOG_WARNING, \"%s is not a valid CC parameter. Ignoring.\\n\", name);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2485}
{"project": "Asterisk", "target": 0, "func": "static int action_dahdidialoffhook(struct mansession *s, const struct message *m)\n{\n\tstruct dahdi_pvt *p;\n\tconst char *channel = astman_get_header(m, \"DAHDIChannel\");\n\tconst char *number = astman_get_header(m, \"Number\");\n\tint i;\n\tif (ast_strlen_zero(channel)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(number)) {\n\t\tastman_send_error(s, m, \"No number specified\");\n\t\treturn 0;\n\t}\n\tp = find_channel_from_str(channel);\n\tif (!p) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn 0;\n\t}\n\tif (!p->owner) {\n\t\tastman_send_error(s, m, \"Channel does not have it's owner\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < strlen(number); i++) {\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = number[i] };\n\t\tdahdi_queue_frame(p, &f);\n\t}\n\tastman_send_ack(s, m, \"DAHDIDialOffhook\");\n\treturn 0;\n}\n", "bug_type": null, "idx": 2486}
{"project": "Asterisk", "target": 0, "func": "static int bucket_http_wizard_create(const struct ast_sorcery *sorcery, void *data,\n\tvoid *object)\n{\n\tstruct ast_bucket_file *bucket_file = object;\n\treturn bucket_file_run_curl(bucket_file);\n}\n", "bug_type": null, "idx": 2487}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_context_add_ignorepat(const char *context, const char *value, const char *registrar)\n{\n\tint ret = -1;\n\tstruct ast_context *c;\n\tc = find_context_locked(context);\n\tif (c) {\n\t\tret = ast_context_add_ignorepat2(c, value, registrar);\n\t\tast_unlock_contexts();\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 2488}
{"project": "Asterisk", "target": 0, "func": "\nint ast_queue_hangup(struct ast_channel *chan)\n{\n\tstruct ast_frame f = { AST_FRAME_CONTROL, .subclass.integer = AST_CONTROL_HANGUP };\n\tint res;\n\t\n\tast_channel_lock(chan);\n\tast_channel_softhangup_internal_flag_add(chan, AST_SOFTHANGUP_DEV);\n\tast_channel_publish_blob(chan, ast_channel_hangup_request_type(), NULL);\n\tres = ast_queue_frame(chan, &f);\n\tast_channel_unlock(chan);\n\treturn res;\n}\n", "bug_type": null, "idx": 2489}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int sla_check_station_delay(struct sla_station *station, \n\tstruct sla_ringing_trunk *ringing_trunk)\n{\n\tRAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);\n\tunsigned int delay = UINT_MAX;\n\tint time_left, time_elapsed;\n\tif (!ringing_trunk)\n\t\tringing_trunk = sla_choose_ringing_trunk(station, &trunk_ref, 0);\n\telse\n\t\ttrunk_ref = sla_find_trunk_ref(station, ringing_trunk->trunk);\n\tif (!ringing_trunk || !trunk_ref)\n\t\treturn delay;\n\t\n\tdelay = trunk_ref->ring_delay;\n\tif (!delay)\n\t\tdelay = station->ring_delay;\n\tif (!delay)\n\t\treturn INT_MAX;\n\ttime_elapsed = ast_tvdiff_ms(ast_tvnow(), ringing_trunk->ring_begin);\n\ttime_left = (delay * 1000) - time_elapsed;\n\treturn time_left;\n}\n", "bug_type": null, "idx": 2490}
{"project": "Asterisk", "target": 0, "func": "int ast_ari_validate_caller_id(struct ast_json *json)\n{\n\tint res = 1;\n\tstruct ast_json_iter *iter;\n\tint has_name = 0;\n\tint has_number = 0;\n\tfor (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {\n\t\tif (strcmp(\"name\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_name = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI CallerID field name failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(\"number\", ast_json_object_iter_key(iter)) == 0) {\n\t\t\tint prop_is_valid;\n\t\t\thas_number = 1;\n\t\t\tprop_is_valid = ast_ari_validate_string(\n\t\t\t\tast_json_object_iter_value(iter));\n\t\t\tif (!prop_is_valid) {\n\t\t\t\tast_log(LOG_ERROR, \"ARI CallerID field number failed validation\\n\");\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_ERROR,\n\t\t\t\t\"ARI CallerID has undocumented field %s\\n\",\n\t\t\t\tast_json_object_iter_key(iter));\n\t\t\tres = 0;\n\t\t}\n\t}\n\tif (!has_name) {\n\t\tast_log(LOG_ERROR, \"ARI CallerID missing required field name\\n\");\n\t\tres = 0;\n\t}\n\tif (!has_number) {\n\t\tast_log(LOG_ERROR, \"ARI CallerID missing required field number\\n\");\n\t\tres = 0;\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 2491}
{"project": "Asterisk", "target": 0, "func": "void iax2_codec_pref_append(struct iax2_codec_pref *pref, struct ast_format *format, unsigned int framing)\n{\n\tuint64_t bitfield;\n\tbitfield = ast_format_compatibility_format2bitfield(format);\n\tif (!bitfield) {\n\t\treturn;\n\t}\n\tiax2_codec_pref_append_bitfield(pref, bitfield, framing);\n}\n", "bug_type": null, "idx": 2492}
{"project": "Asterisk", "target": 0, "func": "\nstatic int adpcmtolin_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)\n{\n\tstruct adpcm_decoder_pvt *tmp = pvt->pvt;\n\tint x = f->datalen;\n\tunsigned char *src = f->data.ptr;\n\tint16_t *dst = pvt->outbuf.i16 + pvt->samples;\n\twhile (x--) {\n\t\t*dst++ = decode((*src >> 4) & 0xf, &tmp->state);\n\t\t*dst++ = decode(*src++ & 0x0f, &tmp->state);\n\t}\n\tpvt->samples += f->samples;\n\tpvt->datalen += 2*f->samples;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2493}
{"project": "Asterisk", "target": 0, "func": "};\nstatic void set_channel_on_rtp_instance(const struct ast_sip_session *session,\n\tconst char *channel_id)\n{\n\tint i;\n\tfor (i = 0; i < AST_VECTOR_SIZE(&session->active_media_state->sessions); ++i) {\n\t\tstruct ast_sip_session_media *session_media;\n\t\tsession_media = AST_VECTOR_GET(&session->active_media_state->sessions, i);\n\t\tif (!session_media || !session_media->rtp) {\n\t\t\tcontinue;\n\t\t}\n\t\tast_rtp_instance_set_channel_id(session_media->rtp, channel_id);\n\t}\n}\n", "bug_type": null, "idx": 2494}
{"project": "Asterisk", "target": 0, "func": "static struct ao2_container *formats;\nstatic int format_hash_cb(const void *obj, int flags)\n{\n\tconst struct ast_format *format;\n\tconst char *key;\n\tswitch (flags & OBJ_SEARCH_MASK) {\n\tcase OBJ_SEARCH_KEY:\n\t\tkey = obj;\n\t\treturn ast_str_case_hash(key);\n\tcase OBJ_SEARCH_OBJECT:\n\t\tformat = obj;\n\t\treturn ast_str_case_hash(ast_format_get_name(format));\n\tdefault:\n\t\t\n\t\tast_assert(0);\n\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 2495}
{"project": "Asterisk", "target": 0, "func": "enum ast_endpoint_state ast_endpoint_get_state(const struct ast_endpoint *endpoint)\n{\n\tif (!endpoint) {\n\t\treturn AST_ENDPOINT_UNKNOWN;\n\t}\n\treturn endpoint->state;\n}\n", "bug_type": null, "idx": 2496}
{"project": "Asterisk", "target": 0, "func": "void include_free(struct ast_include *inc)\n{\n\tast_destroy_timing(&(inc->timing));\n\tast_free(inc);\n}\n", "bug_type": null, "idx": 2497}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245VideoIndicateCompose (OOCTXT* pctxt, H245VideoIndicateCompose* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"compositionNumber\", -1);\n   stat = decodeConsUInt8 (pctxt, &pvalue->compositionNumber, 0U, 255U);\n   if (stat != ASN_OK) return stat;\n   invokeUIntValue (pctxt, pvalue->compositionNumber);\n   invokeEndElement (pctxt, \"compositionNumber\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2498}
{"project": "Asterisk", "target": 0, "func": "int ast_bucket_is_stale(struct ast_bucket *bucket)\n{\n\treturn ast_sorcery_is_stale(bucket_sorcery, bucket);\n}\n", "bug_type": null, "idx": 2499}
{"project": "Asterisk", "target": 0, "func": "\t\"\tORDER BY cat_metric ASC, var_metric ASC;\"\nstatic void free_table(struct sqlite_cache_tables *tblptr)\n{\n\tstruct sqlite_cache_columns *col;\n\t\n\tAST_RWLIST_WRLOCK(&(tblptr->columns));\n\twhile ((col = AST_RWLIST_REMOVE_HEAD(&(tblptr->columns), list))) {\n\t\tast_free(col);\n\t}\n\tAST_RWLIST_UNLOCK(&(tblptr->columns));\n\tAST_RWLIST_HEAD_DESTROY(&(tblptr->columns));\n\tast_free(tblptr);\n}\n", "bug_type": null, "idx": 2500}
{"project": "Asterisk", "target": 0, "func": "void stasis_app_control_unhold(struct stasis_app_control *control)\n{\n\tstasis_app_send_command_async(control, app_control_unhold, NULL, NULL);\n}\n", "bug_type": null, "idx": 2501}
{"project": "Asterisk", "target": 0, "func": "int ooRemoveCapFromCapPrefs(OOH323CallData *call, int cap)\n{\n   int i=0, j=0;\n   OOCapPrefs *capPrefs=NULL, oldPrefs;\n   if(call)\n      capPrefs = &call->capPrefs;\n   else\n      capPrefs = &gH323ep.capPrefs;\n   memcpy(&oldPrefs, capPrefs, sizeof(OOCapPrefs));\n   memset(capPrefs, 0, sizeof(OOCapPrefs));\n   for(i=0; i<oldPrefs.index; i++)\n   {  \n      if(oldPrefs.order[i] != cap) \n         capPrefs->order[j++] = oldPrefs.order[i];\n   }\n   capPrefs->index = j;\n   return OO_OK;\n}\n", "bug_type": null, "idx": 2502}
{"project": "Asterisk", "target": 0, "func": "void ast_connected_line_copy_from_caller(struct ast_party_connected_line *dest, const struct ast_party_caller *src)\n{\n\tast_party_id_copy(&dest->id, &src->id);\n\tast_party_id_copy(&dest->ani, &src->ani);\n\tdest->ani2 = src->ani2;\n}\n", "bug_type": null, "idx": 2503}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225TransportAddress_ipAddress (OOCTXT* pctxt, H225TransportAddress_ipAddress* pvalue)\n{\n   int stat = ASN_OK;\n   \n   stat = asn1PE_H225TransportAddress_ipAddress_ip (pctxt, &pvalue->ip);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeConsUnsigned (pctxt, pvalue->port, 0U, 65535U);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2504}
{"project": "Asterisk", "target": 0, "func": "void ast_ari_response_alloc_failed(struct ast_ari_response *response)\n{\n\tresponse->message = ast_json_ref(oom_json);\n\tresponse->response_code = 500;\n\tresponse->response_text = \"Internal Server Error\";\n}\n", "bug_type": null, "idx": 2505}
{"project": "Asterisk", "target": 0, "func": "static int aoro2_class_cb(void *obj, void *arg, int flags)\n{\n\tstruct odbc_class *class = obj;\n\tchar *name = arg;\n\tif (!strcmp(class->name, name) && !class->delme) {\n\t\treturn CMP_MATCH | CMP_STOP;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2506}
{"project": "Asterisk", "target": 0, "func": "int internal_sip_session_unregister_supplement(struct ast_sip_session_supplement *supplement)\n{\n\tstruct ast_sip_session_supplement *iter;\n\tint res = -1;\n\tSCOPED_LOCK(lock, &session_supplements, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&session_supplements, iter, next) {\n\t\tif (supplement == iter) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(next);\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\treturn res;\n}\n", "bug_type": null, "idx": 2507}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245NetworkAccessParameters (OOCTXT* pctxt, H245NetworkAccessParameters* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   ASN1OpenType openType;\n   OOCTXT lctxt;\n   \n   extbit = (ASN1BOOL)(pvalue->m.t120SetupProcedurePresent);\n   encodeBit (pctxt, extbit);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.distributionPresent);\n   encodeBit (pctxt, (ASN1BOOL)pvalue->m.externalReferencePresent);\n   \n   if (pvalue->m.distributionPresent) {\n      stat = asn1PE_H245NetworkAccessParameters_distribution (pctxt, &pvalue->distribution);\n      if (stat != ASN_OK) return stat;\n   }\n   \n   stat = asn1PE_H245NetworkAccessParameters_networkAddress (pctxt, &pvalue->networkAddress);\n   if (stat != ASN_OK) return stat;\n   \n   stat = encodeBit (pctxt, (ASN1BOOL)pvalue->associateConference);\n   if (stat != ASN_OK) return stat;\n   \n   if (pvalue->m.externalReferencePresent) {\n      stat = asn1PE_H245NetworkAccessParameters_externalReference (pctxt, &pvalue->externalReference);\n      if (stat != ASN_OK) return stat;\n   }\n   if (extbit) {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, 0);\n      if (stat != ASN_OK) return stat;\n      \n      encodeBit (pctxt, (ASN1BOOL)pvalue->m.t120SetupProcedurePresent);\n      \n      if (pvalue->m.t120SetupProcedurePresent) {\n         initContext (&lctxt);\n         stat = setPERBuffer (&lctxt, 0, 0, TRUE);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = asn1PE_H245NetworkAccessParameters_t120SetupProcedure (&lctxt, &pvalue->t120SetupProcedure);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         stat = encodeByteAlign (&lctxt);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         openType.data = encodeGetMsgPtr (&lctxt, (int*)&openType.numocts);\n         stat = encodeOpenType (pctxt, openType.numocts, openType.data);\n         if (stat != ASN_OK) return freeContext (&lctxt), stat;\n         freeContext (&lctxt);\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2508}
{"project": "Asterisk", "target": 0, "func": "static void save_history(plc_state_t *s, int16_t *buf, int len)\n{\n\tif (len >= PLC_HISTORY_LEN) {\n\t\t\n\t\t memcpy(s->history, buf + len - PLC_HISTORY_LEN, sizeof(int16_t) * PLC_HISTORY_LEN);\n\t\ts->buf_ptr = 0;\n\t\treturn;\n\t}\n\tif (s->buf_ptr + len > PLC_HISTORY_LEN) {\n\t\t\n\t\tmemcpy(s->history + s->buf_ptr, buf, sizeof(int16_t) * (PLC_HISTORY_LEN - s->buf_ptr));\n\t\tlen -= (PLC_HISTORY_LEN - s->buf_ptr);\n\t\tmemcpy(s->history, buf + (PLC_HISTORY_LEN - s->buf_ptr), sizeof(int16_t)*len);\n\t\ts->buf_ptr = len;\n\t\treturn;\n\t}\n\t\n\tmemcpy(s->history + s->buf_ptr, buf, sizeof(int16_t)*len);\n\ts->buf_ptr += len;\n}\n", "bug_type": null, "idx": 2509}
{"project": "Asterisk", "target": 0, "func": "void ast_iostream_set_timeout_disable(struct ast_iostream *stream)\n{\n\tast_assert(stream != NULL);\n\tstream->timeout = -1;\n\tstream->timeout_reset = -1;\n}\n", "bug_type": null, "idx": 2510}
{"project": "Asterisk", "target": 0, "func": "int ast_bridge_interval_hook(struct ast_bridge_features *features,\n\tenum ast_bridge_hook_timer_option flags,\n\tunsigned int interval,\n\tast_bridge_hook_callback callback,\n\tvoid *hook_pvt,\n\tast_bridge_hook_pvt_destructor destructor,\n\tenum ast_bridge_hook_remove_flags remove_flags)\n{\n\tstruct ast_bridge_hook_timer *hook;\n\tint res;\n\tif (!features ||!interval || !callback) {\n\t\treturn -1;\n\t}\n\t\n\thook = (struct ast_bridge_hook_timer *) bridge_hook_generic(sizeof(*hook), callback,\n\t\thook_pvt, destructor, remove_flags);\n\tif (!hook) {\n\t\treturn -1;\n\t}\n\thook->generic.type = AST_BRIDGE_HOOK_TYPE_TIMER;\n\thook->timer.interval = interval;\n\thook->timer.trip_time = ast_tvadd(ast_tvnow(), ast_samp2tv(interval, 1000));\n\thook->timer.seqno = ast_atomic_fetchadd_int((int *) &features->interval_sequence, +1);\n\thook->timer.flags = flags;\n\tast_debug(1, \"Putting interval hook %p with interval %u in the heap on features %p\\n\",\n\t\thook, hook->timer.interval, features);\n\tast_heap_wrlock(features->interval_hooks);\n\tres = ast_heap_push(features->interval_hooks, hook);\n\tast_heap_unlock(features->interval_hooks);\n\tif (res) {\n\t\t\n\t\thook->generic.destructor = NULL;\n\t\tao2_ref(hook, -1);\n\t}\n\treturn res ? -1 : 0;\n}\n", "bug_type": null, "idx": 2511}
{"project": "Asterisk", "target": 0, "func": "void __ast_string_field_ptr_build(struct ast_string_field_mgr *mgr,\n\tstruct ast_string_field_pool **pool_head, ast_string_field *ptr, const char *format, ...)\n{\n\tva_list ap;\n\tva_start(ap, format);\n\t__ast_string_field_ptr_build_va(mgr, pool_head, ptr, format, ap);\n\tva_end(ap);\n}\n", "bug_type": null, "idx": 2512}
{"project": "Asterisk", "target": 0, "func": "void free_convolve_data(struct convolve_data *data)\n{\n\tunsigned int i;\n\tast_free(data->pos_ids);\n\tfor (i = 0; i < data->chan_size; i++) {\n\t\tfree_convolve_channel_pair(data->cchan_pair[i]);\n\t\tast_free(data->cchan_pair[i]);\n\t}\n\tast_free(data->cchan_pair);\n}\n", "bug_type": null, "idx": 2513}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H225NonStandardIdentifier (OOCTXT* pctxt, H225NonStandardIdentifier* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = (ASN1BOOL)(pvalue->t > 2);\n   encodeBit (pctxt, extbit);\n   if (!extbit) {\n      \n      stat = encodeConsUnsigned (pctxt, pvalue->t - 1, 0, 1);\n      if (stat != ASN_OK) return stat;\n      \n      switch (pvalue->t)\n      {\n         \n         case 1:\n            stat = encodeObjectIdentifier (pctxt, pvalue->u.object);\n            if (stat != ASN_OK) return stat;\n            break;\n         \n         case 2:\n            stat = asn1PE_H225H221NonStandard (pctxt, pvalue->u.h221NonStandard);\n            if (stat != ASN_OK) return stat;\n            break;\n         default:\n            return ASN_E_INVOPT;\n      }\n   }\n   else {\n      \n      stat = encodeSmallNonNegWholeNumber (pctxt, pvalue->t - 3);\n      if (stat != ASN_OK) return stat;\n      \n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2514}
{"project": "Asterisk", "target": 0, "func": " */\nstatic char *handle_cli_dialplan_save(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tchar filename[256], overrideswitch[256] = \"\";\n\tstruct ast_context *c;\n\tstruct ast_config *cfg;\n\tstruct ast_variable *v;\n\tint incomplete = 0; \n\tFILE *output;\n\tstruct ast_flags config_flags = { 0 };\n\tconst char *base, *slash;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"dialplan save\";\n\t\te->usage =\n\t\t\t\"Usage: dialplan save [/path/to/extension/file]\\n\"\n\t\t\t\"       Save dialplan created by pbx_config module.\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"Example: dialplan save                 (/etc/asterisk/extensions.conf)\\n\"\n\t\t\t\"         dialplan save /home/markster  (/home/markster/extensions.conf)\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (! (static_config && !write_protect_config)) {\n\t\tast_cli(a->fd,\n\t\t\t\"I can't save dialplan now, see '%s' example file.\\n\",\n\t\t\tconfig);\n\t\treturn CLI_FAILURE;\n\t}\n\tif (a->argc != 2 && a->argc != 3)\n\t\treturn CLI_SHOWUSAGE;\n\tif (ast_mutex_lock(&save_dialplan_lock)) {\n\t\tast_cli(a->fd,\n\t\t\t\"Failed to lock dialplan saving (another proccess saving?)\\n\");\n\t\treturn CLI_FAILURE;\n\t}\n\t\n\tif (a->argc == 3) {\t\n\t\tbase = a->argv[2];\n\t\tif (!strstr(a->argv[2], \".conf\")) { \n\t\t\t\n\t\t\tslash = (*(a->argv[2] + strlen(a->argv[2]) -1) == '/') ? \"/\" : \"\";\n\t\t} else {\t\n\t\t\tslash = \"\";\n\t\t}\n\t} else {\n\t\t\n\t\tbase = ast_config_AST_CONFIG_DIR;\n\t\tslash = \"/\";\n\t}\n\tsnprintf(filename, sizeof(filename), \"%s%s%s\", base, slash, config);\n\tcfg = ast_config_load(\"extensions.conf\", config_flags);\n\tif (!cfg) {\n\t\tast_cli(a->fd, \"Failed to load extensions.conf\\n\");\n\t\tast_mutex_unlock(&save_dialplan_lock);\n\t\treturn CLI_FAILURE;\n\t}\n\t\n\tif (ast_rdlock_contexts()) {\n\t\tast_cli(a->fd, \"Failed to lock contexts list\\n\");\n\t\tast_mutex_unlock(&save_dialplan_lock);\n\t\tast_config_destroy(cfg);\n\t\treturn CLI_FAILURE;\n\t}\n\t\n\tif (!(output = fopen(filename, \"wt\"))) {\n\t\tast_cli(a->fd, \"Failed to create file '%s'\\n\",\n\t\t\tfilename);\n\t\tast_unlock_contexts();\n\t\tast_mutex_unlock(&save_dialplan_lock);\n\t\tast_config_destroy(cfg);\n\t\treturn CLI_FAILURE;\n\t}\n\t\n\tif (overrideswitch_config) {\n\t\tsnprintf(overrideswitch, sizeof(overrideswitch), \"overrideswitch=%s\\n\", overrideswitch_config);\n\t}\n\tfprintf(output, \"[general]\\nstatic=%s\\nwriteprotect=%s\\nautofallthrough=%s\\nclearglobalvars=%s\\n%sextenpatternmatchnew=%s\\n\\n\",\n\t\tstatic_config ? \"yes\" : \"no\",\n\t\twrite_protect_config ? \"yes\" : \"no\",\n                autofallthrough_config ? \"yes\" : \"no\",\n\t\t\t\tclearglobalvars_config ? \"yes\" : \"no\",\n\t\t\t\toverrideswitch_config ? overrideswitch : \"\",\n\t\t\t\textenpatternmatchnew_config ? \"yes\" : \"no\");\n\tif ((v = ast_variable_browse(cfg, \"globals\"))) {\n\t\tfprintf(output, \"[globals]\\n\");\n\t\twhile(v) {\n\t\t\tint escaped_len = 2 * strlen(v->value) + 1;\n\t\t\tchar escaped[escaped_len];\n\t\t\tast_escape_semicolons(v->value, escaped, escaped_len);\n\t\t\tfprintf(output, \"%s => %s\\n\", v->name, escaped);\n\t\t\tv = v->next;\n\t\t}\n\t\tfprintf(output, \"\\n\");\n\t}\n\tast_config_destroy(cfg);\n#define PUT_CTX_HDR\tdo { \\\n\tif (!context_header_written) {\t\\\n\t\tfprintf(output, \"[%s]\\n\", ast_get_context_name(c));\t\\\n\t\tcontext_header_written = 1;\t\\\n\t}\t\\\n\t} while (0)\n\t\n\tfor (c = NULL; (c = ast_walk_contexts(c)); ) {\n\t\tint context_header_written = 0;\n\t\tstruct ast_exten *ext, *last_written_e = NULL;\n\t\tint idx;\n\t\t\t\n\t\tif (ast_rdlock_context(c)) { \n\t\t\tincomplete = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tif (!strcmp(ast_get_context_registrar(c), registrar)) {\n\t\t\tfprintf(output, \"[%s]\\n\", ast_get_context_name(c));\n\t\t\tcontext_header_written = 1;\n\t\t}\n\t\t\n\t\tfor (ext = NULL; (ext = ast_walk_context_extensions(c, ext)); ) {\n\t\t\tstruct ast_exten *p = NULL;\n\t\t\t\n\t\t\twhile ( (p = ast_walk_extension_priorities(ext, p)) ) {\n\t\t\t\tif (strcmp(ast_get_extension_registrar(p), registrar) != 0) \n\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\tif (last_written_e != NULL &&\n\t\t\t\t\t    strcmp(ast_get_extension_name(last_written_e),\n\t\t\t\t\t\t    ast_get_extension_name(p)))\n\t\t\t\t\tfprintf(output, \"\\n\");\n\t\t\t\tlast_written_e = p;\n\t\t\t\tPUT_CTX_HDR;\n\t\t\t\tif (ast_get_extension_priority(p) == PRIORITY_HINT) { \n\t\t\t\t\tfprintf(output, \"exten => %s,hint,%s\\n\",\n\t\t\t\t\t\t    ast_get_extension_name(p),\n\t\t\t\t\t\t    ast_get_extension_app(p));\n\t\t\t\t} else {\n\t\t\t\t\tconst char *sep, *cid;\n\t\t\t\t\tconst char *el = ast_get_extension_label(p);\n\t\t\t\t\tchar label[128] = \"\";\n\t\t\t\t\tchar *appdata = ast_get_extension_app_data(p);\n\t\t\t\t\tint escaped_len = (!ast_strlen_zero(appdata)) ? 2 * strlen(appdata) + 1 : 1;\n\t\t\t\t\tchar escaped[escaped_len];\n\t\t\t\t\tif (ast_get_extension_matchcid(p)) {\n\t\t\t\t\t\tsep = \"/\";\n\t\t\t\t\t\tcid = ast_get_extension_cidmatch(p);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsep = cid = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif (el && (snprintf(label, sizeof(label), \"(%s)\", el) != (strlen(el) + 2))) {\n\t\t\t\t\t\tincomplete = 1;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!ast_strlen_zero(appdata)) {\n\t\t\t\t\t\tast_escape_semicolons(appdata, escaped, escaped_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tescaped[0] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(output, \"exten => %s%s%s,%d%s,%s(%s)\\n\",\n\t\t\t\t\t    ast_get_extension_name(p), (ast_strlen_zero(sep) ? \"\" : sep), (ast_strlen_zero(cid) ? \"\" : cid),\n\t\t\t\t\t    ast_get_extension_priority(p), label,\n\t\t\t\t\t    ast_get_extension_app(p), escaped);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (last_written_e)\n\t\t\tfprintf(output, \"\\n\");\n\t\t\n\t\tfor (idx = 0; idx < ast_context_includes_count(c); idx++) {\n\t\t\tconst struct ast_include *i = ast_context_includes_get(c, idx);\n\t\t\tif (strcmp(ast_get_include_registrar(i), registrar) != 0)\n\t\t\t\tcontinue; \n\t\t\tPUT_CTX_HDR;\n\t\t\tfprintf(output, \"include => %s\\n\", ast_get_include_name(i));\n\t\t}\n\t\tif (ast_context_includes_count(c)) {\n\t\t\tfprintf(output, \"\\n\");\n\t\t}\n\t\t\n\t\tfor (idx = 0; idx < ast_context_switches_count(c); idx++) {\n\t\t\tconst struct ast_sw *sw = ast_context_switches_get(c, idx);\n\t\t\tif (strcmp(ast_get_switch_registrar(sw), registrar) != 0)\n\t\t\t\tcontinue; \n\t\t\tPUT_CTX_HDR;\n\t\t\tfprintf(output, \"switch => %s/%s\\n\",\n\t\t\t\t    ast_get_switch_name(sw), ast_get_switch_data(sw));\n\t\t}\n\t\tif (ast_context_switches_count(c)) {\n\t\t\tfprintf(output, \"\\n\");\n\t\t}\n\t\t\n\t\tfor (idx = 0; idx < ast_context_ignorepats_count(c); idx++) {\n\t\t\tconst struct ast_ignorepat *ip = ast_context_ignorepats_get(c, idx);\n\t\t\tif (strcmp(ast_get_ignorepat_registrar(ip), registrar) != 0)\n\t\t\t\tcontinue; \n\t\t\tPUT_CTX_HDR;\n\t\t\tfprintf(output, \"ignorepat => %s\\n\",\n\t\t\t\t\t\tast_get_ignorepat_name(ip));\n\t\t}\n\t\tast_unlock_context(c);\n\t}\t\n\tast_unlock_contexts();\n\tast_mutex_unlock(&save_dialplan_lock);\n\tfclose(output);\n\tif (incomplete) {\n\t\tast_cli(a->fd, \"Saved dialplan is incomplete\\n\");\n\t\treturn CLI_FAILURE;\n\t}\n\tast_cli(a->fd, \"Dialplan successfully saved into '%s'\\n\",\n\t\tfilename);\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2515}
{"project": "Asterisk", "target": 0, "func": "static int restore_gains(struct dahdi_pvt *p)\n{\n\tint res;\n\tres = set_actual_gain(p->subs[SUB_REAL].dfd, p->rxgain, p->txgain, p->rxdrc, p->txdrc, p->law);\n\tif (res) {\n\t\tast_log(LOG_WARNING, \"Unable to restore gains: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2516}
{"project": "Asterisk", "target": 0, "func": "void manager_ec_enable(struct misdn_bchannel *bc)\n{\n\tstruct misdn_stack *stack=get_stack_by_bc(bc);\n\tcb_log(4, stack?stack->port:0,\"ec_enable\\n\");\n\tif (!misdn_cap_is_speech(bc->capability)) {\n\t\tcb_log(1, stack?stack->port:0, \" --> no speech? cannot enable EC\\n\");\n\t} else {\n#ifdef MISDN_1_2\n\tif (*bc->pipeline) {\n\t\tcb_log(3, stack?stack->port:0,\"Sending Control PIPELINE_CFG %s\\n\",bc->pipeline);\n\t\tmanager_ph_control_block(bc, PIPELINE_CFG, bc->pipeline, strlen(bc->pipeline) + 1);\n \t}\n#else\n\tint ec_arr[2];\n\tif (bc->ec_enable) {\n\t\tcb_log(3, stack?stack->port:0,\"Sending Control ECHOCAN_ON taps:%d\\n\",bc->ec_deftaps);\n\t\tswitch (bc->ec_deftaps) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\tcase 128:\n\t\tcase 256:\n\t\tcase 512:\n\t\tcase 1024:\n\t\t\tcb_log(4, stack->port, \"Taps is %d\\n\",bc->ec_deftaps);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcb_log(0, stack->port, \"Taps should be power of 2\\n\");\n\t\t\tbc->ec_deftaps=128;\n\t\t}\n\t\tec_arr[0]=bc->ec_deftaps;\n\t\tec_arr[1]=0;\n\t\tmanager_ph_control_block(bc,  ECHOCAN_ON,  ec_arr, sizeof(ec_arr));\n\t}\n#endif\n\t}\n}\n", "bug_type": null, "idx": 2517}
{"project": "Asterisk", "target": 0, "func": "off_t ast_tellstream(struct ast_filestream *fs)\n{\n\treturn fs->fmt->tell(fs);\n}\n", "bug_type": null, "idx": 2518}
{"project": "Asterisk", "target": 1, "func": "\nstatic void copy_body_types(pjsip_rx_data *rdata,\n\t\t\t    struct exten_state_subscription *exten_state_sub)\n{\n\tint i;\n\tpjsip_accept_hdr *hdr = (pjsip_accept_hdr*)\n\t\tpjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_ACCEPT, NULL);\n\texten_state_sub->body_types_count = hdr->count;\n\texten_state_sub->body_types = ast_malloc(hdr->count * sizeof(char*));\n\tfor (i = 0; i < hdr->count; ++i) {\n\t\texten_state_sub->body_types[i] =\n\t\t\tast_malloc(hdr->values[i].slen * sizeof(char*) + 1);\n\t\tast_copy_string(exten_state_sub->body_types[i],\n\t\t\t\tpj_strbuf(&hdr->values[i]), hdr->values[i].slen + 1);\n\t}\n}\n", "bug_type": "CVE-2014-2289-1", "idx": 2519}
{"project": "Asterisk", "target": 0, "func": "\t\tuint32_t nodeid, uint32_t pid, void *msg, size_t msg_len);\nstatic void cpg_confchg_cb(cpg_handle_t handle, const struct cpg_name *group_name,\n\t\tconst struct cpg_address *member_list, size_t member_list_entries,\n\t\tconst struct cpg_address *left_list, size_t left_list_entries,\n\t\tconst struct cpg_address *joined_list, size_t joined_list_entries);\nstatic cpg_callbacks_t cpg_callbacks = {\n\t.cpg_deliver_fn = cpg_deliver_cb,\n\t.cpg_confchg_fn = cpg_confchg_cb,\n};\n}\nstatic void cpg_confchg_cb(cpg_handle_t handle, const struct cpg_name *group_name,\n\t\tconst struct cpg_address *member_list, size_t member_list_entries,\n\t\tconst struct cpg_address *left_list, size_t left_list_entries,\n\t\tconst struct cpg_address *joined_list, size_t joined_list_entries)\n{\n\tunsigned int i;\n\tfor (i = 0; i < left_list_entries; i++) {\n\t\tconst struct cpg_address *cpg_node = &left_list[i];\n\t\tstruct corosync_node* node;\n\t\tnode = ao2_find(nodes, &cpg_node->nodeid, OBJ_UNLINK | OBJ_SEARCH_KEY);\n\t\tif (!node) {\n\t\t\tcontinue;\n\t\t}\n\t\tpublish_cluster_discovery_to_stasis_full(node, 0);\n\t\tao2_ref(node, -1);\n\t}\n\t\n\tif (!joined_list_entries) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < ARRAY_LEN(event_types); i++) {\n\t\tstruct ao2_container *messages;\n\t\tast_rwlock_rdlock(&event_types_lock);\n\t\tif (!event_types[i].publish) {\n\t\t\tast_rwlock_unlock(&event_types_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!event_types[i].cache_fn || !event_types[i].message_type_fn) {\n\t\t\tast_rwlock_unlock(&event_types_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tmessages = stasis_cache_dump_by_eid(event_types[i].cache_fn(),\n\t\t\tevent_types[i].message_type_fn(),\n\t\t\t&ast_eid_default);\n\t\tast_rwlock_unlock(&event_types_lock);\n\t\tao2_callback(messages, OBJ_NODATA, dump_cache_cb, NULL);\n\t\tao2_t_ref(messages, -1, \"Dispose of dumped cache\");\n\t}\n}\n", "bug_type": null, "idx": 2520}
{"project": "Asterisk", "target": 0, "func": "static int load_module(void)\n{\n\tAST_TEST_REGISTER(resolver_register_unregister);\n\tAST_TEST_REGISTER(resolver_register_off_nominal);\n\tAST_TEST_REGISTER(resolver_unregister_off_nominal);\n\tAST_TEST_REGISTER(resolver_data);\n\tAST_TEST_REGISTER(resolver_set_result);\n\tAST_TEST_REGISTER(resolver_set_result_off_nominal);\n\tAST_TEST_REGISTER(resolver_add_record);\n\tAST_TEST_REGISTER(resolver_add_record_off_nominal);\n\tAST_TEST_REGISTER(resolver_resolve_sync);\n\tAST_TEST_REGISTER(resolver_resolve_sync_off_nominal);\n\tAST_TEST_REGISTER(resolver_resolve_async);\n\tAST_TEST_REGISTER(resolver_resolve_async_off_nominal);\n\tAST_TEST_REGISTER(resolver_resolve_async_cancel);\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n", "bug_type": null, "idx": 2521}
{"project": "Asterisk", "target": 0, "func": "int ast_pbx_hangup_handler_run(struct ast_channel *chan)\n{\n\tstruct ast_hangup_handler_list *handlers;\n\tstruct ast_hangup_handler *h_handler;\n\tast_channel_lock(chan);\n\thandlers = ast_channel_hangup_handlers(chan);\n\tif (AST_LIST_EMPTY(handlers)) {\n\t\tast_channel_unlock(chan);\n\t\treturn 0;\n\t}\n\t\n\tast_softhangup_nolock(chan, AST_SOFTHANGUP_HANGUP_EXEC);\n\tfor (;;) {\n\t\thandlers = ast_channel_hangup_handlers(chan);\n\t\th_handler = AST_LIST_REMOVE_HEAD(handlers, node);\n\t\tif (!h_handler) {\n\t\t\tbreak;\n\t\t}\n\t\tpublish_hangup_handler_message(\"run\", chan, h_handler->args);\n\t\tast_channel_unlock(chan);\n\t\tast_app_exec_sub(NULL, chan, h_handler->args, 1);\n\t\tast_free(h_handler);\n\t\tast_channel_lock(chan);\n\t}\n\tast_channel_unlock(chan);\n\treturn 1;\n}\n", "bug_type": null, "idx": 2522}
{"project": "Asterisk", "target": 0, "func": "static void ast_readconfig(void)\n{\n\tstruct ast_config *cfg;\n\tstruct ast_variable *v;\n\tchar hostname[MAXHOSTNAMELEN] = \"\";\n\tstruct ast_flags config_flags = { CONFIG_FLAG_NOREALTIME };\n\tstruct {\n\t\tunsigned int dbdir:1;\n\t\tunsigned int keydir:1;\n\t} found = { 0, 0 };\n\t\n\tint live_dangerously = 0;\n\tint option_debug_new = 0;\n\tint option_verbose_new = 0;\n\t\n\toption_dtmfminduration = AST_MIN_DTMF_DURATION;\n\tast_option_rtpusedynamic = 1;\n\tast_option_rtpptdynamic = 35;\n\t\n\tast_copy_string(cfg_paths.config_dir, DEFAULT_CONFIG_DIR, sizeof(cfg_paths.config_dir));\n\tast_copy_string(cfg_paths.spool_dir, DEFAULT_SPOOL_DIR, sizeof(cfg_paths.spool_dir));\n\tast_copy_string(cfg_paths.module_dir, DEFAULT_MODULE_DIR, sizeof(cfg_paths.module_dir));\n\tast_copy_string(cfg_paths.monitor_dir, DEFAULT_MONITOR_DIR, sizeof(cfg_paths.monitor_dir));\n\tast_copy_string(cfg_paths.recording_dir, DEFAULT_RECORDING_DIR, sizeof(cfg_paths.recording_dir));\n\tast_copy_string(cfg_paths.var_dir, DEFAULT_VAR_DIR, sizeof(cfg_paths.var_dir));\n\tast_copy_string(cfg_paths.data_dir, DEFAULT_DATA_DIR, sizeof(cfg_paths.data_dir));\n\tast_copy_string(cfg_paths.log_dir, DEFAULT_LOG_DIR, sizeof(cfg_paths.log_dir));\n\tast_copy_string(cfg_paths.agi_dir, DEFAULT_AGI_DIR, sizeof(cfg_paths.agi_dir));\n\tast_copy_string(cfg_paths.db_path, DEFAULT_DB, sizeof(cfg_paths.db_path));\n\tast_copy_string(cfg_paths.sbin_dir, DEFAULT_SBIN_DIR, sizeof(cfg_paths.sbin_dir));\n\tast_copy_string(cfg_paths.key_dir, DEFAULT_KEY_DIR, sizeof(cfg_paths.key_dir));\n\tast_copy_string(cfg_paths.pid_path, DEFAULT_PID, sizeof(cfg_paths.pid_path));\n\tast_copy_string(cfg_paths.socket_path, DEFAULT_SOCKET, sizeof(cfg_paths.socket_path));\n\tast_copy_string(cfg_paths.run_dir, DEFAULT_RUN_DIR, sizeof(cfg_paths.run_dir));\n#ifdef REF_DEBUG\n\t\n\tast_set2_flag(&ast_options, 1, AST_OPT_FLAG_REF_DEBUG);\n#endif\n\tast_set_default_eid(&ast_eid_default);\n\tcfg = ast_config_load2(ast_config_AST_CONFIG_FILE, \"\" , config_flags);\n\t\n\tast_clear_flag(&ast_options, AST_OPT_FLAG_EXEC_INCLUDES);\n\t\n\tif (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tfprintf(stderr, \"Unable to open specified master config file '%s', using built-in defaults\\n\", ast_config_AST_CONFIG_FILE);\n\t\treturn;\n\t}\n\tfor (v = ast_variable_browse(cfg, \"files\"); v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"astctlpermissions\"))\n\t\t\tast_copy_string(ast_config_AST_CTL_PERMISSIONS, v->value, sizeof(ast_config_AST_CTL_PERMISSIONS));\n\t\telse if (!strcasecmp(v->name, \"astctlowner\"))\n\t\t\tast_copy_string(ast_config_AST_CTL_OWNER, v->value, sizeof(ast_config_AST_CTL_OWNER));\n\t\telse if (!strcasecmp(v->name, \"astctlgroup\"))\n\t\t\tast_copy_string(ast_config_AST_CTL_GROUP, v->value, sizeof(ast_config_AST_CTL_GROUP));\n\t\telse if (!strcasecmp(v->name, \"astctl\"))\n\t\t\tast_copy_string(ast_config_AST_CTL, v->value, sizeof(ast_config_AST_CTL));\n\t}\n\tfor (v = ast_variable_browse(cfg, \"directories\"); v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"astetcdir\")) {\n\t\t\tast_copy_string(cfg_paths.config_dir, v->value, sizeof(cfg_paths.config_dir));\n\t\t} else if (!strcasecmp(v->name, \"astspooldir\")) {\n\t\t\tast_copy_string(cfg_paths.spool_dir, v->value, sizeof(cfg_paths.spool_dir));\n\t\t\tsnprintf(cfg_paths.monitor_dir, sizeof(cfg_paths.monitor_dir), \"%s/monitor\", v->value);\n\t\t\tsnprintf(cfg_paths.recording_dir, sizeof(cfg_paths.recording_dir), \"%s/recording\", v->value);\n\t\t} else if (!strcasecmp(v->name, \"astvarlibdir\")) {\n\t\t\tast_copy_string(cfg_paths.var_dir, v->value, sizeof(cfg_paths.var_dir));\n\t\t\tif (!found.dbdir)\n\t\t\t\tsnprintf(cfg_paths.db_path, sizeof(cfg_paths.db_path), \"%s/astdb\", v->value);\n\t\t} else if (!strcasecmp(v->name, \"astdbdir\")) {\n\t\t\tsnprintf(cfg_paths.db_path, sizeof(cfg_paths.db_path), \"%s/astdb\", v->value);\n\t\t\tfound.dbdir = 1;\n\t\t} else if (!strcasecmp(v->name, \"astdatadir\")) {\n\t\t\tast_copy_string(cfg_paths.data_dir, v->value, sizeof(cfg_paths.data_dir));\n\t\t\tif (!found.keydir)\n\t\t\t\tsnprintf(cfg_paths.key_dir, sizeof(cfg_paths.key_dir), \"%s/keys\", v->value);\n\t\t} else if (!strcasecmp(v->name, \"astkeydir\")) {\n\t\t\tsnprintf(cfg_paths.key_dir, sizeof(cfg_paths.key_dir), \"%s/keys\", v->value);\n\t\t\tfound.keydir = 1;\n\t\t} else if (!strcasecmp(v->name, \"astlogdir\")) {\n\t\t\tast_copy_string(cfg_paths.log_dir, v->value, sizeof(cfg_paths.log_dir));\n\t\t} else if (!strcasecmp(v->name, \"astagidir\")) {\n\t\t\tast_copy_string(cfg_paths.agi_dir, v->value, sizeof(cfg_paths.agi_dir));\n\t\t} else if (!strcasecmp(v->name, \"astrundir\")) {\n\t\t\tsnprintf(cfg_paths.pid_path, sizeof(cfg_paths.pid_path), \"%s/%s\", v->value, \"asterisk.pid\");\n\t\t\tsnprintf(cfg_paths.socket_path, sizeof(cfg_paths.socket_path), \"%s/%s\", v->value, ast_config_AST_CTL);\n\t\t\tast_copy_string(cfg_paths.run_dir, v->value, sizeof(cfg_paths.run_dir));\n\t\t} else if (!strcasecmp(v->name, \"astmoddir\")) {\n\t\t\tast_copy_string(cfg_paths.module_dir, v->value, sizeof(cfg_paths.module_dir));\n\t\t} else if (!strcasecmp(v->name, \"astsbindir\")) {\n\t\t\tast_copy_string(cfg_paths.sbin_dir, v->value, sizeof(cfg_paths.sbin_dir));\n\t\t}\n\t}\n\tfor (v = ast_variable_browse(cfg, \"options\"); v; v = v->next) {\n\t\t\n\t\tif (!strcasecmp(v->name, \"verbose\")) {\n\t\t\toption_verbose_new = atoi(v->value);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"timestamp\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_TIMESTAMP);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"execincludes\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_EXEC_INCLUDES);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"debug\")) {\n\t\t\toption_debug_new = 0;\n\t\t\tif (sscanf(v->value, \"%30d\", &option_debug_new) != 1) {\n\t\t\t\toption_debug_new = ast_true(v->value) ? 1 : 0;\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"refdebug\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_REF_DEBUG);\n#if HAVE_WORKING_FORK\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"nofork\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_NO_FORK);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"alwaysfork\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_ALWAYS_FORK);\n#endif\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"quiet\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_QUIET);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"console\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_NO_FORK | AST_OPT_FLAG_CONSOLE);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"highpriority\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_HIGH_PRIORITY);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"initcrypto\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_INIT_KEYS);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"nocolor\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_NO_COLOR);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"dontwarn\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_DONT_WARN);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"dumpcore\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_DUMP_CORE);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"cache_record_files\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_CACHE_RECORD_FILES);\n\t\t\n\t\t}  else if (!strcasecmp(v->name, \"record_cache_dir\")) {\n\t\t\tast_copy_string(record_cache_dir, v->value, AST_CACHE_DIR_LEN);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"transcode_via_sln\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_TRANSCODE_VIA_SLIN);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"transmit_silence_during_record\") || !strcasecmp(v->name, \"transmit_silence\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_TRANSMIT_SILENCE);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"internal_timing\")) {\n\t\t\tif (!ast_opt_remote) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"NOTICE: The internal_timing option is no longer needed.\\n\"\n\t\t\t\t\t\"  It will always be enabled if you have a timing module loaded.\\n\");\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"mindtmfduration\")) {\n\t\t\tif (sscanf(v->value, \"%30u\", &option_dtmfminduration) != 1) {\n\t\t\t\toption_dtmfminduration = AST_MIN_DTMF_DURATION;\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"rtp_use_dynamic\")) {\n\t\t\tast_option_rtpusedynamic = ast_true(v->value);\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"rtp_pt_dynamic\")) {\n\t\t\tast_parse_arg(v->value, PARSE_UINT32|PARSE_IN_RANGE,\n\t\t\t              &ast_option_rtpptdynamic, 0, AST_RTP_PT_FIRST_DYNAMIC);\n\t\t} else if (!strcasecmp(v->name, \"maxcalls\")) {\n\t\t\tif ((sscanf(v->value, \"%30d\", &ast_option_maxcalls) != 1) || (ast_option_maxcalls < 0)) {\n\t\t\t\tast_option_maxcalls = 0;\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"maxload\")) {\n\t\t\tdouble test[1];\n\t\t\tif (getloadavg(test, 1) == -1) {\n\t\t\t\tast_log(LOG_ERROR, \"Cannot obtain load average on this system. 'maxload' option disabled.\\n\");\n\t\t\t\tast_option_maxload = 0.0;\n\t\t\t} else if ((sscanf(v->value, \"%30lf\", &ast_option_maxload) != 1) || (ast_option_maxload < 0.0)) {\n\t\t\t\tast_option_maxload = 0.0;\n\t\t\t}\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"maxfiles\")) {\n\t\t\tast_option_maxfiles = atoi(v->value);\n\t\t\tif (!ast_opt_remote) {\n\t\t\t\tset_ulimit(ast_option_maxfiles);\n\t\t\t}\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"runuser\")) {\n\t\t\tast_copy_string(cfg_paths.run_user, v->value, sizeof(cfg_paths.run_user));\n\t\t\n\t\t} else if (!strcasecmp(v->name, \"rungroup\")) {\n\t\t\tast_copy_string(cfg_paths.run_group, v->value, sizeof(cfg_paths.run_group));\n\t\t} else if (!strcasecmp(v->name, \"systemname\")) {\n\t\t\tast_copy_string(cfg_paths.system_name, v->value, sizeof(cfg_paths.system_name));\n\t\t} else if (!strcasecmp(v->name, \"autosystemname\")) {\n\t\t\tif (ast_true(v->value)) {\n\t\t\t\tif (!gethostname(hostname, sizeof(hostname) - 1))\n\t\t\t\t\tast_copy_string(cfg_paths.system_name, hostname, sizeof(cfg_paths.system_name));\n\t\t\t\telse {\n\t\t\t\t\tif (ast_strlen_zero(ast_config_AST_SYSTEM_NAME)){\n\t\t\t\t\t\tast_copy_string(cfg_paths.system_name, \"localhost\", sizeof(cfg_paths.system_name));\n\t\t\t\t\t}\n\t\t\t\t\tast_log(LOG_ERROR, \"Cannot obtain hostname for this system.  Using '%s' instead.\\n\", ast_config_AST_SYSTEM_NAME);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"languageprefix\")) {\n\t\t\tast_language_is_prefix = ast_true(v->value);\n\t\t} else if (!strcasecmp(v->name, \"defaultlanguage\")) {\n\t\t\tast_copy_string(ast_defaultlanguage, v->value, MAX_LANGUAGE);\n\t\t} else if (!strcasecmp(v->name, \"lockmode\")) {\n\t\t\tif (!strcasecmp(v->value, \"lockfile\")) {\n\t\t\t\tast_set_lock_type(AST_LOCK_TYPE_LOCKFILE);\n\t\t\t} else if (!strcasecmp(v->value, \"flock\")) {\n\t\t\t\tast_set_lock_type(AST_LOCK_TYPE_FLOCK);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"'%s' is not a valid setting for the lockmode option, \"\n\t\t\t\t\t\"defaulting to 'lockfile'\\n\", v->value);\n\t\t\t\tast_set_lock_type(AST_LOCK_TYPE_LOCKFILE);\n\t\t\t}\n#if defined(HAVE_SYSINFO)\n\t\t} else if (!strcasecmp(v->name, \"minmemfree\")) {\n\t\t\t\n\t\t\tif ((sscanf(v->value, \"%30ld\", &option_minmemfree) != 1) || (option_minmemfree < 0)) {\n\t\t\t\toption_minmemfree = 0;\n\t\t\t}\n#endif\n\t\t} else if (!strcasecmp(v->name, \"entityid\")) {\n\t\t\tstruct ast_eid tmp_eid;\n\t\t\tif (!ast_str_to_eid(&tmp_eid, v->value)) {\n\t\t\t\tast_eid_default = tmp_eid;\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid Entity ID '%s' provided\\n\", v->value);\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"lightbackground\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_LIGHT_BACKGROUND);\n\t\t} else if (!strcasecmp(v->name, \"forceblackbackground\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_FORCE_BLACK_BACKGROUND);\n\t\t} else if (!strcasecmp(v->name, \"hideconnect\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_HIDE_CONSOLE_CONNECT);\n\t\t} else if (!strcasecmp(v->name, \"lockconfdir\")) {\n\t\t\tast_set2_flag(&ast_options, ast_true(v->value),\tAST_OPT_FLAG_LOCK_CONFIG_DIR);\n\t\t} else if (!strcasecmp(v->name, \"stdexten\")) {\n\t\t\t\n\t\t\tif (!strcasecmp(v->value, \"gosub\")) {\n\t\t\t\tast_clear_flag(&ast_options, AST_OPT_FLAG_STDEXTEN_MACRO);\n\t\t\t} else if (!strcasecmp(v->value, \"macro\")) {\n\t\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_STDEXTEN_MACRO);\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\"'%s' is not a valid setting for the stdexten option, defaulting to 'gosub'\\n\",\n\t\t\t\t\tv->value);\n\t\t\t\tast_clear_flag(&ast_options, AST_OPT_FLAG_STDEXTEN_MACRO);\n\t\t\t}\n\t\t} else if (!strcasecmp(v->name, \"live_dangerously\")) {\n\t\t\tlive_dangerously = ast_true(v->value);\n\t\t}\n\t}\n\tif (!ast_opt_remote) {\n\t\tpbx_live_dangerously(live_dangerously);\n\t}\n\toption_debug += option_debug_new;\n\toption_verbose += option_verbose_new;\n\tast_config_destroy(cfg);\n}\nstatic void read_pjproject_startup_options(void)\n{\n\tstruct ast_config *cfg;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_NOCACHE | CONFIG_FLAG_NOREALTIME };\n\tast_option_pjproject_log_level = DEFAULT_PJ_LOG_MAX_LEVEL;\n\tcfg = ast_config_load2(\"pjproject.conf\", \"\" , config_flags);\n\tif (!cfg\n\t\t|| cfg == CONFIG_STATUS_FILEUNCHANGED\n\t\t|| cfg == CONFIG_STATUS_FILEINVALID) {\n\t\t\n\t\treturn;\n\t}\n\tfor (v = ast_variable_browse(cfg, \"startup\"); v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"log_level\")) {\n\t\t\tif (sscanf(v->value, \"%30d\", &ast_option_pjproject_log_level) != 1) {\n\t\t\t\tast_option_pjproject_log_level = DEFAULT_PJ_LOG_MAX_LEVEL;\n\t\t\t} else if (ast_option_pjproject_log_level < 0) {\n\t\t\t\tast_option_pjproject_log_level = 0;\n\t\t\t} else if (MAX_PJ_LOG_MAX_LEVEL < ast_option_pjproject_log_level) {\n\t\t\t\tast_option_pjproject_log_level = MAX_PJ_LOG_MAX_LEVEL;\n\t\t\t}\n\t\t}\n\t}\n\tast_config_destroy(cfg);\n}\nstatic void *monitor_sig_flags(void *unused)\n{\n\tfor (;;) {\n\t\tstruct pollfd p = { sig_alert_pipe[0], POLLIN, 0 };\n\t\tint a;\n\t\tast_poll(&p, 1, -1);\n\t\tif (sig_flags.need_reload) {\n\t\t\tsig_flags.need_reload = 0;\n\t\t\tast_module_reload(NULL);\n\t\t}\n\t\tif (sig_flags.need_quit) {\n\t\t\tsig_flags.need_quit = 0;\n\t\t\tif ((consolethread != AST_PTHREADT_NULL) && (consolethread != pthread_self())) {\n\t\t\t\tsig_flags.need_quit_handler = 1;\n\t\t\t\tpthread_kill(consolethread, SIGURG);\n\t\t\t} else {\n\t\t\t\tquit_handler(0, SHUTDOWN_NORMAL, 0);\n\t\t\t}\n\t\t}\n\t\tif (read(sig_alert_pipe[0], &a, sizeof(a)) != sizeof(a)) {\n\t\t}\n\t}\n\treturn NULL;\n}\nstatic void *canary_thread(void *unused)\n{\n\tstruct stat canary_stat;\n\tstruct timeval now;\n\t\n\tsleep(120);\n\tfor (;;) {\n\t\tnow = ast_tvnow();\n\t\tif (stat(canary_filename, &canary_stat) || now.tv_sec > canary_stat.st_mtime + 60) {\n\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\"The canary is no more.  He has ceased to be!  \"\n\t\t\t\t\"He's expired and gone to meet his maker!  \"\n\t\t\t\t\"He's a stiff!  Bereft of life, he rests in peace.  \"\n\t\t\t\t\"His metabolic processes are now history!  He's off the twig!  \"\n\t\t\t\t\"He's kicked the bucket.  He's shuffled off his mortal coil, \"\n\t\t\t\t\"run down the curtain, and joined the bleeding choir invisible!!  \"\n\t\t\t\t\"THIS is an EX-CANARY.  (Reducing priority)\\n\");\n\t\t\tset_priority_all(0);\n\t\t\tpthread_exit(NULL);\n\t\t}\n\t\t\n\t\tsleep(60);\n\t}\n}\n\nstatic void canary_exit(void)\n{\n\tif (canary_pid > 0) {\n\t\tint status;\n\t\tkill(canary_pid, SIGKILL);\n\t\twaitpid(canary_pid, &status, 0);\n\t}\n}\n\nstatic void run_startup_commands(void)\n{\n\tint fd;\n\tstruct ast_config *cfg;\n\tstruct ast_flags cfg_flags = { 0 };\n\tstruct ast_variable *v;\n\tif (!(cfg = ast_config_load2(\"cli.conf\", \"\" , cfg_flags)))\n\t\treturn;\n\tif (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\treturn;\n\t}\n\tfd = open(\"/dev/null\", O_RDWR);\n\tif (fd < 0) {\n\t\tast_config_destroy(cfg);\n\t\treturn;\n\t}\n\tfor (v = ast_variable_browse(cfg, \"startup_commands\"); v; v = v->next) {\n\t\tif (ast_true(v->value))\n\t\t\tast_cli_command(fd, v->name);\n\t}\n\tclose(fd);\n\tast_config_destroy(cfg);\n}\nstatic void env_init(void)\n{\n\tsetenv(\"AST_SYSTEMNAME\", ast_config_AST_SYSTEM_NAME, 1);\n\tsetenv(\"AST_BUILD_HOST\", ast_build_hostname, 1);\n\tsetenv(\"AST_BUILD_DATE\", ast_build_date, 1);\n\tsetenv(\"AST_BUILD_KERNEL\", ast_build_kernel, 1);\n\tsetenv(\"AST_BUILD_MACHINE\", ast_build_machine, 1);\n\tsetenv(\"AST_BUILD_OS\", ast_build_os, 1);\n\tsetenv(\"AST_BUILD_USER\", ast_build_user, 1);\n\tsetenv(\"AST_VERSION\", ast_get_version(), 1);\n}\nstatic void print_intro_message(const char *runuser, const char *rungroup)\n{\n \tif (ast_opt_console || option_verbose || (ast_opt_remote && !ast_opt_exec)) {\n\t\tWELCOME_MESSAGE;\n\t\tif (runuser) {\n\t\t\tast_verbose(\"Running as user '%s'\\n\", runuser);\n\t\t}\n\t\tif (rungroup) {\n\t\t\tast_verbose(\"Running under group '%s'\\n\", rungroup);\n\t\t}\n\t}\n}\nstatic void main_atexit(void)\n{\n\tast_cli_unregister_multiple(cli_asterisk, ARRAY_LEN(cli_asterisk));\n}\nint main(int argc, char *argv[])\n{\n\tint c;\n\tchar * xarg = NULL;\n\tint x;\n\tint isroot = 1, rundir_exists = 0;\n\tconst char *runuser = NULL, *rungroup = NULL;\n\tstruct rlimit l;\n\tstatic const char *getopt_settings = \"BC:cde:FfG:ghIiL:M:mnpqRrs:TtU:VvWXx:\";\n\t\n\tif (argc > ARRAY_LEN(_argv) - 1) {\n\t\tfprintf(stderr, \"Truncating argument size to %d\\n\", (int)ARRAY_LEN(_argv) - 1);\n\t\targc = ARRAY_LEN(_argv) - 1;\n\t}\n\tfor (x = 0; x < argc; x++)\n\t\t_argv[x] = argv[x];\n\t_argv[x] = NULL;\n\tif (geteuid() != 0)\n\t\tisroot = 0;\n\t\n\tif (argv[0] && (strstr(argv[0], \"rasterisk\")) != NULL) {\n\t\tast_set_flag(&ast_options, AST_OPT_FLAG_NO_FORK | AST_OPT_FLAG_REMOTE);\n\t}\n\tast_mainpid = getpid();\n\t\n\tast_copy_string(cfg_paths.config_file, DEFAULT_CONFIG_FILE, sizeof(cfg_paths.config_file));\n\t\n\twhile ((c = getopt(argc, argv, getopt_settings)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'X':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_EXEC_INCLUDES);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tast_copy_string(cfg_paths.config_file, optarg, sizeof(cfg_paths.config_file));\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\toption_debug++;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tshow_cli_help();\n\t\t\texit(0);\n\t\tcase 'R':\n\t\tcase 'r':\n\t\tcase 'x':\n\t\t\t\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_REMOTE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tshow_version();\n\t\t\texit(0);\n\t\tcase 'v':\n\t\t\toption_verbose++;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\t\n\tenv_init();\n\tast_readconfig();\n\t\n\tenv_init();\n\t\n\toptind = 0;\n\twhile ((c = getopt(argc, argv, getopt_settings)) != -1) {\n\t\t\n\t\tswitch (c) {\n\t\tcase 'B': \n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_FORCE_BLACK_BACKGROUND);\n\t\t\tast_clear_flag(&ast_options, AST_OPT_FLAG_LIGHT_BACKGROUND);\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\t\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_NO_FORK | AST_OPT_FLAG_CONSOLE);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t\n\t\t\tbreak;\n#if defined(HAVE_SYSINFO)\n\t\tcase 'e':\n\t\t\tif ((sscanf(&optarg[1], \"%30ld\", &option_minmemfree) != 1) || (option_minmemfree < 0)) {\n\t\t\t\toption_minmemfree = 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#if HAVE_WORKING_FORK\n\t\tcase 'F':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_ALWAYS_FORK);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_NO_FORK);\n\t\t\tbreak;\n#endif\n\t\tcase 'G':\n\t\t\trungroup = ast_strdupa(optarg);\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_DUMP_CORE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tfprintf(stderr,\n\t\t\t\t\"NOTICE: The -I option is no longer needed.\\n\"\n\t\t\t\t\"  It will always be enabled if you have a timing module loaded.\\n\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_INIT_KEYS);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif ((sscanf(optarg, \"%30lf\", &ast_option_maxload) != 1) || (ast_option_maxload < 0.0)) {\n\t\t\t\tast_option_maxload = 0.0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tif ((sscanf(optarg, \"%30d\", &ast_option_maxcalls) != 1) || (ast_option_maxcalls < 0)) {\n\t\t\t\tast_option_maxcalls = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_MUTE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_NO_COLOR);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_HIGH_PRIORITY);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_QUIET);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_NO_FORK | AST_OPT_FLAG_REMOTE | AST_OPT_FLAG_RECONNECT);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_NO_FORK | AST_OPT_FLAG_REMOTE);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (ast_opt_remote) {\n\t\t\t\tast_copy_string((char *) cfg_paths.socket_path, optarg, sizeof(cfg_paths.socket_path));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_TIMESTAMP);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_CACHE_RECORD_FILES);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\trunuser = ast_strdupa(optarg);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\tcase 'v':\n\t\t\t\n\t\t\tbreak;\n\t\tcase 'W': \n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_LIGHT_BACKGROUND);\n\t\t\tast_clear_flag(&ast_options, AST_OPT_FLAG_FORCE_BLACK_BACKGROUND);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\t\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_NO_FORK | AST_OPT_FLAG_REMOTE);\n\t\t\tast_set_flag(&ast_options, AST_OPT_FLAG_EXEC | AST_OPT_FLAG_NO_COLOR);\n\t\t\txarg = ast_strdupa(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (ast_opt_remote) {\n\t\tstrcpy(argv[0], \"rasterisk\");\n\t\tfor (x = 1; x < argc; x++) {\n\t\t\targv[x] = argv[0] + 10;\n\t\t}\n\t}\n\tif (!ast_language_is_prefix && !ast_opt_remote) {\n\t\tfprintf(stderr, \"The 'languageprefix' option in asterisk.conf is deprecated; in a future release it will be removed, and your sound files will need to be organized in the 'new style' language layout.\\n\");\n\t}\n\tif (ast_opt_always_fork && (ast_opt_remote || ast_opt_console)) {\n\t\tfprintf(stderr, \"'alwaysfork' is not compatible with console or remote console mode; ignored\\n\");\n\t\tast_clear_flag(&ast_options, AST_OPT_FLAG_ALWAYS_FORK);\n\t}\n\tif (ast_opt_dump_core) {\n\t\tmemset(&l, 0, sizeof(l));\n\t\tl.rlim_cur = RLIM_INFINITY;\n\t\tl.rlim_max = RLIM_INFINITY;\n\t\tif (setrlimit(RLIMIT_CORE, &l)) {\n\t\t\tfprintf(stderr, \"Unable to disable core size resource limit: %s\\n\", strerror(errno));\n\t\t}\n\t}\n\tif (getrlimit(RLIMIT_NOFILE, &l)) {\n\t\tfprintf(stderr, \"Unable to check file descriptor limit: %s\\n\", strerror(errno));\n\t}\n#if !defined(CONFIGURE_RAN_AS_ROOT)\n\t\n\tdo {\n\t\tint fd, fd2;\n\t\tast_fdset readers;\n\t\tstruct timeval tv = { 0, };\n\t\tif (l.rlim_cur <= FD_SETSIZE) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tif (!(fd = open(\"/dev/null\", O_RDONLY))) {\n\t\t\tfprintf(stderr, \"Cannot open a file descriptor at boot? %s\\n\", strerror(errno));\n\t\t\tbreak; \n\t\t}\n\t\tfd2 = ((l.rlim_cur > sizeof(readers) * 8) ? sizeof(readers) * 8 : l.rlim_cur) - 1;\n\t\tif (dup2(fd, fd2) < 0) {\n\t\t\tfprintf(stderr, \"Cannot open maximum file descriptor %d at boot? %s\\n\", fd2, strerror(errno));\n\t\t\tclose(fd);\n\t\t\tbreak;\n\t\t}\n\t\tFD_ZERO(&readers);\n\t\tFD_SET(fd2, &readers);\n\t\tif (ast_select(fd2 + 1, &readers, NULL, NULL, &tv) < 0) {\n\t\t\tfprintf(stderr, \"Maximum select()able file descriptor is %d\\n\", FD_SETSIZE);\n\t\t}\n\t\tast_FD_SETSIZE = l.rlim_cur > ast_FDMAX ? ast_FDMAX : l.rlim_cur;\n\t\tclose(fd);\n\t\tclose(fd2);\n\t} while (0);\n#elif defined(HAVE_VARIABLE_FDSET)\n\tast_FD_SETSIZE = l.rlim_cur > ast_FDMAX ? ast_FDMAX : l.rlim_cur;\n#endif \n\tif ((!rungroup) && !ast_strlen_zero(ast_config_AST_RUN_GROUP))\n\t\trungroup = ast_config_AST_RUN_GROUP;\n\tif ((!runuser) && !ast_strlen_zero(ast_config_AST_RUN_USER))\n\t\trunuser = ast_config_AST_RUN_USER;\n\t\n\tsigaction(SIGCHLD, &child_handler, NULL);\n\t\n\tif (mkdir(ast_config_AST_RUN_DIR, 0755)) {\n\t\tif (errno == EEXIST) {\n\t\t\trundir_exists = 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unable to create socket file directory.  Remote consoles will not be able to connect! (%s)\\n\", strerror(x));\n\t\t}\n\t}\n#ifndef __CYGWIN__\n\tif (isroot) {\n\t\tast_set_priority(ast_opt_high_priority);\n\t}\n\tif (isroot && rungroup) {\n\t\tstruct group *gr;\n\t\tgr = getgrnam(rungroup);\n\t\tif (!gr) {\n\t\t\tfprintf(stderr, \"No such group '%s'!\\n\", rungroup);\n\t\t\texit(1);\n\t\t}\n\t\tif (!rundir_exists && chown(ast_config_AST_RUN_DIR, -1, gr->gr_gid)) {\n\t\t\tfprintf(stderr, \"Unable to chgrp run directory to %d (%s)\\n\", (int) gr->gr_gid, rungroup);\n\t\t}\n\t\tif (setgid(gr->gr_gid)) {\n\t\t\tfprintf(stderr, \"Unable to setgid to %d (%s)\\n\", (int)gr->gr_gid, rungroup);\n\t\t\texit(1);\n\t\t}\n\t\tif (setgroups(0, NULL)) {\n\t\t\tfprintf(stderr, \"Unable to drop unneeded groups\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (runuser && !ast_test_flag(&ast_options, AST_OPT_FLAG_REMOTE)) {\n#ifdef HAVE_CAP\n\t\tint has_cap = 1;\n#endif \n\t\tstruct passwd *pw;\n\t\tpw = getpwnam(runuser);\n\t\tif (!pw) {\n\t\t\tfprintf(stderr, \"No such user '%s'!\\n\", runuser);\n\t\t\texit(1);\n\t\t}\n\t\tif (chown(ast_config_AST_RUN_DIR, pw->pw_uid, -1)) {\n\t\t\tfprintf(stderr, \"Unable to chown run directory to %d (%s)\\n\", (int) pw->pw_uid, runuser);\n\t\t}\n#ifdef HAVE_CAP\n\t\tif (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0)) {\n\t\t\tast_log(LOG_WARNING, \"Unable to keep capabilities.\\n\");\n\t\t\thas_cap = 0;\n\t\t}\n#endif \n\t\tif (!isroot && pw->pw_uid != geteuid()) {\n\t\t\tfprintf(stderr, \"Asterisk started as nonroot, but runuser '%s' requested.\\n\", runuser);\n\t\t\texit(1);\n\t\t}\n\t\tif (!rungroup) {\n\t\t\tif (setgid(pw->pw_gid)) {\n\t\t\t\tfprintf(stderr, \"Unable to setgid to %d!\\n\", (int)pw->pw_gid);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (isroot && initgroups(pw->pw_name, pw->pw_gid)) {\n\t\t\t\tfprintf(stderr, \"Unable to init groups for '%s'\\n\", runuser);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (setuid(pw->pw_uid)) {\n\t\t\tfprintf(stderr, \"Unable to setuid to %d (%s)\\n\", (int)pw->pw_uid, runuser);\n\t\t\texit(1);\n\t\t}\n#ifdef HAVE_CAP\n\t\tif (has_cap) {\n\t\t\tcap_t cap;\n\t\t\tcap = cap_from_text(\"cap_net_admin=eip\");\n\t\t\tif (cap_set_proc(cap)) {\n\t\t\t\tfprintf(stderr, \"Unable to install capabilities.\\n\");\n\t\t\t}\n\t\t\tif (cap_free(cap)) {\n\t\t\t\tfprintf(stderr, \"Unable to drop capabilities.\\n\");\n\t\t\t}\n\t\t}\n#endif \n\t}\n#endif \n#ifdef linux\n\tif (geteuid() && ast_opt_dump_core) {\n\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0) {\n\t\t\tfprintf(stderr, \"Unable to set the process for core dumps after changing to a non-root user. %s\\n\", strerror(errno));\n\t\t}\n\t}\n#endif\n\t{\n#if defined(HAVE_EACCESS) || defined(HAVE_EUIDACCESS)\n#if defined(HAVE_EUIDACCESS) && !defined(HAVE_EACCESS)\n#define eaccess euidaccess\n#endif\n\t\tchar dir[PATH_MAX];\n\t\tif (!getcwd(dir, sizeof(dir)) || eaccess(dir, R_OK | X_OK | F_OK)) {\n\t\t\tfprintf(stderr, \"Unable to access the running directory (%s).  Changing to '/' for compatibility.\\n\", strerror(errno));\n\t\t\t\n\t\t\tif (chdir(\"/\")) {\n\t\t\t\t\n\t\t\t\tfprintf(stderr, \"chdir(\\\"/\\\") failed?!! %s\\n\", strerror(errno));\n\t\t\t}\n\t\t} else\n#endif \n\t\tif (!ast_opt_no_fork && !ast_opt_dump_core) {\n\t\t\t\n\t\t\tif (chdir(\"/\")) {\n\t\t\t\tfprintf(stderr, \"Unable to chdir(\\\"/\\\") ?!! %s\\n\", strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tast_verb_sys_level = option_verbose;\n\tif (ast_sd_get_fd_un(SOCK_STREAM, ast_config_AST_SOCKET) > 0) {\n\t\tast_socket_is_sd = 1;\n\t}\n\t\n\tif (!ast_socket_is_sd && ast_tryconnect()) {\n\t\t\n\t\tif (ast_opt_remote) {\n\t\t\tmulti_thread_safe = 1;\n\t\t\tif (ast_opt_exec) {\n\t\t\t\tast_remotecontrol(xarg);\n\t\t\t\tquit_handler(0, SHUTDOWN_FAST, 0);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tast_term_init();\n\t\t\tprintf(\"%s\", term_end());\n\t\t\tfflush(stdout);\n\t\t\tprint_intro_message(runuser, rungroup);\n\t\t\tprintf(\"%s\", term_quit());\n\t\t\tast_remotecontrol(NULL);\n\t\t\tquit_handler(0, SHUTDOWN_FAST, 0);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Asterisk already running on %s.  Use 'asterisk -r' to connect.\\n\", ast_config_AST_SOCKET);\n\t\t\tprintf(\"%s\", term_quit());\n\t\t\texit(1);\n\t\t}\n\t} else if (ast_opt_remote || ast_opt_exec) {\n\t\tfprintf(stderr, \"Unable to connect to remote asterisk (does %s exist?)\\n\", ast_config_AST_SOCKET);\n\t\tprintf(\"%s\", term_quit());\n\t\texit(1);\n\t}\n\t\n\tasterisk_daemon(isroot, runuser, rungroup);\n\treturn 0;\n}\nstatic inline void check_init(int init_result, const char *name)\n{\n\tif (init_result) {\n\t\tif (ast_is_logger_initialized()) {\n\t\t\tast_log(LOG_ERROR, \"%s initialization failed.  ASTERISK EXITING!\\n%s\", name, term_quit());\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s initialization failed.  ASTERISK EXITING!\\n%s\", name, term_quit());\n\t\t}\n\t\tast_run_atexits(0);\n\t\texit(init_result == -2 ? 2 : 1);\n\t}\n}\nstatic void asterisk_daemon(int isroot, const char *runuser, const char *rungroup)\n{\n\tFILE *f;\n\tsigset_t sigs;\n\tint num;\n\tchar *buf;\n\tchar pbx_uuid[AST_UUID_STR_LEN];\n\t\n\tast_lastreloadtime = ast_startuptime = ast_tvnow();\n\t\n#if HAVE_WORKING_FORK\n\tif (ast_opt_always_fork || !ast_opt_no_fork) {\n#ifndef HAVE_SBIN_LAUNCHD\n\t\tif (daemon(1, 0) < 0) {\n\t\t\tfprintf(stderr, \"daemon() failed: %s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tast_mainpid = getpid();\n\t\t}\n#else\n\t\tfprintf(stderr, \"Mac OS X detected.  Use 'launchctl load /Library/LaunchDaemon/org.asterisk.asterisk.plist'.\\n\");\n#endif\n\t}\n#endif\n\t\n\tmulti_thread_safe = 1;\n#if defined(__AST_DEBUG_MALLOC)\n\t__ast_mm_init_phase_1();\n#endif\t\n\t\n\tif (has_priority()) {\n\t\tast_set_flag(&ast_options, AST_OPT_FLAG_HIGH_PRIORITY);\n\t} else {\n\t\tast_clear_flag(&ast_options, AST_OPT_FLAG_HIGH_PRIORITY);\n\t}\n\t\n\tif (ast_opt_high_priority) {\n\t\tsnprintf(canary_filename, sizeof(canary_filename), \"%s/alt.asterisk.canary.tweet.tweet.tweet\", ast_config_AST_RUN_DIR);\n\t\t\n\t\tsigaction(SIGPIPE, &ignore_sig_handler, NULL);\n\t\tcanary_pid = fork();\n\t\tif (canary_pid == 0) {\n\t\t\tchar canary_binary[PATH_MAX], ppid[12];\n\t\t\t\n\t\t\tsignal(SIGCHLD, SIG_DFL);\n\t\t\tsignal(SIGPIPE, SIG_DFL);\n\t\t\tast_close_fds_above_n(0);\n\t\t\tast_set_priority(0);\n\t\t\tsnprintf(ppid, sizeof(ppid), \"%d\", (int) ast_mainpid);\n\t\t\t\n\t\t\tsnprintf(canary_binary, sizeof(canary_binary), \"%s/astcanary\", ast_config_AST_SBIN_DIR);\n\t\t\texecl(canary_binary, \"astcanary\", canary_filename, ppid, (char *)NULL);\n\t\t\t\n\t\t\t_exit(1);\n\t\t} else if (canary_pid > 0) {\n\t\t\tpthread_t dont_care;\n\t\t\tast_pthread_create_detached(&dont_care, NULL, canary_thread, NULL);\n\t\t}\n\t\t\n\t\tast_register_atexit(canary_exit);\n\t}\n\t\n\tunlink(ast_config_AST_PID);\n\tf = fopen(ast_config_AST_PID, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%ld\\n\", (long)ast_mainpid);\n\t\tfclose(f);\n\t} else {\n\t\tfprintf(stderr, \"Unable to open pid file '%s': %s\\n\", ast_config_AST_PID, strerror(errno));\n\t}\n\t\n\tast_term_init();\n\tprintf(\"%s\", term_end());\n\tfflush(stdout);\n\tprint_intro_message(runuser, rungroup);\n\tif (ast_opt_console) {\n\t\tast_verb(0, \"[ Initializing Custom Configuration Options ]\\n\");\n\t}\n\t\n\tregister_config_cli();\n\tread_config_maps();\n\tcheck_init(astobj2_init(), \"AO2\");\n\tcheck_init(ast_named_locks_init(), \"Named Locks\");\n\tif (ast_opt_console) {\n\t\tif (el_hist == NULL || el == NULL)\n\t\t\tast_el_initialize();\n\t\tast_el_read_default_histfile();\n\t}\n#ifdef AST_XML_DOCS\n\t\n\tast_xmldoc_load_documentation();\n#endif\n\tcheck_init(astdb_init(), \"ASTdb\");\n\tast_uuid_init();\n\tif (ast_pbx_uuid_get(pbx_uuid, sizeof(pbx_uuid))) {\n\t\tast_uuid_generate_str(pbx_uuid, sizeof(pbx_uuid));\n\t\tast_db_put(\"pbx\", \"UUID\", pbx_uuid);\n\t}\n\tast_verb(0, \"PBX UUID: %s\\n\", pbx_uuid);\n\tast_json_init();\n\tast_ulaw_init();\n\tast_alaw_init();\n\ttdd_init();\n\tcallerid_init();\n\tast_builtins_init();\n\tcheck_init(ast_utils_init(), \"Utilities\");\n\tcheck_init(ast_tps_init(), \"Task Processor Core\");\n\tcheck_init(ast_fd_init(), \"File Descriptor Debugging\");\n\tcheck_init(ast_pbx_init(), \"ast_pbx_init\");\n#ifdef TEST_FRAMEWORK\n\tcheck_init(ast_test_init(), \"Test Framework\");\n#endif\n\tcheck_init(ast_translate_init(), \"Translator Core\");\n\tast_aoc_cli_init();\n\tcheck_init(ast_sorcery_init(), \"Sorcery\");\n\tcheck_init(ast_codec_init(), \"Codecs\");\n\tcheck_init(ast_format_init(), \"Formats\");\n\tcheck_init(ast_format_cache_init(), \"Format Cache\");\n\tcheck_init(ast_codec_builtin_init(), \"Built-in Codecs\");\n\tcheck_init(aco_init(), \"Configuration Option Framework\");\n\tcheck_init(ast_bucket_init(), \"Bucket API\");\n\tcheck_init(stasis_init(), \"Stasis\");\n\tcheck_init(ast_stasis_system_init(), \"Stasis system-level information\");\n\tcheck_init(ast_endpoint_stasis_init(), \"Stasis Endpoint\");\n\tast_makesocket();\n\t\n\t(void) sigemptyset(&sigs);\n\t(void) sigaddset(&sigs, SIGHUP);\n\t(void) sigaddset(&sigs, SIGTERM);\n\t(void) sigaddset(&sigs, SIGINT);\n\t(void) sigaddset(&sigs, SIGPIPE);\n\t(void) sigaddset(&sigs, SIGWINCH);\n\tpthread_sigmask(SIG_BLOCK, &sigs, NULL);\n\tsigaction(SIGURG, &urg_handler, NULL);\n\tsignal(SIGINT, __quit_handler);\n\tsignal(SIGTERM, __quit_handler);\n\tsigaction(SIGHUP, &hup_handler, NULL);\n\tsigaction(SIGPIPE, &ignore_sig_handler, NULL);\n\t\n\tsrand((unsigned int) getpid() + (unsigned int) time(NULL));\n\tinitstate((unsigned int) getpid() * 65536 + (unsigned int) time(NULL), randompool, sizeof(randompool));\n\tthreadstorage_init();\n\tcheck_init(init_logger(), \"Logger\");\n\tcheck_init(ast_rtp_engine_init(), \"RTP Engine\");\n\tast_autoservice_init();\n\tcheck_init(ast_timing_init(), \"Timing\");\n\tcheck_init(ast_ssl_init(), \"SSL\");\n\tread_pjproject_startup_options();\n\tcheck_init(ast_pj_init(), \"Embedded PJProject\");\n\tcheck_init(app_init(), \"App Core\");\n\tcheck_init(devstate_init(), \"Device State Core\");\n\tcheck_init(ast_msg_init(), \"Messaging API\");\n\tcheck_init(ast_channels_init(), \"Channel\");\n\tcheck_init(ast_endpoint_init(), \"Endpoints\");\n\tcheck_init(ast_pickup_init(), \"Call Pickup\");\n\tcheck_init(ast_bridging_init(), \"Bridging\");\n\tcheck_init(ast_parking_stasis_init(), \"Parking Core\");\n\tcheck_init(ast_device_state_engine_init(), \"Device State Engine\");\n\tcheck_init(ast_presence_state_engine_init(), \"Presence State Engine\");\n\tcheck_init(ast_dns_system_resolver_init(), \"Default DNS resolver\");\n\tcheck_init(load_modules(1), \"Module Preload\");\n\tcheck_init(ast_features_init(), \"Call Features\");\n\tcheck_init(dnsmgr_init(), \"DNS manager\");\n\tcheck_init(ast_security_stasis_init(), \"Security Stasis Topic and Events\");\n\tcheck_init(ast_named_acl_init(), \"Named ACL system\");\n\tast_http_init();\t\t\n\tcheck_init(ast_indications_init(), \"Indication Tone Handling\");\n\tcheck_init(ast_cdr_engine_init(), \"CDR Engine\");\n\tast_dsp_init();\n\tast_udptl_init();\n\tcheck_init(ast_image_init(), \"Image\");\n\tcheck_init(ast_file_init(), \"Generic File Format Support\");\n\tcheck_init(load_pbx(), \"load_pbx\");\n\tcheck_init(load_pbx_builtins(), \"Builtin PBX Applications\");\n\tcheck_init(load_pbx_functions_cli(), \"PBX Functions Support\");\n\tcheck_init(load_pbx_variables(), \"PBX Variables Support\");\n\tcheck_init(load_pbx_switch(), \"PBX Switch Support\");\n\tcheck_init(load_pbx_app(), \"PBX Application Support\");\n\tcheck_init(load_pbx_hangup_handler(), \"PBX Hangup Handler Support\");\n\tcheck_init(ast_local_init(), \"Local Proxy Channel Driver\");\n\tcheck_init(ast_cel_engine_init(), \"CEL Engine\");\n\tcheck_init(init_manager(), \"Asterisk Manager Interface\");\n\tcheck_init(ast_enum_init(), \"ENUM Support\");\n\tcheck_init(ast_cc_init(), \"Call Completion Supplementary Services\");\n\tcheck_init(ast_sounds_index_init(), \"Sounds Indexer\");\n\tcheck_init(load_modules(0), \"Module\");\n\t\n\tcheck_init(ast_media_cache_init(), \"Media Cache\");\n\t\n\tast_cli_perms_init(0);\n\tast_stun_init();\n\tdnsmgr_start_refresh();\n\tif (ast_opt_no_fork) {\n\t\tconsolethread = pthread_self();\n\t}\n\tif (pipe(sig_alert_pipe)) {\n\t\tsig_alert_pipe[0] = sig_alert_pipe[1] = -1;\n\t}\n\tast_process_pending_reloads();\n\tast_set_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED);\n\tpublish_fully_booted();\n\tpthread_sigmask(SIG_UNBLOCK, &sigs, NULL);\n#if defined(__AST_DEBUG_MALLOC)\n\t__ast_mm_init_phase_2();\n#endif\t\n\tast_cli_register_multiple(cli_asterisk_shutdown, ARRAY_LEN(cli_asterisk_shutdown));\n\tast_cli_register_multiple(cli_asterisk, ARRAY_LEN(cli_asterisk));\n\tast_register_cleanup(main_atexit);\n\trun_startup_commands();\n\tast_sd_notify(\"READY=1\");\n\tast_verb(0, COLORIZE_FMT \"\\n\", COLORIZE(COLOR_BRGREEN, 0, \"Asterisk Ready.\"));\n\tlogger_queue_start();\n\tif (ast_opt_console) {\n\t\t\n\t\t\n\t\tchar title[256];\n\t\tchar hostname[MAXHOSTNAMELEN] = \"\";\n\t\tif (gethostname(hostname, sizeof(hostname) - 1)) {\n\t\t\tast_copy_string(hostname, \"<Unknown>\", sizeof(hostname));\n\t\t}\n\t\tast_pthread_create_detached(&mon_sig_flags, NULL, monitor_sig_flags, NULL);\n\t\tset_icon(\"Asterisk\");\n\t\tsnprintf(title, sizeof(title), \"Asterisk Console on '%s' (pid %ld)\", hostname, (long)ast_mainpid);\n\t\tset_title(title);\n\t\tel_set(el, EL_GETCFN, ast_el_read_char);\n\t\tfor (;;) {\n\t\t\tif (sig_flags.need_quit || sig_flags.need_quit_handler) {\n\t\t\t\tquit_handler(0, SHUTDOWN_FAST, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = (char *) el_gets(el, &num);\n\t\t\tif (!buf && write(1, \"\", 1) < 0)\n\t\t\t\treturn; \n\t\t\tif (buf) {\n\t\t\t\tif (buf[strlen(buf)-1] == '\\n')\n\t\t\t\t\tbuf[strlen(buf)-1] = '\\0';\n\t\t\t\tconsolehandler(buf);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmonitor_sig_flags(NULL);\n}\n", "bug_type": null, "idx": 2523}
{"project": "Asterisk", "target": 0, "func": "static int attach_framehook(struct attended_transfer_properties *props, struct ast_channel *channel);\nstatic int retransfer_enter(struct attended_transfer_properties *props)\n{\n\tRAII_VAR(struct ast_format_cap *, cap, ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT), ao2_cleanup);\n\tchar destination[AST_MAX_EXTENSION + AST_MAX_CONTEXT + 2];\n\tint cause;\n\tif (!cap) {\n\t\treturn -1;\n\t}\n\tsnprintf(destination, sizeof(destination), \"%s@%s\", props->exten, props->context);\n\tast_format_cap_append(cap, ast_format_slin, 0);\n\t\n\tprops->recall_target = ast_request(\"Local\", cap, NULL, NULL, destination, &cause);\n\tif (!props->recall_target) {\n\t\tast_log(LOG_ERROR, \"Unable to request outbound channel for recall target\\n\");\n\t\treturn -1;\n\t}\n\tif (attach_framehook(props, props->recall_target)) {\n\t\tast_log(LOG_ERROR, \"Unable to attach framehook to recall target\\n\");\n\t\tast_hangup(props->recall_target);\n\t\tprops->recall_target = NULL;\n\t\treturn -1;\n\t}\n\t\n\tast_channel_lock_both(props->recall_target, props->transferer);\n\tast_party_connected_line_copy(ast_channel_connected(props->recall_target),\n\t\t&props->original_transferer_colp);\n\tast_party_id_reset(&ast_channel_connected(props->recall_target)->priv);\n\tcommon_recall_channel_setup(props->recall_target, props->recall_target);\n\tast_channel_unlock(props->recall_target);\n\tast_channel_unlock(props->transferer);\n\tif (ast_call(props->recall_target, destination, 0)) {\n\t\tast_log(LOG_ERROR, \"Unable to place outbound call to recall target\\n\");\n\t\tast_hangup(props->recall_target);\n\t\tprops->recall_target = NULL;\n\t\treturn -1;\n\t}\n\tast_channel_ref(props->recall_target);\n\tif (ast_bridge_impart(props->transferee_bridge, props->recall_target, NULL, NULL,\n\t\tAST_BRIDGE_IMPART_CHAN_INDEPENDENT)) {\n\t\tast_log(LOG_ERROR, \"Unable to place recall target into bridge\\n\");\n\t\tast_hangup(props->recall_target);\n\t\tast_channel_unref(props->recall_target);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2524}
{"project": "Asterisk", "target": 0, "func": "\nstatic int session_hash_cb(const void *obj, const int flags)\n{\n\tconst struct ast_fax_session *s = obj;\n\treturn s->id;\n}\n", "bug_type": null, "idx": 2525}
{"project": "Asterisk", "target": 0, "func": "};\nstatic int lintoilbc_new(struct ast_trans_pvt *pvt)\n{\n\tstruct ilbc_coder_pvt *tmp = pvt->pvt;\n\tstruct ilbc_attr *attr = pvt->explicit_dst ? ast_format_get_attribute_data(pvt->explicit_dst) : NULL;\n\tconst unsigned int mode = attr ? attr->mode : 30;\n\tinitEncode(&tmp->enc, mode);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2526}
{"project": "Asterisk", "target": 0, "func": "*/\nstatic int pw_cb(char *buf, int size, int rwflag, void *userdata)\n{\n\tstruct ast_key *key = (struct ast_key *)userdata;\n\tchar prompt[256];\n\tint tmp;\n\tint res;\n\tif (key->infd < 0) {\n\t\t\n\t\tkey->infd = -2;\n\t\treturn -1;\n\t}\n\tsnprintf(prompt, sizeof(prompt), \">>>> passcode for %s key '%s': \",\n\t\t key->ktype == AST_KEY_PRIVATE ? \"PRIVATE\" : \"PUBLIC\", key->name);\n\tif (write(key->outfd, prompt, strlen(prompt)) < 0) {\n\t\tast_log(LOG_WARNING, \"write() failed: %s\\n\", strerror(errno));\n\t\tkey->infd = -2;\n\t\treturn -1;\n\t}\n\ttmp = ast_hide_password(key->infd);\n\tmemset(buf, 0, size);\n\tres = read(key->infd, buf, size);\n\tif (res == -1) {\n\t\tast_log(LOG_WARNING, \"read() failed: %s\\n\", strerror(errno));\n\t}\n\tast_restore_tty(key->infd, tmp);\n\tif (buf[strlen(buf) -1] == '\\n') {\n\t\tbuf[strlen(buf) - 1] = '\\0';\n\t}\n\treturn strlen(buf);\n}\n", "bug_type": null, "idx": 2527}
{"project": "Asterisk", "target": 0, "func": "void ast_context_add_include2(struct ast_context *con, const char *value, const char *registrar)\n{\n\tif(!no_comp)\n\t\tprintf(\"Executed ast_context_add_include2(con, value=%s, registrar=%s);\\n\", value, registrar);\n\tif( dump_extensions ) {\n\t\tstruct namelist *x;\n\t\tx = create_name((char*)value);\n\t\tADD_LAST(con->includes,x);\n\t}\n}\n", "bug_type": null, "idx": 2528}
{"project": "Asterisk", "target": 0, "func": "static void test_law_destroy(struct ast_format *format)\n{\n}\n", "bug_type": null, "idx": 2529}
{"project": "Asterisk", "target": 0, "func": "static int default_listener_die(void *data)\n{\n\tstruct default_taskprocessor_listener_pvt *pvt = data;\n\tpvt->dead = 1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2530}
{"project": "Asterisk", "target": 0, "func": "static int exec_clearhash(struct ast_channel *chan, const char *data)\n{\n\tchar prefix[80];\n\tsnprintf(prefix, sizeof(prefix), HASH_PREFIX, data ? (char *)data : \"null\");\n\tclearvar_prefix(chan, prefix);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2531}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H235ECpoint_y (OOCTXT* pctxt, H235ECpoint_y* pvalue)\n{\n   static Asn1SizeCnst lsize1 = { 0, 0, 511, 0 };\n   int stat = ASN_OK;\n   addSizeConstraint (pctxt, &lsize1);\n   stat = encodeBitString (pctxt, pvalue->numbits, pvalue->data);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2532}
{"project": "Asterisk", "target": 0, "func": "static int pitch_shift(struct ast_frame *f, float amount, struct fft_data *fft_data);\nstatic void destroy_callback(void *data)\n{\n\tstruct pitchshift_data *shift = data;\n\tast_audiohook_destroy(&shift->audiohook);\n\tast_free(shift);\n};\n", "bug_type": null, "idx": 2533}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int quan(int val, int *table, int size)\n{\n\tint\t\ti;\n\tfor (i = 0; i < size && val >= *table; ++i, ++table)\n\t\t;\n\treturn i;\n}\n", "bug_type": null, "idx": 2534}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void Coefficients_0_12 P3((LARpp_j_1, LARpp_j, LARp),\n\tregister word * LARpp_j_1,\n\tregister word * LARpp_j,\n\tregister word * LARp)\n{\n\tregister int \ti;\n\tfor (i = 1; i <= 8; i++, LARp++, LARpp_j_1++, LARpp_j++) {\n\t\t*LARp = GSM_ADD( SASR( *LARpp_j_1, 2 ), SASR( *LARpp_j, 2 ));\n\t\t*LARp = GSM_ADD( *LARp,  SASR( *LARpp_j_1, 1));\n\t}\n}\n", "bug_type": null, "idx": 2535}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\tast_sip_session_unregister_supplement(&refer_supplement);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2536}
{"project": "Asterisk", "target": 0, "func": "static int sorcery_wizard_load(void *obj, void *arg, int flags)\n{\n\tstruct ast_sorcery_object_wizard *wizard = obj;\n\tstruct sorcery_load_details *details = arg;\n\tvoid (*load)(void *data, const struct ast_sorcery *sorcery, const char *type);\n\tload = !details->reload ? wizard->wizard->callbacks.load : wizard->wizard->callbacks.reload;\n\tif (load) {\n\t\tNOTIFY_WIZARD_OBSERVERS(wizard->wizard->observers, wizard_loading,\n\t\t\twizard->wizard->callbacks.name, &wizard->wizard->callbacks, details->type, details->reload);\n\t\tload(wizard->data, details->sorcery, details->type);\n\t\tNOTIFY_WIZARD_OBSERVERS(wizard->wizard->observers, wizard_loaded,\n\t\t\twizard->wizard->callbacks.name, &wizard->wizard->callbacks, details->type, details->reload);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2537}
{"project": "Asterisk", "target": 0, "func": "unsigned int ast_format_determine_length(const struct ast_format *format, unsigned int samples)\n{\n\treturn ast_codec_determine_length(format->codec, samples);\n}\n", "bug_type": null, "idx": 2538}
{"project": "Asterisk", "target": 0, "func": "\nstatic int jingle_call(struct ast_channel *ast, const char *dest, int timeout)\n{\n\tstruct jingle_session *session = ast_channel_tech_pvt(ast);\n\tast_setstate(ast, AST_STATE_RING);\n\t\n\tast_format_cap_append_from_cap(session->jointcap, session->cap, AST_MEDIA_TYPE_UNKNOWN);\n\t\n\tsession->rule = iks_filter_add_rule(session->connection->filter, jingle_outgoing_hook, session,\n\t\t\t\t\t    IKS_RULE_ID, session->connection->mid, IKS_RULE_DONE);\n\tjingle_send_session_initiate(session);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2539}
{"project": "Asterisk", "target": 0, "func": "int ast_sorcery_update(const struct ast_sorcery *sorcery, void *object)\n{\n\tconst struct ast_sorcery_object_details *details = object;\n\tRAII_VAR(struct ast_sorcery_object_type *, object_type, ao2_find(sorcery->types, details->object->type, OBJ_KEY), ao2_cleanup);\n\tstruct ast_sorcery_object_wizard *object_wizard = NULL;\n\tstruct ast_sorcery_object_wizard *found_wizard;\n\tint i;\n\tstruct sorcery_details sdetails = {\n\t\t.sorcery = sorcery,\n\t\t.obj = object,\n\t};\n\tif (!object_type) {\n\t\treturn -1;\n\t}\n\tAST_VECTOR_RW_RDLOCK(&object_type->wizards);\n\tfor (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {\n\t\tfound_wizard = AST_VECTOR_GET(&object_type->wizards, i);\n\t\tif (!found_wizard->caching\n\t\t\t&& sorcery_wizard_update(found_wizard, &sdetails) == CMP_MATCH) {\n\t\t\tobject_wizard = found_wizard;\n\t\t}\n\t}\n\tif (object_wizard) {\n\t\tfor (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {\n\t\t\tfound_wizard = AST_VECTOR_GET(&object_type->wizards, i);\n\t\t\tif (found_wizard->caching) {\n\t\t\t\tsorcery_wizard_update(found_wizard, &sdetails);\n\t\t\t}\n\t\t}\n\t\tif (ao2_container_count(object_type->observers)) {\n\t\t\tstruct sorcery_observer_invocation *invocation;\n\t\t\tinvocation = sorcery_observer_invocation_alloc(object_type, object);\n\t\t\tif (invocation\n\t\t\t\t&& ast_taskprocessor_push(object_type->serializer, sorcery_observers_notify_update,\n\t\t\t\t\tinvocation)) {\n\t\t\t\tao2_cleanup(invocation);\n\t\t\t}\n\t\t}\n\t}\n\tAST_VECTOR_RW_UNLOCK(&object_type->wizards);\n\treturn object_wizard ? 0 : -1;\n}\n", "bug_type": null, "idx": 2540}
{"project": "Asterisk", "target": 0, "func": "void dahdi_dtmf_detect_enable(struct dahdi_pvt *p)\n{\n\tint val = DAHDI_TONEDETECT_ON | DAHDI_TONEDETECT_MUTE;\n\tif (p->channel == CHAN_PSEUDO)\n\t\treturn;\n\tp->ignoredtmf = 0;\n\tioctl(p->subs[SUB_REAL].dfd, DAHDI_TONEDETECT, &val);\n\tif (!p->hardwaredtmf && p->dsp) {\n\t\tp->dsp_features |= DSP_FEATURE_DIGIT_DETECT;\n\t\tast_dsp_set_features(p->dsp, p->dsp_features);\n\t}\n}\n", "bug_type": null, "idx": 2541}
{"project": "Asterisk", "target": 0, "func": "static int destruct_count;\nstatic int dummy_task(void *data)\n{\n\tint *sleep = data;\n\tusleep(M2U(*sleep));\n\trun_count++;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2542}
{"project": "Asterisk", "target": 0, "func": "static char *handle_bridge_show_all(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n#define FORMAT_HDR \"%-36s %5s %-15s %s\\n\"\n#define FORMAT_ROW \"%-36s %5u %-15s %s\\n\"\n\tRAII_VAR(struct ao2_container *, cached_bridges, NULL, ao2_cleanup);\n\tstruct ao2_iterator iter;\n\tstruct stasis_message *msg;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"bridge show all\";\n\t\te->usage =\n\t\t\t\"Usage: bridge show all\\n\"\n\t\t\t\"       List all bridges\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tcached_bridges = stasis_cache_dump(ast_bridge_cache(), ast_bridge_snapshot_type());\n\tif (!cached_bridges) {\n\t\tast_cli(a->fd, \"Failed to retrieve cached bridges\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\tast_cli(a->fd, FORMAT_HDR, \"Bridge-ID\", \"Chans\", \"Type\", \"Technology\");\n\titer = ao2_iterator_init(cached_bridges, 0);\n\tfor (; (msg = ao2_iterator_next(&iter)); ao2_ref(msg, -1)) {\n\t\tstruct ast_bridge_snapshot *snapshot = stasis_message_data(msg);\n\t\tast_cli(a->fd, FORMAT_ROW,\n\t\t\tsnapshot->uniqueid,\n\t\t\tsnapshot->num_channels,\n\t\t\tS_OR(snapshot->subclass, \"<unknown>\"),\n\t\t\tS_OR(snapshot->technology, \"<unknown>\"));\n\t}\n\tao2_iterator_destroy(&iter);\n\treturn CLI_SUCCESS;\n#undef FORMAT_HDR\n#undef FORMAT_ROW\n}\n", "bug_type": null, "idx": 2543}
{"project": "Asterisk", "target": 0, "func": "void pvalMacroAddStatement( pval *p, pval *statement )\n{\n\tif (!pvalCheckType(p, \"pvalMacroAddStatement\", PV_MACRO))\n\t\treturn;\n\tif (!p->u3.macro_statements)\n\t\tp->u3.macro_statements = statement;\n\telse\n\t\tlinku1(p->u3.macro_statements, statement);\n}\n", "bug_type": null, "idx": 2544}
{"project": "Asterisk", "target": 0, "func": "static int unload_module(void)\n{\n\treturn ast_unregister_application(app);\n}\n", "bug_type": null, "idx": 2545}
{"project": "Asterisk", "target": 0, "func": "\nint ooOpenLogicalChannel(OOH323CallData *call, enum OOCapType capType )\n{\n   ooH323EpCapability *epCap=NULL;\n   int k=0;\n   \n   if(gH323ep.myCaps == 0 && call->ourCaps == 0)\n   {\n      OOTRACEERR3(\"ERROR:Local endpoint does not have any audio capabilities\"\n                  \" (%s, %s)\\n\", call->callType, call->callToken);\n      return OO_FAILED;\n   }\n   \n   OOTRACEINFO3(\"Looking for matching capabilities. (%s, %s)\\n\", \n                 call->callType, call->callToken);\n\n   if(call->masterSlaveState == OO_MasterSlave_Master)\n   {\n      for(k=0; k<call->capPrefs.index; k++)\n      {\n         \n         if(capType == OO_CAP_TYPE_AUDIO && \n            call->capPrefs.order[k] > OO_CAP_VIDEO_BASE)\n            continue;\n         \n         if(capType == OO_CAP_TYPE_VIDEO && \n            call->capPrefs.order[k] <= OO_CAP_VIDEO_BASE)\n            continue;\n         epCap = call->jointCaps;\n         while(epCap){\n            if(epCap->cap == call->capPrefs.order[k] && (epCap->dir & OOTX))\n               break;\n            epCap = epCap->next;\n         }\n         if(!epCap)\n         {\n            OOTRACEDBGA4(\"Prefereed capability %d is not a local transmit \"\n                         \"capability(%s, %s)\\n\", call->capPrefs.order[k],\n                         call->callType, call->callToken);\n            continue;\n         }\n         break;\n      }\n      if(!epCap)\n      {\n         OOTRACEERR4(\"ERROR:Incompatible capabilities - Can not open \"\n                  \"%s channel (%s, %s)\\n\", \n                  (capType==OO_CAP_TYPE_AUDIO)?\"audio\":\"video\", call->callType,\n                  call->callToken);\n         return OO_FAILED;\n      }\n   }\n   else\n   {\n      epCap = call->jointCaps;\n      while(epCap){\n         if(epCap->capType == capType && epCap->dir & OOTX) { break; }\n         epCap = epCap->next;\n      }\n      if(!epCap)\n      {\n         OOTRACEERR4(\"ERROR:Incompatible audio capabilities - Can not open \"\n                  \"%s channel (%s, %s)\\n\", \n                  (capType==OO_CAP_TYPE_AUDIO)?\"audio\":\"video\", call->callType,\n                  call->callToken);\n         return OO_FAILED;\n      }\n   }\n   switch(epCap->cap)\n   {\n   case OO_G711ALAW64K:\n   case OO_G711ALAW56K:\n   case OO_G711ULAW64K:\n   case OO_G711ULAW56K:\n   case OO_G726:\n   case OO_G726AAL2:\n   case OO_AMRNB:\n   case OO_SPEEX:\n   case OO_G728:\n   case OO_G729:\n   case OO_G729A:\n   case OO_G729B:\n   case OO_G7231:\n   case OO_GSMFULLRATE:\n   case OO_GSMHALFRATE:\n   case OO_GSMENHANCEDFULLRATE:\n   case OO_H263VIDEO:\n   case OO_T38:\n      ooOpenChannel(call, epCap);\n      break;\n   default:\n      OOTRACEERR3(\"ERROR:Unknown Audio Capability type (%s, %s)\\n\", \n                   call->callType, call->callToken);\n   }\n   return OO_OK;\n}\n", "bug_type": null, "idx": 2546}
{"project": "Asterisk", "target": 0, "func": "static void join_marked(struct confbridge_user *user)\n{\n\tconf_add_user_marked(user->conference, user);\n\tconf_update_user_mute(user);\n\tconf_change_state(user, CONF_STATE_MULTI_MARKED);\n}\n", "bug_type": null, "idx": 2547}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_audiohook_write_frame(struct ast_audiohook *audiohook, enum ast_audiohook_direction direction, struct ast_frame *frame)\n{\n\tstruct ast_slinfactory *factory = (direction == AST_AUDIOHOOK_DIRECTION_READ ? &audiohook->read_factory : &audiohook->write_factory);\n\tstruct ast_slinfactory *other_factory = (direction == AST_AUDIOHOOK_DIRECTION_READ ? &audiohook->write_factory : &audiohook->read_factory);\n\tstruct timeval *rwtime = (direction == AST_AUDIOHOOK_DIRECTION_READ ? &audiohook->read_time : &audiohook->write_time), previous_time = *rwtime;\n\tint our_factory_samples;\n\tint our_factory_ms;\n\tint other_factory_samples;\n\tint other_factory_ms;\n\t\n\t*rwtime = ast_tvnow();\n\tour_factory_samples = ast_slinfactory_available(factory);\n\tour_factory_ms = ast_tvdiff_ms(*rwtime, previous_time) + (our_factory_samples / (audiohook->hook_internal_samp_rate / 1000));\n\tother_factory_samples = ast_slinfactory_available(other_factory);\n\tother_factory_ms = other_factory_samples / (audiohook->hook_internal_samp_rate / 1000);\n\tif (ast_test_flag(audiohook, AST_AUDIOHOOK_TRIGGER_SYNC) && (our_factory_ms - other_factory_ms > AST_AUDIOHOOK_SYNC_TOLERANCE)) {\n\t\tast_debug(1, \"Flushing audiohook %p so it remains in sync\\n\", audiohook);\n\t\tast_slinfactory_flush(factory);\n\t\tast_slinfactory_flush(other_factory);\n\t}\n\tif (ast_test_flag(audiohook, AST_AUDIOHOOK_SMALL_QUEUE) && ((our_factory_ms > AST_AUDIOHOOK_SMALL_QUEUE_TOLERANCE) || (other_factory_ms > AST_AUDIOHOOK_SMALL_QUEUE_TOLERANCE))) {\n\t\tast_debug(1, \"Audiohook %p has stale audio in its factories. Flushing them both\\n\", audiohook);\n\t\tast_slinfactory_flush(factory);\n\t\tast_slinfactory_flush(other_factory);\n\t} else if ((our_factory_ms > AST_AUDIOHOOK_LONG_QUEUE_TOLERANCE) || (other_factory_ms > AST_AUDIOHOOK_LONG_QUEUE_TOLERANCE)) {\n\t\tast_debug(1, \"Audiohook %p has stale audio in its factories. Flushing them both\\n\", audiohook);\n\t\tast_slinfactory_flush(factory);\n\t\tast_slinfactory_flush(other_factory);\n\t}\n\t\n\tast_slinfactory_feed(factory, frame);\n\t\n\tif ((ast_test_flag(audiohook, AST_AUDIOHOOK_TRIGGER_MODE) == AST_AUDIOHOOK_TRIGGER_READ) && (direction == AST_AUDIOHOOK_DIRECTION_READ)) {\n\t\tast_cond_signal(&audiohook->trigger);\n\t} else if ((ast_test_flag(audiohook, AST_AUDIOHOOK_TRIGGER_MODE) == AST_AUDIOHOOK_TRIGGER_WRITE) && (direction == AST_AUDIOHOOK_DIRECTION_WRITE)) {\n\t\tast_cond_signal(&audiohook->trigger);\n\t} else if (ast_test_flag(audiohook, AST_AUDIOHOOK_TRIGGER_SYNC)) {\n\t\tast_cond_signal(&audiohook->trigger);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2548}
{"project": "Asterisk", "target": 0, "func": "\nstatic int tps_hash_cb(const void *obj, const int flags)\n{\n\tconst struct ast_taskprocessor *tps = obj;\n\tconst char *name = flags & OBJ_KEY ? obj : tps->name;\n\treturn ast_str_case_hash(name);\n}\n", "bug_type": null, "idx": 2549}
{"project": "Asterisk", "target": 0, "func": "static int update2_curl(const char *url, const char *unused, const struct ast_variable *lookup_fields, const struct ast_variable *update_fields)\n{\n\tstruct ast_str *query, *buffer;\n\tchar buf1[200], buf2[200];\n\tconst struct ast_variable *field;\n\tchar *stringp;\n\tunsigned int start = 1;\n\tint rowcount = -1;\n\tif (!ast_custom_function_find(\"CURL\")) {\n\t\tast_log(LOG_ERROR, \"func_curl.so must be loaded in order to use res_config_curl.so!!\\n\");\n\t\treturn -1;\n\t}\n\tif (!(query = ast_str_thread_get(&query_buf, 1000)))\n\t\treturn -1;\n\tif (!(buffer = ast_str_thread_get(&result_buf, 16))) {\n\t\treturn -1;\n\t}\n\tast_str_set(&query, 0, \"${CURL(%s/update?\", url);\n\tfor (field = lookup_fields; field; field = field->next) {\n\t\tast_uri_encode(field->name, buf1, sizeof(buf1), ast_uri_http);\n\t\tast_uri_encode(field->value, buf2, sizeof(buf2), ast_uri_http);\n\t\tast_str_append(&query, 0, \"%s%s=%s\", !start ? \"\" : \"&\", buf1, buf2);\n\t\tstart = 0;\n\t}\n\tast_str_append(&query, 0, \",\");\n\tstart = 1;\n\tfor (field = update_fields; field; field = field->next) {\n\t\tast_uri_encode(field->name, buf1, sizeof(buf1), ast_uri_http);\n\t\tast_uri_encode(field->value, buf2, sizeof(buf2), ast_uri_http);\n\t\tast_str_append(&query, 0, \"%s%s=%s\", !start ? \"\" : \"&\", buf1, buf2);\n\t\tstart = 0;\n\t}\n\tast_str_append(&query, 0, \")}\");\n\t\n\tast_str_substitute_variables(&buffer, 0, NULL, ast_str_buffer(query));\n\t\n\tstringp = ast_str_buffer(buffer);\n\twhile (*stringp <= ' ') {\n\t\tstringp++;\n\t}\n\tsscanf(stringp, \"%30d\", &rowcount);\n\tif (rowcount >= 0) {\n\t\treturn (int)rowcount;\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 2550}
{"project": "Asterisk", "target": 0, "func": "struct ast_sip_cli_formatter_entry *unid_formatter;\nstatic int expire_requests(void *object, void *arg, int flags)\n{\n\tstruct unidentified_request *unid = object;\n\tint *maxage = arg;\n\tint64_t ms = ast_tvdiff_ms(ast_tvnow(), unid->first_seen);\n\tif (ms > (*maxage) * 2 * 1000) {\n\t\treturn CMP_MATCH;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 2551}
{"project": "Asterisk", "target": 0, "func": "static struct ast_frame *ooh323_read(struct ast_channel *ast)\n{\n\tstruct ast_frame *fr;\n\tstatic struct ast_frame null_frame = { AST_FRAME_NULL, };\n\tstruct ooh323_pvt *p = ast_channel_tech_pvt(ast);\n\tif (!p) return &null_frame;\n\tast_mutex_lock(&p->lock);\n\tif (p->rtp)\n\t\tfr = ooh323_rtp_read(ast, p);\n\telse\n\t\tfr = &null_frame;\n\t\n\tast_mutex_unlock(&p->lock);\n\treturn fr;\n}\n", "bug_type": null, "idx": 2552}
{"project": "Asterisk", "target": 0, "func": "static char *handle_pjproject_show_log_level(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"pjproject show log level\";\n\t\te->usage =\n\t\t\t\"Usage: pjproject show log level\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"       Show the current maximum active pjproject logging level.\\n\"\n\t\t\t\"       See pjproject.conf.sample for additional information\\n\"\n\t\t\t\"       about the various levels pjproject uses.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_cli(a->fd, \"pjproject log level is %d.%s\\n\",\n\t\tast_option_pjproject_log_level,\n\t\tast_option_pjproject_log_level == DEFAULT_PJ_LOG_MAX_LEVEL ? \" (default)\" : \"\");\n\treturn CLI_SUCCESS;\n}\n", "bug_type": null, "idx": 2553}
{"project": "Asterisk", "target": 0, "func": "static int handle_controlstreamfile(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])\n{\n\tint res = 0, skipms = 3000;\n\tconst char *fwd = \"#\", *rev = \"*\", *suspend = NULL, *stop = NULL;\t\n\tchar stopkeybuf[2];\n\tlong offsetms = 0;\n\tchar offsetbuf[20];\n\tif (argc < 5 || argc > 10) {\n\t\treturn RESULT_SHOWUSAGE;\n\t}\n\tif (!ast_strlen_zero(argv[4])) {\n\t\tstop = argv[4];\n\t}\n\tif ((argc > 5) && (sscanf(argv[5], \"%30d\", &skipms) != 1)) {\n\t\treturn RESULT_SHOWUSAGE;\n\t}\n\tif (argc > 6 && !ast_strlen_zero(argv[6])) {\n\t\tfwd = argv[6];\n\t}\n\tif (argc > 7 && !ast_strlen_zero(argv[7])) {\n\t\trev = argv[7];\n\t}\n\tif (argc > 8 && !ast_strlen_zero(argv[8])) {\n\t\tsuspend = argv[8];\n\t}\n\tif (argc > 9 && (sscanf(argv[9], \"%30ld\", &offsetms) != 1)) {\n\t\treturn RESULT_SHOWUSAGE;\n\t}\n\tres = ast_control_streamfile(chan, argv[3], fwd, rev, stop, suspend, NULL, skipms, &offsetms);\n\t\n\tif (res > 0 && stop && strchr(stop, res)) {\n\t\tpbx_builtin_setvar_helper(chan, \"CPLAYBACKSTATUS\", \"USERSTOPPED\");\n\t\tsnprintf(stopkeybuf, sizeof(stopkeybuf), \"%c\", res);\n\t\tpbx_builtin_setvar_helper(chan, \"CPLAYBACKSTOPKEY\", stopkeybuf);\n\t} else if (res > 0 && res == AST_CONTROL_STREAM_STOP) {\n\t\tpbx_builtin_setvar_helper(chan, \"CPLAYBACKSTATUS\", \"REMOTESTOPPED\");\n\t\tres = 0;\n\t} else {\n\t\tif (res < 0) {\n\t\t\tpbx_builtin_setvar_helper(chan, \"CPLAYBACKSTATUS\", \"ERROR\");\n\t\t} else {\n\t\t\tpbx_builtin_setvar_helper(chan, \"CPLAYBACKSTATUS\", \"SUCCESS\");\n\t\t}\n\t}\n\tsnprintf(offsetbuf, sizeof(offsetbuf), \"%ld\", offsetms);\n\tpbx_builtin_setvar_helper(chan, \"CPLAYBACKOFFSET\", offsetbuf);\n\tast_agi_send(agi->fd, chan, \"200 result=%d endpos=%ld\\n\", res, offsetms);\n\treturn (res >= 0) ? RESULT_SUCCESS : RESULT_FAILURE;\n}\n", "bug_type": null, "idx": 2554}
{"project": "Asterisk", "target": 0, "func": "static void stub_callback(const struct ast_dns_query *query)\n{\n\treturn;\n}\n", "bug_type": null, "idx": 2555}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PD_H245MaintenanceLoopRequest (OOCTXT* pctxt, H245MaintenanceLoopRequest* pvalue)\n{\n   int stat = ASN_OK;\n   OOCTXT lctxt;\n   ASN1OpenType openType;\n   ASN1UINT bitcnt;\n   ASN1UINT i;\n   ASN1BOOL optbit = 0;\n   ASN1BOOL extbit = 0;\n   \n   DECODEBIT (pctxt, &extbit);\n   \n   invokeStartElement (pctxt, \"type\", -1);\n   stat = asn1PD_H245MaintenanceLoopRequest_type (pctxt, &pvalue->type);\n   if (stat != ASN_OK) return stat;\n   invokeEndElement (pctxt, \"type\", -1);\n   if (extbit) {\n      \n      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);\n      if (stat != ASN_OK) return stat;\n      bitcnt += 1;\n      ZEROCONTEXT (&lctxt);\n      stat = setPERBufferUsingCtxt (&lctxt, pctxt);\n      if (stat != ASN_OK) return stat;\n      stat = moveBitCursor (pctxt, bitcnt);\n      if (stat != ASN_OK) return stat;\n      for (i = 0; i < bitcnt; i++) {\n         DECODEBIT (&lctxt, &optbit);\n         if (optbit) {\n            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);\n            if (stat != ASN_OK) return stat;\n            pctxt->buffer.byteIndex += openType.numocts;\n         }\n      }\n   }\n   return (stat);\n}\n", "bug_type": null, "idx": 2556}
{"project": "Asterisk", "target": 0, "func": "ast_alert_status_t ast_channel_internal_alert_flush(struct ast_channel *chan)\n{\n\treturn ast_alertpipe_flush(chan->alertpipe);\n}\n", "bug_type": null, "idx": 2557}
{"project": "Asterisk", "target": 0, "func": " */\nstatic int atxfer_threeway(struct ast_bridge_channel *bridge_channel, void *hook_pvt)\n{\n\tstruct attended_transfer_properties *props = hook_pvt;\n\tast_debug(1, \"Transferer on attended transfer %p pressed threeway sequence\\n\", props);\n\tstimulate_attended_transfer(props, STIMULUS_DTMF_ATXFER_THREEWAY);\n\treturn 0;\n}\n", "bug_type": null, "idx": 2558}
{"project": "Asterisk", "target": 0, "func": " */\nint ast_dial_option_enable(struct ast_dial *dial, int num, enum ast_dial_option option, void *data)\n{\n\tstruct ast_dial_channel *channel = NULL;\n\t\n\tif (!dial || AST_LIST_EMPTY(&dial->channels))\n\t\treturn -1;\n\tif (!(channel = find_dial_channel(dial, num)))\n\t\treturn -1;\n\t\n\tif (channel->options[option])\n\t\treturn -1;\n\t\n\tif (option_types[option].enable)\n\t\tchannel->options[option] = option_types[option].enable(data);\n\telse\n\t\tchannel->options[option] = (void*)1;\n\treturn 0;\n}\n", "bug_type": null, "idx": 2559}
{"project": "Asterisk", "target": 0, "func": "static char *complete_ari_app(struct ast_cli_args *a, int include_all)\n{\n\tRAII_VAR(struct ao2_container *, apps, stasis_app_get_all(), ao2_cleanup);\n\tRAII_VAR(char *, app, NULL, ao2_cleanup);\n\tstruct app_complete search = {\n\t\t.state = a->n,\n\t};\n\tif (a->pos != 3) {\n\t\treturn NULL;\n\t}\n\tif (!apps) {\n\t\tast_cli(a->fd, \"Error getting ARI applications\\n\");\n\t\treturn CLI_FAILURE;\n\t}\n\tif (include_all && ast_strlen_zero(a->word)) {\n\t\tast_str_container_add(apps, \" all\");\n\t}\n\tapp = ao2_callback_data(apps,\n\t\tast_strlen_zero(a->word) ? 0 : OBJ_SEARCH_PARTIAL_KEY,\n\t\tcomplete_ari_app_search, (char*)a->word, &search);\n\treturn app ? ast_strdup(app) : NULL;\n}\n", "bug_type": null, "idx": 2560}
{"project": "Asterisk", "target": 0, "func": "enum stasis_app_user_event_res stasis_app_user_event(const char *app_name,\n\tconst char *event_name,\n\tconst char **source_uris, int sources_count,\n\tstruct ast_json *json_variables)\n{\n\tRAII_VAR(struct stasis_app *, app, find_app_by_name(app_name), ao2_cleanup);\n\tRAII_VAR(struct ast_json *, blob, NULL, ast_json_unref);\n\tRAII_VAR(struct ast_multi_object_blob *, multi, NULL, ao2_cleanup);\n\tRAII_VAR(void *, obj, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\tenum stasis_app_user_event_res res = STASIS_APP_USER_INTERNAL_ERROR;\n\tstruct ast_json *json_value;\n\tint have_channel = 0;\n\tint i;\n\tif (!app) {\n\t\tast_log(LOG_WARNING, \"App %s not found\\n\", app_name);\n\t\treturn STASIS_APP_USER_APP_NOT_FOUND;\n\t}\n\tif (!ast_multi_user_event_type()) {\n\t\treturn res;\n\t}\n\tblob = json_variables;\n\tif (!blob) {\n\t\tblob = ast_json_pack(\"{}\");\n\t} else {\n\t\tast_json_ref(blob);\n\t}\n\tjson_value = ast_json_string_create(event_name);\n\tif (!json_value) {\n\t\tast_log(LOG_ERROR, \"unable to create json string\\n\");\n\t\treturn res;\n\t}\n\tif (ast_json_object_set(blob, \"eventname\", json_value)) {\n\t\tast_log(LOG_ERROR, \"unable to set eventname to blob\\n\");\n\t\treturn res;\n\t}\n\tmulti = ast_multi_object_blob_create(blob);\n\tfor (i = 0; i < sources_count; ++i) {\n\t\tconst char *uri = source_uris[i];\n\t\tvoid *snapshot=NULL;\n\t\tenum stasis_user_multi_object_snapshot_type type;\n\t\tif (ast_begins_with(uri, \"channel:\")) {\n\t\t\ttype = STASIS_UMOS_CHANNEL;\n\t\t\tsnapshot = ast_channel_snapshot_get_latest(uri + 8);\n\t\t\thave_channel = 1;\n\t\t} else if (ast_begins_with(uri, \"bridge:\")) {\n\t\t\ttype = STASIS_UMOS_BRIDGE;\n\t\t\tsnapshot = ast_bridge_snapshot_get_latest(uri + 7);\n\t\t} else if (ast_begins_with(uri, \"endpoint:\")) {\n\t\t\ttype = STASIS_UMOS_ENDPOINT;\n\t\t\tsnapshot = ast_endpoint_latest_snapshot(uri + 9, NULL);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Invalid scheme: %s\\n\", uri);\n\t\t\treturn STASIS_APP_USER_EVENT_SOURCE_BAD_SCHEME;\n\t\t}\n\t\tif (!snapshot) {\n\t\t\tast_log(LOG_ERROR, \"Unable to get snapshot for %s\\n\", uri);\n\t\t\treturn STASIS_APP_USER_EVENT_SOURCE_NOT_FOUND;\n\t\t}\n\t\tast_multi_object_blob_add(multi, type, snapshot);\n\t}\n\tmessage = stasis_message_create(ast_multi_user_event_type(), multi);\n\tif (!message) {\n\t\tast_log(LOG_ERROR, \"Unable to create stasis user event message\\n\");\n\t\treturn res;\n\t}\n\t\n\tstasis_publish(ast_app_get_topic(app), message);\n\tif (have_channel) {\n\t\tstasis_publish(ast_manager_get_topic(), message);\n\t}\n\treturn STASIS_APP_USER_OK;\n}\n", "bug_type": null, "idx": 2561}
{"project": "Asterisk", "target": 0, "func": "void ast_sdp_payloads_free(struct ast_sdp_payloads *payloads)\n{\n\tif (!payloads) {\n\t\treturn;\n\t}\n\tAST_VECTOR_CALLBACK_VOID(payloads, ast_sdp_payload_free);\n\tAST_VECTOR_FREE(payloads);\n\tast_free(payloads);\n}\n", "bug_type": null, "idx": 2562}
{"project": "Asterisk", "target": 0, "func": "static off_t siren14tell(struct ast_filestream *fs)\n{\n\treturn BYTES_TO_SAMPLES(ftello(fs->f));\n}\n", "bug_type": null, "idx": 2563}
{"project": "Asterisk", "target": 0, "func": "static int mf_detect(struct ast_dsp *dsp, digit_detect_state_t *s, int16_t amp[],\n\t\tint samples, int squelch, int relax)\n{\n\tfloat energy[6];\n\tint best;\n\tint second_best;\n\tint i;\n\tint j;\n\tint sample;\n\tshort samp;\n\tint hit;\n\tint limit;\n\tfragment_t mute = {0, 0};\n\tif (squelch && s->td.mf.mute_samples > 0) {\n\t\tmute.end = (s->td.mf.mute_samples < samples) ? s->td.mf.mute_samples : samples;\n\t\ts->td.mf.mute_samples -= mute.end;\n\t}\n\thit = 0;\n\tfor (sample = 0; sample < samples; sample = limit) {\n\t\t\n\t\t\n\t\tif ((samples - sample) >= (MF_GSIZE - s->td.mf.current_sample)) {\n\t\t\tlimit = sample + (MF_GSIZE - s->td.mf.current_sample);\n\t\t} else {\n\t\t\tlimit = samples;\n\t\t}\n\t\t\n\t\tfor (j = sample; j < limit; j++) {\n\t\t\t\n\t\t\tsamp = amp[j];\n\t\t\tgoertzel_sample(s->td.mf.tone_out, samp);\n\t\t\tgoertzel_sample(s->td.mf.tone_out + 1, samp);\n\t\t\tgoertzel_sample(s->td.mf.tone_out + 2, samp);\n\t\t\tgoertzel_sample(s->td.mf.tone_out + 3, samp);\n\t\t\tgoertzel_sample(s->td.mf.tone_out + 4, samp);\n\t\t\tgoertzel_sample(s->td.mf.tone_out + 5, samp);\n\t\t}\n\t\ts->td.mf.current_sample += (limit - sample);\n\t\tif (s->td.mf.current_sample < MF_GSIZE) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tenergy[0] = goertzel_result(&s->td.mf.tone_out[0]);\n\t\tenergy[1] = goertzel_result(&s->td.mf.tone_out[1]);\n\t\tif (energy[0] > energy[1]) {\n\t\t\tbest = 0;\n\t\t\tsecond_best = 1;\n\t\t} else {\n\t\t\tbest = 1;\n\t\t\tsecond_best = 0;\n\t\t}\n\t\t\n\t\tfor (i = 2; i < 6; i++) {\n\t\t\tenergy[i] = goertzel_result(&s->td.mf.tone_out[i]);\n\t\t\tif (energy[i] >= energy[best]) {\n\t\t\t\tsecond_best = best;\n\t\t\t\tbest = i;\n\t\t\t} else if (energy[i] >= energy[second_best]) {\n\t\t\t\tsecond_best = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\thit = 0;\n\t\tif (energy[best] >= BELL_MF_THRESHOLD && energy[second_best] >= BELL_MF_THRESHOLD\n\t\t    && energy[best] < energy[second_best]*BELL_MF_TWIST\n\t\t    && energy[best] * BELL_MF_TWIST > energy[second_best]) {\n\t\t\t\n\t\t\thit = -1;\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tif (i != best && i != second_best) {\n\t\t\t\t\tif (energy[i]*BELL_MF_RELATIVE_PEAK >= energy[second_best]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\thit = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hit) {\n\t\t\t\n\t\t\tif (second_best < best) {\n\t\t\t\ti = best;\n\t\t\t\tbest = second_best;\n\t\t\t\tsecond_best = i;\n\t\t\t}\n\t\t\tbest = best * 5 + second_best - 1;\n\t\t\thit = bell_mf_positions[best];\n\t\t\t\n\t\t\t\n\t\t\tif (hit == s->td.mf.hits[4] && hit == s->td.mf.hits[3] &&\n\t\t\t   ((hit != '*' && hit != s->td.mf.hits[2] && hit != s->td.mf.hits[1])||\n\t\t\t    (hit == '*' && hit == s->td.mf.hits[2] && hit != s->td.mf.hits[1] &&\n\t\t\t    hit != s->td.mf.hits[0]))) {\n\t\t\t\tstore_digit(s, hit);\n\t\t\t}\n\t\t}\n\t\tif (hit != s->td.mf.hits[4] && hit != s->td.mf.hits[3]) {\n\t\t\t\n\t\t\ts->td.mf.current_hit = 0;\n\t\t}\n\t\ts->td.mf.hits[0] = s->td.mf.hits[1];\n\t\ts->td.mf.hits[1] = s->td.mf.hits[2];\n\t\ts->td.mf.hits[2] = s->td.mf.hits[3];\n\t\ts->td.mf.hits[3] = s->td.mf.hits[4];\n\t\ts->td.mf.hits[4] = hit;\n\t\t\n\t\tif (squelch && hit) {\n\t\t\tif (mute.end < sample - MF_GSIZE) {\n\t\t\t\t\n\t\t\t\tmute_fragment(dsp, &mute);\n\t\t\t\tmute.start = (sample > MF_GSIZE) ? (sample - MF_GSIZE) : 0;\n\t\t\t}\n\t\t\tmute.end = limit + MF_GSIZE;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tgoertzel_reset(&s->td.mf.tone_out[i]);\n\t\t}\n\t\ts->td.mf.current_sample = 0;\n\t}\n\tif (squelch && mute.end) {\n\t\tif (mute.end > samples) {\n\t\t\ts->td.mf.mute_samples = mute.end - samples;\n\t\t\tmute.end = samples;\n\t\t}\n\t\tmute_fragment(dsp, &mute);\n\t}\n\treturn (s->td.mf.current_hit); \n}\n", "bug_type": null, "idx": 2564}
{"project": "Asterisk", "target": 0, "func": "void ast_party_redirecting_reason_copy(struct ast_party_redirecting_reason *dest, const struct ast_party_redirecting_reason *src)\n{\n\tif (dest == src) {\n\t\treturn;\n\t}\n\tast_free(dest->str);\n\tdest->str = ast_strdup(src->str);\n\tdest->code = src->code;\n}\n", "bug_type": null, "idx": 2565}
{"project": "Asterisk", "target": 0, "func": " */\nstatic void sla_ring_stations(void)\n{\n\tstruct sla_station_ref *station_ref;\n\tstruct sla_ringing_trunk *ringing_trunk;\n\t\n\tAST_LIST_TRAVERSE(&sla.ringing_trunks, ringing_trunk, entry) {\n\t\tAST_LIST_TRAVERSE(&ringing_trunk->trunk->stations, station_ref, entry) {\n\t\t\tint time_left;\n\t\t\t\n\t\t\tif (sla_check_ringing_station(station_ref->station))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (sla_check_inuse_station(station_ref->station))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (sla_check_failed_station(station_ref->station))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (sla_check_timed_out_station(ringing_trunk, station_ref->station))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\ttime_left = sla_check_station_delay(station_ref->station, ringing_trunk);\n\t\t\tif (time_left != INT_MAX && time_left > 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tsla_ring_station(ringing_trunk, station_ref->station);\n\t\t}\n\t}\n\t\n}\n", "bug_type": null, "idx": 2566}
{"project": "Asterisk", "target": 0, "func": "\nEXTERN int asn1PE_H245RequestMultiplexEntry (OOCTXT* pctxt, H245RequestMultiplexEntry* pvalue)\n{\n   int stat = ASN_OK;\n   ASN1BOOL extbit;\n   \n   extbit = 0;\n   encodeBit (pctxt, extbit);\n   \n   stat = asn1PE_H245RequestMultiplexEntry_entryNumbers (pctxt, &pvalue->entryNumbers);\n   if (stat != ASN_OK) return stat;\n   return (stat);\n}\n", "bug_type": null, "idx": 2567}
