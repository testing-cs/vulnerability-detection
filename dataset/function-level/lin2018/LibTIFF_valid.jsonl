{"project": "LibTIFF", "target": 0, "func": "TIFF*\nTIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\tm = _TIFFgetMode(mode, module);\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\tfd = (thandle_t)CreateFileW(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = _TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\ttif = TIFFFdOpen((int)fd,\n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\t_TIFFfree(mbname);\n\treturn tif;\n}\n", "bug_type": null, "idx": 0}
{"project": "LibTIFF", "target": 0, "func": "void\n_TIFFfree(tdata_t p)\n{\n\tDisposePtr(p);\n}\n", "bug_type": null, "idx": 1}
{"project": "LibTIFF", "target": 1, "func": "\nint\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\n\tint n;\n\tTIFFDirectory* td;\n\tTIFFDirEntry *dp, *dir = NULL;\n\tuint16 iv;\n\tuint32 v;\n\tconst TIFFFieldInfo* fip;\n\tsize_t fix;\n\tuint16 dircount;\n\tint diroutoforderwarning = 0, compressionknown = 0;\n\n\ttif->tif_diroff = tif->tif_nextdiroff;\n\t\n\n\n\tif (!TIFFCheckDirOffset(tif, tif->tif_nextdiroff))\n\t\treturn 0;\n\t\n\n\n\t(*tif->tif_cleanup)(tif);\n\ttif->tif_curdir++;\n\tdircount = TIFFFetchDirectory(tif, tif->tif_nextdiroff,\n\t\t\t\t      &dir, &tif->tif_nextdiroff);\n\tif (!dircount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: Failed to read directory at offset %u\",\n\t\t\t     tif->tif_name, tif->tif_nextdiroff);\n\t\treturn 0;\n\t}\n\n\ttif->tif_flags &= ~TIFF_BEENWRITING;\t\n\t\n\n\n\n\n\n\n\ttd = &tif->tif_dir;\n\t\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t\n\n\n\n\n\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\t\tif (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) {\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t}\n\t}\n\t\n\n\n\tfix = 0;\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\n\t\tif (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\n\t\t\n\n\n\n\n\t\tif (dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag) {\n\t\t\tif (!diroutoforderwarning) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: invalid TIFF directory; tags are not sorted in ascending order\",\n\t\t\t\t\t    tif->tif_name);\n\t\t\t\tdiroutoforderwarning = 1;\n\t\t\t}\n\t\t\tfix = 0;\t\t\t\n\t\t}\n\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n                        \"%s: unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t\t\t       tif->tif_name,\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\n\t\t\t\t\tif (!_TIFFMergeFieldInfo(tif,\n\t\t\t\t\t\t_TIFFCreateAnonFieldInfo(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t\t1))\n\t\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n\t\t\t\"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\t\t\t\t\tgoto ignore;\n\t\t\t\t\t}\n\t\t\tfix = 0;\n\t\t\twhile (fix < tif->tif_nfields &&\n\t\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\t\tfix++;\n\t\t}\n\t\t\n\n\n\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\n\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t\n\t\t\t\tbreak;\n\t\t\tfip = tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t\n\n\n\t\tif (fip->field_readcount != TIFF_VARIABLE\n\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t\n\n\n\n\n\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t\telse\n\t\t\t\t\tcompressionknown = 1;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t} else if (dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv)\n\t\t\t\t    || !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\tcase TIFFTAG_TILELENGTH:\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\n\n\n\n\n\n\n\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t    (td->td_planarconfig==PLANARCONFIG_SEPARATE)) {\n\t\tdp = TIFFReadDirectoryFind(dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\tdp = TIFFReadDirectoryFind(dir, dircount,\n\t\t\t\t\t\t   TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\t\ttd->td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t\"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\n\n\tif (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {\n\t\tMissingRequired(tif, \"ImageLength\");\n\t\tgoto bad;\n\t}\n\t\n\n\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttd->td_nstrips = TIFFNumberOfStrips(tif);\n\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\ttd->td_tilelength = td->td_rowsperstrip;\n\t\ttd->td_tiledepth = td->td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttd->td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero number of %s\",\n\t\t\t     tif->tif_name, isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttd->td_stripsperimage = td->td_nstrips;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttd->td_stripsperimage /= td->td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n\t\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (td->td_nstrips==1)) {\n\t\t\t\n\n\n\n\n\n\n\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t\n\n\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\tcase TIFFTAG_DATATYPE:\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t\n\t\t\t} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE\n\t\t\t\t   && dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t{\n\t\t\t\tdouble dv = 0.0;\n\t\t\t\tif (!TIFFFetchPerSampleAnys(tif, dp, &dv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, dv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripoffset))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripbytecount))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t{\n\t\t\t\tchar* cp;\n\t\t\t\t\n\n\n\n\n\t\t\t\tv = 1L<<td->td_bitspersample;\n\t\t\t\tif (dp->tdir_tag == TIFFTAG_COLORMAP ||\n\t\t\t\t    dp->tdir_count != v) {\n\t\t\t\t\tif (!CheckDirCount(tif, dp, 3 * v))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv *= sizeof(uint16);\n\t\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t\t\t\t\t      dp->tdir_count,\n\t\t\t\t\t\t\t      sizeof (uint16),\n\t\t\t\t\t\"to read \\\"TransferFunction\\\" tag\");\n\t\t\t\tif (cp != NULL) {\n\t\t\t\t\tif (TIFFFetchData(tif, dp, cp)) {\n\t\t\t\t\t\t\n\n\n\n\n\t\t\t\t\t\tuint32 c = 1L << td->td_bitspersample;\n\t\t\t\t\t\tif (dp->tdir_count == c)\n\t\t\t\t\t\t\tv = 0L;\n\t\t\t\t\t\tTIFFSetField(tif, dp->tdir_tag,\n\t\t\t\t\t\t    cp, cp+v, cp+2*v);\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(cp);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\tcase TIFFTAG_DOTRANGE:\n\t\t\t(void) TIFFFetchShortPair(tif, dp);\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t(void) TIFFFetchRefBlackWhite(tif, dp);\n\t\t\tbreak;\n\n\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\tv = 0L;\n\t\t\tswitch (TIFFExtractData(tif, dp->tdir_type,\n\t\t\t    dp->tdir_offset)) {\n\t\t\tcase OFILETYPE_REDUCEDIMAGE:\n\t\t\t\tv = FILETYPE_REDUCEDIMAGE;\n\t\t\t\tbreak;\n\t\t\tcase OFILETYPE_PAGE:\n\t\t\t\tv = FILETYPE_PAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v)\n\t\t\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, v);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) TIFFFetchNormalTag(tif, dp);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tif (td->td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (td->td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttd->td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag value assumed incorrect, \"\n\t\t\t\"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,\"TIFFReadDirectory\",\n\t\t\"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif ((td->td_photometric==PHOTOMETRIC_RGB)\n\t\t\t    || (td->td_photometric==PHOTOMETRIC_YCBCR))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((td->td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (td->td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"assuming correct SamplesPerPixel value is 1\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\n\tif (td->td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tMissingRequired(tif, \"Colormap\");\n\t\tgoto bad;\n\t}\n\t\n\n\n\n\n\tif (td->td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t\n\n\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t\n\n\n\n\n\t\t\tif ((td->td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    td->td_nstrips > 1) ||\n\t\t\t    (td->td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     td->td_nstrips != td->td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: TIFF directory is missing required \"\n\t\t\t\t\"\\\"%s\\\" field, calculating from imagelength\",\n\t\t\t\ttif->tif_name,\n\t\t\t\t_TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \\\n\t\t      (td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) )\n\n\t\t} else if (td->td_nstrips == 1\n\t\t\t   && td->td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t\n\n\n\n\n\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Bogus \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t} else if (td->td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && td->td_nstrips > 2\n\t\t\t   && td->td_compression == COMPRESSION_NONE\n\t\t\t   && td->td_stripbytecount[0] != td->td_stripbytecount[1]\n                           && td->td_stripbytecount[0] != 0 \n                           && td->td_stripbytecount[1] != 0 ) {\n\t\t\t\n\n\n\n\n\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Wrong \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t}\n\t}\n\tif (dir) {\n\t\t_TIFFfree((char *)dir);\n\t\tdir = NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t\ttd->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);\n\t\n\n\n\n\t\n\n\n\n\n\tif (td->td_nstrips > 1) {\n\t\ttstrip_t strip;\n\n\t\ttd->td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < td->td_nstrips; strip++) {\n\t\t\tif (td->td_stripoffset[strip - 1] >\n\t\t\t    td->td_stripoffset[strip]) {\n\t\t\t\ttd->td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!TIFFFieldSet(tif, FIELD_COMPRESSION))\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\n\n\n\n\n\n\n\n\n\tif (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE &&\n\t    (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP)\n\t\tChopUpSingleUncompressedStrip(tif);\n\n\t\n\n\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (tstrip_t) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (ttile_t) -1;\n\ttif->tif_tilesize = (tsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero scanline size\",\n\t\t\t     tif->tif_name);\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero tile size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero strip size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}", "bug_type": "cve-2012-2088", "idx": 2}
{"project": "LibTIFF", "target": 0, "func": "static void\ninitImageData (struct image_data *image)\n  {\n  image->xres = 0.0;\n  image->yres = 0.0;\n  image->width = 0;\n  image->length = 0;\n  image->res_unit = RESUNIT_NONE;\n  image->bps = 0;\n  image->spp = 0;\n  image->planar = 0;\n  image->photometric = 0;\n  image->orientation = 0;\n  image->compression = COMPRESSION_NONE;\n  image->adjustments = 0;\n  }\n", "bug_type": null, "idx": 3}
{"project": "LibTIFF", "target": 0, "func": "int\n_TIFFmemcmp(const tdata_t d, const tdata_t s, tsize_t c)\n{\n\tchar* dd = (char*) d;\n\tchar* ss = (char*) s;\n\ttsize_t chunks, chunkd, chunk;\n\tint result;\n\twhile (c > 0) {\n\t\tchunks = 0x10000 - ((uint32) ss & 0xffff);\t\n\t\tchunkd = 0x10000 - ((uint32) dd & 0xffff);\t\n\t\tchunk = c;\t\t\t\t\t\n\t\tif (chunk > chunks)\t\t\t\t\n\t\t\tchunk = chunks;\t\t\t\t\n\t\tif (chunk > chunkd)\n\t\t\tchunk = chunkd;\n\t\tif (chunk > 0xff00)\n\t\t\tchunk = 0xff00;\n\t\tresult = memcmp(dd, ss, chunk);\n\t\tif (result != 0)\n\t\t\treturn (result);\n\t\tdd = (char*) (chunk + (char huge*) dd);\n\t\tss = (char*) (chunk + (char huge*) ss);\n\t\tc -= chunk;\n\t}\n\treturn (0);\n}\n", "bug_type": null, "idx": 4}
{"project": "LibTIFF", "target": 0, "func": "void\nTIFFSwabLong(uint32* lp)\n{\n\tregister unsigned char* cp = (unsigned char*) lp;\n\tunsigned char t;\n\tassert(sizeof(uint32)==4);\n\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\n\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\n}\n", "bug_type": null, "idx": 5}
{"project": "LibTIFF", "target": 1, "func": "\nint\nTIFFFillStrip(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFFillStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = td->td_stripbytecount[strip];\n\t\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %I64u, strip %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %llu, strip %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t    || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t\t\n\n\n\n\n\n\n\n\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {\n\t\t\t\t\n\n\n\n\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %I64u bytes, expected %I64u\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned __int64) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned __int64) bytecount);\n#else\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %llu bytes, expected %llu\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned long long) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned long long) bytecount);\n#endif\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip];\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\n\t\t\t\n\n\n\n\n\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t\n\n\n\n\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold strip %lu\",\n\t\t\t\t\t    (unsigned long) strip);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata,\n\t\t\t\tbytecountm, module) != bytecountm)\n\t\t\t\treturn (0);\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata, bytecountm);\n                }\n\t}\n\treturn (TIFFStartStrip(tif, strip));\n}", "bug_type": "cve-2016-10270", "idx": 6}
{"project": "LibTIFF", "target": 0, "func": "static float\nTIFFFetchRational(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint32 l[2];\n\tfloat v;\n\treturn (!TIFFFetchData(tif, dir, (char *)l) ||\n\t    !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v);\n}\n", "bug_type": null, "idx": 7}
{"project": "LibTIFF", "target": 0, "func": "static void\nwin3ErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tchar e[512] = { '\\0' };\n\tif (module != NULL)\n\t\tstrcat(strcpy(e, module), \":\");\n\tvsprintf(e+strlen(e), fmt, ap);\n\tstrcat(e, \".\");\n\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);\n}\n", "bug_type": null, "idx": 8}
{"project": "LibTIFF", "target": 0, "func": "void\nTIFFReadSeparateTileData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttsize_t rowsize = TIFFTileRowSize(tif);\n\tbuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));\n\tif (buf) {\n\t\tuint32 tw, th, w, h;\n\t\tuint32 row, col;\n\t\ttsample_t s, samplesperpixel;\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tfor (row = 0; row < h; row += th) {\n\t\t\tfor (col = 0; col < w; col += tw) {\n\t\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, s) < 0) {\n\t\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (showdata)\n\t\t\t\t\t\tShowTile(row, col, s, buf, th, rowsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}\n", "bug_type": null, "idx": 9}
{"project": "LibTIFF", "target": 0, "func": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)\n{\n\tstruct jbg_dec_state decoder;\n\tint decodeStatus = 0;\n\tunsigned char* pImage = NULL;\n\t(void) size, (void) s;\n\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\n\t{\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);\n\t}\n\tjbg_dec_init(&decoder);\n#if defined(HAVE_JBG_NEWLEN)\n\tjbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);\n\t\n\n\n\n\n\n\n\n\n\n#endif \n\tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,\n\t\t\t\t  (size_t)tif->tif_rawdatasize, NULL);\n\tif (JBG_EOK != decodeStatus)\n\t{\n\t\t\n\n\n\n\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\n\t\t\t     decodeStatus,\n#if defined(JBG_EN)\n\t\t\t     jbg_strerror(decodeStatus, JBG_EN)\n#else\n\t\t\t     jbg_strerror(decodeStatus)\n#endif\n\t\t\t     );\n\t\treturn 0;\n\t}\n\tpImage = jbg_dec_getimage(&decoder, 0);\n\t_TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));\n\tjbg_dec_free(&decoder);\n\treturn 1;\n}\n", "bug_type": null, "idx": 10}
{"project": "LibTIFF", "target": 0, "func": "static void\nPrintTag(FILE* fd, uint16 tag)\n{\n\tconst struct tagname *tp;\n\tfor (tp = tagnames; tp < &tagnames[NTAGS]; tp++)\n\t\tif (tp->tag == tag) {\n\t\t\tfprintf(fd, \"%s (%u)\", tp->name, tag);\n\t\t\treturn;\n\t\t}\n\tfprintf(fd, \"%u (%#x)\", tag, tag);\n}\n", "bug_type": null, "idx": 11}
{"project": "LibTIFF", "target": 0, "func": "void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz)\n{\n    if( nmemb == 0 || siz == 0 )\n        return ((void *) NULL);\n    return calloc((size_t) nmemb, (size_t)siz);\n}\n", "bug_type": null, "idx": 12}
{"project": "LibTIFF", "target": 0, "func": "static int checkcmap(int n, uint16* r, uint16* g, uint16* b)\n{\n    while (n-- > 0)\n        if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n        return (16);\n    return (8);\n}\n", "bug_type": null, "idx": 13}
{"project": "LibTIFF", "target": 0, "func": "static void\nhorizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op,\n\tuint16 *ToLinear16)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    op[0] = ToLinear16[cr = (wp[0] & mask)];\n\t    op[1] = ToLinear16[cg = (wp[1] & mask)];\n\t    op[2] = ToLinear16[cb = (wp[2] & mask)];\n\t    n -= 3;\n\t    while (n > 0) {\n\t\twp += 3;\n\t\top += 3;\n\t\tn -= 3;\n\t\top[0] = ToLinear16[(cr += wp[0]) & mask];\n\t\top[1] = ToLinear16[(cg += wp[1]) & mask];\n\t\top[2] = ToLinear16[(cb += wp[2]) & mask];\n\t    }\n\t} else if (stride == 4) {\n\t    op[0] = ToLinear16[cr = (wp[0] & mask)];\n\t    op[1] = ToLinear16[cg = (wp[1] & mask)];\n\t    op[2] = ToLinear16[cb = (wp[2] & mask)];\n\t    op[3] = ToLinear16[ca = (wp[3] & mask)];\n\t    n -= 4;\n\t    while (n > 0) {\n\t\twp += 4;\n\t\top += 4;\n\t\tn -= 4;\n\t\top[0] = ToLinear16[(cr += wp[0]) & mask];\n\t\top[1] = ToLinear16[(cg += wp[1]) & mask];\n\t\top[2] = ToLinear16[(cb += wp[2]) & mask];\n\t\top[3] = ToLinear16[(ca += wp[3]) & mask];\n\t    }\n\t} else {\n\t    REPEAT(stride, *op = ToLinear16[*wp&mask]; wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; *op = ToLinear16[*wp&mask]; wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}\n", "bug_type": null, "idx": 14}
{"project": "LibTIFF", "target": 0, "func": "void\nNextProc()\n{\n    PageProc(ButtonNextPage);\n}\n", "bug_type": null, "idx": 15}
{"project": "LibTIFF", "target": 0, "func": "static int extend_mem_file (int fd, int size)\n{\n    void *new_mem;\n    int ret;\n    if ((new_mem = realloc (buf[fd], size)) == (void *) NULL)\n        ret = -1;\n    else\n    {\n        buf[fd] = (char *) new_mem;\n        ret = 0;\n    }\n    return (ret);\n}\n", "bug_type": null, "idx": 16}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\nTIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tuint32 m[2];\n\tassert(value>=0.0);\n\tassert(sizeof(uint32)==4);\n\tif (value<=0.0)\n\t{\n\t\tm[0]=0;\n\t\tm[1]=1;\n\t}\n\telse if (value==(double)(uint32)value)\n\t{\n\t\tm[0]=(uint32)value;\n\t\tm[1]=1;\n\t}\n\telse if (value<1.0)\n\t{\n\t\tm[0]=(uint32)(value*0xFFFFFFFF);\n\t\tm[1]=0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tm[0]=0xFFFFFFFF;\n\t\tm[1]=(uint32)(0xFFFFFFFF/value);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t{\n\t\tTIFFSwabLong(&m[0]);\n\t\tTIFFSwabLong(&m[1]);\n\t}\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));\n}", "bug_type": "cve-2016-10371", "idx": 17}
{"project": "LibTIFF", "target": 0, "func": "static void\ntiffinfo(TIFF* tif, uint16 order, long flags)\n{\n\tTIFFPrintDirectory(tif, stdout, flags);\n\tif (!readdata)\n\t\treturn;\n\tif (rawdata) {\n\t\tif (order) {\n\t\t\tuint16 o;\n\t\t\tTIFFGetFieldDefaulted(tif,\n\t\t\t    TIFFTAG_FILLORDER, &o);\n\t\t\tTIFFReadRawData(tif, o != order);\n\t\t} else\n\t\t\tTIFFReadRawData(tif, 0);\n\t} else {\n\t\tif (order)\n\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, order);\n\t\tTIFFReadData(tif);\n\t}\n}\n", "bug_type": null, "idx": 18}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\nLZWDecodeCompat(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s)\n{\n\tLZWCodecState *sp = DecoderState(tif);\n\tchar *op = (char*) op0;\n\tlong occ = (long) occ0;\n\tchar *tp;\n\tunsigned char *bp;\n\tint code, nbits;\n\tlong nextbits, nextdata, nbitsmask;\n\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\n\n\t(void) s;\n\tassert(sp != NULL);\n\t\n\n\n\tif (sp->dec_restart) {\n\t\tlong residue;\n\n\t\tcodep = sp->dec_codep;\n\t\tresidue = codep->length - sp->dec_restart;\n\t\tif (residue > occ) {\n\t\t\t\n\n\n\n\n\n\t\t\tsp->dec_restart += occ;\n\t\t\tdo {\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--residue > occ);\n\t\t\ttp = op + occ;\n\t\t\tdo {\n\t\t\t\t*--tp = codep->value;\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--occ);\n\t\t\treturn (1);\n\t\t}\n\t\t\n\n\n\t\top += residue, occ -= residue;\n\t\ttp = op;\n\t\tdo {\n\t\t\t*--tp = codep->value;\n\t\t\tcodep = codep->next;\n\t\t} while (--residue);\n\t\tsp->dec_restart = 0;\n\t}\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tnbits = sp->lzw_nbits;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tnbitsmask = sp->dec_nbitsmask;\n\toldcodep = sp->dec_oldcodep;\n\tfree_entp = sp->dec_free_entp;\n\tmaxcodep = sp->dec_maxcodep;\n\n\twhile (occ > 0) {\n\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n\t\tif (code == CODE_EOI)\n\t\t\tbreak;\n\t\tif (code == CODE_CLEAR) {\n\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\n\t\t\tnbits = BITS_MIN;\n\t\t\tnbitsmask = MAXCODE(BITS_MIN);\n\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n\t\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n\t\t\tif (code == CODE_EOI)\n\t\t\t\tbreak;\n\t\t\t*op++ = code, occ--;\n\t\t\toldcodep = sp->dec_codetab + code;\n\t\t\tcontinue;\n\t\t}\n\t\tcodep = sp->dec_codetab + code;\n\n\t\t\n\n\n\t\tif (free_entp < &sp->dec_codetab[0] ||\n\t\t\tfree_entp >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\"LZWDecodeCompat: Corrupted LZW table at scanline %d\",\n\t\t\ttif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\n\t\tfree_entp->next = oldcodep;\n\t\tif (free_entp->next < &sp->dec_codetab[0] ||\n\t\t\tfree_entp->next >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\"LZWDecodeCompat: Corrupted LZW table at scanline %d\",\n\t\t\ttif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\t\tfree_entp->firstchar = free_entp->next->firstchar;\n\t\tfree_entp->length = free_entp->next->length+1;\n\t\tfree_entp->value = (codep < free_entp) ?\n\t\t    codep->firstchar : free_entp->firstchar;\n\t\tif (++free_entp > maxcodep) {\n\t\t\tif (++nbits > BITS_MAX)\t\t\n\t\t\t\tnbits = BITS_MAX;\n\t\t\tnbitsmask = MAXCODE(nbits);\n\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n\t\t}\n\t\toldcodep = codep;\n\t\tif (code >= 256) {\n\t\t\t\n\n\n\n\t\t\tif(codep->length == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t    \t\t    \"LZWDecodeCompat: Wrong length of decoded \"\n\t\t\t    \"string: data probably corrupted at scanline %d\",\n\t\t\t    tif->tif_row);\t\n\t\t\t    return (0);\n\t\t\t}\n\t\t\tif (codep->length > occ) {\n\t\t\t\t\n\n\n\n\n\n\t\t\t\tsp->dec_codep = codep;\n\t\t\t\tdo {\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (codep->length > occ);\n\t\t\t\tsp->dec_restart = occ;\n\t\t\t\ttp = op + occ;\n\t\t\t\tdo  {\n\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t}  while (--occ);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\top += codep->length, occ -= codep->length;\n\t\t\ttp = op;\n\t\t\tdo {\n\t\t\t\t*--tp = codep->value;\n\t\t\t} while( (codep = codep->next) != NULL);\n\t\t} else\n\t\t\t*op++ = code, occ--;\n\t}\n\n\ttif->tif_rawcp = (tidata_t) bp;\n\tsp->lzw_nbits = nbits;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->dec_nbitsmask = nbitsmask;\n\tsp->dec_oldcodep = oldcodep;\n\tsp->dec_free_entp = free_entp;\n\tsp->dec_maxcodep = maxcodep;\n\n\tif (occ > 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t    \"LZWDecodeCompat: Not enough data at scanline %d (short %d bytes)\",\n\t\t    tif->tif_row, occ);\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "bug_type": "cve-2009-2285", "idx": 19}
{"project": "LibTIFF", "target": 0, "func": "static int\nprocessCropSelections(struct image_data *image, struct crop_mask *crop, \n                      unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n  {\n  int       i;\n  uint32    width, length, total_width, total_length;\n  tsize_t   cropsize;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *next_buff = NULL;\n  tsize_t   prev_cropsize = 0;\n  read_buff = *read_buff_ptr;\n  if (crop->img_mode == COMPOSITE_IMAGES)\n    {\n    cropsize = crop->bufftotal;\n    crop_buff = seg_buffs[0].buffer; \n    if (!crop_buff)\n      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n    else\n      {\n      prev_cropsize = seg_buffs[0].size;\n      if (prev_cropsize < cropsize)\n        {\n        next_buff = _TIFFrealloc(crop_buff, cropsize);\n        if (! next_buff)\n          {\n          _TIFFfree (crop_buff);\n          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n          }\n        else\n          crop_buff = next_buff;\n        }\n      }\n    if (!crop_buff)\n      {\n      TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n      return (-1);\n      }\n    _TIFFmemset(crop_buff, 0, cropsize);\n    seg_buffs[0].buffer = crop_buff;\n    seg_buffs[0].size = cropsize;\n    \n    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n      return (1);\n    if (crop->crop_mode & CROP_INVERT)\n      {\n      switch (crop->photometric)\n        {\n        \n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n\t     image->photometric = crop->photometric;\n\t     break;\n        case INVERT_DATA_ONLY:\n        case INVERT_DATA_AND_TAG:\n             if (invertImage(image->photometric, image->spp, image->bps, \n                             crop->combined_width, crop->combined_length, crop_buff))\n               {\n               TIFFError(\"processCropSelections\", \n                         \"Failed to invert colorspace for composite regions\");\n               return (-1);\n               }\n             if (crop->photometric == INVERT_DATA_AND_TAG)\n               {\n               switch (image->photometric)\n                 {\n                 case PHOTOMETRIC_MINISWHITE:\n \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n\t              break;\n                 case PHOTOMETRIC_MINISBLACK:\n \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n\t              break;\n                 default:\n\t              break;\n\t         }\n\t       }\n             break;\n        default: break;\n        }\n      }\n    \n    if (crop->crop_mode & CROP_MIRROR)\n      {\n      if (mirrorImage(image->spp, image->bps, crop->mirror, \n                      crop->combined_width, crop->combined_length, crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \"Failed to mirror composite regions %s\", \n\t         (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n        return (-1);\n        }\n      }\n    if (crop->crop_mode & CROP_ROTATE) \n      {\n      if (rotateImage(crop->rotation, image, &crop->combined_width, \n                      &crop->combined_length, &crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \n                  \"Failed to rotate composite regions by %d degrees\", crop->rotation);\n        return (-1);\n        }\n      seg_buffs[0].buffer = crop_buff;\n      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n                            * image->spp) * crop->combined_length; \n      }\n    }\n  else  \n    {\n    total_width = total_length = 0;\n    for (i = 0; i < crop->selections; i++)\n      {\n      cropsize = crop->bufftotal;\n      crop_buff = seg_buffs[i].buffer; \n      if (!crop_buff)\n        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n      else\n        {\n        prev_cropsize = seg_buffs[0].size;\n        if (prev_cropsize < cropsize)\n          {\n          next_buff = _TIFFrealloc(crop_buff, cropsize);\n          if (! next_buff)\n            {\n            _TIFFfree (crop_buff);\n            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n            }\n          else\n            crop_buff = next_buff;\n          }\n        }\n      if (!crop_buff)\n        {\n        TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n        }\n      _TIFFmemset(crop_buff, 0, cropsize);\n      seg_buffs[i].buffer = crop_buff;\n      seg_buffs[i].size = cropsize;\n      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n        {\n\tTIFFError(\"processCropSelections\", \"Unable to extract cropped region %d from image\", i);\n        return (-1);\n        }\n      width  = crop->regionlist[i].width;\n      length = crop->regionlist[i].length;\n      if (crop->crop_mode & CROP_INVERT)\n        {\n        switch (crop->photometric)\n          {\n          \n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n\t       image->photometric = crop->photometric;\n\t       break;\n          case INVERT_DATA_ONLY:\n          case INVERT_DATA_AND_TAG:\n               if (invertImage(image->photometric, image->spp, image->bps, \n                               width, length, crop_buff))\n                 {\n                 TIFFError(\"processCropSelections\", \n                           \"Failed to invert colorspace for region\");\n                 return (-1);\n                 }\n               if (crop->photometric == INVERT_DATA_AND_TAG)\n                 {\n                 switch (image->photometric)\n                   {\n                   case PHOTOMETRIC_MINISWHITE:\n \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n\t                break;\n                   case PHOTOMETRIC_MINISBLACK:\n \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n\t                break;\n                   default:\n\t                break;\n\t           }\n\t         }\n               break;\n          default: break;\n          }\n        }\n      if (crop->crop_mode & CROP_MIRROR)\n        {\n        if (mirrorImage(image->spp, image->bps, crop->mirror, \n                        width, length, crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \"Failed to mirror crop region %s\", \n\t           (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n          return (-1);\n          }\n        }\n      if (crop->crop_mode & CROP_ROTATE) \n        {\n\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n\t\t\t&crop->regionlist[i].length, &crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \n                    \"Failed to rotate crop region by %d degrees\", crop->rotation);\n          return (-1);\n          }\n        total_width  += crop->regionlist[i].width;\n        total_length += crop->regionlist[i].length;\n        crop->combined_width = total_width;\n        crop->combined_length = total_length;\n        seg_buffs[i].buffer = crop_buff;\n        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n                               * image->spp) * crop->regionlist[i].length; \n        }\n      }\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 20}
{"project": "LibTIFF", "target": 0, "func": "DECLAREreadFunc(readSeparateTilesIntoBuffer)\n{\n\tint status = 1;\n\tuint32 imagew = TIFFRasterScanlineSize(in);\n\tuint32 tilew = TIFFTileRowSize(in);\n\tint iskew  = imagew - tilew*spp;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\tuint16 bps = 0, bytes_per_sample;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps == 0 )\n        {\n            TIFFError(TIFFFileName(in), \"Error, cannot read BitsPerSample\");\n            status = 0;\n            goto done;\n        }\n        if( (bps % 8) != 0 )\n        {\n            TIFFError(TIFFFileName(in), \"Error, cannot handle BitsPerSample that is not a multiple of 8\");\n            status = 0;\n            goto done;\n        }\n\tbytes_per_sample = bps/8;\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\ttsample_t s;\n\t\t\tfor (s = 0; s < spp; s++) {\n\t\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0\n\t\t\t\t    && !ignore) {\n\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t    \"Error, can't read tile at %lu %lu, \"\n\t\t\t\t\t    \"sample %lu\",\n\t\t\t\t\t    (unsigned long) col,\n\t\t\t\t\t    (unsigned long) row,\n\t\t\t\t\t    (unsigned long) s);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t\n\n\n\n\t\t\t\tif (colb + tilew*spp > imagew) {\n\t\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\t\tint oskew = tilew*spp - width;\n\t\t\t\t\tcpSeparateBufToContigBuf(\n\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\n\t\t\t\t\t    tilebuf, nrow,\n\t\t\t\t\t    width/(spp*bytes_per_sample),\n\t\t\t\t\t    oskew + iskew,\n\t\t\t\t\t    oskew/spp, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t\t} else\n\t\t\t\t\tcpSeparateBufToContigBuf(\n\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\n\t\t\t\t\t    tilebuf, nrow, tw,\n\t\t\t\t\t    iskew, 0, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t}\n\t\t\tcolb += tilew*spp;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}\n", "bug_type": null, "idx": 21}
{"project": "LibTIFF", "target": 0, "func": "static int\ncombineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n                                 uint32 rows, uint32 imagewidth, \n                                 uint32 tw, uint16 spp, uint16 bps, \n \t                         FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize, src_offset; \n  uint32 bit_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[32];\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      \n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n      matchbits = maskbits << (8 - src_bit - bps); \n      \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        buff1 = ((*src) & matchbits) << (src_bit);\n        \n        if (ready_bits >= 8)\n          {\n          *dst++ = buff2;\n          buff2 = buff1;\n          ready_bits -= 8;\n          strcpy (action, \"Flush\");\n          }\n        else\n          {\n          buff2 = (buff2 | (buff1 >> ready_bits));\n          strcpy (action, \"Update\");\n          }\n        ready_bits += bps;\n        if ((dumpfile != NULL) && (level == 3))\n          {\n          dump_info (dumpfile, format, \"\",\n                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n          dump_byte (dumpfile, format, \"Match bits\", matchbits);\n          dump_byte (dumpfile, format, \"Src   bits\", *src);\n          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);\n          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);\n          dump_info (dumpfile, format, \"\",\"%s\", action); \n\t  }\n        }\n      }\n    if (ready_bits > 0)\n      {\n      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n      *dst++ = buff1;\n      if ((dumpfile != NULL) && (level == 3))\n        {\n        dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                 dump_byte (dumpfile, format, \"Final bits\", buff1);\n        }\n      }\n    if ((dumpfile != NULL) && (level >= 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples8bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 22}
{"project": "LibTIFF", "target": 0, "func": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}\n", "bug_type": null, "idx": 23}
{"project": "LibTIFF", "target": 0, "func": "TIFFCodec*\nTIFFGetConfiguredCODECs()\n{\n\tint\t\ti = 1;\n        codec_t\t\t*cd;\n        const TIFFCodec\t*c;\n\tTIFFCodec\t*codecs = NULL, *new_codecs;\n        for (cd = registeredCODECS; cd; cd = cd->next) {\n                new_codecs = (TIFFCodec *)\n\t\t\t_TIFFrealloc(codecs, i * sizeof(TIFFCodec));\n\t\tif (!new_codecs) {\n\t\t\t_TIFFfree (codecs);\n\t\t\treturn NULL;\n\t\t}\n\t\tcodecs = new_codecs;\n\t\t_TIFFmemcpy(codecs + i - 1, cd, sizeof(TIFFCodec));\n\t\ti++;\n\t}\n        for (c = _TIFFBuiltinCODECS; c->name; c++) {\n                if (TIFFIsCODECConfigured(c->scheme)) {\n                        new_codecs = (TIFFCodec *)\n\t\t\t\t_TIFFrealloc(codecs, i * sizeof(TIFFCodec));\n\t\t\tif (!new_codecs) {\n\t\t\t\t_TIFFfree (codecs);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcodecs = new_codecs;\n\t\t\t_TIFFmemcpy(codecs + i - 1, (const tdata_t)c, sizeof(TIFFCodec));\n\t\t\ti++;\n\t\t}\n\t}\n\tnew_codecs = (TIFFCodec *) _TIFFrealloc(codecs, i * sizeof(TIFFCodec));\n\tif (!new_codecs) {\n\t\t_TIFFfree (codecs);\n\t\treturn NULL;\n\t}\n\tcodecs = new_codecs;\n\t_TIFFmemset(codecs + i - 1, 0, sizeof(TIFFCodec));\n        return codecs;\n}\n", "bug_type": null, "idx": 24}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif( fip == NULL ) \n\t    return 0;\n\t\n\t\n\n\n\n\n\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t\n\n\n\n\n\n\n\n\n\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip->field_name);\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t\n\n\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  \n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t\n\n\n\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}", "bug_type": "cve-2015-7554", "idx": 25}
{"project": "LibTIFF", "target": 0, "func": "int\nwrite_strips(TIFF *tif, const tdata_t array, const tsize_t size)\n{\n\ttstrip_t\tstrip, nstrips;\n\ttsize_t\t\tstripsize, offset;\n\tstripsize = TIFFStripSize(tif);\n\tif (!stripsize) {\n\t\tfprintf (stderr, \"Wrong size of strip.\\n\");\n\t\treturn -1;\n\t}\n\tnstrips = TIFFNumberOfStrips(tif);\n\tfor (offset = 0, strip = 0;\n\t     offset < size && strip < nstrips;\n\t     offset+=stripsize, strip++) {\n\t\t\n\n\n\t\ttsize_t\tbufsize = size - offset;\n\t\tif (bufsize > stripsize)\n\t\t\tbufsize = stripsize;\n\t\tif (TIFFWriteEncodedStrip(tif, strip, (char *)array + offset,\n\t\t\t\t\t  bufsize) != bufsize) {\n\t\t\tfprintf (stderr, \"Can't write strip %lu.\\n\",\n\t\t\t\t (unsigned long)strip);\n\t\t\treturn -1;\n\t\t}\n        }\n\treturn 0;\n}\n", "bug_type": null, "idx": 26}
{"project": "LibTIFF", "target": 0, "func": "void\nTIFFReadSeparateStripData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttsize_t scanline = TIFFScanlineSize(tif);\n\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\n\tif (buf) {\n\t\tuint32 row, h;\n\t\tuint32 rowsperstrip = (uint32)-1;\n\t\ttsample_t s, samplesperpixel;\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tfor (row = 0; row < h; row += rowsperstrip) {\n\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\tuint32 nrow = (row+rowsperstrip > h ?\n\t\t\t\t    h-row : rowsperstrip);\n\t\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, s);\n\t\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\n\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (showdata)\n\t\t\t\t\tShowStrip(strip, buf, nrow, scanline);\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}\n", "bug_type": null, "idx": 27}
{"project": "LibTIFF", "target": 1, "func": " \nstatic int\nTIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint32 l[2];\n\tfloat v;\n\tint ok = 0;\n\n\tif (TIFFFetchData(tif, dir, (char *)l)\n\t    && cvtRational(tif, dir, l[0], l[1], &v)) {\n\t\t\n\n\n\n\n\t\tok = TIFFSetField(tif, dir->tdir_tag,\n\t\t\t\t  (l[0] != 0xFFFFFFFF) ? v : -v);\n\t}\n\n\treturn ok;\n}", "bug_type": "cve-2010-2067", "idx": 28}
{"project": "LibTIFF", "target": 0, "func": "static int\nPredictorSetupEncode(TIFF* tif)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\tif (!(*sp->setupencode)(tif) || !PredictorSetup(tif))\n\t\treturn 0;\n\tif (sp->predictor == 2) {\n\t\tswitch (td->td_bitspersample) {\n\t\t\tcase 8:  sp->encodepfunc = horDiff8; break;\n\t\t\tcase 16: sp->encodepfunc = horDiff16; break;\n\t\t\tcase 32: sp->encodepfunc = horDiff32; break;\n\t\t}\n\t\t\n\n\n\n                if( tif->tif_encoderow != PredictorEncodeRow )\n                {\n                    sp->encoderow = tif->tif_encoderow;\n                    tif->tif_encoderow = PredictorEncodeRow;\n                    sp->encodestrip = tif->tif_encodestrip;\n                    tif->tif_encodestrip = PredictorEncodeTile;\n                    sp->encodetile = tif->tif_encodetile;\n                    tif->tif_encodetile = PredictorEncodeTile;\n                }\n                \n\n\n\n\n\n\n                if (tif->tif_flags & TIFF_SWAB) {\n                    if (sp->encodepfunc == horDiff16) {\n                            sp->encodepfunc = swabHorDiff16;\n                            tif->tif_postdecode = _TIFFNoPostDecode;\n                    } else if (sp->encodepfunc == horDiff32) {\n                            sp->encodepfunc = swabHorDiff32;\n                            tif->tif_postdecode = _TIFFNoPostDecode;\n                    }\n                }\n        }\n\telse if (sp->predictor == 3) {\n\t\tsp->encodepfunc = fpDiff;\n\t\t\n\n\n\n                if( tif->tif_encoderow != PredictorEncodeRow )\n                {\n                    sp->encoderow = tif->tif_encoderow;\n                    tif->tif_encoderow = PredictorEncodeRow;\n                    sp->encodestrip = tif->tif_encodestrip;\n                    tif->tif_encodestrip = PredictorEncodeTile;\n                    sp->encodetile = tif->tif_encodetile;\n                    tif->tif_encodetile = PredictorEncodeTile;\n                }\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 29}
{"project": "LibTIFF", "target": 0, "func": "void\n_TIFFfree(tdata_t p)\n{\n\tfree(p);\n}\n", "bug_type": null, "idx": 30}
{"project": "LibTIFF", "target": 0, "func": "static int\nTIFFAdvanceDirectory(TIFF* tif, uint32* nextdir, toff_t* off)\n{\n    static const char module[] = \"TIFFAdvanceDirectory\";\n    uint16 dircount;\n    if (isMapped(tif))\n    {\n        toff_t poff=*nextdir;\n        if (poff+sizeof(uint16) > tif->tif_size)\n        {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n                      tif->tif_name);\n            return (0);\n        }\n        _TIFFmemcpy(&dircount, tif->tif_base+poff, sizeof (uint16));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabShort(&dircount);\n        poff+=sizeof (uint16)+dircount*sizeof (TIFFDirEntry);\n        if (off != NULL)\n            *off = poff;\n        if (((toff_t) (poff+sizeof (uint32))) > tif->tif_size)\n        {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\",\n                      tif->tif_name);\n            return (0);\n        }\n        _TIFFmemcpy(nextdir, tif->tif_base+poff, sizeof (uint32));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong(nextdir);\n        return (1);\n    }\n    else\n    {\n        if (!SeekOK(tif, *nextdir) ||\n            !ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n                      tif->tif_name);\n            return (0);\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabShort(&dircount);\n        if (off != NULL)\n            *off = TIFFSeekFile(tif,\n                                dircount*sizeof (TIFFDirEntry), SEEK_CUR);\n        else\n            (void) TIFFSeekFile(tif,\n                                dircount*sizeof (TIFFDirEntry), SEEK_CUR);\n        if (!ReadOK(tif, nextdir, sizeof (uint32))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\",\n                      tif->tif_name);\n            return (0);\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong(nextdir);\n        return (1);\n    }\n}\n", "bug_type": null, "idx": 31}
{"project": "LibTIFF", "target": 0, "func": "static void\nprintruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)\n{\n    static struct {\n\tchar white, black;\n\tunsigned short width;\n    } WBarr[] = {\n\t{ 'd', 'n', 512 }, { 'e', 'o', 256 }, { 'f', 'p', 128 },\n\t{ 'g', 'q',  64 }, { 'h', 'r',  32 }, { 'i', 's',  16 },\n\t{ 'j', 't',   8 }, { 'k', 'u',   4 }, { 'l', 'v',   2 },\n\t{ 'm', 'w',   1 }\n    };\n    static char* svalue =\n\t\" !\\\"#$&'*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abc\";\n    int colormode = 1;\t\t\n    uint32 runlength = 0;\n    int n = maxline;\n    uint32 x = 0;\n    int l;\n    (void) buf;\n    printf(\"%d m(\", row++);\n    while (runs < erun) {\n\tif (runlength <= 0) {\n\t    colormode ^= 1;\n\t    runlength = *runs++;\n\t    if (x+runlength > lastx)\n\t\trunlength = runs[-1] = lastx-x;\n\t    x += runlength;\n\t    if (!colormode && runs == erun)\t\n\t\tbreak;\t\t\n\t}\n\t\n\n\n\n\n\n\n\n\n\n\tl = 0;\n\twhile (runlength > 6) {\t\n\t    if (runlength >= WBarr[l].width) {\n\t\tif (n == 0) {\n\t\t    putchar('\\n');\n\t\t    n = maxline;\n\t\t}\n\t\tputchar(colormode ? WBarr[l].black : WBarr[l].white), n--;\n\t\trunlength -= WBarr[l].width;\n\t    } else\n\t\tl++;\n\t}\n\twhile (runlength > 0 && runlength <= 6) {\n\t    uint32 bitsleft = 6;\n\t    int t = 0;\n\t    while (bitsleft) {\n\t\tif (runlength <= bitsleft) {\n\t\t    if (colormode)\n\t\t\tt |= ((1 << runlength)-1) << (bitsleft-runlength);\n\t\t    bitsleft -= runlength;\n\t\t    runlength = 0;\n\t\t    if (bitsleft) {\n\t\t\tif (runs >= erun)\n\t\t\t    break;\n\t\t\tcolormode ^= 1;\n\t\t\trunlength = *runs++;\n\t\t\tif (x+runlength > lastx)\n\t\t\t    runlength = runs[-1] = lastx-x;\n\t\t\tx += runlength;\n\t\t    }\n\t\t} else {\t\t\n\t\t    if (colormode)\n\t\t\tt |= ((1 << bitsleft)-1);\n\t\t    runlength -= bitsleft;\n\t\t    bitsleft = 0;\n\t\t}\n\t    }\n\t    if (n == 0) {\n\t\tputchar('\\n');\n\t\tn = maxline;\n\t    }\n\t    putchar(svalue[t]), n--;\n\t}\n    }\n    printf(\")s\\n\");\n}\n", "bug_type": null, "idx": 32}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\nLZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tregister LZWCodecState *sp = EncoderState(tif);\n\tregister long fcode;\n\tregister hash_t *hp;\n\tregister int h, c;\n\thcode_t ent;\n\tlong disp;\n\tlong incount, outcount, checkpoint;\n\tunsigned long nextdata;\n        long nextbits;\n\tint free_ent, maxcode, nbits;\n\tuint8* op;\n\tuint8* limit;\n\n\t(void) s;\n\tif (sp == NULL)\n\t\treturn (0);\n\n        assert(sp->enc_hashtab != NULL);\n\n\t\n\n\n\tincount = sp->enc_incount;\n\toutcount = sp->enc_outcount;\n\tcheckpoint = sp->enc_checkpoint;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tfree_ent = sp->lzw_free_ent;\n\tmaxcode = sp->lzw_maxcode;\n\tnbits = sp->lzw_nbits;\n\top = tif->tif_rawcp;\n\tlimit = sp->enc_rawlimit;\n\tent = sp->enc_oldcode;\n\n\tif (ent == (hcode_t) -1 && cc > 0) {\n\t\t\n\n\n\n\n\t\tPutNextCode(op, CODE_CLEAR);\n\t\tent = *bp++; cc--; incount++;\n\t}\n\twhile (cc > 0) {\n\t\tc = *bp++; cc--; incount++;\n\t\tfcode = ((long)c << BITS_MAX) + ent;\n\t\th = (c << HSHIFT) ^ ent;\t\n#ifdef _WINDOWS\n\t\t\n\n\n\t\tif (h >= HSIZE)\n\t\t\th -= HSIZE;\n#endif\n\t\thp = &sp->enc_hashtab[h];\n\t\tif (hp->hash == fcode) {\n\t\t\tent = hp->code;\n\t\t\tcontinue;\n\t\t}\n\t\tif (hp->hash >= 0) {\n\t\t\t\n\n\n\t\t\tdisp = HSIZE - h;\n\t\t\tif (h == 0)\n\t\t\t\tdisp = 1;\n\t\t\tdo {\n\t\t\t\t\n\n\n\n\t\t\t\tif ((h -= disp) < 0)\n\t\t\t\t\th += HSIZE;\n\t\t\t\thp = &sp->enc_hashtab[h];\n\t\t\t\tif (hp->hash == fcode) {\n\t\t\t\t\tent = hp->code;\n\t\t\t\t\tgoto hit;\n\t\t\t\t}\n\t\t\t} while (hp->hash >= 0);\n\t\t}\n\t\t\n\n\n\t\t\n\n\n\n\n\n\t\tif (op > limit) {\n\t\t\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n\t\t\tTIFFFlushData1(tif);\n\t\t\top = tif->tif_rawdata;\n\t\t}\n\t\tPutNextCode(op, ent);\n\t\tent = c;\n\t\thp->code = free_ent++;\n\t\thp->hash = fcode;\n\t\tif (free_ent == CODE_MAX-1) {\n\t\t\t\n\t\t\tcl_hash(sp);\n\t\t\tsp->enc_ratio = 0;\n\t\t\tincount = 0;\n\t\t\toutcount = 0;\n\t\t\tfree_ent = CODE_FIRST;\n\t\t\tPutNextCode(op, CODE_CLEAR);\n\t\t\tnbits = BITS_MIN;\n\t\t\tmaxcode = MAXCODE(BITS_MIN);\n\t\t} else {\n\t\t\t\n\n\n\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tnbits++;\n\t\t\t\tassert(nbits <= BITS_MAX);\n\t\t\t\tmaxcode = (int) MAXCODE(nbits);\n\t\t\t} else if (incount >= checkpoint) {\n\t\t\t\tlong rat;\n\t\t\t\t\n\n\n\n\n\n\t\t\t\tcheckpoint = incount+CHECK_GAP;\n\t\t\t\tCALCRATIO(sp, rat);\n\t\t\t\tif (rat <= sp->enc_ratio) {\n\t\t\t\t\tcl_hash(sp);\n\t\t\t\t\tsp->enc_ratio = 0;\n\t\t\t\t\tincount = 0;\n\t\t\t\t\toutcount = 0;\n\t\t\t\t\tfree_ent = CODE_FIRST;\n\t\t\t\t\tPutNextCode(op, CODE_CLEAR);\n\t\t\t\t\tnbits = BITS_MIN;\n\t\t\t\t\tmaxcode = MAXCODE(BITS_MIN);\n\t\t\t\t} else\n\t\t\t\t\tsp->enc_ratio = rat;\n\t\t\t}\n\t\t}\n\thit:\n\t\t;\n\t}\n\n\t\n\n\n\tsp->enc_incount = incount;\n\tsp->enc_outcount = outcount;\n\tsp->enc_checkpoint = checkpoint;\n\tsp->enc_oldcode = ent;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->lzw_free_ent = free_ent;\n\tsp->lzw_maxcode = maxcode;\n\tsp->lzw_nbits = nbits;\n\ttif->tif_rawcp = op;\n\treturn (1);\n}", "bug_type": "cve-2016-3621", "idx": 33}
{"project": "LibTIFF", "target": 0, "func": "static tsize_t\n_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\tDWORD dwSizeRead;\n\tif (!ReadFile(fd, buf, size, &dwSizeRead, NULL))\n\t\treturn(0);\n\treturn ((tsize_t) dwSizeRead);\n}\n", "bug_type": null, "idx": 34}
{"project": "LibTIFF", "target": 0, "func": "\nint sindex(char ch,char *string)\n{\n  char *cp;\n  for(cp=string;*cp;++cp)\n    if(ch==*cp)\n      return (int)(cp-string);\t\n  return -1;\t\t\t\n}\n", "bug_type": null, "idx": 35}
{"project": "LibTIFF", "target": 0, "func": "static void\nhorizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)\n{\n    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;\n    float fltsize = Fltsize;\n#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\n\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\n\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\n\t\t  : LogK1*log(v*LogK2) + 0.5 )\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}\n", "bug_type": null, "idx": 36}
{"project": "LibTIFF", "target": 0, "func": "static void\nhorizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op,\n\tfloat *ToLinearF)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n    register float  t0, t1, t2, t3;\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;\n\t    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;\n\t    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;\n\t    op[0] = CLAMP12(t0);\n\t    op[1] = CLAMP12(t1);\n\t    op[2] = CLAMP12(t2);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\twp += 3;\n\t\top += 3;\n\t\tn -= 3;\n\t\tt0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;\n\t\tt1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;\n\t\tt2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;\n\t\top[0] = CLAMP12(t0);\n\t\top[1] = CLAMP12(t1);\n\t\top[2] = CLAMP12(t2);\n\t    }\n\t} else if (stride == 4) {\n\t    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;\n\t    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;\n\t    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;\n\t    t3 = ToLinearF[ca = (wp[3] & mask)] * SCALE12;\n\t    op[0] = CLAMP12(t0);\n\t    op[1] = CLAMP12(t1);\n\t    op[2] = CLAMP12(t2);\n\t    op[3] = CLAMP12(t3);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\twp += 4;\n\t\top += 4;\n\t\tn -= 4;\n\t\tt0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;\n\t\tt1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;\n\t\tt2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;\n\t\tt3 = ToLinearF[(ca += wp[3]) & mask] * SCALE12;\n\t\top[0] = CLAMP12(t0);\n\t\top[1] = CLAMP12(t1);\n\t\top[2] = CLAMP12(t2);\n\t\top[3] = CLAMP12(t3);\n\t    }\n\t} else {\n\t    REPEAT(stride, t0 = ToLinearF[*wp&mask] * SCALE12;\n                           *op = CLAMP12(t0); wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; t0 = ToLinearF[wp[stride]&mask]*SCALE12;\n\t\t    *op = CLAMP12(t0);  wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}\n", "bug_type": null, "idx": 37}
{"project": "LibTIFF", "target": 0, "func": "void *\nlfind(const void *key, const void *base, size_t *nmemb, size_t size,\n      int(*compar)(const void *, const void *))\n{\n\tchar *element, *end;\n\tend = (char *)base + *nmemb * size;\n\tfor (element = (char *)base; element < end; element += size)\n\t\tif (!compar(element, key))\t\t\n\t\t\treturn element;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 38}
{"project": "LibTIFF", "target": 0, "func": "static void\nPixarLogClose(TIFF* tif)\n{\n        PixarLogState* sp = (PixarLogState*) tif->tif_data;\n\tTIFFDirectory *td = &tif->tif_dir;\n\tassert(sp != 0);\n\t\n\n\n\n\n\n\n\n        if (sp->state&PLSTATE_INIT) {\n            \n\n\n\n\n\n\n\n            td->td_bitspersample = 8;\n            td->td_sampleformat = SAMPLEFORMAT_UINT;\n        }\n}\n", "bug_type": null, "idx": 39}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\nTIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSubifd\";\n\tuint64 m;\n\tint n;\n\tif (tif->tif_dir.td_nsubifd==0)\n\t\treturn(1);\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=tif->tif_dataoff;\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint32* o;\n\t\tuint64* pa;\n\t\tuint32* pb;\n\t\tuint16 p;\n\t\to=_TIFFmalloc(tif->tif_dir.td_nsubifd*sizeof(uint32));\n\t\tif (o==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\tpa=tif->tif_dir.td_subifd;\n\t\tpb=o;\n\t\tfor (p=0; p < tif->tif_dir.td_nsubifd; p++)\n\t\t{\n                        assert(pa != 0);\n\t\t\tassert(*pa <= 0xFFFFFFFFUL);\n\t\t\t*pb++=(uint32)(*pa++);\n\t\t}\n\t\tn=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,o);\n\t\t_TIFFfree(o);\n\t}\n\telse\n\t\tn=TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,tif->tif_dir.td_subifd);\n\tif (!n)\n\t\treturn(0);\n\t\n\n\n\n\n\n\n\n\ttif->tif_flags|=TIFF_INSUBIFD;\n\ttif->tif_nsubifd=tif->tif_dir.td_nsubifd;\n\tif (tif->tif_dir.td_nsubifd==1)\n\t\ttif->tif_subifdoff=0;\n\telse\n\t\ttif->tif_subifdoff=m;\n\treturn(1);\n}", "bug_type": "cve-2017-13727", "idx": 40}
{"project": "LibTIFF", "target": 0, "func": "static void\nquant_fsdither(TIFF* in, TIFF* out)\n{\n\tunsigned char *outline, *inputline, *inptr;\n\tshort *thisline, *nextline;\n\tregister unsigned char\t*outptr;\n\tregister short *thisptr, *nextptr;\n\tregister uint32 i, j;\n\tuint32 imax, jmax;\n\tint lastline, lastpixel;\n\timax = imagelength - 1;\n\tjmax = imagewidth - 1;\n\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\tthisline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short));\n\tnextline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short));\n\toutline = (unsigned char *) _TIFFmalloc(TIFFScanlineSize(out));\n\tGetInputLine(in, 0, goto bad);\t\t\n\tfor (i = 1; i <= imagelength; ++i) {\n\t\tSWAP(short *, thisline, nextline);\n\t\tlastline = (i >= imax);\n\t\tif (i <= imax)\n\t\t\tGetInputLine(in, i, break);\n\t\tthisptr = thisline;\n\t\tnextptr = nextline;\n\t\toutptr = outline;\n\t\tfor (j = 0; j < imagewidth; ++j) {\n\t\t\tint red, green, blue;\n\t\t\tregister int oval, r2, g2, b2;\n\t\t\tlastpixel = (j == jmax);\n\t\t\tGetComponent(*thisptr++, r2, red);\n\t\t\tGetComponent(*thisptr++, g2, green);\n\t\t\tGetComponent(*thisptr++, b2, blue);\n\t\t\toval = histogram[r2][g2][b2];\n\t\t\tif (oval == -1) {\n\t\t\t\tint ci;\n\t\t\t\tregister int cj, tmp, d2, dist;\n\t\t\t\tregister C_cell\t*cell;\n\t\t\t\tcell = *(ColorCells +\n\t\t\t\t    (((r2>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) +\n\t\t\t\t    ((g2>>(B_DEPTH-C_DEPTH)) << C_DEPTH ) +\n\t\t\t\t    (b2>>(B_DEPTH-C_DEPTH))));\n\t\t\t\tif (cell == NULL)\n\t\t\t\t\tcell = create_colorcell(red,\n\t\t\t\t\t    green, blue);\n\t\t\t\tdist = 9999999;\n\t\t\t\tfor (ci = 0; ci < cell->num_ents && dist > cell->entries[ci][1]; ++ci) {\n\t\t\t\t\tcj = cell->entries[ci][0];\n\t\t\t\t\td2 = (rm[cj] >> COLOR_SHIFT) - r2;\n\t\t\t\t\td2 *= d2;\n\t\t\t\t\ttmp = (gm[cj] >> COLOR_SHIFT) - g2;\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\ttmp = (bm[cj] >> COLOR_SHIFT) - b2;\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\tif (d2 < dist) {\n\t\t\t\t\t\tdist = d2;\n\t\t\t\t\t\toval = cj;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thistogram[r2][g2][b2] = oval;\n\t\t\t}\n\t\t\t*outptr++ = oval;\n\t\t\tred -= rm[oval];\n\t\t\tgreen -= gm[oval];\n\t\t\tblue -= bm[oval];\n\t\t\tif (!lastpixel) {\n\t\t\t\tthisptr[0] += blue * 7 / 16;\n\t\t\t\tthisptr[1] += green * 7 / 16;\n\t\t\t\tthisptr[2] += red * 7 / 16;\n\t\t\t}\n\t\t\tif (!lastline) {\n\t\t\t\tif (j != 0) {\n\t\t\t\t\tnextptr[-3] += blue * 3 / 16;\n\t\t\t\t\tnextptr[-2] += green * 3 / 16;\n\t\t\t\t\tnextptr[-1] += red * 3 / 16;\n\t\t\t\t}\n\t\t\t\tnextptr[0] += blue * 5 / 16;\n\t\t\t\tnextptr[1] += green * 5 / 16;\n\t\t\t\tnextptr[2] += red * 5 / 16;\n\t\t\t\tif (!lastpixel) {\n\t\t\t\t\tnextptr[3] += blue / 16;\n\t\t\t\t        nextptr[4] += green / 16;\n\t\t\t\t        nextptr[5] += red / 16;\n\t\t\t\t}\n\t\t\t\tnextptr += 3;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outline, i-1, 0) < 0)\n\t\t\tbreak;\n\t}\nbad:\n\t_TIFFfree(inputline);\n\t_TIFFfree(thisline);\n\t_TIFFfree(nextline);\n\t_TIFFfree(outline);\n}\n", "bug_type": null, "idx": 41}
{"project": "LibTIFF", "target": 0, "func": "int\nmain()\n{\n\tTIFF\t\t*tif;\n\tsize_t\t\ti;\n\tunsigned char\tbuf[SPP] = { 0, 127, 255 };\n\t\n\ttif = TIFFOpen(filename, \"w\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\n\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\n\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\n\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) {\n\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) {\n\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\n\t\tgoto failure;\n\t}\n\tfor (i = 0; i < NSINGLETAGS; i++) {\n\t\tif (!TIFFSetField(tif, short_single_tags[i].tag,\n\t\t\t\t  short_single_tags[i].value)) {\n\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\n\t\t\t\t(unsigned long)short_single_tags[i].tag);\n\t\t\tgoto failure;\n\t\t}\n\t}\n\tfor (i = 0; i < NPAIREDTAGS; i++) {\n\t\tif (!TIFFSetField(tif, short_paired_tags[i].tag,\n\t\t\t\t  short_paired_tags[i].values[0],\n\t\t\t\t  short_paired_tags[i].values[1])) {\n\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\n\t\t\t\t(unsigned long)short_paired_tags[i].tag);\n\t\t\tgoto failure;\n\t\t}\n\t}\n\t\n\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\n\t\tfprintf (stderr, \"Can't write image data.\\n\");\n\t\tgoto failure;\n\t}\n\tTIFFClose(tif);\n\t\n\ttif = TIFFOpen(filename, \"r\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\tif (CheckLongField(tif, TIFFTAG_IMAGEWIDTH, width) < 0)\n\t\tgoto failure;\n\tif (CheckLongField(tif, TIFFTAG_IMAGELENGTH, length) < 0)\n\t\tgoto failure;\n\tif (CheckShortField(tif, TIFFTAG_BITSPERSAMPLE, bps) < 0)\n\t\tgoto failure;\n\tif (CheckShortField(tif, TIFFTAG_PHOTOMETRIC, photometric) < 0)\n\t\tgoto failure;\n\tif (CheckShortField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP) < 0)\n\t\tgoto failure;\n\tif (CheckLongField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip) < 0)\n\t\tgoto failure;\n\tif (CheckShortField(tif, TIFFTAG_PLANARCONFIG, planarconfig) < 0)\n\t\tgoto failure;\n\tfor (i = 0; i < NSINGLETAGS; i++) {\n\t\tif (CheckShortField(tif, short_single_tags[i].tag,\n\t\t\t\t    short_single_tags[i].value) < 0)\n\t\t\tgoto failure;\n\t}\n\tfor (i = 0; i < NPAIREDTAGS; i++) {\n\t\tif (CheckShortPairedField(tif, short_paired_tags[i].tag,\n\t\t\t\t\t  short_paired_tags[i].values) < 0)\n\t\t\tgoto failure;\n\t}\n\tTIFFClose(tif);\n\t\n\tunlink(filename);\n\treturn 0;\nfailure:\n\t\n\n\n\n\tTIFFClose(tif);\n\treturn 1;\n}\n", "bug_type": null, "idx": 42}
{"project": "LibTIFF", "target": 0, "func": "static void\n_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)\n{\n}\n", "bug_type": null, "idx": 43}
{"project": "LibTIFF", "target": 0, "func": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\")) {\n\t\tdefcompression = COMPRESSION_NONE;\n\t} else if (streq(opt, \"packbits\")) {\n\t\tdefcompression = COMPRESSION_PACKBITS;\n\t} else if (strneq(opt, \"jpeg\", 4)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tdefcompression = COMPRESSION_JPEG;\n\t\twhile( cp )\n\t\t{\n\t\t\tif (isdigit((int)cp[1]))\n\t\t\t\tquality = atoi(cp+1);\n\t\t\telse if (cp[1] == 'r' )\n\t\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tcp = strchr(cp+1,':');\n\t\t}\n\t} else if (strneq(opt, \"g3\", 2)) {\n\t\tprocessG3Options(opt);\n\t\tdefcompression = COMPRESSION_CCITTFAX3;\n\t} else if (streq(opt, \"g4\")) {\n\t\tdefcompression = COMPRESSION_CCITTFAX4;\n\t} else if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tdefpredictor = atoi(cp+1);\n\t\tdefcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tprocessZIPOptions(opt);\n\t\tdefcompression = COMPRESSION_ADOBE_DEFLATE;\n\t} else if (strneq(opt, \"lzma\", 4)) {\n\t\tprocessZIPOptions(opt);\n\t\tdefcompression = COMPRESSION_LZMA;\n\t} else if (strneq(opt, \"jbig\", 4)) {\n\t\tdefcompression = COMPRESSION_JBIG;\n\t} else if (strneq(opt, \"sgilog\", 6)) {\n\t\tdefcompression = COMPRESSION_SGILOG;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}\n", "bug_type": null, "idx": 44}
{"project": "LibTIFF", "target": 0, "func": "static int\nTIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v)\n{\n\tint ok = 0;\n\tuint32* l;\n\tl = (uint32*)CheckMalloc(tif,\n\t    dir->tdir_count*TIFFDataWidth(dir->tdir_type),\n\t    \"to fetch array of rationals\");\n\tif (l) {\n\t\tif (TIFFFetchData(tif, dir, (char *)l)) {\n\t\t\tuint32 i;\n\t\t\tfor (i = 0; i < dir->tdir_count; i++) {\n\t\t\t\tok = cvtRational(tif, dir,\n\t\t\t\t    l[2*i+0], l[2*i+1], &v[i]);\n\t\t\t\tif (!ok)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t_TIFFfree((char *)l);\n\t}\n\treturn (ok);\n}\n", "bug_type": null, "idx": 45}
{"project": "LibTIFF", "target": 0, "func": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\ttif = TIFFClientOpen(name, mode,\n\t\t(thandle_t) fd,\n\t\t_tiffReadProc, _tiffWriteProc,\n\t\t_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t\t_tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t{\n\t\ttif->tif_fd = fd;\n\t}\n\treturn (tif);\n}\n", "bug_type": null, "idx": 46}
{"project": "LibTIFF", "target": 0, "func": "static int\nTIFFWriteData(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\ttsize_t cc;\n\tif (tif->tif_flags & TIFF_SWAB) {\n\t\tswitch (dir->tdir_type) {\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdir->tdir_offset = tif->tif_dataoff;\n\tcc = dir->tdir_count * TIFFDataWidth(dir->tdir_type);\n\tif (SeekOK(tif, dir->tdir_offset) &&\n\t    WriteOK(tif, cp, cc)) {\n\t\ttif->tif_dataoff += (cc + 1) & ~1;\n\t\treturn (1);\n\t}\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing data for field \\\"%s\\\"\",\n\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\treturn (0);\n}\n", "bug_type": null, "idx": 47}
{"project": "LibTIFF", "target": 0, "func": "TIFFCodec*\nTIFFRegisterCODEC(uint16 scheme, const char* name, TIFFInitMethod init)\n{\n\tcodec_t* cd = (codec_t*)\n\t    _TIFFmalloc(sizeof (codec_t) + sizeof (TIFFCodec) + strlen(name)+1);\n\tif (cd != NULL) {\n\t\tcd->info = (TIFFCodec*) ((tidata_t) cd + sizeof (codec_t));\n\t\tcd->info->name = (char*)\n\t\t    ((tidata_t) cd->info + sizeof (TIFFCodec));\n\t\tstrcpy(cd->info->name, name);\n\t\tcd->info->scheme = scheme;\n\t\tcd->info->init = init;\n\t\tcd->next = registeredCODECS;\n\t\tregisteredCODECS = cd;\n\t} else {\n\t\tTIFFErrorExt(0, \"TIFFRegisterCODEC\",\n\t\t    \"No space to register compression scheme %s\", name);\n\t\treturn NULL;\n\t}\n\treturn (cd->info);\n}\n", "bug_type": null, "idx": 48}
{"project": "LibTIFF", "target": 0, "func": "static tsize_t\n_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\tDWORD dwSizeWritten;\n\tif (!WriteFile(fd, buf, size, &dwSizeWritten, NULL))\n\t\treturn(0);\n\treturn ((tsize_t) dwSizeWritten);\n}\n", "bug_type": null, "idx": 49}
{"project": "LibTIFF", "target": 0, "func": "int\nmain(int argc, char* argv[])\n{\n\tuint32 rowsperstrip = (uint32) -1;\n\tTIFF *in, *out;\n\tuint32 w, h;\n\tuint16 samplesperpixel;\n\tuint16 bitspersample;\n\tuint16 config;\n\tuint16 photometric;\n\tuint16* red;\n\tuint16* green;\n\tuint16* blue;\n\ttsize_t rowsize;\n\tregister uint32 row;\n\tregister tsample_t s;\n\tunsigned char *inbuf, *outbuf;\n\tchar thing[1024];\n\tint c;\n\textern int optind;\n\textern char *optarg;\n\twhile ((c = getopt(argc, argv, \"c:r:R:G:B:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tRED = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tGREEN = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tBLUE = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tphotometric = 0;\n\tTIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);\n\tif (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE ) {\n\t\tfprintf(stderr,\n\t    \"%s: Bad photometric; can only handle RGB and Palette images.\\n\",\n\t\t    argv[optind]);\n\t\treturn (-1);\n\t}\n\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tif (samplesperpixel != 1 && samplesperpixel != 3) {\n\t\tfprintf(stderr, \"%s: Bad samples/pixel %u.\\n\",\n\t\t    argv[optind], samplesperpixel);\n\t\treturn (-1);\n\t}\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tif (bitspersample != 8) {\n\t\tfprintf(stderr,\n\t\t    \" %s: Sorry, only handle 8-bit samples.\\n\", argv[optind]);\n\t\treturn (-1);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t\treturn (-1);\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, h);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tcpTags(in, out);\n\tif (compression != (uint16) -1) {\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_DEFLATE:\n\t\t\tif (predictor != 0)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\tbreak;\n\t\t}\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tsprintf(thing, \"B&W version of %s\", argv[optind]);\n\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing);\n\tTIFFSetField(out, TIFFTAG_SOFTWARE, \"tiff2bw\");\n\toutbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    TIFFDefaultStripSize(out, rowsperstrip));\n#define\tpack(a,b)\t((a)<<8 | (b))\n\tswitch (pack(photometric, config)) {\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n\t\tTIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue);\n\t\t\n\n\n\n\t\tif (checkcmap(in, 1<<bitspersample, red, green, blue) == 16) {\n\t\t\tint i;\n#define\tCVT(x)\t\t(((x) * 255L) / ((1L<<16)-1))\n\t\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\n\t\t\t\tred[i] = CVT(red[i]);\n\t\t\t\tgreen[i] = CVT(green[i]);\n\t\t\t\tblue[i] = CVT(blue[i]);\n\t\t\t}\n#undef CVT\n\t\t}\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresspalette(outbuf, inbuf, w, red, green, blue);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresscontig(outbuf, inbuf, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n\t\trowsize = TIFFScanlineSize(in);\n\t\tinbuf = (unsigned char *)_TIFFmalloc(3*rowsize);\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tfor (s = 0; s < 3; s++)\n\t\t\t\tif (TIFFReadScanline(in,\n\t\t\t\t    inbuf+s*rowsize, row, s) < 0)\n\t\t\t\t\t return (-1);\n\t\t\tcompresssep(outbuf,\n\t\t\t    inbuf, inbuf+rowsize, inbuf+2*rowsize, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n#undef pack\n\tTIFFClose(out);\n\treturn (0);\n}\n", "bug_type": null, "idx": 50}
{"project": "LibTIFF", "target": 0, "func": "int\nTIFFInitCCITTFax4(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\tif (InitCCITTFax3(tif)) {\t\t\n\t\t_TIFFMergeFieldInfo(tif, fax4FieldInfo, N(fax4FieldInfo));\n\t\ttif->tif_decoderow = Fax4Decode;\n\t\ttif->tif_decodestrip = Fax4Decode;\n\t\ttif->tif_decodetile = Fax4Decode;\n\t\ttif->tif_encoderow = Fax4Encode;\n\t\ttif->tif_encodestrip = Fax4Encode;\n\t\ttif->tif_encodetile = Fax4Encode;\n\t\ttif->tif_postencode = Fax4PostEncode;\n\t\t\n\n\n\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_NORTC);\n\t} else\n\t\treturn (0);\n}\n", "bug_type": null, "idx": 51}
{"project": "LibTIFF", "target": 0, "func": "static void\nShowRawWords(uint16* pp, uint32 n)\n{\n\tuint32 i;\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\" %04x\", *pp++);\n\t\tif (((i+1) % 15) == 0)\n\t\t\tprintf(\"\\n \");\n\t}\n\tputchar('\\n');\n}\n", "bug_type": null, "idx": 52}
{"project": "LibTIFF", "target": 0, "func": "int\n_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c)\n{\n\treturn (memcmp(p1, p2, (size_t) c));\n}\n", "bug_type": null, "idx": 53}
{"project": "LibTIFF", "target": 0, "func": "static void\ncompresscontig(unsigned char* out, unsigned char* rgb, uint32 n)\n{\n\tregister int v, red = RED, green = GREEN, blue = BLUE;\n\twhile (n-- > 0) {\n\t\tv = red*(*rgb++);\n\t\tv += green*(*rgb++);\n\t\tv += blue*(*rgb++);\n\t\t*out++ = v>>8;\n\t}\n}\n", "bug_type": null, "idx": 54}
{"project": "LibTIFF", "target": 0, "func": "static void\nFax3PutBits(TIFF* tif, unsigned int bits, unsigned int length)\n{\n\tFax3CodecState* sp = EncoderState(tif);\n\tunsigned int bit = sp->bit;\n\tint data = sp->data;\n\t_PutBits(tif, bits, length);\n\tsp->data = data;\n\tsp->bit = bit;\n}\n", "bug_type": null, "idx": 55}
{"project": "LibTIFF", "target": 0, "func": "static int\nTIFFFetchExtraSamples(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint16 buf[10];\n\tuint16* v = buf;\n\tint status;\n\tif (dir->tdir_count > NITEMS(buf))\n\t\tv = (uint16*) _TIFFmalloc(dir->tdir_count * sizeof (uint16));\n\tif (dir->tdir_type == TIFF_BYTE)\n\t\tstatus = TIFFFetchByteArray(tif, dir, v);\n\telse\n\t\tstatus = TIFFFetchShortArray(tif, dir, v);\n\tif (status)\n\t\tstatus = TIFFSetField(tif, dir->tdir_tag, dir->tdir_count, v);\n\tif (v != buf)\n\t\t_TIFFfree((char*) v);\n\treturn (status);\n}\n", "bug_type": null, "idx": 56}
{"project": "LibTIFF", "target": 0, "func": "static tmsize_t\nadd_ms(tmsize_t m1, tmsize_t m2)\n{\n\t\n\tif (m1 == 0 || m2 == 0)\n\t\treturn 0;\n\telse if (m1 > TIFF_TMSIZE_T_MAX - m2)\n\t\treturn 0;\n\treturn m1 + m2;\n}\n", "bug_type": null, "idx": 57}
{"project": "LibTIFF", "target": 1, "func": "\nstatic void\nhorizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (r1-r2) & mask; r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (g1-g2) & mask; g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (b1-b2) & mask; b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (r1-r2) & mask; r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (g1-g2) & mask; g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (b1-b2) & mask; b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (a1-a2) & mask; a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "bug_type": "cve-2016-3990", "idx": 58}
{"project": "LibTIFF", "target": 0, "func": "int\nTIFFInitCCITTRLEW(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\tif (InitCCITTFax3(tif)) {\t\t\n\t\ttif->tif_decoderow = Fax3DecodeRLE;\n\t\ttif->tif_decodestrip = Fax3DecodeRLE;\n\t\ttif->tif_decodetile = Fax3DecodeRLE;\n\t\t\n\n\n\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE,\n\t\t    FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_WORDALIGN);\n\t} else\n\t\treturn (0);\n}\n", "bug_type": null, "idx": 59}
{"project": "LibTIFF", "target": 0, "func": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}\n", "bug_type": null, "idx": 60}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\nTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)\n{\n\tstatic const char module[] = \"TIFFWriteDirectorySec\";\n\tuint32 ndir;\n\tTIFFDirEntry* dir;\n\tuint32 dirsize;\n\tvoid* dirmem;\n\tuint32 m;\n\tif (tif->tif_mode == O_RDONLY)\n\t\treturn (1);\n\n        _TIFFFillStriles( tif );\n        \n\t\n\n\n\n\n\tif (imagedone)\n\t{\n\t\tif (tif->tif_flags & TIFF_POSTENCODE)\n\t\t{\n\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\t\tif (!(*tif->tif_postencode)(tif))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Error post-encoding before directory write\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t(*tif->tif_close)(tif);       \n\t\t\n\n\n\n\n\n\n\t\tif (tif->tif_rawcc > 0 \n\t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\n\t\t{\n\t\t    if( !TIFFFlushData1(tif) )\n                    {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Error flushing data before directory write\");\n\t\t\treturn (0);\n                    }\n\t\t}\n\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\n\t\t{\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_rawdata = NULL;\n\t\t\ttif->tif_rawcc = 0;\n\t\t\ttif->tif_rawdatasize = 0;\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = 0;\n\t\t}\n\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\n\t}\n\tdir=NULL;\n\tdirmem=NULL;\n\tdirsize=0;\n\twhile (1)\n\t{\n\t\tndir=0;\n\t\tif (isimage)\n\t\t{\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    \n\n\n\n\n\n\n\n\n\n\n                    if (tif->tif_dir.td_stripoffset != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\n\t\t\t{\n\t\t\t\tif (tif->tif_dir.td_extrasamples)\n\t\t\t\t{\n\t\t\t\t\tuint16 na;\n\t\t\t\t\tuint16* nb;\n\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint32 n;\n\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\n\t\t\t\t\tconst TIFFField* o;\n\t\t\t\t\to = tif->tif_fields[n];\n\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (o->get_field_type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tchar* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\n\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint16 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tvoid* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tassert(0);   \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\n\t\t{\n                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;\n                        uint32 count = tif->tif_dir.td_customValues[m].count;\n\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\n\t\t\t{\n\t\t\t\tcase TIFF_ASCII:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);   \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dir!=NULL)\n\t\t\tbreak;\n\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\n\t\tif (dir==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (isimage)\n\t\t{\n\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse\n\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\n\t\tif (pdiroff!=NULL)\n\t\t\t*pdiroff=tif->tif_diroff;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tdirsize=2+ndir*12+4;\n\t\telse\n\t\t\tdirsize=8+ndir*20+8;\n\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\n\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (isimage)\n\t\t\ttif->tif_curdir++;\n\t}\n\tif (isimage)\n\t{\n\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\n\t\t{\n\t\t\tuint32 na;\n\t\t\tTIFFDirEntry* nb;\n\t\t\tfor (na=0, nb=dir; ; na++, nb++)\n\t\t\t{\n\t\t\t\tassert(na<ndir);\n\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\n\t\t\telse\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\n\t\t}\n\t}\n\tdirmem=_TIFFmalloc(dirsize);\n\tif (dirmem==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\tgoto bad;\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint8* n;\n\t\tuint32 nTmp;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint16*)n=(uint16)ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)n);\n\t\tn+=2;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\tnTmp = (uint32)o->tdir_count;\n\t\t\t_TIFFmemcpy(n,&nTmp,4);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)n);\n\t\t\tn+=4;\n\t\t\t\n\t\t\t\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\n\t\t\tn+=4;\n\t\t\to++;\n\t\t}\n\t\tnTmp = (uint32)tif->tif_nextdiroff;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&nTmp);\n\t\t_TIFFmemcpy(n,&nTmp,4);\n\t}\n\telse\n\t{\n\t\tuint8* n;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint64*)n=ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t\tn+=8;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)n);\n\t\t\tn+=8;\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\n\t\t\tn+=8;\n\t\t\to++;\n\t\t}\n\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t}\n\t_TIFFfree(dir);\n\tdir=NULL;\n\tif (!SeekOK(tif,tif->tif_diroff))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\t_TIFFfree(dirmem);\n\tif (imagedone)\n\t{\n\t\tTIFFFreeDirectory(tif);\n\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\t\t(*tif->tif_cleanup)(tif);\n\t\t\n\n\n\n\t\tTIFFCreateDirectory(tif);\n\t}\n\treturn(1);\nbad:\n\tif (dir!=NULL)\n\t\t_TIFFfree(dir);\n\tif (dirmem!=NULL)\n\t\t_TIFFfree(dirmem);\n\treturn(0);\n}", "bug_type": "cve-2017-13726", "idx": 61}
{"project": "LibTIFF", "target": 0, "func": "static int\nget_page_geometry (char *name, struct pagedef *page)\n    {\n    char *ptr;\n    int n; \n    for (ptr = name; *ptr; ptr++)\n      *ptr = (char)tolower((int)*ptr);\n    for (n = 0; n < MAX_PAPERNAMES; n++)\n      {\n      if (strcmp(name, PaperTable[n].name) == 0)\n        {\n\tpage->width = PaperTable[n].width;\n\tpage->length = PaperTable[n].length;\n        strncpy (page->name, PaperTable[n].name, 15);\n        page->name[15] = '\\0';\n        return (0);\n        }\n      }\n  return (1);\n  }\n", "bug_type": null, "idx": 62}
{"project": "LibTIFF", "target": 0, "func": "static int\nhorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",\n                     \"%s\", \"(cc%(2*stride))!=0\");\n        return 0;\n    }\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 63}
{"project": "LibTIFF", "target": 0, "func": "static int\nextractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n  \t                     tsample_t sample, uint16 spp, uint16 bps, \n                             struct dump_opts *dump)\n  {\n  int    shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32 src_rowsize, src_offset, row, first_col = 0;\n  uint32 dst_rowsize, dst_offset;\n  tsample_t count = 1;\n  uint8 *src, *dst;\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n  src_rowsize = ((bps * spp * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols) + 7) / 8;\n  if ((dump->outfile != NULL) && (dump->level == 4))\n    {\n    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToBuffer\", \n                \"Sample %d, %d rows\", sample + 1, rows + 1);\n    }\n  for (row = 0; row < rows; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = row * dst_rowsize;\n    src = in + src_offset;\n    dst = out + dst_offset;\n    \n    switch (shift_width)\n      {  \n      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n                                             spp, bps,  count, first_col, cols))  \n                return (1);\n \t      break;\n      case 1: if (bps == 1)\n                {\n                if (extractContigSamples8bits (src, dst, cols, sample,\n                                               spp, bps, count, first_col, cols))\n\t          return (1);\n\t        break;\n\t\t}\n\t      else\n                 if (extractContigSamples16bits (src, dst, cols, sample,\n                                                 spp, bps, count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 3:\n      case 4: \n      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      default: TIFFError (\"extractContigSamplesToBuffer\", \"Unsupported bit depth: %d\", bps);\n\t       return (1);\n      }\n    if ((dump->outfile != NULL) && (dump->level == 4))\n      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 64}
{"project": "LibTIFF", "target": 0, "func": "static int\nPredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\tassert(sp != NULL);\n\tassert(sp->decoderow != NULL);\n\tassert(sp->decodepfunc != NULL);  \n\tif ((*sp->decoderow)(tif, op0, occ0, s)) {\n\t\treturn (*sp->decodepfunc)(tif, op0, occ0);\n\t} else\n\t\treturn 0;\n}\n", "bug_type": null, "idx": 65}
{"project": "LibTIFF", "target": 0, "func": "extern int read(int fd, char *buf, int nbytes)\n{\n\t\n\treturn (nbytes - osgbpb_read((os_f) fd, (byte*) buf, nbytes));\n}\n", "bug_type": null, "idx": 66}
{"project": "LibTIFF", "target": 0, "func": "static void\ntiffsv(char* name, int x1, int x2, int y1, int y2)\n{\n\tTIFF *tif;\n\tint xsize, ysize;\n\tint xorg, yorg;\n\tuint32 *scrbuf;\n\txorg = MIN(x1,x2);\n\tyorg = MIN(y1,y2);\n\tif (xorg<0)\n\t\txorg = 0;\n\tif (yorg<0)\n\t\tyorg = 0;\n\txsize = ABS(x2-x1);\n\tysize = ABS(y2-y1);\n\tif (xorg+xsize > xmaxscreen)\n\t\txsize = xmaxscreen-xorg;\n\tif (yorg+ysize > ymaxscreen)\n\t\tysize = ymaxscreen-yorg;\n\ttif = TIFFOpen(name, \"w\");\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) (xsize+1));\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) (ysize+1));\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL,\n\t    photometric == PHOTOMETRIC_RGB ? 3 : 1);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, config);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tif (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\tTIFFSetField(tif, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(tif, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n\trowsperstrip = TIFFDefaultStripSize(tif, rowsperstrip);\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\tscrbuf = (uint32 *)_TIFFmalloc((xsize+1)*(ysize+1)*sizeof (uint32));\n\treaddisplay(xorg, yorg, xorg+xsize, yorg+ysize, scrbuf, RD_FREEZE);\n\tif (photometric == PHOTOMETRIC_RGB) {\n\t\tif (config == PLANARCONFIG_SEPARATE)\n\t\t\tsvRGBSeparate(tif, scrbuf, xsize, ysize);\n\t\telse\n\t\t\tsvRGBContig(tif, scrbuf, xsize, ysize);\n\t} else\n\t\tsvGrey(tif, scrbuf, xsize, ysize);\n\t(void) TIFFClose(tif);\n\t_TIFFfree((char *)scrbuf);\n}\n", "bug_type": null, "idx": 67}
{"project": "LibTIFF", "target": 0, "func": "int\nTIFFReadImageIter(TIFF* tif,\n    uint32 rwidth, uint32 rheight, uint8* raster, int stop)\n{\n    char emsg[1024];\n    TIFFImageIter img;\n    int ok;\n    if (TIFFImageIterBegin(&img, tif, stop, emsg)) {\n\t\n\tok = TIFFImageIterGet(&img, raster, rwidth, img.height);\n\tTIFFImageIterEnd(&img);\n    } else {\n\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg);\n\tok = 0;\n    }\n    return (ok);\n}\n", "bug_type": null, "idx": 68}
{"project": "LibTIFF", "target": 0, "func": "static tsize_t\nTIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tif (dir->tdir_count <= 4) {\n\t\tuint32 l = dir->tdir_offset;\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&l);\n\t\t_TIFFmemcpy(cp, &l, dir->tdir_count);\n\t\treturn (1);\n\t}\n\treturn (TIFFFetchData(tif, dir, cp));\n}\n", "bug_type": null, "idx": 69}
{"project": "LibTIFF", "target": 0, "func": "const TIFFCodec*\nTIFFFindCODEC(uint16 scheme)\n{\n\tconst TIFFCodec* c;\n\tcodec_t* cd;\n\tfor (cd = registeredCODECS; cd; cd = cd->next)\n\t\tif (cd->info->scheme == scheme)\n\t\t\treturn ((const TIFFCodec*) cd->info);\n\tfor (c = _TIFFBuiltinCODECS; c->name; c++)\n\t\tif (c->scheme == scheme)\n\t\t\treturn (c);\n\treturn ((const TIFFCodec*) 0);\n}\n", "bug_type": null, "idx": 70}
{"project": "LibTIFF", "target": 0, "func": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tint m;\n\tlong fd;\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n\tif (m & O_TRUNC) {\n\t\tfd = Fcreate(name, 0);\n\t} else {\n\t\tfd = Fopen(name, m & O_ACCMODE);\n\t\tif (fd == AEFILNF && m & O_CREAT)\n\t\t\tfd = Fcreate(name, 0);\n\t}\n\tif (fd < 0)\n\t\terrno = (int)fd;\n\tif (fd < 0) {\n\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\treturn ((TIFF*)0);\n\t}\n\treturn (TIFFFdOpen(fd, name, mode));\n}\n", "bug_type": null, "idx": 71}
{"project": "LibTIFF", "target": 0, "func": "void\nTIFFSwabFloat(float* fp)\n{\n\tregister unsigned char* cp = (unsigned char*) fp;\n\tunsigned char t;\n\tassert(sizeof(float)==4);\n\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\n\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\n}\n", "bug_type": null, "idx": 72}
{"project": "LibTIFF", "target": 0, "func": "static void\n_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)\n{\n}\n", "bug_type": null, "idx": 73}
{"project": "LibTIFF", "target": 0, "func": "static int \ncombineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n                             uint32 cols, uint32 rows, uint16 spp, uint16 bps,\n                             FILE *dumpfile, int format, int level)\n  {\n  int i, bytes_per_sample;\n  uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t s;\n  src = srcbuffs[0];\n  dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamplesBytes\",\"Invalid buffer address\");\n    return (1);\n    }\n  bytes_per_sample = (bps + 7) / 8; \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * spp * cols) + 7) / 8;\n  for (row = 0; row < rows; row++)\n    {\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      for (s = 0; s < spp; s++)\n        {\n        dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Input data, Sample %d\", s);\n        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n        }\n      }\n    dst = out + (row * dst_rowsize);\n    row_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      col_offset = row_offset + (col * (bps / 8)); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n        src = srcbuffs[s] + col_offset; \n        for (i = 0; i < bytes_per_sample; i++)\n          *(dst + i) = *(src + i);\n        src += bytes_per_sample;\n        dst += bytes_per_sample;\n        }   \n      }\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Output data, combined samples\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 74}
{"project": "LibTIFF", "target": 0, "func": "static int\nSeparateCompare(int reversed, int sample, uint32 row,\n\t\tunsigned char* cp1, unsigned char* p2)\n{\n\tuint32 npixels = imagewidth;\n\tint pixel;\n\tcp1 += sample;\n\tfor (pixel = 0; npixels-- > 0; pixel++, cp1 += samplesperpixel, p2++) {\n\t\tif (*cp1 != *p2) {\n\t\t\tprintf(\"Scanline %lu, pixel %lu, sample %ld: \",\n\t\t\t    (long) row, (long) pixel, (long) sample);\n\t\t\tif (reversed)\n\t\t\t\tprintf(\"%02x %02x\\n\", *p2, *cp1);\n\t\t\telse\n\t\t\t\tprintf(\"%02x %02x\\n\", *cp1, *p2);\n\t\t\tif (--stopondiff == 0)\n\t\t\t\texit(1);\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 75}
{"project": "LibTIFF", "target": 0, "func": "void\nTIFFReadSeparateTileData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttsize_t rowsize = TIFFTileRowSize(tif);\n\tbuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));\n\tif (buf) {\n\t\tuint32 tw, th, w, h;\n\t\tuint32 row, col;\n\t\ttsample_t s, samplesperpixel;\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tfor (row = 0; row < h; row += th) {\n\t\t\tfor (col = 0; col < w; col += tw) {\n\t\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, s) < 0) {\n\t\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (showdata)\n\t\t\t\t\t\tShowTile(row, col, s, buf, th, rowsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}\n", "bug_type": null, "idx": 76}
{"project": "LibTIFF", "target": 0, "func": "int TIFFInitJBIG(TIFF* tif, int scheme)\n{\n\tassert(scheme == COMPRESSION_JBIG);\n\t\n\n\n\n\n\ttif->tif_flags |= TIFF_NOBITREV;\n\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\n\ttif->tif_setupdecode = JBIGSetupDecode;\n\ttif->tif_decodestrip = JBIGDecode;\n\ttif->tif_setupencode = JBIGSetupEncode;\n\ttif->tif_encodestrip = JBIGEncode;\n\treturn 1;\n}\n", "bug_type": null, "idx": 77}
{"project": "LibTIFF", "target": 0, "func": "static void\ncl_hash(LZWCodecState* sp)\n{\n\tregister hash_t *hp = &sp->enc_hashtab[HSIZE-1];\n\tregister long i = HSIZE-8;\n\tdo {\n\t\ti -= 8;\n\t\thp[-7].hash = -1;\n\t\thp[-6].hash = -1;\n\t\thp[-5].hash = -1;\n\t\thp[-4].hash = -1;\n\t\thp[-3].hash = -1;\n\t\thp[-2].hash = -1;\n\t\thp[-1].hash = -1;\n\t\thp[ 0].hash = -1;\n\t\thp -= 8;\n\t} while (i >= 0);\n\tfor (i += 8; i > 0; i--, hp--)\n\t\thp->hash = -1;\n}\n", "bug_type": null, "idx": 78}
{"project": "LibTIFF", "target": 0, "func": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tTIFF* tif;\n\tm = _TIFFgetMode(mode, module);\n\tswitch(m)\n\t{\n\tcase O_RDONLY:\n\t\tdwMode = OPEN_EXISTING;\n\t\tbreak;\n\tcase O_RDWR:\n\t\tdwMode = OPEN_ALWAYS;\n\t\tbreak;\n\tcase O_RDWR|O_CREAT:\n\t\tdwMode = OPEN_ALWAYS;\n\t\tbreak;\n\tcase O_RDWR|O_TRUNC:\n\t\tdwMode = CREATE_ALWAYS;\n\t\tbreak;\n\tcase O_RDWR|O_CREAT|O_TRUNC:\n\t\tdwMode = CREATE_ALWAYS;\n\t\tbreak;\n\tdefault:\n\t\treturn ((TIFF*)0);\n\t}\n\tfd = (thandle_t)CreateFileA(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ | GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\ttif = TIFFFdOpen((int)fd, name, mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\treturn tif;\n}\n", "bug_type": null, "idx": 79}
{"project": "LibTIFF", "target": 0, "func": "static void\nmap_colortable(void)\n{\n\tregister uint32 *histp = &histogram[0][0][0];\n\tregister C_cell *cell;\n\tregister int j, tmp, d2, dist;\n\tint ir, ig, ib, i;\n\tfor (ir = 0; ir < B_LEN; ++ir)\n\t\tfor (ig = 0; ig < B_LEN; ++ig)\n\t\t\tfor (ib = 0; ib < B_LEN; ++ib, histp++) {\n\t\t\t\tif (*histp == 0) {\n\t\t\t\t\t*histp = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcell = *(ColorCells +\n\t\t\t\t    (((ir>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) +\n\t\t\t\t    ((ig>>(B_DEPTH-C_DEPTH)) << C_DEPTH) +\n\t\t\t\t    (ib>>(B_DEPTH-C_DEPTH))));\n\t\t\t\tif (cell == NULL )\n\t\t\t\t\tcell = create_colorcell(\n\t\t\t\t\t    ir << COLOR_SHIFT,\n\t\t\t\t\t    ig << COLOR_SHIFT,\n\t\t\t\t\t    ib << COLOR_SHIFT);\n\t\t\t\tdist = 9999999;\n\t\t\t\tfor (i = 0; i < cell->num_ents &&\n\t\t\t\t    dist > cell->entries[i][1]; ++i) {\n\t\t\t\t\tj = cell->entries[i][0];\n\t\t\t\t\td2 = rm[j] - (ir << COLOR_SHIFT);\n\t\t\t\t\td2 *= d2;\n\t\t\t\t\ttmp = gm[j] - (ig << COLOR_SHIFT);\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\ttmp = bm[j] - (ib << COLOR_SHIFT);\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\tif (d2 < dist) {\n\t\t\t\t\t\tdist = d2;\n\t\t\t\t\t\t*histp = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n}\n", "bug_type": null, "idx": 80}
{"project": "LibTIFF", "target": 0, "func": "const unsigned char*\nTIFFGetBitRevTable(int reversed)\n{\n\treturn (reversed ? TIFFBitRevTable : TIFFNoBitRevTable);\n}\n", "bug_type": null, "idx": 81}
{"project": "LibTIFF", "target": 0, "func": "int\nmain(int argc, char **argv)\n{\n    XSetWindowAttributes window_attributes;\n    Widget widget_list[3];\n    Arg args[5];\n    setbuf(stdout, NULL); setbuf(stderr, NULL);\n    shellWidget = XtInitialize(argv[0], \"XTiff\", shellOptions,\n        XtNumber(shellOptions), &argc, argv);\n    XSetErrorHandler(XTiffErrorHandler);\n    XtGetApplicationResources(shellWidget, &appData,\n        (XtResourceList) clientResources, (Cardinal) XtNumber(clientResources),\n        (ArgList) NULL, (Cardinal) 0);\n    if ((argc <= 1) || (argc > 2) || appData.help)\n        Usage();\n    if (appData.verbose == False) {\n        TIFFSetErrorHandler(0);\n        TIFFSetWarningHandler(0);\n    }\n    fileName = argv[1];\n    xDisplay = XtDisplay(shellWidget);\n    xScreen = DefaultScreen(xDisplay);\n    OpenTIFFFile();\n    GetTIFFHeader();\n    SimpleGammaCorrection();\n    GetVisual();\n    GetTIFFImage();\n    \n\n\n\n    XtSetArg(args[0], XtNvisual, xVisual);\n    XtSetArg(args[1], XtNcolormap, xColormap);\n    XtSetArg(args[2], XtNdepth,\n        xImageDepth == 1 ? DefaultDepth(xDisplay, xScreen) : xImageDepth);\n    XtSetArg(args[3], XtNiconPixmap,\n        XCreateBitmapFromData(xDisplay, RootWindow(xDisplay, xScreen),\n            xtifficon_bits, xtifficon_width, xtifficon_height));\n    XtSetArg(args[4], XtNallowShellResize, True);\n    XtSetValues(shellWidget, args, 5);\n    \n\n\n    formWidget = XtCreateManagedWidget(\"form\", formWidgetClass,\n        shellWidget, formArgs, XtNumber(formArgs));\n        widget_list[0] = listWidget = XtCreateWidget(\"list\",\n            listWidgetClass, formWidget, listArgs, XtNumber(listArgs));\n        widget_list[1] = labelWidget = XtCreateWidget(\"label\",\n            labelWidgetClass, formWidget, labelArgs, XtNumber(labelArgs));\n        widget_list[2] = imageWidget = XtCreateWidget(\"image\",\n            widgetClass, formWidget, imageArgs, XtNumber(imageArgs));\n    XtManageChildren(widget_list, XtNumber(widget_list));\n    \n\n\n    if (tfImageWidth >= appData.viewportWidth) {\n        XtSetArg(args[0], XtNwidth, appData.viewportWidth);\n        XtSetValues(shellWidget, args, 1);\n    }\n    if (tfImageHeight >= appData.viewportHeight) {\n        XtSetArg(args[0], XtNheight, appData.viewportHeight);\n        XtSetValues(shellWidget, args, 1);\n    }\n    XtSetArg(args[0], XtNwidth, tfImageWidth);\n    XtSetArg(args[1], XtNheight, tfImageHeight);\n    XtSetValues(imageWidget, args, 2);\n    \n\n\n    XtSetArg(args[0], XtNfromVert, listWidget);\n    XtSetValues(imageWidget, args, 1);\n    XtSetArg(args[0], XtNfromHoriz, listWidget);\n    XtSetValues(labelWidget, args, 1);\n    SetNameLabel();\n    XtAddCallback(listWidget, XtNcallback, (XtCallbackProc) SelectProc,\n        (XtPointer) NULL);\n    XtAddActions(actionsTable, XtNumber(actionsTable));\n    XtSetArg(args[0], XtNtranslations,\n        XtParseTranslationTable(translationsTable));\n    XtSetValues(formWidget, &args[0], 1);\n    XtSetValues(imageWidget, &args[0], 1);\n    \n\n\n\n    XtAddEventHandler(imageWidget, ExposureMask | ButtonPressMask\n        | ButtonReleaseMask | Button1MotionMask | KeyPressMask,\n        False, EventProc, NULL);\n    XtRealizeWidget(shellWidget);\n    window_attributes.cursor = XCreateFontCursor(xDisplay, XC_fleur);\n    XChangeWindowAttributes(xDisplay, XtWindow(imageWidget),\n        CWCursor, &window_attributes);\n    CreateXImage();\n    XtMainLoop();\n    return 0;\n}\n", "bug_type": null, "idx": 82}
{"project": "LibTIFF", "target": 0, "func": "void\nSimpleGammaCorrection()\n{\n    register int i;\n    register double i_gamma = 1.0 / appData.gamma;\n    for (i = 0; i < colormapSize; i++) {\n        if (((tfPhotometricInterpretation == PHOTOMETRIC_MINISWHITE)\n            && (i == colormapSize - 1))\n            || ((tfPhotometricInterpretation == PHOTOMETRIC_MINISBLACK)\n            && (i == 0)))\n            redMap[i] = greenMap[i] = blueMap[i] = 0;\n        else {\n            redMap[i] = ROUND((pow(dRed[i] / 65535.0, i_gamma) * 65535.0));\n            greenMap[i] = ROUND((pow(dGreen[i] / 65535.0, i_gamma) * 65535.0));\n            blueMap[i] = ROUND((pow(dBlue[i] / 65535.0, i_gamma) * 65535.0));\n        }\n    }\n    free(dRed); free(dGreen); free(dBlue);\n}\n", "bug_type": null, "idx": 83}
{"project": "LibTIFF", "target": 0, "func": "static int\n_notConfigured(TIFF* tif)\n{\n\tconst TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);\n        char compression_code[20];\n        sprintf(compression_code, \"%d\",tif->tif_dir.td_compression );\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                     \"%s compression support is not configured\", \n                     c ? c->name : compression_code );\n\treturn (0);\n}\n", "bug_type": null, "idx": 84}
{"project": "LibTIFF", "target": 0, "func": "static int\nCheckShortTag(TIFF* tif1, TIFF* tif2, int tag, char* name)\n{\n\tuint16 v1, v2;\n\tCHECK(v1 == v2, \"%s: %u %u\\n\");\n}\n", "bug_type": null, "idx": 85}
{"project": "LibTIFF", "target": 0, "func": "int\n_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c)\n{\n\treturn (memcmp(p1, p2, (size_t) c));\n}\n", "bug_type": null, "idx": 86}
{"project": "LibTIFF", "target": 0, "func": "static int\n_tiffCloseProc(thandle_t fd)\n{\n\treturn (CloseHandle(fd) ? 0 : -1);\n}\n", "bug_type": null, "idx": 87}
{"project": "LibTIFF", "target": 0, "func": "void\nusage()\n{\n    error(\"usage: %s -[vq] [-|rasterfile] TIFFfile\\n\", NULL);\n}\n", "bug_type": null, "idx": 88}
{"project": "LibTIFF", "target": 0, "func": "static int\ncombineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 ;\n  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n  uint32 src_byte = 0, src_bit = 0;\n  uint32 row, col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n   \n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      \n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n      matchbits = maskbits << (64 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\t{\n\tsrc = in[s] + src_offset + src_byte;\n\tif (little_endian)\n\t  {\n\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\t  longbuff2 = longbuff1;\n\t  }\n\telse\n\t  {\n\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n          longbuff2 = longbuff1;\n\t  }\n\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n\tbuff1 = (buff3 & matchbits) << (src_bit);\n\t\n\tif (ready_bits >= 32)\n\t  {\n\t  bytebuff1 = (buff2 >> 56);\n\t  *dst++ = bytebuff1;\n\t  bytebuff2 = (buff2 >> 48);\n\t  *dst++ = bytebuff2;\n\t  bytebuff3 = (buff2 >> 40);\n\t  *dst++ = bytebuff3;\n\t  bytebuff4 = (buff2 >> 32);\n\t  *dst++ = bytebuff4;\n\t  ready_bits -= 32;\n\t  \n\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n\t  strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { \n\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n\t  buff2 = (buff2 | (buff1 >> ready_bits));\n\t  strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\tif ((dumpfile != NULL) && (level == 3))\n\t  { \n\t  dump_info (dumpfile, format, \"\",\n\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\n\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n    while (ready_bits > 0)\n      {\n      bytebuff1 = (buff2 >> 56);\n      *dst++ = bytebuff1;\n      buff2 = (buff2 << 8);\n      ready_bits -= 8;\n      }\n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples32bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n      }\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 89}
{"project": "LibTIFF", "target": 0, "func": "static int \nextractContigSamplesBytes (uint8 *in, uint8 *out, uint32 cols, \n                           tsample_t sample, uint16 spp, uint16 bps, \n                           tsample_t count, uint32 start, uint32 end)\n  {\n  int i, bytes_per_sample, sindex;\n  uint32 col, dst_rowsize, bit_offset;\n  uint32 src_byte ;\n  uint8 *src = in;\n  uint8 *dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n  dst_rowsize = (bps * (end - start) * count) / 8;\n  bytes_per_sample = (bps + 7) / 8; \n  \n  if (count == spp)\n    {\n    src = in + (start * spp * bytes_per_sample);\n    _TIFFmemcpy (dst, src, dst_rowsize);\n    }\n  else\n    {\n    for (col = start; col < end; col++)\n      {\n      for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n        {\n        bit_offset = col * bps * spp;\n        if (sindex == 0)\n          {\n          src_byte = bit_offset / 8;\n          \n          }\n        else\n          {\n          src_byte = (bit_offset + (sindex * bps)) / 8;\n          \n          }\n        src = in + src_byte;\n        for (i = 0; i < bytes_per_sample; i++)\n            *dst++ = *src++;\n        }\n      }\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 90}
{"project": "LibTIFF", "target": 0, "func": "static void\nvmsErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}\n", "bug_type": null, "idx": 91}
{"project": "LibTIFF", "target": 0, "func": "static void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Data type %d is not supported, tag %d skipped.\",\n\t\t    tag, type);\n\t}\n}\n", "bug_type": null, "idx": 92}
{"project": "LibTIFF", "target": 0, "func": "\nint main( int argc, char ** argv )\n{\n    int\t\tanOverviews[100];   \n    int\t\tnOverviewCount = 0;\n    int\t\tbUseSubIFD = 0;\n    TIFF\t*hTIFF;\n    const char  *pszResampling = \"nearest\";\n\n\n\n    if( argc < 2 )\n    {\n        printf( \"Usage: addtiffo [-r {nearest,average,mode}]\\n\"\n                \"                tiff_filename [resolution_reductions]\\n\"\n                \"\\n\"\n                \"Example:\\n\"\n                \" %% addtiffo abc.tif 2 4 8 16\\n\" );\n        return( 1 );\n    }\n    while( argv[1][0] == '-' )\n    {\n        if( strcmp(argv[1],\"-subifd\") == 0 )\n        {\n            bUseSubIFD = 1;\n            argv++;\n            argc--;\n        }\n        else if( strcmp(argv[1],\"-r\") == 0 )\n        {\n            argv += 2;\n            argc -= 2;\n            pszResampling = *argv;\n        }\n        else\n        {\n            fprintf( stderr, \"Incorrect parameters\\n\" );\n            return( 1 );\n        }\n    }\n    \n\n\n\n    while( nOverviewCount < argc - 2 && nOverviewCount < 100 )\n    {\n        anOverviews[nOverviewCount] = atoi(argv[nOverviewCount+2]);\n        if( anOverviews[nOverviewCount] <= 0)\n        {\n            fprintf( stderr, \"Incorrect parameters\\n\" );\n            return(1);\n        }\n        nOverviewCount++;\n    }\n\n\n\n\n    \n    if( nOverviewCount == 0 )\n    {\n        nOverviewCount = 4;\n        anOverviews[0] = 2;\n        anOverviews[1] = 4;\n        anOverviews[2] = 8;\n        anOverviews[3] = 16;\n    }\n\n\n\n    hTIFF = TIFFOpen( argv[1], \"r+\" );\n    if( hTIFF == NULL )\n    {\n        fprintf( stderr, \"TIFFOpen(%s) failed.\\n\", argv[1] );\n        return( 1 );\n    }\n    TIFFBuildOverviews( hTIFF, nOverviewCount, anOverviews, bUseSubIFD,\n                        pszResampling, NULL, NULL );\n    TIFFClose( hTIFF );\n\n\n\n#ifdef DBMALLOC\n    malloc_dump(1);\n#endif\n    return( 0 );\n}\n", "bug_type": null, "idx": 93}
{"project": "LibTIFF", "target": 0, "func": "static void\nprocessG3Options(char* cp)\n{\n\tif ((cp = strchr(cp, ':'))) {\n\t\tdo {\n\t\t\tcp++;\n\t\t\tif (strneq(cp, \"1d\", 2))\n\t\t\t\tgroup3options &= ~GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"2d\", 2))\n\t\t\t\tgroup3options |= GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"fill\", 4))\n\t\t\t\tgroup3options |= GROUP3OPT_FILLBITS;\n\t\t\telse\n\t\t\t\tusage();\n\t\t} while ((cp = strchr(cp, ':')));\n\t}\n}\n", "bug_type": null, "idx": 94}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\nThunderDecode(TIFF* tif, tidata_t op, tsize_t maxpixels)\n{\n\tregister unsigned char *bp;\n\tregister tsize_t cc;\n\tunsigned int lastpixel;\n\ttsize_t npixels;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tlastpixel = 0;\n\tnpixels = 0;\n\twhile (cc > 0 && npixels < maxpixels) {\n\t\tint n, delta;\n\n\t\tn = *bp++, cc--;\n\t\tswitch (n & THUNDER_CODE) {\n\t\tcase THUNDER_RUN:\t\t\n\t\t\t\n\n\n\n\t\t\tif (npixels & 1) {\n\t\t\t\top[0] |= lastpixel;\n\t\t\t\tlastpixel = *op++; npixels++; n--;\n\t\t\t} else\n\t\t\t\tlastpixel |= lastpixel << 4;\n\t\t\tnpixels += n;\n\t\t\tif (npixels < maxpixels) {\n\t\t\t\tfor (; n > 0; n -= 2)\n\t\t\t\t\t*op++ = (tidataval_t) lastpixel;\n\t\t\t}\n\t\t\tif (n == -1)\n\t\t\t\t*--op &= 0xf0;\n\t\t\tlastpixel &= 0xf;\n\t\t\tbreak;\n\t\tcase THUNDER_2BITDELTAS:\t\n\t\t\tif ((delta = ((n >> 4) & 3)) != DELTA2_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\n\t\t\tif ((delta = ((n >> 2) & 3)) != DELTA2_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\n\t\t\tif ((delta = (n & 3)) != DELTA2_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\n\t\t\tbreak;\n\t\tcase THUNDER_3BITDELTAS:\t\n\t\t\tif ((delta = ((n >> 3) & 7)) != DELTA3_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\n\t\t\tif ((delta = (n & 7)) != DELTA3_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\n\t\t\tbreak;\n\t\tcase THUNDER_RAW:\t\t\n\t\t\tSETPIXEL(op, n);\n\t\t\tbreak;\n\t\t}\n\t}\n\ttif->tif_rawcp = (tidata_t) bp;\n\ttif->tif_rawcc = cc;\n\tif (npixels != maxpixels) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"ThunderDecode: %s data at scanline %ld (%lu != %lu)\",\n\t\t    npixels < maxpixels ? \"Not enough\" : \"Too much\",\n\t\t    (long) tif->tif_row, (long) npixels, (long) maxpixels);\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "bug_type": "cve-2011-1167", "idx": 95}
{"project": "LibTIFF", "target": 0, "func": "void\nTIFFCvtNativeToIEEEFloat(TIFF* tif, u_int n, float* f)\n{\n\tfloat_t* fp = (float_t*) f;\n\twhile (n-- > 0) {\n\t\tNATIVE2IEEEFLOAT(fp);\n\t\tfp++;\n\t}\n}\n", "bug_type": null, "idx": 96}
{"project": "LibTIFF", "target": 0, "func": "static void\nsvRGBSeparate(TIFF* tif, uint32* ss, int xsize, int ysize)\n{\n\ttsize_t stripsize = TIFFStripSize(tif);\n\tunsigned char *rbuf = (unsigned char *)_TIFFmalloc(3*stripsize);\n\tunsigned char *gbuf = rbuf + stripsize;\n\tunsigned char *bbuf = gbuf + stripsize;\n\tregister int y;\n\tfor (y = 0; y <= ysize; y += rowsperstrip) {\n\t\tunsigned char *rp, *gp, *bp;\n\t\tregister int x;\n\t\tregister uint32 n;\n\t\tn = rowsperstrip;\n\t\tif (n > ysize-y+1)\n\t\t\tn = ysize-y+1;\n\t\trp = rbuf; gp = gbuf; bp = bbuf;\n\t\tdo {\n\t\t\tfor (x = 0; x <= xsize; x++) {\n\t\t\t\tuint32 v = ss[x];\n\t\t\t\trp[x] = v;\n\t\t\t\tgp[x] = v >> 8;\n\t\t\t\tbp[x] = v >> 16;\n\t\t\t}\n\t\t\trp += xsize+1, gp += xsize+1, bp += xsize+1;\n\t\t\tss += xsize+1;\n\t\t} while (--n);\n\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0),\n\t\t    rbuf, stripsize) < 0)\n\t\t\tbreak;\n\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,1),\n\t\t    gbuf, stripsize) < 0)\n\t\t\tbreak;\n\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,2),\n\t\t    bbuf, stripsize) < 0)\n\t\t\tbreak;\n\t}\n\t_TIFFfree(rbuf);\n}\n", "bug_type": null, "idx": 97}
{"project": "LibTIFF", "target": 0, "func": "void\n_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c)\n{\n\tif (c > 0xFFFF)\n\t\thmemcpy((void _huge*) d, (void _huge*) s, c);\n\telse\n\t\t(void) memcpy(d, s, (size_t) c);\n}\n", "bug_type": null, "idx": 98}
{"project": "LibTIFF", "target": 0, "func": "\nstatic void TIFFWriteOvrRow( TIFFOvrCache * psCache )\n{\n    int\t\tnRet, iTileX, iTileY = psCache->nBlockOffset;\n    unsigned char *pabyData;\n    toff_t\tnBaseDirOffset;\n    uint32      RowsInStrip;\n\n\n\n\n\n    if( TIFFIsByteSwapped(psCache->hTIFF) )\n    {\n        if( psCache->nBitsPerPixel == 16 )\n            TIFFSwabArrayOfShort( (uint16 *) psCache->pabyRow1Blocks,\n                      (psCache->nBytesPerBlock * psCache->nSamples) / 2 );\n        else if( psCache->nBitsPerPixel == 32 )\n            TIFFSwabArrayOfLong( (uint32 *) psCache->pabyRow1Blocks,\n                         (psCache->nBytesPerBlock * psCache->nSamples) / 4 );\n        else if( psCache->nBitsPerPixel == 64 )\n            TIFFSwabArrayOfDouble( (double *) psCache->pabyRow1Blocks,\n                         (psCache->nBytesPerBlock * psCache->nSamples) / 8 );\n    }\n\n\n\n\n    nBaseDirOffset = TIFFCurrentDirOffset( psCache->hTIFF );\n    nRet = TIFFSetSubDirectory( psCache->hTIFF, psCache->nDirOffset );\n    assert( nRet == 1 );\n\n\n\n\tfor( iTileX = 0; iTileX < psCache->nBlocksPerRow; iTileX++ )\n\t{\n\t\tint nTileID;\n\t\tif (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE)\n\t\t{\n\t\t\tint iSample;\n\t\t\tfor( iSample = 0; iSample < psCache->nSamples; iSample++ )\n\t\t\t{\n\t\t\t\tpabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, iSample );\n\t\t\t\tif( psCache->bTiled )\n\t\t\t\t{\n\t\t\t\t\tnTileID = TIFFComputeTile( psCache->hTIFF,\n\t\t\t\t\t    iTileX * psCache->nBlockXSize,\n\t\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t\t    0, (tsample_t) iSample );\n\t\t\t\t\tTIFFWriteEncodedTile( psCache->hTIFF, nTileID,\n\t\t\t\t\t    pabyData,\n\t\t\t\t\t    TIFFTileSize(psCache->hTIFF) );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnTileID = TIFFComputeStrip( psCache->hTIFF,\n\t\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t\t    (tsample_t) iSample );\n\t\t\t\t\tRowsInStrip=psCache->nBlockYSize;\n\t\t\t\t\tif ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize)\n\t\t\t\t\t\tRowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize;\n\t\t\t\t\tTIFFWriteEncodedStrip( psCache->hTIFF, nTileID,\n\t\t\t\t\t    pabyData,\n\t\t\t\t\t    TIFFVStripSize(psCache->hTIFF,RowsInStrip) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, 0 );\n\t\t\tif( psCache->bTiled )\n\t\t\t{\n\t\t\t\tnTileID = TIFFComputeTile( psCache->hTIFF,\n\t\t\t\t    iTileX * psCache->nBlockXSize,\n\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t    0, 0 );\n\t\t\t\tTIFFWriteEncodedTile( psCache->hTIFF, nTileID,\n\t\t\t\t    pabyData,\n\t\t\t\t    TIFFTileSize(psCache->hTIFF) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnTileID = TIFFComputeStrip( psCache->hTIFF,\n\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t    0 );\n\t\t\t\tRowsInStrip=psCache->nBlockYSize;\n\t\t\t\tif ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize)\n\t\t\t\t\tRowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize;\n\t\t\t\tTIFFWriteEncodedStrip( psCache->hTIFF, nTileID,\n\t\t\t\t    pabyData,\n\t\t\t\t    TIFFVStripSize(psCache->hTIFF,RowsInStrip) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\n\n    pabyData = psCache->pabyRow1Blocks;\n    psCache->pabyRow1Blocks = psCache->pabyRow2Blocks;\n    psCache->pabyRow2Blocks = pabyData;\n    _TIFFmemset( pabyData, 0, psCache->nBytesPerRow );\n    psCache->nBlockOffset++;\n\n\n\n    TIFFFlush( psCache->hTIFF );\n    \n    TIFFSetSubDirectory( psCache->hTIFF, nBaseDirOffset );\n    \n}\n", "bug_type": null, "idx": 99}
{"project": "LibTIFF", "target": 1, "func": "\nvoid\n_TIFFmemcpy(void* d, const void* s, tmsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}", "bug_type": "cve-2016-10269", "idx": 100}
{"project": "LibTIFF", "target": 0, "func": "static void\nMissingRequired(TIFF* tif, const char* tagname)\n{\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t    \"TIFF directory is missing required \\\"%s\\\" field\", tagname);\n}\n", "bug_type": null, "idx": 101}
{"project": "LibTIFF", "target": 0, "func": "static int\nreverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  \n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: \n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } \n", "bug_type": null, "idx": 102}
{"project": "LibTIFF", "target": 0, "func": "static int\nTIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, int* pl)\n{\n\tint samples = tif->tif_dir.td_samplesperpixel;\n\tint status = 0;\n\tif (CheckDirCount(tif, dir, (uint32) samples)) {\n\t\tuint16 buf[10];\n\t\tuint16* v = buf;\n\t\tif (samples > NITEMS(buf))\n\t\t\tv = (uint16*) _TIFFmalloc(samples * sizeof (uint16));\n\t\tif (TIFFFetchShortArray(tif, dir, v)) {\n\t\t\tint i;\n\t\t\tfor (i = 1; i < samples; i++)\n\t\t\t\tif (v[i] != v[0]) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t   _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t*pl = v[0];\n\t\t\tstatus = 1;\n\t\t}\n\tbad:\n\t\tif (v != buf)\n\t\t\t_TIFFfree((char*) v);\n\t}\n\treturn (status);\n}\n", "bug_type": null, "idx": 103}
{"project": "LibTIFF", "target": 0, "func": "static int\nTIFFWriteAnyArray(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v)\n{\n\tchar buf[10 * sizeof(double)];\n\tchar* w = buf;\n\tint i, status = 0;\n\tif (n * TIFFDataWidth(type) > sizeof buf)\n\t\tw = (char*) _TIFFmalloc(n * TIFFDataWidth(type));\n\tswitch (type) {\n\tcase TIFF_BYTE:\n\t\t{ unsigned char* bp = (unsigned char*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (unsigned char) v[i];\n\t\t  dir->tdir_tag = tag;\n\t\t  dir->tdir_type = (short) type;\n\t\t  dir->tdir_count = n;\n\t\t  if (!TIFFWriteByteArray(tif, dir, (char*) bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SBYTE:\n\t\t{ signed char* bp = (signed char*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (signed char) v[i];\n\t\t  dir->tdir_tag = tag;\n\t\t  dir->tdir_type = (short) type;\n\t\t  dir->tdir_count = n;\n\t\t  if (!TIFFWriteByteArray(tif, dir, (char*) bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SHORT:\n\t\t{ uint16* bp = (uint16*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (uint16) v[i];\n\t\t  if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SSHORT:\n\t\t{ int16* bp = (int16*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (int16) v[i];\n\t\t  if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32* bp = (uint32*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (uint32) v[i];\n\t\t  if (!TIFFWriteLongArray(tif, type, tag, dir, n, bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SLONG:\n\t\t{ int32* bp = (int32*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (int32) v[i];\n\t\t  if (!TIFFWriteLongArray(tif, type, tag, dir, n, (uint32*) bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_FLOAT:\n\t\t{ float* bp = (float*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (float) v[i];\n\t\t  if (!TIFFWriteFloatArray(tif, type, tag, dir, n, bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\treturn (TIFFWriteDoubleArray(tif, type, tag, dir, n, v));\n\tdefault:\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tgoto out;\n\t}\n\tstatus = 1;\n out:\n\tif (w != buf)\n\t\t_TIFFfree(w);\n\treturn (status);\n}\n", "bug_type": null, "idx": 104}
{"project": "LibTIFF", "target": 0, "func": "int\nTIFFSetDirectory(TIFF* tif, tdir_t dirn)\n{\n\ttoff_t nextdir;\n\ttdir_t n;\n\tnextdir = tif->tif_header.tiff_diroff;\n\tfor (n = dirn; n > 0 && nextdir != 0; n--)\n\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, NULL))\n\t\t\treturn (0);\n\ttif->tif_nextdiroff = nextdir;\n\t\n\n\n\n\n\ttif->tif_curdir = (dirn - n) - 1;\n\t\n\n\n\n\ttif->tif_dirnumber = 0;\n\treturn (TIFFReadDirectory(tif));\n}\n", "bug_type": null, "idx": 105}
{"project": "LibTIFF", "target": 0, "func": "int\nTIFFReadPrivateDataSubDirectory(TIFF* tif, toff_t pdir_offset,\n\t\t\t\tTIFFFieldInfo *field_info,\n\t\t\t\tint (*setFieldFn)(TIFF *tif, ttag_t tag, ...))\n{\n\tregister TIFFDirEntry* dp;\n\tregister int n;\n\tregister TIFFDirectory* td;\n\tTIFFDirEntry* dir;\n\tint iv;\n\tlong v;\n\tdouble dv;\n\tconst TIFFFieldInfo* fip;\n\tint fix;\n\tuint16 dircount;\n\tuint32 nextdiroff;\n\tchar* cp;\n\tint diroutoforderwarning = 0;\n\t\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, pdir_offset)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Seek error accessing TIFF private subdirectory\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (!ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Can not read TIFF private subdirectory count\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)CheckMalloc(tif,\n\t\t    dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\");\n\t\tif (dir == NULL)\n\t\t\treturn (0);\n\t\tif (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\");\n\t\t\tgoto bad;\n\t\t}\n\t\t\n\n\n\t\t(void) ReadOK(tif, &nextdiroff, sizeof (uint32));\n\t} else {\n\t\ttoff_t off = pdir_offset;\n\t\tif (off + sizeof (short) > tif->tif_size) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Can not read TIFF private subdirectory count\");\n\t\t\treturn (0);\n\t\t} else\n\t\t\t_TIFFmemcpy(&dircount, tif->tif_base + off, sizeof (uint16));\n\t\toff += sizeof (uint16);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)CheckMalloc(tif,\n\t\t    dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\");\n\t\tif (dir == NULL)\n\t\t\treturn (0);\n\t\tif (off + dircount*sizeof (TIFFDirEntry) > tif->tif_size) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\");\n\t\t\tgoto bad;\n\t\t} else\n\t\t\t_TIFFmemcpy(dir, tif->tif_base + off,\n\t\t\t    dircount*sizeof (TIFFDirEntry));\n\t\toff += dircount* sizeof (TIFFDirEntry);\n\t\tif (off + sizeof (uint32) < tif->tif_size)\n\t\t\t_TIFFmemcpy(&nextdiroff, tif->tif_base+off, sizeof (uint32));\n\t}\n\tif (tif->tif_flags & TIFF_SWAB)\n\t\tTIFFSwabLong(&nextdiroff);\n\t\n\n\n\n\n\n\n\ttd = &tif->tif_dir;\n\tfor (fip = field_info, dp = dir, n = dircount;\n\t     n > 0; n--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\t\t\n\n\n\t\t\n\n\n\n\n\t\tif (dp->tdir_tag < fip->field_tag) {\n\t\t\tif (!diroutoforderwarning) {\n\t\t\t\tTIFFWarning(tif->tif_name,\n\t\"invalid TIFF private subdirectory; tags are not sorted in ascending order\");\n\t\t\t\tdiroutoforderwarning = 1;\n\t\t\t}\n\t\t\tfip = field_info;    \n\t\t}\n\t\twhile (fip->field_tag && fip->field_tag < dp->tdir_tag)\n\t\t\tfip++;\n\t\tif (!fip->field_tag || fip->field_tag != dp->tdir_tag) {\n\t\t\tTIFFWarning(tif->tif_name,\n\t\t\t    \"unknown field with tag %d (0x%x) in private subdirectory ignored\",\n\t\t\t    dp->tdir_tag,  dp->tdir_tag);\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tfip = field_info;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\n\n\t\t\n\n\t\tif (0 ) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\n\n\t\twhile (dp->tdir_type != (u_short)fip->field_type) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t\n\t\t\t\tbreak;\n\t\t\tfip++;\n\t\t\tif (!fip->field_tag || fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarning(tif->tif_name,\n\t\t\t\t   \"wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t    dp->tdir_type, fip[-1].field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t\n\n\n\t\tif (fip->field_readcount != TIFF_VARIABLE) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\t\t\n\t\tif (!TIFFFetchNormalSubTag(tif, dp, fip, setFieldFn))\n\t\t    goto bad;\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}\n", "bug_type": null, "idx": 106}
{"project": "LibTIFF", "target": 0, "func": "subtract(32)\nstatic biasFn *lineSubtractFn (unsigned bits)\n{\n\tswitch (bits) {\n\t\tcase  8:  return subtract8;\n\t\tcase 16:  return subtract16;\n\t\tcase 32:  return subtract32;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 107}
{"project": "LibTIFF", "target": 0, "func": "static int \nwriteSelections(TIFF *in, TIFF **out, struct crop_mask *crop, \n                struct image_data *image, struct dump_opts *dump,\n                struct buffinfo seg_buffs[], char *mp, char *filename, \n                unsigned int *page, unsigned int total_pages)\n  {\n  int i, page_count;\n  int autoindex = 0;\n  unsigned char *crop_buff = NULL;\n    \n  switch (crop->exp_mode)\n    {\n    case ONE_FILE_COMPOSITE: \n         autoindex = 0;\n         crop_buff = seg_buffs[0].buffer;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = total_pages;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length,\n                               crop_buff, *page, total_pages))\n            {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t break;\n    case ONE_FILE_SEPARATED: \n         autoindex = 0;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = crop->selections * total_pages;\n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t   }\n         break;\n    case FILE_PER_IMAGE_COMPOSITE: \n         autoindex = 1;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         crop_buff = seg_buffs[0].buffer;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length, \n                               crop_buff, *page, total_pages))\n           {\n           TIFFError(\"writeRegions\", \"Unable to write new image\");\n           return (-1);\n           }\n         break;\n    case FILE_PER_IMAGE_SEPARATED: \n         autoindex = 1;\n         page_count = crop->selections;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           \n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n         break;\n    case FILE_PER_SELECTION:\n         autoindex = 1;\n\t page_count = 1;\n         for (i = 0; i < crop->selections; i++)\n           {\n           if (update_output_file (out, mp, autoindex, filename, page))\n             return (1);\n           crop_buff = seg_buffs[i].buffer;\n           \n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n\t break;\n    default: return (1);\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 108}
{"project": "LibTIFF", "target": 0, "func": "void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)\n    { setByteArray(vpp, vp, n, 1); }\n", "bug_type": null, "idx": 109}
{"project": "LibTIFF", "target": 0, "func": "void\nTIFFFreeDirectory(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tint            i;\n\t_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);\n\tCleanupField(td_colormap[0]);\n\tCleanupField(td_colormap[1]);\n\tCleanupField(td_colormap[2]);\n\tCleanupField(td_sampleinfo);\n\tCleanupField(td_subifd);\n\tCleanupField(td_inknames);\n\tCleanupField(td_transferfunction[0]);\n\tCleanupField(td_transferfunction[1]);\n\tCleanupField(td_transferfunction[2]);\n\tCleanupField(td_stripoffset);\n\tCleanupField(td_stripbytecount);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\n\t\n\tfor( i = 0; i < td->td_customValueCount; i++ ) {\n\t\tif (td->td_customValues[i].value)\n\t\t\t_TIFFfree(td->td_customValues[i].value);\n\t}\n\ttd->td_customValueCount = 0;\n\tCleanupField(td_customValues);\n}\n", "bug_type": null, "idx": 110}
{"project": "LibTIFF", "target": 0, "func": "int\nTIFFFlush(TIFF* tif)\n{\n    if( tif->tif_mode == O_RDONLY )\n        return 1;\n    if (!TIFFFlushData(tif))\n        return (0);\n    \n\n\n\n    if( (tif->tif_flags & TIFF_DIRTYSTRIP)\n        && !(tif->tif_flags & TIFF_DIRTYDIRECT) \n        && tif->tif_mode == O_RDWR )\n    {\n        uint64  *offsets=NULL, *sizes=NULL;\n        if( TIFFIsTiled(tif) )\n        {\n            if( TIFFGetField( tif, TIFFTAG_TILEOFFSETS, &offsets ) \n                && TIFFGetField( tif, TIFFTAG_TILEBYTECOUNTS, &sizes ) \n                && _TIFFRewriteField( tif, TIFFTAG_TILEOFFSETS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, offsets )\n                && _TIFFRewriteField( tif, TIFFTAG_TILEBYTECOUNTS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, sizes ) )\n            {\n                tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n                tif->tif_flags &= ~TIFF_BEENWRITING;\n                return 1;\n            }\n        }\n        else\n        {\n            if( TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &offsets ) \n                && TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &sizes ) \n                && _TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, offsets )\n                && _TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, sizes ) )\n            {\n                tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n                tif->tif_flags &= ~TIFF_BEENWRITING;\n                return 1;\n            }\n        }\n    }\n    if ((tif->tif_flags & (TIFF_DIRTYDIRECT|TIFF_DIRTYSTRIP)) \n        && !TIFFRewriteDirectory(tif))\n        return (0);\n    return (1);\n}\n", "bug_type": null, "idx": 111}
{"project": "LibTIFF", "target": 1, "func": "\nstatic void\nsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)\n{\n\tif (*vpp)\n\t\t_TIFFfree(*vpp), *vpp = 0;\n\tif (vp) {\n\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\n\t\tif (elem_size && bytes / elem_size == nmemb)\n\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\n\t\tif (*vpp)\n\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\n\t}\n}", "bug_type": "cve-2016-5315", "idx": 112}
{"project": "LibTIFF", "target": 0, "func": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\ttif = TIFFClientOpen(name, mode,\n\t    (thandle_t) fd,\n\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\n\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}\n", "bug_type": null, "idx": 113}
{"project": "LibTIFF", "target": 0, "func": "tdir_t\nTIFFNumberOfDirectories(TIFF* tif)\n{\n    toff_t nextdir = tif->tif_header.tiff_diroff;\n    tdir_t n = 0;\n    while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))\n        n++;\n    return (n);\n}\n", "bug_type": null, "idx": 114}
{"project": "LibTIFF", "target": 0, "func": "int\nTIFFVGetField(TIFF* tif, ttag_t tag, va_list ap)\n{\n\tconst TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);\n\treturn (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?\n\t    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);\n}\n", "bug_type": null, "idx": 115}
{"project": "LibTIFF", "target": 0, "func": "static int\nContigCompare(int sample, uint32 row,\n\t      unsigned char* p1, unsigned char* p2, tsize_t size)\n{\n    uint32 pix;\n    int ppb = 8 / bitspersample;\n    int\t samples_to_test;\n    if (memcmp(p1, p2, size) == 0)\n        return 0;\n    samples_to_test = (sample == -1) ? samplesperpixel : 1;\n    switch (bitspersample) {\n      case 1: case 2: case 4: case 8: \n      {\n          unsigned char *pix1 = p1, *pix2 = p2;\n          for (pix = 0; pix < imagewidth; pix += ppb) {\n              int\t\ts;\n              for(s = 0; s < samples_to_test; s++) {\n                  if (*pix1 != *pix2) {\n                      if( sample == -1 )\n                          PrintIntDiff(row, s, pix, *pix1, *pix2);\n                      else\n                          PrintIntDiff(row, sample, pix, *pix1, *pix2);\n                  }\n                  pix1++;\n                  pix2++;\n              }\n          }\n          break;\n      }\n      case 16: \n      {\n          uint16 *pix1 = (uint16 *)p1, *pix2 = (uint16 *)p2;\n          for (pix = 0; pix < imagewidth; pix++) {\n              int\ts;\n              for(s = 0; s < samples_to_test; s++) {\n                  if (*pix1 != *pix2)\n                      PrintIntDiff(row, sample, pix, *pix1, *pix2);\n                  pix1++;\n                  pix2++;\n              }\n          }\n          break;\n      }\n      case 32: \n\tif (sampleformat == SAMPLEFORMAT_UINT\n\t    || sampleformat == SAMPLEFORMAT_INT) {\n\t\tuint32 *pix1 = (uint32 *)p1, *pix2 = (uint32 *)p2;\n\t\tfor (pix = 0; pix < imagewidth; pix++) {\n\t\t\tint\ts;\n\t\t\tfor(s = 0; s < samples_to_test; s++) {\n\t\t\t\tif (*pix1 != *pix2) {\n\t\t\t\t\tPrintIntDiff(row, sample, pix,\n\t\t\t\t\t\t     *pix1, *pix2);\n\t\t\t\t}\n\t\t\t\tpix1++;\n\t\t\t\tpix2++;\n\t\t\t}\n\t\t}\n\t} else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\n\t\tfloat *pix1 = (float *)p1, *pix2 = (float *)p2;\n\t\tfor (pix = 0; pix < imagewidth; pix++) {\n\t\t\tint\ts;\n\t\t\tfor(s = 0; s < samples_to_test; s++) {\n\t\t\t\tif (fabs(*pix1 - *pix2) < 0.000000000001) {\n\t\t\t\t\tPrintFloatDiff(row, sample, pix,\n\t\t\t\t\t\t       *pix1, *pix2);\n\t\t\t\t}\n\t\t\t\tpix1++;\n\t\t\t\tpix2++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t  fprintf(stderr, \"Sample format %d is not supported.\\n\",\n\t\t\t  sampleformat);\n\t\t  return -1;\n\t}\n        break;\n      default:\n\tfprintf(stderr, \"Bit depth %d is not supported.\\n\", bitspersample);\n\treturn -1;\n    }\n    return 0;\n}\n", "bug_type": null, "idx": 116}
{"project": "LibTIFF", "target": 0, "func": "static tsize_t\n_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\treturn (write((int) fd, buf, size));\n}\n", "bug_type": null, "idx": 117}
{"project": "LibTIFF", "target": 0, "func": "static int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp)\n{\n\tregister uint32* lp;\n\tint status;\n\tif (!CheckDirCount(tif, dir, (uint32) nstrips))\n\t\treturn (0);\n\t\n\n\n\tif (*lpp == NULL &&\n\t    (*lpp = (uint32 *)CheckMalloc(tif,\n\t      nstrips * sizeof (uint32), \"for strip array\")) == NULL)\n\t\treturn (0);\n\tlp = *lpp;\n\tif (dir->tdir_type == (int)TIFF_SHORT) {\n\t\t\n\n\n\t\tuint16* dp = (uint16*) CheckMalloc(tif,\n\t\t    dir->tdir_count* sizeof (uint16), \"to fetch strip tag\");\n\t\tif (dp == NULL)\n\t\t\treturn (0);\n\t\tif (status = TIFFFetchShortArray(tif, dir, dp)) {\n\t\t\tregister uint16* wp = dp;\n\t\t\twhile (nstrips-- > 0)\n\t\t\t\t*lp++ = *wp++;\n\t\t}\n\t\t_TIFFfree((char*) dp);\n\t} else\n\t\tstatus = TIFFFetchLongArray(tif, dir, lp);\n\treturn (status);\n}\n", "bug_type": null, "idx": 118}
{"project": "LibTIFF", "target": 0, "func": "static tsize_t\n_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\treturn (FSRead((short) fd, (long*) &size, (char*) buf) == noErr ?\n\t    size : (tsize_t) -1);\n}\n", "bug_type": null, "idx": 119}
{"project": "LibTIFF", "target": 1, "func": "\nstatic int\nOJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesDcTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint8 o[16];\n\tuint32 p;\n\tuint32 q;\n\tuint32 ra;\n\tuint8* rb;\n\tif (sp->dctable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->dctable_offset[m]!=0) && ((m==0) || (sp->dctable_offset[m]!=sp->dctable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->dctable_offset[m]==sp->dctable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegDcTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET);\n\t\t\tp=(uint32)TIFFReadFile(tif,o,16);\n\t\t\tif (p!=16)\n\t\t\t\treturn(0);\n\t\t\tq=0;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\tq+=o[n];\n\t\t\tra=sizeof(uint32)+21+q;\n\t\t\trb=_TIFFmalloc(ra);\n\t\t\tif (rb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)rb=ra;\n\t\t\trb[sizeof(uint32)]=255;\n\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\t\trb[sizeof(uint32)+2]=(uint8)((19+q)>>8);\n\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\n\t\t\trb[sizeof(uint32)+4]=m;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\n\t\t\tp=(uint32)TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\n\t\t\tif (p!=q)\n\t\t\t\treturn(0);\n\t\t\tsp->dctable[m]=rb;\n\t\t\tsp->sos_tda[m]=(m<<4);\n\t\t}\n\t\telse\n\t\t\tsp->sos_tda[m]=sp->sos_tda[m-1];\n\t}\n\treturn(1);\n}", "bug_type": "cve-2017-7594", "idx": 120}
{"project": "LibTIFF", "target": 0, "func": "static int\nextractImageSection(struct image_data *image, struct pageseg *section, \n                    unsigned char *src_buff, unsigned char *sect_buff)\n  {\n  unsigned  char  bytebuff1, bytebuff2;\n#ifdef DEVELMODE\n  \n#endif\n  uint32    img_width, img_rowsize;\n#ifdef DEVELMODE\n  uint32    img_length;\n#endif\n  uint32    j, shift1, shift2, trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_offset, dst_offset, row_offset, col_offset;\n  uint32    offset1, offset2, full_bytes;\n  uint32    sect_width;\n#ifdef DEVELMODE\n  uint32    sect_length;\n#endif\n  uint16    bps, spp;\n#ifdef DEVELMODE\n  int      k;\n  unsigned char bitset;\n  static char *bitarray = NULL;\n#endif\n  img_width = image->width;\n#ifdef DEVELMODE\n  img_length = image->length;\n#endif\n  bps = image->bps;\n  spp = image->spp;\n#ifdef DEVELMODE\n  \n  \n#endif\n  src_offset = 0;\n  dst_offset = 0;\n#ifdef DEVELMODE\n  if (bitarray == NULL)\n    {\n    if ((bitarray = (char *)malloc(img_width)) == NULL)\n      {\n      TIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\");\n      return (-1);\n      }\n    }\n#endif\n  \n  first_row = section->y1;\n  last_row  = section->y2;\n  first_col = section->x1;\n  last_col  = section->x2;\n  sect_width = last_col - first_col + 1;\n#ifdef DEVELMODE\n  sect_length = last_row - first_row + 1;\n#endif\n  img_rowsize = ((img_width * bps + 7) / 8) * spp;\n  full_bytes = (sect_width * spp * bps) / 8;   \n  trailing_bits = (sect_width * bps) % 8;\n#ifdef DEVELMODE\n    TIFFError (\"\", \"First row: %d, last row: %d, First col: %d, last col: %d\\n\",\n           first_row, last_row, first_col, last_col);\n    TIFFError (\"\", \"Image width: %d, Image length: %d, bps: %d, spp: %d\\n\",\n\t   img_width, img_length, bps, spp);\n    TIFFError (\"\", \"Sect  width: %d,  Sect length: %d, full bytes: %d trailing bits %d\\n\", \n           sect_width, sect_length, full_bytes, trailing_bits);\n#endif\n  if ((bps % 8) == 0)\n    {\n    col_offset = first_col * spp * bps / 8;\n    for (row = first_row; row <= last_row; row++)\n      {\n      \n      row_offset = row * img_rowsize;\n      src_offset = row_offset + col_offset;\n#ifdef DEVELMODE\n        TIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset); \n#endif\n      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n      dst_offset += full_bytes;\n      }        \n    }\n  else\n    { \n    shift1  = spp * ((first_col * bps) % 8);\n    shift2  = spp * ((last_col * bps) % 8);\n    for (row = first_row; row <= last_row; row++)\n      {\n      \n      row_offset = row * img_rowsize;\n      offset1 = row_offset + (first_col * bps / 8);\n      offset2 = row_offset + (last_col * bps / 8);\n#ifdef DEVELMODE\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      sprintf(&bitarray[8], \" \");\n      sprintf(&bitarray[9], \" \");\n      for (j = 10, k = 7; j < 18; j++, k--)\n        {\n        bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      bitarray[18] = '\\0';\n      TIFFError (\"\", \"Row: %3d Offset1: %d,  Shift1: %d,    Offset2: %d,  Shift2:  %d\\n\", \n                 row, offset1, shift1, offset2, shift2); \n#endif\n      bytebuff1 = bytebuff2 = 0;\n      if (shift1 == 0) \n        {\n\t_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);\n#ifdef DEVELMODE\n\tTIFFError (\"\", \"        Alligned data src offset1: %8d, Dst offset: %8d\\n\", offset1, dst_offset); \n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n        if (trailing_bits != 0)\n          {\n\t  bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));\n          sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Trailing bits src offset:  %8d, Dst offset: %8d\\n\", \n                              offset2, dst_offset); \n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n          dst_offset++;\n          }\n        }\n      else   \n        {\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Unalligned data src offset: %8d, Dst offset: %8d\\n\", offset1 , dst_offset); \n#endif\n        for (j = 0; j <= full_bytes; j++) \n          {\n\t  bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);\n\t  bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));\n          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));\n          }\n#ifdef DEVELMODE\n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n        if (trailing_bits != 0)\n          {\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Trailing bits   src offset: %8d, Dst offset: %8d\\n\", offset1 + full_bytes, dst_offset); \n#endif\n\t  if (shift2 > shift1)\n            {\n\t    bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));\n            bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);\n            sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Shift2 > Shift1\\n\"); \n#endif\n            }\n          else\n            {\n\t    if (shift2 < shift1)\n              {\n              bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));\n\t      sect_buff[dst_offset] &= bytebuff2;\n#ifdef DEVELMODE\n\t      TIFFError (\"\", \"        Shift2 < Shift1\\n\"); \n#endif\n              }\n#ifdef DEVELMODE\n            else\n\t      TIFFError (\"\", \"        Shift2 == Shift1\\n\"); \n#endif\n            }\n\t  }\n#ifdef DEVELMODE\n\t  sprintf(&bitarray[28], \" \");\n\t  sprintf(&bitarray[29], \" \");\n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n        dst_offset++;\n        }\n      }\n    }\n  return (0);\n  } \n", "bug_type": null, "idx": 121}
{"project": "LibTIFF", "target": 0, "func": "extern int close(int fd)\n{\n\treturn ((int) xosfind_close((os_f) fd));\n}\n", "bug_type": null, "idx": 122}
