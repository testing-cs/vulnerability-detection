{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nmakepng_error(png_structp png_ptr, png_const_charp message)\n{\n   makepng_warning(png_ptr, message);\n   png_longjmp(png_ptr, 1);\n}\n", "bug_type": null, "idx": 0}
{"project": "LibPNG", "target": 0, "func": "static unsigned int\nbit_size(png_const_structp pp, png_byte colour_type, png_byte bit_depth)\n{\n   switch (colour_type)\n   {\n      default: png_error(pp, \"invalid color type\");\n      case 0:  return bit_depth;\n      case 2:  return 3*bit_depth;\n      case 3:  return bit_depth;\n      case 4:  return 2*bit_depth;\n      case 6:  return 4*bit_depth;\n   }\n}\n", "bug_type": null, "idx": 1}
{"project": "LibPNG", "target": 0, "func": "static int\nmake_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,\n    int bdlo, int PNG_CONST bdhi)\n{\n   for (; bdlo <= bdhi; ++bdlo)\n   {\n      int interlace_type;\n      for (interlace_type = PNG_INTERLACE_NONE;\n           interlace_type < INTERLACE_LAST; ++interlace_type)\n      {\n         unsigned int test;\n         char name[FILE_NAME_SIZE];\n         standard_name(name, sizeof name, 0, colour_type, 1<<bdlo, 0,\n            interlace_type, 0, 0, 0);\n         for (test=0; test<ARRAY_SIZE(error_test); ++test)\n         {\n            make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type,\n               test, name);\n            if (fail(pm))\n               return 0;\n         }\n      }\n   }\n   return 1; \n}\n", "bug_type": null, "idx": 2}
{"project": "LibPNG", "target": 0, "func": "static void\ntest_one_file(struct display *dp, const char *filename)\n{\n   \n\n\n   dp->operation = \"cache file\";\n   dp->transforms = 0;\n   display_cache_file(dp, filename);\n   update_display(dp);\n   \n\n\n   if (dp->ignored_transforms != 0)\n   {\n      read_png(dp, &dp->original_file, \"ignored transforms\",\n         dp->ignored_transforms);\n      \n      if (!compare_read(dp, 0))\n         return; \n   }\n#ifdef PNG_WRITE_SUPPORTED\n   \n\n\n\n   dp->operation = \"write\";\n   write_png(dp, dp->original_ip, 0);\n   read_png(dp, &dp->written_file, NULL, 0);\n   if (!compare_read(dp, 0))\n      return;\n#endif\n   \n\n\n   {\n      \n\n\n\n      unsigned int active = dp->active_transforms;\n      const int exhaustive = (dp->options & EXHAUSTIVE) != 0;\n      unsigned int current = first_transform(active);\n      unsigned int bad_transforms = 0;\n      unsigned int bad_combo = ~0U;    \n      unsigned int bad_combo_list = 0; \n      for (;;)\n      {\n         read_png(dp, &dp->original_file, \"active transforms\", current);\n         \n\n\n\n\n\n\n\n\n\n#ifdef PNG_WRITE_SUPPORTED\n         if ((current & write_transforms) == current)\n         {\n            \n\n\n\n\n            dp->operation = \"reversible transforms\";\n            write_png(dp, dp->read_ip, current);\n            \n\n\n            read_png(dp, &dp->written_file, NULL, 0);\n            if (!compare_read(dp, current))\n            {\n               \n\n\n\n\n               if (is_combo(current))\n               {\n                  bad_combo &= current;\n                  bad_combo_list |= current;\n               }\n               else\n                  bad_transforms |= current;\n            }\n         }\n#endif\n         \n         if (exhaustive) \n         {\n            unsigned int next = current;\n            do\n            {\n               if (next == read_transforms) \n                  goto combo;\n               ++next;\n            }  \n\n\n            while (  (next & read_transforms) <= current\n                  || (next & active) == 0 \n                  || (next & bad_transforms) != 0\n                  || skip_transform(dp, next));\n            assert((next & read_transforms) == next);\n            current = next;\n         }\n         else \n         {\n            active &= ~current;\n            if (active == 0)\n               goto combo;\n            current = first_transform(active);\n         }\n      }\ncombo:\n      if (dp->options & FIND_BAD_COMBOS)\n      {\n         \n\n\n\n         if (bad_combo != ~0U)\n            printf(\"%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x\\n\",\n               dp->filename, active, bad_combo, bad_combo_list,\n               rw_transforms & ~bad_combo_list);\n         else\n            printf(\"%s: no %sbad combos found\\n\", dp->filename,\n               (dp->options & SKIP_BUGS) ? \"additional \" : \"\");\n      }\n   }\n}\n", "bug_type": null, "idx": 3}
{"project": "LibPNG", "target": 0, "func": "static double\nchromaticity_y(CIE_color c)\n{\n   return c.Y / (c.X + c.Y + c.Z);\n}\n", "bug_type": null, "idx": 4}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_rgb_to_gray_ini(PNG_CONST image_transform *this,\n    transform_display *that)\n{\n   png_modifier *pm = that->pm;\n   PNG_CONST color_encoding *e = pm->current_encoding;\n   UNUSED(this)\n   \n   pm->test_uses_encoding = 1;\n   \n\n\n   if (e != 0)\n   {\n      \n\n\n      PNG_CONST double whiteY = e->red.Y + e->green.Y + e->blue.Y;\n      data.red_coefficient = e->red.Y;\n      data.green_coefficient = e->green.Y;\n      data.blue_coefficient = e->blue.Y;\n      if (whiteY != 1)\n      {\n         data.red_coefficient /= whiteY;\n         data.green_coefficient /= whiteY;\n         data.blue_coefficient /= whiteY;\n      }\n   }\n   else\n   {\n      \n      data.red_coefficient = 6968 / 32768.;\n      data.green_coefficient = 23434 / 32768.;\n      data.blue_coefficient = 2366 / 32768.;\n   }\n   data.gamma = pm->current_gamma;\n   \n   if (data.gamma == 0)\n      data.gamma = 1;\n   \n\n\n\n   if (pm->test_exhaustive)\n   {\n      \n\n\n\n      data.coefficients_overridden = !data.coefficients_overridden;\n      pm->repeat = data.coefficients_overridden != 0;\n   }\n   else\n      data.coefficients_overridden = random_choice();\n   if (data.coefficients_overridden)\n   {\n      \n\n\n      png_uint_32 ru;\n      double total;\n      RANDOMIZE(ru);\n      data.green_coefficient = total = (ru & 0xffff) / 65535.;\n      ru >>= 16;\n      data.red_coefficient = (1 - total) * (ru & 0xffff) / 65535.;\n      total += data.red_coefficient;\n      data.blue_coefficient = 1 - total;\n#     ifdef PNG_FLOATING_POINT_SUPPORTED\n         data.red_to_set = data.red_coefficient;\n         data.green_to_set = data.green_coefficient;\n#     else\n         data.red_to_set = fix(data.red_coefficient);\n         data.green_to_set = fix(data.green_coefficient);\n#     endif\n      \n      pm->encoding_ignored = 1;\n   }\n   else\n   {\n      data.red_to_set = -1;\n      data.green_to_set = -1;\n   }\n   \n\n\n   if (data.gamma != 1) \n   {\n      if (that->this.bit_depth == 16 || pm->assume_16_bit_calculations)\n      {\n         \n\n\n\n\n\n\n\n\n         that->pm->limit +=\n#        if PNG_MAX_GAMMA_8 < 14\n               pow((that->this.bit_depth == 16 ?\n                  8. : 6. + (1<<(15-PNG_MAX_GAMMA_8)))/65535, data.gamma);\n#        else\n               pow((that->this.bit_depth == 16 ?\n                  8. : 8. + (1<<(15-PNG_MAX_GAMMA_8)))/65535, data.gamma);\n#        endif\n      }\n      else\n      {\n         \n\n\n\n\n\n\n\n\n\n\n\n\n         that->pm->limit +=\n#        if DIGITIZE\n             pow(1.1 /255, data.gamma);\n#        else\n             pow(1.0 /255, data.gamma);\n#        endif\n      }\n   }\n   else\n   {\n      \n\n\n      if (that->this.bit_depth != 16 && !pm->assume_16_bit_calculations)\n         that->pm->limit += 4E-3;\n   }\n}\n", "bug_type": null, "idx": 5}
{"project": "LibPNG", "target": 0, "func": "static int global_showmode;\nint WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode)\n{\n    char *args[1024];                 \n    char **argv = args;\n    char *p, *q, *bgstr = NULL;\n    int argc = 0;\n    int rc, alen, flen;\n    int error = 0;\n    int timing = FALSE;\n    int have_bg = FALSE;\n    double LUT_exponent;              \n    double CRT_exponent = 2.2;        \n    double default_display_exponent;  \n    MSG msg;\n    \n\n\n    global_hInst = hInst;\n    global_showmode = showmode;\n    filename = (char *)NULL;\n    memset(&rpng2_info, 0, sizeof(mainprog_info));\n#ifndef __CYGWIN__\n    \n\n\n\n    AllocConsole();\n    freopen(\"CONOUT$\", \"a\", stderr);\n    freopen(\"CONOUT$\", \"a\", stdout);\n#endif\n    \n\n\n\n\n\n#if defined(NeXT)\n    \n    LUT_exponent = 1.0 / 2.2;\n    \n\n\n\n#elif defined(sgi)\n    LUT_exponent = 1.0 / 1.7;\n    \n\n    infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");\n    if (infile) {\n        double sgi_gamma;\n        fgets(tmpline, 80, infile);\n        fclose(infile);\n        sgi_gamma = atof(tmpline);\n        if (sgi_gamma > 0.0)\n            LUT_exponent = 1.0 / sgi_gamma;\n    }\n#elif defined(Macintosh)\n    LUT_exponent = 1.8 / 2.61;\n    \n\n\n\n#else\n    LUT_exponent = 1.0;   \n#endif\n    \n    default_display_exponent = LUT_exponent * CRT_exponent;\n    \n\n\n\n    if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)\n        rpng2_info.display_exponent = atof(p);\n    else\n        rpng2_info.display_exponent = default_display_exponent;\n    \n\n\n    argv[argc++] = PROGNAME;\n    p = cmd;\n    for (;;) {\n        if (*p == ' ')\n            while (*++p == ' ')\n                ;\n        \n        if (*p == '\\0')\n            break;    \n        argv[argc++] = q = p;\n        while (*q && *q != ' ')\n            ++q;\n        \n        if (*q == '\\0')\n            break;    \n        *q = '\\0';    \n        p = q + 1;\n    }\n    argv[argc] = NULL;   \n    \n    while (*++argv && !error) {\n        if (!strncmp(*argv, \"-gamma\", 2)) {\n            if (!*++argv)\n                ++error;\n            else {\n                rpng2_info.display_exponent = atof(*argv);\n                if (rpng2_info.display_exponent <= 0.0)\n                    ++error;\n            }\n        } else if (!strncmp(*argv, \"-bgcolor\", 4)) {\n            if (!*++argv)\n                ++error;\n            else {\n                bgstr = *argv;\n                if (strlen(bgstr) != 7 || bgstr[0] != '#')\n                    ++error;\n                else {\n                    have_bg = TRUE;\n                    bg_image = FALSE;\n                }\n            }\n        } else if (!strncmp(*argv, \"-bgpat\", 4)) {\n            if (!*++argv)\n                ++error;\n            else {\n                pat = atoi(*argv) - 1;\n                if (pat < 0 || pat >= num_bgpat)\n                    ++error;\n                else {\n                    bg_image = TRUE;\n                    have_bg = FALSE;\n                }\n            }\n        } else if (!strncmp(*argv, \"-timing\", 2)) {\n            timing = TRUE;\n        } else {\n            if (**argv != '-') {\n                filename = *argv;\n                if (argv[1])   \n                    ++error;\n            } else\n                ++error;   \n        }\n    }\n    if (!filename)\n        ++error;\n    \n    if (error) {\n#ifndef __CYGWIN__\n        int ch;\n#endif\n        fprintf(stderr, \"\\n%s %s:  %s\\n\\n\", PROGNAME, VERSION, appname);\n        readpng2_version_info();\n        fprintf(stderr, \"\\n\"\n          \"Usage:  %s [-gamma exp] [-bgcolor bg | -bgpat pat] [-timing]\\n\"\n          \"        %*s file.png\\n\\n\"\n          \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"\n          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"\n          \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"\n          \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"\n          \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"\n          \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"\n          \"\\t\\t  used with transparent images; overrides -bgpat option\\n\"\n          \"    pat \\tdesired background pattern number (1-%d); used with\\n\"\n          \"\\t\\t  transparent images; overrides -bgcolor option\\n\"\n          \"    -timing\\tenables delay for every block read, to simulate modem\\n\"\n          \"\\t\\t  download of image (~36 Kbps)\\n\"\n          \"\\nPress Q, Esc or mouse button 1 after image is displayed to quit.\\n\"\n#ifndef __CYGWIN__\n          \"Press Q or Esc to quit this usage screen. \",\n#else\n          ,\n#endif\n          PROGNAME,\n#if (defined(__i386__) || defined(_M_IX86) || defined(__x86_64__)) && \\\n    !(defined(__CYGWIN__) || defined(__MINGW32__))\n          (int)strlen(PROGNAME), \" \",\n#endif\n          (int)strlen(PROGNAME), \" \", default_display_exponent, num_bgpat);\n        fflush(stderr);\n#ifndef __CYGWIN__\n        do\n            ch = _getch();\n        while (ch != 'q' && ch != 'Q' && ch != 0x1B);\n#endif\n        exit(1);\n    }\n    if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);\n        ++error;\n    } else {\n        incount = fread(inbuf, 1, INBUFSIZE, infile);\n        if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {\n            fprintf(stderr, PROGNAME\n              \":  [%s] is not a PNG file: incorrect signature\\n\",\n              filename);\n            ++error;\n        } else if ((rc = readpng2_init(&rpng2_info)) != 0) {\n            switch (rc) {\n                case 2:\n                    fprintf(stderr, PROGNAME\n                      \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);\n                    break;\n                case 4:\n                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");\n                    break;\n                default:\n                    fprintf(stderr, PROGNAME\n                      \":  unknown readpng2_init() error\\n\");\n                    break;\n            }\n            ++error;\n        }\n        if (error)\n            fclose(infile);\n    }\n    if (error) {\n#ifndef __CYGWIN__\n        int ch;\n#endif\n        fprintf(stderr, PROGNAME \":  aborting.\\n\");\n#ifndef __CYGWIN__\n        do\n            ch = _getch();\n        while (ch != 'q' && ch != 'Q' && ch != 0x1B);\n#endif\n        exit(2);\n    } else {\n        fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, appname);\n#ifndef __CYGWIN__\n        fprintf(stderr,\n          \"\\n   [console window:  closing this window will terminate %s]\\n\\n\",\n          PROGNAME);\n#endif\n        fflush(stderr);\n    }\n    \n    alen = strlen(appname);\n    flen = strlen(filename);\n    if (alen + flen + 3 > 1023)\n        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));\n    else\n        sprintf(titlebar, \"%s:  %s\", appname, filename);\n    \n    if (have_bg) {\n        unsigned r, g, b;   \n        sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);\n        rpng2_info.bg_red   = (uch)r;\n        rpng2_info.bg_green = (uch)g;\n        rpng2_info.bg_blue  = (uch)b;\n    } else\n        rpng2_info.need_bgcolor = TRUE;\n    rpng2_info.state = kPreInit;\n    rpng2_info.mainprog_init = rpng2_win_init;\n    rpng2_info.mainprog_display_row = rpng2_win_display_row;\n    rpng2_info.mainprog_finish_display = rpng2_win_finish_display;\n    \n\n\n\n\n\n\n\n    for (;;) {\n        Trace((stderr, \"about to call readpng2_decode_data()\\n\"))\n        if (readpng2_decode_data(&rpng2_info, inbuf, incount))\n            ++error;\n        Trace((stderr, \"done with readpng2_decode_data()\\n\"))\n        if (error || incount != INBUFSIZE || rpng2_info.state == kDone) {\n            if (rpng2_info.state == kDone) {\n                Trace((stderr, \"done decoding PNG image\\n\"))\n            } else if (ferror(infile)) {\n                fprintf(stderr, PROGNAME\n                  \":  error while reading PNG image file\\n\");\n                exit(3);\n            } else if (feof(infile)) {\n                fprintf(stderr, PROGNAME \":  end of file reached \"\n                  \"(unexpectedly) while reading PNG image file\\n\");\n                exit(3);\n            } else  {\n                \n            }\n            break;\n        }\n        if (timing)\n            Sleep(1000L);\n        incount = fread(inbuf, 1, INBUFSIZE, infile);\n    }\n    \n    fclose(infile);\n    Trace((stderr, \"about to call readpng2_cleanup()\\n\"))\n    readpng2_cleanup(&rpng2_info);\n    if (error) {\n        fprintf(stderr, PROGNAME \":  libpng error while decoding PNG image\\n\");\n        exit(3);\n    }\n    \n    while (GetMessage(&msg, NULL, 0, 0)) {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    \n    Trace((stderr, \"about to call rpng2_win_cleanup()\\n\"))\n    rpng2_win_cleanup();\n    return msg.wParam;\n}\n", "bug_type": null, "idx": 6}
{"project": "LibPNG", "target": 0, "func": "static void\ndisplay_destroy(struct display *dp)\n{\n    \n#  ifdef PNG_WRITE_SUPPORTED\n      buffer_destroy(&dp->written_file);\n#  endif\n   buffer_destroy(&dp->original_file);\n}\n", "bug_type": null, "idx": 7}
{"project": "LibPNG", "target": 0, "func": "static void\ninit_display(display *d, const char *program)\n{\n   memset(d, 0, sizeof *d);\n   d->png_ptr = NULL;\n   d->info_ptr = d->end_ptr = NULL;\n   d->error_count = d->warning_count = 0;\n   d->program = program;\n   d->file = program;\n   d->test = init;\n}\n", "bug_type": null, "idx": 8}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_rgb_to_gray_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(bit_depth)\n   this->next = *that;\n   *that = this;\n   return (colour_type & PNG_COLOR_MASK_COLOR) != 0;\n}\n", "bug_type": null, "idx": 9}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_b16c(Pixel *out, const Pixel *in, const Background *back)\n{\n   if (in->a <= 0)\n   {\n      out->r = back->ir;\n      out->g = back->ig;\n      out->b = back->ib;\n   }\n   else\n   {\n      double a = in->a/65535.;\n      double a1 = 1-a;\n      a /= 65535;\n      out->r = sRGB(in->r * a + back->dr * a1);\n      out->g = sRGB(in->g * a + back->dg * a1);\n      out->b = sRGB(in->b * a + back->db * a1);\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 10}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\ndisplay_error(png_structp pp, png_const_charp error)\n{\n   struct display *dp = get_dp(pp);\n   display_log(dp, LIBPNG_ERROR, \"%s\", error);\n}\n", "bug_type": null, "idx": 11}
{"project": "LibPNG", "target": 1, "func": "\n\nvoid \npng_write_iCCP(png_structp png_ptr, png_const_charp name, int compression_type,\n    png_const_charp profile, int profile_len)\n{\n   PNG_iCCP;\n   png_size_t name_len;\n   png_charp new_name;\n   compression_state comp;\n   int embedded_profile_len = 0;\n\n   png_debug(1, \"in png_write_iCCP\");\n\n   comp.num_output_ptr = 0;\n   comp.max_output_ptr = 0;\n   comp.output_ptr = NULL;\n   comp.input = NULL;\n   comp.input_len = 0;\n\n   if ((name_len = png_check_keyword(png_ptr, name, &new_name)) == 0)\n      return;\n\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\n      png_warning(png_ptr, \"Unknown compression type in iCCP chunk\");\n\n   if (profile == NULL)\n      profile_len = 0;\n\n   if (profile_len > 3)\n      embedded_profile_len =\n          ((*( (png_const_bytep)profile    ))<<24) |\n          ((*( (png_const_bytep)profile + 1))<<16) |\n          ((*( (png_const_bytep)profile + 2))<< 8) |\n          ((*( (png_const_bytep)profile + 3))    );\n\n   if (embedded_profile_len < 0)\n   {\n      png_warning(png_ptr,\n          \"Embedded profile length in iCCP chunk is negative\");\n\n      png_free(png_ptr, new_name);\n      return;\n   }\n\n   if (profile_len < embedded_profile_len)\n   {\n      png_warning(png_ptr,\n          \"Embedded profile length too large in iCCP chunk\");\n\n      png_free(png_ptr, new_name);\n      return;\n   }\n\n   if (profile_len > embedded_profile_len)\n   {\n      png_warning(png_ptr,\n          \"Truncating profile to actual length in iCCP chunk\");\n\n      profile_len = embedded_profile_len;\n   }\n\n   if (profile_len)\n      profile_len = png_text_compress(png_ptr, profile,\n          (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);\n\n   \n   png_write_chunk_start(png_ptr, png_iCCP,\n       (png_uint_32)(name_len + profile_len + 2));\n\n   new_name[name_len + 1] = 0x00;\n\n   png_write_chunk_data(png_ptr, (png_bytep)new_name,\n       (png_size_t)(name_len + 2));\n\n   if (profile_len)\n      png_write_compressed_data_out(png_ptr, &comp);\n\n   png_write_chunk_end(png_ptr);\n   png_free(png_ptr, new_name);\n}\n#endif", "bug_type": "cve-2009-5063", "idx": 12}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_argb16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = pp[1];\n   p->g = pp[2];\n   p->b = pp[3];\n   p->a = pp[0];\n}\n", "bug_type": null, "idx": 13}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,\n    png_byte bit_depth, png_uint_32 x, store_palette palette)\n{\n   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==\n      PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);\n   PNG_CONST unsigned int max = (1U<<sample_depth)-1;\n   \n\n\n\n   this->palette_index = this->red = this->green = this->blue =\n      sample(row, colour_type, bit_depth, x, 0);\n   this->alpha = max;\n   this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =\n      sample_depth;\n   \n   if (colour_type == 3) \n   {\n      \n      if (palette != 0)\n      {\n         PNG_CONST unsigned int i = this->palette_index;\n         this->red = palette[i].red;\n         this->green = palette[i].green;\n         this->blue = palette[i].blue;\n         this->alpha = palette[i].alpha;\n      }\n   }\n   else \n   {\n      unsigned int i = 0;\n      if (colour_type & 2)\n      {\n         this->green = sample(row, colour_type, bit_depth, x, 1);\n         this->blue = sample(row, colour_type, bit_depth, x, 2);\n         i = 2;\n      }\n      if (colour_type & 4)\n         this->alpha = sample(row, colour_type, bit_depth, x, ++i);\n   }\n   \n\n\n\n   image_pixel_setf(this, max);\n   \n\n\n   this->colour_type = colour_type;\n   this->bit_depth = bit_depth;\n   this->sample_depth = sample_depth;\n   this->have_tRNS = 0;\n}\n", "bug_type": null, "idx": 14}
{"project": "LibPNG", "target": 0, "func": "static void\nbuffer_destroy(struct buffer *buffer)\n{\n   struct buffer_list *list = buffer->first.next;\n   buffer_init(buffer);\n   buffer_destroy_list(list);\n}\n", "bug_type": null, "idx": 15}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\ncrc_init_4(png_uint_32 value)\n{\n   \n\n\n\n\n\n\n   png_uint_32 crc = crc_table[(~value >> 24)] ^ 0xffffff;\n   crc = crc_table[(crc ^ (value >> 16)) & 0xff] ^ (crc >> 8);\n   crc = crc_table[(crc ^ (value >> 8)) & 0xff] ^ (crc >> 8);\n   return crc_table[(crc ^ value) & 0xff] ^ (crc >> 8);\n}\n", "bug_type": null, "idx": 16}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_random_bytes(png_uint_32* seed, void* pv, size_t size)\n{\n   png_uint_32 u0 = seed[0], u1 = seed[1];\n   png_bytep bytes = voidcast(png_bytep, pv);\n   \n\n\n   size_t i;\n   for (i=0; i<size; ++i)\n   {\n      \n      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;\n      u1 <<= 8;\n      u1 |= u0 >> 24;\n      u0 <<= 8;\n      u0 |= u;\n      *bytes++ = (png_byte)u;\n   }\n   seed[0] = u0;\n   seed[1] = u1;\n}\n", "bug_type": null, "idx": 17}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_@_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_@(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 18}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_storenew(png_store *ps)\n{\n   png_store_buffer *pb;\n   if (ps->writepos != STORE_BUFFER_SIZE)\n      png_error(ps->pwrite, \"invalid store call\");\n   pb = voidcast(png_store_buffer*, malloc(sizeof *pb));\n   if (pb == NULL)\n      png_error(ps->pwrite, \"store new: OOM\");\n   *pb = ps->new;\n   ps->new.prev = pb;\n   ps->writepos = 0;\n}\n", "bug_type": null, "idx": 19}
{"project": "LibPNG", "target": 0, "func": "static chunk_insert *\nmake_insert(png_const_charp what,\n   void (*insert)(png_structp, png_infop, int, png_charpp),\n   int nparams, png_charpp list)\n{\n   int i;\n   chunk_insert *cip;\n   cip = malloc(offsetof(chunk_insert,parameters) +\n      nparams * sizeof (png_charp));\n   if (cip == NULL)\n   {\n      fprintf(stderr, \"--insert %s: out of memory allocating %d parameters\\n\",\n         what, nparams);\n      exit(1);\n   }\n   cip->next = NULL;\n   cip->insert = insert;\n   cip->nparams = nparams;\n   for (i=0; i<nparams; ++i)\n      cip->parameters[i] = list[i];\n   return cip;\n}\n", "bug_type": null, "idx": 20}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\nformatof(const char *arg)\n{\n   char *ep;\n   unsigned long format = strtoul(arg, &ep, 0);\n   if (ep > arg && *ep == 0 && format < FORMAT_COUNT)\n      return (png_uint_32)format;\n   else for (format=0; format < FORMAT_COUNT; ++format)\n   {\n      if (strcmp(format_names[format], arg) == 0)\n         return (png_uint_32)format;\n   }\n   fprintf(stderr, \"pngstest: format name '%s' invalid\\n\", arg);\n   return FORMAT_COUNT;\n}\n", "bug_type": null, "idx": 21}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_four_random_bytes(png_uint_32* seed, png_bytep bytes)\n{\n   make_random_bytes(seed, bytes, 4);\n}\n", "bug_type": null, "idx": 22}
{"project": "LibPNG", "target": 0, "func": "static void\nsBIT_error_fn(png_structp pp, png_infop pi)\n{\n   png_byte bit_depth;\n   png_color_8 bad;\n   if (png_get_color_type(pp, pi) == PNG_COLOR_TYPE_PALETTE)\n      bit_depth = 8;\n   else\n      bit_depth = png_get_bit_depth(pp, pi);\n   \n   bad.red = bad.green = bad.blue = bad.gray = bad.alpha =\n      (png_byte)(bit_depth+1);\n   png_set_sBIT(pp, pi, &bad);\n}\n", "bug_type": null, "idx": 23}
{"project": "LibPNG", "target": 0, "func": "static void rpng2_win_cleanup()\n{\n    if (bg_image && bg_data) {\n        free(bg_data);\n        bg_data = NULL;\n    }\n    if (rpng2_info.image_data) {\n        free(rpng2_info.image_data);\n        rpng2_info.image_data = NULL;\n    }\n    if (rpng2_info.row_pointers) {\n        free(rpng2_info.row_pointers);\n        rpng2_info.row_pointers = NULL;\n    }\n    if (dib) {\n        free(dib);\n        dib = NULL;\n    }\n}\n", "bug_type": null, "idx": 24}
{"project": "LibPNG", "target": 0, "func": "static void\nset_text(png_structp png_ptr, png_infop info_ptr, png_textp text,\n   png_charp param)\n{\n   switch (param[0])\n   {\n      case '<':\n         {\n            png_bytep file = NULL;\n            text->text_length = load_file(param+1, &file);\n            text->text = (png_charp)file;\n         }\n         break;\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n         {\n            png_bytep data = NULL;\n            png_size_t fake_len = load_fake(param, &data);\n            if (fake_len > 0) \n            {\n               text->text_length = fake_len;\n               text->text = (png_charp)data;\n               break;\n            }\n         }\n      default:\n         text->text = param;\n         break;\n   }\n   png_set_text(png_ptr, info_ptr, text, 1);\n   if (text->text != param)\n      free(text->text);\n}\n", "bug_type": null, "idx": 25}
{"project": "LibPNG", "target": 0, "func": "#ifdef PNG_READ_TRANSFORMS_SUPPORTED\nstatic size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d,\n    int precision)\n{\n   char number[64];\n   sprintf(number, \"%.*f\", precision, d);\n   return safecat(buffer, bufsize, pos, number);\n}\n", "bug_type": null, "idx": 26}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_image_validate(standard_display *dp, png_const_structp pp, int iImage,\n    int iDisplay)\n{\n   png_uint_32 y;\n   if (iImage >= 0)\n      store_image_check(dp->ps, pp, iImage);\n   if (iDisplay >= 0)\n      store_image_check(dp->ps, pp, iDisplay);\n   for (y=0; y<dp->h; ++y)\n      standard_row_validate(dp, pp, iImage, iDisplay, y);\n   \n   dp->ps->validated = 1;\n}\n", "bug_type": null, "idx": 27}
{"project": "LibPNG", "target": 1, "func": "\nvoid PNGAPI\npng_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n      return;\n   }\n\n   \n\n\n\n\n\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n\n   \n\n\n\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n\n   info_ptr->free_me |= PNG_FREE_PLTE;\n\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "bug_type": "cve-2015-8472", "idx": 28}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_default_ini(PNG_CONST image_transform *this,\n    transform_display *that)\n{\n   this->next->ini(this->next, that);\n}\n", "bug_type": null, "idx": 29}
{"project": "LibPNG", "target": 0, "func": "static void\ninterlace_row(png_bytep buffer, png_const_bytep imageRow,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   png_uint_32 xin, xout, xstep;\n   \n\n\n\n   xin = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xout=0; xin<w; xin+=xstep)\n   {\n      pixel_copy(buffer, xout, imageRow, xin, pixel_size);\n      ++xout;\n   }\n}\n", "bug_type": null, "idx": 30}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nstore_write(png_structp ppIn, png_bytep pb, png_size_t st)\n{\n   png_const_structp pp = ppIn;\n   png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));\n   if (ps->pwrite != pp)\n      png_error(pp, \"store state damaged\");\n   while (st > 0)\n   {\n      size_t cb;\n      if (ps->writepos >= STORE_BUFFER_SIZE)\n         store_storenew(ps);\n      cb = st;\n      if (cb > STORE_BUFFER_SIZE - ps->writepos)\n         cb = STORE_BUFFER_SIZE - ps->writepos;\n      memcpy(ps->new.buffer + ps->writepos, pb, cb);\n      pb += cb;\n      st -= cb;\n      ps->writepos += cb;\n   }\n}\n", "bug_type": null, "idx": 31}
{"project": "LibPNG", "target": 0, "func": "static void\nclear(void *pv, size_t size)\n{\n   static png_uint_32 clear_seed[2] = { 0x12345678, 0x9abcdef0 };\n   make_random_bytes(clear_seed, pv, size);\n}\n", "bug_type": null, "idx": 32}
{"project": "LibPNG", "target": 0, "func": "static int\npixel_depth_of_type(int color_type, int bit_depth)\n{\n   return channels_of_type(color_type) * bit_depth;\n}\n", "bug_type": null, "idx": 33}
{"project": "LibPNG", "target": 0, "func": "static void\npng_cexcept_error(png_structp png_ptr, png_const_charp msg)\n{\n   if(png_ptr)\n     ;\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n   fprintf(stderr, \"libpng error: %s\\n\", msg);\n#endif\n   {\n      Throw msg;\n   }\n}\n", "bug_type": null, "idx": 34}
{"project": "LibPNG", "target": 0, "func": "static void\nsequential_row(standard_display *dp, png_structp pp, png_infop pi,\n    PNG_CONST int iImage, PNG_CONST int iDisplay)\n{\n   PNG_CONST int         npasses = dp->npasses;\n   PNG_CONST int         do_interlace = dp->do_interlace &&\n      dp->interlace_type == PNG_INTERLACE_ADAM7;\n   PNG_CONST png_uint_32 height = standard_height(pp, dp->id);\n   PNG_CONST png_uint_32 width = standard_width(pp, dp->id);\n   PNG_CONST png_store*  ps = dp->ps;\n   int pass;\n   for (pass=0; pass<npasses; ++pass)\n   {\n      png_uint_32 y;\n      png_uint_32 wPass = PNG_PASS_COLS(width, pass);\n      for (y=0; y<height; ++y)\n      {\n         if (do_interlace)\n         {\n            \n\n\n            if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass))\n            {\n               \n\n\n               png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX];\n               \n\n\n\n\n\n               memset(row, 0xc5, sizeof row);\n               memset(display, 0x5c, sizeof display);\n               png_read_row(pp, row, display);\n               if (iImage >= 0)\n                  deinterlace_row(store_image_row(ps, pp, iImage, y), row,\n                     dp->pixel_size, dp->w, pass);\n               if (iDisplay >= 0)\n                  deinterlace_row(store_image_row(ps, pp, iDisplay, y), display,\n                     dp->pixel_size, dp->w, pass);\n            }\n         }\n         else\n            png_read_row(pp,\n               iImage >= 0 ? store_image_row(ps, pp, iImage, y) : NULL,\n               iDisplay >= 0 ? store_image_row(ps, pp, iDisplay, y) : NULL);\n      }\n   }\n   \n\n\n   png_read_end(pp, pi);\n}\n", "bug_type": null, "idx": 35}
{"project": "LibPNG", "target": 0, "func": "static void\npixel_copy(png_bytep toBuffer, png_uint_32 toIndex,\n   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize)\n{\n   \n\n\n   toIndex *= pixelSize;\n   fromIndex *= pixelSize;\n   if (pixelSize < 8) \n   {\n      \n      unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));\n      \n      unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;\n      unsigned int sourceByte = fromBuffer[fromIndex >> 3];\n      \n      fromIndex &= 7;\n      if (fromIndex > 0) sourceByte <<= fromIndex;\n      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;\n      toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));\n   }\n   else \n      memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);\n}\n", "bug_type": null, "idx": 36}
{"project": "LibPNG", "target": 0, "func": "static int rpng2_x_create_window(void)\n{\n    ulg bg_red   = rpng2_info.bg_red;\n    ulg bg_green = rpng2_info.bg_green;\n    ulg bg_blue  = rpng2_info.bg_blue;\n    ulg bg_pixel = 0L;\n    ulg attrmask;\n    int need_colormap = FALSE;\n    int screen, pad;\n    uch *xdata;\n    Window root;\n    XEvent e;\n    XGCValues gcvalues;\n    XSetWindowAttributes attr;\n    XTextProperty windowName, *pWindowName = &windowName;\n    XTextProperty iconName, *pIconName = &iconName;\n    XVisualInfo visual_info;\n    XSizeHints *size_hints;\n    XWMHints *wm_hints;\n    XClassHint *class_hints;\n    Trace((stderr, \"beginning rpng2_x_create_window()\\n\"))\n    screen = DefaultScreen(display);\n    depth = DisplayPlanes(display, screen);\n    root = RootWindow(display, screen);\n#ifdef DEBUG\n    XSynchronize(display, True);\n#endif\n    if (depth != 16 && depth != 24 && depth != 32) {\n        int visuals_matched = 0;\n        Trace((stderr, \"default depth is %d:  checking other visuals\\n\",\n          depth))\n        \n        visual_info.screen = screen;\n        visual_info.depth = 24;\n        visual_list = XGetVisualInfo(display,\n          VisualScreenMask | VisualDepthMask, &visual_info, &visuals_matched);\n        if (visuals_matched == 0) {\n\n            fprintf(stderr, \"default screen depth %d not supported, and no\"\n              \" 24-bit visuals found\\n\", depth);\n            return 2;\n        }\n        Trace((stderr, \"XGetVisualInfo() returned %d 24-bit visuals\\n\",\n          visuals_matched))\n        visual = visual_list[0].visual;\n        depth = visual_list[0].depth;\n\n\n\n\n\n        have_nondefault_visual = TRUE;\n        need_colormap = TRUE;\n    } else {\n        XMatchVisualInfo(display, screen, depth, TrueColor, &visual_info);\n        visual = visual_info.visual;\n    }\n    RMask = visual->red_mask;\n    GMask = visual->green_mask;\n    BMask = visual->blue_mask;\n\n    if (depth == 8 || need_colormap) {\n        colormap = XCreateColormap(display, root, visual, AllocNone);\n        if (!colormap) {\n            fprintf(stderr, \"XCreateColormap() failed\\n\");\n            return 2;\n        }\n        have_colormap = TRUE;\n        if (depth == 8)\n            bg_image = FALSE;   \n    }\n    if (depth == 15 || depth == 16) {\n        RShift = 15 - rpng2_x_msb(RMask);    \n        GShift = 15 - rpng2_x_msb(GMask);\n        BShift = 15 - rpng2_x_msb(BMask);\n    } else if (depth > 16) {\n        RShift = rpng2_x_msb(RMask) - 7;     \n        GShift = rpng2_x_msb(GMask) - 7;\n        BShift = rpng2_x_msb(BMask) - 7;\n    }\n    if (depth >= 15 && (RShift < 0 || GShift < 0 || BShift < 0)) {\n        fprintf(stderr, \"rpng2 internal logic error:  negative X shift(s)!\\n\");\n        return 2;\n    }\n\n\n\n    attr.backing_store = Always;\n    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;\n    attrmask = CWBackingStore | CWEventMask;\n    if (have_nondefault_visual) {\n        attr.colormap = colormap;\n        attr.background_pixel = 0;\n        attr.border_pixel = 1;\n        attrmask |= CWColormap | CWBackPixel | CWBorderPixel;\n    }\n    window = XCreateWindow(display, root, 0, 0, rpng2_info.width,\n      rpng2_info.height, 0, depth, InputOutput, visual, attrmask, &attr);\n    if (window == None) {\n        fprintf(stderr, \"XCreateWindow() failed\\n\");\n        return 2;\n    } else\n        have_window = TRUE;\n    if (depth == 8)\n        XSetWindowColormap(display, window, colormap);\n    if (!XStringListToTextProperty(&window_name, 1, pWindowName))\n        pWindowName = NULL;\n    if (!XStringListToTextProperty(&icon_name, 1, pIconName))\n        pIconName = NULL;\n    \n    if ((size_hints = XAllocSizeHints()) != NULL) {\n        \n        size_hints->flags = PMinSize | PMaxSize;\n        size_hints->min_width = size_hints->max_width = (int)rpng2_info.width;\n        size_hints->min_height = size_hints->max_height =\n          (int)rpng2_info.height;\n    }\n    if ((wm_hints = XAllocWMHints()) != NULL) {\n        wm_hints->initial_state = NormalState;\n        wm_hints->input = True;\n     \n        wm_hints->flags = StateHint | InputHint   ;\n    }\n    if ((class_hints = XAllocClassHint()) != NULL) {\n        class_hints->res_name = res_name;\n        class_hints->res_class = res_class;\n    }\n    XSetWMProperties(display, window, pWindowName, pIconName, NULL, 0,\n      size_hints, wm_hints, class_hints);\n    \n    if (pWindowName)\n       XFree(pWindowName->value);\n    if (pIconName)\n       XFree(pIconName->value);\n    if (size_hints)\n        XFree(size_hints);\n    if (wm_hints)\n       XFree(wm_hints);\n    if (class_hints)\n       XFree(class_hints);\n    XMapWindow(display, window);\n    gc = XCreateGC(display, window, 0, &gcvalues);\n    have_gc = TRUE;\n\n\n\n    if (depth == 24 || depth == 32) {\n        xdata = (uch *)malloc(4*rpng2_info.width*rpng2_info.height);\n        pad = 32;\n    } else if (depth == 16) {\n        xdata = (uch *)malloc(2*rpng2_info.width*rpng2_info.height);\n        pad = 16;\n    } else  {\n        xdata = (uch *)malloc(rpng2_info.width*rpng2_info.height);\n        pad = 8;\n    }\n    if (!xdata) {\n        fprintf(stderr, PROGNAME \":  unable to allocate image memory\\n\");\n        return 4;\n    }\n    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,\n      (char *)xdata, rpng2_info.width, rpng2_info.height, pad, 0);\n    if (!ximage) {\n        fprintf(stderr, PROGNAME \":  XCreateImage() failed\\n\");\n        free(xdata);\n        return 3;\n    }\n    \n\n\n\n\n\n    ximage->byte_order = MSBFirst;\n\n\n\n\n\n    if (bg_image)\n        rpng2_x_load_bg_image();    \n    if (!bg_image) {\n        if (depth == 24 || depth == 32) {\n            bg_pixel = (bg_red   << RShift) |\n                       (bg_green << GShift) |\n                       (bg_blue  << BShift);\n        } else if (depth == 16) {\n            bg_pixel = (((bg_red   << 8) >> RShift) & RMask) |\n                       (((bg_green << 8) >> GShift) & GMask) |\n                       (((bg_blue  << 8) >> BShift) & BMask);\n        } else  {\n            \n        }\n        XSetForeground(display, gc, bg_pixel);\n        XFillRectangle(display, window, gc, 0, 0, rpng2_info.width,\n          rpng2_info.height);\n    }\n\n\n\n    do\n        XNextEvent(display, &e);\n    while (e.type != Expose || e.xexpose.count);\n    XFlush(display);\n    return 0;\n} \n", "bug_type": null, "idx": 37}
{"project": "LibPNG", "target": 0, "func": "static void\ninsert_tEXt(png_structp png_ptr, png_infop info_ptr, int nparams,\n   png_charpp params)\n{\n   png_text text;\n   check_param_count(nparams, 2);\n   clear_text(&text, params[0]);\n   set_text(png_ptr, info_ptr, &text, params[1]);\n}\n", "bug_type": null, "idx": 38}
{"project": "LibPNG", "target": 0, "func": "static void\ndisplay_clean_write(struct display *dp)\n{\n      if (dp->write_pp != NULL)\n         png_destroy_write_struct(&dp->write_pp, NULL);\n}\n", "bug_type": null, "idx": 39}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_expand_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(colour_type)\n   this->next = *that;\n   *that = this;\n   \n   return bit_depth < 16;\n}\n", "bug_type": null, "idx": 40}
{"project": "LibPNG", "target": 0, "func": "static png_structp\nset_store_for_write(png_store *ps, png_infopp ppi,\n   PNG_CONST char * volatile name)\n{\n   anon_context(ps);\n   Try\n   {\n      if (ps->pwrite != NULL)\n         png_error(ps->pwrite, \"write store already in use\");\n      store_write_reset(ps);\n      safecat(ps->wname, sizeof ps->wname, 0, name);\n      \n\n\n#     ifdef PNG_USER_MEM_SUPPORTED\n         if (!ps->speed)\n            ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,\n               ps, store_error, store_warning, &ps->write_memory_pool,\n               store_malloc, store_free);\n         else\n#     endif\n         ps->pwrite = png_create_write_struct(png_get_libpng_ver(NULL),\n            ps, store_error, store_warning);\n      png_set_write_fn(ps->pwrite, ps, store_write, store_flush);\n#     ifdef PNG_SET_OPTION_SUPPORTED\n         {\n            int opt;\n            for (opt=0; opt<ps->noptions; ++opt)\n               if (png_set_option(ps->pwrite, ps->options[opt].option,\n                  ps->options[opt].setting) == PNG_OPTION_INVALID)\n                  png_error(ps->pwrite, \"png option invalid\");\n         }\n#     endif\n      if (ppi != NULL)\n         *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);\n   }\n   Catch_anonymous\n      return NULL;\n   return ps->pwrite;\n}\n", "bug_type": null, "idx": 41}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nstore_free(png_structp ppIn, png_voidp memory)\n{\n   png_const_structp pp = ppIn;\n   store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp));\n   store_memory *this = voidcast(store_memory*, memory), **test;\n   \n\n\n\n\n   if (pp != pool->store->pread && pp != pool->store->pwrite)\n      pp = NULL;\n   \n\n\n   --this;\n   for (test = &pool->list; *test != this; test = &(*test)->next)\n   {\n      if (*test == NULL)\n      {\n         store_pool_error(pool->store, pp, \"bad pointer to free\");\n         return;\n      }\n   }\n   \n   *test = this->next;\n   this->next = NULL;\n   store_memory_free(pp, pool, this);\n}\n", "bug_type": null, "idx": 42}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_write_reset(png_store *ps)\n{\n   if (ps->pwrite != NULL)\n   {\n      anon_context(ps);\n      Try\n         png_destroy_write_struct(&ps->pwrite, &ps->piwrite);\n      Catch_anonymous\n      {\n         \n      }\n      ps->pwrite = NULL;\n      ps->piwrite = NULL;\n   }\n   \n\n\n#  ifdef PNG_USER_MEM_SUPPORTED\n      store_pool_delete(ps, &ps->write_memory_pool);\n#  endif\n   store_freenew(ps);\n}\n", "bug_type": null, "idx": 43}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_image_free(png_store *ps, png_const_structp pp)\n{\n   if (ps->image != NULL)\n   {\n      png_bytep image = ps->image;\n      if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)\n      {\n         if (pp != NULL)\n            png_error(pp, \"png_store image overwrite (1)\");\n         else\n            store_log(ps, NULL, \"png_store image overwrite (2)\", 1);\n      }\n      ps->image = NULL;\n      ps->cb_image = 0;\n      --image;\n      free(image);\n   }\n}\n", "bug_type": null, "idx": 44}
{"project": "LibPNG", "target": 0, "func": "static void\ninternal_error(png_store *ps, png_const_charp message)\n{\n   store_log(ps, NULL, message, 1 );\n   \n   {\n      struct exception_context *the_exception_context = &ps->exception_context;\n      Throw ps;\n   }\n}\n", "bug_type": null, "idx": 45}
{"project": "LibPNG", "target": 0, "func": "void PNGCBAPI\npng_default_flush(png_structp png_ptr)\n{\n   png_FILE_p io_ptr;\n   if (png_ptr == NULL)\n      return;\n   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));\n   fflush(io_ptr);\n}\n", "bug_type": null, "idx": 46}
{"project": "LibPNG", "target": 0, "func": "static int\nlogclose(Image *image, FILE *f, const char *name, const char *operation)\n{\n   int e = errno;\n   fclose(f);\n   return logerror(image, name, operation, strerror(e));\n}\n", "bug_type": null, "idx": 47}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_palette_to_rgb_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n      image_pixel_convert_PLTE(that);\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 48}
{"project": "LibPNG", "target": 0, "func": "static int\npng_pass_col_shift(int pass)\n{\n   int x, y, base=(-1), inc=8;\n   ++pass;\n   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)\n   {\n      if (base == (-1))\n         base = x;\n      else if (base == x)\n         {}\n      else if (inc == x-base)\n         base=x;\n      else if (inc == 8)\n         inc = x-base, base=x;\n      else if (inc != x-base)\n         return 0xff; \n   }\n   if (base == (-1)) return 0xfe; \n   \n   switch (inc)\n   {\ncase 1: return 0; \ncase 2: return 1;\ncase 4: return 2;\ncase 8: return 3;\ndefault: break;\n   }\n   \n   return (inc << 8) + 0xfd;\n}\n", "bug_type": null, "idx": 49}
{"project": "LibPNG", "target": 0, "func": "int\nmain(void)\n{\n   fwrite(signature, sizeof signature, 1, stdout);\n   put_chunk(IHDR, sizeof IHDR);\n   for (;;)\n      put_chunk(unknown, sizeof unknown);\n}\n", "bug_type": null, "idx": 50}
{"project": "LibPNG", "target": 0, "func": "#include <sys/ioctl.h>\nint repl_getch( void )\n{\n  char ch;\n  int fd = fileno(stdin);\n  struct termio old_tty, new_tty;\n  ioctl(fd, TCGETA, &old_tty);\n  new_tty = old_tty;\n  new_tty.c_lflag &= ~(ICANON | ECHO | ISIG);\n  ioctl(fd, TCSETA, &new_tty);\n  fread(&ch, 1, sizeof(ch), stdin);\n  ioctl(fd, TCSETA, &old_tty);\n  return ch;\n}\n", "bug_type": null, "idx": 51}
{"project": "LibPNG", "target": 0, "func": " */\nstatic double outlog(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n{\n   \n\n\n   if (out_depth <= 8)\n   {\n      if (pm->log8 == 0) \n         return 256;\n      if (out_depth < 8)\n         return pm->log8 / 255 * ((1<<out_depth)-1);\n      return pm->log8;\n   }\n   if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n   {\n      if (pm->log16 == 0)\n         return 65536;\n      return pm->log16;\n   }\n   \n\n\n   if (pm->log8 == 0)\n      return 65536;\n   return pm->log8 * 257;\n}\n", "bug_type": null, "idx": 52}
{"project": "LibPNG", "target": 0, "func": "LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam,\n        LPARAM lParam)\n{\n    static HINSTANCE          hInstance ;\n    static HDC                hdc;\n    static PAINTSTRUCT        ps;\n    static HMENU              hMenu;\n    static BITMAPFILEHEADER  *pbmfh;\n    static BITMAPINFOHEADER  *pbmih;\n    static BYTE              *pbImage;\n    static int                cxWinSize, cyWinSize;\n    static int                cxImgSize, cyImgSize;\n    static int                cImgChannels;\n    static png_color          bkgColor = {127, 127, 127};\n    static BOOL               bStretched = TRUE;\n    static BYTE              *pDib = NULL;\n    static BYTE              *pDiData = NULL;\n    static TCHAR              szImgPathName [MAX_PATH];\n    static TCHAR              szTitleName [MAX_PATH];\n    static TCHAR             *pPngFileList = NULL;\n    static int                iPngFileCount;\n    static int                iPngFileIndex;\n    BOOL                      bOk;\n    switch (message)\n    {\n    case WM_CREATE:\n        hInstance = ((LPCREATESTRUCT) lParam)->hInstance ;\n        PngFileInitialize (hwnd);\n        strcpy (szImgPathName, \"\");\n        \n        if (szCmdFileName[0] != '\\0')\n        {\n            strcpy (szImgPathName, szCmdFileName);\n            \n            \n            BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,\n                          &iPngFileIndex);\n            \n            if (!LoadImageFile (hwnd, szImgPathName,\n                &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))\n                return 0;\n            \n            InvalidateRect (hwnd, NULL, TRUE);\n            \n            DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,\n                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);\n        }\n        return 0;\n    case WM_SIZE:\n        cxWinSize = LOWORD (lParam);\n        cyWinSize = HIWORD (lParam);\n        \n        InvalidateRect (hwnd, NULL, TRUE);\n        \n        DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,\n            pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);\n        return 0;\n    case WM_INITMENUPOPUP:\n        hMenu = GetMenu (hwnd);\n        if (pbImage)\n            EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_ENABLED);\n        else\n            EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_GRAYED);\n        return 0;\n    case WM_COMMAND:\n        hMenu = GetMenu (hwnd);\n        switch (LOWORD (wParam))\n        {\n        case IDM_FILE_OPEN:\n            \n            if (!PngFileOpenDlg (hwnd, szImgPathName, szTitleName))\n                return 0;\n            \n            \n            BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,\n                          &iPngFileIndex);\n            \n            if (!LoadImageFile (hwnd, szImgPathName,\n                &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))\n                return 0;\n            \n            InvalidateRect (hwnd, NULL, TRUE);\n            \n            DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,\n                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);\n            return 0;\n        case IDM_FILE_SAVE:\n            \n            if (!PngFileSaveDlg (hwnd, szImgPathName, szTitleName))\n                return 0;\n            \n            SetCursor (LoadCursor (NULL, IDC_WAIT));\n            ShowCursor (TRUE);\n            bOk = PngSaveImage (szImgPathName, pDiData, cxWinSize, cyWinSize,\n                  bkgColor);\n            ShowCursor (FALSE);\n            SetCursor (LoadCursor (NULL, IDC_ARROW));\n            if (!bOk)\n                MessageBox (hwnd, TEXT (\"Error in saving the PNG image\"),\n                szProgName, MB_ICONEXCLAMATION | MB_OK);\n            return 0;\n        case IDM_FILE_NEXT:\n            \n            if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex,\n                NULL, szImgPathName))\n            {\n                if (strcmp (szImgPathName, \"\") == 0)\n                    return 0;\n                \n                if (!LoadImageFile (hwnd, szImgPathName, &pbImage,\n                        &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))\n                    return 0;\n                \n                InvalidateRect (hwnd, NULL, TRUE);\n                \n                DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,\n                    pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);\n            }\n            return 0;\n        case IDM_FILE_PREVIOUS:\n            \n            if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex,\n                szImgPathName, NULL))\n            {\n                if (strcmp (szImgPathName, \"\") == 0)\n                    return 0;\n                \n                if (!LoadImageFile (hwnd, szImgPathName, &pbImage, &cxImgSize,\n                    &cyImgSize, &cImgChannels, &bkgColor))\n                    return 0;\n                \n                InvalidateRect (hwnd, NULL, TRUE);\n                \n                DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,\n                    pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);\n            }\n            return 0;\n        case IDM_FILE_EXIT:\n            \n            \n            if (pDib != NULL)\n            {\n                free (pDib);\n                pDib = NULL;\n            }\n            \n            if (pPngFileList != NULL)\n            {\n                free (pPngFileList);\n                pPngFileList = NULL;\n            }\n            \n            exit (0);\n            return 0;\n        case IDM_OPTIONS_STRETCH:\n            bStretched = !bStretched;\n            if (bStretched)\n                CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_CHECKED);\n            else\n                CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_UNCHECKED);\n            \n            InvalidateRect (hwnd, NULL, TRUE);\n            \n            DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,\n                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);\n            return 0;\n        case IDM_HELP_ABOUT:\n            DialogBox (hInstance, TEXT (\"AboutBox\"), hwnd, AboutDlgProc) ;\n            return 0;\n        } \n        break;\n    case WM_PAINT:\n        hdc = BeginPaint (hwnd, &ps);\n        if (pDib)\n            SetDIBitsToDevice (hdc, 0, 0, cxWinSize, cyWinSize, 0, 0,\n                0, cyWinSize, pDiData, (BITMAPINFO *) pDib, DIB_RGB_COLORS);\n        EndPaint (hwnd, &ps);\n        return 0;\n    case WM_DESTROY:\n        if (pbmfh)\n        {\n            free (pbmfh);\n            pbmfh = NULL;\n        }\n        PostQuitMessage (0);\n        return 0;\n    }\n    return DefWindowProc (hwnd, message, wParam, lParam);\n}\n", "bug_type": null, "idx": 53}
{"project": "LibPNG", "target": 0, "func": "static int\ntest_standard(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,\n    int bdlo, int PNG_CONST bdhi)\n{\n   for (; bdlo <= bdhi; ++bdlo)\n   {\n      int interlace_type;\n      for (interlace_type = PNG_INTERLACE_NONE;\n           interlace_type < INTERLACE_LAST; ++interlace_type)\n      {\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,\n            interlace_type, 0, 0, 0), 0, pm->use_update_info);\n         if (fail(pm))\n            return 0;\n      }\n   }\n   return 1; \n}\n", "bug_type": null, "idx": 54}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_abgr8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = pp[3];\n   p->g = pp[2];\n   p->b = pp[1];\n   p->a = pp[0];\n}\n", "bug_type": null, "idx": 55}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_display_init(standard_display *dp, png_store* ps, png_uint_32 id,\n   int do_interlace, int use_update_info)\n{\n   memset(dp, 0, sizeof *dp);\n   dp->ps = ps;\n   dp->colour_type = COL_FROM_ID(id);\n   dp->bit_depth = DEPTH_FROM_ID(id);\n   if (dp->bit_depth < 1 || dp->bit_depth > 16)\n      internal_error(ps, \"internal: bad bit depth\");\n   if (dp->colour_type == 3)\n      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT = 8;\n   else\n      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT =\n         dp->bit_depth;\n   dp->interlace_type = INTERLACE_FROM_ID(id);\n   check_interlace_type(dp->interlace_type);\n   dp->id = id;\n   \n   dp->w = 0;\n   dp->h = 0;\n   dp->npasses = 0;\n   dp->pixel_size = 0;\n   dp->bit_width = 0;\n   dp->cbRow = 0;\n   dp->do_interlace = do_interlace;\n   dp->is_transparent = 0;\n   dp->speed = ps->speed;\n   dp->use_update_info = use_update_info;\n   dp->npalette = 0;\n   \n   memset(&dp->transparent, 0, sizeof dp->transparent);\n   \n   memset(dp->palette, 0xff, sizeof dp->palette);\n}\n", "bug_type": null, "idx": 56}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_rgb_to_gray_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      double gray, err;\n      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n         image_pixel_convert_PLTE(that);\n      \n#  if DIGITIZE\n      {\n         PNG_CONST png_modifier *pm = display->pm;\n         const unsigned int sample_depth = that->sample_depth;\n         const unsigned int calc_depth = (pm->assume_16_bit_calculations ? 16 :\n            sample_depth);\n         const unsigned int gamma_depth = (sample_depth == 16 ? 16 :\n            (pm->assume_16_bit_calculations ? PNG_MAX_GAMMA_8 : sample_depth));\n         int isgray;\n         double r, g, b;\n         double rlo, rhi, glo, ghi, blo, bhi, graylo, grayhi;\n         \n\n\n\n\n\n\n\n\n         r = rlo = rhi = that->redf;\n         rlo -= that->rede;\n         rlo = digitize(rlo, calc_depth, 1);\n         rhi += that->rede;\n         rhi = digitize(rhi, calc_depth, 1);\n         g = glo = ghi = that->greenf;\n         glo -= that->greene;\n         glo = digitize(glo, calc_depth, 1);\n         ghi += that->greene;\n         ghi = digitize(ghi, calc_depth, 1);\n         b = blo = bhi = that->bluef;\n         blo -= that->bluee;\n         blo = digitize(blo, calc_depth, 1);\n         bhi += that->greene;\n         bhi = digitize(bhi, calc_depth, 1);\n         isgray = r==g && g==b;\n         if (data.gamma != 1)\n         {\n            PNG_CONST double power = 1/data.gamma;\n            PNG_CONST double abse = calc_depth == 16 ? .5/65535 : .5/255;\n            \n\n\n\n\n\n            r = pow(r, power);\n            rlo = digitize(pow(rlo, power)-abse, calc_depth, 1);\n            rhi = digitize(pow(rhi, power)+abse, calc_depth, 1);\n            g = pow(g, power);\n            glo = digitize(pow(glo, power)-abse, calc_depth, 1);\n            ghi = digitize(pow(ghi, power)+abse, calc_depth, 1);\n            b = pow(b, power);\n            blo = digitize(pow(blo, power)-abse, calc_depth, 1);\n            bhi = digitize(pow(bhi, power)+abse, calc_depth, 1);\n         }\n         \n\n\n\n\n\n\n\n\n\n         gray = r * data.red_coefficient + g * data.green_coefficient +\n            b * data.blue_coefficient;\n         {\n            PNG_CONST int do_round = data.gamma != 1 || calc_depth == 16;\n            PNG_CONST double ce = 1. / 32768;\n            graylo = digitize(rlo * (data.red_coefficient-ce) +\n               glo * (data.green_coefficient-ce) +\n               blo * (data.blue_coefficient-ce), gamma_depth, do_round);\n            if (graylo <= 0)\n               graylo = 0;\n            grayhi = digitize(rhi * (data.red_coefficient+ce) +\n               ghi * (data.green_coefficient+ce) +\n               bhi * (data.blue_coefficient+ce), gamma_depth, do_round);\n            if (grayhi >= 1)\n               grayhi = 1;\n         }\n         \n         if (data.gamma != 1)\n         {\n            PNG_CONST double power = data.gamma;\n            gray = pow(gray, power);\n            graylo = digitize(pow(graylo, power), sample_depth, 1);\n            grayhi = digitize(pow(grayhi, power), sample_depth, 1);\n         }\n         \n\n\n\n\n         if (isgray)\n            err = (that->rede + that->greene + that->bluee)/3;\n         else\n         {\n            err = fabs(grayhi-gray);\n            if (fabs(gray - graylo) > err)\n               err = fabs(graylo-gray);\n            \n            if (err > pm->limit)\n            {\n               size_t pos = 0;\n               char buffer[128];\n               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");\n               pos = safecatd(buffer, sizeof buffer, pos, err, 6);\n               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");\n               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);\n               png_error(pp, buffer);\n            }\n         }\n      }\n#  else  \n      {\n         double r = that->redf;\n         double re = that->rede;\n         double g = that->greenf;\n         double ge = that->greene;\n         double b = that->bluef;\n         double be = that->bluee;\n         \n         if (r == g && r == b)\n         {\n            gray = r;\n            err = re;\n            if (err < ge) err = ge;\n            if (err < be) err = be;\n         }\n         else if (data.gamma == 1)\n         {\n            \n\n\n\n\n\n\n\n            gray = r * data.red_coefficient + g * data.green_coefficient +\n               b * data.blue_coefficient;\n            err = re * data.red_coefficient + ge * data.green_coefficient +\n               be * data.blue_coefficient + 1./32768 + gray * 5 * DBL_EPSILON;\n         }\n         else\n         {\n            \n\n\n\n\n\n            PNG_CONST png_modifier *pm = display->pm;\n            double in_qe = (that->sample_depth > 8 ? .5/65535 : .5/255);\n            double out_qe = (that->sample_depth > 8 ? .5/65535 :\n               (pm->assume_16_bit_calculations ? .5/(1<<PNG_MAX_GAMMA_8) :\n               .5/255));\n            double rhi, ghi, bhi, grayhi;\n            double g1 = 1/data.gamma;\n            rhi = r + re + in_qe; if (rhi > 1) rhi = 1;\n            r -= re + in_qe; if (r < 0) r = 0;\n            ghi = g + ge + in_qe; if (ghi > 1) ghi = 1;\n            g -= ge + in_qe; if (g < 0) g = 0;\n            bhi = b + be + in_qe; if (bhi > 1) bhi = 1;\n            b -= be + in_qe; if (b < 0) b = 0;\n            r = pow(r, g1)*(1-DBL_EPSILON); rhi = pow(rhi, g1)*(1+DBL_EPSILON);\n            g = pow(g, g1)*(1-DBL_EPSILON); ghi = pow(ghi, g1)*(1+DBL_EPSILON);\n            b = pow(b, g1)*(1-DBL_EPSILON); bhi = pow(bhi, g1)*(1+DBL_EPSILON);\n            \n\n\n\n            gray = r * data.red_coefficient + g * data.green_coefficient +\n               b * data.blue_coefficient - 1./32768 - out_qe;\n            if (gray <= 0)\n               gray = 0;\n            else\n            {\n               gray *= (1 - 6 * DBL_EPSILON);\n               gray = pow(gray, data.gamma) * (1-DBL_EPSILON);\n            }\n            grayhi = rhi * data.red_coefficient + ghi * data.green_coefficient +\n               bhi * data.blue_coefficient + 1./32768 + out_qe;\n            grayhi *= (1 + 6 * DBL_EPSILON);\n            if (grayhi >= 1)\n               grayhi = 1;\n            else\n               grayhi = pow(grayhi, data.gamma) * (1+DBL_EPSILON);\n            err = (grayhi - gray) / 2;\n            gray = (grayhi + gray) / 2;\n            if (err <= in_qe)\n               err = gray * DBL_EPSILON;\n            else\n               err -= in_qe;\n            \n\n\n            if (err > pm->limit)\n            {\n               size_t pos = 0;\n               char buffer[128];\n               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");\n               pos = safecatd(buffer, sizeof buffer, pos, err, 6);\n               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");\n               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);\n               png_error(pp, buffer);\n            }\n         }\n      }\n#  endif \n      that->bluef = that->greenf = that->redf = gray;\n      that->bluee = that->greene = that->rede = err;\n      \n      if (that->red_sBIT > that->green_sBIT)\n         that->red_sBIT = that->green_sBIT;\n      if (that->red_sBIT > that->blue_sBIT)\n         that->red_sBIT = that->blue_sBIT;\n      that->blue_sBIT = that->green_sBIT = that->red_sBIT;\n      \n      if (that->colour_type == PNG_COLOR_TYPE_RGB)\n         that->colour_type = PNG_COLOR_TYPE_GRAY;\n      else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         that->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n   }\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 57}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_expand_gray_1_2_4_to_8_set(\n    PNG_CONST image_transform *this, transform_display *that, png_structp pp,\n    png_infop pi)\n{\n   png_set_expand_gray_1_2_4_to_8(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 58}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_byte buf[32];\n   png_fixed_point x_white, y_white, x_red, y_red, x_green, y_green, x_blue,\n      y_blue;\n\n   png_debug(1, \"in png_handle_cHRM\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before cHRM\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid cHRM after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n      \n      png_warning(png_ptr, \"Missing PLTE before cHRM\");\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)\n#  ifdef PNG_READ_sRGB_SUPPORTED\n       && !(info_ptr->valid & PNG_INFO_sRGB)\n#  endif\n      )\n   {\n      png_warning(png_ptr, \"Duplicate cHRM chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != 32)\n   {\n      png_warning(png_ptr, \"Incorrect cHRM chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 32);\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   x_white = png_get_fixed_point(NULL, buf);\n   y_white = png_get_fixed_point(NULL, buf + 4);\n   x_red   = png_get_fixed_point(NULL, buf + 8);\n   y_red   = png_get_fixed_point(NULL, buf + 12);\n   x_green = png_get_fixed_point(NULL, buf + 16);\n   y_green = png_get_fixed_point(NULL, buf + 20);\n   x_blue  = png_get_fixed_point(NULL, buf + 24);\n   y_blue  = png_get_fixed_point(NULL, buf + 28);\n\n   if (x_white == PNG_FIXED_ERROR ||\n       y_white == PNG_FIXED_ERROR ||\n       x_red   == PNG_FIXED_ERROR ||\n       y_red   == PNG_FIXED_ERROR ||\n       x_green == PNG_FIXED_ERROR ||\n       y_green == PNG_FIXED_ERROR ||\n       x_blue  == PNG_FIXED_ERROR ||\n       y_blue  == PNG_FIXED_ERROR)\n   {\n      png_warning(png_ptr, \"Ignoring cHRM chunk with negative chromaticities\");\n      return;\n   }\n\n#ifdef PNG_READ_sRGB_SUPPORTED\n   if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))\n   {\n      if (PNG_OUT_OF_RANGE(x_white, 31270,  1000) ||\n          PNG_OUT_OF_RANGE(y_white, 32900,  1000) ||\n          PNG_OUT_OF_RANGE(x_red,   64000L, 1000) ||\n          PNG_OUT_OF_RANGE(y_red,   33000,  1000) ||\n          PNG_OUT_OF_RANGE(x_green, 30000,  1000) ||\n          PNG_OUT_OF_RANGE(y_green, 60000L, 1000) ||\n          PNG_OUT_OF_RANGE(x_blue,  15000,  1000) ||\n          PNG_OUT_OF_RANGE(y_blue,   6000,  1000))\n      {\n         PNG_WARNING_PARAMETERS(p)\n\n         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed, x_white);\n         png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_fixed, y_white);\n         png_warning_parameter_signed(p, 3, PNG_NUMBER_FORMAT_fixed, x_red);\n         png_warning_parameter_signed(p, 4, PNG_NUMBER_FORMAT_fixed, y_red);\n         png_warning_parameter_signed(p, 5, PNG_NUMBER_FORMAT_fixed, x_green);\n         png_warning_parameter_signed(p, 6, PNG_NUMBER_FORMAT_fixed, y_green);\n         png_warning_parameter_signed(p, 7, PNG_NUMBER_FORMAT_fixed, x_blue);\n         png_warning_parameter_signed(p, 8, PNG_NUMBER_FORMAT_fixed, y_blue);\n\n         png_formatted_warning(png_ptr, p,\n             \"Ignoring incorrect cHRM white(@1,@2) r(@3,@4)g(@5,@6)b(@7,@8) \"\n             \"when sRGB is also present\");\n      }\n      return;\n   }\n#endif \n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n   \n\n\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)\n   {\n      \n\n\n      if (y_red <= (1<<17) && y_green <= (1<<17) && y_blue <= (1<<17))\n      {\n         \n\n\n\n         png_uint_32 w = y_red + y_green + y_blue;\n\n         png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)(((png_uint_32)y_red *\n            32768)/w);\n         png_ptr->rgb_to_gray_green_coeff = (png_uint_16)(((png_uint_32)y_green\n            * 32768)/w);\n         png_ptr->rgb_to_gray_blue_coeff  = (png_uint_16)(((png_uint_32)y_blue *\n            32768)/w);\n      }\n   }\n#endif\n\n   png_set_cHRM_fixed(png_ptr, info_ptr, x_white, y_white, x_red, y_red,\n      x_green, y_green, x_blue, y_blue);\n}", "bug_type": "cve-2011-3328", "idx": 59}
{"project": "LibPNG", "target": 0, "func": "static size_t\nstandard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,\n    int bit_depth, unsigned int npalette, int interlace_type,\n    png_uint_32 w, png_uint_32 h, int do_interlace)\n{\n   pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);\n   if (npalette > 0)\n   {\n      pos = safecat(buffer, bufsize, pos, \"[\");\n      pos = safecatn(buffer, bufsize, pos, npalette);\n      pos = safecat(buffer, bufsize, pos, \"]\");\n   }\n   pos = safecat(buffer, bufsize, pos, \" \");\n   pos = safecatn(buffer, bufsize, pos, bit_depth);\n   pos = safecat(buffer, bufsize, pos, \" bit\");\n   if (interlace_type != PNG_INTERLACE_NONE)\n   {\n      pos = safecat(buffer, bufsize, pos, \" interlaced\");\n      if (do_interlace)\n         pos = safecat(buffer, bufsize, pos, \"(pngvalid)\");\n      else\n         pos = safecat(buffer, bufsize, pos, \"(libpng)\");\n   }\n   if (w > 0 || h > 0)\n   {\n      pos = safecat(buffer, bufsize, pos, \" \");\n      pos = safecatn(buffer, bufsize, pos, w);\n      pos = safecat(buffer, bufsize, pos, \"x\");\n      pos = safecatn(buffer, bufsize, pos, h);\n   }\n   return pos;\n}\nstatic size_t\nstandard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,\n    int bit_depth, unsigned int npalette, int interlace_type,\n    png_uint_32 w, png_uint_32 h, int do_interlace)\n{\n   pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);\n   if (npalette > 0)\n   {\n      pos = safecat(buffer, bufsize, pos, \"[\");\n      pos = safecatn(buffer, bufsize, pos, npalette);\n      pos = safecat(buffer, bufsize, pos, \"]\");\n   }\n", "bug_type": null, "idx": 60}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_progressive_read(png_modifier *pm, png_structp pp, png_infop pi)\n{\n   if (pm->this.pread != pp || pm->this.current == NULL ||\n       pm->this.next == NULL)\n      png_error(pp, \"store state damaged (progressive)\");\n   \n\n\n\n\n\n   for (;;)\n   {\n      static png_uint_32 noise = 1;\n      png_size_t cb, cbAvail;\n      png_byte buffer[512];\n      \n      noise = (noise << 9) | ((noise ^ (noise >> (9-5))) & 0x1ff);\n      cb = noise & 0x1ff;\n      \n\n\n\n\n      cbAvail = store_read_buffer_avail(&pm->this);\n      if (pm->buffer_count > pm->buffer_position)\n         cbAvail += pm->buffer_count - pm->buffer_position;\n      if (cb > cbAvail)\n      {\n         \n         if (cbAvail == 0)\n            break;\n         cb = cbAvail;\n      }\n      modifier_read_imp(pm, buffer, cb);\n      png_process_data(pp, pi, buffer, cb);\n   }\n   \n\n\n   if (pm->buffer_count > pm->buffer_position ||\n       pm->this.next != &pm->this.current->data ||\n       pm->this.readpos < pm->this.current->datacount)\n      png_error(pp, \"progressive read implementation error\");\n}\n", "bug_type": null, "idx": 61}
{"project": "LibPNG", "target": 0, "func": "static void\ngama_modification_init(gama_modification *me, png_modifier *pm, double gammad)\n{\n   double g;\n   modification_init(&me->this);\n   me->this.chunk = CHUNK_gAMA;\n   me->this.modify_fn = gama_modify;\n   me->this.add = CHUNK_PLTE;\n   g = fix(gammad);\n   me->gamma = (png_fixed_point)g;\n   me->this.next = pm->modifications;\n   pm->modifications = &me->this;\n}\n", "bug_type": null, "idx": 62}
{"project": "LibPNG", "target": 1, "func": "\nint \npng_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)\n\n{\n   png_uint_32 i;\n\n   png_uint_32 row_width = row_info->width;\n   int rgb_error = 0;\n\n   png_debug(1, \"in png_do_rgb_to_gray\");\n\n   if (\n       (row_info->color_type & PNG_COLOR_MASK_COLOR))\n   {\n      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;\n      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;\n      png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff;\n\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n      {\n         if (row_info->bit_depth == 8)\n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte green = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];\n\n                  if (red != green || red != blue)\n                  {\n                     rgb_error |= 1;\n                     *(dp++) = png_ptr->gamma_from_1[\n                         (rc*red + gc*green + bc*blue)>>15];\n                  }\n\n                  else\n                     *(dp++) = *(sp - 1);\n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = *(sp++);\n                  png_byte green = *(sp++);\n                  png_byte blue  = *(sp++);\n\n                  if (red != green || red != blue)\n                  {\n                     rgb_error |= 1;\n                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);\n                  }\n\n                  else\n                     *(dp++) = *(sp - 1);\n               }\n            }\n         }\n\n         else \n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_16_to_1 != NULL &&\n                png_ptr->gamma_16_from_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, w;\n\n                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n\n                  if (red == green && red == blue)\n                     w = red;\n\n                  else\n                  {\n                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)\n                         >> png_ptr->gamma_shift][red>>8];\n                     png_uint_16 green_1 =\n                         png_ptr->gamma_16_to_1[(green&0xff) >>\n                         png_ptr->gamma_shift][green>>8];\n                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)\n                         >> png_ptr->gamma_shift][blue>>8];\n                     png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1\n                         + bc*blue_1)>>15);\n                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>\n                         png_ptr->gamma_shift][gray16 >> 8];\n                     rgb_error |= 1;\n                  }\n\n                  *(dp++) = (png_byte)((w>>8) & 0xff);\n                  *(dp++) = (png_byte)(w & 0xff);\n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, gray16;\n\n                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n\n                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);\n                  *(dp++) = (png_byte)((gray16>>8) & 0xff);\n                  *(dp++) = (png_byte)(gray16 & 0xff);\n               }\n            }\n         }\n      }\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n      {\n         if (row_info->bit_depth == 8)\n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte green = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];\n\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n\n                  *(dp++) =  png_ptr->gamma_from_1\n                      [(rc*red + gc*green + bc*blue)>>15];\n\n                  *(dp++) = *(sp++);  \n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = *(sp++);\n                  png_byte green = *(sp++);\n                  png_byte blue  = *(sp++);\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n\n                  *(dp++) =  (png_byte)((rc*red + gc*green + bc*blue)>>15);\n                  *(dp++) = *(sp++);  \n               }\n            }\n         }\n         else \n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_16_to_1 != NULL &&\n                png_ptr->gamma_16_from_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, w;\n\n                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\n\n                  if (red == green && red == blue)\n                     w = red;\n\n                  else\n                  {\n                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>\n                         png_ptr->gamma_shift][red>>8];\n\n                     png_uint_16 green_1 =\n                         png_ptr->gamma_16_to_1[(green&0xff) >>\n                         png_ptr->gamma_shift][green>>8];\n\n                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>\n                         png_ptr->gamma_shift][blue>>8];\n\n                     png_uint_16 gray16  = (png_uint_16)((rc * red_1\n                         + gc * green_1 + bc * blue_1)>>15);\n\n                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>\n                         png_ptr->gamma_shift][gray16 >> 8];\n\n                     rgb_error |= 1;\n                  }\n\n                  *(dp++) = (png_byte)((w>>8) & 0xff);\n                  *(dp++) = (png_byte)(w & 0xff);\n                  *(dp++) = *(sp++);  \n                  *(dp++) = *(sp++);\n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, gray16;\n                  red   = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;\n                  green = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;\n                  blue  = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;\n\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n\n                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);\n                  *(dp++) = (png_byte)((gray16>>8) & 0xff);\n                  *(dp++) = (png_byte)(gray16 & 0xff);\n                  *(dp++) = *(sp++);  \n                  *(dp++) = *(sp++);\n               }\n            }\n         }\n      }\n      row_info->channels -= 2;\n      row_info->color_type = (png_byte)(row_info->color_type &\n          ~PNG_COLOR_MASK_COLOR);\n      row_info->pixel_depth = (png_byte)(row_info->channels *\n          row_info->bit_depth);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n   }\n   return rgb_error;\n}\n#endif", "bug_type": "cve-2011-0408-2", "idx": 63}
{"project": "LibPNG", "target": 0, "func": "#endif\nstatic int format_is_initial(format_list *pf)\n{\n   int i;\n   for (i=0; i<FORMAT_SET_COUNT; ++i)\n      if (pf->bits[i] != 0)\n         return 0;\n   return 1;\n}\n", "bug_type": null, "idx": 64}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\npngtest_warning(png_structp png_ptr, png_const_charp message)\n{\n   PNG_CONST char *name = \"UNKNOWN (ERROR!)\";\n   char *test;\n   test = png_get_error_ptr(png_ptr);\n   if (test == NULL)\n     fprintf(STDERR, \"%s: libpng warning: %s\\n\", name, message);\n   else\n     fprintf(STDERR, \"%s: libpng warning: %s\\n\", test, message);\n}\n", "bug_type": null, "idx": 65}
{"project": "LibPNG", "target": 0, "func": "} \nstatic int rpng2_win_load_bg_image()\n{\n    uch *src, *dest;\n    uch r1, r2, g1, g2, b1, b2;\n    uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv;\n    int k, hmax, max;\n    int xidx, yidx, yidx_max = (bgscale-1);\n    int even_odd_vert, even_odd_horiz, even_odd;\n    int invert_gradient2 = (bg[pat].type & 0x08);\n    int invert_column;\n    ulg i, row;\n\n\n\n\n    bg_rowbytes = 3 * rpng2_info.width;\n    bg_data = (uch *)malloc(bg_rowbytes * rpng2_info.height);\n    if (!bg_data) {\n        fprintf(stderr, PROGNAME\n          \":  unable to allocate memory for background image\\n\");\n        bg_image = 0;\n        return 1;\n    }\n\n\n\n\n    if ((bg[pat].type & 0x07) == 0) {\n        uch r1_min  = rgb[bg[pat].rgb1_min].r;\n        uch g1_min  = rgb[bg[pat].rgb1_min].g;\n        uch b1_min  = rgb[bg[pat].rgb1_min].b;\n        uch r2_min  = rgb[bg[pat].rgb2_min].r;\n        uch g2_min  = rgb[bg[pat].rgb2_min].g;\n        uch b2_min  = rgb[bg[pat].rgb2_min].b;\n        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;\n        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;\n        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;\n        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;\n        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;\n        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;\n        for (row = 0;  row < rpng2_info.height;  ++row) {\n            yidx = row % bgscale;\n            even_odd_vert = (row / bgscale) & 1;\n            r1 = r1_min + (r1_diff * yidx) / yidx_max;\n            g1 = g1_min + (g1_diff * yidx) / yidx_max;\n            b1 = b1_min + (b1_diff * yidx) / yidx_max;\n            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;\n            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;\n            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;\n            r2 = r2_min + (r2_diff * yidx) / yidx_max;\n            g2 = g2_min + (g2_diff * yidx) / yidx_max;\n            b2 = b2_min + (b2_diff * yidx) / yidx_max;\n            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;\n            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;\n            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;\n            dest = bg_data + row*bg_rowbytes;\n            for (i = 0;  i < rpng2_info.width;  ++i) {\n                even_odd_horiz = (i / bgscale) & 1;\n                even_odd = even_odd_vert ^ even_odd_horiz;\n                invert_column =\n                  (even_odd_horiz && (bg[pat].type & 0x10));\n                if (even_odd == 0) {         \n                    if (invert_column) {\n                        *dest++ = r1_inv;\n                        *dest++ = g1_inv;\n                        *dest++ = b1_inv;\n                    } else {\n                        *dest++ = r1;\n                        *dest++ = g1;\n                        *dest++ = b1;\n                    }\n                } else {                     \n                    if ((invert_column && invert_gradient2) ||\n                        (!invert_column && !invert_gradient2))\n                    {\n                        *dest++ = r2;        \n                        *dest++ = g2;        \n                        *dest++ = b2;\n                    } else {\n                        *dest++ = r2_inv;\n                        *dest++ = g2_inv;    \n                        *dest++ = b2_inv;\n                    }\n                }\n            }\n        }\n\n\n\n\n    } else if ((bg[pat].type & 0x07) == 1) {\n        hmax = (bgscale-1)/2;   \n        max = 2*hmax;           \n        r1 = rgb[bg[pat].rgb1_max].r;\n        g1 = rgb[bg[pat].rgb1_max].g;\n        b1 = rgb[bg[pat].rgb1_max].b;\n        r2 = rgb[bg[pat].rgb2_max].r;\n        g2 = rgb[bg[pat].rgb2_max].g;\n        b2 = rgb[bg[pat].rgb2_max].b;\n        for (row = 0;  row < rpng2_info.height;  ++row) {\n            yidx = row % bgscale;\n            if (yidx > hmax)\n                yidx = bgscale-1 - yidx;\n            dest = bg_data + row*bg_rowbytes;\n            for (i = 0;  i < rpng2_info.width;  ++i) {\n                xidx = i % bgscale;\n                if (xidx > hmax)\n                    xidx = bgscale-1 - xidx;\n                k = xidx + yidx;\n                *dest++ = (k*r1 + (max-k)*r2) / max;\n                *dest++ = (k*g1 + (max-k)*g2) / max;\n                *dest++ = (k*b1 + (max-k)*b2) / max;\n            }\n        }\n\n\n\n\n\n    } else if ((bg[pat].type & 0x07) == 2) {\n        uch ch;\n        int ii, x, y, hw, hh, grayspot;\n        double freq, rotate, saturate, gray, intensity;\n        double angle=0.0, aoffset=0.0, maxDist, dist;\n        double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t;\n        fprintf(stderr, \"%s:  computing radial background...\",\n          PROGNAME);\n        fflush(stderr);\n        hh = rpng2_info.height / 2;\n        hw = rpng2_info.width / 2;\n        \n\n\n\n\n\n\n        angle = CLIP(angle, 0.0, 360.0);\n        grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw));\n        freq = MAX((double)bg[pat].bg_freq, 0.0);\n        saturate = (double)bg[pat].bg_bsat * 0.1;\n        rotate = (double)bg[pat].bg_brot * 0.1;\n        gray = 0.0;\n        intensity = 0.0;\n        maxDist = (double)((hw*hw) + (hh*hh));\n        for (row = 0;  row < rpng2_info.height;  ++row) {\n            y = row - hh;\n            dest = bg_data + row*bg_rowbytes;\n            for (i = 0;  i < rpng2_info.width;  ++i) {\n                x = i - hw;\n                angle = (x == 0)? PI_2 : atan((double)y / (double)x);\n                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;\n                gray = MIN(1.0, gray);\n                dist = (double)((x*x) + (y*y)) / maxDist;\n                intensity = cos((angle+(rotate*dist*PI)) * freq) *\n                  gray * saturate;\n                intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5;\n                hue = (angle + PI) * INV_PI_360 + aoffset;\n                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));\n                s = MIN(MAX(s,0.0), 1.0);\n                v = MIN(MAX(intensity,0.0), 1.0);\n                if (s == 0.0) {\n                    ch = (uch)(v * 255.0);\n                    *dest++ = ch;\n                    *dest++ = ch;\n                    *dest++ = ch;\n                } else {\n                    if ((hue < 0.0) || (hue >= 360.0))\n                        hue -= (((int)(hue / 360.0)) * 360.0);\n                    hue /= 60.0;\n                    ii = (int)hue;\n                    f = hue - (double)ii;\n                    p = (1.0 - s) * v;\n                    q = (1.0 - (s * f)) * v;\n                    t = (1.0 - (s * (1.0 - f))) * v;\n                    if      (ii == 0) { red = v; green = t; blue = p; }\n                    else if (ii == 1) { red = q; green = v; blue = p; }\n                    else if (ii == 2) { red = p; green = v; blue = t; }\n                    else if (ii == 3) { red = p; green = q; blue = v; }\n                    else if (ii == 4) { red = t; green = p; blue = v; }\n                    else if (ii == 5) { red = v; green = p; blue = q; }\n                    *dest++ = (uch)(red * 255.0);\n                    *dest++ = (uch)(green * 255.0);\n                    *dest++ = (uch)(blue * 255.0);\n                }\n            }\n        }\n        fprintf(stderr, \"done.\\n\");\n        fflush(stderr);\n    }\n\n\n\n\n    for (row = 0;  row < rpng2_info.height;  ++row) {\n        src = bg_data + row*bg_rowbytes;\n        dest = wimage_data + row*wimage_rowbytes;\n        for (i = rpng2_info.width;  i > 0;  --i) {\n            r1 = *src++;\n            g1 = *src++;\n            b1 = *src++;\n            *dest++ = b1;\n            *dest++ = g1;   \n            *dest++ = r1;\n        }\n    }\n    return 0;\n} \n", "bug_type": null, "idx": 66}
{"project": "LibPNG", "target": 1, "func": "\npng_charp \npng_decompress_chunk(png_structp png_ptr, int comp_type,\n                              png_charp chunkdata, png_size_t chunklength,\n                              png_size_t prefix_size, png_size_t *newlength)\n{\n   static char msg[] = \"Error decoding compressed text\";\n   png_charp text;\n   png_size_t text_size;\n\n   if (comp_type == PNG_COMPRESSION_TYPE_BASE)\n   {\n      int ret = Z_OK;\n      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);\n      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n      text_size = 0;\n      text = NULL;\n\n      while (png_ptr->zstream.avail_in)\n      {\n         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END)\n         {\n            if (png_ptr->zstream.msg != NULL)\n               png_warning(png_ptr, png_ptr->zstream.msg);\n            else\n               png_warning(png_ptr, msg);\n            inflateReset(&png_ptr->zstream);\n            png_ptr->zstream.avail_in = 0;\n\n            if (text ==  NULL)\n            {\n               text_size = prefix_size + png_sizeof(msg) + 1;\n               text = (png_charp)png_malloc_warn(png_ptr, text_size);\n               if (text ==  NULL)\n                 {\n                    png_free(png_ptr,chunkdata);\n                    png_error(png_ptr,\"Not enough memory to decompress chunk\");\n                 }\n               png_memcpy(text, chunkdata, prefix_size);\n            }\n\n            text[text_size - 1] = 0x00;\n\n            \n            text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);\n            text_size = png_sizeof(msg) > text_size ? text_size :\n               png_sizeof(msg);\n            png_memcpy(text + prefix_size, msg, text_size + 1);\n            break;\n         }\n         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)\n         {\n            if (text == NULL)\n            {\n               text_size = prefix_size +\n                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);\n               if (text ==  NULL)\n                 {\n                    png_free(png_ptr,chunkdata);\n                    png_error(png_ptr,\"Not enough memory to decompress chunk.\");\n                 }\n               png_memcpy(text + prefix_size, png_ptr->zbuf,\n                    text_size - prefix_size);\n               png_memcpy(text, chunkdata, prefix_size);\n               *(text + text_size) = 0x00;\n            }\n            else\n            {\n               png_charp tmp;\n\n               tmp = text;\n               text = (png_charp)png_malloc_warn(png_ptr,\n                  (png_uint_32)(text_size +\n                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));\n               if (text == NULL)\n               {\n                  png_free(png_ptr, tmp);\n                  png_free(png_ptr, chunkdata);\n                  png_error(png_ptr,\"Not enough memory to decompress chunk..\");\n               }\n               png_memcpy(text, tmp, text_size);\n               png_free(png_ptr, tmp);\n               png_memcpy(text + text_size, png_ptr->zbuf,\n                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));\n               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n               *(text + text_size) = 0x00;\n            }\n            if (ret == Z_STREAM_END)\n               break;\n            else\n            {\n               png_ptr->zstream.next_out = png_ptr->zbuf;\n               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n            }\n         }\n      }\n      if (ret != Z_STREAM_END)\n      {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n         char umsg[50];\n\n         if (ret == Z_BUF_ERROR)\n            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         else if (ret == Z_DATA_ERROR)\n            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         else\n            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         png_warning(png_ptr, umsg);\n#else\n         png_warning(png_ptr,\n            \"Incomplete compressed datastream in chunk other than IDAT\");\n#endif\n         text_size=prefix_size;\n         if (text ==  NULL)\n         {\n            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);\n            if (text == NULL)\n              {\n                png_free(png_ptr, chunkdata);\n                png_error(png_ptr,\"Not enough memory for text.\");\n              }\n            png_memcpy(text, chunkdata, prefix_size);\n         }\n         *(text + text_size) = 0x00;\n      }\n\n      inflateReset(&png_ptr->zstream);\n      png_ptr->zstream.avail_in = 0;\n\n      png_free(png_ptr, chunkdata);\n      chunkdata = text;\n      *newlength=text_size;\n   }\n   else \n   {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n      char umsg[50];\n\n      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);\n      png_warning(png_ptr, umsg);\n#else\n      png_warning(png_ptr, \"Unknown zTXt compression type\");\n#endif\n\n      *(chunkdata + prefix_size) = 0x00;\n      *newlength=prefix_size;\n   }\n\n   return chunkdata;\n}", "bug_type": "cve-2006-3334", "idx": 67}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\ncrc_one_byte(png_uint_32 crc, int b)\n{\n   return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8);\n}\n", "bug_type": null, "idx": 68}
{"project": "LibPNG", "target": 0, "func": "int\nmain(int argc, char **argv)\n{\n   unsigned int i, i16, ibase;\n   double min_error = 0;\n   double max_error = 0;\n   double min_error16 = 0;\n   double max_error16 = 0;\n   double adjust;\n   double adjust_lo = 0.4, adjust_hi = 0.6, adjust_mid = 0.5;\n   unsigned int ec_lo = 0, ec_hi = 0, ec_mid = 0;\n   unsigned int error_count = 0;\n   unsigned int error_count16 = 0;\n   int test_only = 0;\n   if (argc > 1)\n      test_only = strcmp(\"--test\", argv[1]) == 0;\n   \n   for (i=0; i<256; ++i)\n   {\n      png_sRGB_table[i] = invsRGB(i);\n   }\n   \n\n\n   for (;;)\n   {\n      if (ec_lo == 0)\n         adjust = adjust_lo;\n      else if (ec_hi == 0)\n         adjust = adjust_hi;\n      else if (ec_mid == 0)\n         adjust = adjust_mid;\n      else if (ec_mid < ec_hi)\n         adjust = (adjust_mid + adjust_hi)/2;\n      else if (ec_mid < ec_lo)\n         adjust = (adjust_mid + adjust_lo)/2;\n      else\n      {\n         fprintf(stderr, \"not reached: %u .. %u .. %u\\n\", ec_lo, ec_mid, ec_hi);\n         exit(1);\n      }\n      \n      for (i=0; i<=511; ++i)\n      {\n         double lo = 255 * sRGB(i << 15);\n         double hi = 255 * sRGB((i+1) << 15);\n         unsigned int calc;\n         calc = nearbyint((lo+adjust) * 256);\n         if (calc > 65535)\n         {\n            fprintf(stderr, \"table[%d][0]: overflow %08x (%d)\\n\", i, calc,\n               calc);\n            exit(1);\n         }\n         png_sRGB_base[i] = calc;\n         calc = nearbyint((hi-lo) * 32);\n         if (calc > 255)\n         {\n            fprintf(stderr, \"table[%d][1]: overflow %08x (%d)\\n\", i, calc,\n               calc);\n            exit(1);\n         }\n         png_sRGB_delta[i] = calc;\n      }\n      \n      error_count16 = 0;\n      for (i16=0; i16 <= 65535; ++i16)\n      {\n         unsigned int i = 255*i16;\n         unsigned int iexact = nearbyint(255*sRGB(i));\n         unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);\n         if (icalc != iexact)\n            ++error_count16;\n      }\n      \n      if (ec_lo == 0)\n         ec_lo = error_count16;\n      else if (ec_hi == 0)\n         ec_hi = error_count16;\n      else if (ec_mid == 0)\n      {\n         ec_mid = error_count16;\n         printf(\"/* initial error counts: %u .. %u .. %u */\\n\", ec_lo, ec_mid,\n            ec_hi);\n      }\n      else if (error_count16 < ec_mid)\n      {\n         printf(\"/* adjust (mid ): %f: %u -> %u */\\n\", adjust, ec_mid,\n            error_count16);\n         ec_mid = error_count16;\n         adjust_mid = adjust;\n      }\n      else if (adjust < adjust_mid && error_count16 < ec_lo)\n      {\n         printf(\"/* adjust (low ): %f: %u -> %u */\\n\", adjust, ec_lo,\n            error_count16);\n         ec_lo = error_count16;\n         adjust_lo = adjust;\n      }\n      else if (adjust > adjust_mid && error_count16 < ec_hi)\n      {\n         printf(\"/* adjust (high): %f: %u -> %u */\\n\", adjust, ec_hi,\n            error_count16);\n         ec_hi = error_count16;\n         adjust_hi = adjust;\n      }\n      else\n      {\n         adjust = adjust_mid;\n         printf(\"/* adjust: %f: %u */\\n\", adjust, ec_mid);\n         break;\n      }\n   }\n   \n\n\n   for (ibase=0; ibase<65536; ibase+=128)\n   {\n      png_uint_16 base = png_sRGB_base[ibase >> 7], trybase = base, ob=base;\n      png_byte delta = png_sRGB_delta[ibase >> 7], trydelta = delta, od=delta;\n      unsigned int ecbase = 0, eco;\n      for (;;)\n      {\n         png_sRGB_base[ibase >> 7] = trybase;\n         png_sRGB_delta[ibase >> 7] = trydelta;\n         \n         error_count16 = 0;\n         for (i16=ibase; i16 < ibase+128; ++i16)\n         {\n            unsigned int i = 255*i16;\n            unsigned int iexact = nearbyint(255*sRGB(i));\n            unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);\n            if (icalc != iexact)\n               ++error_count16;\n         }\n         if (error_count16 == 0)\n            break;\n         if (ecbase == 0)\n         {\n            eco = ecbase = error_count16;\n            ++trybase; \n         }\n         else if (error_count16 < ecbase)\n         {\n            if (trybase > base)\n            {\n               base = trybase;\n               ++trybase;\n            }\n            else if (trybase < base)\n            {\n               base = trybase;\n               --trybase;\n            }\n            else if (trydelta > delta)\n            {\n               delta = trydelta;\n               ++trydelta;\n            }\n            else if (trydelta < delta)\n            {\n               delta = trydelta;\n               --trydelta;\n            }\n            else\n            {\n               fprintf(stderr, \"makesRGB: impossible\\n\");\n               exit(1);\n            }\n            ecbase = error_count16;\n         }\n         else\n         {\n            if (trybase > base)\n               trybase = base-1;\n            else if (trybase < base)\n            {\n               trybase = base;\n               ++trydelta;\n            }\n            else if (trydelta > delta)\n               trydelta = delta-1;\n            else if (trydelta < delta)\n               break; \n         }\n      }\n      png_sRGB_base[ibase >> 7] = base;\n      png_sRGB_delta[ibase >> 7] = delta;\n      if (base != ob || delta != od)\n      {\n         printf(\"/* table[%u]={%u,%u} -> {%u,%u} %u -> %u errors */\\n\",\n            ibase>>7, ob, od, base, delta, eco, ecbase);\n      }\n      else if (0)\n         printf(\"/* table[%u]={%u,%u} %u errors */\\n\", ibase>>7, ob, od,\n            ecbase);\n   }\n   \n   min_error = -.4999;\n   max_error = .4999;\n   error_count = 0;\n   for (i=0; i <= max_input; ++i)\n   {\n      unsigned int iexact = nearbyint(255*sRGB(i));\n      unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);\n      if (icalc != iexact)\n      {\n         double err = 255*sRGB(i) - icalc;\n         if (err > (max_error+.001) || err < (min_error-.001))\n         {\n            printf(\n               \"/* 0x%08x: exact: %3d, got: %3d [tables: %08x, %08x] (%f) */\\n\",\n               i, iexact, icalc, png_sRGB_base[i>>15],\n               png_sRGB_delta[i>>15], err);\n         }\n         ++error_count;\n         if (err > max_error)\n            max_error = err;\n         else if (err < min_error)\n            min_error = err;\n      }\n   }\n   \n\n\n   error_count16 = 0;\n   max_error16 = 0;\n   min_error16 = 0;\n   for (i16=0; i16 <= 65535; ++i16)\n   {\n      unsigned int i = 255*i16;\n      unsigned int iexact = nearbyint(255*sRGB(i));\n      unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);\n      if (icalc != iexact)\n      {\n         double err = 255*sRGB(i) - icalc;\n         ++error_count16;\n         if (err > max_error16)\n            max_error16 = err;\n         else if (err < min_error16)\n            min_error16 = err;\n         if (abs(icalc - iexact) > 1)\n            printf(\n               \"/* 0x%04x: exact: %3d, got: %3d [tables: %08x, %08x] (%f) */\\n\",\n               i16, iexact, icalc, png_sRGB_base[i>>15],\n               png_sRGB_delta[i>>15], err);\n      }\n   }\n   \n   for (i16=0; i16 <= 255; ++i16)\n   {\n      unsigned int i = 255 * png_sRGB_table[i16];\n      unsigned int iexact = nearbyint(255*sRGB(i));\n      unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);\n      if (i16 != iexact)\n      {\n         fprintf(stderr, \"8-bit rounding error: %d -> %d\\n\", i16, iexact);\n         exit(1);\n      }\n      if (icalc != i16)\n      {\n         double finv = finvsRGB(i16);\n         printf(\"/* 8-bit roundtrip error: %d -> %f -> %d(%f) */\\n\",\n            i16, finv, icalc, fsRGB(255*finv));\n      }\n   }\n   printf(\"/* error: %g - %g, %u (%g%%) of readings inexact */\\n\",\n      min_error, max_error, error_count, (100.*error_count)/max_input);\n   printf(\"/* 16-bit error: %g - %g, %u (%g%%) of readings inexact */\\n\",\n      min_error16, max_error16, error_count16, (100.*error_count16)/65535);\n   if (!test_only)\n   {\n      printf(\"PNG_CONST png_uint_16 png_sRGB_table[256] =\\n{\\n   \");\n      for (i=0; i<255; )\n      {\n         do\n         {\n            printf(\"%d,\", png_sRGB_table[i++]);\n         }\n         while ((i & 0x7) != 0 && i<255);\n         if (i<255) printf(\"\\n   \");\n      }\n      printf(\"%d\\n};\\n\\n\", png_sRGB_table[i]);\n      printf(\"PNG_CONST png_uint_16 png_sRGB_base[512] =\\n{\\n   \");\n      for (i=0; i<511; )\n      {\n         do\n         {\n            printf(\"%d,\", png_sRGB_base[i++]);\n         }\n         while ((i & 0x7) != 0 && i<511);\n         if (i<511) printf(\"\\n   \");\n      }\n      printf(\"%d\\n};\\n\\n\", png_sRGB_base[i]);\n      printf(\"PNG_CONST png_byte png_sRGB_delta[512] =\\n{\\n   \");\n      for (i=0; i<511; )\n      {\n         do\n         {\n            printf(\"%d,\", png_sRGB_delta[i++]);\n         }\n         while ((i & 0xf) != 0 && i<511);\n         if (i<511) printf(\"\\n   \");\n      }\n      printf(\"%d\\n};\\n\\n\", png_sRGB_delta[i]);\n   }\n   return 0;\n}\n", "bug_type": null, "idx": 69}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_pool_init(png_store *ps, store_pool *pool)\n{\n   memset(pool, 0, sizeof *pool);\n   pool->store = ps;\n   pool->list = NULL;\n   pool->max = pool->current = pool->limit = pool->total = 0;\n   pool->max_max = pool->max_limit = pool->max_total = 0;\n   store_pool_mark(pool->mark);\n}\n", "bug_type": null, "idx": 70}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_noop(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   out->r = in->r;\n   out->g = in->g;\n   out->b = in->b;\n   out->a = in->a;\n}\n", "bug_type": null, "idx": 71}
{"project": "LibPNG", "target": 1, "func": "\n\nvoid \npng_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,\n   png_charp profile, int profile_len)\n{\n#ifdef PNG_USE_LOCAL_ARRAYS\n   PNG_iCCP;\n#endif\n   png_size_t name_len;\n   png_charp new_name;\n   compression_state comp;\n\n   png_debug(1, \"in png_write_iCCP\\n\");\n\n   comp.num_output_ptr = 0;\n   comp.max_output_ptr = 0;\n   comp.output_ptr = NULL;\n   comp.input = NULL;\n   comp.input_len = 0;\n\n   if (name == NULL || (name_len = png_check_keyword(png_ptr, name,\n      &new_name)) == 0)\n   {\n      png_warning(png_ptr, \"Empty keyword in iCCP chunk\");\n      return;\n   }\n\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\n      png_warning(png_ptr, \"Unknown compression type in iCCP chunk\");\n\n   if (profile == NULL)\n      profile_len = 0;\n\n   if (profile_len)\n       profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,\n          PNG_COMPRESSION_TYPE_BASE, &comp);\n\n   \n   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,\n          (png_uint_32)name_len+profile_len+2);\n   new_name[name_len+1]=0x00;\n   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2);\n\n   if (profile_len)\n      png_write_compressed_data_out(png_ptr, &comp);\n\n   png_write_chunk_end(png_ptr);\n   png_free(png_ptr, new_name);\n}\n#endif", "bug_type": "cve-2006-7244", "idx": 72}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_default_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(colour_type)\n   UNUSED(bit_depth)\n   this->next = *that;\n   *that = this;\n   return 1;\n}\n", "bug_type": null, "idx": 73}
{"project": "LibPNG", "target": 0, "func": "static void\ninsert_iCCP(png_structp png_ptr, png_infop info_ptr, int nparams,\n   png_charpp params)\n{\n   png_bytep profile = NULL;\n   png_uint_32 proflen = 0;\n   int result;\n   check_param_count(nparams, 2);\n   switch (params[1][0])\n   {\n      case '<':\n         {\n            png_size_t filelen = load_file(params[1]+1, &profile);\n            if (filelen > 0xfffffffc) \n            {\n               fprintf(stderr, \"%s: file too long (%lu) for an ICC profile\\n\",\n                  params[1]+1, (unsigned long)filelen);\n               exit(1);\n            }\n            proflen = (png_uint_32)filelen;\n         }\n         break;\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n         {\n            png_size_t fake_len = load_fake(params[1], &profile);\n            if (fake_len > 0) \n            {\n               if (fake_len > 0xffffffff) \n               {\n                  fprintf(stderr,\n                     \"%s: fake data too long (%lu) for an ICC profile\\n\",\n                     params[1], (unsigned long)fake_len);\n                  exit(1);\n               }\n               proflen = (png_uint_32)(fake_len & ~3U);\n               \n               png_save_uint_32(profile, proflen);\n               break;\n            }\n         }\n      default:\n         fprintf(stderr, \"--insert iCCP \\\"%s\\\": unrecognized\\n\", params[1]);\n         fprintf(stderr, \"  use '<' to read a file: \\\"<filename\\\"\\n\");\n         exit(1);\n   }\n   result = 1;\n   if (proflen & 3)\n   {\n      fprintf(stderr,\n         \"makepng: --insert iCCP %s: profile length made a multiple of 4\\n\",\n         params[1]);\n      \n\n\n      while (proflen & 3)\n         profile[proflen++] = 0;\n   }\n   if (profile != NULL && proflen > 3)\n   {\n      png_uint_32 prof_header = png_get_uint_32(profile);\n      if (prof_header != proflen)\n      {\n         fprintf(stderr, \"--insert iCCP %s: profile length field wrong:\\n\",\n            params[1]);\n         fprintf(stderr, \"  actual %lu, recorded value %lu (corrected)\\n\",\n            (unsigned long)proflen, (unsigned long)prof_header);\n         png_save_uint_32(profile, proflen);\n      }\n   }\n   if (result && profile != NULL && proflen >=4)\n      png_set_iCCP(png_ptr, info_ptr, params[0], PNG_COMPRESSION_TYPE_BASE,\n         profile, proflen);\n   if (profile)\n      free(profile);\n   if (!result)\n      exit(1);\n}\n", "bug_type": null, "idx": 74}
{"project": "LibPNG", "target": 0, "func": "static int\nread_byte(struct file *file)\n{\n   int ch = getc(file->file);\n   if (ch >= 0 && ch <= 255)\n   {\n      ++(file->read_count);\n      return ch;\n   }\n   else if (ch != EOF)\n   {\n      file->status_code |= INTERNAL_ERROR;\n      file->read_errno = ERANGE; \n      \n      emit_error(file, UNEXPECTED_ERROR_CODE, \"file read\");\n   }\n#  ifdef EINTR\n      else if (errno == EINTR) \n      {\n         errno = 0;\n         return read_byte(file);\n      }\n#  endif\n   else\n   {\n      \n\n\n      if (ferror(file->file))\n         file->read_errno = errno;\n      else if (feof(file->file))\n         file->read_errno = 0; \n      else \n         file->read_errno = EDOM;\n   }\n   \n\n\n\n   file->status_code |= TRUNCATED;\n   return EOF;\n}\n", "bug_type": null, "idx": 75}
{"project": "LibPNG", "target": 0, "func": "#if DIGITIZE\nstatic double digitize(double value, int depth, int do_round)\n{\n   \n\n\n\n\n\n   PNG_CONST unsigned int digitization_factor = (1U << depth) -1;\n   \n\n\n   if (value <= 0)\n      value = 0;\n   else if (value >= 1)\n      value = 1;\n   value *= digitization_factor;\n   if (do_round) value += .5;\n   return floor(value)/digitization_factor;\n}\n", "bug_type": null, "idx": 76}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_gamma_composition_tests(png_modifier *pm, int do_background,\n   int expand_16)\n{\n   png_byte colour_type = 0;\n   png_byte bit_depth = 0;\n   unsigned int palette_number = 0;\n   \n\n\n   while (next_format(&colour_type, &bit_depth, &palette_number, 1))\n      if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0)\n   {\n      unsigned int i, j;\n      \n      for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)\n      {\n         gamma_composition_test(pm, colour_type, bit_depth, palette_number,\n            pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],\n            pm->use_input_precision, do_background, expand_16);\n         if (fail(pm))\n            return;\n      }\n   }\n}\n", "bug_type": null, "idx": 77}
{"project": "LibPNG", "target": 0, "func": "#define COUNT 1000000000\nint main(int argc, char **argv)\n{\n   int count = COUNT;\n   while (argc > 1)\n   {\n      if (argc > 2 && strcmp(argv[1], \"-c\") == 0)\n      {\n         count = atoi(argv[2]);\n         argc -= 2;\n         argv += 2;\n      }\n      else if (strcmp(argv[1], \"-v\") == 0)\n      {\n         ++verbose;\n         --argc;\n         ++argv;\n      }\n      else\n         break;\n   }\n   if (count > 0 && argc > 1)\n   {\n      if (strcmp(argv[1], \"ascii\") == 0)\n         return validation_ascii_to_fp(count, argc-1, argv+1);\n      else if (strcmp(argv[1], \"checkfp\") == 0)\n         return validation_checkfp(count, argc-1, argv+1);\n      else if (strcmp(argv[1], \"muldiv\") == 0)\n         return validation_muldiv(count, argc-1, argv+1);\n      else if (strcmp(argv[1], \"gamma\") == 0)\n         return validation_gamma(argc-1, argv+1);\n   }\n   \n   fprintf(stderr,\n      \"usage: tarith [-v] [-c count] {ascii,muldiv,gamma} [args]\\n\");\n   fprintf(stderr, \" arguments: ascii [-a (all results)] [-e error%%]\\n\");\n   fprintf(stderr, \"            checkfp [-l max-number-chars]\\n\");\n   fprintf(stderr, \"            muldiv\\n\");\n   fprintf(stderr, \"            gamma -s (silent) -g (only gamma; no log)\\n\");\n   return 1;\n}\n", "bug_type": null, "idx": 78}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_read_reset(png_store *ps)\n{\n#  ifdef PNG_READ_SUPPORTED\n      if (ps->pread != NULL)\n      {\n         anon_context(ps);\n         Try\n            png_destroy_read_struct(&ps->pread, &ps->piread, NULL);\n         Catch_anonymous\n         {\n            \n         }\n         ps->pread = NULL;\n         ps->piread = NULL;\n      }\n#  endif\n#  ifdef PNG_USER_MEM_SUPPORTED\n      \n      store_pool_delete(ps, &ps->read_memory_pool);\n#  endif\n   ps->current = NULL;\n   ps->next = NULL;\n   ps->readpos = 0;\n   ps->validated = 0;\n}\n", "bug_type": null, "idx": 79}
{"project": "LibPNG", "target": 0, "func": "static int\nfind_by_flag(png_uint_32 flag)\n{\n   int i = NINFO;\n   while (--i >= 0) if (chunk_info[i].flag == flag) return i;\n   fprintf(stderr, \"pngunknown: internal error\\n\");\n   exit(4);\n}\n", "bug_type": null, "idx": 80}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_textp text_ptr;\n   png_charp key;\n   png_charp text;\n   png_uint_32 skip = 0;\n   png_size_t slength;\n   int ret;\n\n   png_debug(1, \"in png_handle_tEXt\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before tEXt\");\n\n   if (png_ptr->mode & PNG_HAVE_IDAT)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > (png_uint_32)65535L)\n   {\n      png_warning(png_ptr, \"tEXt chunk too large to fit in memory\");\n      skip = length - (png_uint_32)65535L;\n      length = (png_uint_32)65535L;\n   }\n#endif\n\n   key = (png_charp)png_malloc_warn(png_ptr, length + 1);\n   if (key == NULL)\n   {\n     png_warning(png_ptr, \"No memory to process text chunk.\");\n     return;\n   }\n   slength = (png_size_t)length;\n   png_crc_read(png_ptr, (png_bytep)key, slength);\n\n   if (png_crc_finish(png_ptr, skip))\n   {\n      png_free(png_ptr, key);\n      return;\n   }\n\n   key[slength] = 0x00;\n\n   for (text = key; *text; text++)\n       ;\n\n   if (text != key + slength)\n      text++;\n\n   text_ptr = (png_textp)png_malloc_warn(png_ptr,\n      (png_uint_32)png_sizeof(png_text));\n   if (text_ptr == NULL)\n   {\n     png_warning(png_ptr, \"Not enough memory to process text chunk.\");\n     png_free(png_ptr, key);\n     return;\n   }\n   text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;\n   text_ptr->key = key;\n#ifdef PNG_iTXt_SUPPORTED\n   text_ptr->lang = NULL;\n   text_ptr->lang_key = NULL;\n   text_ptr->itxt_length = 0;\n#endif\n   text_ptr->text = text;\n   text_ptr->text_length = png_strlen(text);\n\n   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n   png_free(png_ptr, key);\n   png_free(png_ptr, text_ptr);\n   if (ret)\n     png_warning(png_ptr, \"Insufficient memory to process text chunk.\");\n}\n#endif", "bug_type": "cve-2008-6218", "idx": 81}
{"project": "LibPNG", "target": 0, "func": "static int\nchannels_of_type(int color_type)\n{\n   if (color_type & PNG_COLOR_MASK_PALETTE)\n      return 1;\n   else\n   {\n      int channels = 1;\n      if (color_type & PNG_COLOR_MASK_COLOR)\n         channels = 3;\n      if (color_type & PNG_COLOR_MASK_ALPHA)\n         return channels + 1;\n      else\n         return channels;\n   }\n}\n", "bug_type": null, "idx": 82}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_info_imp(transform_display *dp, png_structp pp, png_infop pi)\n{\n   \n   standard_info_part1(&dp->this, pp, pi);\n   \n   dp->transform_list->set(dp->transform_list, dp, pp, pi);\n   \n   {\n      int i = dp->this.use_update_info;\n      \n      do\n         png_read_update_info(pp, pi);\n      while (--i > 0);\n   }\n   \n   standard_info_part2(&dp->this, pp, pi, 1);\n   \n   dp->output_colour_type = png_get_color_type(pp, pi);\n   dp->output_bit_depth = png_get_bit_depth(pp, pi);\n   \n\n\n\n   switch (dp->output_colour_type)\n   {\n   case PNG_COLOR_TYPE_PALETTE:\n      if (dp->output_bit_depth > 8) goto error;\n      \n   case PNG_COLOR_TYPE_GRAY:\n      if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 ||\n         dp->output_bit_depth == 4)\n         break;\n      \n   default:\n      if (dp->output_bit_depth == 8 || dp->output_bit_depth == 16)\n         break;\n      \n   error:\n      {\n         char message[128];\n         size_t pos;\n         pos = safecat(message, sizeof message, 0,\n            \"invalid final bit depth: colour type(\");\n         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);\n         pos = safecat(message, sizeof message, pos, \") with bit depth: \");\n         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);\n         png_error(pp, message);\n      }\n   }\n   \n\n\n   {\n      image_pixel test_pixel;\n      memset(&test_pixel, 0, sizeof test_pixel);\n      test_pixel.colour_type = dp->this.colour_type; \n      test_pixel.bit_depth = dp->this.bit_depth;\n      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)\n         test_pixel.sample_depth = 8;\n      else\n         test_pixel.sample_depth = test_pixel.bit_depth;\n      \n\n\n      test_pixel.have_tRNS = dp->this.is_transparent;\n      test_pixel.red_sBIT = test_pixel.green_sBIT = test_pixel.blue_sBIT =\n         test_pixel.alpha_sBIT = test_pixel.sample_depth;\n      dp->transform_list->mod(dp->transform_list, &test_pixel, pp, dp);\n      if (test_pixel.colour_type != dp->output_colour_type)\n      {\n         char message[128];\n         size_t pos = safecat(message, sizeof message, 0, \"colour type \");\n         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);\n         pos = safecat(message, sizeof message, pos, \" expected \");\n         pos = safecatn(message, sizeof message, pos, test_pixel.colour_type);\n         png_error(pp, message);\n      }\n      if (test_pixel.bit_depth != dp->output_bit_depth)\n      {\n         char message[128];\n         size_t pos = safecat(message, sizeof message, 0, \"bit depth \");\n         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);\n         pos = safecat(message, sizeof message, pos, \" expected \");\n         pos = safecatn(message, sizeof message, pos, test_pixel.bit_depth);\n         png_error(pp, message);\n      }\n      \n\n\n      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (test_pixel.sample_depth != 8) \n            png_error(pp, \"pngvalid: internal: palette sample depth not 8\");\n      }\n      else if (test_pixel.sample_depth != dp->output_bit_depth)\n      {\n         char message[128];\n         size_t pos = safecat(message, sizeof message, 0,\n            \"internal: sample depth \");\n         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);\n         pos = safecat(message, sizeof message, pos, \" expected \");\n         pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth);\n         png_error(pp, message);\n      }\n   }\n}\n", "bug_type": null, "idx": 83}
{"project": "LibPNG", "target": 0, "func": " */\nstatic double outerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n{\n   \n\n\n\n\n\n\n   if (out_depth == 2)\n      return .73182-.5;\n   if (out_depth == 4)\n      return .90644-.5;\n   if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n      return pm->maxout16;\n   \n\n\n   else if (out_depth == 16)\n      return pm->maxout8 * 257;\n   else\n      return pm->maxout8;\n}\n", "bug_type": null, "idx": 84}
{"project": "LibPNG", "target": 0, "func": "static const char *\nzlib_flevel(struct zlib *zlib)\n{\n   switch (zlib->header[1] >> 6)\n   {\n      case 0:  return \"supfast\";\n      case 1:  return \"stdfast\";\n      case 2:  return \"default\";\n      case 3:  return \"maximum\";\n      default: assert(UNREACHED);\n   }\n   return \"COMPILER BUG\";\n}\n", "bug_type": null, "idx": 85}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\npngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n   png_size_t check = 0;\n   png_voidp io_ptr;\n   \n\n\n   io_ptr = png_get_io_ptr(png_ptr);\n   if (io_ptr != NULL)\n   {\n      check = fread(data, 1, length, (png_FILE_p)io_ptr);\n   }\n   if (check != length)\n   {\n      png_error(png_ptr, \"Read Error\");\n   }\n#ifdef PNG_IO_STATE_SUPPORTED\n   pngtest_check_io_state(png_ptr, length, PNG_IO_READING);\n#endif\n}\nstatic void PNGCBAPI\npngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n   png_size_t check;\n   png_byte *n_data;\n   png_FILE_p io_ptr;\n   \n   n_data = (png_byte *)CVT_PTR_NOCHECK(data);\n   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));\n   if ((png_bytep)n_data == data)\n   {\n      check = fread(n_data, 1, length, io_ptr);\n   }\n   else\n   {\n      png_byte buf[NEAR_BUF_SIZE];\n      png_size_t read, remaining, err;\n      check = 0;\n      remaining = length;\n      do\n      {\n         read = MIN(NEAR_BUF_SIZE, remaining);\n         err = fread(buf, 1, 1, io_ptr);\n         png_memcpy(data, buf, read); \n         if (err != read)\n            break;\n         else\n            check += err;\n         data += read;\n         remaining -= read;\n      }\n      while (remaining != 0);\n   }\n   if (check != length)\n      png_error(png_ptr, \"Read Error\");\n#ifdef PNG_IO_STATE_SUPPORTED\n   pngtest_check_io_state(png_ptr, length, PNG_IO_READING);\n#endif\n}\n", "bug_type": null, "idx": 86}
{"project": "LibPNG", "target": 0, "func": "static void\nglobal_init(struct global *global)\n   \n{\n   CLEAR(*global);\n   \n   global->errors        = 0;\n   global->warnings      = 0;\n   global->quiet         = 0;\n   global->verbose       = 0;\n   global->idat_max      = 0;         \n   global->optimize_zlib = 0;\n   global->skip          = SKIP_NONE;\n   global->status_code   = 0;\n   IDAT_list_init(&global->idat_cache);\n}\n", "bug_type": null, "idx": 87}
{"project": "LibPNG", "target": 0, "func": "static void perform_gamma_sbit_tests(png_modifier *pm)\n{\n   png_byte sbit;\n   \n\n\n\n   for (sbit=pm->sbitlow; sbit<(1<<READ_BDHI); ++sbit)\n   {\n      png_byte colour_type = 0, bit_depth = 0;\n      unsigned int npalette = 0;\n      while (next_format(&colour_type, &bit_depth, &npalette, 1))\n         if ((colour_type & PNG_COLOR_MASK_ALPHA) == 0 &&\n            ((colour_type == 3 && sbit < 8) ||\n            (colour_type != 3 && sbit < bit_depth)))\n      {\n         unsigned int i;\n         for (i=0; i<pm->ngamma_tests; ++i)\n         {\n            unsigned int j;\n            for (j=0; j<pm->ngamma_tests; ++j) if (i != j)\n            {\n               gamma_transform_test(pm, colour_type, bit_depth, npalette,\n                  pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],\n                  sbit, pm->use_input_precision_sbit, 0 );\n               if (fail(pm))\n                  return;\n            }\n         }\n      }\n   }\n}\n", "bug_type": null, "idx": 88}
{"project": "LibPNG", "target": 0, "func": "static png_uint_16\nilinear_g22(int fixed_srgb)\n{\n   return u16d(65535 * g22_to_d[fixed_srgb]);\n}\n", "bug_type": null, "idx": 89}
{"project": "LibPNG", "target": 0, "func": "static void readpng2_row_callback(png_structp png_ptr, png_bytep new_row,\n                                  png_uint_32 row_num, int pass)\n{\n    mainprog_info  *mainprog_ptr;\n    \n\n    if (!new_row)\n        return;\n    \n\n    mainprog_ptr = png_get_progressive_ptr(png_ptr);\n    \n    mainprog_ptr->pass = pass;\n    \n\n\n    png_progressive_combine_row(png_ptr, mainprog_ptr->row_pointers[row_num],\n      new_row);\n    \n\n    (*mainprog_ptr->mainprog_display_row)(row_num);\n    \n    return;\n}\n", "bug_type": null, "idx": 90}
{"project": "LibPNG", "target": 0, "func": "static size_t\nsafecat_current_encoding(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST png_modifier *pm)\n{\n   pos = safecat_color_encoding(buffer, bufsize, pos, pm->current_encoding,\n      pm->current_gamma);\n   if (pm->encoding_ignored)\n      pos = safecat(buffer, bufsize, pos, \"[overridden]\");\n   return pos;\n}\n", "bug_type": null, "idx": 91}
{"project": "LibPNG", "target": 0, "func": "static int\nchrm_modify(png_modifier *pm, png_modification *me, int add)\n{\n   UNUSED(add)\n   \n   png_save_uint_32(pm->buffer   , 32);\n   png_save_uint_32(pm->buffer+ 4, CHUNK_cHRM);\n   png_save_uint_32(pm->buffer+ 8, ((chrm_modification*)me)->wx);\n   png_save_uint_32(pm->buffer+12, ((chrm_modification*)me)->wy);\n   png_save_uint_32(pm->buffer+16, ((chrm_modification*)me)->rx);\n   png_save_uint_32(pm->buffer+20, ((chrm_modification*)me)->ry);\n   png_save_uint_32(pm->buffer+24, ((chrm_modification*)me)->gx);\n   png_save_uint_32(pm->buffer+28, ((chrm_modification*)me)->gy);\n   png_save_uint_32(pm->buffer+32, ((chrm_modification*)me)->bx);\n   png_save_uint_32(pm->buffer+36, ((chrm_modification*)me)->by);\n   return 1;\n}\n", "bug_type": null, "idx": 92}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_textp text_ptr;\n   png_charp chunkdata;\n   png_charp key, lang, text, lang_key;\n   int comp_flag;\n   int comp_type = 0;\n   int ret;\n   png_size_t slength, prefix_len, data_len;\n\n   png_debug(1, \"in png_handle_iTXt\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before iTXt\");\n\n   if (png_ptr->mode & PNG_HAVE_IDAT)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n#ifdef PNG_MAX_MALLOC_64K\n   \n\n   if (length > (png_uint_32)65535L)\n   {\n     png_warning(png_ptr,\"iTXt chunk too large to fit in memory\");\n     png_crc_finish(png_ptr, length);\n     return;\n   }\n#endif\n\n   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);\n   if (chunkdata == NULL)\n   {\n     png_warning(png_ptr, \"No memory to process iTXt chunk.\");\n     return;\n   }\n   slength = (png_size_t)length;\n   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_free(png_ptr, chunkdata);\n      return;\n   }\n\n   chunkdata[slength] = 0x00;\n\n   for (lang = chunkdata; *lang; lang++)\n       ;\n   lang++;        \n\n   \n\n\n\n   if (lang >= chunkdata + slength)\n   {\n      comp_flag = PNG_TEXT_COMPRESSION_NONE;\n      png_warning(png_ptr, \"Zero length iTXt chunk\");\n   }\n   else\n   {\n       comp_flag = *lang++;\n       comp_type = *lang++;\n   }\n\n   for (lang_key = lang; *lang_key; lang_key++)\n       ;\n   lang_key++;        \n\n   for (text = lang_key; *text; text++)\n       ;\n   text++;        \n\n   prefix_len = text - chunkdata;\n\n   key=chunkdata;\n   if (comp_flag)\n       chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata,\n          (size_t)length, prefix_len, &data_len);\n   else\n       data_len=png_strlen(chunkdata + prefix_len);\n   text_ptr = (png_textp)png_malloc_warn(png_ptr,\n      (png_uint_32)png_sizeof(png_text));\n   if (text_ptr == NULL)\n   {\n     png_warning(png_ptr,\"Not enough memory to process iTXt chunk.\");\n     png_free(png_ptr, chunkdata);\n     return;\n   }\n   text_ptr->compression = (int)comp_flag + 1;\n   text_ptr->lang_key = chunkdata+(lang_key-key);\n   text_ptr->lang = chunkdata+(lang-key);\n   text_ptr->itxt_length = data_len;\n   text_ptr->text_length = 0;\n   text_ptr->key = chunkdata;\n   text_ptr->text = chunkdata + prefix_len;\n\n   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n   png_free(png_ptr, text_ptr);\n   png_free(png_ptr, chunkdata);\n   if (ret)\n     png_error(png_ptr, \"Insufficient memory to store iTXt chunk.\");\n}\n#endif", "bug_type": "cve-2007-5629-3", "idx": 93}
{"project": "LibPNG", "target": 0, "func": "static void\ncheck_handling(display *d, int def, png_uint_32 chunks, png_uint_32 known,\n   png_uint_32 unknown, const char *position, int set_callback)\n{\n   while (chunks)\n   {\n      png_uint_32 flag = chunks & -(png_int_32)chunks;\n      int i = find_by_flag(flag);\n      int keep = chunk_info[i].keep;\n      const char *type;\n      const char *errorx = NULL;\n      if (chunk_info[i].unknown)\n      {\n         if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n         {\n            type = \"UNKNOWN (default)\";\n            keep = def;\n         }\n         else\n            type = \"UNKNOWN (specified)\";\n         if (flag & known)\n            errorx = \"chunk processed\";\n         else switch (keep)\n         {\n            case PNG_HANDLE_CHUNK_AS_DEFAULT:\n               if (flag & unknown)\n                  errorx = \"DEFAULT: unknown chunk saved\";\n               break;\n            case PNG_HANDLE_CHUNK_NEVER:\n               if (flag & unknown)\n                  errorx = \"DISCARD: unknown chunk saved\";\n               break;\n            case PNG_HANDLE_CHUNK_IF_SAFE:\n               if (ancillary(chunk_info[i].name))\n               {\n                  if (!(flag & unknown))\n                     errorx = \"IF-SAFE: unknown ancillary chunk lost\";\n               }\n               else if (flag & unknown)\n                  errorx = \"IF-SAFE: unknown critical chunk saved\";\n               break;\n            case PNG_HANDLE_CHUNK_ALWAYS:\n               if (!(flag & unknown))\n                  errorx = \"SAVE: unknown chunk lost\";\n               break;\n            default:\n               errorx = \"internal error: bad keep\";\n               break;\n         }\n      } \n      else \n      {\n         type = \"KNOWN\";\n         if (flag & known)\n         {\n            \n\n\n            if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)\n               errorx = \"!DEFAULT: known chunk processed\";\n         }\n         else  switch (keep)\n         {\n            case PNG_HANDLE_CHUNK_AS_DEFAULT:\n               errorx = \"DEFAULT: known chunk not processed\";\n               break;\n            case PNG_HANDLE_CHUNK_NEVER:\n               if (flag & unknown)\n                  errorx = \"DISCARD: known chunk saved\";\n               break;\n            case PNG_HANDLE_CHUNK_IF_SAFE:\n               if (ancillary(chunk_info[i].name))\n               {\n                  if (!(flag & unknown))\n                     errorx = \"IF-SAFE: known ancillary chunk lost\";\n               }\n               else if (flag & unknown)\n                  errorx = \"IF-SAFE: known critical chunk saved\";\n               break;\n            case PNG_HANDLE_CHUNK_ALWAYS:\n               if (!(flag & unknown))\n                  errorx = \"SAVE: known chunk lost\";\n               break;\n            default:\n               errorx = \"internal error: bad keep (2)\";\n               break;\n         }\n      }\n      if (errorx != NULL)\n      {\n         ++(d->error_count);\n         fprintf(stderr, \"%s(%s%s): %s %s %s: %s\\n\", d->file, d->test,\n            set_callback ? \",callback\" : \"\",\n            type, chunk_info[i].name, position, errorx);\n      }\n      chunks &= ~flag;\n   }\n}\n", "bug_type": null, "idx": 94}
{"project": "LibPNG", "target": 0, "func": "static void\ninsert_zTXt(png_structp png_ptr, png_infop info_ptr, int nparams,\n   png_charpp params)\n{\n   png_text text;\n   check_param_count(nparams, 2);\n   clear_text(&text, params[0]);\n   text.compression = 0; \n   set_text(png_ptr, info_ptr, &text, params[1]);\n}\n", "bug_type": null, "idx": 95}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_rgb8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = pp[0];\n   p->g = pp[1];\n   p->b = pp[2];\n   p->a = 255;\n}\n", "bug_type": null, "idx": 96}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_reset(png_modifier *pm)\n{\n   store_read_reset(&pm->this);\n   pm->limit = 4E-3;\n   pm->pending_len = pm->pending_chunk = 0;\n   pm->flush = pm->buffer_count = pm->buffer_position = 0;\n   pm->modifications = NULL;\n   pm->state = modifier_start;\n   modifier_encoding_iterate(pm);\n   \n\n\n\n   pm->test_uses_encoding = 0;\n   pm->current_gamma = 0;\n   pm->current_encoding = 0;\n   pm->encoding_ignored = 0;\n   \n   pm->bit_depth = pm->colour_type = 0;\n}\n", "bug_type": null, "idx": 97}
{"project": "LibPNG", "target": 0, "func": "#endif \nstatic void rpng2_x_cleanup(void)\n{\n    if (bg_image && bg_data) {\n        free(bg_data);\n        bg_data = NULL;\n    }\n    if (rpng2_info.image_data) {\n        free(rpng2_info.image_data);\n        rpng2_info.image_data = NULL;\n    }\n    if (rpng2_info.row_pointers) {\n        free(rpng2_info.row_pointers);\n        rpng2_info.row_pointers = NULL;\n    }\n    if (ximage) {\n        if (ximage->data) {\n            free(ximage->data);           \n            ximage->data = (char *)NULL;  \n        }\n        XDestroyImage(ximage);\n        ximage = NULL;\n    }\n    if (have_gc)\n        XFreeGC(display, gc);\n    if (have_window)\n        XDestroyWindow(display, window);\n    if (have_colormap)\n        XFreeColormap(display, colormap);\n    if (have_nondefault_visual)\n        XFree(visual_list);\n}\n", "bug_type": null, "idx": 98}
{"project": "LibPNG", "target": 0, "func": "double\nfsRGB(double l)\n{\n   return sRGB_from_linear(l/max_input);\n}\n", "bug_type": null, "idx": 99}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_strip_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(colour_type)\n   this->next = *that;\n   *that = this;\n   return bit_depth > 8;\n}\n", "bug_type": null, "idx": 100}
{"project": "LibPNG", "target": 1, "func": " \npng_size_t \npng_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)\n{\n   png_size_t key_len;\n   png_charp kp, dp;\n   int kflag;\n   int kwarn=0;\n\n   png_debug(1, \"in png_check_keyword\\n\");\n   *new_key = NULL;\n\n   if (key == NULL || (key_len = png_strlen(key)) == 0)\n   {\n      png_warning(png_ptr, \"zero length keyword\");\n      return ((png_size_t)0);\n   }\n\n   png_debug1(2, \"Keyword to be checked is '%s'\\n\", key);\n\n   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));\n   if (*new_key == NULL)\n   {\n      png_warning(png_ptr, \"Out of memory while procesing keyword\");\n      return ((png_size_t)0);\n   }\n\n   \n   for (kp = key, dp = *new_key; *kp != '\\0'; kp++, dp++)\n   {\n      if ((png_byte)*kp < 0x20 ||\n         ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))\n      {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n         char msg[40];\n\n         png_snprintf(msg, 40,\n           \"invalid keyword character 0x%02X\", (png_byte)*kp);\n         png_warning(png_ptr, msg);\n#else\n         png_warning(png_ptr, \"invalid character in keyword\");\n#endif\n         *dp = ' ';\n      }\n      else\n      {\n         *dp = *kp;\n      }\n   }\n   *dp = '\\0';\n\n   \n   kp = *new_key + key_len - 1;\n   if (*kp == ' ')\n   {\n      png_warning(png_ptr, \"trailing spaces removed from keyword\");\n\n      while (*kp == ' ')\n      {\n        *(kp--) = '\\0';\n        key_len--;\n      }\n   }\n\n   \n   kp = *new_key;\n   if (*kp == ' ')\n   {\n      png_warning(png_ptr, \"leading spaces removed from keyword\");\n\n      while (*kp == ' ')\n      {\n        kp++;\n        key_len--;\n      }\n   }\n\n   png_debug1(2, \"Checking for multiple internal spaces in '%s'\\n\", kp);\n\n   \n   for (kflag = 0, dp = *new_key; *kp != '\\0'; kp++)\n   {\n      if (*kp == ' ' && kflag == 0)\n      {\n         *(dp++) = *kp;\n         kflag = 1;\n      }\n      else if (*kp == ' ')\n      {\n         key_len--;\n         kwarn=1;\n      }\n      else\n      {\n         *(dp++) = *kp;\n         kflag = 0;\n      }\n   }\n   *dp = '\\0';\n   if (kwarn)\n      png_warning(png_ptr, \"extra interior spaces removed from keyword\");\n\n   if (key_len == 0)\n   {\n      png_free(png_ptr, *new_key);\n       *new_key=NULL;\n      png_warning(png_ptr, \"Zero length keyword\");\n   }\n\n   if (key_len > 79)\n   {\n      png_warning(png_ptr, \"keyword length must be 1 - 79 characters\");\n      new_key[79] = '\\0';\n      key_len = 79;\n   }\n\n   return (key_len);\n}\n#endif", "bug_type": "cve-2008-5907", "idx": 101}
{"project": "LibPNG", "target": 0, "func": "static int\ncmppixel(Transform *transform, png_const_voidp in, png_const_voidp out,\n   png_uint_32 x, png_uint_32 y)\n{\n   int maxerr;\n   png_const_charp errmsg;\n   Pixel pixel_in, pixel_calc, pixel_out;\n   transform->in_gp(&pixel_in, in);\n   if (transform->from_linear == NULL)\n      transform->transform(&pixel_calc, &pixel_in, transform->background);\n   else\n   {\n      transform->transform(&pixel_out, &pixel_in, transform->background);\n      transform->from_linear(&pixel_calc, &pixel_out, NULL);\n   }\n   transform->out_gp(&pixel_out, out);\n   \n   if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r &&\n      pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b)\n      return 1;\n   \n\n\n\n   if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0)\n      return 1;\n   \n\n\n   errmsg = NULL;\n   {\n      int err_a = abs(pixel_calc.a-pixel_out.a);\n      if (err_a > transform->error[3])\n      {\n         \n         if (transform->accumulate)\n            transform->error[3] = (png_uint_16)err_a;\n         else\n            errmsg = \"alpha\";\n      }\n   }\n   \n\n\n   if (errmsg == NULL && transform->output_8bit &&\n      (pixel_calc.a == 0 || pixel_out.a == 0))\n      return 1;\n   if (errmsg == NULL) \n   {\n      int err_r = abs(pixel_calc.r - pixel_out.r);\n      int err_g = abs(pixel_calc.g - pixel_out.g);\n      int err_b = abs(pixel_calc.b - pixel_out.b);\n      int limit;\n      if ((err_r | err_g | err_b) == 0)\n         return 1; \n      \n      if (pixel_in.a >= transform->in_opaque)\n      {\n         errmsg = \"opaque component\";\n         limit = 2; \n      }\n      else if (pixel_in.a > 0)\n      {\n         errmsg = \"alpha component\";\n         limit = 1; \n      }\n      else\n      {\n         errmsg = \"transparent component (background)\";\n         limit = 0; \n      }\n      maxerr = err_r;\n      if (maxerr < err_g) maxerr = err_g;\n      if (maxerr < err_b) maxerr = err_b;\n      if (maxerr <= transform->error[limit])\n         return 1; \n      \n\n\n      if (transform->accumulate)\n      {\n         transform->error[limit] = (png_uint_16)maxerr;\n         return 1; \n      }\n   }\n   \n   return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);\n}\n", "bug_type": null, "idx": 102}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_memory_free(png_const_structp pp, store_pool *pool, store_memory *memory)\n{\n   \n\n\n\n   if (memory->pool != pool)\n      store_pool_error(pool->store, pp, \"memory corrupted (pool)\");\n   else if (memcmp(memory->mark, pool->mark, sizeof memory->mark) != 0)\n      store_pool_error(pool->store, pp, \"memory corrupted (start)\");\n   \n   else\n   {\n      png_alloc_size_t cb = memory->size;\n      if (cb > pool->max)\n         store_pool_error(pool->store, pp, \"memory corrupted (size)\");\n      else if (memcmp((png_bytep)(memory+1)+cb, pool->mark, sizeof pool->mark)\n         != 0)\n         store_pool_error(pool->store, pp, \"memory corrupted (end)\");\n      \n      else\n         {\n         pool->current -= cb;\n         free(memory);\n         }\n   }\n}\n", "bug_type": null, "idx": 103}
{"project": "LibPNG", "target": 0, "func": "static int format_set(format_list *pf, png_uint_32 format)\n{\n   if (format < FORMAT_COUNT)\n      return pf->bits[format >> 5] |= ((png_uint_32)1) << (format & 31);\n   return 0;\n}\n", "bug_type": null, "idx": 104}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_sGp(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->a <= 128)\n   {\n      out->r = out->g = out->b = 255;\n      out->a = 0;\n   }\n   else\n   {\n      out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/in->a);\n      out->a = u8d(in->a / 257.);\n   }\n}\n", "bug_type": null, "idx": 105}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\ncurrent_type(struct file *file, int code)\n   \n{\n   \n\n\n\n\n   if (file->chunk != NULL)\n   {\n      png_uint_32 type = file->chunk->chunk_type;\n      \n\n\n\n      if (code <= LIBPNG_ERROR_CODE && type == png_IDAT &&\n         file->write_count == 8)\n         type = 0; \n      return type;\n   }\n   else\n      return file->type;\n}\n", "bug_type": null, "idx": 106}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\npng_pass_start_col(int pass)\n{\n   int x, y;\n   ++pass;\n   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)\n      return x;\n   return 0xf;\n}\n", "bug_type": null, "idx": 107}
{"project": "LibPNG", "target": 0, "func": "static int\nread_one_file(Image *image)\n{\n   if (!(image->opts & READ_FILE) || (image->opts & USE_STDIO))\n   {\n      \n      FILE *f = fopen(image->file_name, \"rb\");\n      if (f != NULL)\n      {\n         if (image->opts & READ_FILE)\n            image->input_file = f;\n         else \n         {\n            if (fseek(f, 0, SEEK_END) == 0)\n            {\n               long int cb = ftell(f);\n               if (cb > 0 && (unsigned long int)cb < (size_t)~(size_t)0)\n               {\n                  png_bytep b = voidcast(png_bytep, malloc((size_t)cb));\n                  if (b != NULL)\n                  {\n                     rewind(f);\n                     if (fread(b, (size_t)cb, 1, f) == 1)\n                     {\n                        fclose(f);\n                        image->input_memory_size = cb;\n                        image->input_memory = b;\n                     }\n                     else\n                     {\n                        free(b);\n                        return logclose(image, f, image->file_name,\n                           \": read failed: \");\n                     }\n                  }\n                  else\n                     return logclose(image, f, image->file_name,\n                        \": out of memory: \");\n               }\n               else if (cb == 0)\n                  return logclose(image, f, image->file_name,\n                     \": zero length: \");\n               else\n                  return logclose(image, f, image->file_name,\n                     \": tell failed: \");\n            }\n            else\n               return logclose(image, f, image->file_name, \": seek failed: \");\n         }\n      }\n      else\n         return logerror(image, image->file_name, \": open failed: \",\n            strerror(errno));\n   }\n   return read_file(image, FORMAT_NO_CHANGE, NULL);\n}\n", "bug_type": null, "idx": 108}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_size(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo,\n    int PNG_CONST bdhi)\n{\n   for (; bdlo <= bdhi; ++bdlo)\n   {\n      png_uint_32 width;\n      for (width = 1; width <= 16; ++width)\n      {\n         png_uint_32 height;\n         for (height = 1; height <= 16; ++height)\n         {\n            \n\n\n\n            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,\n               width, height, 0);\n            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,\n               width, height, 1);\n#        ifdef PNG_WRITE_INTERLACING_SUPPORTED\n            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,\n               width, height, 0);\n            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,\n               width, height, 1);\n#        endif\n         }\n      }\n   }\n}\n", "bug_type": null, "idx": 109}
{"project": "LibPNG", "target": 0, "func": "static int\nmodifier_color_encoding_is_set(PNG_CONST png_modifier *pm)\n{\n   return pm->current_gamma != 0;\n}\n", "bug_type": null, "idx": 110}
{"project": "LibPNG", "target": 1, "func": "\nstatic void \npng_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp\n    error_message)\n{\n   int iout = 0, iin = 0;\n\n   while (iin < 4)\n   {\n      int c = png_ptr->chunk_name[iin++];\n      if (isnonalpha(c))\n      {\n         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;\n         buffer[iout++] = png_digit[(c & 0xf0) >> 4];\n         buffer[iout++] = png_digit[c & 0x0f];\n         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;\n      }\n\n      else\n      {\n         buffer[iout++] = (png_byte)c;\n      }\n   }\n\n   if (error_message == NULL)\n      buffer[iout] = '\\0';\n\n   else\n   {\n      buffer[iout++] = ':';\n      buffer[iout++] = ' ';\n      png_memcpy(buffer + iout, error_message, PNG_MAX_ERROR_TEXT);\n      buffer[iout + PNG_MAX_ERROR_TEXT - 1] = '\\0';\n   }\n}\n#endif \n", "bug_type": "cve-2011-2501", "idx": 111}
{"project": "LibPNG", "target": 0, "func": "double\nfinvsRGB(unsigned int i)\n{\n   return 65535 * linear_from_sRGB(i/255.);\n}\npng_uint_16\ninvsRGB(unsigned int i)\n{\n   unsigned int x = nearbyint(finvsRGB(i));\n   if (x > 65535)\n   {\n      fprintf(stderr, \"invsRGB(%u) overflows to %u\\n\", i, x);\n      exit(1);\n   }\n   return (png_uint_16)x;\n}\n", "bug_type": null, "idx": 112}
{"project": "LibPNG", "target": 0, "func": " */\npng_uint_32 get_data (FILE *pnm_file, int depth)\n{\n  static int bits_left = 0;\n  static int old_value = 0;\n  static int mask = 0;\n  int i;\n  png_uint_32 ret_value;\n  if (mask == 0)\n    for (i = 0; i < depth; i++)\n      mask = (mask >> 1) | 0x80;\n  if (bits_left <= 0)\n  {\n    old_value = fgetc (pnm_file);\n    bits_left = 8;\n  }\n  ret_value = old_value & mask;\n  for (i = 1; i < (8 / depth); i++)\n    ret_value = ret_value || (ret_value >> depth);\n  old_value = (old_value << depth) & 0xFF;\n  bits_left -= depth;\n  return ret_value;\n}\n", "bug_type": null, "idx": 113}
{"project": "LibPNG", "target": 0, "func": "   const char *tests);\nstatic int check_one_character(checkfp_command *co, checkfp_control c, int ch)\n{\n   \n\n   png_size_t index = 0;\n   const char test = (char)ch;\n   const int number_is_valid = png_check_fp_number(&test, 1, &c.state, &index);\n   const int character_accepted = (index == 1);\n   if (c.check_state != exponent && isdigit(ch) && ch != '0')\n      c.is_zero = 0;\n   if (c.check_state == start && c.at_start && ch == '-')\n      c.is_negative = 1;\n   if (isprint(ch))\n      co->number[c.cnumber++] = (char)ch;\n   else\n   {\n      co->number[c.cnumber++] = '<';\n      co->number[c.cnumber++] = hexdigits[(ch >> 4) & 0xf];\n      co->number[c.cnumber++] = hexdigits[ch & 0xf];\n      co->number[c.cnumber++] = '>';\n   }\n   co->number[c.cnumber] = 0;\n   if (co->verbose > 1)\n      fprintf(stderr, \"%s\\n\", co->number);\n   if (++(co->ctimes) == 1000000)\n   {\n      if (co->verbose == 1)\n         fputc('.', stderr);\n      co->ctimes = 0;\n      ++(co->cmillions);\n   }\n   if (!number_is_valid)\n      ++(co->cinvalid);\n   if (!character_accepted)\n      ++(co->cnoaccept);\n   \n   if (index != 0 && index != 1)\n   {\n      fprintf(stderr, \"%s: read beyond end of string (%lu)\\n\", co->number,\n         (unsigned long)index);\n      return 0;\n   }\n   \n\n\n   if (PNG_FP_IS_NEGATIVE(c.state) !=\n      (number_is_valid && !c.is_zero && c.is_negative))\n   {\n      fprintf(stderr, \"%s: negative when it is not\\n\", co->number);\n      return 0;\n   }\n   if (PNG_FP_IS_ZERO(c.state) != (number_is_valid && c.is_zero))\n   {\n      fprintf(stderr, \"%s: zero when it is not\\n\", co->number);\n      return 0;\n   }\n   if (PNG_FP_IS_POSITIVE(c.state) !=\n      (number_is_valid && !c.is_zero && !c.is_negative))\n   {\n      fprintf(stderr, \"%s: positive when it is not\\n\", co->number);\n      return 0;\n   }\n   \n   if (isdigit(ch))\n   {\n      if (!character_accepted)\n      {\n         fprintf(stderr, \"%s: digit '%c' not accepted\\n\", co->number, ch);\n         return 0;\n      }\n      if (!number_is_valid)\n      {\n         fprintf(stderr, \"%s: saw a digit (%c) but number not valid\\n\",\n            co->number, ch);\n         return 0;\n      }\n      ++c.cdigits_in_state;\n      c.at_start = 0;\n      c.number_was_valid = 1;\n      \n\n\n\n      if (c.cdigits_in_state < 1)\n         return check_all_characters(co, c);\n      else\n         return check_some_characters(co, c,\n            state_characters[c.check_state].tests);\n   }\n   \n   else if (((ch == '+' || ch == '-') && c.check_state != fraction &&\n               c.at_start) ||\n            (ch == '.' && c.check_state == start) ||\n            ((ch == 'e' || ch == 'E') && c.number_was_valid &&\n               c.check_state != exponent))\n   {\n      if (!character_accepted)\n      {\n         fprintf(stderr, \"%s: character '%c' not accepted\\n\", co->number, ch);\n         return 0;\n      }\n      \n      if (number_is_valid && (c.check_state != start || ch != '.'))\n      {\n         fprintf(stderr, \"%s: saw a non-digit (%c) but number valid\\n\",\n            co->number, ch);\n         return 0;\n      }\n      c.number_was_valid = number_is_valid;\n      \n\n\n\n      if (c.check_state == start && ch == '.')\n      {\n         c.check_state = fraction;\n         c.at_start = !number_is_valid;\n         c.cdigits_in_state = 0;\n         c.limit = co->limit;\n         return check_all_characters(co, c);\n      }\n      else if (c.check_state < exponent && (ch == 'e' || ch == 'E'))\n      {\n         c.check_state = exponent;\n         c.at_start = 1;\n         c.cdigits_in_state = 0;\n         c.limit = co->limit;\n         return check_all_characters(co, c);\n      }\n      \n      else\n      {\n         if (ch != '-' && ch != '+')\n         {\n            fprintf(stderr, \"checkfp: internal error (1)\\n\");\n            return 0;\n         }\n         c.at_start = 0;\n         return check_all_characters(co, c);\n      }\n   }\n   \n   else\n   {\n      if (character_accepted)\n      {\n         fprintf(stderr, \"%s: character '%c' [0x%.2x] accepted\\n\", co->number,\n            ch, ch);\n         return 0;\n      }\n      if (number_is_valid != c.number_was_valid)\n      {\n         fprintf(stderr,\n            \"%s: character '%c' [0x%.2x] changed number validity\\n\", co->number,\n            ch, ch);\n         return 0;\n      }\n      \n\n\n   }\n   \n   return 1;\n}\n", "bug_type": null, "idx": 114}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_argb8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = pp[1];\n   p->g = pp[2];\n   p->b = pp[3];\n   p->a = pp[0];\n}\n", "bug_type": null, "idx": 115}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_bgr16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = pp[2];\n   p->g = pp[1];\n   p->b = pp[0];\n   p->a = 65535;\n}\n", "bug_type": null, "idx": 116}
{"project": "LibPNG", "target": 0, "func": "static int\nread_file(Image *image, png_uint_32 format, png_const_colorp background)\n{\n   memset(&image->image, 0, sizeof image->image);\n   image->image.version = PNG_IMAGE_VERSION;\n   if (image->input_memory != NULL)\n   {\n      if (!png_image_begin_read_from_memory(&image->image, image->input_memory,\n         image->input_memory_size))\n         return logerror(image, \"memory init: \", image->file_name, \"\");\n   }\n#  ifdef PNG_STDIO_SUPPORTED\n      else if (image->input_file != NULL)\n      {\n         if (!png_image_begin_read_from_stdio(&image->image, image->input_file))\n            return logerror(image, \"stdio init: \", image->file_name, \"\");\n      }\n      else\n      {\n         if (!png_image_begin_read_from_file(&image->image, image->file_name))\n            return logerror(image, \"file init: \", image->file_name, \"\");\n      }\n#  else\n      else\n      {\n         return logerror(image, \"unsupported file/stdio init: \",\n            image->file_name, \"\");\n      }\n#  endif\n   \n   if (image->opts & sRGB_16BIT)\n      image->image.flags |= PNG_IMAGE_FLAG_16BIT_sRGB;\n   \n\n\n   {\n      int result;\n      png_uint_32 image_format;\n      \n      image_format = image->image.format;\n      if (image->opts & VERBOSE)\n      {\n         printf(\"%s %lu x %lu %s -> %s\", image->file_name,\n            (unsigned long)image->image.width,\n            (unsigned long)image->image.height,\n            format_names[image_format & FORMAT_MASK],\n            (format & FORMAT_NO_CHANGE) != 0 || image->image.format == format\n            ? \"no change\" : format_names[format & FORMAT_MASK]);\n         if (background != NULL)\n            printf(\" background(%d,%d,%d)\\n\", background->red,\n               background->green, background->blue);\n         else\n            printf(\"\\n\");\n         fflush(stdout);\n      }\n      \n\n\n\n      if ((format & FORMAT_NO_CHANGE) != 0)\n      {\n         if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&\n            (image_format & PNG_FORMAT_FLAG_COLORMAP) != 0)\n            format = (image_format & ~BASE_FORMATS) | (format & BASE_FORMATS);\n         else\n            format = image_format;\n      }\n      image->image.format = format;\n      image->stride = PNG_IMAGE_ROW_STRIDE(image->image) + image->stride_extra;\n      allocbuffer(image);\n      result = png_image_finish_read(&image->image, background,\n         image->buffer+16, (png_int_32)image->stride, image->colormap);\n      checkbuffer(image, image->file_name);\n      if (result)\n         return checkopaque(image);\n      else\n         return logerror(image, image->file_name, \": image read failed\", \"\");\n   }\n}\n", "bug_type": null, "idx": 117}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_bgra16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = pp[2];\n   p->g = pp[1];\n   p->b = pp[0];\n   p->a = pp[3];\n}\n", "bug_type": null, "idx": 118}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_strip_16_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_strip_16(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 119}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nstandard_info(png_structp pp, png_infop pi)\n{\n   standard_display *dp = voidcast(standard_display*,\n      png_get_progressive_ptr(pp));\n   \n\n\n   standard_info_imp(dp, pp, pi, 1 );\n}\n", "bug_type": null, "idx": 120}
{"project": "LibPNG", "target": 0, "func": "static int\ntestimage(Image *image, png_uint_32 opts, format_list *pf)\n{\n   int result;\n   Image copy;\n   \n   checkopaque(image);\n   copy = *image;\n   copy.opts = opts;\n   copy.buffer = NULL;\n   copy.bufsize = 0;\n   copy.allocsize = 0;\n   image->input_file = NULL;\n   image->input_memory = NULL;\n   image->input_memory_size = 0;\n   image->tmpfile_name[0] = 0;\n   {\n      png_uint_32 counter;\n      Image output;\n      newimage(&output);\n      result = 1;\n      \n\n\n\n      for (counter=0; counter<2*FORMAT_COUNT; ++counter)\n         if (format_isset(pf, counter >> 1))\n      {\n         png_uint_32 format = counter >> 1;\n         png_color background_color;\n         png_colorp background = NULL;\n         \n\n\n\n\n\n         if ((counter & 1) == 0)\n         {\n            if ((format & PNG_FORMAT_FLAG_ALPHA) == 0 &&\n               (image->image.format & PNG_FORMAT_FLAG_ALPHA) != 0)\n            {\n               \n\n\n               random_color(&background_color);\n               background = &background_color;\n               \n\n\n\n               if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&\n                  (format & PNG_FORMAT_FLAG_LINEAR) == 0)\n                  ++counter;\n            }\n            \n\n\n            else\n               ++counter;\n         }\n         \n         resetimage(&copy);\n         copy.opts = opts; \n         result = read_file(&copy, format, background);\n         if (!result)\n            break;\n         \n         result = compare_two_images(image, &copy, 0, background);\n         if (!result)\n            break;\n#        ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED\n            \n\n\n\n            output.opts = opts;\n            result = write_one_file(&output, &copy, 0);\n            if (!result)\n               break;\n            \n\n\n            result = compare_two_images(image, &output, 0, background);\n            if (!result)\n               break;\n            if ((format & PNG_FORMAT_FLAG_LINEAR) != 0 &&\n               (format & PNG_FORMAT_FLAG_COLORMAP) == 0)\n            {\n               \n\n               output.opts = opts;\n               result = write_one_file(&output, &copy, 1);\n               if (!result)\n                  break;\n               \n\n\n\n\n\n\n\n\n               result = compare_two_images(image, &output, 1,\n                  background);\n               if (!result)\n                  break;\n            }\n#        endif \n      }\n      freeimage(&output);\n   }\n   freeimage(&copy);\n   return result;\n}\n", "bug_type": null, "idx": 121}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\npng_row_from_pass_row(png_uint_32 yIn, int pass)\n{\n   \n   switch (pass)\n   {\ncase 0: return yIn * 8;\ncase 1: return yIn * 8;\ncase 2: return yIn * 8 + 4;\ncase 3: return yIn * 4;\ncase 4: return yIn * 4 + 2;\ncase 5: return yIn * 2;\ncase 6: return yIn * 2 + 1;\ndefault: break;\n   }\n   return 0xff; \n}\n", "bug_type": null, "idx": 122}
{"project": "LibPNG", "target": 0, "func": "static void\nbuffer_start_read(struct buffer *buffer)\n{\n   buffer->current = &buffer->first;\n   buffer->read_count = 0;\n}\n", "bug_type": null, "idx": 123}
{"project": "LibPNG", "target": 0, "func": "int readpng2_check_sig(uch *sig, int num)\n{\n    return !png_sig_cmp(sig, 0, num);\n}\n", "bug_type": null, "idx": 124}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   \n\n\n\n\n   if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n   \n   if (that->colour_type == PNG_COLOR_TYPE_GRAY)\n   {\n      \n      if (that->bit_depth < 8)\n         that->sample_depth = that->bit_depth = 8;\n      \n\n\n      that->colour_type = PNG_COLOR_TYPE_RGB;\n   }\n   else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 125}
{"project": "LibPNG", "target": 0, "func": "static int\nfindb(const png_byte *name)\n{\n   int i = NINFO;\n   while (--i >= 0)\n   {\n      if (memcmp(chunk_info[i].name, name, 4) == 0)\n         break;\n   }\n   return i;\n}\n", "bug_type": null, "idx": 126}
{"project": "LibPNG", "target": 0, "func": "static void perform_gamma_transform_tests(png_modifier *pm)\n{\n   png_byte colour_type = 0;\n   png_byte bit_depth = 0;\n   unsigned int palette_number = 0;\n   while (next_format(&colour_type, &bit_depth, &palette_number, 1))\n   {\n      unsigned int i, j;\n      for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)\n         if (i != j)\n         {\n            gamma_transform_test(pm, colour_type, bit_depth, palette_number,\n               pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], 0,\n               pm->use_input_precision, 0 );\n            if (fail(pm))\n               return;\n         }\n   }\n}\n", "bug_type": null, "idx": 127}
{"project": "LibPNG", "target": 1, "func": "\nvoid PNGAPI\npng_set_unknown_chunks(png_structp png_ptr,\n   png_infop info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)\n{\n   png_unknown_chunkp np;\n   int i;\n\n   if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)\n      return;\n\n   np = (png_unknown_chunkp)png_malloc_warn(png_ptr,\n       (png_size_t)(info_ptr->unknown_chunks_num + num_unknowns) *\n       png_sizeof(png_unknown_chunk));\n\n   if (np == NULL)\n   {\n      png_warning(png_ptr,\n          \"Out of memory while processing unknown chunk\");\n      return;\n   }\n\n   png_memcpy(np, info_ptr->unknown_chunks,\n       (png_size_t)info_ptr->unknown_chunks_num *\n       png_sizeof(png_unknown_chunk));\n\n   png_free(png_ptr, info_ptr->unknown_chunks);\n   info_ptr->unknown_chunks = NULL;\n\n   for (i = 0; i < num_unknowns; i++)\n   {\n      png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;\n      png_const_unknown_chunkp from = unknowns + i;\n\n      png_memcpy(to->name, from->name, png_sizeof(from->name));\n      to->name[png_sizeof(to->name)-1] = '\\0';\n      to->size = from->size;\n\n      \n      to->location = (png_byte)(png_ptr->mode & 0xff);\n\n      if (from->size == 0)\n         to->data=NULL;\n\n      else\n      {\n         to->data = (png_bytep)png_malloc_warn(png_ptr,\n             (png_size_t)from->size);\n\n         if (to->data == NULL)\n         {\n            png_warning(png_ptr,\n                \"Out of memory while processing unknown chunk\");\n            to->size = 0;\n         }\n\n         else\n            png_memcpy(to->data, from->data, from->size);\n      }\n   }\n\n   info_ptr->unknown_chunks = np;\n   info_ptr->unknown_chunks_num += num_unknowns;\n   info_ptr->free_me |= PNG_FREE_UNKN;\n}", "bug_type": "cve-2013-7353", "idx": 128}
{"project": "LibPNG", "target": 0, "func": "BOOL PngFileOpenDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName)\n{\n    ofn.hwndOwner         = hwnd;\n    ofn.lpstrFile         = pstrFileName;\n    ofn.lpstrFileTitle    = pstrTitleName;\n    ofn.Flags             = OFN_HIDEREADONLY;\n    return GetOpenFileName (&ofn);\n}\n", "bug_type": null, "idx": 129}
{"project": "LibPNG", "target": 0, "func": "static void\ninit_standard_palette(png_store *ps, png_structp pp, png_infop pi, int npalette,\n   int do_tRNS)\n{\n   store_palette_entry *ppal = make_standard_palette(ps, npalette, do_tRNS);\n   {\n      int i;\n      png_color palette[256];\n      \n      for (i=0; i<npalette; ++i)\n      {\n         palette[i].red = ppal[i].red;\n         palette[i].green = ppal[i].green;\n         palette[i].blue = ppal[i].blue;\n      }\n      \n      for (; i<256; ++i)\n         palette[i].red = palette[i].green = palette[i].blue = 42;\n      png_set_PLTE(pp, pi, palette, npalette);\n   }\n   if (do_tRNS)\n   {\n      int i, j;\n      png_byte tRNS[256];\n      \n      for (i=j=0; i<npalette; ++i)\n         if ((tRNS[i] = ppal[i].alpha) < 255)\n            j = i+1;\n      \n      for (; i<256; ++i)\n         tRNS[i] = 24;\n#  ifdef PNG_WRITE_tRNS_SUPPORTED\n         if (j > 0)\n            png_set_tRNS(pp, pi, tRNS, j, 0);\n#  endif\n   }\n}\n", "bug_type": null, "idx": 130}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_storefile(png_store *ps, png_uint_32 id)\n{\n   png_store_file *pf = voidcast(png_store_file*, malloc(sizeof *pf));\n   if (pf == NULL)\n      png_error(ps->pwrite, \"storefile: OOM\");\n   safecat(pf->name, sizeof pf->name, 0, ps->wname);\n   pf->id = id;\n   pf->data = ps->new;\n   pf->datacount = ps->writepos;\n   ps->new.prev = NULL;\n   ps->writepos = 0;\n   pf->palette = ps->palette;\n   pf->npalette = ps->npalette;\n   ps->palette = 0;\n   ps->npalette = 0;\n   \n   pf->next = ps->saved;\n   ps->saved = pf;\n}\n", "bug_type": null, "idx": 131}
{"project": "LibPNG", "target": 0, "func": "static void\nIDAT_list_end(struct IDAT_list *IDAT_list)\n{\n   struct IDAT_list *list = IDAT_list->next;\n   CLEAR(*IDAT_list);\n   while (list != NULL)\n   {\n      struct IDAT_list *next = list->next;\n      clear(list, IDAT_list_size(list, 0));\n      free(list);\n      list = next;\n   }\n}\n", "bug_type": null, "idx": 132}
{"project": "LibPNG", "target": 0, "func": "static void\nprint_pixel(png_structp png_ptr, png_infop info_ptr, png_const_bytep row,\n   png_uint_32 x)\n{\n   PNG_CONST unsigned int bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n   switch (png_get_color_type(png_ptr, info_ptr))\n   {\n      case PNG_COLOR_TYPE_GRAY:\n         printf(\"GRAY %u\\n\", component(row, x, 0, bit_depth, 1));\n         return;\n      \n\n\n\n      case PNG_COLOR_TYPE_PALETTE:\n         {\n            PNG_CONST unsigned int index = component(row, x, 0, bit_depth, 1);\n            png_colorp palette = NULL;\n            int num_palette = 0;\n            if ((png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette) &\n               PNG_INFO_PLTE) && num_palette > 0 && palette != NULL)\n            {\n               png_bytep trans_alpha = NULL;\n               int num_trans = 0;\n               if ((png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans,\n                  NULL) & PNG_INFO_tRNS) && num_trans > 0 &&\n                  trans_alpha != NULL)\n                  printf(\"INDEXED %u = %d %d %d %d\\n\", index,\n                     palette[index].red, palette[index].green,\n                     palette[index].blue,\n                     index < num_trans ? trans_alpha[index] : 255);\n               else \n                  printf(\"INDEXED %u = %d %d %d\\n\", index,\n                     palette[index].red, palette[index].green,\n                     palette[index].blue);\n            }\n            else\n               printf(\"INDEXED %u = invalid index\\n\", index);\n         }\n         return;\n      case PNG_COLOR_TYPE_RGB:\n         printf(\"RGB %u %u %u\\n\", component(row, x, 0, bit_depth, 3),\n            component(row, x, 1, bit_depth, 3),\n            component(row, x, 2, bit_depth, 3));\n         return;\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         printf(\"GRAY+ALPHA %u %u\\n\", component(row, x, 0, bit_depth, 2),\n            component(row, x, 1, bit_depth, 2));\n         return;\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         printf(\"RGBA %u %u %u %u\\n\", component(row, x, 0, bit_depth, 4),\n            component(row, x, 1, bit_depth, 4),\n            component(row, x, 2, bit_depth, 4),\n            component(row, x, 3, bit_depth, 4));\n         return;\n      default:\n         png_error(png_ptr, \"invalid color type\");\n   }\n}\n", "bug_type": null, "idx": 133}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nread_function(png_structp pp, png_bytep data, png_size_t size)\n{\n   buffer_read(get_dp(pp), get_buffer(pp), data, size);\n}\n", "bug_type": null, "idx": 134}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\nget_unknown(display *d, png_infop info_ptr, int after_IDAT)\n{\n   \n   png_uint_32 flags = 0;\n   UNUSED(after_IDAT)\n   {\n      png_unknown_chunkp unknown;\n      int num_unknown = png_get_unknown_chunks(d->png_ptr, info_ptr, &unknown);\n      while (--num_unknown >= 0)\n      {\n         int chunk = findb(unknown[num_unknown].name);\n         \n\n\n\n         if (chunk < 0) switch (d->keep)\n         {\n            default: \n            case PNG_HANDLE_CHUNK_AS_DEFAULT:\n            case PNG_HANDLE_CHUNK_NEVER:\n               fprintf(stderr, \"%s(%s): %s: %s: unknown chunk saved\\n\",\n                  d->file, d->test, d->keep ? \"discard\" : \"default\",\n                  unknown[num_unknown].name);\n               ++(d->error_count);\n               break;\n            case PNG_HANDLE_CHUNK_IF_SAFE:\n               if (!ancillaryb(unknown[num_unknown].name))\n               {\n                  fprintf(stderr,\n                     \"%s(%s): if-safe: %s: unknown critical chunk saved\\n\",\n                     d->file, d->test, unknown[num_unknown].name);\n                  ++(d->error_count);\n                  break;\n               }\n               \n            case PNG_HANDLE_CHUNK_ALWAYS:\n               break;\n         }\n         else\n            flags |= chunk_info[chunk].flag;\n      }\n   }\n   return flags;\n}\n", "bug_type": null, "idx": 135}
{"project": "LibPNG", "target": 0, "func": "static png_fixed_point\nfix(double d)\n{\n   d = floor(d * PNG_FP_1 + .5);\n   return (png_fixed_point)d;\n}\n", "bug_type": null, "idx": 136}
{"project": "LibPNG", "target": 0, "func": "void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)\n{\n   void *near_ptr;\n   void FAR *far_ptr;\n   FP_OFF(near_ptr) = FP_OFF(ptr);\n   far_ptr = (void FAR *)near_ptr;\n   if (check != 0)\n      if (FP_SEG(ptr) != FP_SEG(far_ptr))\n         png_error(png_ptr, \"segment lost in conversion\");\n   return(near_ptr);\n}\n}\nvoid *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)\n{\n   void *near_ptr;\n   void FAR *far_ptr;\n   near_ptr = (void FAR *)ptr;\n   far_ptr = (void FAR *)near_ptr;\n   if (check != 0)\n      if (far_ptr != ptr)\n         png_error(png_ptr, \"segment lost in conversion\");\n   return(near_ptr);\n}\n", "bug_type": null, "idx": 137}
{"project": "LibPNG", "target": 0, "func": "static double\ngamma_component_validate(PNG_CONST char *name, PNG_CONST validate_info *vi,\n    PNG_CONST unsigned int id, PNG_CONST unsigned int od,\n    PNG_CONST double alpha ,\n    PNG_CONST double background )\n{\n   PNG_CONST unsigned int isbit = id >> vi->isbit_shift;\n   PNG_CONST unsigned int sbit_max = vi->sbit_max;\n   PNG_CONST unsigned int outmax = vi->outmax;\n   PNG_CONST int do_background = vi->do_background;\n   double i;\n   \n\n\n\n   i = isbit; i /= sbit_max;\n   \n\n\n\n   if (alpha == 1  || !do_background\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n      || do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_PNG\n#endif\n      || (alpha < 0 \n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n      && do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN\n#endif\n      ))\n   {\n      \n\n\n\n\n      double encoded_sample = i;\n      double encoded_error;\n      \n\n      if (alpha >= 0 && vi->gamma_correction > 0)\n         encoded_sample = pow(encoded_sample, vi->gamma_correction);\n      encoded_sample *= outmax;\n      encoded_error = fabs(od-encoded_sample);\n      if (encoded_error > vi->dp->maxerrout)\n         vi->dp->maxerrout = encoded_error;\n      if (encoded_error < vi->maxout_total && encoded_error < vi->outlog)\n         return i;\n   }\n   \n   \n\n\n\n\n\n\n   {\n      double input_sample = i; \n      double output, error, encoded_sample, encoded_error;\n      double es_lo, es_hi;\n      int compose = 0;           \n      int output_is_encoded;     \n      int log_max_error = 1;     \n      png_const_charp pass = 0;  \n      \n\n\n      if (alpha >= 0)\n      {\n         int tcompose;\n         if (vi->file_inverse > 0)\n            input_sample = pow(input_sample, vi->file_inverse);\n         \n         tcompose = 0;\n         input_sample = gamma_component_compose(do_background, input_sample,\n            alpha, background, &tcompose);\n         if (tcompose)\n            compose = 1;\n      }\n      \n\n\n      output = od;\n      output /= outmax;\n      output_is_encoded = vi->screen_gamma > 0;\n      if (alpha < 0) \n      {\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n         if (do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN)\n#endif\n         {\n            \n\n\n            output_is_encoded = 0;\n            log_max_error = 0;\n         }\n      }\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n      else \n      {\n         if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&\n            alpha < 1) \n         {\n            if (alpha > 0) log_max_error = 0;\n            output_is_encoded = 0;\n         }\n      }\n#endif\n      if (output_is_encoded)\n         output = pow(output, vi->screen_gamma);\n      \n\n\n      encoded_sample = input_sample;\n      if (output_is_encoded)\n         encoded_sample = pow(encoded_sample, vi->screen_inverse);\n      encoded_sample *= outmax;\n      encoded_error = fabs(od-encoded_sample);\n      \n\n\n      if (log_max_error && encoded_error > vi->dp->maxerrout)\n         vi->dp->maxerrout = encoded_error;\n      if (encoded_error < vi->maxout_total)\n      {\n         if (encoded_error < vi->outlog)\n            return i;\n         \n\n\n         pass = \"less than maxout:\\n\";\n      }\n      \n\n\n\n\n\n\n\n\n\n      \n\n\n      error = fabs(input_sample-output);\n      if (log_max_error && error > vi->dp->maxerrabs)\n         vi->dp->maxerrabs = error;\n      \n\n\n      if (log_max_error && input_sample > .5)\n      {\n         double percentage_error = error/input_sample;\n         if (percentage_error > vi->dp->maxerrpc)\n            vi->dp->maxerrpc = percentage_error;\n      }\n      \n\n\n\n\n\n      {\n         double tmp = input_sample * vi->maxpc;\n         if (tmp < vi->maxabs) tmp = vi->maxabs;\n         \n\n\n\n\n\n         if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc;\n         \n\n\n         es_lo = encoded_sample - vi->maxout;\n         if (es_lo > 0 && input_sample-tmp > 0)\n         {\n            double low_value = input_sample-tmp;\n            if (output_is_encoded)\n               low_value = pow(low_value, vi->screen_inverse);\n            low_value *= outmax;\n            if (low_value < es_lo) es_lo = low_value;\n            \n            es_lo = ceil(es_lo / vi->outquant - .5) * vi->outquant;\n         }\n         else\n            es_lo = 0;\n         es_hi = encoded_sample + vi->maxout;\n         if (es_hi < outmax && input_sample+tmp < 1)\n         {\n            double high_value = input_sample+tmp;\n            if (output_is_encoded)\n               high_value = pow(high_value, vi->screen_inverse);\n            high_value *= outmax;\n            if (high_value > es_hi) es_hi = high_value;\n            es_hi = floor(es_hi / vi->outquant + .5) * vi->outquant;\n         }\n         else\n            es_hi = outmax;\n      }\n      \n\n\n\n      if (od >= es_lo && od <= es_hi)\n      {\n         \n         if (encoded_error < vi->outlog)\n            return i;\n         if (pass == 0)\n            pass = \"within digitization limits:\\n\";\n      }\n      {\n         \n\n\n         double is_lo, is_hi;\n         \n\n\n\n         if (pass == 0 && vi->use_input_precision && vi->dp->sbit)\n         {\n            \n\n\n\n\n\n\n\n\n\n\n#           if PNG_LIBPNG_VER < 10700\n#              define SBIT_ERROR .5\n#           else\n#              define SBIT_ERROR 1.\n#           endif\n            double tmp = (isbit - SBIT_ERROR)/sbit_max;\n            if (tmp <= 0)\n               tmp = 0;\n            else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)\n               tmp = pow(tmp, vi->file_inverse);\n            tmp = gamma_component_compose(do_background, tmp, alpha, background,\n               NULL);\n            if (output_is_encoded && tmp > 0 && tmp < 1)\n               tmp = pow(tmp, vi->screen_inverse);\n            is_lo = ceil(outmax * tmp - vi->maxout_total);\n            if (is_lo < 0)\n               is_lo = 0;\n            tmp = (isbit + SBIT_ERROR)/sbit_max;\n            if (tmp >= 1)\n               tmp = 1;\n            else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)\n               tmp = pow(tmp, vi->file_inverse);\n            tmp = gamma_component_compose(do_background, tmp, alpha, background,\n               NULL);\n            if (output_is_encoded && tmp > 0 && tmp < 1)\n               tmp = pow(tmp, vi->screen_inverse);\n            is_hi = floor(outmax * tmp + vi->maxout_total);\n            if (is_hi > outmax)\n               is_hi = outmax;\n            if (!(od < is_lo || od > is_hi))\n            {\n               if (encoded_error < vi->outlog)\n                  return i;\n               pass = \"within input precision limits:\\n\";\n            }\n            \n\n\n\n\n\n\n\n#           ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED\n#              if PNG_LIBPNG_VER < 10504\n                  \n\n\n\n\n\n                  if (pass == 0 && alpha < 0 && vi->scale16 && vi->sbit > 8 &&\n                     vi->sbit + vi->isbit_shift == 16)\n                  {\n                     tmp = ((id >> 8) - .5)/255;\n                     if (tmp > 0)\n                     {\n                        is_lo = ceil(outmax * tmp - vi->maxout_total);\n                        if (is_lo < 0) is_lo = 0;\n                     }\n                     else\n                        is_lo = 0;\n                     tmp = ((id >> 8) + .5)/255;\n                     if (tmp < 1)\n                     {\n                        is_hi = floor(outmax * tmp + vi->maxout_total);\n                        if (is_hi > outmax) is_hi = outmax;\n                     }\n                     else\n                        is_hi = outmax;\n                     if (!(od < is_lo || od > is_hi))\n                     {\n                        if (encoded_error < vi->outlog)\n                           return i;\n                        pass = \"within 8 bit limits:\\n\";\n                     }\n                  }\n#              endif\n#           endif\n         }\n         else \n            is_lo = es_lo, is_hi = es_hi;\n         \n\n\n\n         {\n            size_t pos = 0;\n            \n\n\n            int precision = (outmax >= 1000 ? 6 : 3);\n            int use_input=1, use_background=0, do_compose=0;\n            char msg[256];\n            if (pass != 0)\n               pos = safecat(msg, sizeof msg, pos, \"\\n\\t\");\n            \n\n\n            switch (do_background)\n            {\n#           ifdef PNG_READ_BACKGROUND_SUPPORTED\n               case PNG_BACKGROUND_GAMMA_SCREEN:\n               case PNG_BACKGROUND_GAMMA_FILE:\n               case PNG_BACKGROUND_GAMMA_UNIQUE:\n                  use_background = (alpha >= 0 && alpha < 1);\n                  \n#           endif\n#           ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n               case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:\n               case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:\n               case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:\n#           endif \n               do_compose = (alpha > 0 && alpha < 1);\n               use_input = (alpha != 0);\n               break;\n            default:\n               break;\n            }\n            \n            if (compose != do_compose)\n               png_error(vi->pp, \"internal error (compose)\");\n            \n            pos = safecat(msg, sizeof msg, pos, name);\n            pos = safecat(msg, sizeof msg, pos, \"(\");\n            pos = safecatn(msg, sizeof msg, pos, id);\n            if (use_input || pass != 0)\n            {\n               if (isbit != id)\n               {\n                  \n                  pos = safecat(msg, sizeof msg, pos, \", sbit(\");\n                  pos = safecatn(msg, sizeof msg, pos, vi->sbit);\n                  pos = safecat(msg, sizeof msg, pos, \"): \");\n                  pos = safecatn(msg, sizeof msg, pos, isbit);\n               }\n               pos = safecat(msg, sizeof msg, pos, \"/\");\n               \n               pos = safecatn(msg, sizeof msg, pos, vi->sbit_max);\n            }\n            pos = safecat(msg, sizeof msg, pos, \")\");\n            \n\n\n            if (compose || pass != 0)\n            {\n               \n\n\n\n\n               if (use_input || pass != 0)\n               {\n                  if (vi->file_inverse > 0)\n                  {\n                     pos = safecat(msg, sizeof msg, pos, \"^\");\n                     pos = safecatd(msg, sizeof msg, pos, vi->file_inverse, 2);\n                  }\n                  else\n                     pos = safecat(msg, sizeof msg, pos, \"[linear]\");\n                  pos = safecat(msg, sizeof msg, pos, \"*(alpha)\");\n                  pos = safecatd(msg, sizeof msg, pos, alpha, precision);\n               }\n               \n\n\n\n               if (use_background)\n               {\n                  pos = safecat(msg, sizeof msg, pos, use_input ? \"+\" : \" \");\n                  pos = safecat(msg, sizeof msg, pos, \"(background)\");\n                  pos = safecatd(msg, sizeof msg, pos, background, precision);\n                  pos = safecat(msg, sizeof msg, pos, \"*\");\n                  pos = safecatd(msg, sizeof msg, pos, 1-alpha, precision);\n               }\n            }\n            \n\n\n\n            if (compose || alpha < 0 || pass != 0)\n            {\n               pos = safecat(msg, sizeof msg, pos,\n                  pass != 0 ? \" =\\n\\t\" : \" = \");\n               pos = safecatd(msg, sizeof msg, pos, input_sample, precision);\n               pos = safecat(msg, sizeof msg, pos, \" (libpng: \");\n               pos = safecatd(msg, sizeof msg, pos, output, precision);\n               pos = safecat(msg, sizeof msg, pos, \")\");\n               \n               if (output_is_encoded)\n               {\n                  pos = safecat(msg, sizeof msg, pos, \" ^\");\n                  pos = safecatd(msg, sizeof msg, pos, vi->screen_inverse, 2);\n                  pos = safecat(msg, sizeof msg, pos, \"(to screen) =\");\n               }\n               else\n                  pos = safecat(msg, sizeof msg, pos, \" [screen is linear] =\");\n            }\n            if ((!compose && alpha >= 0) || pass != 0)\n            {\n               if (pass != 0) \n                  pos = safecat(msg, sizeof msg, pos, \"\\n\\t[overall:\");\n               \n\n\n\n\n               if (vi->gamma_correction > 0)\n               {\n                  pos = safecat(msg, sizeof msg, pos, \" ^\");\n                  pos = safecatd(msg, sizeof msg, pos, vi->gamma_correction, 2);\n                  pos = safecat(msg, sizeof msg, pos, \"(gamma correction) =\");\n               }\n               else\n                  pos = safecat(msg, sizeof msg, pos,\n                     \" [no gamma correction] =\");\n               if (pass != 0)\n                  pos = safecat(msg, sizeof msg, pos, \"]\");\n            }\n            \n\n\n            pos = safecat(msg, sizeof msg, pos, pass != 0 ? \"\\n\\t\" : \" \");\n            pos = safecatd(msg, sizeof msg, pos, is_lo, 1);\n            pos = safecat(msg, sizeof msg, pos, \" < \");\n            pos = safecatd(msg, sizeof msg, pos, encoded_sample, 1);\n            pos = safecat(msg, sizeof msg, pos, \" (libpng: \");\n            pos = safecatn(msg, sizeof msg, pos, od);\n            pos = safecat(msg, sizeof msg, pos, \")\");\n            pos = safecat(msg, sizeof msg, pos, \"/\");\n            pos = safecatn(msg, sizeof msg, pos, outmax);\n            pos = safecat(msg, sizeof msg, pos, \" < \");\n            pos = safecatd(msg, sizeof msg, pos, is_hi, 1);\n            if (pass == 0) \n            {\n#              ifdef PNG_WARNINGS_SUPPORTED\n                  png_warning(vi->pp, msg);\n#              else\n                  store_warning(vi->pp, msg);\n#              endif\n            }\n            else \n               store_verbose(&vi->dp->pm->this, vi->pp, pass, msg);\n         }\n      }\n   }\n   return i;\n}\n", "bug_type": null, "idx": 138}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\ntransform_end(png_structp ppIn, png_infop pi)\n{\n   png_const_structp pp = ppIn;\n   transform_display *dp = voidcast(transform_display*,\n      png_get_progressive_ptr(pp));\n   if (!dp->this.speed)\n      transform_image_validate(dp, pp, pi);\n   else\n      dp->this.ps->validated = 1;\n}\n", "bug_type": null, "idx": 139}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_pool_mark(png_bytep mark)\n{\n   static png_uint_32 store_seed[2] = { 0x12345678, 1};\n   make_four_random_bytes(store_seed, mark);\n}\n", "bug_type": null, "idx": 140}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\npngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n   png_size_t check;\n   check = fwrite(data, 1, length, (png_FILE_p)png_get_io_ptr(png_ptr));\n   if (check != length)\n   {\n      png_error(png_ptr, \"Write Error\");\n   }\n#ifdef PNG_IO_STATE_SUPPORTED\n   pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);\n#endif\n}\nstatic void PNGCBAPI\npngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n   png_size_t check;\n   png_byte *near_data;  \n   png_FILE_p io_ptr;\n   \n   near_data = (png_byte *)CVT_PTR_NOCHECK(data);\n   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));\n   if ((png_bytep)near_data == data)\n   {\n      check = fwrite(near_data, 1, length, io_ptr);\n   }\n   else\n   {\n      png_byte buf[NEAR_BUF_SIZE];\n      png_size_t written, remaining, err;\n      check = 0;\n      remaining = length;\n      do\n      {\n         written = MIN(NEAR_BUF_SIZE, remaining);\n         png_memcpy(buf, data, written); \n         err = fwrite(buf, 1, written, io_ptr);\n         if (err != written)\n            break;\n         else\n            check += err;\n         data += written;\n         remaining -= written;\n      }\n      while (remaining != 0);\n   }\n   if (check != length)\n   {\n      png_error(png_ptr, \"Write Error\");\n   }\n#ifdef PNG_IO_STATE_SUPPORTED\n   pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);\n#endif\n}\n", "bug_type": null, "idx": 141}
{"project": "LibPNG", "target": 0, "func": "double\nfinvsRGB(unsigned int i)\n{\n   return 65535 * linear_from_sRGB(i/255.);\n}\n", "bug_type": null, "idx": 142}
{"project": "LibPNG", "target": 0, "func": "void\npngtest_check_io_state(png_structp png_ptr, png_size_t data_length,\n   png_uint_32 io_op)\n{\n   png_uint_32 io_state = png_get_io_state(png_ptr);\n   int err = 0;\n   \n   if ((io_state & PNG_IO_MASK_OP) != io_op)\n      png_error(png_ptr, \"Incorrect operation in I/O state\");\n   \n\n\n   switch (io_state & PNG_IO_MASK_LOC)\n   {\n   case PNG_IO_SIGNATURE:\n      if (data_length > 8)\n         err = 1;\n      break;\n   case PNG_IO_CHUNK_HDR:\n      if (data_length != 8)\n         err = 1;\n      break;\n   case PNG_IO_CHUNK_DATA:\n      break;  \n   case PNG_IO_CHUNK_CRC:\n      if (data_length != 4)\n         err = 1;\n      break;\n   default:\n      err = 1;  \n   }\n   if (err)\n      png_error(png_ptr, \"Bad I/O state or buffer size\");\n}\n", "bug_type": null, "idx": 143}
{"project": "LibPNG", "target": 1, "func": "\n\n\n\npng_charp PNGAPI\npng_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)\n{\n   static PNG_CONST char short_months[12][4] =\n        {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n\n   if (png_ptr == NULL)\n      return (NULL);\n   if (png_ptr->time_buffer == NULL)\n   {\n      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*\n         png_sizeof(char)));\n   }\n\n#ifdef USE_FAR_KEYWORD\n   {\n      char near_time_buf[29];\n      png_snprintf6(near_time_buf, 29, \"%d %s %d %02d:%02d:%02d +0000\",\n          ptime->day % 32, short_months[(ptime->month - 1) % 12],\n          ptime->year, ptime->hour % 24, ptime->minute % 60,\n          ptime->second % 61);\n      png_memcpy(png_ptr->time_buffer, near_time_buf,\n          29*png_sizeof(char));\n   }\n#else\n   png_snprintf6(png_ptr->time_buffer, 29, \"%d %s %d %02d:%02d:%02d +0000\",\n       ptime->day % 32, short_months[(ptime->month - 1) % 12],\n       ptime->year, ptime->hour % 24, ptime->minute % 60,\n       ptime->second % 61);\n#endif\n   return ((png_charp)png_ptr->time_buffer);\n}\n#endif ", "bug_type": "cve-2015-7981", "idx": 144}
{"project": "LibPNG", "target": 0, "func": "void PNGCBAPI\nwrite_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)\n{\n   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX || pass > 7)\n      return;\n   fprintf(stdout, \"w\");\n}\n", "bug_type": null, "idx": 145}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_expand_16_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_expand_16(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 146}
{"project": "LibPNG", "target": 0, "func": "int\nmain(void)\n{\n   fprintf(stderr, \"pngimage: no support for png_read/write_image\\n\");\n   return 77;\n}\n", "bug_type": null, "idx": 147}
{"project": "LibPNG", "target": 0, "func": "static struct IDAT_list *\nIDAT_list_extend(struct IDAT_list *tail)\n{\n   \n   struct IDAT_list *next = tail->next;\n   if (next == NULL)\n   {\n      \n\n\n      unsigned int length = 2 * tail->length;\n      if (length < tail->length) \n         length = tail->length;\n      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));\n      CLEAR(*next);\n      \n      if (next == NULL)\n         return NULL;\n      next->next = NULL;\n      next->length = length;\n      tail->next = next;\n   }\n   return next;\n}\n", "bug_type": null, "idx": 148}
{"project": "LibPNG", "target": 0, "func": "static void\nprint_one(const char *leader, double err)\n{\n   if (err != -1.)\n      printf(\" %s %.5f\\n\", leader, err);\n}\n", "bug_type": null, "idx": 149}
{"project": "LibPNG", "target": 0, "func": "static png_uint_16\nilineara_g22(int fixed_srgb, int alpha)\n{\n   return u16d((257 * alpha) * g22_to_d[fixed_srgb]);\n}\n", "bug_type": null, "idx": 150}
{"project": "LibPNG", "target": 0, "func": "static size_t\ntransform_rowsize(png_const_structp pp, png_byte colour_type,\n   png_byte bit_depth)\n{\n   return (TRANSFORM_WIDTH * bit_size(pp, colour_type, bit_depth)) / 8;\n}\n", "bug_type": null, "idx": 151}
{"project": "LibPNG", "target": 0, "func": "#endif \nint validation_gamma(int argc, char **argv)\n{\n   double gamma[9] = { 2.2, 1.8, 1.52, 1.45, 1., 1/1.45, 1/1.52, 1/1.8, 1/2.2 };\n   double maxerr;\n   int i, silent=0, onlygamma=0;\n   \n   while (--argc > 0)\n      if (strcmp(*++argv, \"-s\") == 0)\n         silent = 1;\n      else if (strcmp(*argv, \"-g\") == 0)\n         onlygamma = 1;\n      else\n      {\n         fprintf(stderr, \"unknown argument %s\\n\", *argv);\n         return 1;\n      }\n   if (!onlygamma)\n   {\n      \n      maxerr = 0;\n      for (i=0; i<256; ++i)\n      {\n         double correct = -log(i/255.)/log(2.)*65536;\n         double error = png_log8bit(i) - correct;\n         if (i != 0 && fabs(error) > maxerr)\n            maxerr = fabs(error);\n         if (i == 0 && png_log8bit(i) != 0xffffffff ||\n             i != 0 && png_log8bit(i) != floor(correct+.5))\n         {\n            fprintf(stderr, \"8 bit log error: %d: got %u, expected %f\\n\",\n               i, png_log8bit(i), correct);\n         }\n      }\n      if (!silent)\n         printf(\"maximum 8 bit log error = %f\\n\", maxerr);\n      maxerr = 0;\n      for (i=0; i<65536; ++i)\n      {\n         double correct = -log(i/65535.)/log(2.)*65536;\n         double error = png_log16bit(i) - correct;\n         if (i != 0 && fabs(error) > maxerr)\n            maxerr = fabs(error);\n         if (i == 0 && png_log16bit(i) != 0xffffffff ||\n             i != 0 && png_log16bit(i) != floor(correct+.5))\n         {\n            if (error > .68) \n            {\n               fprintf(stderr, \"16 bit log error: %d: got %u, expected %f\"\n                  \" error: %f\\n\", i, png_log16bit(i), correct, error);\n            }\n         }\n      }\n      if (!silent)\n         printf(\"maximum 16 bit log error = %f\\n\", maxerr);\n      \n      maxerr = 0;\n      for (i=0; i<=0xfffff; ++i)\n      {\n         double correct = exp(-i/65536. * log(2.)) * (65536. * 65536);\n         double error = png_exp(i) - correct;\n         if (fabs(error) > maxerr)\n            maxerr = fabs(error);\n         if (fabs(error) > 1883) \n         {\n            fprintf(stderr, \"32 bit exp error: %d: got %u, expected %f\"\n                  \" error: %f\\n\", i, png_exp(i), correct, error);\n         }\n      }\n      if (!silent)\n         printf(\"maximum 32 bit exp error = %f\\n\", maxerr);\n      maxerr = 0;\n      for (i=0; i<=0xfffff; ++i)\n      {\n         double correct = exp(-i/65536. * log(2.)) * 255;\n         double error = png_exp8bit(i) - correct;\n         if (fabs(error) > maxerr)\n            maxerr = fabs(error);\n         if (fabs(error) > .50002) \n         {\n            fprintf(stderr, \"8 bit exp error: %d: got %u, expected %f\"\n                  \" error: %f\\n\", i, png_exp8bit(i), correct, error);\n         }\n      }\n      if (!silent)\n         printf(\"maximum 8 bit exp error = %f\\n\", maxerr);\n      maxerr = 0;\n      for (i=0; i<=0xfffff; ++i)\n      {\n         double correct = exp(-i/65536. * log(2.)) * 65535;\n         double error = png_exp16bit(i) - correct;\n         if (fabs(error) > maxerr)\n            maxerr = fabs(error);\n         if (fabs(error) > .524) \n         {\n            fprintf(stderr, \"16 bit exp error: %d: got %u, expected %f\"\n                  \" error: %f\\n\", i, png_exp16bit(i), correct, error);\n         }\n      }\n      if (!silent)\n         printf(\"maximum 16 bit exp error = %f\\n\", maxerr);\n   } \n   \n   for (i=0; i<9; ++i)\n   {\n      unsigned j;\n      double g = gamma[i];\n      png_fixed_point gfp = floor(g * PNG_FP_1 + .5);\n      if (!silent)\n         printf(\"Test gamma %f\\n\", g);\n      maxerr = 0;\n      for (j=0; j<256; ++j)\n      {\n         double correct = pow(j/255., g) * 255;\n         png_byte out = png_gamma_8bit_correct(j, gfp);\n         double error = out - correct;\n         if (fabs(error) > maxerr)\n            maxerr = fabs(error);\n         if (out != floor(correct+.5))\n         {\n            fprintf(stderr, \"8bit %d ^ %f: got %d expected %f error %f\\n\",\n               j, g, out, correct, error);\n         }\n      }\n      if (!silent)\n         printf(\"gamma %f: maximum 8 bit error %f\\n\", g, maxerr);\n      maxerr = 0;\n      for (j=0; j<65536; ++j)\n      {\n         double correct = pow(j/65535., g) * 65535;\n         png_uint_16 out = png_gamma_16bit_correct(j, gfp);\n         double error = out - correct;\n         if (fabs(error) > maxerr)\n            maxerr = fabs(error);\n         if (fabs(error) > 1.62)\n         {\n            fprintf(stderr, \"16bit %d ^ %f: got %d expected %f error %f\\n\",\n               j, g, out, correct, error);\n         }\n      }\n      if (!silent)\n         printf(\"gamma %f: maximum 16 bit error %f\\n\", g, maxerr);\n   }\n   return 0;\n}\n", "bug_type": null, "idx": 152}
{"project": "LibPNG", "target": 0, "func": "\nint readpng2_init(mainprog_info *mainprog_ptr)\n{\n    png_structp  png_ptr;       \n    png_infop  info_ptr;\n    \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      readpng2_error_handler, NULL);\n    if (!png_ptr)\n        return 4;   \n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return 4;   \n    }\n    \n\n\n    \n\n\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return 2;\n    }\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n    \n\n\n    {\n        \n\n\n        static PNG_CONST png_byte chunks_to_process[] = {\n            98,  75,  71,  68, '\\0',  \n           103,  65,  77,  65, '\\0',  \n           115,  82,  71,  66, '\\0',  \n           };\n       \n       png_set_keep_unknown_chunks(png_ptr, -1 ,\n          NULL, -1);\n       \n       png_set_keep_unknown_chunks(png_ptr,\n          0 , chunks_to_process,\n          sizeof(chunks_to_process)/5);\n    }\n#endif \n    \n\n    png_set_progressive_read_fn(png_ptr, mainprog_ptr,\n      readpng2_info_callback, readpng2_row_callback, readpng2_end_callback);\n    \n    mainprog_ptr->png_ptr = png_ptr;\n    mainprog_ptr->info_ptr = info_ptr;\n    \n    return 0;\n}\n", "bug_type": null, "idx": 153}
{"project": "LibPNG", "target": 0, "func": " *  unexpected pnmtype; note that outfile might be stdout */\nint writepng_init(mainprog_info *mainprog_ptr)\n{\n    png_structp  png_ptr;       \n    png_infop  info_ptr;\n    int color_type, interlace_type;\n    \n    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      writepng_error_handler, NULL);\n    if (!png_ptr)\n        return 4;   \n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_write_struct(&png_ptr, NULL);\n        return 4;   \n    }\n    \n\n\n\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        return 2;\n    }\n    \n    png_init_io(png_ptr, mainprog_ptr->outfile);\n    \n\n\n\n\n\n    png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);\n\n\n\n\n\n\n\n\n    \n    if (mainprog_ptr->pnmtype == 5)\n        color_type = PNG_COLOR_TYPE_GRAY;\n    else if (mainprog_ptr->pnmtype == 6)\n        color_type = PNG_COLOR_TYPE_RGB;\n    else if (mainprog_ptr->pnmtype == 8)\n        color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    else {\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        return 11;\n    }\n    interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 :\n                                               PNG_INTERLACE_NONE;\n    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,\n      mainprog_ptr->sample_depth, color_type, interlace_type,\n      PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n    if (mainprog_ptr->gamma > 0.0)\n        png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma);\n    if (mainprog_ptr->have_bg) {   \n        png_color_16  background;\n        background.red = mainprog_ptr->bg_red;\n        background.green = mainprog_ptr->bg_green;\n        background.blue = mainprog_ptr->bg_blue;\n        png_set_bKGD(png_ptr, info_ptr, &background);\n    }\n    if (mainprog_ptr->have_time) {\n        png_time  modtime;\n        png_convert_from_time_t(&modtime, mainprog_ptr->modtime);\n        png_set_tIME(png_ptr, info_ptr, &modtime);\n    }\n    if (mainprog_ptr->have_text) {\n        png_text  text[6];\n        int  num_text = 0;\n        if (mainprog_ptr->have_text & TEXT_TITLE) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Title\";\n            text[num_text].text = mainprog_ptr->title;\n            ++num_text;\n        }\n        if (mainprog_ptr->have_text & TEXT_AUTHOR) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Author\";\n            text[num_text].text = mainprog_ptr->author;\n            ++num_text;\n        }\n        if (mainprog_ptr->have_text & TEXT_DESC) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Description\";\n            text[num_text].text = mainprog_ptr->desc;\n            ++num_text;\n        }\n        if (mainprog_ptr->have_text & TEXT_COPY) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Copyright\";\n            text[num_text].text = mainprog_ptr->copyright;\n            ++num_text;\n        }\n        if (mainprog_ptr->have_text & TEXT_EMAIL) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"E-mail\";\n            text[num_text].text = mainprog_ptr->email;\n            ++num_text;\n        }\n        if (mainprog_ptr->have_text & TEXT_URL) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"URL\";\n            text[num_text].text = mainprog_ptr->url;\n            ++num_text;\n        }\n        png_set_text(png_ptr, info_ptr, text, num_text);\n    }\n    \n    png_write_info(png_ptr, info_ptr);\n    \n\n\n\n\n    \n\n    png_set_packing(png_ptr);\n\n    \n    mainprog_ptr->png_ptr = png_ptr;\n    mainprog_ptr->info_ptr = info_ptr;\n    \n    return 0;\n}\n", "bug_type": null, "idx": 154}
{"project": "LibPNG", "target": 1, "func": "\n\n\nvoid \npng_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_charp purpose;\n   png_int_32 X0, X1;\n   png_byte type, nparams;\n   png_charp buf, units, endptr;\n   png_charpp params;\n   png_size_t slength;\n   int i;\n\n   png_debug(1, \"in png_handle_pCAL\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before pCAL\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid pCAL after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))\n   {\n      png_warning(png_ptr, \"Duplicate pCAL chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading pCAL chunk data (%lu bytes)\\n\",\n      length + 1);\n   purpose = (png_charp)png_malloc_warn(png_ptr, length + 1);\n   if (purpose == NULL)\n     {\n       png_warning(png_ptr, \"No memory for pCAL purpose.\");\n       return;\n     }\n   slength = (png_size_t)length;\n   png_crc_read(png_ptr, (png_bytep)purpose, slength);\n\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_free(png_ptr, purpose);\n      return;\n   }\n\n   purpose[slength] = 0x00; \n\n   png_debug(3, \"Finding end of pCAL purpose string\\n\");\n   for (buf = purpose; *buf; buf++)\n       ;\n\n   endptr = purpose + slength;\n\n   \n\n   if (endptr <= buf + 12)\n   {\n      png_warning(png_ptr, \"Invalid pCAL data\");\n      png_free(png_ptr, purpose);\n      return;\n   }\n\n   png_debug(3, \"Reading pCAL X0, X1, type, nparams, and units\\n\");\n   X0 = png_get_int_32((png_bytep)buf+1);\n   X1 = png_get_int_32((png_bytep)buf+5);\n   type = buf[9];\n   nparams = buf[10];\n   units = buf + 11;\n\n   png_debug(3, \"Checking pCAL equation type and number of parameters\\n\");\n   \n\n   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||\n       (type == PNG_EQUATION_BASE_E && nparams != 3) ||\n       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||\n       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))\n   {\n      png_warning(png_ptr, \"Invalid pCAL parameters for equation type\");\n      png_free(png_ptr, purpose);\n      return;\n   }\n   else if (type >= PNG_EQUATION_LAST)\n   {\n      png_warning(png_ptr, \"Unrecognized equation type for pCAL chunk\");\n   }\n\n   for (buf = units; *buf; buf++)\n       ;\n\n   png_debug(3, \"Allocating pCAL parameters array\\n\");\n   params = (png_charpp)png_malloc_warn(png_ptr, (png_uint_32)(nparams\n      *png_sizeof(png_charp))) ;\n   if (params == NULL)\n     {\n       png_free(png_ptr, purpose);\n       png_warning(png_ptr, \"No memory for pCAL params.\");\n       return;\n     }\n\n   \n   for (i = 0; i < (int)nparams; i++)\n   {\n      buf++; \n\n      png_debug1(3, \"Reading pCAL parameter %d\\n\", i);\n      for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++)\n          ;\n\n      \n      if (buf > endptr)\n      {\n         png_warning(png_ptr, \"Invalid pCAL data\");\n         png_free(png_ptr, purpose);\n         png_free(png_ptr, params);\n         return;\n      }\n   }\n\n   png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,\n      units, params);\n\n   png_free(png_ptr, purpose);\n   png_free(png_ptr, params);\n}\n#endif", "bug_type": "cve-2007-5269-1", "idx": 155}
{"project": "LibPNG", "target": 0, "func": "static int wpng_isvalid_latin1(uch *p, int len)\n{\n    int i, result = -1;\n    for (i = 0;  i < len;  ++i) {\n        if (p[i] == 10 || (p[i] > 31 && p[i] < 127) || p[i] > 160)\n            continue;           \n        if (result < 0 || (p[result] != 27 && p[i] == 27))\n            result = i;         \n    }                           \n    return result;\n}\n", "bug_type": null, "idx": 156}
{"project": "LibPNG", "target": 0, "func": "unsigned long\ncomponent(const char *prog, const char *arg, int issRGB)\n{\n   char *ep;\n   unsigned long c = strtoul(arg, &ep, 0);\n   if (ep <= arg || *ep || c > 65535 || (issRGB && c > 255))\n   {\n      fprintf(stderr, \"%s: %s: invalid component value (%lu)\\n\", prog, arg, c);\n      usage(prog);\n   }\n   return c;\n}\n", "bug_type": null, "idx": 157}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_unpg(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->a <= 128)\n   {\n      out->r = out->g = out->b = 255;\n      out->a = 0;\n   }\n   else\n   {\n      out->r = out->g = out->b = sRGB((double)in->g / in->a);\n      out->a = u8d(in->a / 257.);\n   }\n}\n", "bug_type": null, "idx": 158}
{"project": "LibPNG", "target": 0, "func": "static PNG_NORETURN void\nusage(const char *program, const char *reason)\n{\n   fprintf(stderr, \"pngunknown: %s: usage:\\n %s [--strict] \"\n      \"--default|{(CHNK|default|all)=(default|discard|if-safe|save)} \"\n      \"testfile.png\\n\", reason, program);\n   exit(99);\n}\n", "bug_type": null, "idx": 159}
{"project": "LibPNG", "target": 0, "func": "static void\nfile_setpos(struct file *file, const fpos_t *pos)\n{\n   if (fsetpos(file->file, pos))\n   {\n      perror(file->file_name);\n      stop(file, READ_ERROR_CODE, \"fsetpos\");\n   }\n}\n", "bug_type": null, "idx": 160}
{"project": "LibPNG", "target": 0, "func": "#else \nint main(void)\n{\n   fprintf(stderr, \"pngstest: no read support in libpng, test skipped\\n\");\n   \n   return 77;\n}\n", "bug_type": null, "idx": 161}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_error_test(png_modifier *pm)\n{\n#ifdef PNG_WARNINGS_SUPPORTED \n   \n   safecat(pm->this.test, sizeof pm->this.test, 0, \"error test\");\n   if (!make_errors(pm, 0, 0, WRITE_BDHI))\n      return;\n   if (!make_errors(pm, 2, 3, WRITE_BDHI))\n      return;\n   if (!make_errors(pm, 3, 0, 3))\n      return;\n   if (!make_errors(pm, 4, 3, WRITE_BDHI))\n      return;\n   if (!make_errors(pm, 6, 3, WRITE_BDHI))\n      return;\n#else\n   UNUSED(pm)\n#endif\n}\n", "bug_type": null, "idx": 162}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_abgr16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = pp[3];\n   p->g = pp[2];\n   p->b = pp[1];\n   p->a = pp[0];\n}\n", "bug_type": null, "idx": 163}
{"project": "LibPNG", "target": 0, "func": "PNG_NORETURN static void\nstop_invalid(struct file *file, const char *what)\n{\n   stop(file, INVALID_ERROR_CODE, what);\n}\n", "bug_type": null, "idx": 164}
{"project": "LibPNG", "target": 0, "func": "static png_uint_16\nilinear(int fixed_srgb)\n{\n   return u16d(65535 * sRGB_to_d[fixed_srgb]);\n}\n", "bug_type": null, "idx": 165}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_one_test_safe(FILE *fp, int argc, const char **argv,\n   png_uint_32 *default_flags, display *d, const char *test)\n{\n   if (setjmp(d->error_return) == 0)\n   {\n      d->test = test; \n#     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED\n         perform_one_test(fp, argc, argv, default_flags, d, 0);\n#     endif\n#     ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n         perform_one_test(fp, argc, argv, default_flags, d, 1);\n#     endif\n      d->test = init; \n   }\n}\n", "bug_type": null, "idx": 166}
{"project": "LibPNG", "target": 0, "func": "void readpng_cleanup(int free_image_data)\n{\n    if (free_image_data && image_data) {\n        free(image_data);\n        image_data = NULL;\n    }\n    if (png_ptr && info_ptr) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        png_ptr = NULL;\n        info_ptr = NULL;\n    }\n}\n", "bug_type": null, "idx": 167}
{"project": "LibPNG", "target": 0, "func": "static void\nusage(const char *prog)\n{\n   fprintf(stderr,\n      \"%s: usage: %s [-linear|-sRGB] [-gray|-color] component{1,4}\\n\",\n      prog, prog);\n   exit(1);\n}\n", "bug_type": null, "idx": 168}
{"project": "LibPNG", "target": 0, "func": "static void\nsrgb_modification_init(srgb_modification *me, png_modifier *pm, png_byte intent)\n{\n   modification_init(&me->this);\n   me->this.chunk = CHUNK_sBIT;\n   if (intent <= 3) \n   {\n      me->this.modify_fn = srgb_modify;\n      me->this.add = CHUNK_PLTE;\n      me->intent = intent;\n   }\n   else\n   {\n      me->this.modify_fn = 0;\n      me->this.add = 0;\n      me->intent = 0;\n   }\n   me->this.next = pm->modifications;\n   pm->modifications = &me->this;\n}\n", "bug_type": null, "idx": 169}
{"project": "LibPNG", "target": 0, "func": "\nuch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)\n{\n    ulg  rowbytes;\n    \n\n\n    \n    *pRowbytes = rowbytes = channels*width;\n    *pChannels = channels;\n    if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {\n        return NULL;\n    }\n    Trace((stderr, \"readpng_get_image:  rowbytes = %ld, height = %ld\\n\", rowbytes, height));\n    \n    fread(image_data, 1L, rowbytes*height, saved_infile);\n    return image_data;\n}\n", "bug_type": null, "idx": 170}
{"project": "LibPNG", "target": 0, "func": "int\nmain(int argc, char *argv[])\n{\n   int multiple = 0;\n   int ierror = 0;\n   fprintf(STDERR, \"\\n Testing libpng version %s\\n\", PNG_LIBPNG_VER_STRING);\n   fprintf(STDERR, \"   with zlib   version %s\\n\", ZLIB_VERSION);\n   fprintf(STDERR, \"%s\", png_get_copyright(NULL));\n   \n   fprintf(STDERR, \" library (%lu):%s\",\n      (unsigned long)png_access_version_number(),\n      png_get_header_version(NULL));\n   \n   fprintf(STDERR, \" pngtest (%lu):%s\", (unsigned long)PNG_LIBPNG_VER,\n      PNG_HEADER_VERSION_STRING);\n   \n\n\n\n\n#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)\n      fprintf(STDERR, \" NOTE: Zlib compiled for max 64k, libpng not\\n\");\n#endif\n   \n#if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)\n      fprintf(STDERR, \" NOTE: libpng compiled for max 64k, zlib not\\n\");\n#endif\n   if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))\n   {\n      fprintf(STDERR,\n         \"Warning: versions are different between png.h and png.c\\n\");\n      fprintf(STDERR, \"  png.h version: %s\\n\", PNG_LIBPNG_VER_STRING);\n      fprintf(STDERR, \"  png.c version: %s\\n\\n\", png_libpng_ver);\n      ++ierror;\n   }\n   if (argc > 1)\n   {\n      if (strcmp(argv[1], \"-m\") == 0)\n      {\n         multiple = 1;\n         status_dots_requested = 0;\n      }\n      else if (strcmp(argv[1], \"-mv\") == 0 ||\n               strcmp(argv[1], \"-vm\") == 0 )\n      {\n         multiple = 1;\n         verbose = 1;\n         status_dots_requested = 1;\n      }\n      else if (strcmp(argv[1], \"-v\") == 0)\n      {\n         verbose = 1;\n         status_dots_requested = 1;\n         inname = argv[2];\n      }\n      else\n      {\n         inname = argv[1];\n         status_dots_requested = 0;\n      }\n   }\n   if (!multiple && argc == 3 + verbose)\n     outname = argv[2 + verbose];\n   if ((!multiple && argc > 3 + verbose) || (multiple && argc < 2))\n   {\n     fprintf(STDERR,\n       \"usage: %s [infile.png] [outfile.png]\\n\\t%s -m {infile.png}\\n\",\n        argv[0], argv[0]);\n     fprintf(STDERR,\n       \"  reads/writes one PNG file (without -m) or multiple files (-m)\\n\");\n     fprintf(STDERR,\n       \"  with -m %s is used as a temporary file\\n\", outname);\n     exit(1);\n   }\n   if (multiple)\n   {\n      int i;\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n      int allocation_now = current_allocation;\n#endif\n      for (i=2; i<argc; ++i)\n      {\n         int kerror;\n         fprintf(STDERR, \"\\n Testing %s:\", argv[i]);\n         kerror = test_one_file(argv[i], outname);\n         if (kerror == 0)\n         {\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n            int k;\n#endif\n#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED\n            fprintf(STDERR, \"\\n PASS (%lu zero samples)\\n\",\n               (unsigned long)zero_samples);\n#else\n            fprintf(STDERR, \" PASS\\n\");\n#endif\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n            for (k = 0; k<256; k++)\n               if (filters_used[k])\n                  fprintf(STDERR, \" Filter %d was used %lu times\\n\",\n                     k, (unsigned long)filters_used[k]);\n#endif\n#ifdef PNG_TIME_RFC1123_SUPPORTED\n         if (tIME_chunk_present != 0)\n            fprintf(STDERR, \" tIME = %s\\n\", tIME_string);\n         tIME_chunk_present = 0;\n#endif \n         }\n         else\n         {\n            fprintf(STDERR, \" FAIL\\n\");\n            ierror += kerror;\n         }\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n         if (allocation_now != current_allocation)\n            fprintf(STDERR, \"MEMORY ERROR: %d bytes lost\\n\",\n               current_allocation - allocation_now);\n         if (current_allocation != 0)\n         {\n            memory_infop pinfo = pinformation;\n            fprintf(STDERR, \"MEMORY ERROR: %d bytes still allocated\\n\",\n               current_allocation);\n            while (pinfo != NULL)\n            {\n               fprintf(STDERR, \" %lu bytes at %x\\n\",\n                 (unsigned long)pinfo->size,\n                 (unsigned int)pinfo->pointer);\n               pinfo = pinfo->next;\n            }\n         }\n#endif\n      }\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n         fprintf(STDERR, \" Current memory allocation: %10d bytes\\n\",\n            current_allocation);\n         fprintf(STDERR, \" Maximum memory allocation: %10d bytes\\n\",\n            maximum_allocation);\n         fprintf(STDERR, \" Total   memory allocation: %10d bytes\\n\",\n            total_allocation);\n         fprintf(STDERR, \"     Number of allocations: %10d\\n\",\n            num_allocations);\n#endif\n   }\n   else\n   {\n      int i;\n      for (i = 0; i<3; ++i)\n      {\n         int kerror;\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n         int allocation_now = current_allocation;\n#endif\n         if (i == 1)\n            status_dots_requested = 1;\n         else if (verbose == 0)\n            status_dots_requested = 0;\n         if (i == 0 || verbose == 1 || ierror != 0)\n            fprintf(STDERR, \"\\n Testing %s:\", inname);\n         kerror = test_one_file(inname, outname);\n         if (kerror == 0)\n         {\n            if (verbose == 1 || i == 2)\n            {\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n                int k;\n#endif\n#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED\n                fprintf(STDERR, \"\\n PASS (%lu zero samples)\\n\",\n                   (unsigned long)zero_samples);\n#else\n                fprintf(STDERR, \" PASS\\n\");\n#endif\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n                for (k = 0; k<256; k++)\n                   if (filters_used[k])\n                      fprintf(STDERR, \" Filter %d was used %lu times\\n\",\n                         k, (unsigned long)filters_used[k]);\n#endif\n#ifdef PNG_TIME_RFC1123_SUPPORTED\n             if (tIME_chunk_present != 0)\n                fprintf(STDERR, \" tIME = %s\\n\", tIME_string);\n#endif \n            }\n         }\n         else\n         {\n            if (verbose == 0 && i != 2)\n               fprintf(STDERR, \"\\n Testing %s:\", inname);\n            fprintf(STDERR, \" FAIL\\n\");\n            ierror += kerror;\n         }\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n         if (allocation_now != current_allocation)\n             fprintf(STDERR, \"MEMORY ERROR: %d bytes lost\\n\",\n               current_allocation - allocation_now);\n         if (current_allocation != 0)\n         {\n             memory_infop pinfo = pinformation;\n             fprintf(STDERR, \"MEMORY ERROR: %d bytes still allocated\\n\",\n                current_allocation);\n             while (pinfo != NULL)\n             {\n                fprintf(STDERR, \" %lu bytes at %x\\n\",\n                   (unsigned long)pinfo->size, (unsigned int)pinfo->pointer);\n                pinfo = pinfo->next;\n             }\n          }\n#endif\n       }\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n       fprintf(STDERR, \" Current memory allocation: %10d bytes\\n\",\n          current_allocation);\n       fprintf(STDERR, \" Maximum memory allocation: %10d bytes\\n\",\n          maximum_allocation);\n       fprintf(STDERR, \" Total   memory allocation: %10d bytes\\n\",\n          total_allocation);\n       fprintf(STDERR, \"     Number of allocations: %10d\\n\",\n            num_allocations);\n#endif\n   }\n#ifdef PNGTEST_TIMING\n   t_stop = (float)clock();\n   t_misc += (t_stop - t_start);\n   t_start = t_stop;\n   fprintf(STDERR, \" CPU time used = %.3f seconds\",\n      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);\n   fprintf(STDERR, \" (decoding %.3f,\\n\",\n      t_decode/(float)CLOCKS_PER_SEC);\n   fprintf(STDERR, \"        encoding %.3f ,\",\n      t_encode/(float)CLOCKS_PER_SEC);\n   fprintf(STDERR, \" other %.3f seconds)\\n\\n\",\n      t_misc/(float)CLOCKS_PER_SEC);\n#endif\n   if (ierror == 0)\n      fprintf(STDERR, \" libpng passes test\\n\");\n   else\n      fprintf(STDERR, \" libpng FAILS test\\n\");\n   return (int)(ierror != 0);\n}\n", "bug_type": null, "idx": 171}
{"project": "LibPNG", "target": 0, "func": "static void\nfreeimage(Image *image)\n{\n   freebuffer(image);\n   png_image_free(&image->image);\n   if (image->input_file != NULL)\n   {\n      fclose(image->input_file);\n      image->input_file = NULL;\n   }\n   if (image->input_memory != NULL)\n   {\n      free(image->input_memory);\n      image->input_memory = NULL;\n      image->input_memory_size = 0;\n   }\n   if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)\n   {\n      remove(image->tmpfile_name);\n      image->tmpfile_name[0] = 0;\n   }\n}\n", "bug_type": null, "idx": 172}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_g16q(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));\n   out->a = in->a;\n}\n", "bug_type": null, "idx": 173}
{"project": "LibPNG", "target": 0, "func": "static double calcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n{\n   \n\n\n   if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n      return pm->maxcalc16;\n   else if (pm->assume_16_bit_calculations)\n      return pm->maxcalcG;\n   else\n      return pm->maxcalc8;\n}\n", "bug_type": null, "idx": 174}
{"project": "LibPNG", "target": 1, "func": "\nint \npng_set_text_2(png_structp png_ptr, png_infop info_ptr,\n    png_const_textp text_ptr, int num_text)\n{\n   int i;\n\n   png_debug1(1, \"in %s storage function\", ((png_ptr == NULL ||\n       png_ptr->chunk_name[0] == '\\0') ?\n       \"text\" : (png_const_charp)png_ptr->chunk_name));\n\n   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)\n      return(0);\n\n   \n\n\n   if (info_ptr->num_text + num_text > info_ptr->max_text)\n   {\n      if (info_ptr->text != NULL)\n      {\n         png_textp old_text;\n         int old_max;\n\n         old_max = info_ptr->max_text;\n         info_ptr->max_text = info_ptr->num_text + num_text + 8;\n         old_text = info_ptr->text;\n         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,\n            (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));\n\n         if (info_ptr->text == NULL)\n         {\n            png_free(png_ptr, old_text);\n            return(1);\n         }\n\n         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *\n             png_sizeof(png_text)));\n         png_free(png_ptr, old_text);\n      }\n\n      else\n      {\n         info_ptr->max_text = num_text + 8;\n         info_ptr->num_text = 0;\n         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,\n             (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));\n         if (info_ptr->text == NULL)\n            return(1);\n         info_ptr->free_me |= PNG_FREE_TEXT;\n      }\n\n      png_debug1(3, \"allocated %d entries for info_ptr->text\",\n          info_ptr->max_text);\n   }\n   for (i = 0; i < num_text; i++)\n   {\n      png_size_t text_length, key_len;\n      png_size_t lang_len, lang_key_len;\n      png_textp textp = &(info_ptr->text[info_ptr->num_text]);\n\n      if (text_ptr[i].key == NULL)\n          continue;\n\n      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||\n          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)\n      {\n         png_warning(png_ptr, \"text compression mode is out of range\");\n         continue;\n      }\n\n      key_len = png_strlen(text_ptr[i].key);\n\n      if (text_ptr[i].compression <= 0)\n      {\n         lang_len = 0;\n         lang_key_len = 0;\n      }\n\n      else\n#  ifdef PNG_iTXt_SUPPORTED\n      {\n         \n\n         if (text_ptr[i].lang != NULL)\n            lang_len = png_strlen(text_ptr[i].lang);\n\n         else\n            lang_len = 0;\n\n         if (text_ptr[i].lang_key != NULL)\n            lang_key_len = png_strlen(text_ptr[i].lang_key);\n\n         else\n            lang_key_len = 0;\n      }\n#  else \n      {\n         png_warning(png_ptr, \"iTXt chunk not supported\");\n         continue;\n      }\n#  endif\n\n      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')\n      {\n         text_length = 0;\n#  ifdef PNG_iTXt_SUPPORTED\n         if (text_ptr[i].compression > 0)\n            textp->compression = PNG_ITXT_COMPRESSION_NONE;\n\n         else\n#  endif\n            textp->compression = PNG_TEXT_COMPRESSION_NONE;\n      }\n\n      else\n      {\n         text_length = png_strlen(text_ptr[i].text);\n         textp->compression = text_ptr[i].compression;\n      }\n\n      textp->key = (png_charp)png_malloc_warn(png_ptr,\n          (png_size_t)\n          (key_len + text_length + lang_len + lang_key_len + 4));\n\n      if (textp->key == NULL)\n         return(1);\n\n      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",\n          (unsigned long)(png_uint_32)\n          (key_len + lang_len + lang_key_len + text_length + 4),\n          textp->key);\n\n      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));\n      *(textp->key + key_len) = '\\0';\n\n      if (text_ptr[i].compression > 0)\n      {\n         textp->lang = textp->key + key_len + 1;\n         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);\n         *(textp->lang + lang_len) = '\\0';\n         textp->lang_key = textp->lang + lang_len + 1;\n         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);\n         *(textp->lang_key + lang_key_len) = '\\0';\n         textp->text = textp->lang_key + lang_key_len + 1;\n      }\n\n      else\n      {\n         textp->lang=NULL;\n         textp->lang_key=NULL;\n         textp->text = textp->key + key_len + 1;\n      }\n\n      if (text_length)\n         png_memcpy(textp->text, text_ptr[i].text,\n             (png_size_t)(text_length));\n\n      *(textp->text + text_length) = '\\0';\n\n#  ifdef PNG_iTXt_SUPPORTED\n      if (textp->compression > 0)\n      {\n         textp->text_length = 0;\n         textp->itxt_length = text_length;\n      }\n\n      else\n#  endif\n      {\n         textp->text_length = text_length;\n         textp->itxt_length = 0;\n      }\n\n      info_ptr->num_text++;\n      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);\n   }\n   return(0);\n}\n#endif", "bug_type": "cve-2011-3048", "idx": 175}
{"project": "LibPNG", "target": 0, "func": "static void\npng_write_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n   png_uint_32 check;\n   check = fwrite(data, 1, length, (FILE *)(png_ptr->io_ptr));\n   if (check != length)\n   {\n      png_error(png_ptr, \"Write Error\");\n   }\n}\n", "bug_type": null, "idx": 176}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\npngtest_error(png_structp png_ptr, png_const_charp message)\n{\n   pngtest_warning(png_ptr, message);\n   \n\n\n}\n", "bug_type": null, "idx": 177}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_pool_delete(png_store *ps, store_pool *pool)\n{\n   if (pool->list != NULL)\n   {\n      fprintf(stderr, \"%s: %s %s: memory lost (list follows):\\n\", ps->test,\n         pool == &ps->read_memory_pool ? \"read\" : \"write\",\n         pool == &ps->read_memory_pool ? (ps->current != NULL ?\n            ps->current->name : \"unknown file\") : ps->wname);\n      ++ps->nerrors;\n      do\n      {\n         store_memory *next = pool->list;\n         pool->list = next->next;\n         next->next = NULL;\n         fprintf(stderr, \"\\t%lu bytes @ %p\\n\",\n             (unsigned long)next->size, (PNG_CONST void*)(next+1));\n         \n\n\n         store_memory_free(NULL, pool, next);\n      }\n      while (pool->list != NULL);\n   }\n   \n   if (pool->max > pool->max_max) pool->max_max = pool->max;\n   pool->max = 0;\n   if (pool->current != 0) \n      fprintf(stderr, \"%s: %s %s: memory counter mismatch (internal error)\\n\",\n         ps->test, pool == &ps->read_memory_pool ? \"read\" : \"write\",\n         pool == &ps->read_memory_pool ? (ps->current != NULL ?\n            ps->current->name : \"unknown file\") : ps->wname);\n   pool->current = 0;\n   if (pool->limit > pool->max_limit)\n      pool->max_limit = pool->limit;\n   pool->limit = 0;\n   if (pool->total > pool->max_total)\n      pool->max_total = pool->total;\n   pool->total = 0;\n   \n   store_pool_mark(pool->mark);\n}\n", "bug_type": null, "idx": 178}
{"project": "LibPNG", "target": 0, "func": "static int \nwrite_png(const char **name, FILE *fp, int color_type, int bit_depth,\n   volatile png_fixed_point gamma, chunk_insert * volatile insert,\n   unsigned int filters, unsigned int *colors)\n{\n   png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n      name, makepng_error, makepng_warning);\n   volatile png_infop info_ptr = NULL;\n   volatile png_bytep row = NULL;\n   if (png_ptr == NULL)\n   {\n      fprintf(stderr, \"makepng: OOM allocating write structure\\n\");\n      return 1;\n   }\n   if (setjmp(png_jmpbuf(png_ptr)))\n   {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n      if (row != NULL) free(row);\n      return 1;\n   }\n   \n   png_set_benign_errors(png_ptr, 1);\n   png_init_io(png_ptr, fp);\n   info_ptr = png_create_info_struct(png_ptr);\n   if (info_ptr == NULL)\n      png_error(png_ptr, \"OOM allocating info structure\");\n   {\n      unsigned int size = image_size_of_type(color_type, bit_depth, colors);\n      png_fixed_point real_gamma = 45455; \n      png_byte gamma_table[256];\n      double conv;\n      \n\n\n      if (gamma == PNG_GAMMA_MAC_18)\n         gamma = 65909;\n      else if (gamma > 0 && gamma < 1000)\n         gamma = PNG_FP_1;\n      if (gamma > 0)\n         real_gamma = gamma;\n      {\n         unsigned int i;\n         if (real_gamma == 45455) for (i=0; i<256; ++i)\n         {\n            gamma_table[i] = (png_byte)i;\n            conv = 1.;\n         }\n         else\n         {\n            \n\n\n            conv = real_gamma;\n            conv /= 45455;\n            gamma_table[0] = 0;\n            for (i=1; i<255; ++i)\n               gamma_table[i] = (png_byte)floor(pow(i/255.,conv) * 255 + .5);\n            gamma_table[255] = 255;\n         }\n      }\n      png_set_IHDR(png_ptr, info_ptr, size, size, bit_depth, color_type,\n         PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n      if (color_type & PNG_COLOR_MASK_PALETTE)\n      {\n         int npalette;\n         png_color palette[256];\n         png_byte trans[256];\n         npalette = generate_palette(palette, trans, bit_depth, gamma_table,\n            colors);\n         png_set_PLTE(png_ptr, info_ptr, palette, npalette);\n         png_set_tRNS(png_ptr, info_ptr, trans, npalette-1,\n            NULL);\n         \n         for (npalette=0; npalette<256; ++npalette)\n            gamma_table[npalette] = (png_byte)npalette;\n      }\n      if (gamma == PNG_DEFAULT_sRGB)\n         png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_ABSOLUTE);\n      else if (gamma > 0) \n      {\n         png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma);\n         \n         png_set_cHRM_fixed(png_ptr, info_ptr,\n            \n             31270, 32900,\n             64000, 33000,\n             30000, 60000,\n             15000,  6000\n         );\n      }\n      \n      while (insert != NULL)\n      {\n         insert->insert(png_ptr, info_ptr, insert->nparams, insert->parameters);\n         insert = insert->next;\n      }\n      \n      png_write_info(png_ptr, info_ptr);\n      \n      png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters);\n      {\n         int passes = png_set_interlace_handling(png_ptr);\n         int pass;\n         png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n         row = malloc(rowbytes);\n         if (row == NULL)\n            png_error(png_ptr, \"OOM allocating row buffer\");\n         for (pass = 0; pass < passes; ++pass)\n         {\n            unsigned int y;\n            for (y=0; y<size; ++y)\n            {\n               generate_row(row, rowbytes, y, color_type, bit_depth,\n                  gamma_table, conv, colors);\n               png_write_row(png_ptr, row);\n            }\n         }\n      }\n   }\n   \n   png_write_end(png_ptr, info_ptr);\n   {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n   }\n   free(row);\n   return 0;\n}\n", "bug_type": null, "idx": 179}
{"project": "LibPNG", "target": 0, "func": "static void\nallocbuffer(Image *image)\n{\n   png_size_t size = PNG_IMAGE_BUFFER_SIZE(image->image, image->stride);\n   if (size+32 > image->bufsize)\n   {\n      freebuffer(image);\n      image->buffer = voidcast(png_bytep, malloc(size+32));\n      if (image->buffer == NULL)\n      {\n         fflush(stdout);\n         fprintf(stderr,\n            \"simpletest: out of memory allocating %lu(+32) byte buffer\\n\",\n            (unsigned long)size);\n         exit(1);\n      }\n      image->bufsize = size+32;\n   }\n   memset(image->buffer, 95, image->bufsize);\n   memset(image->buffer+16, BUFFER_INIT8, size);\n   image->allocsize = size;\n}\n", "bug_type": null, "idx": 180}
{"project": "LibPNG", "target": 0, "func": "static int mytime(struct timespec *t)\n{\n   \n   if (!clock_gettime(CLOCK_PROCESS_CPUTIME_ID, t))\n      return 1;\n   perror(\"CLOCK_PROCESS_CPUTIME_ID\");\n   fprintf(stderr, \"timepng: could not get the time\\n\");\n   return 0;\n}\n", "bug_type": null, "idx": 181}
{"project": "LibPNG", "target": 0, "func": "static void\nIDAT_list_init(struct IDAT_list *list)\n{\n   CLEAR(*list);\n   list->next = NULL;\n   list->length = IDAT_INIT_LENGTH;\n}\n", "bug_type": null, "idx": 182}
{"project": "LibPNG", "target": 0, "func": "static unsigned int\nimage_size_of_type(int color_type, int bit_depth, unsigned int *colors)\n{\n   if (*colors)\n      return 16;\n   else\n   {\n      int pixel_depth = pixel_depth_of_type(color_type, bit_depth);\n      if (pixel_depth < 8)\n         return 64;\n      else if (pixel_depth > 16)\n         return 1024;\n      else\n         return 256;\n   }\n}\n", "bug_type": null, "idx": 183}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_pixel_convert_PLTE(image_pixel *this)\n{\n   if (this->colour_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (this->have_tRNS)\n      {\n         this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;\n         this->have_tRNS = 0;\n      }\n      else\n         this->colour_type = PNG_COLOR_TYPE_RGB;\n      \n\n\n      this->bit_depth = 8;\n   }\n}\n", "bug_type": null, "idx": 184}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_ensure_image(png_store *ps, png_const_structp pp, int nImages,\n   png_size_t cbRow, png_uint_32 cRows)\n{\n   png_size_t cb = nImages * cRows * (cbRow + 5);\n   if (ps->cb_image < cb)\n   {\n      png_bytep image;\n      store_image_free(ps, pp);\n      \n      image = voidcast(png_bytep, malloc(cb+2));\n      if (image == NULL)\n      {\n         \n         if (pp == NULL)\n            return;\n         png_error(pp, \"OOM allocating image buffer\");\n      }\n      \n      ++image;\n      image[-1] = 0xed;\n      image[cb] = 0xfe;\n      ps->image = image;\n      ps->cb_image = cb;\n   }\n   \n\n\n\n   ps->cb_row = cbRow;\n   ps->image_h = cRows;\n   \n\n\n\n\n\n   memset(ps->image, 178, cb);\n   \n   while (--nImages >= 0)\n   {\n      png_uint_32 y;\n      for (y=0; y<cRows; ++y)\n      {\n         png_bytep row = store_image_row(ps, pp, nImages, y);\n         \n         row[-2] = 190;\n         row[-1] = 239;\n         row[cbRow] = 222;\n         row[cbRow+1] = 173;\n         row[cbRow+2] = 17;\n      }\n   }\n}\n", "bug_type": null, "idx": 185}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_bgr8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = pp[2];\n   p->g = pp[1];\n   p->b = pp[0];\n   p->a = 255;\n}\n", "bug_type": null, "idx": 186}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace,\n     BOOL alpha)\n{\n  png_struct    *png_ptr = NULL;\n  png_info      *info_ptr = NULL;\n  png_byte      *png_pixels = NULL;\n  png_byte      **row_pointers = NULL;\n  png_byte      *pix_ptr = NULL;\n  volatile png_uint_32   row_bytes;\n  char          type_token[16];\n  char          width_token[16];\n  char          height_token[16];\n  char          maxval_token[16];\n  volatile int           color_type;\n  unsigned long   ul_width=0, ul_alpha_width=0;\n  unsigned long   ul_height=0, ul_alpha_height=0;\n  unsigned long   ul_maxval=0;\n  volatile png_uint_32   width, height;\n  volatile png_uint_32   alpha_width, alpha_height;\n  png_uint_32   maxval;\n  volatile int           bit_depth = 0;\n  int           channels;\n  int           alpha_depth = 0;\n  int           alpha_present;\n  int           row, col;\n  BOOL          raw, alpha_raw = FALSE;\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n  BOOL          packed_bitmap = FALSE;\n#endif\n  png_uint_32   tmp16;\n  int           i;\n  \n  get_token(pnm_file, type_token);\n  if (type_token[0] != 'P')\n  {\n    return FALSE;\n  }\n  else if ((type_token[1] == '1') || (type_token[1] == '4'))\n  {\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n    raw = (type_token[1] == '4');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    bit_depth = 1;\n    packed_bitmap = TRUE;\n#else\n    fprintf (stderr, \"PNM2PNG built without PNG_WRITE_INVERT_SUPPORTED and \\n\");\n    fprintf (stderr, \"PNG_WRITE_PACK_SUPPORTED can't read PBM (P1,P4) files\\n\");\n#endif\n  }\n  else if ((type_token[1] == '2') || (type_token[1] == '5'))\n  {\n    raw = (type_token[1] == '5');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n    if (maxval <= 1)\n      bit_depth = 1;\n    else if (maxval <= 3)\n      bit_depth = 2;\n    else if (maxval <= 15)\n      bit_depth = 4;\n    else if (maxval <= 255)\n      bit_depth = 8;\n    else \n      bit_depth = 16;\n  }\n  else if ((type_token[1] == '3') || (type_token[1] == '6'))\n  {\n    raw = (type_token[1] == '6');\n    color_type = PNG_COLOR_TYPE_RGB;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n    if (maxval <= 1)\n      bit_depth = 1;\n    else if (maxval <= 3)\n      bit_depth = 2;\n    else if (maxval <= 15)\n      bit_depth = 4;\n    else if (maxval <= 255)\n      bit_depth = 8;\n    else \n      bit_depth = 16;\n  }\n  else\n  {\n    return FALSE;\n  }\n  \n  if (alpha)\n  {\n    if (color_type == PNG_COLOR_TYPE_GRAY)\n      color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n    if (color_type == PNG_COLOR_TYPE_RGB)\n      color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    get_token(alpha_file, type_token);\n    if (type_token[0] != 'P')\n    {\n      return FALSE;\n    }\n    else if ((type_token[1] == '2') || (type_token[1] == '5'))\n    {\n      alpha_raw = (type_token[1] == '5');\n      get_token(alpha_file, width_token);\n      sscanf (width_token, \"%lu\", &ul_alpha_width);\n      alpha_width=(png_uint_32) ul_alpha_width;\n      if (alpha_width != width)\n        return FALSE;\n      get_token(alpha_file, height_token);\n      sscanf (height_token, \"%lu\", &ul_alpha_height);\n      alpha_height = (png_uint_32) ul_alpha_height;\n      if (alpha_height != height)\n        return FALSE;\n      get_token(alpha_file, maxval_token);\n      sscanf (maxval_token, \"%lu\", &ul_maxval);\n      maxval = (png_uint_32) ul_maxval;\n      if (maxval <= 1)\n        alpha_depth = 1;\n      else if (maxval <= 3)\n        alpha_depth = 2;\n      else if (maxval <= 15)\n        alpha_depth = 4;\n      else if (maxval <= 255)\n        alpha_depth = 8;\n      else \n        alpha_depth = 16;\n      if (alpha_depth != bit_depth)\n        return FALSE;\n    }\n    else\n    {\n      return FALSE;\n    }\n  } \n  \n  if (color_type == PNG_COLOR_TYPE_GRAY)\n    channels = 1;\n  else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    channels = 2;\n  else if (color_type == PNG_COLOR_TYPE_RGB)\n    channels = 3;\n  else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n    channels = 4;\n  else\n    channels = 0; \n  alpha_present = (channels - 1) % 2;\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n  if (packed_bitmap)\n    \n    row_bytes = (width * channels * bit_depth + 7) / 8;\n  else\n#endif\n    \n    row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2);\n  if ((png_pixels = (png_byte *)\n     malloc (row_bytes * height * sizeof (png_byte))) == NULL)\n    return FALSE;\n  \n  pix_ptr = png_pixels;\n  for (row = 0; row < (int) height; row++)\n  {\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n    if (packed_bitmap) {\n      for (i = 0; i < (int) row_bytes; i++)\n        \n        *pix_ptr++ = get_data (pnm_file, 8);\n    } else\n#endif\n    {\n      for (col = 0; col < (int) width; col++)\n      {\n        for (i = 0; i < (channels - alpha_present); i++)\n        {\n          if (raw)\n            *pix_ptr++ = get_data (pnm_file, bit_depth);\n          else\n            if (bit_depth <= 8)\n              *pix_ptr++ = get_value (pnm_file, bit_depth);\n            else\n            {\n              tmp16 = get_value (pnm_file, bit_depth);\n              *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);\n              pix_ptr++;\n              *pix_ptr = (png_byte) (tmp16 & 0xFF);\n              pix_ptr++;\n            }\n        }\n        if (alpha) \n        {\n          if (alpha_raw)\n            *pix_ptr++ = get_data (alpha_file, alpha_depth);\n          else\n            if (alpha_depth <= 8)\n              *pix_ptr++ = get_value (alpha_file, bit_depth);\n            else\n            {\n              tmp16 = get_value (alpha_file, bit_depth);\n              *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);\n              *pix_ptr++ = (png_byte) (tmp16 & 0xFF);\n            }\n        } \n      } \n    } \n  } \n  \n  png_ptr = png_create_write_struct (png_get_libpng_ver(NULL), NULL, NULL,\n      NULL);\n  if (!png_ptr)\n  {\n    return FALSE;\n  }\n  info_ptr = png_create_info_struct (png_ptr);\n  if (!info_ptr)\n  {\n    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n    return FALSE;\n  }\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n  if (packed_bitmap == TRUE)\n  {\n    png_set_packing (png_ptr);\n    png_set_invert_mono (png_ptr);\n  }\n#endif\n  \n  if (setjmp (png_jmpbuf(png_ptr)))\n  {\n    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n    return FALSE;\n  }\n  \n  png_init_io (png_ptr, png_file);\n  \n  png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type,\n    (!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7,\n    PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n  \n  png_write_info (png_ptr, info_ptr);\n  \n  if (row_pointers == (unsigned char**) NULL)\n  {\n    if ((row_pointers = (png_byte **)\n        malloc (height * sizeof (png_bytep))) == NULL)\n    {\n      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n      return FALSE;\n    }\n  }\n  \n  for (i = 0; i < (int) height; i++)\n    row_pointers[i] = png_pixels + i * row_bytes;\n  \n  png_write_image (png_ptr, row_pointers);\n  \n  png_write_end (png_ptr, info_ptr);\n  \n  png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n  if (row_pointers != (unsigned char**) NULL)\n    free (row_pointers);\n  if (png_pixels != (unsigned char*) NULL)\n    free (png_pixels);\n  return TRUE;\n} \n", "bug_type": null, "idx": 187}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_pool_error(png_store *ps, png_const_structp pp, PNG_CONST char *msg)\n{\n   if (pp != NULL)\n      png_error(pp, msg);\n   \n\n\n\n   store_log(ps, pp, msg, 1 );\n}\n", "bug_type": null, "idx": 188}
{"project": "LibPNG", "target": 0, "func": "static int\nfind_parameters(png_const_charp what, png_charp param, png_charp *list,\n   int nparams)\n{\n   \n\n\n   int i;\n   for (i=0; *param && i<nparams; ++i)\n   {\n      list[i] = param;\n      while (*++param) if (*param == '\\n' || *param == ':')\n      {\n         *param++ = 0; \n         break;        \n      }\n   }\n   if (*param)\n   {\n      fprintf(stderr, \"--insert %s: too many parameters (%s)\\n\", what, param);\n      exit(1);\n   }\n   list[i] = NULL; \n   return i; \n}\n", "bug_type": null, "idx": 189}
{"project": "LibPNG", "target": 0, "func": "static void\ninit_gamma_errors(png_modifier *pm)\n{\n   \n   pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = -1.;\n   pm->error_color_8 = -1.;\n   pm->error_indexed = -1.;\n   pm->error_gray_16 = pm->error_color_16 = -1.;\n}\n", "bug_type": null, "idx": 190}
{"project": "LibPNG", "target": 0, "func": "static size_t\nstore_read_buffer_avail(png_store *ps)\n{\n   if (ps->current != NULL && ps->next != NULL)\n   {\n      png_store_buffer *next = &ps->current->data;\n      size_t cbAvail = ps->current->datacount;\n      while (next != ps->next && next != NULL)\n      {\n         next = next->prev;\n         cbAvail += STORE_BUFFER_SIZE;\n      }\n      if (next != ps->next)\n         png_error(ps->pread, \"buffer read error\");\n      if (cbAvail > ps->readpos)\n         return cbAvail - ps->readpos;\n   }\n   return 0;\n}\n", "bug_type": null, "idx": 191}
{"project": "LibPNG", "target": 0, "func": "} \nstatic void rpng2_x_display_row(ulg row)\n{\n    uch bg_red   = rpng2_info.bg_red;\n    uch bg_green = rpng2_info.bg_green;\n    uch bg_blue  = rpng2_info.bg_blue;\n    uch *src, *src2=NULL;\n    char *dest;\n    uch r, g, b, a;\n    int ximage_rowbytes = ximage->bytes_per_line;\n    ulg i, pixel;\n    static int rows=0, prevpass=(-1);\n    static ulg firstrow;\n\n\n\n\n\n    Trace((stderr, \"beginning rpng2_x_display_row()\\n\"))\n    if (rpng2_info.pass != prevpass) {\n        if (pause_after_pass && rpng2_info.pass > 0) {\n            XEvent e;\n            KeySym k;\n            fprintf(stderr,\n              \"%s:  end of pass %d of 7; click in image window to continue\\n\",\n              PROGNAME, prevpass + 1);\n            do\n                XNextEvent(display, &e);\n            while (!QUIT(e,k));\n        }\n        fprintf(stderr, \"%s:  pass %d of 7\\r\", PROGNAME, rpng2_info.pass + 1);\n        fflush(stderr);\n        prevpass = rpng2_info.pass;\n    }\n    if (rows == 0)\n        firstrow = row;   \n    ++rows;   \n\n\n\n\n\n\n    if (depth == 24 || depth == 32) {\n        ulg red, green, blue;\n        int bpp = ximage->bits_per_pixel;\n        src = rpng2_info.image_data + row*rpng2_info.rowbytes;\n        if (bg_image)\n            src2 = bg_data + row*bg_rowbytes;\n        dest = ximage->data + row*ximage_rowbytes;\n        if (rpng2_info.channels == 3) {\n            for (i = rpng2_info.width;  i > 0;  --i) {\n                red   = *src++;\n                green = *src++;\n                blue  = *src++;\n                pixel = (red   << RShift) |\n                        (green << GShift) |\n                        (blue  << BShift);\n                \n                if (bpp == 32) {\n                    *dest++ = (char)((pixel >> 24) & 0xff);\n                    *dest++ = (char)((pixel >> 16) & 0xff);\n                    *dest++ = (char)((pixel >>  8) & 0xff);\n                    *dest++ = (char)( pixel        & 0xff);\n                } else {\n                    \n                    \n                    *dest++ = (char)((pixel >> 16) & 0xff);\n                    *dest++ = (char)((pixel >>  8) & 0xff);\n                    *dest++ = (char)( pixel        & 0xff);\n                }\n            }\n        } else  {\n            for (i = rpng2_info.width;  i > 0;  --i) {\n                r = *src++;\n                g = *src++;\n                b = *src++;\n                a = *src++;\n                if (bg_image) {\n                    bg_red   = *src2++;\n                    bg_green = *src2++;\n                    bg_blue  = *src2++;\n                }\n                if (a == 255) {\n                    red   = r;\n                    green = g;\n                    blue  = b;\n                } else if (a == 0) {\n                    red   = bg_red;\n                    green = bg_green;\n                    blue  = bg_blue;\n                } else {\n                    \n\n\n                    alpha_composite(red,   r, a, bg_red);\n                    alpha_composite(green, g, a, bg_green);\n                    alpha_composite(blue,  b, a, bg_blue);\n                }\n                pixel = (red   << RShift) |\n                        (green << GShift) |\n                        (blue  << BShift);\n                \n                if (bpp == 32) {\n                    *dest++ = (char)((pixel >> 24) & 0xff);\n                    *dest++ = (char)((pixel >> 16) & 0xff);\n                    *dest++ = (char)((pixel >>  8) & 0xff);\n                    *dest++ = (char)( pixel        & 0xff);\n                } else {\n                    \n                    \n                    *dest++ = (char)((pixel >> 16) & 0xff);\n                    *dest++ = (char)((pixel >>  8) & 0xff);\n                    *dest++ = (char)( pixel        & 0xff);\n                }\n            }\n        }\n    } else if (depth == 16) {\n        ush red, green, blue;\n        src = rpng2_info.row_pointers[row];\n        if (bg_image)\n            src2 = bg_data + row*bg_rowbytes;\n        dest = ximage->data + row*ximage_rowbytes;\n        if (rpng2_info.channels == 3) {\n            for (i = rpng2_info.width;  i > 0;  --i) {\n                red   = ((ush)(*src) << 8);\n                ++src;\n                green = ((ush)(*src) << 8);\n                ++src;\n                blue  = ((ush)(*src) << 8);\n                ++src;\n                pixel = ((red   >> RShift) & RMask) |\n                        ((green >> GShift) & GMask) |\n                        ((blue  >> BShift) & BMask);\n                \n                *dest++ = (char)((pixel >>  8) & 0xff);\n                *dest++ = (char)( pixel        & 0xff);\n            }\n        } else  {\n            for (i = rpng2_info.width;  i > 0;  --i) {\n                r = *src++;\n                g = *src++;\n                b = *src++;\n                a = *src++;\n                if (bg_image) {\n                    bg_red   = *src2++;\n                    bg_green = *src2++;\n                    bg_blue  = *src2++;\n                }\n                if (a == 255) {\n                    red   = ((ush)r << 8);\n                    green = ((ush)g << 8);\n                    blue  = ((ush)b << 8);\n                } else if (a == 0) {\n                    red   = ((ush)bg_red   << 8);\n                    green = ((ush)bg_green << 8);\n                    blue  = ((ush)bg_blue  << 8);\n                } else {\n                    \n\n\n                    alpha_composite(r, r, a, bg_red);\n                    alpha_composite(g, g, a, bg_green);\n                    alpha_composite(b, b, a, bg_blue);\n                    red   = ((ush)r << 8);\n                    green = ((ush)g << 8);\n                    blue  = ((ush)b << 8);\n                }\n                pixel = ((red   >> RShift) & RMask) |\n                        ((green >> GShift) & GMask) |\n                        ((blue  >> BShift) & BMask);\n                \n                *dest++ = (char)((pixel >>  8) & 0xff);\n                *dest++ = (char)( pixel        & 0xff);\n            }\n        }\n    } else  {\n        \n    }\n\n\n\n\n\n\n\n    if (demo_timing && (row - firstrow >= 16 || row >= rpng2_info.height-2)) {\n        XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0,\n          (int)firstrow, rpng2_info.width, row - firstrow + 1);\n        XFlush(display);\n        rows = 0;\n        usleep(usleep_duration);\n    } else\n    if (!demo_timing && ((rows & 0xf) == 0 || row >= rpng2_info.height-2)) {\n        XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0,\n          (int)firstrow, rpng2_info.width, row - firstrow + 1);\n        XFlush(display);\n        rows = 0;\n    }\n}\n", "bug_type": null, "idx": 192}
{"project": "LibPNG", "target": 0, "func": "static size_t\nstore_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize,\n   size_t pos, PNG_CONST char *msg)\n{\n   if (pp != NULL && pp == ps->pread)\n   {\n      \n      pos = safecat(buffer, bufsize, pos, \"read: \");\n      if (ps->current != NULL)\n      {\n         pos = safecat(buffer, bufsize, pos, ps->current->name);\n         pos = safecat(buffer, bufsize, pos, sep);\n      }\n   }\n   else if (pp != NULL && pp == ps->pwrite)\n   {\n      \n      pos = safecat(buffer, bufsize, pos, \"write: \");\n      pos = safecat(buffer, bufsize, pos, ps->wname);\n      pos = safecat(buffer, bufsize, pos, sep);\n   }\n   else\n   {\n      \n      pos = safecat(buffer, bufsize, pos, \"pngvalid: \");\n   }\n   if (ps->test[0] != 0)\n   {\n      pos = safecat(buffer, bufsize, pos, ps->test);\n      pos = safecat(buffer, bufsize, pos, sep);\n   }\n   pos = safecat(buffer, bufsize, pos, msg);\n   return pos;\n}\n", "bug_type": null, "idx": 193}
{"project": "LibPNG", "target": 1, "func": "\nvoid\npng_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   int num, i;\n\n   png_debug(1, \"in png_handle_hIST\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before hIST\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid hIST after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (!(png_ptr->mode & PNG_HAVE_PLTE))\n   {\n      png_warning(png_ptr, \"Missing PLTE before hIST\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_hIST)\n   {\n      png_warning(png_ptr, \"Duplicate hIST chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != (png_uint_32)(2 * png_ptr->num_palette))\n   {\n      png_warning(png_ptr, \"Incorrect hIST chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   num = (int)length / 2;\n   png_ptr->hist = (png_uint_16p)png_malloc(png_ptr,\n      (png_uint_32)(num * sizeof (png_uint_16)));\n   png_ptr->flags |= PNG_FLAG_FREE_HIST;\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->hist[i] = png_get_uint_16(buf);\n   }\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   png_set_hIST(png_ptr, info_ptr, png_ptr->hist);\n}\n#endif", "bug_type": "cve-2004-0597-3", "idx": 194}
{"project": "LibPNG", "target": 0, "func": "static int perform_one_test(FILE *fp, int nfiles)\n{\n   int i;\n   struct timespec before, after;\n   \n   rewind(fp);\n   if (mytime(&before))\n   {\n      for (i=0; i<nfiles; ++i)\n      {\n         if (read_png(fp))\n         {\n            if (ferror(fp))\n            {\n               perror(\"temporary file\");\n               fprintf(stderr, \"file %d: error reading PNG data\\n\", i);\n               return 0;\n            }\n         }\n         else\n         {\n            perror(\"temporary file\");\n            fprintf(stderr, \"file %d: error from libpng\\n\", i);\n            return 0;\n         }\n      }\n   }\n   else\n      return 0;\n   if (mytime(&after))\n   {\n      \n\n\n      unsigned long s = after.tv_sec - before.tv_sec;\n      long ns = after.tv_nsec - before.tv_nsec;\n      if (ns < 0)\n      {\n         --s;\n         ns += 1000000000;\n         if (ns < 0)\n         {\n            fprintf(stderr, \"timepng: bad clock from kernel\\n\");\n            return 0;\n         }\n      }\n      printf(\"%lu.%.9ld\\n\", s, ns);\n      fflush(stdout);\n      if (ferror(stdout))\n      {\n         fprintf(stderr, \"timepng: error writing output\\n\");\n         return 0;\n      }\n      \n      return 1;\n   }\n   else\n      return 0;\n}\n", "bug_type": null, "idx": 195}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_test(png_modifier *pmIn, PNG_CONST png_uint_32 idIn,\n    PNG_CONST image_transform* transform_listIn, PNG_CONST char * volatile name)\n{\n   transform_display d;\n   context(&pmIn->this, fault);\n   transform_display_init(&d, pmIn, idIn, transform_listIn);\n   Try\n   {\n      size_t pos = 0;\n      png_structp pp;\n      png_infop pi;\n      char full_name[256];\n      \n\n\n      transform_set_encoding(&d);\n      \n      d.transform_list->ini(d.transform_list, &d);\n      \n      pos = safecat(full_name, sizeof full_name, pos, name);\n      pos = safecat_current_encoding(full_name, sizeof full_name, pos, d.pm);\n      \n      pp = set_modifier_for_read(d.pm, &pi, d.this.id, full_name);\n      standard_palette_init(&d.this);\n#     if 0\n         \n         {\n            char buffer[256];\n            (void)store_message(&d.pm->this, pp, buffer, sizeof buffer, 0,\n               \"running test\");\n            fprintf(stderr, \"%s\\n\", buffer);\n         }\n#     endif\n      \n      if (d.pm->this.progressive)\n      {\n         \n         png_set_progressive_read_fn(pp, &d, transform_info, progressive_row,\n            transform_end);\n         \n         modifier_progressive_read(d.pm, pp, pi);\n      }\n      else\n      {\n         \n         png_set_read_fn(pp, d.pm, modifier_read);\n         \n         png_read_info(pp, pi);\n         \n         transform_info_imp(&d, pp, pi);\n         sequential_row(&d.this, pp, pi, -1, 0);\n         if (!d.this.speed)\n            transform_image_validate(&d, pp, pi);\n         else\n            d.this.ps->validated = 1;\n      }\n      modifier_reset(d.pm);\n   }\n   Catch(fault)\n   {\n      modifier_reset(voidcast(png_modifier*,(void*)fault));\n   }\n}\n", "bug_type": null, "idx": 196}
{"project": "LibPNG", "target": 0, "func": "static void\nprint_pixel(char string[64], const Pixel *pixel, png_uint_32 format)\n{\n   switch (format & (PNG_FORMAT_FLAG_ALPHA|PNG_FORMAT_FLAG_COLOR))\n   {\n      case 0:\n         sprintf(string, \"%s(%d)\", format_names[format], pixel->g);\n         break;\n      case PNG_FORMAT_FLAG_ALPHA:\n         sprintf(string, \"%s(%d,%d)\", format_names[format], pixel->g,\n            pixel->a);\n         break;\n      case PNG_FORMAT_FLAG_COLOR:\n         sprintf(string, \"%s(%d,%d,%d)\", format_names[format],\n            pixel->r, pixel->g, pixel->b);\n         break;\n      case PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA:\n         sprintf(string, \"%s(%d,%d,%d,%d)\", format_names[format],\n            pixel->r, pixel->g, pixel->b, pixel->a);\n         break;\n      default:\n         sprintf(string, \"invalid-format\");\n         break;\n   }\n}\n", "bug_type": null, "idx": 197}
{"project": "LibPNG", "target": 0, "func": "double\nsRGB(unsigned int i)\n{\n   return fsRGB(i);\n}\ndouble\nfinvsRGB(unsigned int i)\n{\n   return 65535 * linear_from_sRGB(i/255.);\n}\npng_uint_16\ninvsRGB(unsigned int i)\n{\n   unsigned int x = nearbyint(finvsRGB(i));\n   if (x > 65535)\n   {\n      fprintf(stderr, \"invsRGB(%u) overflows to %u\\n\", i, x);\n      exit(1);\n   }\n   return (png_uint_16)x;\n}\n", "bug_type": null, "idx": 198}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL LoadImageFile (HWND hwnd, PTSTR pstrPathName,\n                png_byte **ppbImage, int *pxImgSize, int *pyImgSize,\n                int *piChannels, png_color *pBkgColor)\n{\n    static TCHAR szTmp [MAX_PATH];\n    \n    if (*ppbImage)\n    {\n        free (*ppbImage);\n        *ppbImage = NULL;\n    }\n    \n    SetCursor (LoadCursor (NULL, IDC_WAIT));\n    ShowCursor (TRUE);\n    PngLoadImage (pstrPathName, ppbImage, pxImgSize, pyImgSize, piChannels,\n                  pBkgColor);\n    ShowCursor (FALSE);\n    SetCursor (LoadCursor (NULL, IDC_ARROW));\n    if (*ppbImage != NULL)\n    {\n        sprintf (szTmp, \"VisualPng - %s\", strrchr(pstrPathName, '\\\\') + 1);\n        SetWindowText (hwnd, szTmp);\n    }\n    else\n    {\n        MessageBox (hwnd, TEXT (\"Error in loading the PNG image\"),\n            szProgName, MB_ICONEXCLAMATION | MB_OK);\n        return FALSE;\n    }\n    return TRUE;\n}\n */\nBOOL LoadImageFile (HWND hwnd, PTSTR pstrPathName,\n                png_byte **ppbImage, int *pxImgSize, int *pyImgSize,\n                int *piChannels, png_color *pBkgColor)\n{\n    static TCHAR szTmp [MAX_PATH];\n    \n    if (*ppbImage)\n    {\n        free (*ppbImage);\n        *ppbImage = NULL;\n    }\n", "bug_type": null, "idx": 199}
{"project": "LibPNG", "target": 0, "func": "static size_t\nstore_read_buffer_size(png_store *ps)\n{\n   \n   if (ps->next != &ps->current->data)\n      return STORE_BUFFER_SIZE;\n   return ps->current->datacount;\n}\n", "bug_type": null, "idx": 200}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_tRNS_to_alpha_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(bit_depth)\n   this->next = *that;\n   *that = this;\n   \n\n\n\n   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;\n}\n", "bug_type": null, "idx": 201}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_row_validate(standard_display *dp, png_const_structp pp,\n   int iImage, int iDisplay, png_uint_32 y)\n{\n   int where;\n   png_byte std[STANDARD_ROWMAX];\n   \n\n\n   memset(std, 178, sizeof std);\n   standard_row(pp, std, dp->id, y);\n   \n\n\n\n\n\n\n\n\n\n\n\n\n   if (iImage >= 0 &&\n      (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),\n            dp->bit_width)) != 0)\n   {\n      char msg[64];\n      sprintf(msg, \"PNG image row[%lu][%d] changed from %.2x to %.2x\",\n         (unsigned long)y, where-1, std[where-1],\n         store_image_row(dp->ps, pp, iImage, y)[where-1]);\n      png_error(pp, msg);\n   }\n#if PNG_LIBPNG_VER < 10506\n   \n\n\n\n\n#endif\n   if (iDisplay >= 0 &&\n      (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),\n         dp->bit_width)) != 0)\n   {\n      char msg[64];\n      sprintf(msg, \"display  row[%lu][%d] changed from %.2x to %.2x\",\n         (unsigned long)y, where-1, std[where-1],\n         store_image_row(dp->ps, pp, iDisplay, y)[where-1]);\n      png_error(pp, msg);\n   }\n}\n", "bug_type": null, "idx": 202}
{"project": "LibPNG", "target": 0, "func": "static int\nread_palette(store_palette palette, int *npalette, png_const_structp pp,\n   png_infop pi)\n{\n   png_colorp pal;\n   png_bytep trans_alpha;\n   int num;\n   pal = 0;\n   *npalette = -1;\n   if (png_get_PLTE(pp, pi, &pal, npalette) & PNG_INFO_PLTE)\n   {\n      int i = *npalette;\n      if (i <= 0 || i > 256)\n         png_error(pp, \"validate: invalid PLTE count\");\n      while (--i >= 0)\n      {\n         palette[i].red = pal[i].red;\n         palette[i].green = pal[i].green;\n         palette[i].blue = pal[i].blue;\n      }\n      \n\n\n      memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette);\n   }\n   else \n   {\n      if (*npalette != (-1))\n         png_error(pp, \"validate: invalid PLTE result\");\n      \n      *npalette = 0;\n      memset(palette, 113, sizeof (store_palette));\n   }\n   trans_alpha = 0;\n   num = 2; \n   if ((png_get_tRNS(pp, pi, &trans_alpha, &num, 0) & PNG_INFO_tRNS) != 0 &&\n      (trans_alpha != NULL || num != 1) &&\n      \n\n\n\n\n      !(trans_alpha != NULL && num == 0)) \n   {\n      int i;\n      \n\n\n\n\n\n      if (trans_alpha == NULL || num <= 0 || num > 256 || num > *npalette)\n         png_error(pp, \"validate: unexpected png_get_tRNS (palette) result\");\n      for (i=0; i<num; ++i)\n         palette[i].alpha = trans_alpha[i];\n      for (num=*npalette; i<num; ++i)\n         palette[i].alpha = 255;\n      for (; i<256; ++i)\n         palette[i].alpha = 33; \n      return 1; \n   }\n   else\n   {\n      \n      int i;\n      for (i=0, num=*npalette; i<num; ++i)\n         palette[i].alpha = 255;\n      for (; i<256; ++i)\n         palette[i].alpha = 55; \n      return 0; \n   }\n}\n", "bug_type": null, "idx": 203}
{"project": "LibPNG", "target": 0, "func": "BOOL PngFileSaveDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName)\n{\n    ofn.hwndOwner         = hwnd;\n    ofn.lpstrFile         = pstrFileName;\n    ofn.lpstrFileTitle    = pstrTitleName;\n    ofn.Flags             = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;\n    return GetSaveFileName (&ofn);\n}\n", "bug_type": null, "idx": 204}
{"project": "LibPNG", "target": 0, "func": "\nint readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight)\n{\n    uch sig[8];\n    \n\n    fread(sig, 1, 8, infile);\n    if (png_sig_cmp(sig, 0, 8))\n        return 1;   \n    \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    if (!png_ptr)\n        return 4;   \n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return 4;   \n    }\n    \n\n\n    \n\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return 2;\n    }\n    png_init_io(png_ptr, infile);\n    png_set_sig_bytes(png_ptr, 8);  \n    png_read_info(png_ptr, info_ptr);  \n    \n\n\n    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\n      NULL, NULL, NULL);\n    *pWidth = width;\n    *pHeight = height;\n    \n    return 0;\n}\n", "bug_type": null, "idx": 205}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\npng_pass_rows(png_uint_32 height, int pass)\n{\n   png_uint_32 tiles = height>>3;\n   png_uint_32 rows = 0;\n   unsigned int x, y;\n   height &= 7;\n   ++pass;\n   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)\n   {\n      rows += tiles;\n      if (y < height) ++rows;\n      break; \n   }\n   return rows;\n}\n", "bug_type": null, "idx": 206}
{"project": "LibPNG", "target": 0, "func": "static int\nsbit_modify(png_modifier *pm, png_modification *me, int add)\n{\n   png_byte sbit = ((sbit_modification*)me)->sbit;\n   if (pm->bit_depth > sbit)\n   {\n      int cb = 0;\n      switch (pm->colour_type)\n      {\n         case 0:\n            cb = 1;\n            break;\n         case 2:\n         case 3:\n            cb = 3;\n            break;\n         case 4:\n            cb = 2;\n            break;\n         case 6:\n            cb = 4;\n            break;\n         default:\n            png_error(pm->this.pread,\n               \"unexpected colour type in sBIT modification\");\n      }\n      png_save_uint_32(pm->buffer, cb);\n      png_save_uint_32(pm->buffer+4, CHUNK_sBIT);\n      while (cb > 0)\n         (pm->buffer+8)[--cb] = sbit;\n      return 1;\n   }\n   else if (!add)\n   {\n      \n      pm->buffer_count = pm->buffer_position = 0;\n      return 1;\n   }\n   else\n      return 0; \n}\n", "bug_type": null, "idx": 207}
{"project": "LibPNG", "target": 0, "func": "static int\npng_have_neon(png_structp png_ptr)\n{\n   \n\n\n\n   PNG_UNUSED(png_ptr)\n   return android_getCpuFamily() == ANDROID_CPU_FAMILY_ARM &&\n      (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) != 0;\n}\n", "bug_type": null, "idx": 208}
{"project": "LibPNG", "target": 0, "func": "static double\nYfromRGBint(int ir, int ig, int ib)\n{\n   double r = ir;\n   double g = ig;\n   double b = ib;\n   return YfromRGB(r, g, b);\n}\n", "bug_type": null, "idx": 209}
{"project": "LibPNG", "target": 0, "func": "   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\nstatic void gamma_composition_test(png_modifier *pm,\n   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,\n   PNG_CONST int palette_number,\n   PNG_CONST int interlace_type, PNG_CONST double file_gamma,\n   PNG_CONST double screen_gamma,\n   PNG_CONST int use_input_precision, PNG_CONST int do_background,\n   PNG_CONST int expand_16)\n{\n   size_t pos = 0;\n   png_const_charp base;\n   double bg;\n   char name[128];\n   png_color_16 background;\n   \n   switch (do_background)\n   {\n      default:\n         base = \"\";\n         bg = 4; \n         break;\n      case PNG_BACKGROUND_GAMMA_SCREEN:\n         base = \" bckg(Screen):\";\n         bg = 1/screen_gamma;\n         break;\n      case PNG_BACKGROUND_GAMMA_FILE:\n         base = \" bckg(File):\";\n         bg = file_gamma;\n         break;\n      case PNG_BACKGROUND_GAMMA_UNIQUE:\n         base = \" bckg(Unique):\";\n         \n\n\n\n         bg = (file_gamma + screen_gamma) / 3;\n         break;\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n      case ALPHA_MODE_OFFSET + PNG_ALPHA_PNG:\n         base = \" alpha(PNG)\";\n         bg = 4; \n         break;\n      case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:\n         base = \" alpha(Porter-Duff)\";\n         bg = 4; \n         break;\n      case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:\n         base = \" alpha(Optimized)\";\n         bg = 4; \n         break;\n      case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:\n         base = \" alpha(Broken)\";\n         bg = 4; \n         break;\n#endif\n   }\n   \n\n\n   if (expand_16 || bit_depth == 16)\n   {\n      png_uint_32 r = random_32();\n      background.red = (png_uint_16)r;\n      background.green = (png_uint_16)(r >> 16);\n      r = random_32();\n      background.blue = (png_uint_16)r;\n      background.gray = (png_uint_16)(r >> 16);\n      \n\n\n\n\n\n#     if DIGITIZE\n         if (expand_16 && (do_background == PNG_BACKGROUND_GAMMA_UNIQUE ||\n                           do_background == PNG_BACKGROUND_GAMMA_FILE) &&\n            fabs(bg*screen_gamma-1) > PNG_GAMMA_THRESHOLD)\n         {\n            \n\n\n\n            background.red = (png_uint_16)((background.red >> 8) * 257);\n            background.green = (png_uint_16)((background.green >> 8) * 257);\n            background.blue = (png_uint_16)((background.blue >> 8) * 257);\n            background.gray = (png_uint_16)((background.gray >> 8) * 257);\n         }\n#     endif\n   }\n   else \n   {\n      png_uint_32 r = random_32();\n      background.red = (png_byte)r;\n      background.green = (png_byte)(r >> 8);\n      background.blue = (png_byte)(r >> 16);\n      background.gray = (png_byte)(r >> 24);\n   }\n   background.index = 193; \n   if (!(colour_type & PNG_COLOR_MASK_COLOR))\n   {\n      \n\n\n      background.red = background.green = background.blue = background.gray;\n   }\n   pos = safecat(name, sizeof name, pos, \"gamma \");\n   pos = safecatd(name, sizeof name, pos, file_gamma, 3);\n   pos = safecat(name, sizeof name, pos, \"->\");\n   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);\n   pos = safecat(name, sizeof name, pos, base);\n   if (do_background < ALPHA_MODE_OFFSET)\n   {\n      \n      pos = safecat(name, sizeof name, pos, \"(\");\n      \n\n      if (colour_type & PNG_COLOR_MASK_COLOR)\n      {\n         pos = safecatn(name, sizeof name, pos, background.red);\n         pos = safecat(name, sizeof name, pos, \",\");\n         pos = safecatn(name, sizeof name, pos, background.green);\n         pos = safecat(name, sizeof name, pos, \",\");\n         pos = safecatn(name, sizeof name, pos, background.blue);\n      }\n      else\n         pos = safecatn(name, sizeof name, pos, background.gray);\n      pos = safecat(name, sizeof name, pos, \")^\");\n      pos = safecatd(name, sizeof name, pos, bg, 3);\n   }\n   gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,\n      file_gamma, screen_gamma, 0, 0, name, use_input_precision,\n      0, expand_16, do_background, &background, bg);\n}\n", "bug_type": null, "idx": 210}
{"project": "LibPNG", "target": 0, "func": "void PNGCBAPI\ncount_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data)\n{\n   png_bytep dp = data;\n   if (png_ptr == NULL)\n      return;\n   \n\n\n\n\n\n\n\n    \n    if (row_info->color_type == 0 || row_info->color_type == 3)\n    {\n       int pos = 0;\n       png_uint_32 n, nstop;\n       for (n = 0, nstop=row_info->width; n<nstop; n++)\n       {\n          if (row_info->bit_depth == 1)\n          {\n             if (((*dp << pos++ ) & 0x80) == 0)\n                zero_samples++;\n             if (pos == 8)\n             {\n                pos = 0;\n                dp++;\n             }\n          }\n          if (row_info->bit_depth == 2)\n          {\n             if (((*dp << (pos+=2)) & 0xc0) == 0)\n                zero_samples++;\n             if (pos == 8)\n             {\n                pos = 0;\n                dp++;\n             }\n          }\n          if (row_info->bit_depth == 4)\n          {\n             if (((*dp << (pos+=4)) & 0xf0) == 0)\n                zero_samples++;\n             if (pos == 8)\n             {\n                pos = 0;\n                dp++;\n             }\n          }\n          if (row_info->bit_depth == 8)\n             if (*dp++ == 0)\n                zero_samples++;\n          if (row_info->bit_depth == 16)\n          {\n             if ((*dp | *(dp+1)) == 0)\n                zero_samples++;\n             dp+=2;\n          }\n       }\n    }\n    else \n    {\n       png_uint_32 n, nstop;\n       int channel;\n       int color_channels = row_info->channels;\n       if (row_info->color_type > 3)color_channels--;\n       for (n = 0, nstop=row_info->width; n<nstop; n++)\n       {\n          for (channel = 0; channel < color_channels; channel++)\n          {\n             if (row_info->bit_depth == 8)\n                if (*dp++ == 0)\n                   zero_samples++;\n             if (row_info->bit_depth == 16)\n             {\n                if ((*dp | *(dp+1)) == 0)\n                   zero_samples++;\n                dp+=2;\n             }\n          }\n          if (row_info->color_type > 3)\n          {\n             dp++;\n             if (row_info->bit_depth == 16)\n                dp++;\n          }\n       }\n    }\n}\n", "bug_type": null, "idx": 211}
{"project": "LibPNG", "target": 0, "func": "static int rpng2_win_create_window()\n{\n    uch bg_red   = rpng2_info.bg_red;\n    uch bg_green = rpng2_info.bg_green;\n    uch bg_blue  = rpng2_info.bg_blue;\n    uch *dest;\n    int extra_width, extra_height;\n    ulg i, j;\n    WNDCLASSEX wndclass;\n    RECT rect;\n\n\n\n\n    wimage_rowbytes = ((3*rpng2_info.width + 3L) >> 2) << 2;\n    if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) +\n                              wimage_rowbytes*rpng2_info.height)))\n    {\n        return 4;   \n    }\n\n\n\n\n\n\n    memset(dib, 0, sizeof(BITMAPINFOHEADER));\n    bmih = (BITMAPINFOHEADER *)dib;\n    bmih->biSize = sizeof(BITMAPINFOHEADER);\n    bmih->biWidth = rpng2_info.width;\n    bmih->biHeight = -((long)rpng2_info.height);\n    bmih->biPlanes = 1;\n    bmih->biBitCount = 24;\n    bmih->biCompression = 0;\n    wimage_data = dib + sizeof(BITMAPINFOHEADER);\n\n\n\n\n\n    if (bg_image) {   \n        memset(wimage_data, 0, wimage_rowbytes*rpng2_info.height);\n    } else {\n        for (j = 0;  j < rpng2_info.height;  ++j) {\n            dest = wimage_data + j*wimage_rowbytes;\n            for (i = rpng2_info.width;  i > 0;  --i) {\n                *dest++ = bg_blue;\n                *dest++ = bg_green;\n                *dest++ = bg_red;\n            }\n        }\n    }\n\n\n\n    memset(&wndclass, 0, sizeof(wndclass));\n    wndclass.cbSize = sizeof(wndclass);\n    wndclass.style = CS_HREDRAW | CS_VREDRAW;\n    wndclass.lpfnWndProc = rpng2_win_wndproc;\n    wndclass.hInstance = global_hInst;\n    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);\n    wndclass.lpszMenuName = NULL;\n    wndclass.lpszClassName = progname;\n    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n    RegisterClassEx(&wndclass);\n\n\n\n    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +\n                      GetSystemMetrics(SM_CXDLGFRAME));\n    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +\n                      GetSystemMetrics(SM_CYDLGFRAME)) +\n                      GetSystemMetrics(SM_CYCAPTION);\n    global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW,\n      CW_USEDEFAULT, CW_USEDEFAULT, rpng2_info.width+extra_width,\n      rpng2_info.height+extra_height, NULL, NULL, global_hInst, NULL);\n    ShowWindow(global_hwnd, global_showmode);\n    UpdateWindow(global_hwnd);\n\n\n\n\n    if (bg_image) {\n        static const char *msg = \"Computing background image...\";\n        int x, y, len = strlen(msg);\n        HDC hdc = GetDC(global_hwnd);\n        TEXTMETRIC tm;\n        GetTextMetrics(hdc, &tm);\n        x = (rpng2_info.width - len*tm.tmAveCharWidth)/2;\n        y = (rpng2_info.height - tm.tmHeight)/2;\n        SetBkMode(hdc, TRANSPARENT);\n        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));\n        \n        TextOut(hdc, ((x < 0)? 0 : x), ((y < 0)? 0 : y), msg, len);\n        ReleaseDC(global_hwnd, hdc);\n        rpng2_win_load_bg_image();   \n    }\n    if (!bg_image) {\n        for (j = 0;  j < rpng2_info.height;  ++j) {\n            dest = wimage_data + j*wimage_rowbytes;\n            for (i = rpng2_info.width;  i > 0;  --i) {\n                *dest++ = bg_blue;\n                *dest++ = bg_green;\n                *dest++ = bg_red;\n            }\n        }\n    }\n    rect.left = 0L;\n    rect.top = 0L;\n    rect.right = (LONG)rpng2_info.width;       \n    rect.bottom = (LONG)rpng2_info.height;     \n    InvalidateRect(global_hwnd, &rect, FALSE);\n    UpdateWindow(global_hwnd);                 \n    return 0;\n} \n", "bug_type": null, "idx": 212}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_read_IDAT_data(png_structrp png_ptr, png_bytep output,\n   png_alloc_size_t avail_out)\n{\n   \n   png_ptr->zstream.next_out = output;\n   png_ptr->zstream.avail_out = 0; \n\n   if (output == NULL)\n      avail_out = 0;\n\n   do\n   {\n      int ret;\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\n\n      if (png_ptr->zstream.avail_in == 0)\n      {\n         uInt avail_in;\n         png_bytep buffer;\n\n         while (png_ptr->idat_size == 0)\n         {\n            png_crc_finish(png_ptr, 0);\n\n            png_ptr->idat_size = png_read_chunk_header(png_ptr);\n            \n\n\n            if (png_ptr->chunk_name != png_IDAT)\n               png_error(png_ptr, \"Not enough image data\");\n         }\n\n         avail_in = png_ptr->IDAT_read_size;\n\n         if (avail_in > png_ptr->idat_size)\n            avail_in = (uInt)png_ptr->idat_size;\n\n         \n\n\n\n\n         buffer = png_read_buffer(png_ptr, avail_in, 0);\n\n         png_crc_read(png_ptr, buffer, avail_in);\n         png_ptr->idat_size -= avail_in;\n\n         png_ptr->zstream.next_in = buffer;\n         png_ptr->zstream.avail_in = avail_in;\n      }\n\n      \n      if (output != NULL) \n      {\n         uInt out = ZLIB_IO_MAX;\n\n         if (out > avail_out)\n            out = (uInt)avail_out;\n\n         avail_out -= out;\n         png_ptr->zstream.avail_out = out;\n      }\n\n      else \n      {\n         png_ptr->zstream.next_out = tmpbuf;\n         png_ptr->zstream.avail_out = (sizeof tmpbuf);\n      }\n\n      \n\n\n\n\n\n\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\n\n      \n      if (output != NULL)\n         avail_out += png_ptr->zstream.avail_out;\n\n      else \n         avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;\n\n      png_ptr->zstream.avail_out = 0;\n\n      if (ret == Z_STREAM_END)\n      {\n         \n         png_ptr->zstream.next_out = NULL;\n\n         png_ptr->mode |= PNG_AFTER_IDAT;\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\n\n         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)\n            png_chunk_benign_error(png_ptr, \"Extra compressed data\");\n         break;\n      }\n\n      if (ret != Z_OK)\n      {\n         png_zstream_error(png_ptr, ret);\n\n         if (output != NULL)\n            png_chunk_error(png_ptr, png_ptr->zstream.msg);\n\n         else \n         {\n            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);\n            return;\n         }\n      }\n   } while (avail_out > 0);\n\n   if (avail_out > 0)\n   {\n      \n\n\n      if (output != NULL)\n         png_error(png_ptr, \"Not enough image data\");\n\n      else \n         png_chunk_benign_error(png_ptr, \"Too much image data\");\n   }\n}", "bug_type": "cve-2015-0973", "idx": 213}
{"project": "LibPNG", "target": 0, "func": "static void\nwrite_png(struct display *dp, png_infop ip, int transforms)\n{\n   display_clean_write(dp); \n   buffer_start_write(&dp->written_file);\n   dp->operation = \"write\";\n   dp->transforms = transforms;\n   dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,\n      display_error, display_warning);\n   if (dp->write_pp == NULL)\n      display_log(dp, APP_ERROR, \"failed to create write png_struct\");\n   png_set_write_fn(dp->write_pp, &dp->written_file, write_function,\n      NULL);\n#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\n      \n      png_set_user_limits(dp->write_pp, 0x7fffffff, 0x7fffffff);\n#  endif\n   \n\n\n   if (transforms & (PNG_TRANSFORM_PACKING|\n                     PNG_TRANSFORM_STRIP_FILLER|\n                     PNG_TRANSFORM_STRIP_FILLER_BEFORE))\n   {\n      int ct = dp->color_type;\n      if (transforms & (PNG_TRANSFORM_STRIP_FILLER|\n                        PNG_TRANSFORM_STRIP_FILLER_BEFORE))\n         ct &= ~PNG_COLOR_MASK_ALPHA;\n      png_set_IHDR(dp->write_pp, ip, dp->width, dp->height, dp->bit_depth, ct,\n         dp->interlace_method, dp->compression_method, dp->filter_method);\n   }\n   png_write_png(dp->write_pp, ip, transforms, NULL);\n   \n\n\n   display_clean_write(dp);\n}\n", "bug_type": null, "idx": 214}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_set_end(PNG_CONST image_transform *this,\n   transform_display *that, png_structp pp, png_infop pi)\n{\n   UNUSED(this)\n   UNUSED(that)\n   UNUSED(pp)\n   UNUSED(pi)\n}\n", "bug_type": null, "idx": 215}
{"project": "LibPNG", "target": 0, "func": "static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr)\n{\n    mainprog_info  *mainprog_ptr;\n    int  color_type, bit_depth;\n    png_uint_32 width, height;\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n    double  gamma;\n#else\n    png_fixed_point gamma;\n#endif\n    \n\n\n\n\n    \n\n\n\n\n    mainprog_ptr = png_get_progressive_ptr(png_ptr);\n    if (mainprog_ptr == NULL) {         \n        fprintf(stderr,\n          \"readpng2 error:  main struct not recoverable in info_callback.\\n\");\n        fflush(stderr);\n        return;\n        \n\n\n\n\n\n\n    }\n    \n    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\n       NULL, NULL, NULL);\n    mainprog_ptr->width = (ulg)width;\n    mainprog_ptr->height = (ulg)height;\n    \n\n    if (mainprog_ptr->need_bgcolor &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))\n    {\n        png_color_16p pBackground;\n        \n\n\n        png_get_bKGD(png_ptr, info_ptr, &pBackground);\n        \n\n        if (bit_depth == 16) {\n            mainprog_ptr->bg_red   = pBackground->red   >> 8;\n            mainprog_ptr->bg_green = pBackground->green >> 8;\n            mainprog_ptr->bg_blue  = pBackground->blue  >> 8;\n        } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {\n            if (bit_depth == 1)\n                mainprog_ptr->bg_red = mainprog_ptr->bg_green =\n                  mainprog_ptr->bg_blue = pBackground->gray? 255 : 0;\n            else if (bit_depth == 2)\n                mainprog_ptr->bg_red = mainprog_ptr->bg_green =\n                  mainprog_ptr->bg_blue = (255/3) * pBackground->gray;\n            else \n                mainprog_ptr->bg_red = mainprog_ptr->bg_green =\n                  mainprog_ptr->bg_blue = (255/15) * pBackground->gray;\n        } else {\n            mainprog_ptr->bg_red   = (uch)pBackground->red;\n            mainprog_ptr->bg_green = (uch)pBackground->green;\n            mainprog_ptr->bg_blue  = (uch)pBackground->blue;\n        }\n    }\n    \n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_expand(png_ptr);\n    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\n        png_set_expand(png_ptr);\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\n        png_set_expand(png_ptr);\n#ifdef PNG_READ_16_TO_8_SUPPORTED\n    if (bit_depth == 16)\n#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n        png_set_scale_16(png_ptr);\n#  else\n        png_set_strip_16(png_ptr);\n#  endif\n#endif\n    if (color_type == PNG_COLOR_TYPE_GRAY ||\n        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        png_set_gray_to_rgb(png_ptr);\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n    if (png_get_gAMA(png_ptr, info_ptr, &gamma))\n        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);\n    else\n        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);\n#else\n    if (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma))\n        png_set_gamma_fixed(png_ptr,\n            (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma);\n    else\n        png_set_gamma_fixed(png_ptr,\n            (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455);\n#endif\n    \n    mainprog_ptr->passes = png_set_interlace_handling(png_ptr);\n    \n\n    png_read_update_info(png_ptr, info_ptr);\n    mainprog_ptr->rowbytes = (int)png_get_rowbytes(png_ptr, info_ptr);\n    mainprog_ptr->channels = png_get_channels(png_ptr, info_ptr);\n    \n\n\n\n    (*mainprog_ptr->mainprog_init)();\n    \n    return;\n}\n", "bug_type": null, "idx": 216}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_scale_16_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   if (that->bit_depth == 16)\n   {\n      that->sample_depth = that->bit_depth = 8;\n      if (that->red_sBIT > 8) that->red_sBIT = 8;\n      if (that->green_sBIT > 8) that->green_sBIT = 8;\n      if (that->blue_sBIT > 8) that->blue_sBIT = 8;\n      if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;\n   }\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 217}
{"project": "LibPNG", "target": 0, "func": "#ifdef DO_16BIT\nstatic void perform_gamma_scale16_tests(png_modifier *pm)\n{\n#  ifndef PNG_MAX_GAMMA_8\n#     define PNG_MAX_GAMMA_8 11\n#  endif\n#  define SBIT_16_TO_8 PNG_MAX_GAMMA_8\n   \n\n\n\n\n\n\n\n   unsigned int i, j;\n   for (i=0; i<pm->ngamma_tests; ++i)\n   {\n      for (j=0; j<pm->ngamma_tests; ++j)\n      {\n         if (i != j &&\n             fabs(pm->gammas[j]/pm->gammas[i]-1) >= PNG_GAMMA_THRESHOLD)\n         {\n            gamma_transform_test(pm, 0, 16, 0, pm->interlace_type,\n               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 );\n            if (fail(pm))\n               return;\n            gamma_transform_test(pm, 2, 16, 0, pm->interlace_type,\n               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 );\n            if (fail(pm))\n               return;\n            gamma_transform_test(pm, 4, 16, 0, pm->interlace_type,\n               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 );\n            if (fail(pm))\n               return;\n            gamma_transform_test(pm, 6, 16, 0, pm->interlace_type,\n               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 );\n            if (fail(pm))\n               return;\n         }\n      }\n   }\n}\n", "bug_type": null, "idx": 218}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_cb16(Pixel *out, const Pixel *in, const Background *back)\n{\n   if (in->a <= 0)\n   {\n      out->r = back->ir;\n      out->g = back->ig;\n      out->b = back->ib;\n   }\n   else if (in->a >= 65535)\n   {\n      out->r = isRGB(in->r);\n      out->g = isRGB(in->g);\n      out->b = isRGB(in->b);\n   }\n   else\n   {\n      double a = in->a / 65535.;\n      double a1 = 1-a;\n      a /= 65535;\n      out->r = sRGB(in->r * a + back->dr * a1);\n      out->g = sRGB(in->g * a + back->dg * a1);\n      out->b = sRGB(in->b * a + back->db * a1);\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 219}
{"project": "LibPNG", "target": 0, "func": " */\nvoid usage()\n{\n  fprintf (stderr, \"PNG2PNM\\n\");\n  fprintf (stderr, \"   by Willem van Schaik, 1999\\n\");\n#ifdef __TURBOC__\n  fprintf (stderr, \"   for Turbo-C and Borland-C compilers\\n\");\n#else\n  fprintf (stderr, \"   for Linux (and Unix) compilers\\n\");\n#endif\n  fprintf (stderr, \"Usage:  png2pnm [options] <file>.png [<file>.pnm]\\n\");\n  fprintf (stderr, \"   or:  ... | png2pnm [options]\\n\");\n  fprintf (stderr, \"Options:\\n\");\n  fprintf (stderr,\n     \"   -r[aw]   write pnm-file in binary format (P4/P5/P6) (default)\\n\");\n  fprintf (stderr, \"   -n[oraw] write pnm-file in ascii format (P1/P2/P3)\\n\");\n  fprintf (stderr,\n     \"   -a[lpha] <file>.pgm write PNG alpha channel as pgm-file\\n\");\n  fprintf (stderr, \"   -h | -?  print this help-information\\n\");\n}\n", "bug_type": null, "idx": 220}
{"project": "LibPNG", "target": 0, "func": "static int\nread_one_file(FILE *ip, const char *name)\n{\n   uLong length = 0;\n   uLong a32 = adler32(0, NULL, 0);\n   uLong c32 = crc32(0, NULL, 0);\n   Byte header[132];\n   for (;;)\n   {\n      int ch = getc(ip);\n      Byte b;\n      if (ch == EOF) break;\n      b = (Byte)ch;\n      if (length < sizeof header)\n         header[length] = b;\n      ++length;\n      a32 = adler32(a32, &b, 1);\n      c32 = crc32(c32, &b, 1);\n   }\n   if (ferror(ip))\n      return 0;\n   \n   printf(\"PNG_ICC_CHECKSUM(0x%8.8lx, 0x%8.8lx,\\n   PNG_MD5(\"\n      \"0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x,\"\n      \" 0x%2.2x%2.2x%2.2x%2.2x), %d,\\n\"\n      \"   \\\"%4.4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d\\\", %lu, \\\"%s\\\")\\n\",\n      (unsigned long)a32, (unsigned long)c32,\n      header[84], header[85], header[86], header[87],\n      header[88], header[89], header[90], header[91],\n      header[92], header[93], header[94], header[95],\n      header[96], header[97], header[98], header[99],\n#     define u16(x) (header[x] * 256 + header[x+1])\n#     define u32(x) (u16(x) * 65536 + u16(x+2))\n      u32(64), u16(24), u16(26), u16(28), u16(30), u16(32), u16(34),\n      (unsigned long)length, name);\n   return 1;\n}\n", "bug_type": null, "idx": 221}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_setbuffer(png_modifier *pm)\n{\n   modifier_crc(pm->buffer);\n   pm->buffer_count = png_get_uint_32(pm->buffer)+12;\n   pm->buffer_position = 0;\n}\n", "bug_type": null, "idx": 222}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_lin(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   out->r = ilinear(in->r);\n   if (in->g == in->r)\n   {\n      out->g = out->r;\n      if (in->b == in->r)\n         out->b = out->r;\n      else\n         out->b = ilinear(in->b);\n   }\n   else\n   {\n      out->g = ilinear(in->g);\n      if (in->b == in->r)\n         out->b = out->r;\n      else if (in->b == in->g)\n         out->b = out->g;\n      else\n         out->b = ilinear(in->b);\n   }\n   out->a = 65535;\n}\n", "bug_type": null, "idx": 223}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_test(png_store* PNG_CONST psIn, png_uint_32 PNG_CONST id,\n   int do_interlace, int use_update_info)\n{\n   standard_display d;\n   context(psIn, fault);\n   \n\n\n   standard_display_init(&d, psIn, id, do_interlace, use_update_info);\n   \n\n\n   Try\n   {\n      png_structp pp;\n      png_infop pi;\n      \n\n\n      pp = set_store_for_read(d.ps, &pi, d.id,\n         d.do_interlace ?  (d.ps->progressive ?\n            \"pngvalid progressive deinterlacer\" :\n            \"pngvalid sequential deinterlacer\") : (d.ps->progressive ?\n               \"progressive reader\" : \"sequential reader\"));\n      \n      standard_palette_init(&d);\n      \n      if (d.ps->progressive)\n      {\n         png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,\n            standard_end);\n         \n         store_progressive_read(d.ps, pp, pi);\n      }\n      else\n      {\n         \n         png_set_read_fn(pp, d.ps, store_read);\n         \n         png_read_info(pp, pi);\n         \n\n\n         standard_info_imp(&d, pp, pi, 2 );\n         \n\n\n\n         {\n            sequential_row(&d, pp, pi, 0, 1);\n            \n\n\n            if (!d.speed)\n            {\n               standard_text_validate(&d, pp, pi, 1);\n               standard_image_validate(&d, pp, 0, 1);\n            }\n            else\n               d.ps->validated = 1;\n         }\n      }\n      \n      if (!d.ps->validated)\n         png_error(pp, \"image read failed silently\");\n      \n   }\n   Catch(fault)\n      d.ps = fault; \n   \n   store_read_reset(d.ps);\n}\n", "bug_type": null, "idx": 224}
{"project": "LibPNG", "target": 0, "func": "static void\nrandom_color(png_colorp color)\n{\n   static png_uint_32 color_seed[2] = { 0x12345678, 0x9abcdef };\n   make_random_bytes(color_seed, color, sizeof *color);\n}\n", "bug_type": null, "idx": 225}
{"project": "LibPNG", "target": 0, "func": "static int\nlogerror(Image *image, const char *a1, const char *a2, const char *a3)\n{\n   fflush(stdout);\n   if (image->image.warning_or_error)\n      fprintf(stderr, \"%s%s%s: %s\\n\", a1, a2, a3, image->image.message);\n   else\n      fprintf(stderr, \"%s%s%s\\n\", a1, a2, a3);\n   if (image->image.opaque != NULL)\n   {\n      fprintf(stderr, \"%s: image opaque pointer non-NULL on error\\n\",\n         image->file_name);\n      png_image_free(&image->image);\n   }\n   return 0;\n}\n", "bug_type": null, "idx": 226}
{"project": "LibPNG", "target": 0, "func": "static void\nnormalize_color_encoding(color_encoding *encoding)\n{\n   PNG_CONST double whiteY = encoding->red.Y + encoding->green.Y +\n      encoding->blue.Y;\n   if (whiteY != 1)\n   {\n      encoding->red.X /= whiteY;\n      encoding->red.Y /= whiteY;\n      encoding->red.Z /= whiteY;\n      encoding->green.X /= whiteY;\n      encoding->green.Y /= whiteY;\n      encoding->green.Z /= whiteY;\n      encoding->blue.X /= whiteY;\n      encoding->blue.Y /= whiteY;\n      encoding->blue.Z /= whiteY;\n   }\n}\n", "bug_type": null, "idx": 227}
{"project": "LibPNG", "target": 0, "func": "static void\ninit_validate_info(validate_info *vi, gamma_display *dp, png_const_structp pp,\n    int in_depth, int out_depth)\n{\n   PNG_CONST unsigned int outmax = (1U<<out_depth)-1;\n   vi->pp = pp;\n   vi->dp = dp;\n   if (dp->sbit > 0 && dp->sbit < in_depth)\n   {\n      vi->sbit = dp->sbit;\n      vi->isbit_shift = in_depth - dp->sbit;\n   }\n   else\n   {\n      vi->sbit = (png_byte)in_depth;\n      vi->isbit_shift = 0;\n   }\n   vi->sbit_max = (1U << vi->sbit)-1;\n   \n\n\n   vi->screen_gamma = dp->screen_gamma;\n   if (fabs(vi->screen_gamma-1) < PNG_GAMMA_THRESHOLD)\n      vi->screen_gamma = vi->screen_inverse = 0;\n   else\n      vi->screen_inverse = 1/vi->screen_gamma;\n   vi->use_input_precision = dp->use_input_precision;\n   vi->outmax = outmax;\n   vi->maxabs = abserr(dp->pm, in_depth, out_depth);\n   vi->maxpc = pcerr(dp->pm, in_depth, out_depth);\n   vi->maxcalc = calcerr(dp->pm, in_depth, out_depth);\n   vi->maxout = outerr(dp->pm, in_depth, out_depth);\n   vi->outquant = output_quantization_factor(dp->pm, in_depth, out_depth);\n   vi->maxout_total = vi->maxout + vi->outquant * .5;\n   vi->outlog = outlog(dp->pm, in_depth, out_depth);\n   if ((dp->this.colour_type & PNG_COLOR_MASK_ALPHA) != 0 ||\n      (dp->this.colour_type == 3 && dp->this.is_transparent))\n   {\n      vi->do_background = dp->do_background;\n      if (vi->do_background != 0)\n      {\n         PNG_CONST double bg_inverse = 1/dp->background_gamma;\n         double r, g, b;\n         \n         r = dp->background_color.red; r /= outmax;\n         g = dp->background_color.green; g /= outmax;\n         b = dp->background_color.blue; b /= outmax;\n#     if 0\n         \n\n         if (fabs(bg_inverse-1) >= PNG_GAMMA_THRESHOLD)\n#     endif\n         {\n            r = pow(r, bg_inverse);\n            g = pow(g, bg_inverse);\n            b = pow(b, bg_inverse);\n         }\n         vi->background_red = r;\n         vi->background_green = g;\n         vi->background_blue = b;\n      }\n   }\n   else\n      vi->do_background = 0;\n   if (vi->do_background == 0)\n      vi->background_red = vi->background_green = vi->background_blue = 0;\n   vi->gamma_correction = 1/(dp->file_gamma*dp->screen_gamma);\n   if (fabs(vi->gamma_correction-1) < PNG_GAMMA_THRESHOLD)\n      vi->gamma_correction = 0;\n   vi->file_inverse = 1/dp->file_gamma;\n   if (fabs(vi->file_inverse-1) < PNG_GAMMA_THRESHOLD)\n      vi->file_inverse = 0;\n   vi->scale16 = dp->scale16;\n}\n", "bug_type": null, "idx": 228}
{"project": "LibPNG", "target": 0, "func": " */\nint main(int argc, char *argv[])\n{\n  FILE *fp_rd = stdin;\n  FILE *fp_al = NULL;\n  FILE *fp_wr = stdout;\n  BOOL interlace = FALSE;\n  BOOL alpha = FALSE;\n  int argi;\n  for (argi = 1; argi < argc; argi++)\n  {\n    if (argv[argi][0] == '-')\n    {\n      switch (argv[argi][1])\n      {\n        case 'i':\n          interlace = TRUE;\n          break;\n        case 'a':\n          alpha = TRUE;\n          argi++;\n          if ((fp_al = fopen (argv[argi], \"rb\")) == NULL)\n          {\n            fprintf (stderr, \"PNM2PNG\\n\");\n            fprintf (stderr, \"Error:  alpha-channel file %s does not exist\\n\",\n               argv[argi]);\n            exit (1);\n          }\n          break;\n        case 'h':\n        case '?':\n          usage();\n          exit(0);\n          break;\n        default:\n          fprintf (stderr, \"PNM2PNG\\n\");\n          fprintf (stderr, \"Error:  unknown option %s\\n\", argv[argi]);\n          usage();\n          exit(1);\n          break;\n      } \n    }\n    else if (fp_rd == stdin)\n    {\n      if ((fp_rd = fopen (argv[argi], \"rb\")) == NULL)\n      {\n        fprintf (stderr, \"PNM2PNG\\n\");\n        fprintf (stderr, \"Error:  file %s does not exist\\n\", argv[argi]);\n        exit (1);\n      }\n    }\n    else if (fp_wr == stdout)\n    {\n      if ((fp_wr = fopen (argv[argi], \"wb\")) == NULL)\n      {\n        fprintf (stderr, \"PNM2PNG\\n\");\n        fprintf (stderr, \"Error:  can not create PNG-file %s\\n\", argv[argi]);\n        exit (1);\n      }\n    }\n    else\n    {\n      fprintf (stderr, \"PNM2PNG\\n\");\n      fprintf (stderr, \"Error:  too many parameters\\n\");\n      usage();\n      exit (1);\n    }\n  } \n#ifdef __TURBOC__\n  \n  if (fp_rd == stdin)\n  {\n    setmode (STDIN, O_BINARY);\n  }\n  if (fp_wr == stdout)\n  {\n    setmode (STDOUT, O_BINARY);\n  }\n#endif\n  \n  if (pnm2png (fp_rd, fp_wr, fp_al, interlace, alpha) == FALSE)\n  {\n    fprintf (stderr, \"PNM2PNG\\n\");\n    fprintf (stderr, \"Error:  unsuccessful converting to PNG-image\\n\");\n    exit (1);\n  }\n  \n  fclose (fp_rd);\n  \n  fclose (fp_wr);\n  \n  if (alpha)\n    fclose (fp_al);\n  return 0;\n}\n", "bug_type": null, "idx": 229}
{"project": "LibPNG", "target": 0, "func": "static void\nmodification_reset(png_modification *pmm)\n{\n   if (pmm != NULL)\n   {\n      pmm->modified = 0;\n      pmm->added = 0;\n      pmm->removed = 0;\n      modification_reset(pmm->next);\n   }\n}\n", "bug_type": null, "idx": 230}
{"project": "LibPNG", "target": 0, "func": "static void\npng_flush(png_structp png_ptr)\n{\n   FILE *io_ptr;\n   io_ptr = (FILE *)CVT_PTR((png_ptr->io_ptr));\n   if (io_ptr != NULL)\n      fflush(io_ptr);\n}\n", "bug_type": null, "idx": 231}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_current_encoding(PNG_CONST png_modifier *pm, color_encoding *ce)\n{\n   if (pm->current_encoding != 0)\n      *ce = *pm->current_encoding;\n   else\n      memset(ce, 0, sizeof *ce);\n   ce->gamma = pm->current_gamma;\n}\n", "bug_type": null, "idx": 232}
{"project": "LibPNG", "target": 0, "func": "static size_t\nsafe_read(png_structp png_ptr, int fd, void *buffer_in, size_t nbytes)\n{\n   size_t ntotal = 0;\n   char *buffer = png_voidcast(char*, buffer_in);\n   while (nbytes > 0)\n   {\n      unsigned int nread;\n      int iread;\n      \n\n\n\n      if (nbytes > INT_MAX)\n         nread = INT_MAX;\n      else\n         nread = (unsigned int)nbytes;\n      iread = read(fd, buffer, nread);\n      if (iread == -1)\n      {\n         \n\n\n\n         if (errno != EINTR)\n         {\n            png_warning(png_ptr, \"/proc read failed\");\n            return 0; \n         }\n      }\n      else if (iread < 0)\n      {\n         \n         png_warning(png_ptr, \"OS /proc read bug\");\n         return 0;\n      }\n      else if (iread > 0)\n      {\n         \n         buffer += iread;\n         nbytes -= (unsigned int)iread;\n         ntotal += (unsigned int)iread;\n      }\n      else\n         return ntotal;\n   }\n   return ntotal; \n}\n", "bug_type": null, "idx": 233}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_strip_alpha_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(bit_depth)\n   this->next = *that;\n   *that = this;\n   return (colour_type & PNG_COLOR_MASK_ALPHA) != 0;\n}\n", "bug_type": null, "idx": 234}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nstore_flush(png_structp ppIn)\n{\n   UNUSED(ppIn) \n}\n", "bug_type": null, "idx": 235}
{"project": "LibPNG", "target": 0, "func": "static int\ntest_size(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,\n    int bdlo, int PNG_CONST bdhi)\n{\n   \n\n\n\n\n\n\n   static PNG_CONST png_byte hinc[] = {1, 3, 11, 1, 5};\n   static PNG_CONST png_byte winc[] = {1, 9, 5, 7, 1};\n   for (; bdlo <= bdhi; ++bdlo)\n   {\n      png_uint_32 h, w;\n      for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo])\n      {\n         \n\n\n\n\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,\n            PNG_INTERLACE_NONE, w, h, 0), 0,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,\n            PNG_INTERLACE_NONE, w, h, 1), 0,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n#     ifdef PNG_WRITE_INTERLACING_SUPPORTED\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,\n            PNG_INTERLACE_ADAM7, w, h, 0), 0,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,\n            PNG_INTERLACE_ADAM7, w, h, 1), 0,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n#     endif\n         \n\n\n\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,\n            PNG_INTERLACE_NONE, w, h, 0), 1,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n#     ifdef PNG_WRITE_INTERLACING_SUPPORTED\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,\n            PNG_INTERLACE_ADAM7, w, h, 0), 1,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n#     endif\n      }\n   }\n   return 1; \n}\n", "bug_type": null, "idx": 236}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_ga16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = p->g = p->b = pp[0];\n   p->a = pp[1];\n}\n", "bug_type": null, "idx": 237}
{"project": "LibPNG", "target": 0, "func": "#ifdef PNG_READ_GAMMA_SUPPORTED\nstatic double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n{\n   \n\n\n   if (pm->assume_16_bit_calculations ||\n      (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n      return pm->maxabs16;\n   else\n      return pm->maxabs8;\n}\n", "bug_type": null, "idx": 238}
{"project": "LibPNG", "target": 0, "func": "BOOL PngSaveImage (PTSTR pstrFileName, png_byte *pDiData,\n                   int iWidth, int iHeight, png_color bkgColor)\n{\n    const int           ciBitDepth = 8;\n    const int           ciChannels = 3;\n    static FILE        *pfFile;\n    png_uint_32         ulRowBytes;\n    static png_byte   **ppbRowPointers = NULL;\n    int                 i;\n    \n    if (!pstrFileName)\n        return FALSE;\n    if (!(pfFile = fopen(pstrFileName, \"wb\")))\n        return FALSE;\n    \n    png_ptr = png_create_write_struct(png_get_libpng_ver(NULL), NULL,\n      (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL);\n    if (!png_ptr)\n    {\n        fclose(pfFile);\n        return FALSE;\n    }\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        fclose(pfFile);\n        png_destroy_write_struct(&png_ptr, (png_infopp) NULL);\n        return FALSE;\n    }\n    Try\n    {\n        \n#ifdef PNG_STDIO_SUPPORTED\n        png_init_io(png_ptr, pfFile);\n#else\n        png_set_write_fn(png_ptr, (png_voidp)pfFile, png_write_data, png_flush);\n#endif\n        \n        png_set_IHDR(png_ptr, info_ptr, iWidth, iHeight, ciBitDepth,\n            PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,\n            PNG_FILTER_TYPE_BASE);\n        \n        png_write_info(png_ptr, info_ptr);\n        \n        png_set_bgr(png_ptr);\n        \n        ulRowBytes = iWidth * ciChannels;\n        \n        if ((ppbRowPointers = (png_bytepp) malloc(iHeight * sizeof(png_bytep))) == NULL)\n            Throw \"Visualpng: Out of memory\";\n        \n        for (i = 0; i < iHeight; i++)\n            ppbRowPointers[i] = pDiData + i * (((ulRowBytes + 3) >> 2) << 2);\n        \n        png_write_image (png_ptr, ppbRowPointers);\n        \n        png_write_end(png_ptr, info_ptr);\n        \n        free (ppbRowPointers);\n        ppbRowPointers = NULL;\n        \n        png_destroy_write_struct(&png_ptr, (png_infopp) NULL);\n        \n    }\n    Catch (msg)\n    {\n        png_destroy_write_struct(&png_ptr, (png_infopp) NULL);\n        if(ppbRowPointers)\n            free (ppbRowPointers);\n        fclose(pfFile);\n        return FALSE;\n    }\n    fclose (pfFile);\n    return TRUE;\n}\n", "bug_type": null, "idx": 239}
{"project": "LibPNG", "target": 0, "func": "static void\nset_value(png_bytep row, size_t rowbytes, png_uint_32 x, unsigned int bit_depth,\n   png_uint_32 value, png_const_bytep gamma_table, double conv)\n{\n   unsigned int mask = (1U << bit_depth)-1;\n   x *= bit_depth;  \n   if (value <= mask)\n   {\n      png_uint_32 offset = x >> 3;\n      if (offset < rowbytes && (bit_depth < 16 || offset+1 < rowbytes))\n      {\n         row += offset;\n         switch (bit_depth)\n         {\n            case 1:\n            case 2:\n            case 4:\n               \n               {\n                  unsigned int shift = (8 - bit_depth) - (x & 0x7U);\n                  mask <<= shift;\n                  value = (value << shift) & mask;\n                  *row = (png_byte)((*row & ~mask) | value);\n               }\n               return;\n            default:\n               fprintf(stderr, \"makepng: bad bit depth (internal error)\\n\");\n               exit(1);\n            case 16:\n               value = (unsigned int)floor(65535*pow(value/65535.,conv)+.5);\n               *row++ = (png_byte)(value >> 8);\n               *row = (png_byte)value;\n               return;\n            case 8:\n               *row = gamma_table[value];\n               return;\n         }\n      }\n      else\n      {\n         fprintf(stderr, \"makepng: row buffer overflow (internal error)\\n\");\n         exit(1);\n      }\n   }\n   else\n   {\n      fprintf(stderr, \"makepng: component overflow (internal error)\\n\");\n      exit(1);\n   }\n}\n", "bug_type": null, "idx": 240}
{"project": "LibPNG", "target": 0, "func": "static struct buffer_list *\nbuffer_extend(struct buffer_list *current)\n{\n   struct buffer_list *add;\n   assert(current->next == NULL);\n   add = NEW(struct buffer_list);\n   if (add == NULL)\n      return NULL;\n   add->next = NULL;\n   current->next = add;\n   return add;\n}\n", "bug_type": null, "idx": 241}
{"project": "LibPNG", "target": 0, "func": "void readpng_cleanup(int free_image_data)\n{\n    if (free_image_data && image_data) {\n        free(image_data);\n        image_data = NULL;\n    }\n}\n", "bug_type": null, "idx": 242}
{"project": "LibPNG", "target": 0, "func": "static void\nfile_getpos(struct file *file, fpos_t *pos)\n{\n   if (fgetpos(file->file, pos))\n   {\n      \n      perror(file->file_name);\n      stop(file, READ_ERROR_CODE, \"fgetpos\");\n   }\n}\n", "bug_type": null, "idx": 243}
{"project": "LibPNG", "target": 0, "func": "static int\nancillaryb(const png_byte *name)\n{\n   return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3]));\n}\n", "bug_type": null, "idx": 244}
{"project": "LibPNG", "target": 0, "func": "static void\ngamma_image_validate(gamma_display *dp, png_const_structp pp,\n   png_infop pi)\n{\n   \n   PNG_CONST png_store* PNG_CONST ps = dp->this.ps;\n   PNG_CONST png_byte in_ct = dp->this.colour_type;\n   PNG_CONST png_byte in_bd = dp->this.bit_depth;\n   PNG_CONST png_uint_32 w = dp->this.w;\n   PNG_CONST png_uint_32 h = dp->this.h;\n   PNG_CONST size_t cbRow = dp->this.cbRow;\n   PNG_CONST png_byte out_ct = png_get_color_type(pp, pi);\n   PNG_CONST png_byte out_bd = png_get_bit_depth(pp, pi);\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   PNG_CONST unsigned int samples_per_pixel = (out_ct & 2U) ? 3U : 1U;\n   int processing;\n   png_uint_32 y;\n   PNG_CONST store_palette_entry *in_palette = dp->this.palette;\n   PNG_CONST int in_is_transparent = dp->this.is_transparent;\n   int out_npalette = -1;\n   int out_is_transparent = 0; \n   store_palette out_palette;\n   validate_info vi;\n   \n   store_image_check(dp->this.ps, pp, 0);\n   \n\n\n   init_validate_info(&vi, dp, pp, in_ct==3?8:in_bd, out_ct==3?8:out_bd);\n   processing = (vi.gamma_correction > 0 && !dp->threshold_test)\n      || in_bd != out_bd || in_ct != out_ct || vi.do_background;\n   \n\n\n\n\n\n\n   if (in_ct == 3 && out_ct == 3)\n      processing = 0;\n   if (processing && out_ct == 3)\n      out_is_transparent = read_palette(out_palette, &out_npalette, pp, pi);\n   for (y=0; y<h; ++y)\n   {\n      png_const_bytep pRow = store_image_row(ps, pp, 0, y);\n      png_byte std[STANDARD_ROWMAX];\n      transform_row(pp, std, in_ct, in_bd, y);\n      if (processing)\n      {\n         unsigned int x;\n         for (x=0; x<w; ++x)\n         {\n            double alpha = 1; \n            \n            PNG_CONST unsigned int in_index =\n               in_ct == 3 ? sample(std, 3, in_bd, x, 0) : 256;\n            PNG_CONST unsigned int out_index =\n               out_ct == 3 ? sample(std, 3, out_bd, x, 0) : 256;\n            \n\n\n            if ((in_ct & PNG_COLOR_MASK_ALPHA) != 0 || (in_ct == 3 &&\n               in_is_transparent))\n            {\n               PNG_CONST unsigned int input_alpha = in_ct == 3 ?\n                  dp->this.palette[in_index].alpha :\n                  sample(std, in_ct, in_bd, x, samples_per_pixel);\n               unsigned int output_alpha = 65536 ;\n               if (out_ct == 3)\n               {\n                  if (out_is_transparent)\n                     output_alpha = out_palette[out_index].alpha;\n               }\n               else if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0)\n                  output_alpha = sample(pRow, out_ct, out_bd, x,\n                     samples_per_pixel);\n               if (output_alpha != 65536)\n                  alpha = gamma_component_validate(\"alpha\", &vi, input_alpha,\n                     output_alpha, -1, 0);\n               else \n               {\n                  \n\n\n                  alpha = input_alpha >> vi.isbit_shift;\n                  alpha /= vi.sbit_max;\n               }\n            }\n            \n            if ((in_ct & PNG_COLOR_MASK_COLOR) == 0) \n               (void)gamma_component_validate(\"gray\", &vi,\n                  sample(std, in_ct, in_bd, x, 0),\n                  sample(pRow, out_ct, out_bd, x, 0), alpha,\n                  vi.background_red);\n            else \n            {\n               (void)gamma_component_validate(\"red\", &vi,\n                  in_ct == 3 ? in_palette[in_index].red :\n                     sample(std, in_ct, in_bd, x, 0),\n                  out_ct == 3 ? out_palette[out_index].red :\n                     sample(pRow, out_ct, out_bd, x, 0),\n                  alpha, vi.background_red);\n               (void)gamma_component_validate(\"green\", &vi,\n                  in_ct == 3 ? in_palette[in_index].green :\n                     sample(std, in_ct, in_bd, x, 1),\n                  out_ct == 3 ? out_palette[out_index].green :\n                     sample(pRow, out_ct, out_bd, x, 1),\n                  alpha, vi.background_green);\n               (void)gamma_component_validate(\"blue\", &vi,\n                  in_ct == 3 ? in_palette[in_index].blue :\n                     sample(std, in_ct, in_bd, x, 2),\n                  out_ct == 3 ? out_palette[out_index].blue :\n                     sample(pRow, out_ct, out_bd, x, 2),\n                  alpha, vi.background_blue);\n            }\n         }\n      }\n      else if (memcmp(std, pRow, cbRow) != 0)\n      {\n         char msg[64];\n         \n         sprintf(msg, \"gamma: below threshold row %lu changed\",\n            (unsigned long)y);\n         png_error(pp, msg);\n      }\n   } \n   dp->this.ps->validated = 1;\n}\n", "bug_type": null, "idx": 245}
{"project": "LibPNG", "target": 0, "func": "static void\ncheck_interlace_type(int PNG_CONST interlace_type)\n{\n   if (interlace_type != PNG_INTERLACE_NONE)\n   {\n      \n\n\n      fprintf(stderr, \"pngvalid: no interlace support\\n\");\n      exit(99);\n   }\n}\n", "bug_type": null, "idx": 246}
{"project": "LibPNG", "target": 0, "func": "#include \"../../png.h\"\nint main(int argc, const char **argv)\n{\n   int result = 1;\n   if (argc == 3)\n   {\n      png_image image;\n      \n      memset(&image, 0, sizeof image);\n      image.version = PNG_IMAGE_VERSION;\n      if (png_image_begin_read_from_file(&image, argv[1]))\n      {\n         png_bytep buffer;\n         \n\n\n         image.format = PNG_FORMAT_RGBA;\n         buffer = malloc(PNG_IMAGE_SIZE(image));\n         if (buffer != NULL)\n         {\n            if (png_image_finish_read(&image, NULL, buffer,\n               0, NULL))\n            {\n               if (png_image_write_to_file(&image, argv[2],\n                  0, buffer, 0,\n                  NULL))\n                  result = 0;\n               else\n                  fprintf(stderr, \"pngtopng: write %s: %s\\n\", argv[2],\n                      image.message);\n               free(buffer);\n            }\n            else\n            {\n               fprintf(stderr, \"pngtopng: read %s: %s\\n\", argv[1],\n                   image.message);\n               \n\n\n\n               png_image_free(&image);\n            }\n         }\n         else\n            fprintf(stderr, \"pngtopng: out of memory: %lu bytes\\n\",\n               (unsigned long)PNG_IMAGE_SIZE(image));\n      }\n      else\n         \n         fprintf(stderr, \"pngtopng: %s: %s\\n\", argv[1], image.message);\n   }\n   else\n      \n      fprintf(stderr, \"pngtopng: usage: pngtopng input-file output-file\\n\");\n   return result;\n}\n", "bug_type": null, "idx": 247}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_expand_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(bit_depth)\n   this->next = *that;\n   *that = this;\n   \n\n\n   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;\n}\n", "bug_type": null, "idx": 248}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_interlace_macro_validation(void)\n{\n   \n\n\n\n\n\n\n   int pass;\n   for (pass=0; pass<7; ++pass)\n   {\n      png_uint_32 m, f, v;\n      m = PNG_PASS_START_ROW(pass);\n      f = png_pass_start_row(pass);\n      if (m != f)\n      {\n         fprintf(stderr, \"PNG_PASS_START_ROW(%d) = %u != %x\\n\", pass, m, f);\n         exit(99);\n      }\n      m = PNG_PASS_START_COL(pass);\n      f = png_pass_start_col(pass);\n      if (m != f)\n      {\n         fprintf(stderr, \"PNG_PASS_START_COL(%d) = %u != %x\\n\", pass, m, f);\n         exit(99);\n      }\n      m = PNG_PASS_ROW_SHIFT(pass);\n      f = png_pass_row_shift(pass);\n      if (m != f)\n      {\n         fprintf(stderr, \"PNG_PASS_ROW_SHIFT(%d) = %u != %x\\n\", pass, m, f);\n         exit(99);\n      }\n      m = PNG_PASS_COL_SHIFT(pass);\n      f = png_pass_col_shift(pass);\n      if (m != f)\n      {\n         fprintf(stderr, \"PNG_PASS_COL_SHIFT(%d) = %u != %x\\n\", pass, m, f);\n         exit(99);\n      }\n      \n\n\n\n\n\n\n\n\n      for (v=0;;)\n      {\n         \n         m = PNG_ROW_FROM_PASS_ROW(v, pass);\n         f = png_row_from_pass_row(v, pass);\n         if (m != f)\n         {\n            fprintf(stderr, \"PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\\n\",\n               v, pass, m, f);\n            exit(99);\n         }\n         m = PNG_COL_FROM_PASS_COL(v, pass);\n         f = png_col_from_pass_col(v, pass);\n         if (m != f)\n         {\n            fprintf(stderr, \"PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\\n\",\n               v, pass, m, f);\n            exit(99);\n         }\n         m = PNG_ROW_IN_INTERLACE_PASS(v, pass);\n         f = png_row_in_interlace_pass(v, pass);\n         if (m != f)\n         {\n            fprintf(stderr, \"PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\\n\",\n               v, pass, m, f);\n            exit(99);\n         }\n         m = PNG_COL_IN_INTERLACE_PASS(v, pass);\n         f = png_col_in_interlace_pass(v, pass);\n         if (m != f)\n         {\n            fprintf(stderr, \"PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\\n\",\n               v, pass, m, f);\n            exit(99);\n         }\n         \n         ++v;\n         m = PNG_PASS_ROWS(v, pass);\n         f = png_pass_rows(v, pass);\n         if (m != f)\n         {\n            fprintf(stderr, \"PNG_PASS_ROWS(%u, %d) = %u != %x\\n\",\n               v, pass, m, f);\n            exit(99);\n         }\n         m = PNG_PASS_COLS(v, pass);\n         f = png_pass_cols(v, pass);\n         if (m != f)\n         {\n            fprintf(stderr, \"PNG_PASS_COLS(%u, %d) = %u != %x\\n\",\n               v, pass, m, f);\n            exit(99);\n         }\n         \n\n\n         if (v > 1024)\n         {\n            if (v == PNG_UINT_31_MAX)\n               break;\n            v = (v << 1) ^ v;\n            if (v >= PNG_UINT_31_MAX)\n               v = PNG_UINT_31_MAX-1;\n         }\n      }\n   }\n}\n", "bug_type": null, "idx": 249}
{"project": "LibPNG", "target": 0, "func": " */\nvoid usage()\n{\n  fprintf (stderr, \"PNM2PNG\\n\");\n  fprintf (stderr, \"   by Willem van Schaik, 1999\\n\");\n#ifdef __TURBOC__\n  fprintf (stderr, \"   for Turbo-C and Borland-C compilers\\n\");\n#else\n  fprintf (stderr, \"   for Linux (and Unix) compilers\\n\");\n#endif\n  fprintf (stderr, \"Usage:  pnm2png [options] <file>.<pnm> [<file>.png]\\n\");\n  fprintf (stderr, \"   or:  ... | pnm2png [options]\\n\");\n  fprintf (stderr, \"Options:\\n\");\n  fprintf (stderr, \"   -i[nterlace]   write png-file with interlacing on\\n\");\n  fprintf (stderr,\n      \"   -a[lpha] <file>.pgm read PNG alpha channel as pgm-file\\n\");\n  fprintf (stderr, \"   -h | -?  print this help-information\\n\");\n}\n", "bug_type": null, "idx": 250}
{"project": "LibPNG", "target": 0, "func": "int\nmain(void)\n{\n   unsigned int i;\n   unsigned char buf[MAX_LENGTH];\n   unsigned long crc;\n   unsigned char c;\n   int inchar;\n\n   for (i=8; i; i--)\n   {\n      c=GETBREAK;\n      putchar(c);\n   }\nif (inchar != EOF)\nfor (;;)\n {\n   \n   unsigned long length; \n   c=GETBREAK; buf[0] = c; length  = c; length <<= 8;\n   c=GETBREAK; buf[1] = c; length += c; length <<= 8;\n   c=GETBREAK; buf[2] = c; length += c; length <<= 8;\n   c=GETBREAK; buf[3] = c; length += c;\n   \n   c=GETBREAK; buf[4] = c;\n   c=GETBREAK; buf[5] = c;\n   c=GETBREAK; buf[6] = c;\n   c=GETBREAK; buf[7] = c;\n   \n   if (buf[4] == 105 && buf[5] == 84 && buf[6] == 88 && buf[7] == 116)\n   {\n      if (length >= MAX_LENGTH-12)\n         break;  \n      \n      crc = crc32(0, Z_NULL, 0);\n      \n      for (i=8; i < length + 12; i++)\n      {\n         c=GETBREAK; buf[i] = c;\n      }\n      \n      crc = crc32(crc, buf+4, (uInt)length+4);\n      for (;;)\n      {\n        \n        if (((crc >> 24) & 0xff) == buf[length+8] &&\n            ((crc >> 16) & 0xff) == buf[length+9] &&\n            ((crc >>  8) & 0xff) == buf[length+10] &&\n            ((crc      ) & 0xff) == buf[length+11])\n           break;\n        length++;\n        if (length >= MAX_LENGTH-12)\n           break;\n        c=GETBREAK;\n        buf[length+11]=c;\n        \n        crc = crc32(crc, buf+7+length, 1);\n      }\n      \n      buf[0] = (unsigned char)((length << 24) & 0xff);\n      buf[1] = (unsigned char)((length << 16) & 0xff);\n      buf[2] = (unsigned char)((length <<  8) & 0xff);\n      buf[3] = (unsigned char)((length      ) & 0xff);\n      \n      for (i=0; i<length+12; i++)\n         putchar(buf[i]);\n   }\n   else\n   {\n      \n      for (i=0; i<8; i++)\n         putchar(buf[i]);\n      \n      for (i=8; i< length+12; i++)\n      {\n         c=GETBREAK;\n         putchar(c);\n      }\n      if (inchar == EOF)\n      {\n         break;\n      }\n   \n      if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)\n         break;\n   }\n   if (inchar == EOF)\n      break;\n   if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)\n     break;\n }\n return 0;\n}\n", "bug_type": null, "idx": 251}
{"project": "LibPNG", "target": 0, "func": "static int\ncontrol_end(struct control *control)\n{\n   return file_end(&control->file);\n}\n", "bug_type": null, "idx": 252}
{"project": "LibPNG", "target": 0, "func": "LRESULT CALLBACK rpng_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP)\n{\n    HDC         hdc;\n    PAINTSTRUCT ps;\n    int rc;\n    switch (iMsg) {\n        case WM_CREATE:\n            \n            return 0;\n        case WM_PAINT:\n            hdc = BeginPaint(hwnd, &ps);\n                    \n            rc = StretchDIBits(hdc, 0, 0, image_width, image_height,\n                    \n                                    0, 0, image_width, image_height,\n                                    wimage_data, (BITMAPINFO *)bmih,\n                    \n                                    0, SRCCOPY);\n            EndPaint(hwnd, &ps);\n            return 0;\n        \n        case WM_CHAR:\n            switch (wP) {      \n                case 'q':\n                case 'Q':\n                case 0x1B:     \n                    PostQuitMessage(0);\n            }\n            return 0;\n        case WM_LBUTTONDOWN:   \n        case WM_DESTROY:\n            PostQuitMessage(0);\n            return 0;\n    }\n    return DefWindowProc(hwnd, iMsg, wP, lP);\n}\n", "bug_type": null, "idx": 253}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)\n{\n   if (png_ptr->buffer_size && png_ptr->current_text_left)\n   {\n      png_size_t text_size;\n\n      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)\n         text_size = png_ptr->buffer_size;\n\n      else\n         text_size = png_ptr->current_text_left;\n\n      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);\n      png_ptr->current_text_left -= text_size;\n      png_ptr->current_text_ptr += text_size;\n   }\n   if (!(png_ptr->current_text_left))\n   {\n      png_textp text_ptr;\n      png_charp text;\n      png_charp key;\n      int ret;\n      png_size_t text_size, key_size;\n\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_crc_finish(png_ptr);\n\n      key = png_ptr->current_text;\n\n      for (text = key; *text; text++)\n          ;\n\n      \n      if (text >= key + png_ptr->current_text_size)\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         return;\n      }\n\n      text++;\n\n      if (*text != PNG_TEXT_COMPRESSION_zTXt) \n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         return;\n      }\n\n      text++;\n\n      png_ptr->zstream.next_in = (png_bytep)text;\n      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -\n          (text - key));\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n      key_size = text - key;\n      text_size = 0;\n      text = NULL;\n      ret = Z_STREAM_END;\n\n      while (png_ptr->zstream.avail_in)\n      {\n         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END)\n         {\n            inflateReset(&png_ptr->zstream);\n            png_ptr->zstream.avail_in = 0;\n            png_ptr->current_text = NULL;\n            png_free(png_ptr, key);\n            png_free(png_ptr, text);\n            return;\n         }\n\n         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)\n         {\n            if (text == NULL)\n            {\n               text = (png_charp)png_malloc(png_ptr,\n                   (png_ptr->zbuf_size\n                   - png_ptr->zstream.avail_out + key_size + 1));\n\n               png_memcpy(text + key_size, png_ptr->zbuf,\n                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);\n\n               png_memcpy(text, key, key_size);\n\n               text_size = key_size + png_ptr->zbuf_size -\n                   png_ptr->zstream.avail_out;\n\n               *(text + text_size) = '\\0';\n            }\n\n            else\n            {\n               png_charp tmp;\n\n               tmp = text;\n               text = (png_charp)png_malloc(png_ptr, text_size +\n                   (png_ptr->zbuf_size\n                   - png_ptr->zstream.avail_out + 1));\n\n               png_memcpy(text, tmp, text_size);\n               png_free(png_ptr, tmp);\n\n               png_memcpy(text + text_size, png_ptr->zbuf,\n                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);\n\n               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n               *(text + text_size) = '\\0';\n            }\n\n            if (ret != Z_STREAM_END)\n            {\n               png_ptr->zstream.next_out = png_ptr->zbuf;\n               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n            }\n         }\n         else\n         {\n            break;\n         }\n\n         if (ret == Z_STREAM_END)\n            break;\n      }\n\n      inflateReset(&png_ptr->zstream);\n      png_ptr->zstream.avail_in = 0;\n\n      if (ret != Z_STREAM_END)\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         png_free(png_ptr, text);\n         return;\n      }\n\n      png_ptr->current_text = NULL;\n      png_free(png_ptr, key);\n      key = text;\n      text += key_size;\n\n      text_ptr = (png_textp)png_malloc(png_ptr,\n          png_sizeof(png_text));\n      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;\n      text_ptr->key = key;\n      text_ptr->itxt_length = 0;\n      text_ptr->lang = NULL;\n      text_ptr->lang_key = NULL;\n      text_ptr->text = text;\n\n      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n      png_free(png_ptr, key);\n      png_free(png_ptr, text_ptr);\n\n      if (ret)\n         png_warning(png_ptr, \"Insufficient memory to store text chunk\");\n   }\n}\n#endif", "bug_type": "cve-2012-3425", "idx": 254}
{"project": "LibPNG", "target": 0, "func": "static void\ninsert_hIST(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params)\n{\n   int i;\n   png_uint_16 freq[256];\n   \n\n\n   memset(freq, 0, sizeof freq);\n   for (i=0; i<nparams; ++i)\n   {\n      char *endptr = NULL;\n      unsigned long int l = strtoul(params[i], &endptr, 0);\n      if (params[i][0] && *endptr == 0 && l <= 65535)\n         freq[i] = (png_uint_16)l;\n      else\n      {\n         fprintf(stderr, \"hIST[%d]: %s: invalid frequency\\n\", i, params[i]);\n         exit(1);\n      }\n   }\n   png_set_hIST(png_ptr, info_ptr, freq);\n}\n", "bug_type": null, "idx": 255}
{"project": "LibPNG", "target": 0, "func": "int\nmain(int argc, char **argv)\n{\n   int i;\n   int extracted = 0;\n   for (i=1; i<argc; ++i)\n   {\n      if (strcmp(argv[i], \"-q\") == 0)\n         verbose = 0;\n      else if (extract_one_file(argv[i]))\n         extracted = 1;\n   }\n   \n   return extracted == 0;\n}\n", "bug_type": null, "idx": 256}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_g8b(Pixel *out, const Pixel *in, const Background *back)\n{\n   if (in->a <= 0)\n      out->r = out->g = out->b = back->ig;\n   else if (in->a >= 255)\n   {\n      if (in->r == in->g && in->g == in->b)\n         out->r = out->g = out->b = in->g;\n      else\n         out->r = out->g = out->b = sRGB(YfromRGB(\n            sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));\n   }\n   else\n   {\n      double a = in->a/255.;\n      out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r],\n         sRGB_to_d[in->g], sRGB_to_d[in->b]) + back->dg * (1-a));\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 257}
{"project": "LibPNG", "target": 0, "func": "static unsigned int\nmodifier_total_encodings(PNG_CONST png_modifier *pm)\n{\n   return 1 +                 \n      pm->ngammas +           \n      pm->nencodings +        \n      \n\n\n\n\n\n\n\n      ((pm->bit_depth == 16 || pm->assume_16_bit_calculations) ?\n         pm->nencodings : 0); \n}\n", "bug_type": null, "idx": 258}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_progressive_read(png_store *ps, png_structp pp, png_infop pi)\n{\n   \n\n\n   if (ps->pread != pp || ps->current == NULL || ps->next == NULL)\n      png_error(pp, \"store state damaged (progressive)\");\n   do\n   {\n      if (ps->readpos != 0)\n         png_error(pp, \"store_read called during progressive read\");\n      png_process_data(pp, pi, ps->next->buffer, store_read_buffer_size(ps));\n   }\n   while (store_read_buffer_next(ps));\n}\n", "bug_type": null, "idx": 259}
{"project": "LibPNG", "target": 0, "func": "void PNGCBAPI\npng_debug_free(png_structp png_ptr, png_voidp ptr)\n{\n   if (png_ptr == NULL)\n      fprintf(STDERR, \"NULL pointer to png_debug_free.\\n\");\n   if (ptr == 0)\n   {\n#if 0 \n      fprintf(STDERR, \"WARNING: freeing NULL pointer\\n\");\n#endif\n      return;\n   }\n   \n   {\n      memory_infop FAR *ppinfo = &pinformation;\n      for (;;)\n      {\n         memory_infop pinfo = *ppinfo;\n         if (pinfo->pointer == ptr)\n         {\n            *ppinfo = pinfo->next;\n            current_allocation -= pinfo->size;\n            if (current_allocation < 0)\n               fprintf(STDERR, \"Duplicate free of memory\\n\");\n            \n\n            png_memset(ptr, 0x55, pinfo->size);\n            png_free_default(png_ptr, pinfo);\n            pinfo = NULL;\n            break;\n         }\n         if (pinfo->next == NULL)\n         {\n            fprintf(STDERR, \"Pointer %x not found\\n\", (unsigned int)ptr);\n            break;\n         }\n         ppinfo = &pinfo->next;\n      }\n   }\n   \n   if (verbose)\n      printf(\"Freeing %p\\n\", ptr);\n   png_free_default(png_ptr, ptr);\n   ptr = NULL;\n}\n", "bug_type": null, "idx": 260}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_expand_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   \n   if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n      image_pixel_convert_PLTE(that);\n   else if (that->bit_depth < 8) \n      that->sample_depth = that->bit_depth = 8;\n   if (that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 261}
{"project": "LibPNG", "target": 1, "func": "\nvoid PNGAPI\npng_read_png(png_structp png_ptr, png_infop info_ptr,\n                           int transforms,\n                           voidp params)\n{\n   int row;\n\n   if (png_ptr == NULL) return;\n#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)\n   \n\n   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)\n       png_set_invert_alpha(png_ptr);\n#endif\n\n   \n\n\n   png_read_info(png_ptr, info_ptr);\n   if (info_ptr->height > PNG_UINT_32_MAX/png_sizeof(png_bytep))\n      png_error(png_ptr, \"Image is too high to process with png_read_png()\");\n\n   \n\n#if defined(PNG_READ_16_TO_8_SUPPORTED)\n   \n\n   if (transforms & PNG_TRANSFORM_STRIP_16)\n       png_set_strip_16(png_ptr);\n#endif\n\n#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)\n   \n\n\n   if (transforms & PNG_TRANSFORM_STRIP_ALPHA)\n       png_set_strip_alpha(png_ptr);\n#endif\n\n#if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED)\n   \n\n\n   if (transforms & PNG_TRANSFORM_PACKING)\n       png_set_packing(png_ptr);\n#endif\n\n#if defined(PNG_READ_PACKSWAP_SUPPORTED)\n   \n\n\n   if (transforms & PNG_TRANSFORM_PACKSWAP)\n       png_set_packswap(png_ptr);\n#endif\n\n#if defined(PNG_READ_EXPAND_SUPPORTED)\n   \n\n\n\n\n   if (transforms & PNG_TRANSFORM_EXPAND)\n       if ((png_ptr->bit_depth < 8) ||\n           (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||\n           (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)))\n         png_set_expand(png_ptr);\n#endif\n\n   \n\n\n#if defined(PNG_READ_INVERT_SUPPORTED)\n   \n\n   if (transforms & PNG_TRANSFORM_INVERT_MONO)\n       png_set_invert_mono(png_ptr);\n#endif\n\n#if defined(PNG_READ_SHIFT_SUPPORTED)\n   \n\n\n\n   if ((transforms & PNG_TRANSFORM_SHIFT)\n       && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))\n   {\n      png_color_8p sig_bit;\n\n      png_get_sBIT(png_ptr, info_ptr, &sig_bit);\n      png_set_shift(png_ptr, sig_bit);\n   }\n#endif\n\n#if defined(PNG_READ_BGR_SUPPORTED)\n   \n\n   if (transforms & PNG_TRANSFORM_BGR)\n       png_set_bgr(png_ptr);\n#endif\n\n#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)\n   \n\n   if (transforms & PNG_TRANSFORM_SWAP_ALPHA)\n       png_set_swap_alpha(png_ptr);\n#endif\n\n#if defined(PNG_READ_SWAP_SUPPORTED)\n   \n\n   if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)\n       png_set_swap(png_ptr);\n#endif\n\n   \n\n   \n\n\n\n   png_read_update_info(png_ptr, info_ptr);\n\n   \n\n#ifdef PNG_FREE_ME_SUPPORTED\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\n#endif\n   if (info_ptr->row_pointers == NULL)\n   {\n      info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr,\n         info_ptr->height * png_sizeof(png_bytep));\n#ifdef PNG_FREE_ME_SUPPORTED\n      info_ptr->free_me |= PNG_FREE_ROWS;\n#endif\n      for (row = 0; row < (int)info_ptr->height; row++)\n      {\n         info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr,\n            png_get_rowbytes(png_ptr, info_ptr));\n      }\n   }\n\n   png_read_image(png_ptr, info_ptr->row_pointers);\n   info_ptr->valid |= PNG_INFO_IDAT;\n\n   \n   png_read_end(png_ptr, info_ptr);\n\n   transforms = transforms; \n   params = params;\n\n}\n#endif \n#endif \n#endif \n", "bug_type": "cve-2009-0040", "idx": 262}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\nget_valid(display *d, png_infop info_ptr)\n{\n   png_uint_32 flags = png_get_valid(d->png_ptr, info_ptr, (png_uint_32)~0);\n   \n   {\n      png_textp text;\n      png_uint_32 ntext = png_get_text(d->png_ptr, info_ptr, &text, NULL);\n      while (ntext-- > 0) switch (text[ntext].compression)\n      {\n         case -1:\n            flags |= PNG_INFO_tEXt;\n            break;\n         case 0:\n            flags |= PNG_INFO_zTXt;\n            break;\n         case 1:\n         case 2:\n            flags |= PNG_INFO_iTXt;\n            break;\n         default:\n            fprintf(stderr, \"%s(%s): unknown text compression %d\\n\", d->file,\n               d->test, text[ntext].compression);\n            display_exit(d);\n      }\n   }\n   return flags;\n}\n", "bug_type": null, "idx": 263}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      that->colour_type = PNG_COLOR_TYPE_GRAY;\n   else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)\n      that->colour_type = PNG_COLOR_TYPE_RGB;\n   that->have_tRNS = 0;\n   that->alphaf = 1;\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 264}
{"project": "LibPNG", "target": 1, "func": "PNG_FUNCTION(void,PNGAPI\npng_err,(png_structp png_ptr),PNG_NORETURN)\n{\n   if (png_ptr != NULL && png_ptr->error_fn != NULL)\n      (*(png_ptr->error_fn))(png_ptr, '\\0');\n\n   \n\n   png_default_error(png_ptr, '\\0');\n}", "bug_type": "cve-2011-2961", "idx": 265}
{"project": "LibPNG", "target": 0, "func": "} \nstatic void rpng2_win_display_row(ulg row)\n{\n    uch bg_red   = rpng2_info.bg_red;\n    uch bg_green = rpng2_info.bg_green;\n    uch bg_blue  = rpng2_info.bg_blue;\n    uch *src, *src2=NULL, *dest;\n    uch r, g, b, a;\n    ulg i;\n    static int rows=0;\n    static ulg firstrow;\n\n\n\n\n\n    Trace((stderr, \"beginning rpng2_win_display_row()\\n\"))\n    if (rows == 0)\n        firstrow = row;   \n    ++rows;   \n\n\n\n\n\n    src = rpng2_info.image_data + row*rpng2_info.rowbytes;\n    if (bg_image)\n        src2 = bg_data + row*bg_rowbytes;\n    dest = wimage_data + row*wimage_rowbytes;\n    if (rpng2_info.channels == 3) {\n        for (i = rpng2_info.width;  i > 0;  --i) {\n            r = *src++;\n            g = *src++;\n            b = *src++;\n            *dest++ = b;\n            *dest++ = g;   \n            *dest++ = r;\n        }\n    } else  {\n        for (i = rpng2_info.width;  i > 0;  --i) {\n            r = *src++;\n            g = *src++;\n            b = *src++;\n            a = *src++;\n            if (bg_image) {\n                bg_red   = *src2++;\n                bg_green = *src2++;\n                bg_blue  = *src2++;\n            }\n            if (a == 255) {\n                *dest++ = b;\n                *dest++ = g;\n                *dest++ = r;\n            } else if (a == 0) {\n                *dest++ = bg_blue;\n                *dest++ = bg_green;\n                *dest++ = bg_red;\n            } else {\n                \n\n\n\n                alpha_composite(*dest++, b, a, bg_blue);\n                alpha_composite(*dest++, g, a, bg_green);\n                alpha_composite(*dest++, r, a, bg_red);\n            }\n        }\n    }\n\n\n\n\n    if ((rows & 0xf) == 0 || row == rpng2_info.height-1) {\n        RECT rect;\n        rect.left = 0L;\n        rect.top = (LONG)firstrow;\n        rect.right = (LONG)rpng2_info.width;       \n        rect.bottom = (LONG)row + 1L;              \n        InvalidateRect(global_hwnd, &rect, FALSE);\n        UpdateWindow(global_hwnd);                 \n        rows = 0;\n    }\n} \n", "bug_type": null, "idx": 266}
{"project": "LibPNG", "target": 0, "func": "static void\ncheck_error(display *d, png_uint_32 flags, const char *message)\n{\n   while (flags)\n   {\n      png_uint_32 flag = flags & -(png_int_32)flags;\n      int i = find_by_flag(flag);\n      fprintf(stderr, \"%s(%s): chunk %s: %s\\n\", d->file, d->test,\n         chunk_info[i].name, message);\n      ++(d->error_count);\n      flags &= ~flag;\n   }\n}\n", "bug_type": null, "idx": 267}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_g16(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));\n   out->a = 65535;\n}\n", "bug_type": null, "idx": 268}
{"project": "LibPNG", "target": 0, "func": "static const char *\nstrcode(int code)\n{\n   switch (code)\n   {\n      case LIBPNG_WARNING_CODE:   return \"warning\";\n      case LIBPNG_ERROR_CODE:     return \"libpng\";\n      case ZLIB_ERROR_CODE:       return \"zlib\";\n      case INVALID_ERROR_CODE:    return \"invalid\";\n      case READ_ERROR_CODE:       return \"read\";\n      case WRITE_ERROR_CODE:      return \"write\";\n      case UNEXPECTED_ERROR_CODE: return \"unexpected\";\n      default:                    return \"INVALID\";\n   }\n}\n", "bug_type": null, "idx": 269}
{"project": "LibPNG", "target": 0, "func": "static png_byte\nu8d(double d)\n{\n   d = closestinteger(d);\n   return (png_byte)d;\n}\n", "bug_type": null, "idx": 270}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_transform_test(png_modifier *pm)\n{\n   png_byte colour_type = 0;\n   png_byte bit_depth = 0;\n   unsigned int palette_number = 0;\n   while (next_format(&colour_type, &bit_depth, &palette_number, 0))\n   {\n      png_uint_32 counter = 0;\n      size_t base_pos;\n      char name[64];\n      base_pos = safecat(name, sizeof name, 0, \"transform:\");\n      for (;;)\n      {\n         size_t pos = base_pos;\n         PNG_CONST image_transform *list = 0;\n         \n\n\n         counter = image_transform_add(&list, 1, counter,\n            name, sizeof name, &pos, colour_type, bit_depth);\n         if (counter == 0)\n            break;\n         \n         do\n         {\n            pm->repeat = 0;\n            transform_test(pm, FILEID(colour_type, bit_depth, palette_number,\n               pm->interlace_type, 0, 0, 0), list, name);\n            if (fail(pm))\n               return;\n         }\n         while (pm->repeat);\n      }\n   }\n}\n", "bug_type": null, "idx": 271}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_glin(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->r == in->g && in->g == in->b)\n      out->r = out->g = out->b = ilinear(in->g);\n   else\n      out->r = out->g = out->b = u16d(65535 *\n         YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));\n   out->a = 65535;\n}\n", "bug_type": null, "idx": 272}
{"project": "LibPNG", "target": 0, "func": "static void readpng2_error_handler(png_structp png_ptr, png_const_charp msg)\n{\n    mainprog_info  *mainprog_ptr;\n    \n\n\n\n\n\n\n\n    fprintf(stderr, \"readpng2 libpng error: %s\\n\", msg);\n    fflush(stderr);\n    mainprog_ptr = png_get_error_ptr(png_ptr);\n    if (mainprog_ptr == NULL) {         \n        fprintf(stderr,\n          \"readpng2 severe error:  jmpbuf not recoverable; terminating.\\n\");\n        fflush(stderr);\n        exit(99);\n    }\n    \n\n\n\n\n\n\n    longjmp(mainprog_ptr->jmpbuf, 1);\n}\n", "bug_type": null, "idx": 273}
{"project": "LibPNG", "target": 0, "func": "static double\nchromaticity_x(CIE_color c)\n{\n   return c.X / (c.X + c.Y + c.Z);\n}\n", "bug_type": null, "idx": 274}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\ngamma_info(png_structp pp, png_infop pi)\n{\n   gamma_info_imp(voidcast(gamma_display*, png_get_progressive_ptr(pp)), pp,\n      pi);\n}\n", "bug_type": null, "idx": 275}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nprogressive_row(png_structp ppIn, png_bytep new_row, png_uint_32 y, int pass)\n{\n   png_const_structp pp = ppIn;\n   PNG_CONST standard_display *dp = voidcast(standard_display*,\n      png_get_progressive_ptr(pp));\n   \n\n\n\n\n   if (new_row != NULL)\n   {\n      png_bytep row;\n      \n\n\n      if (dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7)\n      {\n#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED\n         \n         if (y != png_get_current_row_number(pp))\n            png_error(pp, \"png_get_current_row_number is broken\");\n         if (pass != png_get_current_pass_number(pp))\n            png_error(pp, \"png_get_current_pass_number is broken\");\n#endif\n         y = PNG_ROW_FROM_PASS_ROW(y, pass);\n      }\n      \n      if (y >= dp->h)\n         png_error(pp, \"invalid y to progressive row callback\");\n      row = store_image_row(dp->ps, pp, 0, y);\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n      \n      if (dp->do_interlace)\n      {\n         if (dp->interlace_type == PNG_INTERLACE_ADAM7)\n            deinterlace_row(row, new_row, dp->pixel_size, dp->w, pass);\n         else\n            row_copy(row, new_row, dp->pixel_size * dp->w);\n      }\n      else\n         png_progressive_combine_row(pp, row, new_row);\n#endif \n   }\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   else if (dp->interlace_type == PNG_INTERLACE_ADAM7 &&\n       PNG_ROW_IN_INTERLACE_PASS(y, pass) &&\n       PNG_PASS_COLS(dp->w, pass) > 0)\n      png_error(pp, \"missing row in progressive de-interlacing\");\n#endif \n}\n", "bug_type": null, "idx": 276}
{"project": "LibPNG", "target": 0, "func": "} \nstatic void rpng2_win_finish_display()\n{\n    Trace((stderr, \"beginning rpng2_win_finish_display()\\n\"))\n    \n\n\n    rpng2_info.state = kDone;\n    printf(\n#ifndef __CYGWIN__\n      \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\"\n#else\n      \"Done.  Press mouse button 1 (within image window) to quit.\\n\"\n#endif\n    );\n    fflush(stdout);\n}\n", "bug_type": null, "idx": 277}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_pixel_setf(image_pixel *this, unsigned int max)\n{\n   this->redf = this->red / (double)max;\n   this->greenf = this->green / (double)max;\n   this->bluef = this->blue / (double)max;\n   this->alphaf = this->alpha / (double)max;\n   if (this->red < max)\n      this->rede = this->redf * DBL_EPSILON;\n   else\n      this->rede = 0;\n   if (this->green < max)\n      this->greene = this->greenf * DBL_EPSILON;\n   else\n      this->greene = 0;\n   if (this->blue < max)\n      this->bluee = this->bluef * DBL_EPSILON;\n   else\n      this->bluee = 0;\n   if (this->alpha < max)\n      this->alphae = this->alphaf * DBL_EPSILON;\n   else\n      this->alphae = 0;\n}\n", "bug_type": null, "idx": 278}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_init(png_store* ps)\n{\n   memset(ps, 0, sizeof *ps);\n   init_exception_context(&ps->exception_context);\n   store_pool_init(ps, &ps->read_memory_pool);\n   store_pool_init(ps, &ps->write_memory_pool);\n   ps->verbose = 0;\n   ps->treat_warnings_as_errors = 0;\n   ps->expect_error = 0;\n   ps->expect_warning = 0;\n   ps->saw_warning = 0;\n   ps->speed = 0;\n   ps->progressive = 0;\n   ps->validated = 0;\n   ps->nerrors = ps->nwarnings = 0;\n   ps->pread = NULL;\n   ps->piread = NULL;\n   ps->saved = ps->current = NULL;\n   ps->next = NULL;\n   ps->readpos = 0;\n   ps->image = NULL;\n   ps->cb_image = 0;\n   ps->cb_row = 0;\n   ps->image_h = 0;\n   ps->pwrite = NULL;\n   ps->piwrite = NULL;\n   ps->writepos = 0;\n   ps->new.prev = NULL;\n   ps->palette = NULL;\n   ps->npalette = 0;\n   ps->noptions = 0;\n}\n", "bug_type": null, "idx": 279}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_freenew(png_store *ps)\n{\n   store_freebuffer(&ps->new);\n   ps->writepos = 0;\n   if (ps->palette != NULL)\n   {\n      free(ps->palette);\n      ps->palette = NULL;\n      ps->npalette = 0;\n   }\n}\n", "bug_type": null, "idx": 280}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_tRNS\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before tRNS\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid tRNS after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))\n   {\n      png_warning(png_ptr, \"Duplicate tRNS chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_byte buf[2];\n\n      if (length != 2)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_values.gray = png_get_uint_16(buf);\n   }\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_byte buf[6];\n\n      if (length != 6)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n      png_crc_read(png_ptr, buf, (png_size_t)length);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_values.red = png_get_uint_16(buf);\n      png_ptr->trans_values.green = png_get_uint_16(buf + 2);\n      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);\n   }\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (!(png_ptr->mode & PNG_HAVE_PLTE))\n      {\n         \n         png_warning(png_ptr, \"Missing PLTE before tRNS\");\n      }\n      if (length > (png_uint_32)png_ptr->num_palette ||\n          length > PNG_MAX_PALETTE_LENGTH)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n      if (length == 0)\n      {\n         png_warning(png_ptr, \"Zero length tRNS chunk\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n      png_crc_read(png_ptr, readbuf, (png_size_t)length);\n      png_ptr->num_trans = (png_uint_16)length;\n   }\n   else\n   {\n      png_warning(png_ptr, \"tRNS chunk not allowed with alpha channel\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,\n      &(png_ptr->trans_values));\n}\n#endif", "bug_type": "cve-2007-2445", "idx": 281}
{"project": "LibPNG", "target": 0, "func": "static int\nprocess_iTXt(struct file *file)\n{\n   \n   struct chunk *chunk = file->chunk;\n   png_uint_32 length;\n   png_uint_32 index = 0;\n   assert(chunk != NULL && file->idat == NULL);\n   length = chunk->chunk_length;\n   setpos(chunk);\n   while (length >= 5)\n   {\n      --length;\n      ++index;\n      if (reread_byte(file) == 0) \n      {\n         --length;\n         ++index;\n         if (reread_byte(file) == 0) \n            return 1; \n         --length;\n         ++index;\n         (void)reread_byte(file); \n         \n         while (length >= 9)\n         {\n            --length;\n            ++index;\n            if (reread_byte(file) == 0) \n            {\n               \n               while (length >= 8)\n               {\n                  --length;\n                  ++index;\n                  if (reread_byte(file) == 0) \n                     return zlib_check(file, index);\n               }\n            }\n         }\n         \n         break;\n      }\n   }\n   log_error(file, INVALID_ERROR_CODE, \"iTXt chunk length\");\n   return 0; \n}\n", "bug_type": null, "idx": 282}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_@_add(image_transform *this,\n    PNG_CONST image_transform **that, char *name, size_t sizeof_name,\n    size_t *pos, png_byte colour_type, png_byte bit_depth)\n{\n   this->next = *that;\n   *that = this;\n   *pos = safecat(name, sizeof_name, *pos, \" +@\");\n   return 1;\n}\n", "bug_type": null, "idx": 283}
{"project": "LibPNG", "target": 0, "func": "void PNGCBAPI\nread_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)\n{\n   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX)\n      return;\n   if (status_pass != pass)\n   {\n      fprintf(stdout, \"\\n Pass %d: \", pass);\n      status_pass = pass;\n      status_dots = 31;\n   }\n   status_dots--;\n   if (status_dots == 0)\n   {\n      fprintf(stdout, \"\\n         \");\n      status_dots=30;\n   }\n   fprintf(stdout, \"r\");\n}\n", "bug_type": null, "idx": 284}
{"project": "LibPNG", "target": 0, "func": "static void\ngenerate_row(png_bytep row, size_t rowbytes, unsigned int y, int color_type,\n   int bit_depth, png_const_bytep gamma_table, double conv,\n   unsigned int *colors)\n{\n   png_uint_32 size_max = image_size_of_type(color_type, bit_depth, colors)-1;\n   png_uint_32 depth_max = (1U << bit_depth)-1; \n   if (colors[0] == 0) switch (channels_of_type(color_type))\n   {\n   \n\n\n      case 1:\n         {\n            png_uint_32 x;\n            png_uint_32 base = 2*size_max - abs(2*y-size_max);\n            for (x=0; x<=size_max; ++x)\n            {\n               png_uint_32 luma = base - abs(2*x-size_max);\n               \n\n\n               luma = (luma*depth_max + size_max) / (2*size_max);\n               set_value(row, rowbytes, x, bit_depth, luma, gamma_table, conv);\n            }\n         }\n         break;\n   \n\n\n      case 2:\n         {\n            png_uint_32 alpha = (depth_max * y * 2 + size_max) / (2 * size_max);\n            png_uint_32 x;\n            for (x=0; x<=size_max; ++x)\n            {\n               set_value(row, rowbytes, 2*x, bit_depth,\n                  (depth_max * x * 2 + size_max) / (2 * size_max), gamma_table,\n                  conv);\n               set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,\n                  conv);\n            }\n         }\n         break;\n   \n\n\n      case 3:\n         {\n            \n\n\n\n\n            png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);\n            png_uint_32 x;\n            \n\n\n\n\n\n\n            for (x=0; x<=size_max; ++x)\n            {\n               set_value(row, rowbytes, 3*x+0, bit_depth,  Y,\n                     gamma_table, conv);\n               set_value(row, rowbytes, 3*x+1, bit_depth, \n                  (depth_max * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 3*x+2, bit_depth, \n                  (Y * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n            }\n         }\n         break;\n   \n\n\n      case 4:\n         {\n            \n\n\n\n\n\n            png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);\n            png_uint_32 x;\n            \n\n\n\n\n\n\n\n            for (x=0; x<=size_max; ++x)\n            {\n               set_value(row, rowbytes, 4*x+0, bit_depth, \n                  ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 4*x+1, bit_depth, \n                  (Y * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 4*x+2, bit_depth, \n                  Y - (Y * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 4*x+3, bit_depth, \n                  Y + ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n            }\n         }\n         break;\n      default:\n         fprintf(stderr, \"makepng: internal bad channel count\\n\");\n         exit(2);\n   }\n   else if (color_type & PNG_COLOR_MASK_PALETTE)\n   {\n      \n\n\n      memset(row, 0, rowbytes);\n   }\n   else if (colors[0] == channels_of_type(color_type))\n      switch (channels_of_type(color_type))\n      {\n         case 1:\n            {\n               const png_uint_32 luma = colors[1];\n               png_uint_32 x;\n               for (x=0; x<=size_max; ++x)\n                  set_value(row, rowbytes, x, bit_depth, luma, gamma_table,\n                     conv);\n            }\n            break;\n         case 2:\n            {\n               const png_uint_32 luma = colors[1];\n               const png_uint_32 alpha = colors[2];\n               png_uint_32 x;\n               for (x=0; x<size_max; ++x)\n               {\n                  set_value(row, rowbytes, 2*x, bit_depth, luma, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,\n                     conv);\n               }\n            }\n            break;\n         case 3:\n            {\n               const png_uint_32 red = colors[1];\n               const png_uint_32 green = colors[2];\n               const png_uint_32 blue = colors[3];\n               png_uint_32 x;\n               for (x=0; x<=size_max; ++x)\n               {\n                  set_value(row, rowbytes, 3*x+0, bit_depth, red, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 3*x+1, bit_depth, green, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 3*x+2, bit_depth, blue, gamma_table,\n                     conv);\n               }\n            }\n            break;\n         case 4:\n            {\n               const png_uint_32 red = colors[1];\n               const png_uint_32 green = colors[2];\n               const png_uint_32 blue = colors[3];\n               const png_uint_32 alpha = colors[4];\n               png_uint_32 x;\n               for (x=0; x<=size_max; ++x)\n               {\n                  set_value(row, rowbytes, 4*x+0, bit_depth, red, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 4*x+1, bit_depth, green, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 4*x+2, bit_depth, blue, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 4*x+3, bit_depth, alpha, gamma_table,\n                     conv);\n               }\n            }\n         break;\n         default:\n            fprintf(stderr, \"makepng: internal bad channel count\\n\");\n            exit(2);\n      }\n   else\n   {\n      fprintf(stderr,\n         \"makepng: --color: count(%u) does not match channels(%u)\\n\",\n         colors[0], channels_of_type(color_type));\n      exit(1);\n   }\n}\n", "bug_type": null, "idx": 285}
{"project": "LibPNG", "target": 0, "func": "static void\nsummarize_gamma_errors(png_modifier *pm, png_const_charp who, int low_bit_depth,\n   int indexed)\n{\n   fflush(stderr);\n   if (who)\n      printf(\"\\nGamma correction with %s:\\n\", who);\n   else\n      printf(\"\\nBasic gamma correction:\\n\");\n   if (low_bit_depth)\n   {\n      print_one(\" 2 bit gray: \", pm->error_gray_2);\n      print_one(\" 4 bit gray: \", pm->error_gray_4);\n      print_one(\" 8 bit gray: \", pm->error_gray_8);\n      print_one(\" 8 bit color:\", pm->error_color_8);\n      if (indexed)\n         print_one(\" indexed:    \", pm->error_indexed);\n   }\n   print_one(\"16 bit gray: \", pm->error_gray_16);\n   print_one(\"16 bit color:\", pm->error_color_16);\n   fflush(stdout);\n}\n", "bug_type": null, "idx": 286}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL png2pnm (FILE *png_file, FILE *pnm_file, FILE *alpha_file,\n    volatile BOOL raw, BOOL alpha)\n{\n  png_struct    *png_ptr = NULL;\n  png_info        *info_ptr = NULL;\n  png_byte      buf[8];\n  png_byte      *png_pixels = NULL;\n  png_byte      **row_pointers = NULL;\n  png_byte      *pix_ptr = NULL;\n  png_uint_32   row_bytes;\n  png_uint_32   width;\n  png_uint_32   height;\n  int           bit_depth;\n  int           channels;\n  int           color_type;\n  int           alpha_present;\n  int           row, col;\n  int           ret;\n  int           i;\n  long          dep_16;\n  \n  ret = fread (buf, 1, 8, png_file);\n  if (ret != 8)\n    return FALSE;\n  ret = png_sig_cmp (buf, 0, 8);\n  if (ret)\n    return FALSE;\n  \n  png_ptr = png_create_read_struct (png_get_libpng_ver(NULL),\n    NULL, NULL, NULL);\n  if (!png_ptr)\n    return FALSE;   \n  info_ptr = png_create_info_struct (png_ptr);\n  if (!info_ptr)\n  {\n    png_destroy_read_struct (&png_ptr, NULL, NULL);\n    return FALSE;   \n  }\n  if (setjmp (png_jmpbuf(png_ptr)))\n  {\n    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);\n    return FALSE;\n  }\n  \n  png_init_io (png_ptr, png_file);\n  png_set_sig_bytes (png_ptr, 8);  \n  \n  png_read_info (png_ptr, info_ptr);\n  \n  png_get_IHDR (png_ptr, info_ptr,\n    &width, &height, &bit_depth, &color_type,\n    NULL, NULL, NULL);\n  \n  \n  if (color_type == PNG_COLOR_TYPE_PALETTE)\n    png_set_expand (png_ptr);\n  \n  if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\n    png_set_expand (png_ptr);\n  \n  if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS))\n    png_set_expand (png_ptr);\n#ifdef NJET\n  \n  if (bit_depth == 16)\n    png_set_strip_16 (png_ptr);\n  \n  if (color_type == PNG_COLOR_TYPE_GRAY ||\n    color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    png_set_gray_to_rgb (png_ptr);\n  \n  if (png_get_gAMA (png_ptr, info_ptr, &file_gamma))\n    png_set_gamma (png_ptr, (double) 2.2, file_gamma);\n#endif\n  \n\n  png_read_update_info (png_ptr, info_ptr);\n  \n  png_get_IHDR (png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\n    NULL, NULL, NULL);\n  \n  if (bit_depth == 16)\n  {\n    raw = FALSE;\n#ifdef __TURBOC__\n    pnm_file->flags &= ~((unsigned) _F_BIN);\n#endif\n  }\n  \n  if (color_type == PNG_COLOR_TYPE_GRAY)\n    channels = 1;\n  else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    channels = 2;\n  else if (color_type == PNG_COLOR_TYPE_RGB)\n    channels = 3;\n  else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n    channels = 4;\n  else\n    channels = 0; \n  alpha_present = (channels - 1) % 2;\n  \n  if (alpha && !alpha_present)\n  {\n    fprintf (stderr, \"PNG2PNM\\n\");\n    fprintf (stderr, \"Error:  PNG-file doesn't contain alpha channel\\n\");\n    exit (1);\n  }\n  \n  row_bytes = png_get_rowbytes (png_ptr, info_ptr);\n  if ((png_pixels = (png_byte *)\n     malloc (row_bytes * height * sizeof (png_byte))) == NULL) {\n    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);\n    return FALSE;\n  }\n  if ((row_pointers = (png_byte **)\n     malloc (height * sizeof (png_bytep))) == NULL)\n  {\n    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);\n    free (png_pixels);\n    png_pixels = NULL;\n    return FALSE;\n  }\n  \n  for (i = 0; i < ((int) height); i++)\n    row_pointers[i] = png_pixels + i * row_bytes;\n  \n  png_read_image (png_ptr, row_pointers);\n  \n  png_read_end (png_ptr, info_ptr);\n  \n  png_destroy_read_struct (&png_ptr, &info_ptr, (png_infopp) NULL);\n  \n  if ((color_type == PNG_COLOR_TYPE_GRAY) ||\n      (color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n  {\n    fprintf (pnm_file, \"%s\\n\", (raw) ? \"P5\" : \"P2\");\n    fprintf (pnm_file, \"%d %d\\n\", (int) width, (int) height);\n    fprintf (pnm_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));\n  }\n  else if ((color_type == PNG_COLOR_TYPE_RGB) ||\n           (color_type == PNG_COLOR_TYPE_RGB_ALPHA))\n  {\n    fprintf (pnm_file, \"%s\\n\", (raw) ? \"P6\" : \"P3\");\n    fprintf (pnm_file, \"%d %d\\n\", (int) width, (int) height);\n    fprintf (pnm_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));\n  }\n  \n  if ((alpha) &&\n      ((color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n       (color_type == PNG_COLOR_TYPE_RGB_ALPHA)))\n  {\n    fprintf (alpha_file, \"%s\\n\", (raw) ? \"P5\" : \"P2\");\n    fprintf (alpha_file, \"%d %d\\n\", (int) width, (int) height);\n    fprintf (alpha_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));\n  }\n  \n  pix_ptr = png_pixels;\n  for (row = 0; row < (int) height; row++)\n  {\n    for (col = 0; col < (int) width; col++)\n    {\n      for (i = 0; i < (channels - alpha_present); i++)\n      {\n        if (raw)\n          fputc ((int) *pix_ptr++ , pnm_file);\n        else\n          if (bit_depth == 16){\n            dep_16 = (long) *pix_ptr++;\n            fprintf (pnm_file, \"%ld \", (dep_16 << 8) + ((long) *pix_ptr++));\n          }\n          else\n            fprintf (pnm_file, \"%ld \", (long) *pix_ptr++);\n      }\n      if (alpha_present)\n      {\n        if (!alpha)\n        {\n          pix_ptr++; \n          if (bit_depth == 16)\n            pix_ptr++;\n        }\n        else \n        {\n          if (raw)\n            fputc ((int) *pix_ptr++ , alpha_file);\n          else\n            if (bit_depth == 16){\n              dep_16 = (long) *pix_ptr++;\n              fprintf (alpha_file, \"%ld \", (dep_16 << 8) + (long) *pix_ptr++);\n            }\n            else\n              fprintf (alpha_file, \"%ld \", (long) *pix_ptr++);\n        }\n      } \n      if (!raw)\n        if (col % 4 == 3)\n          fprintf (pnm_file, \"\\n\");\n    } \n    if (!raw)\n      if (col % 4 != 0)\n        fprintf (pnm_file, \"\\n\");\n  } \n  if (row_pointers != (unsigned char**) NULL)\n    free (row_pointers);\n  if (png_pixels != (unsigned char*) NULL)\n    free (png_pixels);\n  return TRUE;\n} \n", "bug_type": null, "idx": 287}
{"project": "LibPNG", "target": 0, "func": "int\ntest_one_file(PNG_CONST char *inname, PNG_CONST char *outname)\n{\n   static png_FILE_p fpin;\n   static png_FILE_p fpout;  \n   png_structp read_ptr;\n   png_infop read_info_ptr, end_info_ptr;\n#ifdef PNG_WRITE_SUPPORTED\n   png_structp write_ptr;\n   png_infop write_info_ptr;\n   png_infop write_end_info_ptr;\n#else\n   png_structp write_ptr = NULL;\n   png_infop write_info_ptr = NULL;\n   png_infop write_end_info_ptr = NULL;\n#endif\n   png_bytep row_buf;\n   png_uint_32 y;\n   png_uint_32 width, height;\n   int num_pass, pass;\n   int bit_depth, color_type;\n#ifdef PNG_SETJMP_SUPPORTED\n#ifdef USE_FAR_KEYWORD\n   jmp_buf png_jmpbuf;\n#endif\n#endif\n   char inbuf[256], outbuf[256];\n   row_buf = NULL;\n   if ((fpin = fopen(inname, \"rb\")) == NULL)\n   {\n      fprintf(STDERR, \"Could not find input file %s\\n\", inname);\n      return (1);\n   }\n   if ((fpout = fopen(outname, \"wb\")) == NULL)\n   {\n      fprintf(STDERR, \"Could not open output file %s\\n\", outname);\n      FCLOSE(fpin);\n      return (1);\n   }\n   pngtest_debug(\"Allocating read and write structures\");\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n   read_ptr =\n      png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL,\n      NULL, NULL, NULL, png_debug_malloc, png_debug_free);\n#else\n   read_ptr =\n      png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n#endif\n#ifndef PNG_STDIO_SUPPORTED\n   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,\n       pngtest_warning);\n#endif\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n   user_chunk_data[0] = 0;\n   user_chunk_data[1] = 0;\n   user_chunk_data[2] = 0;\n   user_chunk_data[3] = 0;\n   png_set_read_user_chunk_fn(read_ptr, user_chunk_data,\n     read_user_chunk_callback);\n#endif\n#ifdef PNG_WRITE_SUPPORTED\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n   write_ptr =\n      png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL,\n      NULL, NULL, NULL, png_debug_malloc, png_debug_free);\n#else\n   write_ptr =\n      png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n#endif\n#ifndef PNG_STDIO_SUPPORTED\n   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,\n       pngtest_warning);\n#endif\n#endif\n   pngtest_debug(\"Allocating read_info, write_info and end_info structures\");\n   read_info_ptr = png_create_info_struct(read_ptr);\n   end_info_ptr = png_create_info_struct(read_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n   write_info_ptr = png_create_info_struct(write_ptr);\n   write_end_info_ptr = png_create_info_struct(write_ptr);\n#endif\n#ifdef PNG_SETJMP_SUPPORTED\n   pngtest_debug(\"Setting jmpbuf for read struct\");\n#ifdef USE_FAR_KEYWORD\n   if (setjmp(png_jmpbuf))\n#else\n   if (setjmp(png_jmpbuf(read_ptr)))\n#endif\n   {\n      fprintf(STDERR, \"%s -> %s: libpng read error\\n\", inname, outname);\n      png_free(read_ptr, row_buf);\n      row_buf = NULL;\n      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n      png_destroy_info_struct(write_ptr, &write_end_info_ptr);\n      png_destroy_write_struct(&write_ptr, &write_info_ptr);\n#endif\n      FCLOSE(fpin);\n      FCLOSE(fpout);\n      return (1);\n   }\n#ifdef USE_FAR_KEYWORD\n   png_memcpy(png_jmpbuf(read_ptr), png_jmpbuf, png_sizeof(jmp_buf));\n#endif\n#ifdef PNG_WRITE_SUPPORTED\n   pngtest_debug(\"Setting jmpbuf for write struct\");\n#ifdef USE_FAR_KEYWORD\n   if (setjmp(png_jmpbuf))\n#else\n   if (setjmp(png_jmpbuf(write_ptr)))\n#endif\n   {\n      fprintf(STDERR, \"%s -> %s: libpng write error\\n\", inname, outname);\n      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);\n      png_destroy_info_struct(write_ptr, &write_end_info_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n      png_destroy_write_struct(&write_ptr, &write_info_ptr);\n#endif\n      FCLOSE(fpin);\n      FCLOSE(fpout);\n      return (1);\n   }\n#ifdef USE_FAR_KEYWORD\n   png_memcpy(png_jmpbuf(write_ptr), png_jmpbuf, png_sizeof(jmp_buf));\n#endif\n#endif\n#endif\n   pngtest_debug(\"Initializing input and output streams\");\n#ifdef PNG_STDIO_SUPPORTED\n   png_init_io(read_ptr, fpin);\n#  ifdef PNG_WRITE_SUPPORTED\n   png_init_io(write_ptr, fpout);\n#  endif\n#else\n   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);\n#  ifdef PNG_WRITE_SUPPORTED\n   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,\n#    ifdef PNG_WRITE_FLUSH_SUPPORTED\n      pngtest_flush);\n#    else\n      NULL);\n#    endif\n#  endif\n#endif\n   if (status_dots_requested == 1)\n   {\n#ifdef PNG_WRITE_SUPPORTED\n      png_set_write_status_fn(write_ptr, write_row_callback);\n#endif\n      png_set_read_status_fn(read_ptr, read_row_callback);\n   }\n   else\n   {\n#ifdef PNG_WRITE_SUPPORTED\n      png_set_write_status_fn(write_ptr, NULL);\n#endif\n      png_set_read_status_fn(read_ptr, NULL);\n   }\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n   {\n      int i;\n      for (i = 0; i<256; i++)\n         filters_used[i] = 0;\n      png_set_read_user_transform_fn(read_ptr, count_filters);\n   }\n#endif\n#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED\n   zero_samples = 0;\n   png_set_write_user_transform_fn(write_ptr, count_zero_samples);\n#endif\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n#  ifndef PNG_HANDLE_CHUNK_ALWAYS\n#    define PNG_HANDLE_CHUNK_ALWAYS       3\n#  endif\n   png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS,\n      NULL, 0);\n#endif\n#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED\n#  ifndef PNG_HANDLE_CHUNK_IF_SAFE\n#    define PNG_HANDLE_CHUNK_IF_SAFE      2\n#  endif\n   png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_IF_SAFE,\n      NULL, 0);\n#endif\n   pngtest_debug(\"Reading info struct\");\n   png_read_info(read_ptr, read_info_ptr);\n   pngtest_debug(\"Transferring info struct\");\n   {\n      int interlace_type, compression_type, filter_type;\n      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,\n          &color_type, &interlace_type, &compression_type, &filter_type))\n      {\n         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,\n#ifdef PNG_WRITE_INTERLACING_SUPPORTED\n            color_type, interlace_type, compression_type, filter_type);\n#else\n            color_type, PNG_INTERLACE_NONE, compression_type, filter_type);\n#endif\n      }\n   }\n#ifdef PNG_FIXED_POINT_SUPPORTED\n#ifdef PNG_cHRM_SUPPORTED\n   {\n      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,\n         blue_y;\n      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y,\n         &red_x, &red_y, &green_x, &green_y, &blue_x, &blue_y))\n      {\n         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,\n            red_y, green_x, green_y, blue_x, blue_y);\n      }\n   }\n#endif\n#ifdef PNG_gAMA_SUPPORTED\n   {\n      png_fixed_point gamma;\n      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))\n         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);\n   }\n#endif\n#else \n#ifdef PNG_FLOATING_POINT_SUPPORTED\n#ifdef PNG_cHRM_SUPPORTED\n   {\n      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,\n         blue_y;\n      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,\n         &red_y, &green_x, &green_y, &blue_x, &blue_y))\n      {\n         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,\n            red_y, green_x, green_y, blue_x, blue_y);\n      }\n   }\n#endif\n#ifdef PNG_gAMA_SUPPORTED\n   {\n      double gamma;\n      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma))\n         png_set_gAMA(write_ptr, write_info_ptr, gamma);\n   }\n#endif\n#endif \n#endif \n#ifdef PNG_iCCP_SUPPORTED\n   {\n      png_charp name;\n      png_bytep profile;\n      png_uint_32 proflen;\n      int compression_type;\n      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,\n                      &profile, &proflen))\n      {\n         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,\n                      profile, proflen);\n      }\n   }\n#endif\n#ifdef PNG_sRGB_SUPPORTED\n   {\n      int intent;\n      if (png_get_sRGB(read_ptr, read_info_ptr, &intent))\n         png_set_sRGB(write_ptr, write_info_ptr, intent);\n   }\n#endif\n   {\n      png_colorp palette;\n      int num_palette;\n      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))\n         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);\n   }\n#ifdef PNG_bKGD_SUPPORTED\n   {\n      png_color_16p background;\n      if (png_get_bKGD(read_ptr, read_info_ptr, &background))\n      {\n         png_set_bKGD(write_ptr, write_info_ptr, background);\n      }\n   }\n#endif\n#ifdef PNG_hIST_SUPPORTED\n   {\n      png_uint_16p hist;\n      if (png_get_hIST(read_ptr, read_info_ptr, &hist))\n         png_set_hIST(write_ptr, write_info_ptr, hist);\n   }\n#endif\n#ifdef PNG_oFFs_SUPPORTED\n   {\n      png_int_32 offset_x, offset_y;\n      int unit_type;\n      if (png_get_oFFs(read_ptr, read_info_ptr, &offset_x, &offset_y,\n          &unit_type))\n      {\n         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);\n      }\n   }\n#endif\n#ifdef PNG_pCAL_SUPPORTED\n   {\n      png_charp purpose, units;\n      png_charpp params;\n      png_int_32 X0, X1;\n      int type, nparams;\n      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,\n         &nparams, &units, &params))\n      {\n         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,\n            nparams, units, params);\n      }\n   }\n#endif\n#ifdef PNG_pHYs_SUPPORTED\n   {\n      png_uint_32 res_x, res_y;\n      int unit_type;\n      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y, &unit_type))\n         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);\n   }\n#endif\n#ifdef PNG_sBIT_SUPPORTED\n   {\n      png_color_8p sig_bit;\n      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))\n         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);\n   }\n#endif\n#ifdef PNG_sCAL_SUPPORTED\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n   {\n      int unit;\n      double scal_width, scal_height;\n      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,\n         &scal_height))\n      {\n         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);\n      }\n   }\n#else\n#ifdef PNG_FIXED_POINT_SUPPORTED\n   {\n      int unit;\n      png_charp scal_width, scal_height;\n      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,\n          &scal_height))\n      {\n         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width,\n             scal_height);\n      }\n   }\n#endif\n#endif\n#endif\n#ifdef PNG_TEXT_SUPPORTED\n   {\n      png_textp text_ptr;\n      int num_text;\n      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)\n      {\n         pngtest_debug1(\"Handling %d iTXt/tEXt/zTXt chunks\", num_text);\n         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);\n      }\n   }\n#endif\n#ifdef PNG_tIME_SUPPORTED\n   {\n      png_timep mod_time;\n      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))\n      {\n         png_set_tIME(write_ptr, write_info_ptr, mod_time);\n#ifdef PNG_TIME_RFC1123_SUPPORTED\n         \n\n\n\n         png_memcpy(tIME_string,\n                    png_convert_to_rfc1123(read_ptr, mod_time),\n                    png_sizeof(tIME_string));\n         tIME_string[png_sizeof(tIME_string) - 1] = '\\0';\n         tIME_chunk_present++;\n#endif \n      }\n   }\n#endif\n#ifdef PNG_tRNS_SUPPORTED\n   {\n      png_bytep trans_alpha;\n      int num_trans;\n      png_color_16p trans_color;\n      if (png_get_tRNS(read_ptr, read_info_ptr, &trans_alpha, &num_trans,\n         &trans_color))\n      {\n         int sample_max = (1 << bit_depth);\n         \n         if (!((color_type == PNG_COLOR_TYPE_GRAY &&\n             (int)trans_color->gray > sample_max) ||\n             (color_type == PNG_COLOR_TYPE_RGB &&\n             ((int)trans_color->red > sample_max ||\n             (int)trans_color->green > sample_max ||\n             (int)trans_color->blue > sample_max))))\n            png_set_tRNS(write_ptr, write_info_ptr, trans_alpha, num_trans,\n               trans_color);\n      }\n   }\n#endif\n#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED\n   {\n      png_unknown_chunkp unknowns;\n      int num_unknowns = png_get_unknown_chunks(read_ptr, read_info_ptr,\n         &unknowns);\n      if (num_unknowns)\n      {\n         int i;\n         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,\n           num_unknowns);\n         \n\n\n\n         for (i = 0; i < num_unknowns; i++)\n           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,\n             unknowns[i].location);\n      }\n   }\n#endif\n#ifdef PNG_WRITE_SUPPORTED\n   pngtest_debug(\"Writing info struct\");\n\n\n\n   png_write_info(write_ptr, write_info_ptr);\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n   if (user_chunk_data[0] != 0)\n   {\n      png_byte png_sTER[5] = {115,  84,  69,  82, '\\0'};\n      unsigned char\n        ster_chunk_data[1];\n      if (verbose)\n         fprintf(STDERR, \"\\n stereo mode = %lu\\n\",\n           (unsigned long)(user_chunk_data[0] - 1));\n      ster_chunk_data[0]=(unsigned char)(user_chunk_data[0] - 1);\n      png_write_chunk(write_ptr, png_sTER, ster_chunk_data, 1);\n   }\n   if (user_chunk_data[1] != 0 || user_chunk_data[2] != 0)\n   {\n      png_byte png_vpAg[5] = {118, 112,  65, 103, '\\0'};\n      unsigned char\n        vpag_chunk_data[9];\n      if (verbose)\n         fprintf(STDERR, \" vpAg = %lu x %lu, units = %lu\\n\",\n           (unsigned long)user_chunk_data[1],\n           (unsigned long)user_chunk_data[2],\n           (unsigned long)user_chunk_data[3]);\n      png_save_uint_32(vpag_chunk_data, user_chunk_data[1]);\n      png_save_uint_32(vpag_chunk_data + 4, user_chunk_data[2]);\n      vpag_chunk_data[8] = (unsigned char)(user_chunk_data[3] & 0xff);\n      png_write_chunk(write_ptr, png_vpAg, vpag_chunk_data, 9);\n   }\n#endif\n#endif\n#ifdef SINGLE_ROWBUF_ALLOC\n   pngtest_debug(\"Allocating row buffer...\");\n   row_buf = (png_bytep)png_malloc(read_ptr,\n      png_get_rowbytes(read_ptr, read_info_ptr));\n   pngtest_debug1(\"\\t0x%08lx\", (unsigned long)row_buf);\n#endif \n   pngtest_debug(\"Writing row data\");\n#if defined(PNG_READ_INTERLACING_SUPPORTED) || \\\n  defined(PNG_WRITE_INTERLACING_SUPPORTED)\n   num_pass = png_set_interlace_handling(read_ptr);\n#  ifdef PNG_WRITE_SUPPORTED\n   png_set_interlace_handling(write_ptr);\n#  endif\n#else\n   num_pass = 1;\n#endif\n#ifdef PNGTEST_TIMING\n   t_stop = (float)clock();\n   t_misc += (t_stop - t_start);\n   t_start = t_stop;\n#endif\n   for (pass = 0; pass < num_pass; pass++)\n   {\n      pngtest_debug1(\"Writing row data for pass %d\", pass);\n      for (y = 0; y < height; y++)\n      {\n#ifndef SINGLE_ROWBUF_ALLOC\n         pngtest_debug2(\"Allocating row buffer (pass %d, y = %u)...\", pass, y);\n         row_buf = (png_bytep)png_malloc(read_ptr,\n            png_get_rowbytes(read_ptr, read_info_ptr));\n         pngtest_debug2(\"\\t0x%08lx (%u bytes)\", (unsigned long)row_buf,\n            png_get_rowbytes(read_ptr, read_info_ptr));\n#endif \n         png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);\n#ifdef PNG_WRITE_SUPPORTED\n#ifdef PNGTEST_TIMING\n         t_stop = (float)clock();\n         t_decode += (t_stop - t_start);\n         t_start = t_stop;\n#endif\n         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);\n#ifdef PNGTEST_TIMING\n         t_stop = (float)clock();\n         t_encode += (t_stop - t_start);\n         t_start = t_stop;\n#endif\n#endif \n#ifndef SINGLE_ROWBUF_ALLOC\n         pngtest_debug2(\"Freeing row buffer (pass %d, y = %u)\", pass, y);\n         png_free(read_ptr, row_buf);\n         row_buf = NULL;\n#endif \n      }\n   }\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);\n#endif\n#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED\n   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);\n#endif\n   pngtest_debug(\"Reading and writing end_info data\");\n   png_read_end(read_ptr, end_info_ptr);\n#ifdef PNG_TEXT_SUPPORTED\n   {\n      png_textp text_ptr;\n      int num_text;\n      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)\n      {\n         pngtest_debug1(\"Handling %d iTXt/tEXt/zTXt chunks\", num_text);\n         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);\n      }\n   }\n#endif\n#ifdef PNG_tIME_SUPPORTED\n   {\n      png_timep mod_time;\n      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))\n      {\n         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);\n#ifdef PNG_TIME_RFC1123_SUPPORTED\n         \n\n\n         png_memcpy(tIME_string,\n                    png_convert_to_rfc1123(read_ptr, mod_time),\n                    png_sizeof(tIME_string));\n         tIME_string[png_sizeof(tIME_string) - 1] = '\\0';\n         tIME_chunk_present++;\n#endif \n      }\n   }\n#endif\n#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED\n   {\n      png_unknown_chunkp unknowns;\n      int num_unknowns = png_get_unknown_chunks(read_ptr, end_info_ptr,\n         &unknowns);\n      if (num_unknowns)\n      {\n         int i;\n         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,\n           num_unknowns);\n         \n\n\n\n         for (i = 0; i < num_unknowns; i++)\n           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,\n             unknowns[i].location);\n      }\n   }\n#endif\n#ifdef PNG_WRITE_SUPPORTED\n   png_write_end(write_ptr, write_end_info_ptr);\n#endif\n#ifdef PNG_EASY_ACCESS_SUPPORTED\n   if (verbose)\n   {\n      png_uint_32 iwidth, iheight;\n      iwidth = png_get_image_width(write_ptr, write_info_ptr);\n      iheight = png_get_image_height(write_ptr, write_info_ptr);\n      fprintf(STDERR, \"\\n Image width = %lu, height = %lu\\n\",\n         (unsigned long)iwidth, (unsigned long)iheight);\n   }\n#endif\n   pngtest_debug(\"Destroying data structs\");\n#ifdef SINGLE_ROWBUF_ALLOC\n   pngtest_debug(\"destroying row_buf for read_ptr\");\n   png_free(read_ptr, row_buf);\n   row_buf = NULL;\n#endif \n   pngtest_debug(\"destroying read_ptr, read_info_ptr, end_info_ptr\");\n   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n   pngtest_debug(\"destroying write_end_info_ptr\");\n   png_destroy_info_struct(write_ptr, &write_end_info_ptr);\n   pngtest_debug(\"destroying write_ptr, write_info_ptr\");\n   png_destroy_write_struct(&write_ptr, &write_info_ptr);\n#endif\n   pngtest_debug(\"Destruction complete.\");\n   FCLOSE(fpin);\n   FCLOSE(fpout);\n   pngtest_debug(\"Opening files for comparison\");\n   if ((fpin = fopen(inname, \"rb\")) == NULL)\n   {\n      fprintf(STDERR, \"Could not find file %s\\n\", inname);\n      return (1);\n   }\n   if ((fpout = fopen(outname, \"rb\")) == NULL)\n   {\n      fprintf(STDERR, \"Could not find file %s\\n\", outname);\n      FCLOSE(fpin);\n      return (1);\n   }\n   for (;;)\n   {\n      png_size_t num_in, num_out;\n         num_in = fread(inbuf, 1, 1, fpin);\n         num_out = fread(outbuf, 1, 1, fpout);\n      if (num_in != num_out)\n      {\n         fprintf(STDERR, \"\\nFiles %s and %s are of a different size\\n\",\n                 inname, outname);\n         if (wrote_question == 0)\n         {\n            fprintf(STDERR,\n         \"   Was %s written with the same maximum IDAT chunk size (%d bytes),\",\n              inname, PNG_ZBUF_SIZE);\n            fprintf(STDERR,\n              \"\\n   filtering heuristic (libpng default), compression\");\n            fprintf(STDERR,\n              \" level (zlib default),\\n   and zlib version (%s)?\\n\\n\",\n              ZLIB_VERSION);\n            wrote_question = 1;\n         }\n         FCLOSE(fpin);\n         FCLOSE(fpout);\n         return (0);\n      }\n      if (!num_in)\n         break;\n      if (png_memcmp(inbuf, outbuf, num_in))\n      {\n         fprintf(STDERR, \"\\nFiles %s and %s are different\\n\", inname, outname);\n         if (wrote_question == 0)\n         {\n            fprintf(STDERR,\n         \"   Was %s written with the same maximum IDAT chunk size (%d bytes),\",\n                 inname, PNG_ZBUF_SIZE);\n            fprintf(STDERR,\n              \"\\n   filtering heuristic (libpng default), compression\");\n            fprintf(STDERR,\n              \" level (zlib default),\\n   and zlib version (%s)?\\n\\n\",\n              ZLIB_VERSION);\n            wrote_question = 1;\n         }\n         FCLOSE(fpin);\n         FCLOSE(fpout);\n         return (0);\n      }\n   }\n   FCLOSE(fpin);\n   FCLOSE(fpout);\n   return (0);\n}\n", "bug_type": null, "idx": 288}
{"project": "LibPNG", "target": 0, "func": "#include <sys/ioctl.h>\nint repl_getch( void )\n{\n  char ch;\n  int fd = fileno(stdin);\n  struct termio old_tty, new_tty;\n  ioctl(fd, TCGETA, &old_tty);\n  new_tty = old_tty;\n  new_tty.c_lflag &= ~(ICANON | ECHO | ISIG);\n  ioctl(fd, TCSETA, &new_tty);\n  fread(&ch, 1, sizeof(ch), stdin);\n  ioctl(fd, TCSETA, &old_tty);\n  return ch;\n}\n", "bug_type": null, "idx": 289}
{"project": "LibPNG", "target": 1, "func": "\nstatic png_size_t\npng_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,\n        png_bytep output, png_size_t output_size)\n{\n   png_size_t count = 0;\n\n   png_ptr->zstream.next_in = (png_bytep)data; \n   png_ptr->zstream.avail_in = size;\n\n   while (1)\n   {\n      int ret, avail;\n\n      \n\n\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = png_ptr->zbuf_size;\n\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\n      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n\n      \n\n\n      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)\n      {\n         if (output != 0 && output_size > count)\n         {\n            int copy = output_size - count;\n            if (avail < copy) copy = avail;\n            png_memcpy(output + count, png_ptr->zbuf, copy);\n         }\n\n         count += avail;\n      }\n\n      if (ret == Z_OK)\n         continue;\n\n      \n\n\n      png_ptr->zstream.avail_in = 0;\n      inflateReset(&png_ptr->zstream);\n\n      if (ret == Z_STREAM_END)\n         return count; \n\n      \n\n\n\n      {\n         PNG_CONST char *msg;\n         if (png_ptr->zstream.msg != 0)\n            msg = png_ptr->zstream.msg;\n         else\n         {\n#ifdef PNG_STDIO_SUPPORTED\n            char umsg[52];\n\n            switch (ret)\n            {\n               case Z_BUF_ERROR:\n                  msg = \"Buffer error in compressed datastream in %s chunk\";\n                  break;\n\n               case Z_DATA_ERROR:\n                  msg = \"Data error in compressed datastream in %s chunk\";\n                  break;\n\n               default:\n                  msg = \"Incomplete compressed datastream in %s chunk\";\n                  break;\n            }\n\n            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);\n            msg = umsg;\n#else\n            msg = \"Damaged compressed datastream in chunk other than IDAT\";\n#endif\n         }\n\n         png_warning(png_ptr, msg);\n      }\n\n      \n\n\n      return 0;\n   }\n}\n", "bug_type": "cve-2011-3045", "idx": 290}
{"project": "LibPNG", "target": 0, "func": "void \npng_read_data(png_structrp png_ptr, png_bytep data, png_size_t length)\n{\n   png_debug1(4, \"reading %d bytes\", (int)length);\n   if (png_ptr->read_data_fn != NULL)\n      (*(png_ptr->read_data_fn))(png_ptr, data, length);\n   else\n      png_error(png_ptr, \"Call to NULL read function\");\n}\n", "bug_type": null, "idx": 291}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_image_validate(transform_display *dp, png_const_structp pp,\n   png_infop pi)\n{\n   \n   PNG_CONST png_store* PNG_CONST ps = dp->this.ps;\n   PNG_CONST png_byte in_ct = dp->this.colour_type;\n   PNG_CONST png_byte in_bd = dp->this.bit_depth;\n   PNG_CONST png_uint_32 w = dp->this.w;\n   PNG_CONST png_uint_32 h = dp->this.h;\n   PNG_CONST png_byte out_ct = dp->output_colour_type;\n   PNG_CONST png_byte out_bd = dp->output_bit_depth;\n   PNG_CONST png_byte sample_depth = (png_byte)(out_ct ==\n      PNG_COLOR_TYPE_PALETTE ? 8 : out_bd);\n   PNG_CONST png_byte red_sBIT = dp->this.red_sBIT;\n   PNG_CONST png_byte green_sBIT = dp->this.green_sBIT;\n   PNG_CONST png_byte blue_sBIT = dp->this.blue_sBIT;\n   PNG_CONST png_byte alpha_sBIT = dp->this.alpha_sBIT;\n   PNG_CONST int have_tRNS = dp->this.is_transparent;\n   double digitization_error;\n   store_palette out_palette;\n   png_uint_32 y;\n   UNUSED(pi)\n   \n   store_image_check(dp->this.ps, pp, 0);\n   \n\n\n   if (out_ct == PNG_COLOR_TYPE_PALETTE)\n   {\n      \n\n\n      int npalette = (-1);\n      (void)read_palette(out_palette, &npalette, pp, pi);\n      if (npalette != dp->this.npalette)\n         png_error(pp, \"unexpected change in palette size\");\n      digitization_error = .5;\n   }\n   else\n   {\n      png_byte in_sample_depth;\n      memset(out_palette, 0x5e, sizeof out_palette);\n      \n\n\n\n      if (in_ct == PNG_COLOR_TYPE_PALETTE || in_bd < 16)\n         in_sample_depth = 8;\n      else\n         in_sample_depth = in_bd;\n      if (sample_depth != 16 || in_sample_depth > 8 ||\n         !dp->pm->calculations_use_input_precision)\n         digitization_error = .5;\n      \n\n\n      else\n         digitization_error = .5 * 257;\n   }\n   for (y=0; y<h; ++y)\n   {\n      png_const_bytep PNG_CONST pRow = store_image_row(ps, pp, 0, y);\n      png_uint_32 x;\n      \n      png_byte std[STANDARD_ROWMAX];\n      transform_row(pp, std, in_ct, in_bd, y);\n      \n\n\n      for (x=0; x<w; ++x)\n      {\n         image_pixel in_pixel, out_pixel;\n         unsigned int r, g, b, a;\n         \n         image_pixel_init(&in_pixel, std, in_ct, in_bd, x, dp->this.palette);\n         in_pixel.red_sBIT = red_sBIT;\n         in_pixel.green_sBIT = green_sBIT;\n         in_pixel.blue_sBIT = blue_sBIT;\n         in_pixel.alpha_sBIT = alpha_sBIT;\n         in_pixel.have_tRNS = have_tRNS;\n         \n         r = in_pixel.red;\n         g = in_pixel.green;\n         b = in_pixel.blue;\n         a = in_pixel.alpha;\n         dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp);\n         \n\n\n         image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette);\n         \n\n\n         if (in_ct == PNG_COLOR_TYPE_PALETTE &&\n            out_ct == PNG_COLOR_TYPE_PALETTE)\n         {\n            if (in_pixel.palette_index != out_pixel.palette_index)\n               png_error(pp, \"unexpected transformed palette index\");\n         }\n         \n\n\n         if (in_pixel.red != out_pixel.red)\n            transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf,\n               out_pixel.red, sample_depth, in_pixel.rede,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.red_sBIT)-1)), \"red/gray\",\n               digitization_error);\n         if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&\n            in_pixel.green != out_pixel.green)\n            transform_range_check(pp, r, g, b, a, in_pixel.green,\n               in_pixel.greenf, out_pixel.green, sample_depth, in_pixel.greene,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.green_sBIT)-1)), \"green\",\n               digitization_error);\n         if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&\n            in_pixel.blue != out_pixel.blue)\n            transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef,\n               out_pixel.blue, sample_depth, in_pixel.bluee,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), \"blue\",\n               digitization_error);\n         if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&\n            in_pixel.alpha != out_pixel.alpha)\n            transform_range_check(pp, r, g, b, a, in_pixel.alpha,\n               in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.alpha_sBIT)-1)), \"alpha\",\n               digitization_error);\n      } \n   } \n   \n   dp->this.ps->validated = 1;\n}\n", "bug_type": null, "idx": 292}
{"project": "LibPNG", "target": 0, "func": "static void\nsBIT0_error_fn(png_structp pp, png_infop pi)\n{\n   \n   png_color_8 bad;\n   bad.red = bad.green = bad.blue = bad.gray = bad.alpha = 0;\n   png_set_sBIT(pp, pi, &bad);\n}\n", "bug_type": null, "idx": 293}
{"project": "LibPNG", "target": 0, "func": "static void\nfreebuffer(Image *image)\n{\n   if (image->buffer) free(image->buffer);\n   image->buffer = NULL;\n   image->bufsize = 0;\n   image->allocsize = 0;\n}\n", "bug_type": null, "idx": 294}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_encoding_iterate(png_modifier *pm)\n{\n   if (!pm->repeat && \n      pm->test_uses_encoding) \n   {\n      if (pm->test_exhaustive)\n      {\n         if (++pm->encoding_counter >= modifier_total_encodings(pm))\n            pm->encoding_counter = 0; \n      }\n      else\n      {\n         \n\n\n         if (pm->encoding_counter == 0)\n            pm->encoding_counter = random_mod(modifier_total_encodings(pm)-1)+1;\n         else\n            pm->encoding_counter = 0;\n      }\n      if (pm->encoding_counter > 0)\n         pm->repeat = 1;\n   }\n   else if (!pm->repeat)\n      pm->encoding_counter = 0;\n}\n", "bug_type": null, "idx": 295}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nerror_handler(png_structp png_ptr, png_const_charp message)\n{\n   stop(get_control(png_ptr),  LIBPNG_ERROR_CODE, message);\n}\n", "bug_type": null, "idx": 296}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\ndisplay_warning(png_structp pp, png_const_charp warning)\n{\n   display_log(get_dp(pp), LIBPNG_WARNING, \"%s\", warning);\n}\n", "bug_type": null, "idx": 297}
{"project": "LibPNG", "target": 0, "func": "static void\ndisplay_clean_read(struct display *dp)\n{\n   if (dp->read_pp != NULL)\n      png_destroy_read_struct(&dp->read_pp, &dp->read_ip, NULL);\n}\n", "bug_type": null, "idx": 298}
{"project": "LibPNG", "target": 0, "func": "static store_palette_entry *\nmake_standard_palette(png_store* ps, int npalette, int do_tRNS)\n{\n   static png_uint_32 palette_seed[2] = { 0x87654321, 9 };\n   int i = 0;\n   png_byte values[256][4];\n   \n\n   for (; i<8; ++i)\n   {\n      values[i][1] = (png_byte)((i&1) ? 255U : 0U);\n      values[i][2] = (png_byte)((i&2) ? 255U : 0U);\n      values[i][3] = (png_byte)((i&4) ? 255U : 0U);\n   }\n   \n   {\n      int j = 0;\n      png_byte random_bytes[4];\n      png_byte need[256];\n      need[0] = 0; \n      memset(need+1, 1, (sizeof need)-2); \n      need[255] = 0; \n      while (i<70)\n      {\n         png_byte b;\n         if (j==0)\n         {\n            make_four_random_bytes(palette_seed, random_bytes);\n            j = 4;\n         }\n         b = random_bytes[--j];\n         if (need[b])\n         {\n            values[i][1] = b;\n            values[i][2] = b;\n            values[i++][3] = b;\n         }\n      }\n   }\n   \n\n\n\n\n   for (; i<256; ++i)\n      make_four_random_bytes(palette_seed, values[i]);\n   \n\n\n   {\n      store_palette_entry *palette;\n      png_byte selector[4];\n      make_four_random_bytes(palette_seed, selector);\n      if (do_tRNS)\n         for (i=0; i<256; ++i)\n            values[i][0] = (png_byte)(i ^ selector[0]);\n      else\n         for (i=0; i<256; ++i)\n            values[i][0] = 255; \n      \n\n\n\n\n\n\n\n\n      palette = store_write_palette(ps, npalette);\n      for (i=0; i<npalette; ++i)\n      {\n         palette[i].alpha = values[i ^ selector[1]][0];\n         palette[i].red   = values[i ^ selector[1]][1];\n         palette[i].green = values[i ^ selector[1]][2];\n         palette[i].blue  = values[i ^ selector[1]][3];\n      }\n      return palette;\n   }\n}\n", "bug_type": null, "idx": 299}
{"project": "LibPNG", "target": 0, "func": "static int\nglobal_end(struct global *global)\n{\n   int rc;\n   IDAT_list_end(&global->idat_cache);\n   rc = global->status_code;\n   CLEAR(*global);\n   return rc;\n}\n", "bug_type": null, "idx": 300}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\nstandard_rowsize(png_const_structp pp, png_uint_32 id)\n{\n   png_uint_32 width = standard_width(pp, id);\n   \n   width *= bit_size(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));\n   return (width + 7) / 8;\n}\n", "bug_type": null, "idx": 301}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_ag8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = p->g = p->b = pp[1];\n   p->a = pp[0];\n}\n", "bug_type": null, "idx": 302}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_background_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_byte colour_type, bit_depth;\n   png_byte random_bytes[8]; \n   int expand;\n   png_color_16 back;\n   \n\n\n\n\n   RANDOMIZE(random_bytes);\n   \n\n\n   colour_type = that->this.colour_type;\n   if (colour_type == 3)\n   {\n      colour_type = PNG_COLOR_TYPE_RGB;\n      bit_depth = 8;\n      expand = 0; \n   }\n   else\n   {\n      bit_depth = that->this.bit_depth;\n      expand = 1;\n   }\n   image_pixel_init(&data, random_bytes, colour_type,\n      bit_depth, 0, 0);\n   \n\n\n   RANDOMIZE(back);\n   if (colour_type & PNG_COLOR_MASK_COLOR)\n   {\n      back.red = (png_uint_16)data.red;\n      back.green = (png_uint_16)data.green;\n      back.blue = (png_uint_16)data.blue;\n   }\n   else\n      back.gray = (png_uint_16)data.red;\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\n      png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);\n#  else\n      png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);\n#  endif\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 303}
{"project": "LibPNG", "target": 0, "func": "#ifdef DOS_OS2_W32\nstatic char *dos_kbd_gets(char *buf, int len)\n{\n    int ch, count=0;\n    do {\n        buf[count++] = ch = getche();\n    } while (ch != '\\r' && count < len-1);\n    buf[count--] = '\\0';        \n    if (buf[count] == '\\r')     \n        buf[count] = '\\n';\n    fprintf(stderr, \"\\n\");      \n    fflush(stderr);\n    return buf;\n}\n", "bug_type": null, "idx": 304}
{"project": "LibPNG", "target": 0, "func": " * read and processed--i.e., we now have enough info to finish initializing */\nstatic void rpng2_x_init(void)\n{\n    ulg i;\n    ulg rowbytes = rpng2_info.rowbytes;\n    Trace((stderr, \"beginning rpng2_x_init()\\n\"))\n    Trace((stderr, \"  rowbytes = %d\\n\", rpng2_info.rowbytes))\n    Trace((stderr, \"  width  = %ld\\n\", rpng2_info.width))\n    Trace((stderr, \"  height = %ld\\n\", rpng2_info.height))\n    rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height);\n    if (!rpng2_info.image_data) {\n        readpng2_cleanup(&rpng2_info);\n        return;\n    }\n    rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *));\n    if (!rpng2_info.row_pointers) {\n        free(rpng2_info.image_data);\n        rpng2_info.image_data = NULL;\n        readpng2_cleanup(&rpng2_info);\n        return;\n    }\n    for (i = 0;  i < rpng2_info.height;  ++i)\n        rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes;\n    \n\n\n    if (rpng2_x_create_window()) {\n        \n\n\n\n        \n        readpng2_cleanup(&rpng2_info);\n        rpng2_x_cleanup();\n        exit(2);\n    }\n    rpng2_info.state = kWindowInit;\n}\n", "bug_type": null, "idx": 305}
{"project": "LibPNG", "target": 0, "func": "static int check_all_characters(checkfp_command *co, checkfp_control c)\n{\n   int ch;\n   if (c.cnumber+4 < sizeof co->number) for (ch=0; ch<256; ++ch)\n   {\n      if (!check_one_character(co, c, ch))\n         return 0;\n   }\n   return 1;\n}\n", "bug_type": null, "idx": 306}
{"project": "LibPNG", "target": 0, "func": "static int verbose = 0;\nint validation_ascii_to_fp(int count, int argc, char **argv)\n{\n   int    showall = 0;\n   double max_error=2;      \n   double max_error_abs=17; \n   double max = 0;\n   double max_abs = 0;\n   double test = 0; \n   int    precision = 5;\n   int    nonfinite = 0;\n   int    finite = 0;\n   int    ok = 0;\n   int    failcount = 0;\n   int    minorarith = 0;\n   while (--argc > 0)\n      if (strcmp(*++argv, \"-a\") == 0)\n         showall = 1;\n      else if (strcmp(*argv, \"-e\") == 0 && argc > 0)\n      {\n         --argc;\n         max_error = atof(*++argv);\n      }\n      else if (strcmp(*argv, \"-E\") == 0 && argc > 0)\n      {\n         --argc;\n         max_error_abs = atof(*++argv);\n      }\n      else\n      {\n         fprintf(stderr, \"unknown argument %s\\n\", *argv);\n         return 1;\n      }\n   do\n   {\n      png_size_t index;\n      int state, failed = 0;\n      char buffer[64];\n      if (isfinite(test))\n         ++finite;\n      else\n         ++nonfinite;\n      if (verbose)\n         fprintf(stderr, \"%.*g %d\\n\", DBL_DIG, test, precision);\n      \n      memset(buffer, 71, sizeof buffer);\n      png_ascii_from_fp(0, buffer, precision+10, test, precision);\n      \n\n\n      if (buffer[precision+7] != 71)\n      {\n         fprintf(stderr, \"%g[%d] -> '%s'[%lu] buffer overflow\\n\", test,\n            precision, buffer, (unsigned long)strlen(buffer));\n         failed = 1;\n      }\n      \n\n\n      state = 0;\n      index = 0;\n      if (!isfinite(test))\n      {\n         \n         if (test >= 0 && strcmp(buffer, \"inf\") ||\n             test <  0 && strcmp(buffer, \"-inf\"))\n         {\n            fprintf(stderr, \"%g[%d] -> '%s' but expected 'inf'\\n\", test,\n               precision, buffer);\n            failed = 1;\n         }\n      }\n      else if (!png_check_fp_number(buffer, precision+10, &state, &index) ||\n          buffer[index] != 0)\n      {\n         fprintf(stderr, \"%g[%d] -> '%s' but has bad format ('%c')\\n\", test,\n         precision, buffer, buffer[index]);\n         failed = 1;\n      }\n      else if (PNG_FP_IS_NEGATIVE(state) && !(test < 0))\n      {\n         fprintf(stderr, \"%g[%d] -> '%s' but negative value not so reported\\n\",\n            test, precision, buffer);\n         failed = 1;\n         assert(!PNG_FP_IS_ZERO(state));\n         assert(!PNG_FP_IS_POSITIVE(state));\n      }\n      else if (PNG_FP_IS_ZERO(state) && !(test == 0))\n      {\n         fprintf(stderr, \"%g[%d] -> '%s' but zero value not so reported\\n\",\n            test, precision, buffer);\n         failed = 1;\n         assert(!PNG_FP_IS_NEGATIVE(state));\n         assert(!PNG_FP_IS_POSITIVE(state));\n      }\n      else if (PNG_FP_IS_POSITIVE(state) && !(test > 0))\n      {\n         fprintf(stderr, \"%g[%d] -> '%s' but postive value not so reported\\n\",\n            test, precision, buffer);\n         failed = 1;\n         assert(!PNG_FP_IS_NEGATIVE(state));\n         assert(!PNG_FP_IS_ZERO(state));\n      }\n      else\n      {\n         \n         double out = atof(buffer);\n         double change = fabs((out - test)/test);\n         double allow = .5/pow(10,\n            (precision >= DBL_DIG) ? DBL_DIG-1 : precision-1);\n         \n\n\n\n\n\n\n         if (change >= allow && (isfinite(out) ||\n             fabs(test/DBL_MAX) <= 1-allow))\n         {\n            double percent = (precision >= DBL_DIG) ? max_error_abs : max_error;\n            double allowp = (change-allow)*100/allow;\n            if (precision >= DBL_DIG)\n            {\n               if (max_abs < allowp) max_abs = allowp;\n            }\n            else\n            {\n               if (max < allowp) max = allowp;\n            }\n            if (showall || allowp >= percent)\n            {\n               fprintf(stderr,\n                  \"%.*g[%d] -> '%s' -> %.*g number changed (%g > %g (%d%%))\\n\",\n                  DBL_DIG, test, precision, buffer, DBL_DIG, out, change, allow,\n                  (int)round(allowp));\n               failed = 1;\n            }\n            else\n               ++minorarith;\n         }\n      }\n      if (failed)\n         ++failcount;\n      else\n         ++ok;\nskip:\n      \n      precision = rand();\n      if (precision & 1) test = -test;\n      precision >>= 1;\n      \n      if (test == 0 || !isfinite(test))\n         test = precision+1;\n      else\n      {\n         \n         int exponent = precision % (DBL_MAX_EXP - DBL_MIN_EXP) + DBL_MIN_EXP;\n         int tmp;\n         test = frexp(test * rand(), &tmp);\n         test = ldexp(test, exponent);\n         precision >>= 8; \n      }\n      \n\n\n      precision = (precision & 0x1f) + 1;\n   }\n   while (--count);\n   printf(\"Tested %d finite values, %d non-finite, %d OK (%d failed) %d minor \"\n      \"arithmetic errors\\n\", finite, nonfinite, ok, failcount, minorarith);\n   printf(\" Error with >=%d digit precision %.2f%%\\n\", DBL_DIG, max_abs);\n   printf(\" Error with < %d digit precision %.2f%%\\n\", DBL_DIG, max);\n   return 0;\n}\n", "bug_type": null, "idx": 307}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\nstandard_height(png_const_structp pp, png_uint_32 id)\n{\n   png_uint_32 height = HEIGHT_FROM_ID(id);\n   if (height == 0)\n      height = transform_height(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));\n   return height;\n}\n", "bug_type": null, "idx": 308}
{"project": "LibPNG", "target": 0, "func": "static int\npixel_cmp(png_const_bytep pa, png_const_bytep pb, png_uint_32 bit_width)\n{\n#if PNG_LIBPNG_VER < 10506\n   if (memcmp(pa, pb, bit_width>>3) == 0)\n   {\n      png_uint_32 p;\n      if ((bit_width & 7) == 0) return 0;\n      \n      p = pa[bit_width >> 3];\n      p ^= pb[bit_width >> 3];\n      if (p == 0) return 0;\n      \n\n\n      bit_width &= 7;\n      p >>= 8-bit_width;\n      if (p == 0) return 0;\n   }\n#else\n   \n\n\n   if (memcmp(pa, pb, (bit_width+7)>>3) == 0)\n      return 0;\n#endif\n   \n   {\n      png_uint_32 where = 0;\n      while (pa[where] == pb[where]) ++where;\n      return 1+where;\n   }\n}\n", "bug_type": null, "idx": 309}
{"project": "LibPNG", "target": 0, "func": "static int rpng_win_create_window(HINSTANCE hInst, int showmode)\n{\n    uch *dest;\n    int extra_width, extra_height;\n    ulg i, j;\n    WNDCLASSEX wndclass;\n\n\n\n\n    wimage_rowbytes = ((3*image_width + 3L) >> 2) << 2;\n    if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) +\n                              wimage_rowbytes*image_height)))\n    {\n        return 4;   \n    }\n\n\n\n\n\n\n    memset(dib, 0, sizeof(BITMAPINFOHEADER));\n    bmih = (BITMAPINFOHEADER *)dib;\n    bmih->biSize = sizeof(BITMAPINFOHEADER);\n    bmih->biWidth = image_width;\n    bmih->biHeight = -((long)image_height);\n    bmih->biPlanes = 1;\n    bmih->biBitCount = 24;\n    bmih->biCompression = 0;\n    wimage_data = dib + sizeof(BITMAPINFOHEADER);\n\n\n\n    for (j = 0;  j < image_height;  ++j) {\n        dest = wimage_data + j*wimage_rowbytes;\n        for (i = image_width;  i > 0;  --i) {\n            *dest++ = bg_blue;\n            *dest++ = bg_green;\n            *dest++ = bg_red;\n        }\n    }\n\n\n\n    memset(&wndclass, 0, sizeof(wndclass));\n    wndclass.cbSize = sizeof(wndclass);\n    wndclass.style = CS_HREDRAW | CS_VREDRAW;\n    wndclass.lpfnWndProc = rpng_win_wndproc;\n    wndclass.hInstance = hInst;\n    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);\n    wndclass.lpszMenuName = NULL;\n    wndclass.lpszClassName = progname;\n    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n    RegisterClassEx(&wndclass);\n\n\n\n    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +\n                      GetSystemMetrics(SM_CXDLGFRAME));\n    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +\n                      GetSystemMetrics(SM_CYDLGFRAME)) +\n                      GetSystemMetrics(SM_CYCAPTION);\n    global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW,\n      CW_USEDEFAULT, CW_USEDEFAULT, image_width+extra_width,\n      image_height+extra_height, NULL, NULL, hInst, NULL);\n    ShowWindow(global_hwnd, showmode);\n    UpdateWindow(global_hwnd);\n    return 0;\n} \n", "bug_type": null, "idx": 310}
{"project": "LibPNG", "target": 0, "func": "static int\npng_have_neon(png_structp png_ptr)\n{\n   int fd = open(\"/proc/self/auxv\", O_RDONLY);\n   Elf32_auxv_t aux;\n   \n   if (fd == -1)\n   {\n      png_warning(png_ptr, \"/proc/self/auxv open failed\");\n      return 0;\n   }\n   while (safe_read(png_ptr, fd, &aux, sizeof aux) == sizeof aux)\n   {\n      if (aux.a_type == AT_HWCAP && (aux.a_un.a_val & HWCAP_NEON) != 0)\n      {\n         close(fd);\n         return 1;\n      }\n   }\n   close(fd);\n   return 0;\n}\n", "bug_type": null, "idx": 311}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_sG(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535);\n   out->a = 255;\n}\n", "bug_type": null, "idx": 312}
{"project": "LibPNG", "target": 0, "func": "static png_byte\nsRGB(double linear )\n{\n   return u8d(255 * sRGB_from_linear(linear));\n}\n", "bug_type": null, "idx": 313}
{"project": "LibPNG", "target": 0, "func": "static png_uint_16 png_exp16bit(png_uint_32 log)\n{\n   return (png_uint_16)floor(.5 + exp(log * -LN2) * 65535);\n}\n", "bug_type": null, "idx": 314}
{"project": "LibPNG", "target": 0, "func": "static int\ncheck(FILE *fp, int argc, const char **argv, png_uint_32p flags,\n   display *d, int set_callback)\n{\n   int i, npasses, ipass;\n   png_uint_32 height;\n   d->keep = PNG_HANDLE_CHUNK_AS_DEFAULT;\n   d->before_IDAT = 0;\n   d->after_IDAT = 0;\n   \n\n\n   d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error,\n      warning);\n   if (d->png_ptr == NULL)\n   {\n      fprintf(stderr, \"%s(%s): could not allocate png struct\\n\", d->file,\n         d->test);\n      \n      exit(1);\n   }\n   d->info_ptr = png_create_info_struct(d->png_ptr);\n   d->end_ptr = png_create_info_struct(d->png_ptr);\n   if (d->info_ptr == NULL || d->end_ptr == NULL)\n   {\n      fprintf(stderr, \"%s(%s): could not allocate png info\\n\", d->file,\n         d->test);\n      clean_display(d);\n      exit(1);\n   }\n   png_init_io(d->png_ptr, fp);\n#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n      \n\n\n      if (set_callback)\n         png_set_read_user_chunk_fn(d->png_ptr, d, read_callback);\n#  else\n      UNUSED(set_callback)\n#  endif\n   \n\n\n\n   for (i=0; i<argc; ++i)\n   {\n      const char *equals = strchr(argv[i], '=');\n      if (equals != NULL)\n      {\n         int chunk, option;\n         if (strcmp(equals+1, \"default\") == 0)\n            option = PNG_HANDLE_CHUNK_AS_DEFAULT;\n         else if (strcmp(equals+1, \"discard\") == 0)\n            option = PNG_HANDLE_CHUNK_NEVER;\n         else if (strcmp(equals+1, \"if-safe\") == 0)\n            option = PNG_HANDLE_CHUNK_IF_SAFE;\n         else if (strcmp(equals+1, \"save\") == 0)\n            option = PNG_HANDLE_CHUNK_ALWAYS;\n         else\n         {\n            fprintf(stderr, \"%s(%s): %s: unrecognized chunk option\\n\", d->file,\n               d->test, argv[i]);\n            display_exit(d);\n         }\n         switch (equals - argv[i])\n         {\n            case 4: \n               chunk = find(argv[i]);\n               if (chunk >= 0)\n               {\n                  \n\n\n\n\n                  png_byte name[5];\n                  memcpy(name, chunk_info[chunk].name, 5);\n                  png_set_keep_unknown_chunks(d->png_ptr, option, name, 1);\n                  chunk_info[chunk].keep = option;\n                  continue;\n               }\n               break;\n            case 7: \n               if (memcmp(argv[i], \"default\", 7) == 0)\n               {\n                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, 0);\n                  d->keep = option;\n                  continue;\n               }\n               break;\n            case 3: \n               if (memcmp(argv[i], \"all\", 3) == 0)\n               {\n                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, -1);\n                  d->keep = option;\n                  for (chunk = 0; chunk < NINFO; ++chunk)\n                     if (chunk_info[chunk].all)\n                        chunk_info[chunk].keep = option;\n                  continue;\n               }\n               break;\n            default: \n               break;\n         }\n      }\n      fprintf(stderr, \"%s(%s): %s: unrecognized chunk argument\\n\", d->file,\n         d->test, argv[i]);\n      display_exit(d);\n   }\n   png_read_info(d->png_ptr, d->info_ptr);\n   switch (png_get_interlace_type(d->png_ptr, d->info_ptr))\n   {\n      case PNG_INTERLACE_NONE:\n         npasses = 1;\n         break;\n      case PNG_INTERLACE_ADAM7:\n         npasses = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n      default:\n         \n         fprintf(stderr, \"%s(%s): invalid interlace type\\n\", d->file, d->test);\n         clean_display(d);\n         exit(1);\n   }\n   \n\n\n   if (chunk_info[0].keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n   {\n      png_start_read_image(d->png_ptr);\n      height = png_get_image_height(d->png_ptr, d->info_ptr);\n      if (npasses > 1)\n      {\n         png_uint_32 width = png_get_image_width(d->png_ptr, d->info_ptr);\n         for (ipass=0; ipass<npasses; ++ipass)\n         {\n            png_uint_32 wPass = PNG_PASS_COLS(width, ipass);\n            if (wPass > 0)\n            {\n               png_uint_32 y;\n               for (y=0; y<height; ++y) if (PNG_ROW_IN_INTERLACE_PASS(y, ipass))\n                  png_read_row(d->png_ptr, NULL, NULL);\n            }\n         }\n      } \n      else \n      {\n         png_uint_32 y;\n         for (y=0; y<height; ++y)\n            png_read_row(d->png_ptr, NULL, NULL);\n      }\n   }\n   png_read_end(d->png_ptr, d->end_ptr);\n   flags[0] = get_valid(d, d->info_ptr);\n   flags[1] = get_unknown(d, d->info_ptr, 0);\n   \n   flags[chunk_info[0].keep != PNG_HANDLE_CHUNK_AS_DEFAULT] |=\n      PNG_INFO_IDAT;\n   flags[2] = get_valid(d, d->end_ptr);\n   flags[3] = get_unknown(d, d->end_ptr, 1);\n   clean_display(d);\n   return d->keep;\n}\n", "bug_type": null, "idx": 315}
{"project": "LibPNG", "target": 0, "func": "#else \nint main(void)\n{\n   fprintf(stderr,\n      \"pngvalid: no low level write support in libpng, all tests skipped\\n\");\n   \n   return SKIP;\n}\n", "bug_type": null, "idx": 316}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_nop6(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->a == 0)\n      out->r = out->g = out->b = 65535;\n   else\n   {\n      out->r = in->r;\n      out->g = in->g;\n      out->b = in->b;\n   }\n   out->a = in->a;\n}\n", "bug_type": null, "idx": 317}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_@_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   this->next->mod(this->next, that, pp, display);\n}\n", "bug_type": null, "idx": 318}
{"project": "LibPNG", "target": 0, "func": "static int\ngenerate_palette(png_colorp palette, png_bytep trans, int bit_depth,\n   png_const_bytep gamma_table, unsigned int *colors)\n{\n   \n\n\n\n\n\n\n\n\n   switch (colors[0])\n   {\n      default:\n         fprintf(stderr, \"makepng: --colors=...: invalid count %u\\n\",\n            colors[0]);\n         exit(1);\n      case 1:\n         set_color(palette+0, trans+0, colors[1], colors[1], colors[1], 255,\n            gamma_table);\n         return 1;\n      case 2:\n         set_color(palette+0, trans+0, colors[1], colors[1], colors[1],\n            colors[2], gamma_table);\n         return 1;\n      case 3:\n         set_color(palette+0, trans+0, colors[1], colors[2], colors[3], 255,\n            gamma_table);\n         return 1;\n      case 4:\n         set_color(palette+0, trans+0, colors[1], colors[2], colors[3],\n            colors[4], gamma_table);\n         return 1;\n      case 0:\n         if (bit_depth == 1)\n         {\n            set_color(palette+0, trans+0, 255, 0, 0, 0, gamma_table);\n            set_color(palette+1, trans+1, 255, 255, 255, 255, gamma_table);\n            return 2;\n         }\n         else\n         {\n            unsigned int size = 1U << (bit_depth/2); \n            unsigned int x, y, ip;\n            for (x=0; x<size; ++x) for (y=0; y<size; ++y)\n            {\n               ip = x + (size * y);\n               \n\n#              define interp(pos, c1, c2) ((pos * c1) + ((size-pos) * c2))\n#              define xyinterp(x, y, c1, c2, c3, c4) (((size * size / 2) +\\\n                  (interp(x, c1, c2) * y + (size-y) * interp(x, c3, c4))) /\\\n                  (size*size))\n               set_color(palette+ip, trans+ip,\n                  \n                  xyinterp(x, y,   0, 255,   0, 255),\n                  xyinterp(x, y, 255,   0,   0, 255),\n                  xyinterp(x, y,   0,   0, 255, 255),\n                  \n                  xyinterp(x, y,   0, 102, 204, 255),\n                  gamma_table);\n            }\n            return ip+1;\n         }\n   }\n}\n", "bug_type": null, "idx": 319}
{"project": "LibPNG", "target": 0, "func": "static void\ninit_sRGB_to_d(void)\n{\n   int i;\n   sRGB_to_d[0] = 0;\n   for (i=1; i<255; ++i)\n      sRGB_to_d[i] = linear_from_sRGB(i/255.);\n   sRGB_to_d[255] = 1;\n   g22_to_d[0] = 0;\n   for (i=1; i<255; ++i)\n      g22_to_d[i] = pow(i/255., 1/.45455);\n   g22_to_d[255] = 1;\n}\n", "bug_type": null, "idx": 320}
{"project": "LibPNG", "target": 0, "func": "\nvoid PngFileInitialize (HWND hwnd)\n{\n    static TCHAR szFilter[] = TEXT (\"PNG Files (*.PNG)\\0*.png\\0\")\n        TEXT (\"All Files (*.*)\\0*.*\\0\\0\");\n    ofn.lStructSize       = sizeof (OPENFILENAME);\n    ofn.hwndOwner         = hwnd;\n    ofn.hInstance         = NULL;\n    ofn.lpstrFilter       = szFilter;\n    ofn.lpstrCustomFilter = NULL;\n    ofn.nMaxCustFilter    = 0;\n    ofn.nFilterIndex      = 0;\n    ofn.lpstrFile         = NULL;          \n    ofn.nMaxFile          = MAX_PATH;\n    ofn.lpstrFileTitle    = NULL;          \n    ofn.nMaxFileTitle     = MAX_PATH;\n    ofn.lpstrInitialDir   = NULL;\n    ofn.lpstrTitle        = NULL;\n    ofn.Flags             = 0;             \n    ofn.nFileOffset       = 0;\n    ofn.nFileExtension    = 0;\n    ofn.lpstrDefExt       = TEXT (\"png\");\n    ofn.lCustData         = 0;\n    ofn.lpfnHook          = NULL;\n    ofn.lpTemplateName    = NULL;\n}\n", "bug_type": null, "idx": 321}
{"project": "LibPNG", "target": 1, "func": "\n\n\n\n\n\n\n\n\n\n\npng_size_t \npng_check_keyword(png_structp png_ptr, png_const_charp key, png_charpp new_key)\n{\n   png_size_t key_len;\n   png_const_charp ikp;\n   png_charp kp, dp;\n   int kflag;\n   int kwarn=0;\n\n   png_debug(1, \"in png_check_keyword\");\n\n   *new_key = NULL;\n\n   if (key == NULL || (key_len = png_strlen(key)) == 0)\n   {\n      png_warning(png_ptr, \"zero length keyword\");\n      return ((png_size_t)0);\n   }\n\n   png_debug1(2, \"Keyword to be checked is '%s'\", key);\n\n   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));\n\n   if (*new_key == NULL)\n   {\n      png_warning(png_ptr, \"Out of memory while procesing keyword\");\n      return ((png_size_t)0);\n   }\n\n   \n   for (ikp = key, dp = *new_key; *ikp != '\\0'; ikp++, dp++)\n   {\n      if ((png_byte)*ikp < 0x20 ||\n         ((png_byte)*ikp > 0x7E && (png_byte)*ikp < 0xA1))\n      {\n         PNG_WARNING_PARAMETERS(p)\n\n         png_warning_parameter_unsigned(p, 1, PNG_NUMBER_FORMAT_02x,\n            (png_byte)*ikp);\n         png_formatted_warning(png_ptr, p, \"invalid keyword character 0x@1\");\n         *dp = ' ';\n      }\n\n      else\n      {\n         *dp = *ikp;\n      }\n   }\n   *dp = '\\0';\n\n   \n   kp = *new_key + key_len - 1;\n   if (*kp == ' ')\n   {\n      png_warning(png_ptr, \"trailing spaces removed from keyword\");\n\n      while (*kp == ' ')\n      {\n         *(kp--) = '\\0';\n         key_len--;\n      }\n   }\n\n   \n   kp = *new_key;\n   if (*kp == ' ')\n   {\n      png_warning(png_ptr, \"leading spaces removed from keyword\");\n\n      while (*kp == ' ')\n      {\n         kp++;\n         key_len--;\n      }\n   }\n\n   png_debug1(2, \"Checking for multiple internal spaces in '%s'\", kp);\n\n   \n   for (kflag = 0, dp = *new_key; *kp != '\\0'; kp++)\n   {\n      if (*kp == ' ' && kflag == 0)\n      {\n         *(dp++) = *kp;\n         kflag = 1;\n      }\n\n      else if (*kp == ' ')\n      {\n         key_len--;\n         kwarn = 1;\n      }\n\n      else\n      {\n         *(dp++) = *kp;\n         kflag = 0;\n      }\n   }\n   *dp = '\\0';\n   if (kwarn)\n      png_warning(png_ptr, \"extra interior spaces removed from keyword\");\n\n   if (key_len == 0)\n   {\n      png_free(png_ptr, *new_key);\n      png_warning(png_ptr, \"Zero length keyword\");\n   }\n\n   if (key_len > 79)\n   {\n      png_warning(png_ptr, \"keyword length must be 1 - 79 characters\");\n      (*new_key)[79] = '\\0';\n      key_len = 79;\n   }\n\n   return (key_len);\n}\n", "bug_type": "cve-2015-8540", "idx": 322}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,\n    PNG_CONST image_transform *transform_list)\n{\n   memset(dp, 0, sizeof *dp);\n   \n   standard_display_init(&dp->this, &pm->this, id, 0,\n      pm->use_update_info);\n   \n   dp->pm = pm;\n   dp->transform_list = transform_list;\n   \n   dp->output_colour_type = 255; \n   dp->output_bit_depth = 255;  \n}\n", "bug_type": null, "idx": 323}
{"project": "LibPNG", "target": 0, "func": "void\nput_uLong(uLong val)\n{\n   putchar(val >> 24);\n   putchar(val >> 16);\n   putchar(val >>  8);\n   putchar(val >>  0);\n}\n", "bug_type": null, "idx": 324}
{"project": "LibPNG", "target": 0, "func": "static int\nextract_one_file(const char *filename)\n{\n   int result = 0;\n   FILE *fp = fopen(filename, \"rb\");\n   if (fp != NULL)\n   {\n      png_uint_32 proflen = 0;\n      png_bytep profile = extract(fp, &proflen);\n      if (profile != NULL && profile != no_profile)\n      {\n         size_t len;\n         char *output;\n         {\n            const char *ep = strrchr(filename, '.');\n            if (ep != NULL)\n               len = ep-filename;\n            else\n               len = strlen(filename);\n         }\n         output = malloc(len + 5);\n         if (output != NULL)\n         {\n            FILE *of;\n            memcpy(output, filename, len);\n            strcpy(output+len, \".icc\");\n            of = fopen(output, \"wb\");\n            if (of != NULL)\n            {\n               if (fwrite(profile, proflen, 1, of) == 1 &&\n                  fflush(of) == 0 &&\n                  fclose(of) == 0)\n               {\n                  if (verbose)\n                     printf(\"%s -> %s\\n\", filename, output);\n                  \n                  result = 1;\n               }\n               else\n               {\n                  fprintf(stderr, \"%s: error writing profile\\n\", output);\n                  if (remove(output))\n                     fprintf(stderr, \"%s: could not remove file\\n\", output);\n               }\n            }\n            else\n               fprintf(stderr, \"%s: failed to open output file\\n\", output);\n            free(output);\n         }\n         else\n            fprintf(stderr, \"%s: OOM allocating string!\\n\", filename);\n         free(profile);\n      }\n      else if (verbose && profile == no_profile)\n\tprintf(\"%s has no profile\\n\", filename);\n   }\n   else\n      fprintf(stderr, \"%s: could not open file\\n\", filename);\n   return result;\n}\n", "bug_type": null, "idx": 325}
{"project": "LibPNG", "target": 0, "func": " * scales values to 8-bit if necessary */\nint readpng_get_bgcolor(uch *red, uch *green, uch *blue)\n{\n    return 1;\n}\n", "bug_type": null, "idx": 326}
{"project": "LibPNG", "target": 0, "func": "static png_voidp PNGCBAPI\nstore_malloc(png_structp ppIn, png_alloc_size_t cb)\n{\n   png_const_structp pp = ppIn;\n   store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp));\n   store_memory *new = voidcast(store_memory*, malloc(cb + (sizeof *new) +\n      (sizeof pool->mark)));\n   if (new != NULL)\n   {\n      if (cb > pool->max)\n         pool->max = cb;\n      pool->current += cb;\n      if (pool->current > pool->limit)\n         pool->limit = pool->current;\n      pool->total += cb;\n      new->size = cb;\n      memcpy(new->mark, pool->mark, sizeof new->mark);\n      memcpy((png_byte*)(new+1) + cb, pool->mark, sizeof pool->mark);\n      new->pool = pool;\n      new->next = pool->list;\n      pool->list = new;\n      ++new;\n   }\n   else\n   {\n      \n\n\n\n\n\n\n\n\n\n\n\n      store_log(pool->store, pp, \"out of memory\", 1 );\n   }\n   return new;\n}\n", "bug_type": null, "idx": 327}
{"project": "LibPNG", "target": 0, "func": "int\nmain(void)\n{\n   fprintf(stderr,\n      \" test ignored: no support to find out about unknown chunks\\n\");\n   \n   return 77;\n}\nint\nmain(void)\n{\n   fprintf(stderr,\n      \" test ignored: no support to modify unknown chunk handling\\n\");\n   \n   return 77;\n}\n", "bug_type": null, "idx": 328}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_scale_16_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_scale_16(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 329}
{"project": "LibPNG", "target": 0, "func": "static int\npng_have_neon(png_structp png_ptr)\n{\n   FILE *f = fopen(\"/proc/cpuinfo\", \"rb\");\n   if (f != NULL)\n   {\n      \n\n\n      static const char ch_feature[] = { 70, 69, 65, 84, 85, 82, 69, 83 };\n      static const char ch_neon[] = { 78, 69, 79, 78 };\n      enum\n      {\n         StartLine, Feature, Colon, StartTag, Neon, HaveNeon, SkipTag, SkipLine\n      }  state;\n      int counter;\n      for (state=StartLine, counter=0;;)\n      {\n         int ch = fgetc(f);\n         if (ch == EOF)\n         {\n            \n\n\n            fclose(f);\n            return 0;\n         }\n         switch (state)\n         {\n            case StartLine:\n               \n               if (ch <= 32) \n                  break;\n               counter=0;\n               state = Feature;\n               \n            case Feature:\n               \n               if ((ch & ~0x20) == ch_feature[counter])\n               {\n                  if (++counter == (sizeof ch_feature))\n                     state = Colon;\n                  break;\n               }\n               \n               state = SkipLine;\n               \n            case SkipLine:\n            skipLine:\n               \n               if (ch != 10 && ch != 13)\n                  break;\n               state = StartLine;\n               break;\n            case Colon:\n               \n               if (ch == 32 || ch == 9)\n                  break;\n               if (ch == 58) \n               {\n                  state = StartTag;\n                  break;\n               }\n               \n\n\n               state = SkipLine;\n               goto skipLine;\n            case StartTag:\n               \n               if (ch == 32 || ch == 9)\n                  break;\n               state = Neon;\n               counter = 0;\n               \n            case Neon:\n               \n               if ((ch & ~0x20) == ch_neon[counter])\n               {\n                  if (++counter == (sizeof ch_neon))\n                     state = HaveNeon;\n                  break;\n               }\n               state = SkipTag;\n               \n            case SkipTag:\n               \n               if (ch == 10 || ch == 13)\n                  state = StartLine;\n               else if (ch == 32 || ch == 9)\n                  state = StartTag;\n               break;\n            case HaveNeon:\n               \n\n\n               if (ch == 10 || ch == 13 || ch == 32 || ch == 9)\n               {\n                  fclose(f);\n                  return 1;\n               }\n               state = SkipTag;\n               break;\n            default:\n               png_error(png_ptr, \"png_have_neon: internal error (bug)\");\n         }\n      }\n   }\n#ifdef PNG_WARNINGS_SUPPORTED\n   else\n      png_warning(png_ptr, \"/proc/cpuinfo open failed\");\n#endif\n   return 0;\n}\n", "bug_type": null, "idx": 330}
{"project": "LibPNG", "target": 0, "func": "static void\nbuffer_start_write(struct buffer *buffer)\n{\n   buffer->last = &buffer->first;\n   buffer->end_count = 0;\n   buffer->current = NULL;\n}\n", "bug_type": null, "idx": 331}
{"project": "LibPNG", "target": 0, "func": "     */\nstatic int PNGCBAPI read_user_chunk_callback(png_struct *png_ptr,\n   png_unknown_chunkp chunk)\n{\n   png_uint_32\n     *my_user_chunk_data;\n   \n\n\n\n\n\n\n\n\n\n\n\n   if (chunk->name[0] == 115 && chunk->name[1] ==  84 &&     \n       chunk->name[2] ==  69 && chunk->name[3] ==  82)       \n      {\n         \n         if (chunk->size != 1)\n            return (-1); \n         if (chunk->data[0] != 0 && chunk->data[0] != 1)\n            return (-1);  \n         my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);\n         my_user_chunk_data[0]=chunk->data[0]+1;\n         return (1);\n      }\n   if (chunk->name[0] != 118 || chunk->name[1] != 112 ||    \n       chunk->name[2] !=  65 || chunk->name[3] != 103)      \n      return (0); \n   \n   if (chunk->size != 9)\n      return (-1); \n   my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);\n   my_user_chunk_data[1]=png_get_uint_31(png_ptr, chunk->data);\n   my_user_chunk_data[2]=png_get_uint_31(png_ptr, chunk->data + 4);\n   my_user_chunk_data[3]=(png_uint_32)chunk->data[8];\n   return (1);\n}\n", "bug_type": null, "idx": 332}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_g16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = p->g = p->b = pp[0];\n   p->a = 65535;\n}\n", "bug_type": null, "idx": 333}
{"project": "LibPNG", "target": 1, "func": "\nvoid PNGAPI\npng_set_sPLT(png_structp png_ptr,\n    png_infop info_ptr, png_const_sPLT_tp entries, int nentries)\n\n\n\n\n\n\n\n\n{\n   png_sPLT_tp np;\n   int i;\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   np = (png_sPLT_tp)png_malloc_warn(png_ptr,\n       (info_ptr->splt_palettes_num + nentries) *\n       (png_size_t)png_sizeof(png_sPLT_t));\n\n   if (np == NULL)\n   {\n      png_warning(png_ptr, \"No memory for sPLT palettes\");\n      return;\n   }\n\n   png_memcpy(np, info_ptr->splt_palettes,\n       info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));\n\n   png_free(png_ptr, info_ptr->splt_palettes);\n   info_ptr->splt_palettes=NULL;\n\n   for (i = 0; i < nentries; i++)\n   {\n      png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;\n      png_const_sPLT_tp from = entries + i;\n      png_size_t length;\n\n      length = png_strlen(from->name) + 1;\n      to->name = (png_charp)png_malloc_warn(png_ptr, length);\n\n      if (to->name == NULL)\n      {\n         png_warning(png_ptr,\n             \"Out of memory while processing sPLT chunk\");\n         continue;\n      }\n\n      png_memcpy(to->name, from->name, length);\n      to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,\n          from->nentries * png_sizeof(png_sPLT_entry));\n\n      if (to->entries == NULL)\n      {\n         png_warning(png_ptr,\n             \"Out of memory while processing sPLT chunk\");\n         png_free(png_ptr, to->name);\n         to->name = NULL;\n         continue;\n      }\n\n      png_memcpy(to->entries, from->entries,\n          from->nentries * png_sizeof(png_sPLT_entry));\n\n      to->nentries = from->nentries;\n      to->depth = from->depth;\n   }\n\n   info_ptr->splt_palettes = np;\n   info_ptr->splt_palettes_num += nentries;\n   info_ptr->valid |= PNG_INFO_sPLT;\n   info_ptr->free_me |= PNG_FREE_SPLT;\n}\n#endif ", "bug_type": "cve-2013-7354-1", "idx": 334}
{"project": "LibPNG", "target": 0, "func": "static unsigned int\nsample_scale(double sample_value, unsigned int scale)\n{\n   sample_value = floor(sample_value * scale + .5);\n   \n   if (!(sample_value > 0))\n      sample_value = 0;\n   else if (sample_value > scale)\n      sample_value = scale;\n   return (unsigned int)sample_value;\n}\n", "bug_type": null, "idx": 335}
{"project": "LibPNG", "target": 0, "func": "static png_size_t\nload_fake(png_charp param, png_bytepp profile)\n{\n   char *endptr = NULL;\n   unsigned long long int size = strtoull(param, &endptr, 0);\n   \n   if (endptr != NULL && *endptr == '*')\n   {\n      size_t len = strlen(++endptr);\n      size_t result = (size_t)size;\n      if (len == 0) len = 1; \n      \n      if (result == size && (*profile = malloc(result)) != NULL)\n      {\n         png_bytep out = *profile;\n         if (len == 1)\n            memset(out, *endptr, result);\n         else\n         {\n            while (size >= len)\n            {\n               memcpy(out, endptr, len);\n               out += len;\n               size -= len;\n            }\n            memcpy(out, endptr, size);\n         }\n         return result;\n      }\n      else\n      {\n         fprintf(stderr, \"%s: size exceeds system limits\\n\", param);\n         exit(1);\n      }\n   }\n   return 0;\n}\n", "bug_type": null, "idx": 336}
{"project": "LibPNG", "target": 1, "func": "\npng_uint_32 PNGAPI\npng_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_colorp *palette, int *num_palette)\n{\n   png_debug1(1, \"in %s retrieval function\", \"PLTE\");\n\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)\n       && palette != NULL)\n   {\n      *palette = info_ptr->palette;\n      *num_palette = info_ptr->num_palette;\n      png_debug1(3, \"num_palette = %d\", *num_palette);\n      return (PNG_INFO_PLTE);\n   }\n\n   return (0);\n}", "bug_type": "cve-2015-8126_2", "idx": 337}
{"project": "LibPNG", "target": 0, "func": "void PNGCBAPI\npng_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n   png_size_t check;\n   if (png_ptr == NULL)\n      return;\n   \n\n\n   check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));\n   if (check != length)\n      png_error(png_ptr, \"Read Error\");\n}\n", "bug_type": null, "idx": 338}
{"project": "LibPNG", "target": 0, "func": "} \nstatic int rpng_win_display_image()\n{\n    uch *src, *dest;\n    uch r, g, b, a;\n    ulg i, row, lastrow;\n    RECT rect;\n    Trace((stderr, \"beginning display loop (image_channels == %d)\\n\",\n      image_channels))\n    Trace((stderr, \"(width = %ld, rowbytes = %ld, wimage_rowbytes = %d)\\n\",\n      image_width, image_rowbytes, wimage_rowbytes))\n\n\n\n\n\n    for (lastrow = row = 0;  row < image_height;  ++row) {\n        src = image_data + row*image_rowbytes;\n        dest = wimage_data + row*wimage_rowbytes;\n        if (image_channels == 3) {\n            for (i = image_width;  i > 0;  --i) {\n                r = *src++;\n                g = *src++;\n                b = *src++;\n                *dest++ = b;\n                *dest++ = g;   \n                *dest++ = r;\n            }\n        } else  {\n            for (i = image_width;  i > 0;  --i) {\n                r = *src++;\n                g = *src++;\n                b = *src++;\n                a = *src++;\n                if (a == 255) {\n                    *dest++ = b;\n                    *dest++ = g;\n                    *dest++ = r;\n                } else if (a == 0) {\n                    *dest++ = bg_blue;\n                    *dest++ = bg_green;\n                    *dest++ = bg_red;\n                } else {\n                    \n\n\n\n                    alpha_composite(*dest++, b, a, bg_blue);\n                    alpha_composite(*dest++, g, a, bg_green);\n                    alpha_composite(*dest++, r, a, bg_red);\n                }\n            }\n        }\n        \n        if (((row+1) & 0xf) == 0) {\n            rect.left = 0L;\n            rect.top = (LONG)lastrow;\n            rect.right = (LONG)image_width;      \n            rect.bottom = (LONG)lastrow + 16L;   \n            InvalidateRect(global_hwnd, &rect, FALSE);\n            UpdateWindow(global_hwnd);     \n            lastrow = row + 1;\n        }\n    }\n    Trace((stderr, \"calling final image-flush routine\\n\"))\n    if (lastrow < image_height) {\n        rect.left = 0L;\n        rect.top = (LONG)lastrow;\n        rect.right = (LONG)image_width;      \n        rect.bottom = (LONG)image_height;    \n        InvalidateRect(global_hwnd, &rect, FALSE);\n        UpdateWindow(global_hwnd);     \n    }\n\n\n\n\n\n    return 0;\n}\n", "bug_type": null, "idx": 339}
{"project": "LibPNG", "target": 1, "func": "\nvoid PNGAPI\npng_set_iCCP(png_structp png_ptr, png_infop info_ptr,\n             png_charp name, int compression_type,\n             png_charp profile, png_uint_32 proflen)\n{\n   png_charp new_iccp_name;\n   png_charp new_iccp_profile;\n\n   png_debug1(1, \"in %s storage function\\n\", \"iCCP\");\n   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)\n      return;\n\n   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, png_strlen(name)+1);\n   if (new_iccp_name == NULL)\n   {\n      png_warning(png_ptr, \"Insufficient memory to process iCCP chunk.\");\n      return;\n   }\n   png_strcpy(new_iccp_name, name);\n   new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen);\n   if (new_iccp_profile == NULL)\n   {\n      png_free (png_ptr, new_iccp_name);\n      png_warning(png_ptr, \"Insufficient memory to process iCCP profile.\");\n      return;\n   }\n   png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);\n\n   info_ptr->iccp_proflen = proflen;\n   info_ptr->iccp_name = new_iccp_name;\n   info_ptr->iccp_profile = new_iccp_profile;\n   \n\n   info_ptr->iccp_compression = (png_byte)compression_type;\n#ifdef PNG_FREE_ME_SUPPORTED\n   info_ptr->free_me |= PNG_FREE_ICCP;\n#endif\n   info_ptr->valid |= PNG_INFO_iCCP;\n}\n#endif\n", "bug_type": "cve-2007-5266", "idx": 340}
{"project": "LibPNG", "target": 0, "func": "\nPNG_FUNCTION(void, (PNGCBAPI error), (png_structp png_ptr, const char *message),\n   static PNG_NORETURN)\n{\n   display *d = (display*)png_get_error_ptr(png_ptr);\n   fprintf(stderr, \"%s(%s): libpng error: %s\\n\", d->file, d->test, message);\n   display_exit(d);\n}\n", "bug_type": null, "idx": 341}
{"project": "LibPNG", "target": 0, "func": "static png_uint_16\nilineara(int fixed_srgb, int alpha)\n{\n   return u16d((257 * alpha) * sRGB_to_d[fixed_srgb]);\n}\n", "bug_type": null, "idx": 342}
{"project": "LibPNG", "target": 0, "func": "static int\npng_row_in_interlace_pass(png_uint_32 y, int pass)\n{\n   \n   int x;\n   y &= 7;\n   ++pass;\n   for (x=0; x<8; ++x) if (adam7[y][x] == pass)\n      return 1;\n   return 0;\n}\n", "bug_type": null, "idx": 343}
{"project": "LibPNG", "target": 0, "func": "int validation_checkfp(int count, int argc, char **argv)\n{\n   int result;\n   checkfp_command command;\n   checkfp_control control;\n   command.number[0] = 0;\n   command.limit = 3;\n   command.verbose = verbose;\n   command.ctimes = 0;\n   command.cmillions = 0;\n   command.cinvalid = 0;\n   command.cnoaccept = 0;\n   while (--argc > 0)\n   {\n      ++argv;\n      if (argc > 1 && strcmp(*argv, \"-l\") == 0)\n      {\n         --argc;\n         command.limit = atoi(*++argv);\n      }\n      else\n      {\n         fprintf(stderr, \"unknown argument %s\\n\", *argv);\n         return 1;\n      }\n   }\n   control.cnumber = 0;\n   control.check_state = start;\n   control.at_start = 1;\n   control.cdigits_in_state = 0;\n   control.limit = command.limit;\n   control.state = 0;\n   control.is_negative = 0;\n   control.is_zero = 1;\n   control.number_was_valid = 0;\n   result = check_all_characters(&command, control);\n   printf(\"checkfp: %s: checked %d,%.3d,%.3d,%.3d strings (%d invalid)\\n\",\n      result ? \"pass\" : \"FAIL\", command.cmillions / 1000,\n      command.cmillions % 1000, command.ctimes / 1000, command.ctimes % 1000,\n      command.cinvalid);\n   return result;\n}\n", "bug_type": null, "idx": 344}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL SearchPngList (\n        TCHAR *pFileList, int FileCount, int *pFileIndex,\n        PTSTR pstrPrevName, PTSTR pstrNextName)\n{\n    if (FileCount > 0)\n    {\n        \n        if (pstrPrevName != NULL)\n        {\n            if (*pFileIndex > 0)\n                *pFileIndex -= 1;\n            else\n                *pFileIndex = FileCount - 1;\n            strcpy (pstrPrevName, pFileList + (*pFileIndex * MAX_PATH));\n        }\n        \n        if (pstrNextName != NULL)\n        {\n            if (*pFileIndex < FileCount - 1)\n                *pFileIndex += 1;\n            else\n                *pFileIndex = 0;\n            strcpy (pstrNextName, pFileList + (*pFileIndex * MAX_PATH));\n        }\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}\n */\nBOOL SearchPngList (\n        TCHAR *pFileList, int FileCount, int *pFileIndex,\n        PTSTR pstrPrevName, PTSTR pstrNextName)\n{\n    if (FileCount > 0)\n    {\n        \n        if (pstrPrevName != NULL)\n        {\n            if (*pFileIndex > 0)\n                *pFileIndex -= 1;\n            else\n                *pFileIndex = FileCount - 1;\n            strcpy (pstrPrevName, pFileList + (*pFileIndex * MAX_PATH));\n        }\n        \n        if (pstrNextName != NULL)\n        {\n            if (*pFileIndex < FileCount - 1)\n                *pFileIndex += 1;\n            else\n                *pFileIndex = 0;\n            strcpy (pstrNextName, pFileList + (*pFileIndex * MAX_PATH));\n        }\n        return TRUE;\n    }\n", "bug_type": null, "idx": 345}
{"project": "LibPNG", "target": 0, "func": "static void\nclear_text(png_text *text, png_charp keyword)\n{\n   text->compression = -1; \n   text->key = keyword;\n   text->text = NULL;\n   text->text_length = 0; \n   text->itxt_length = 0; \n   text->lang = NULL;\n   text->lang_key = NULL;\n}\n", "bug_type": null, "idx": 346}
{"project": "LibPNG", "target": 0, "func": "static void\nclear_keep(void)\n{\n   int i = NINFO;\n   while (--i >= 0)\n      chunk_info[i].keep = 0;\n}\n", "bug_type": null, "idx": 347}
{"project": "LibPNG", "target": 0, "func": "png_voidp\nPNGCBAPI png_debug_malloc(png_structp png_ptr, png_alloc_size_t size)\n{\n   \n\n\n   if (size == 0)\n      return (NULL);\n   \n\n   {\n      \n      memory_infop pinfo;\n      png_set_mem_fn(png_ptr, NULL, NULL, NULL);\n      pinfo = (memory_infop)png_malloc(png_ptr,\n         png_sizeof(*pinfo));\n      pinfo->size = size;\n      current_allocation += size;\n      total_allocation += size;\n      num_allocations ++;\n      if (current_allocation > maximum_allocation)\n         maximum_allocation = current_allocation;\n      pinfo->pointer = png_malloc(png_ptr, size);\n      \n      png_set_mem_fn(png_ptr,\n          NULL, png_debug_malloc, png_debug_free);\n      if (size != 0 && pinfo->pointer == NULL)\n      {\n         current_allocation -= size;\n         total_allocation -= size;\n         png_error(png_ptr,\n           \"out of memory in pngtest->png_debug_malloc\");\n      }\n      pinfo->next = pinformation;\n      pinformation = pinfo;\n      \n      png_memset(pinfo->pointer, 0xdd, pinfo->size);\n      if (verbose)\n         printf(\"png_malloc %lu bytes at %p\\n\", (unsigned long)size,\n            pinfo->pointer);\n      return (png_voidp)(pinfo->pointer);\n   }\n}\n", "bug_type": null, "idx": 348}
{"project": "LibPNG", "target": 1, "func": "\nint \npng_set_text_2(png_structp png_ptr, png_infop info_ptr,\n    png_const_textp text_ptr, int num_text)\n{\n   int i;\n\n   png_debug1(1, \"in %s storage function\", ((png_ptr == NULL ||\n       png_ptr->chunk_name[0] == '\\0') ?\n       \"text\" : (png_const_charp)png_ptr->chunk_name));\n\n   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)\n      return(0);\n\n   \n\n\n   if (info_ptr->num_text + num_text > info_ptr->max_text)\n   {\n      if (info_ptr->text != NULL)\n      {\n         png_textp old_text;\n         int old_max;\n\n         old_max = info_ptr->max_text;\n         info_ptr->max_text = info_ptr->num_text + num_text + 8;\n         old_text = info_ptr->text;\n         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,\n            (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));\n\n         if (info_ptr->text == NULL)\n         {\n            png_free(png_ptr, old_text);\n            return(1);\n         }\n\n         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *\n             png_sizeof(png_text)));\n         png_free(png_ptr, old_text);\n      }\n\n      else\n      {\n         info_ptr->max_text = num_text + 8;\n         info_ptr->num_text = 0;\n         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,\n             (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));\n         if (info_ptr->text == NULL)\n            return(1);\n         info_ptr->free_me |= PNG_FREE_TEXT;\n      }\n\n      png_debug1(3, \"allocated %d entries for info_ptr->text\",\n          info_ptr->max_text);\n   }\n   for (i = 0; i < num_text; i++)\n   {\n      png_size_t text_length, key_len;\n      png_size_t lang_len, lang_key_len;\n      png_textp textp = &(info_ptr->text[info_ptr->num_text]);\n\n      if (text_ptr[i].key == NULL)\n          continue;\n\n      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||\n          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)\n      {\n         png_warning(png_ptr, \"text compression mode is out of range\");\n         continue;\n      }\n\n      key_len = png_strlen(text_ptr[i].key);\n\n      if (text_ptr[i].compression <= 0)\n      {\n         lang_len = 0;\n         lang_key_len = 0;\n      }\n\n      else\n#  ifdef PNG_iTXt_SUPPORTED\n      {\n         \n\n         if (text_ptr[i].lang != NULL)\n            lang_len = png_strlen(text_ptr[i].lang);\n\n         else\n            lang_len = 0;\n\n         if (text_ptr[i].lang_key != NULL)\n            lang_key_len = png_strlen(text_ptr[i].lang_key);\n\n         else\n            lang_key_len = 0;\n      }\n#  else \n      {\n         png_warning(png_ptr, \"iTXt chunk not supported\");\n         continue;\n      }\n#  endif\n\n      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')\n      {\n         text_length = 0;\n#  ifdef PNG_iTXt_SUPPORTED\n         if (text_ptr[i].compression > 0)\n            textp->compression = PNG_ITXT_COMPRESSION_NONE;\n\n         else\n#  endif\n            textp->compression = PNG_TEXT_COMPRESSION_NONE;\n      }\n\n      else\n      {\n         text_length = png_strlen(text_ptr[i].text);\n         textp->compression = text_ptr[i].compression;\n      }\n\n      textp->key = (png_charp)png_malloc_warn(png_ptr,\n          (png_size_t)\n          (key_len + text_length + lang_len + lang_key_len + 4));\n\n      if (textp->key == NULL)\n         return(1);\n\n      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",\n          (unsigned long)(png_uint_32)\n          (key_len + lang_len + lang_key_len + text_length + 4),\n          textp->key);\n\n      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));\n      *(textp->key + key_len) = '\\0';\n\n      if (text_ptr[i].compression > 0)\n      {\n         textp->lang = textp->key + key_len + 1;\n         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);\n         *(textp->lang + lang_len) = '\\0';\n         textp->lang_key = textp->lang + lang_len + 1;\n         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);\n         *(textp->lang_key + lang_key_len) = '\\0';\n         textp->text = textp->lang_key + lang_key_len + 1;\n      }\n\n      else\n      {\n         textp->lang=NULL;\n         textp->lang_key=NULL;\n         textp->text = textp->key + key_len + 1;\n      }\n\n      if (text_length)\n         png_memcpy(textp->text, text_ptr[i].text,\n             (png_size_t)(text_length));\n\n      *(textp->text + text_length) = '\\0';\n\n#  ifdef PNG_iTXt_SUPPORTED\n      if (textp->compression > 0)\n      {\n         textp->text_length = 0;\n         textp->itxt_length = text_length;\n      }\n\n      else\n#  endif\n      {\n         textp->text_length = text_length;\n         textp->itxt_length = 0;\n      }\n\n      info_ptr->num_text++;\n      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);\n   }\n   return(0);\n}\n#endif", "bug_type": "cve-2013-7354-2", "idx": 349}
{"project": "LibPNG", "target": 0, "func": "static int\npng_pass_row_shift(int pass)\n{\n   int x, y, base=(-1), inc=8;\n   ++pass;\n   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)\n   {\n      if (base == (-1))\n         base = y;\n      else if (base == y)\n         {}\n      else if (inc == y-base)\n         base=y;\n      else if (inc == 8)\n         inc = y-base, base=y;\n      else if (inc != y-base)\n         return 0xff; \n   }\n   if (base == (-1)) return 0xfe; \n   \n   switch (inc)\n   {\ncase 2: return 1;\ncase 4: return 2;\ncase 8: return 3;\ndefault: break;\n   }\n   \n   return (inc << 8) + 0xfd;\n}\n", "bug_type": null, "idx": 350}
{"project": "LibPNG", "target": 0, "func": "static void\nmodifier_set_encoding(png_modifier *pm)\n{\n   \n\n\n\n   pm->current_gamma = 0;\n   pm->current_encoding = 0;\n   pm->encoding_ignored = 0; \n   \n   if (pm->encoding_counter > 0)\n   {\n      \n\n\n      if (pm->encoding_counter <= pm->ngammas)\n         pm->current_gamma = 1/pm->gammas[pm->encoding_counter-1];\n      else\n      {\n         unsigned int i = pm->encoding_counter - pm->ngammas;\n         if (i >= pm->nencodings)\n         {\n            i %= pm->nencodings;\n            pm->current_gamma = 1; \n         }\n         else\n            pm->current_gamma = pm->encodings[i].gamma;\n         pm->current_encoding = pm->encodings + i;\n      }\n   }\n}\n", "bug_type": null, "idx": 351}
{"project": "LibPNG", "target": 0, "func": "static void rpng_win_cleanup()\n{\n    if (image_data) {\n        free(image_data);\n        image_data = NULL;\n    }\n    if (dib) {\n        free(dib);\n        dib = NULL;\n    }\n}\n", "bug_type": null, "idx": 352}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_row(png_const_structp pp, png_byte buffer[TRANSFORM_ROWMAX],\n   png_byte colour_type, png_byte bit_depth, png_uint_32 y)\n{\n   png_uint_32 v = y << 7;\n   png_uint_32 i = 0;\n   switch (bit_size(pp, colour_type, bit_depth))\n   {\n      case 1:\n         while (i<128/8) buffer[i] = (png_byte)(v & 0xff), v += 17, ++i;\n         return;\n      case 2:\n         while (i<128/4) buffer[i] = (png_byte)(v & 0xff), v += 33, ++i;\n         return;\n      case 4:\n         while (i<128/2) buffer[i] = (png_byte)(v & 0xff), v += 65, ++i;\n         return;\n      case 8:\n         \n         while (i<128) buffer[i] = (png_byte)(v & 0xff), ++v, ++i;\n         return;\n      case 16:\n         \n\n\n         while (i<128)\n         {\n            buffer[2*i] = (png_byte)((v>>8) & 0xff);\n            buffer[2*i+1] = (png_byte)(v & 0xff);\n            ++v;\n            ++i;\n         }\n         return;\n      case 24:\n         \n         while (i<128)\n         {\n            \n            buffer[3*i+0] = (png_byte)((v >> 8) & 0xff);\n            buffer[3*i+1] = (png_byte)(v & 0xff);\n            buffer[3*i+2] = (png_byte)(((v >> 8) ^ v) & 0xff);\n            ++v;\n            ++i;\n         }\n         return;\n      case 32:\n         \n         while (i<128)\n         {\n            buffer[4*i+0] = (png_byte)((v >> 8) & 0xff);\n            buffer[4*i+1] = (png_byte)(v & 0xff);\n            buffer[4*i+2] = (png_byte)((v >> 8) & 0xff);\n            buffer[4*i+3] = (png_byte)(v & 0xff);\n            ++v;\n            ++i;\n         }\n         return;\n      case 48:\n         \n\n\n         while (i<128)\n         {\n            png_uint_32 t = v++;\n            buffer[6*i+0] = (png_byte)((t >> 8) & 0xff);\n            buffer[6*i+1] = (png_byte)(t & 0xff);\n            t *= 257;\n            buffer[6*i+2] = (png_byte)((t >> 8) & 0xff);\n            buffer[6*i+3] = (png_byte)(t & 0xff);\n            t *= 17;\n            buffer[6*i+4] = (png_byte)((t >> 8) & 0xff);\n            buffer[6*i+5] = (png_byte)(t & 0xff);\n            ++i;\n         }\n         return;\n      case 64:\n         \n         while (i<128)\n         {\n            png_uint_32 t = v++;\n            buffer[8*i+0] = (png_byte)((t >> 8) & 0xff);\n            buffer[8*i+1] = (png_byte)(t & 0xff);\n            buffer[8*i+4] = (png_byte)((t >> 8) & 0xff);\n            buffer[8*i+5] = (png_byte)(t & 0xff);\n            t *= 257;\n            buffer[8*i+2] = (png_byte)((t >> 8) & 0xff);\n            buffer[8*i+3] = (png_byte)(t & 0xff);\n            buffer[8*i+6] = (png_byte)((t >> 8) & 0xff);\n            buffer[8*i+7] = (png_byte)(t & 0xff);\n            ++i;\n         }\n         return;\n      default:\n         break;\n   }\n   png_error(pp, \"internal error\");\n}\n", "bug_type": null, "idx": 353}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL BuildPngList (PTSTR pstrPathName, TCHAR **ppFileList, int *pFileCount,\n     int *pFileIndex)\n{\n    static TCHAR              szImgPathName [MAX_PATH];\n    static TCHAR              szImgFileName [MAX_PATH];\n    static TCHAR              szImgFindName [MAX_PATH];\n    WIN32_FIND_DATA           finddata;\n    HANDLE                    hFind;\n    static TCHAR              szTmp [MAX_PATH];\n    BOOL                      bOk;\n    int                       i, ii;\n    int                       j, jj;\n    \n    if (*ppFileList != NULL)\n    {\n        free (*ppFileList);\n        *ppFileList = NULL;\n    }\n    \n    strcpy (szImgPathName, pstrPathName);\n    strcpy (szImgFileName, strrchr (pstrPathName, '\\\\') + 1);\n    strcpy (szImgFindName, szImgPathName);\n    *(strrchr (szImgFindName, '\\\\') + 1) = '\\0';\n    strcat (szImgFindName, \"*.png\");\n    \n    *pFileCount = 0;\n    hFind = FindFirstFile(szImgFindName, &finddata);\n    bOk = (hFind != (HANDLE) -1);\n    while (bOk)\n    {\n        *pFileCount += 1;\n        bOk = FindNextFile(hFind, &finddata);\n    }\n    FindClose(hFind);\n    \n    *ppFileList = (TCHAR *) malloc (*pFileCount * MAX_PATH);\n    \n    hFind = FindFirstFile(szImgFindName, &finddata);\n    bOk = (hFind != (HANDLE) -1);\n    i = 0;\n    ii = 0;\n    while (bOk)\n    {\n        strcpy (*ppFileList + ii, szImgPathName);\n        strcpy (strrchr(*ppFileList + ii, '\\\\') + 1, finddata.cFileName);\n        if (strcmp(pstrPathName, *ppFileList + ii) == 0)\n            *pFileIndex = i;\n        ii += MAX_PATH;\n        i++;\n        bOk = FindNextFile(hFind, &finddata);\n    }\n    FindClose(hFind);\n    \n    for (i = 0; i < *pFileCount - 1; i++)\n    {\n        ii = i * MAX_PATH;\n        for (j = i+1; j < *pFileCount; j++)\n        {\n            jj = j * MAX_PATH;\n            if (strcmp (*ppFileList + ii, *ppFileList + jj) > 0)\n            {\n                strcpy (szTmp, *ppFileList + jj);\n                strcpy (*ppFileList + jj, *ppFileList + ii);\n                strcpy (*ppFileList + ii, szTmp);\n                \n                if (*pFileIndex == i)\n                    *pFileIndex = j;\n                else\n                    if (*pFileIndex == j)\n                        *pFileIndex = i;\n            }\n        }\n    }\n    return TRUE;\n}\n", "bug_type": null, "idx": 354}
{"project": "LibPNG", "target": 0, "func": "static png_modifier pm;\nstatic void signal_handler(int signum)\n{\n   size_t pos = 0;\n   char msg[64];\n   pos = safecat(msg, sizeof msg, pos, \"caught signal: \");\n   switch (signum)\n   {\n      case SIGABRT:\n         pos = safecat(msg, sizeof msg, pos, \"abort\");\n         break;\n      case SIGFPE:\n         pos = safecat(msg, sizeof msg, pos, \"floating point exception\");\n         break;\n      case SIGILL:\n         pos = safecat(msg, sizeof msg, pos, \"illegal instruction\");\n         break;\n      case SIGINT:\n         pos = safecat(msg, sizeof msg, pos, \"interrupt\");\n         break;\n      case SIGSEGV:\n         pos = safecat(msg, sizeof msg, pos, \"invalid memory access\");\n         break;\n      case SIGTERM:\n         pos = safecat(msg, sizeof msg, pos, \"termination request\");\n         break;\n      default:\n         pos = safecat(msg, sizeof msg, pos, \"unknown \");\n         pos = safecatn(msg, sizeof msg, pos, signum);\n         break;\n   }\n   store_log(&pm.this, NULL, msg, 1);\n   \n\n\n   if (signum != SIGTERM)\n   {\n      struct exception_context *the_exception_context =\n         &pm.this.exception_context;\n      Throw &pm.this;\n   }\n   else\n      exit(1);\n}\n", "bug_type": null, "idx": 355}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_rgb_to_gray_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   PNG_CONST int error_action = 1; \n#  ifdef PNG_FLOATING_POINT_SUPPORTED\n      png_set_rgb_to_gray(pp, error_action, data.red_to_set, data.green_to_set);\n#  else\n      png_set_rgb_to_gray_fixed(pp, error_action, data.red_to_set,\n         data.green_to_set);\n#  endif\n#  ifdef PNG_READ_cHRM_SUPPORTED\n      if (that->pm->current_encoding != 0)\n      {\n         \n\n\n\n\n#        ifdef PNG_FLOATING_POINT_SUPPORTED\n#           define API_function png_get_cHRM_XYZ\n#           define API_form \"FP\"\n#           define API_type double\n#           define API_cvt(x) (x)\n#        else\n#           define API_function png_get_cHRM_XYZ_fixed\n#           define API_form \"fixed\"\n#           define API_type png_fixed_point\n#           define API_cvt(x) ((double)(x)/PNG_FP_1)\n#        endif\n         API_type rX, gX, bX;\n         API_type rY, gY, bY;\n         API_type rZ, gZ, bZ;\n         if ((API_function(pp, pi, &rX, &rY, &rZ, &gX, &gY, &gZ, &bX, &bY, &bZ)\n               & PNG_INFO_cHRM) != 0)\n         {\n            double maxe;\n            PNG_CONST char *el;\n            color_encoding e, o;\n            \n\n\n            modifier_current_encoding(that->pm, &o);\n            normalize_color_encoding(&o);\n            \n\n\n\n            if (data.red_to_set == -1 && data.green_to_set == -1 &&\n               (fabs(o.red.Y - data.red_coefficient) > DBL_EPSILON ||\n               fabs(o.green.Y - data.green_coefficient) > DBL_EPSILON ||\n               fabs(o.blue.Y - data.blue_coefficient) > DBL_EPSILON))\n               png_error(pp, \"internal pngvalid cHRM coefficient error\");\n            \n            e.gamma = o.gamma; \n            e.red.X = API_cvt(rX);\n            e.red.Y = API_cvt(rY);\n            e.red.Z = API_cvt(rZ);\n            e.green.X = API_cvt(gX);\n            e.green.Y = API_cvt(gY);\n            e.green.Z = API_cvt(gZ);\n            e.blue.X = API_cvt(bX);\n            e.blue.Y = API_cvt(bY);\n            e.blue.Z = API_cvt(bZ);\n            \n\n\n            maxe = 0;\n            el = \"-\"; \n#           define CHECK(col,x)\\\n            {\\\n               double err = fabs(o.col.x - e.col.x);\\\n               if (err > maxe)\\\n               {\\\n                  maxe = err;\\\n                  el = #col \"(\" #x \")\";\\\n               }\\\n            }\n            CHECK(red,X)\n            CHECK(red,Y)\n            CHECK(red,Z)\n            CHECK(green,X)\n            CHECK(green,Y)\n            CHECK(green,Z)\n            CHECK(blue,X)\n            CHECK(blue,Y)\n            CHECK(blue,Z)\n            \n\n\n\n            if (maxe >= 1E-5)\n            {\n               size_t pos = 0;\n               char buffer[256];\n               pos = safecat(buffer, sizeof buffer, pos, API_form);\n               pos = safecat(buffer, sizeof buffer, pos, \" cHRM \");\n               pos = safecat(buffer, sizeof buffer, pos, el);\n               pos = safecat(buffer, sizeof buffer, pos, \" error: \");\n               pos = safecatd(buffer, sizeof buffer, pos, maxe, 7);\n               pos = safecat(buffer, sizeof buffer, pos, \" \");\n               \n               pos = safecat_color_encoding(buffer, sizeof buffer, pos, &o, 0);\n               pos = safecat(buffer, sizeof buffer, pos, \" -> \");\n               pos = safecat_color_encoding(buffer, sizeof buffer, pos, &e, 0);\n               png_error(pp, buffer);\n            }\n         }\n      }\n#  endif \n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 356}
{"project": "LibPNG", "target": 0, "func": "static int\nancillary(const char *name)\n{\n   return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3]));\n}\n", "bug_type": null, "idx": 357}
{"project": "LibPNG", "target": 0, "func": "void \npng_flush(png_structp png_ptr)\n{\n   if (png_ptr->output_flush_fn != NULL)\n      (*(png_ptr->output_flush_fn))(png_ptr);\n}\n", "bug_type": null, "idx": 358}
{"project": "LibPNG", "target": 0, "func": "static int\npng_col_in_interlace_pass(png_uint_32 x, int pass)\n{\n   \n   int y;\n   x &= 7;\n   ++pass;\n   for (y=0; y<8; ++y) if (adam7[y][x] == pass)\n      return 1;\n   return 0;\n}\n", "bug_type": null, "idx": 359}
{"project": "LibPNG", "target": 0, "func": "static void wpng_cleanup(void)\n{\n    if (wpng_info.outfile) {\n        fclose(wpng_info.outfile);\n        wpng_info.outfile = NULL;\n    }\n    if (wpng_info.infile) {\n        fclose(wpng_info.infile);\n        wpng_info.infile = NULL;\n    }\n    if (wpng_info.image_data) {\n        free(wpng_info.image_data);\n        wpng_info.image_data = NULL;\n    }\n    if (wpng_info.row_pointers) {\n        free(wpng_info.row_pointers);\n        wpng_info.row_pointers = NULL;\n    }\n}\n", "bug_type": null, "idx": 360}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\ngamma_end(png_structp ppIn, png_infop pi)\n{\n   png_const_structp pp = ppIn;\n   gamma_display *dp = voidcast(gamma_display*, png_get_progressive_ptr(pp));\n   if (!dp->this.speed)\n      gamma_image_validate(dp, pp, pi);\n   else\n      dp->this.ps->validated = 1;\n}\n", "bug_type": null, "idx": 361}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_expand_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_expand(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 362}
{"project": "LibPNG", "target": 0, "func": "static int have_gc = FALSE;\nint main(int argc, char **argv)\n{\n#ifdef sgi\n    char tmpline[80];\n#endif\n    char *p, *bgstr = NULL;\n    int rc, alen, flen;\n    int error = 0;\n    int timing = FALSE;\n    int have_bg = FALSE;\n#ifdef FEATURE_LOOP\n    int loop = FALSE;\n    long loop_interval = -1;            \n#endif\n    double LUT_exponent;                \n    double CRT_exponent = 2.2;          \n    double default_display_exponent;    \n    XEvent e;\n    KeySym k;\n    \n\n\n    displayname = (char *)NULL;\n    filename = (char *)NULL;\n    memset(&rpng2_info, 0, sizeof(mainprog_info));\n    \n\n\n\n\n#if defined(NeXT)\n    \n    LUT_exponent = 1.0 / 2.2;\n    \n\n\n\n#elif defined(sgi)\n    LUT_exponent = 1.0 / 1.7;\n    \n\n    infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");\n    if (infile) {\n        double sgi_gamma;\n        fgets(tmpline, 80, infile);\n        fclose(infile);\n        sgi_gamma = atof(tmpline);\n        if (sgi_gamma > 0.0)\n            LUT_exponent = 1.0 / sgi_gamma;\n    }\n#elif defined(Macintosh)\n    LUT_exponent = 1.8 / 2.61;\n    \n\n\n\n#else\n    LUT_exponent = 1.0;   \n#endif\n    \n    default_display_exponent = LUT_exponent * CRT_exponent;\n    \n\n\n\n    if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)\n        rpng2_info.display_exponent = atof(p);\n    else\n        rpng2_info.display_exponent = default_display_exponent;\n    \n    while (*++argv && !error) {\n        if (!strncmp(*argv, \"-display\", 2)) {\n            if (!*++argv)\n                ++error;\n            else\n                displayname = *argv;\n        } else if (!strncmp(*argv, \"-gamma\", 2)) {\n            if (!*++argv)\n                ++error;\n            else {\n                rpng2_info.display_exponent = atof(*argv);\n                if (rpng2_info.display_exponent <= 0.0)\n                    ++error;\n            }\n        } else if (!strncmp(*argv, \"-bgcolor\", 4)) {\n            if (!*++argv)\n                ++error;\n            else {\n                bgstr = *argv;\n                if (strlen(bgstr) != 7 || bgstr[0] != '#')\n                    ++error;\n                else {\n                    have_bg = TRUE;\n                    bg_image = FALSE;\n                }\n            }\n        } else if (!strncmp(*argv, \"-bgpat\", 4)) {\n            if (!*++argv)\n                ++error;\n            else {\n                pat = atoi(*argv);\n                if (pat >= 0 && pat < num_bgpat) {\n                    bg_image = TRUE;\n                    have_bg = FALSE;\n                } else\n                    ++error;\n            }\n        } else if (!strncmp(*argv, \"-usleep\", 2)) {\n            if (!*++argv)\n                ++error;\n            else {\n                usleep_duration = (ulg)atol(*argv);\n                demo_timing = TRUE;\n            }\n        } else if (!strncmp(*argv, \"-pause\", 2)) {\n            pause_after_pass = TRUE;\n        } else if (!strncmp(*argv, \"-timing\", 2)) {\n            timing = TRUE;\n#ifdef FEATURE_LOOP\n        } else if (!strncmp(*argv, \"-loop\", 2)) {\n            loop = TRUE;\n            if (!argv[1] || !is_number(argv[1]))\n                loop_interval = 2;\n            else {\n                ++argv;\n                loop_interval = atol(*argv);\n                if (loop_interval < 0)\n                    loop_interval = 2;\n                else if (loop_interval > 100000)   \n                    loop_interval = 100000;\n            }\n#endif\n        } else {\n            if (**argv != '-') {\n                filename = *argv;\n                if (argv[1])   \n                    ++error;\n            } else\n                ++error;   \n        }\n    }\n    if (!filename)\n        ++error;\n    \n    if (error) {\n        fprintf(stderr, \"\\n%s %s:  %s\\n\\n\", PROGNAME, VERSION, appname);\n        readpng2_version_info();\n        fprintf(stderr, \"\\n\"\n          \"Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg | -bgpat pat]\\n\"\n#ifdef FEATURE_LOOP\n          \"        %*s [-usleep dur | -timing] [-pause] [-loop [sec]] file.png\\n\\n\"\n#else\n          \"        %*s [-usleep dur | -timing] [-pause] file.png\\n\\n\"\n#endif\n          \"    xdpy\\tname of the target X display (e.g., ``hostname:0'')\\n\"\n          \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"\n          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"\n          \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"\n          \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"\n          \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"\n          \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"\n          \"\\t\\t  used with transparent images; overrides -bgpat\\n\"\n          \"    pat \\tdesired background pattern number (0-%d); used with\\n\"\n          \"\\t\\t  transparent images; overrides -bgcolor\\n\"\n#ifdef FEATURE_LOOP\n          \"    -loop\\tloops through background images after initial display\\n\"\n          \"\\t\\t  is complete (depends on -bgpat)\\n\"\n          \"    sec \\tseconds to display each background image (default = 2)\\n\"\n#endif\n          \"    dur \\tduration in microseconds to wait after displaying each\\n\"\n          \"\\t\\t  row (for demo purposes)\\n\"\n          \"    -timing\\tenables delay for every block read, to simulate modem\\n\"\n          \"\\t\\t  download of image (~36 Kbps)\\n\"\n          \"    -pause\\tpauses after displaying each pass until mouse clicked\\n\"\n          \"\\nPress Q, Esc or mouse button 1 (within image window, after image\\n\"\n          \"is displayed) to quit.\\n\"\n          \"\\n\", PROGNAME,\n          (int)strlen(PROGNAME), \" \", default_display_exponent, num_bgpat-1);\n        exit(1);\n    }\n    if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);\n        ++error;\n    } else {\n        incount = fread(inbuf, 1, INBUFSIZE, infile);\n        if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {\n            fprintf(stderr, PROGNAME\n              \":  [%s] is not a PNG file: incorrect signature\\n\",\n              filename);\n            ++error;\n        } else if ((rc = readpng2_init(&rpng2_info)) != 0) {\n            switch (rc) {\n                case 2:\n                    fprintf(stderr, PROGNAME\n                      \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);\n                    break;\n                case 4:\n                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");\n                    break;\n                default:\n                    fprintf(stderr, PROGNAME\n                      \":  unknown readpng2_init() error\\n\");\n                    break;\n            }\n            ++error;\n        } else {\n            Trace((stderr, \"about to call XOpenDisplay()\\n\"))\n            display = XOpenDisplay(displayname);\n            if (!display) {\n                readpng2_cleanup(&rpng2_info);\n                fprintf(stderr, PROGNAME \":  can't open X display [%s]\\n\",\n                  displayname? displayname : \"default\");\n                ++error;\n            }\n        }\n        if (error)\n            fclose(infile);\n    }\n    if (error) {\n        fprintf(stderr, PROGNAME \":  aborting.\\n\");\n        exit(2);\n    }\n    \n    alen = strlen(appname);\n    flen = strlen(filename);\n    if (alen + flen + 3 > 1023)\n        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));\n    else\n        sprintf(titlebar, \"%s:  %s\", appname, filename);\n    \n    if (have_bg) {\n        unsigned r, g, b;   \n        sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);\n        rpng2_info.bg_red   = (uch)r;\n        rpng2_info.bg_green = (uch)g;\n        rpng2_info.bg_blue  = (uch)b;\n    } else\n        rpng2_info.need_bgcolor = TRUE;\n    rpng2_info.state = kPreInit;\n    rpng2_info.mainprog_init = rpng2_x_init;\n    rpng2_info.mainprog_display_row = rpng2_x_display_row;\n    rpng2_info.mainprog_finish_display = rpng2_x_finish_display;\n    \n\n\n\n\n\n\n\n    for (;;) {\n        Trace((stderr, \"about to call readpng2_decode_data()\\n\"))\n        if (readpng2_decode_data(&rpng2_info, inbuf, incount))\n            ++error;\n        Trace((stderr, \"done with readpng2_decode_data()\\n\"))\n        if (error || incount != INBUFSIZE || rpng2_info.state == kDone) {\n            if (rpng2_info.state == kDone) {\n                Trace((stderr, \"done decoding PNG image\\n\"))\n            } else if (ferror(infile)) {\n                fprintf(stderr, PROGNAME\n                  \":  error while reading PNG image file\\n\");\n                exit(3);\n            } else if (feof(infile)) {\n                fprintf(stderr, PROGNAME \":  end of file reached \"\n                  \"(unexpectedly) while reading PNG image file\\n\");\n                exit(3);\n            } else  {\n                \n            }\n            break;\n        }\n        if (timing)\n            sleep(1);\n        incount = fread(inbuf, 1, INBUFSIZE, infile);\n    }\n    \n    fclose(infile);\n    Trace((stderr, \"about to call readpng2_cleanup()\\n\"))\n    readpng2_cleanup(&rpng2_info);\n    if (error) {\n        fprintf(stderr, PROGNAME \":  libpng error while decoding PNG image\\n\");\n        exit(3);\n    }\n#ifdef FEATURE_LOOP\n    if (loop && bg_image) {\n        Trace((stderr, \"entering -loop loop (FEATURE_LOOP)\\n\"))\n        for (;;) {\n            int i, use_sleep;\n            struct timeval now, then;\n            \n            if (gettimeofday(&then, NULL) == 0) {\n                then.tv_sec += loop_interval;\n                use_sleep = FALSE;\n            } else\n                use_sleep = TRUE;\n            \n            \n            if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask, &e))\n                if (QUIT(e,k))\n                    break;\n            \n            if (++pat >= num_bgpat)\n                pat = 0;\n            rpng2_x_reload_bg_image();\n            \n            if (use_sleep || gettimeofday(&now, NULL) != 0) {\n                for (i = loop_interval;  i > 0;  --i) {\n                    sleep(1);\n                    \n                    if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask,\n                        &e) && QUIT(e,k))\n                        break;\n                }\n            } else {\n                \n                if (now.tv_sec < then.tv_sec ||\n                    (now.tv_sec == then.tv_sec && now.tv_usec < then.tv_usec))\n                {\n                    int quit = FALSE;\n                    long seconds_to_go = then.tv_sec - now.tv_sec;\n                    long usleep_usec;\n                    \n\n\n\n\n                    while (seconds_to_go-- > 1) {\n                        int seconds_done = 0;\n                        for (i = seconds_to_go;  i > 0 && !quit;  --i) {\n                            sleep(1);\n                            \n                            if (XCheckMaskEvent(display, KeyPressMask |\n                                ButtonPressMask, &e) && QUIT(e,k))\n                                quit = TRUE;\n                            if (++seconds_done > 1000)\n                                break;   \n                        }\n                        if (quit)\n                            break;\n                        \n\n                        if (gettimeofday(&now, NULL) == 0) {\n                            if (now.tv_sec >= then.tv_sec)\n                                break;\n                            seconds_to_go = then.tv_sec - now.tv_sec;\n                        } else\n                            ++seconds_to_go;  \n                    }\n                    if (quit)\n                        break;   \n                    \n\n\n                    if (gettimeofday(&now, NULL) == 0) {\n                        usleep_usec = 1000000L*(then.tv_sec - now.tv_sec) +\n                          then.tv_usec - now.tv_usec;\n                        if (usleep_usec > 0)\n                            usleep((ulg)usleep_usec);\n                    }\n                }\n            }\n            \n\n            rpng2_x_redisplay_image (0, 0, rpng2_info.width, rpng2_info.height);\n        }\n    } else \n#endif \n    \n    if (rpng2_info.state >= kWindowInit) {\n        Trace((stderr, \"entering final wait-for-quit-event loop\\n\"))\n        do {\n            XNextEvent(display, &e);\n            if (e.type == Expose) {\n                XExposeEvent *ex = (XExposeEvent *)&e;\n                rpng2_x_redisplay_image (ex->x, ex->y, ex->width, ex->height);\n            }\n        } while (!QUIT(e,k));\n    } else {\n        fprintf(stderr, PROGNAME \":  init callback never called:  probable \"\n          \"libpng error while decoding PNG metadata\\n\");\n        exit(4);\n    }\n    \n    Trace((stderr, \"about to call rpng2_x_cleanup()\\n\"))\n    rpng2_x_cleanup();\n    return 0;\n}\n", "bug_type": null, "idx": 363}
{"project": "LibPNG", "target": 0, "func": "static void\nIDAT_end(struct IDAT **idat_var)\n{\n   struct IDAT *idat = *idat_var;\n   struct file *file = idat->file;\n   *idat_var = NULL;\n   CLEAR(*idat);\n   assert(file->chunk != NULL);\n   chunk_end(&file->chunk);\n   \n\n\n\n   file->state = STATE_CHUNKS;\n}\n", "bug_type": null, "idx": 364}
{"project": "LibPNG", "target": 0, "func": "static int\ndisplay_rc(const display *d, int strict)\n{\n   return d->error_count + (strict ? d->warning_count : 0);\n}\n", "bug_type": null, "idx": 365}
{"project": "LibPNG", "target": 0, "func": "static void writepng_error_handler(png_structp png_ptr, png_const_charp msg);\nvoid writepng_version_info(void)\n{\n  fprintf(stderr, \"   Compiled with libpng %s; using libpng %s.\\n\",\n    PNG_LIBPNG_VER_STRING, png_libpng_ver);\n  fprintf(stderr, \"   Compiled with zlib %s; using zlib %s.\\n\",\n    ZLIB_VERSION, zlib_version);\n}\n", "bug_type": null, "idx": 366}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_g8(Pixel *p, png_const_voidp pb)\n{\n   png_const_bytep pp = voidcast(png_const_bytep, pb);\n   p->r = p->g = p->b = pp[0];\n   p->a = 255;\n}\n", "bug_type": null, "idx": 367}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_read_imp(png_store *ps, png_bytep pb, png_size_t st)\n{\n   if (ps->current == NULL || ps->next == NULL)\n      png_error(ps->pread, \"store state damaged\");\n   while (st > 0)\n   {\n      size_t cbAvail = store_read_buffer_size(ps) - ps->readpos;\n      if (cbAvail > 0)\n      {\n         if (cbAvail > st) cbAvail = st;\n         memcpy(pb, ps->next->buffer + ps->readpos, cbAvail);\n         st -= cbAvail;\n         pb += cbAvail;\n         ps->readpos += cbAvail;\n      }\n      else if (!store_read_buffer_next(ps))\n         png_error(ps->pread, \"read beyond end of file\");\n   }\n}\n", "bug_type": null, "idx": 368}
{"project": "LibPNG", "target": 0, "func": " */\nBOOL CenterAbout (HWND hwndChild, HWND hwndParent)\n{\n   RECT    rChild, rParent, rWorkArea;\n   int     wChild, hChild, wParent, hParent;\n   int     xNew, yNew;\n   BOOL  bResult;\n   \n   GetWindowRect (hwndChild, &rChild);\n   wChild = rChild.right - rChild.left;\n   hChild = rChild.bottom - rChild.top;\n   \n   GetWindowRect (hwndParent, &rParent);\n   wParent = rParent.right - rParent.left;\n   hParent = rParent.bottom - rParent.top;\n   \n   bResult = SystemParametersInfo(\n      SPI_GETWORKAREA,  \n      sizeof(RECT),\n      &rWorkArea,\n      0);\n   if (!bResult) {\n      rWorkArea.left = rWorkArea.top = 0;\n      rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);\n      rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);\n   }\n   \n   xNew = rParent.left + ((wParent - wChild) /2);\n   if (xNew < rWorkArea.left) {\n      xNew = rWorkArea.left;\n   } else if ((xNew+wChild) > rWorkArea.right) {\n      xNew = rWorkArea.right - wChild;\n   }\n   \n   yNew = rParent.top  + ((hParent - hChild) /2);\n   if (yNew < rWorkArea.top) {\n      yNew = rWorkArea.top;\n   } else if ((yNew+hChild) > rWorkArea.bottom) {\n      yNew = rWorkArea.bottom - hChild;\n   }\n   \n   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE |\n          SWP_NOZORDER);\n}\n", "bug_type": null, "idx": 369}
{"project": "LibPNG", "target": 0, "func": "static size_t\nsafecat_color_encoding(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST color_encoding *e, double encoding_gamma)\n{\n   if (e != 0)\n   {\n      if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \"(\");\n      pos = safecat(buffer, bufsize, pos, \"R(\");\n      pos = safecatd(buffer, bufsize, pos, e->red.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),G(\");\n      pos = safecatd(buffer, bufsize, pos, e->green.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),B(\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \")\");\n      if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \")\");\n   }\n   if (encoding_gamma != 0)\n   {\n      pos = safecat(buffer, bufsize, pos, \"^\");\n      pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);\n   }\n   return pos;\n}\n", "bug_type": null, "idx": 370}
{"project": "LibPNG", "target": 1, "func": "\nvoid\npng_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_size_t truelen;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_sBIT\\n\");\n\n   buf[0] = buf[1] = buf[2] = buf[3] = 0;\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sBIT\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sBIT after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n   {\n      \n      png_warning(png_ptr, \"Out of place sBIT chunk\");\n   }\n   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_sBIT)\n   {\n      png_warning(png_ptr, \"Duplicate sBIT chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      truelen = 3;\n   else\n      truelen = (png_size_t)png_ptr->channels;\n\n   if (length != truelen)\n   {\n      png_warning(png_ptr, \"Incorrect sBIT chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, truelen);\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\n   {\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[1];\n      png_ptr->sig_bit.blue = buf[2];\n      png_ptr->sig_bit.alpha = buf[3];\n   }\n   else\n   {\n      png_ptr->sig_bit.gray = buf[0];\n      png_ptr->sig_bit.alpha = buf[1];\n   }\n   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));\n}\n#endif", "bug_type": "cve-2004-0597-2", "idx": 371}
{"project": "LibPNG", "target": 0, "func": "#ifdef FEATURE_LOOP\nstatic void rpng2_x_reload_bg_image(void)\n{\n    char *dest;\n    uch r1, r2, g1, g2, b1, b2;\n    uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv;\n    int k, hmax, max;\n    int xidx, yidx, yidx_max;\n    int even_odd_vert, even_odd_horiz, even_odd;\n    int invert_gradient2 = (bg[pat].type & 0x08);\n    int invert_column;\n    ulg i, row;\n    bgscale = (pat == 0)? 8 : bgscale_default;\n    yidx_max = bgscale - 1;\n\n\n\n\n    if ((bg[pat].type & 0x07) == 0) {\n        uch r1_min  = rgb[bg[pat].rgb1_min].r;\n        uch g1_min  = rgb[bg[pat].rgb1_min].g;\n        uch b1_min  = rgb[bg[pat].rgb1_min].b;\n        uch r2_min  = rgb[bg[pat].rgb2_min].r;\n        uch g2_min  = rgb[bg[pat].rgb2_min].g;\n        uch b2_min  = rgb[bg[pat].rgb2_min].b;\n        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;\n        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;\n        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;\n        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;\n        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;\n        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;\n        for (row = 0;  row < rpng2_info.height;  ++row) {\n            yidx = (int)(row % bgscale);\n            even_odd_vert = (int)((row / bgscale) & 1);\n            r1 = r1_min + (r1_diff * yidx) / yidx_max;\n            g1 = g1_min + (g1_diff * yidx) / yidx_max;\n            b1 = b1_min + (b1_diff * yidx) / yidx_max;\n            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;\n            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;\n            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;\n            r2 = r2_min + (r2_diff * yidx) / yidx_max;\n            g2 = g2_min + (g2_diff * yidx) / yidx_max;\n            b2 = b2_min + (b2_diff * yidx) / yidx_max;\n            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;\n            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;\n            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;\n            dest = (char *)bg_data + row*bg_rowbytes;\n            for (i = 0;  i < rpng2_info.width;  ++i) {\n                even_odd_horiz = (int)((i / bgscale) & 1);\n                even_odd = even_odd_vert ^ even_odd_horiz;\n                invert_column =\n                  (even_odd_horiz && (bg[pat].type & 0x10));\n                if (even_odd == 0) {        \n                    if (invert_column) {\n                        *dest++ = r1_inv;\n                        *dest++ = g1_inv;\n                        *dest++ = b1_inv;\n                    } else {\n                        *dest++ = r1;\n                        *dest++ = g1;\n                        *dest++ = b1;\n                    }\n                } else {                    \n                    if ((invert_column && invert_gradient2) ||\n                        (!invert_column && !invert_gradient2))\n                    {\n                        *dest++ = r2;       \n                        *dest++ = g2;       \n                        *dest++ = b2;\n                    } else {\n                        *dest++ = r2_inv;\n                        *dest++ = g2_inv;   \n                        *dest++ = b2_inv;\n                    }\n                }\n            }\n        }\n\n\n\n\n    } else if ((bg[pat].type & 0x07) == 1) {\n        hmax = (bgscale-1)/2;   \n        max = 2*hmax;           \n        r1 = rgb[bg[pat].rgb1_max].r;\n        g1 = rgb[bg[pat].rgb1_max].g;\n        b1 = rgb[bg[pat].rgb1_max].b;\n        r2 = rgb[bg[pat].rgb2_max].r;\n        g2 = rgb[bg[pat].rgb2_max].g;\n        b2 = rgb[bg[pat].rgb2_max].b;\n        for (row = 0;  row < rpng2_info.height;  ++row) {\n            yidx = (int)(row % bgscale);\n            if (yidx > hmax)\n                yidx = bgscale-1 - yidx;\n            dest = (char *)bg_data + row*bg_rowbytes;\n            for (i = 0;  i < rpng2_info.width;  ++i) {\n                xidx = (int)(i % bgscale);\n                if (xidx > hmax)\n                    xidx = bgscale-1 - xidx;\n                k = xidx + yidx;\n                *dest++ = (k*r1 + (max-k)*r2) / max;\n                *dest++ = (k*g1 + (max-k)*g2) / max;\n                *dest++ = (k*b1 + (max-k)*b2) / max;\n            }\n        }\n\n\n\n\n\n    } else if ((bg[pat].type & 0x07) == 2) {\n        uch ch;\n        int ii, x, y, hw, hh, grayspot;\n        double freq, rotate, saturate, gray, intensity;\n        double angle=0.0, aoffset=0.0, maxDist, dist;\n        double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t;\n        hh = (int)(rpng2_info.height / 2);\n        hw = (int)(rpng2_info.width / 2);\n        \n\n\n\n\n\n\n        angle = CLIP(angle, 0.0, 360.0);\n        grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw));\n        freq = MAX((double)bg[pat].bg_freq, 0.0);\n        saturate = (double)bg[pat].bg_bsat * 0.1;\n        rotate = (double)bg[pat].bg_brot * 0.1;\n        gray = 0.0;\n        intensity = 0.0;\n        maxDist = (double)((hw*hw) + (hh*hh));\n        for (row = 0;  row < rpng2_info.height;  ++row) {\n            y = (int)(row - hh);\n            dest = (char *)bg_data + row*bg_rowbytes;\n            for (i = 0;  i < rpng2_info.width;  ++i) {\n                x = (int)(i - hw);\n                angle = (x == 0)? PI_2 : atan((double)y / (double)x);\n                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;\n                gray = MIN(1.0, gray);\n                dist = (double)((x*x) + (y*y)) / maxDist;\n                intensity = cos((angle+(rotate*dist*PI)) * freq) *\n                  gray * saturate;\n                intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5;\n                hue = (angle + PI) * INV_PI_360 + aoffset;\n                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));\n                s = MIN(MAX(s,0.0), 1.0);\n                v = MIN(MAX(intensity,0.0), 1.0);\n                if (s == 0.0) {\n                    ch = (uch)(v * 255.0);\n                    *dest++ = ch;\n                    *dest++ = ch;\n                    *dest++ = ch;\n                } else {\n                    if ((hue < 0.0) || (hue >= 360.0))\n                        hue -= (((int)(hue / 360.0)) * 360.0);\n                    hue /= 60.0;\n                    ii = (int)hue;\n                    f = hue - (double)ii;\n                    p = (1.0 - s) * v;\n                    q = (1.0 - (s * f)) * v;\n                    t = (1.0 - (s * (1.0 - f))) * v;\n                    if      (ii == 0) { red = v; green = t; blue = p; }\n                    else if (ii == 1) { red = q; green = v; blue = p; }\n                    else if (ii == 2) { red = p; green = v; blue = t; }\n                    else if (ii == 3) { red = p; green = q; blue = v; }\n                    else if (ii == 4) { red = t; green = p; blue = v; }\n                    else if (ii == 5) { red = v; green = p; blue = q; }\n                    *dest++ = (uch)(red * 255.0);\n                    *dest++ = (uch)(green * 255.0);\n                    *dest++ = (uch)(blue * 255.0);\n                }\n            }\n        }\n    }\n} \n", "bug_type": null, "idx": 372}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_gray_to_rgb_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   UNUSED(bit_depth)\n   this->next = *that;\n   *that = this;\n   return (colour_type & PNG_COLOR_MASK_COLOR) == 0;\n}\n", "bug_type": null, "idx": 373}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nstandard_end(png_structp ppIn, png_infop pi)\n{\n   png_const_structp pp = ppIn;\n   standard_display *dp = voidcast(standard_display*,\n      png_get_progressive_ptr(pp));\n   UNUSED(pi)\n   \n\n\n   standard_text_validate(dp, pp, pi,\n      PNG_LIBPNG_VER >= 10518);\n   standard_image_validate(dp, pp, 0, -1);\n}\n", "bug_type": null, "idx": 374}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_push_read_chunk(png_structrp png_ptr, png_inforp info_ptr)\n{\n   png_uint_32 chunk_name;\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n   int keep; \n#endif\n\n   \n\n\n\n\n\n   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))\n   {\n      png_byte chunk_length[4];\n      png_byte chunk_tag[4];\n\n      if (png_ptr->buffer_size < 8)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_fill_buffer(png_ptr, chunk_length, 4);\n      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);\n      png_reset_crc(png_ptr);\n      png_crc_read(png_ptr, chunk_tag, 4);\n      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);\n      png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;\n   }\n\n   chunk_name = png_ptr->chunk_name;\n\n   if (chunk_name == png_IDAT)\n   {\n      if (png_ptr->mode & PNG_AFTER_IDAT)\n         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;\n\n      \n\n\n\n      if (!(png_ptr->mode & PNG_HAVE_IHDR))\n         png_error(png_ptr, \"Missing IHDR before IDAT\");\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n          !(png_ptr->mode & PNG_HAVE_PLTE))\n         png_error(png_ptr, \"Missing PLTE before IDAT\");\n\n      png_ptr->mode |= PNG_HAVE_IDAT;\n\n      if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))\n         if (png_ptr->push_length == 0)\n            return;\n\n      if (png_ptr->mode & PNG_AFTER_IDAT)\n         png_benign_error(png_ptr, \"Too many IDATs found\");\n   }\n\n   if (chunk_name == png_IHDR)\n   {\n      if (png_ptr->push_length != 13)\n         png_error(png_ptr, \"Invalid IHDR length\");\n\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n   else if (chunk_name == png_IEND)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);\n\n      png_ptr->process_mode = PNG_READ_DONE_MODE;\n      png_push_have_end(png_ptr, info_ptr);\n   }\n\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n   else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length, keep);\n\n      if (chunk_name == png_PLTE)\n         png_ptr->mode |= PNG_HAVE_PLTE;\n   }\n\n#endif\n   else if (chunk_name == png_PLTE)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n   else if (chunk_name == png_IDAT)\n   {\n      png_ptr->idat_size = png_ptr->push_length;\n      png_ptr->process_mode = PNG_READ_IDAT_MODE;\n      png_push_have_info(png_ptr, info_ptr);\n      png_ptr->zstream.avail_out =\n          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,\n          png_ptr->iwidth) + 1;\n      png_ptr->zstream.next_out = png_ptr->row_buf;\n      return;\n   }\n\n#ifdef PNG_READ_gAMA_SUPPORTED\n   else if (png_ptr->chunk_name == png_gAMA)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sBIT_SUPPORTED\n   else if (png_ptr->chunk_name == png_sBIT)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_cHRM_SUPPORTED\n   else if (png_ptr->chunk_name == png_cHRM)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sRGB_SUPPORTED\n   else if (chunk_name == png_sRGB)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_iCCP_SUPPORTED\n   else if (png_ptr->chunk_name == png_iCCP)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sPLT_SUPPORTED\n   else if (chunk_name == png_sPLT)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_tRNS_SUPPORTED\n   else if (chunk_name == png_tRNS)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_bKGD_SUPPORTED\n   else if (chunk_name == png_bKGD)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_hIST_SUPPORTED\n   else if (chunk_name == png_hIST)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_pHYs_SUPPORTED\n   else if (chunk_name == png_pHYs)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_oFFs_SUPPORTED\n   else if (chunk_name == png_oFFs)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);\n   }\n#endif\n\n#ifdef PNG_READ_pCAL_SUPPORTED\n   else if (chunk_name == png_pCAL)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sCAL_SUPPORTED\n   else if (chunk_name == png_sCAL)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_tIME_SUPPORTED\n   else if (chunk_name == png_tIME)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_tEXt_SUPPORTED\n   else if (chunk_name == png_tEXt)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_zTXt_SUPPORTED\n   else if (chunk_name == png_zTXt)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_iTXt_SUPPORTED\n   else if (chunk_name == png_iTXt)\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n   else\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length,\n         PNG_HANDLE_CHUNK_AS_DEFAULT);\n   }\n\n   png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;\n}", "bug_type": "cve-2014-0333", "idx": 375}
{"project": "LibPNG", "target": 0, "func": "static void\nperform_formatting_test(png_store *volatile ps)\n{\n#ifdef PNG_TIME_RFC1123_SUPPORTED\n   \n\n\n   context(ps, fault);\n   Try\n   {\n      png_const_charp correct = \"29 Aug 2079 13:53:60 +0000\";\n      png_const_charp result;\n#     if PNG_LIBPNG_VER >= 10600\n         char timestring[29];\n#     endif\n      png_structp pp;\n      png_time pt;\n      pp = set_store_for_write(ps, NULL, \"libpng formatting test\");\n      if (pp == NULL)\n         Throw ps;\n      \n      pt.year = 2079;\n      pt.month = 8;\n      pt.day = 29;\n      pt.hour = 13;\n      pt.minute = 53;\n      pt.second = 60; \n#     if PNG_LIBPNG_VER < 10600\n         result = png_convert_to_rfc1123(pp, &pt);\n#     else\n         if (png_convert_to_rfc1123_buffer(timestring, &pt))\n            result = timestring;\n         else\n            result = NULL;\n#     endif\n      if (result == NULL)\n         png_error(pp, \"png_convert_to_rfc1123 failed\");\n      if (strcmp(result, correct) != 0)\n      {\n         size_t pos = 0;\n         char msg[128];\n         pos = safecat(msg, sizeof msg, pos, \"png_convert_to_rfc1123(\");\n         pos = safecat(msg, sizeof msg, pos, correct);\n         pos = safecat(msg, sizeof msg, pos, \") returned: '\");\n         pos = safecat(msg, sizeof msg, pos, result);\n         pos = safecat(msg, sizeof msg, pos, \"'\");\n         png_error(pp, msg);\n      }\n      store_write_reset(ps);\n   }\n   Catch(fault)\n   {\n      store_write_reset(fault);\n   }\n#else\n   UNUSED(ps)\n#endif\n}\n", "bug_type": null, "idx": 376}
{"project": "LibPNG", "target": 0, "func": "static int\nimage_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n{\n   return image_transform_png_set_expand_add(this, that, colour_type,\n      bit_depth);\n}\n", "bug_type": null, "idx": 377}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_unpc(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->a <= 128)\n   {\n      out->r = out->g = out->b = 255;\n      out->a = 0;\n   }\n   else\n   {\n      out->r = sRGB((double)in->r / in->a);\n      out->g = sRGB((double)in->g / in->a);\n      out->b = sRGB((double)in->b / in->a);\n      out->a = u8d(in->a / 257.);\n   }\n}\n", "bug_type": null, "idx": 378}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_sRGB(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   out->r = isRGB(in->r);\n   if (in->g == in->r)\n   {\n      out->g = out->r;\n      if (in->b == in->r)\n         out->b = out->r;\n      else\n         out->b = isRGB(in->b);\n   }\n   else\n   {\n      out->g = isRGB(in->g);\n      if (in->b == in->r)\n         out->b = out->r;\n      else if (in->b == in->g)\n         out->b = out->g;\n      else\n         out->b = isRGB(in->b);\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 379}
{"project": "LibPNG", "target": 0, "func": "#define png_fixed_error png_fixed_warning\nvoid png_fixed_warning(png_const_structrp png_ptr, png_const_charp msg)\n{\n   fprintf(stderr, \"overflow in: %s\\n\", msg);\n}\n", "bug_type": null, "idx": 380}
{"project": "LibPNG", "target": 0, "func": "static int check_some_characters(checkfp_command *co, checkfp_control c,\n   const char *tests)\n{\n   int i;\n   --(c.limit);\n   if (c.cnumber+4 < sizeof co->number && c.limit >= 0)\n   {\n      if (c.limit > 0) for (i=0; tests[i]; ++i)\n      {\n         if (!check_one_character(co, c, tests[i]))\n               return 0;\n      }\n      \n      else\n         return check_all_characters(co, c);\n   }\n   return 1;\n}\n", "bug_type": null, "idx": 381}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_set_encoding(transform_display *this)\n{\n   \n\n\n   png_modifier *pm = this->pm;\n   modifier_set_encoding(pm);\n   if (modifier_color_encoding_is_set(pm))\n   {\n      if (modifier_color_encoding_is_sRGB(pm))\n         srgb_modification_init(&this->srgb_mod, pm, PNG_sRGB_INTENT_ABSOLUTE);\n      else\n      {\n         \n         gama_modification_init(&this->gama_mod, pm, pm->current_gamma);\n         if (pm->current_encoding != 0)\n            chrm_modification_init(&this->chrm_mod, pm, pm->current_encoding);\n      }\n   }\n}\n", "bug_type": null, "idx": 382}
{"project": "LibPNG", "target": 0, "func": "void\nput_chunk(const unsigned char *chunk, uInt length)\n{\n   uLong crc;\n   put_uLong(length-4); \n   fwrite(chunk, length, 1, stdout);\n   crc = crc32(0, Z_NULL, 0);\n   put_uLong(crc32(crc, chunk, length));\n}\n", "bug_type": null, "idx": 383}
{"project": "LibPNG", "target": 0, "func": "static void\nchunk_message(struct chunk *chunk, const char *message)\n{\n   type_message(chunk->file, chunk->chunk_type, message);\n}\n", "bug_type": null, "idx": 384}
{"project": "LibPNG", "target": 0, "func": "static png_uint_16\nu16d(double d)\n{\n   d = closestinteger(d);\n   return (png_uint_16)d;\n}\n", "bug_type": null, "idx": 385}
{"project": "LibPNG", "target": 0, "func": "static int\nis_bad_combo(int transforms)\n{\n   unsigned int i;\n   for (i=0; i<ARRAY_SIZE(known_bad_combos); ++i)\n   {\n      int combo = known_bad_combos[i][0];\n      if ((combo & transforms) == combo &&\n         (transforms & known_bad_combos[i][1]) == 0)\n         return 1;\n   }\n   return 0; \n}\n", "bug_type": null, "idx": 386}
{"project": "LibPNG", "target": 1, "func": "\nvoid\npng_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_debug(1, \"in png_handle_tRNS\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before tRNS\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid tRNS after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)\n   {\n      png_warning(png_ptr, \"Duplicate tRNS chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (!(png_ptr->mode & PNG_HAVE_PLTE))\n      {\n         \n         png_warning(png_ptr, \"Missing PLTE before tRNS\");\n      }\n      else if (length > png_ptr->num_palette)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_ptr->trans = (png_bytep)png_malloc(png_ptr, length);\n      png_ptr->flags |= PNG_FLAG_FREE_TRANS;\n      png_crc_read(png_ptr, png_ptr->trans, (png_size_t)length);\n      png_ptr->num_trans = (png_uint_16)length;\n   }\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_byte buf[6];\n\n      if (length != 6)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, (png_size_t)length);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_values.red = png_get_uint_16(buf);\n      png_ptr->trans_values.green = png_get_uint_16(buf + 2);\n      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);\n   }\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_byte buf[6];\n\n      if (length != 2)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_values.gray = png_get_uint_16(buf);\n   }\n   else\n   {\n      png_warning(png_ptr, \"tRNS chunk not allowed with alpha channel\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   png_set_tRNS(png_ptr, info_ptr, png_ptr->trans, png_ptr->num_trans,\n      &(png_ptr->trans_values));\n}\n#endif", "bug_type": "cve-2004-0597-1", "idx": 387}
{"project": "LibPNG", "target": 0, "func": "\nint WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,\n                    PSTR szCmdLine, int iCmdShow)\n{\n    HACCEL   hAccel;\n    HWND     hwnd;\n    MSG      msg;\n    WNDCLASS wndclass;\n    int ixBorders, iyBorders;\n    wndclass.style         = CS_HREDRAW | CS_VREDRAW;\n    wndclass.lpfnWndProc   = WndProc;\n    wndclass.cbClsExtra    = 0;\n    wndclass.cbWndExtra    = 0;\n    wndclass.hInstance     = hInstance;\n    wndclass.hIcon         = LoadIcon (hInstance, szIconName) ;\n    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);\n    wndclass.hbrBackground = NULL; \n    wndclass.lpszMenuName  = szProgName;\n    wndclass.lpszClassName = szProgName;\n    if (!RegisterClass (&wndclass))\n    {\n        MessageBox (NULL, TEXT (\"Error: this program requires Windows NT!\"),\n            szProgName, MB_ICONERROR);\n        return 0;\n    }\n    \n    if ((szCmdLine != NULL) && (*szCmdLine != '\\0'))\n        if (szCmdLine[0] == '\"')\n            strncpy (szCmdFileName, szCmdLine + 1, strlen(szCmdLine) - 2);\n        else\n            strcpy (szCmdFileName, szCmdLine);\n    else\n        strcpy (szCmdFileName, \"\");\n    \n    ixBorders = 2 * (GetSystemMetrics (SM_CXBORDER) +\n                     GetSystemMetrics (SM_CXDLGFRAME));\n    iyBorders = 2 * (GetSystemMetrics (SM_CYBORDER) +\n                     GetSystemMetrics (SM_CYDLGFRAME)) +\n                     GetSystemMetrics (SM_CYCAPTION) +\n                     GetSystemMetrics (SM_CYMENUSIZE) +\n                     1; \n    hwnd = CreateWindow (szProgName, szAppName,\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, CW_USEDEFAULT,\n        512 + 2 * MARGIN + ixBorders, 384 + 2 * MARGIN + iyBorders,\n\n        NULL, NULL, hInstance, NULL);\n    ShowWindow (hwnd, iCmdShow);\n    UpdateWindow (hwnd);\n    hAccel = LoadAccelerators (hInstance, szProgName);\n    while (GetMessage (&msg, NULL, 0, 0))\n    {\n        if (!TranslateAccelerator (hwnd, hAccel, &msg))\n        {\n            TranslateMessage (&msg);\n            DispatchMessage (&msg);\n        }\n    }\n    return msg.wParam;\n}\n", "bug_type": null, "idx": 388}
{"project": "LibPNG", "target": 0, "func": "static png_uint_32\nstandard_width(png_const_structp pp, png_uint_32 id)\n{\n   png_uint_32 width = WIDTH_FROM_ID(id);\n   UNUSED(pp)\n   if (width == 0)\n      width = transform_width(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));\n   return width;\n}\n", "bug_type": null, "idx": 389}
{"project": "LibPNG", "target": 0, "func": "static void\ntransform_enable(PNG_CONST char *name)\n{\n   \n\n\n   static int all_disabled = 0;\n   int found_it = 0;\n   image_transform *list = image_transform_first;\n   while (list != &image_transform_end)\n   {\n      if (strcmp(list->name, name) == 0)\n      {\n         list->enable = 1;\n         found_it = 1;\n      }\n      else if (!all_disabled)\n         list->enable = 0;\n      list = list->list;\n   }\n   all_disabled = 1;\n   if (!found_it)\n   {\n      fprintf(stderr, \"pngvalid: --transform-enable=%s: unknown transform\\n\",\n         name);\n      exit(99);\n   }\n}\n", "bug_type": null, "idx": 390}
{"project": "LibPNG", "target": 0, "func": "static size_t\nstandard_name_from_id(char *buffer, size_t bufsize, size_t pos, png_uint_32 id)\n{\n   return standard_name(buffer, bufsize, pos, COL_FROM_ID(id),\n      DEPTH_FROM_ID(id), PALETTE_FROM_ID(id), INTERLACE_FROM_ID(id),\n      WIDTH_FROM_ID(id), HEIGHT_FROM_ID(id), DO_INTERLACE_FROM_ID(id));\n}\n", "bug_type": null, "idx": 391}
{"project": "LibPNG", "target": 0, "func": "static unsigned int\ncomponent(png_const_bytep row, png_uint_32 x, unsigned int c,\n   unsigned int bit_depth, unsigned int channels)\n{\n   \n\n\n\n\n   png_uint_32 bit_offset_hi = bit_depth * ((x >> 6) * channels);\n   png_uint_32 bit_offset_lo = bit_depth * ((x & 0x3f) * channels + c);\n   row = (png_const_bytep)(((PNG_CONST png_byte (*)[8])row) + bit_offset_hi);\n   row += bit_offset_lo >> 3;\n   bit_offset_lo &= 0x07;\n   \n\n\n\n   switch (bit_depth)\n   {\n      case 1: return (row[0] >> (7-bit_offset_lo)) & 0x01;\n      case 2: return (row[0] >> (6-bit_offset_lo)) & 0x03;\n      case 4: return (row[0] >> (4-bit_offset_lo)) & 0x0f;\n      case 8: return row[0];\n      case 16: return (row[0] << 8) + row[1];\n      default:\n         \n\n\n         fprintf(stderr, \"pngpixel: invalid bit depth %u\\n\", bit_depth);\n         exit(1);\n   }\n}\n", "bug_type": null, "idx": 392}
{"project": "LibPNG", "target": 0, "func": "static void\ninsert_iTXt(png_structp png_ptr, png_infop info_ptr, int nparams,\n   png_charpp params)\n{\n   png_text text;\n   check_param_count(nparams, 4);\n   clear_text(&text, params[0]);\n   text.compression = 2; \n   text.lang = params[1];\n   text.lang_key = params[2]; \n   set_text(png_ptr, info_ptr, &text, params[3]);\n}\n", "bug_type": null, "idx": 393}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_g8(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->r == in->g && in->g == in->b)\n      out->r = out->g = out->b = in->g;\n   else\n      out->r = out->g = out->b =\n         sRGB(YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));\n   out->a = in->a;\n}\n", "bug_type": null, "idx": 394}
{"project": "LibPNG", "target": 0, "func": "\nBOOL PngLoadImage (PTSTR pstrFileName, png_byte **ppbImageData,\n                   int *piWidth, int *piHeight, int *piChannels, png_color *pBkgColor)\n{\n    static FILE        *pfFile;\n    png_byte            pbSig[8];\n    int                 iBitDepth;\n    int                 iColorType;\n    double              dGamma;\n    png_color_16       *pBackground;\n    png_uint_32         ulChannels;\n    png_uint_32         ulRowBytes;\n    png_byte           *pbImageData = *ppbImageData;\n    static png_byte   **ppbRowPointers = NULL;\n    int                 i;\n    \n    if (!pstrFileName)\n    {\n        *ppbImageData = pbImageData = NULL;\n        return FALSE;\n    }\n    if (!(pfFile = fopen(pstrFileName, \"rb\")))\n    {\n        *ppbImageData = pbImageData = NULL;\n        return FALSE;\n    }\n    \n    fread(pbSig, 1, 8, pfFile);\n    if (png_sig_cmp(pbSig, 0, 8))\n    {\n        *ppbImageData = pbImageData = NULL;\n        return FALSE;\n    }\n    \n    png_ptr = png_create_read_struct(png_get_libpng_ver(NULL), NULL,\n      (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL);\n    if (!png_ptr)\n    {\n        *ppbImageData = pbImageData = NULL;\n        return FALSE;\n    }\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr)\n    {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        *ppbImageData = pbImageData = NULL;\n        return FALSE;\n    }\n    Try\n    {\n        \n#ifdef PNG_STDIO_SUPPORTED\n        png_init_io(png_ptr, pfFile);\n#else\n        png_set_read_fn(png_ptr, (png_voidp)pfFile, png_read_data);\n#endif\n        png_set_sig_bytes(png_ptr, 8);\n        \n        png_read_info(png_ptr, info_ptr);\n        \n        png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,\n            &iColorType, NULL, NULL, NULL);\n        \n        \n#ifdef PNG_READ_16_TO_8_SUPPORTED\n    if (iBitDepth == 16)\n#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n        png_set_scale_16(png_ptr);\n#  else\n        png_set_strip_16(png_ptr);\n#  endif\n#endif\n        if (iColorType == PNG_COLOR_TYPE_PALETTE)\n            png_set_expand(png_ptr);\n        if (iBitDepth < 8)\n            png_set_expand(png_ptr);\n        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\n            png_set_expand(png_ptr);\n        if (iColorType == PNG_COLOR_TYPE_GRAY ||\n            iColorType == PNG_COLOR_TYPE_GRAY_ALPHA)\n            png_set_gray_to_rgb(png_ptr);\n        \n        if (png_get_bKGD(png_ptr, info_ptr, &pBackground))\n        {\n            png_set_background(png_ptr, pBackground, PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);\n            pBkgColor->red   = (byte) pBackground->red;\n            pBkgColor->green = (byte) pBackground->green;\n            pBkgColor->blue  = (byte) pBackground->blue;\n        }\n        else\n        {\n            pBkgColor = NULL;\n        }\n        \n        if (png_get_gAMA(png_ptr, info_ptr, &dGamma))\n            png_set_gamma(png_ptr, (double) 2.2, dGamma);\n        \n        png_read_update_info(png_ptr, info_ptr);\n        \n        png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,\n            &iColorType, NULL, NULL, NULL);\n        \n        ulRowBytes = png_get_rowbytes(png_ptr, info_ptr);\n        ulChannels = png_get_channels(png_ptr, info_ptr);\n        *piChannels = ulChannels;\n        \n        if (pbImageData)\n        {\n            free (pbImageData);\n            pbImageData = NULL;\n        }\n        if ((pbImageData = (png_byte *) malloc(ulRowBytes * (*piHeight)\n                            * sizeof(png_byte))) == NULL)\n        {\n            png_error(png_ptr, \"Visual PNG: out of memory\");\n        }\n        *ppbImageData = pbImageData;\n        \n        if ((ppbRowPointers = (png_bytepp) malloc((*piHeight)\n                            * sizeof(png_bytep))) == NULL)\n        {\n            png_error(png_ptr, \"Visual PNG: out of memory\");\n        }\n        \n        for (i = 0; i < (*piHeight); i++)\n            ppbRowPointers[i] = pbImageData + i * ulRowBytes;\n        \n        png_read_image(png_ptr, ppbRowPointers);\n        \n        png_read_end(png_ptr, NULL);\n        \n        free (ppbRowPointers);\n        ppbRowPointers = NULL;\n        \n    }\n    Catch (msg)\n    {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        *ppbImageData = pbImageData = NULL;\n        if(ppbRowPointers)\n            free (ppbRowPointers);\n        fclose(pfFile);\n        return FALSE;\n    }\n    fclose (pfFile);\n    return TRUE;\n}\n", "bug_type": null, "idx": 395}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_bckc(Pixel *out, const Pixel *in, const Background *back)\n{\n   if (in->a <= 0)\n   {\n      out->r = back->ir;\n      out->g = back->ig;\n      out->b = back->ib;\n   }\n   else if (in->a >= 255)\n   {\n      out->r = in->r;\n      out->g = in->g;\n      out->b = in->b;\n   }\n   else\n   {\n      double a = in->a / 255.;\n      out->r = sRGB(sRGB_to_d[in->r] * a + back->dr * (1-a));\n      out->g = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));\n      out->b = sRGB(sRGB_to_d[in->b] * a + back->db * (1-a));\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 396}
{"project": "LibPNG", "target": 0, "func": "int main(int argc, char **argv)\n{\n   int ok = 0;\n   FILE *fp = tmpfile();\n   if (fp != NULL)\n   {\n      int err = 0;\n      int nfiles = 0;\n      if (argc > 1)\n      {\n         int i;\n         for (i=1; i<argc; ++i)\n         {\n            if (add_one_file(fp, argv[i]))\n               ++nfiles;\n            else\n            {\n               err = 1;\n               break;\n            }\n         }\n      }\n      else\n      {\n         char filename[FILENAME_MAX+1];\n         while (fgets(filename, FILENAME_MAX+1, stdin))\n         {\n            size_t len = strlen(filename);\n            if (filename[len-1] == '\\n')\n            {\n               filename[len-1] = 0;\n               if (add_one_file(fp, filename))\n                  ++nfiles;\n               else\n               {\n                  err = 1;\n                  break;\n               }\n            }\n            else\n            {\n               fprintf(stderr, \"timepng: truncated file name ...%s\\n\",\n                  filename+len-32);\n               err = 1;\n               break;\n            }\n         }\n         if (ferror(stdin))\n         {\n            fprintf(stderr, \"timepng: stdin: read error\\n\");\n            err = 1;\n         }\n      }\n      if (!err)\n      {\n         if (nfiles > 0)\n            ok = perform_one_test(fp, nfiles);\n         else\n            fprintf(stderr, \"usage: timepng {files} or ls files | timepng\\n\");\n      }\n      (void)fclose(fp);\n   }\n   else\n      fprintf(stderr, \"timepng: could not open temporary file\\n\");\n   \n   return ok == 0;\n}\n", "bug_type": null, "idx": 397}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_strip_alpha(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "bug_type": null, "idx": 398}
{"project": "LibPNG", "target": 0, "func": "static void\nbad_parameter_count(png_const_charp what, int nparams)\n{\n   fprintf(stderr, \"--insert %s: bad parameter count %d\\n\", what, nparams);\n   exit(1);\n}\n", "bug_type": null, "idx": 399}
{"project": "LibPNG", "target": 0, "func": "static HWND global_hwnd;\nint WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode)\n{\n    char *args[1024];                 \n    char *p, *q, **argv = args;\n    int argc = 0;\n    int rc, alen, flen;\n    int error = 0;\n    int have_bg = FALSE;\n    double LUT_exponent;              \n    double CRT_exponent = 2.2;        \n    double default_display_exponent;  \n    MSG msg;\n    filename = (char *)NULL;\n#ifndef __CYGWIN__\n    \n\n\n\n    AllocConsole();\n    freopen(\"CONOUT$\", \"a\", stderr);\n    freopen(\"CONOUT$\", \"a\", stdout);\n#endif\n    \n\n\n\n\n\n#if defined(NeXT)\n    LUT_exponent = 1.0 / 2.2;\n    \n\n\n\n#elif defined(sgi)\n    LUT_exponent = 1.0 / 1.7;\n    \n\n    infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");\n    if (infile) {\n        double sgi_gamma;\n        fgets(tmpline, 80, infile);\n        fclose(infile);\n        sgi_gamma = atof(tmpline);\n        if (sgi_gamma > 0.0)\n            LUT_exponent = 1.0 / sgi_gamma;\n    }\n#elif defined(Macintosh)\n    LUT_exponent = 1.8 / 2.61;\n    \n\n\n\n#else\n    LUT_exponent = 1.0;   \n#endif\n    \n    default_display_exponent = LUT_exponent * CRT_exponent;\n    \n\n\n\n    if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)\n        display_exponent = atof(p);\n    else\n        display_exponent = default_display_exponent;\n    \n\n\n    argv[argc++] = PROGNAME;\n    p = cmd;\n    for (;;) {\n        if (*p == ' ')\n            while (*++p == ' ')\n                ;\n        \n        if (*p == '\\0')\n            break;    \n        argv[argc++] = q = p;\n        while (*q && *q != ' ')\n            ++q;\n        \n        if (*q == '\\0')\n            break;    \n        *q = '\\0';    \n        p = q + 1;\n    }\n    argv[argc] = NULL;   \n    \n    while (*++argv && !error) {\n        if (!strncmp(*argv, \"-gamma\", 2)) {\n            if (!*++argv)\n                ++error;\n            else {\n                display_exponent = atof(*argv);\n                if (display_exponent <= 0.0)\n                    ++error;\n            }\n        } else if (!strncmp(*argv, \"-bgcolor\", 2)) {\n            if (!*++argv)\n                ++error;\n            else {\n                bgstr = *argv;\n                if (strlen(bgstr) != 7 || bgstr[0] != '#')\n                    ++error;\n                else\n                    have_bg = TRUE;\n            }\n        } else {\n            if (**argv != '-') {\n                filename = *argv;\n                if (argv[1])   \n                    ++error;\n            } else\n                ++error;   \n        }\n    }\n    if (!filename)\n        ++error;\n    \n    if (error) {\n#ifndef __CYGWIN__\n        int ch;\n#endif\n        fprintf(stderr, \"\\n%s %s:  %s\\n\\n\", PROGNAME, VERSION, appname);\n        readpng_version_info();\n        fprintf(stderr, \"\\n\"\n          \"Usage:  %s [-gamma exp] [-bgcolor bg] file.png\\n\"\n          \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"\n          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"\n          \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"\n          \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"\n          \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"\n          \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"\n          \"\\t\\t  used with transparent images\\n\"\n          \"\\nPress Q, Esc or mouse button 1 after image is displayed to quit.\\n\"\n#ifndef __CYGWIN__\n          \"Press Q or Esc to quit this usage screen.\\n\"\n#endif\n          \"\\n\", PROGNAME, default_display_exponent);\n#ifndef __CYGWIN__\n        do\n            ch = _getch();\n        while (ch != 'q' && ch != 'Q' && ch != 0x1B);\n#endif\n        exit(1);\n    }\n    if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);\n        ++error;\n    } else {\n        if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {\n            switch (rc) {\n                case 1:\n                    fprintf(stderr, PROGNAME\n                      \":  [%s] is not a PNG file: incorrect signature\\n\",\n                      filename);\n                    break;\n                case 2:\n                    fprintf(stderr, PROGNAME\n                      \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);\n                    break;\n                case 4:\n                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");\n                    break;\n                default:\n                    fprintf(stderr, PROGNAME\n                      \":  unknown readpng_init() error\\n\");\n                    break;\n            }\n            ++error;\n        }\n        if (error)\n            fclose(infile);\n    }\n    if (error) {\n#ifndef __CYGWIN__\n        int ch;\n#endif\n        fprintf(stderr, PROGNAME \":  aborting.\\n\");\n#ifndef __CYGWIN__\n        do\n            ch = _getch();\n        while (ch != 'q' && ch != 'Q' && ch != 0x1B);\n#endif\n        exit(2);\n    } else {\n        fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, appname);\n#ifndef __CYGWIN__\n        fprintf(stderr,\n          \"\\n   [console window:  closing this window will terminate %s]\\n\\n\",\n          PROGNAME);\n#endif\n    }\n    \n    alen = strlen(appname);\n    flen = strlen(filename);\n    if (alen + flen + 3 > 1023)\n        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));\n    else\n        sprintf(titlebar, \"%s:  %s\", appname, filename);\n    \n\n\n    if (have_bg) {\n        unsigned r, g, b;   \n        sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);\n        bg_red   = (uch)r;\n        bg_green = (uch)g;\n        bg_blue  = (uch)b;\n    } else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {\n        readpng_cleanup(TRUE);\n        fprintf(stderr, PROGNAME\n          \":  libpng error while checking for background color\\n\");\n        exit(2);\n    }\n    \n\n    if (rpng_win_create_window(hInst, showmode))\n        exit(2);\n    \n    Trace((stderr, \"calling readpng_get_image()\\n\"))\n    image_data = readpng_get_image(display_exponent, &image_channels,\n      &image_rowbytes);\n    Trace((stderr, \"done with readpng_get_image()\\n\"))\n    \n\n    readpng_cleanup(FALSE);\n    fclose(infile);\n    if (!image_data) {\n        fprintf(stderr, PROGNAME \":  unable to decode PNG image\\n\");\n        exit(3);\n    }\n    \n    Trace((stderr, \"calling rpng_win_display_image()\\n\"))\n    if (rpng_win_display_image()) {\n        free(image_data);\n        exit(4);\n    }\n    Trace((stderr, \"done with rpng_win_display_image()\\n\"))\n    \n    printf(\n#ifndef __CYGWIN__\n      \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\"\n#else\n      \"Done.  Press mouse button 1 (within image window) to quit.\\n\"\n#endif\n    );\n    fflush(stdout);\n    while (GetMessage(&msg, NULL, 0, 0)) {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    \n    rpng_win_cleanup();\n    return msg.wParam;\n}\n", "bug_type": null, "idx": 400}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_transform_images(png_store *ps)\n{\n   png_byte colour_type = 0;\n   png_byte bit_depth = 0;\n   unsigned int palette_number = 0;\n   \n   safecat(ps->test, sizeof ps->test, 0, \"make standard images\");\n   \n\n\n   while (next_format(&colour_type, &bit_depth, &palette_number, 0))\n   {\n      int interlace_type;\n      for (interlace_type = PNG_INTERLACE_NONE;\n           interlace_type < INTERLACE_LAST; ++interlace_type)\n      {\n         char name[FILE_NAME_SIZE];\n         standard_name(name, sizeof name, 0, colour_type, bit_depth,\n            palette_number, interlace_type, 0, 0, 0);\n         make_transform_image(ps, colour_type, bit_depth, palette_number,\n            interlace_type, name);\n      }\n   }\n}\n", "bug_type": null, "idx": 401}
{"project": "LibPNG", "target": 0, "func": "static void\nparse_color(char *arg, unsigned int *colors)\n{\n   unsigned int ncolors = 0;\n   while (*arg && ncolors < 4)\n   {\n      char *ep = arg;\n      unsigned long ul = strtoul(arg, &ep, 0);\n      if (ul > 65535)\n      {\n         fprintf(stderr, \"makepng --color=...'%s': too big\\n\", arg);\n         exit(1);\n      }\n      if (ep == arg)\n      {\n         fprintf(stderr, \"makepng --color=...'%s': not a valid color\\n\", arg);\n         exit(1);\n      }\n      if (*ep) ++ep; \n      arg = ep;\n      colors[++ncolors] = (unsigned int)ul; \n   }\n   if (*arg)\n   {\n      fprintf(stderr, \"makepng --color=...'%s': too many values\\n\", arg);\n      exit(1);\n   }\n   *colors = ncolors;\n}\n", "bug_type": null, "idx": 402}
{"project": "LibPNG", "target": 0, "func": "static size_t\nload_file(png_const_charp name, png_bytepp result)\n{\n   FILE *fp = tmpfile();\n   if (fp != NULL)\n   {\n      FILE *ip = fopen(name, \"rb\");\n      if (ip != NULL)\n      {\n         size_t total = 0;\n         int ch;\n         for (;;)\n         {\n            ch = getc(ip);\n            if (ch == EOF) break;\n            putc(ch, fp);\n            ++total;\n         }\n         if (ferror(ip))\n         {\n            perror(name);\n            fprintf(stderr, \"%s: read error\\n\", name);\n            (void)fclose(ip);\n         }\n         else\n         {\n            (void)fclose(ip);\n            if (ferror(fp))\n            {\n               perror(\"temporary file\");\n               fprintf(stderr, \"temporary file write error\\n\");\n            }\n            else\n            {\n               rewind(fp);\n               if (total > 0)\n               {\n                  \n\n\n                  png_bytep data = malloc((total+3)&~3);\n                  if (data != NULL)\n                  {\n                     size_t new_size = 0;\n                     for (;;)\n                     {\n                        ch = getc(fp);\n                        if (ch == EOF) break;\n                        data[new_size++] = (png_byte)ch;\n                     }\n                     if (ferror(fp) || new_size != total)\n                     {\n                        perror(\"temporary file\");\n                        fprintf(stderr, \"temporary file read error\\n\");\n                        free(data);\n                     }\n                     else\n                     {\n                        (void)fclose(fp);\n                        *result = data;\n                        return total;\n                     }\n                  }\n                  else\n                     fprintf(stderr, \"%s: out of memory loading file\\n\", name);\n               }\n               else\n                  fprintf(stderr, \"%s: empty file\\n\", name);\n            }\n         }\n      }\n      else\n      {\n         perror(name);\n         fprintf(stderr, \"%s: open failed\\n\", name);\n      }\n      fclose(fp);\n   }\n   else\n      fprintf(stderr, \"makepng: %s: could not open temporary file\\n\", name);\n   exit(1);\n   return 0;\n}\n", "bug_type": null, "idx": 403}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_verbose(png_store *ps, png_const_structp pp, png_const_charp prefix,\n   png_const_charp message)\n{\n   char buffer[512];\n   if (prefix)\n      fputs(prefix, stderr);\n   (void)store_message(ps, pp, buffer, sizeof buffer, 0, message);\n   fputs(buffer, stderr);\n   fputc('\\n', stderr);\n}\n", "bug_type": null, "idx": 404}
{"project": "LibPNG", "target": 0, "func": "static void\ncheckbuffer(Image *image, const char *arg)\n{\n   if (check16(image->buffer, 95))\n   {\n      fflush(stdout);\n      fprintf(stderr, \"%s: overwrite at start of image buffer\\n\", arg);\n      exit(1);\n   }\n   if (check16(image->buffer+16+image->allocsize, 95))\n   {\n      fflush(stdout);\n      fprintf(stderr, \"%s: overwrite at end of image buffer\\n\", arg);\n      exit(1);\n   }\n}\n", "bug_type": null, "idx": 405}
{"project": "LibPNG", "target": 0, "func": "static void PNGCBAPI\nstore_warning(png_structp ppIn, png_const_charp message)\n{\n   png_const_structp pp = ppIn;\n   png_store *ps = voidcast(png_store*, png_get_error_ptr(pp));\n   if (!ps->expect_warning)\n      store_log(ps, pp, message, 0 );\n   else\n      ps->saw_warning = 1;\n}\n", "bug_type": null, "idx": 406}
{"project": "LibPNG", "target": 0, "func": "int\nmain(void)\n{\n   fprintf(stderr,\n      \"pngfix needs libpng with a zlib >=1.2.4 (not 0x%x)\\n\",\n      ZLIB_VERNUM);\n   return 77;\n}\nint\nmain(void)\n{\n   fprintf(stderr, \"pngfix does not work without read support\\n\");\n   return 77;\n}\nint\nmain(void)\n{\n   fprintf(stderr, \"pngfix does not work without setjmp support\\n\");\n   return 77;\n}\n", "bug_type": null, "idx": 407}
{"project": "LibPNG", "target": 0, "func": "static int rpng2_x_msb(ulg u32val)\n{\n    int i;\n    for (i = 31;  i >= 0;  --i) {\n        if (u32val & 0x80000000L)\n            break;\n        u32val <<= 1;\n    }\n    return i;\n}\n", "bug_type": null, "idx": 408}
{"project": "LibPNG", "target": 0, "func": "#endif\nstatic int format_isset(format_list *pf, png_uint_32 format)\n{\n   return format < FORMAT_COUNT &&\n      (pf->bits[format >> 5] & (((png_uint_32)1) << (format & 31))) != 0;\n}\n", "bug_type": null, "idx": 409}
{"project": "LibPNG", "target": 0, "func": "static store_palette_entry *\nstore_current_palette(png_store *ps, int *npalette)\n{\n   \n\n\n   if (ps->current == NULL)\n      store_log(ps, ps->pread, \"no current stream for palette\", 1);\n   \n   *npalette = ps->current->npalette;\n   return ps->current->palette;\n}\n", "bug_type": null, "idx": 410}
{"project": "LibPNG", "target": 1, "func": "\nvoid \npng_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n\n{\n   png_charp chunkdata;\n   png_byte compression_type;\n   png_bytep pC;\n   png_charp profile;\n   png_uint_32 skip = 0;\n   png_uint_32 profile_size, profile_length;\n   png_size_t slength, prefix_length, data_length;\n\n   png_debug(1, \"in png_handle_iCCP\\n\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before iCCP\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid iCCP after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n      \n      png_warning(png_ptr, \"Out of place iCCP chunk\");\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))\n   {\n      png_warning(png_ptr, \"Duplicate iCCP chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > (png_uint_32)65535L)\n   {\n      png_warning(png_ptr, \"iCCP chunk too large to fit in memory\");\n      skip = length - (png_uint_32)65535L;\n      length = (png_uint_32)65535L;\n   }\n#endif\n\n   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);\n   slength = (png_size_t)length;\n   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);\n\n   if (png_crc_finish(png_ptr, skip))\n   {\n      png_free(png_ptr, chunkdata);\n      return;\n   }\n\n   chunkdata[slength] = 0x00;\n\n   for (profile = chunkdata; *profile; profile++)\n       ;\n\n   ++profile;\n\n   \n\n   if ( profile >= chunkdata + slength - 1)\n   {\n      png_free(png_ptr, chunkdata);\n      png_warning(png_ptr, \"Malformed iCCP chunk\");\n      return;\n   }\n\n   \n   compression_type = *profile++;\n   if (compression_type)\n   {\n      png_warning(png_ptr, \"Ignoring nonzero compression type in iCCP chunk\");\n      compression_type=0x00;  \n\n   }\n\n   prefix_length = profile - chunkdata;\n   chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata,\n                                    slength, prefix_length, &data_length);\n\n   profile_length = data_length - prefix_length;\n\n   if ( prefix_length > data_length || profile_length < 4)\n   {\n      png_free(png_ptr, chunkdata);\n      png_warning(png_ptr, \"Profile size field missing from iCCP chunk\");\n      return;\n   }\n\n   \n   pC = (png_bytep)(chunkdata+prefix_length);\n   profile_size = ((*(pC  ))<<24) |\n                  ((*(pC+1))<<16) |\n                  ((*(pC+2))<< 8) |\n                  ((*(pC+3))    );\n\n   if(profile_size < profile_length)\n      profile_length = profile_size;\n\n   if(profile_size > profile_length)\n   {\n      png_free(png_ptr, chunkdata);\n      png_warning(png_ptr, \"Ignoring truncated iCCP profile.\");\n      return;\n   }\n\n   png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type,\n                chunkdata + prefix_length, profile_length);\n   png_free(png_ptr, chunkdata);\n}\n#endif", "bug_type": "cve-2004-0598", "idx": 411}
{"project": "LibPNG", "target": 0, "func": "static double\ngamma_component_compose(int do_background, double input_sample, double alpha,\n   double background, int *compose)\n{\n   switch (do_background)\n   {\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n      case PNG_BACKGROUND_GAMMA_SCREEN:\n      case PNG_BACKGROUND_GAMMA_FILE:\n      case PNG_BACKGROUND_GAMMA_UNIQUE:\n         \n         if (alpha < 1)\n         {\n            if (alpha > 0)\n            {\n               input_sample = input_sample * alpha + background * (1-alpha);\n               if (compose != NULL)\n                  *compose = 1;\n            }\n            else\n               input_sample = background;\n         }\n         break;\n#endif\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n      case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:\n      case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:\n         \n\n\n\n      case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:\n         \n\n\n\n         if (alpha < 1)\n         {\n            if (alpha > 0)\n            {\n               input_sample *= alpha;\n               if (compose != NULL)\n                  *compose = 1;\n            }\n            else\n               input_sample = 0;\n         }\n         break;\n#endif\n      default:\n         \n\n\n         UNUSED(alpha)\n         UNUSED(background)\n         UNUSED(compose)\n         break;\n   }\n   return input_sample;\n}\n", "bug_type": null, "idx": 412}
{"project": "LibPNG", "target": 0, "func": "static int add_one_file(FILE *fp, char *name)\n{\n   FILE *ip = fopen(name, \"rb\");\n   if (ip != NULL)\n   {\n      int ch;\n      for (;;)\n      {\n         ch = getc(ip);\n         if (ch == EOF) break;\n         putc(ch, fp);\n      }\n      if (ferror(ip))\n      {\n         perror(name);\n         fprintf(stderr, \"%s: read error\\n\", name);\n         return 0;\n      }\n      (void)fclose(ip);\n      if (ferror(fp))\n      {\n         perror(\"temporary file\");\n         fprintf(stderr, \"temporary file write error\\n\");\n         return 0;\n      }\n   }\n   else\n   {\n      perror(name);\n      fprintf(stderr, \"%s: open failed\\n\", name);\n      return 0;\n   }\n   return 1;\n}\n", "bug_type": null, "idx": 413}
{"project": "LibPNG", "target": 0, "func": "static void\ngp_rgb16(Pixel *p, png_const_voidp pb)\n{\n   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);\n   p->r = pp[0];\n   p->g = pp[1];\n   p->b = pp[2];\n   p->a = 65535;\n}\n", "bug_type": null, "idx": 414}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_gprq(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->r == in->g && in->g == in->b)\n      out->r = out->g = out->b = ilineara(in->g, in->a);\n   else\n      out->r = out->g = out->b = u16d(in->a * 257 *\n         YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));\n   out->a = 65535;\n}\n", "bug_type": null, "idx": 415}
{"project": "LibPNG", "target": 0, "func": "static void gamma_threshold_test(png_modifier *pm, png_byte colour_type,\n    png_byte bit_depth, int interlace_type, double file_gamma,\n    double screen_gamma)\n{\n   size_t pos = 0;\n   char name[64];\n   pos = safecat(name, sizeof name, pos, \"threshold \");\n   pos = safecatd(name, sizeof name, pos, file_gamma, 3);\n   pos = safecat(name, sizeof name, pos, \"/\");\n   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);\n   (void)gamma_test(pm, colour_type, bit_depth, 0, interlace_type,\n      file_gamma, screen_gamma, 0, 1, name,\n      0 ,\n      0 , 0 , 0 , 0 ,\n      0 );\n}\n", "bug_type": null, "idx": 416}
{"project": "LibPNG", "target": 0, "func": "static void\ngamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi)\n{\n   \n   standard_info_part1(&dp->this, pp, pi);\n   \n\n\n\n\n   if (dp->scale16)\n#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n         png_set_scale_16(pp);\n#     else\n         \n#        ifdef PNG_READ_16_TO_8_SUPPORTED\n            png_set_strip_16(pp);\n#        else\n            png_error(pp, \"scale16 (16 to 8 bit conversion) not supported\");\n#        endif\n#     endif\n   if (dp->expand16)\n#     ifdef PNG_READ_EXPAND_16_SUPPORTED\n         png_set_expand_16(pp);\n#     else\n         png_error(pp, \"expand16 (8 to 16 bit conversion) not supported\");\n#     endif\n   if (dp->do_background >= ALPHA_MODE_OFFSET)\n   {\n#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n      {\n         \n         int mode = dp->do_background - ALPHA_MODE_OFFSET;\n         \n\n\n\n         PNG_CONST double sg = dp->screen_gamma;\n#        ifndef PNG_FLOATING_POINT_SUPPORTED\n            PNG_CONST png_fixed_point g = fix(sg);\n#        endif\n#        ifdef PNG_FLOATING_POINT_SUPPORTED\n            png_set_alpha_mode(pp, mode, sg);\n#        else\n            png_set_alpha_mode_fixed(pp, mode, g);\n#        endif\n         \n\n\n\n         if (mode == PNG_ALPHA_STANDARD && sg != 1)\n         {\n#           ifdef PNG_FLOATING_POINT_SUPPORTED\n               png_set_gamma(pp, sg, dp->file_gamma);\n#           else\n               png_fixed_point f = fix(dp->file_gamma);\n               png_set_gamma_fixed(pp, g, f);\n#           endif\n         }\n      }\n#     else\n         png_error(pp, \"alpha mode handling not supported\");\n#     endif\n   }\n   else\n   {\n      \n#     ifdef PNG_FLOATING_POINT_SUPPORTED\n         png_set_gamma(pp, dp->screen_gamma, dp->file_gamma);\n#     else\n      {\n         png_fixed_point s = fix(dp->screen_gamma);\n         png_fixed_point f = fix(dp->file_gamma);\n         png_set_gamma_fixed(pp, s, f);\n      }\n#     endif\n      if (dp->do_background)\n      {\n#     ifdef PNG_READ_BACKGROUND_SUPPORTED\n         \n\n         PNG_CONST double bg = dp->background_gamma;\n#        ifndef PNG_FLOATING_POINT_SUPPORTED\n            PNG_CONST png_fixed_point g = fix(bg);\n#        endif\n#        ifdef PNG_FLOATING_POINT_SUPPORTED\n            png_set_background(pp, &dp->background_color, dp->do_background,\n               0, bg);\n#        else\n            png_set_background_fixed(pp, &dp->background_color,\n               dp->do_background, 0, g);\n#        endif\n#     else\n         png_error(pp, \"png_set_background not supported\");\n#     endif\n      }\n   }\n   {\n      int i = dp->this.use_update_info;\n      \n      do\n         png_read_update_info(pp, pi);\n      while (--i > 0);\n   }\n   \n   standard_info_part2(&dp->this, pp, pi, 1 );\n}\n", "bug_type": null, "idx": 417}
{"project": "LibPNG", "target": 0, "func": "static void\nmake_transform_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,\n    png_byte PNG_CONST bit_depth, unsigned int palette_number,\n    int interlace_type, png_const_charp name)\n{\n   context(ps, fault);\n   check_interlace_type(interlace_type);\n   Try\n   {\n      png_infop pi;\n      png_structp pp = set_store_for_write(ps, &pi, name);\n      png_uint_32 h;\n      \n\n\n\n      if (pp == NULL)\n         Throw ps;\n      h = transform_height(pp, colour_type, bit_depth);\n      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth), h,\n         bit_depth, colour_type, interlace_type,\n         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n#ifdef PNG_TEXT_SUPPORTED\n#  if defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED)\n#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_zTXt\n#  else\n#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_NONE\n#  endif\n      {\n         static char key[] = \"image name\"; \n         size_t pos;\n         png_text text;\n         char copy[FILE_NAME_SIZE];\n         \n\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         \n         pos = safecat(copy, sizeof copy, 0, ps->wname);\n         text.text = copy;\n         text.text_length = pos;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n         png_set_text(pp, pi, &text, 1);\n      }\n#endif\n      if (colour_type == 3) \n         init_standard_palette(ps, pp, pi, 1U << bit_depth, 1);\n      png_write_info(pp, pi);\n      if (png_get_rowbytes(pp, pi) !=\n          transform_rowsize(pp, colour_type, bit_depth))\n         png_error(pp, \"row size incorrect\");\n      else\n      {\n         \n\n\n\n         int npasses = png_set_interlace_handling(pp);\n         int pass;\n         if (npasses != npasses_from_interlace_type(pp, interlace_type))\n            png_error(pp, \"write: png_set_interlace_handling failed\");\n         for (pass=0; pass<npasses; ++pass)\n         {\n            png_uint_32 y;\n            for (y=0; y<h; ++y)\n            {\n               png_byte buffer[TRANSFORM_ROWMAX];\n               transform_row(pp, buffer, colour_type, bit_depth, y);\n               png_write_row(pp, buffer);\n            }\n         }\n      }\n#ifdef PNG_TEXT_SUPPORTED\n      {\n         static char key[] = \"end marker\";\n         static char comment[] = \"end\";\n         png_text text;\n         \n\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         text.text = comment;\n         text.text_length = (sizeof comment)-1;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n         png_set_text(pp, pi, &text, 1);\n      }\n#endif\n      png_write_end(pp, pi);\n      \n      store_storefile(ps, FILEID(colour_type, bit_depth, palette_number,\n         interlace_type, 0, 0, 0));\n      store_write_reset(ps);\n   }\n   Catch(fault)\n   {\n      \n\n\n\n      store_write_reset(fault);\n   }\n}\n", "bug_type": null, "idx": 418}
{"project": "LibPNG", "target": 0, "func": "static void\nimage_transform_mod_end(PNG_CONST image_transform *this, image_pixel *that,\n    png_const_structp pp, PNG_CONST transform_display *display)\n{\n   PNG_CONST unsigned int scale = (1U<<that->sample_depth)-1;\n   UNUSED(this)\n   UNUSED(pp)\n   UNUSED(display)\n   \n\n\n\n\n\n\n   that->red = sample_scale(that->redf, scale);\n   \n\n\n\n\n\n\n\n\n\n   that->rede += 1./(2*((1U<<that->red_sBIT)-1));\n   if (that->colour_type & PNG_COLOR_MASK_COLOR)\n   {\n      that->green = sample_scale(that->greenf, scale);\n      that->blue = sample_scale(that->bluef, scale);\n      that->greene += 1./(2*((1U<<that->green_sBIT)-1));\n      that->bluee += 1./(2*((1U<<that->blue_sBIT)-1));\n   }\n   else\n   {\n      that->blue = that->green = that->red;\n      that->bluef = that->greenf = that->redf;\n      that->bluee = that->greene = that->rede;\n   }\n   if ((that->colour_type & PNG_COLOR_MASK_ALPHA) ||\n      that->colour_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      that->alpha = sample_scale(that->alphaf, scale);\n      that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1));\n   }\n   else\n   {\n      that->alpha = scale; \n      that->alpha = 1;     \n      that->alphae = 0;    \n   }\n}\n", "bug_type": null, "idx": 419}
{"project": "LibPNG", "target": 0, "func": "static void\nstandard_info_part1(standard_display *dp, png_structp pp, png_infop pi)\n{\n   if (png_get_bit_depth(pp, pi) != dp->bit_depth)\n      png_error(pp, \"validate: bit depth changed\");\n   if (png_get_color_type(pp, pi) != dp->colour_type)\n      png_error(pp, \"validate: color type changed\");\n   if (png_get_filter_type(pp, pi) != PNG_FILTER_TYPE_BASE)\n      png_error(pp, \"validate: filter type changed\");\n   if (png_get_interlace_type(pp, pi) != dp->interlace_type)\n      png_error(pp, \"validate: interlacing changed\");\n   if (png_get_compression_type(pp, pi) != PNG_COMPRESSION_TYPE_BASE)\n      png_error(pp, \"validate: compression type changed\");\n   dp->w = png_get_image_width(pp, pi);\n   if (dp->w != standard_width(pp, dp->id))\n      png_error(pp, \"validate: image width changed\");\n   dp->h = png_get_image_height(pp, pi);\n   if (dp->h != standard_height(pp, dp->id))\n      png_error(pp, \"validate: image height changed\");\n   \n\n\n   {\n      png_color_8p sBIT = 0;\n      if (png_get_sBIT(pp, pi, &sBIT) & PNG_INFO_sBIT)\n      {\n         int sBIT_invalid = 0;\n         if (sBIT == 0)\n            png_error(pp, \"validate: unexpected png_get_sBIT result\");\n         if (dp->colour_type & PNG_COLOR_MASK_COLOR)\n         {\n            if (sBIT->red == 0 || sBIT->red > dp->bit_depth)\n               sBIT_invalid = 1;\n            else\n               dp->red_sBIT = sBIT->red;\n            if (sBIT->green == 0 || sBIT->green > dp->bit_depth)\n               sBIT_invalid = 1;\n            else\n               dp->green_sBIT = sBIT->green;\n            if (sBIT->blue == 0 || sBIT->blue > dp->bit_depth)\n               sBIT_invalid = 1;\n            else\n               dp->blue_sBIT = sBIT->blue;\n         }\n         else \n         {\n            if (sBIT->gray == 0 || sBIT->gray > dp->bit_depth)\n               sBIT_invalid = 1;\n            else\n               dp->blue_sBIT = dp->green_sBIT = dp->red_sBIT = sBIT->gray;\n         }\n         \n\n\n         if (dp->colour_type & PNG_COLOR_MASK_ALPHA)\n         {\n            if (sBIT->alpha == 0 || sBIT->alpha > dp->bit_depth)\n               sBIT_invalid = 1;\n            else\n               dp->alpha_sBIT = sBIT->alpha;\n         }\n         if (sBIT_invalid)\n            png_error(pp, \"validate: sBIT value out of range\");\n      }\n   }\n   \n\n\n\n\n   if (png_get_rowbytes(pp, pi) != standard_rowsize(pp, dp->id))\n      png_error(pp, \"validate: row size changed\");\n   \n\n\n   standard_palette_validate(dp, pp, pi);\n   \n\n\n\n   {\n      png_color_16p trans_color = 0;\n      if (png_get_tRNS(pp, pi, 0, 0, &trans_color) & PNG_INFO_tRNS)\n      {\n         if (trans_color == 0)\n            png_error(pp, \"validate: unexpected png_get_tRNS (color) result\");\n         switch (dp->colour_type)\n         {\n         case 0:\n            dp->transparent.red = dp->transparent.green = dp->transparent.blue =\n               trans_color->gray;\n            dp->is_transparent = 1;\n            break;\n         case 2:\n            dp->transparent.red = trans_color->red;\n            dp->transparent.green = trans_color->green;\n            dp->transparent.blue = trans_color->blue;\n            dp->is_transparent = 1;\n            break;\n         case 3:\n            \n\n\n            png_error(pp, \"validate: unexpected png_get_tRNS result\");\n            break;\n         default:\n            png_error(pp, \"validate: invalid tRNS chunk with alpha image\");\n         }\n      }\n   }\n   \n\n\n\n   dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type);\n   if (!dp->do_interlace && dp->npasses != png_set_interlace_handling(pp))\n      png_error(pp, \"validate: file changed interlace type\");\n   \n\n\n}\n", "bug_type": null, "idx": 420}
{"project": "LibPNG", "target": 0, "func": "static void\nset_color(png_colorp color, png_bytep trans, unsigned int red,\n   unsigned int green, unsigned int blue, unsigned int alpha,\n   png_const_bytep gamma_table)\n{\n   color->red = gamma_table[red];\n   color->green = gamma_table[green];\n   color->blue = gamma_table[blue];\n   *trans = (png_byte)alpha;\n}\n", "bug_type": null, "idx": 421}
{"project": "LibPNG", "target": 0, "func": "static int\ngama_modify(png_modifier *pm, png_modification *me, int add)\n{\n   UNUSED(add)\n   \n   png_save_uint_32(pm->buffer, 4);\n   png_save_uint_32(pm->buffer+4, CHUNK_gAMA);\n   png_save_uint_32(pm->buffer+8, ((gama_modification*)me)->gamma);\n   return 1;\n}\n", "bug_type": null, "idx": 422}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_nop8(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   if (in->a == 0)\n      out->r = out->g = out->b = 255;\n   else\n   {\n      out->r = in->r;\n      out->g = in->g;\n      out->b = in->b;\n   }\n   out->a = in->a;\n}\n", "bug_type": null, "idx": 423}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_A(Pixel *out, const Pixel *in, const Background *back)\n{\n   (void)back;\n   out->r = in->r;\n   out->g = in->g;\n   out->b = in->b;\n   out->a = 65535;\n}\n", "bug_type": null, "idx": 424}
{"project": "LibPNG", "target": 0, "func": "} \nstatic int is_number(char *p)\n{\n    while (*p) {\n        if (!isdigit(*p))\n            return FALSE;\n        ++p;\n    }\n    return TRUE;\n}\n", "bug_type": null, "idx": 425}
{"project": "LibPNG", "target": 0, "func": "static void\nzlib_end(struct zlib *zlib)\n{\n   \n\n\n   if (!zlib->global->quiet)\n   {\n      if (zlib->ok_bits < 16) \n      {\n         const char *reason;\n         if (zlib->cksum)\n            reason = \"CHK\"; \n         else if (zlib->ok_bits > zlib->file_bits)\n            reason = \"TFB\"; \n         else if (zlib->ok_bits == zlib->file_bits)\n            reason = \"OK \";\n         else\n            reason = \"OPT\"; \n         \n\n\n\n         type_name(zlib->chunk->chunk_type, stdout);\n         printf(\" %s %s %d %d \", reason, zlib_flevel(zlib), zlib->file_bits,\n            zlib->ok_bits);\n         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);\n         putc(' ', stdout);\n         uarb_print(zlib->uncompressed_bytes, zlib->uncompressed_digits,\n            stdout);\n         putc(' ', stdout);\n         fputs(zlib->file->file_name, stdout);\n         putc('\\n', stdout);\n      }\n      else\n      {\n         \n\n\n\n\n\n\n\n\n\n\n         type_name(zlib->chunk->chunk_type, stdout);\n         printf(\" SKP %s %d %s \", zlib_flevel(zlib), zlib->file_bits,\n            zlib_rc(zlib));\n         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);\n         putc(' ', stdout);\n         emit_string(zlib->z.msg ? zlib->z.msg : \"[no_message]\", stdout);\n         putc(' ', stdout);\n         fputs(zlib->file->file_name, stdout);\n         putc('\\n', stdout);\n      }\n   }\n   if (zlib->state >= 0)\n   {\n      zlib->rc = inflateEnd(&zlib->z);\n      if (zlib->rc != Z_OK)\n         zlib_message(zlib, 1);\n   }\n   CLEAR(*zlib);\n}\n", "bug_type": null, "idx": 426}
{"project": "LibPNG", "target": 0, "func": "static int PNGCBAPI\nread_callback(png_structp pp, png_unknown_chunkp pc)\n{\n   \n\n\n   display *d = voidcast(display*, png_get_user_chunk_ptr(pp));\n   int chunk = findb(pc->name);\n   int keep, discard;\n   if (chunk < 0) \n      keep = d->keep;\n   else\n   {\n      keep = chunk_info[chunk].keep;\n      if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n      {\n         \n\n\n         if (chunk_info[chunk].unknown)\n            keep = d->keep;\n         else\n            keep = PNG_HANDLE_CHUNK_NEVER;\n      }\n   }\n   switch (keep)\n   {\n      default:\n         fprintf(stderr, \"%s(%s): %d: unrecognized chunk option\\n\", d->file,\n            d->test, chunk_info[chunk].keep);\n         display_exit(d);\n      case PNG_HANDLE_CHUNK_AS_DEFAULT:\n      case PNG_HANDLE_CHUNK_NEVER:\n         discard = 1;\n         break;\n      case PNG_HANDLE_CHUNK_IF_SAFE:\n      case PNG_HANDLE_CHUNK_ALWAYS:\n         discard = 0;\n         break;\n   }\n   \n\n\n   if (chunk >= 0) if (!discard) \n   {\n      png_uint_32 flag = chunk_info[chunk].flag;\n      if (pc->location & PNG_AFTER_IDAT)\n         d->after_IDAT |= flag;\n      else\n         d->before_IDAT |= flag;\n   }\n   \n\n\n#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n      return discard;\n#  else\n      return 1; \n#  endif\n}\n", "bug_type": null, "idx": 427}
{"project": "LibPNG", "target": 0, "func": "static CIE_color\nwhite_point(PNG_CONST color_encoding *encoding)\n{\n   CIE_color white;\n   white.X = encoding->red.X + encoding->green.X + encoding->blue.X;\n   white.Y = encoding->red.Y + encoding->green.Y + encoding->blue.Y;\n   white.Z = encoding->red.Z + encoding->green.Z + encoding->blue.Z;\n   return white;\n}\n", "bug_type": null, "idx": 428}
{"project": "LibPNG", "target": 0, "func": "static void\nstore_freefile(png_store_file **ppf)\n{\n   if (*ppf != NULL)\n   {\n      store_freefile(&(*ppf)->next);\n      store_freebuffer(&(*ppf)->data);\n      (*ppf)->datacount = 0;\n      if ((*ppf)->palette != NULL)\n      {\n         free((*ppf)->palette);\n         (*ppf)->palette = NULL;\n         (*ppf)->npalette = 0;\n      }\n      free(*ppf);\n      *ppf = NULL;\n   }\n}\n", "bug_type": null, "idx": 429}
{"project": "LibPNG", "target": 0, "func": "static void\ngpc_bckg(Pixel *out, const Pixel *in, const Background *back)\n{\n   if (in->a <= 0)\n      out->r = out->g = out->b = back->ig;\n   else if (in->a >= 255)\n      out->r = out->g = out->b = in->g;\n   else\n   {\n      double a = in->a / 255.;\n      out->r = out->g = out->b = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));\n   }\n   out->a = 255;\n}\n", "bug_type": null, "idx": 430}
{"project": "LibPNG", "target": 0, "func": " */\nint main(int argc, char *argv[])\n{\n  FILE *fp_rd = stdin;\n  FILE *fp_wr = stdout;\n  FILE *fp_al = NULL;\n  BOOL raw = TRUE;\n  BOOL alpha = FALSE;\n  int argi;\n  for (argi = 1; argi < argc; argi++)\n  {\n    if (argv[argi][0] == '-')\n    {\n      switch (argv[argi][1])\n      {\n        case 'n':\n          raw = FALSE;\n          break;\n        case 'r':\n          raw = TRUE;\n          break;\n        case 'a':\n          alpha = TRUE;\n          argi++;\n          if ((fp_al = fopen (argv[argi], \"wb\")) == NULL)\n          {\n            fprintf (stderr, \"PNM2PNG\\n\");\n            fprintf (stderr, \"Error:  can not create alpha-channel file %s\\n\",\n               argv[argi]);\n            exit (1);\n          }\n          break;\n        case 'h':\n        case '?':\n          usage();\n          exit(0);\n          break;\n        default:\n          fprintf (stderr, \"PNG2PNM\\n\");\n          fprintf (stderr, \"Error:  unknown option %s\\n\", argv[argi]);\n          usage();\n          exit(1);\n          break;\n      } \n    }\n    else if (fp_rd == stdin)\n    {\n      if ((fp_rd = fopen (argv[argi], \"rb\")) == NULL)\n      {\n             fprintf (stderr, \"PNG2PNM\\n\");\n            fprintf (stderr, \"Error:  file %s does not exist\\n\", argv[argi]);\n            exit (1);\n      }\n    }\n    else if (fp_wr == stdout)\n    {\n      if ((fp_wr = fopen (argv[argi], \"wb\")) == NULL)\n      {\n        fprintf (stderr, \"PNG2PNM\\n\");\n        fprintf (stderr, \"Error:  can not create file %s\\n\", argv[argi]);\n        exit (1);\n      }\n    }\n    else\n    {\n      fprintf (stderr, \"PNG2PNM\\n\");\n      fprintf (stderr, \"Error:  too many parameters\\n\");\n      usage();\n      exit(1);\n    }\n  } \n#ifdef __TURBOC__\n  \n  if (fp_rd == stdin)\n  {\n    setmode (STDIN, O_BINARY);\n  }\n  if ((raw) && (fp_wr == stdout))\n  {\n    setmode (STDOUT, O_BINARY);\n  }\n#endif\n  \n  if (png2pnm (fp_rd, fp_wr, fp_al, raw, alpha) == FALSE)\n  {\n    fprintf (stderr, \"PNG2PNM\\n\");\n    fprintf (stderr, \"Error:  unsuccessful conversion of PNG-image\\n\");\n    exit(1);\n  }\n  \n  fclose (fp_rd);\n  \n  fclose (fp_wr);\n  \n  if (alpha)\n    fclose (fp_al);\n  return 0;\n}\n", "bug_type": null, "idx": 431}
{"project": "LibPNG", "target": 0, "func": "int main(int argc, char **argv)\n{\n   int err = 0;\n   printf(\"/* adler32, crc32, MD5[16], intent, date, length, file-name */\\n\");\n   if (argc > 1)\n   {\n      int i;\n      for (i=1; i<argc; ++i)\n      {\n         FILE *ip = fopen(argv[i], \"rb\");\n         if (ip == NULL || !read_one_file(ip, argv[i]))\n         {\n            err = 1;\n            perror(argv[i]);\n            fprintf(stderr, \"%s: read error\\n\", argv[i]);\n            printf(\"/* ERROR: %s */\\n\", argv[i]);\n         }\n         (void)fclose(ip);\n      }\n   }\n   else\n   {\n      if (!read_one_file(stdin, \"-\"))\n      {\n         err = 1;\n         perror(\"stdin\");\n         fprintf(stderr, \"stdin: read error\\n\");\n         printf(\"/* ERROR: stdin */\\n\");\n      }\n   }\n   return err;\n}\n", "bug_type": null, "idx": 432}
