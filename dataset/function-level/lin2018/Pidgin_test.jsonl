{"project": "Pidgin", "target": 0, "func": "GList *\npurple_get_conversations(void)\n{\n\treturn conversations;\n}\n", "bug_type": null, "idx": 0}
{"project": "Pidgin", "target": 0, "func": "static void jabber_si_xfer_send_method_cb(JabberStream *js, const char *from,\n                                          JabberIqType type, const char *id,\n                                          xmlnode *packet, gpointer data)\n{\n\tPurpleXfer *xfer = data;\n\txmlnode *si, *feature, *x, *field, *value;\n\tgboolean found_method = FALSE;\n\tif(!(si = xmlnode_get_child_with_namespace(packet, \"si\", \"http://jabber.org/protocol/si\"))) {\n\t\tpurple_xfer_cancel_remote(xfer);\n\t\treturn;\n\t}\n\tif(!(feature = xmlnode_get_child_with_namespace(si, \"feature\", \"http://jabber.org/protocol/feature-neg\"))) {\n\t\tpurple_xfer_cancel_remote(xfer);\n\t\treturn;\n\t}\n\tif(!(x = xmlnode_get_child_with_namespace(feature, \"x\", \"jabber:x:data\"))) {\n\t\tpurple_xfer_cancel_remote(xfer);\n\t\treturn;\n\t}\n\tfor(field = xmlnode_get_child(x, \"field\"); field; field = xmlnode_get_next_twin(field)) {\n\t\tconst char *var = xmlnode_get_attrib(field, \"var\");\n\t\tJabberSIXfer *jsx = (JabberSIXfer *) xfer->data;\n\t\tif(var && !strcmp(var, \"stream-method\")) {\n\t\t\tif((value = xmlnode_get_child(field, \"value\"))) {\n\t\t\t\tchar *val = xmlnode_get_data(value);\n\t\t\t\tif(val && !strcmp(val, NS_BYTESTREAMS)) {\n\t\t\t\t\tjabber_si_xfer_bytestreams_send_init(xfer);\n\t\t\t\t\tjsx->stream_method |= STREAM_METHOD_BYTESTREAMS;\n\t\t\t\t\tfound_method = TRUE;\n\t\t\t\t} else if (val && !strcmp(val, NS_IBB)) {\n\t\t\t\t\tjsx->stream_method |= STREAM_METHOD_IBB;\n\t\t\t\t\tif (!found_method) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tjabber_si_xfer_ibb_send_init(js, xfer);\n\t\t\t\t\t\tfound_method = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg_free(val);\n\t\t\t}\n\t\t}\n\t}\n\tif (!found_method) {\n\t\tpurple_xfer_cancel_remote(xfer);\n\t}\n}\n", "bug_type": null, "idx": 1}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_connection_error_is_fatal (PurpleConnectionError reason)\n{\n\tswitch (reason)\n\t{\n\t\tcase PURPLE_CONNECTION_ERROR_NETWORK_ERROR:\n\t\tcase PURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR:\n\t\t\treturn FALSE;\n\t\tcase PURPLE_CONNECTION_ERROR_INVALID_USERNAME:\n\t\tcase PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED:\n\t\tcase PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE:\n\t\tcase PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT:\n\t\tcase PURPLE_CONNECTION_ERROR_NAME_IN_USE:\n\t\tcase PURPLE_CONNECTION_ERROR_INVALID_SETTINGS:\n\t\tcase PURPLE_CONNECTION_ERROR_OTHER_ERROR:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_NOT_PROVIDED:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_UNTRUSTED:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_EXPIRED:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_NOT_ACTIVATED:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_HOSTNAME_MISMATCH:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_FINGERPRINT_MISMATCH:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_SELF_SIGNED:\n\t\tcase PURPLE_CONNECTION_ERROR_CERT_OTHER_ERROR:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\tg_return_val_if_reached(TRUE);\n\t}\n}\n", "bug_type": null, "idx": 2}
{"project": "Pidgin", "target": 0, "func": "static void *tcl_signal_callback(va_list args, struct tcl_signal_handler *handler)\n{\n\tGString *name, *val;\n\tPurpleBlistNode *node;\n\tint i;\n\tvoid *retval = NULL;\n\tTcl_Obj *cmd, *arg, *result;\n\tvoid **vals; \n\tchar ***strs;\n\tvals = g_new0(void *, handler->nargs);\n\tstrs = g_new0(char **, handler->nargs);\n\tname = g_string_sized_new(32);\n\tval = g_string_sized_new(32);\n\tcmd = Tcl_NewListObj(0, NULL);\n\tTcl_IncrRefCount(cmd);\n\targ = Tcl_DuplicateObj(handler->namespace);\n\tTcl_AppendStringsToObj(arg, \"::cb\", NULL);\n\tTcl_ListObjAppendElement(handler->interp, cmd, arg);\n\tfor (i = 0; i < handler->nargs; i++) {\n\t\tif (purple_value_is_outgoing(handler->argtypes[i]))\n\t\t\tg_string_printf(name, \"%s::arg%d\",\n\t\t\t\t\tTcl_GetString(handler->namespace), i);\n\t\tswitch(purple_value_get_type(handler->argtypes[i])) {\n\t\tcase PURPLE_TYPE_UNKNOWN:\t\n\t\t\t\n\t\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"tcl\", \"unknown PurpleValue type %d\\n\",\n\t\t\t\t   purple_value_get_type(handler->argtypes[i]));\n\t\t\t\n\t\tcase PURPLE_TYPE_POINTER:\n\t\tcase PURPLE_TYPE_OBJECT:\n\t\tcase PURPLE_TYPE_BOXED:\n\t\t\t\n\t\t\tif (purple_value_is_outgoing(handler->argtypes[i]))\n\t\t\t\tpurple_debug_error(\"tcl\", \"pointer types do not currently support outgoing arguments\\n\");\n\t\t\targ = purple_tcl_ref_new(PurpleTclRefPointer, va_arg(args, void *));\n\t\t\tbreak;\n\t\tcase PURPLE_TYPE_BOOLEAN:\n\t\t\tif (purple_value_is_outgoing(handler->argtypes[i])) {\n\t\t\t\tvals[i] = va_arg(args, gboolean *);\n\t\t\t\tTcl_LinkVar(handler->interp, name->str,\n\t\t\t\t\t    (char *)&vals[i], TCL_LINK_BOOLEAN);\n\t\t\t\targ = Tcl_NewStringObj(name->str, -1);\n\t\t\t} else {\n\t\t\t\targ = Tcl_NewBooleanObj(va_arg(args, gboolean));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_TYPE_CHAR:\n\t\tcase PURPLE_TYPE_UCHAR:\n\t\tcase PURPLE_TYPE_SHORT:\n\t\tcase PURPLE_TYPE_USHORT:\n\t\tcase PURPLE_TYPE_INT:\n\t\tcase PURPLE_TYPE_UINT:\n\t\tcase PURPLE_TYPE_LONG:\n\t\tcase PURPLE_TYPE_ULONG:\n\t\tcase PURPLE_TYPE_ENUM:\n\t\t\t\n\t\t\tif (purple_value_is_outgoing(handler->argtypes[i])) {\n\t\t\t\tvals[i] = va_arg(args, int *);\n\t\t\t\tTcl_LinkVar(handler->interp, name->str,\n\t\t\t\t\t    vals[i], TCL_LINK_INT);\n\t\t\t\targ = Tcl_NewStringObj(name->str, -1);\n\t\t\t} else {\n\t\t\t\targ = Tcl_NewIntObj(va_arg(args, int));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_TYPE_INT64:\n\t\tcase PURPLE_TYPE_UINT64:\n\t\t\t\n\t\t\tif (purple_value_is_outgoing(handler->argtypes[i])) {\n\t\t\t\tvals[i] = (void *)va_arg(args, gint64 *);\n\t\t\t\t#if (TCL_MAJOR_VERSION >= 8 && TCL_MINOR_VERSION >= 4)\n\t\t\t\tTcl_LinkVar(handler->interp, name->str,\n\t\t\t\t\t    vals[i], TCL_LINK_WIDE_INT);\n\t\t\t\t#else\n\t\t\t\t\n\t\t\t\tTcl_LinkVar(handler->interp, name->str,\n\t\t\t\t\t    vals[i], TCL_LINK_INT);\n\t\t\t\t#endif \n\t\t\t\targ = Tcl_NewStringObj(name->str, -1);\n\t\t\t} else {\n\t\t\t\t#if (TCL_MAJOR_VERSION >= 8 && TCL_MINOR_VERSION >= 4)\n\t\t\t\targ = Tcl_NewWideIntObj(va_arg(args, gint64));\n\t\t\t\t#else\n\t\t\t\targ = Tcl_NewIntObj((int)va_arg(args, int));\n\t\t\t\t#endif \n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_TYPE_STRING:\n\t\t\tif (purple_value_is_outgoing(handler->argtypes[i])) {\n\t\t\t\tstrs[i] = va_arg(args, char **);\n\t\t\t\tif (strs[i] == NULL || *strs[i] == NULL) {\n\t\t\t\t\tvals[i] = ckalloc(1);\n\t\t\t\t\t*(char *)vals[i] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tsize_t len = strlen(*strs[i]) + 1;\n\t\t\t\t\tvals[i] = ckalloc(len);\n\t\t\t\t\tg_strlcpy(vals[i], *strs[i], len);\n\t\t\t\t}\n\t\t\t\tTcl_LinkVar(handler->interp, name->str,\n\t\t\t\t\t    (char *)&vals[i], TCL_LINK_STRING);\n\t\t\t\targ = Tcl_NewStringObj(name->str, -1);\n\t\t\t} else {\n\t\t\t\targ = Tcl_NewStringObj(va_arg(args, char *), -1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_TYPE_SUBTYPE:\n\t\t\tswitch (purple_value_get_subtype(handler->argtypes[i])) {\n\t\t\tcase PURPLE_SUBTYPE_UNKNOWN:\n\t\t\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"tcl\", \"subtype unknown\\n\");\n\t\t\t\t\n\t\t\tcase PURPLE_SUBTYPE_ACCOUNT:\n\t\t\tcase PURPLE_SUBTYPE_CONNECTION:\n\t\t\tcase PURPLE_SUBTYPE_CONVERSATION:\n\t\t\tcase PURPLE_SUBTYPE_STATUS:\n\t\t\tcase PURPLE_SUBTYPE_PLUGIN:\n\t\t\tcase PURPLE_SUBTYPE_XFER:\n\t\t\t\tif (purple_value_is_outgoing(handler->argtypes[i]))\n\t\t\t\t\tpurple_debug_error(\"tcl\", \"pointer subtypes do not currently support outgoing arguments\\n\");\n\t\t\t\targ = purple_tcl_ref_new(ref_type(purple_value_get_subtype(handler->argtypes[i])), va_arg(args, void *));\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_SUBTYPE_BLIST:\n\t\t\tcase PURPLE_SUBTYPE_BLIST_BUDDY:\n\t\t\tcase PURPLE_SUBTYPE_BLIST_GROUP:\n\t\t\tcase PURPLE_SUBTYPE_BLIST_CHAT:\n\t\t\t\t\n\t\t\t\tif (purple_value_is_outgoing(handler->argtypes[i]))\n\t\t\t\t\tnode = *va_arg(args, PurpleBlistNode **);\n\t\t\t\telse\n\t\t\t\t\tnode = va_arg(args, PurpleBlistNode *);\n\t\t\t\tswitch (purple_blist_node_get_type(node)) {\n\t\t\t\tcase PURPLE_BLIST_GROUP_NODE:\n\t\t\t\t\targ = Tcl_NewListObj(0, NULL);\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t Tcl_NewStringObj(\"group\", -1));\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t Tcl_NewStringObj(purple_group_get_name((PurpleGroup *)node), -1));\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_BLIST_CONTACT_NODE:\n\t\t\t\t\t\n\t\t\t\t\targ = Tcl_NewStringObj(\"contact\", -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_BLIST_BUDDY_NODE:\n\t\t\t\t\targ = Tcl_NewListObj(0, NULL);\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t Tcl_NewStringObj(\"buddy\", -1));\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t Tcl_NewStringObj(purple_buddy_get_name((PurpleBuddy *)node), -1));\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t purple_tcl_ref_new(PurpleTclRefAccount,\n\t\t\t\t\t\t\t\t\t\t    purple_buddy_get_account((PurpleBuddy *)node)));\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_BLIST_CHAT_NODE:\n\t\t\t\t\targ = Tcl_NewListObj(0, NULL);\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t Tcl_NewStringObj(\"chat\", -1));\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t Tcl_NewStringObj(purple_chat_get_name((PurpleChat *)node), -1));\n\t\t\t\t\tTcl_ListObjAppendElement(handler->interp, arg,\n\t\t\t\t\t\t\t\t purple_tcl_ref_new(PurpleTclRefAccount,\n\t\t\t\t\t\t\t\t\t\t  purple_chat_get_account((PurpleChat *)node)));\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_BLIST_OTHER_NODE:\n\t\t\t\t\targ = Tcl_NewStringObj(\"other\", -1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTcl_ListObjAppendElement(handler->interp, cmd, arg);\n\t}\n\t\n\tif (Tcl_EvalObjEx(handler->interp, cmd, TCL_EVAL_GLOBAL) != TCL_OK) {\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"tcl\", \"error evaluating callback: %s\\n\",\n\t\t\t   Tcl_GetString(Tcl_GetObjResult(handler->interp)));\n\t} else {\n\t\tresult = Tcl_GetObjResult(handler->interp);\n\t\t\n\t\tif (handler->returntype) {\n\t\t\tif (purple_value_get_type(handler->returntype) == PURPLE_TYPE_STRING) {\n\t\t\t\tretval = (void *)g_strdup(Tcl_GetString(result));\n\t\t\t} else {\n\t\t\t\tif (Tcl_GetIntFromObj(handler->interp, result, (int *)&retval) != TCL_OK) {\n\t\t\t\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"tcl\", \"Error retrieving procedure result: %s\\n\",\n\t\t\t\t\t\t   Tcl_GetString(Tcl_GetObjResult(handler->interp)));\n\t\t\t\t\tretval = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < handler->nargs; i++) {\n\t\tg_string_printf(name, \"%s::arg%d\",\n\t\t\t\tTcl_GetString(handler->namespace), i);\n\t\tif (purple_value_is_outgoing(handler->argtypes[i])\n\t\t    && purple_value_get_type(handler->argtypes[i]) != PURPLE_TYPE_SUBTYPE)\n\t\t\tTcl_UnlinkVar(handler->interp, name->str);\n\t\t\n\t\tswitch (purple_value_get_type(handler->argtypes[i])) {\n\t\tcase PURPLE_TYPE_STRING:\n\t\t\tif (purple_value_is_outgoing(handler->argtypes[i])) {\n\t\t\t\tif (vals[i] != NULL && *(char **)vals[i] != NULL) {\n\t\t\t\t\tg_free(*strs[i]);\n\t\t\t\t\t*strs[i] = g_strdup(vals[i]);\n\t\t\t\t}\n\t\t\t\tckfree(vals[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\n\t\t\t;\n\t\t}\n\t}\n\tg_string_free(name, TRUE);\n\tg_string_free(val, TRUE);\n\tg_free(vals);\n\tg_free(strs);\n\treturn retval;\n}\n", "bug_type": null, "idx": 3}
{"project": "Pidgin", "target": 0, "func": "int\nnm_contact_get_id(NMContact * contact)\n{\n\tif (contact == NULL)\n\t\treturn -1;\n\treturn contact->id;\n}\n", "bug_type": null, "idx": 4}
{"project": "Pidgin", "target": 0, "func": "static void\nupdate_generic_error_message(PurpleAccount *account,\n                             const char *description)\n{\n\tPidginBuddyListPrivate *priv = PIDGIN_BUDDY_LIST_GET_PRIVATE(gtkblist);\n\tGtkWidget *mini_dialog = find_child_widget_by_account(\n\t\tGTK_CONTAINER(priv->error_scrollbook), account);\n\tpidgin_mini_dialog_set_description(PIDGIN_MINI_DIALOG(mini_dialog),\n\t\tdescription);\n}\n", "bug_type": null, "idx": 5}
{"project": "Pidgin", "target": 0, "func": "static guint jabber_caps_hash(gconstpointer data) {\n\tconst JabberCapsTuple *key = data;\n\tguint nodehash = g_str_hash(key->node);\n\tguint verhash  = g_str_hash(key->ver);\n\t\n\tguint hashhash = (key->hash ? g_str_hash(key->hash) : 0);\n\treturn nodehash ^ verhash ^ hashhash;\n}\n", "bug_type": null, "idx": 6}
{"project": "Pidgin", "target": 0, "func": "static char *\nnm_rtfize_text(char *text)\n{\n\tGString *gstr = NULL;\n\tunsigned char *pch;\n\tchar *uni_str = NULL, *rtf = NULL;\n\tint bytes;\n\tgunichar uc;\n\tgstr = g_string_sized_new(strlen(text)*2);\n\tpch = (unsigned char *)text;\n\twhile (*pch) {\n\t\tif ((*pch) <= 0x7F) {\n\t\t\tswitch (*pch) {\n\t\t\t\tcase '{':\n\t\t\t\tcase '}':\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tgstr = g_string_append_c(gstr, '\\\\');\n\t\t\t\t\tgstr = g_string_append_c(gstr, *pch);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\t\tgstr = g_string_append(gstr, \"\\\\par \");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgstr = g_string_append_c(gstr, *pch);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpch++;\n\t\t} else {\n\t\t\t\n\t\t\tif(*pch <= 0xDF) {\n\t\t\t\tuc = ((((gunichar)pch[0]) & 0x001F) << 6) |\n\t\t\t\t\t(((gunichar)pch[1]) & 0x003F);\n\t\t\t\tbytes = 2;\n\t\t\t} else if(*pch <= 0xEF) {\n\t\t\t\tuc = ((((gunichar)pch[0]) & 0x000F) << 12) |\n\t\t\t\t\t((((gunichar)pch[1]) & 0x003F) << 6) |\n\t\t\t\t\t(((gunichar)pch[2]) & 0x003F);\n\t\t\t\tbytes = 3;\n\t\t\t} else if (*pch <= 0xF7) {\n\t\t\t\tuc = ((((gunichar)pch[0]) & 0x0007) << 18) |\n\t\t\t\t\t((((gunichar)pch[1]) & 0x003F) << 12) |\n\t\t\t\t\t((((gunichar)pch[2]) & 0x003F) << 6) |\n\t\t\t\t\t(((gunichar)pch[3]) & 0x003F);\n\t\t\t\tbytes = 4;\n\t\t\t} else if (*pch <= 0xFB) {\n\t\t\t\tuc = ((((gunichar)pch[0]) & 0x0003) << 24) |\n\t\t\t\t\t((((gunichar)pch[1]) & 0x003F) << 18) |\n\t\t\t\t\t((((gunichar)pch[2]) & 0x003F) << 12) |\n\t\t\t\t\t((((gunichar)pch[3]) & 0x003F) << 6) |\n\t\t\t\t\t(((gunichar)pch[4]) & 0x003F);\n\t\t\t\tbytes = 5;\n\t\t\t} else if (*pch <= 0xFD) {\n\t\t\t\tuc = ((((gunichar)pch[0]) & 0x0001) << 30) |\n\t\t\t\t\t((((gunichar)pch[1]) & 0x003F) << 24) |\n\t\t\t\t\t((((gunichar)pch[2]) & 0x003F) << 18) |\n\t\t\t\t\t((((gunichar)pch[3]) & 0x003F) << 12) |\n\t\t\t\t\t((((gunichar)pch[4]) & 0x003F) << 6) |\n\t\t\t\t\t(((gunichar)pch[5]) & 0x003F);\n\t\t\t\tbytes = 6;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tpurple_debug_info(\"novell\", \"bogus utf-8 lead byte: 0x%X\\n\", pch[0]);\n\t\t\t\tuc = 0x003F;\n\t\t\t\tbytes = 1;\n\t\t\t}\n\t\t\tuni_str = g_strdup_printf(\"\\\\u%d?\", uc);\n\t\t\tpurple_debug_info(\"novell\", \"unicode escaped char %s\\n\", uni_str);\n\t\t\tgstr = g_string_append(gstr, uni_str);\n\t\t\tpch += bytes;\n\t\t\tg_free(uni_str);\n\t\t}\n\t}\n\trtf = g_strdup_printf(RTF_TEMPLATE, gstr->str);\n\tg_string_free(gstr, TRUE);\n\treturn rtf;\n}\n", "bug_type": null, "idx": 7}
{"project": "Pidgin", "target": 0, "func": "static PurpleSavedStatusSub *\nparse_substatus(xmlnode *substatus)\n{\n\tPurpleSavedStatusSub *ret;\n\txmlnode *node;\n\tchar *data;\n\tret = g_new0(PurpleSavedStatusSub, 1);\n\t\n\tnode = xmlnode_get_child(substatus, \"account\");\n\tif (node != NULL)\n\t{\n\t\tchar *acct_name;\n\t\tconst char *protocol;\n\t\tacct_name = xmlnode_get_data(node);\n\t\tprotocol = xmlnode_get_attrib(node, \"protocol\");\n\t\tprotocol = _purple_oscar_convert(acct_name, protocol); \n\t\tif ((acct_name != NULL) && (protocol != NULL))\n\t\t\tret->account = purple_accounts_find(acct_name, protocol);\n\t\tg_free(acct_name);\n\t}\n\tif (ret->account == NULL)\n\t{\n\t\tg_free(ret);\n\t\treturn NULL;\n\t}\n\t\n\tnode = xmlnode_get_child(substatus, \"state\");\n\tif ((node != NULL) && ((data = xmlnode_get_data(node)) != NULL))\n\t{\n\t\tret->type = purple_status_type_find_with_id(\n\t\t\t\t\t\t\tret->account->status_types, data);\n\t\tg_free(data);\n\t}\n\tif (ret->type == NULL)\n\t{\n\t\tg_free(ret);\n\t\treturn NULL;\n\t}\n\t\n\tnode = xmlnode_get_child(substatus, \"message\");\n\tif ((node != NULL) && ((data = xmlnode_get_data(node)) != NULL))\n\t{\n\t\tret->message = data;\n\t}\n\tPURPLE_DBUS_REGISTER_POINTER(ret, PurpleSavedStatusSub);\n\treturn ret;\n}\n", "bug_type": null, "idx": 8}
{"project": "Pidgin", "target": 0, "func": "static inline uint32_t\nparse_int32(unsigned len, const uint8_t *data)\n{\n\treturn parse_uint32(len, data);\n}\n", "bug_type": null, "idx": 9}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npurple_media_backend_fs2_set_send_codec(PurpleMediaBackend *self,\n\t\tconst gchar *sess_id, PurpleMediaCodec *codec)\n{\n\tPurpleMediaBackendFs2Session *session;\n\tFsCodec *fscodec;\n\tGError *err = NULL;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_BACKEND_FS2(self), FALSE);\n\tsession = get_session(PURPLE_MEDIA_BACKEND_FS2(self), sess_id);\n\tif (session == NULL)\n\t\treturn FALSE;\n\tfscodec = codec_to_fs(codec);\n\tfs_session_set_send_codec(session->session, fscodec, &err);\n\tfs_codec_destroy(fscodec);\n\tif (err) {\n\t\tpurple_debug_error(\"media\", \"Error setting send codec\\n\");\n\t\tg_error_free(err);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 10}
{"project": "Pidgin", "target": 0, "func": "GtkWidget *\npidgin_prefs_labeled_spin_button(GtkWidget *box, const gchar *title,\n\t\tconst char *key, int min, int max, GtkSizeGroup *sg)\n{\n\tGtkWidget *spin;\n\tGtkObject *adjust;\n\tint val;\n\tval = purple_prefs_get_int(key);\n\tadjust = gtk_adjustment_new(val, min, max, 1, 1, 0);\n\tspin = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 1, 0);\n\tg_object_set_data(G_OBJECT(spin), \"val\", (char *)key);\n\tif (max < 10000)\n\t\tgtk_widget_set_size_request(spin, 50, -1);\n\telse\n\t\tgtk_widget_set_size_request(spin, 60, -1);\n\tg_signal_connect(G_OBJECT(adjust), \"value-changed\",\n\t\t\t\t\t G_CALLBACK(update_spin_value), GTK_WIDGET(spin));\n\tgtk_widget_show(spin);\n\treturn pidgin_add_widget_to_vbox(GTK_BOX(box), title, sg, spin, FALSE, NULL);\n}\n", "bug_type": null, "idx": 11}
{"project": "Pidgin", "target": 0, "func": "\tstatic void\nmd4_append(PurpleCipherContext *context, const guchar *data, size_t len)\n{\n\tstruct MD4_Context *mctx = purple_cipher_context_get_data(context);\n\tconst guint32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\n\tmctx->byte_count += len;\n\tif (avail > len) {\n\t\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t\t\t\tdata, len);\n\t\treturn;\n\t}\n\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t\t\tdata, avail);\n\tmd4_transform_helper(mctx);\n\tdata += avail;\n\tlen -= avail;\n\twhile (len >= sizeof(mctx->block)) {\n\t\tmemcpy(mctx->block, data, sizeof(mctx->block));\n\t\tmd4_transform_helper(mctx);\n\t\tdata += sizeof(mctx->block);\n\t\tlen -= sizeof(mctx->block);\n\t}\n\tmemcpy(mctx->block, data, len);\n}\n", "bug_type": null, "idx": 12}
{"project": "Pidgin", "target": 0, "func": "static void\nbrowser_changed1_cb(const char *name, PurplePrefType type,\n\t\t\t\t\tgconstpointer value, gpointer data)\n{\n\tGtkWidget *hbox = data;\n\tconst char *browser = value;\n\tgtk_widget_set_sensitive(hbox, strcmp(browser, \"custom\"));\n}\n", "bug_type": null, "idx": 13}
{"project": "Pidgin", "target": 0, "func": "gint\njabber_identity_compare(gconstpointer a, gconstpointer b)\n{\n\tconst JabberIdentity *ac;\n\tconst JabberIdentity *bc;\n\tgint cat_cmp;\n\tgint typ_cmp;\n\tac = a;\n\tbc = b;\n\tif ((cat_cmp = strcmp(ac->category, bc->category)) == 0) {\n\t\tif ((typ_cmp = strcmp(ac->type, bc->type)) == 0) {\n\t\t\tif (!ac->lang && !bc->lang) {\n\t\t\t\treturn 0;\n\t\t\t} else if (ac->lang && !bc->lang) {\n\t\t\t\treturn 1;\n\t\t\t} else if (!ac->lang && bc->lang) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn strcmp(ac->lang, bc->lang);\n\t\t\t}\n\t\t} else {\n\t\t\treturn typ_cmp;\n\t\t}\n\t} else {\n\t\treturn cat_cmp;\n\t}\n}\n", "bug_type": null, "idx": 14}
{"project": "Pidgin", "target": 0, "func": "static void\npeer_connection_got_proposition_yes_cb(gpointer data, gint id)\n{\n\tPeerConnection *conn;\n\tconn = data;\n\tconn->flags |= PEER_CONNECTION_FLAG_APPROVED;\n\tpeer_connection_trynext(conn);\n}\n", "bug_type": null, "idx": 15}
{"project": "Pidgin", "target": 0, "func": "static void message_clicked_cb(GtkWidget *w, gpointer nul)\n{\n\tGtkWidget *vbox;\n\tGtkWidget *hbox;\n\tGtkWidget *to_entry;\n\tGtkWidget *body_entry;\n\tGtkWidget *thread_entry;\n\tGtkWidget *subject_entry;\n\tGtkWidget *label;\n\tGtkWidget *type_combo;\n\tGtkSizeGroup *sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);\n\tGtkTextIter iter;\n\tGtkTextBuffer *buffer;\n\tconst char *to, *body, *thread, *subject;\n\tchar *stanza;\n\tint result;\n\tGtkWidget *dialog = gtk_dialog_new_with_buttons(\"<message/>\",\n\t\t\t\t\t\t\tGTK_WINDOW(console->window),\n\t\t\t\t\t\t\tGTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\t\t\tGTK_STOCK_CANCEL,\n\t\t\t\t\t\t\tGTK_RESPONSE_REJECT,\n\t\t\t\t\t\t\tGTK_STOCK_OK,\n\t\t\t\t\t\t\tGTK_RESPONSE_ACCEPT,\n\t\t\t\t\t\t\tNULL);\n\tgtk_dialog_set_has_separator(GTK_DIALOG(dialog), FALSE);\n\tgtk_dialog_set_default_response (GTK_DIALOG(dialog), GTK_RESPONSE_ACCEPT);\n\tgtk_container_set_border_width(GTK_CONTAINER(dialog), 12);\n#if GTK_CHECK_VERSION(2,14,0)\n\tvbox = gtk_dialog_get_content_area(GTK_DIALOG(dialog));\n#else\n\tvbox = GTK_DIALOG(dialog)->vbox;\n#endif\n\thbox = gtk_hbox_new(FALSE, 3);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlabel = gtk_label_new(\"To:\");\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);\n\tgtk_size_group_add_widget(sg, label);\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\tto_entry = gtk_entry_new();\n\tgtk_entry_set_activates_default (GTK_ENTRY (to_entry), TRUE);\n\tgtk_box_pack_start(GTK_BOX(hbox), to_entry, FALSE, FALSE, 0);\n\thbox = gtk_hbox_new(FALSE, 3);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlabel = gtk_label_new(\"Type:\");\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);\n\tgtk_size_group_add_widget(sg, label);\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\ttype_combo = gtk_combo_box_new_text();\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"chat\");\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"headline\");\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"groupchat\");\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"normal\");\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"error\");\n\tgtk_combo_box_set_active(GTK_COMBO_BOX(type_combo), 0);\n\tgtk_box_pack_start(GTK_BOX(hbox), type_combo, FALSE, FALSE, 0);\n\thbox = gtk_hbox_new(FALSE, 3);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlabel = gtk_label_new(\"Body:\");\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);\n\tgtk_size_group_add_widget(sg, label);\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\tbody_entry = gtk_entry_new();\n\tgtk_entry_set_activates_default (GTK_ENTRY (body_entry), TRUE);\n\tgtk_box_pack_start(GTK_BOX(hbox), body_entry, FALSE, FALSE, 0);\n\thbox = gtk_hbox_new(FALSE, 3);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlabel = gtk_label_new(\"Subject:\");\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);\n\tgtk_size_group_add_widget(sg, label);\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\tsubject_entry = gtk_entry_new();\n\tgtk_entry_set_activates_default (GTK_ENTRY (subject_entry), TRUE);\n\tgtk_box_pack_start(GTK_BOX(hbox), subject_entry, FALSE, FALSE, 0);\n\thbox = gtk_hbox_new(FALSE, 3);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlabel = gtk_label_new(\"Thread:\");\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);\n\tgtk_size_group_add_widget(sg, label);\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\tthread_entry = gtk_entry_new();\n\tgtk_entry_set_activates_default (GTK_ENTRY (thread_entry), TRUE);\n\tgtk_box_pack_start(GTK_BOX(hbox), thread_entry, FALSE, FALSE, 0);\n\tgtk_widget_show_all(vbox);\n\tresult = gtk_dialog_run(GTK_DIALOG(dialog));\n\tif (result != GTK_RESPONSE_ACCEPT) {\n\t\tgtk_widget_destroy(dialog);\n\t\treturn;\n\t}\n\tto = gtk_entry_get_text(GTK_ENTRY(to_entry));\n\tbody = gtk_entry_get_text(GTK_ENTRY(body_entry));\n\tthread = gtk_entry_get_text(GTK_ENTRY(thread_entry));\n\tsubject = gtk_entry_get_text(GTK_ENTRY(subject_entry));\n\tstanza = g_strdup_printf(\"<message %s%s%s id='console%x' type='%s'>\"\n\t                         \"%s%s%s%s%s%s%s%s%s\"\n\t                         \"</message>\",\n\t                         *to ? \"to='\" : \"\",\n\t                         *to ? to : \"\",\n\t                         *to ? \"'\" : \"\",\n\t                         g_random_int(),\n\t                         gtk_combo_box_get_active_text(GTK_COMBO_BOX(type_combo)),\n\t                         *body ? \"<body>\" : \"\",\n\t                         *body ? body : \"\",\n\t                         *body ? \"</body>\" : \"\",\n\t                         *subject ? \"<subject>\" : \"\",\n\t                         *subject ? subject : \"\",\n\t                         *subject ? \"</subject>\" : \"\",\n\t                         *thread ? \"<thread>\" : \"\",\n\t                         *thread ? thread : \"\",\n\t                         *thread ? \"</thread>\" : \"\");\n\tbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(console->entry));\n\tgtk_text_buffer_set_text(buffer, stanza, -1);\n\tgtk_text_buffer_get_iter_at_offset(buffer, &iter, strstr(stanza, \"</message>\") - stanza);\n\tgtk_text_buffer_place_cursor(buffer, &iter);\n\tg_free(stanza);\n\tgtk_widget_destroy(dialog);\n\tg_object_unref(sg);\n}\n", "bug_type": null, "idx": 16}
{"project": "Pidgin", "target": 0, "func": "void gnt_wm_move_window(GntWM *wm, GntWidget *widget, int x, int y)\n{\n\tgboolean ret = TRUE;\n\tGntNode *node;\n\twhile (widget->parent)\n\t\twidget = widget->parent;\n\tnode = g_hash_table_lookup(wm->nodes, widget);\n\tif (!node)\n\t\treturn;\n\tg_signal_emit(wm, signals[SIG_CONFIRM_MOVE], 0, widget, &x, &y, &ret);\n\tif (!ret)\n\t\treturn;    \n\tgnt_widget_set_position(widget, x, y);\n\tmove_panel(node->panel, y, x);\n\tg_signal_emit(wm, signals[SIG_MOVED], 0, node);\n\tif (gnt_style_get_bool(GNT_STYLE_REMPOS, TRUE) && GNT_IS_BOX(widget) &&\n\t\t!GNT_WIDGET_IS_FLAG_SET(widget, GNT_WIDGET_TRANSIENT)) {\n\t\tconst char *title = GNT_BOX(widget)->title;\n\t\tif (title) {\n\t\t\tGntPosition *p = g_new0(GntPosition, 1);\n\t\t\tGntWidget *wid = node->me;\n\t\t\tp->x = wid->priv.x;\n\t\t\tp->y = wid->priv.y;\n\t\t\tg_hash_table_replace(wm->positions, g_strdup(title), p);\n\t\t\twrite_positions_to_file(wm);\n\t\t}\n\t}\n\tupdate_screen(wm);\n}\n", "bug_type": null, "idx": 17}
{"project": "Pidgin", "target": 0, "func": "static int nullprpl_send_im(PurpleConnection *gc, const char *who,\n                            const char *message, PurpleMessageFlags flags)\n{\n  const char *from_username = gc->account->username;\n  PurpleMessageFlags receive_flags = ((flags & ~PURPLE_MESSAGE_SEND)\n                                      | PURPLE_MESSAGE_RECV);\n  PurpleAccount *to_acct = purple_accounts_find(who, NULLPRPL_ID);\n  PurpleConnection *to;\n  purple_debug_info(\"nullprpl\", \"sending message from %s to %s: %s\\n\",\n                    from_username, who, message);\n  \n  if (to_acct && !purple_privacy_check(to_acct, gc->account->username)) {\n    char *msg = g_strdup_printf(\n      _(\"Your message was blocked by %s's privacy settings.\"), who);\n    purple_debug_info(\"nullprpl\",\n                      \"discarding; %s is blocked by %s's privacy settings\\n\",\n                      from_username, who);\n    purple_conv_present_error(who, gc->account, msg);\n    g_free(msg);\n    return 0;\n  }\n  \n  to = get_nullprpl_gc(who);\n  if (to) {  \n    serv_got_im(to, from_username, message, receive_flags, time(NULL));\n  } else {  \n    GOfflineMessage *offline_message;\n    GList *messages;\n    purple_debug_info(\"nullprpl\",\n                      \"%s is offline, sending as offline message\\n\", who);\n    offline_message = g_new0(GOfflineMessage, 1);\n    offline_message->from = g_strdup(from_username);\n    offline_message->message = g_strdup(message);\n    offline_message->mtime = time(NULL);\n    offline_message->flags = receive_flags;\n    messages = g_hash_table_lookup(goffline_messages, who);\n    messages = g_list_append(messages, offline_message);\n    g_hash_table_insert(goffline_messages, g_strdup(who), messages);\n  }\n   return 1;\n}\n", "bug_type": null, "idx": 18}
{"project": "Pidgin", "target": 0, "func": "static GIOStatus\ng_io_win32_sock_close (GIOChannel *channel,\n\t\t       GError    **err)\n{\n  GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;\n  LOCK (win32_channel->mutex);\n  if (win32_channel->running)\n    {\n      if (win32_channel->debug)\n\tg_print (\"thread %#x: running, marking for later close\\n\",\n\t\t win32_channel->thread_id);\n      win32_channel->running = FALSE;\n      win32_channel->needs_close = TRUE;\n      SetEvent(win32_channel->data_avail_noticed_event);\n    }\n  if (win32_channel->fd != -1)\n    {\n      if (win32_channel->debug)\n\tg_print (\"thread %#x: closing socket %d\\n\",\n\t\t win32_channel->thread_id,\n\t\t win32_channel->fd);\n      closesocket (win32_channel->fd);\n      win32_channel->fd = -1;\n    }\n  UNLOCK (win32_channel->mutex);\n  \n  return G_IO_STATUS_NORMAL;\n}\n", "bug_type": null, "idx": 19}
{"project": "Pidgin", "target": 0, "func": "\nstatic int wpurple_is_socket( int fd ) {\n\tint optval;\n\tint optlen = sizeof(int);\n\tif( (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void*)&optval, &optlen)) == SOCKET_ERROR ) {\n\t\tint error = WSAGetLastError();\n\t\tif( error == WSAENOTSOCK )\n\t\t\treturn FALSE;\n\t\telse {\n                        purple_debug(PURPLE_DEBUG_WARNING, \"wpurple\", \"wpurple_is_socket: getsockopt returned error: %d\\n\", error);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 20}
{"project": "Pidgin", "target": 0, "func": "static void\naccount_removed_callback(PurpleAccount *account)\n{\n\tif (accounts.window == NULL)\n\t\treturn;\n\tgnt_tree_remove(GNT_TREE(accounts.tree), account);\n}\n", "bug_type": null, "idx": 21}
{"project": "Pidgin", "target": 0, "func": "static void\nclose_link_dialog(GtkIMHtmlToolbar *toolbar)\n{\n\tif (toolbar->link_dialog != NULL)\n\t{\n\t\tpurple_request_close(PURPLE_REQUEST_FIELDS, toolbar->link_dialog);\n\t\ttoolbar->link_dialog = NULL;\n\t}\n}\n", "bug_type": null, "idx": 22}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_debug_window_show(void)\n{\n\tif (debug_win == NULL)\n\t\tdebug_win = debug_window_new();\n\tgtk_widget_show(debug_win->window);\n\tpurple_prefs_set_bool(PIDGIN_PREFS_ROOT \"/debug/enabled\", TRUE);\n}\n", "bug_type": null, "idx": 23}
{"project": "Pidgin", "target": 0, "func": "static void\nsha256_append(PurpleCipherContext *context, const guchar *data, size_t len) {\n\tstruct SHA256Context *sha256_ctx;\n\tgint i;\n\tsha256_ctx = purple_cipher_context_get_data(context);\n\tg_return_if_fail(sha256_ctx);\n\tfor(i = 0; i < len; i++) {\n\t\tsha256_ctx->W[sha256_ctx->lenW / 4] <<= 8;\n\t\tsha256_ctx->W[sha256_ctx->lenW / 4] |= data[i];\n\t\tif((++sha256_ctx->lenW) % 64 == 0) {\n\t\t\tsha256_hash_block(sha256_ctx);\n\t\t\tsha256_ctx->lenW = 0;\n\t\t}\n\t\tsha256_ctx->sizeLo += 8;\n\t\tsha256_ctx->sizeHi += (sha256_ctx->sizeLo < 8);\n\t}\n}\n", "bug_type": null, "idx": 24}
{"project": "Pidgin", "target": 0, "func": "static SECStatus\nssl_auth_cert(void *arg, PRFileDesc *socket, PRBool checksig, PRBool is_server)\n{\n\t\n\treturn SECSuccess;\n}\n", "bug_type": null, "idx": 25}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_session_handle_dcc7_id_reply(struct gg_session *gs, uint32_t type,\n\tconst char *ptr, size_t len, struct gg_event *ge)\n{\n\tgg_debug_session(gs, GG_DEBUG_MISC, \"// gg_watch_fd_connected() received dcc7 id packet\\n\");\n\treturn gg_dcc7_handle_id(gs, ge, ptr, len);\n}\n", "bug_type": null, "idx": 26}
{"project": "Pidgin", "target": 0, "func": " */\nstatic struct gg_dcc7 *gg_dcc7_send_file_common(struct gg_session *sess,\n\tuin_t rcpt, int fd, size_t size, const char *filename1250,\n\tconst char *hash, int seek)\n{\n\tstruct gg_dcc7 *dcc = NULL;\n\tif (!sess || !rcpt || !filename1250 || !hash || fd == -1) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_dcc7_send_file_common() invalid parameters\\n\");\n\t\terrno = EINVAL;\n\t\tgoto fail;\n\t}\n\tif (!(dcc = malloc(sizeof(struct gg_dcc7)))) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_dcc7_send_file_common() not enough memory\\n\");\n\t\tgoto fail;\n\t}\n\tif (gg_dcc7_request_id(sess, GG_DCC7_TYPE_FILE) == -1)\n\t\tgoto fail;\n\tmemset(dcc, 0, sizeof(struct gg_dcc7));\n\tdcc->type = GG_SESSION_DCC7_SEND;\n\tdcc->dcc_type = GG_DCC7_TYPE_FILE;\n\tdcc->state = GG_STATE_REQUESTING_ID;\n\tdcc->timeout = GG_DEFAULT_TIMEOUT;\n\tdcc->sess = sess;\n\tdcc->fd = -1;\n\tdcc->uin = sess->uin;\n\tdcc->peer_uin = rcpt;\n\tdcc->file_fd = fd;\n\tdcc->size = size;\n\tdcc->seek = seek;\n\tstrncpy((char*) dcc->filename, filename1250, GG_DCC7_FILENAME_LEN);\n\tdcc->filename[GG_DCC7_FILENAME_LEN] = 0;\n\tmemcpy(dcc->hash, hash, GG_DCC7_HASH_LEN);\n\tif (gg_dcc7_session_add(sess, dcc) == -1)\n\t\tgoto fail;\n\treturn dcc;\nfail:\n\tfree(dcc);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 27}
{"project": "Pidgin", "target": 0, "func": "static void\nstatus_editor_destroy_cb(GtkWidget *widget, gpointer user_data)\n{\n\tStatusEditor *dialog = user_data;\n\tstatus_editor_remove_dialog(dialog);\n\tg_free(dialog->original_title);\n\tg_object_unref(G_OBJECT(dialog->model));\n\tg_free(dialog);\n}\nstatic void\nsubstatus_editor_destroy_cb(GtkWidget *widget, gpointer user_data)\n{\n\tSubStatusEditor *dialog = user_data;\n\tsubstatus_editor_remove_dialog(dialog);\n\tg_free(dialog);\n}\n", "bug_type": null, "idx": 28}
{"project": "Pidgin", "target": 0, "func": "static inline uint64_t\nzigzag64(int64_t v)\n{\n\tif (v < 0)\n\t\treturn ((uint64_t) (-v)) * 2 - 1;\n\telse\n\t\treturn v * 2;\n}\n", "bug_type": null, "idx": 29}
{"project": "Pidgin", "target": 0, "func": "static void cap_prefs_ui_destroy_cb(GtkObject *object, gpointer user_data) {\n\tCapPrefsUI *ui = user_data;\n\tif(_db) {\n\t\tadd_plugin_functionality(_plugin_pointer);\n\t}\n\tg_free(ui);\n}\n", "bug_type": null, "idx": 30}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_account_set_show_all(PurpleRequestField *field,\n\t\t\t\t\t\t\t\t\t\tgboolean show_all)\n{\n\tg_return_if_fail(field != NULL);\n\tg_return_if_fail(field->type == PURPLE_REQUEST_FIELD_ACCOUNT);\n\tif (field->u.account.show_all == show_all)\n\t\treturn;\n\tfield->u.account.show_all = show_all;\n\tif (!show_all)\n\t{\n\t\tif (purple_account_is_connected(field->u.account.default_account))\n\t\t{\n\t\t\tpurple_request_field_account_set_default_value(field,\n\t\t\t\t(PurpleAccount *)purple_connections_get_all()->data);\n\t\t}\n\t\tif (purple_account_is_connected(field->u.account.account))\n\t\t{\n\t\t\tpurple_request_field_account_set_value(field,\n\t\t\t\t(PurpleAccount *)purple_connections_get_all()->data);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 31}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conv_im_set_typing_state(PurpleConvIm *im, PurpleTypingState state)\n{\n\tg_return_if_fail(im != NULL);\n\tif (im->typing_state != state)\n\t{\n\t\tim->typing_state = state;\n\t\tswitch (state)\n\t\t{\n\t\t\tcase PURPLE_TYPING:\n\t\t\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\t\t\t\t\t   \"buddy-typing\", im->conv->account, im->conv->name);\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_TYPED:\n\t\t\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\t\t\t\t\t   \"buddy-typed\", im->conv->account, im->conv->name);\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_NOT_TYPING:\n\t\t\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\t\t\t\t\t   \"buddy-typing-stopped\", im->conv->account, im->conv->name);\n\t\t\t\tbreak;\n\t\t}\n\t\tpurple_conv_im_update_typing(im);\n\t}\n}\n", "bug_type": null, "idx": 32}
{"project": "Pidgin", "target": 0, "func": "static const char *\nget_encoding_from_locale (const char *locale)\n{\n\tchar lang[3];\n\tconst char *encoding;\n\tstatic GHashTable *encodings = NULL;\n\tif (locale == NULL)\n\t\treturn NULL;\n\t\n\tencoding = strchr (locale, '.');\n\tif (encoding != NULL) {\n\t\treturn encoding+1;\n\t}\n\tif (encodings == NULL)\n\t\tencodings = init_encodings ();\n\t\n\tencoding = g_hash_table_lookup (encodings, locale);\n\tif (encoding != NULL)\n\t\treturn encoding;\n\t\n\tstrncpy (lang, locale, 2);\n\tlang[2] = '\\0';\n\treturn g_hash_table_lookup (encodings, lang);\n}\n", "bug_type": null, "idx": 33}
{"project": "Pidgin", "target": 0, "func": "static gint\nrc4_encrypt(PurpleCipherContext *context, const guchar data[],\n            size_t len, guchar output[], size_t *outlen) {\n\tstruct RC4Context *ctx;\n\tguchar temp_swap;\n\tguchar x, y, z;\n\tguchar *state;\n\tguint i;\n\tctx = purple_cipher_context_get_data(context);\n\tx = ctx->x;\n\ty = ctx->y;\n\tstate = &ctx->state[0];\n\tfor(i = 0; i < len; i++)\n\t{\n\t\tx = (x + 1) % 256;\n\t\ty = (state[x] + y) % 256;\n\t\ttemp_swap = state[x];\n\t\tstate[x] = state[y];\n\t\tstate[y] = temp_swap;\n\t\tz = state[x] + (state[y]) % 256;\n\t\toutput[i] = data[i] ^ state[z];\n\t}\n\tctx->x = x;\n\tctx->y = y;\n\tif(outlen)\n\t\t*outlen = len;\n\treturn 0;\n}\n", "bug_type": null, "idx": 34}
{"project": "Pidgin", "target": 0, "func": "void\npurple_plugins_register_load_notify_cb(void (*func)(PurplePlugin *, void *),\n\t\t\t\t\t\t\t\t\t void *data)\n{\n\tload_cb = func;\n\tload_cb_data = data;\n}\n", "bug_type": null, "idx": 35}
{"project": "Pidgin", "target": 0, "func": "static void\nedit_savedstatus_cb(GntWidget *widget, gpointer null)\n{\n\tg_return_if_fail(statuses.tree != NULL);\n\tfinch_savedstatus_edit(gnt_tree_get_selection_data(GNT_TREE(statuses.tree)));\n}\n", "bug_type": null, "idx": 36}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_account_get_user_info(const PurpleAccount *account)\n{\n\tg_return_val_if_fail(account != NULL, NULL);\n\treturn account->user_info;\n}\n", "bug_type": null, "idx": 37}
{"project": "Pidgin", "target": 0, "func": "size_t gg110_pong__get_packed_size\n                     (const GG110Pong *message)\n{\n  assert(message->base.descriptor == &gg110_pong__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\n", "bug_type": null, "idx": 38}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_savedstatus_delete(const char *title)\n{\n\tPurpleSavedStatus *status;\n\tstatus = purple_savedstatus_find(title);\n\tif (status == NULL)\n\t\treturn FALSE;\n\tif (purple_savedstatus_get_current() == status)\n\t\treturn FALSE;\n\tpurple_savedstatus_delete_by_status(status);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 39}
{"project": "Pidgin", "target": 0, "func": "static char *\nget_path_basename(const char *name)\n{\n\tconst char *c;\n\tif ((c = strrchr(name, '/')) != NULL)\n\t\treturn g_strdup(c + 1);\n\treturn g_strdup(name);\n}\n", "bug_type": null, "idx": 40}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ntext_view_contains(GntTextView *view, const char *str)\n{\n\treturn (str >= view->string->str && str < view->string->str + view->string->len);\n}\n", "bug_type": null, "idx": 41}
{"project": "Pidgin", "target": 0, "func": "const gchar* jabber_caps_get_own_hash(JabberStream *js)\n{\n\tif (!js->caps_hash)\n\t\tjabber_caps_calculate_own_hash(js);\n\treturn js->caps_hash;\n}\n", "bug_type": null, "idx": 42}
{"project": "Pidgin", "target": 0, "func": "\nstatic void pidgin_whiteboard_draw_brush_line(PurpleWhiteboard *wb, int x0, int y0, int x1, int y1, int color, int size)\n{\n\tint temp;\n\tint xstep;\n\tint ystep;\n\tint dx;\n\tint dy;\n\tint error;\n\tint derror;\n\tint x;\n\tint y;\n\tgboolean steep = abs(y1 - y0) > abs(x1 - x0);\n\tif(steep)\n\t{\n\t\ttemp = x0; x0 = y0; y0 = temp;\n\t\ttemp = x1; x1 = y1; y1 = temp;\n\t}\n\tdx = abs(x1 - x0);\n\tdy = abs(y1 - y0);\n\terror = 0;\n\tderror = dy;\n\tx = x0;\n\ty = y0;\n\tif(x0 < x1)\n\t\txstep = 1;\n\telse\n\t\txstep = -1;\n\tif(y0 < y1)\n\t\tystep = 1;\n\telse\n\t\tystep = -1;\n\tif(steep)\n\t\tpidgin_whiteboard_draw_brush_point(wb, y, x, color, size);\n\telse\n\t\tpidgin_whiteboard_draw_brush_point(wb, x, y, color, size);\n\twhile(x != x1)\n\t{\n\t\tx += xstep;\n\t\terror += derror;\n\t\tif((error * 2) >= dx)\n\t\t{\n\t\t\ty += ystep;\n\t\t\terror -= dx;\n\t\t}\n\t\tif(steep)\n\t\t\tpidgin_whiteboard_draw_brush_point(wb, y, x, color, size);\n\t\telse\n\t\t\tpidgin_whiteboard_draw_brush_point(wb, x, y, color, size);\n\t}\n}\n", "bug_type": null, "idx": 43}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\npidgin_media_add_dtmf_widget(PidginMedia *gtkmedia,\n\t\tPurpleMediaSessionType type, const gchar *_sid)\n{\n\tGtkWidget *grid = gtk_table_new(4, 3, TRUE);\n\tGtkWidget *button;\n\tgint index = 0;\n\tGtkWindow *win = &gtkmedia->parent;\n\t\n\tfor (index = 0; phone_labels[index].subtext != NULL; index++) {\n\t\tbutton = phone_create_button(phone_labels[index].text,\n\t\t\t\tphone_labels[index].subtext);\n\t\tg_signal_connect(button, \"pressed\",\n\t\t\t\tG_CALLBACK(phone_dtmf_pressed_cb), gtkmedia);\n\t\tg_object_set_data(G_OBJECT(button), \"dtmf-digit\",\n\t\t\t\tGINT_TO_POINTER(phone_labels[index].chr));\n\t\tg_object_set_data_full(G_OBJECT(button), \"session-id\",\n\t\t\t\tg_strdup(_sid), g_free);\n\t\tgtk_table_attach(GTK_TABLE(grid), button, index % 3,\n\t\t\t\tindex % 3 + 1, index / 3, index / 3 + 1,\n\t\t\t\tGTK_FILL | GTK_EXPAND, GTK_FILL | GTK_EXPAND,\n\t\t\t\t2, 2);\n\t}\n\tg_signal_connect(G_OBJECT(win), \"key-press-event\",\n\t\tG_CALLBACK(pidgin_media_dtmf_key_press_event_cb), gtkmedia);\n\tg_object_set_data_full(G_OBJECT(win), \"session-id\",\n\t\tg_strdup(_sid), g_free);\n\tgtk_widget_show_all(grid);\n\treturn grid;\n}\n", "bug_type": null, "idx": 44}
{"project": "Pidgin", "target": 0, "func": "static int\nhostversions(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tint vercount;\n\tguint8 *versions;\n\t\n\tvercount = byte_stream_bytes_left(bs)/4;\n\t\n\t(void)vercount;\n\tversions = byte_stream_getraw(bs, byte_stream_bytes_left(bs));\n\tg_free(versions);\n\t\n\taim_srv_reqrates(od, conn);\n\treturn 1;\n}\n", "bug_type": null, "idx": 45}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nis_word_lowercase(const gchar *word)\n{\n\tfor (; word[0] != '\\0'; word = g_utf8_find_next_char(word, NULL)) {\n\t\tgunichar c = g_utf8_get_char(word);\n\t\tif (!(g_unichar_islower(c) ||\n\t\t      g_unichar_ispunct(c) ||\n\t\t      g_unichar_isspace(c)))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 46}
{"project": "Pidgin", "target": 0, "func": "\n\nchar *ggp_buddy_get_name(PurpleConnection *gc, const uin_t uin)\n{\n\tPurpleBuddy *buddy;\n\tgchar *str_uin;\n\tstr_uin = g_strdup_printf(\"%lu\", (unsigned long int)uin);\n\tbuddy = purple_find_buddy(purple_connection_get_account(gc), str_uin);\n\tif (buddy != NULL) {\n\t\tg_free(str_uin);\n\t\treturn g_strdup(purple_buddy_get_alias(buddy));\n\t} else {\n\t\treturn str_uin;\n\t}\n}\n\n\n\nchar *ggp_buddy_get_name(PurpleConnection *gc, const uin_t uin)\n{\n\tPurpleBuddy *buddy;\n\tgchar *str_uin;\n\tstr_uin = g_strdup_printf(\"%lu\", (unsigned long int)uin);\n\tbuddy = purple_find_buddy(purple_connection_get_account(gc), str_uin);\n\tif (buddy != NULL) {\n\t\tg_free(str_uin);\n\t\treturn g_strdup(purple_buddy_get_alias(buddy));\n\t} else {\n\t\treturn str_uin;\n\t}\n}\n\n\nchar *ggp_buddy_get_name(PurpleConnection *gc, const uin_t uin)\n{\n\tPurpleBuddy *buddy;\n\tgchar *str_uin;\n\tstr_uin = g_strdup_printf(\"%lu\", (unsigned long int)uin);\n\tbuddy = purple_find_buddy(purple_connection_get_account(gc), str_uin);\n\tif (buddy != NULL) {\n\t\tg_free(str_uin);\n\t\treturn g_strdup(purple_buddy_get_alias(buddy));\n\t} else {\n\t\treturn str_uin;\n\t}\n}\n", "bug_type": null, "idx": 47}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\tvoid *conv_handle = purple_conversations_get_handle();\n\tvoid *gtkconv_handle = pidgin_conversations_get_handle();\n\t\n\tpurple_signal_connect_priority(conv_handle, \"conversation-created\",\n\t\tplugin, PURPLE_CALLBACK(timestamp_new_convo), NULL,\n\t\tPURPLE_SIGNAL_PRIORITY_DEFAULT + 1);\n\tpurple_signal_connect(gtkconv_handle, \"displaying-chat-msg\",\n\t\tplugin, PURPLE_CALLBACK(timestamp_displaying_conv_msg), NULL);\n\tpurple_signal_connect(gtkconv_handle, \"displaying-im-msg\",\n\t\tplugin, PURPLE_CALLBACK(timestamp_displaying_conv_msg), NULL);\n\tinterval = purple_prefs_get_int(\"/plugins/gtk/timestamp/interval\") / 1000;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 48}
{"project": "Pidgin", "target": 0, "func": "char *jabber_status_text(PurpleBuddy *b)\n{\n\tchar *ret = NULL;\n\tJabberBuddy *jb = NULL;\n\tPurpleAccount *account = purple_buddy_get_account(b);\n\tPurpleConnection *gc = purple_account_get_connection(account);\n\tif (gc && gc->proto_data)\n\t\tjb = jabber_buddy_find(gc->proto_data, purple_buddy_get_name(b), FALSE);\n\tif(jb && !PURPLE_BUDDY_IS_ONLINE(b) && (jb->subscription & JABBER_SUB_PENDING || !(jb->subscription & JABBER_SUB_TO))) {\n\t\tret = g_strdup(_(\"Not Authorized\"));\n\t} else if(jb && !PURPLE_BUDDY_IS_ONLINE(b) && jb->error_msg) {\n\t\tret = g_strdup(jb->error_msg);\n\t} else {\n\t\tPurplePresence *presence = purple_buddy_get_presence(b);\n\t\tPurpleStatus *status = purple_presence_get_active_status(presence);\n\t\tconst char *message;\n\t\tif((message = purple_status_get_attr_string(status, \"message\"))) {\n\t\t\tret = g_markup_escape_text(message, -1);\n\t\t} else if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_TUNE)) {\n\t\t\tPurpleStatus *status = purple_presence_get_status(presence, \"tune\");\n\t\t\tconst char *title = purple_status_get_attr_string(status, PURPLE_TUNE_TITLE);\n\t\t\tconst char *artist = purple_status_get_attr_string(status, PURPLE_TUNE_ARTIST);\n\t\t\tconst char *album = purple_status_get_attr_string(status, PURPLE_TUNE_ALBUM);\n\t\t\tret = purple_util_format_song_info(title, artist, album, NULL);\n\t\t}\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 49}
{"project": "Pidgin", "target": 0, "func": "static inline uint32_t\nzigzag32(int32_t v)\n{\n\tif (v < 0)\n\t\treturn ((uint32_t) (-v)) * 2 - 1;\n\telse\n\t\treturn v * 2;\n}\n", "bug_type": null, "idx": 50}
{"project": "Pidgin", "target": 0, "func": "static gboolean tcl_file_callback(GIOChannel *source, GIOCondition condition, gpointer data)\n{\n\tstruct tcl_file_handler *tfh = data;\n\tstruct tcl_file_event *fev;\n\tint mask = 0;\n\tif (condition & G_IO_IN)\n\t\tmask |= TCL_READABLE;\n\tif (condition & G_IO_OUT)\n\t\tmask |= TCL_WRITABLE;\n\tif (condition & (G_IO_ERR|G_IO_HUP|G_IO_NVAL))\n\t\tmask |= TCL_EXCEPTION;\n\tif (!(tfh->mask & (mask & ~tfh->pending)))\n\t\treturn TRUE;\n\ttfh->pending |= mask;\n\tfev = (struct tcl_file_event *)ckalloc(sizeof(struct tcl_file_event));\n\tmemset(fev, 0, sizeof(struct tcl_file_event));\n\tfev->header.proc = tcl_file_event_callback;\n\tfev->fd = tfh->fd;\n\tTcl_QueueEvent((Tcl_Event *)fev, TCL_QUEUE_TAIL);\n\tTcl_ServiceAll();\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 51}
{"project": "Pidgin", "target": 0, "func": "static void\nrecv_cb(gpointer data, gint source, PurpleInputCondition cond)\n{\n\tPurpleSslConnection *gsc = data;\n\tgsc->recv_cb(gsc->recv_cb_data, gsc, cond);\n}\n", "bug_type": null, "idx": 52}
{"project": "Pidgin", "target": 0, "func": "const char * gnt_menuitem_get_id(GntMenuItem *item)\n{\n\treturn item->priv.id;\n}\n", "bug_type": null, "idx": 53}
{"project": "Pidgin", "target": 0, "func": "static int\nicqresponse(OscarData *od, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tGSList *tlvlist;\n\taim_tlv_t *datatlv;\n\tByteStream qbs;\n\tguint32 ouruin;\n\tguint16 cmdlen, cmd, reqid;\n\tif (!(tlvlist = aim_tlvlist_read(bs)) || !(datatlv = aim_tlv_gettlv(tlvlist, 0x0001, 1))) {\n\t\taim_tlvlist_free(tlvlist);\n\t\tpurple_debug_misc(\"oscar\", \"corrupt ICQ response\\n\");\n\t\treturn 0;\n\t}\n\tbyte_stream_init(&qbs, datatlv->value, datatlv->length);\n\tcmdlen = byte_stream_getle16(&qbs);\n\touruin = byte_stream_getle32(&qbs);\n\tcmd = byte_stream_getle16(&qbs);\n\treqid = byte_stream_getle16(&qbs);\n\tpurple_debug_misc(\"oscar\", \"icq response: %d bytes, %u, 0x%04x, 0x%04x\\n\", cmdlen, ouruin, cmd, reqid);\n\tif (cmd == 0x07da) { \n\t\tguint16 subtype;\n\t\tGSList *info_ptr;\n\t\tstruct aim_icq_info *info;\n\t\tsubtype = byte_stream_getle16(&qbs);\n\t\tbyte_stream_advance(&qbs, 1); \n\t\t\n\t\tinfo_ptr = g_slist_find_custom(od->icq_info, &reqid, compare_icq_infos);\n\t\tif (!info_ptr) {\n\t\t\tstruct aim_icq_info *new_info = (struct aim_icq_info *)g_new0(struct aim_icq_info, 1);\n\t\t\tnew_info->reqid = reqid;\n\t\t\tinfo_ptr = od->icq_info = g_slist_prepend(od->icq_info, new_info);\n\t\t}\n\t\tinfo = info_ptr->data;\n\t\tswitch (subtype) {\n\t\tcase 0x00a0: { \n\t\t\t\n\t\t} break;\n\t\tcase 0x00aa: { \n\t\t\t\n\t\t} break;\n\t\tcase 0x00c8: { \n\t\t\tinfo->nick = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->first = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->last = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->email = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->homecity = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->homestate = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->homephone = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->homefax = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->homeaddr = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->mobile = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->homezip = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->homecountry = byte_stream_getle16(&qbs);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t} break;\n\t\tcase 0x00dc: { \n\t\t\tinfo->age = byte_stream_getle8(&qbs);\n\t\t\tinfo->unknown = byte_stream_getle8(&qbs);\n\t\t\tinfo->gender = byte_stream_getle8(&qbs); \n\t\t\tinfo->personalwebpage = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->birthyear = byte_stream_getle16(&qbs);\n\t\t\tinfo->birthmonth = byte_stream_getle8(&qbs);\n\t\t\tinfo->birthday = byte_stream_getle8(&qbs);\n\t\t\tinfo->language1 = byte_stream_getle8(&qbs);\n\t\t\tinfo->language2 = byte_stream_getle8(&qbs);\n\t\t\tinfo->language3 = byte_stream_getle8(&qbs);\n\t\t\t\n\t\t} break;\n\t\tcase 0x00d2: { \n\t\t\tinfo->workcity = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workstate = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workphone = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workfax = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workaddr = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workzip = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workcountry = byte_stream_getle16(&qbs);\n\t\t\tinfo->workcompany = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workdivision = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->workposition = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tbyte_stream_advance(&qbs, 2); \n\t\t\tinfo->workwebpage = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t} break;\n\t\tcase 0x00e6: { \n\t\t\tinfo->info = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs)-1);\n\t\t} break;\n\t\tcase 0x00eb: { \n\t\t\tint i;\n\t\t\tinfo->numaddresses = byte_stream_getle16(&qbs);\n\t\t\tinfo->email2 = (char **)g_new0(char *, info->numaddresses);\n\t\t\tfor (i = 0; i < info->numaddresses; i++) {\n\t\t\t\tinfo->email2[i] = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\t\tif (i+1 != info->numaddresses)\n\t\t\t\t\tbyte_stream_advance(&qbs, 1); \n\t\t\t}\n\t\t} break;\n\t\tcase 0x00f0: { \n\t\t} break;\n\t\tcase 0x00fa: { \n\t\t} break;\n\t\tcase 0x0104: { \n\t\t\tinfo->nick = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->first = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->last = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tbyte_stream_advance(&qbs, byte_stream_getle16(&qbs)); \n\t\t\t\n\t\t} break;\n\t\tcase 0x010e: { \n\t\t\t\n\t\t} break;\n\t\tcase 0x019a: { \n\t\t\tbyte_stream_advance(&qbs, 2);\n\t\t\tinfo->uin = byte_stream_getle32(&qbs);\n\t\t\tinfo->nick = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->first = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->last = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\tinfo->email = byte_stream_getstr(&qbs, byte_stream_getle16(&qbs));\n\t\t\t\n\t\t} break;\n\t\t\n\t\tcase 0x0fb4: {\n\t\t\tGSList *tlvlist;\n\t\t\taim_tlv_t *tlv;\n\t\t\tFlapConnection *conn;\n\t\t\tchar *uin = NULL;\n\t\t\tchar *status_note_title = NULL;\n\t\t\tconn = flap_connection_findbygroup(od, 0x0004);\n\t\t\tif (conn == NULL)\n\t\t\t{\n\t\t\t\tpurple_debug_misc(\"oscar\", \"icq/0x0fb4: flap connection was not found.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbyte_stream_advance(&qbs, 0x02); \n\t\t\tbyte_stream_advance(&qbs, 0x2f); \n\t\t\ttlvlist = aim_tlvlist_read(&qbs);\n\t\t\ttlv = aim_tlv_gettlv(tlvlist, 0x0032, 1);\n\t\t\tif (tlv != NULL)\n\t\t\t\t\n\t\t\t\tuin = aim_tlv_getvalue_as_string(tlv);\n\t\t\ttlv = aim_tlv_gettlv(tlvlist, 0x0226, 1);\n\t\t\tif (tlv != NULL)\n\t\t\t\t\n\t\t\t\tstatus_note_title = aim_tlv_getvalue_as_string(tlv);\n\t\t\taim_tlvlist_free(tlvlist);\n\t\t\tif (uin == NULL || status_note_title == NULL)\n\t\t\t{\n\t\t\t\tpurple_debug_misc(\"oscar\", \"icq/0x0fb4: uin or \"\n\t\t\t\t\t\t\"status_note_title was not found\\n\");\n\t\t\t\tg_free(uin);\n\t\t\t\tg_free(status_note_title);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (status_note_title[0] == '\\0')\n\t\t\t{\n\t\t\t\tPurpleAccount *account;\n\t\t\t\tPurpleBuddy *buddy;\n\t\t\t\tPurplePresence *presence;\n\t\t\t\tPurpleStatus *status;\n\t\t\t\taccount = purple_connection_get_account(od->gc);\n\t\t\t\tbuddy = purple_find_buddy(account, uin);\n\t\t\t\tpresence = purple_buddy_get_presence(buddy);\n\t\t\t\tstatus = purple_presence_get_active_status(presence);\n\t\t\t\tpurple_prpl_got_user_status(account, uin,\n\t\t\t\t\t\tpurple_status_get_id(status),\n\t\t\t\t\t\t\"message\", NULL, NULL);\n\t\t\t\tg_free(status_note_title);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstruct aim_icq_info *info;\n\t\t\t\tByteStream bs;\n\t\t\t\tguint32 bslen;\n\t\t\t\taim_snacid_t snacid;\n\t\t\t\tguchar cookie[8];\n\t\t\t\tinfo = g_new0(struct aim_icq_info, 1);\n\t\t\t\tbslen = 13 + strlen(uin) + 30 + 6 + 4 + 55 + 85 + 4;\n\t\t\t\tbyte_stream_new(&bs, 4 + bslen);\n\t\t\t\tsnacid = aim_cachesnac(od, 0x0004, 0x0006, 0x0000, NULL, 0);\n\t\t\t\taim_icbm_makecookie(cookie);\n\t\t\t\tbyte_stream_putraw(&bs, cookie, 8); \n\t\t\t\tbyte_stream_put16(&bs, 0x0002); \n\t\t\t\tbyte_stream_put8(&bs, strlen(uin)); \n\t\t\t\tbyte_stream_putstr(&bs, uin);\n\t\t\t\tbyte_stream_put16(&bs, 0x0005); \n\t\t\t\tbyte_stream_put16(&bs, 0x00b2);\n\t\t\t\tbyte_stream_put16(&bs, 0x0000); \n\t\t\t\tbyte_stream_putraw(&bs, cookie, 8); \n\t\t\t\tbyte_stream_put32(&bs, 0x09461349); \n\t\t\t\tbyte_stream_put16(&bs, 0x4c7f);\n\t\t\t\tbyte_stream_put16(&bs, 0x11d1);\n\t\t\t\tbyte_stream_put32(&bs, 0x82224445);\n\t\t\t\tbyte_stream_put32(&bs, 0x53540000);\n\t\t\t\tbyte_stream_put16(&bs, 0x000a); \n\t\t\t\tbyte_stream_put16(&bs, 0x0002);\n\t\t\t\tbyte_stream_put16(&bs, 0x0001);\n\t\t\t\tbyte_stream_put16(&bs, 0x000f); \n\t\t\t\tbyte_stream_put16(&bs, 0x0000);\n\t\t\t\tbyte_stream_put16(&bs, 0x2711); \n\t\t\t\tbyte_stream_put16(&bs, 0x008a);\n\t\t\t\tbyte_stream_putle16(&bs, 0x001b); \n\t\t\t\tbyte_stream_putle16(&bs, 0x0009); \n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000); \n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_putle16(&bs, 0x0000); \n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000); \n\t\t\t\tbyte_stream_put8(&bs, 0x00); \n\t\t\t\tbyte_stream_putle16(&bs, 0x0064); \n\t\t\t\tbyte_stream_putle16(&bs, 0x000e); \n\t\t\t\tbyte_stream_putle16(&bs, 0x0064); \n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000); \n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_putle32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_put8(&bs, 0x1a); \n\t\t\t\tbyte_stream_put8(&bs, 0x00); \n\t\t\t\tbyte_stream_putle16(&bs, 0x0000); \n\t\t\t\tbyte_stream_putle16(&bs, 0x0001); \n\t\t\t\tbyte_stream_putle16(&bs, 0x0000); \n\t\t\t\tbyte_stream_put8(&bs, 0x3a); \n\t\t\t\tbyte_stream_put32(&bs, 0x00811a18);\n\t\t\t\tbyte_stream_put32(&bs, 0xbc0e6c18);\n\t\t\t\tbyte_stream_put32(&bs, 0x47a5916f);\n\t\t\t\tbyte_stream_put32(&bs, 0x18dcc76f);\n\t\t\t\tbyte_stream_put32(&bs, 0x1a010013);\n\t\t\t\tbyte_stream_put32(&bs, 0x00000041);\n\t\t\t\tbyte_stream_put32(&bs, 0x77617920);\n\t\t\t\tbyte_stream_put32(&bs, 0x53746174);\n\t\t\t\tbyte_stream_put32(&bs, 0x7573204d);\n\t\t\t\tbyte_stream_put32(&bs, 0x65737361);\n\t\t\t\tbyte_stream_put32(&bs, 0x67650100);\n\t\t\t\tbyte_stream_put32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_put32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_put32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_put32(&bs, 0x00000015);\n\t\t\t\tbyte_stream_put32(&bs, 0x00000000);\n\t\t\t\tbyte_stream_put32(&bs, 0x0000000d);\n\t\t\t\tbyte_stream_put32(&bs, 0x00000074);\n\t\t\t\tbyte_stream_put32(&bs, 0x6578742f);\n\t\t\t\tbyte_stream_put32(&bs, 0x782d616f);\n\t\t\t\tbyte_stream_put32(&bs, 0x6c727466);\n\t\t\t\tbyte_stream_put16(&bs, 0x0003); \n\t\t\t\tbyte_stream_put16(&bs, 0x0000);\n\t\t\t\tinfo->uin = atoi(uin);\n\t\t\t\tinfo->status_note_title = status_note_title;\n\t\t\t\tmemcpy(&info->icbm_cookie, cookie, 8);\n\t\t\t\tod->icq_info = g_slist_prepend(od->icq_info, info);\n\t\t\t\tflap_connection_send_snac_with_priority(od, conn, 0x0004, 0x0006, snacid, &bs, FALSE);\n\t\t\t\tbyte_stream_destroy(&bs);\n\t\t\t}\n\t\t\tg_free(uin);\n\t\t} break;\n\t\t} \n\t\tif (!(snac->flags & 0x0001)) {\n\t\t\tif (subtype != 0x0104)\n\t\t\t\toscar_user_info_display_icq(od, info);\n\t\t\tif (info->uin && info->nick)\n\t\t\t\tgotalias(od, info);\n\t\t\taim_icq_freeinfo(info);\n\t\t\tod->icq_info = g_slist_remove(od->icq_info, info);\n\t\t}\n\t}\n\taim_tlvlist_free(tlvlist);\n\treturn 1;\n}\n", "bug_type": null, "idx": 54}
{"project": "Pidgin", "target": 0, "func": "static void\nupdate_window_in_list(GntWM *wm, GntWidget *wid)\n{\n\tGntTextFormatFlags flag = 0;\n\tif (wm->windows == NULL)\n\t\treturn;\n\tif (wm->cws->ordered && wid == wm->cws->ordered->data)\n\t\tflag |= GNT_TEXT_FLAG_DIM;\n\telse if (GNT_WIDGET_IS_FLAG_SET(wid, GNT_WIDGET_URGENT))\n\t\tflag |= GNT_TEXT_FLAG_BOLD;\n\tgnt_tree_set_row_flags(GNT_TREE(wm->windows->tree), wid, flag);\n}\n", "bug_type": null, "idx": 55}
{"project": "Pidgin", "target": 0, "func": "static gint\ncompare_plugins(gconstpointer a, gconstpointer b)\n{\n\tconst PurplePlugin *plugina = a;\n\tconst PurplePlugin *pluginb = b;\n\treturn strcmp(plugina->info->name, pluginb->info->name);\n}\n", "bug_type": null, "idx": 56}
{"project": "Pidgin", "target": 0, "func": "void\npurple_media_codec_remove_optional_parameter(PurpleMediaCodec *codec,\n\t\tPurpleKeyValuePair *param)\n{\n\tPurpleMediaCodecPrivate *priv;\n\tg_return_if_fail(codec != NULL && param != NULL);\n\tpriv = PURPLE_MEDIA_CODEC_GET_PRIVATE(codec);\n\tg_free(param->key);\n\tg_free(param->value);\n\tpriv->optional_params =\n\t\t\tg_list_remove(priv->optional_params, param);\n\tg_free(param);\n}\n", "bug_type": null, "idx": 57}
{"project": "Pidgin", "target": 0, "func": "GtkWidget *\npidgin_menu_tray_new() {\n\treturn g_object_new(PIDGIN_TYPE_MENU_TRAY, NULL);\n}\n", "bug_type": null, "idx": 58}
{"project": "Pidgin", "target": 0, "func": "static GHashTable *plugins_hash = NULL;\nvoid ml_add_plugin(PurpleMonoPlugin *plugin)\n{\n\tif (!plugins_hash)\n\t\tplugins_hash = g_hash_table_new(NULL, NULL);\n\tg_hash_table_insert(plugins_hash, plugin->klass, plugin);\n}\n", "bug_type": null, "idx": 59}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nservice_click_cb(GtkTreeView *tree, GdkEventButton *event, gpointer user_data)\n{\n\tPidginDiscoList *pdl;\n\tXmppDiscoService *service;\n\tGtkWidget *menu;\n\tGtkTreePath *path;\n\tGtkTreeIter iter;\n\tGValue val;\n\tif (event->button != 3 || event->type != GDK_BUTTON_PRESS)\n\t\treturn FALSE;\n\tpdl = user_data;\n\t\n\tif (!gtk_tree_view_get_path_at_pos(tree, event->x, event->y, &path,\n\t\t                               NULL, NULL, NULL))\n\t\treturn FALSE;\n\tgtk_tree_model_get_iter(GTK_TREE_MODEL(pdl->model), &iter, path);\n\tgtk_tree_path_free(path);\n\tval.g_type = 0;\n\tgtk_tree_model_get_value(GTK_TREE_MODEL(pdl->model), &iter, SERVICE_COLUMN,\n\t                         &val);\n\tservice = g_value_get_pointer(&val);\n\tif (!service)\n\t\treturn FALSE;\n\tmenu = gtk_menu_new();\n\tif (service->flags & XMPP_DISCO_ADD)\n\t\tpidgin_new_item_from_stock(menu, _(\"Add to Buddy List\"), GTK_STOCK_ADD,\n\t\t                           G_CALLBACK(add_to_blist_cb), pdl->dialog,\n\t\t                           0, 0, NULL);\n\tif (service->flags & XMPP_DISCO_REGISTER) {\n\t\tGtkWidget *item = pidgin_new_item(menu, _(\"Register\"));\n\t\tg_signal_connect(G_OBJECT(item), \"activate\",\n\t\t                 G_CALLBACK(register_button_cb), pdl->dialog);\n\t}\n\tgtk_widget_show_all(menu);\n\tgtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event->button,\n\t               event->time);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 60}
{"project": "Pidgin", "target": 0, "func": "static void\npounces_manager_delete_confirm_cb(PurplePounce *pounce)\n{\n\tGtkTreeIter iter;\n\tif (pounces_manager && pounces_manager_find_pounce(&iter, pounce))\n\t\tgtk_list_store_remove(pounces_manager->model, &iter);\n\tpurple_request_close_with_handle(pounce);\n\tpurple_pounce_destroy(pounce);\n}\n", "bug_type": null, "idx": 61}
{"project": "Pidgin", "target": 0, "func": "static FsCodec *\ncodec_to_fs(const PurpleMediaCodec *codec)\n{\n\tFsCodec *new_codec;\n\tgint id;\n\tchar *encoding_name;\n\tPurpleMediaSessionType media_type;\n\tguint clock_rate;\n\tguint channels;\n\tGList *iter;\n\tif (codec == NULL)\n\t\treturn NULL;\n\tg_object_get(G_OBJECT(codec),\n\t\t\t\"id\", &id,\n\t\t\t\"encoding-name\", &encoding_name,\n\t\t\t\"media-type\", &media_type,\n\t\t\t\"clock-rate\", &clock_rate,\n\t\t\t\"channels\", &channels,\n\t\t\t\"optional-params\", &iter,\n\t\t\tNULL);\n\tnew_codec = fs_codec_new(id, encoding_name,\n\t\t\tsession_type_to_fs_media_type(media_type),\n\t\t\tclock_rate);\n\tnew_codec->channels = channels;\n\tfor (; iter; iter = g_list_next(iter)) {\n\t\tPurpleKeyValuePair *param = (PurpleKeyValuePair*)iter->data;\n\t\tfs_codec_add_optional_parameter(new_codec,\n\t\t\t\tparam->key, param->value);\n\t}\n\tg_free(encoding_name);\n\treturn new_codec;\n}\n", "bug_type": null, "idx": 62}
{"project": "Pidgin", "target": 0, "func": "JabberCapsClientInfo *jabber_caps_parse_client_info(xmlnode *query)\n{\n\txmlnode *child;\n\tJabberCapsClientInfo *info;\n\tif (!query || !g_str_equal(query->name, \"query\") ||\n\t\t\t!purple_strequal(query->xmlns, NS_DISCO_INFO))\n\t\treturn NULL;\n\tinfo = g_new0(JabberCapsClientInfo, 1);\n\tfor(child = query->child; child; child = child->next) {\n\t\tif (child->type != XMLNODE_TYPE_TAG)\n\t\t\tcontinue;\n\t\tif (g_str_equal(child->name, \"identity\")) {\n\t\t\t\n\t\t\tconst char *category = xmlnode_get_attrib(child, \"category\");\n\t\t\tconst char *type = xmlnode_get_attrib(child, \"type\");\n\t\t\tconst char *name = xmlnode_get_attrib(child, \"name\");\n\t\t\tconst char *lang = xmlnode_get_attrib(child, \"lang\");\n\t\t\tJabberIdentity *id;\n\t\t\tif (!category || !type)\n\t\t\t\tcontinue;\n\t\t\tid = g_new0(JabberIdentity, 1);\n\t\t\tid->category = g_strdup(category);\n\t\t\tid->type = g_strdup(type);\n\t\t\tid->name = g_strdup(name);\n\t\t\tid->lang = g_strdup(lang);\n\t\t\tinfo->identities = g_list_append(info->identities, id);\n\t\t} else if (g_str_equal(child->name, \"feature\")) {\n\t\t\t\n\t\t\tconst char *var = xmlnode_get_attrib(child, \"var\");\n\t\t\tif (var)\n\t\t\t\tinfo->features = g_list_prepend(info->features, g_strdup(var));\n\t\t} else if (g_str_equal(child->name, \"x\")) {\n\t\t\tif (purple_strequal(child->xmlns, \"jabber:x:data\")) {\n\t\t\t\t\n\t\t\t\txmlnode *dataform = xmlnode_copy(child);\n\t\t\t\tinfo->forms = g_list_append(info->forms, dataform);\n\t\t\t}\n\t\t}\n\t}\n\treturn info;\n}\n", "bug_type": null, "idx": 63}
{"project": "Pidgin", "target": 0, "func": "int irc_cmd_wallops(struct irc_conn *irc, const char *cmd, const char *target, const char **args)\n{\n\tchar *buf;\n\tif (!args || !args[0])\n\t\treturn 0;\n\tif (!strcmp(cmd, \"wallops\"))\n\t\tbuf = irc_format(irc, \"v:\", \"WALLOPS\", args[0]);\n\telse if (!strcmp(cmd, \"operwall\"))\n\t\tbuf = irc_format(irc, \"v:\", \"OPERWALL\", args[0]);\n\telse\n\t\treturn 0;\n\tirc_send(irc, buf);\n\tg_free(buf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 64}
{"project": "Pidgin", "target": 0, "func": "JingleContent *\njingle_session_find_content(JingleSession *session, const gchar *name, const gchar *creator)\n{\n\tGList *iter;\n\tif (name == NULL)\n\t\treturn NULL;\n\titer = session->priv->contents;\n\tfor (; iter; iter = g_list_next(iter)) {\n\t\tJingleContent *content = iter->data;\n\t\tgchar *cname = jingle_content_get_name(content);\n\t\tgboolean result = g_str_equal(name, cname);\n\t\tg_free(cname);\n\t\tif (creator != NULL) {\n\t\t\tgchar *ccreator = jingle_content_get_creator(content);\n\t\t\tresult = (result && !strcmp(creator, ccreator));\n\t\t\tg_free(ccreator);\n\t\t}\n\t\tif (result == TRUE)\n\t\t\treturn content;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 65}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_dialogs_merge_groups_cb(struct _PidginGroupMergeObject *GGP)\n{\n\tpurple_blist_rename_group(GGP->parent, GGP->new_name);\n\tfree_ggmo(GGP);\n}\n", "bug_type": null, "idx": 66}
{"project": "Pidgin", "target": 0, "func": "struct gg_http *gg_unregister(uin_t uin, const char *password, const char *email, int async)\n{\n\tgg_debug(GG_DEBUG_MISC, \"// gg_unregister() is obsolete. use gg_unregister3() instead!\\n\");\n\terrno = EINVAL;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 67}
{"project": "Pidgin", "target": 0, "func": "void jabber_pep_init_actions(GList **m) {\n\t\n\tjabber_nick_init_action(m);\n}\n", "bug_type": null, "idx": 68}
{"project": "Pidgin", "target": 0, "func": "static void\nspellcheck_prefs_cb(const char *name, PurplePrefType type,\n\t\t\t\t\tgconstpointer value, gpointer data)\n{\n#ifdef USE_GTKSPELL\n\tPidginStatusBox *status_box = (PidginStatusBox *)data;\n\tif (value)\n\t\tpidgin_setup_gtkspell(GTK_TEXT_VIEW(status_box->imhtml));\n\telse\n\t{\n\t\tGtkSpell *spell;\n\t\tspell = gtkspell_get_from_text_view(GTK_TEXT_VIEW(status_box->imhtml));\n\t\tgtkspell_detach(spell);\n\t}\n#endif\n}\n", "bug_type": null, "idx": 69}
{"project": "Pidgin", "target": 0, "func": "void\nnm_message_set_conference(NMMessage * msg, NMConference * conf)\n{\n\tif (msg == NULL || conf == NULL)\n\t\treturn;\n\t\n\tnm_conference_add_ref(conf);\n\tmsg->conference = conf;\n}\n", "bug_type": null, "idx": 70}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nx509_tls_peers_delete_cert(const gchar *id)\n{\n\tgboolean ret = FALSE;\n\tgchar *keypath;\n\tg_return_val_if_fail(id, FALSE);\n\t\n\tif (!x509_tls_peers_cert_in_pool(id)) {\n\t\tpurple_debug_warning(\"certificate/tls_peers\",\n\t\t\t\t     \"Id %s wasn't in the pool\\n\",\n\t\t\t\t     id);\n\t\treturn FALSE;\n\t}\n\t\n\tkeypath = purple_certificate_pool_mkpath(&x509_tls_peers, id);\n\tif ( unlink(keypath) != 0 ) {\n\t\tpurple_debug_error(\"certificate/tls_peers\",\n\t\t\t\t   \"Unlink of %s failed!\\n\",\n\t\t\t\t   keypath);\n\t\tret = FALSE;\n\t} else {\n\t\tret = TRUE;\n\t}\n\tg_free(keypath);\n\treturn ret;\n}\n", "bug_type": null, "idx": 71}
{"project": "Pidgin", "target": 0, "func": "static void\nhandle_count_title(PidginWindow *purplewin)\n{\n\tGtkWindow *window;\n\tchar newtitle[256];\n\tg_return_if_fail(purplewin != NULL);\n\twindow = GTK_WINDOW(purplewin->window);\n\tg_return_if_fail(window != NULL);\n\tg_snprintf(newtitle, sizeof(newtitle), \"[%d] %s\",\n\t           count_messages(purplewin), gtk_window_get_title(window));\n\tgtk_window_set_title(window, newtitle);\n}\n", "bug_type": null, "idx": 72}
{"project": "Pidgin", "target": 0, "func": "int wpurple_getsockopt(int socket, int level, int optname, void *optval, socklen_t *optlenptr) {\n\tif(getsockopt(socket, level, optname, optval, optlenptr) == SOCKET_ERROR ) {\n\t\terrno = WSAGetLastError();\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n}\nint wpurple_getsockopt(int socket, int level, int optname, void *optval, socklen_t *optlenptr) {\n\tif(getsockopt(socket, level, optname, optval, optlenptr) == SOCKET_ERROR ) {\n\t\terrno = WSAGetLastError();\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 73}
{"project": "Pidgin", "target": 0, "func": "static void\n_send_message(NMUser * user, NMMessage * message)\n{\n\tNMConference *conf;\n\tNMERR_T rc = NM_OK;\n\tconf = nm_message_get_conference(message);\n\tif (conf) {\n\t\t\n\t\tif (nm_conference_is_instantiated(conf)) {\n\t\t\t\n\t\t\trc = nm_send_message(user, message, _send_message_resp_cb);\n\t\t\t_check_for_disconnect(user, rc);\n\t\t\tnm_release_message(message);\n\t\t} else {\n\t\t\trc = nm_send_create_conference(user, conf, _createconf_resp_send_msg, message);\n\t\t\t_check_for_disconnect(user, rc);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 74}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_unload(PurplePlugin *plugin)\n{\n\tvoid *jabber_handle = purple_plugins_find_with_id(\"prpl-jabber\");\n\tpurple_signals_disconnect_by_handle(plugin);\n\tif (jabber_handle) {\n\t\t\n\t\tpurple_signal_emit(jabber_handle, \"jabber-unregister-namespace-watcher\",\n\t\t                   \"bogus_node\", \"super-duper-namespace\");\n\t\t\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 75}
{"project": "Pidgin", "target": 0, "func": "size_t gg110_options__get_packed_size\n                     (const GG110Options *message)\n{\n  assert(message->base.descriptor == &gg110_options__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\n", "bug_type": null, "idx": 76}
{"project": "Pidgin", "target": 0, "func": "static void buddy_ticker_create_window(void) {\n\tif(tickerwindow) {\n\t\tgtk_widget_show(tickerwindow);\n\t\treturn;\n\t}\n\ttickerwindow = pidgin_create_window(_(\"Buddy Ticker\"), 0, \"ticker\", TRUE);\n\tgtk_window_set_default_size(GTK_WINDOW(tickerwindow), 500, -1);\n\tg_signal_connect(G_OBJECT(tickerwindow), \"delete_event\",\n\t\t\tG_CALLBACK (buddy_ticker_destroy_window), NULL);\n\tticker = gtk_ticker_new();\n\tgtk_ticker_set_spacing(GTK_TICKER(ticker), 20);\n\tgtk_container_add(GTK_CONTAINER(tickerwindow), ticker);\n\tgtk_ticker_set_interval(GTK_TICKER(ticker), 500);\n\tgtk_ticker_set_scootch(GTK_TICKER(ticker), 10);\n\tgtk_ticker_start_scroll(GTK_TICKER(ticker));\n\tgtk_widget_set_size_request(ticker, 1, -1);\n\tgtk_widget_show_all(tickerwindow);\n}\n}\nstatic void buddy_ticker_create_window(void) {\n\tif(tickerwindow) {\n\t\tgtk_widget_show(tickerwindow);\n\t\treturn;\n\t}\n\ttickerwindow = pidgin_create_window(_(\"Buddy Ticker\"), 0, \"ticker\", TRUE);\n\tgtk_window_set_default_size(GTK_WINDOW(tickerwindow), 500, -1);\n\tg_signal_connect(G_OBJECT(tickerwindow), \"delete_event\",\n\t\t\tG_CALLBACK (buddy_ticker_destroy_window), NULL);\n\tticker = gtk_ticker_new();\n\tgtk_ticker_set_spacing(GTK_TICKER(ticker), 20);\n\tgtk_container_add(GTK_CONTAINER(tickerwindow), ticker);\n\tgtk_ticker_set_interval(GTK_TICKER(ticker), 500);\n\tgtk_ticker_set_scootch(GTK_TICKER(ticker), 10);\n\tgtk_ticker_start_scroll(GTK_TICKER(ticker));\n\tgtk_widget_set_size_request(ticker, 1, -1);\n\tgtk_widget_show_all(tickerwindow);\n}\n", "bug_type": null, "idx": 77}
{"project": "Pidgin", "target": 0, "func": "static gboolean no_group_can_add_node(PurpleBlistNode *node)\n{\n\treturn on_offline_can_add_node(node);   \n}\n", "bug_type": null, "idx": 78}
{"project": "Pidgin", "target": 0, "func": "void\npurple_log_uninit(void)\n{\n\tpurple_signals_unregister_by_instance(purple_log_get_handle());\n\tpurple_log_logger_remove(html_logger);\n\tpurple_log_logger_free(html_logger);\n\thtml_logger = NULL;\n\tpurple_log_logger_remove(txt_logger);\n\tpurple_log_logger_free(txt_logger);\n\ttxt_logger = NULL;\n\tpurple_log_logger_remove(old_logger);\n\tpurple_log_logger_free(old_logger);\n\told_logger = NULL;\n\tg_hash_table_destroy(logsize_users);\n\tg_hash_table_destroy(logsize_users_decayed);\n}\n", "bug_type": null, "idx": 79}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddy_status_changed_cb(PurpleBuddy *buddy, PurpleStatus *old_status,\n                        PurpleStatus *status, void *data)\n{\n\tgboolean available, old_available;\n\tif (!purple_status_is_exclusive(status) ||\n\t\t\t!purple_status_is_exclusive(old_status))\n\t\treturn;\n\tavailable = purple_status_is_available(status);\n\told_available = purple_status_is_available(old_status);\n\tif (purple_prefs_get_bool(\"/plugins/core/statenotify/notify_away\")) {\n\t\tif (available && !old_available)\n\t\t\twrite_status(buddy, _(\"%s is no longer away.\"));\n\t\telse if (!available && old_available)\n\t\t\twrite_status(buddy, _(\"%s has gone away.\"));\n\t}\n}\n", "bug_type": null, "idx": 80}
{"project": "Pidgin", "target": 0, "func": "static void\ndo_joinchat(GtkWidget *dialog, int id, PidginChatData *info)\n{\n\tswitch(id)\n\t{\n\t\tcase GTK_RESPONSE_OK:\n\t\t\tdo_join_chat(info);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpidgin_roomlist_dialog_show_with_account(info->rq_data.account);\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tgtk_widget_destroy(GTK_WIDGET(dialog));\n\tg_list_free(info->entries);\n\tg_free(info);\n}\n", "bug_type": null, "idx": 81}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_connect(PurpleAccount *account)\n{\n\tPurplePlugin *prpl;\n\tconst char *password, *username;\n\tPurplePluginProtocolInfo *prpl_info;\n\tg_return_if_fail(account != NULL);\n\tusername = purple_account_get_username(account);\n\tif (!purple_account_get_enabled(account, purple_core_get_ui())) {\n\t\tpurple_debug_info(\"account\",\n\t\t\t\t  \"Account %s not enabled, not connecting.\\n\",\n\t\t\t\t  username);\n\t\treturn;\n\t}\n\tprpl = purple_find_prpl(purple_account_get_protocol_id(account));\n\tif (prpl == NULL) {\n\t\tgchar *message;\n\t\tmessage = g_strdup_printf(_(\"Missing protocol plugin for %s\"), username);\n\t\tpurple_notify_error(account, _(\"Connection Error\"), message, NULL);\n\t\tg_free(message);\n\t\treturn;\n\t}\n\tpurple_debug_info(\"account\", \"Connecting to account %s.\\n\", username);\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\tpassword = purple_account_get_password(account);\n\tif ((password == NULL) &&\n\t\t!(prpl_info->options & OPT_PROTO_NO_PASSWORD) &&\n\t\t!(prpl_info->options & OPT_PROTO_PASSWORD_OPTIONAL))\n\t\tpurple_account_request_password(account, G_CALLBACK(request_password_ok_cb), G_CALLBACK(request_password_cancel_cb), account);\n\telse\n\t\t_purple_connection_new(account, FALSE, password);\n}\n", "bug_type": null, "idx": 82}
{"project": "Pidgin", "target": 0, "func": "void\noscar_keepalive(PurpleConnection *gc)\n{\n\tOscarData *od;\n\tGSList *l;\n\tod = purple_connection_get_protocol_data(gc);\n\tfor (l = od->oscar_connections; l; l = l->next) {\n\t\tflap_connection_send_keepalive(od, l->data);\n\t}\n}\n", "bug_type": null, "idx": 83}
{"project": "Pidgin", "target": 0, "func": " *****************************************************************************/\nstatic void delete_foreach(GtkTreeModel *model, GtkTreePath *path,\n\t\tGtkTreeIter *iter, gpointer data)\n{\n\tPurpleSmiley *smiley = NULL;\n\tgtk_tree_model_get(model, iter,\n\t\t\tSMILEY, &smiley,\n\t\t\t-1);\n\tif(smiley != NULL) {\n\t\tg_object_unref(G_OBJECT(smiley));\n\t\tpidgin_smiley_del_from_list(smiley);\n\t\tpurple_smiley_delete(smiley);\n\t}\n}\n", "bug_type": null, "idx": 84}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nlarge_step_forward(GntBindable *bindable, GList *null)\n{\n\tGntSlider *slider = GNT_SLIDER(bindable);\n\tgnt_slider_set_value(slider, slider->current + slider->largestep);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 85}
{"project": "Pidgin", "target": 0, "func": "void\nnm_conference_add_participant(NMConference * conference,\n\t\t\t\t\t\t\t  NMUserRecord * user_record)\n{\n\tif (conference == NULL || user_record == NULL) {\n\t\treturn;\n\t}\n\tnm_user_record_add_ref(user_record);\n\tconference->participants = g_slist_append(conference->participants, user_record);\n}\n", "bug_type": null, "idx": 86}
{"project": "Pidgin", "target": 0, "func": "static void\nnetwork_ip_changed(GtkEntry *entry, gpointer data)\n{\n\tconst gchar *text = gtk_entry_get_text(entry);\n\tGdkColor color;\n\tif (text && *text) {\n\t\tif (purple_ip_address_is_valid(text)) {\n\t\t\tcolor.red = 0xAFFF;\n\t\t\tcolor.green = 0xFFFF;\n\t\t\tcolor.blue = 0xAFFF;\n\t\t\tpurple_network_set_public_ip(text);\n\t\t} else {\n\t\t\tcolor.red = 0xFFFF;\n\t\t\tcolor.green = 0xAFFF;\n\t\t\tcolor.blue = 0xAFFF;\n\t\t}\n\t\tgtk_widget_modify_base(GTK_WIDGET(entry), GTK_STATE_NORMAL, &color);\n\t} else {\n\t\tpurple_network_set_public_ip(\"\");\n\t\tgtk_widget_modify_base(GTK_WIDGET(entry), GTK_STATE_NORMAL, NULL);\n\t}\n}\n", "bug_type": null, "idx": 87}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_write(struct gg_session *sess, const char *buf, int length)\n{\n\tint res = 0;\n\tif (!sess->async) {\n\t\tint written = 0;\n\t\twhile (written < length) {\n\t\t\tres = gg_write_common(sess, buf + written, length - written);\n\t\t\tif (res == -1)\n\t\t\t\treturn -1;\n\t\t\twritten += res;\n\t\t\tres = written;\n\t\t}\n\t} else {\n\t\tif (sess->send_buf == NULL) {\n\t\t\tres = gg_write_common(sess, buf, length);\n\t\t\tif (res == -1 && errno == EAGAIN)\n\t\t\t\tres = 0;\n\t\t\tif (res == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (res < length) {\n\t\t\tchar *tmp;\n\t\t\tif (!(tmp = realloc(sess->send_buf, sess->send_left + length - res))) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsess->send_buf = tmp;\n\t\t\tmemcpy(sess->send_buf + sess->send_left, buf + res, length - res);\n\t\t\tsess->send_left += length - res;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 88}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddy_signed_off(PurpleBuddy *buddy, gpointer null)\n{\n\tif (purple_prefs_get_bool(PREFS_EVENT_SIGNONF))\n\t\tnotify(NULL, _(\"%s just signed off\"), purple_buddy_get_alias(buddy));\n}\n", "bug_type": null, "idx": 89}
{"project": "Pidgin", "target": 0, "func": "PurpleStoredImage *\npurple_buddy_icons_find_custom_icon(PurpleContact *contact)\n{\n\treturn purple_buddy_icons_node_find_custom_icon((PurpleBlistNode*)contact);\n}\n", "bug_type": null, "idx": 90}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_dialogs_alias_buddy_cb(PurpleBuddy *buddy, const char *new_alias)\n{\n\tpurple_blist_alias_buddy(buddy, new_alias);\n\tserv_alias_buddy(buddy);\n}\n", "bug_type": null, "idx": 91}
{"project": "Pidgin", "target": 0, "func": "int tcl_cmd_account(ClientData unused, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])\n{\n\tTcl_Obj *result, *list, *elem;\n\tconst char *cmds[] = { \"alias\", \"connect\", \"connection\", \"disconnect\",\n\t                       \"enabled\", \"find\", \"handle\", \"isconnected\",\n\t                       \"list\", \"presence\", \"protocol\", \"status\",\n\t                       \"status_type\", \"status_types\", \"username\",\n\t                       NULL };\n\tenum { CMD_ACCOUNT_ALIAS,\n\t       CMD_ACCOUNT_CONNECT, CMD_ACCOUNT_CONNECTION,\n\t       CMD_ACCOUNT_DISCONNECT, CMD_ACCOUNT_ENABLED, CMD_ACCOUNT_FIND,\n\t       CMD_ACCOUNT_HANDLE, CMD_ACCOUNT_ISCONNECTED, CMD_ACCOUNT_LIST,\n\t       CMD_ACCOUNT_PRESENCE, CMD_ACCOUNT_PROTOCOL, CMD_ACCOUNT_STATUS,\n\t       CMD_ACCOUNT_STATUS_TYPE, CMD_ACCOUNT_STATUS_TYPES,\n\t       CMD_ACCOUNT_USERNAME } cmd;\n\tconst char *listopts[] = { \"-all\", \"-online\", NULL };\n\tenum { CMD_ACCOUNTLIST_ALL, CMD_ACCOUNTLIST_ONLINE } listopt;\n\tconst char *alias;\n\tGList *cur;\n\tPurpleAccount *account;\n\tPurpleStatus *status;\n\tPurpleStatusType *status_type;\n\tPurpleValue *value;\n\tchar *attr_id;\n\tint error;\n\tint b, i;\n\tif (objc < 2) {\n\t\tTcl_WrongNumArgs(interp, 1, objv, \"subcommand ?args?\");\n\t\treturn TCL_ERROR;\n\t}\n\tif ((error = Tcl_GetIndexFromObj(interp, objv[1], cmds, \"subcommand\", 0, (int *)&cmd)) != TCL_OK)\n\t\treturn error;\n\tswitch (cmd) {\n\tcase CMD_ACCOUNT_ALIAS:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\talias = purple_account_get_alias(account);\n\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(alias ? (char *)alias : \"\", -1));\n\t\tbreak;\n\tcase CMD_ACCOUNT_CONNECT:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tif (!purple_account_is_connected(account))\n\t\t\tpurple_account_connect(account);\n\t\tTcl_SetObjResult(interp,\n\t\t                 purple_tcl_ref_new(PurpleTclRefConnection,\n\t\t                                  purple_account_get_connection(account)));\n\t\tbreak;\n\tcase CMD_ACCOUNT_CONNECTION:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp,\n\t\t                 purple_tcl_ref_new(PurpleTclRefConnection,\n\t\t\t\t\t\t    purple_account_get_connection(account)));\n\t\tbreak;\n\tcase CMD_ACCOUNT_DISCONNECT:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tpurple_account_disconnect(account);\n\t\tbreak;\n\tcase CMD_ACCOUNT_ENABLED:\n\t\tif (objc != 3 && objc != 4) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account ?enabled?\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tif (objc == 3) {\n\t\t\tTcl_SetObjResult(interp,\n\t\t\t\t\t Tcl_NewBooleanObj(\n\t\t\t\t\t\t purple_account_get_enabled(account,\n\t\t\t\t\t\t\t\t\t    purple_core_get_ui())));\n\t\t} else {\n\t\t\tif ((error = Tcl_GetBooleanFromObj(interp, objv[3], &b)) != TCL_OK)\n\t\t\t\treturn TCL_ERROR;\n\t\t\tpurple_account_set_enabled(account, purple_core_get_ui(), b);\n\t\t}\n\t\tbreak;\n\tcase CMD_ACCOUNT_FIND:\n\t\tif (objc != 4) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"username protocol\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\taccount = purple_accounts_find(Tcl_GetString(objv[2]),\n\t\t                             Tcl_GetString(objv[3]));\n\t\tTcl_SetObjResult(interp,\n\t\t                 purple_tcl_ref_new(PurpleTclRefAccount, account));\n\t\tbreak;\n\tcase CMD_ACCOUNT_HANDLE:\n\t\tif (objc != 2) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t purple_tcl_ref_new(PurpleTclRefHandle,\n\t\t\t\t\t\t    purple_accounts_get_handle()));\n\t\tbreak;\n\tcase CMD_ACCOUNT_ISCONNECTED:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t Tcl_NewBooleanObj(\n\t\t\t\t\t purple_account_is_connected(account)));\n\t\tbreak;\n\tcase CMD_ACCOUNT_LIST:\n\t\tlistopt = CMD_ACCOUNTLIST_ALL;\n\t\tif (objc > 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"?option?\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif (objc == 3) {\n\t\t\tif ((error = Tcl_GetIndexFromObj(interp, objv[2], listopts, \"option\", 0, (int *)&listopt)) != TCL_OK)\n\t\t\t\treturn error;\n\t\t}\n\t\tlist = Tcl_NewListObj(0, NULL);\n\t\tfor (cur = purple_accounts_get_all(); cur != NULL; cur = g_list_next(cur)) {\n\t\t\taccount = cur->data;\n\t\t\tif (listopt == CMD_ACCOUNTLIST_ONLINE && !purple_account_is_connected(account))\n\t\t\t\tcontinue;\n\t\t\telem = purple_tcl_ref_new(PurpleTclRefAccount, account);\n\t\t\tTcl_ListObjAppendElement(interp, list, elem);\n\t\t}\n\t\tTcl_SetObjResult(interp, list);\n\t\tbreak;\n\tcase CMD_ACCOUNT_PRESENCE:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp, purple_tcl_ref_new(PurpleTclRefPresence,\n\t\t\t\t\t\t\t  purple_account_get_presence(account)));\n\t\tbreak;\n\tcase CMD_ACCOUNT_PROTOCOL:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp, Tcl_NewStringObj((char *)purple_account_get_protocol_id(account), -1));\n\t\tbreak;\n\tcase CMD_ACCOUNT_STATUS:\n\t\tif (objc < 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account ?status_id name value ...?\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tif (objc == 3) {\n\t\t\tTcl_SetObjResult(interp,\n\t\t\t\t\t purple_tcl_ref_new(PurpleTclRefStatus,\n\t\t\t\t\t\t\t  purple_account_get_active_status(account)));\n\t\t} else {\n\t\t\tGList *l = NULL;\n\t\t\tif (objc % 2) {\n\t\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"name without value setting status\", -1));\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t\tstatus = purple_account_get_status(account, Tcl_GetString(objv[3]));\n\t\t\tif (status == NULL) {\n\t\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"invalid status for account\", -1));\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t\tfor (i = 4; i < objc; i += 2) {\n\t\t\t\tattr_id = Tcl_GetString(objv[i]);\n\t\t\t\tvalue = purple_status_get_attr_value(status, attr_id);\n\t\t\t\tif (value == NULL) {\n\t\t\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"invalid attribute for account\", -1));\n\t\t\t\t\treturn TCL_ERROR;\n\t\t\t\t}\n\t\t\t\tswitch (purple_value_get_type(value)) {\n\t\t\t\tcase PURPLE_TYPE_BOOLEAN:\n\t\t\t\t\terror = Tcl_GetBooleanFromObj(interp, objv[i + 1], &b);\n\t\t\t\t\tif (error != TCL_OK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t\tl = g_list_append(l, attr_id);\n\t\t\t\t\tl = g_list_append(l, GINT_TO_POINTER(b));\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_TYPE_INT:\n\t\t\t\t\terror = Tcl_GetIntFromObj(interp, objv[i + 1], &b);\n\t\t\t\t\tif (error != TCL_OK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t\tl = g_list_append(l, attr_id);\n\t\t\t\t\tl = g_list_append(l, GINT_TO_POINTER(b));\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_TYPE_STRING:\n\t\t\t\t\tl = g_list_append(l, attr_id);\n\t\t\t\t\tl = g_list_append(l, Tcl_GetString(objv[i + 1]));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"unknown PurpleValue type\", -1));\n\t\t\t\t\treturn TCL_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpurple_account_set_status_list(account, Tcl_GetString(objv[3]), TRUE, l);\n\t\t\tg_list_free(l);\n\t\t}\n\t\tbreak;\n\tcase CMD_ACCOUNT_STATUS_TYPE:\n\t\tif (objc != 4 && objc != 5) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account ?statustype? ?-primitive primitive?\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tif (objc == 4) {\n\t\t\tstatus_type = purple_account_get_status_type(account,\n\t\t\t\t\t\t\t\t   Tcl_GetString(objv[3]));\n\t\t} else {\n\t\t\tPurpleStatusPrimitive primitive;\n\t\t\tif (strcmp(Tcl_GetString(objv[3]), \"-primitive\")) {\n\t\t\t\tresult = Tcl_NewStringObj(\"bad option \\\"\", -1);\n\t\t\t\tTcl_AppendObjToObj(result, objv[3]);\n\t\t\t\tTcl_AppendToObj(result, \"\\\": should be -primitive\", -1);\n\t\t\t\tTcl_SetObjResult(interp,result);\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t\tprimitive = purple_primitive_get_type_from_id(Tcl_GetString(objv[4]));\n\t\t\tstatus_type = purple_account_get_status_type_with_primitive(account,\n\t\t\t\t\t\t\t\t\t\t  primitive);\n\t\t}\n\t\tif (status_type == NULL) {\n\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"status type not found\", -1));\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t purple_tcl_ref_new(PurpleTclRefStatusType,\n\t\t\t\t\t\t  status_type));\n\t\tbreak;\n\tcase CMD_ACCOUNT_STATUS_TYPES:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tlist = Tcl_NewListObj(0, NULL);\n\t\tfor (cur = purple_account_get_status_types(account); cur != NULL;\n\t\t     cur = g_list_next(cur)) {\n\t\t\tTcl_ListObjAppendElement(interp, list,\n\t\t\t\t\t\t purple_tcl_ref_new(PurpleTclRefStatusType,\n\t\t\t\t\t\t\t\t  cur->data));\n\t\t}\n\t\tTcl_SetObjResult(interp, list);\n\t\tbreak;\n\tcase CMD_ACCOUNT_USERNAME:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"account\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t Tcl_NewStringObj((char *)purple_account_get_username(account), -1));\n\t\tbreak;\n\t}\n\treturn TCL_OK;\n}\n", "bug_type": null, "idx": 92}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nwindow_list(GntBindable *bindable, GList *null)\n{\n\tGntWM *wm = GNT_WM(bindable);\n\tif (wm->_list.window || wm->menu)\n\t\treturn TRUE;\n\tif (!wm->cws->ordered)\n\t\treturn TRUE;\n\tlist_of_windows(wm, FALSE);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 93}
{"project": "Pidgin", "target": 0, "func": "static int gg_session_handle_welcome_110(struct gg_session *gs, uint32_t seed,\n\tstruct gg_event *ge)\n{\n\tGG105Login msg = GG105_LOGIN__INIT;\n\tchar client_str[1000];\n\tuint8_t hash[64];\n\tconst char *client_name = GG11_VERSION;\n\tconst char *client_version = GG_DEFAULT_CLIENT_VERSION_110;\n\tconst char *client_target = GG11_TARGET;\n\tuint8_t dummy4[4] = {0, 0, 0, 0};\n\tif (gs->hash_type != GG_LOGIN_HASH_SHA1) {\n\t\tgg_debug_session(gs, GG_DEBUG_ERROR, \"// Unsupported hash type \"\n\t\t\t\"for this protocol version\\n\");\n\t\tgg_connection_failure(gs, ge, GG_FAILURE_INTERNAL);\n\t\treturn -1;\n\t}\n\tif (gg_login_hash_sha1_2(gs->password, seed, hash) == -1) {\n\t\tgg_debug_session(gs, GG_DEBUG_ERROR, \"// gg_watch_fd() \"\n\t\t\t\"gg_login_hash_sha1_2() failed, \"\n\t\t\t\"probably out of memory\\n\");\n\t\tgg_connection_failure(gs, ge, GG_FAILURE_INTERNAL);\n\t\treturn -1;\n\t}\n\tif (gs->client_version != NULL && !isdigit(gs->client_version[0])) {\n\t\tclient_name = \"\";\n\t\tclient_target = \"\";\n\t}\n\tif (gs->client_version != NULL)\n\t\tclient_version = gs->client_version;\n\tsnprintf(client_str, sizeof(client_str), \"%s%s%s\",\n\t\tclient_name, client_version, client_target);\n\tclient_str[sizeof(client_str) - 1] = '\\0';\n\tgg_debug_session(gs, GG_DEBUG_MISC, \"// gg_watch_fd() \"\n\t\t\"sending GG_LOGIN105 packet\\n\");\n\tmsg.lang = GG8_LANG;\n\tgg_protobuf_set_uin(&msg.uin, gs->uin, NULL);\n\tmsg.hash.len = 20;\n\tmsg.hash.data = hash;\n\tmsg.client = client_str;\n\t\n\tmsg.initial_status = gs->initial_status ?\n\t\t(gs->initial_status & 0xFF) : GG_STATUS_AVAIL;\n\tif (gs->initial_descr != NULL) {\n\t\tmsg.initial_descr = gs->initial_descr;\n\t}\n\t\n\t\n\tmsg.supported_features = \"avatar,StatusComments,ggaccount,edisc,\"\n\t\t\"music_shared,bot,fanpage,pubdir,botCaps,gifts,Gift\";\n\tmsg.dummy4.len = sizeof(dummy4);\n\tmsg.dummy4.data = dummy4;\n\tmsg.has_dummy7 = 1;\n\tmsg.has_dummy8 = 1;\n\tmsg.has_dummy10 = 1;\n\tif (!GG_PROTOBUF_SEND(gs, ge, GG_LOGIN105, gg105_login, msg))\n\t\treturn -1;\n\tgs->state = GG_STATE_READING_REPLY;\n\tgs->check = GG_CHECK_READ;\n\treturn 0;\n}\n", "bug_type": null, "idx": 94}
{"project": "Pidgin", "target": 0, "func": " */\nunsigned char *gg_deflate(const char *in, size_t *out_lenp)\n{\n#ifdef GG_CONFIG_HAVE_ZLIB\n\tint ret;\n\tz_stream strm;\n\tunsigned char *out, *out2;\n\tsize_t out_len;\n\tif (in == NULL || out_lenp == NULL)\n\t\treturn NULL;\n\tstrm.zalloc = Z_NULL;\n\tstrm.zfree = Z_NULL;\n\tstrm.opaque = Z_NULL;\n\tstrm.avail_in = strlen(in);\n\tstrm.next_in = (unsigned char*) in;\n\tret = deflateInit(&strm, Z_BEST_COMPRESSION);\n\tif (ret != Z_OK) {\n\t\tgg_debug(GG_DEBUG_MISC, \"// gg_deflate() deflateInit() failed (%d)\\n\", ret);\n\t\treturn NULL;\n\t}\n\tout_len = deflateBound(&strm, strm.avail_in);\n\tout = malloc(out_len);\n\tif (out == NULL) {\n\t\tgg_debug(GG_DEBUG_MISC, \"// gg_deflate() not enough memory for \"\n\t\t\t\"output data (%\" GG_SIZE_FMT \")\\n\", out_len);\n\t\tgoto fail;\n\t}\n\tstrm.avail_out = out_len;\n\tstrm.next_out = out;\n\tfor (;;) {\n\t\tret = deflate(&strm, Z_FINISH);\n\t\tif (ret == Z_STREAM_END)\n\t\t\tbreak;\n\t\t\n\t\tif (ret == Z_OK) {\n\t\t\tout_len *= 2;\n\t\t\tout2 = realloc(out, out_len);\n\t\t\tif (out2 == NULL) {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"// gg_deflate() not \"\n\t\t\t\t\t\"enough memory for output data (%\"\n\t\t\t\t\tGG_SIZE_FMT \")\\n\", out_len);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tout = out2;\n\t\t\tstrm.avail_out = out_len / 2;\n\t\t\tstrm.next_out = out + out_len / 2;\n\t\t} else {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"// gg_deflate() deflate() \"\n\t\t\t\t\"failed (ret=%d, msg=%s)\\n\", ret,\n\t\t\t\tstrm.msg != NULL ? strm.msg :\n\t\t\t\t\"no error message provided\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tout_len = strm.total_out;\n\tout2 = realloc(out, out_len);\n\tif (out2 == NULL) {\n\t\tgg_debug(GG_DEBUG_MISC, \"// gg_deflate() not enough memory for \"\n\t\t\t\"output data (%\" GG_SIZE_FMT \")\\n\", out_len);\n\t\tgoto fail;\n\t}\n\t*out_lenp = out_len;\n\tdeflateEnd(&strm);\n\treturn out2;\nfail:\n\t*out_lenp = 0;\n\tdeflateEnd(&strm);\n\tfree(out);\n#endif\n\treturn NULL;\n}\n", "bug_type": null, "idx": 95}
{"project": "Pidgin", "target": 0, "func": "void aim__shutdownmodules(OscarData *od)\n{\n\taim_module_t *cur;\n\tfor (cur = (aim_module_t *)od->modlistv; cur; ) {\n\t\taim_module_t *tmp;\n\t\ttmp = cur->next;\n\t\tif (cur->shutdown)\n\t\t\tcur->shutdown(od, cur);\n\t\tg_free(cur);\n\t\tcur = tmp;\n\t}\n\tod->modlistv = NULL;\n\treturn;\n}\n", "bug_type": null, "idx": 96}
{"project": "Pidgin", "target": 0, "func": "static void\nclear_cb(GtkWidget *w, DebugWindow *win)\n{\n\tgtk_imhtml_clear(GTK_IMHTML(win->text));\n#ifdef USE_REGEX\n\tgtk_list_store_clear(win->store);\n#endif \n}\n", "bug_type": null, "idx": 97}
{"project": "Pidgin", "target": 0, "func": "static void destroy_cb(GtkWidget *w, gint resp, struct log_viewer_hash_t *ht) {\n\tPidginLogViewer *lv = syslog_viewer;\n#ifdef _WIN32\n\tif (resp == GTK_RESPONSE_HELP) {\n\t\tGtkTreeSelection *sel;\n\t\tGtkTreeIter iter;\n\t\tGtkTreeModel *model;\n\t\tPurpleLog *log = NULL;\n\t\tchar *logdir;\n\t\tif (ht != NULL)\n\t\t\tlv = g_hash_table_lookup(log_viewers, ht);\n\t\tmodel = GTK_TREE_MODEL(lv->treestore);\n\t\tsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(lv->treeview));\n\t\tif (gtk_tree_selection_get_selected(sel, &model, &iter)) {\n\t\t\tGValue val;\n\t\t\tval.g_type = 0;\n\t\t\tgtk_tree_model_get_value (model, &iter, 1, &val);\n\t\t\tlog = g_value_get_pointer(&val);\n\t\t\tg_value_unset(&val);\n\t\t}\n\t\tif (log == NULL)\n\t\t\tlogdir = g_build_filename(purple_user_dir(), \"logs\", NULL);\n\t\telse\n\t\t\tlogdir = purple_log_get_log_dir(log->type, log->name, log->account);\n\t\twinpidgin_shell_execute(logdir, \"explore\", NULL);\n\t\tg_free(logdir);\n\t\treturn;\n\t}\n#endif\n\tif (ht != NULL) {\n\t\tlv = g_hash_table_lookup(log_viewers, ht);\n\t\tg_hash_table_remove(log_viewers, ht);\n\t\tg_free(ht->buddyname);\n\t\tg_free(ht);\n\t} else\n\t\tsyslog_viewer = NULL;\n\tpurple_request_close_with_handle(lv);\n\tg_list_foreach(lv->logs, (GFunc)purple_log_free, NULL);\n\tg_list_free(lv->logs);\n\tg_free(lv->search);\n\tg_free(lv);\n\tgtk_widget_destroy(w);\n}\n", "bug_type": null, "idx": 98}
{"project": "Pidgin", "target": 0, "func": "static inline size_t\nfixed64_pack(uint64_t value, void *out)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, &value, 8);\n#else\n\tfixed32_pack(value, out);\n\tfixed32_pack(value >> 32, ((char *) out) + 4);\n#endif\n\treturn 8;\n}\n", "bug_type": null, "idx": 99}
{"project": "Pidgin", "target": 0, "func": "PurpleRequestField *\npurple_request_field_account_new(const char *id, const char *text,\n\t\t\t\t\t\t\t   PurpleAccount *account)\n{\n\tPurpleRequestField *field;\n\tg_return_val_if_fail(id   != NULL, NULL);\n\tg_return_val_if_fail(text != NULL, NULL);\n\tfield = purple_request_field_new(id, text, PURPLE_REQUEST_FIELD_ACCOUNT);\n\tif (account == NULL && purple_connections_get_all() != NULL)\n\t{\n\t\taccount = purple_connection_get_account(\n\t\t\t(PurpleConnection *)purple_connections_get_all()->data);\n\t}\n\tpurple_request_field_account_set_default_value(field, account);\n\tpurple_request_field_account_set_value(field, account);\n\treturn field;\n}\n", "bug_type": null, "idx": 100}
{"project": "Pidgin", "target": 0, "func": "void\ngnt_widget_get_position(GntWidget *wid, int *x, int *y)\n{\n\tif (x)\n\t\t*x = wid->priv.x;\n\tif (y)\n\t\t*y = wid->priv.y;\n}\n", "bug_type": null, "idx": 101}
{"project": "Pidgin", "target": 0, "func": "static guint gnt_input_add(gint fd, PurpleInputCondition condition, PurpleInputFunction function,\n\t\t\t\t\t\t\t   gpointer data)\n{\n\tPurpleGntIOClosure *closure = g_new0(PurpleGntIOClosure, 1);\n\tGIOChannel *channel;\n\tGIOCondition cond = 0;\n\tclosure->function = function;\n\tclosure->data = data;\n\tif (condition & PURPLE_INPUT_READ)\n\t\tcond |= FINCH_READ_COND;\n\tif (condition & PURPLE_INPUT_WRITE)\n\t\tcond |= FINCH_WRITE_COND;\n\tchannel = g_io_channel_unix_new(fd);\n\tclosure->result = g_io_add_watch_full(channel, G_PRIORITY_DEFAULT, cond,\n\t\t\t\t\t      purple_gnt_io_invoke, closure, purple_gnt_io_destroy);\n\tg_io_channel_unref(channel);\n\treturn closure->result;\n}\n", "bug_type": null, "idx": 102}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nlocal_read_fn(const char *path, GList **files, GError **error)\n{\n\tGDir *dir;\n\tGntFile *file;\n\tconst char *str;\n\tdir = g_dir_open(path, 0, error);\n\tif (dir == NULL || (error && *error)) {\n\t\treturn FALSE;\n\t}\n\t*files = NULL;\n\tif (*path != '\\0' && strcmp(path, G_DIR_SEPARATOR_S)) {\n\t\tfile = gnt_file_new_dir(\"..\");\n\t\t*files = g_list_prepend(*files, file);\n\t}\n\twhile ((str = g_dir_read_name(dir)) != NULL) {\n\t\tchar *fp = g_build_filename(path, str, NULL);\n\t\tstruct stat st;\n\t\tif (stat(fp, &st)) {\n\t\t\tgnt_warning(\"Error stating location %s\", fp);\n\t\t} else {\n\t\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\t\tfile = gnt_file_new_dir(str);\n\t\t\t} else {\n\t\t\t\tfile = gnt_file_new(str, (long)st.st_size);\n\t\t\t}\n\t\t\t*files = g_list_prepend(*files, file);\n\t\t}\n\t\tg_free(fp);\n\t}\n\tg_dir_close(dir);\n\t*files = g_list_reverse(*files);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 103}
{"project": "Pidgin", "target": 1, "func": "int gg_http_watch_fd(struct gg_http *h)\n{\n\tgg_debug(GG_DEBUG_FUNCTION, \"** gg_http_watch_fd(%p);\\n\", h);\n\tif (!h) {\n\t\tgg_debug(GG_DEBUG_MISC, \"// gg_http_watch_fd() invalid arguments\\n\");\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\tif (h->state == GG_STATE_RESOLVING) {\n\t\tstruct in_addr a;\n\t\tgg_debug(GG_DEBUG_MISC, \"=> http, resolving done\\n\");\n\t\tif (read(h->fd, &a, sizeof(a)) < (signed)sizeof(a) || a.s_addr == INADDR_NONE) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, resolver thread failed\\n\");\n\t\t\tgg_http_error(GG_ERROR_RESOLVING);\n\t\t}\n\t\tclose(h->fd);\n\t\th->fd = -1;\n\t\th->resolver_cleanup(&h->resolver, 0);\n\t\tgg_debug(GG_DEBUG_MISC, \"=> http, connecting to %s:%d\\n\", inet_ntoa(a), h->port);\n\t\tif ((h->fd = gg_connect(&a, h->port, h->async)) == -1) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, connection failed (errno=%d, %s)\\n\", errno, strerror(errno));\n\t\t\tgg_http_error(GG_ERROR_CONNECTING);\n\t\t}\n\t\th->state = GG_STATE_CONNECTING;\n\t\th->check = GG_CHECK_WRITE;\n\t\th->timeout = GG_DEFAULT_TIMEOUT;\n\t\treturn 0;\n\t}\n\tif (h->state == GG_STATE_CONNECTING) {\n\t\tint res = 0;\n\t\tsocklen_t res_size = sizeof(res);\n\t\tif (h->async && (getsockopt(h->fd, SOL_SOCKET, SO_ERROR, &res, &res_size) || res)) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, async connection failed (errno=%d, %s)\\n\", (res) ? res : errno , strerror((res) ? res : errno));\n\t\t\tclose(h->fd);\n\t\t\th->fd = -1;\n\t\t\th->state = GG_STATE_ERROR;\n\t\t\th->error = GG_ERROR_CONNECTING;\n\t\t\tif (res)\n\t\t\t\terrno = res;\n\t\t\treturn 0;\n\t\t}\n\t\tgg_debug(GG_DEBUG_MISC, \"=> http, connected, sending request\\n\");\n\t\th->state = GG_STATE_SENDING_QUERY;\n\t}\n\tif (h->state == GG_STATE_SENDING_QUERY) {\n\t\tsize_t res;\n\t\tif ((res = write(h->fd, h->query, strlen(h->query))) < 1) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, write() failed (len=%d, res=%d, errno=%d)\\n\", strlen(h->query), res, errno);\n\t\t\tgg_http_error(GG_ERROR_WRITING);\n\t\t}\n\t\tif (res < strlen(h->query)) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, partial header sent (led=%d, sent=%d)\\n\", strlen(h->query), res);\n\t\t\tmemmove(h->query, h->query + res, strlen(h->query) - res + 1);\n\t\t\th->state = GG_STATE_SENDING_QUERY;\n\t\t\th->check = GG_CHECK_WRITE;\n\t\t\th->timeout = GG_DEFAULT_TIMEOUT;\n\t\t} else {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, request sent (len=%d)\\n\", strlen(h->query));\n\t\t\tfree(h->query);\n\t\t\th->query = NULL;\n\t\t\th->state = GG_STATE_READING_HEADER;\n\t\t\th->check = GG_CHECK_READ;\n\t\t\th->timeout = GG_DEFAULT_TIMEOUT;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (h->state == GG_STATE_READING_HEADER) {\n\t\tchar buf[1024], *tmp;\n\t\tint res;\n\t\tif ((res = read(h->fd, buf, sizeof(buf))) == -1) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, reading header failed (errno=%d)\\n\", errno);\n\t\t\tif (h->header) {\n\t\t\t\tfree(h->header);\n\t\t\t\th->header = NULL;\n\t\t\t}\n\t\t\tgg_http_error(GG_ERROR_READING);\n\t\t}\n\t\tif (!res) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, connection reset by peer\\n\");\n\t\t\tif (h->header) {\n\t\t\t\tfree(h->header);\n\t\t\t\th->header = NULL;\n\t\t\t}\n\t\t\tgg_http_error(GG_ERROR_READING);\n\t\t}\n\t\tgg_debug(GG_DEBUG_MISC, \"=> http, read %d bytes of header\\n\", res);\n\t\tif (!(tmp = realloc(h->header, h->header_size + res + 1))) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, not enough memory for header\\n\");\n\t\t\tfree(h->header);\n\t\t\th->header = NULL;\n\t\t\tgg_http_error(GG_ERROR_READING);\n\t\t}\n\t\th->header = tmp;\n\t\tmemcpy(h->header + h->header_size, buf, res);\n\t\th->header_size += res;\n\t\tgg_debug(GG_DEBUG_MISC, \"=> http, header_buf=%p, header_size=%d\\n\", h->header, h->header_size);\n\t\th->header[h->header_size] = 0;\n\t\tif ((tmp = strstr(h->header, \"\\r\\n\\r\\n\")) || (tmp = strstr(h->header, \"\\n\\n\"))) {\n\t\t\tint sep_len = (*tmp == '\\r') ? 4 : 2;\n\t\t\tunsigned int left;\n\t\t\tchar *line;\n\t\t\tleft = h->header_size - ((long)(tmp) - (long)(h->header) + sep_len);\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, got all header (%d bytes, %d left)\\n\", h->header_size - left, left);\n\t\t\t\n\t\t\tif (strlen(h->header) < 16 || strncmp(h->header + 9, \"200\", 3)) {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> -----BEGIN-HTTP-HEADER-----\\n%s\\n=> -----END-HTTP-HEADER-----\\n\", h->header);\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, didn't get 200 OK -- no results\\n\");\n\t\t\t\tfree(h->header);\n\t\t\t\th->header = NULL;\n\t\t\t\tgg_http_error(GG_ERROR_CONNECTING);\n\t\t\t}\n\t\t\th->body_size = 0;\n\t\t\tline = h->header;\n\t\t\t*tmp = 0;\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> -----BEGIN-HTTP-HEADER-----\\n%s\\n=> -----END-HTTP-HEADER-----\\n\", h->header);\n\t\t\twhile (line) {\n\t\t\t\tif (!strncasecmp(line, \"Content-length: \", 16)) {\n\t\t\t\t\th->body_size = atoi(line + 16);\n\t\t\t\t}\n\t\t\t\tline = strchr(line, '\\n');\n\t\t\t\tif (line)\n\t\t\t\t\tline++;\n\t\t\t}\n\t\t\tif (h->body_size <= 0) {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, content-length not found\\n\");\n\t\t\t\th->body_size = left;\n\t\t\t}\n\t\t\tif (left > h->body_size) {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, oversized reply (%d bytes needed, %d bytes left)\\n\", h->body_size, left);\n\t\t\t\th->body_size = left;\n\t\t\t}\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, body_size=%d\\n\", h->body_size);\n\t\t\tif (!(h->body = malloc(h->body_size + 1))) {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, not enough memory (%d bytes for body_buf)\\n\", h->body_size + 1);\n\t\t\t\tfree(h->header);\n\t\t\t\th->header = NULL;\n\t\t\t\tgg_http_error(GG_ERROR_READING);\n\t\t\t}\n\t\t\tif (left) {\n\t\t\t\tmemcpy(h->body, tmp + sep_len, left);\n\t\t\t\th->body_done = left;\n\t\t\t}\n\t\t\th->body[left] = 0;\n\t\t\th->state = GG_STATE_READING_DATA;\n\t\t\th->check = GG_CHECK_READ;\n\t\t\th->timeout = GG_DEFAULT_TIMEOUT;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (h->state == GG_STATE_READING_DATA) {\n\t\tchar buf[1024];\n\t\tint res;\n\t\tif ((res = read(h->fd, buf, sizeof(buf))) == -1) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, reading body failed (errno=%d)\\n\", errno);\n\t\t\tif (h->body) {\n\t\t\t\tfree(h->body);\n\t\t\t\th->body = NULL;\n\t\t\t}\n\t\t\tgg_http_error(GG_ERROR_READING);\n\t\t}\n\t\tif (!res) {\n\t\t\tif (h->body_done >= h->body_size) {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, we're done, closing socket\\n\");\n\t\t\t\th->state = GG_STATE_PARSING;\n\t\t\t\tclose(h->fd);\n\t\t\t\th->fd = -1;\n\t\t\t} else {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, connection closed while reading (have %d, need %d)\\n\", h->body_done, h->body_size);\n\t\t\t\tif (h->body) {\n\t\t\t\t\tfree(h->body);\n\t\t\t\t\th->body = NULL;\n\t\t\t\t}\n\t\t\t\tgg_http_error(GG_ERROR_READING);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tgg_debug(GG_DEBUG_MISC, \"=> http, read %d bytes of body\\n\", res);\n\t\tif (h->body_done + res > h->body_size) {\n\t\t\tchar *tmp;\n\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, too much data (%d bytes, %d needed), enlarging buffer\\n\", h->body_done + res, h->body_size);\n\t\t\tif (!(tmp = realloc(h->body, h->body_done + res + 1))) {\n\t\t\t\tgg_debug(GG_DEBUG_MISC, \"=> http, not enough memory for data (%d needed)\\n\", h->body_done + res + 1);\n\t\t\t\tfree(h->body);\n\t\t\t\th->body = NULL;\n\t\t\t\tgg_http_error(GG_ERROR_READING);\n\t\t\t}\n\t\t\th->body = tmp;\n\t\t\th->body_size = h->body_done + res;\n\t\t}\n\t\th->body[h->body_done + res] = 0;\n\t\tmemcpy(h->body + h->body_done, buf, res);\n\t\th->body_done += res;\n\t\tgg_debug(GG_DEBUG_MISC, \"=> body_done=%d, body_size=%d\\n\", h->body_done, h->body_size);\n\t\treturn 0;\n\t}\n\tif (h->fd != -1)\n\t\tclose(h->fd);\n\th->fd = -1;\n\th->state = GG_STATE_ERROR;\n\th->error = 0;\n\treturn -1;\n}\n", "bug_type": "CVE-2013-6487", "idx": 104}
{"project": "Pidgin", "target": 0, "func": "#include \"internal.h\"\nstruct gg_http *gg_userlist_get(uin_t uin, const char *passwd, int async)\n{\n\tgg_debug(GG_DEBUG_MISC, \"// gg_userlist_get() is obsolete. use gg_userlist_request() instead!\\n\");\n\terrno = EINVAL;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 105}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nget_rect_of_window_multimonitor(HWND window, RECT *rect) {\n\tHMODULE hmod;\n\tpurple_MonitorFromWindow *the_MonitorFromWindow;\n\tHMONITOR monitor;\n\tif (!(hmod = GetModuleHandle(\"user32\"))) {\n\t\treturn FALSE;\n\t}\n\tif (!(the_MonitorFromWindow = (purple_MonitorFromWindow*)\n\t\tGetProcAddress(hmod, \"MonitorFromWindow\"))) {\n\t\treturn FALSE;\n\t}\n\tmonitor =\n\t\tthe_MonitorFromWindow(window, MONITOR_DEFAULTTOPRIMARY);\n\treturn get_rect_from_monitor(hmod, monitor, rect);\n}\n", "bug_type": null, "idx": 106}
{"project": "Pidgin", "target": 0, "func": "gboolean\npidgin_roomlist_is_showable()\n{\n\tGList *c;\n\tPurpleConnection *gc;\n\tfor (c = purple_connections_get_all(); c != NULL; c = c->next) {\n\t\tgc = c->data;\n\t\tif (account_filter_func(purple_connection_get_account(gc)))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 107}
{"project": "Pidgin", "target": 0, "func": "static void nullprpl_add_buddy(PurpleConnection *gc, PurpleBuddy *buddy,\n                               PurpleGroup *group)\n{\n  const char *username = gc->account->username;\n  PurpleConnection *buddy_gc = get_nullprpl_gc(buddy->name);\n  purple_debug_info(\"nullprpl\", \"adding %s to %s's buddy list\\n\", buddy->name,\n                    username);\n  if (buddy_gc) {\n    PurpleAccount *buddy_acct = buddy_gc->account;\n    discover_status(gc, buddy_gc, NULL);\n    if (purple_find_buddy(buddy_acct, username)) {\n      purple_debug_info(\"nullprpl\", \"%s is already on %s's buddy list\\n\",\n                        username, buddy->name);\n    } else {\n      purple_debug_info(\"nullprpl\", \"asking %s if they want to add %s\\n\",\n                        buddy->name, username);\n      purple_account_request_add(buddy_acct,\n                                 username,\n                                 NULL,   \n                                 NULL,   \n                                 NULL);  \n    }\n  }\n}\n", "bug_type": null, "idx": 108}
{"project": "Pidgin", "target": 0, "func": "static GHashTable *\nicq_get_account_text_table(PurpleAccount *account)\n{\n\tGHashTable *table;\n\ttable = g_hash_table_new(g_str_hash, g_str_equal);\n\tg_hash_table_insert(table, \"login_label\", (gpointer)_(\"ICQ UIN...\"));\n\treturn table;\n}\n", "bug_type": null, "idx": 109}
{"project": "Pidgin", "target": 0, "func": "static void\nparse_idle(JabberStream *js, JabberPresence *presence, xmlnode *query)\n{\n\tconst gchar *seconds = xmlnode_get_attrib(query, \"seconds\");\n\tif (seconds) {\n\t\tpresence->idle = atoi(seconds);\n\t\tif (presence->idle < 0) {\n\t\t\tpurple_debug_warning(\"jabber\", \"Received bogus idle time %s\\n\", seconds);\n\t\t\tpresence->idle = 0;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 110}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int parsedel(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tint ret = 0;\n\taim_rxcallback_t userfunc;\n\tguint16 gid, bid;\n\tstruct aim_ssi_item *del;\n\twhile (byte_stream_bytes_left(bs)) {\n\t\tbyte_stream_advance(bs, byte_stream_get16(bs));\n\t\tgid = byte_stream_get16(bs);\n\t\tbid = byte_stream_get16(bs);\n\t\tbyte_stream_get16(bs);\n\t\tbyte_stream_advance(bs, byte_stream_get16(bs));\n\t\tif ((del = aim_ssi_itemlist_find(od->ssi.local, gid, bid)))\n\t\t\taim_ssi_itemlist_del(&od->ssi.local, del);\n\t\tif ((del = aim_ssi_itemlist_find(od->ssi.official, gid, bid)))\n\t\t\taim_ssi_itemlist_del(&od->ssi.official, del);\n\t\tif ((userfunc = aim_callhandler(od, snac->family, snac->subtype)))\n\t\t\tret = userfunc(od, conn, frame);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 111}
{"project": "Pidgin", "target": 0, "func": "static void\ninsert_anchor (GtkTextBuffer *buffer, gint pos, GtkTextChildAnchor *anchor)\n{\n\tGtkTextIter iter;\n\tgtk_text_buffer_get_iter_at_offset (buffer, &iter, pos);\n\tgtk_text_buffer_insert_child_anchor (buffer, &iter, anchor);\n}\n", "bug_type": null, "idx": 112}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_bosh_disable_pipelining(PurpleBOSHConnection *bosh)\n{\n\t\n\tif (!bosh->pipelining)\n\t\treturn;\n\tpurple_debug_info(\"jabber\", \"BOSH: Disabling pipelining on conn %p\\n\",\n\t                            bosh);\n\tbosh->pipelining = FALSE;\n\tif (bosh->connections[1] == NULL) {\n\t\tbosh->connections[1] = jabber_bosh_http_connection_init(bosh);\n\t\thttp_connection_connect(bosh->connections[1]);\n\t} else {\n\t\t\n\t\tg_warn_if_reached();\n\t}\n}\n", "bug_type": null, "idx": 113}
{"project": "Pidgin", "target": 0, "func": " **********************************************************************************/\nstatic void pidgin_blist_new_list(PurpleBuddyList *blist)\n{\n\tPidginBuddyList *gtkblist;\n\tgtkblist = g_new0(PidginBuddyList, 1);\n\tgtkblist->connection_errors = g_hash_table_new_full(g_direct_hash,\n\t\t\t\t\t\t\t\t\t\t\t\tg_direct_equal, NULL, g_free);\n\tgtkblist->priv = g_new0(PidginBuddyListPrivate, 1);\n\tblist->ui_data = gtkblist;\n}\n", "bug_type": null, "idx": 114}
{"project": "Pidgin", "target": 0, "func": "static void\naccount_connecting_cb(PurpleAccount *account, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"account-connecting (%s)\\n\",\n\t\t\t\t\tpurple_account_get_username(account));\n}\n", "bug_type": null, "idx": 115}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conv_chat_cb_destroy(PurpleConvChatBuddy *cb)\n{\n\tif (cb == NULL)\n\t\treturn;\n\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\"deleting-chat-buddy\", cb);\n\tg_free(cb->alias);\n\tg_free(cb->alias_key);\n\tg_free(cb->name);\n\tg_hash_table_destroy(cb->attributes);\n\tPURPLE_DBUS_UNREGISTER_POINTER(cb);\n\tg_free(cb);\n}\n", "bug_type": null, "idx": 116}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_blist_theme_class_init(PidginBlistThemeClass *klass)\n{\n\tGObjectClass *obj_class = G_OBJECT_CLASS(klass);\n\tGParamSpec *pspec;\n\tparent_class = g_type_class_peek_parent (klass);\n\tobj_class->get_property = pidgin_blist_theme_get_property;\n\tobj_class->set_property = pidgin_blist_theme_set_property;\n\tobj_class->finalize = pidgin_blist_theme_finalize;\n\t\n\tpspec = g_param_spec_boxed(\"background-color\", _(\"Background Color\"),\n\t\t\t_(\"The background color for the buddy list\"),\n\t\t\tGDK_TYPE_COLOR, G_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_BACKGROUND_COLOR, pspec);\n\tpspec = g_param_spec_pointer(\"layout\", _(\"Layout\"),\n\t\t\t_(\"The layout of icons, name, and status of the buddy list\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_LAYOUT, pspec);\n\t\n\t\n\tpspec = g_param_spec_boxed(\"expanded-color\", _(\"Expanded Background Color\"),\n\t\t\t_(\"The background color of an expanded group\"),\n\t\t\tGDK_TYPE_COLOR, G_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_EXPANDED_COLOR, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"expanded-text\", _(\"Expanded Text\"),\n\t\t\t_(\"The text information for when a group is expanded\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_EXPANDED_TEXT, pspec);\n\t\n\tpspec = g_param_spec_boxed(\"collapsed-color\", _(\"Collapsed Background Color\"),\n\t\t\t_(\"The background color of a collapsed group\"),\n\t\t\tGDK_TYPE_COLOR, G_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_COLLAPSED_COLOR, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"collapsed-text\", _(\"Collapsed Text\"),\n\t\t\t_(\"The text information for when a group is collapsed\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_COLLAPSED_TEXT, pspec);\n\t\n\t\n\tpspec = g_param_spec_boxed(\"contact-color\", _(\"Contact/Chat Background Color\"),\n\t\t\t_(\"The background color of a contact or chat\"),\n\t\t\tGDK_TYPE_COLOR, G_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_CONTACT_COLOR, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"contact\", _(\"Contact Text\"),\n\t\t\t_(\"The text information for when a contact is expanded\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_CONTACT, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"online\", _(\"Online Text\"),\n\t\t\t_(\"The text information for when a buddy is online\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_ONLINE, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"away\", _(\"Away Text\"),\n\t\t\t_(\"The text information for when a buddy is away\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_AWAY, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"offline\", _(\"Offline Text\"),\n\t\t\t_(\"The text information for when a buddy is offline\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_OFFLINE, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"idle\", _(\"Idle Text\"),\n\t\t\t_(\"The text information for when a buddy is idle\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_IDLE, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"message\", _(\"Message Text\"),\n\t\t\t_(\"The text information for when a buddy has an unread message\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_MESSAGE, pspec);\n\t\n\tpspec = g_param_spec_pointer(\"message_nick_said\", _(\"Message (Nick Said) Text\"),\n\t\t\t_(\"The text information for when a chat has an unread message that mentions your nickname\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_MESSAGE_NICK_SAID, pspec);\n\tpspec = g_param_spec_pointer(\"status\", _(\"Status Text\"),\n\t\t\t_(\"The text information for a buddy's status\"),\n\t\t\tG_PARAM_READWRITE);\n\tg_object_class_install_property(obj_class, PROP_STATUS, pspec);\n}\n", "bug_type": null, "idx": 117}
{"project": "Pidgin", "target": 0, "func": "void\naim_srv_set_dc_info(OscarData *od)\n{\n\tFlapConnection *conn;\n\tByteStream bs, tlv0c;\n\taim_snacid_t snacid;\n\tGSList *tlvlist = NULL;\n\t\n\tbyte_stream_new(&tlv0c, 4*2 + 1 + 2 + 4*6 + 2);\n\tbyte_stream_put32(&tlv0c, 0x0);\n\tbyte_stream_put32(&tlv0c, 0x0);\n\tbyte_stream_put8(&tlv0c, 0x0); \n\tbyte_stream_put16(&tlv0c, 8); \n\tbyte_stream_put32(&tlv0c, 0x0);\n\tbyte_stream_put32(&tlv0c, 0x50);\n\tbyte_stream_put32(&tlv0c, 0x3);\n\tbyte_stream_put32(&tlv0c, 0x0);\n\tbyte_stream_put32(&tlv0c, 0x0);\n\tbyte_stream_put32(&tlv0c, 0x0);\n\tbyte_stream_put16(&tlv0c, 0x0);\n\taim_tlvlist_add_raw(&tlvlist, 0x000c, byte_stream_curpos(&tlv0c), tlv0c.data);\n\tbyte_stream_destroy(&tlv0c);\n\tbyte_stream_new(&bs, aim_tlvlist_size(tlvlist));\n\taim_tlvlist_write(&bs, &tlvlist);\n\taim_tlvlist_free(tlvlist);\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_OSERVICE, 0x001e, 0x0000, NULL, 0);\n\tconn = flap_connection_findbygroup(od, SNAC_FAMILY_ICBM);\n\tg_warn_if_fail(conn != NULL);\n\tif (conn) {\n\t\tflap_connection_send_snac(od, conn, SNAC_FAMILY_OSERVICE,\n\t\t\t0x001e, snacid, &bs);\n\t}\n\tbyte_stream_destroy(&bs);\n}\n", "bug_type": null, "idx": 118}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_savedstatus_unset_all_substatuses(const PurpleAccount *account,\n\t\tgpointer user_data)\n{\n\tGList *iter;\n\tPurpleSavedStatus *status;\n\tg_return_if_fail(account != NULL);\n\tfor (iter = saved_statuses; iter != NULL; iter = iter->next)\n\t{\n\t\tstatus = (PurpleSavedStatus *)iter->data;\n\t\tpurple_savedstatus_unset_substatus(status, account);\n\t}\n}\n", "bug_type": null, "idx": 119}
{"project": "Pidgin", "target": 0, "func": "static void\njingle_session_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)\n{\n\tJingleSession *session;\n\tg_return_if_fail(object != NULL);\n\tg_return_if_fail(JINGLE_IS_SESSION(object));\n\tsession = JINGLE_SESSION(object);\n\tswitch (prop_id) {\n\t\tcase PROP_SID:\n\t\t\tg_free(session->priv->sid);\n\t\t\tsession->priv->sid = g_value_dup_string(value);\n\t\t\tbreak;\n\t\tcase PROP_JS:\n\t\t\tsession->priv->js = g_value_get_pointer(value);\n\t\t\tbreak;\n\t\tcase PROP_REMOTE_JID:\n\t\t\tg_free(session->priv->remote_jid);\n\t\t\tsession->priv->remote_jid = g_value_dup_string(value);\n\t\t\tbreak;\n\t\tcase PROP_LOCAL_JID:\n\t\t\tg_free(session->priv->local_jid);\n\t\t\tsession->priv->local_jid = g_value_dup_string(value);\n\t\t\tbreak;\n\t\tcase PROP_IS_INITIATOR:\n\t\t\tsession->priv->is_initiator = g_value_get_boolean(value);\n\t\t\tbreak;\n\t\tcase PROP_STATE:\n\t\t\tsession->priv->state = g_value_get_boolean(value);\n\t\t\tbreak;\n\t\tcase PROP_CONTENTS:\n\t\t\tsession->priv->contents = g_value_get_pointer(value);\n\t\t\tbreak;\n\t\tcase PROP_PENDING_CONTENTS:\n\t\t\tsession->priv->pending_contents = g_value_get_pointer(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 120}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_set_connection(PurpleAccount *account, PurpleConnection *gc)\n{\n\tg_return_if_fail(account != NULL);\n\taccount->gc = gc;\n}\n", "bug_type": null, "idx": 121}
{"project": "Pidgin", "target": 0, "func": "static void insert_cap_success(CapStatistics *stats) {\n\tgchar *buddy_name = stats->buddy->name;\n\tconst gchar *protocol_id = purple_account_get_protocol_id(stats->buddy->account);\n\tconst gchar *account_id = purple_account_get_username(stats->buddy->account);\n\tconst gchar *status_id = (stats->last_message_status_id) ?\n\t\tstats->last_message_status_id :\n\t\tpurple_status_get_id(get_status_for(stats->buddy));\n\tstruct tm *current_time;\n\tint minute;\n\tif(stats->last_message == -1) {\n\t\ttime_t now = time(NULL);\n\t\tcurrent_time = localtime(&now);\n\t} else {\n\t\tcurrent_time = localtime(&stats->last_message);\n\t}\n\tminute = current_time->tm_min + current_time->tm_hour * 60;\n\tinsert_cap_msg_count_success(buddy_name, account_id, protocol_id, minute);\n\tinsert_cap_status_count_success(buddy_name, account_id, protocol_id, status_id);\n\tstats->last_message = -1;\n\tstats->last_message_status_id = NULL;\n}\n", "bug_type": null, "idx": 122}
{"project": "Pidgin", "target": 0, "func": "static SV *\ncreate_sv_ptr(void *object)\n{\n\tSV *sv;\n\tsv = newSViv((IV)object);\n\tsv_magic(sv, NULL, '~', NULL, 0);\n\tSvMAGIC(sv)->mg_private = 0x1551; \n\tSvMAGIC(sv)->mg_virtual = &vtbl_free_object;\n\treturn sv;\n}\n", "bug_type": null, "idx": 123}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_xfer_cancel_local(PurpleXfer *xfer)\n{\n\tif (xfer_dialog)\n\t\tpidgin_xfer_dialog_cancel_xfer(xfer_dialog, xfer);\n}\n", "bug_type": null, "idx": 124}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_core_init(const char *ui)\n{\n\tPurpleCoreUiOps *ops;\n\tPurpleCore *core;\n\tg_return_val_if_fail(ui != NULL, FALSE);\n\tg_return_val_if_fail(purple_get_core() == NULL, FALSE);\n#ifdef ENABLE_NLS\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n#endif\n#ifdef _WIN32\n\twpurple_init();\n#endif\n#if !GLIB_CHECK_VERSION(2, 36, 0)\n\t\n\tg_type_init();\n#endif\n\t_core = core = g_new0(PurpleCore, 1);\n\tcore->ui = g_strdup(ui);\n\tcore->reserved = NULL;\n\tops = purple_core_get_ui_ops();\n\t\n\tpurple_signals_init();\n\tpurple_util_init();\n\tpurple_signal_register(core, \"uri-handler\",\n\t\tpurple_marshal_BOOLEAN__POINTER_POINTER_POINTER,\n\t\tpurple_value_new(PURPLE_TYPE_BOOLEAN), 3,\n\t\tpurple_value_new(PURPLE_TYPE_STRING), \n\t\tpurple_value_new(PURPLE_TYPE_STRING), \n\t\tpurple_value_new(PURPLE_TYPE_BOXED, \"GHashTable *\")); \n\tpurple_signal_register(core, \"quitting\", purple_marshal_VOID, NULL, 0);\n\t\n\tpurple_prefs_init();\n\tpurple_debug_init();\n\tif (ops != NULL)\n\t{\n\t\tif (ops->ui_prefs_init != NULL)\n\t\t\tops->ui_prefs_init();\n\t\tif (ops->debug_ui_init != NULL)\n\t\t\tops->debug_ui_init();\n\t}\n#ifdef HAVE_DBUS\n\tpurple_dbus_init();\n#endif\n\tpurple_ciphers_init();\n\tpurple_cmds_init();\n\t\n\tpurple_plugins_init();\n\t\n\tstatic_proto_init();\n\tpurple_plugins_probe(G_MODULE_SUFFIX);\n\tpurple_theme_manager_init();\n\t\n\tpurple_imgstore_init();\n\t\n\tpurple_status_init();\n\tpurple_buddy_icons_init();\n\tpurple_connections_init();\n\tpurple_accounts_init();\n\tpurple_savedstatuses_init();\n\tpurple_notify_init();\n\tpurple_certificate_init();\n\tpurple_conversations_init();\n\tpurple_blist_init();\n\tpurple_log_init();\n\tpurple_network_init();\n\tpurple_privacy_init();\n\tpurple_pounces_init();\n\tpurple_proxy_init();\n\tpurple_dnsquery_init();\n\tpurple_sound_init();\n\tpurple_ssl_init();\n\tpurple_stun_init();\n\tpurple_xfers_init();\n\tpurple_idle_init();\n\tpurple_smileys_init();\n\t\n\tpurple_network_get_my_ip(-1);\n\tif (ops != NULL && ops->ui_init != NULL)\n\t\tops->ui_init();\n\t\n\tpurple_theme_manager_refresh();\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 125}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_box_init(GTypeInstance *instance, gpointer class)\n{\n\tGntWidget *widget = GNT_WIDGET(instance);\n\tGntBox *box = GNT_BOX(widget);\n\t\n\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_GROW_X | GNT_WIDGET_GROW_Y);\n\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_CAN_TAKE_FOCUS | GNT_WIDGET_DISABLE_ACTIONS);\n\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_NO_BORDER | GNT_WIDGET_NO_SHADOW);\n\tbox->pad = 1;\n\tbox->fill = TRUE;\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 126}
{"project": "Pidgin", "target": 0, "func": "static void\nhandle_present(PurpleConversation *conv)\n{\n\tif (pidgin_conv_is_hidden(PIDGIN_CONVERSATION(conv)))\n\t\treturn;\n\tpurple_conversation_present(conv);\n}\n", "bug_type": null, "idx": 127}
{"project": "Pidgin", "target": 0, "func": "void\njabber_gmail_poke(JabberStream *js, const char *from, JabberIqType type,\n                  const char *id, xmlnode *new_mail)\n{\n\txmlnode *query;\n\tJabberIq *iq;\n\t\n\tif (!purple_account_get_check_mail(js->gc->account))\n\t\treturn;\n\t\n\tif (type != JABBER_IQ_SET)\n\t\treturn;\n\t\n\tiq = jabber_iq_new(js, JABBER_IQ_RESULT);\n\tif (from)\n\t\txmlnode_set_attrib(iq->node, \"to\", from);\n\txmlnode_set_attrib(iq->node, \"id\", id);\n\tjabber_iq_send(iq);\n\tpurple_debug_misc(\"jabber\",\n\t\t   \"Got new mail notification. Sending request for more info\\n\");\n\tiq = jabber_iq_new_query(js, JABBER_IQ_GET, NS_GOOGLE_MAIL_NOTIFY);\n\tjabber_iq_set_callback(iq, jabber_gmail_parse, NULL);\n\tquery = xmlnode_get_child(iq->node, \"query\");\n\tif (js->gmail_last_time)\n\t\txmlnode_set_attrib(query, \"newer-than-time\", js->gmail_last_time);\n\tif (js->gmail_last_tid)\n\t\txmlnode_set_attrib(query, \"newer-than-tid\", js->gmail_last_tid);\n\tjabber_iq_send(iq);\n\treturn;\n}\n", "bug_type": null, "idx": 128}
{"project": "Pidgin", "target": 0, "func": "struct gg_http *gg_unregister2(uin_t uin, const char *password, const char *qa, int async)\n{\n\tgg_debug(GG_DEBUG_MISC, \"// gg_unregister2() is obsolete. use gg_unregister3() instead!\\n\");\n\terrno = EINVAL;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 129}
{"project": "Pidgin", "target": 0, "func": "void gnt_tree_adjust_columns(GntTree *tree)\n{\n\tGntTreeRow *row = tree->root;\n\tint *widths, i, twidth;\n\twidths = g_new0(int, tree->ncol);\n\twhile (row) {\n\t\tGList *iter;\n\t\tfor (i = 0, iter = row->columns; iter; iter = iter->next, i++) {\n\t\t\tGntTreeCol *col = iter->data;\n\t\t\tint w = gnt_util_onscreen_width(col->text, NULL);\n\t\t\tif (i == 0 && row->choice)\n\t\t\t\tw += 4;\n\t\t\tif (i == 0) {\n\t\t\t\tw += find_depth(row) * TAB_SIZE;\n\t\t\t}\n\t\t\tif (widths[i] < w)\n\t\t\t\twidths[i] = w;\n\t\t}\n\t\trow = get_next(row);\n\t}\n\ttwidth = 1 + 2 * (!GNT_WIDGET_IS_FLAG_SET(GNT_WIDGET(tree), GNT_WIDGET_NO_BORDER));\n\tfor (i = 0; i < tree->ncol; i++) {\n\t\tif (tree->columns[i].flags & GNT_TREE_COLUMN_FIXED_SIZE)\n\t\t\twidths[i] = tree->columns[i].width;\n\t\tgnt_tree_set_col_width(tree, i, widths[i]);\n\t\tif (!COLUMN_INVISIBLE(tree, i)) {\n\t\t\ttwidth = twidth + widths[i];\n\t\t\tif (tree->priv->lastvisible != i)\n\t\t\t\ttwidth += 1;\n\t\t}\n\t}\n\tg_free(widths);\n\tgnt_widget_set_size(GNT_WIDGET(tree), twidth, -1);\n}\n", "bug_type": null, "idx": 130}
{"project": "Pidgin", "target": 0, "func": "GList *\ngevo_get_groups(void)\n{\n\tstatic GList *list = NULL;\n\tPurpleGroup *g;\n\tPurpleBlistNode *gnode;\n\tg_list_free(list);\n\tlist = NULL;\n\tif (purple_get_blist()->root == NULL)\n\t{\n\t\tlist  = g_list_append(list, (gpointer)_(\"Buddies\"));\n\t}\n\telse\n\t{\n\t\tfor (gnode = purple_get_blist()->root;\n\t\t\t gnode != NULL;\n\t\t\t gnode = gnode->next)\n\t\t{\n\t\t\tif (PURPLE_BLIST_NODE_IS_GROUP(gnode))\n\t\t\t{\n\t\t\t\tg = (PurpleGroup *)gnode;\n\t\t\t\tlist = g_list_append(list, g->name);\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n", "bug_type": null, "idx": 131}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_accounts_request_add(PurpleAccount *account, const char *remote_user,\n                              const char *id, const char *alias,\n                              const char *msg)\n{\n\tchar *buffer;\n\tPurpleConnection *gc;\n\tPidginAccountAddUserData *data;\n\tGtkWidget *alert;\n\tgc = purple_account_get_connection(account);\n\tdata = g_new0(PidginAccountAddUserData, 1);\n\tdata->account  = account;\n\tdata->username = g_strdup(remote_user);\n\tdata->alias    = g_strdup(alias);\n\tbuffer = make_info(account, gc, remote_user, id, alias, msg);\n\talert = pidgin_make_mini_dialog(gc, PIDGIN_STOCK_DIALOG_QUESTION,\n\t\t\t\t\t  _(\"Add buddy to your list?\"), buffer, data,\n\t\t\t\t\t  _(\"Add\"), G_CALLBACK(add_user_cb),\n\t\t\t\t\t  _(\"Cancel\"), G_CALLBACK(free_add_user_data), NULL);\n\tpidgin_blist_add_alert(alert);\n\tg_free(buffer);\n}\n", "bug_type": null, "idx": 132}
{"project": "Pidgin", "target": 0, "func": "void\n_purple_buddy_icon_set_old_icons_dir(const char *dirname)\n{\n\told_icons_dir = g_strdup(dirname);\n}\n", "bug_type": null, "idx": 133}
{"project": "Pidgin", "target": 0, "func": "static void\nregex_pref_filter_cb(const gchar *name, PurplePrefType type,\n\t\t\t\t\t gconstpointer val, gpointer data)\n{\n\tDebugWindow *win = (DebugWindow *)data;\n\tgboolean active = GPOINTER_TO_INT(val), current;\n\tif(!win || !win->window)\n\t\treturn;\n\tcurrent = gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(win->filter));\n\tif(active != current)\n\t\tgtk_toggle_tool_button_set_active(GTK_TOGGLE_TOOL_BUTTON(win->filter), active);\n}\n", "bug_type": null, "idx": 134}
{"project": "Pidgin", "target": 0, "func": "static void\nunseen_conv_menu(void)\n{\n\tstatic GtkWidget *menu = NULL;\n\tGList *convs = NULL;\n\tGList *chats, *ims;\n\tif (menu) {\n\t\tgtk_widget_destroy(menu);\n\t\tmenu = NULL;\n\t}\n\tims = pidgin_conversations_find_unseen_list(PURPLE_CONV_TYPE_IM,\n\t\t\t\tPIDGIN_UNSEEN_TEXT, FALSE, 0);\n\tchats = pidgin_conversations_find_unseen_list(PURPLE_CONV_TYPE_CHAT,\n\t\t\t\tPIDGIN_UNSEEN_NICK, FALSE, 0);\n\tif(ims && chats)\n\t\tconvs = g_list_concat(ims, chats);\n\telse if(ims && !chats)\n\t\tconvs = ims;\n\telse if(!ims && chats)\n\t\tconvs = chats;\n\tif (!convs)\n\t\t\n\t\treturn;\n\tmenu = gtk_menu_new();\n\tpidgin_conversations_fill_menu(menu, convs);\n\tg_list_free(convs);\n\tgtk_widget_show_all(menu);\n\tgtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 3,\n\t\t\tgtk_get_current_event_time());\n}\n", "bug_type": null, "idx": 135}
{"project": "Pidgin", "target": 0, "func": "static char*\ngenerate_next_id()\n{\n\tstatic guint32 index = 0;\n\tif (index == 0) {\n\t\tdo {\n\t\t\tindex = g_random_int();\n\t\t} while (index == 0);\n\t}\n\treturn g_strdup_printf(\"purpledisco%x\", index++);\n}\n", "bug_type": null, "idx": 136}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_attention_type_get_outgoing_desc(const PurpleAttentionType *type)\n{\n\tg_return_val_if_fail(type != NULL, NULL);\n\treturn type->outgoing_description;\n}\n", "bug_type": null, "idx": 137}
{"project": "Pidgin", "target": 0, "func": "\nstatic void gtk_appbar_setpos(GtkAppBar *ab, HWND hwnd) {\n        APPBARDATA abd;\n        if(!ab->registered)\n                gtk_appbar_register(ab, hwnd);\n\tabd.hWnd = hwnd;\n\tabd.cbSize = sizeof(APPBARDATA);\n        CopyRect(&abd.rc, &(ab->docked_rect));\n\tabd.uEdge = ab->side;\n\tSHAppBarMessage(ABM_SETPOS, &abd);\n}\n", "bug_type": null, "idx": 138}
{"project": "Pidgin", "target": 0, "func": "static GHashTable *\nget_ui_settings_table(PurpleAccount *account, const char *ui)\n{\n\tGHashTable *table;\n\ttable = g_hash_table_lookup(account->ui_settings, ui);\n\tif (table == NULL) {\n\t\ttable = g_hash_table_new_full(g_str_hash, g_str_equal, g_free,\n\t\t\t\t\t\t\t\t\t  delete_setting);\n\t\tg_hash_table_insert(account->ui_settings, g_strdup(ui), table);\n\t}\n\treturn table;\n}\n", "bug_type": null, "idx": 139}
{"project": "Pidgin", "target": 0, "func": "static void\nblist_created_cb(PurpleBuddyList *purple_blist, gpointer data) {\n\tif (blist) {\n\t\tif (purple_prefs_get_bool(OPT_WINTRANS_BL_ENABLED)) {\n\t\t\tset_wintrans(blist,\n\t\t\t\tpurple_prefs_get_int(OPT_WINTRANS_BL_ALPHA),\n\t\t\t\tTRUE,\n\t\t\t\tpurple_prefs_get_bool(OPT_WINTRANS_BL_ONTOP));\n\t\t}\n\t\tg_signal_connect(G_OBJECT(blist), \"focus_in_event\",\n\t\t\tG_CALLBACK(focus_blist_win_cb), blist);\n\t\tg_signal_connect(G_OBJECT(blist), \"focus_out_event\",\n\t\t\tG_CALLBACK(focus_blist_win_cb), blist);\n\t}\n}\nstatic void\nblist_created_cb(PurpleBuddyList *purple_blist, gpointer data) {\n\tif (blist) {\n\t\tif (purple_prefs_get_bool(OPT_WINTRANS_BL_ENABLED)) {\n\t\t\tset_wintrans(blist,\n\t\t\t\tpurple_prefs_get_int(OPT_WINTRANS_BL_ALPHA),\n\t\t\t\tTRUE,\n\t\t\t\tpurple_prefs_get_bool(OPT_WINTRANS_BL_ONTOP));\n\t\t}\n\t\tg_signal_connect(G_OBJECT(blist), \"focus_in_event\",\n\t\t\tG_CALLBACK(focus_blist_win_cb), blist);\n\t\tg_signal_connect(G_OBJECT(blist), \"focus_out_event\",\n\t\t\tG_CALLBACK(focus_blist_win_cb), blist);\n\t}\n}\n", "bug_type": null, "idx": 140}
{"project": "Pidgin", "target": 0, "func": "static int gg_session_handle_chat_invite_ack(struct gg_session *gs,\n\tuint32_t type, const char *ptr, size_t len, struct gg_event *ge)\n{\n\tconst struct gg_chat_invite_ack *p =\n\t\t(const struct gg_chat_invite_ack *)ptr;\n\tge->type = GG_EVENT_CHAT_INVITE_ACK;\n\tge->event.chat_invite_ack.id = gg_fix64(p->id);\n\tge->event.chat_invite_ack.seq = gg_fix32(p->seq);\n\treturn 0;\n}\n", "bug_type": null, "idx": 141}
{"project": "Pidgin", "target": 0, "func": "char *\nxmlnode_get_data_unescaped(const xmlnode *node)\n{\n\tchar *escaped = xmlnode_get_data(node);\n\tchar *unescaped = escaped ? purple_unescape_html(escaped) : NULL;\n\tg_free(escaped);\n\treturn unescaped;\n}\n", "bug_type": null, "idx": 142}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_wm_init(GTypeInstance *instance, gpointer class)\n{\n\tGntWM *wm = GNT_WM(instance);\n\twm->workspaces = NULL;\n\twm->name_places = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\twm->title_places = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\tgnt_style_read_workspaces(wm);\n\tif (wm->workspaces == NULL) {\n\t\twm->cws = gnt_ws_new(\"default\");\n\t\tgnt_wm_add_workspace(wm, wm->cws);\n\t} else {\n\t\twm->cws = wm->workspaces->data;\n\t}\n\twm->event_stack = FALSE;\n\twm->tagged = NULL;\n\twm->windows = NULL;\n\twm->actions = NULL;\n\twm->nodes = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, free_node);\n\twm->positions = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\tif (gnt_style_get_bool(GNT_STYLE_REMPOS, TRUE))\n\t\tread_window_positions(wm);\n\tg_timeout_add_seconds(IDLE_CHECK_INTERVAL, check_idle, NULL);\n\ttime(&last_active_time);\n\tgnt_wm_switch_workspace(wm, 0);\n}\n", "bug_type": null, "idx": 143}
{"project": "Pidgin", "target": 0, "func": "static int\nbonjour_send_im(PurpleConnection *connection, const char *to, const char *msg, PurpleMessageFlags flags)\n{\n\tif(!to || !msg)\n\t\treturn 0;\n\treturn bonjour_jabber_send_message(((BonjourData*)(connection->proto_data))->jabber_data, to, msg);\n}\n", "bug_type": null, "idx": 144}
{"project": "Pidgin", "target": 0, "func": "static void\nsend_file_cb(GntMenuItem *item, gpointer ggconv)\n{\n\tFinchConv *ggc = ggconv;\n\tserv_send_file(purple_conversation_get_gc(ggc->active_conv),\n\t\t\tpurple_conversation_get_name(ggc->active_conv), NULL);\n}\n", "bug_type": null, "idx": 145}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nclose_button_entered_cb(GtkWidget *widget, GdkEventCrossing *event, GtkLabel *label)\n{\n\tstatic GdkCursor *hand = NULL;\n\tif (hand == NULL) {\n\t\thand = gdk_cursor_new(GDK_HAND2);\n\t}\n\tgtk_label_set_markup(label, \"<u>\u00c3\u2014</u>\");\n\tgdk_window_set_cursor(event->window, hand);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 146}
{"project": "Pidgin", "target": 0, "func": "static void\noscar_ask_directim_no_cb(struct oscar_ask_directim_data *data)\n{\n\tg_free(data->who);\n\tg_free(data);\n}\n", "bug_type": null, "idx": 147}
{"project": "Pidgin", "target": 0, "func": "static void jabber_si_xfer_cancel_recv(PurpleXfer *xfer)\n{\n\tJabberSIXfer *jsx = (JabberSIXfer *) xfer->data;\n\t\n\tif (jsx->ibb_session) {\n\t\tjabber_ibb_session_close(jsx->ibb_session);\n\t}\n\tjabber_si_xfer_free(xfer);\n\tpurple_debug_info(\"jabber\", \"in jabber_si_xfer_cancel_recv\\n\");\n}\n", "bug_type": null, "idx": 148}
{"project": "Pidgin", "target": 0, "func": "\n\nvoid ggp_buddylist_load(PurpleConnection *gc, char *buddylist)\n{\n\tPurpleBuddy *buddy;\n\tPurpleGroup *group;\n\tgchar **users_tbl;\n\tint i;\n\tchar *utf8buddylist = charset_convert(buddylist, \"CP1250\", \"UTF-8\");\n\t\n\tusers_tbl = g_strsplit(utf8buddylist, \"\\r\\n\", -1);\n\tfor (i = 0; users_tbl[i] != NULL; i++) {\n\t\tgchar **data_tbl;\n\t\tgchar *name, *show, *g;\n\t\tif (strlen(users_tbl[i]) == 0)\n\t\t\tcontinue;\n\t\tdata_tbl = g_strsplit(users_tbl[i], \";\", 8);\n\t\tif (ggp_array_size(data_tbl) < 8) {\n\t\t\tpurple_debug_warning(\"gg\",\n\t\t\t\t\"Something is wrong on line %d of the buddylist. Skipping.\\n\",\n\t\t\t\ti + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tshow = data_tbl[F_NICKNAME];\n\t\tname = data_tbl[F_UIN];\n\t\tif ('\\0' == *name || !atol(name)) {\n\t\t\tpurple_debug_warning(\"gg\",\n\t\t\t\t\"Identifier on line %d of the buddylist is not a number. Skipping.\\n\",\n\t\t\t\ti + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif ('\\0' == *show) {\n\t\t\tshow = name;\n\t\t}\n\t\tpurple_debug_info(\"gg\", \"got buddy: name=%s; show=%s\\n\", name, show);\n\t\tif (purple_find_buddy(purple_connection_get_account(gc), name)) {\n\t\t\tg_strfreev(data_tbl);\n\t\t\tcontinue;\n\t\t}\n\t\tg = g_strdup(\"Gadu-Gadu\");\n\t\tif ('\\0' != data_tbl[F_GROUP]) {\n\t\t\t\n\t\t\t\n\t\t\tgchar **group_tbl = g_strsplit(data_tbl[F_GROUP], \",\", 50);\n\t\t\tif (ggp_array_size(group_tbl) > 0) {\n\t\t\t\tg_free(g);\n\t\t\t\tg = g_strdup(group_tbl[0]);\n\t\t\t}\n\t\t\tg_strfreev(group_tbl);\n\t\t}\n\t\tbuddy = purple_buddy_new(purple_connection_get_account(gc), name,\n\t\t\t\t\t strlen(show) ? show : NULL);\n\t\tif (!(group = purple_find_group(g))) {\n\t\t\tgroup = purple_group_new(g);\n\t\t\tpurple_blist_add_group(group, NULL);\n\t\t}\n\t\tpurple_blist_add_buddy(buddy, NULL, group, NULL);\n\t\tg_free(g);\n\t\tg_strfreev(data_tbl);\n\t}\n\tg_strfreev(users_tbl);\n\tg_free(utf8buddylist);\n\tggp_buddylist_send(gc);\n}\n\n\n\nvoid ggp_buddylist_load(PurpleConnection *gc, char *buddylist)\n{\n\tPurpleBuddy *buddy;\n\tPurpleGroup *group;\n\tgchar **users_tbl;\n\tint i;\n\tchar *utf8buddylist = charset_convert(buddylist, \"CP1250\", \"UTF-8\");\n\t\n\tusers_tbl = g_strsplit(utf8buddylist, \"\\r\\n\", -1);\n\tfor (i = 0; users_tbl[i] != NULL; i++) {\n\t\tgchar **data_tbl;\n\t\tgchar *name, *show, *g;\n\t\tif (strlen(users_tbl[i]) == 0)\n\t\t\tcontinue;\n\t\tdata_tbl = g_strsplit(users_tbl[i], \";\", 8);\n\t\tif (ggp_array_size(data_tbl) < 8) {\n\t\t\tpurple_debug_warning(\"gg\",\n\t\t\t\t\"Something is wrong on line %d of the buddylist. Skipping.\\n\",\n\t\t\t\ti + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tshow = data_tbl[F_NICKNAME];\n\t\tname = data_tbl[F_UIN];\n\t\tif ('\\0' == *name || !atol(name)) {\n\t\t\tpurple_debug_warning(\"gg\",\n\t\t\t\t\"Identifier on line %d of the buddylist is not a number. Skipping.\\n\",\n\t\t\t\ti + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif ('\\0' == *show) {\n\t\t\tshow = name;\n\t\t}\n\t\tpurple_debug_info(\"gg\", \"got buddy: name=%s; show=%s\\n\", name, show);\n\t\tif (purple_find_buddy(purple_connection_get_account(gc), name)) {\n\t\t\tg_strfreev(data_tbl);\n\t\t\tcontinue;\n\t\t}\n\t\tg = g_strdup(\"Gadu-Gadu\");\n\t\tif ('\\0' != data_tbl[F_GROUP]) {\n\t\t\t\n\t\t\t\n\t\t\tgchar **group_tbl = g_strsplit(data_tbl[F_GROUP], \",\", 50);\n\t\t\tif (ggp_array_size(group_tbl) > 0) {\n\t\t\t\tg_free(g);\n\t\t\t\tg = g_strdup(group_tbl[0]);\n\t\t\t}\n\t\t\tg_strfreev(group_tbl);\n\t\t}\n\t\tbuddy = purple_buddy_new(purple_connection_get_account(gc), name,\n\t\t\t\t\t strlen(show) ? show : NULL);\n\t\tif (!(group = purple_find_group(g))) {\n\t\t\tgroup = purple_group_new(g);\n\t\t\tpurple_blist_add_group(group, NULL);\n\t\t}\n\t\tpurple_blist_add_buddy(buddy, NULL, group, NULL);\n\t\tg_free(g);\n\t\tg_strfreev(data_tbl);\n\t}\n\tg_strfreev(users_tbl);\n\tg_free(utf8buddylist);\n\tggp_buddylist_send(gc);\n}\n\n\nvoid ggp_buddylist_load(PurpleConnection *gc, char *buddylist)\n{\n\tPurpleBuddy *buddy;\n\tPurpleGroup *group;\n\tgchar **users_tbl;\n\tint i;\n\tchar *utf8buddylist = charset_convert(buddylist, \"CP1250\", \"UTF-8\");\n\t\n\tusers_tbl = g_strsplit(utf8buddylist, \"\\r\\n\", -1);\n\tfor (i = 0; users_tbl[i] != NULL; i++) {\n\t\tgchar **data_tbl;\n\t\tgchar *name, *show, *g;\n\t\tif (strlen(users_tbl[i]) == 0)\n\t\t\tcontinue;\n\t\tdata_tbl = g_strsplit(users_tbl[i], \";\", 8);\n\t\tif (ggp_array_size(data_tbl) < 8) {\n\t\t\tpurple_debug_warning(\"gg\",\n\t\t\t\t\"Something is wrong on line %d of the buddylist. Skipping.\\n\",\n\t\t\t\ti + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tshow = data_tbl[F_NICKNAME];\n\t\tname = data_tbl[F_UIN];\n\t\tif ('\\0' == *name || !atol(name)) {\n\t\t\tpurple_debug_warning(\"gg\",\n\t\t\t\t\"Identifier on line %d of the buddylist is not a number. Skipping.\\n\",\n\t\t\t\ti + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif ('\\0' == *show) {\n\t\t\tshow = name;\n\t\t}\n\t\tpurple_debug_info(\"gg\", \"got buddy: name=%s; show=%s\\n\", name, show);\n\t\tif (purple_find_buddy(purple_connection_get_account(gc), name)) {\n\t\t\tg_strfreev(data_tbl);\n\t\t\tcontinue;\n\t\t}\n\t\tg = g_strdup(\"Gadu-Gadu\");\n\t\tif ('\\0' != data_tbl[F_GROUP]) {\n\t\t\t\n\t\t\t\n\t\t\tgchar **group_tbl = g_strsplit(data_tbl[F_GROUP], \",\", 50);\n\t\t\tif (ggp_array_size(group_tbl) > 0) {\n\t\t\t\tg_free(g);\n\t\t\t\tg = g_strdup(group_tbl[0]);\n\t\t\t}\n\t\t\tg_strfreev(group_tbl);\n\t\t}\n\t\tbuddy = purple_buddy_new(purple_connection_get_account(gc), name,\n\t\t\t\t\t strlen(show) ? show : NULL);\n\t\tif (!(group = purple_find_group(g))) {\n\t\t\tgroup = purple_group_new(g);\n\t\t\tpurple_blist_add_group(group, NULL);\n\t\t}\n\t\tpurple_blist_add_buddy(buddy, NULL, group, NULL);\n\t\tg_free(g);\n\t\tg_strfreev(data_tbl);\n\t}\n\tg_strfreev(users_tbl);\n\tg_free(utf8buddylist);\n\tggp_buddylist_send(gc);\n}\n", "bug_type": null, "idx": 149}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_menu_init(GTypeInstance *instance, gpointer class)\n{\n\tGntWidget *widget = GNT_WIDGET(instance);\n\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_NO_SHADOW | GNT_WIDGET_NO_BORDER |\n\t\t\tGNT_WIDGET_CAN_TAKE_FOCUS | GNT_WIDGET_TRANSIENT | GNT_WIDGET_DISABLE_ACTIONS);\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 150}
{"project": "Pidgin", "target": 0, "func": "static void\ncreate_conv_from_userlist(GntWidget *widget, FinchConv *fc)\n{\n\tPurpleAccount *account = purple_conversation_get_account(fc->active_conv);\n\tPurpleConnection *gc = purple_account_get_connection(account);\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tchar *name, *realname;\n\tif (!gc) {\n\t\tpurple_conversation_write(fc->active_conv, NULL, _(\"You are not connected.\"),\n\t\t\t\tPURPLE_MESSAGE_SYSTEM, time(NULL));\n\t\treturn;\n\t}\n\tname = gnt_tree_get_selection_data(GNT_TREE(widget));\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);\n\tif (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, get_cb_real_name))\n\t\trealname = prpl_info->get_cb_real_name(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(fc->active_conv)), name);\n\telse\n\t\trealname = NULL;\n\tpurple_conversation_new(PURPLE_CONV_TYPE_IM, account, realname ? realname : name);\n\tg_free(realname);\n}\n", "bug_type": null, "idx": 151}
{"project": "Pidgin", "target": 0, "func": "static PurplePluginPrefFrame *\nget_plugin_pref_frame(PurplePlugin *plugin) {\n  PurplePluginPrefFrame *frame;\n  PurplePluginPref *pref;\n  frame = purple_plugin_pref_frame_new();\n  pref = purple_plugin_pref_new_with_name(PREF_LENGTH);\n  purple_plugin_pref_set_label(pref, _(\"Only create TinyURL for URLs\"\n\t\t\t\t     \" of this length or greater\"));\n  purple_plugin_pref_frame_add(frame, pref);\n  pref = purple_plugin_pref_new_with_name(PREF_URL);\n  purple_plugin_pref_set_label(pref, _(\"TinyURL (or other) address prefix\"));\n  purple_plugin_pref_frame_add(frame, pref);\n  return frame;\n}\n", "bug_type": null, "idx": 152}
{"project": "Pidgin", "target": 0, "func": "size_t\nprotobuf_c_message_pack(const ProtobufCMessage *message, uint8_t *out)\n{\n\tunsigned i;\n\tsize_t rv = 0;\n\tASSERT_IS_MESSAGE(message);\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *field =\n\t\t\tmessage->descriptor->fields + i;\n\t\tconst void *member = ((const char *) message) + field->offset;\n\t\t\n\t\tconst void *qmember =\n\t\t\t((const char *) message) + field->quantifier_offset;\n\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\trv += required_field_pack(field, member, out + rv);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\t\n\t\t\trv += optional_field_pack(field, qmember, member, out + rv);\n\t\t} else {\n\t\t\trv += repeated_field_pack(field, *(const size_t *) qmember,\n\t\t\t\tmember, out + rv);\n\t\t}\n\t}\n\tfor (i = 0; i < message->n_unknown_fields; i++)\n\t\trv += unknown_field_pack(&message->unknown_fields[i], out + rv);\n\treturn rv;\n}\n", "bug_type": null, "idx": 153}
{"project": "Pidgin", "target": 0, "func": " */\nstatic gboolean plugin_load(PurplePlugin *plugin) {\n\thandle = plugin;\n\t\n\tif(purple_get_blist() && PIDGIN_BLIST(purple_get_blist())\n\t\t\t&& PIDGIN_BLIST(purple_get_blist())->window) {\n\t\tblist_create_cb(purple_get_blist(), NULL);\n\t}\n\t\n\tpurple_signal_connect(pidgin_blist_get_handle(), \"gtkblist-created\",\n\t\tplugin, PURPLE_CALLBACK(blist_create_cb), NULL);\n\tpurple_signal_connect((void*)purple_get_core(), \"quitting\", plugin,\n\t\tPURPLE_CALLBACK(purple_quit_cb), NULL);\n\tpurple_prefs_connect_callback(handle, PREF_BLIST_ON_TOP,\n\t\twinprefs_set_blist_ontop, NULL);\n\tpurple_prefs_connect_callback(handle, PREF_DBLIST_DOCKABLE,\n\t\twinprefs_set_blist_dockable, NULL);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 154}
{"project": "Pidgin", "target": 0, "func": "void\npurple_privacy_allow(PurpleAccount *account, const char *who, gboolean local,\n\t\t\t\t\t\tgboolean restore)\n{\n\tGSList *list;\n\tPurplePrivacyType type = account->perm_deny;\n\tswitch (account->perm_deny) {\n\t\tcase PURPLE_PRIVACY_ALLOW_ALL:\n\t\t\treturn;\n\t\tcase PURPLE_PRIVACY_ALLOW_USERS:\n\t\t\tpurple_privacy_permit_add(account, who, local);\n\t\t\tbreak;\n\t\tcase PURPLE_PRIVACY_DENY_USERS:\n\t\t\tpurple_privacy_deny_remove(account, who, local);\n\t\t\tbreak;\n\t\tcase PURPLE_PRIVACY_DENY_ALL:\n\t\t\tif (!restore) {\n\t\t\t\t\n\t\t\t\tconst char *norm = purple_normalize(account, who);\n\t\t\t\tfor (list = account->permit; list != NULL;) {\n\t\t\t\t\tchar *person = list->data;\n\t\t\t\t\tlist = list->next;\n\t\t\t\t\tif (!purple_strequal(norm, person))\n\t\t\t\t\t\tpurple_privacy_permit_remove(account, person, local);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpurple_privacy_permit_add(account, who, local);\n\t\t\taccount->perm_deny = PURPLE_PRIVACY_ALLOW_USERS;\n\t\t\tbreak;\n\t\tcase PURPLE_PRIVACY_ALLOW_BUDDYLIST:\n\t\t\tif (!purple_find_buddy(account, who)) {\n\t\t\t\tadd_all_buddies_to_permit_list(account, local);\n\t\t\t\tpurple_privacy_permit_add(account, who, local);\n\t\t\t\taccount->perm_deny = PURPLE_PRIVACY_ALLOW_USERS;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_return_if_reached();\n\t}\n\t\n\tif (type != account->perm_deny && purple_account_is_connected(account))\n\t\tserv_set_permit_deny(purple_account_get_connection(account));\n}\n", "bug_type": null, "idx": 155}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_media_candidate_pair_established_cb(PurpleMediaBackend *backend,\n\t\tconst gchar *sess_id, const gchar *name,\n\t\tPurpleMediaCandidate *local_candidate,\n\t\tPurpleMediaCandidate *remote_candidate,\n\t\tPurpleMedia *media)\n{\n\tPurpleMediaStream *stream;\n\tGList *iter;\n\tguint id;\n\tg_return_if_fail(PURPLE_IS_MEDIA(media));\n\tstream = purple_media_get_stream(media, sess_id, name);\n\tid = purple_media_candidate_get_component_id(local_candidate);\n\titer = stream->active_local_candidates;\n\tfor(; iter; iter = g_list_next(iter)) {\n\t\tPurpleMediaCandidate *c = iter->data;\n\t\tif (id == purple_media_candidate_get_component_id(c)) {\n\t\t\tg_object_unref(c);\n\t\t\tstream->active_local_candidates =\n\t\t\t\t\tg_list_delete_link(iter, iter);\n\t\t\tstream->active_local_candidates = g_list_prepend(\n\t\t\t\t\tstream->active_local_candidates,\n\t\t\t\t\tpurple_media_candidate_copy(\n\t\t\t\t\tlocal_candidate));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (iter == NULL)\n\t\tstream->active_local_candidates = g_list_prepend(\n\t\t\t\tstream->active_local_candidates,\n\t\t\t\tpurple_media_candidate_copy(\n\t\t\t\tlocal_candidate));\n\tid = purple_media_candidate_get_component_id(local_candidate);\n\titer = stream->active_remote_candidates;\n\tfor(; iter; iter = g_list_next(iter)) {\n\t\tPurpleMediaCandidate *c = iter->data;\n\t\tif (id == purple_media_candidate_get_component_id(c)) {\n\t\t\tg_object_unref(c);\n\t\t\tstream->active_remote_candidates =\n\t\t\t\t\tg_list_delete_link(iter, iter);\n\t\t\tstream->active_remote_candidates = g_list_prepend(\n\t\t\t\t\tstream->active_remote_candidates,\n\t\t\t\t\tpurple_media_candidate_copy(\n\t\t\t\t\tremote_candidate));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (iter == NULL)\n\t\tstream->active_remote_candidates = g_list_prepend(\n\t\t\t\tstream->active_remote_candidates,\n\t\t\t\tpurple_media_candidate_copy(\n\t\t\t\tremote_candidate));\n\tg_signal_emit(media, purple_media_signals[CANDIDATE_PAIR_ESTABLISHED],\n\t\t0, sess_id, name, local_candidate, remote_candidate);\n\tpurple_debug_info(\"media\", \"candidate pair established\\n\");\n}\n", "bug_type": null, "idx": 156}
{"project": "Pidgin", "target": 0, "func": "static void\npurplerc_set_color(GtkWidget *widget, gpointer data)\n{\n\tGdkColor color;\n\tgchar title[128];\n\tconst gchar *pref = NULL;\n\tGtkWidget *color_dialog = NULL;\n\tgint subscript = GPOINTER_TO_INT(data);\n\tg_snprintf(title, sizeof(title), _(\"Select Color for %s\"),\n\t           _(color_names[GPOINTER_TO_INT(data)]));\n\tcolor_dialog = gtk_color_selection_dialog_new(_(\"Select Color\"));\n\tg_signal_connect(G_OBJECT(color_dialog), \"response\",\n\t                 G_CALLBACK(purplerc_color_response), data);\n\tpref = purple_prefs_get_string(color_prefs[subscript]);\n\tif (pref != NULL && strcmp(pref, \"\")) {\n\t\tif (gdk_color_parse(pref, &color)) {\n#if GTK_CHECK_VERSION(2,14,0)\n\t\t\tgtk_color_selection_set_current_color(GTK_COLOR_SELECTION(\n\t\t\t\tgtk_color_selection_dialog_get_color_selection(GTK_COLOR_SELECTION_DIALOG(color_dialog))),\n\t\t\t\t&color);\n#else\n\t\t\tgtk_color_selection_set_current_color(GTK_COLOR_SELECTION(GTK_COLOR_SELECTION_DIALOG(color_dialog)->colorsel), &color);\n#endif\n\t\t}\n\t}\n\tgtk_window_present(GTK_WINDOW(color_dialog));\n}\n", "bug_type": null, "idx": 157}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_userlist100_request(struct gg_session *sess, char type,\n\tunsigned int version, char format_type, const char *request)\n{\n\tstruct gg_userlist100_request pkt;\n\tunsigned char *zrequest;\n\tsize_t zrequest_len;\n\tint ret;\n\tif (!sess) {\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\tif (sess->state != GG_STATE_CONNECTED) {\n\t\terrno = ENOTCONN;\n\t\treturn -1;\n\t}\n\tpkt.type = type;\n\tpkt.version = gg_fix32(version);\n\tpkt.format_type = format_type;\n\tpkt.unknown1 = 0x01;\n\tif (request == NULL)\n\t\treturn gg_send_packet(sess, GG_USERLIST100_REQUEST, &pkt, sizeof(pkt), NULL);\n\tzrequest = gg_deflate(request, &zrequest_len);\n\tif (zrequest == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_userlist100_request() gg_deflate() failed\\n\");\n\t\treturn -1;\n\t}\n\tret = gg_send_packet(sess, GG_USERLIST100_REQUEST, &pkt, sizeof(pkt), zrequest, zrequest_len, NULL);\n\tfree(zrequest);\n\treturn ret;\n}\n", "bug_type": null, "idx": 158}
{"project": "Pidgin", "target": 0, "func": "PurpleAccount *\npurple_chat_get_account(PurpleChat *chat)\n{\n\tg_return_val_if_fail(chat != NULL, NULL);\n\treturn chat->account;\n}\n", "bug_type": null, "idx": 159}
{"project": "Pidgin", "target": 0, "func": "static guint32\nrateclass_get_new_current(FlapConnection *conn, struct rateclass *rateclass, struct timeval *now)\n{\n\tunsigned long timediff; \n\tguint32 current;\n\t\n\ttimediff = (now->tv_sec - rateclass->last.tv_sec) * 1000 + (now->tv_usec - rateclass->last.tv_usec) / 1000;\n\tcurrent = ((rateclass->current * (rateclass->windowsize - 1)) + timediff) / rateclass->windowsize;\n\treturn MIN(current, rateclass->max);\n}\n", "bug_type": null, "idx": 160}
{"project": "Pidgin", "target": 0, "func": "static void do_add_room_cb(GtkWidget *w, struct _menu_cb_info *info)\n{\n\tchar *name;\n\tPurpleConnection *gc = purple_account_get_connection(info->list->account);\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tif(gc != NULL)\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);\n\tif(prpl_info != NULL && prpl_info->roomlist_room_serialize)\n\t\tname = prpl_info->roomlist_room_serialize(info->room);\n\telse\n\t\tname = g_strdup(info->room->name);\n\tpurple_blist_request_add_chat(info->list->account, NULL, NULL, name);\n\tg_free(name);\n}\n", "bug_type": null, "idx": 161}
{"project": "Pidgin", "target": 0, "func": "static void\npounce_test_sound(GtkWidget *w, GtkWidget *entry)\n{\n\tconst char *filename;\n\tgboolean temp_mute;\n\ttemp_mute = purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/sound/mute\");\n\tif (temp_mute) purple_prefs_set_bool(PIDGIN_PREFS_ROOT \"/sound/mute\", FALSE);\n\tfilename = gtk_entry_get_text(GTK_ENTRY(entry));\n\tif (filename != NULL && *filename != '\\0' && strcmp(filename, _(\"(default)\")))\n\t\tpurple_sound_play_file(filename, NULL);\n\telse\n\t\tpurple_sound_play_event(PURPLE_SOUND_POUNCE_DEFAULT, NULL);\n\tif (temp_mute) purple_prefs_set_bool(PIDGIN_PREFS_ROOT \"/sound/mute\", TRUE);\n}\n", "bug_type": null, "idx": 162}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_xfer_dialog_update_xfer(PidginXferDialog *dialog,\n\t\t\t\t\t\t\t\tPurpleXfer *xfer)\n{\n\tPidginXferUiData *data;\n\tchar *size_str, *remaining_str;\n\ttime_t current_time;\n\tGtkTreeIter iter;\n\tgboolean valid;\n\tg_return_if_fail(dialog != NULL);\n\tg_return_if_fail(xfer != NULL);\n\tif ((data = PIDGINXFER(xfer)) == NULL)\n\t\treturn;\n\tif (data->in_list == FALSE)\n\t\treturn;\n\tcurrent_time = time(NULL);\n\tif (((current_time - data->last_updated_time) == 0) &&\n\t\t(!purple_xfer_is_completed(xfer)))\n\t{\n\t\t\n\t\treturn;\n\t}\n\tdata->last_updated_time = current_time;\n\tsize_str      = purple_str_size_to_units(purple_xfer_get_size(xfer));\n\tremaining_str = purple_str_size_to_units(purple_xfer_get_bytes_remaining(xfer));\n\tgtk_list_store_set(xfer_dialog->model, &data->iter,\n\t\t\t\t\t   COLUMN_PROGRESS, (gint)(purple_xfer_get_progress(xfer) * 100),\n\t\t\t\t\t   COLUMN_SIZE, size_str,\n\t\t\t\t\t   COLUMN_REMAINING, remaining_str,\n\t\t\t\t\t   -1);\n\tg_free(size_str);\n\tg_free(remaining_str);\n\tif (purple_xfer_is_completed(xfer))\n\t{\n\t\tGdkPixbuf *pixbuf;\n\t\tpixbuf = gtk_widget_render_icon(dialog->window,\n\t\t\t\t\t\t\t\t\t\tPIDGIN_STOCK_FILE_DONE,\n\t\t\t\t\t\t\t\t\t\tGTK_ICON_SIZE_MENU, NULL);\n\t\tgtk_list_store_set(GTK_LIST_STORE(xfer_dialog->model), &data->iter,\n\t\t\t\t\t\t   COLUMN_STATUS, pixbuf,\n\t\t\t\t\t\t   COLUMN_REMAINING, _(\"Finished\"),\n\t\t\t\t\t\t   -1);\n\t\tg_object_unref(pixbuf);\n\t}\n\tupdate_title_progress(dialog);\n\tif (xfer == dialog->selected_xfer)\n\t\tupdate_detailed_info(xfer_dialog, xfer);\n\tif (purple_xfer_is_completed(xfer) && dialog->auto_clear)\n\t\tpidgin_xfer_dialog_remove_xfer(dialog, xfer);\n\telse\n\t\tupdate_buttons(dialog, xfer);\n\t\n\tif (dialog->keep_open)\n\t\treturn;\n\tvalid = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(dialog->model), &iter);\n\twhile (valid)\n\t{\n\t\tGValue val;\n\t\tPurpleXfer *next;\n\t\tval.g_type = 0;\n\t\tgtk_tree_model_get_value(GTK_TREE_MODEL(dialog->model),\n\t\t\t\t&iter, COLUMN_DATA, &val);\n\t\tnext = g_value_get_pointer(&val);\n\t\tif (!purple_xfer_is_completed(next))\n\t\t\treturn;\n\t\tvalid = gtk_tree_model_iter_next(GTK_TREE_MODEL(dialog->model), &iter);\n\t}\n\t\n\tpidgin_xfer_dialog_hide(dialog);\n}\n", "bug_type": null, "idx": 163}
{"project": "Pidgin", "target": 0, "func": "static GdkFilterReturn wnd_exitsizemove(GtkAppBar *ab, GdkXEvent *xevent) {\n        MSG *msg = (MSG*)xevent;\n        purple_debug(PURPLE_DEBUG_INFO, \"gtkappbar\", \"wnd_exitsizemove\\n\");\n        if(ab->docking) {\n\t\tgtk_appbar_setpos(ab, msg->hwnd);\n\t\tab->docking = FALSE;\n\t\tab->docked = TRUE;\n\t\tShowWindow(msg->hwnd, SW_HIDE);\n\t\tset_toolbar(msg->hwnd, TRUE);\n\t\tShowWindow(msg->hwnd, SW_SHOW);\n\t\tgtk_appbar_dispatch_dock_cbs(ab, TRUE);\n\t} else if(ab->undocking) {\n\t\tShowWindow(msg->hwnd, SW_HIDE);\n\t\tset_toolbar(msg->hwnd, FALSE);\n\t\tShowWindow(msg->hwnd, SW_SHOW);\n\t\tgtk_appbar_dispatch_dock_cbs(ab, FALSE);\n\t\tab->undocking = FALSE;\n        }\n        return GDK_FILTER_CONTINUE;\n}\n", "bug_type": null, "idx": 164}
{"project": "Pidgin", "target": 0, "func": "gchar *\npurple_media_candidate_get_ip(PurpleMediaCandidate *candidate)\n{\n\tgchar *ip;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_CANDIDATE(candidate), NULL);\n\tg_object_get(candidate, \"ip\", &ip, NULL);\n\treturn ip;\n}\n", "bug_type": null, "idx": 165}
{"project": "Pidgin", "target": 0, "func": "void winpidgin_ensure_onscreen(GtkWidget *win) {\n\tRECT winR, wAR, intR;\n\tHWND hwnd = GDK_WINDOW_HWND(win->window);\n\tg_return_if_fail(hwnd != NULL);\n\twinR = get_actualWindowRect(hwnd);\n\tpurple_debug_info(\"win32placement\",\n\t\t\t\"Window RECT: L:%ld R:%ld T:%ld B:%ld\\n\",\n\t\t\twinR.left, winR.right,\n\t\t\twinR.top, winR.bottom);\n\tif(!get_WorkingAreaRectForWindow(hwnd, &wAR)) {\n\t\tpurple_debug_info(\"win32placement\",\n\t\t\t\t\"Couldn't get multimonitor working area\\n\");\n\t\tif(!SystemParametersInfo(SPI_GETWORKAREA, 0, &wAR, FALSE)) {\n\t\t\t\n\t\t\twAR.left = 0;\n\t\t\twAR.top = 0;\n\t\t\twAR.bottom = GetSystemMetrics(SM_CYSCREEN);\n\t\t\twAR.right = GetSystemMetrics(SM_CXSCREEN);\n\t\t}\n\t}\n\tpurple_debug_info(\"win32placement\",\n\t\t\t\"Working Area RECT: L:%ld R:%ld T:%ld B:%ld\\n\",\n\t\t\twAR.left, wAR.right,\n\t\t\twAR.top, wAR.bottom);\n\t\n\tif(!(IntersectRect(&intR, &winR, &wAR)\n\t\t\t\t&& EqualRect(&intR, &winR))) {\n\t\tpurple_debug_info(\"win32placement\",\n\t\t\t\t\"conversation window out of working area, relocating\\n\");\n\t\t\n\t\tif ((winR.right - winR.left) <= (wAR.right - wAR.left)\n\t\t\t\t&& (winR.bottom - winR.top) <= (wAR.bottom - wAR.top)) {\n\t\t\t\n\t\t\tif (winR.bottom > wAR.bottom) {\n\t\t\t\twinR.top = wAR.bottom - (winR.bottom - winR.top);\n\t\t\t\twinR.bottom = wAR.bottom;\n\t\t\t}\n\t\t\t\n\t\t\telse if (winR.top < wAR.top) {\n\t\t\t\twinR.bottom = wAR.top + (winR.bottom - winR.top);\n\t\t\t\twinR.top = wAR.top;\n\t\t\t}\n\t\t\t\n\t\t\tif (winR.left < wAR.left) {\n\t\t\t\twinR.right = wAR.left + (winR.right - winR.left);\n\t\t\t\twinR.left = wAR.left;\n\t\t\t}\n\t\t\t\n\t\t\telse  if (winR.right > wAR.right) {\n\t\t\t\twinR.left = wAR.right - (winR.right - winR.left);\n\t\t\t\twinR.right = wAR.right;\n\t\t\t}\n\t\t} else {\n \t\t\t\n \t\t\twinR.right = wAR.left + (winR.right - winR.left);\n \t\t\twinR.bottom = wAR.top + (winR.bottom - winR.top);\n \t\t\twinR.left = wAR.left;\n \t\t\twinR.top = wAR.top;\n\t\t}\n\t\tpurple_debug_info(\"win32placement\",\n\t\t\t\"Relocation RECT: L:%ld R:%ld T:%ld B:%ld\\n\",\n\t\t\twinR.left, winR.right,\n\t\t\twinR.top, winR.bottom);\n\t\tMoveWindow(hwnd, winR.left, winR.top,\n\t\t\t\t   (winR.right - winR.left),\n\t\t\t\t   (winR.bottom - winR.top), TRUE);\n\t}\n}\n", "bug_type": null, "idx": 166}
{"project": "Pidgin", "target": 0, "func": "void\naim_srv_rates_addparam(OscarData *od, FlapConnection *conn)\n{\n\tByteStream bs;\n\taim_snacid_t snacid;\n\tGSList *tmp;\n\tbyte_stream_new(&bs, 502);\n\tfor (tmp = conn->rateclasses; tmp != NULL; tmp = tmp->next)\n\t{\n\t\tstruct rateclass *rateclass;\n\t\trateclass = tmp->data;\n\t\tbyte_stream_put16(&bs, rateclass->classid);\n\t}\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_OSERVICE, 0x0008, 0x0000, NULL, 0);\n\tflap_connection_send_snac(od, conn, SNAC_FAMILY_OSERVICE, 0x0008, snacid, &bs);\n\tbyte_stream_destroy(&bs);\n}\n", "bug_type": null, "idx": 167}
{"project": "Pidgin", "target": 0, "func": "static void\npref_toggled(GntTree *tree, char *key, gpointer null)\n{\n\tpurple_prefs_set_bool(key, gnt_tree_get_choice(tree, key));\n}\n", "bug_type": null, "idx": 168}
{"project": "Pidgin", "target": 0, "func": "static gssize\njabber_si_xfer_ibb_write(const guchar *buffer, size_t len, PurpleXfer *xfer)\n{\n\tJabberSIXfer *jsx = (JabberSIXfer *) xfer->data;\n\tJabberIBBSession *sess = jsx->ibb_session;\n\tgsize packet_size = len < jabber_ibb_session_get_max_data_size(sess) ?\n\t\tlen : jabber_ibb_session_get_max_data_size(sess);\n\tjabber_ibb_session_send_data(sess, buffer, packet_size);\n\treturn packet_size;\n}\n", "bug_type": null, "idx": 169}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_change_passwd(PurpleConnection *gc, const char *old, const char *new)\n{\n\tchar prd[256];\n\tg_snprintf(prd, sizeof(prd), \"%s\" G_DIR_SEPARATOR_S \"private_key.pub\", silcpurple_silcdir());\n\tsilc_change_private_key_passphrase(purple_account_get_string(gc->account,\n\t\t\t\t\t\t\t\t   \"private-key\",\n\t\t\t\t\t\t\t\t   prd), old ? old : \"\", new ? new : \"\");\n}\n", "bug_type": null, "idx": 170}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int ggp_setup_proxy(PurpleAccount *account)\n{\n\tPurpleProxyInfo *gpi;\n\tgpi = purple_proxy_get_setup(account);\n\tif ((purple_proxy_info_get_type(gpi) != PURPLE_PROXY_NONE) &&\n\t    (purple_proxy_info_get_host(gpi) == NULL ||\n\t     purple_proxy_info_get_port(gpi) <= 0)) {\n\t\tgg_proxy_enabled = 0;\n\t\tpurple_notify_error(NULL, NULL, _(\"Invalid proxy settings\"),\n\t\t\t\t  _(\"Either the host name or port number specified for your given proxy type is invalid.\"));\n\t\treturn -1;\n\t} else if (purple_proxy_info_get_type(gpi) != PURPLE_PROXY_NONE) {\n\t\tgg_proxy_enabled = 1;\n\t\tgg_proxy_host = g_strdup(purple_proxy_info_get_host(gpi));\n\t\tgg_proxy_port = purple_proxy_info_get_port(gpi);\n\t\tgg_proxy_username = g_strdup(purple_proxy_info_get_username(gpi));\n\t\tgg_proxy_password = g_strdup(purple_proxy_info_get_password(gpi));\n\t} else {\n\t\tgg_proxy_enabled = 0;\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 171}
{"project": "Pidgin", "target": 0, "func": "char *\nxmlnode_to_formatted_str(const xmlnode *node, int *len)\n{\n\tchar *xml, *xml_with_declaration;\n\tg_return_val_if_fail(node != NULL, NULL);\n\txml = xmlnode_to_str_helper(node, len, TRUE, 0);\n\txml_with_declaration =\n\t\tg_strdup_printf(\"<?xml version='1.0' encoding='UTF-8' ?>\" NEWLINE_S NEWLINE_S \"%s\", xml);\n\tg_free(xml);\n\tif (len)\n\t\t*len += sizeof(\"<?xml version='1.0' encoding='UTF-8' ?>\" NEWLINE_S NEWLINE_S) - 1;\n\treturn xml_with_declaration;\n}\n", "bug_type": null, "idx": 172}
{"project": "Pidgin", "target": 0, "func": "GtkWidget *\npidgin_prefs_dropdown_from_list(GtkWidget *box, const gchar *title,\n\t\tPurplePrefType type, const char *key, GList *menuitems)\n{\n\tGtkWidget  *dropdown, *opt, *menu;\n\tGtkWidget  *label = NULL;\n\tgchar      *text;\n\tconst char *stored_str = NULL;\n\tint         stored_int = 0;\n\tint         int_value  = 0;\n\tconst char *str_value  = NULL;\n\tint         o = 0;\n\tg_return_val_if_fail(menuitems != NULL, NULL);\n\tdropdown = gtk_option_menu_new();\n\tmenu = gtk_menu_new();\n\tif (type == PURPLE_PREF_INT)\n\t\tstored_int = purple_prefs_get_int(key);\n\telse if (type == PURPLE_PREF_STRING)\n\t\tstored_str = purple_prefs_get_string(key);\n\twhile (menuitems != NULL && (text = (char *) menuitems->data) != NULL) {\n\t\tmenuitems = g_list_next(menuitems);\n\t\tg_return_val_if_fail(menuitems != NULL, NULL);\n\t\topt = gtk_menu_item_new_with_label(text);\n\t\tg_object_set_data(G_OBJECT(opt), \"type\", GINT_TO_POINTER(type));\n\t\tif (type == PURPLE_PREF_INT) {\n\t\t\tint_value = GPOINTER_TO_INT(menuitems->data);\n\t\t\tg_object_set_data(G_OBJECT(opt), \"value\",\n\t\t\t\t\t\t\t  GINT_TO_POINTER(int_value));\n\t\t}\n\t\telse if (type == PURPLE_PREF_STRING) {\n\t\t\tstr_value = (const char *)menuitems->data;\n\t\t\tg_object_set_data(G_OBJECT(opt), \"value\", (char *)str_value);\n\t\t}\n\t\telse if (type == PURPLE_PREF_BOOLEAN) {\n\t\t\tg_object_set_data(G_OBJECT(opt), \"value\",\n\t\t\t\t\tmenuitems->data);\n\t\t}\n\t\tg_signal_connect(G_OBJECT(opt), \"activate\",\n\t\t\t\t\t\t G_CALLBACK(dropdown_set), (char *)key);\n\t\tgtk_widget_show(opt);\n\t\tgtk_menu_shell_append(GTK_MENU_SHELL(menu), opt);\n\t\tif ((type == PURPLE_PREF_INT && stored_int == int_value) ||\n\t\t\t(type == PURPLE_PREF_STRING && stored_str != NULL &&\n\t\t\t !strcmp(stored_str, str_value)) ||\n\t\t\t(type == PURPLE_PREF_BOOLEAN &&\n\t\t\t (purple_prefs_get_bool(key) == GPOINTER_TO_INT(menuitems->data)))) {\n\t\t\tgtk_menu_set_active(GTK_MENU(menu), o);\n\t\t}\n\t\tmenuitems = g_list_next(menuitems);\n\t\to++;\n\t}\n\tgtk_option_menu_set_menu(GTK_OPTION_MENU(dropdown), menu);\n\tpidgin_add_widget_to_vbox(GTK_BOX(box), title, NULL, dropdown, FALSE, &label);\n\treturn label;\n}\n", "bug_type": null, "idx": 173}
{"project": "Pidgin", "target": 0, "func": "static void\nchat_invited_user_cb(PurpleConversation *conv, const char *name,\n\t\t\t\t\t  const char *reason, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"chat-invited-user (%s, %s, %s)\\n\",\n\t\t\t\t\tpurple_conversation_get_name(conv), name, reason);\n}\n", "bug_type": null, "idx": 174}
{"project": "Pidgin", "target": 0, "func": "static void\nactivate_status_account_cb(GtkMenuItem *menuitem, gpointer user_data)\n{\n\tPurpleStatusType *status_type;\n\tPurpleStatusPrimitive primitive;\n\tPurpleSavedStatus *saved_status = NULL;\n\tGList *iter = purple_savedstatuses_get_all();\n\tGList *tmp, *active_accts = purple_accounts_get_all_active();\n\tstatus_type = (PurpleStatusType *)user_data;\n\tprimitive = purple_status_type_get_primitive(status_type);\n\tfor (; iter != NULL; iter = iter->next) {\n\t\tPurpleSavedStatus *ss = iter->data;\n\t\tif ((purple_savedstatus_get_type(ss) == primitive) && purple_savedstatus_is_transient(ss) &&\n\t\t\tpurple_savedstatus_has_substatuses(ss))\n\t\t{\n\t\t\tgboolean found = FALSE;\n\t\t\t\n\t\t\tfor(tmp = active_accts; tmp != NULL; tmp = tmp->next) {\n\t\t\t\tPurpleAccount *acct = tmp->data;\n\t\t\t\tPurpleSavedStatusSub *sub = purple_savedstatus_get_substatus(ss, acct);\n\t\t\t\tif (sub) {\n\t\t\t\t\tconst PurpleStatusType *sub_type = purple_savedstatus_substatus_get_type(sub);\n\t\t\t\t\tconst char *subtype_status_id = purple_status_type_get_id(sub_type);\n\t\t\t\t\tif (subtype_status_id && !strcmp(subtype_status_id,\n\t\t\t\t\t\t\tpurple_status_type_get_id(status_type)))\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tcontinue;\n\t\t\tsaved_status = ss;\n\t\t\tbreak;\n\t\t}\n\t}\n\tg_list_free(active_accts);\n\t\n\tif (saved_status == NULL)\n\t\tsaved_status = create_transient_status(primitive, status_type);\n\t\n\tpurple_savedstatus_activate(saved_status);\n}\n", "bug_type": null, "idx": 175}
{"project": "Pidgin", "target": 0, "func": "static void\nhash(const JabberScramHash *hash, guchar *out, const guchar *data)\n{\n\tPurpleCipherContext *context;\n\tcontext = purple_cipher_context_new_by_name(hash->name, NULL);\n\tpurple_cipher_context_append(context, data, hash->size);\n\tpurple_cipher_context_digest(context, hash->size, out, NULL);\n\tpurple_cipher_context_destroy(context);\n}\n", "bug_type": null, "idx": 176}
{"project": "Pidgin", "target": 0, "func": "static int dbus_request_name_reply = DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER;\ngboolean purple_dbus_is_owner(void)\n{\n\treturn(DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER == dbus_request_name_reply);\n}\n", "bug_type": null, "idx": 177}
{"project": "Pidgin", "target": 0, "func": " */\nvoid bonjour_dns_sd_free(BonjourDnsSd *data) {\n\tg_free(data->first);\n\tg_free(data->last);\n\tg_free(data->phsh);\n\tg_free(data->status);\n\tg_free(data->vc);\n\tg_free(data->msg);\n\tg_free(data);\n}\n", "bug_type": null, "idx": 178}
{"project": "Pidgin", "target": 0, "func": "static int gg_session_handle_options(struct gg_session *gs, uint32_t type,\n\tconst char *ptr, size_t len, struct gg_event *ge)\n{\n\tGG110Options *msg = gg110_options__unpack(NULL, len, (uint8_t*)ptr);\n\tsize_t i;\n\tif (!GG_PROTOBUF_VALID(gs, \"GG110Options\", msg))\n\t\treturn -1;\n\tgg_protobuf_expected(gs, \"GG110Options.dummy1\", msg->dummy1, 0);\n\tfor (i = 0; i < msg->n_options; i++) {\n\t\tProtobufKVP *kvp = msg->options[i];\n\t\tif (!GG_PROTOBUF_VALID(gs, \"ProtobufKVP\", kvp))\n\t\t\tcontinue;\n\t\tgg_debug_session(gs, GG_DEBUG_MISC,\n\t\t\t\"// gg_session_handle_options[%s] = \\\"%s\\\"\\n\",\n\t\t\tkvp->key, kvp->value);\n\t}\n\tgg110_options__free_unpacked(msg, NULL);\n\treturn 0;\n}\n", "bug_type": null, "idx": 179}
{"project": "Pidgin", "target": 0, "func": "static PurpleCmdRet silcpurple_cmd_chat_join(PurpleConversation *conv,\n        const char *cmd, char **args, char **error, void *data)\n{\n\tGHashTable *comp;\n\tif(!args || !args[0])\n\t\treturn PURPLE_CMD_RET_FAILED;\n\tcomp = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);\n\tg_hash_table_replace(comp, \"channel\", args[0]);\n\tif(args[1])\n\t\tg_hash_table_replace(comp, \"passphrase\", args[1]);\n\tsilcpurple_chat_join(purple_conversation_get_gc(conv), comp);\n\tg_hash_table_destroy(comp);\n\treturn PURPLE_CMD_RET_OK;\n}\n", "bug_type": null, "idx": 180}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_docklet_remove()\n{\n\tif (visible) {\n\t\tif (visibility_manager) {\n\t\t\tpidgin_blist_visibility_manager_remove();\n\t\t\tvisibility_manager = FALSE;\n\t\t}\n\t\tif (docklet_blinking_timer) {\n\t\t\tg_source_remove(docklet_blinking_timer);\n\t\t\tdocklet_blinking_timer = 0;\n\t\t}\n\t\tvisible = FALSE;\n\t\tstatus = PURPLE_STATUS_OFFLINE;\n\t}\n}\n", "bug_type": null, "idx": 181}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_status_box_add(PidginStatusBox *status_box, PidginStatusBoxItemType type, GdkPixbuf *pixbuf,\n\t\tconst char *title, const char *desc, gpointer data)\n{\n\tGtkTreeIter iter;\n\tchar *text;\n\tconst char *stock = NULL;\n\tif (desc == NULL)\n\t{\n\t\ttext = g_markup_escape_text(title, -1);\n\t}\n\telse\n\t{\n\t\tGtkStyle *style;\n\t\tchar aa_color[8];\n\t\tgchar *escaped_title, *escaped_desc;\n\t\tstyle = gtk_widget_get_style(GTK_WIDGET(status_box));\n\t\tsnprintf(aa_color, sizeof(aa_color), \"#%02x%02x%02x\",\n\t\t\t style->text_aa[GTK_STATE_NORMAL].red >> 8,\n\t\t\t style->text_aa[GTK_STATE_NORMAL].green >> 8,\n\t\t\t style->text_aa[GTK_STATE_NORMAL].blue >> 8);\n\t\tescaped_title = g_markup_escape_text(title, -1);\n\t\tescaped_desc = g_markup_escape_text(desc, -1);\n\t\ttext = g_strdup_printf(\"%s - <span color=\\\"%s\\\" size=\\\"smaller\\\">%s</span>\",\n\t\t\t\t\tescaped_title,\n\t\t\t\t       aa_color, escaped_desc);\n\t\tg_free(escaped_title);\n\t\tg_free(escaped_desc);\n\t}\n\tif (!pixbuf) {\n\t\tPurpleStatusPrimitive prim = PURPLE_STATUS_UNSET;\n\t\tif (type == PIDGIN_STATUS_BOX_TYPE_PRIMITIVE) {\n\t\t\tprim = GPOINTER_TO_INT(data);\n\t\t} else if (type == PIDGIN_STATUS_BOX_TYPE_SAVED_POPULAR ||\n\t\t\t\ttype == PIDGIN_STATUS_BOX_TYPE_POPULAR) {\n\t\t\tPurpleSavedStatus *saved = purple_savedstatus_find_by_creation_time(GPOINTER_TO_INT(data));\n\t\t\tif (saved) {\n\t\t\t\tprim = purple_savedstatus_get_type(saved);\n\t\t\t}\n\t\t}\n\t\tstock = pidgin_stock_id_from_status_primitive(prim);\n\t}\n\tgtk_list_store_append(status_box->dropdown_store, &iter);\n\tgtk_list_store_set(status_box->dropdown_store, &iter,\n\t\t\tTYPE_COLUMN, type,\n\t\t\tICON_STOCK_COLUMN, stock,\n\t\t\tTEXT_COLUMN, text,\n\t\t\tTITLE_COLUMN, title,\n\t\t\tDESC_COLUMN, desc,\n\t\t\tDATA_COLUMN, data,\n\t\t\tEMBLEM_VISIBLE_COLUMN, type == PIDGIN_STATUS_BOX_TYPE_SAVED_POPULAR,\n\t\t\tEMBLEM_COLUMN, GTK_STOCK_SAVE,\n\t\t\t-1);\n\tg_free(text);\n}\n", "bug_type": null, "idx": 182}
{"project": "Pidgin", "target": 0, "func": "static JabberIq *\njingle_create_iq(JingleSession *session)\n{\n\tJabberStream *js = jingle_session_get_js(session);\n\tJabberIq *result = jabber_iq_new(js, JABBER_IQ_SET);\n\tgchar *from = jingle_session_get_local_jid(session);\n\tgchar *to = jingle_session_get_remote_jid(session);\n\txmlnode_set_attrib(result->node, \"from\", from);\n\txmlnode_set_attrib(result->node, \"to\", to);\n\tg_free(from);\n\tg_free(to);\n\treturn result;\n}\n", "bug_type": null, "idx": 183}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_file_hash_sha1_part(int fd, SHA_CTX *ctx, off_t pos, size_t len)\n{\n\tunsigned char buf[4096];\n\tsize_t chunk_len;\n\tint res = 0;\n\twhile (len > 0) {\n\t\tif (lseek(fd, pos, SEEK_SET) == (off_t) -1) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tchunk_len = len;\n\t\tif (chunk_len > sizeof(buf))\n\t\t\tchunk_len = sizeof(buf);\n\t\tres = read(fd, buf, chunk_len);\n\t\tif (res == -1 && errno != EINTR)\n\t\t\tbreak;\n\t\tif (res == 0)\n\t\t\tbreak;\n\t\tif (res != -1) {\n\t\t\tif (!SHA1_Update(ctx, buf, res)) {\n\t\t\t\tres = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos += res;\n\t\t\tlen -= res;\n\t\t}\n\t}\n\treturn res;\n}\n", "bug_type": null, "idx": 184}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load (PurplePlugin * plugin)\n{\n\tpurple_notify_message (plugin, PURPLE_NOTIFY_MSG_INFO, \"Hello World!\",\n\t\t\"This is the Hello World! plugin :)\", NULL, NULL,\n\t\tNULL);\n\thelloworld_plugin = plugin; \n\treturn TRUE;\n}\n", "bug_type": null, "idx": 185}
{"project": "Pidgin", "target": 0, "func": "static void update_buttons(GtkIMHtmlToolbar *toolbar)\n{\n\tgboolean bold, italic, underline, strike;\n\tchar *tmp;\n\tchar *tmp2;\n\tGtkLabel *label = g_object_get_data(G_OBJECT(toolbar), \"font_label\");\n\tgtk_label_set_label(label, _(\"_Font\"));\n\tgtk_imhtml_get_current_format(GTK_IMHTML(toolbar->imhtml),\n\t\t\t\t\t\t\t\t  &bold, &italic, &underline);\n\tstrike = GTK_IMHTML(toolbar->imhtml)->edit.strike;\n\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->bold)) != bold)\n\t\ttoggle_button_set_active_block(GTK_TOGGLE_BUTTON(toolbar->bold), bold,\n\t\t\t\t\t\t\t\t\t   toolbar);\n\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->italic)) != italic)\n\t\ttoggle_button_set_active_block(GTK_TOGGLE_BUTTON(toolbar->italic), italic,\n\t\t\t\t\t\t\t\t\t   toolbar);\n\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->underline)) != underline)\n\t\ttoggle_button_set_active_block(GTK_TOGGLE_BUTTON(toolbar->underline),\n\t\t\t\t\t\t\t\t\t   underline, toolbar);\n\tif(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->strikethrough)) != strike)\n\t\ttoggle_button_set_active_block(GTK_TOGGLE_BUTTON(toolbar->strikethrough),\n\t\t\t\t\t\t\t\t\t   strike, toolbar);\n\t\n\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->smaller_size), FALSE);\n\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->larger_size), FALSE);\n\tif (bold) {\n\t\tgchar *markup = g_strdup_printf(\"<b>%s</b>\",\n\t\t\t\tgtk_label_get_label(label));\n\t\tgtk_label_set_markup_with_mnemonic(label, markup);\n\t\tg_free(markup);\n\t}\n\tif (italic) {\n\t\tgchar *markup = g_strdup_printf(\"<i>%s</i>\",\n\t\t\t\tgtk_label_get_label(label));\n\t\tgtk_label_set_markup_with_mnemonic(label, markup);\n\t\tg_free(markup);\n\t}\n\tif (underline) {\n\t\tgchar *markup = g_strdup_printf(\"<u>%s</u>\",\n\t\t\t\tgtk_label_get_label(label));\n\t\tgtk_label_set_markup_with_mnemonic(label, markup);\n\t\tg_free(markup);\n\t}\n\tif (strike) {\n\t\tgchar *markup = g_strdup_printf(\"<s>%s</s>\",\n\t\t\t\tgtk_label_get_label(label));\n\t\tgtk_label_set_markup_with_mnemonic(label, markup);\n\t\tg_free(markup);\n\t}\n\ttmp = gtk_imhtml_get_current_fontface(GTK_IMHTML(toolbar->imhtml));\n\ttoggle_button_set_active_block(GTK_TOGGLE_BUTTON(toolbar->font),\n\t\t\t\t\t\t\t\t   (tmp != NULL), toolbar);\n\tif (tmp != NULL) {\n\t\tgchar *markup = g_strdup_printf(\"<span font_desc=\\\"%s\\\">%s</span>\",\n\t\t\t\ttmp, gtk_label_get_label(label));\n\t\tgtk_label_set_markup_with_mnemonic(label, markup);\n\t\tg_free(markup);\n\t}\n\tg_free(tmp);\n\ttmp = gtk_imhtml_get_current_forecolor(GTK_IMHTML(toolbar->imhtml));\n\ttoggle_button_set_active_block(GTK_TOGGLE_BUTTON(toolbar->fgcolor),\n\t\t\t\t\t\t\t\t   (tmp != NULL), toolbar);\n\tif (tmp != NULL) {\n\t\tgchar *markup = g_strdup_printf(\"<span foreground=\\\"%s\\\">%s</span>\",\n\t\t\t\ttmp, gtk_label_get_label(label));\n\t\tgtk_label_set_markup_with_mnemonic(label, markup);\n\t\tg_free(markup);\n\t}\n\tg_free(tmp);\n\ttmp = gtk_imhtml_get_current_backcolor(GTK_IMHTML(toolbar->imhtml));\n\ttmp2 = gtk_imhtml_get_current_background(GTK_IMHTML(toolbar->imhtml));\n\ttoggle_button_set_active_block(GTK_TOGGLE_BUTTON(toolbar->bgcolor),\n\t\t\t\t\t\t\t\t   (tmp != NULL || tmp2 != NULL), toolbar);\n\tif (tmp != NULL) {\n\t\tgchar *markup = g_strdup_printf(\"<span background=\\\"%s\\\">%s</span>\",\n\t\t\t\ttmp, gtk_label_get_label(label));\n\t\tgtk_label_set_markup_with_mnemonic(label, markup);\n\t\tg_free(markup);\n\t}\n\tg_free(tmp);\n\tg_free(tmp2);\n}\n", "bug_type": null, "idx": 186}
{"project": "Pidgin", "target": 0, "func": "static gint\ndes3_encrypt(PurpleCipherContext *context, const guchar data[],\n             size_t len, guchar output[], size_t *outlen)\n{\n\tstruct _des3_ctx *ctx = purple_cipher_context_get_data(context);\n\tif (ctx->mode == PURPLE_CIPHER_BATCH_MODE_ECB) {\n\t\treturn des3_ecb_encrypt(ctx, data, len, output, outlen);\n\t} else if (ctx->mode == PURPLE_CIPHER_BATCH_MODE_CBC) {\n\t\treturn des3_cbc_encrypt(ctx, data, len, output, outlen);\n\t} else {\n\t\tg_return_val_if_reached(0);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 187}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_status_box_pulse_typing(PidginStatusBox *status_box)\n{\n\tif (!typing_stock_ids[++status_box->typing_index])\n\t\tstatus_box->typing_index = 0;\n\tpidgin_status_box_refresh(status_box);\n}\n", "bug_type": null, "idx": 188}
{"project": "Pidgin", "target": 0, "func": "static void*\npidgin_notify_get_handle(void)\n{\n\tstatic int handle;\n\treturn &handle;\n}\n", "bug_type": null, "idx": 189}
{"project": "Pidgin", "target": 0, "func": "void *\nfinch_pounces_get_handle()\n{\n\tstatic int handle;\n\treturn &handle;\n}\n", "bug_type": null, "idx": 190}
{"project": "Pidgin", "target": 0, "func": "PurpleEventLoopUiOps *\npurple_eventloop_get_ui_ops(void)\n{\n\tg_return_val_if_fail(eventloop_ui_ops != NULL, NULL);\n\treturn eventloop_ui_ops;\n}\n", "bug_type": null, "idx": 191}
{"project": "Pidgin", "target": 0, "func": "gboolean _mdns_publish(BonjourDnsSd *data, PublishType type, GSList *records) {\n\tTXTRecordRef dns_data;\n\tgboolean ret = TRUE;\n\tDNSServiceErrorType errorCode = kDNSServiceErr_NoError;\n\tWin32SessionImplData *idata = data->mdns_impl_data;\n\tg_return_val_if_fail(idata != NULL, FALSE);\n\tTXTRecordCreate(&dns_data, 256, NULL);\n\twhile (records) {\n\t\tPurpleKeyValuePair *kvp = records->data;\n\t\terrorCode = TXTRecordSetValue(&dns_data, kvp->key, strlen(kvp->value), kvp->value);\n\t\tif (errorCode != kDNSServiceErr_NoError)\n\t\t\tbreak;\n\t\trecords = records->next;\n\t}\n\tif (errorCode != kDNSServiceErr_NoError) {\n\t\tpurple_debug_error(\"bonjour\", \"Unable to allocate memory for text record.(%d)\\n\", errorCode);\n\t\tret = FALSE;\n\t} else {\n\t\t\n\t\tDNSServiceRef presence_sr;\n\t\tswitch (type) {\n\t\t\tcase PUBLISH_START:\n\t\t\t\tpurple_debug_info(\"bonjour\", \"Registering presence on port %d\\n\", data->port_p2pj);\n\t\t\t\terrorCode = DNSServiceRegister(&presence_sr, kDNSServiceInterfaceIndexAny,\n\t\t\t\t\t0, bonjour_get_jid(data->account), LINK_LOCAL_RECORD_NAME,\n\t\t\t\t\tNULL, NULL, htons(data->port_p2pj), TXTRecordGetLength(&dns_data), TXTRecordGetBytesPtr(&dns_data),\n\t\t\t\t\t_mdns_service_register_callback, NULL);\n\t\t\t\tbreak;\n\t\t\tcase PUBLISH_UPDATE:\n\t\t\t\tpurple_debug_info(\"bonjour\", \"Updating presence.\\n\");\n\t\t\t\terrorCode = DNSServiceUpdateRecord(idata->presence_query->sdRef, NULL, 0, TXTRecordGetLength(&dns_data), TXTRecordGetBytesPtr(&dns_data), 0);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (errorCode != kDNSServiceErr_NoError) {\n\t\t\tpurple_debug_error(\"bonjour\", \"Failed to publish presence service.(%d)\\n\", errorCode);\n\t\t\tret = FALSE;\n\t\t} else if (type == PUBLISH_START) {\n\t\t\t\n\t\t\tidata->presence_query = g_new(DnsSDServiceRefHandlerData, 1);\n\t\t\tidata->presence_query->sdRef = presence_sr;\n\t\t\tidata->presence_query->account = data->account;\n\t\t\tidata->presence_query->input_handler = purple_input_add(DNSServiceRefSockFD(presence_sr),\n\t\t\t\tPURPLE_INPUT_READ, _mdns_handle_event, idata->presence_query);\n\t\t}\n\t}\n\t\n\tTXTRecordDeallocate(&dns_data);\n\treturn ret;\n}\n", "bug_type": null, "idx": 192}
{"project": "Pidgin", "target": 0, "func": "static void\nscore_pref_changed_cb(const char *name, PurplePrefType type,\n\t\t\t\t\t  gconstpointer value, gpointer data)\n{\n\tint index = GPOINTER_TO_INT(data);\n\tprimitive_scores[index] = GPOINTER_TO_INT(value);\n}\n", "bug_type": null, "idx": 193}
{"project": "Pidgin", "target": 0, "func": "GType\ngnt_text_view_get_gtype(void)\n{\n\tstatic GType type = 0;\n\tif(type == 0)\n\t{\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(GntTextViewClass),\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tNULL,\t\t\t\t\t\n\t\t\t(GClassInitFunc)gnt_text_view_class_init,\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tsizeof(GntTextView),\n\t\t\t0,\t\t\t\t\t\t\n\t\t\tgnt_text_view_init,\t\t\t\n\t\t\tNULL\t\t\t\t\t\n\t\t};\n\t\ttype = g_type_register_static(GNT_TYPE_WIDGET,\n\t\t\t\t\t\t\t\t\t  \"GntTextView\",\n\t\t\t\t\t\t\t\t\t  &info, 0);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 194}
{"project": "Pidgin", "target": 0, "func": "GHashTable *silcpurple_chat_info_defaults(PurpleConnection *gc, const char *chat_name)\n{\n\tGHashTable *defaults;\n\tdefaults = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);\n\tif (chat_name != NULL)\n\t\tg_hash_table_insert(defaults, \"channel\", g_strdup(chat_name));\n\treturn defaults;\n}\n", "bug_type": null, "idx": 195}
{"project": "Pidgin", "target": 0, "func": "GList *\npurple_media_get_codecs(PurpleMedia *media, const gchar *sess_id)\n{\n#ifdef USE_VV\n\tg_return_val_if_fail(PURPLE_IS_MEDIA(media), NULL);\n\treturn purple_media_backend_get_codecs(media->priv->backend, sess_id);\n#else\n\treturn NULL;\n#endif\n}\n", "bug_type": null, "idx": 196}
{"project": "Pidgin", "target": 0, "func": "static GList *irc_actions(PurplePlugin *plugin, gpointer context)\n{\n\tGList *list = NULL;\n\tPurplePluginAction *act = NULL;\n\tact = purple_plugin_action_new(_(\"View MOTD\"), irc_view_motd);\n\tlist = g_list_append(list, act);\n\treturn list;\n}\n", "bug_type": null, "idx": 197}
{"project": "Pidgin", "target": 0, "func": "int irc_cmd_topic(struct irc_conn *irc, const char *cmd, const char *target, const char **args)\n{\n\tchar *buf;\n\tconst char *topic;\n\tPurpleConversation *convo;\n\tif (!args)\n\t\treturn 0;\n\tconvo = purple_find_conversation_with_account(PURPLE_CONV_TYPE_CHAT, target, irc->account);\n\tif (!convo)\n\t\treturn 0;\n\tif (!args[0]) {\n\t\ttopic = purple_conv_chat_get_topic (PURPLE_CONV_CHAT(convo));\n\t\tif (topic) {\n\t\t\tchar *tmp, *tmp2;\n\t\t\ttmp = g_markup_escape_text(topic, -1);\n\t\t\ttmp2 = purple_markup_linkify(tmp);\n\t\t\tbuf = g_strdup_printf(_(\"current topic is: %s\"), tmp2);\n\t\t\tg_free(tmp);\n\t\t\tg_free(tmp2);\n\t\t} else\n\t\t\tbuf = g_strdup(_(\"No topic is set\"));\n\t\tpurple_conv_chat_write(PURPLE_CONV_CHAT(convo), target, buf, PURPLE_MESSAGE_SYSTEM|PURPLE_MESSAGE_NO_LOG, time(NULL));\n\t\tg_free(buf);\n\t\treturn 0;\n\t}\n\tbuf = irc_format(irc, \"vt:\", \"TOPIC\", target, args[0]);\n\tirc_send(irc, buf);\n\tg_free(buf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 198}
{"project": "Pidgin", "target": 0, "func": "static PurpleCmdRet zephyr_purple_cmd_zc(PurpleConversation *conv,\n\t\t\t\t     const char *cmd, char **args, char **error, void *data)\n{\n\t\n\tzephyr_account *zephyr = purple_conversation_get_gc(conv)->proto_data;\n\tif ( zephyr_send_message(zephyr,args[0],\"PERSONAL\",\"\",args[1],zephyr_get_signature(),\"\"))\n\t\treturn PURPLE_CMD_RET_OK;\n\telse\n\t\treturn PURPLE_CMD_RET_FAILED;\n}\n", "bug_type": null, "idx": 199}
{"project": "Pidgin", "target": 1, "func": "\n\nstatic void\nsilc_channel_message(SilcClient client, SilcClientConnection conn,\n\t\t     SilcClientEntry sender, SilcChannelEntry channel,\n\t\t     SilcMessagePayload payload,\n\t\t     SilcChannelPrivateKey key, SilcMessageFlags flags,\n\t\t     const unsigned char *message,\n\t\t     SilcUInt32 message_len)\n{\n\tPurpleConnection *gc = client->application;\n\tSilcPurple sg = gc->proto_data;\n\tPurpleConversation *convo = NULL;\n\tchar *msg, *tmp;\n\n\tif (!message)\n\t\treturn;\n\n\tif (key) {\n\t\tGList *l;\n\t\tSilcPurplePrvgrp prv;\n\n\t\tfor (l = sg->grps; l; l = l->next)\n\t\t\tif (((SilcPurplePrvgrp)l->data)->key == key) {\n\t\t\t\tprv = l->data;\n\t\t\t\tconvo = purple_find_conversation_with_account(PURPLE_CONV_TYPE_CHAT,\n\t\t\t\t\t\t\t\t\t\tprv->channel, sg->account);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif (!convo)\n\t\tconvo = purple_find_conversation_with_account(PURPLE_CONV_TYPE_CHAT,\n\t\t\t\t\t\t\t      channel->channel_name, sg->account);\n\tif (!convo)\n\t\treturn;\n\n\tif (flags & SILC_MESSAGE_FLAG_SIGNED &&\n\t    purple_account_get_bool(sg->account, \"sign-verify\", FALSE)) {\n\t\t\n\t}\n\n\tif (flags & SILC_MESSAGE_FLAG_DATA) {\n\t\t\n\t\tSilcMime mime;\n\t\tmime = silc_mime_decode(NULL, message, message_len);\n\t\tsilcpurple_mime_message(client, conn, sender, channel, payload,\n\t\t\t\t\tkey, flags, mime, FALSE);\n\t\treturn;\n\t}\n\n\tif (flags & SILC_MESSAGE_FLAG_ACTION) {\n\t\tmsg = g_strdup_printf(\"/me %s\",\n\t\t\t\t      (const char *)message);\n\t\tif (!msg)\n\t\t\treturn;\n\n\t\ttmp = g_markup_escape_text(msg, -1);\n\t\t\n\t\tserv_got_chat_in(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(convo)),\n\t\t\t\t sender->nickname, 0, tmp, time(NULL));\n\t\tg_free(tmp);\n\t\tg_free(msg);\n\t\treturn;\n\t}\n\n\tif (flags & SILC_MESSAGE_FLAG_NOTICE) {\n\t\tmsg = g_strdup_printf(\"(notice) <I>%s</I> %s\",\n\t\t\t\t      sender->nickname, (const char *)message);\n\t\tif (!msg)\n\t\t\treturn;\n\n\t\t\n\t\tpurple_conversation_write(convo, NULL, (const char *)msg,\n\t\t\t\t\tPURPLE_MESSAGE_SYSTEM, time(NULL));\n\t\tg_free(msg);\n\t\treturn;\n\t}\n\n\tif (flags & SILC_MESSAGE_FLAG_UTF8) {\n\t\ttmp = g_markup_escape_text((const char *)message, -1);\n\t\t\n\t\tserv_got_chat_in(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(convo)),\n\t\t\t\t sender->nickname, 0, tmp, time(NULL));\n\t\tg_free(tmp);\n\t}\n}\n\n", "bug_type": "CVE-2011-4603", "idx": 200}
{"project": "Pidgin", "target": 0, "func": "static void ggp_get_info(PurpleConnection *gc, const char *name)\n{\n\tGGPInfo *info = gc->proto_data;\n\tGGPSearchForm *form;\n\tguint32 seq;\n\tform = ggp_search_form_new(GGP_SEARCH_TYPE_INFO);\n\tform->user_data = info;\n\tform->uin = g_strdup(name);\n\tseq = ggp_search_start(gc, form);\n\tggp_search_add(info->searches, seq, form);\n\tpurple_debug_info(\"gg\", \"ggp_get_info(): Added seq %u\", seq);\n}\n", "bug_type": null, "idx": 201}
{"project": "Pidgin", "target": 0, "func": "#ifdef HAVE_DBUS\nstatic char *purple_dbus_owner_user_dir(void)\n{\n\tDBusMessage *msg = NULL, *reply = NULL;\n\tDBusConnection *dbus_connection = NULL;\n\tDBusError dbus_error;\n\tchar *remote_user_dir = NULL;\n\tif ((dbus_connection = purple_dbus_get_connection()) == NULL)\n\t\treturn NULL;\n\tif ((msg = dbus_message_new_method_call(DBUS_SERVICE_PURPLE, DBUS_PATH_PURPLE, DBUS_INTERFACE_PURPLE, \"PurpleUserDir\")) == NULL)\n\t\treturn NULL;\n\tdbus_error_init(&dbus_error);\n\treply = dbus_connection_send_with_reply_and_block(dbus_connection, msg, 5000, &dbus_error);\n\tdbus_message_unref(msg);\n\tdbus_error_free(&dbus_error);\n\tif (reply)\n\t{\n\t\tdbus_error_init(&dbus_error);\n\t\tdbus_message_get_args(reply, &dbus_error, DBUS_TYPE_STRING, &remote_user_dir, DBUS_TYPE_INVALID);\n\t\tremote_user_dir = g_strdup(remote_user_dir);\n\t\tdbus_error_free(&dbus_error);\n\t\tdbus_message_unref(reply);\n\t}\n\treturn remote_user_dir;\n}\n", "bug_type": null, "idx": 202}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_dcc_fill_file_info(struct gg_dcc *d, const char *filename)\n{\n\treturn gg_dcc_fill_file_info2(d, filename, filename);\n}\n", "bug_type": null, "idx": 203}
{"project": "Pidgin", "target": 0, "func": "\nstatic GList *amsn_logger_list(PurpleLogType type, const char *sn, PurpleAccount *account)\n{\n\tGList *list = NULL;\n\tconst char *logdir;\n\tchar *username;\n\tchar *log_path;\n\tchar *buddy_log;\n\tchar *filename;\n\tGDir *dir;\n\tconst char *name;\n\tlogdir = purple_prefs_get_string(\"/plugins/core/log_reader/amsn/log_directory\");\n\t\n\tif (!logdir || !*logdir)\n\t\treturn NULL;\n\t\n\tif (strcmp(account->protocol_id, \"prpl-msn\"))\n\t\treturn NULL;\n\tusername = g_strdup(purple_normalize(account, account->username));\n\tbuddy_log = g_strdup_printf(\"%s.log\", purple_normalize(account, sn));\n\tlog_path = g_build_filename(logdir, username, \"logs\", NULL);\n\t\n\tfilename = g_build_filename(log_path, buddy_log, NULL);\n\tif (g_file_test(filename, G_FILE_TEST_EXISTS))\n\t\tlist = amsn_logger_parse_file(filename, sn, account);\n\telse\n\t\tg_free(filename);\n\t\n\tdir = g_dir_open(log_path, 0, NULL);\n\tif (dir) {\n\t\twhile ((name = g_dir_read_name(dir)) != NULL) {\n\t\t\tfilename = g_build_filename(log_path, name, buddy_log, NULL);\n\t\t\tif (g_file_test(filename, G_FILE_TEST_EXISTS))\n\t\t\t\tlist = g_list_concat(list, amsn_logger_parse_file(filename, sn, account));\n\t\t\tg_free(filename);\n\t\t}\n\t\tg_dir_close(dir);\n\t}\n\tg_free(log_path);\n\t\n\tpurple_util_chrreplace(username, '@', '_');\n\tpurple_util_chrreplace(username, '.', '_');\n\tlog_path = g_build_filename(logdir, username, \"logs\", NULL);\n\t\n\tfilename = g_build_filename(log_path, buddy_log, NULL);\n\tif (g_file_test(filename, G_FILE_TEST_EXISTS))\n\t\tlist = g_list_concat(list, amsn_logger_parse_file(filename, sn, account));\n\tg_free(filename);\n\t\n\tdir = g_dir_open(log_path, 0, NULL);\n\tif (dir) {\n\t\twhile ((name = g_dir_read_name(dir)) != NULL) {\n\t\t\tfilename = g_build_filename(log_path, name, buddy_log, NULL);\n\t\t\tif (g_file_test(filename, G_FILE_TEST_EXISTS))\n\t\t\t\tlist = g_list_concat(list, amsn_logger_parse_file(filename, sn, account));\n\t\t\tg_free(filename);\n\t\t}\n\t\tg_dir_close(dir);\n\t}\n\tg_free(log_path);\n\tg_free(username);\n\tg_free(buddy_log);\n\treturn list;\n}\n", "bug_type": null, "idx": 204}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nmatch_string(const char *category, const char *args)\n{\n\tconst char *str = gnt_entry_get_text(GNT_ENTRY(debug.search));\n\tif (!str || !*str)\n\t\treturn TRUE;\n\tif (g_strrstr(category, str) != NULL)\n\t\treturn TRUE;\n\tif (g_strrstr(args, str) != NULL)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 205}
{"project": "Pidgin", "target": 0, "func": "static void\ngoogle_session_state_changed_cb(PurpleMedia *media, PurpleMediaState state,\n\t\tgchar *sid, gchar *name, GoogleSession *session)\n{\n\tif (sid == NULL && name == NULL) {\n\t\tif (state == PURPLE_MEDIA_STATE_END) {\n\t\t\tgoogle_session_destroy(session);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 206}
{"project": "Pidgin", "target": 0, "func": "};\nstatic void ice_process_messages(gpointer data, gint fd,\n\t\t\t\t\t\t\t\t PurpleInputCondition condition) {\n\tstruct ice_connection_info *conninfo = (struct ice_connection_info*) data;\n\tIceProcessMessagesStatus status;\n\t\n\tstatus = IceProcessMessages(conninfo->connection, NULL, NULL);\n\tif (status == IceProcessMessagesIOError) {\n\t\tpurple_debug(PURPLE_DEBUG_INFO, \"Session Management\",\n\t\t\t\t   \"ICE IO error, closing connection... \");\n\t\t\n\t\tIceSetShutdownNegotiation(conninfo->connection, False);\n\t\tIceCloseConnection(conninfo->connection);\n\t\tpurple_debug(PURPLE_DEBUG_INFO, NULL, \"done.\\n\");\n\t\t\n\t\tpurple_input_remove(conninfo->input_id);\n\t}\n}\n", "bug_type": null, "idx": 207}
{"project": "Pidgin", "target": 0, "func": "static void simple_buddy_resub(char *name, struct simple_buddy *buddy, struct simple_account_data *sip) {\n\ttime_t curtime = time(NULL);\n\tpurple_debug_info(\"simple\", \"buddy resub\\n\");\n\tif(buddy->resubscribe < curtime) {\n\t\tpurple_debug(PURPLE_DEBUG_MISC, \"simple\", \"simple_buddy_resub %s\\n\", name);\n\t\tsimple_subscribe(sip, buddy);\n\t}\n}\n", "bug_type": null, "idx": 208}
{"project": "Pidgin", "target": 0, "func": "void\npurple_prefs_add_path_list(const char *name, GList *value)\n{\n\tstruct purple_pref *pref;\n\tGList *tmp;\n\t\n\tPURPLE_PREFS_UI_OP_CALL(add_string_list, name, value);\n\tpref = add_pref(PURPLE_PREF_PATH_LIST, name);\n\tif(!pref)\n\t\treturn;\n\tfor(tmp = value; tmp; tmp = tmp->next)\n\t\tpref->value.stringlist = g_list_append(pref->value.stringlist,\n\t\t\t\tg_strdup(tmp->data));\n}\n", "bug_type": null, "idx": 209}
{"project": "Pidgin", "target": 0, "func": "static gboolean purple_ssi_rerequestdata(gpointer data) {\n\tOscarData *od = data;\n\taim_ssi_reqdata(od);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 210}
{"project": "Pidgin", "target": 0, "func": "GList *\npurple_perl_plugin_actions(PurplePlugin *plugin, gpointer context)\n{\n\tGList *l = NULL;\n\tPurplePerlScript *gps;\n\tint i = 0, count = 0;\n\tdSP;\n\tgps = plugin->info->extra_info;\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\tXPUSHs(sv_2mortal(purple_perl_bless_object(plugin, \"Purple::Plugin\")));\n\t\n\tif (context != NULL)\n\t\tXPUSHs(sv_2mortal(purple_perl_bless_object(context,\n\t\t                                         \"Purple::Connection\")));\n\telse\n\t\tXPUSHs(&PL_sv_undef);\n\tPUTBACK;\n\tcount = call_pv(gps->plugin_action_sub, G_EVAL | G_ARRAY);\n\tSPAGAIN;\n\tif (SvTRUE(ERRSV)) {\n\t\tpurple_debug_error(\"perl\",\n\t\t                 \"Perl plugin actions lookup exited abnormally: %s\\n\",\n\t\t                 SvPVutf8_nolen(ERRSV));\n\t}\n\tif (count == 0)\n\t\tcroak(\"The plugin_actions sub didn't return anything.\\n\");\n\tfor (i = 0; i < count; i++) {\n\t\tSV *sv;\n\t\tPurplePluginAction *act;\n\t\tsv = POPs;\n\t\tact = purple_plugin_action_new(SvPVutf8_nolen(sv), purple_perl_plugin_action_cb);\n\t\tl = g_list_prepend(l, act);\n\t}\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n\treturn l;\n}\n", "bug_type": null, "idx": 211}
{"project": "Pidgin", "target": 0, "func": "int byte_stream_getrawbuf(ByteStream *bs, guint8 *buf, size_t len)\n{\n\tg_return_val_if_fail(byte_stream_bytes_left(bs) >= len, 0);\n\tbyte_stream_getrawbuf_nocheck(bs, buf, len);\n\treturn len;\n}\n", "bug_type": null, "idx": 212}
{"project": "Pidgin", "target": 0, "func": "static size_t\nrequired_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t       const void *member)\n{\n\tsize_t rv = get_tag_size(field->id);\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\treturn rv + sint32_size(*(const int32_t *) member);\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\treturn rv + int32_size(*(const uint32_t *) member);\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\treturn rv + uint32_size(*(const uint32_t *) member);\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\treturn rv + sint64_size(*(const int64_t *) member);\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\treturn rv + uint64_size(*(const uint64_t *) member);\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\treturn rv + 4;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\treturn rv + 8;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\treturn rv + 1;\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\treturn rv + 4;\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\treturn rv + 8;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\t\t\n\t\treturn rv + uint32_size(*(const uint32_t *) member);\n\tcase PROTOBUF_C_TYPE_STRING: {\n\t\tconst char *str = *(char * const *) member;\n\t\tsize_t len = str ? strlen(str) : 0;\n\t\treturn rv + uint32_size(len) + len;\n\t}\n\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\tsize_t len = ((const ProtobufCBinaryData *) member)->len;\n\t\treturn rv + uint32_size(len) + len;\n\t}\n\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\tconst ProtobufCMessage *msg = *(ProtobufCMessage * const *) member;\n\t\tsize_t subrv = msg ? protobuf_c_message_get_packed_size(msg) : 0;\n\t\treturn rv + uint32_size(subrv) + subrv;\n\t}\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n", "bug_type": null, "idx": 213}
{"project": "Pidgin", "target": 0, "func": "static gboolean xmpp_uri_handler(const char *proto, const char *user, GHashTable *params)\n{\n\tchar *acct_id = params ? g_hash_table_lookup(params, \"account\") : NULL;\n\tPurpleAccount *acct;\n\tif (g_ascii_strcasecmp(proto, \"xmpp\"))\n\t\treturn FALSE;\n\tacct = find_acct(purple_plugin_get_id(my_protocol), acct_id);\n\tif (!acct)\n\t\treturn FALSE;\n\t\n\t\n\tif (!params || g_hash_table_lookup_extended(params, \"message\", NULL, NULL)) {\n\t\tchar *body = g_hash_table_lookup(params, \"body\");\n\t\tif (user && *user) {\n\t\t\tPurpleConversation *conv =\n\t\t\t\t\tpurple_conversation_new(PURPLE_CONV_TYPE_IM, acct, user);\n\t\t\tpurple_conversation_present(conv);\n\t\t\tif (body && *body)\n\t\t\t\tpurple_conv_send_confirm(conv, body);\n\t\t}\n\t} else if (g_hash_table_lookup_extended(params, \"roster\", NULL, NULL)) {\n\t\tchar *name = g_hash_table_lookup(params, \"name\");\n\t\tif (user && *user)\n\t\t\tpurple_blist_request_add_buddy(acct, user, NULL, name);\n\t} else if (g_hash_table_lookup_extended(params, \"join\", NULL, NULL)) {\n\t\tPurpleConnection *gc = purple_account_get_connection(acct);\n\t\tif (user && *user) {\n\t\t\tGHashTable *params = jabber_chat_info_defaults(gc, user);\n\t\t\tjabber_chat_join(gc, params);\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 214}
{"project": "Pidgin", "target": 0, "func": "const char *irc_nick_skip_mode(struct irc_conn *irc, const char *nick)\n{\n\tstatic const char *default_modes = \"@+%&\";\n\tconst char *mode_chars;\n\tmode_chars = irc->mode_chars ? irc->mode_chars : default_modes;\n\twhile (strchr(mode_chars, *nick) != NULL)\n\t\tnick++;\n\treturn nick;\n}\n", "bug_type": null, "idx": 215}
{"project": "Pidgin", "target": 0, "func": "static PurpleTheme *\npurple_sound_loader_build(const gchar *dir)\n{\n\txmlnode *root_node = NULL, *sub_node;\n\tgchar *filename_full, *data = NULL;\n\tPurpleSoundTheme *theme = NULL;\n\tconst gchar *name;\n\t\n\tg_return_val_if_fail(dir != NULL, NULL);\n\tfilename_full = g_build_filename(dir, \"theme.xml\", NULL);\n\tif (g_file_test(filename_full, G_FILE_TEST_IS_REGULAR))\n\t\troot_node = xmlnode_from_file(dir, \"theme.xml\", \"sound themes\", \"sound-theme-loader\");\n\tg_free(filename_full);\n\tif (root_node == NULL)\n\t\treturn NULL;\n\tname = xmlnode_get_attrib(root_node, \"name\");\n\tif (name && purple_strequal(xmlnode_get_attrib(root_node, \"type\"), \"sound\")) {\n\t\t\n\t\tsub_node = xmlnode_get_child(root_node, \"description\");\n\t\tdata = xmlnode_get_data(sub_node);\n\t\tif (xmlnode_get_attrib(root_node, \"name\") != NULL) {\n\t\t\ttheme = g_object_new(PURPLE_TYPE_SOUND_THEME,\n\t\t\t\t\t\"type\", \"sound\",\n\t\t\t\t\t\"name\", name,\n\t\t\t\t\t\"author\", xmlnode_get_attrib(root_node, \"author\"),\n\t\t\t\t\t\"image\", xmlnode_get_attrib(root_node, \"image\"),\n\t\t\t\t\t\"directory\", dir,\n\t\t\t\t\t\"description\", data, NULL);\n\t\t\tsub_node = xmlnode_get_child(root_node, \"event\");\n\t\t\twhile (sub_node) {\n\t\t\t\tpurple_sound_theme_set_file(theme,\n\t\t\t\t\t\txmlnode_get_attrib(sub_node, \"name\"),\n\t\t\t\t\t\txmlnode_get_attrib(sub_node, \"file\"));\n\t\t\t\tsub_node = xmlnode_get_next_twin(sub_node);\n\t\t\t}\n\t\t}\n\t} else purple_debug_warning(\"sound-theme-loader\", \"Missing attribute or problem with the root element\\n\");\n\txmlnode_free(root_node);\n\tg_free(data);\n\treturn PURPLE_THEME(theme);\n}\n", "bug_type": null, "idx": 216}
{"project": "Pidgin", "target": 0, "func": "GType\njingle_rawudp_candidate_get_type()\n{\n\tstatic GType type = 0;\n\tif (type == 0) {\n\t\ttype = g_boxed_type_register_static(\"JingleRawUdpCandidate\",\n\t\t\t\t(GBoxedCopyFunc)jingle_rawudp_candidate_copy,\n\t\t\t\t(GBoxedFreeFunc)jingle_rawudp_candidate_free);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 217}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_status_icon_theme_class_init(PidginStatusIconThemeClass *klass)\n{\n\tGObjectClass *obj_class = G_OBJECT_CLASS(klass);\n\tparent_class = g_type_class_peek_parent(klass);\n\tobj_class->finalize = pidgin_status_icon_theme_finalize;\n}\n", "bug_type": null, "idx": 218}
{"project": "Pidgin", "target": 0, "func": "static size_t\nrepeated_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t      unsigned count, const void *member,\n\t\t\t      ProtobufCBuffer *buffer)\n{\n\tchar *array = *(char * const *) member;\n\tif (count == 0)\n\t\treturn 0;\n\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {\n\t\tuint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];\n\t\tsize_t rv = tag_pack(field->id, scratch);\n\t\tsize_t payload_len = get_packed_payload_length(field, count, array);\n\t\tsize_t tmp;\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\trv += uint32_pack(payload_len, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\ttmp = pack_buffer_packed_payload(field, count, array, buffer);\n\t\tassert(tmp == payload_len);\n\t\treturn rv + payload_len;\n\t} else {\n\t\tsize_t siz;\n\t\tunsigned i;\n\t\t\n\t\tunsigned rv = 0;\n\t\tsiz = sizeof_elt_in_repeated_array(field->type);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\trv += required_field_pack_to_buffer(field, array, buffer);\n\t\t\tarray = ((char*)array) + siz;\n\t\t}\n\t\treturn rv;\n\t}\n}\n", "bug_type": null, "idx": 219}
{"project": "Pidgin", "target": 0, "func": "static void\ninitialize_profile(const char *name, PurplePrefType type, gconstpointer val, gpointer null)\n{\n\tFinchSoundEvent *event;\n\tif (purple_prefs_exists(make_pref(\"\")))\n\t\treturn;\n\tpurple_prefs_add_none(make_pref(\"\"));\n\tpurple_prefs_add_none(make_pref(\"/enabled\"));\n\tpurple_prefs_add_none(make_pref(\"/file\"));\n\tfor (event = sounds; event - sounds < PURPLE_NUM_SOUNDS; event++) {\n\t\tchar pref[512];\n\t\tg_snprintf(pref, sizeof(pref), \"/enabled/%s\", event->pref);\n\t\tpurple_prefs_add_bool(make_pref(pref), FALSE);\n\t\tg_snprintf(pref, sizeof(pref), \"/file/%s\", event->pref);\n\t\tpurple_prefs_add_path(make_pref(pref), \"\");\n\t}\n\tpurple_prefs_add_bool(make_pref(\"/conv_focus\"), FALSE);\n\tpurple_prefs_add_bool(make_pref(\"/mute\"), FALSE);\n\tpurple_prefs_add_path(make_pref(\"/command\"), \"\");\n\tpurple_prefs_add_string(make_pref(\"/method\"), \"automatic\");\n\tpurple_prefs_add_int(make_pref(\"/volume\"), 50);\n}\n", "bug_type": null, "idx": 220}
{"project": "Pidgin", "target": 0, "func": "void gnt_tree_set_choice(GntTree *tree, void *key, gboolean set)\n{\n\tGntTreeRow *row = g_hash_table_lookup(tree->hash, key);\n\tif (!row)\n\t\treturn;\n\tg_return_if_fail(row->choice);\n\trow->isselected = set;\n\tredraw_tree(tree);\n}\n", "bug_type": null, "idx": 221}
{"project": "Pidgin", "target": 0, "func": "static void update_buddy_metadata(JabberStream *js, const char *from, xmlnode *items);\nvoid jabber_avatar_init(void)\n{\n\tjabber_add_feature(NS_AVATAR_1_1_METADATA,\n\t                   jabber_pep_namespace_only_when_pep_enabled_cb);\n\tjabber_add_feature(NS_AVATAR_1_1_DATA,\n\t                   jabber_pep_namespace_only_when_pep_enabled_cb);\n\tjabber_pep_register_handler(NS_AVATAR_1_1_METADATA,\n\t                            update_buddy_metadata);\n}\n", "bug_type": null, "idx": 222}
{"project": "Pidgin", "target": 0, "func": "PurpleConvChatBuddy *\npurple_conv_chat_cb_find(PurpleConvChat *chat, const char *name)\n{\n\tg_return_val_if_fail(chat != NULL, NULL);\n\tg_return_val_if_fail(name != NULL, NULL);\n\treturn g_hash_table_lookup(chat->users, name);\n}\n", "bug_type": null, "idx": 223}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_status_attr_get_id(const PurpleStatusAttr *attr)\n{\n\tg_return_val_if_fail(attr != NULL, NULL);\n\treturn attr->id;\n}\n", "bug_type": null, "idx": 224}
{"project": "Pidgin", "target": 0, "func": "void gnt_slider_set_large_step(GntSlider *slider, int step)\n{\n\tslider->largestep = step;\n}\n", "bug_type": null, "idx": 225}
{"project": "Pidgin", "target": 0, "func": "void jabber_pep_register_handler(const char *xmlns, JabberPEPHandler handlerfunc) {\n\tgchar *notifyns = g_strdup_printf(\"%s+notify\", xmlns);\n\tjabber_add_feature(notifyns, NULL); \n\tg_free(notifyns);\n\tg_hash_table_replace(pep_handlers, g_strdup(xmlns), handlerfunc);\n}\n", "bug_type": null, "idx": 226}
{"project": "Pidgin", "target": 0, "func": "static void\nreset_blist_node_ui_data(PurpleBlistNode *node)\n{\n\tFinchBlistNode *fnode = FINCH_GET_DATA(node);\n\tif (fnode == NULL)\n\t\treturn;\n\tif (fnode->signed_timer)\n\t\tpurple_timeout_remove(fnode->signed_timer);\n\tg_free(fnode);\n\tFINCH_SET_DATA(node, NULL);\n}\n", "bug_type": null, "idx": 227}
{"project": "Pidgin", "target": 0, "func": "static void jabber_sasl_build_callbacks(JabberStream *);\nstatic void disallow_plaintext_auth(PurpleAccount *account)\n{\n\tpurple_connection_error_reason(purple_account_get_connection(account),\n\t\tPURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR,\n\t\t_(\"Server may require plaintext authentication over an unencrypted stream\"));\n}\n", "bug_type": null, "idx": 228}
{"project": "Pidgin", "target": 0, "func": "JingleTransport *\njingle_transport_parse_internal(xmlnode *transport)\n{\n\tconst gchar *type = xmlnode_get_namespace(transport);\n\treturn jingle_transport_create(type);\n}\n", "bug_type": null, "idx": 229}
{"project": "Pidgin", "target": 0, "func": "static void\npounces_manager_close_cb(GtkButton *button, gpointer user_data)\n{\n\tpidgin_pounces_manager_hide();\n}\n", "bug_type": null, "idx": 230}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_chat_getinfo_menu(PurpleBlistNode *node, gpointer data)\n{\n\tPurpleChat *chat = (PurpleChat *)node;\n\tsilcpurple_chat_getinfo(chat->account->gc, chat->components);\n}\n", "bug_type": null, "idx": 231}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_gmail_parse(JabberStream *js, const char *from,\n                   JabberIqType type, const char *id,\n                   xmlnode *packet, gpointer nul)\n{\n\txmlnode *child;\n\txmlnode *message;\n\tconst char *to, *url;\n\tconst char *in_str;\n\tchar *to_name;\n\tint i, count = 1, returned_count;\n\tconst char **tos, **froms, **urls;\n\tchar **subjects;\n\tif (type == JABBER_IQ_ERROR)\n\t\treturn;\n\tchild = xmlnode_get_child(packet, \"mailbox\");\n\tif (!child)\n\t\treturn;\n\tin_str = xmlnode_get_attrib(child, \"total-matched\");\n\tif (in_str && *in_str)\n\t\tcount = atoi(in_str);\n\t\n\tto = xmlnode_get_attrib(packet, \"to\");\n\tmessage = xmlnode_get_child(child, \"mail-thread-info\");\n\tif (count == 0 || !message) {\n\t\tif (count > 0) {\n\t\t\tchar *bare_jid = jabber_get_bare_jid(to);\n\t\t\tconst char *default_tos[2] = { bare_jid };\n\t\t\tpurple_notify_emails(js->gc, count, FALSE, NULL, NULL, default_tos, NULL, NULL, NULL);\n\t\t\tg_free(bare_jid);\n\t\t} else {\n\t\t\tpurple_notify_emails(js->gc, count, FALSE, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor (returned_count = 0; message; returned_count++, message=xmlnode_get_next_twin(message));\n\tfroms    = g_new0(const char* , returned_count + 1);\n\ttos      = g_new0(const char* , returned_count + 1);\n\tsubjects = g_new0(char* , returned_count + 1);\n\turls     = g_new0(const char* , returned_count + 1);\n\tto = xmlnode_get_attrib(packet, \"to\");\n\tto_name = jabber_get_bare_jid(to);\n\turl = xmlnode_get_attrib(child, \"url\");\n\tif (!url || !*url)\n\t\turl = \"http://www.gmail.com\";\n\tmessage= xmlnode_get_child(child, \"mail-thread-info\");\n\tfor (i=0; message; message = xmlnode_get_next_twin(message), i++) {\n\t\txmlnode *sender_node, *subject_node;\n\t\tconst char *from, *tid;\n\t\tchar *subject;\n\t\tsubject_node = xmlnode_get_child(message, \"subject\");\n\t\tsender_node  = xmlnode_get_child(message, \"senders\");\n\t\tsender_node  = xmlnode_get_child(sender_node, \"sender\");\n\t\twhile (sender_node && (!xmlnode_get_attrib(sender_node, \"unread\") ||\n\t\t       !strcmp(xmlnode_get_attrib(sender_node, \"unread\"),\"0\")))\n\t\t\tsender_node = xmlnode_get_next_twin(sender_node);\n\t\tif (!sender_node) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tfrom = xmlnode_get_attrib(sender_node, \"name\");\n\t\tif (!from || !*from)\n\t\t\tfrom = xmlnode_get_attrib(sender_node, \"address\");\n\t\tsubject = xmlnode_get_data(subject_node);\n\t\t\n\t\ttos[i] = (to_name != NULL ?  to_name : \"\");\n\t\tfroms[i] = (from != NULL ?  from : \"\");\n\t\tsubjects[i] = (subject != NULL ? subject : g_strdup(\"\"));\n\t\turls[i] = url;\n\t\ttid = xmlnode_get_attrib(message, \"tid\");\n\t\tif (tid &&\n\t\t    (js->gmail_last_tid == NULL || strcmp(tid, js->gmail_last_tid) > 0)) {\n\t\t\tg_free(js->gmail_last_tid);\n\t\t\tjs->gmail_last_tid = g_strdup(tid);\n\t\t}\n\t}\n\tif (i>0)\n\t\tpurple_notify_emails(js->gc, count, count == i, (const char**) subjects, froms, tos,\n\t\t\t\turls, NULL, NULL);\n\tg_free(to_name);\n\tg_free(tos);\n\tg_free(froms);\n\tfor (i = 0; i < returned_count; i++)\n\t\tg_free(subjects[i]);\n\tg_free(subjects);\n\tg_free(urls);\n\tin_str = xmlnode_get_attrib(child, \"result-time\");\n\tif (in_str && *in_str) {\n\t\tg_free(js->gmail_last_time);\n\t\tjs->gmail_last_time = g_strdup(in_str);\n\t}\n}\n", "bug_type": null, "idx": 232}
{"project": "Pidgin", "target": 0, "func": "gboolean\njabber_audio_enabled(JabberStream *js, const char *namespace)\n{\n\tPurpleMediaManager *manager = purple_media_manager_get();\n\tPurpleMediaCaps caps = purple_media_manager_get_ui_caps(manager);\n\treturn (caps & (PURPLE_MEDIA_CAPS_AUDIO | PURPLE_MEDIA_CAPS_AUDIO_SINGLE_DIRECTION));\n}\n", "bug_type": null, "idx": 233}
{"project": "Pidgin", "target": 0, "func": "GtkWidget *\npidgin_status_box_new_with_account(PurpleAccount *account)\n{\n\treturn g_object_new(PIDGIN_TYPE_STATUS_BOX, \"account\", account,\n\t                    \"iconsel\", TRUE, NULL);\n}\n", "bug_type": null, "idx": 234}
{"project": "Pidgin", "target": 0, "func": "MonoObject* ml_invoke(MonoMethod *method, void *obj, void **params)\n{\n\tMonoObject *ret, *exception;\n\tret = mono_runtime_invoke(method, obj, params, &exception);\n\tif (exception) {\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"mono\", \"caught exception: %s\\n\", mono_class_get_name(mono_object_get_class(exception)));\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 235}
{"project": "Pidgin", "target": 0, "func": "static guint16\nget_buddy_list_type(OscarData *od)\n{\n\tPurpleAccount *account = purple_connection_get_account(od->gc);\n\treturn purple_account_is_status_active(account, OSCAR_STATUS_ID_INVISIBLE) ? AIM_SSI_TYPE_PERMIT : AIM_SSI_TYPE_DENY;\n}\n", "bug_type": null, "idx": 236}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_request_fields_exists(const PurpleRequestFields *fields, const char *id)\n{\n\tg_return_val_if_fail(fields != NULL, FALSE);\n\tg_return_val_if_fail(id     != NULL, FALSE);\n\treturn (g_hash_table_lookup(fields->fields, id) != NULL);\n}\n", "bug_type": null, "idx": 237}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nsearchresults_close_cb(PidginNotifySearchResultsData *data, GdkEvent *event, gpointer user_data)\n{\n\tpurple_notify_close(PURPLE_NOTIFY_SEARCHRESULTS, data);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 238}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nbox_focus_change(GntBox *box, gboolean next)\n{\n\tGntWidget *now;\n\tnow = box->active;\n\tif (next) {\n\t\tfind_next_focus(box);\n\t} else {\n\t\tfind_prev_focus(box);\n\t}\n\tif (now && now != box->active) {\n\t\tgnt_widget_set_focus(now, FALSE);\n\t\tgnt_widget_set_focus(box->active, TRUE);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 239}
{"project": "Pidgin", "target": 0, "func": "size_t purple_stringref_len(const PurpleStringref *stringref)\n{\n\treturn strlen(purple_stringref_value(stringref));\n}\n", "bug_type": null, "idx": 240}
{"project": "Pidgin", "target": 0, "func": "static char *jabber_prep_resource(char *input) {\n\tchar hostname[256], \n\t\t *dot = NULL;\n\t\n\tif (input == NULL || *input == '\\0')\n\t\treturn NULL;\n\tif (strstr(input, \"__HOSTNAME__\") == NULL)\n\t\treturn g_strdup(input);\n\t\n\tif (gethostname(hostname, sizeof(hostname) - 1)) {\n\t\tpurple_debug_warning(\"jabber\", \"gethostname: %s\\n\", g_strerror(errno));\n\t\t\n\t\tg_strlcpy(hostname, \"localhost\", sizeof(hostname));\n\t}\n\thostname[sizeof(hostname) - 1] = '\\0';\n\t\n\tif((dot = strchr(hostname, '.')))\n\t\t*dot = '\\0';\n\treturn purple_strreplace(input, \"__HOSTNAME__\", hostname);\n}\n", "bug_type": null, "idx": 241}
{"project": "Pidgin", "target": 0, "func": "static int\ninfoupdate(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\taim_rxcallback_t userfunc;\n\tint ret = 0;\n\tguint8 detaillevel = 0;\n\tstruct aim_chat_roominfo roominfo;\n\tGSList *tlvlist;\n\tguint16 maxmsglen, maxvisiblemsglen;\n\taim_chat_readroominfo(bs, &roominfo);\n\tdetaillevel = byte_stream_get8(bs);\n\tif (detaillevel != 0x02) {\n\t\tpurple_debug_misc(\"oscar\", \"faim: chat_roomupdateinfo: detail level %d not supported\\n\", detaillevel);\n\t\treturn 1;\n\t}\n\tbyte_stream_get16(bs); \n\t\n\ttlvlist = aim_tlvlist_read(bs);\n\t\n\tmaxmsglen = aim_tlv_get16(tlvlist, 0x00d1, 1);\n\t\n\tmaxvisiblemsglen = aim_tlv_get16(tlvlist, 0x00da, 1);\n\tif ((userfunc = aim_callhandler(od, snac->family, snac->subtype))) {\n\t\tret = userfunc(od, conn, frame, maxmsglen, maxvisiblemsglen);\n\t}\n\tg_free(roominfo.name);\n\taim_tlvlist_free(tlvlist);\n\treturn ret;\n}\n", "bug_type": null, "idx": 242}
{"project": "Pidgin", "target": 0, "func": "static void\npounce_response_dismiss()\n{\n\tGtkTreeModel *model = GTK_TREE_MODEL(pounce_dialog->treemodel);\n\tGtkTreeSelection *selection;\n\tGtkTreeIter iter;\n\tGtkTreeIter new_selection;\n\tGList *list = NULL;\n\tgboolean found_selection = FALSE;\n\tselection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pounce_dialog->treeview));\n\tgtk_tree_selection_selected_foreach(selection, delete_foreach, pounce_dialog);\n\tgtk_tree_selection_selected_foreach(selection, append_to_list, &list);\n\tg_return_if_fail(list != NULL);\n\tif (list->next == NULL) {\n\t\tgtk_tree_model_get_iter(model, &new_selection, list->data);\n\t\tif (gtk_tree_model_iter_next(model, &new_selection))\n\t\t\tfound_selection = TRUE;\n\t\telse {\n\t\t\t\n\t\t\tGtkTreePath *path;\n\t\t\t\n\t\t\tgtk_tree_model_get_iter(model, &new_selection, list->data);\n\t\t\tpath = gtk_tree_model_get_path(model, &new_selection);\n\t\t\tif (gtk_tree_path_prev(path)) {\n\t\t\t\tgtk_tree_model_get_iter(model, &new_selection, path);\n\t\t\t\tfound_selection = TRUE;\n\t\t\t}\n\t\t\tgtk_tree_path_free(path);\n\t\t}\n\t}\n\twhile (list) {\n\t\tif (gtk_tree_model_get_iter(model, &iter, list->data)) {\n\t\t\tgtk_tree_store_remove(GTK_TREE_STORE(pounce_dialog->treemodel), &iter);\n\t\t}\n\t\tgtk_tree_path_free(list->data);\n\t\tlist = g_list_delete_link(list, list);\n\t}\n\tif (gtk_tree_model_get_iter_first(model, &iter)) {\n\t\tif (found_selection)\n\t\t\tgtk_tree_selection_select_iter(selection, &new_selection);\n\t\telse\n\t\t\tgtk_tree_selection_select_iter(selection, &iter);\n\t} else\n\t\tpounce_response_close(pounce_dialog);\n}\n", "bug_type": null, "idx": 243}
{"project": "Pidgin", "target": 0, "func": "void\npurple_pounce_set_events(PurplePounce *pounce, PurplePounceEvent events)\n{\n\tg_return_if_fail(pounce != NULL);\n\tg_return_if_fail(events != PURPLE_POUNCE_NONE);\n\tpounce->events = events;\n\tschedule_pounces_save();\n}\n", "bug_type": null, "idx": 244}
{"project": "Pidgin", "target": 0, "func": "static void send_notify(struct simple_account_data *sip, struct simple_watcher *watcher) {\n\tgchar *doc = watcher->needsxpidf ? gen_xpidf(sip) : gen_pidf(sip, TRUE);\n\tgchar *hdr = watcher->needsxpidf ? \"Event: presence\\r\\nContent-Type: application/xpidf+xml\\r\\n\" : \"Event: presence\\r\\nContent-Type: application/pidf+xml\\r\\n\";\n\tsend_sip_request(sip->gc, \"NOTIFY\", watcher->name, watcher->name, hdr, doc, &watcher->dialog, NULL);\n\tg_free(doc);\n}\n", "bug_type": null, "idx": 245}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_blist_theme_set_collapsed_background_color(PidginBlistTheme *theme, const GdkColor *color)\n{\n\tPidginBlistThemePrivate *priv;\n\tg_return_if_fail(PIDGIN_IS_BLIST_THEME(theme));\n\tpriv = PIDGIN_BLIST_THEME_GET_PRIVATE(G_OBJECT(theme));\n\tif (priv->collapsed_color)\n\t\tgdk_color_free(priv->collapsed_color);\n\tpriv->collapsed_color = color ? gdk_color_copy(color) : NULL;\n}\n", "bug_type": null, "idx": 246}
{"project": "Pidgin", "target": 0, "func": "GntProgressBarOrientation\ngnt_progress_bar_get_orientation (GntProgressBar *pbar)\n{\n\tGntProgressBarPrivate *priv = GNT_PROGRESS_BAR_GET_PRIVATE (pbar);\n\treturn priv->orientation;\n}\n", "bug_type": null, "idx": 247}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nstatus_text_changed(GntEntry *entry, const char *text, gpointer null)\n{\n\tif ((text[0] == 27 || (text[0] == '\\t' && text[1] == '\\0')) && ggblist->typing == 0)\n\t\treturn FALSE;\n\tif (ggblist->typing)\n\t\tpurple_timeout_remove(ggblist->typing);\n\tggblist->typing = 0;\n\tif (text[0] == '\\r' && text[1] == 0)\n\t{\n\t\t\n\t\tremove_typing_cb(NULL);\n\t\treturn TRUE;\n\t}\n\tggblist->typing = purple_timeout_add_seconds(TYPING_TIMEOUT_S, (GSourceFunc)remove_typing_cb, NULL);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 248}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npurple_dnsquery_ui_resolve(PurpleDnsQueryData *query_data)\n{\n\tPurpleDnsQueryUiOps *ops = purple_dnsquery_get_ui_ops();\n\tif (ops && ops->resolve_host)\n\t\treturn ops->resolve_host(query_data, purple_dnsquery_resolved, purple_dnsquery_failed);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 249}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nbonjour_can_receive_file(PurpleConnection *connection, const char *who)\n{\n\tPurpleBuddy *buddy = purple_find_buddy(connection->account, who);\n\treturn (buddy != NULL && purple_buddy_get_protocol_data(buddy) != NULL);\n}\n", "bug_type": null, "idx": 250}
{"project": "Pidgin", "target": 0, "func": "static gboolean pidgin_status_menu_add_primitive(GtkListStore *model, GtkWidget *w, PurpleStatusPrimitive primitive,\n\tPurpleSavedStatus *current_status)\n{\n\tGtkTreeIter iter;\n\tgboolean currently_selected = FALSE;\n\tgtk_list_store_append(model, &iter);\n\tgtk_list_store_set(model, &iter,\n\t\t\t   SS_MENU_TYPE_COLUMN, SS_MENU_ENTRY_TYPE_PRIMITIVE,\n\t\t\t   SS_MENU_ICON_COLUMN, pidgin_stock_id_from_status_primitive(primitive),\n\t\t\t   SS_MENU_TEXT_COLUMN, purple_primitive_get_name_from_type(primitive),\n\t\t\t   SS_MENU_DATA_COLUMN, GINT_TO_POINTER(primitive),\n\t\t\t   SS_MENU_EMBLEM_VISIBLE_COLUMN, FALSE,\n\t\t\t   -1);\n\tif (purple_savedstatus_is_transient(current_status)\n\t\t\t&& !purple_savedstatus_has_substatuses(current_status)\n\t\t\t&& purple_savedstatus_get_type(current_status) == primitive)\n\t\tcurrently_selected = TRUE;\n\treturn currently_selected;\n}\n", "bug_type": null, "idx": 251}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_request_close_with_account(PurpleAccount *account)\n{\n\tGList *l, *l_next;\n\tg_return_if_fail(account != NULL);\n\tfor (l = handles; l != NULL; l = l_next) {\n\t\tPurpleAccountRequestInfo *info = l->data;\n\t\tl_next = l->next;\n\t\tif (info->account == account) {\n\t\t\thandles = g_list_remove(handles, info);\n\t\t\tpurple_account_request_close_info(info);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 252}
{"project": "Pidgin", "target": 0, "func": "Tcl_Obj *purple_tcl_ref_new(PurpleStringref *type, void *value)\n{\n\tTcl_Obj *obj = Tcl_NewObj();\n\tobj->typePtr = &purple_tcl_ref;\n\tOBJ_REF_TYPE(obj) = purple_stringref_ref(type);\n\tOBJ_REF_VALUE(obj) = value;\n\tTcl_InvalidateStringRep(obj);\n\treturn obj;\n}\n", "bug_type": null, "idx": 253}
{"project": "Pidgin", "target": 0, "func": "static GList *\nplugin_actions (PurplePlugin * plugin, gpointer context)\n{\n\t\n\tGList *list = NULL;\n\tPurplePluginAction *action = NULL;\n\t\n\taction = purple_plugin_action_new (\"Plugin Action Test\", plugin_action_test_cb);\n\t\n\tlist = g_list_append (list, action);\n\t\n\treturn list;\n}\n", "bug_type": null, "idx": 254}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_message_add_remote_smileys(JabberStream *js, const gchar *who,\n    const xmlnode *message)\n{\n\txmlnode *data_tag;\n\tfor (data_tag = xmlnode_get_child_with_namespace(message, \"data\", NS_BOB) ;\n\t\t data_tag ;\n\t\t data_tag = xmlnode_get_next_twin(data_tag)) {\n\t\tconst gchar *cid = xmlnode_get_attrib(data_tag, \"cid\");\n\t\tconst JabberData *data = jabber_data_find_remote_by_cid(js, who, cid);\n\t\tif (!data && cid != NULL) {\n\t\t\t\n\t\t\tJabberData *new_data = jabber_data_create_from_xml(data_tag);\n\t\t\tif (new_data) {\n\t\t\t\tjabber_data_associate_remote(js, who, new_data);\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 255}
{"project": "Pidgin", "target": 0, "func": "GntFile* gnt_file_new_dir(const char *name)\n{\n\tGntFile *file = g_new0(GntFile, 1);\n\tfile->basename = g_strdup(name);\n\tfile->type = GNT_FILE_DIR;\n\treturn file;\n}\n", "bug_type": null, "idx": 256}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_unload(PurplePlugin *plugin)\n{\n\tPurplePlugin *prpl;\n\tPurplePluginProtocolInfo *prpl_info;\n\tPurpleAccountOption *option;\n\tGList *l, *options;\n\t\n\tfor (l = purple_plugins_get_protocols(); l != NULL; l = l->next) {\n\t\tprpl = (PurplePlugin *)l->data;\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\t\tif (prpl_info != NULL && !(prpl_info->options & OPT_PROTO_NO_PASSWORD)) {\n\t\t\toptions = prpl_info->protocol_options;\n\t\t\twhile (options != NULL) {\n\t\t\t\toption = (PurpleAccountOption *) options->data;\n\t\t\t\tif (strcmp(PREF_NAME, purple_account_option_get_setting(option)) == 0) {\n\t\t\t\t\tprpl_info->protocol_options = g_list_delete_link(prpl_info->protocol_options, options);\n\t\t\t\t\tpurple_account_option_destroy(option);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toptions = options->next;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 257}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nx509_times (PurpleCertificate *crt, time_t *activation, time_t *expiration)\n{\n\tCERTCertificate *crt_dat;\n\tPRTime nss_activ, nss_expir;\n\tSECStatus cert_times_success;\n\tg_return_val_if_fail(crt, FALSE);\n\tg_return_val_if_fail(crt->scheme == &x509_nss, FALSE);\n\tcrt_dat = X509_NSS_DATA(crt);\n\tg_return_val_if_fail(crt_dat, FALSE);\n\t\n\t\n\tcert_times_success = CERT_GetCertTimes(crt_dat,\n\t\t\t\t\t\t&nss_activ, &nss_expir);\n\tg_return_val_if_fail(cert_times_success == SECSuccess, FALSE);\n\t\n\tnss_activ = nss_activ / 1000000;\n\tnss_expir = nss_expir / 1000000;\n\tif (activation) {\n\t\t*activation = nss_activ;\n#if SIZEOF_TIME_T == 4\n\t\t\n\t\tif (*activation != nss_activ) {\n\t\t\tif (nss_activ < 0) {\n\t\t\t\tpurple_debug_warning(\"nss\",\n\t\t\t\t\t\"Setting Activation Date to epoch to handle pre-epoch value\\n\");\n\t\t\t\t*activation = 0;\n\t\t\t} else {\n\t\t\t\tpurple_debug_error(\"nss\",\n\t\t\t\t\t\"Activation date past 32-bit barrier, forcing invalidity\\n\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (expiration) {\n\t\t*expiration = nss_expir;\n#if SIZEOF_TIME_T == 4\n\t\tif (*expiration != nss_expir) {\n\t\t\tif (*expiration < nss_expir) {\n\t\t\t\tif (*expiration < 0) {\n\t\t\t\t\tpurple_debug_warning(\"nss\",\n\t\t\t\t\t\t\"Setting Expiration Date to 32-bit signed max\\n\");\n\t\t\t\t\t*expiration = PR_INT32_MAX;\n\t\t\t\t} else {\n\t\t\t\t\tpurple_debug_warning(\"nss\",\n\t\t\t\t\t\t\"Setting Expiration Date to 32-bit unsigned max\\n\");\n\t\t\t\t\t*expiration = PR_UINT32_MAX;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpurple_debug_error(\"nss\",\n\t\t\t\t\t\"Expiration date prior to unix epoch, forcing invalidity\\n\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 258}
{"project": "Pidgin", "target": 0, "func": " * hidden, it'll trigger the blist_visible_cb */\nstatic gboolean listen_for_blist_visible_cb(gpointer data) {\n\tif (handle != NULL)\n\t\tblist_visible_cb_id =\n\t\t\tpurple_prefs_connect_callback(handle,\n\t\t\t\tPIDGIN_PREFS_ROOT \"/blist/list_visible\",\n\t\t\t\tblist_visible_cb, NULL);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 259}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_blist_theme_set_collapsed_text_info(PidginBlistTheme *theme, const PidginThemeFont *pair)\n{\n\tPidginBlistThemePrivate *priv;\n\tg_return_if_fail(PIDGIN_IS_BLIST_THEME(theme));\n\tpriv = PIDGIN_BLIST_THEME_GET_PRIVATE(G_OBJECT(theme));\n\tpidgin_theme_font_free(priv->collapsed);\n\tpriv->collapsed = copy_font_and_color(pair);\n}\n", "bug_type": null, "idx": 260}
{"project": "Pidgin", "target": 0, "func": "static void\nfree_tree_row(gpointer data)\n{\n\tGntTreeRow *row = data;\n\tif (!row)\n\t\treturn;\n\tg_list_foreach(row->columns, (GFunc)free_tree_col, NULL);\n\tg_list_free(row->columns);\n\tg_free(row);\n}\n", "bug_type": null, "idx": 261}
{"project": "Pidgin", "target": 0, "func": " */\nint aim_search_address(OscarData *od, const char *address)\n{\n\tFlapConnection *conn;\n\tByteStream bs;\n\taim_snacid_t snacid;\n\tconn = flap_connection_findbygroup(od, SNAC_FAMILY_USERLOOKUP);\n\tif (!conn || !address)\n\t\treturn -EINVAL;\n\tbyte_stream_new(&bs, strlen(address));\n\tbyte_stream_putstr(&bs, address);\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_USERLOOKUP, 0x0002, 0x0000, address, strlen(address)+1);\n\tflap_connection_send_snac(od, conn, SNAC_FAMILY_USERLOOKUP, 0x0002, snacid, &bs);\n\tbyte_stream_destroy(&bs);\n\treturn 0;\n}\n", "bug_type": null, "idx": 262}
{"project": "Pidgin", "target": 0, "func": "static void\nsortmethod_act(GtkCheckMenuItem *checkmenuitem, char *id)\n{\n\tif (gtk_check_menu_item_get_active(checkmenuitem))\n\t{\n\t\tpidgin_set_cursor(gtkblist->window, GDK_WATCH);\n\t\t\n\t\t\n\t\tpurple_prefs_set_string(PIDGIN_PREFS_ROOT \"/blist/sort_type\", id);\n\t\tpidgin_clear_cursor(gtkblist->window);\n\t}\n}\n", "bug_type": null, "idx": 263}
{"project": "Pidgin", "target": 0, "func": "static PurpleMediaBackendFs2Session *\nget_session(PurpleMediaBackendFs2 *self, const gchar *sess_id)\n{\n\tPurpleMediaBackendFs2Private *priv;\n\tPurpleMediaBackendFs2Session *session = NULL;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_BACKEND_FS2(self), NULL);\n\tpriv = PURPLE_MEDIA_BACKEND_FS2_GET_PRIVATE(self);\n\tif (priv->sessions != NULL)\n\t\tsession = g_hash_table_lookup(priv->sessions, sess_id);\n\treturn session;\n}\n", "bug_type": null, "idx": 264}
{"project": "Pidgin", "target": 0, "func": "PurpleCertificatePool *\npurple_certificate_find_pool(const gchar *scheme_name, const gchar *pool_name)\n{\n\tPurpleCertificatePool *pool = NULL;\n\tGList *l;\n\tg_return_val_if_fail(scheme_name, NULL);\n\tg_return_val_if_fail(pool_name, NULL);\n\t\n\tfor(l = cert_pools; l; l = l->next) {\n\t\tpool = (PurpleCertificatePool *)(l->data);\n\t\t\n\t\tif(!g_ascii_strcasecmp(pool->scheme_name, scheme_name) &&\n\t\t   !g_ascii_strcasecmp(pool->name, pool_name))\n\t\t\treturn pool;\n\t}\n\tpurple_debug_warning(\"certificate\",\n\t\t\t     \"CertificatePool %s, %s requested but not found.\\n\",\n\t\t\t     scheme_name, pool_name);\n\t\n\treturn NULL;\n}\n", "bug_type": null, "idx": 265}
{"project": "Pidgin", "target": 0, "func": "static void mark_set_cb(GtkTextBuffer *buffer, GtkTextIter *location,\n\t\t\t\t\t\tGtkTextMark *mark, GtkIMHtmlToolbar *toolbar)\n{\n\tif(mark != gtk_text_buffer_get_insert(buffer))\n\t\treturn;\n\tupdate_buttons(toolbar);\n}\n", "bug_type": null, "idx": 266}
{"project": "Pidgin", "target": 0, "func": "END_TEST\nSTART_TEST(test_hmac_sha1_null_key_and_text) {\n\tHMAC_TEST(\"Hi\\x00Th\\x00re\",\n\t          8,\n\t          \"\\x0c\\x0d\\x00\\x0f\\x10\\x1a\\x3a\\x3a\\xe6\\x34\"\n\t          \"\\x0b\\x00\\x00\\x0b\\x0b\\x49\\x5f\\x6e\\x0b\\x0b\",\n\t          20,\n\t          \"sha1\",\n\t          \"e6b8e2fede87aa09dcb13e554df1435e056eae36\");\n}\n", "bug_type": null, "idx": 267}
{"project": "Pidgin", "target": 0, "func": "static void\ntls_peers_mgmt_export_ok_cb(gpointer data, const char *filename)\n{\n\tPurpleCertificate *crt = (PurpleCertificate *) data;\n\tg_assert(filename);\n\tif (!purple_certificate_export(filename, crt)) {\n\t\t\n\t\t\n\t\tgchar * secondary;\n\t\tsecondary = g_strdup_printf(_(\"Export to file %s failed.\\nCheck that you have write permission to the target path\\n\"), filename);\n\t\tpurple_notify_error(NULL,\n\t\t\t\t    _(\"Certificate Export Error\"),\n\t\t\t\t    _(\"X.509 certificate export failed\"),\n\t\t\t\t    secondary);\n\t\tg_free(secondary);\n\t}\n\tpurple_certificate_destroy(crt);\n}\n", "bug_type": null, "idx": 268}
{"project": "Pidgin", "target": 0, "func": "GType irssi_get_gtype(void)\n{\n\tstatic GType type = 0;\n\tif(type == 0) {\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(IrssiClass),\n\t\t\tNULL,           \n\t\t\tNULL,           \n\t\t\t(GClassInitFunc)irssi_class_init,\n\t\t\tNULL,\n\t\t\tNULL,           \n\t\t\tsizeof(Irssi),\n\t\t\t0,              \n\t\t\tNULL,\t        \n\t\t\tNULL\n\t\t};\n\t\ttype = g_type_register_static(GNT_TYPE_WM,\n\t\t                              \"GntIrssi\",\n\t\t                              &info, 0);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 269}
{"project": "Pidgin", "target": 0, "func": "static void\nedit_mood_cb(PurpleConnection *gc, PurpleRequestFields *fields)\n{\n\tPurpleRequestField *mood_field;\n\tGList *l;\n\tmood_field = purple_request_fields_get_field(fields, \"mood\");\n\tl = purple_request_field_list_get_selected(mood_field);\n\tif (l) {\n\t\tconst char *mood = purple_request_field_list_get_data(mood_field, l->data);\n\t\tif (gc) {\n\t\t\tconst char *text;\n\t\t\tPurpleAccount *account = purple_connection_get_account(gc);\n\t\t\tif (gc->flags & PURPLE_CONNECTION_SUPPORT_MOOD_MESSAGES) {\n\t\t\t\tPurpleRequestField *text_field;\n\t\t\t\ttext_field = purple_request_fields_get_field(fields, \"text\");\n\t\t\t\ttext = purple_request_field_string_get_value(text_field);\n\t\t\t} else {\n\t\t\t\ttext = NULL;\n\t\t\t}\n\t\t\tupdate_status_with_mood(account, mood, text);\n\t\t} else {\n\t\t\tGList *accounts = purple_accounts_get_all_active();\n\t\t\tfor (; accounts ; accounts = g_list_delete_link(accounts, accounts)) {\n\t\t\t\tPurpleAccount *account = (PurpleAccount *) accounts->data;\n\t\t\t\tPurpleConnection *gc = purple_account_get_connection(account);\n\t\t\t\tif (gc && gc->flags & PURPLE_CONNECTION_SUPPORT_MOODS) {\n\t\t\t\t\tupdate_status_with_mood(account, mood, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 270}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_widget_map(GntWidget *widget)\n{\n\t\n\tGNTDEBUG;\n\tg_signal_emit(widget, signals[SIG_MAP], 0);\n\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_MAPPED);\n}\n", "bug_type": null, "idx": 271}
{"project": "Pidgin", "target": 0, "func": "void purple_circ_buffer_destroy(PurpleCircBuffer *buf) {\n\tg_return_if_fail(buf != NULL);\n\tg_free(buf->buffer);\n\tg_free(buf);\n}\n", "bug_type": null, "idx": 272}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_tree_draw(GntWidget *widget)\n{\n\tGntTree *tree = GNT_TREE(widget);\n\tredraw_tree(tree);\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 273}
{"project": "Pidgin", "target": 0, "func": "static gg_action_t gg_handle_error(struct gg_session *sess, struct gg_event *e,\n\tenum gg_state_t next_state, enum gg_state_t alt_state,\n\tenum gg_state_t alt2_state)\n{\n\tstruct gg_session_private *p = sess->private_data;\n\tgg_debug_session(sess, GG_DEBUG_MISC | GG_DEBUG_ERROR, \"// gg_handle_error() failure=%d\\n\", p->socket_failure);\n\te->event.failure = p->socket_failure;\n\treturn GG_ACTION_FAIL;\n}\n", "bug_type": null, "idx": 274}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nlarge_step_back(GntBindable *bindable, GList *null)\n{\n\tGntSlider *slider = GNT_SLIDER(bindable);\n\tgnt_slider_set_value(slider, slider->current - slider->largestep);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 275}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\ncreate_int_field(PurpleRequestField *field)\n{\n\tint value;\n\tGtkWidget *widget;\n\twidget = gtk_entry_new();\n\tsetup_entry_field(widget, field);\n\tvalue = purple_request_field_int_get_default_value(field);\n\tif (value != 0)\n\t{\n\t\tchar buf[32];\n\t\tg_snprintf(buf, sizeof(buf), \"%d\", value);\n\t\tgtk_entry_set_text(GTK_ENTRY(widget), buf);\n\t}\n\tg_signal_connect(G_OBJECT(widget), \"focus-out-event\",\n\t\t\t\t\t G_CALLBACK(field_int_focus_out_cb), field);\n\treturn widget;\n}\n", "bug_type": null, "idx": 276}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_smiley_get_property(GObject *object, guint param_id, GValue *value,\n\t\tGParamSpec *spec)\n{\n\tPurpleSmiley *smiley = PURPLE_SMILEY(object);\n\tswitch (param_id) {\n\t\tcase PROP_SHORTCUT:\n\t\t\tg_value_set_string(value, smiley->shortcut);\n\t\t\tbreak;\n\t\tcase PROP_IMGSTORE:\n\t\t\tg_value_set_pointer(value, smiley->img);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID(object, param_id, spec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 277}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_dcc7_accept(struct gg_dcc7 *dcc, unsigned int offset)\n{\n\tstruct gg_dcc7_accept pkt;\n\tgg_debug_dcc(dcc, GG_DEBUG_FUNCTION, \"** gg_dcc7_accept(%p, %d)\\n\", dcc, offset);\n\tif (!dcc || !dcc->sess) {\n\t\tgg_debug_dcc(dcc, GG_DEBUG_MISC, \"// gg_dcc7_accept() invalid parameters\\n\");\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.uin = gg_fix32(dcc->peer_uin);\n\tpkt.id = dcc->cid;\n\tpkt.offset = gg_fix32(offset);\n\tif (gg_send_packet(dcc->sess, GG_DCC7_ACCEPT, &pkt, sizeof(pkt), NULL) == -1)\n\t\treturn -1;\n\tdcc->offset = offset;\n\treturn gg_dcc7_listen_and_send_info(dcc);\n}\n", "bug_type": null, "idx": 278}
{"project": "Pidgin", "target": 0, "func": "static void\nnovell_set_idle(PurpleConnection * gc, int time)\n{\n\tNMUser *user;\n\tNMERR_T rc = NM_OK;\n\tconst char *id = NULL;\n\tPurpleStatus *status = NULL;\n\tif (gc == NULL)\n\t\treturn;\n\tuser = gc->proto_data;\n\tif (user == NULL)\n\t\treturn;\n\tstatus = purple_account_get_active_status(purple_connection_get_account(gc));\n\tid = purple_status_get_id(status);\n\t\n\tif (!strcmp(id, NOVELL_STATUS_TYPE_AVAILABLE)) {\n\t\tif (time > 0) {\n\t\t\trc = nm_send_set_status(user, NM_STATUS_AWAY_IDLE, NULL, NULL, NULL, NULL);\n\t\t} else {\n\t\t\trc = nm_send_set_status(user, NM_STATUS_AVAILABLE, NULL, NULL, NULL, NULL);\n\t\t}\n\t}\n\t_check_for_disconnect(user, rc);\n}\n", "bug_type": null, "idx": 279}
{"project": "Pidgin", "target": 0, "func": "static PurpleCmdRet jabber_cmd_chat_topic(PurpleConversation *conv,\n\t\tconst char *cmd, char **args, char **error, void *data)\n{\n\tJabberChat *chat = jabber_chat_find_by_conv(conv);\n\tif (!chat)\n\t\treturn PURPLE_CMD_RET_FAILED;\n\tif (args && args[0] && *args[0])\n\t\tjabber_chat_change_topic(chat, args[0]);\n\telse {\n\t\tconst char *cur = purple_conv_chat_get_topic(PURPLE_CONV_CHAT(conv));\n\t\tchar *buf, *tmp, *tmp2;\n\t\tif (cur) {\n\t\t\ttmp = g_markup_escape_text(cur, -1);\n\t\t\ttmp2 = purple_markup_linkify(tmp);\n\t\t\tbuf = g_strdup_printf(_(\"current topic is: %s\"), tmp2);\n\t\t\tg_free(tmp);\n\t\t\tg_free(tmp2);\n\t\t} else\n\t\t\tbuf = g_strdup(_(\"No topic is set\"));\n\t\tpurple_conv_chat_write(PURPLE_CONV_CHAT(conv), \"\", buf,\n\t\t\t\tPURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_NO_LOG, time(NULL));\n\t\tg_free(buf);\n\t}\n\treturn PURPLE_CMD_RET_OK;\n}\n", "bug_type": null, "idx": 280}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_request_file(void *handle, const char *title, const char *filename,\n\t\t\t\t  gboolean savedialog,\n\t\t\t\t  GCallback ok_cb, GCallback cancel_cb,\n\t\t\t\t  PurpleAccount *account, const char *who, PurpleConversation *conv,\n\t\t\t\t  void *user_data)\n{\n\tPurpleRequestUiOps *ops;\n\tops = purple_request_get_ui_ops();\n\tif (ops != NULL && ops->request_file != NULL) {\n\t\tPurpleRequestInfo *info;\n\t\tinfo            = g_new0(PurpleRequestInfo, 1);\n\t\tinfo->type      = PURPLE_REQUEST_FILE;\n\t\tinfo->handle    = handle;\n\t\tinfo->ui_handle = ops->request_file(title, filename, savedialog,\n\t\t\t\t\t\t\t\t\t\t\tok_cb, cancel_cb,\n\t\t\t\t\t\t\t\t\t\t\taccount, who, conv, user_data);\n\t\thandles = g_list_append(handles, info);\n\t\treturn info->ui_handle;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 281}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_docklet_set_ui_ops(struct docklet_ui_ops *ops)\n{\n\tui_ops = ops;\n}\n", "bug_type": null, "idx": 282}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_account_set_default_value(PurpleRequestField *field,\n\t\t\t\t\t\t\t\t\t\t\t PurpleAccount *default_value)\n{\n\tg_return_if_fail(field != NULL);\n\tg_return_if_fail(field->type == PURPLE_REQUEST_FIELD_ACCOUNT);\n\tfield->u.account.default_account = default_value;\n}\n", "bug_type": null, "idx": 283}
{"project": "Pidgin", "target": 0, "func": "gchar *\npurple_media_candidate_get_password(PurpleMediaCandidate *candidate)\n{\n\tgchar *password;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_CANDIDATE(candidate), NULL);\n\tg_object_get(candidate, \"password\", &password, NULL);\n\treturn password;\n}\n", "bug_type": null, "idx": 284}
{"project": "Pidgin", "target": 0, "func": "static void\nmessage_recv_toggle(GtkButton *message_recv, GtkWidget *send_msg)\n{\n\tgboolean active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(message_recv));\n\tgtk_widget_set_sensitive(send_msg, !active);\n\tif (active)\n\t\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(send_msg), FALSE);\n}\n", "bug_type": null, "idx": 285}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin)\n{\n}\n", "bug_type": null, "idx": 286}
{"project": "Pidgin", "target": 0, "func": "static void\ntxt_resolved_cb(GList *responses, gpointer data)\n{\n\tJabberStream *js = data;\n\tgboolean found = FALSE;\n\tjs->srv_query_data = NULL;\n\twhile (responses) {\n\t\tPurpleTxtResponse *resp = responses->data;\n\t\tgchar **token;\n\t\ttoken = g_strsplit(purple_txt_response_get_content(resp), \"=\", 2);\n\t\tif (!strcmp(token[0], \"_xmpp-client-xbosh\")) {\n\t\t\tpurple_debug_info(\"jabber\",\"Found alternative connection method using %s at %s.\\n\", token[0], token[1]);\n\t\t\tjs->bosh = jabber_bosh_connection_init(js, token[1]);\n\t\t\tg_strfreev(token);\n\t\t\tbreak;\n\t\t}\n\t\tg_strfreev(token);\n\t\tpurple_txt_response_destroy(resp);\n\t\tresponses = g_list_delete_link(responses, responses);\n\t}\n\tif (js->bosh) {\n\t\tfound = TRUE;\n\t\tjabber_bosh_connection_connect(js->bosh);\n\t}\n\tif (!found) {\n\t\tpurple_debug_warning(\"jabber\", \"Unable to find alternative XMPP connection \"\n\t\t\t\t  \"methods after failing to connect directly.\\n\");\n\t\tpurple_connection_error_reason(js->gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t\t_(\"Unable to connect\"));\n\t\treturn;\n\t}\n\tif (responses) {\n\t\tg_list_foreach(responses, (GFunc)purple_txt_response_destroy, NULL);\n\t\tg_list_free(responses);\n\t}\n}\n", "bug_type": null, "idx": 287}
{"project": "Pidgin", "target": 0, "func": "static int gg_session_handle_chat_info_update(struct gg_session *gs,\n\tuint32_t type, const char *ptr, size_t len, struct gg_event *ge)\n{\n\tGG110ChatInfoUpdate *msg = gg110_chat_info_update__unpack(NULL, len, (uint8_t*)ptr);\n\tgg_chat_list_t *chat;\n\tuin_t participant;\n\tif (!GG_PROTOBUF_VALID(gs, \"GG110ChatInfoUpdate\", msg))\n\t\treturn -1;\n\tgg_debug_session(gs, GG_DEBUG_VERBOSE,\n\t\t\"// gg_session_handle_chat_info_update() \"\n\t\t\"msg_id=%016\" PRIx64 \" conv_id=%016\" PRIx64 \"\\n\",\n\t\tmsg->msg_id, msg->conv_id);\n\tge->type = GG_EVENT_CHAT_INFO_UPDATE;\n\tge->event.chat_info_update.id = msg->chat_id;\n\tge->event.chat_info_update.type = msg->update_type;\n\tge->event.chat_info_update.participant = participant = gg_protobuf_get_uin(msg->participant);\n\tge->event.chat_info_update.inviter = gg_protobuf_get_uin(msg->inviter);\n\tge->event.chat_info_update.version = msg->version;\n\tge->event.chat_info_update.time = msg->time;\n\tchat = gg_chat_find(gs, msg->chat_id);\n\tif (!chat) {\n\t\tgg110_chat_info_update__free_unpacked(msg, NULL);\n\t\treturn 0;\n\t}\n\tchat->version = msg->version;\n\tif (msg->update_type == GG_CHAT_INFO_UPDATE_ENTERED) {\n\t\tuin_t *old_part = chat->participants;\n\t\tchat->participants = realloc(chat->participants,\n\t\t\tsizeof(uin_t) * chat->participants_count);\n\t\tif (chat->participants == NULL) {\n\t\t\tchat->participants = old_part;\n\t\t\tgg_debug_session(gs, GG_DEBUG_ERROR,\n\t\t\t\t\"// gg_session_handle_chat_info_update() \"\n\t\t\t\t\"out of memory (count=%u)\\n\",\n\t\t\t\tchat->participants_count);\n\t\t\treturn -1;\n\t\t}\n\t\tchat->participants_count++;\n\t\tchat->participants[chat->participants_count - 1] = participant;\n\t} else if (msg->update_type == GG_CHAT_INFO_UPDATE_EXITED) {\n\t\tuint32_t idx;\n\t\tfor (idx = 0; idx < chat->participants_count; idx++)\n\t\t\tif (chat->participants[idx] == participant)\n\t\t\t\tbreak;\n\t\tif (chat->participants_count > 1 &&\n\t\t\tidx < chat->participants_count)\n\t\t\tchat->participants[idx] = chat->participants[chat->participants_count - 1];\n\t\tif (idx < chat->participants_count) {\n\t\t\tchat->participants_count--;\n\t\t\tif (chat->participants_count == 0) {\n\t\t\t\tfree(chat->participants);\n\t\t\t\tchat->participants = NULL;\n\t\t\t} else {\n\t\t\t\tchat->participants = realloc(chat->participants,\n\t\t\t\t\tsizeof(uin_t)*chat->participants_count);\n\t\t\t}\n\t\t}\n\t}\n\tgg110_chat_info_update__free_unpacked(msg, NULL);\n\treturn 0;\n}\n", "bug_type": null, "idx": 288}
{"project": "Pidgin", "target": 0, "func": " */\nstatic void pidgin_blist_update_group(PurpleBuddyList *list,\n                                      PurpleBlistNode *node)\n{\n\tgint count;\n\tPurpleGroup *group;\n\tPurpleBlistNode* gnode;\n\tgboolean show = FALSE, show_offline = FALSE;\n\tg_return_if_fail(node != NULL);\n\tif (editing_blist)\n\t\treturn;\n\tif (PURPLE_BLIST_NODE_IS_GROUP(node))\n\t\tgnode = node;\n\telse if (PURPLE_BLIST_NODE_IS_BUDDY(node))\n\t\tgnode = node->parent->parent;\n\telse if (PURPLE_BLIST_NODE_IS_CONTACT(node) || PURPLE_BLIST_NODE_IS_CHAT(node))\n\t\tgnode = node->parent;\n\telse\n\t\treturn;\n\tgroup = (PurpleGroup*)gnode;\n\tshow_offline = purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/blist/show_offline_buddies\");\n\tif(show_offline)\n\t\tcount = purple_blist_get_group_size(group, FALSE);\n\telse\n\t\tcount = purple_blist_get_group_online_count(group);\n\tif (count > 0 || purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/blist/show_empty_groups\"))\n\t\tshow = TRUE;\n\telse if (PURPLE_BLIST_NODE_IS_BUDDY(node) && buddy_is_displayable((PurpleBuddy*)node)) { \n\t\tshow = TRUE;\n\t} else if (!show_offline) {\n\t\tshow = pidgin_blist_group_has_show_offline_buddy(group);\n\t}\n\tif (show) {\n\t\tgchar *title;\n\t\tgboolean biglist;\n\t\tGtkTreeIter iter;\n\t\tGtkTreePath *path;\n\t\tgboolean expanded;\n\t\tGdkColor *bgcolor = NULL;\n\t\tGdkPixbuf *avatar = NULL;\n\t\tPidginBlistTheme *theme = NULL;\n\t\tif(!insert_node(list, gnode, &iter))\n\t\t\treturn;\n\t\tif ((theme = pidgin_blist_get_theme()) == NULL)\n\t\t\tbgcolor = NULL;\n\t\telse if (purple_blist_node_get_bool(gnode, \"collapsed\") || count <= 0)\n\t\t\tbgcolor = pidgin_blist_theme_get_collapsed_background_color(theme);\n\t\telse\n\t\t\tbgcolor = pidgin_blist_theme_get_expanded_background_color(theme);\n\t\tpath = gtk_tree_model_get_path(GTK_TREE_MODEL(gtkblist->treemodel), &iter);\n\t\texpanded = gtk_tree_view_row_expanded(GTK_TREE_VIEW(gtkblist->treeview), path);\n\t\tgtk_tree_path_free(path);\n\t\ttitle = pidgin_get_group_title(gnode, expanded);\n\t\tbiglist = purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/blist/show_buddy_icons\");\n\t\tif (biglist) {\n\t\t\tavatar = pidgin_blist_get_buddy_icon(gnode, TRUE, TRUE);\n\t\t}\n\t\tgtk_tree_store_set(gtkblist->treemodel, &iter,\n\t\t\t\t   STATUS_ICON_VISIBLE_COLUMN, FALSE,\n\t\t\t\t   STATUS_ICON_COLUMN, NULL,\n\t\t\t\t   NAME_COLUMN, title,\n\t\t\t\t   NODE_COLUMN, gnode,\n\t\t\t\t   BGCOLOR_COLUMN, bgcolor,\n\t\t\t\t   GROUP_EXPANDER_COLUMN, TRUE,\n\t\t\t\t   GROUP_EXPANDER_VISIBLE_COLUMN, TRUE,\n\t\t\t\t   CONTACT_EXPANDER_VISIBLE_COLUMN, FALSE,\n\t\t\t\t   BUDDY_ICON_COLUMN, avatar,\n\t\t\t\t   BUDDY_ICON_VISIBLE_COLUMN, biglist,\n\t\t\t\t   IDLE_VISIBLE_COLUMN, FALSE,\n\t\t\t\t   EMBLEM_VISIBLE_COLUMN, FALSE,\n\t\t\t\t   -1);\n\t\tg_free(title);\n\t} else {\n\t\tpidgin_blist_hide_node(list, gnode, TRUE);\n\t}\n}\n", "bug_type": null, "idx": 289}
{"project": "Pidgin", "target": 0, "func": "GType\npurple_media_candidate_type_get_type()\n{\n\tstatic GType type = 0;\n\tif (type == 0) {\n\t\tstatic const GEnumValue values[] = {\n\t\t\t{ PURPLE_MEDIA_CANDIDATE_TYPE_HOST,\n\t\t\t\t\t\"PURPLE_MEDIA_CANDIDATE_TYPE_HOST\",\n\t\t\t\t\t\"host\" },\n\t\t\t{ PURPLE_MEDIA_CANDIDATE_TYPE_SRFLX,\n\t\t\t\t\t\"PURPLE_MEDIA_CANDIDATE_TYPE_SRFLX\",\n\t\t\t\t\t\"srflx\" },\n\t\t\t{ PURPLE_MEDIA_CANDIDATE_TYPE_PRFLX,\n\t\t\t\t\t\"PURPLE_MEDIA_CANDIDATE_TYPE_PRFLX\",\n\t\t\t\t\t\"prflx\" },\n\t\t\t{ PURPLE_MEDIA_CANDIDATE_TYPE_RELAY,\n\t\t\t\t\t\"PURPLE_MEDIA_CANDIDATE_TYPE_RELAY\",\n\t\t\t\t\t\"relay\" },\n\t\t\t{ PURPLE_MEDIA_CANDIDATE_TYPE_MULTICAST,\n\t\t\t\t\t\"PURPLE_MEDIA_CANDIDATE_TYPE_MULTICAST\",\n\t\t\t\t\t\"multicast\" },\n\t\t\t{ 0, NULL, NULL }\n\t\t};\n\t\ttype = g_enum_register_static(\"PurpleMediaCandidateType\",\n\t\t\t\tvalues);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 290}
{"project": "Pidgin", "target": 0, "func": "static void\nremove_node_custom_icon(GtkWidget *w, PurpleBlistNode *node)\n{\n\tpurple_buddy_icons_node_set_custom_icon(node, NULL, 0);\n}\n", "bug_type": null, "idx": 291}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_blist_toggle_visibility()\n{\n\tif (gtkblist && gtkblist->window) {\n\t\tif (GTK_WIDGET_VISIBLE(gtkblist->window)) {\n\t\t\t\n\t\t\tpurple_blist_set_visible(PIDGIN_WINDOW_ICONIFIED(gtkblist->window) ||\n\t\t\t\t\t((gtk_blist_visibility != GDK_VISIBILITY_UNOBSCURED) &&\n\t\t\t\t\t!gtk_blist_focused));\n\t\t} else {\n\t\t\tpurple_blist_set_visible(TRUE);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 292}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_parser_element_end_libxml(void *user_data, const xmlChar *element_name,\n\t\t\t\t const xmlChar *prefix, const xmlChar *namespace)\n{\n\tJabberStream *js = user_data;\n\tif(!js->current)\n\t\treturn;\n\tif(js->current->parent) {\n\t\tif(!xmlStrcmp((xmlChar*) js->current->name, element_name))\n\t\t\tjs->current = js->current->parent;\n\t} else {\n\t\txmlnode *packet = js->current;\n\t\tjs->current = NULL;\n\t\tjabber_process_packet(js, &packet);\n\t\tif (packet != NULL)\n\t\t\txmlnode_free(packet);\n\t}\n}\n", "bug_type": null, "idx": 293}
{"project": "Pidgin", "target": 0, "func": "void\npurple_savedstatus_set_title(PurpleSavedStatus *status, const char *title)\n{\n\tg_return_if_fail(status != NULL);\n\t\n\tg_return_if_fail(purple_savedstatus_find(title) == NULL);\n\tg_free(status->title);\n\tstatus->title = g_strdup(title);\n\tschedule_save();\n\tpurple_signal_emit(purple_savedstatuses_get_handle(),\n\t\t\t\"savedstatus-modified\", status);\n}\n", "bug_type": null, "idx": 294}
{"project": "Pidgin", "target": 0, "func": "gchar *jabber_caps_calculate_hash(JabberCapsClientInfo *info, const char *hash)\n{\n\tGList *node;\n\tPurpleCipherContext *context;\n\tguint8 checksum[20];\n\tgsize checksum_size = 20;\n\tgboolean success;\n\tif (!info || !(context = purple_cipher_context_new_by_name(hash, NULL)))\n\t\treturn NULL;\n\t\n\tinfo->identities = g_list_sort(info->identities, jabber_identity_compare);\n\tinfo->features = g_list_sort(info->features, (GCompareFunc)strcmp);\n\tinfo->forms = g_list_sort(info->forms, jabber_xdata_compare);\n\t\n\tfor (node = info->identities; node; node = node->next) {\n\t\tJabberIdentity *id = (JabberIdentity*)node->data;\n\t\tchar *category = g_markup_escape_text(id->category, -1);\n\t\tchar *type = g_markup_escape_text(id->type, -1);\n\t\tchar *lang = NULL;\n\t\tchar *name = NULL;\n\t\tchar *tmp;\n\t\tif (id->lang)\n\t\t\tlang = g_markup_escape_text(id->lang, -1);\n\t\tif (id->name)\n\t\t\tname = g_markup_escape_text(id->name, -1);\n\t\ttmp = g_strconcat(category, \"/\", type, \"/\", lang ? lang : \"\",\n\t\t                  \"/\", name ? name : \"\", \"<\", NULL);\n\t\tpurple_cipher_context_append(context, (const guchar *)tmp, strlen(tmp));\n\t\tg_free(tmp);\n\t\tg_free(category);\n\t\tg_free(type);\n\t\tg_free(lang);\n\t\tg_free(name);\n\t}\n\t\n\tfor (node = info->features; node; node = node->next) {\n\t\tappend_escaped_string(context, node->data);\n\t}\n\t\n\tfor(node = info->forms; node; node = node->next) {\n\t\txmlnode *data = (xmlnode *)node->data;\n\t\tgchar *formtype = jabber_x_data_get_formtype(data);\n\t\tGList *fields = jabber_caps_xdata_get_fields(data);\n\t\t\n\t\tappend_escaped_string(context, formtype);\n\t\tg_free(formtype);\n\t\twhile (fields) {\n\t\t\tGList *value;\n\t\t\tJabberDataFormField *field = (JabberDataFormField*)fields->data;\n\t\t\tif (!g_str_equal(field->var, \"FORM_TYPE\")) {\n\t\t\t\t\n\t\t\t\tappend_escaped_string(context, field->var);\n\t\t\t\t\n\t\t\t\tfor (value = field->values; value; value = value->next) {\n\t\t\t\t\tappend_escaped_string(context, value->data);\n\t\t\t\t\tg_free(value->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tg_free(field->var);\n\t\t\tg_list_free(field->values);\n\t\t\tfields = g_list_delete_link(fields, fields);\n\t\t}\n\t}\n\t\n\tsuccess = purple_cipher_context_digest(context, checksum_size,\n\t                                       checksum, &checksum_size);\n\tpurple_cipher_context_destroy(context);\n\treturn (success ? purple_base64_encode(checksum, checksum_size) : NULL);\n}\n", "bug_type": null, "idx": 295}
{"project": "Pidgin", "target": 0, "func": "static void\nshow_submenu(GntMenu *menu)\n{\n\tGntMenuItem *item;\n\tif (menu->type != GNT_MENU_TOPLEVEL)\n\t\t\treturn;\n\titem = g_list_nth_data(menu->list, menu->selected);\n\tif (!item || !item->submenu)\n\t\treturn;\n\tmenuitem_activate(menu, item);\n}\n", "bug_type": null, "idx": 296}
{"project": "Pidgin", "target": 0, "func": "static void*\nfinch_request_action(const char *title, const char *primary,\n\t\tconst char *secondary, int default_value,\n\t\tPurpleAccount *account, const char *who, PurpleConversation *conv,\n\t\tvoid *user_data, size_t actioncount,\n\t\tva_list actions)\n{\n\tGntWidget *window, *box, *button, *focus = NULL;\n\tgsize i;\n\twindow = setup_request_window(title, primary, secondary, PURPLE_REQUEST_ACTION);\n\tbox = gnt_hbox_new(FALSE);\n\tgnt_box_add_widget(GNT_BOX(window), box);\n\tfor (i = 0; i < actioncount; i++)\n\t{\n\t\tconst char *text = va_arg(actions, const char *);\n\t\tPurpleRequestActionCb callback = va_arg(actions, PurpleRequestActionCb);\n\t\tbutton = gnt_button_new(text);\n\t\tgnt_box_add_widget(GNT_BOX(box), button);\n\t\tg_object_set_data(G_OBJECT(button), \"activate-callback\", callback);\n\t\tg_object_set_data(G_OBJECT(button), \"activate-userdata\", user_data);\n\t\tg_object_set_data(G_OBJECT(button), \"activate-id\", GINT_TO_POINTER(i));\n\t\tg_signal_connect(G_OBJECT(button), \"activate\", G_CALLBACK(request_action_cb), window);\n\t\tif (default_value >= 0 && i == (gsize)default_value)\n\t\t\tfocus = button;\n\t}\n\tgnt_widget_show(window);\n\tif (focus)\n\t\tgnt_box_give_focus_to_child(GNT_BOX(window), focus);\n\treturn window;\n}\n", "bug_type": null, "idx": 297}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nsubstitute_simple_buffer(GtkTextBuffer *buffer)\n{\n\tGtkTextIter start;\n\tGtkTextIter end;\n\tGtkTreeIter treeiter;\n\tgchar *text = NULL;\n\tgtk_text_buffer_get_iter_at_offset(buffer, &start, 0);\n\tgtk_text_buffer_get_iter_at_offset(buffer, &end, 0);\n\tgtk_text_iter_forward_to_end(&end);\n\ttext = gtk_text_buffer_get_text(buffer, &start, &end, FALSE);\n\tif (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &treeiter) && text) {\n\t\tdo {\n\t\t\tGValue val1;\n\t\t\tconst gchar *bad;\n\t\t\tgchar *cursor;\n\t\t\tglong char_pos;\n\t\t\tval1.g_type = 0;\n\t\t\tgtk_tree_model_get_value(GTK_TREE_MODEL(model), &treeiter, WORD_ONLY_COLUMN, &val1);\n\t\t\tif (g_value_get_boolean(&val1))\n\t\t\t{\n\t\t\t\tg_value_unset(&val1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg_value_unset(&val1);\n\t\t\tgtk_tree_model_get_value(GTK_TREE_MODEL(model), &treeiter, BAD_COLUMN, &val1);\n\t\t\tbad = g_value_get_string(&val1);\n\t\t\t\n\t\t\tif ((cursor = g_strrstr(text, bad)))\n\t\t\t{\n\t\t\t\tGValue val2;\n\t\t\t\tconst gchar *good;\n\t\t\t\tval2.g_type = 0;\n\t\t\t\tgtk_tree_model_get_value(GTK_TREE_MODEL(model), &treeiter, GOOD_COLUMN, &val2);\n\t\t\t\tgood = g_value_get_string(&val2);\n\t\t\t\tchar_pos = g_utf8_pointer_to_offset(text, cursor);\n\t\t\t\tgtk_text_buffer_get_iter_at_offset(buffer, &start, char_pos);\n\t\t\t\tgtk_text_buffer_get_iter_at_offset(buffer, &end, char_pos + g_utf8_strlen(bad, -1));\n\t\t\t\tgtk_text_buffer_delete(buffer, &start, &end);\n\t\t\t\tgtk_text_buffer_get_iter_at_offset(buffer, &start, char_pos);\n\t\t\t\tgtk_text_buffer_insert(buffer, &start, good, -1);\n\t\t\t\tg_value_unset(&val2);\n\t\t\t\tg_free(text);\n\t\t\t\tg_value_unset(&val1);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tg_value_unset(&val1);\n\t\t} while (gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &treeiter));\n\t}\n\tg_free(text);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 298}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nremove_new_empty_group(gpointer data)\n{\n\tPurpleBuddyList *list;\n\tif (!ggblist)\n\t\treturn FALSE;\n\tlist = purple_get_blist();\n\tg_return_val_if_fail(list, FALSE);\n\tggblist->new_group_timeout = 0;\n\twhile (ggblist->new_group) {\n\t\tPurpleBlistNode *group = ggblist->new_group->data;\n\t\tggblist->new_group = g_list_delete_link(ggblist->new_group, ggblist->new_group);\n\t\tnode_update(list, group);\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 299}
{"project": "Pidgin", "target": 0, "func": "int gnt_slider_get_value(GntSlider *slider)\n{\n\treturn slider->current;\n}\n", "bug_type": null, "idx": 300}
{"project": "Pidgin", "target": 0, "func": "PurplePluginPref *\npurple_plugin_pref_new_with_name(const char *name)\n{\n\tPurplePluginPref *pref;\n\tg_return_val_if_fail(name != NULL, NULL);\n\tpref = g_new0(PurplePluginPref, 1);\n\tpref->name = g_strdup(name);\n\treturn pref;\n}\n", "bug_type": null, "idx": 301}
{"project": "Pidgin", "target": 0, "func": "void gnt_text_view_clear(GntTextView *view)\n{\n\treset_text_view(view);\n\tg_list_foreach(view->tags, free_tag, NULL);\n\tview->tags = NULL;\n\tif (GNT_WIDGET(view)->window)\n\t\tgnt_widget_draw(GNT_WIDGET(view));\n}\n", "bug_type": null, "idx": 302}
{"project": "Pidgin", "target": 0, "func": "void\npurple_theme_manager_unregister_type(PurpleThemeLoader *loader)\n{\n\tconst gchar *type;\n\tg_return_if_fail(PURPLE_IS_THEME_LOADER(loader));\n\ttype = purple_theme_loader_get_type_string(loader);\n\tg_return_if_fail(type);\n\tif (g_hash_table_lookup(theme_table, type) == loader)\n\t{\n\t\tg_hash_table_remove(theme_table, type);\n\t\tg_hash_table_foreach_remove(theme_table,\n\t\t\t\t(GHRFunc)purple_theme_manager_is_theme_type, (gpointer)type);\n\t} \n}\n", "bug_type": null, "idx": 303}
{"project": "Pidgin", "target": 0, "func": "static void\nparse_current_error(xmlnode *node, PurpleAccount *account)\n{\n\tguint type;\n\tchar *type_str = NULL, *description = NULL;\n\txmlnode *child;\n\tPurpleConnectionErrorInfo *current_error = NULL;\n\tchild = xmlnode_get_child(node, \"type\");\n\tif (child == NULL || (type_str = xmlnode_get_data(child)) == NULL)\n\t\treturn;\n\ttype = atoi(type_str);\n\tg_free(type_str);\n\tif (type > PURPLE_CONNECTION_ERROR_OTHER_ERROR)\n\t{\n\t\tpurple_debug_error(\"account\",\n\t\t\t\"Invalid PurpleConnectionError value %d found when \"\n\t\t\t\"loading account information for %s\\n\",\n\t\t\ttype, purple_account_get_username(account));\n\t\ttype = PURPLE_CONNECTION_ERROR_OTHER_ERROR;\n\t}\n\tchild = xmlnode_get_child(node, \"description\");\n\tif (child)\n\t\tdescription = xmlnode_get_data(child);\n\tif (description == NULL)\n\t\tdescription = g_strdup(\"\");\n\tcurrent_error = g_new0(PurpleConnectionErrorInfo, 1);\n\tPURPLE_DBUS_REGISTER_POINTER(current_error, PurpleConnectionErrorInfo);\n\tcurrent_error->type = type;\n\tcurrent_error->description = description;\n\tset_current_error(account, current_error);\n}\n", "bug_type": null, "idx": 304}
{"project": "Pidgin", "target": 0, "func": "void\nnm_user_record_add_ref(NMUserRecord * user_record)\n{\n\tif (user_record)\n\t\tuser_record->ref_count++;\n}\n", "bug_type": null, "idx": 305}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_group_add_field(PurpleRequestFieldGroup *group,\n\t\t\t\t\t\t\t\t   PurpleRequestField *field)\n{\n\tg_return_if_fail(group != NULL);\n\tg_return_if_fail(field != NULL);\n\tgroup->fields = g_list_append(group->fields, field);\n\tif (group->fields_list != NULL)\n\t{\n\t\tg_hash_table_insert(group->fields_list->fields,\n\t\t\t\t\t\t\tg_strdup(purple_request_field_get_id(field)), field);\n\t\tif (purple_request_field_is_required(field))\n\t\t{\n\t\t\tgroup->fields_list->required_fields =\n\t\t\t\tg_list_append(group->fields_list->required_fields, field);\n\t\t}\n\t}\n\tfield->group = group;\n}\n", "bug_type": null, "idx": 306}
{"project": "Pidgin", "target": 0, "func": "static gboolean\njabber_process_starttls(JabberStream *js, xmlnode *packet)\n{\n\tPurpleAccount *account;\n\txmlnode *starttls;\n\taccount = purple_connection_get_account(js->gc);\n#if 0\n\t\n\t{\n\t\tconst gchar *connection_security = purple_account_get_string(account, \"connection_security\", JABBER_DEFAULT_REQUIRE_TLS);\n\t\tif (!g_str_equal(connection_security, \"none\") &&\n\t\t\t\tpurple_ssl_is_supported()) {\n\t\t\tjabber_send_raw(js,\n\t\t\t\t\t\"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\", -1);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n#else\n\tif(purple_ssl_is_supported()) {\n\t\tjabber_send_raw(js,\n\t\t\t\t\"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\", -1);\n\t\treturn TRUE;\n\t} else {\n\t\tpurple_debug_warning(\"jabber\", \"No libpurple TLS/SSL support found.\");\n\t}\n#endif\n\tstarttls = xmlnode_get_child(packet, \"starttls\");\n\tif(xmlnode_get_child(starttls, \"required\")) {\n\t\tpurple_connection_error_reason(js->gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,\n\t\t\t\t_(\"Server requires TLS/SSL, but no TLS/SSL support was found.\"));\n\t\treturn TRUE;\n\t}\n\tif (g_str_equal(\"require_tls\", purple_account_get_string(account, \"connection_security\", JABBER_DEFAULT_REQUIRE_TLS))) {\n\t\tpurple_connection_error_reason(js->gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,\n\t\t\t\t_(\"You require encryption, but no TLS/SSL support was found.\"));\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 307}
{"project": "Pidgin", "target": 0, "func": "static gchar *\noscar_convert_to_utf8(const gchar *data, gsize datalen, const char *charsetstr, gboolean fallback)\n{\n\tgchar *ret = NULL;\n\tGError *err = NULL;\n\tif ((charsetstr == NULL) || (*charsetstr == '\\0'))\n\t\treturn NULL;\n\tif (g_ascii_strcasecmp(\"UTF-8\", charsetstr)) {\n\t\tret = encoding_multi_convert_to_utf8(data, datalen, charsetstr, &err, fallback);\n\t\tif (err != NULL) {\n\t\t\tpurple_debug_warning(\"oscar\", \"Conversion from %s failed: %s.\\n\",\n\t\t\t\t\t\t\t   charsetstr, err->message);\n\t\t\tg_error_free(err);\n\t\t}\n\t} else {\n\t\tif (g_utf8_validate(data, datalen, NULL))\n\t\t\tret = g_strndup(data, datalen);\n\t\telse\n\t\t\tpurple_debug_warning(\"oscar\", \"String is not valid UTF-8.\\n\");\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 308}
{"project": "Pidgin", "target": 0, "func": "PurpleXferUiOps *\npidgin_xfers_get_ui_ops(void)\n{\n\treturn &ops;\n}\n", "bug_type": null, "idx": 309}
{"project": "Pidgin", "target": 0, "func": "static GList *\npurple_media_backend_fs2_get_local_candidates(PurpleMediaBackend *self,\n\t\tconst gchar *sess_id, const gchar *participant)\n{\n\tPurpleMediaBackendFs2Stream *stream;\n\tGList *candidates = NULL;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_BACKEND_FS2(self), NULL);\n\tstream = get_stream(PURPLE_MEDIA_BACKEND_FS2(self),\n\t\t\tsess_id, participant);\n\tif (stream != NULL)\n\t\tcandidates = candidate_list_from_fs(\n\t\t\t\tstream->local_candidates);\n\treturn candidates;\n}\n", "bug_type": null, "idx": 310}
{"project": "Pidgin", "target": 0, "func": "JingleSession *\njingle_session_find_by_sid(JabberStream *js, const gchar *sid)\n{\n\tJingleSession *session = NULL;\n\tif (js->sessions)\n\t\tsession = g_hash_table_lookup(js->sessions, sid);\n\tpurple_debug_info(\"jingle\", \"find_by_id %s\\n\", sid);\n\tpurple_debug_info(\"jingle\", \"lookup: %p\\n\", session);\n\treturn session;\n}\n", "bug_type": null, "idx": 311}
{"project": "Pidgin", "target": 0, "func": " */\nstatic void ggp_generic_status_handler(PurpleConnection *gc, uin_t uin,\n\t\t\t\t       int status, const char *descr)\n{\n\tgchar *from;\n\tconst char *st;\n\tchar *status_msg = NULL;\n\tggp_update_buddy_avatar(gc, uin);\n\tfrom = g_strdup_printf(\"%u\", uin);\n\tswitch (status) {\n\t\tcase GG_STATUS_NOT_AVAIL:\n\t\tcase GG_STATUS_NOT_AVAIL_DESCR:\n\t\t\tst = purple_primitive_get_id_from_type(PURPLE_STATUS_OFFLINE);\n\t\t\tbreak;\n\t\tcase GG_STATUS_FFC:\n\t\tcase GG_STATUS_FFC_DESCR:\n\t\t\tst = purple_primitive_get_id_from_type(PURPLE_STATUS_AVAILABLE);\n\t\t\tbreak;\n\t\tcase GG_STATUS_AVAIL:\n\t\tcase GG_STATUS_AVAIL_DESCR:\n\t\t\tst = purple_primitive_get_id_from_type(PURPLE_STATUS_AVAILABLE);\n\t\t\tbreak;\n\t\tcase GG_STATUS_BUSY:\n\t\tcase GG_STATUS_BUSY_DESCR:\n\t\t\tst = purple_primitive_get_id_from_type(PURPLE_STATUS_AWAY);\n\t\t\tbreak;\n\t\tcase GG_STATUS_DND:\n\t\tcase GG_STATUS_DND_DESCR:\n\t\t\tst = purple_primitive_get_id_from_type(PURPLE_STATUS_UNAVAILABLE);\n\t\t\tbreak;\n\t\tcase GG_STATUS_BLOCKED:\n\t\t\t\n\t\t\tst = \"blocked\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tst = purple_primitive_get_id_from_type(PURPLE_STATUS_AVAILABLE);\n\t\t\tpurple_debug_info(\"gg\",\n\t\t\t\t\"GG_EVENT_NOTIFY: Unknown status: %d\\n\", status);\n\t\t\tbreak;\n\t}\n\tif (descr != NULL) {\n\t\tstatus_msg = g_strdup(descr);\n\t\tg_strstrip(status_msg);\n\t\tif (status_msg[0] == '\\0') {\n\t\t\tg_free(status_msg);\n\t\t\tstatus_msg = NULL;\n\t\t}\n\t}\n\tpurple_debug_info(\"gg\", \"status of %u is %s [%s]\\n\", uin, st,\n\t\tstatus_msg ? status_msg : \"\");\n\tif (status_msg == NULL) {\n\t\tpurple_prpl_got_user_status(purple_connection_get_account(gc),\n\t\t\tfrom, st, NULL);\n\t} else {\n\t\tpurple_prpl_got_user_status(purple_connection_get_account(gc),\n\t\t\tfrom, st, \"message\", status_msg, NULL);\n\t\tg_free(status_msg);\n\t}\n\tg_free(from);\n}\n", "bug_type": null, "idx": 312}
{"project": "Pidgin", "target": 0, "func": "static void\nsigned_off_cb(PurpleConnection *gc, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"signed-off (%s)\\n\",\n\t\t\t\t\tpurple_account_get_username(purple_connection_get_account(gc)));\n}\n", "bug_type": null, "idx": 313}
{"project": "Pidgin", "target": 0, "func": "void\nnm_contact_set_data(NMContact * contact, gpointer data)\n{\n\tif (contact == NULL)\n\t\treturn;\n\tcontact->data = data;\n}\n", "bug_type": null, "idx": 314}
{"project": "Pidgin", "target": 0, "func": "static gboolean\naccounts_window_find_account_in_treemodel(GtkTreeIter *iter, PurpleAccount *account)\n{\n\tGtkTreeModel *model;\n\tPurpleAccount *cur;\n\tg_return_val_if_fail(account != NULL, FALSE);\n\tg_return_val_if_fail(accounts_window != NULL, FALSE);\n\tmodel = GTK_TREE_MODEL(accounts_window->model);\n\tif (!gtk_tree_model_get_iter_first(model, iter))\n\t\treturn FALSE;\n\tgtk_tree_model_get(model, iter, COLUMN_DATA, &cur, -1);\n\tif (cur == account)\n\t\treturn TRUE;\n\twhile (gtk_tree_model_iter_next(model, iter))\n\t{\n\t\tgtk_tree_model_get(model, iter, COLUMN_DATA, &cur, -1);\n\t\tif (cur == account)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 315}
{"project": "Pidgin", "target": 0, "func": "GstElement *\npurple_media_manager_get_pipeline(PurpleMediaManager *manager)\n{\n#ifdef USE_VV\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_MANAGER(manager), NULL);\n\tif (manager->priv->pipeline == NULL) {\n\t\tFsElementAddedNotifier *notifier;\n\t\tgchar *filename;\n\t\tGError *err = NULL;\n\t\tGKeyFile *keyfile;\n\t\tGstBus *bus;\n\t\tmanager->priv->pipeline = gst_pipeline_new(NULL);\n\t\tbus = gst_pipeline_get_bus(\n\t\t\t\tGST_PIPELINE(manager->priv->pipeline));\n\t\tgst_bus_add_signal_watch(GST_BUS(bus));\n\t\tg_signal_connect(G_OBJECT(bus), \"message\",\n\t\t\t\tG_CALLBACK(pipeline_bus_call), manager);\n#if GST_CHECK_VERSION(1,0,0)\n\t\tgst_bus_set_sync_handler(bus, gst_bus_sync_signal_handler, NULL, NULL);\n#else\n\t\tgst_bus_set_sync_handler(bus, gst_bus_sync_signal_handler, NULL);\n#endif\n\t\tgst_object_unref(bus);\n\t\tfilename = g_build_filename(purple_user_dir(),\n\t\t\t\t\"fs-element.conf\", NULL);\n\t\tkeyfile = g_key_file_new();\n\t\tif (!g_key_file_load_from_file(keyfile, filename,\n\t\t\t\tG_KEY_FILE_NONE, &err)) {\n\t\t\tif (err->code == 4)\n\t\t\t\tpurple_debug_info(\"mediamanager\",\n\t\t\t\t\t\t\"Couldn't read \"\n\t\t\t\t\t\t\"fs-element.conf: %s\\n\",\n\t\t\t\t\t\terr->message);\n\t\t\telse\n\t\t\t\tpurple_debug_error(\"mediamanager\",\n\t\t\t\t\t\t\"Error reading \"\n\t\t\t\t\t\t\"fs-element.conf: %s\\n\",\n\t\t\t\t\t\terr->message);\n\t\t\tg_error_free(err);\n\t\t}\n\t\tg_free(filename);\n\t\t\n\t\tif (!g_key_file_has_key(keyfile,\n\t\t\t\t\"alsasrc\", \"slave-method\", NULL)) {\n\t\t\tg_key_file_set_integer(keyfile,\n\t\t\t\t\t\"alsasrc\", \"slave-method\", 2);\n\t\t}\n\t\tnotifier = fs_element_added_notifier_new();\n\t\tfs_element_added_notifier_add(notifier,\n\t\t\t\tGST_BIN(manager->priv->pipeline));\n\t\tfs_element_added_notifier_set_properties_from_keyfile(\n\t\t\t\tnotifier, keyfile);\n\t\tgst_element_set_state(manager->priv->pipeline,\n\t\t\t\tGST_STATE_PLAYING);\n\t}\n\treturn manager->priv->pipeline;\n#else\n\treturn NULL;\n#endif\n}\n", "bug_type": null, "idx": 316}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_entry_class_init(GntEntryClass *klass)\n{\n\tGntBindableClass *bindable = GNT_BINDABLE_CLASS(klass);\n\tchar s[3] = {'\\033', erasechar(), 0};\n\tparent_class = GNT_WIDGET_CLASS(klass);\n\tparent_class->clicked = gnt_entry_clicked;\n\tparent_class->destroy = gnt_entry_destroy;\n\tparent_class->draw = gnt_entry_draw;\n\tparent_class->map = gnt_entry_map;\n\tparent_class->size_request = gnt_entry_size_request;\n\tparent_class->key_pressed = gnt_entry_key_pressed;\n\tparent_class->lost_focus = gnt_entry_lost_focus;\n\tsignals[SIG_TEXT_CHANGED] =\n\t\tg_signal_new(\"text_changed\",\n\t\t\t\t\t G_TYPE_FROM_CLASS(klass),\n\t\t\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t\t\t G_STRUCT_OFFSET(GntEntryClass, text_changed),\n\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t g_cclosure_marshal_VOID__VOID,\n\t\t\t\t\t G_TYPE_NONE, 0);\n\tsignals[SIG_COMPLETION] =\n\t\tg_signal_new(\"completion\",\n\t\t\t\t\t G_TYPE_FROM_CLASS(klass),\n\t\t\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t\t\t 0, NULL, NULL,\n\t\t\t\t\t gnt_closure_marshal_VOID__POINTER_POINTER,\n\t\t\t\t\t G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_POINTER);\n\tgnt_bindable_class_register_action(bindable, \"cursor-home\", move_start,\n\t\t\t\tGNT_KEY_CTRL_A, NULL);\n\tgnt_bindable_register_binding(bindable, \"cursor-home\", GNT_KEY_HOME, NULL);\n\tgnt_bindable_class_register_action(bindable, \"cursor-end\", move_end,\n\t\t\t\tGNT_KEY_CTRL_E, NULL);\n\tgnt_bindable_register_binding(bindable, \"cursor-end\", GNT_KEY_END, NULL);\n\tgnt_bindable_class_register_action(bindable, \"delete-prev\", backspace,\n\t\t\t\tGNT_KEY_BACKSPACE, NULL);\n\tgnt_bindable_register_binding(bindable, \"delete-prev\", s + 1, NULL);\n\tgnt_bindable_register_binding(bindable, \"delete-prev\", GNT_KEY_CTRL_H, NULL);\n\tgnt_bindable_class_register_action(bindable, \"delete-next\", delkey,\n\t\t\t\tGNT_KEY_DEL, NULL);\n\tgnt_bindable_register_binding(bindable, \"delete-next\", GNT_KEY_CTRL_D, NULL);\n\tgnt_bindable_class_register_action(bindable, \"delete-start\", del_to_home,\n\t\t\t\tGNT_KEY_CTRL_U, NULL);\n\tgnt_bindable_class_register_action(bindable, \"delete-end\", del_to_end,\n\t\t\t\tGNT_KEY_CTRL_K, NULL);\n\tgnt_bindable_class_register_action(bindable, \"delete-prev-word\", del_prev_word,\n\t\t\t\tGNT_KEY_CTRL_W, NULL);\n\tgnt_bindable_register_binding(bindable, \"delete-prev-word\", s, NULL);\n\tgnt_bindable_class_register_action(bindable, \"cursor-prev-word\", move_back_word,\n\t\t\t\t\"\\033\" \"b\", NULL);\n\tgnt_bindable_class_register_action(bindable, \"cursor-prev\", move_back,\n\t\t\t\tGNT_KEY_LEFT, NULL);\n\tgnt_bindable_register_binding(bindable, \"cursor-prev\", GNT_KEY_CTRL_B, NULL);\n\tgnt_bindable_class_register_action(bindable, \"cursor-next\", move_forward,\n\t\t\t\tGNT_KEY_RIGHT, NULL);\n\tgnt_bindable_register_binding(bindable, \"cursor-next\", GNT_KEY_CTRL_F, NULL);\n\tgnt_bindable_class_register_action(bindable, \"cursor-next-word\", move_forward_word,\n\t\t\t\t\"\\033\" \"f\", NULL);\n\tgnt_bindable_class_register_action(bindable, \"delete-next-word\", delete_forward_word,\n\t\t\t\t\"\\033\" \"d\", NULL);\n\tgnt_bindable_class_register_action(bindable, \"transpose-chars\", transpose_chars,\n\t\t\t\tGNT_KEY_CTRL_T, NULL);\n\tgnt_bindable_class_register_action(bindable, \"yank\", entry_yank,\n\t\t\t\tGNT_KEY_CTRL_Y, NULL);\n\tgnt_bindable_class_register_action(bindable, \"suggest-show\", suggest_show,\n\t\t\t\t\"\\t\", NULL);\n\tgnt_bindable_class_register_action(bindable, \"suggest-next\", suggest_next,\n\t\t\t\tGNT_KEY_DOWN, NULL);\n\tgnt_bindable_class_register_action(bindable, \"suggest-prev\", suggest_prev,\n\t\t\t\tGNT_KEY_UP, NULL);\n\tgnt_bindable_class_register_action(bindable, \"suggest-next-page\", suggest_next_page,\n\t\t\t\tGNT_KEY_PGDOWN, NULL);\n\tgnt_bindable_class_register_action(bindable, \"suggest-prev-page\", suggest_prev_page,\n\t\t\t\tGNT_KEY_PGUP, NULL);\n\tgnt_bindable_class_register_action(bindable, \"history-next\", history_next,\n\t\t\t\tGNT_KEY_CTRL_DOWN, NULL);\n\tgnt_bindable_class_register_action(bindable, \"history-prev\", history_prev,\n\t\t\t\tGNT_KEY_CTRL_UP, NULL);\n\tgnt_bindable_register_binding(bindable, \"history-prev\", GNT_KEY_CTRL_P, NULL);\n\tgnt_bindable_register_binding(bindable, \"history-next\", GNT_KEY_CTRL_N, NULL);\n\tgnt_bindable_class_register_action(bindable, \"history-search\", history_search,\n\t\t\t\tGNT_KEY_CTRL_R, NULL);\n\tgnt_bindable_class_register_action(bindable, \"clipboard-paste\", clipboard_paste,\n\t\t\t\tGNT_KEY_CTRL_V, NULL);\n\tgnt_style_read_actions(G_OBJECT_CLASS_TYPE(klass), GNT_BINDABLE_CLASS(klass));\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 317}
{"project": "Pidgin", "target": 0, "func": "\nstatic gboolean probe_mono_plugin(PurplePlugin *plugin)\n{\n\tMonoAssembly *assm;\n\tMonoMethod *m = NULL;\n\tMonoObject *plugin_info;\n\tgboolean found_load = FALSE, found_unload = FALSE, found_destroy = FALSE;\n\tgpointer iter = NULL;\n\tPurplePluginInfo *info;\n\tPurpleMonoPlugin *mplug;\n\tchar *file = plugin->path;\n\tassm = mono_domain_assembly_open(ml_get_domain(), file);\n\tif (!assm) {\n\t\treturn FALSE;\n\t}\n\tpurple_debug(PURPLE_DEBUG_INFO, \"mono\", \"Probing plugin\\n\");\n\tif (ml_is_api_dll(mono_assembly_get_image(assm))) {\n\t\tpurple_debug_info(\"mono\", \"Found our PurpleAPI.dll\\n\");\n\t\tmono_assembly_close(assm);\n\t\treturn FALSE;\n\t}\n\tmplug = g_new0(PurpleMonoPlugin, 1);\n\tmplug->signal_data = NULL;\n\tmplug->assm = assm;\n\tmplug->klass = ml_find_plugin_class(mono_assembly_get_image(mplug->assm));\n\tif (!mplug->klass) {\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"mono\", \"no plugin class in \\'%s\\'\\n\", file);\n\t\tmono_assembly_close(assm);\n\t\tg_free(mplug);\n\t\treturn FALSE;\n\t}\n\tmplug->obj = mono_object_new(ml_get_domain(), mplug->klass);\n\tif (!mplug->obj) {\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"mono\", \"obj not valid\\n\");\n\t\tmono_assembly_close(assm);\n\t\tg_free(mplug);\n\t\treturn FALSE;\n\t}\n\tmono_runtime_object_init(mplug->obj);\n\twhile ((m = mono_class_get_methods(mplug->klass, &iter))) {\n\t\tpurple_debug_info(\"mono\", \"plugin method: %s\\n\", mono_method_get_name(m));\n\t\tif (strcmp(mono_method_get_name(m), \"Load\") == 0) {\n\t\t\tmplug->load = m;\n\t\t\tfound_load = TRUE;\n\t\t} else if (strcmp(mono_method_get_name(m), \"Unload\") == 0) {\n\t\t\tmplug->unload = m;\n\t\t\tfound_unload = TRUE;\n\t\t} else if (strcmp(mono_method_get_name(m), \"Destroy\") == 0) {\n\t\t\tmplug->destroy = m;\n\t\t\tfound_destroy = TRUE;\n\t\t}\n\t}\n\tif (!(found_load && found_unload && found_destroy)) {\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"mono\", \"did not find the required methods\\n\");\n\t\tmono_assembly_close(assm);\n\t\tg_free(mplug);\n\t\treturn FALSE;\n\t}\n\tplugin_info = ml_get_info_prop(mplug->obj);\n\t\n\tinfo = g_new0(PurplePluginInfo, 1);\n\tinfo->id = ml_get_prop_string(plugin_info, \"Id\");\n\tinfo->name = ml_get_prop_string(plugin_info, \"Name\");\n\tinfo->version = ml_get_prop_string(plugin_info, \"Version\");\n\tinfo->summary = ml_get_prop_string(plugin_info, \"Summary\");\n\tinfo->description = ml_get_prop_string(plugin_info, \"Description\");\n\tinfo->author = ml_get_prop_string(plugin_info, \"Author\");\n\tinfo->homepage = ml_get_prop_string(plugin_info, \"Homepage\");\n\tinfo->magic = PURPLE_PLUGIN_MAGIC;\n\tinfo->major_version = PURPLE_MAJOR_VERSION;\n\tinfo->minor_version = PURPLE_MINOR_VERSION;\n\tinfo->type = PURPLE_PLUGIN_STANDARD;\n\t\n\tinfo->dependencies = g_list_append(info->dependencies, MONO_PLUGIN_ID);\n\tmplug->plugin = plugin;\n\tplugin->info = info;\n\tinfo->extra_info = mplug;\n\tml_add_plugin(mplug);\n\treturn purple_plugin_register(plugin);\n}\n", "bug_type": null, "idx": 318}
{"project": "Pidgin", "target": 0, "func": "gpointer\njabber_ibb_session_get_user_data(JabberIBBSession *sess)\n{\n\treturn sess->user_data;\n}\n", "bug_type": null, "idx": 319}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_request_field_get_label(const PurpleRequestField *field)\n{\n\tg_return_val_if_fail(field != NULL, NULL);\n\treturn field->label;\n}\n", "bug_type": null, "idx": 320}
{"project": "Pidgin", "target": 0, "func": "static GdkPixbuf *pidgin_blist_get_buddy_icon(PurpleBlistNode *node,\n                                              gboolean scaled, gboolean greyed)\n{\n\tgsize len;\n\tPurpleBuddy *buddy = NULL;\n\tPurpleGroup *group = NULL;\n\tconst guchar *data = NULL;\n\tGdkPixbuf *buf, *ret = NULL;\n\tPurpleBuddyIcon *icon = NULL;\n\tPurpleAccount *account = NULL;\n\tPurpleContact *contact = NULL;\n\tPurpleStoredImage *custom_img;\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tgint orig_width, orig_height, scale_width, scale_height;\n\tif (PURPLE_BLIST_NODE_IS_CONTACT(node)) {\n\t\tbuddy = purple_contact_get_priority_buddy((PurpleContact*)node);\n\t\tcontact = (PurpleContact*)node;\n\t} else if (PURPLE_BLIST_NODE_IS_BUDDY(node)) {\n\t\tbuddy = (PurpleBuddy*)node;\n\t\tcontact = purple_buddy_get_contact(buddy);\n\t} else if (PURPLE_BLIST_NODE_IS_GROUP(node)) {\n\t\tgroup = (PurpleGroup*)node;\n\t} else if (PURPLE_BLIST_NODE_IS_CHAT(node)) {\n\t\t\n\t} else {\n\t\treturn NULL;\n\t}\n\tif (buddy) {\n\t\taccount = purple_buddy_get_account(buddy);\n\t}\n\tif(account && account->gc) {\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(account->gc->prpl);\n\t}\n#if 0\n\tif (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/blist/show_buddy_icons\"))\n\t\treturn NULL;\n#endif\n\t\n\tif (contact) {\n\t\tcustom_img = purple_buddy_icons_node_find_custom_icon((PurpleBlistNode*)contact);\n\t} else {\n\t\tcustom_img = purple_buddy_icons_node_find_custom_icon(node);\n\t}\n\tif (custom_img) {\n\t\tdata = purple_imgstore_get_data(custom_img);\n\t\tlen = purple_imgstore_get_size(custom_img);\n\t}\n\tif (data == NULL) {\n\t\tif (buddy) {\n\t\t\t\n\t\t\tif (!(icon = purple_buddy_icons_find(buddy->account, buddy->name)))\n\t\t\t\treturn NULL;\n\t\t\tdata = purple_buddy_icon_get_data(icon, &len);\n\t\t}\n\t\tif(data == NULL)\n\t\t\treturn NULL;\n\t}\n\tbuf = pidgin_pixbuf_from_data(data, len);\n\tpurple_buddy_icon_unref(icon);\n\tif (!buf) {\n\t\tpurple_debug_warning(\"gtkblist\", \"Couldn't load buddy icon \"\n\t\t\t\t\"on account %s (%s)  buddyname=%s  \"\n\t\t\t\t\"custom_img_data=%p\\n\",\n\t\t\t\taccount ? purple_account_get_username(account) : \"(no account)\",\n\t\t\t\taccount ? purple_account_get_protocol_id(account) : \"(no account)\",\n\t\t\t\tbuddy ? purple_buddy_get_name(buddy) : \"(no buddy)\",\n\t\t\t\tcustom_img ? purple_imgstore_get_data(custom_img) : NULL);\n\t\tpurple_imgstore_unref(custom_img);\n\t\treturn NULL;\n\t}\n\tpurple_imgstore_unref(custom_img);\n\tif (greyed) {\n\t\tgboolean offline = FALSE, idle = FALSE;\n\t\tif (buddy) {\n\t\t\tPurplePresence *presence = purple_buddy_get_presence(buddy);\n\t\t\tif (!PURPLE_BUDDY_IS_ONLINE(buddy))\n\t\t\t\toffline = TRUE;\n\t\t\tif (purple_presence_is_idle(presence))\n\t\t\t\tidle = TRUE;\n\t\t} else if (group) {\n\t\t\tif (purple_blist_get_group_online_count(group) == 0)\n\t\t\t\toffline = TRUE;\n\t\t}\n\t\tif (offline)\n\t\t\tgdk_pixbuf_saturate_and_pixelate(buf, buf, 0.0, FALSE);\n\t\tif (idle)\n\t\t\tgdk_pixbuf_saturate_and_pixelate(buf, buf, 0.25, FALSE);\n\t}\n\t\n\tscale_width = orig_width = gdk_pixbuf_get_width(buf);\n\tscale_height = orig_height = gdk_pixbuf_get_height(buf);\n\tif (prpl_info && prpl_info->icon_spec.scale_rules & PURPLE_ICON_SCALE_DISPLAY)\n\t\tpurple_buddy_icon_get_scale_size(&prpl_info->icon_spec, &scale_width, &scale_height);\n\tif (scaled || scale_height > 200 || scale_width > 200) {\n\t\tGdkPixbuf *tmpbuf;\n\t\tfloat scale_size = scaled ? 32.0 : 200.0;\n\t\tif(scale_height > scale_width) {\n\t\t\tscale_width = scale_size * (double)scale_width / (double)scale_height;\n\t\t\tscale_height = scale_size;\n\t\t} else {\n\t\t\tscale_height = scale_size * (double)scale_height / (double)scale_width;\n\t\t\tscale_width = scale_size;\n\t\t}\n\t\t\n\t\ttmpbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, scale_width, scale_height);\n\t\tgdk_pixbuf_fill(tmpbuf, 0x00000000);\n\t\tgdk_pixbuf_scale(buf, tmpbuf, 0, 0, scale_width, scale_height, 0, 0, (double)scale_width/(double)orig_width, (double)scale_height/(double)orig_height, GDK_INTERP_BILINEAR);\n\t\tif (pidgin_gdk_pixbuf_is_opaque(tmpbuf))\n\t\t\tpidgin_gdk_pixbuf_make_round(tmpbuf);\n\t\tret = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, scale_size, scale_size);\n\t\tgdk_pixbuf_fill(ret, 0x00000000);\n\t\tgdk_pixbuf_copy_area(tmpbuf, 0, 0, scale_width, scale_height, ret, (scale_size-scale_width)/2, (scale_size-scale_height)/2);\n\t\tg_object_unref(G_OBJECT(tmpbuf));\n\t} else {\n\t\tret = gdk_pixbuf_scale_simple(buf,scale_width,scale_height, GDK_INTERP_BILINEAR);\n\t}\n\tg_object_unref(G_OBJECT(buf));\n\treturn ret;\n}\n", "bug_type": null, "idx": 321}
{"project": "Pidgin", "target": 0, "func": "#if GTK_CHECK_VERSION(2,12,0)\npidgin_media_output_volume_changed(GtkScaleButton *range, double value,\n\t\tPurpleMedia *media)\n{\n\tdouble val = (double)value * 100.0;\n#else\npidgin_media_output_volume_changed(GtkRange *range, PurpleMedia *media)\n{\n\tdouble val = (double)gtk_range_get_value(GTK_RANGE(range));\n#endif\n\tpurple_media_set_output_volume(media, NULL, NULL, val);\n}\n}\n", "bug_type": null, "idx": 322}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_status_box_popdown(PidginStatusBox *box)\n{\n\tgtk_widget_hide(box->popup_window);\n\tbox->popup_in_progress = FALSE;\n\tgtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (box->toggle_button),\n\t\t\t\t      FALSE);\n\tgtk_grab_remove (box->popup_window);\n}\n", "bug_type": null, "idx": 323}
{"project": "Pidgin", "target": 0, "func": "static inline uint32_t\nscan_length_prefixed_data(size_t len, const uint8_t *data,\n\t\t\t  size_t *prefix_len_out)\n{\n\tunsigned hdr_max = len < 5 ? len : 5;\n\tunsigned hdr_len;\n\tuint32_t val = 0;\n\tunsigned i;\n\tunsigned shift = 0;\n\tfor (i = 0; i < hdr_max; i++) {\n\t\tval |= (data[i] & 0x7f) << shift;\n\t\tshift += 7;\n\t\tif ((data[i] & 0x80) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == hdr_max) {\n\t\tPROTOBUF_C_UNPACK_ERROR(\"error parsing length for length-prefixed data\");\n\t\treturn 0;\n\t}\n\thdr_len = i + 1;\n\t*prefix_len_out = hdr_len;\n\tif (hdr_len + val > len) {\n\t\tPROTOBUF_C_UNPACK_ERROR(\"data too short after length-prefix of %u\", val);\n\t\treturn 0;\n\t}\n\treturn hdr_len + val;\n}\n", "bug_type": null, "idx": 324}
{"project": "Pidgin", "target": 0, "func": "void\npurple_theme_loader_set_type_string(PurpleThemeLoader *loader, const gchar *type)\n{\n\tPurpleThemeLoaderPrivate *priv;\n\tg_return_if_fail(PURPLE_IS_THEME_LOADER(loader));\n\tpriv = PURPLE_THEME_LOADER_GET_PRIVATE(loader);\n\tg_free(priv->type);\n\tpriv->type = g_strdup(type);\n}\n", "bug_type": null, "idx": 325}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_chat_chpk_add(void *user_data, const char *name)\n{\n\tSilcPurpleChauth sgc = (SilcPurpleChauth)user_data;\n\tSilcPurple sg = sgc->sg;\n\tSilcClient client = sg->client;\n\tSilcClientConnection conn = sg->conn;\n\tSilcPublicKey public_key;\n\tSilcBuffer chpks, pk, chidp;\n\tunsigned char mode[4];\n\tSilcUInt32 m;\n\t\n\tif (!silc_pkcs_load_public_key(name, &public_key, SILC_PKCS_FILE_PEM) &&\n\t    !silc_pkcs_load_public_key(name, &public_key, SILC_PKCS_FILE_BIN)) {\n\t\tsilcpurple_chat_chauth_show(sgc->sg, sgc->channel, sgc->pubkeys);\n\t\tsilc_buffer_free(sgc->pubkeys);\n\t\tsilc_free(sgc);\n\t\tpurple_notify_error(client->application,\n\t\t\t\t  _(\"Add Channel Public Key\"),\n\t\t\t\t  _(\"Could not load public key\"), NULL);\n\t\treturn;\n\t}\n\tpk = silc_pkcs_public_key_payload_encode(public_key);\n\tchpks = silc_buffer_alloc_size(2);\n\tSILC_PUT16_MSB(1, chpks->head);\n\tchpks = silc_argument_payload_encode_one(chpks, pk->data,\n\t\t\t\t\t\t pk->len, 0x00);\n\tsilc_buffer_free(pk);\n\tm = sgc->channel->mode;\n\tm |= SILC_CHANNEL_MODE_CHANNEL_AUTH;\n\t\n\tSILC_PUT32_MSB(m, mode);\n\tchidp = silc_id_payload_encode(sgc->channel->id, SILC_ID_CHANNEL);\n\tsilc_client_command_send(client, conn, SILC_COMMAND_CMODE,\n\t\t\t\t ++conn->cmd_ident, 3,\n\t\t\t\t 1, chidp->data, chidp->len,\n\t\t\t\t 2, mode, sizeof(mode),\n\t\t\t\t 9, chpks->data, chpks->len);\n\tsilc_buffer_free(chpks);\n\tsilc_buffer_free(chidp);\n\tsilc_buffer_free(sgc->pubkeys);\n\tsilc_free(sgc);\n}\n", "bug_type": null, "idx": 326}
{"project": "Pidgin", "target": 0, "func": "static gboolean timeoutfunc(gpointer data) {\n\tstruct stun_conn *sc = data;\n\tif(sc->retry >= 2) {\n\t\tpurple_debug_warning(\"stun\", \"request timed out, giving up.\\n\");\n\t\tif(sc->test == 2)\n\t\t\tnattype.type = PURPLE_STUN_NAT_TYPE_SYMMETRIC;\n\t\t\n\t\tnattype.status = PURPLE_STUN_STATUS_UNKNOWN;\n\t\tnattype.lookup_time = time(NULL);\n\t\t\n\t\tdo_callbacks();\n\t\t\n\t\tsc->timeout = 0;\n\t\tclose_stun_conn(sc);\n\t\treturn FALSE;\n\t}\n\tpurple_debug_info(\"stun\", \"request timed out, retrying.\\n\");\n\tsc->retry++;\n\tif (sendto(sc->fd, sc->packet, sc->packetsize, 0,\n\t\t(struct sockaddr *)&(sc->addr), sizeof(struct sockaddr_in)) !=\n\t\t(gssize)sc->packetsize)\n\t{\n\t\tpurple_debug_warning(\"stun\", \"sendto failed\\n\");\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 327}
{"project": "Pidgin", "target": 0, "func": "static void\noscar_auth_dontgrant_msgprompt(gpointer cbdata)\n{\n\tstruct name_data *data = cbdata;\n\tpurple_request_input(data->gc, NULL, _(\"Authorization Denied Message:\"),\n\t\t\t\t\t   NULL, _(\"No reason given.\"), TRUE, FALSE, NULL,\n\t\t\t\t\t   _(\"_OK\"), G_CALLBACK(oscar_auth_dontgrant),\n\t\t\t\t\t   _(\"_Cancel\"), G_CALLBACK(oscar_free_name_data),\n\t\t\t\t\t   purple_connection_get_account(data->gc), data->name, NULL,\n\t\t\t\t\t   data);\n}\n", "bug_type": null, "idx": 328}
{"project": "Pidgin", "target": 0, "func": "static void zephyr_register_slash_commands(void)\n{\n\tpurple_cmd_register(\"msg\",\"ws\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_msg, _(\"msg &lt;nick&gt; &lt;message&gt;:  Send a private message to a user\"), NULL);\n\tpurple_cmd_register(\"zlocate\",\"w\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_zlocate, _(\"zlocate &lt;nick&gt;: Locate user\"), NULL);\n\tpurple_cmd_register(\"zl\",\"w\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_zlocate, _(\"zl &lt;nick&gt;: Locate user\"), NULL);\n\tpurple_cmd_register(\"instance\",\"s\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_instance, _(\"instance &lt;instance&gt;: Set the instance to be used on this class\"), NULL);\n\tpurple_cmd_register(\"inst\",\"s\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_instance, _(\"inst &lt;instance&gt;: Set the instance to be used on this class\"), NULL);\n\tpurple_cmd_register(\"topic\",\"s\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_instance, _(\"topic &lt;instance&gt;: Set the instance to be used on this class\"), NULL);\n\tpurple_cmd_register(\"sub\", \"www\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_joinchat_cir,\n\t\t\t  _(\"sub &lt;class&gt; &lt;instance&gt; &lt;recipient&gt;: Join a new chat\"), NULL);\n\tpurple_cmd_register(\"zi\",\"ws\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_zi, _(\"zi &lt;instance&gt;: Send a message to &lt;message,<i>instance</i>,*&gt;\"), NULL);\n\tpurple_cmd_register(\"zci\",\"wws\",PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_zci,\n\t\t\t  _(\"zci &lt;class&gt; &lt;instance&gt;: Send a message to &lt;<i>class</i>,<i>instance</i>,*&gt;\"), NULL);\n\tpurple_cmd_register(\"zcir\",\"wwws\",PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_zcir,\n\t\t\t  _(\"zcir &lt;class&gt; &lt;instance&gt; &lt;recipient&gt;: Send a message to &lt;<i>class</i>,<i>instance</i>,<i>recipient</i>&gt;\"), NULL);\n\tpurple_cmd_register(\"zir\",\"wws\",PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_zir,\n\t\t\t  _(\"zir &lt;instance&gt; &lt;recipient&gt;: Send a message to &lt;MESSAGE,<i>instance</i>,<i>recipient</i>&gt;\"), NULL);\n\tpurple_cmd_register(\"zc\",\"ws\", PURPLE_CMD_P_PRPL,\n\t\t\t  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,\n\t\t\t  \"prpl-zephyr\",\n\t\t\t  zephyr_purple_cmd_zc, _(\"zc &lt;class&gt;: Send a message to &lt;<i>class</i>,PERSONAL,*&gt;\"), NULL);\n}\n", "bug_type": null, "idx": 329}
{"project": "Pidgin", "target": 0, "func": " */\nint gnt_text_view_tag_change(GntTextView *view, const char *name, const char *text, gboolean all)\n{\n\tGList *alllines = g_list_first(view->list);\n\tGList *list, *next, *iter, *inext;\n\tconst int text_length = text ? strlen(text) : 0;\n\tint count = 0;\n\tfor (list = view->tags; list; list = next) {\n\t\tGntTextTag *tag = list->data;\n\t\tnext = list->next;\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tint change;\n\t\t\tchar *before, *after;\n\t\t\tcount++;\n\t\t\tbefore = g_strndup(view->string->str, tag->start);\n\t\t\tafter = g_strdup(view->string->str + tag->end);\n\t\t\tchange = (tag->end - tag->start) - text_length;\n\t\t\tg_string_printf(view->string, \"%s%s%s\", before, text ? text : \"\", after);\n\t\t\tg_free(before);\n\t\t\tg_free(after);\n\t\t\t\n\t\t\tfor (iter = next; iter; iter = iter->next) {\n\t\t\t\tGntTextTag *t = iter->data;\n\t\t\t\tt->start -= change;\n\t\t\t\tt->end -= change;\n\t\t\t}\n\t\t\t\n\t\t\tfor (iter = alllines; iter; iter = inext) {\n\t\t\t\tGList *segs, *snext;\n\t\t\t\tGntTextLine *line = iter->data;\n\t\t\t\tinext = iter->next;\n\t\t\t\tif (!line) {\n\t\t\t\t\tg_warn_if_reached();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (segs = line->segments; segs; segs = snext) {\n\t\t\t\t\tGntTextSegment *seg = segs->data;\n\t\t\t\t\tif (!line)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsnext = segs->next;\n\t\t\t\t\tif (seg->start >= tag->end) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tseg->start -= change;\n\t\t\t\t\t\tseg->end -= change;\n\t\t\t\t\t} else if (seg->end <= tag->start) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else if (seg->start >= tag->start) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (text == NULL) {\n\t\t\t\t\t\t\tfree_text_segment(seg, NULL);\n\t\t\t\t\t\t\tline->segments = g_list_delete_link(line->segments, segs);\n\t\t\t\t\t\t\tif (line->segments == NULL) {\n\t\t\t\t\t\t\t\tfree_text_line(line, NULL);\n\t\t\t\t\t\t\t\tline = NULL;\n\t\t\t\t\t\t\t\tif (view->list == iter) {\n\t\t\t\t\t\t\t\t\tif (inext)\n\t\t\t\t\t\t\t\t\t\tview->list = inext;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tview->list = iter->prev;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\talllines = g_list_delete_link(alllines, iter);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tseg->start = tag->start;\n\t\t\t\t\t\t\tseg->end = tag->end - change;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (line)\n\t\t\t\t\t\t\tline->length -= change;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tgnt_warning(\"WTF! This needs to be handled properly!!%s\", \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (text == NULL) {\n\t\t\t\t\n\t\t\t\tview->tags = g_list_delete_link(view->tags, list);\n\t\t\t\tfree_tag(tag, NULL);\n\t\t\t} else {\n\t\t\t\ttag->end -= change;\n\t\t\t}\n\t\t\tif (!all)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgnt_widget_draw(GNT_WIDGET(view));\n\treturn count;\n}\n", "bug_type": null, "idx": 330}
{"project": "Pidgin", "target": 0, "func": "static void\nresolve_host(PurpleDnsQueryData *query_data)\n{\n\tqueued_requests = g_slist_append(queued_requests, query_data);\n\thandle_next_queued_request();\n}\nstatic void\nresolve_host(PurpleDnsQueryData *query_data)\n{\n\tGError *err = NULL;\n\t\n\tquery_data->resolver = g_thread_create(dns_thread,\n\t\t\tquery_data, FALSE, &err);\n\tif (query_data->resolver == NULL)\n\t{\n\t\tchar message[1024];\n\t\tg_snprintf(message, sizeof(message), _(\"Thread creation failure: %s\"),\n\t\t\t\t(err && err->message) ? err->message : _(\"Unknown reason\"));\n\t\tg_error_free(err);\n\t\tpurple_dnsquery_failed(query_data, message);\n\t}\n}\nstatic void\nresolve_host(PurpleDnsQueryData *query_data)\n{\n\tstruct sockaddr_in sin;\n\tGSList *hosts = NULL;\n\tstruct hostent *hp;\n\tgchar *hostname;\n#ifdef USE_IDN\n\tif (!dns_str_is_ascii(query_data->hostname)) {\n\t\tint ret = purple_network_convert_idn_to_ascii(query_data->hostname,\n\t\t\t\t&hostname);\n\t\tif (ret != 0) {\n\t\t\tchar message[1024];\n\t\t\tg_snprintf(message, sizeof(message), _(\"Error resolving %s: %d\"),\n\t\t\t\t\tquery_data->hostname, ret);\n\t\t\tpurple_dnsquery_failed(query_data, message);\n\t\t\treturn;\n\t\t}\n\t} else \n#endif\n\thostname = g_strdup(query_data->hostname);\n\tif(!(hp = gethostbyname(hostname))) {\n\t\tchar message[1024];\n\t\tg_snprintf(message, sizeof(message), _(\"Error resolving %s: %d\"),\n\t\t\t\tquery_data->hostname, h_errno);\n\t\tpurple_dnsquery_failed(query_data, message);\n\t\tg_free(hostname);\n\t\treturn;\n\t}\n\tmemset(&sin, 0, sizeof(struct sockaddr_in));\n\tmemcpy(&sin.sin_addr.s_addr, hp->h_addr, hp->h_length);\n\tsin.sin_family = hp->h_addrtype;\n\tg_free(hostname);\n\tsin.sin_port = htons(query_data->port);\n\thosts = g_slist_append(hosts, GINT_TO_POINTER(sizeof(sin)));\n\thosts = g_slist_append(hosts, g_memdup(&sin, sizeof(sin)));\n\tpurple_dnsquery_resolved(query_data, hosts);\n}\n", "bug_type": null, "idx": 331}
{"project": "Pidgin", "target": 0, "func": "static PurpleBlistNode *get_next_node(PurpleBlistNode *node, gboolean godeep)\n{\n\tif (node == NULL)\n\t\treturn NULL;\n\tif (godeep && node->child)\n\t\treturn node->child;\n\tif (node->next)\n\t\treturn node->next;\n\treturn get_next_node(node->parent, FALSE);\n}\n", "bug_type": null, "idx": 332}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nvalue_equals(gpointer key, gpointer value, gpointer user_data)\n{\n\treturn (value == user_data);\n}\n", "bug_type": null, "idx": 333}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npidgin_tooltip_expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)\n{\n\tif (pidgin_tooltip.paint_tooltip) {\n\t\tgtk_paint_flat_box(widget->style, widget->window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,\n\t\t\t\tNULL, widget, \"tooltip\", 0, 0, -1, -1);\n\t\tpidgin_tooltip.paint_tooltip(widget, data);\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 334}
{"project": "Pidgin", "target": 0, "func": "PurplePresence *\npurple_account_get_presence(const PurpleAccount *account)\n{\n\tg_return_val_if_fail(account != NULL, NULL);\n\treturn account->presence;\n}\n", "bug_type": null, "idx": 335}
{"project": "Pidgin", "target": 0, "func": "GType\npurple_media_session_type_get_type()\n{\n\tstatic GType type = 0;\n\tif (type == 0) {\n\t\tstatic const GFlagsValue values[] = {\n\t\t\t{ PURPLE_MEDIA_NONE,\n\t\t\t\t\"PURPLE_MEDIA_NONE\", \"none\" },\n\t\t\t{ PURPLE_MEDIA_RECV_AUDIO,\n\t\t\t\t\"PURPLE_MEDIA_RECV_AUDIO\", \"recv-audio\" },\n\t\t\t{ PURPLE_MEDIA_SEND_AUDIO,\n\t\t\t\t\"PURPLE_MEDIA_SEND_AUDIO\", \"send-audio\" },\n\t\t\t{ PURPLE_MEDIA_RECV_VIDEO,\n\t\t\t\t\"PURPLE_MEDIA_RECV_VIDEO\", \"recv-video\" },\n\t\t\t{ PURPLE_MEDIA_SEND_VIDEO,\n\t\t\t\t\"PURPLE_MEDIA_SEND_VIDEO\", \"send-video\" },\n\t\t\t{ PURPLE_MEDIA_RECV_APPLICATION,\n\t\t\t\t\"PURPLE_MEDIA_RECV_APPLICATION\", \"recv-application\" },\n\t\t\t{ PURPLE_MEDIA_SEND_APPLICATION,\n\t\t\t\t\"PURPLE_MEDIA_SEND_APPLICATION\", \"send-application\" },\n\t\t\t{ PURPLE_MEDIA_AUDIO,\n\t\t\t\t\"PURPLE_MEDIA_AUDIO\", \"audio\" },\n\t\t\t{ PURPLE_MEDIA_VIDEO,\n\t\t\t\t\"PURPLE_MEDIA_VIDEO\", \"video\" },\n\t\t\t{ PURPLE_MEDIA_APPLICATION,\n\t\t\t\t\"PURPLE_MEDIA_APPLICATION\", \"application\" },\n\t\t\t{ 0, NULL, NULL }\n\t\t};\n\t\ttype = g_flags_register_static(\n\t\t\t\t\"PurpleMediaSessionType\", values);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 336}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_blist_theme_set_layout(PidginBlistTheme *theme, const PidginBlistLayout *layout)\n{\n\tPidginBlistThemePrivate *priv;\n\tg_return_if_fail(PIDGIN_IS_BLIST_THEME(theme));\n\tpriv = PIDGIN_BLIST_THEME_GET_PRIVATE(G_OBJECT(theme));\n\tg_free(priv->layout);\n\tpriv->layout = g_memdup(layout, sizeof(PidginBlistLayout));\n}\n", "bug_type": null, "idx": 337}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_signal_emit_vargs_return_1(void *instance, const char *signal,\n\t\t\t\t\t\t\t\tva_list args)\n{\n\tPurpleInstanceData *instance_data;\n\tPurpleSignalData *signal_data;\n\tPurpleSignalHandlerData *handler_data;\n\tGList *l, *l_next;\n\tva_list tmp;\n\tg_return_val_if_fail(instance != NULL, NULL);\n\tg_return_val_if_fail(signal   != NULL, NULL);\n\tinstance_data =\n\t\t(PurpleInstanceData *)g_hash_table_lookup(instance_table, instance);\n\tg_return_val_if_fail(instance_data != NULL, NULL);\n\tsignal_data =\n\t\t(PurpleSignalData *)g_hash_table_lookup(instance_data->signals, signal);\n\tif (signal_data == NULL)\n\t{\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"signals\",\n\t\t\t\t   \"Signal data for %s not found!\\n\", signal);\n\t\treturn 0;\n\t}\n#ifdef HAVE_DBUS\n\tG_VA_COPY(tmp, args);\n\tpurple_dbus_signal_emit_purple(signal, signal_data->num_values,\n\t\t\t\t   signal_data->values, tmp);\n\tva_end(tmp);\n#endif\t\n\tfor (l = signal_data->handlers; l != NULL; l = l_next)\n\t{\n\t\tvoid *ret_val = NULL;\n\t\tl_next = l->next;\n\t\thandler_data = (PurpleSignalHandlerData *)l->data;\n\t\tG_VA_COPY(tmp, args);\n\t\tif (handler_data->use_vargs)\n\t\t{\n\t\t\tret_val = ((void *(*)(va_list, void *))handler_data->cb)(\n\t\t\t\ttmp, handler_data->data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsignal_data->marshal(handler_data->cb, tmp,\n\t\t\t\t\t\t\t\t handler_data->data, &ret_val);\n\t\t}\n\t\tva_end(tmp);\n\t\tif (ret_val != NULL)\n\t\t\treturn ret_val;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 338}
{"project": "Pidgin", "target": 0, "func": "void tcl_cmd_cleanup(Tcl_Interp *interp)\n{\n\tGList *cur;\n\tstruct tcl_cmd_handler *handler;\n\tfor (cur = tcl_cmd_callbacks; cur != NULL; cur = g_list_next(cur)) {\n\t\thandler = cur->data;\n\t\tif (handler->interp == interp) {\n\t\t\tpurple_cmd_unregister(handler->id);\n\t\t\ttcl_cmd_handler_free(handler);\n\t\t\tcur->data = NULL;\n\t\t}\n\t}\n\ttcl_cmd_callbacks = g_list_remove_all(tcl_cmd_callbacks, NULL);\n}\n", "bug_type": null, "idx": 339}
{"project": "Pidgin", "target": 0, "func": "void\njabber_google_session_parse(JabberStream *js, const char *from,\n                            JabberIqType type, const char *iq_id,\n                            xmlnode *session_node)\n{\n\tGoogleSession *session = NULL;\n\tGoogleSessionId id;\n\txmlnode *desc_node;\n\tGList *iter = NULL;\n\tif (type != JABBER_IQ_SET)\n\t\treturn;\n\tid.id = (gchar*)xmlnode_get_attrib(session_node, \"id\");\n\tif (!id.id)\n\t\treturn;\n\tid.initiator = (gchar*)xmlnode_get_attrib(session_node, \"initiator\");\n\tif (!id.initiator)\n\t\treturn;\n\titer = purple_media_manager_get_media_by_account(\n\t\t\tpurple_media_manager_get(),\n\t\t\tpurple_connection_get_account(js->gc));\n\tfor (; iter; iter = g_list_delete_link(iter, iter)) {\n\t\tGoogleSession *gsession =\n\t\t\t\tpurple_media_get_prpl_data(iter->data);\n\t\tif (google_session_id_equal(&(gsession->id), &id)) {\n\t\t\tsession = gsession;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (iter != NULL) {\n\t\tg_list_free(iter);\n\t}\n\tif (session) {\n\t\tgoogle_session_parse_iq(js, session, session_node, iq_id);\n\t\treturn;\n\t}\n\t\n\tif (strcmp(xmlnode_get_attrib(session_node, \"type\"), \"initiate\"))\n\t\treturn;\n\tdesc_node = xmlnode_get_child(session_node, \"description\");\n\tif (!desc_node)\n\t\treturn;\n\tsession = g_new0(GoogleSession, 1);\n\tsession->id.id = g_strdup(id.id);\n\tsession->id.initiator = g_strdup(id.initiator);\n\tsession->state = UNINIT;\n\tsession->js = js;\n\tsession->remote_jid = g_strdup(session->id.initiator);\n\tsession->session_data = g_new0(GoogleAVSessionData, 1);\n\tgoogle_session_handle_initiate(js, session, session_node, iq_id);\n}\n", "bug_type": null, "idx": 340}
{"project": "Pidgin", "target": 0, "func": "static void\njingle_session_finalize (GObject *session)\n{\n\tJingleSessionPrivate *priv = JINGLE_SESSION_GET_PRIVATE(session);\n\tpurple_debug_info(\"jingle\",\"jingle_session_finalize\\n\");\n\tg_hash_table_remove(priv->js->sessions, priv->sid);\n\tg_free(priv->sid);\n\tg_free(priv->remote_jid);\n\tg_free(priv->local_jid);\n\tfor (; priv->contents; priv->contents =\n\t\t\tg_list_delete_link(priv->contents, priv->contents)) {\n\t\tg_object_unref(priv->contents->data);\n\t}\n\tfor (; priv->pending_contents; priv->pending_contents =\n\t\t\tg_list_delete_link(priv->pending_contents, priv->pending_contents)) {\n\t\tg_object_unref(priv->pending_contents->data);\n\t}\n\tparent_class->finalize(session);\n}\n", "bug_type": null, "idx": 341}
{"project": "Pidgin", "target": 0, "func": "void\npurple_plugin_pref_frame_destroy(PurplePluginPrefFrame *frame)\n{\n\tg_return_if_fail(frame != NULL);\n\tg_list_foreach(frame->prefs, (GFunc)purple_plugin_pref_destroy, NULL);\n\tg_list_free(frame->prefs);\n\tg_free(frame);\n}\n", "bug_type": null, "idx": 342}
{"project": "Pidgin", "target": 0, "func": "static void\npython_script_selected(GntFileSel *fs, const char *path, const char *f, gpointer n)\n{\n\tchar *dir = g_path_get_dirname(path);\n\tFILE *file = fopen(path, \"r\");\n\tPyObject *pp = PySys_GetObject(\"path\");\n#if PY_MAJOR_VERSION >= 3\n\tPyObject *dirobj = PyUnicode_FromString(dir);\n#else\n\tPyObject *dirobj = PyString_FromString(dir);\n#endif\n\tPyList_Insert(pp, 0, dirobj);\n\tPy_DECREF(dirobj);\n\tPyRun_SimpleFile(file, path);\n\tfclose(file);\n\tif (PyErr_Occurred()) {\n\t\tPyErr_Print();\n\t}\n\tg_free(dir);\n\tgnt_widget_destroy(GNT_WIDGET(fs));\n}\n", "bug_type": null, "idx": 343}
{"project": "Pidgin", "target": 0, "func": "void gg_connection_failure(struct gg_session *gs, struct gg_event *ge,\n\tenum gg_failure_t failure)\n{\n\tgg_close(gs);\n\tif (ge != NULL) {\n\t\tge->type = GG_EVENT_CONN_FAILED;\n\t\tge->event.failure = failure;\n\t}\n\tgs->state = GG_STATE_IDLE;\n}\n", "bug_type": null, "idx": 344}
{"project": "Pidgin", "target": 0, "func": "const char *\nprotobuf_c_version(void)\n{\n\treturn PROTOBUF_C_VERSION;\n}\n", "bug_type": null, "idx": 345}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_session_set_resolver(struct gg_session *gs, gg_resolver_t type)\n{\n\tGG_SESSION_CHECK(gs, -1);\n\tif (type == GG_RESOLVER_DEFAULT) {\n\t\tif (gg_global_resolver_type != GG_RESOLVER_DEFAULT) {\n\t\t\tgs->resolver_type = gg_global_resolver_type;\n\t\t\tgs->resolver_start = gg_global_resolver_start;\n\t\t\tgs->resolver_cleanup = gg_global_resolver_cleanup;\n\t\t\treturn 0;\n\t\t}\n#ifdef GG_CONFIG_HAVE_PTHREAD\n\t\ttype = GG_RESOLVER_PTHREAD;\n#elif defined(_WIN32)\n\t\ttype = GG_RESOLVER_WIN32;\n#elif defined(GG_CONFIG_HAVE_FORK)\n\t\ttype = GG_RESOLVER_FORK;\n#endif\n\t}\n\tswitch (type) {\n#ifdef GG_CONFIG_HAVE_FORK\n\t\tcase GG_RESOLVER_FORK:\n\t\t\tgs->resolver_type = type;\n\t\t\tgs->resolver_start = gg_resolver_fork_start;\n\t\t\tgs->resolver_cleanup = gg_resolver_fork_cleanup;\n\t\t\treturn 0;\n#endif\n#ifdef GG_CONFIG_HAVE_PTHREAD\n\t\tcase GG_RESOLVER_PTHREAD:\n\t\t\tgs->resolver_type = type;\n\t\t\tgs->resolver_start = gg_resolver_pthread_start;\n\t\t\tgs->resolver_cleanup = gg_resolver_pthread_cleanup;\n\t\t\treturn 0;\n#endif\n#ifdef _WIN32\n\t\tcase GG_RESOLVER_WIN32:\n\t\t\tgs->resolver_type = type;\n\t\t\tgs->resolver_start = gg_resolver_win32_start;\n\t\t\tgs->resolver_cleanup = gg_resolver_win32_cleanup;\n\t\t\treturn 0;\n#endif\n\t\tdefault:\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t}\n}\n", "bug_type": null, "idx": 346}
{"project": "Pidgin", "target": 0, "func": " */\nint aim_ssi_addbuddy(OscarData *od, const char *name, const char *group, GSList *data, const char *alias, const char *comment, const char *smsnum, gboolean needauth)\n{\n\tstruct aim_ssi_item *parent;\n\tif (!od || !name || !group)\n\t\treturn -EINVAL;\n\t\n\tif (!(parent = aim_ssi_itemlist_finditem(od->ssi.local, group, NULL, AIM_SSI_TYPE_GROUP))) {\n\t\t\n\t\tif (aim_ssi_itemlist_find(od->ssi.local, 0x0000, 0x0000) == NULL)\n\t\t\taim_ssi_itemlist_add(&od->ssi.local, NULL, 0x0000, 0x0000, AIM_SSI_TYPE_GROUP, NULL);\n\t\t\n\t\tparent = aim_ssi_itemlist_add(&od->ssi.local, group, 0xFFFF, 0x0000, AIM_SSI_TYPE_GROUP, NULL);\n\t\t\n\t\taim_ssi_itemlist_rebuildgroup(od->ssi.local, NULL);\n\t}\n\t\n\tif (needauth)\n\t\taim_tlvlist_add_noval(&data, 0x0066);\n\tif (alias != NULL)\n\t\taim_tlvlist_add_str(&data, 0x0131, alias);\n\tif (smsnum != NULL)\n\t\taim_tlvlist_add_str(&data, 0x013a, smsnum);\n\tif (comment != NULL)\n\t\taim_tlvlist_add_str(&data, 0x013c, comment);\n\t\n\taim_ssi_itemlist_add(&od->ssi.local, name, parent->gid, 0xFFFF, AIM_SSI_TYPE_BUDDY, data);\n\taim_tlvlist_free(data);\n\t\n\taim_ssi_itemlist_rebuildgroup(od->ssi.local, group);\n\t\n\treturn aim_ssi_sync(od);\n}\n", "bug_type": null, "idx": 347}
{"project": "Pidgin", "target": 0, "func": " */\nstatic gboolean parse_client_login_response(PurpleConnection *gc, const gchar *response, gsize response_len, char **token, char **secret, time_t *hosttime)\n{\n\tOscarData *od = purple_connection_get_protocol_data(gc);\n\txmlnode *response_node, *tmp_node, *data_node;\n\txmlnode *secret_node = NULL, *hosttime_node = NULL, *token_node = NULL, *tokena_node = NULL;\n\tchar *tmp;\n\t\n\tresponse_node = xmlnode_from_str(response, response_len);\n\tif (response_node == NULL)\n\t{\n\t\tchar *msg;\n\t\tpurple_debug_error(\"oscar\", \"clientLogin could not parse \"\n\t\t\t\t\"response as XML: %s\\n\", response);\n\t\tmsg = generate_error_message(response_node,\n\t\t\t\tget_client_login_url(od));\n\t\tpurple_connection_error_reason(gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, msg);\n\t\tg_free(msg);\n\t\treturn FALSE;\n\t}\n\t\n\ttmp_node = xmlnode_get_child(response_node, \"statusCode\");\n\tdata_node = xmlnode_get_child(response_node, \"data\");\n\tif (data_node != NULL) {\n\t\tsecret_node = xmlnode_get_child(data_node, \"sessionSecret\");\n\t\thosttime_node = xmlnode_get_child(data_node, \"hostTime\");\n\t\ttoken_node = xmlnode_get_child(data_node, \"token\");\n\t\tif (token_node != NULL)\n\t\t\ttokena_node = xmlnode_get_child(token_node, \"a\");\n\t}\n\t\n\tif (tmp_node == NULL || (tmp = xmlnode_get_data_unescaped(tmp_node)) == NULL) {\n\t\tchar *msg;\n\t\tpurple_debug_error(\"oscar\", \"clientLogin response was \"\n\t\t\t\t\"missing statusCode: %s\\n\", response);\n\t\tmsg = generate_error_message(response_node,\n\t\t\t\tget_client_login_url(od));\n\t\tpurple_connection_error_reason(gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, msg);\n\t\tg_free(msg);\n\t\txmlnode_free(response_node);\n\t\treturn FALSE;\n\t}\n\t\n\tif (strcmp(tmp, \"200\") != 0)\n\t{\n\t\tint status_code, status_detail_code = 0;\n\t\tstatus_code = atoi(tmp);\n\t\tg_free(tmp);\n\t\ttmp_node = xmlnode_get_child(response_node, \"statusDetailCode\");\n\t\tif (tmp_node != NULL && (tmp = xmlnode_get_data_unescaped(tmp_node)) != NULL) {\n\t\t\tstatus_detail_code = atoi(tmp);\n\t\t\tg_free(tmp);\n\t\t}\n\t\tpurple_debug_error(\"oscar\", \"clientLogin response statusCode \"\n\t\t\t\t\"was %d (%d): %s\\n\", status_code, status_detail_code, response);\n\t\tif (status_code == 330 && status_detail_code == 3011) {\n\t\t\tPurpleAccount *account = purple_connection_get_account(gc);\n\t\t\tif (!purple_account_get_remember_password(account))\n\t\t\t\tpurple_account_set_password(account, NULL);\n\t\t\tpurple_connection_error_reason(gc,\n\t\t\t\t\tPURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,\n\t\t\t\t\t_(\"Incorrect password\"));\n\t\t} else if (status_code == 330 && status_detail_code == 3015) {\n\t\t\tpurple_connection_error_reason(gc,\n\t\t\t\t\tPURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,\n\t\t\t\t\t_(\"Server requested that you fill out a CAPTCHA in order to \"\n\t\t\t\t\t\"sign in, but this client does not currently support CAPTCHAs.\"));\n\t\t} else if (status_code == 401 && status_detail_code == 3019) {\n\t\t\tpurple_connection_error_reason(gc,\n\t\t\t\t\tPURPLE_CONNECTION_ERROR_OTHER_ERROR,\n\t\t\t\t\t_(\"AOL does not allow your screen name to authenticate here\"));\n\t\t} else {\n\t\t\tchar *msg;\n\t\t\tmsg = generate_error_message(response_node,\n\t\t\t\t\tget_client_login_url(od));\n\t\t\tpurple_connection_error_reason(gc,\n\t\t\t\t\tPURPLE_CONNECTION_ERROR_OTHER_ERROR, msg);\n\t\t\tg_free(msg);\n\t\t}\n\t\txmlnode_free(response_node);\n\t\treturn FALSE;\n\t}\n\tg_free(tmp);\n\t\n\tif (data_node == NULL || secret_node == NULL ||\n\t\ttoken_node == NULL || tokena_node == NULL)\n\t{\n\t\tchar *msg;\n\t\tpurple_debug_error(\"oscar\", \"clientLogin response was missing \"\n\t\t\t\t\"something: %s\\n\", response);\n\t\tmsg = generate_error_message(response_node,\n\t\t\t\tget_client_login_url(od));\n\t\tpurple_connection_error_reason(gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, msg);\n\t\tg_free(msg);\n\t\txmlnode_free(response_node);\n\t\treturn FALSE;\n\t}\n\t\n\t*token = xmlnode_get_data_unescaped(tokena_node);\n\t*secret = xmlnode_get_data_unescaped(secret_node);\n\ttmp = xmlnode_get_data_unescaped(hosttime_node);\n\tif (*token == NULL || **token == '\\0' || *secret == NULL || **secret == '\\0' || tmp == NULL || *tmp == '\\0')\n\t{\n\t\tchar *msg;\n\t\tpurple_debug_error(\"oscar\", \"clientLogin response was missing \"\n\t\t\t\t\"something: %s\\n\", response);\n\t\tmsg = generate_error_message(response_node,\n\t\t\t\tget_client_login_url(od));\n\t\tpurple_connection_error_reason(gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, msg);\n\t\tg_free(msg);\n\t\tg_free(*token);\n\t\tg_free(*secret);\n\t\tg_free(tmp);\n\t\txmlnode_free(response_node);\n\t\treturn FALSE;\n\t}\n\t*hosttime = strtol(tmp, NULL, 10);\n\tg_free(tmp);\n\txmlnode_free(response_node);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 348}
{"project": "Pidgin", "target": 0, "func": "char *jabber_get_next_id(JabberStream *js)\n{\n\treturn g_strdup_printf(\"purple%x\", js->next_id++);\n}\n", "bug_type": null, "idx": 349}
{"project": "Pidgin", "target": 0, "func": "#undef listen\nint gg_win32_listen(int sockfd, int backlog)\n{\n\tint res;\n\tres = listen(sockfd, backlog);\n\tif (res == -1)\n\t\terrno = gg_win32_map_wsa_error_to_errno(EAGAIN);\n\treturn res;\n}\n", "bug_type": null, "idx": 350}
{"project": "Pidgin", "target": 0, "func": "size_t purple_imgstore_get_size(PurpleStoredImage *img)\n{\n\tg_return_val_if_fail(img != NULL, 0);\n\treturn img->size;\n}\n", "bug_type": null, "idx": 351}
{"project": "Pidgin", "target": 0, "func": "static PurpleTheme *\nprefs_theme_find_theme(const gchar *path, const gchar *type)\n{\n\tPurpleTheme *theme = purple_theme_manager_load_theme(path, type);\n\tGDir *dir = g_dir_open(path, 0, NULL);\n\tconst gchar *next;\n\twhile (!PURPLE_IS_THEME(theme) && (next = g_dir_read_name(dir))) {\n\t\tgchar *next_path = g_build_filename(path, next, NULL);\n\t\tif (g_file_test(next_path, G_FILE_TEST_IS_DIR))\n\t\t\ttheme = prefs_theme_find_theme(next_path, type);\n\t\tg_free(next_path);\n\t}\n\tg_dir_close(dir);\n\treturn theme;\n}\n", "bug_type": null, "idx": 352}
{"project": "Pidgin", "target": 0, "func": "DNSServiceErrorType _wpurple_DNSServiceResolve(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name,\n\t\tconst char *regtype, const char *domain, DNSServiceResolveReply callBack, void *context) {\n\tg_return_val_if_fail(_DNSServiceResolve != NULL, kDNSServiceErr_Unknown);\n\treturn (_DNSServiceResolve)(sdRef, flags, interfaceIndex, name, regtype, domain, callBack, context);\n}\n", "bug_type": null, "idx": 353}
{"project": "Pidgin", "target": 0, "func": "static unsigned\nscan_varint(unsigned len, const uint8_t *data)\n{\n\tunsigned i;\n\tif (len > 10)\n\t\tlen = 10;\n\tfor (i = 0; i < len; i++)\n\t\tif ((data[i] & 0x80) == 0)\n\t\t\tbreak;\n\tif (i == len)\n\t\treturn 0;\n\treturn i + 1;\n}\n", "bug_type": null, "idx": 354}
{"project": "Pidgin", "target": 0, "func": "static void\nreset_blist_window(GntWidget *window, gpointer null)\n{\n\tPurpleBlistNode *node;\n\tpurple_signals_disconnect_by_handle(finch_blist_get_handle());\n\tFINCH_SET_DATA(purple_get_blist(), NULL);\n\tnode = purple_blist_get_root();\n\twhile (node) {\n\t\treset_blist_node_ui_data(node);\n\t\tnode = purple_blist_node_next(node, TRUE);\n\t}\n\tif (ggblist->typing)\n\t\tpurple_timeout_remove(ggblist->typing);\n\tremove_peripherals(ggblist);\n\tif (ggblist->tagged)\n\t\tg_list_free(ggblist->tagged);\n\tif (ggblist->new_group_timeout)\n\t\tpurple_timeout_remove(ggblist->new_group_timeout);\n\tif (ggblist->new_group)\n\t\tg_list_free(ggblist->new_group);\n\tg_free(ggblist);\n\tggblist = NULL;\n}\n", "bug_type": null, "idx": 355}
{"project": "Pidgin", "target": 0, "func": "static void nullprpl_reject_chat(PurpleConnection *gc, GHashTable *components) {\n  const char *invited_by = g_hash_table_lookup(components, \"invited_by\");\n  const char *room = g_hash_table_lookup(components, \"room\");\n  const char *username = gc->account->username;\n  PurpleConnection *invited_by_gc = get_nullprpl_gc(invited_by);\n  char *message = g_strdup_printf(\n    \"%s %s %s.\",\n    username,\n    _(\"has rejected your invitation to join the chat room\"),\n    room);\n  purple_debug_info(\"nullprpl\",\n                    \"%s has rejected %s's invitation to join chat room %s\\n\",\n                    username, invited_by, room);\n  purple_notify_info(invited_by_gc,\n                     _(\"Chat invitation rejected\"),\n                     _(\"Chat invitation rejected\"),\n                     message);\n  g_free(message);\n}\n", "bug_type": null, "idx": 356}
{"project": "Pidgin", "target": 0, "func": "static void\nappend_to_tooltip(PurpleBlistNode *node, GString *text, gboolean full)\n{\n\tif (full) {\n\t\tconst gchar *note = purple_blist_node_get_string(node, \"notes\");\n\t\tif ((note != NULL) && (*note != '\\0')) {\n\t\t\tchar *tmp, *esc;\n\t\t\tpurple_markup_html_to_xhtml(note, NULL, &tmp);\n\t\t\tesc = g_markup_escape_text(tmp, -1);\n\t\t\tg_free(tmp);\n\t\t\tg_string_append_printf(text, _(\"\\n<b>Buddy Note</b>: %s\"),\n\t\t\t                       esc);\n\t\t\tg_free(esc);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 357}
{"project": "Pidgin", "target": 0, "func": "unsigned int\npurple_plugin_pref_get_max_length(PurplePluginPref *pref)\n{\n\tg_return_val_if_fail(pref != NULL, 0);\n\treturn pref->max_length;\n}\n", "bug_type": null, "idx": 358}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ngnt_text_view_clicked(GntWidget *widget, GntMouseEvent event, int x, int y)\n{\n\tif (event == GNT_MOUSE_SCROLL_UP) {\n\t\tgnt_text_view_scroll(GNT_TEXT_VIEW(widget), -1);\n\t} else if (event == GNT_MOUSE_SCROLL_DOWN) {\n\t\tgnt_text_view_scroll(GNT_TEXT_VIEW(widget), 1);\n\t} else if (event == GNT_LEFT_MOUSE_DOWN) {\n\t\tselect_start = gnt_text_view_get_p(GNT_TEXT_VIEW(widget), x - widget->priv.x, y - widget->priv.y);\n\t\tg_timeout_add(500, too_slow, NULL);\n\t} else if (event == GNT_MOUSE_UP) {\n\t\tGntTextView *view = GNT_TEXT_VIEW(widget);\n\t\tif (text_view_contains(view, select_start)) {\n\t\t\tGString *clip;\n\t\t\tselect_end = gnt_text_view_get_p(view, x - widget->priv.x, y - widget->priv.y);\n\t\t\tif (select_end < select_start) {\n\t\t\t\tgchar *t = select_start;\n\t\t\t\tselect_start = select_end;\n\t\t\t\tselect_end = t;\n\t\t\t}\n\t\t\tif (select_start == select_end) {\n\t\t\t\tif (double_click) {\n\t\t\t\t\tclip = select_word_text(view, select_start);\n\t\t\t\t\tdouble_click = FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tdouble_click = TRUE;\n\t\t\t\t\tselect_start = 0;\n\t\t\t\t\tselect_end = 0;\n\t\t\t\t\tgnt_widget_draw(widget);\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgchar *endsize = g_utf8_next_char(select_end); \n\t\t\t\tclip = g_string_new_len(select_start, endsize - select_start);\n\t\t\t}\n\t\t\tgnt_widget_draw(widget);\n\t\t\tgnt_set_clipboard_string(clip->str);\n\t\t\tg_string_free(clip, TRUE);\n\t\t}\n\t} else\n\t\treturn FALSE;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 359}
{"project": "Pidgin", "target": 0, "func": "const char *\nfinch_sound_get_active_profile()\n{\n\treturn purple_prefs_get_string(FINCH_PREFS_ROOT \"/sound/actprofile\");\n}\n", "bug_type": null, "idx": 360}
{"project": "Pidgin", "target": 0, "func": "\nstatic void display_x509_issuer(gchar *issuer_id) {\n\tPurpleCertificate *issuer_crt;\n\tissuer_crt = x509_ca_get_cert(issuer_id);\n\tif (issuer_crt) {\n\t\tpurple_certificate_display_x509(issuer_crt);\n\t\tpurple_certificate_destroy(issuer_crt);\n\t} else {\n\t\tpurple_notify_info(NULL, \n\t\t\t_(\"Certificate Information\"),\n\t\t\t\"\",\n\t\t\t_(\"Unable to find Issuer Certificate\"));\n\t}\n\tg_free(issuer_id);\n}\n", "bug_type": null, "idx": 361}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_login_connected(gpointer data, gint source, const gchar *error_message)\n{\n\tPurpleConnection *gc = data;\n\tSilcPurple sg;\n\tSilcClient client;\n\tSilcClientConnection conn;\n\tPurpleAccount *account;\n\tSilcClientConnectionParams params;\n\tSilcUInt32 mask;\n\tconst char *dfile, *tmp;\n#ifdef SILC_ATTRIBUTE_USER_ICON\n\tPurpleStoredImage *img;\n#endif\n#ifdef HAVE_SYS_UTSNAME_H\n\tstruct utsname u;\n#endif\n\tg_return_if_fail(gc != NULL);\n\tsg = gc->proto_data;\n\tif (source < 0) {\n\t\tpurple_connection_error_reason(gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t_(\"Connection failed\"));\n\t\treturn;\n\t}\n\tclient = sg->client;\n\taccount = sg->account;\n\t\n\tmemset(&params, 0, sizeof(params));\n\tdfile = silcpurple_session_file(purple_account_get_username(sg->account));\n\tparams.detach_data = (unsigned char *)silc_file_readfile(dfile, &params.detach_data_len);\n\tif (params.detach_data)\n\t\tparams.detach_data[params.detach_data_len] = 0;\n\t\n\tconn = silc_client_add_connection(\n\t\t\t  sg->client, &params,\n\t\t\t  (char *)purple_account_get_string(account, \"server\",\n\t\t\t\t\t\t\t  \"silc.silcnet.org\"),\n\t\t\t  purple_account_get_int(account, \"port\", 706), sg);\n\tif (!conn) {\n\t\tpurple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t_(\"Unable to initialize SILC Client connection\"));\n\t\tgc->proto_data = NULL;\n\t\treturn;\n\t}\n\tsg->conn = conn;\n\t\n\tif (params.detach_data) {\n\t\tpurple_connection_update_progress(gc, _(\"Resuming session\"), 2, 5);\n\t\tsg->resuming = TRUE;\n\t} else {\n\t\tpurple_connection_update_progress(gc, _(\"Performing key exchange\"), 2, 5);\n\t}\n\t\n\tsilc_client_start_key_exchange(sg->client, sg->conn, source);\n\t\n\tmask = SILC_ATTRIBUTE_MOOD_NORMAL;\n\tsilc_client_attribute_add(client, conn,\n\t\t\t\t  SILC_ATTRIBUTE_STATUS_MOOD,\n\t\t\t\t  SILC_32_TO_PTR(mask),\n\t\t\t\t  sizeof(SilcUInt32));\n\tmask = SILC_ATTRIBUTE_CONTACT_CHAT;\n\tsilc_client_attribute_add(client, conn,\n\t\t\t\t  SILC_ATTRIBUTE_PREFERRED_CONTACT,\n\t\t\t\t  SILC_32_TO_PTR(mask),\n\t\t\t\t  sizeof(SilcUInt32));\n#ifdef HAVE_SYS_UTSNAME_H\n\tif (!uname(&u)) {\n\t\tSilcAttributeObjDevice dev;\n\t\tmemset(&dev, 0, sizeof(dev));\n\t\tdev.type = SILC_ATTRIBUTE_DEVICE_COMPUTER;\n\t\tdev.version = u.release;\n\t\tdev.model = u.sysname;\n\t\tsilc_client_attribute_add(client, conn,\n\t\t\t\t\t  SILC_ATTRIBUTE_DEVICE_INFO,\n\t\t\t\t\t  (void *)&dev, sizeof(dev));\n\t}\n#endif\n#ifdef _WIN32\n\ttmp = _tzname[0];\n#else\n\ttmp = tzname[0];\n#endif\n\tsilc_client_attribute_add(client, conn,\n\t\t\t\t  SILC_ATTRIBUTE_TIMEZONE,\n\t\t\t\t  (void *)tmp, strlen(tmp));\n#ifdef SILC_ATTRIBUTE_USER_ICON\n\t\n\timg = purple_buddy_icons_find_account_icon(account);\n\tsilcpurple_buddy_set_icon(gc, img);\n\tpurple_imgstore_unref(img);\n#endif\n\tsilc_free(params.detach_data);\n}\n", "bug_type": null, "idx": 362}
{"project": "Pidgin", "target": 0, "func": "void\npurple_plugins_init(void) {\n\tvoid *handle = purple_plugins_get_handle();\n\tpurple_plugins_add_search_path(LIBDIR);\n\tpurple_signal_register(handle, \"plugin-load\",\n\t\t\t\t\t\t purple_marshal_VOID__POINTER,\n\t\t\t\t\t\t NULL, 1,\n\t\t\t\t\t\t purple_value_new(PURPLE_TYPE_SUBTYPE,\n\t\t\t\t\t\t\t\t\t\tPURPLE_SUBTYPE_PLUGIN));\n\tpurple_signal_register(handle, \"plugin-unload\",\n\t\t\t\t\t\t purple_marshal_VOID__POINTER,\n\t\t\t\t\t\t NULL, 1,\n\t\t\t\t\t\t purple_value_new(PURPLE_TYPE_SUBTYPE,\n\t\t\t\t\t\t\t\t\t\tPURPLE_SUBTYPE_PLUGIN));\n}\n", "bug_type": null, "idx": 363}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conv_im_stop_send_typed_timeout(PurpleConvIm *im)\n{\n\tg_return_if_fail(im != NULL);\n\tif (im->send_typed_timeout == 0)\n\t\treturn;\n\tpurple_timeout_remove(im->send_typed_timeout);\n\tim->send_typed_timeout = 0;\n}\n", "bug_type": null, "idx": 364}
{"project": "Pidgin", "target": 0, "func": "GSList *purple_find_buddies(PurpleAccount *account, const char *name)\n{\n\tPurpleBuddy *buddy;\n\tPurpleBlistNode *node;\n\tGSList *ret = NULL;\n\tg_return_val_if_fail(purplebuddylist != NULL, NULL);\n\tg_return_val_if_fail(account != NULL, NULL);\n\tif ((name != NULL) && (*name != '\\0')) {\n\t\tstruct _purple_hbuddy hb;\n\t\thb.name = (gchar *)purple_normalize(account, name);\n\t\thb.account = account;\n\t\tfor (node = purplebuddylist->root; node != NULL; node = node->next) {\n\t\t\tif (!node->child)\n\t\t\t\tcontinue;\n\t\t\thb.group = node;\n\t\t\tif ((buddy = g_hash_table_lookup(purplebuddylist->buddies, &hb)) != NULL)\n\t\t\t\tret = g_slist_prepend(ret, buddy);\n\t\t}\n\t} else {\n\t\tGSList *list = NULL;\n\t\tGHashTable *buddies = g_hash_table_lookup(buddies_cache, account);\n\t\tg_hash_table_foreach(buddies, find_acct_buddies, &list);\n\t\tret = list;\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 365}
{"project": "Pidgin", "target": 0, "func": "static void\nblist_node_added_cb(PurpleBlistNode *bnode, void *data)\n{\n\tconst char *name;\n\tif (PURPLE_BLIST_NODE_IS_GROUP(bnode))\n\t\tname = purple_group_get_name(PURPLE_GROUP(bnode));\n\telse if (PURPLE_BLIST_NODE_IS_CONTACT(bnode))\n\t\t\n\t\tname = purple_contact_get_alias(PURPLE_CONTACT(bnode));\n\telse if (PURPLE_BLIST_NODE_IS_BUDDY(bnode))\n\t\tname = purple_buddy_get_name(PURPLE_BUDDY(bnode));\n\telse\n\t\tname = \"(unknown)\";\n\tpurple_debug_misc(\"signals test\", \"blist_node_added_cb (%s)\\n\",\n\t                  name ? name : \"(null)\");\n}\n", "bug_type": null, "idx": 366}
{"project": "Pidgin", "target": 0, "func": "static void add_selected_row_to_list(GtkTreeModel *model, GtkTreePath *path,\n\tGtkTreeIter *iter, gpointer data)\n{\n\tGtkTreeRowReference *row_reference;\n\tGSList **list = (GSList **)data;\n\trow_reference = gtk_tree_row_reference_new(model, path);\n\t*list = g_slist_prepend(*list, row_reference);\n}\n", "bug_type": null, "idx": 367}
{"project": "Pidgin", "target": 0, "func": "JabberIq *\njingle_session_terminate_packet(JingleSession *session, const gchar *reason)\n{\n\tJabberIq *iq = jingle_session_to_packet(session,\n\t\t\tJINGLE_SESSION_TERMINATE);\n\txmlnode *jingle = xmlnode_get_child(iq->node, \"jingle\");\n\tif (reason != NULL) {\n\t\txmlnode *reason_node;\n\t\treason_node = xmlnode_new_child(jingle, \"reason\");\n\t\txmlnode_new_child(reason_node, reason);\n\t}\n\treturn iq;\n}\n", "bug_type": null, "idx": 368}
{"project": "Pidgin", "target": 0, "func": "static void _purple_blist_hbuddy_free_key(struct _purple_hbuddy *hb)\n{\n\tg_free(hb->name);\n\tg_free(hb);\n}\n", "bug_type": null, "idx": 369}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_buddy_keyagr(PurpleBlistNode *node, gpointer data)\n{\n\tPurpleBuddy *buddy;\n\tbuddy = (PurpleBuddy *)node;\n\tsilcpurple_buddy_keyagr_do(buddy->account->gc, buddy->name, FALSE);\n}\n", "bug_type": null, "idx": 370}
{"project": "Pidgin", "target": 0, "func": "gboolean jabber_pep_namespace_only_when_pep_enabled_cb(JabberStream *js, const gchar *namespace) {\n\treturn js->pep;\n}\n", "bug_type": null, "idx": 371}
{"project": "Pidgin", "target": 0, "func": "static void\n_handle_multiple_get_details_login_cb(NMUser * user, NMERR_T ret_code,\n\t\t\t\t\t\t\t\t\t  gpointer resp_data, gpointer user_data)\n{\n\tnm_response_cb cb;\n\tNMRequest *request = user_data;\n\tif (user == NULL || request == NULL)\n\t\treturn;\n\tif ((cb = nm_request_get_callback(request))) {\n\t\tcb(user, ret_code, nm_request_get_data(request),\n\t\t   nm_request_get_user_define(request));\n\t\tnm_release_request(request);\n\t}\n}\n", "bug_type": null, "idx": 372}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_menu_tray_get_property(GObject *obj, guint param_id, GValue *value,\n\t\t\t\t\t\t\t\tGParamSpec *pspec)\n{\n\tPidginMenuTray *menu_tray = PIDGIN_MENU_TRAY(obj);\n\tswitch(param_id) {\n\t\tcase PROP_BOX:\n\t\t\tg_value_set_object(value, pidgin_menu_tray_get_box(menu_tray));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID(obj, param_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 373}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_presence_get_chat_user(const PurplePresence *presence)\n{\n\tg_return_val_if_fail(presence != NULL, NULL);\n\tg_return_val_if_fail(purple_presence_get_context(presence) ==\n\t\t\tPURPLE_PRESENCE_CONTEXT_CONV, NULL);\n\treturn presence->u.chat.user;\n}\n", "bug_type": null, "idx": 374}
{"project": "Pidgin", "target": 0, "func": "static gpointer\ng_hash_table_find(GHashTable * table, GHRFunc func, gpointer data)\n{\n\ttable_find_data.data = data;\n\ttable_find_data.value = NULL;\n\tg_hash_table_foreach(table, table_find_helper, func);\n\treturn table_find_data.value;\n}\n", "bug_type": null, "idx": 375}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npurple_theme_manager_is_theme(gchar *key,\n\t\tgpointer value,\n\t\tgchar *user_data)\n{\n\treturn PURPLE_IS_THEME(value);\n}\n", "bug_type": null, "idx": 376}
{"project": "Pidgin", "target": 0, "func": "static Tcl_Obj *new_cb_namespace (void);\nvoid tcl_signal_init()\n{\n\ttcl_callbacks = NULL;\n}\n", "bug_type": null, "idx": 377}
{"project": "Pidgin", "target": 0, "func": " */\nint aim_ssi_modend(OscarData *od)\n{\n\tFlapConnection *conn;\n\tif (!od || !(conn = flap_connection_findbygroup(od, SNAC_FAMILY_FEEDBAG)))\n\t\treturn -EINVAL;\n\taim_genericreq_n(od, conn, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_EDITSTOP);\n\treturn 0;\n}\n", "bug_type": null, "idx": 378}
{"project": "Pidgin", "target": 0, "func": "static void\ninvite_user_to_chat(gpointer data, PurpleRequestFields *fields)\n{\n\tPurpleConversation *conv;\n\tPurpleConvChat *chat;\n\tconst char *user, *message;\n\tconv = data;\n\tchat = PURPLE_CONV_CHAT(conv);\n\tuser = purple_request_fields_get_string(fields, \"screenname\");\n\tmessage = purple_request_fields_get_string(fields, \"message\");\n\tserv_chat_invite(purple_conversation_get_gc(conv), chat->id, message, user);\n}\n", "bug_type": null, "idx": 379}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int receiveauthgrant(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tint ret = 0;\n\taim_rxcallback_t userfunc;\n\tguint16 tmp;\n\tchar *bn, *msg, *tmpstr;\n\t\n\ttmp = byte_stream_get8(bs);\n\tif (!tmp) {\n\t\tpurple_debug_warning(\"oscar\", \"Dropping auth grant SNAC \"\n\t\t\t\t\"because username was empty\\n\");\n\t\treturn 0;\n\t}\n\tbn = byte_stream_getstr(bs, tmp);\n\tif (!g_utf8_validate(bn, -1, NULL)) {\n\t\tpurple_debug_warning(\"oscar\", \"Dropping auth grant SNAC \"\n\t\t\t\t\"because the username was not valid UTF-8\\n\");\n\t\tg_free(bn);\n\t}\n\t\n\ttmp = byte_stream_get16(bs);\n\tif (tmp) {\n\t\tmsg = byte_stream_getstr(bs, tmp);\n\t\tif (!g_utf8_validate(msg, -1, NULL)) {\n\t\t\t\n\t\t\tpurple_debug_warning(\"oscar\", \"Got non-UTF8 message in auth \"\n\t\t\t\t\t\"grant from %s\\n\", bn);\n\t\t\ttmpstr = purple_utf8_salvage(msg);\n\t\t\tg_free(msg);\n\t\t\tmsg = tmpstr;\n\t\t}\n\t} else\n\t\tmsg = NULL;\n\t\n\ttmp = byte_stream_get16(bs);\n\tif ((userfunc = aim_callhandler(od, snac->family, snac->subtype)))\n\t\tret = userfunc(od, conn, frame, bn, msg);\n\tg_free(bn);\n\tg_free(msg);\n\treturn ret;\n}\n", "bug_type": null, "idx": 380}
{"project": "Pidgin", "target": 0, "func": "static void pidgin_whiteboard_create(PurpleWhiteboard *wb)\n{\n\tPurpleBuddy *buddy;\n\tGtkWidget *window;\n\tGtkWidget *drawing_area;\n\tGtkWidget *vbox_controls;\n\tGtkWidget *hbox_canvas_and_controls;\n\t\n\tGtkWidget *clear_button;\n\tGtkWidget *save_button;\n\tGtkWidget *color_button;\n\tPidginWhiteboard *gtkwb = g_new0(PidginWhiteboard, 1);\n\tgtkwb->wb = wb;\n\twb->ui_data = gtkwb;\n\t\n\tif (!purple_whiteboard_get_dimensions(wb, &gtkwb->width, &gtkwb->height))\n\t{\n\t\t\n\t\tgtkwb->width = 300;\n\t\tgtkwb->height = 250;\n\t}\n\tif (!purple_whiteboard_get_brush(wb, &gtkwb->brush_size, &gtkwb->brush_color))\n\t{\n\t\t\n\t\tgtkwb->brush_size = 2;\n\t\tgtkwb->brush_color = 0xff0000;\n\t}\n\t\n\tbuddy = purple_find_buddy(wb->account, wb->who);\n\twindow = pidgin_create_window(buddy != NULL ? purple_buddy_get_contact_alias(buddy) : wb->who, 0, NULL, FALSE);\n\tgtkwb->window = window;\n\tgtk_widget_set_name(window, wb->who);\n\tg_signal_connect(G_OBJECT(window), \"delete_event\",\n\t\t\t\t\t G_CALLBACK(whiteboard_close_cb), gtkwb);\n#if 0\n\tint i;\n\tGtkWidget *hbox_palette;\n\tGtkWidget *vbox_palette_above_canvas_and_controls;\n\tGtkWidget *palette_color_box[PALETTE_NUM_COLORS];\n\t\n\tvbox_palette_above_canvas_and_controls = gtk_vbox_new(FALSE, 0);\n\tgtk_container_add(GTK_CONTAINER(window), vbox_palette_above_canvas_and_controls);\n\tgtk_widget_show(vbox_palette_above_canvas_and_controls);\n\t\n\thbox_palette = gtk_hbox_new(FALSE, 0);\n\tgtk_box_pack_start(GTK_BOX(vbox_palette_above_canvas_and_controls),\n\t\t\thbox_palette, FALSE, FALSE, PIDGIN_HIG_BORDER);\n\tgtk_widget_show(hbox_palette);\n\t\n\thbox_canvas_and_controls = gtk_hbox_new(FALSE, 0);\n\tgtk_box_pack_start(GTK_BOX(vbox_palette_above_canvas_and_controls),\n\t\t\thbox_canvas_and_controls, FALSE, FALSE, PIDGIN_HIG_BORDER);\n\tgtk_widget_show(hbox_canvas_and_controls);\n\tfor(i = 0; i < PALETTE_NUM_COLORS; i++)\n\t{\n\t\tpalette_color_box[i] = gtk_image_new_from_pixbuf(NULL);\n\t\tgtk_widget_set_size_request(palette_color_box[i], gtkwb->width / PALETTE_NUM_COLORS ,32);\n\t\tgtk_container_add(GTK_CONTAINER(hbox_palette), palette_color_box[i]);\n\t\tgtk_widget_show(palette_color_box[i]);\n\t}\n#endif\n\thbox_canvas_and_controls = gtk_hbox_new(FALSE, 0);\n\tgtk_widget_show(hbox_canvas_and_controls);\n\tgtk_container_add(GTK_CONTAINER(window), hbox_canvas_and_controls);\n\tgtk_container_set_border_width(GTK_CONTAINER(window), PIDGIN_HIG_BORDER);\n\t\n\tdrawing_area = gtk_drawing_area_new();\n\tgtkwb->drawing_area = drawing_area;\n\tgtk_widget_set_size_request(GTK_WIDGET(drawing_area), gtkwb->width, gtkwb->height);\n\tgtk_box_pack_start(GTK_BOX(hbox_canvas_and_controls), drawing_area, TRUE, TRUE, PIDGIN_HIG_BOX_SPACE);\n\tgtk_widget_show(drawing_area);\n\t\n\tg_signal_connect(G_OBJECT(drawing_area), \"expose_event\",\n\t\t\t\t\t G_CALLBACK(pidgin_whiteboard_expose_event), gtkwb);\n\tg_signal_connect(G_OBJECT(drawing_area), \"configure_event\",\n\t\t\t\t\t G_CALLBACK(pidgin_whiteboard_configure_event), gtkwb);\n\t\n\tg_signal_connect(G_OBJECT(drawing_area), \"button_press_event\",\n\t\t\t\t\t G_CALLBACK(pidgin_whiteboard_brush_down), gtkwb);\n\tg_signal_connect(G_OBJECT(drawing_area), \"motion_notify_event\",\n\t\t\t\t\t G_CALLBACK(pidgin_whiteboard_brush_motion), gtkwb);\n\tg_signal_connect(G_OBJECT(drawing_area), \"button_release_event\",\n\t\t\t\t\t G_CALLBACK(pidgin_whiteboard_brush_up), gtkwb);\n\tgtk_widget_set_events(drawing_area,\n\t\t\t\t\t\t  GDK_EXPOSURE_MASK |\n\t\t\t\t\t\t  GDK_LEAVE_NOTIFY_MASK |\n\t\t\t\t\t\t  GDK_BUTTON_PRESS_MASK |\n\t\t\t\t\t\t  GDK_POINTER_MOTION_MASK |\n\t\t\t\t\t\t  GDK_BUTTON_RELEASE_MASK |\n\t\t\t\t\t\t  GDK_POINTER_MOTION_HINT_MASK);\n\t\n\tvbox_controls = gtk_vbox_new(FALSE, 0);\n\tgtk_box_pack_start(GTK_BOX(hbox_canvas_and_controls),\n\t\t\t\t\tvbox_controls, FALSE, FALSE, PIDGIN_HIG_BOX_SPACE);\n\tgtk_widget_show(vbox_controls);\n\t\n\tclear_button = gtk_button_new_from_stock(GTK_STOCK_CLEAR);\n\tgtk_box_pack_start(GTK_BOX(vbox_controls), clear_button, FALSE, FALSE, PIDGIN_HIG_BOX_SPACE);\n\tgtk_widget_show(clear_button);\n\tg_signal_connect(G_OBJECT(clear_button), \"clicked\",\n\t\t\t\t\t G_CALLBACK(pidgin_whiteboard_button_clear_press), gtkwb);\n\t\n\tsave_button = gtk_button_new_from_stock(GTK_STOCK_SAVE);\n\tgtk_box_pack_start(GTK_BOX(vbox_controls), save_button, FALSE, FALSE, PIDGIN_HIG_BOX_SPACE);\n\tgtk_widget_show(save_button);\n\tg_signal_connect(G_OBJECT(save_button), \"clicked\",\n\t\t\t\t\t G_CALLBACK(pidgin_whiteboard_button_save_press), gtkwb);\n\t\n\tcolor_button = gtk_button_new_from_stock(GTK_STOCK_SELECT_COLOR);\n\tgtk_box_pack_start(GTK_BOX(vbox_controls), color_button, FALSE, FALSE, PIDGIN_HIG_BOX_SPACE);\n\tgtk_widget_show(color_button);\n\tg_signal_connect(G_OBJECT(color_button), \"clicked\",\n\t\t\t\t\t G_CALLBACK(color_select_dialog), gtkwb);\n\t\n\tgtk_widget_show(window);\n\tpidgin_whiteboard_set_canvas_as_icon(gtkwb);\n\t\n\t\n\t\n}\n", "bug_type": null, "idx": 381}
{"project": "Pidgin", "target": 0, "func": "static void gg_get_avatar_url_cb(PurpleUtilFetchUrlData *url_data, gpointer user_data,\n               const gchar *url_text, size_t len, const gchar *error_message) {\n\tstruct gg_fetch_avatar_data *data;\n\tPurpleConnection *gc = user_data;\n\tPurpleAccount *account;\n\tPurpleBuddy *buddy;\n\tconst char *uin;\n\tconst char *is_blank;\n\tconst char *checksum;\n\tgchar *bigavatar = NULL;\n\txmlnode *xml = NULL;\n\txmlnode *xmlnode_users;\n\txmlnode *xmlnode_user;\n\txmlnode *xmlnode_avatars;\n\txmlnode *xmlnode_avatar;\n\txmlnode *xmlnode_bigavatar;\n\tg_return_if_fail(PURPLE_CONNECTION_IS_VALID(gc));\n\taccount = purple_connection_get_account(gc);\n\tif (error_message != NULL)\n\t\tpurple_debug_error(\"gg\", \"gg_get_avatars_cb error: %s\\n\", error_message);\n\telse if (len > 0 && url_text && *url_text) {\n\t\txml = xmlnode_from_str(url_text, -1);\n\t\tif (xml == NULL)\n\t\t\tgoto out;\n\t\txmlnode_users = xmlnode_get_child(xml, \"users\");\n\t\tif (xmlnode_users == NULL)\n\t\t\tgoto out;\n\t\txmlnode_user = xmlnode_get_child(xmlnode_users, \"user\");\n\t\tif (xmlnode_user == NULL)\n\t\t\tgoto out;\n\t\tuin = xmlnode_get_attrib(xmlnode_user, \"uin\");\n\t\txmlnode_avatars = xmlnode_get_child(xmlnode_user, \"avatars\");\n\t\tif (xmlnode_avatars == NULL)\n\t\t\tgoto out;\n\t\txmlnode_avatar = xmlnode_get_child(xmlnode_avatars, \"avatar\");\n\t\tif (xmlnode_avatar == NULL)\n\t\t\tgoto out;\n\t\txmlnode_bigavatar = xmlnode_get_child(xmlnode_avatar, \"originBigAvatar\");\n\t\tif (xmlnode_bigavatar == NULL)\n\t\t\tgoto out;\n\t\tis_blank = xmlnode_get_attrib(xmlnode_avatar, \"blank\");\n\t\tbigavatar = xmlnode_get_data(xmlnode_bigavatar);\n\t\tpurple_debug_info(\"gg\", \"gg_get_avatar_url_cb: UIN %s, IS_BLANK %s, \"\n\t\t                        \"URL %s\\n\",\n\t\t                  uin ? uin : \"(null)\", is_blank ? is_blank : \"(null)\",\n\t\t                  bigavatar ? bigavatar : \"(null)\");\n\t\tif (uin != NULL && bigavatar != NULL) {\n\t\t\tbuddy = purple_find_buddy(account, uin);\n\t\t\tif (buddy == NULL)\n\t\t\t\tgoto out;\n\t\t\tchecksum = purple_buddy_icons_get_checksum_for_user(buddy);\n\t\t\tif (purple_strequal(is_blank, \"1\")) {\n\t\t\t\tpurple_buddy_icons_set_for_user(account,\n\t\t\t\t\t\tpurple_buddy_get_name(buddy), NULL, 0, NULL);\n\t\t\t} else if (!purple_strequal(checksum, bigavatar)) {\n\t\t\t\tdata = g_new0(struct gg_fetch_avatar_data, 1);\n\t\t\t\tdata->gc = gc;\n\t\t\t\tdata->uin = g_strdup(uin);\n\t\t\t\tdata->avatar_url = g_strdup(bigavatar);\n\t\t\t\tpurple_debug_info(\"gg\", \"gg_get_avatar_url_cb: \"\n\t\t\t\t\t\"requesting avatar for %s\\n\", uin);\n\t\t\t\turl_data = purple_util_fetch_url_request_len_with_account(account,\n\t\t\t\t\t\tbigavatar, TRUE, \"Mozilla/4.0 (compatible; MSIE 5.0)\",\n\t\t\t\t\t\tFALSE, NULL, FALSE, -1, gg_fetch_avatar_cb, data);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (xml)\n\t\txmlnode_free(xml);\n\tg_free(bigavatar);\n}\n", "bug_type": null, "idx": 382}
{"project": "Pidgin", "target": 0, "func": "static protobuf_c_boolean\ncount_packed_elements(ProtobufCType type,\n\t\t      size_t len, const uint8_t *data, size_t *count_out)\n{\n\tswitch (type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tif (len % 4 != 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"length must be a multiple of 4 for fixed-length 32-bit types\");\n\t\t\treturn FALSE;\n\t\t}\n\t\t*count_out = len / 4;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tif (len % 8 != 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"length must be a multiple of 8 for fixed-length 64-bit types\");\n\t\t\treturn FALSE;\n\t\t}\n\t\t*count_out = len / 8;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_INT32:\n\tcase PROTOBUF_C_TYPE_SINT32:\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_UINT32:\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_SINT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\t*count_out = max_b128_numbers(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\t*count_out = len;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_STRING:\n\tcase PROTOBUF_C_TYPE_BYTES:\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\tdefault:\n\t\tPROTOBUF_C_UNPACK_ERROR(\"bad protobuf-c type %u for packed-repeated\", type);\n\t\treturn FALSE;\n\t}\n}\n", "bug_type": null, "idx": 383}
{"project": "Pidgin", "target": 0, "func": "static void\nstroke_next_tab(GtkWidget *widget, void *data)\n{\n\tPurpleConversation *conv;\n\tPidginWindow *win;\n\tconv  = (PurpleConversation *)data;\n\twin   = PIDGIN_CONVERSATION(conv)->win;\n\tswitch_page(win, GTK_DIR_RIGHT);\n}\n", "bug_type": null, "idx": 384}
{"project": "Pidgin", "target": 0, "func": "xmlnode *\nxmlnode_get_child_with_namespace(const xmlnode *parent, const char *name, const char *ns)\n{\n\txmlnode *x, *ret = NULL;\n\tchar **names;\n\tchar *parent_name, *child_name;\n\tg_return_val_if_fail(parent != NULL, NULL);\n\tg_return_val_if_fail(name != NULL, NULL);\n\tnames = g_strsplit(name, \"/\", 2);\n\tparent_name = names[0];\n\tchild_name = names[1];\n\tfor(x = parent->child; x; x = x->next) {\n\t\t\n\t\tconst char *xmlns = NULL;\n\t\tif(ns)\n\t\t\txmlns = xmlnode_get_namespace(x);\n\t\tif(x->type == XMLNODE_TYPE_TAG && purple_strequal(parent_name, x->name)\n\t\t\t\t&& purple_strequal(ns, xmlns)) {\n\t\t\tret = x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(child_name && ret)\n\t\tret = xmlnode_get_child(ret, child_name);\n\tg_strfreev(names);\n\treturn ret;\n}\n", "bug_type": null, "idx": 385}
{"project": "Pidgin", "target": 0, "func": "static void\nnotify_warn_cb(PurplePluginAction *action)\n{\n\tpurple_notify_warning(notify_example, \"Test Notification\", \"Test Notification\",\n\t\t\"This is a test warning notification\");\n}\n", "bug_type": null, "idx": 386}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_buddy_icons_get_checksum_for_user(PurpleBuddy *buddy)\n{\n\treturn purple_blist_node_get_string((PurpleBlistNode*)buddy,\n\t                                    \"icon_checksum\");\n}\n", "bug_type": null, "idx": 387}
{"project": "Pidgin", "target": 0, "func": "int\naim_srv_setextrainfo(OscarData *od,\n\t\tgboolean seticqstatus, guint32 icqstatus,\n\t\tgboolean setstatusmsg, const char *statusmsg, const char *itmsurl)\n{\n\tFlapConnection *conn;\n\tByteStream bs;\n\taim_snacid_t snacid;\n\tGSList *tlvlist = NULL;\n\tif (!od || !(conn = flap_connection_findbygroup(od, SNAC_FAMILY_ICBM)))\n\t\treturn -EINVAL;\n\tif (seticqstatus)\n\t{\n\t\taim_tlvlist_add_32(&tlvlist, 0x0006, icqstatus |\n\t\t\t\tAIM_ICQ_STATE_HIDEIP | AIM_ICQ_STATE_DIRECTREQUIREAUTH);\n\t}\n\tif (setstatusmsg)\n\t{\n\t\tsize_t statusmsglen, itmsurllen;\n\t\tByteStream tmpbs;\n\t\tstatusmsglen = (statusmsg != NULL) ? strlen(statusmsg) : 0;\n\t\titmsurllen = (itmsurl != NULL) ? strlen(itmsurl) : 0;\n\t\tbyte_stream_new(&tmpbs, statusmsglen + 8 + itmsurllen + 8);\n\t\tbyte_stream_put_bart_asset_str(&tmpbs, 0x0002, statusmsg);\n\t\tbyte_stream_put_bart_asset_str(&tmpbs, 0x0009, itmsurl);\n\t\taim_tlvlist_add_raw(&tlvlist, 0x001d,\n\t\t\t\tbyte_stream_curpos(&tmpbs), tmpbs.data);\n\t\tbyte_stream_destroy(&tmpbs);\n\t}\n\tbyte_stream_new(&bs, aim_tlvlist_size(tlvlist));\n\taim_tlvlist_write(&bs, &tlvlist);\n\taim_tlvlist_free(tlvlist);\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_OSERVICE, 0x001e, 0x0000, NULL, 0);\n\tflap_connection_send_snac(od, conn, SNAC_FAMILY_OSERVICE, 0x001e, snacid, &bs);\n\tbyte_stream_destroy(&bs);\n\treturn 0;\n}\n", "bug_type": null, "idx": 388}
{"project": "Pidgin", "target": 0, "func": "static void\noscar_chat_kill(PurpleConnection *gc, struct chat_connection *cc)\n{\n\tOscarData *od = purple_connection_get_protocol_data(gc);\n\t\n\tserv_got_chat_left(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(cc->conv)));\n\t\n\tod->oscar_chats = g_slist_remove(od->oscar_chats, cc);\n\toscar_chat_destroy(cc);\n}\n", "bug_type": null, "idx": 389}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_set_remember_password(PurpleAccount *account, gboolean value)\n{\n\tg_return_if_fail(account != NULL);\n\taccount->remember_pass = value;\n\tschedule_accounts_save();\n}\n", "bug_type": null, "idx": 390}
{"project": "Pidgin", "target": 0, "func": "int serv_send_im(PurpleConnection *gc, const char *name, const char *message,\n\t\t\t\t PurpleMessageFlags flags)\n{\n\tPurpleConversation *conv = NULL;\n\tPurpleAccount *account = NULL;\n\tPurplePresence *presence = NULL;\n\tPurplePlugin *prpl = NULL;\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tint val = -EINVAL;\n\tconst gchar *auto_reply_pref = NULL;\n\tg_return_val_if_fail(gc != NULL, val);\n\tprpl = purple_connection_get_prpl(gc);\n\tg_return_val_if_fail(prpl != NULL, val);\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\taccount  = purple_connection_get_account(gc);\n\tpresence = purple_account_get_presence(account);\n\tconv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, name, account);\n\tif (prpl_info->send_im)\n\t\tval = prpl_info->send_im(gc, name, message, flags);\n\t\n\tauto_reply_pref = purple_prefs_get_string(\"/purple/away/auto_reply\");\n\tif((gc->flags & PURPLE_CONNECTION_AUTO_RESP) &&\n\t\t\t!purple_presence_is_available(presence) &&\n\t\t\t!purple_strequal(auto_reply_pref, \"never\")) {\n\t\tstruct last_auto_response *lar;\n\t\tlar = get_last_auto_response(gc, name);\n\t\tlar->sent = time(NULL);\n\t}\n\tif(conv && purple_conv_im_get_send_typed_timeout(PURPLE_CONV_IM(conv)))\n\t\tpurple_conv_im_stop_send_typed_timeout(PURPLE_CONV_IM(conv));\n\treturn val;\n}\n", "bug_type": null, "idx": 391}
{"project": "Pidgin", "target": 0, "func": "static void\njingle_handle_session_terminate(JingleSession *session, xmlnode *jingle)\n{\n\tjabber_iq_send(jingle_session_create_ack(session, jingle));\n\tjingle_session_handle_action(session, jingle,\n\t\t\tJINGLE_SESSION_TERMINATE);\n\t\n\tg_object_unref(session);\n}\n", "bug_type": null, "idx": 392}
{"project": "Pidgin", "target": 0, "func": "size_t gg110_options__pack_to_buffer\n                     (const GG110Options *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &gg110_options__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\n", "bug_type": null, "idx": 393}
{"project": "Pidgin", "target": 0, "func": "unsigned long\npurple_value_get_ulong(const PurpleValue *value)\n{\n\tg_return_val_if_fail(value != NULL, 0);\n\treturn value->data.long_data;\n}\n", "bug_type": null, "idx": 394}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_menu_destroy(GntWidget *widget)\n{\n\tGntMenu *menu = GNT_MENU(widget);\n\tg_list_foreach(menu->list, (GFunc)g_object_unref, NULL);\n\tg_list_free(menu->list);\n\torg_destroy(widget);\n}\n", "bug_type": null, "idx": 395}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_xfer_destroy(PurpleXfer *xfer)\n{\n\tPurpleGntXferUiData *data;\n\tdata = FINCHXFER(xfer);\n\tif (data) {\n\t\tg_free(data->name);\n\t\tg_free(data);\n\t\tFINCH_SET_DATA(xfer, NULL);\n\t}\n}\n", "bug_type": null, "idx": 396}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_connection_connected(PurpleConnection *gc)\n{\n\tPurpleAccount *account;\n\tPidginBuddyList *gtkblist;\n\taccount  = purple_connection_get_account(gc);\n\tgtkblist = pidgin_blist_get_default_gtk_blist();\n\tif (gtkblist != NULL)\n\t\tpidgin_status_box_set_connecting(PIDGIN_STATUS_BOX(gtkblist->statusbox),\n\t\t\t\t\t   (purple_connections_get_connecting() != NULL));\n\tg_hash_table_remove(auto_reconns, account);\n}\n", "bug_type": null, "idx": 397}
{"project": "Pidgin", "target": 0, "func": "\nstatic void add_gtkimhtml_to_list(GtkIMHtmlSmiley *gtksmiley)\n{\n\tgtk_smileys = g_slist_prepend(gtk_smileys, gtksmiley);\n\tpurple_debug_info(\"gtksmiley\", \"adding %s to gtk_smileys\\n\", gtksmiley->smile);\n}\n", "bug_type": null, "idx": 398}
{"project": "Pidgin", "target": 0, "func": "static void\nlist_field_select_changed_cb(GtkTreeSelection *sel, PurpleRequestField *field)\n{\n\tpurple_request_field_list_clear_selected(field);\n\tgtk_tree_selection_selected_foreach(sel, select_field_list_item, field);\n}\n", "bug_type": null, "idx": 399}
{"project": "Pidgin", "target": 0, "func": "GtkWidget *\npidgin_prefs_labeled_password(GtkWidget *page, const gchar *title,\n\t\t\t\t\t\t\t const char *key, GtkSizeGroup *sg)\n{\n\tGtkWidget *entry;\n\tconst gchar *value;\n\tvalue = purple_prefs_get_string(key);\n\tentry = gtk_entry_new();\n\tgtk_entry_set_visibility(GTK_ENTRY(entry), FALSE);\n\tgtk_entry_set_text(GTK_ENTRY(entry), value);\n\tg_signal_connect(G_OBJECT(entry), \"changed\",\n\t\t\t\t\t G_CALLBACK(entry_set), (char*)key);\n\tgtk_widget_show(entry);\n\treturn pidgin_add_widget_to_vbox(GTK_BOX(page), title, sg, entry, TRUE, NULL);\n}\n", "bug_type": null, "idx": 400}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_smileys_load(void)\n{\n\txmlnode *root_node, *profile_node;\n\txmlnode *smileyset_node = NULL;\n\txmlnode *smiley_node;\n\tsmileys_loaded = TRUE;\n\troot_node = purple_util_read_xml_from_file(XML_FILE_NAME,\n\t\t\t_(SMILEYS_LOG_ID));\n\tif (root_node == NULL)\n\t\treturn;\n\t\n\tprofile_node = xmlnode_get_child(root_node, XML_PROFILE_TAG);\n\tif (profile_node)\n\t\tsmileyset_node = xmlnode_get_child(profile_node, XML_SMILEY_SET_TAG);\n\tif (smileyset_node) {\n\t\tsmiley_node = xmlnode_get_child(smileyset_node, XML_SMILEY_TAG);\n\t\tfor (; smiley_node != NULL;\n\t\t\t\tsmiley_node = xmlnode_get_next_twin(smiley_node)) {\n\t\t\tparse_smiley(smiley_node);\n\t\t}\n\t}\n\txmlnode_free(root_node);\n}\n", "bug_type": null, "idx": 401}
{"project": "Pidgin", "target": 1, "func": " static void mxit_cb_http_read( gpointer user_data, gint source, PurpleInputCondition cond )\n{\n\tstruct MXitSession*\tsession\t\t= (struct MXitSession*) user_data;\n\tchar\t\t\t\tbuf[256];\n\tint\t\t\t\t\tbuflen;\n\tchar*\t\t\t\tbody;\n\tint\t\t\t\t\tbodylen;\n\tchar*\t\t\t\tch;\n\tint\t\t\t\t\tlen;\n\tchar*\t\t\t\ttmp;\n\tint\t\t\t\t\tres;\n\tchar*\t\t\t\tnext;\n\tpurple_debug_info( MXIT_PLUGIN_ID, \"mxit_cb_http_read\\n\" );\n\tif ( session->rx_state == RX_STATE_RLEN ) {\n\t\t\n\t\t\n\t\tmemcpy( buf, session->rx_dbuf, session->rx_i );\n\t\tbuflen = session->rx_i;\n\t\t\n\t\tlen = read( session->fd, buf + buflen, sizeof( buf ) - ( buflen + 1 ) );\n\t\tif ( len <= 0 ) {\n\t\t\t\n\t\t\tgoto done;\n\t\t}\n\t\tbuf[buflen+len] = '\\0';\n//nextpacket:\n#ifdef\tDEBUG_HTTP\n\t\tpurple_debug_info( MXIT_PLUGIN_ID, \"HTTP POST READ 1: (%i)\\n\", len );\n\t\tdump_bytes( session, buf + buflen, len );\n#endif\n\t\t\n\t\tch = strstr( buf, HTTP_11_SEPERATOR );\n\t\tif ( !ch ) {\n\t\t\t\n\t\t\tsession->rx_i = buflen + len;\n\t\t\tmemcpy( session->rx_dbuf, buf, session->rx_i );\n\t\t\treturn;\n\t\t}\n\t\tbuflen += len;\n\t\t\n\t\tch += strlen( HTTP_11_SEPERATOR );\n\t\t*(ch - 1) = '\\0';\n\t\tbody = ch;\n\t\tres = buflen - ( ch - buf );\n\t\tif ( res > 0 ) {\n\t\t\t\n\t\t\tmemcpy( session->rx_dbuf, ch, res );\n\t\t\tsession->rx_i = res;\n\t\t}\n\t\telse {\n\t\t\tsession->rx_i = 0;\n\t\t}\n\t\t\n\t\tif ( ( strncmp( buf, HTTP_11_200_OK, strlen( HTTP_11_200_OK ) ) != 0 ) && ( strncmp( buf, HTTP_11_100_CONT, strlen( HTTP_11_100_CONT ) ) != 0 ) ) {\n\t\t\t\n\t\t\tpurple_debug_error( MXIT_PLUGIN_ID, \"HTTP error: %s\\n\", ch );\n\t\t\tgoto done;\n\t\t}\n\t\t\n\t\tch = (char*) purple_strcasestr( buf, HTTP_CONTENT_LEN );\n\t\tif ( !ch ) {\n\t\t\t\n\t\t\tpurple_debug_error( MXIT_PLUGIN_ID, \"HTTP reply received without content-length header (ignoring packet)\\n\" );\n\t\t\tgoto done;\n\t\t}\n\t\t\n\t\tch += strlen( HTTP_CONTENT_LEN );\n\t\ttmp = strchr( ch, '\\r' );\n\t\tif ( !tmp ) {\n\t\t\tpurple_debug_error( MXIT_PLUGIN_ID, \"Received bad HTTP reply packet (ignoring packet)\\n\" );\n\t\t\tgoto done;\n\t\t}\n\t\ttmp = g_strndup( ch, tmp - ch );\n\t\tbodylen = atoi( tmp );\n\t\tg_free( tmp );\n\t\ttmp = NULL;\n\t\tif ( buflen + bodylen >= CP_MAX_PACKET ) {\n\t\t\t\n\t\t\tgoto done;\n\t\t}\n\t\telse if ( buflen > ( ( body - buf ) + bodylen ) ) {\n\t\t\t\n\t\t\tnext = body + bodylen;\n\t\t\tsession->rx_res = 0;\n\t\t}\n\t\telse {\n\t\t\tsession->rx_res = bodylen - session->rx_i;\n\t\t}\n\t\tif ( session->rx_res == 0 ) {\n\t\t\t\n\t\t\tsession->rx_i = bodylen;\n\t\t\tsession->rx_state = RX_STATE_PROC;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tsession->rx_state = RX_STATE_DATA;\n\t\t}\n\t}\n\telse if ( session->rx_state == RX_STATE_DATA ) {\n\t\t\n\t\t\n\t\tlen = read( session->fd, &session->rx_dbuf[session->rx_i], session->rx_res );\n\t\tif ( len <= 0 ) {\n\t\t\t\n\t\t\tgoto done;\n\t\t}\n#ifdef\tDEBUG_HTTP\n\t\tpurple_debug_info( MXIT_PLUGIN_ID, \"HTTP POST READ 2: (%i)\\n\", len );\n\t\tdump_bytes( session, &session->rx_dbuf[session->rx_i], len );\n#endif\n\t\tsession->rx_i += len;\n\t\tsession->rx_res -= len;\n\t\tif ( session->rx_res == 0 ) {\n\t\t\t\n\t\t\tsession->rx_state = RX_STATE_PROC;\n\t\t}\n\t}\n\tif ( session->rx_state == RX_STATE_PROC ) {\n\t\tmxit_parse_packet( session );\n#if\t0\n\t\tif ( next ) {\n\t\t\t\n\t\t\t\n\t\t\tsession->rx_state = RX_STATE_RLEN;\n\t\t\tsession->rx_lbuf[0] = '\\0';\n\t\t\tsession->rx_i = 0;\n\t\t\tsession->rx_res = 0;\n\t\t\t\n\t\t\tlen = next - buf;\n\t\t\tbuflen = len;\n\t\t\tmemcpy( buf, next, len );\n\t\t\tgoto nextpacket;\n\t\t}\n#endif\n\t\t\n\t\tgoto done;\n\t}\n\treturn;\ndone:\n\tclose( session->fd );\n\tpurple_input_remove( session->http_handler );\n\tsession->http_handler = 0;\n}\n", "bug_type": "CVE-2016-2377", "idx": 402}
{"project": "Pidgin", "target": 0, "func": "size_t gg112_transfer_info_file__get_packed_size\n                     (const GG112TransferInfoFile *message)\n{\n  assert(message->base.descriptor == &gg112_transfer_info_file__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\n", "bug_type": null, "idx": 403}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npurple_media_backend_fs2_set_encryption_parameters (PurpleMediaBackend *self,\n\t\tconst gchar *sess_id, const gchar *cipher, const gchar *auth,\n\t\tconst gchar *key, gsize key_len)\n{\n\tPurpleMediaBackendFs2Session *session;\n\tGstStructure *srtp;\n\tGError *err = NULL;\n\tgboolean result;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_BACKEND_FS2(self), FALSE);\n\tsession = get_session(PURPLE_MEDIA_BACKEND_FS2(self), sess_id);\n\tif (!session)\n\t\treturn FALSE;\n\tsrtp = create_fs2_srtp_structure(cipher, auth, key, key_len);\n\tif (!srtp)\n\t\treturn FALSE;\n\tresult = fs_session_set_encryption_parameters(session->session, srtp,\n\t\t\t\t\t\t&err);\n\tif (!result) {\n\t\tpurple_debug_error(\"backend-fs2\",\n\t\t\t\t\"Error setting encryption parameters: %s\\n\", err->message);\n\t\tg_error_free(err);\n\t}\n\tgst_structure_free(srtp);\n\treturn result;\n}\n", "bug_type": null, "idx": 404}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_attention_type_get_unlocalized_name(const PurpleAttentionType *type)\n{\n\tg_return_val_if_fail(type != NULL, NULL);\n\treturn type->unlocalized_name;\n}\n", "bug_type": null, "idx": 405}
{"project": "Pidgin", "target": 0, "func": "GtkWidget *\npidgin_plugin_pref_create_frame(PurplePluginPrefFrame *frame) {\n\tGtkWidget *ret, *parent;\n\tGtkSizeGroup *sg;\n\tGList *pp;\n\tg_return_val_if_fail(frame, NULL);\n\tsg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);\n\tparent = ret = gtk_vbox_new(FALSE, 16);\n\tgtk_container_set_border_width(GTK_CONTAINER(ret), PIDGIN_HIG_BORDER);\n\tgtk_widget_show(ret);\n\tfor(pp = purple_plugin_pref_frame_get_prefs(frame);\n\t\tpp != NULL;\n\t\tpp = pp->next)\n\t{\n\t\tPurplePluginPref *pref = (PurplePluginPref *)pp->data;\n\t\tconst char *name = purple_plugin_pref_get_name(pref);\n\t\tconst char *label = purple_plugin_pref_get_label(pref);\n\t\tif(name == NULL) {\n\t\t\tif(label == NULL)\n\t\t\t\tcontinue;\n\t\t\tif(purple_plugin_pref_get_type(pref) == PURPLE_PLUGIN_PREF_INFO) {\n\t\t\t\tmake_info_pref(parent, pref);\n\t\t\t} else {\n\t\t\t\tparent = pidgin_make_frame(ret, label);\n\t\t\t\tgtk_widget_show(parent);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(purple_prefs_get_type(name)) {\n\t\t\tcase PURPLE_PREF_BOOLEAN:\n\t\t\t\tpidgin_prefs_checkbox(label, name, parent);\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_PREF_INT:\n\t\t\t\tmake_int_pref(parent, pref, sg);\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_PREF_STRING:\n\t\t\t\tmake_string_pref(parent, pref, sg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tg_object_unref(sg);\n\treturn ret;\n}\n", "bug_type": null, "idx": 406}
{"project": "Pidgin", "target": 0, "func": "void\nfinch_xfer_dialog_destroy()\n{\n\tgnt_widget_destroy(xfer_dialog->window);\n\tg_free(xfer_dialog);\n\txfer_dialog = NULL;\n}\n", "bug_type": null, "idx": 407}
{"project": "Pidgin", "target": 0, "func": "static void\nflap_connection_send_close(OscarData *od, FlapConnection *conn)\n{\n\tFlapFrame *frame;\n\tframe = flap_frame_new(od, 0x04, 0);\n\tflap_connection_send(conn, frame);\n}\n", "bug_type": null, "idx": 408}
{"project": "Pidgin", "target": 0, "func": "void pidgin_dialogs_translators(void)\n{\n\tGString *str;\n\tchar *tmp;\n\tstatic GtkWidget *translator_info = NULL;\n\tif (translator_info != NULL) {\n\t\tgtk_window_present(GTK_WINDOW(translator_info));\n\t\treturn;\n\t}\n\tstr = g_string_sized_new(4096);\n\t\n\tg_string_append_printf(str, \"<FONT SIZE=\\\"4\\\">%s:</FONT><BR/>\",\n\t\t\t\t\t\t   _(\"Current Translators\"));\n\tadd_translators(str, translators);\n\tg_string_append(str, \"<BR/>\");\n\t\n\tg_string_append_printf(str, \"<FONT SIZE=\\\"4\\\">%s:</FONT><BR/>\",\n\t\t\t\t\t\t   _(\"Past Translators\"));\n\tadd_translators(str, past_translators);\n\ttmp = g_strdup_printf(_(\"%s Translator Information\"), PIDGIN_NAME);\n\ttranslator_info = pidgin_build_help_dialog(tmp, \"translator_info\", str);\n\tg_signal_connect(G_OBJECT(translator_info), \"destroy\", G_CALLBACK(gtk_widget_destroyed), &translator_info);\n\tg_free(tmp);\n}\n", "bug_type": null, "idx": 409}
{"project": "Pidgin", "target": 0, "func": "void\npurple_serv_got_private_alias(PurpleConnection *gc, const char *who, const char *alias)\n{\n\tPurpleAccount *account = NULL;\n\tGSList *buddies = NULL;\n\tPurpleBuddy *b = NULL;\n\taccount = purple_connection_get_account(gc);\n\tbuddies = purple_find_buddies(account, who);\n\twhile(buddies != NULL) {\n\t\tconst char *balias;\n\t\tb = buddies->data;\n\t\tbuddies = g_slist_delete_link(buddies, buddies);\n\t\tbalias = purple_buddy_get_local_buddy_alias(b);\n\t\tif (purple_strequal(balias, alias))\n\t\t\tcontinue;\n\t\tpurple_blist_alias_buddy(b, alias);\n\t}\n}\n", "bug_type": null, "idx": 410}
{"project": "Pidgin", "target": 0, "func": "void finch_accounts_uninit()\n{\n\tif (accounts.window)\n\t\tgnt_widget_destroy(accounts.window);\n}\n", "bug_type": null, "idx": 411}
{"project": "Pidgin", "target": 0, "func": "void _mdns_delete_buddy(BonjourBuddy *buddy) {\n\tWin32BuddyImplData *idata = buddy->mdns_impl_data;\n\tg_return_if_fail(idata != NULL);\n\twhile (idata->resolvers) {\n\t\tWin32SvcResolverData *rd = idata->resolvers->data;\n\t\t_cleanup_resolver_data(rd);\n\t\tidata->resolvers = g_slist_delete_link(idata->resolvers, idata->resolvers);\n\t}\n\tif (idata->null_query != NULL) {\n\t\tpurple_input_remove(idata->null_query->input_handler);\n\t\tDNSServiceRefDeallocate(idata->null_query->sdRef);\n\t\tg_free(idata->null_query);\n\t}\n\tg_free(idata);\n\tbuddy->mdns_impl_data = NULL;\n}\n", "bug_type": null, "idx": 412}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_prefs_update_old(void)\n{\n\tconst char *str = NULL;\n\tpurple_prefs_rename(\"/gaim/gtk\", PIDGIN_PREFS_ROOT);\n\t\n\tpurple_prefs_rename(PIDGIN_PREFS_ROOT \"/logging/log_ims\", \"/purple/logging/log_ims\");\n\tpurple_prefs_rename(PIDGIN_PREFS_ROOT \"/logging/log_chats\", \"/purple/logging/log_chats\");\n\tpurple_prefs_rename(\"/purple/conversations/placement\",\n\t\t\t\t\t  PIDGIN_PREFS_ROOT \"/conversations/placement\");\n\tpurple_prefs_rename(PIDGIN_PREFS_ROOT \"/debug/timestamps\", \"/purple/debug/timestamps\");\n\tpurple_prefs_rename(PIDGIN_PREFS_ROOT \"/conversations/im/raise_on_events\", \"/plugins/gtk/X11/notify/method_raise\");\n\tpurple_prefs_rename_boolean_toggle(PIDGIN_PREFS_ROOT \"/conversations/ignore_colors\",\n\t\t\t\t\t\t\t\t\t PIDGIN_PREFS_ROOT \"/conversations/show_incoming_formatting\");\n\t\n\tif((str = purple_prefs_get_path(PIDGIN_PREFS_ROOT \"/browsers/command\")) != NULL) {\n\t\tpurple_prefs_set_string(PIDGIN_PREFS_ROOT \"/browsers/manual_command\", str);\n\t\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/browsers/command\");\n\t}\n\t\n\tpurple_prefs_rename(PIDGIN_PREFS_ROOT \"/idle/reporting_method\", \"/purple/away/idle_reporting\");\n\tif ((str = purple_prefs_get_string(\"/purple/away/idle_reporting\")) &&\n\t\t\tstrcmp(str, \"gaim\") == 0)\n\t\tpurple_prefs_set_string(\"/purple/away/idle_reporting\", \"purple\");\n\t\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/blist/auto_expand_contacts\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/blist/button_style\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/blist/grey_idle_buddies\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/blist/raise_on_events\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/blist/show_group_count\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/blist/show_warning_level\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/button_type\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/ctrl_enter_sends\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/enter_sends\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/escape_closes\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/html_shortcuts\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/icons_on_tabs\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/send_formatting\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/show_smileys\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/show_urls_as_links\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/smiley_shortcuts\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/use_custom_bgcolor\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/use_custom_fgcolor\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/use_custom_font\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/use_custom_size\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/chat/old_tab_complete\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/chat/tab_completion\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/im/hide_on_send\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/chat/color_nicks\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/chat/raise_on_events\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/ignore_fonts\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/ignore_font_sizes\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/passthrough_unknown_commands\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/idle\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/logging/individual_logs\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/sound/signon\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/sound/silent_signon\");\n\t\n\tif (purple_prefs_exists(\"/plugins/gtk/docklet/queue_messages\") &&\n\t    purple_prefs_get_bool(\"/plugins/gtk/docklet/queue_messages\"))\n\t{\n\t\tpurple_prefs_set_string(PIDGIN_PREFS_ROOT \"/conversations/im/hide_new\", \"always\");\n\t}\n\telse if (purple_prefs_exists(PIDGIN_PREFS_ROOT \"/away/queue_messages\") &&\n\t         purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/away/queue_messages\"))\n\t{\n\t\tpurple_prefs_set_string(PIDGIN_PREFS_ROOT \"/conversations/im/hide_new\", \"away\");\n\t}\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/away/queue_messages\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/away\");\n\tpurple_prefs_remove(\"/plugins/gtk/docklet/queue_messages\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/chat/default_width\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/chat/default_height\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/im/default_width\");\n\tpurple_prefs_remove(PIDGIN_PREFS_ROOT \"/conversations/im/default_height\");\n\tpurple_prefs_rename(PIDGIN_PREFS_ROOT \"/conversations/x\",\n\t\t\tPIDGIN_PREFS_ROOT \"/conversations/im/x\");\n\tpurple_prefs_rename(PIDGIN_PREFS_ROOT \"/conversations/y\",\n\t\t\tPIDGIN_PREFS_ROOT \"/conversations/im/y\");\n}\n", "bug_type": null, "idx": 413}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin) {\n}\n", "bug_type": null, "idx": 414}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_handle_recv_msg_options(struct gg_session *sess,\n\tstruct gg_event *e, uin_t sender, const char *p, const char *packet_end,\n\tuint32_t packet_type)\n{\n\twhile (p < packet_end) {\n\t\tswitch (*p) {\n\t\t\tcase GG_MSG_OPTION_CONFERENCE:\n\t\t\t{\n\t\t\t\tconst struct gg_msg_recipients *m = (const void*) p;\n\t\t\t\tuint32_t i, count;\n\t\t\t\tp += sizeof(*m);\n\t\t\t\tif (p > packet_end) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" packet out of bounds (1)\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcount = gg_fix32(m->count);\n\t\t\t\tif (p + count * sizeof(uin_t) > packet_end ||\n\t\t\t\t\tp + count * sizeof(uin_t) < p ||\n\t\t\t\t\tcount > 0xffff)\n\t\t\t\t{\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" packet out of bounds (1.5)\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tif (e->event.msg.recipients != NULL) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" e->event.msg.recipients already exist\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\te->event.msg.recipients = malloc(count * sizeof(uin_t));\n\t\t\t\tif (e->event.msg.recipients == NULL) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" not enough memory for recipients data\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tmemcpy(e->event.msg.recipients, p, count * sizeof(uin_t));\n\t\t\t\tp += count * sizeof(uin_t);\n\t\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\t\te->event.msg.recipients[i] = gg_fix32(e->event.msg.recipients[i]);\n\t\t\t\te->event.msg.recipients_count = count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase GG_MSG_OPTION_ATTRIBUTES:\n\t\t\t{\n\t\t\t\tuint16_t len;\n\t\t\t\tchar *buf;\n\t\t\t\tif (p + 3 > packet_end) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" packet out of bounds (2)\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tmemcpy(&len, p + 1, sizeof(uint16_t));\n\t\t\t\tlen = gg_fix16(len);\n\t\t\t\tif (e->event.msg.formats != NULL) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" e->event.msg.formats already exist\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tbuf = malloc(len);\n\t\t\t\tif (buf == NULL) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" not enough memory for richtext data\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tp += 3;\n\t\t\t\tif (p + len > packet_end) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" packet out of bounds (3)\\n\");\n\t\t\t\t\tfree(buf);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tmemcpy(buf, p, len);\n\t\t\t\te->event.msg.formats = buf;\n\t\t\t\te->event.msg.formats_length = len;\n\t\t\t\tp += len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase GG_MSG_OPTION_IMAGE_REQUEST:\n\t\t\t{\n\t\t\t\tconst struct gg_msg_image_request *i = (const void*) p;\n\t\t\t\tif (p + sizeof(*i) > packet_end) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg() \"\n\t\t\t\t\t\t\"packet out of bounds (3)\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tif (e->event.msg.formats != NULL || e->event.msg.recipients != NULL) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options()\"\n\t\t\t\t\t\t\" mixed options (1)\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\te->event.image_request.sender = sender;\n\t\t\t\te->event.image_request.size = gg_fix32(i->size);\n\t\t\t\te->event.image_request.crc32 = gg_fix32(i->crc32);\n\t\t\t\te->type = GG_EVENT_IMAGE_REQUEST;\n\t\t\t\tgoto handled;\n\t\t\t}\n\t\t\tcase GG_MSG_OPTION_IMAGE_REPLY:\n\t\t\tcase GG_MSG_OPTION_IMAGE_REPLY_MORE:\n\t\t\t{\n\t\t\t\tstruct gg_msg_image_reply *rep = (void*) p;\n\t\t\t\tif (e->event.msg.formats != NULL || e->event.msg.recipients != NULL) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg_options() \"\n\t\t\t\t\t\t\"mixed options (2)\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tif (p + sizeof(struct gg_msg_image_reply) == packet_end) {\n\t\t\t\t\t\n\t\t\t\t\te->type = GG_EVENT_IMAGE_REPLY;\n\t\t\t\t\te->event.image_reply.sender = sender;\n\t\t\t\t\te->event.image_reply.size = 0;\n\t\t\t\t\te->event.image_reply.crc32 = gg_fix32(rep->crc32);\n\t\t\t\t\te->event.image_reply.filename = NULL;\n\t\t\t\t\te->event.image_reply.image = NULL;\n\t\t\t\t\tgoto handled;\n\t\t\t\t} else if (p + sizeof(struct gg_msg_image_reply) + 1 > packet_end) {\n\t\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\t\"// gg_handle_recv_msg() \"\n\t\t\t\t\t\t\"packet out of bounds (4)\\n\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\trep->size = gg_fix32(rep->size);\n\t\t\t\trep->crc32 = gg_fix32(rep->crc32);\n\t\t\t\tgg_image_queue_parse(e, p, (unsigned int)(packet_end - p), sess, sender, packet_type);\n\t\t\t\tgoto handled;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\t\"// gg_handle_recv_msg() \"\n\t\t\t\t\t\"unknown payload 0x%.2x\\n\", *p);\n\t\t\t\tp = packet_end;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\nhandled:\n\treturn -1;\nfail:\n\treturn -2;\nmalformed:\n\treturn -3;\n}\n", "bug_type": null, "idx": 415}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_menu_activate(GntWidget *widget)\n{\n\tGntMenu *menu = GNT_MENU(widget);\n\tGntMenuItem *item;\n\tif (menu->type == GNT_MENU_TOPLEVEL) {\n\t\titem = g_list_nth_data(menu->list, menu->selected);\n\t} else {\n\t\titem = gnt_tree_get_selection_data(GNT_TREE(menu));\n\t}\n\tif (item) {\n\t\tif (GNT_IS_MENU_ITEM_CHECK(item))\n\t\t\tgnt_menu_toggled(GNT_TREE(widget), item);\n\t\telse\n\t\t\tmenuitem_activate(menu, item);\n\t}\n}\n", "bug_type": null, "idx": 416}
{"project": "Pidgin", "target": 0, "func": "void jabber_message_send(JabberMessage *jm)\n{\n\txmlnode *message, *child;\n\tconst char *type = NULL;\n\tmessage = xmlnode_new(\"message\");\n\tswitch(jm->type) {\n\t\tcase JABBER_MESSAGE_NORMAL:\n\t\t\ttype = \"normal\";\n\t\t\tbreak;\n\t\tcase JABBER_MESSAGE_CHAT:\n\t\tcase JABBER_MESSAGE_GROUPCHAT_INVITE:\n\t\t\ttype = \"chat\";\n\t\t\tbreak;\n\t\tcase JABBER_MESSAGE_HEADLINE:\n\t\t\ttype = \"headline\";\n\t\t\tbreak;\n\t\tcase JABBER_MESSAGE_GROUPCHAT:\n\t\t\ttype = \"groupchat\";\n\t\t\tbreak;\n\t\tcase JABBER_MESSAGE_ERROR:\n\t\t\ttype = \"error\";\n\t\t\tbreak;\n\t\tcase JABBER_MESSAGE_OTHER:\n\t\tdefault:\n\t\t\ttype = NULL;\n\t\t\tbreak;\n\t}\n\tif(type)\n\t\txmlnode_set_attrib(message, \"type\", type);\n\tif (jm->id)\n\t\txmlnode_set_attrib(message, \"id\", jm->id);\n\txmlnode_set_attrib(message, \"to\", jm->to);\n\tif(jm->thread_id) {\n\t\tchild = xmlnode_new_child(message, \"thread\");\n\t\txmlnode_insert_data(child, jm->thread_id, -1);\n\t}\n\tchild = NULL;\n\tswitch(jm->chat_state)\n\t{\n\t\tcase JM_STATE_ACTIVE:\n\t\t\tchild = xmlnode_new_child(message, \"active\");\n\t\t\tbreak;\n\t\tcase JM_STATE_COMPOSING:\n\t\t\tchild = xmlnode_new_child(message, \"composing\");\n\t\t\tbreak;\n\t\tcase JM_STATE_PAUSED:\n\t\t\tchild = xmlnode_new_child(message, \"paused\");\n\t\t\tbreak;\n\t\tcase JM_STATE_INACTIVE:\n\t\t\tchild = xmlnode_new_child(message, \"inactive\");\n\t\t\tbreak;\n\t\tcase JM_STATE_GONE:\n\t\t\tchild = xmlnode_new_child(message, \"gone\");\n\t\t\tbreak;\n\t\tcase JM_STATE_NONE:\n\t\t\t\n\t\t\tbreak;\n\t}\n\tif(child)\n\t\txmlnode_set_namespace(child, \"http://jabber.org/protocol/chatstates\");\n\tif(jm->subject) {\n\t\tchild = xmlnode_new_child(message, \"subject\");\n\t\txmlnode_insert_data(child, jm->subject, -1);\n\t}\n\tif(jm->body) {\n\t\tchild = xmlnode_new_child(message, \"body\");\n\t\txmlnode_insert_data(child, jm->body, -1);\n\t}\n\tif(jm->xhtml) {\n\t\tif ((child = xmlnode_from_str(jm->xhtml, -1))) {\n\t\t\txmlnode_insert_child(message, child);\n\t\t} else {\n\t\t\tpurple_debug_error(\"jabber\",\n\t\t\t\t\t\"XHTML translation/validation failed, returning: %s\\n\",\n\t\t\t\t\tjm->xhtml);\n\t\t}\n\t}\n\tjabber_send(jm->js, message);\n\txmlnode_free(message);\n}\n", "bug_type": null, "idx": 417}
{"project": "Pidgin", "target": 0, "func": "PurplePlugin *\npurple_plugin_probe(const char *filename)\n{\n#ifdef PURPLE_PLUGINS\n\tPurplePlugin *plugin = NULL;\n\tPurplePlugin *loader;\n\tgpointer unpunned;\n\tgchar *basename = NULL;\n\tgboolean (*purple_init_plugin)(PurplePlugin *);\n\tpurple_debug_misc(\"plugins\", \"probing %s\\n\", filename);\n\tg_return_val_if_fail(filename != NULL, NULL);\n\tif (!g_file_test(filename, G_FILE_TEST_EXISTS))\n\t\treturn NULL;\n\t\n\tbasename = purple_plugin_get_basename(filename);\n\tplugin = purple_plugins_find_with_basename(basename);\n\tg_free(basename);\n\tif (plugin != NULL)\n\t{\n\t\tif (purple_strequal(filename, plugin->path))\n\t\t\treturn plugin;\n\t\telse if (!purple_plugin_is_unloadable(plugin))\n\t\t{\n\t\t\tpurple_debug_warning(\"plugins\", \"Not loading %s. \"\n\t\t\t\t\t\t\t\"Another plugin with the same name (%s) has already been loaded.\\n\",\n\t\t\t\t\t\t\tfilename, plugin->path);\n\t\t\treturn plugin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tpurple_plugin_destroy(plugin);\n\t\t}\n\t}\n\tplugin = purple_plugin_new(has_file_extension(filename, G_MODULE_SUFFIX), filename);\n\tif (plugin->native_plugin) {\n\t\tconst char *error;\n#ifdef _WIN32\n\t\t\n\t\tUINT old_error_mode = SetErrorMode(SEM_FAILCRITICALERRORS);\n#endif\n\t\t\n\t\tplugin->handle = g_module_open(filename, G_MODULE_BIND_LOCAL);\n\t\tif (plugin->handle == NULL)\n\t\t{\n\t\t\tconst char *error = g_module_error();\n\t\t\tif (error != NULL && purple_str_has_prefix(error, filename))\n\t\t\t{\n\t\t\t\terror = error + strlen(filename);\n\t\t\t\t\n\t\t\t\tif (*error == ':')\n\t\t\t\t\terror++;\n\t\t\t\tif (*error == ' ')\n\t\t\t\t\terror++;\n\t\t\t}\n\t\t\tif (error == NULL || !*error)\n\t\t\t{\n\t\t\t\tplugin->error = g_strdup(_(\"Unknown error\"));\n\t\t\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: Unknown error\\n\",\n\t\t\t\t\t\t plugin->path);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplugin->error = g_strdup(error);\n\t\t\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: %s\\n\",\n\t\t\t\t\t\t plugin->path, plugin->error);\n\t\t\t}\n\t\t\tplugin->handle = g_module_open(filename, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);\n\t\t\tif (plugin->handle == NULL)\n\t\t\t{\n#ifdef _WIN32\n\t\t\t\t\n\t\t\t\tSetErrorMode(old_error_mode);\n#endif\n\t\t\t\tpurple_plugin_destroy(plugin);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tplugin->unloadable = TRUE;\n\t\t\t}\n\t\t}\n\t\tif (!g_module_symbol(plugin->handle, \"purple_init_plugin\",\n\t\t\t\t\t\t\t &unpunned))\n\t\t{\n\t\t\tpurple_debug_error(\"plugins\", \"%s is not usable because the \"\n\t\t\t\t\t\t\t \"'purple_init_plugin' symbol could not be \"\n\t\t\t\t\t\t\t \"found.  Does the plugin call the \"\n\t\t\t\t\t\t\t \"PURPLE_INIT_PLUGIN() macro?\\n\", plugin->path);\n\t\t\tg_module_close(plugin->handle);\n\t\t\terror = g_module_error();\n\t\t\tif (error != NULL)\n\t\t\t\tpurple_debug_error(\"plugins\", \"Error closing module %s: %s\\n\",\n\t\t\t\t\t\t\t\t plugin->path, error);\n\t\t\tplugin->handle = NULL;\n#ifdef _WIN32\n\t\t\t\n\t\t\tSetErrorMode(old_error_mode);\n#endif\n\t\t\tpurple_plugin_destroy(plugin);\n\t\t\treturn NULL;\n\t\t}\n\t\tpurple_init_plugin = unpunned;\n#ifdef _WIN32\n\t\t\n\t\tSetErrorMode(old_error_mode);\n#endif\n\t}\n\telse {\n\t\tloader = find_loader_for_plugin(plugin);\n\t\tif (loader == NULL) {\n\t\t\tpurple_plugin_destroy(plugin);\n\t\t\treturn NULL;\n\t\t}\n\t\tpurple_init_plugin = PURPLE_PLUGIN_LOADER_INFO(loader)->probe;\n\t}\n\tif (!purple_init_plugin(plugin) || plugin->info == NULL)\n\t{\n\t\tpurple_plugin_destroy(plugin);\n\t\treturn NULL;\n\t}\n\telse if (plugin->info->ui_requirement &&\n\t\t\t!purple_strequal(plugin->info->ui_requirement, purple_core_get_ui()))\n\t{\n\t\tplugin->error = g_strdup_printf(_(\"You are using %s, but this plugin requires %s.\"),\n\t\t\t\t\tpurple_core_get_ui(), plugin->info->ui_requirement);\n\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: The UI requirement is not met. (%s)\\n\", plugin->path, plugin->error);\n\t\tplugin->unloadable = TRUE;\n\t\treturn plugin;\n\t}\n\t\n\tif (plugin->info->id == NULL || *plugin->info->id == '\\0')\n\t{\n\t\tplugin->error = g_strdup(_(\"This plugin has not defined an ID.\"));\n\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: info->id is not defined.\\n\", plugin->path);\n\t\tplugin->unloadable = TRUE;\n\t\treturn plugin;\n\t}\n\t\n\tif (plugin->info->magic != PURPLE_PLUGIN_MAGIC)\n\t{\n\t\tif (plugin->info->magic >= 2 && plugin->info->magic <= 4)\n\t\t{\n\t\t\tstruct _PurplePluginInfo2\n\t\t\t{\n\t\t\t\tunsigned int api_version;\n\t\t\t\tPurplePluginType type;\n\t\t\t\tchar *ui_requirement;\n\t\t\t\tunsigned long flags;\n\t\t\t\tGList *dependencies;\n\t\t\t\tPurplePluginPriority priority;\n\t\t\t\tchar *id;\n\t\t\t\tchar *name;\n\t\t\t\tchar *version;\n\t\t\t\tchar *summary;\n\t\t\t\tchar *description;\n\t\t\t\tchar *author;\n\t\t\t\tchar *homepage;\n\t\t\t\tgboolean (*load)(PurplePlugin *plugin);\n\t\t\t\tgboolean (*unload)(PurplePlugin *plugin);\n\t\t\t\tvoid (*destroy)(PurplePlugin *plugin);\n\t\t\t\tvoid *ui_info;\n\t\t\t\tvoid *extra_info;\n\t\t\t\tPurplePluginUiInfo *prefs_info;\n\t\t\t\tGList *(*actions)(PurplePlugin *plugin, gpointer context);\n\t\t\t} *info2 = (struct _PurplePluginInfo2 *)plugin->info;\n\t\t\t\n\t\t\tplugin->info = g_new0(PurplePluginInfo, 1);\n\t\t\t\n\t\t\tplugin->info->magic          = info2->api_version;\n\t\t\tplugin->info->type           = info2->type;\n\t\t\tplugin->info->ui_requirement = info2->ui_requirement;\n\t\t\tplugin->info->flags          = info2->flags;\n\t\t\tplugin->info->dependencies   = info2->dependencies;\n\t\t\tplugin->info->id             = info2->id;\n\t\t\tplugin->info->name           = info2->name;\n\t\t\tplugin->info->version        = info2->version;\n\t\t\tplugin->info->summary        = info2->summary;\n\t\t\tplugin->info->description    = info2->description;\n\t\t\tplugin->info->author         = info2->author;\n\t\t\tplugin->info->homepage       = info2->homepage;\n\t\t\tplugin->info->load           = info2->load;\n\t\t\tplugin->info->unload         = info2->unload;\n\t\t\tplugin->info->destroy        = info2->destroy;\n\t\t\tplugin->info->ui_info        = info2->ui_info;\n\t\t\tplugin->info->extra_info     = info2->extra_info;\n\t\t\tif (info2->api_version >= 3)\n\t\t\t\tplugin->info->prefs_info = info2->prefs_info;\n\t\t\tif (info2->api_version >= 4)\n\t\t\t\tplugin->info->actions    = info2->actions;\n\t\t\tplugin->error = g_strdup_printf(_(\"Plugin magic mismatch %d (need %d)\"),\n\t\t\t\t\t\t\t plugin->info->magic, PURPLE_PLUGIN_MAGIC);\n\t\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: Plugin magic mismatch %d (need %d)\\n\",\n\t\t\t\t\t  plugin->path, plugin->info->magic, PURPLE_PLUGIN_MAGIC);\n\t\t\tplugin->unloadable = TRUE;\n\t\t\treturn plugin;\n\t\t}\n\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: Plugin magic mismatch %d (need %d)\\n\",\n\t\t\t\t plugin->path, plugin->info->magic, PURPLE_PLUGIN_MAGIC);\n\t\tpurple_plugin_destroy(plugin);\n\t\treturn NULL;\n\t}\n\tif (plugin->info->major_version != PURPLE_MAJOR_VERSION ||\n\t\t\tplugin->info->minor_version > PURPLE_MINOR_VERSION)\n\t{\n\t\tplugin->error = g_strdup_printf(_(\"ABI version mismatch %d.%d.x (need %d.%d.x)\"),\n\t\t\t\t\t\t plugin->info->major_version, plugin->info->minor_version,\n\t\t\t\t\t\t PURPLE_MAJOR_VERSION, PURPLE_MINOR_VERSION);\n\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: ABI version mismatch %d.%d.x (need %d.%d.x)\\n\",\n\t\t\t\t plugin->path, plugin->info->major_version, plugin->info->minor_version,\n\t\t\t\t PURPLE_MAJOR_VERSION, PURPLE_MINOR_VERSION);\n\t\tplugin->unloadable = TRUE;\n\t\treturn plugin;\n\t}\n\tif (plugin->info->type == PURPLE_PLUGIN_PROTOCOL)\n\t{\n\t\t\n\t\tif ((PURPLE_PLUGIN_PROTOCOL_INFO(plugin)->list_icon == NULL) ||\n\t\t    (PURPLE_PLUGIN_PROTOCOL_INFO(plugin)->login == NULL) ||\n\t\t    (PURPLE_PLUGIN_PROTOCOL_INFO(plugin)->close == NULL))\n\t\t{\n\t\t\tplugin->error = g_strdup(_(\"Plugin does not implement all required functions (list_icon, login and close)\"));\n\t\t\tpurple_debug_error(\"plugins\", \"%s is not loadable: %s\\n\",\n\t\t\t\t\t plugin->path, plugin->error);\n\t\t\tplugin->unloadable = TRUE;\n\t\t\treturn plugin;\n\t\t}\n\t\t\n\t\tif (plugin->info->prefs_info != NULL)\n\t\t{\n\t\t\tpurple_debug_error(\"plugins\", \"%s has a prefs_info, but is a prpl. This is no longer supported.\\n\",\n\t\t\t                 plugin->path);\n\t\t}\n\t}\n\treturn plugin;\n#else\n\treturn NULL;\n#endif \n}\n", "bug_type": null, "idx": 418}
{"project": "Pidgin", "target": 0, "func": "static PurpleRequestField *\nget_pref_field(Prefs *prefs)\n{\n\tPurpleRequestField *field = NULL;\n\tif (prefs->lv == NULL)\n\t{\n\t\tswitch (prefs->type)\n\t\t{\n\t\t\tcase PURPLE_PREF_BOOLEAN:\n\t\t\t\tfield = purple_request_field_bool_new(prefs->pref, _(prefs->label),\n\t\t\t\t\t\tpurple_prefs_get_bool(prefs->pref));\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_PREF_INT:\n\t\t\t\tfield = purple_request_field_int_new(prefs->pref, _(prefs->label),\n\t\t\t\t\t\tpurple_prefs_get_int(prefs->pref));\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_PREF_STRING:\n\t\t\t\tfield = purple_request_field_string_new(prefs->pref, _(prefs->label),\n\t\t\t\t\t\tpurple_prefs_get_string(prefs->pref), FALSE);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tGList *list = prefs->lv(), *iter;\n\t\tif (list)\n\t\t\tfield = purple_request_field_list_new(prefs->pref, _(prefs->label));\n\t\tfor (iter = list; iter; iter = iter->next)\n\t\t{\n\t\t\tgboolean select = FALSE;\n\t\t\tconst char *data = iter->data;\n\t\t\tint idata;\n\t\t\titer = iter->next;\n\t\t\tswitch (prefs->type)\n\t\t\t{\n\t\t\t\tcase PURPLE_PREF_BOOLEAN:\n\t\t\t\t\tif (sscanf(iter->data, \"%d\", &idata) != 1)\n\t\t\t\t\t\tidata = FALSE;\n\t\t\t\t\tif (purple_prefs_get_bool(prefs->pref) == idata)\n\t\t\t\t\t\tselect = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_PREF_INT:\n\t\t\t\t\tif (sscanf(iter->data, \"%d\", &idata) != 1)\n\t\t\t\t\t\tidata = 0;\n\t\t\t\t\tif (purple_prefs_get_int(prefs->pref) == idata)\n\t\t\t\t\t\tselect = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_PREF_STRING:\n\t\t\t\t\tif (strcmp(purple_prefs_get_string(prefs->pref), iter->data) == 0)\n\t\t\t\t\t\tselect = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpurple_request_field_list_add_icon(field, data, NULL, iter->data);\n\t\t\tif (select)\n\t\t\t\tpurple_request_field_list_add_selected(field, data);\n\t\t}\n\t\tg_list_free(list);\n\t}\n\treturn field;\n}\n", "bug_type": null, "idx": 419}
{"project": "Pidgin", "target": 0, "func": "static GType\npidgin_status_box_child_type (GtkContainer *container)\n{\n    return GTK_TYPE_WIDGET;\n}\n", "bug_type": null, "idx": 420}
{"project": "Pidgin", "target": 0, "func": "void silcpurple_idle_set(PurpleConnection *gc, int idle)\n{\n\tSilcPurple sg;\n\tSilcClient client;\n\tSilcClientConnection conn;\n\tSilcAttributeObjService service;\n\tconst char *server;\n\tint port;\n\tsg = gc->proto_data;\n\tif (sg == NULL)\n\t\treturn;\n\tclient = sg->client;\n\tif (client == NULL)\n\t\treturn;\n\tconn = sg->conn;\n\tif (conn == NULL)\n\t\treturn;\n\tserver = purple_account_get_string(sg->account, \"server\",\n\t\t\t\t\t \"silc.silcnet.org\");\n\tport = purple_account_get_int(sg->account, \"port\", 706),\n\tmemset(&service, 0, sizeof(service));\n\tsilc_client_attribute_del(client, conn,\n\t\t\t\t  SILC_ATTRIBUTE_SERVICE, NULL);\n\tservice.port = port;\n\tg_snprintf(service.address, sizeof(service.address), \"%s\", server);\n\tservice.idle = idle;\n\tsilc_client_attribute_add(client, conn, SILC_ATTRIBUTE_SERVICE,\n\t\t\t\t  &service, sizeof(service));\n}\n", "bug_type": null, "idx": 421}
{"project": "Pidgin", "target": 0, "func": "void\nfinch_pounces_manager_show(void)\n{\n\tPouncesManager *dialog;\n\tGntWidget *bbox;\n\tGntWidget *button;\n\tGntWidget *tree;\n\tGntWidget *win;\n\tif (pounces_manager != NULL) {\n\t\tgnt_window_present(pounces_manager->window);\n\t\treturn;\n\t}\n\tpounces_manager = dialog = g_new0(PouncesManager, 1);\n\tdialog->window = win = gnt_vbox_new(FALSE);\n\tgnt_box_set_toplevel(GNT_BOX(win), TRUE);\n\tgnt_box_set_title(GNT_BOX(win), _(\"Buddy Pounces\"));\n\tgnt_box_set_pad(GNT_BOX(win), 0);\n\tg_signal_connect(G_OBJECT(win), \"destroy\",\n\t\t\t\t\t G_CALLBACK(pounces_manager_destroy_cb), dialog);\n\t\n\tdialog->tree = tree = GNT_WIDGET(gnt_tree_new_with_columns(2));\n\tgnt_tree_set_column_titles(GNT_TREE(tree), \"Account\", \"Pouncee\", NULL);\n\tgnt_tree_set_show_title(GNT_TREE(tree), TRUE);\n\tgnt_box_add_widget(GNT_BOX(win), tree);\n\t\n\tbbox = gnt_hbox_new(FALSE);\n\t\n\tbutton = gnt_button_new(_(\"Add\"));\n\tgnt_box_add_widget(GNT_BOX(bbox), button);\n\tgnt_util_set_trigger_widget(tree, GNT_KEY_INS, button);\n\tg_signal_connect(G_OBJECT(button), \"activate\",\n\t\t\t\t\t G_CALLBACK(pounces_manager_add_cb), dialog);\n\t\n\tbutton = gnt_button_new(_(\"Modify\"));\n\tdialog->modify_button = button;\n\tgnt_box_add_widget(GNT_BOX(bbox), button);\n\tg_signal_connect(G_OBJECT(button), \"activate\",\n\t\t\t\t\t G_CALLBACK(pounces_manager_modify_cb), dialog);\n\t\n\tbutton = gnt_button_new(_(\"Delete\"));\n\tdialog->delete_button = button;\n\tgnt_box_add_widget(GNT_BOX(bbox), button);\n\tgnt_util_set_trigger_widget(tree, GNT_KEY_DEL, button);\n\tg_signal_connect(G_OBJECT(button), \"activate\",\n\t\t\t\t\t G_CALLBACK(pounces_manager_delete_cb), dialog);\n\t\n\tbutton = gnt_button_new(_(\"Close\"));\n\tgnt_box_add_widget(GNT_BOX(bbox), button);\n\tgnt_widget_show(button);\n\tg_signal_connect(G_OBJECT(button), \"activate\",\n\t\t\t\t\t G_CALLBACK(pounces_manager_close_cb), dialog);\n\tgnt_box_add_widget(GNT_BOX(win), bbox);\n\tgnt_widget_show(win);\n\tpopulate_pounces_list(pounces_manager);\n}\n", "bug_type": null, "idx": 422}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_glib_log_handler(const gchar *domain, GLogLevelFlags flags,\n\t\t\t\t\t  const gchar *msg, gpointer user_data)\n{\n\tPurpleDebugLevel level;\n\tchar *new_msg = NULL;\n\tchar *new_domain = NULL;\n\tif ((flags & G_LOG_LEVEL_ERROR) == G_LOG_LEVEL_ERROR)\n\t\tlevel = PURPLE_DEBUG_ERROR;\n\telse if ((flags & G_LOG_LEVEL_CRITICAL) == G_LOG_LEVEL_CRITICAL)\n\t\tlevel = PURPLE_DEBUG_FATAL;\n\telse if ((flags & G_LOG_LEVEL_WARNING) == G_LOG_LEVEL_WARNING)\n\t\tlevel = PURPLE_DEBUG_WARNING;\n\telse if ((flags & G_LOG_LEVEL_MESSAGE) == G_LOG_LEVEL_MESSAGE)\n\t\tlevel = PURPLE_DEBUG_INFO;\n\telse if ((flags & G_LOG_LEVEL_INFO) == G_LOG_LEVEL_INFO)\n\t\tlevel = PURPLE_DEBUG_INFO;\n\telse if ((flags & G_LOG_LEVEL_DEBUG) == G_LOG_LEVEL_DEBUG)\n\t\tlevel = PURPLE_DEBUG_MISC;\n\telse\n\t{\n\t\tpurple_debug_warning(\"gtkdebug\",\n\t\t\t\t   \"Unknown glib logging level in %d\\n\", flags);\n\t\tlevel = PURPLE_DEBUG_MISC; \n\t}\n\tif (msg != NULL)\n\t\tnew_msg = purple_utf8_try_convert(msg);\n\tif (domain != NULL)\n\t\tnew_domain = purple_utf8_try_convert(domain);\n\tif (new_msg != NULL)\n\t{\n\t\tpurple_debug(level, (new_domain != NULL ? new_domain : \"g_log\"),\n\t\t\t\t   \"%s\\n\", new_msg);\n\t\tg_free(new_msg);\n\t}\n\tg_free(new_domain);\n}\n", "bug_type": null, "idx": 423}
{"project": "Pidgin", "target": 0, "func": "};\nPurpleConversationUiOps *finch_conv_get_ui_ops()\n{\n\treturn &conv_ui_ops;\n}\n", "bug_type": null, "idx": 424}
{"project": "Pidgin", "target": 0, "func": "static gboolean chat_buddy_leaving_cb(PurpleConversation *conv, const char *name,\n                               const char *reason, GHashTable *users)\n{\n\treturn should_hide_notice(conv, name, users);\n}\n", "bug_type": null, "idx": 425}
{"project": "Pidgin", "target": 0, "func": "static void\nset_creation_time(PurpleSavedStatus *status, time_t creation_time)\n{\n\tg_return_if_fail(status != NULL);\n\t\n\tstatus->creation_time = creation_time != 0 ? creation_time : 1;\n\twhile (g_hash_table_lookup(creation_times, (gconstpointer)status->creation_time) != NULL)\n\t\tstatus->creation_time++;\n\tg_hash_table_insert(creation_times,\n\t\t\t\t\t\t(gpointer)status->creation_time,\n\t\t\t\t\t\tstatus);\n}\n", "bug_type": null, "idx": 426}
{"project": "Pidgin", "target": 0, "func": "static void\nsigned_off_cb(PurpleConnection *gc,\n              gpointer unused)\n{\n\tPurpleAccount *account = purple_connection_get_account(gc);\n\tpurple_signal_emit(purple_accounts_get_handle(), \"account-signed-off\",\n\t                   account);\n}\n", "bug_type": null, "idx": 427}
{"project": "Pidgin", "target": 0, "func": "static PurpleMediaElementInfo *\nget_send_application_element_info ()\n{\n\tstatic PurpleMediaElementInfo *info = NULL;\n#ifdef HAVE_MEDIA_APPLICATION\n\tif (info == NULL) {\n\t\tinfo = g_object_new(PURPLE_TYPE_MEDIA_ELEMENT_INFO,\n\t\t\t\"id\", \"pidginappsrc\",\n\t\t\t\"name\", \"Pidgin Application Source\",\n\t\t\t\"type\", PURPLE_MEDIA_ELEMENT_APPLICATION\n\t\t\t\t\t| PURPLE_MEDIA_ELEMENT_SRC\n\t\t\t\t\t| PURPLE_MEDIA_ELEMENT_ONE_SRC,\n\t\t\t\"create-cb\", create_send_appsrc, NULL);\n\t}\n#endif\n\treturn info;\n}\n", "bug_type": null, "idx": 428}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin)\n{\n}\n", "bug_type": null, "idx": 429}
{"project": "Pidgin", "target": 0, "func": "static gchar *\nfind_icon_file(PidginIconTheme *theme, const gchar *size, SizedStockIcon sized_icon, gboolean rtl)\n{\n\tconst gchar *file, *dir;\n\tgchar *file_full = NULL;\n\tgchar *tmp;\n\tif (theme != NULL) {\n\t\tfile = pidgin_icon_theme_get_icon(PIDGIN_ICON_THEME(theme), sized_icon.name);\n\t\tdir = purple_theme_get_dir(PURPLE_THEME(theme));\n\t\tif (rtl)\n\t\t\tfile_full = g_build_filename(dir, size, \"rtl\", file, NULL);\n\t\telse\n\t\t\tfile_full = g_build_filename(dir, size, file, NULL);\n\t\tif (g_file_test(file_full, G_FILE_TEST_IS_REGULAR))\n\t\t\treturn file_full;\n\t\tg_free(file_full);\n\t}\n\tif (rtl)\n\t\ttmp = g_build_filename(\"pixmaps\", \"pidgin\", sized_icon.dir, size, \"rtl\", sized_icon.filename, NULL);\n\telse\n\t\ttmp = g_build_filename(\"pixmaps\", \"pidgin\", sized_icon.dir, size, sized_icon.filename, NULL);\n\tfile_full = find_file_common(tmp);\n\tg_free(tmp);\n\treturn file_full;\n}\n", "bug_type": null, "idx": 430}
{"project": "Pidgin", "target": 0, "func": "unsigned int\noscar_send_typing(PurpleConnection *gc, const char *name, PurpleTypingState state)\n{\n\tOscarData *od;\n\tPeerConnection *conn;\n\tod = purple_connection_get_protocol_data(gc);\n\tconn = peer_connection_find_by_type(od, name, OSCAR_CAPABILITY_DIRECTIM);\n\tif ((conn != NULL) && (conn->ready))\n\t{\n\t\tpeer_odc_send_typing(conn, state);\n\t}\n\telse {\n\t\t\n\t\tGSList *list;\n\t\tfor (list=gc->account->deny; (list && oscar_util_name_compare(name, list->data)); list=list->next);\n\t\tif (!list) {\n\t\t\tstruct buddyinfo *bi = g_hash_table_lookup(od->buddyinfo, purple_normalize(gc->account, name));\n\t\t\tif (bi && bi->typingnot) {\n\t\t\t\tif (state == PURPLE_TYPING)\n\t\t\t\t\taim_im_sendmtn(od, 0x0001, name, 0x0002);\n\t\t\t\telse if (state == PURPLE_TYPED)\n\t\t\t\t\taim_im_sendmtn(od, 0x0001, name, 0x0001);\n\t\t\t\telse\n\t\t\t\t\taim_im_sendmtn(od, 0x0001, name, 0x0000);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 431}
{"project": "Pidgin", "target": 0, "func": "static void\nupdate_menuitem(GtkToggleButton *button, GtkCheckMenuItem *item)\n{\n\tg_signal_handlers_block_by_func(G_OBJECT(item), G_CALLBACK(gtk_button_clicked), button);\n\tgtk_check_menu_item_set_active(item, gtk_toggle_button_get_active(button));\n\tg_signal_handlers_unblock_by_func(G_OBJECT(item), G_CALLBACK(gtk_button_clicked), button);\n}\n", "bug_type": null, "idx": 432}
{"project": "Pidgin", "target": 0, "func": "xmlnode*\nxmlnode_new(const char *name)\n{\n\tg_return_val_if_fail(name != NULL && *name != '\\0', NULL);\n\treturn new_node(name, XMLNODE_TYPE_TAG);\n}\n", "bug_type": null, "idx": 433}
{"project": "Pidgin", "target": 0, "func": "static GList *html_logger_list(PurpleLogType type, const char *sn, PurpleAccount *account)\n{\n\treturn purple_log_common_lister(type, sn, account, \".html\", html_logger);\n}\n", "bug_type": null, "idx": 434}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddy_state_cb(PurpleBuddy *buddy, PurpleSoundEventID event)\n{\n\tpurple_sound_play_event(event, purple_buddy_get_account(buddy));\n}\n", "bug_type": null, "idx": 435}
{"project": "Pidgin", "target": 0, "func": " */\nstatic PurpleAccount *find_acct(const char *prpl, const char *acct_id)\n{\n\tPurpleAccount *acct = NULL;\n\t\n\tif (acct_id) {\n\t\tacct = purple_accounts_find(acct_id, prpl);\n\t\tif (acct && !purple_account_is_connected(acct))\n\t\t\tacct = NULL;\n\t} else { \n\t\tGList *l = purple_accounts_get_all();\n\t\twhile (l) {\n\t\t\tif (!strcmp(prpl, purple_account_get_protocol_id(l->data))\n\t\t\t\t\t&& purple_account_is_connected(l->data)) {\n\t\t\t\tacct = l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl = l->next;\n\t\t}\n\t}\n\treturn acct;\n}\n", "bug_type": null, "idx": 436}
{"project": "Pidgin", "target": 0, "func": "PurpleStatusAttr *\npurple_status_type_get_attr(const PurpleStatusType *status_type, const char *id)\n{\n\tGList *l;\n\tg_return_val_if_fail(status_type != NULL, NULL);\n\tg_return_val_if_fail(id          != NULL, NULL);\n\tfor (l = status_type->attrs; l != NULL; l = l->next)\n\t{\n\t\tPurpleStatusAttr *attr = (PurpleStatusAttr *)l->data;\n\t\tif (purple_strequal(purple_status_attr_get_id(attr), id))\n\t\t\treturn attr;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 437}
{"project": "Pidgin", "target": 0, "func": "#undef recv\nint gg_win32_recv(int sockfd, void *buf, size_t len, int flags)\n{\n\tint res;\n\tres = recv(sockfd, buf, len, flags);\n\tif (res == -1)\n\t\terrno = gg_win32_map_wsa_error_to_errno(EAGAIN);\n\treturn res;\n}\n", "bug_type": null, "idx": 438}
{"project": "Pidgin", "target": 0, "func": "JingleTransport *\njingle_transport_parse(xmlnode *transport)\n{\n\tconst gchar *type_name = xmlnode_get_namespace(transport);\n\tGType type = jingle_get_type(type_name);\n\tif (type == G_TYPE_NONE)\n\t\treturn NULL;\n\treturn JINGLE_TRANSPORT_CLASS(g_type_class_ref(type))->parse(transport);\n}\n", "bug_type": null, "idx": 439}
{"project": "Pidgin", "target": 0, "func": "static protobuf_c_boolean\nmerge_messages(ProtobufCMessage *earlier_msg,\n\t       ProtobufCMessage *latter_msg,\n\t       ProtobufCAllocator *allocator)\n{\n\tunsigned i;\n\tconst ProtobufCFieldDescriptor *fields =\n\t\tearlier_msg->descriptor->fields;\n\tfor (i = 0; i < latter_msg->descriptor->n_fields; i++) {\n\t\tif (fields[i].label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t *n_earlier =\n\t\t\t\tSTRUCT_MEMBER_PTR(size_t, earlier_msg,\n\t\t\t\t\t\t  fields[i].quantifier_offset);\n\t\t\tuint8_t **p_earlier =\n\t\t\t\tSTRUCT_MEMBER_PTR(uint8_t *, earlier_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\t\t\tsize_t *n_latter =\n\t\t\t\tSTRUCT_MEMBER_PTR(size_t, latter_msg,\n\t\t\t\t\t\t  fields[i].quantifier_offset);\n\t\t\tuint8_t **p_latter =\n\t\t\t\tSTRUCT_MEMBER_PTR(uint8_t *, latter_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\t\t\tif (*n_earlier > 0) {\n\t\t\t\tif (*n_latter > 0) {\n\t\t\t\t\t\n\t\t\t\t\tsize_t el_size =\n\t\t\t\t\t\tsizeof_elt_in_repeated_array(fields[i].type);\n\t\t\t\t\tuint8_t *new_field;\n\t\t\t\t\tnew_field = do_alloc(allocator,\n\t\t\t\t\t\t(*n_earlier + *n_latter) * el_size);\n\t\t\t\t\tif (!new_field)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\tmemcpy(new_field, *p_earlier,\n\t\t\t\t\t       *n_earlier * el_size);\n\t\t\t\t\tmemcpy(new_field +\n\t\t\t\t\t       *n_earlier * el_size,\n\t\t\t\t\t       *p_latter,\n\t\t\t\t\t       *n_latter * el_size);\n\t\t\t\t\tdo_free(allocator, *p_latter);\n\t\t\t\t\tdo_free(allocator, *p_earlier);\n\t\t\t\t\t*p_latter = new_field;\n\t\t\t\t\t*n_latter = *n_earlier + *n_latter;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t*n_latter = *n_earlier;\n\t\t\t\t\t*p_latter = *p_earlier;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t*n_earlier = 0;\n\t\t\t\t*p_earlier = 0;\n\t\t\t}\n\t\t} else if (fields[i].type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\tProtobufCMessage **em =\n\t\t\t\tSTRUCT_MEMBER_PTR(ProtobufCMessage *,\n\t\t\t\t\t\t  earlier_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\t\t\tProtobufCMessage **lm =\n\t\t\t\tSTRUCT_MEMBER_PTR(ProtobufCMessage *,\n\t\t\t\t\t\t  latter_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\t\t\tif (*em != NULL) {\n\t\t\t\tif (*lm != NULL) {\n\t\t\t\t\tif (!merge_messages\n\t\t\t\t\t    (*em, *lm, allocator))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tassert(fields[i].label ==\n\t\t\t\t\t       PROTOBUF_C_LABEL_OPTIONAL);\n\t\t\t\t\t*lm = *em;\n\t\t\t\t\t*em = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fields[i].label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\tsize_t el_size = 0;\n\t\t\tprotobuf_c_boolean need_to_merge = FALSE;\n\t\t\tvoid *earlier_elem =\n\t\t\t\tSTRUCT_MEMBER_P(earlier_msg, fields[i].offset);\n\t\t\tvoid *latter_elem =\n\t\t\t\tSTRUCT_MEMBER_P(latter_msg, fields[i].offset);\n\t\t\tconst void *def_val = fields[i].default_value;\n\t\t\tswitch (fields[i].type) {\n\t\t\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\t\t\tuint8_t *e_data =\n\t\t\t\t\t((ProtobufCBinaryData *) earlier_elem)->data;\n\t\t\t\tuint8_t *l_data =\n\t\t\t\t\t((ProtobufCBinaryData *) latter_elem)->data;\n\t\t\t\tconst ProtobufCBinaryData *d_bd =\n\t\t\t\t\t(ProtobufCBinaryData *) def_val;\n\t\t\t\tel_size = sizeof(ProtobufCBinaryData);\n\t\t\t\tneed_to_merge =\n\t\t\t\t\t(e_data != NULL &&\n\t\t\t\t\t (d_bd != NULL &&\n\t\t\t\t\t  e_data != d_bd->data)) &&\n\t\t\t\t\t(l_data == NULL ||\n\t\t\t\t\t (d_bd != NULL &&\n\t\t\t\t\t  l_data == d_bd->data));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PROTOBUF_C_TYPE_STRING: {\n\t\t\t\tchar *e_str = *(char **) earlier_elem;\n\t\t\t\tchar *l_str = *(char **) latter_elem;\n\t\t\t\tconst char *d_str = def_val;\n\t\t\t\tel_size = sizeof(char *);\n\t\t\t\tneed_to_merge = e_str != d_str && l_str == d_str;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tel_size = sizeof_elt_in_repeated_array(fields[i].type);\n\t\t\t\tneed_to_merge =\n\t\t\t\t\tSTRUCT_MEMBER(protobuf_c_boolean,\n\t\t\t\t\t\t      earlier_msg,\n\t\t\t\t\t\t      fields[i].quantifier_offset) &&\n\t\t\t\t\t!STRUCT_MEMBER(protobuf_c_boolean,\n\t\t\t\t\t\t       latter_msg,\n\t\t\t\t\t\t       fields[i].quantifier_offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t\tif (need_to_merge) {\n\t\t\t\tmemcpy(latter_elem, earlier_elem, el_size);\n\t\t\t\t\n\t\t\t\tmemset(earlier_elem, 0, el_size);\n\t\t\t\tif (fields[i].quantifier_offset != 0) {\n\t\t\t\t\t\n\t\t\t\t\tSTRUCT_MEMBER(protobuf_c_boolean,\n\t\t\t\t\t\t      latter_msg,\n\t\t\t\t\t\t      fields[i].\n\t\t\t\t\t\t      quantifier_offset) = TRUE;\n\t\t\t\t\tSTRUCT_MEMBER(protobuf_c_boolean,\n\t\t\t\t\t\t      earlier_msg,\n\t\t\t\t\t\t      fields[i].\n\t\t\t\t\t\t      quantifier_offset) = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 440}
{"project": "Pidgin", "target": 0, "func": "void\npurple_prpl_send_attention(PurpleConnection *gc, const char *who, guint type_code)\n{\n\tPurpleAttentionType *attn;\n\tPurpleMessageFlags flags;\n\tPurplePlugin *prpl;\n\tPurpleConversation *conv;\n\tgboolean (*send_attention)(PurpleConnection *, const char *, guint);\n\tPurpleBuddy *buddy;\n\tconst char *alias;\n\tgchar *description;\n\ttime_t mtime;\n\tg_return_if_fail(gc != NULL);\n\tg_return_if_fail(who != NULL);\n\tprpl = purple_find_prpl(purple_account_get_protocol_id(gc->account));\n\tsend_attention = PURPLE_PLUGIN_PROTOCOL_INFO(prpl)->send_attention;\n\tg_return_if_fail(send_attention != NULL);\n\tmtime = time(NULL);\n\tattn = purple_get_attention_type_from_code(gc->account, type_code);\n\tif ((buddy = purple_find_buddy(purple_connection_get_account(gc), who)) != NULL)\n\t\talias = purple_buddy_get_contact_alias(buddy);\n\telse\n\t\talias = who;\n\tif (attn && purple_attention_type_get_outgoing_desc(attn)) {\n\t\tdescription = g_strdup_printf(purple_attention_type_get_outgoing_desc(attn), alias);\n\t} else {\n\t\tdescription = g_strdup_printf(_(\"Requesting %s's attention...\"), alias);\n\t}\n\tflags = PURPLE_MESSAGE_SEND | PURPLE_MESSAGE_NOTIFY | PURPLE_MESSAGE_SYSTEM;\n\tpurple_debug_info(\"server\", \"serv_send_attention: sending '%s' to %s\\n\",\n\t\t\tdescription, who);\n\tif (!send_attention(gc, who, type_code))\n\t\treturn;\n\tconv = purple_conversation_new(PURPLE_CONV_TYPE_IM, gc->account, who);\n\tpurple_conv_im_write(PURPLE_CONV_IM(conv), NULL, description, flags, mtime);\n\tpurple_prpl_attention(conv, who, type_code, PURPLE_MESSAGE_SEND, time(NULL));\n\tg_free(description);\n}\n", "bug_type": null, "idx": 441}
{"project": "Pidgin", "target": 0, "func": "static gboolean jabber_login_connect(JabberStream *js, const char *domain, const char *host, int port,\n\t\t\t\t gboolean fatal_failure)\n{\n\t\n\tg_free(js->serverFQDN);\n\tif (purple_ip_address_is_valid(host))\n\t\tjs->serverFQDN = g_strdup(domain);\n\telse\n\t\tjs->serverFQDN = g_strdup(host);\n\tif (purple_proxy_connect(js->gc, purple_connection_get_account(js->gc),\n\t\t\thost, port, jabber_login_callback, js->gc) == NULL) {\n\t\tif (fatal_failure) {\n\t\t\tpurple_connection_error_reason(js->gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t\t_(\"Unable to connect\"));\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 442}
{"project": "Pidgin", "target": 0, "func": "static void insert_status_change_from_purple_status(CapStatistics *statistics, PurpleStatus *status) {\n\tchar *sql;\n\tint rc;\n\tconst gchar *status_id;\n\tconst gchar *buddy_name;\n\tconst gchar *protocol_id;\n\tconst gchar *account_id;\n\t\n\tif(strcmp(statistics->last_status_id, purple_status_get_id(status)) == 0)\n\t\treturn;\n\tstatus_id = purple_status_get_id(status);\n\tbuddy_name = statistics->buddy->name;\n\tprotocol_id = purple_account_get_protocol_id(statistics->buddy->account);\n\taccount_id = purple_account_get_username(statistics->buddy->account);\n\tstatistics->last_status_id = purple_status_get_id(status);\n\tpurple_debug_info(\"cap\", \"Executing: insert into cap_status (buddy, account, protocol, status, event_time) values(%s, %s, %s, %s, now());\\n\", buddy_name, account_id, protocol_id, status_id);\n\tsql = sqlite3_mprintf(\"insert into cap_status values (%Q, %Q, %Q, %Q, now());\", buddy_name, account_id, protocol_id, status_id);\n\trc = sqlite3_exec(_db, sql, NULL, NULL, NULL);\n\tsqlite3_free(sql);\n}\n", "bug_type": null, "idx": 443}
{"project": "Pidgin", "target": 0, "func": "PurplePrefsUiOps *\npurple_prefs_get_ui_ops(void)\n{\n\treturn prefs_ui_ops;\n}\n", "bug_type": null, "idx": 444}
{"project": "Pidgin", "target": 0, "func": "static void jabber_bosh_connection_boot(PurpleBOSHConnection *conn) {\n\tGString *buf = g_string_new(NULL);\n\tg_string_printf(buf, \"<body content='text/xml; charset=utf-8' \"\n\t                \"secure='true' \"\n\t                \"to='%s' \"\n\t                \"xml:lang='en' \"\n\t                \"xmpp:version='1.0' \"\n\t                \"ver='1.6' \"\n\t                \"xmlns:xmpp='\" NS_XMPP_BOSH \"' \"\n\t                \"rid='%\" G_GUINT64_FORMAT \"' \"\n\n\t                \"wait='60' \"\n\t                \"hold='1' \"\n\t                \"xmlns='\" NS_BOSH \"'/>\",\n\t                conn->js->user->domain,\n\t                ++conn->rid);\n\tpurple_debug_misc(\"jabber\", \"SendBOSH Boot %s(%\" G_GSIZE_FORMAT \"): %s\\n\",\n\t                  conn->ssl ? \"(ssl)\" : \"\", buf->len, buf->str);\n\tconn->receive_cb = boot_response_cb;\n\thttp_connection_send_request(conn->connections[0], buf);\n\tg_string_free(buf, TRUE);\n}\n", "bug_type": null, "idx": 445}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddynote_edit_cb(PurpleBlistNode *node, gpointer data)\n{\n\tconst char *note;\n\tnote = purple_blist_node_get_string(node, \"notes\");\n\tpurple_request_input(node, _(\"Notes\"),\n\t\t\t\t\t   _(\"Enter your notes below...\"),\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   note, TRUE, FALSE, \"html\",\n\t\t\t\t\t   _(\"Save\"), G_CALLBACK(do_it_cb),\n\t\t\t\t\t   _(\"Cancel\"), G_CALLBACK(dont_do_it_cb),\n\t\t\t\t\t   NULL, NULL, NULL,\n\t\t\t\t\t   node);\n}\n", "bug_type": null, "idx": 446}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_request_action_varg(void *handle, const char *title,\n\t\t\t\t\t\t const char *primary, const char *secondary,\n\t\t\t\t\t\t int default_action,\n\t\t\t\t\t\t PurpleAccount *account, const char *who, PurpleConversation *conv,\n\t\t\t\t\t\t  void *user_data, size_t action_count, va_list actions)\n{\n\tPurpleRequestUiOps *ops;\n\tg_return_val_if_fail(action_count > 0, NULL);\n\tops = purple_request_get_ui_ops();\n\tif (ops != NULL && ops->request_action != NULL) {\n\t\tPurpleRequestInfo *info;\n\t\tinfo            = g_new0(PurpleRequestInfo, 1);\n\t\tinfo->type      = PURPLE_REQUEST_ACTION;\n\t\tinfo->handle    = handle;\n\t\tinfo->ui_handle = ops->request_action(title, primary, secondary,\n\t\t\t\t\t\t\t\t\t\t\t  default_action, account, who, conv,\n\t\t\t\t\t\t\t\t\t\t\t  user_data, action_count, actions);\n\t\thandles = g_list_append(handles, info);\n\t\treturn info->ui_handle;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 447}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_prefs_trigger_ui_callback_object(PurplePrefCallbackData *cb)\n{\n\tPurplePrefsUiOps *uiop = purple_prefs_get_ui_ops();\n\tgconstpointer value = NULL;\n\tPurplePrefType type = PURPLE_PREF_NONE;\n\ttype = uiop->get_type(cb->name);\n\tswitch (type) {\n\t\tcase PURPLE_PREF_INT:\n\t\t\tif (uiop->get_int) {\n\t\t\t\tvalue = GINT_TO_POINTER(uiop->get_int(cb->name));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_BOOLEAN:\n\t\t\tif (uiop->get_bool) {\n\t\t\t\tvalue = GINT_TO_POINTER(uiop->get_bool(cb->name));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_STRING:\n\t\tcase PURPLE_PREF_PATH:\n\t\t\tif (uiop->get_string) {\n\t\t\t\tvalue = uiop->get_string(cb->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_STRING_LIST:\n\t\tcase PURPLE_PREF_PATH_LIST:\n\t\t\tif (uiop->get_string_list) {\n\t\t\t\tvalue = uiop->get_string_list(cb->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_NONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpurple_debug_error(\"prefs\", \"Unexpected type = %i\\n\", type);\n\t}\n\tcb->func(cb->name, type, value, cb->data);\n}\n", "bug_type": null, "idx": 448}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin (PurplePlugin * plugin)\n{\n}\n", "bug_type": null, "idx": 449}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nx509_tls_peers_init(void)\n{\n\tgchar *poolpath;\n\tint ret;\n\t\n\tpoolpath = purple_certificate_pool_mkpath(&x509_tls_peers, NULL);\n\tret = purple_build_dir(poolpath, 0700); \n\tif (ret != 0)\n\t\tpurple_debug_info(\"certificate/tls_peers\",\n\t\t\t\t\"Could not create %s.  Certificates will not be cached.\\n\",\n\t\t\t\tpoolpath);\n\tg_free(poolpath);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 450}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_chat_settopic(PurpleBlistNode *node, gpointer data)\n{\n\tPurpleChat *chat;\n\tPurpleConnection *gc;\n\tSilcPurple sg;\n\tg_return_if_fail(PURPLE_BLIST_NODE_IS_CHAT(node));\n\tchat = (PurpleChat *) node;\n\tgc = purple_account_get_connection(chat->account);\n\tsg = gc->proto_data;\n\tsilc_client_command_call(sg->client, sg->conn, NULL, \"CMODE\",\n\t\t\t\t g_hash_table_lookup(chat->components, \"channel\"),\n\t\t\t\t \"+t\", NULL);\n}\n", "bug_type": null, "idx": 451}
{"project": "Pidgin", "target": 0, "func": " * the prefs list. They'll get cleaned up when the plugin is unloaded*/\nstatic void init_tmp_prefs(void) {\n\tGList *conf_ciphers, *tmp;\n\tconst PRUint16 *cipher;\n\tif (tmp_prefs) {\n\t\treturn;\n\t}\n\tconf_ciphers = get_current_cipher_list(FALSE);\n\tpurple_prefs_add_none(CIPHER_TMP_ROOT);\n\tfor (cipher = SSL_GetImplementedCiphers(); *cipher != 0; ++cipher) {\n\t\tgboolean found = FALSE;\n\t\tgchar *pref_name = g_strdup_printf(CIPHER_TMP, *cipher);\n\t\ttmp_prefs = g_list_prepend(tmp_prefs, pref_name);\n\t\ttmp = conf_ciphers;\n\t\twhile (tmp) {\n\t\t\tguint64 parsed = g_ascii_strtoull(tmp->data, NULL, 16);\n\t\t\tif (parsed == 0 || parsed > PR_UINT16_MAX) {\n\t\t\t\tpurple_debug_error(\"nss-prefs\",\n\t\t\t\t\t\t\"Cipher '%s' is not valid to init_tmp_pref.\\n\",\n\t\t\t\t\t\t(const char *) tmp->data);\n\t\t\t}\n\t\t\tif (parsed == *cipher) {\n\t\t\t\tfound = TRUE;\n\t\t\t\t/** Remove the entry since we're done with it */\n\t\t\t\tg_free(tmp->data);\n\t\t\t\tconf_ciphers = g_list_delete_link(conf_ciphers, tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp = tmp->next;\n\t\t}\n\t\tpurple_prefs_add_bool(pref_name, found);\n\t\tpurple_prefs_set_bool(pref_name, found);\n\t\tpurple_prefs_connect_callback(handle, pref_name,\n\t\t\t\tset_cipher_pref, (void *) cipher);\n\t}\n\ttmp_prefs = g_list_reverse(tmp_prefs);\n\tfor (tmp = conf_ciphers; tmp; tmp = g_list_delete_link(tmp, tmp)) {\n\t\tg_free(tmp->data);\n\t}\n}\n", "bug_type": null, "idx": 452}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conv_send_confirm(PurpleConversation *conv, const char *message)\n{\n\tchar *text;\n\tgpointer *data;\n\tg_return_if_fail(conv != NULL);\n\tg_return_if_fail(message != NULL);\n\tif (conv->ui_ops != NULL && conv->ui_ops->send_confirm != NULL)\n\t{\n\t\tconv->ui_ops->send_confirm(conv, message);\n\t\treturn;\n\t}\n\ttext = g_strdup_printf(\"You are about to send the following message:\\n%s\", message);\n\tdata = g_new0(gpointer, 2);\n\tdata[0] = conv;\n\tdata[1] = (gpointer)message;\n\tpurple_request_action(conv, NULL, _(\"Send Message\"), text, 0,\n\t\t\t\t\t\t  purple_conversation_get_account(conv), NULL, conv,\n\t\t\t\t\t\t  data, 2,\n\t\t\t\t\t\t  _(\"_Send Message\"), G_CALLBACK(purple_conv_send_confirm_cb),\n\t\t\t\t\t\t  _(\"Cancel\"), NULL);\n}\n", "bug_type": null, "idx": 453}
{"project": "Pidgin", "target": 0, "func": "static void\n_sync_contact_list(NMUser *user)\n{\n\t\n\t_remove_purple_buddies(user);\n\t_add_purple_buddies(user);\n\tuser->clist_synched = TRUE;\n}\n", "bug_type": null, "idx": 454}
{"project": "Pidgin", "target": 0, "func": "static void adium_logger_finalize(PurpleLog *log)\n{\n\tstruct adium_logger_data *data;\n\tg_return_if_fail(log != NULL);\n\tdata = log->logger_data;\n\tg_free(data->path);\n\tg_free(data);\n}\n", "bug_type": null, "idx": 455}
{"project": "Pidgin", "target": 0, "func": "void\npurple_prpl_got_attention_in_chat(PurpleConnection *gc, int id, const char *who, guint type_code)\n{\n\tgot_attention(gc, id, who, type_code);\n}\n", "bug_type": null, "idx": 456}
{"project": "Pidgin", "target": 0, "func": "static FinchLogViewer *display_log_viewer(struct log_viewer_hash_t *ht, GList *logs,\n\t\t\t\t\t\tconst char *title, int log_size)\n{\n\tFinchLogViewer *lv;\n\tchar *text;\n\tGntWidget *vbox, *hbox;\n\tGntWidget *size_label;\n\tif (logs == NULL)\n\t{\n\t\t\n\t\tconst char *log_preferences = NULL;\n\t\tif (ht == NULL) {\n\t\t\tif (!purple_prefs_get_bool(\"/purple/logging/log_system\"))\n\t\t\t\tlog_preferences = _(\"System events will only be logged if the \\\"Log all status changes to system log\\\" preference is enabled.\");\n\t\t} else {\n\t\t\tif (ht->type == PURPLE_LOG_IM) {\n\t\t\t\tif (!purple_prefs_get_bool(\"/purple/logging/log_ims\"))\n\t\t\t\t\tlog_preferences = _(\"Instant messages will only be logged if the \\\"Log all instant messages\\\" preference is enabled.\");\n\t\t\t} else if (ht->type == PURPLE_LOG_CHAT) {\n\t\t\t\tif (!purple_prefs_get_bool(\"/purple/logging/log_chats\"))\n\t\t\t\t\tlog_preferences = _(\"Chats will only be logged if the \\\"Log all chats\\\" preference is enabled.\");\n\t\t\t}\n\t\t\tg_free(ht->username);\n\t\t\tg_free(ht);\n\t\t}\n\t\tpurple_notify_info(NULL, title, _(\"No logs were found\"), log_preferences);\n\t\treturn NULL;\n\t}\n\tlv = g_new0(FinchLogViewer, 1);\n\tlv->logs = logs;\n\tif (ht != NULL)\n\t\tg_hash_table_insert(log_viewers, ht, lv);\n\t\n\tlv->window = gnt_vwindow_new(FALSE);\n\tgnt_box_set_title(GNT_BOX(lv->window), title);\n\tgnt_box_set_toplevel(GNT_BOX(lv->window), TRUE);\n\tgnt_box_set_pad(GNT_BOX(lv->window), 0);\n\tg_signal_connect(G_OBJECT(lv->window), \"destroy\", G_CALLBACK(destroy_cb), ht);\n\tvbox = gnt_vbox_new(FALSE);\n\tgnt_box_add_widget(GNT_BOX(lv->window), vbox);\n\t\n\ttext = g_strdup_printf(\"%s\", title);\n\tlv->label = gnt_label_new_with_format(text, GNT_TEXT_FLAG_BOLD);\n\tg_free(text);\n\tgnt_box_add_widget(GNT_BOX(vbox), lv->label);\n\thbox = gnt_hbox_new(FALSE);\n\tgnt_box_add_widget(GNT_BOX(vbox), hbox);\n\t\n\tlv->tree = gnt_tree_new();\n\tgnt_widget_set_size(lv->tree, 30, 0);\n\tpopulate_log_tree(lv);\n\tg_signal_connect (G_OBJECT(lv->tree), \"selection-changed\",\n\t\t\tG_CALLBACK (log_select_cb),\n\t\t\tlv);\n\tgnt_box_add_widget(GNT_BOX(hbox), lv->tree);\n\t\n\tlv->text = gnt_text_view_new();\n\tgnt_box_add_widget(GNT_BOX(hbox), lv->text);\n\tgnt_text_view_set_flag(GNT_TEXT_VIEW(lv->text), GNT_TEXT_VIEW_TOP_ALIGN);\n\thbox = gnt_hbox_new(FALSE);\n\tgnt_box_add_widget(GNT_BOX(vbox), hbox);\n\t\n\tif (log_size) {\n\t\tchar *sz_txt = purple_str_size_to_units(log_size);\n\t\ttext = g_strdup_printf(\"%s %s\", _(\"Total log size:\"), sz_txt);\n\t\tsize_label = gnt_label_new(text);\n\t\tgnt_box_add_widget(GNT_BOX(hbox), size_label);\n\t\tg_free(sz_txt);\n\t\tg_free(text);\n\t}\n\t\n\tgnt_box_add_widget(GNT_BOX(hbox), gnt_label_new(_(\"Scroll/Search: \")));\n\tlv->entry = gnt_entry_new(\"\");\n\tgnt_box_add_widget(GNT_BOX(hbox), lv->entry);\n\tg_signal_connect(GNT_ENTRY(lv->entry), \"activate\", G_CALLBACK(search_cb), lv);\n\tgnt_text_view_attach_scroll_widget(GNT_TEXT_VIEW(lv->text), lv->entry);\n\tgnt_text_view_attach_pager_widget(GNT_TEXT_VIEW(lv->text), lv->entry);\n\tgnt_widget_show(lv->window);\n\treturn lv;\n}\n", "bug_type": null, "idx": 457}
{"project": "Pidgin", "target": 0, "func": "static void set_editor_path (GtkWidget *button, GtkWidget *text_field)\n{\n\tconst char * path = gtk_entry_get_text((GtkEntry*)text_field);\n\tpurple_prefs_set_string(\"/plugins/gtk/musicmessaging/editor_path\", path);\n}\n", "bug_type": null, "idx": 458}
{"project": "Pidgin", "target": 0, "func": "PurpleContact *purple_buddy_get_contact(PurpleBuddy *buddy)\n{\n\tg_return_val_if_fail(buddy != NULL, NULL);\n\treturn PURPLE_CONTACT(PURPLE_BLIST_NODE(buddy)->parent);\n}\n", "bug_type": null, "idx": 459}
{"project": "Pidgin", "target": 0, "func": "static GSList *callbacks = NULL;\nstatic void close_stun_conn(struct stun_conn *sc) {\n\tif (sc->incb)\n\t\tpurple_input_remove(sc->incb);\n\tif (sc->timeout)\n\t\tpurple_timeout_remove(sc->timeout);\n\tif (sc->fd)\n\t\tclose(sc->fd);\n\tg_free(sc);\n}\n", "bug_type": null, "idx": 460}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_destroy(PurpleRequestField *field)\n{\n\tg_return_if_fail(field != NULL);\n\tg_free(field->id);\n\tg_free(field->label);\n\tg_free(field->type_hint);\n\tif (field->type == PURPLE_REQUEST_FIELD_STRING)\n\t{\n\t\tg_free(field->u.string.default_value);\n\t\tg_free(field->u.string.value);\n\t}\n\telse if (field->type == PURPLE_REQUEST_FIELD_CHOICE)\n\t{\n\t\tif (field->u.choice.labels != NULL)\n\t\t{\n\t\t\tg_list_foreach(field->u.choice.labels, (GFunc)g_free, NULL);\n\t\t\tg_list_free(field->u.choice.labels);\n\t\t}\n\t}\n\telse if (field->type == PURPLE_REQUEST_FIELD_LIST)\n\t{\n\t\tif (field->u.list.items != NULL)\n\t\t{\n\t\t\tg_list_foreach(field->u.list.items, (GFunc)g_free, NULL);\n\t\t\tg_list_free(field->u.list.items);\n\t\t}\n\t\tif (field->u.list.selected != NULL)\n\t\t{\n\t\t\tg_list_foreach(field->u.list.selected, (GFunc)g_free, NULL);\n\t\t\tg_list_free(field->u.list.selected);\n\t\t}\n\t\tg_hash_table_destroy(field->u.list.item_data);\n\t\tg_hash_table_destroy(field->u.list.selected_table);\n\t}\n\tg_free(field);\n}\n", "bug_type": null, "idx": 461}
{"project": "Pidgin", "target": 0, "func": "static void\nnew_node(PurpleBlistNode *node)\n{\n}\n", "bug_type": null, "idx": 462}
{"project": "Pidgin", "target": 0, "func": "};\nPurpleRoomlistUiOps *finch_roomlist_get_ui_ops(void)\n{\n\treturn &ui_ops;\n}\n", "bug_type": null, "idx": 463}
{"project": "Pidgin", "target": 0, "func": "static void\nnew_pounce(PurplePounce *pounce)\n{\n\tpurple_pounce_action_register(pounce, \"open-window\");\n\tpurple_pounce_action_register(pounce, \"popup-notify\");\n\tpurple_pounce_action_register(pounce, \"send-message\");\n\tpurple_pounce_action_register(pounce, \"execute-command\");\n\tpurple_pounce_action_register(pounce, \"play-sound\");\n\tupdate_pounces();\n}\n", "bug_type": null, "idx": 464}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_account_uninit(void)\n{\n\t\n\tg_hash_table_destroy(account_pref_wins);\n\tpurple_signals_disconnect_by_handle(pidgin_account_get_handle());\n\tpurple_signals_unregister_by_instance(pidgin_account_get_handle());\n}\n", "bug_type": null, "idx": 465}
{"project": "Pidgin", "target": 0, "func": "static void\nregex_clear_color(GtkWidget *w) {\n\tgtk_widget_modify_base(w, GTK_STATE_NORMAL, NULL);\n}\n", "bug_type": null, "idx": 466}
{"project": "Pidgin", "target": 0, "func": "static GList *\nget_element_devices(const gchar *element_name)\n{\n\tGList *ret = NULL;\n\tGstElement *element;\n\tGObjectClass *klass;\n#if !GST_CHECK_VERSION(1,0,0)\n\tGstPropertyProbe *probe;\n\tconst GParamSpec *pspec;\n#endif\n\tret = g_list_prepend(ret, (gpointer)_(\"Default\"));\n\tret = g_list_prepend(ret, \"\");\n\tif (!strcmp(element_name, \"<custom>\") || (*element_name == '\\0')) {\n\t\treturn g_list_reverse(ret);\n\t}\n\telement = gst_element_factory_make(element_name, \"test\");\n\tif(!element) {\n\t\tpurple_debug_info(\"vvconfig\", \"'%s' - unable to find element\\n\", element_name);\n\t\treturn g_list_reverse(ret);\n\t}\n\tklass = G_OBJECT_GET_CLASS (element);\n\tif(!klass) {\n\t\tpurple_debug_info(\"vvconfig\", \"'%s' - unable to find G_Object Class\\n\", element_name);\n\t\treturn g_list_reverse(ret);\n\t}\n#if GST_CHECK_VERSION(1,0,0)\n\tpurple_debug_info(\"vvconfig\", \"'%s' - gstreamer-1.0 doesn't suport \"\n\t\t\"property probing\\n\", element_name);\n#else\n\tif (!g_object_class_find_property(klass, \"device\") ||\n\t\t\t!GST_IS_PROPERTY_PROBE(element) ||\n\t\t\t!(probe = GST_PROPERTY_PROBE(element)) ||\n\t\t\t!(pspec = gst_property_probe_get_property(probe, \"device\"))) {\n\t\tpurple_debug_info(\"vvconfig\", \"'%s' - no device\\n\", element_name);\n\t} else {\n\t\tgsize n;\n\t\tGValueArray *array;\n\t\t\n\t\tif (g_object_class_find_property (klass, \"autoprobe\")) {\n\t\t\tg_object_set (G_OBJECT (element), \"autoprobe\", FALSE, NULL);\n\t\t\tif (g_object_class_find_property (klass, \"autoprobe-fps\")) {\n\t\t\t\tg_object_set (G_OBJECT (element), \"autoprobe-fps\", FALSE, NULL);\n\t\t\t}\n\t\t}\n\t\tarray = gst_property_probe_probe_and_get_values (probe, pspec);\n\t\tif (array == NULL) {\n\t\t\tpurple_debug_info(\"vvconfig\", \"'%s' has no devices\\n\", element_name);\n\t\t\treturn g_list_reverse(ret);\n\t\t}\n\t\tfor (n=0; n < array->n_values; ++n) {\n\t\t\tGValue *device;\n\t\t\tconst gchar *name;\n\t\t\tconst gchar *device_name;\nG_GNUC_BEGIN_IGNORE_DEPRECATIONS\n\t\t\t\n\t\t\tdevice = g_value_array_get_nth(array, n);\nG_GNUC_END_IGNORE_DEPRECATIONS\n\t\t\tg_object_set_property(G_OBJECT(element), \"device\", device);\n\t\t\tif (gst_element_set_state(element, GST_STATE_READY)\n\t\t\t\t\t!= GST_STATE_CHANGE_SUCCESS) {\n\t\t\t\tpurple_debug_warning(\"vvconfig\",\n\t\t\t\t\t\t\"Error changing state of %s\\n\",\n\t\t\t\t\t\telement_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg_object_get(G_OBJECT(element), \"device-name\", &name, NULL);\n\t\t\tdevice_name = g_value_get_string(device);\n\t\t\tif (name == NULL)\n\t\t\t\tname = _(\"Unknown\");\n\t\t\tpurple_debug_info(\"vvconfig\", \"Found device %s : %s for %s\\n\",\n\t\t\t\t\tdevice_name, name, element_name);\n\t\t\tret = g_list_prepend(ret, (gpointer)name);\n\t\t\tret = g_list_prepend(ret, (gpointer)device_name);\n\t\t\tgst_element_set_state(element, GST_STATE_NULL);\n\t\t}\n\t}\n#endif\n\tgst_object_unref(element);\n\treturn g_list_reverse(ret);\n}\n", "bug_type": null, "idx": 467}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conv_chat_add_users(PurpleConvChat *chat, GList *users, GList *extra_msgs,\n\t\t\t\t\t\t GList *flags, gboolean new_arrivals)\n{\n\tPurpleConversation *conv;\n\tPurpleConversationUiOps *ops;\n\tPurpleConvChatBuddy *cbuddy;\n\tPurpleConnection *gc;\n\tPurplePluginProtocolInfo *prpl_info;\n\tGList *ul, *fl;\n\tGList *cbuddies = NULL;\n\tg_return_if_fail(chat  != NULL);\n\tg_return_if_fail(users != NULL);\n\tconv = purple_conv_chat_get_conversation(chat);\n\tops  = purple_conversation_get_ui_ops(conv);\n\tgc = purple_conversation_get_gc(conv);\n\tg_return_if_fail(gc != NULL);\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(purple_connection_get_prpl(gc));\n\tg_return_if_fail(prpl_info != NULL);\n\tul = users;\n\tfl = flags;\n\twhile ((ul != NULL) && (fl != NULL)) {\n\t\tconst char *user = (const char *)ul->data;\n\t\tconst char *alias = user;\n\t\tgboolean quiet;\n\t\tPurpleConvChatBuddyFlags flag = GPOINTER_TO_INT(fl->data);\n\t\tconst char *extra_msg = (extra_msgs ? extra_msgs->data : NULL);\n\t\tif(!(prpl_info->options & OPT_PROTO_UNIQUE_CHATNAME)) {\n\t\t\tif (purple_strequal(chat->nick, purple_normalize(conv->account, user))) {\n\t\t\t\tconst char *alias2 = purple_account_get_alias(conv->account);\n\t\t\t\tif (alias2 != NULL)\n\t\t\t\t\talias = alias2;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst char *display_name = purple_connection_get_display_name(gc);\n\t\t\t\t\tif (display_name != NULL)\n\t\t\t\t\t\talias = display_name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tPurpleBuddy *buddy;\n\t\t\t\tif ((buddy = purple_find_buddy(gc->account, user)) != NULL)\n\t\t\t\t\talias = purple_buddy_get_contact_alias(buddy);\n\t\t\t}\n\t\t}\n\t\tquiet = GPOINTER_TO_INT(purple_signal_emit_return_1(purple_conversations_get_handle(),\n\t\t\t\t\t\t \"chat-buddy-joining\", conv, user, flag)) ||\n\t\t\t\tpurple_conv_chat_is_user_ignored(chat, user);\n\t\tcbuddy = purple_conv_chat_cb_new(user, alias, flag);\n\t\tcbuddy->buddy = purple_find_buddy(conv->account, user) != NULL;\n\t\tchat->in_room = g_list_prepend(chat->in_room, cbuddy);\n\t\tg_hash_table_replace(chat->users, g_strdup(cbuddy->name), cbuddy);\n\t\tcbuddies = g_list_prepend(cbuddies, cbuddy);\n\t\tif (!quiet && new_arrivals) {\n\t\t\tchar *alias_esc = g_markup_escape_text(alias, -1);\n\t\t\tchar *tmp;\n\t\t\tif (extra_msg == NULL)\n\t\t\t\ttmp = g_strdup_printf(_(\"%s entered the room.\"), alias_esc);\n\t\t\telse {\n\t\t\t\tchar *extra_msg_esc = g_markup_escape_text(extra_msg, -1);\n\t\t\t\ttmp = g_strdup_printf(_(\"%s [<I>%s</I>] entered the room.\"),\n\t\t\t\t                      alias_esc, extra_msg_esc);\n\t\t\t\tg_free(extra_msg_esc);\n\t\t\t}\n\t\t\tg_free(alias_esc);\n\t\t\tpurple_conversation_write(conv, NULL, tmp,\n\t\t\t\t\tPURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_NO_LINKIFY,\n\t\t\t\t\ttime(NULL));\n\t\t\tg_free(tmp);\n\t\t}\n\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\t\t\t \"chat-buddy-joined\", conv, user, flag, new_arrivals);\n\t\tul = ul->next;\n\t\tfl = fl->next;\n\t\tif (extra_msgs != NULL)\n\t\t\textra_msgs = extra_msgs->next;\n\t}\n\tcbuddies = g_list_sort(cbuddies, (GCompareFunc)purple_conv_chat_cb_compare);\n\tif (ops != NULL && ops->chat_add_users != NULL)\n\t\tops->chat_add_users(conv, cbuddies, new_arrivals);\n\tg_list_free(cbuddies);\n}\n", "bug_type": null, "idx": 468}
{"project": "Pidgin", "target": 0, "func": "static void\nx509_tls_cached_user_auth_cb (x509_tls_cached_ua_ctx *c, gint id)\n{\n\tPurpleCertificateVerificationRequest *vrq;\n\tPurpleCertificatePool *tls_peers;\n\tg_return_if_fail(c);\n\tg_return_if_fail(c->vrq);\n\tvrq = c->vrq;\n\tx509_tls_cached_ua_ctx_free(c);\n\ttls_peers = purple_certificate_find_pool(\"x509\",\"tls_peers\");\n\tif (2 == id) {\n\t\tgchar *cache_id = vrq->subject_name;\n\t\tpurple_debug_info(\"certificate/x509/tls_cached\",\n\t\t\t\t  \"User ACCEPTED cert\\nCaching first in chain for future use as %s...\\n\",\n\t\t\t\t  cache_id);\n\t\tpurple_certificate_pool_store(tls_peers, cache_id,\n\t\t\t\t\t      vrq->cert_chain->data);\n\t\tpurple_certificate_verify_complete(vrq,\n\t\t\t\t\t\t   PURPLE_CERTIFICATE_VALID);\n\t} else {\n\t\tpurple_debug_warning(\"certificate/x509/tls_cached\",\n\t\t\t\t  \"User REJECTED cert\\n\");\n\t\tpurple_certificate_verify_complete(vrq,\n\t\t\t\t\t\t   PURPLE_CERTIFICATE_INVALID);\n\t}\n}\n", "bug_type": null, "idx": 469}
{"project": "Pidgin", "target": 0, "func": "const char *\nnm_contact_get_userid(NMContact * contact)\n{\n\tNMUserRecord *user_record;\n\tconst char *userid = NULL;\n\tif (contact == NULL)\n\t\treturn NULL;\n\tuser_record = nm_contact_get_user_record(contact);\n\tif (user_record) {\n\t\tuserid = nm_user_record_get_userid(user_record);\n\t}\n\treturn userid;\n}\n", "bug_type": null, "idx": 470}
{"project": "Pidgin", "target": 0, "func": "static void\nperl_pref_cb(const char *name, PurplePrefType type, gconstpointer value,\n\t\t\t gpointer data)\n{\n\tPurplePerlPrefsHandler *handler = data;\n\tdSP;\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(sp);\n\tXPUSHs(sv_2mortal(newSVpv(name, 0)));\n\tXPUSHs(sv_2mortal(newSViv(type)));\n\tswitch(type) {\n\t\tcase PURPLE_PREF_INT:\n\t\t\tXPUSHs(sv_2mortal(newSViv(GPOINTER_TO_INT(value))));\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_BOOLEAN:\n\t\t\tXPUSHs((GPOINTER_TO_INT(value) == FALSE) ? &PL_sv_no : &PL_sv_yes);\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_STRING:\n\t\tcase PURPLE_PREF_PATH:\n\t\t\tXPUSHs(sv_2mortal(newSVGChar(value)));\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_STRING_LIST:\n\t\tcase PURPLE_PREF_PATH_LIST:\n\t\t\t{\n\t\t\t\tAV* av = newAV();\n\t\t\t\tconst GList *l = value;\n\t\t\t\t\n\t\t\t\twhile (l && l->next) l = l->next;\n\t\t\t\twhile (l) {\n\t\t\t\t\tav_push(av, sv_2mortal(newSVGChar(l->data)));\n\t\t\t\t\tl = l->prev;\n\t\t\t\t}\n\t\t\t\tXPUSHs(sv_2mortal(newRV_noinc((SV *) av)));\n\t\t\t} break;\n\t\tdefault:\n\t\tcase PURPLE_PREF_NONE:\n\t\t\tXPUSHs(&PL_sv_undef);\n\t\t\tbreak;\n\t}\n\tXPUSHs((SV *)handler->data);\n\tPUTBACK;\n\tcall_sv(handler->callback, G_EVAL | G_VOID | G_DISCARD);\n\tSPAGAIN;\n\tif (SvTRUE(ERRSV)) {\n\t\tpurple_debug_error(\"perl\",\n\t\t                 \"Perl prefs callback function exited abnormally: %s\\n\",\n\t\t                 SvPVutf8_nolen(ERRSV));\n\t}\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n}\n", "bug_type": null, "idx": 471}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_chat_prv_add(SilcPurpleCharPrv p, PurpleRequestFields *fields)\n{\n\tSilcPurple sg = p->sg;\n\tchar tmp[512];\n\tPurpleRequestField *f;\n\tconst char *name, *passphrase, *alias;\n\tGHashTable *comp;\n\tPurpleGroup *g;\n\tPurpleChat *cn;\n\tf = purple_request_fields_get_field(fields, \"name\");\n\tname = purple_request_field_string_get_value(f);\n\tif (!name) {\n\t\tsilc_free(p);\n\t\treturn;\n\t}\n\tf = purple_request_fields_get_field(fields, \"passphrase\");\n\tpassphrase = purple_request_field_string_get_value(f);\n\tf = purple_request_fields_get_field(fields, \"alias\");\n\talias = purple_request_field_string_get_value(f);\n\t\n\tg_snprintf(tmp, sizeof(tmp), \"%s [Private Group]\", name);\n\tcomp = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\tg_hash_table_replace(comp, g_strdup(\"channel\"), g_strdup(tmp));\n\tg_hash_table_replace(comp, g_strdup(\"passphrase\"), g_strdup(passphrase));\n\tcn = purple_chat_new(sg->account, alias, comp);\n\tg = (PurpleGroup *)p->c->node.parent;\n\tpurple_blist_add_chat(cn, g, (PurpleBlistNode *)p->c);\n\t\n\tpurple_blist_node_set_string((PurpleBlistNode *)cn, \"parentch\", p->channel);\n\t\n\tsilcpurple_chat_join(sg->gc, comp);\n\tsilc_free(p);\n}\n", "bug_type": null, "idx": 472}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_buddy_keyagr_do(PurpleConnection *gc, const char *name,\n\t\t\t \t\t\t gboolean force_local);\ntypedef struct {\n\tchar *nick;\n\tPurpleConnection *gc;\n} *SilcPurpleResolve;\nstatic void\nsilcpurple_buddy_keyagr_do(PurpleConnection *gc, const char *name,\n\t\t\t gboolean force_local)\n{\n\tSilcPurple sg = gc->proto_data;\n\tSilcClientEntry *clients;\n\tSilcUInt32 clients_count;\n\tchar *local_ip = NULL, *remote_ip = NULL;\n\tgboolean local = TRUE;\n\tchar *nickname;\n\tSilcPurpleKeyAgr a;\n\tif (!sg->conn || !name)\n\t\treturn;\n\tif (!silc_parse_userfqdn(name, &nickname, NULL))\n\t\treturn;\n\t\n\tclients = silc_client_get_clients_local(sg->client, sg->conn, nickname, name,\n\t\t\t\t\t\t&clients_count);\n\tif (!clients) {\n\t\t\n\t\tSilcPurpleResolve r = silc_calloc(1, sizeof(*r));\n\t\tif (!r)\n\t\t\treturn;\n\t\tr->nick = g_strdup(name);\n\t\tr->gc = gc;\n\t\tsilc_client_get_clients(sg->client, sg->conn, nickname, NULL,\n\t\t\t\t\tsilcpurple_buddy_keyagr_resolved, r);\n\t\tsilc_free(nickname);\n\t\treturn;\n\t}\n\t\n\tif (silc_net_check_local_by_sock(sg->conn->sock->sock, NULL, &local_ip)) {\n\t\t\n\t\tif (!force_local && silcpurple_ip_is_private(local_ip)) {\n\t\t\tlocal = FALSE;\n\t\t\t\n\t\t\tif (silc_net_check_host_by_sock(sg->conn->sock->sock, NULL,\n\t\t\t\t\t\t\t&remote_ip))\n\t\t\t\tif (silcpurple_ip_is_private(remote_ip))\n\t\t\t\t\t\n\t\t\t\t\tlocal = TRUE;\n\t\t}\n\t}\n\tif (force_local)\n\t\tlocal = TRUE;\n\tif (local && !local_ip)\n\t\tlocal_ip = silc_net_localip();\n\ta = silc_calloc(1, sizeof(*a));\n\tif (!a)\n\t\treturn;\n\ta->responder = local;\n\t\n\tsilc_client_send_key_agreement(sg->client, sg->conn, clients[0],\n\t\t\t\t       local ? local_ip : NULL, NULL, 0, 60,\n\t\t\t\t       silcpurple_buddy_keyagr_cb, a);\n\tsilc_free(local_ip);\n\tsilc_free(remote_ip);\n\tsilc_free(clients);\n}\n", "bug_type": null, "idx": 473}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_menu_size_request(GntWidget *widget)\n{\n\tGntMenu *menu = GNT_MENU(widget);\n\tif (menu->type == GNT_MENU_TOPLEVEL) {\n\t\twidget->priv.height = 1;\n\t\twidget->priv.width = getmaxx(stdscr);\n\t} else {\n\t\torg_size_request(widget);\n\t\twidget->priv.height = g_list_length(menu->list) + 2;\n\t}\n}\n", "bug_type": null, "idx": 474}
{"project": "Pidgin", "target": 0, "func": "int\nbos_modfirst(OscarData *od, aim_module_t *mod)\n{\n\tmod->family = SNAC_FAMILY_BOS;\n\tmod->version = 0x0001;\n\tmod->toolid = 0x0110;\n\tmod->toolversion = 0x0629;\n\tmod->flags = 0;\n\tstrncpy(mod->name, \"bos\", sizeof(mod->name));\n\tmod->snachandler = snachandler;\n\treturn 0;\n}\n", "bug_type": null, "idx": 475}
{"project": "Pidgin", "target": 0, "func": "static int\npidgin_x_error_handler(Display *display, XErrorEvent *event)\n{\n\tconst gchar *error_type;\n\tswitch (event->error_code) {\n#define XERRORCASE(type) case type: error_type = #type; break\n\t\tXERRORCASE(BadAccess);\n\t\tXERRORCASE(BadAlloc);\n\t\tXERRORCASE(BadAtom);\n\t\tXERRORCASE(BadColor);\n\t\tXERRORCASE(BadCursor);\n\t\tXERRORCASE(BadDrawable);\n\t\tXERRORCASE(BadFont);\n\t\tXERRORCASE(BadGC);\n\t\tXERRORCASE(BadIDChoice);\n\t\tXERRORCASE(BadImplementation);\n\t\tXERRORCASE(BadLength);\n\t\tXERRORCASE(BadMatch);\n\t\tXERRORCASE(BadName);\n\t\tXERRORCASE(BadPixmap);\n\t\tXERRORCASE(BadRequest);\n\t\tXERRORCASE(BadValue);\n\t\tXERRORCASE(BadWindow);\n#undef XERRORCASE\n\t\tdefault:\n\t\t\terror_type = \"unknown\";\n\t\t\tbreak;\n\t}\n\tpurple_debug_error(\"media\", \"A %s Xlib error has occurred. \"\n\t\t\t\"The program would normally crash now.\\n\",\n\t\t\terror_type);\n\treturn 0;\n}\n", "bug_type": null, "idx": 476}
{"project": "Pidgin", "target": 1, "func": "char* mxit_convert_markup_tx( const char* message, int* msgtype )\n{\n\tGString*\t\t\tmx;\n\tstruct tag*\t\t\ttag;\n\tGList*\t\t\t\tentry;\n\tGList*\t\t\t\ttagstack\t= NULL;\n\tchar*\t\t\t\treply;\n\tchar\t\t\t\tcolor[8];\n\tint\t\t\t\t\tlen\t\t\t= strlen ( message );\n\tint\t\t\t\t\ti;\n#ifdef MXIT_DEBUG_MARKUP\n\tpurple_debug_info( MXIT_PLUGIN_ID, \"Markup TX (original): '%s'\\n\", message );\n#endif\n\t\n\t\n\tmx = g_string_sized_new( len );\n\t\n\tfor ( i = 0; i < len; i++ ) {\n\t\tswitch ( message[i] ) {\n\t\t\tcase '<' :\n\t\t\t\tif ( purple_str_has_prefix( &message[i], \"<b>\" ) || purple_str_has_prefix( &message[i], \"</b>\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\tg_string_append_c( mx, '*' );\n\t\t\t\t}\n\t\t\t\telse if ( purple_str_has_prefix( &message[i], \"<i>\" ) || purple_str_has_prefix( &message[i], \"</i>\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\tg_string_append_c( mx, '/' );\n\t\t\t\t}\n\t\t\t\telse if ( purple_str_has_prefix( &message[i], \"<u>\" ) || purple_str_has_prefix( &message[i], \"</u>\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\tg_string_append_c( mx, '_' );\n\t\t\t\t}\n\t\t\t\telse if ( purple_str_has_prefix( &message[i], \"<br>\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\tg_string_append_c( mx, '\\n' );\n\t\t\t\t}\n\t\t\t\telse if ( purple_str_has_prefix( &message[i], \"<font size=\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\tint fontsize;\n\t\t\t\t\ttag = g_new0( struct tag, 1 );\n\t\t\t\t\ttag->type = MXIT_TAG_SIZE;\n\t\t\t\t\ttagstack = g_list_prepend( tagstack, tag );\n\t\t\t\t\t// TODO: implement size control\n\t\t\t\t\tif ( sscanf( &message[i+12], \"%i\", &fontsize ) ) {\n\t\t\t\t\t\tpurple_debug_info( MXIT_PLUGIN_ID, \"Font size set to %i\\n\", fontsize );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( purple_str_has_prefix( &message[i], \"<font color=\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\ttag = g_new0( struct tag, 1 );\n\t\t\t\t\ttag->type = MXIT_TAG_COLOR;\n\t\t\t\t\ttagstack = g_list_append( tagstack, tag );\n\t\t\t\t\tmemset( color, 0x00, sizeof( color ) );\n\t\t\t\t\tmemcpy( color, &message[i + 13], 7 );\n\t\t\t\t\tg_string_append( mx, color );\n\t\t\t\t}\n\t\t\t\telse if ( purple_str_has_prefix( &message[i], \"</font>\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\tentry = g_list_last( tagstack );\n\t\t\t\t\tif ( entry ) {\n\t\t\t\t\t\ttag = entry->data;\n\t\t\t\t\t\tif ( tag->type == MXIT_TAG_COLOR ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tg_string_append( mx, \"#??????\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( tag->type == MXIT_TAG_SIZE ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// TODO: implement size control\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttagstack = g_list_remove( tagstack, tag );\n\t\t\t\t\t\tg_free( tag );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( purple_str_has_prefix( &message[i], \"<IMG ID=\" ) ) {\n\t\t\t\t\t\n\t\t\t\t\tint imgid;\n\t\t\t\t\tif ( sscanf( &message[i+9], \"%i\", &imgid ) ) {\n\t\t\t\t\t\tinline_image_add( mx, imgid );\n\t\t\t\t\t\t*msgtype = CP_MSGTYPE_COMMAND;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor ( i++; ( i < len ) && ( message[i] != '>' ) ; i++ );\n\t\t\t\tbreak;\n\t\t\tcase '*' :\t\n\t\t\tcase '_' :\t\n\t\t\tcase '/' :\t\n\t\t\tcase '#' :\t\n\t\t\tcase '$' :\t\n\t\t\tcase '\\\\' :\t\n\t\t\t\tg_string_append( mx, \"\\\\\" );\t\t\t\t\n\t\t\t\tg_string_append_c( mx, message[i] );\t\t\n\t\t\t\tbreak;\n\t\t\tcase '.' : \n\t\t\t\tif ( i + 1 < len ) {\n\t\t\t\t\tif ( ( message[i+1] == '+' ) || ( message[i+1] == '-' ) )\n\t\t\t\t\t\tg_string_append( mx, \"\\\\.\" );\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\tg_string_append_c( mx, '.' );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tg_string_append_c( mx, '.' );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c( mx, message[i] );\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treply = purple_unescape_html( mx->str );\n\tg_string_free( mx, TRUE );\n#ifdef MXIT_DEBUG_MARKUP\n\tpurple_debug_info( MXIT_PLUGIN_ID, \"Markup TX (converted): '%s'\\n\", reply );\n#endif\n\treturn reply;\n}\n", "bug_type": "CVE-2016-2380", "idx": 477}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nmove_max_value(GntBindable *bindable, GList *null)\n{\n\tGntSlider *slider = GNT_SLIDER(bindable);\n\tgnt_slider_set_value(slider, slider->max);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 478}
{"project": "Pidgin", "target": 0, "func": "int main(int argc, char *argv[])\n{\n\tsignal(SIGPIPE, SIG_IGN);\n#if !GLIB_CHECK_VERSION(2, 32, 0)\n\t\n\tg_thread_init(NULL);\n#endif\n\tg_set_prgname(\"Finch\");\n\tg_set_application_name(_(\"Finch\"));\n\tif (gnt_start(&argc, &argv)) {\n\t\tgnt_main();\n#ifdef STANDALONE\n\t\tpurple_core_quit();\n#endif\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 479}
{"project": "Pidgin", "target": 0, "func": "static char *\nsnarf_locale_from_key (const char *key)\n{\n\tconst char *brace;\n\tchar *locale, *p;\n\tbrace = strchr (key, '[');\n\tif (brace == NULL)\n\t\treturn NULL;\n\tlocale = g_strdup (brace + 1);\n\tif (*locale == '\\0') {\n\t\tg_free (locale);\n\t\treturn NULL;\n\t}\n\tp = strchr (locale, ']');\n\tif (p == NULL) {\n\t\tg_free (locale);\n\t\treturn NULL;\n\t}\n\t*p = '\\0';\n\treturn locale;\n}\n", "bug_type": null, "idx": 480}
{"project": "Pidgin", "target": 0, "func": "gboolean finch_sound_is_enabled(void)\n{\n\tconst char *pref = make_pref(\"/method\");\n\tconst char *method = purple_prefs_get_string(pref);\n\tif (!method)\n\t\treturn FALSE;\n\tif (strcmp(method, \"nosound\") == 0)\n\t\treturn FALSE;\n\tif (purple_prefs_get_int(make_pref(\"/volume\")) <= 0)\n\t\treturn FALSE;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 481}
{"project": "Pidgin", "target": 0, "func": "static void set_versions(gboolean force_default) {\n#if NSS_VMAJOR > 3 || ( NSS_VMAJOR == 3 && NSS_VMINOR >= 14 )\n\tSSLVersionRange supported, enabled;\n\t\n\tif ((SSL_VersionRangeGetSupported(ssl_variant_stream, &supported) == SECSuccess) &&\n\t\t\t(SSL_VersionRangeGetDefault(ssl_variant_stream, &enabled) == SECSuccess)) {\n\t\tPRUint16 tmp;\n\t\t\n\t\tif (!default_versions) {\n\t\t\tdefault_versions = g_new0(SSLVersionRange, 1);\n\t\t\tdefault_versions->min = enabled.min;\n\t\t\tdefault_versions->max = enabled.max;\n\t\t}\n\t\tif (force_default) {\n\t\t\ttmp = default_versions->min;\n\t\t} else {\n\t\t\ttmp = purple_prefs_get_int(MIN_TLS);\n\t\t}\n\t\tif (tmp > 0) {\n\t\t\tenabled.min = tmp;\n\t\t}\n\t\tif (force_default) {\n\t\t\ttmp = default_versions->max;\n\t\t} else {\n\t\t\ttmp = purple_prefs_get_int(MAX_TLS);\n\t\t}\n\t\tif (tmp > 0) {\n\t\t\tenabled.max = tmp;\n\t\t}\n\t\tif (SSL_VersionRangeSetDefault(ssl_variant_stream, &enabled) == SECSuccess) {\n\t\t\tpurple_debug_info(\"nss-prefs\", \"Changed allowed TLS versions to \"\n\t\t\t\t\t\"0x%04hx through 0x%04hx\\n\", enabled.min, enabled.max);\n\t\t} else {\n\t\t\tpurple_debug_error(\"nss-prefs\", \"Error setting allowed TLS versions to \"\n\t\t\t\t\t\"0x%04hx through 0x%04hx\\n\", enabled.min, enabled.max);\n\t\t}\n\t}\n#else\n\tpurple_debug_error(\"nss-prefs\", \"Unable set SSL/TLS Versions\\n\");\n#endif \n}\n", "bug_type": null, "idx": 482}
{"project": "Pidgin", "target": 0, "func": "void\npurple_blist_update_buddy_icon(PurpleBuddy *buddy)\n{\n\tpurple_blist_update_node_icon((PurpleBlistNode *)buddy);\n}\n", "bug_type": null, "idx": 483}
{"project": "Pidgin", "target": 0, "func": " */\nvoid gg_tvbuilder_free(gg_tvbuilder_t *tvb)\n{\n\tif (tvb == NULL)\n\t\treturn;\n\tfree(tvb->buffer);\n\tfree(tvb);\n}\n", "bug_type": null, "idx": 484}
{"project": "Pidgin", "target": 0, "func": "static void\nsend_button_cb(GtkButton *button, PidginConversation *gtkconv)\n{\n\tg_signal_emit_by_name(gtkconv->entry, \"message_send\");\n}\n", "bug_type": null, "idx": 485}
{"project": "Pidgin", "target": 0, "func": "static PurpleCmdRet silcpurple_cmd_chat_topic(PurpleConversation *conv,\n\t\tconst char *cmd, char **args, char **error, void *data)\n{\n\tPurpleConnection *gc;\n\tint id = 0;\n\tchar *buf, *tmp, *tmp2;\n\tconst char *topic;\n\tgc = purple_conversation_get_gc(conv);\n\tid = purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv));\n\tif (gc == NULL || id == 0)\n\t\treturn PURPLE_CMD_RET_FAILED;\n\tif (!args || !args[0]) {\n\t\ttopic = purple_conv_chat_get_topic (PURPLE_CONV_CHAT(conv));\n\t\tif (topic) {\n\t\t\ttmp = g_markup_escape_text(topic, -1);\n\t\t\ttmp2 = purple_markup_linkify(tmp);\n\t\t\tbuf = g_strdup_printf(_(\"current topic is: %s\"), tmp2);\n\t\t\tg_free(tmp);\n\t\t\tg_free(tmp2);\n\t\t} else\n\t\t\tbuf = g_strdup(_(\"No topic is set\"));\n\t\tpurple_conv_chat_write(PURPLE_CONV_CHAT(conv), gc->account->username, buf,\n\t\t\t\t\t\t\t PURPLE_MESSAGE_SYSTEM|PURPLE_MESSAGE_NO_LOG, time(NULL));\n\t\tg_free(buf);\n\t}\n\tif (args && args[0] && (strlen(args[0]) > 255)) {\n\t\t*error = g_strdup(_(\"Topic too long\"));\n\t\treturn PURPLE_CMD_RET_FAILED;\n\t}\n\tsilcpurple_chat_set_topic(gc, id, args ? args[0] : NULL);\n\treturn PURPLE_CMD_RET_OK;\n}\n", "bug_type": null, "idx": 486}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_prefs_show(void)\n{\n\tGtkWidget *vbox;\n\tGtkWidget *notebook;\n\tGtkWidget *button;\n\tif (prefs) {\n\t\tgtk_window_present(GTK_WINDOW(prefs));\n\t\treturn;\n\t}\n\t\n\t\n\t\n\t\n\tprefs = pidgin_create_dialog(_(\"Preferences\"), PIDGIN_HIG_BORDER, \"preferences\", FALSE);\n\tg_signal_connect(G_OBJECT(prefs), \"destroy\",\n\t\t\t\t\t G_CALLBACK(delete_prefs), NULL);\n\tvbox = pidgin_dialog_get_vbox_with_properties(GTK_DIALOG(prefs), FALSE, PIDGIN_HIG_BORDER);\n\t\n\tprefsnotebook = notebook = gtk_notebook_new ();\n\tgtk_notebook_set_tab_pos(GTK_NOTEBOOK(notebook), GTK_POS_LEFT);\n\tgtk_box_pack_start(GTK_BOX (vbox), notebook, FALSE, FALSE, 0);\n\tgtk_widget_show(prefsnotebook);\n\tbutton = pidgin_dialog_add_button(GTK_DIALOG(prefs), GTK_STOCK_CLOSE, NULL, NULL);\n\tg_signal_connect_swapped(G_OBJECT(button), \"clicked\",\n\t\t\t\t\t\t\t G_CALLBACK(gtk_widget_destroy), prefs);\n\tprefs_notebook_init();\n\t\n\tprefs_themes_refresh();\n\t\n\tgtk_widget_show(prefs);\n}\n", "bug_type": null, "idx": 487}
{"project": "Pidgin", "target": 0, "func": "static void\ngg_create_menu(FinchConv *ggc)\n{\n\tGntWidget *menu, *sub;\n\tGntMenuItem *item;\n\tggc->menu = menu = gnt_menu_new(GNT_MENU_TOPLEVEL);\n\tgnt_window_set_menu(GNT_WINDOW(ggc->window), GNT_MENU(menu));\n\titem = gnt_menuitem_new(_(\"Conversation\"));\n\tgnt_menu_add_item(GNT_MENU(menu), item);\n\tsub = gnt_menu_new(GNT_MENU_POPUP);\n\tgnt_menuitem_set_submenu(item, GNT_MENU(sub));\n\titem = gnt_menuitem_new(_(\"Clear Scrollback\"));\n\tgnt_menu_add_item(GNT_MENU(sub), item);\n\tgnt_menuitem_set_callback(item, clear_scrollback_cb, ggc);\n\titem = gnt_menuitem_check_new(_(\"Show Timestamps\"));\n\tgnt_menuitem_check_set_checked(GNT_MENU_ITEM_CHECK(item),\n\t\tpurple_prefs_get_bool(PREF_ROOT \"/timestamps\"));\n\tgnt_menu_add_item(GNT_MENU(sub), item);\n\tgnt_menuitem_set_callback(item, toggle_timestamps_cb, ggc);\n\tif (purple_conversation_get_type(ggc->active_conv) == PURPLE_CONV_TYPE_IM) {\n\t\tPurpleAccount *account = purple_conversation_get_account(ggc->active_conv);\n\t\tPurpleConnection *gc = purple_account_get_connection(account);\n\t\tPurplePluginProtocolInfo *pinfo =\n\t\t\tgc ? PURPLE_PLUGIN_PROTOCOL_INFO(purple_connection_get_prpl(gc)) : NULL;\n\t\tif (pinfo && pinfo->get_info) {\n\t\t\titem = gnt_menuitem_new(_(\"Get Info\"));\n\t\t\tgnt_menu_add_item(GNT_MENU(sub), item);\n\t\t\tgnt_menuitem_set_callback(item, get_info_cb, ggc);\n\t\t}\n\t\titem = gnt_menuitem_new(_(\"Add Buddy Pounce...\"));\n\t\tgnt_menu_add_item(GNT_MENU(sub), item);\n\t\tgnt_menuitem_set_callback(item, add_pounce_cb, ggc);\n\t\tif (pinfo && pinfo->send_file &&\n\t\t\t\t(!pinfo->can_receive_file ||\n\t\t\t\t\tpinfo->can_receive_file(gc, purple_conversation_get_name(ggc->active_conv)))) {\n\t\t\titem = gnt_menuitem_new(_(\"Send File\"));\n\t\t\tgnt_menu_add_item(GNT_MENU(sub), item);\n\t\t\tgnt_menuitem_set_callback(item, send_file_cb, ggc);\n\t\t}\n\t\tgenerate_send_to_menu(ggc);\n\t} else if (purple_conversation_get_type(ggc->active_conv) == PURPLE_CONV_TYPE_CHAT) {\n\t\titem = gnt_menuitem_new(_(\"Invite...\"));\n\t\tgnt_menu_add_item(GNT_MENU(sub), item);\n\t\tgnt_menuitem_set_callback(item, invite_cb, ggc);\n\t}\n\titem = gnt_menuitem_new(_(\"View Log...\"));\n\tgnt_menu_add_item(GNT_MENU(sub), item);\n\tgnt_menuitem_set_callback(item, view_log_cb, ggc);\n\titem = gnt_menuitem_check_new(_(\"Enable Logging\"));\n\tgnt_menuitem_check_set_checked(GNT_MENU_ITEM_CHECK(item),\n\t\t\tpurple_conversation_is_logging(ggc->active_conv));\n\tgnt_menu_add_item(GNT_MENU(sub), item);\n\tgnt_menuitem_set_callback(item, toggle_logging_cb, ggc);\n\titem = gnt_menuitem_check_new(_(\"Enable Sounds\"));\n\tgnt_menuitem_check_set_checked(GNT_MENU_ITEM_CHECK(item),\n\t\t\t!(ggc->flags & FINCH_CONV_NO_SOUND));\n\tgnt_menu_add_item(GNT_MENU(sub), item);\n\tgnt_menuitem_set_callback(item, toggle_sound_cb, ggc);\n}\n", "bug_type": null, "idx": 488}
{"project": "Pidgin", "target": 0, "func": "GntTreeRow *gnt_tree_create_row(GntTree *tree, ...)\n{\n\tint i;\n\tva_list args;\n\tGList *list = NULL;\n\tGntTreeRow *row;\n\tva_start(args, tree);\n\tfor (i = 0; i < tree->ncol; i++)\n\t{\n\t\tlist = g_list_append(list, va_arg(args, char *));\n\t}\n\tva_end(args);\n\trow = gnt_tree_create_row_from_list(tree, list);\n\tg_list_free(list);\n\treturn row;\n}\n", "bug_type": null, "idx": 489}
{"project": "Pidgin", "target": 0, "func": "static gboolean resend_timeout(struct simple_account_data *sip) {\n\tGSList *tmp = sip->transactions;\n\ttime_t currtime = time(NULL);\n\twhile(tmp) {\n\t\tstruct transaction *trans = tmp->data;\n\t\ttmp = tmp->next;\n\t\tpurple_debug_info(\"simple\", \"have open transaction age: %lu\\n\", currtime- trans->time);\n\t\tif((currtime - trans->time > 5) && trans->retries >= 1) {\n\t\t\t\n\t\t} else {\n\t\t\tif((currtime - trans->time > 2) && trans->retries == 0) {\n\t\t\t\ttrans->retries++;\n\t\t\t\tsendout_sipmsg(sip, trans->msg);\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 490}
{"project": "Pidgin", "target": 0, "func": "JingleTransport *\njingle_content_get_transport(JingleContent *content)\n{\n\tJingleTransport *transport;\n\tg_object_get(content, \"transport\", &transport, NULL);\n\treturn transport;\n}\n", "bug_type": null, "idx": 491}
{"project": "Pidgin", "target": 0, "func": "GList *\npurple_media_codec_get_optional_parameters(PurpleMediaCodec *codec)\n{\n\tGList *optional_params;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_CODEC(codec), NULL);\n\tg_object_get(codec, \"optional-params\", &optional_params, NULL);\n\treturn optional_params;\n}\n", "bug_type": null, "idx": 492}
{"project": "Pidgin", "target": 0, "func": "GList *\npurple_plugins_get_all(void)\n{\n\treturn plugins;\n}\n", "bug_type": null, "idx": 493}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_media_stream_info_cb(PurpleMedia *media, PurpleMediaInfoType type,\n\t\tgchar *sid, gchar *name, gboolean local, FinchMedia *gntmedia)\n{\n\tif (type == PURPLE_MEDIA_INFO_REJECT) {\n\t\tfinch_media_emit_message(gntmedia,\n\t\t\t\t_(\"You have rejected the call.\"));\n\t}\n}\n", "bug_type": null, "idx": 494}
{"project": "Pidgin", "target": 0, "func": "static void\ndocklet_gtk_status_clicked_cb(GtkStatusIcon *status_icon, guint button, guint activate_time, gpointer user_data)\n{\n\tpurple_debug_info(\"docklet\", \"The button is %u\\n\", button);\n#ifdef GDK_WINDOWING_QUARTZ\n\t\n\tpidgin_docklet_clicked(3);\n#else\n\tpidgin_docklet_clicked(button);\n#endif\n}\n", "bug_type": null, "idx": 495}
{"project": "Pidgin", "target": 0, "func": "static void buddy_ticker_show(void)\n{\n\tPurpleBlistNode *gnode, *cnode, *bnode;\n\tPurpleBuddy *b;\n\tfor(gnode = purple_blist_get_root();\n\t    gnode;\n\t    gnode = purple_blist_node_get_sibling_next(gnode))\n\t{\n\t\tif(!PURPLE_BLIST_NODE_IS_GROUP(gnode))\n\t\t\tcontinue;\n\t\tfor(cnode = purple_blist_node_get_first_child(gnode);\n\t\t    cnode;\n\t\t    cnode = purple_blist_node_get_sibling_next(cnode))\n\t\t{\n\t\t\tif(!PURPLE_BLIST_NODE_IS_CONTACT(cnode))\n\t\t\t\tcontinue;\n\t\t\tfor(bnode = purple_blist_node_get_first_child(cnode);\n\t\t\t    bnode;\n\t\t\t    bnode = purple_blist_node_get_sibling_next(bnode))\n\t\t\t{\n\t\t\t\tif(!PURPLE_BLIST_NODE_IS_BUDDY(bnode))\n\t\t\t\t\tcontinue;\n\t\t\t\tb = (PurpleBuddy *)bnode;\n\t\t\t\tif(PURPLE_BUDDY_IS_ONLINE(b))\n\t\t\t\t\tbuddy_ticker_add_buddy(b);\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 496}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ntoggled_cb(GtkWidget *widget, GdkEventButton *event, PidginStatusBox *box)\n{\n\tif (!box->popup_in_progress)\n\t\tpidgin_status_box_popup (box);\n\telse\n\t\tpidgin_status_box_popdown(box);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 497}
{"project": "Pidgin", "target": 0, "func": "void purple_log_common_writer(PurpleLog *log, const char *ext)\n{\n\tPurpleLogCommonLoggerData *data = log->logger_data;\n\tif (data == NULL)\n\t{\n\t\t\n\t\tchar *dir;\n\t\tstruct tm *tm;\n\t\tconst char *tz;\n\t\tconst char *date;\n\t\tchar *filename;\n\t\tchar *path;\n\t\tdir = purple_log_get_log_dir(log->type, log->name, log->account);\n\t\tif (dir == NULL)\n\t\t\treturn;\n\t\tpurple_build_dir (dir, S_IRUSR | S_IWUSR | S_IXUSR);\n\t\ttm = localtime(&log->time);\n\t\ttz = purple_escape_filename(purple_utf8_strftime(\"%Z\", tm));\n\t\tdate = purple_utf8_strftime(\"%Y-%m-%d.%H%M%S%z\", tm);\n\t\tfilename = g_strdup_printf(\"%s%s%s\", date, tz, ext ? ext : \"\");\n\t\tpath = g_build_filename(dir, filename, NULL);\n\t\tg_free(dir);\n\t\tg_free(filename);\n\t\tlog->logger_data = data = g_slice_new0(PurpleLogCommonLoggerData);\n\t\tdata->file = g_fopen(path, \"a\");\n\t\tif (data->file == NULL)\n\t\t{\n\t\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"log\",\n\t\t\t\t\t\"Could not create log file %s\\n\", path);\n\t\t\tif (log->conv != NULL)\n\t\t\t\tpurple_conversation_write(log->conv, NULL, _(\"Logging of this conversation failed.\"),\n\t\t\t\t\t\t\t\t\t\tPURPLE_MESSAGE_ERROR, time(NULL));\n\t\t\tg_free(path);\n\t\t\treturn;\n\t\t}\n\t\tg_free(path);\n\t}\n}\n", "bug_type": null, "idx": 498}
{"project": "Pidgin", "target": 0, "func": "void\nnm_user_record_set_data(NMUserRecord * user_record, gpointer data)\n{\n\tif (user_record == NULL)\n\t\treturn;\n\tuser_record->data = data;\n}\n", "bug_type": null, "idx": 499}
{"project": "Pidgin", "target": 0, "func": "static gg_action_t gg_handle_send_proxy_gg(struct gg_session *sess,\n\tstruct gg_event *e, enum gg_state_t next_state,\n\tenum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tchar *req, *auth;\n\tsize_t req_len;\n\tint res;\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_watch_fd() %s\\n\", gg_debug_state(sess->state));\n\tif (sess->connect_index > 1 || sess->connect_port[sess->connect_index] == 0) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_watch_fd() out of connection candidates\\n\");\n\t\te->event.failure = GG_FAILURE_CONNECTING;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tauth = gg_proxy_auth();\n\treq = gg_saprintf(\"CONNECT %s:%d HTTP/1.0\\r\\n%s\\r\\n\",\n\t\tsess->connect_host, sess->connect_port[sess->connect_index],\n\t\t(auth) ? auth : \"\");\n\tfree(auth);\n\tsess->connect_index++;\n\tif (req == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_watch_fd() out of memory\\n\");\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\treq_len = strlen(req);\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_watch_fd() proxy request:\\n%s\", req);\n\tres = send(sess->fd, req, req_len, 0);\n\tfree(req);\n\tif (res == -1 && errno != EINTR && errno != EAGAIN) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_watch_fd() sending query failed\\n\");\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tif ((size_t) res < req_len) {\n\t\tsess->state = alt_state;\n\t\tsess->check = GG_CHECK_WRITE;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t} else {\n\t\tsess->state = next_state;\n\t\tsess->check = GG_CHECK_READ;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t}\n\treturn GG_ACTION_WAIT;\n}\n", "bug_type": null, "idx": 500}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nx509_ca_put_cert(const gchar *id, PurpleCertificate *crt)\n{\n\tgboolean ret = FALSE;\n\tg_return_val_if_fail(x509_ca_lazy_init(), FALSE);\n\t\n\tret = x509_ca_quiet_put_cert(crt);\n\treturn ret;\n}\n", "bug_type": null, "idx": 501}
{"project": "Pidgin", "target": 0, "func": "static void\nproxy_type_changed_cb(GtkWidget *menu, AccountPrefsDialog *dialog)\n{\n\tGtkTreeIter iter;\n\tif (gtk_combo_box_get_active_iter(GTK_COMBO_BOX(menu), &iter)) {\n\t\tint int_value;\n\t\tgtk_tree_model_get(gtk_combo_box_get_model(GTK_COMBO_BOX(menu)), &iter,\n\t\t\t1, &int_value, -1);\n\t\tdialog->new_proxy_type = int_value;\n\t}\n\tif (dialog->new_proxy_type == PURPLE_PROXY_USE_GLOBAL ||\n\t\tdialog->new_proxy_type == PURPLE_PROXY_NONE ||\n\t\tdialog->new_proxy_type == PURPLE_PROXY_USE_ENVVAR) {\n\t\tgtk_widget_hide_all(dialog->proxy_vbox);\n\t}\n\telse\n\t\tgtk_widget_show_all(dialog->proxy_vbox);\n}\n", "bug_type": null, "idx": 502}
{"project": "Pidgin", "target": 0, "func": "static struct chat_connection *\nfind_oscar_chat_by_conv(PurpleConnection *gc, PurpleConversation *conv)\n{\n\tOscarData *od = purple_connection_get_protocol_data(gc);\n\tGSList *cur;\n\tstruct chat_connection *cc;\n\tfor (cur = od->oscar_chats; cur != NULL; cur = cur->next)\n\t{\n\t\tcc = (struct chat_connection *)cur->data;\n\t\tif (cc->conv == conv)\n\t\t\treturn cc;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 503}
{"project": "Pidgin", "target": 0, "func": "static void\nregex_pref_highlight_cb(const gchar *name, PurplePrefType type,\n\t\t\t\t\t\tgconstpointer val, gpointer data)\n{\n\tDebugWindow *win = (DebugWindow *)data;\n\tgboolean active = GPOINTER_TO_INT(val);\n\twin->highlight = active;\n\tif(gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(win->filter)))\n\t\tregex_filter_all(win);\n}\n", "bug_type": null, "idx": 504}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_prefs_get_handle(void)\n{\n\tstatic int handle;\n\treturn &handle;\n}\n", "bug_type": null, "idx": 505}
{"project": "Pidgin", "target": 0, "func": "static void run_editor (MMConversation *mmconv)\n{\n\tGError *spawn_error = NULL;\n\tGString *session_id;\n\tgchar * args[4];\n\targs[0] = (gchar *)purple_prefs_get_string(\"/plugins/gtk/musicmessaging/editor_path\");\n\targs[1] = \"-session_id\";\n\tsession_id = g_string_new(\"\");\n\tg_string_append_printf(session_id, \"%d\", mmconv_from_conv_loc(mmconv->conv));\n\targs[2] = session_id->str;\n\targs[3] = NULL;\n\tif (!(g_spawn_async (\".\", args, NULL, 4, NULL, NULL, &(mmconv->pid), &spawn_error)))\n\t{\n\t\tpurple_notify_error(plugin_pointer, _(\"Error Running Editor\"),\n\t\t\t\t  _(\"The following error has occurred:\"), spawn_error->message);\n\t\tmmconv->started = FALSE;\n\t}\n\telse\n\t{\n\t\tmmconv->started = TRUE;\n\t}\n}\n", "bug_type": null, "idx": 506}
{"project": "Pidgin", "target": 0, "func": "static char *zephyr_get_chat_name(GHashTable *data) {\n\tgchar* zclass = g_hash_table_lookup(data,\"class\");\n\tgchar* inst = g_hash_table_lookup(data,\"instance\");\n\tgchar* recipient = g_hash_table_lookup(data, \"recipient\");\n\tif (!zclass) \n\t\tzclass = \"\";\n\tif (!inst)\n\t\tinst = \"*\";\n\tif (!recipient)\n\t\trecipient = \"\";\n\treturn g_strdup_printf(\"%s,%s,%s\",zclass,inst,recipient);\n}\n", "bug_type": null, "idx": 507}
{"project": "Pidgin", "target": 0, "func": "static void\nactivate_currently_selected_status(PidginStatusBox *status_box)\n{\n\tPidginStatusBoxItemType type;\n\tgpointer data;\n\tgchar *title;\n\tGtkTreeIter iter;\n\tGtkTreePath *path;\n\tchar *message;\n\tPurpleSavedStatus *saved_status = NULL;\n\tgboolean changed = TRUE;\n\tpath = gtk_tree_row_reference_get_path(status_box->active_row);\n\tif (!gtk_tree_model_get_iter (GTK_TREE_MODEL(status_box->dropdown_store), &iter, path))\n\t\treturn;\n\tgtk_tree_path_free(path);\n\tgtk_tree_model_get(GTK_TREE_MODEL(status_box->dropdown_store), &iter,\n\t\t\t\t\t   TYPE_COLUMN, &type,\n\t\t\t\t\t   DATA_COLUMN, &data,\n\t\t\t\t\t   -1);\n\t\n\tif (type != PIDGIN_STATUS_BOX_TYPE_PRIMITIVE)\n\t\treturn;\n\tgtk_tree_model_get(GTK_TREE_MODEL(status_box->dropdown_store), &iter,\n\t\t\t\t\t   TITLE_COLUMN, &title, -1);\n\tmessage = pidgin_status_box_get_message(status_box);\n\tif (!message || !*message)\n\t{\n\t\tgtk_widget_hide_all(status_box->vbox);\n\t\tstatus_box->imhtml_visible = FALSE;\n\t\tif (message != NULL)\n\t\t{\n\t\t\tg_free(message);\n\t\t\tmessage = NULL;\n\t\t}\n\t}\n\tif (status_box->account == NULL) {\n\t\tPurpleStatusType *acct_status_type = NULL;\n\t\tconst char *id = NULL; \n\t\tPurpleStatusPrimitive primitive = GPOINTER_TO_INT(data);\n\t\t\n\t\t\n\t\t\n\t\tif (status_box->token_status_account) {\n\t\t\tgint active;\n\t\t\tPurpleStatus *status;\n\t\t\tGtkTreePath *path = gtk_tree_row_reference_get_path(status_box->active_row);\n\t\t\tactive = gtk_tree_path_get_indices(path)[0];\n\t\t\tgtk_tree_path_free(path);\n\t\t\tstatus = purple_account_get_active_status(status_box->token_status_account);\n\t\t\tacct_status_type = find_status_type_by_index(status_box->token_status_account, active);\n\t\t\tid = purple_status_type_get_id(acct_status_type);\n\t\t\tif (g_str_equal(id, purple_status_get_id(status)) &&\n\t\t\t\tpurple_strequal(message, purple_status_get_attr_string(status, \"message\")))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tPurpleSavedStatus *ss = purple_savedstatus_get_current();\n\t\t\t\t\n\t\t\t\tif ((purple_savedstatus_get_type(ss) == primitive)\n\t\t\t\t\t&& purple_savedstatus_is_transient(ss)\n\t\t\t\t\t&& purple_savedstatus_has_substatuses(ss))\n\t\t\t\t\tchanged = FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tsaved_status = purple_savedstatus_get_current();\n\t\t\tif (purple_savedstatus_get_type(saved_status) == primitive &&\n\t\t\t    !purple_savedstatus_has_substatuses(saved_status) &&\n\t\t\t\tpurple_strequal(purple_savedstatus_get_message(saved_status), message))\n\t\t\t{\n\t\t\t\tchanged = FALSE;\n\t\t\t}\n\t\t}\n\t\tif (changed)\n\t\t{\n\t\t\t\n\t\t\tif (status_box->token_status_account) {\n\t\t\t\tGList *iter = purple_savedstatuses_get_all();\n\t\t\t\tGList *tmp, *active_accts = purple_accounts_get_all_active();\n\t\t\t\tfor (; iter != NULL; iter = iter->next) {\n\t\t\t\t\tPurpleSavedStatus *ss = iter->data;\n\t\t\t\t\tconst char *ss_msg = purple_savedstatus_get_message(ss);\n\t\t\t\t\t\n\t\t\t\t\tif ((purple_savedstatus_get_type(ss) == primitive) && purple_savedstatus_is_transient(ss) &&\n\t\t\t\t\t\tpurple_savedstatus_has_substatuses(ss) && \n\t\t\t\t\t\tpurple_strequal(ss_msg, message))\n\t\t\t\t\t{\n\t\t\t\t\t\tgboolean found = FALSE;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(tmp = active_accts; tmp != NULL; tmp = tmp->next) {\n\t\t\t\t\t\t\tPurpleAccount *acct = tmp->data;\n\t\t\t\t\t\t\tPurpleSavedStatusSub *sub = purple_savedstatus_get_substatus(ss, acct);\n\t\t\t\t\t\t\tif (sub) {\n\t\t\t\t\t\t\t\tconst PurpleStatusType *sub_type = purple_savedstatus_substatus_get_type(sub);\n\t\t\t\t\t\t\t\tconst char *subtype_status_id = purple_status_type_get_id(sub_type);\n\t\t\t\t\t\t\t\tif (purple_strequal(subtype_status_id, id)) {\n\t\t\t\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (found) {\n\t\t\t\t\t\t\tsaved_status = ss;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg_list_free(active_accts);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tsaved_status = purple_savedstatus_find_transient_by_type_and_message(primitive, message);\n\t\t\t}\n\t\t\t\n\t\t\tif (saved_status == NULL)\n\t\t\t{\n\t\t\t\tsaved_status = purple_savedstatus_new(NULL, primitive);\n\t\t\t\tpurple_savedstatus_set_message(saved_status, message);\n\t\t\t\tif (status_box->token_status_account) {\n\t\t\t\t\tGList *tmp, *active_accts = purple_accounts_get_all_active();\n\t\t\t\t\tfor (tmp = active_accts; tmp != NULL; tmp = tmp->next) {\n\t\t\t\t\t\tpurple_savedstatus_set_substatus(saved_status,\n\t\t\t\t\t\t\t(PurpleAccount*) tmp->data, acct_status_type, message);\n\t\t\t\t\t}\n\t\t\t\t\tg_list_free(active_accts);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpurple_savedstatus_activate(saved_status);\n\t\t}\n\t} else {\n\t\t\n\t\tgint active;\n\t\tPurpleStatusType *status_type;\n\t\tPurpleStatus *status;\n\t\tconst char *id = NULL;\n\t\tstatus = purple_account_get_active_status(status_box->account);\n\t\tactive = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(status_box), \"active\"));\n\t\tstatus_type = find_status_type_by_index(status_box->account, active);\n\t\tid = purple_status_type_get_id(status_type);\n\t\tif (g_str_equal(id, purple_status_get_id(status)) &&\n\t\t\tpurple_strequal(message, purple_status_get_attr_string(status, \"message\")))\n\t\t{\n\t\t\t\n\t\t\tchanged = FALSE;\n\t\t}\n\t\tif (changed)\n\t\t{\n\t\t\tif (message)\n\t\t\t\tpurple_account_set_status(status_box->account, id,\n\t\t\t\t\t\t\t\t\t\tTRUE, \"message\", message, NULL);\n\t\t\telse\n\t\t\t\tpurple_account_set_status(status_box->account, id,\n\t\t\t\t\t\t\t\t\t\tTRUE, NULL);\n\t\t\tsaved_status = purple_savedstatus_get_current();\n\t\t\tif (purple_savedstatus_is_transient(saved_status))\n\t\t\t\tpurple_savedstatus_set_substatus(saved_status, status_box->account,\n\t\t\t\t\t\tstatus_type, message);\n\t\t}\n\t}\n\tg_free(title);\n\tg_free(message);\n}\n", "bug_type": null, "idx": 508}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_blist_buddies_cache_add_account(PurpleAccount *account)\n{\n\tGHashTable *account_buddies = g_hash_table_new_full((GHashFunc)_purple_blist_hbuddy_hash,\n\t\t\t\t\t\t(GEqualFunc)_purple_blist_hbuddy_equal,\n\t\t\t\t\t\t(GDestroyNotify)_purple_blist_hbuddy_free_key, NULL);\n\tg_hash_table_insert(buddies_cache, account, account_buddies);\n}\n", "bug_type": null, "idx": 509}
{"project": "Pidgin", "target": 0, "func": "void gnt_screen_occupy(GntWidget *widget)\n{\n\tgnt_wm_new_window(wm, widget);\n}\n", "bug_type": null, "idx": 510}
{"project": "Pidgin", "target": 0, "func": "static void\nsetup_des_key(const guint8 key_56[], guint8 *key)\n{\n\tkey[0] = key_56[0];\n\tkey[1] = ((key_56[0] << 7) & 0xFF) | (key_56[1] >> 1);\n\tkey[2] = ((key_56[1] << 6) & 0xFF) | (key_56[2] >> 2);\n\tkey[3] = ((key_56[2] << 5) & 0xFF) | (key_56[3] >> 3);\n\tkey[4] = ((key_56[3] << 4) & 0xFF) | (key_56[4] >> 4);\n\tkey[5] = ((key_56[4] << 3) & 0xFF) | (key_56[5] >> 5);\n\tkey[6] = ((key_56[5] << 2) & 0xFF) | (key_56[6] >> 6);\n\tkey[7] =  (key_56[6] << 1) & 0xFF;\n}\n", "bug_type": null, "idx": 511}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npurple_media_backend_fs2_set_decryption_parameters (PurpleMediaBackend *self,\n\t\tconst gchar *sess_id, const gchar *participant,\n\t\tconst gchar *cipher, const gchar *auth,\n\t\tconst gchar *key, gsize key_len)\n{\n\tPurpleMediaBackendFs2Stream *stream;\n\tGstStructure *srtp;\n\tGError *err = NULL;\n\tgboolean result;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_BACKEND_FS2(self), FALSE);\n\tstream = get_stream(PURPLE_MEDIA_BACKEND_FS2(self), sess_id,\n\t\t\tparticipant);\n\tif (!stream)\n\t\treturn FALSE;\n\tsrtp = create_fs2_srtp_structure(cipher, auth, key, key_len);\n\tif (!srtp)\n\t\treturn FALSE;\n\tresult = fs_stream_set_decryption_parameters(stream->stream, srtp,\n\t\t\t\t\t\t&err);\n\tif (!result) {\n\t\tpurple_debug_error(\"backend-fs2\",\n\t\t\t\t\"Error setting decryption parameters: %s\\n\", err->message);\n\t\tg_error_free(err);\n\t}\n\tgst_structure_free(srtp);\n\treturn result;\n}\n", "bug_type": null, "idx": 512}
{"project": "Pidgin", "target": 0, "func": "static void\ndestroy_signal_handler(PurplePerlSignalHandler *handler)\n{\n\tsignal_handlers = g_slist_remove(signal_handlers, handler);\n\tif (handler->callback != NULL)\n\t\tSvREFCNT_dec(handler->callback);\n\tif (handler->data != NULL)\n\t\tSvREFCNT_dec(handler->data);\n\tg_free(handler->signal);\n\tg_free(handler);\n}\n", "bug_type": null, "idx": 513}
{"project": "Pidgin", "target": 0, "func": "static gboolean account_filter_func(PurpleAccount *account)\n{\n\treturn purple_strequal(purple_account_get_protocol_id(account), XMPP_PLUGIN_ID);\n}\n", "bug_type": null, "idx": 514}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddy_icon_changed_cb(PurpleBuddy *buddy)\n{\n\tpurple_debug_misc(\"signals test\", \"buddy icon changed (%s)\\n\",\n\t\t\t\t\tpurple_buddy_get_name(buddy));\n}\n", "bug_type": null, "idx": 515}
{"project": "Pidgin", "target": 0, "func": "PurpleConversation *\npurple_find_conversation_with_account(PurpleConversationType type,\n\t\t\t\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\t\t\t\tconst PurpleAccount *account)\n{\n\tPurpleConversation *c = NULL;\n\tstruct _purple_hconv hc;\n\tg_return_val_if_fail(name != NULL, NULL);\n\thc.name = (gchar *)purple_normalize(account, name);\n\thc.account = account;\n\thc.type = type;\n\tswitch (type) {\n\t\tcase PURPLE_CONV_TYPE_IM:\n\t\tcase PURPLE_CONV_TYPE_CHAT:\n\t\t\tc = g_hash_table_lookup(conversation_cache, &hc);\n\t\t\tbreak;\n\t\tcase PURPLE_CONV_TYPE_ANY:\n\t\t\thc.type = PURPLE_CONV_TYPE_IM;\n\t\t\tc = g_hash_table_lookup(conversation_cache, &hc);\n\t\t\tif (!c) {\n\t\t\t\thc.type = PURPLE_CONV_TYPE_CHAT;\n\t\t\t\tc = g_hash_table_lookup(conversation_cache, &hc);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_return_val_if_reached(NULL);\n\t}\n\treturn c;\n}\n", "bug_type": null, "idx": 516}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_wb_request(SilcClient client, const unsigned char *message,\n\t\t    SilcUInt32 message_len, SilcClientEntry sender,\n\t\t    SilcChannelEntry channel)\n{\n\tchar tmp[128];\n\tSilcPurpleWbRequest req;\n\tPurpleConnection *gc;\n\tSilcPurple sg;\n\tgc = client->application;\n\tsg = gc->proto_data;\n\t\n\tif (purple_account_get_bool(sg->account, \"open-wb\", FALSE)) {\n\t\tPurpleWhiteboard *wb;\n\t\tif (!channel)\n\t\t\twb = silcpurple_wb_init(sg, sender);\n\t\telse\n\t\t\twb = silcpurple_wb_init_ch(sg, channel);\n\t\tsilcpurple_wb_parse(wb->proto_data, wb, (unsigned char *)message,\n\t\t\t\t  message_len);\n\t\treturn;\n\t}\n\t\n\tpurple_request_close_with_handle(sender);\n\tif (!channel) {\n\t\tg_snprintf(tmp, sizeof(tmp),\n\t\t\t_(\"%s sent message to whiteboard. Would you like \"\n\t\t\t  \"to open the whiteboard?\"), sender->nickname);\n\t} else {\n\t\tg_snprintf(tmp, sizeof(tmp),\n\t\t\t_(\"%s sent message to whiteboard on %s channel. \"\n\t\t\t  \"Would you like to open the whiteboard?\"),\n\t\t\tsender->nickname, channel->channel_name);\n\t}\n\treq = silc_calloc(1, sizeof(*req));\n\tif (!req)\n\t\treturn;\n\treq->message = silc_memdup(message, message_len);\n\treq->message_len = message_len;\n\treq->sender = sender;\n\treq->channel = channel;\n\treq->sg = sg;\n\tpurple_request_action(sender, _(\"Whiteboard\"), tmp, NULL, 1,\n\t\t\t\tsg->account, sender->nickname, NULL, req, 2,\n\t\t\t    _(\"Yes\"), G_CALLBACK(silcpurple_wb_request_cb),\n\t\t\t    _(\"No\"), G_CALLBACK(silcpurple_wb_request_cb));\n}\n", "bug_type": null, "idx": 517}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_g_checksum_append(PurpleCipherContext *context, const guchar *data,\n                         gsize len)\n{\n    GChecksum *checksum;\n    checksum = purple_cipher_context_get_data(context);\n    g_return_if_fail(checksum != NULL);\n    while (len >= G_MAXSSIZE) {\n        g_checksum_update(checksum, data, G_MAXSSIZE);\n        len -= G_MAXSSIZE;\n        data += G_MAXSSIZE;\n    }\n    if (len)\n        g_checksum_update(checksum, data, len);\n}\n", "bug_type": null, "idx": 518}
{"project": "Pidgin", "target": 0, "func": "static void zephyr_zloc(PurpleConnection *gc, const char *who)\n{\n\tZAsyncLocateData_t ald;\n\tzephyr_account *zephyr = gc->proto_data;\n\tgchar* normalized_who = local_zephyr_normalize(zephyr,who);\n\tif (use_zeph02(zephyr)) {\n\t\tif (ZRequestLocations(normalized_who, &ald, UNACKED, ZAUTH) == ZERR_NONE) {\n\t\t\tzephyr->pending_zloc_names = g_list_append(zephyr->pending_zloc_names,\n\t\t\t\t\t\t\t\t   g_strdup(normalized_who));\n\t\t} else {\n\t\t\t\n\t\t}\n\t} else if (use_tzc(zephyr)) {\n\t\tsize_t len;\n\t\tsize_t result;\n\t\tchar* zlocstr = g_strdup_printf(\"((tzcfodder . zlocate) \\\"%s\\\")\\n\",normalized_who);\n\t\tzephyr->pending_zloc_names = g_list_append(zephyr->pending_zloc_names, g_strdup(normalized_who));\n\t\tlen = strlen(zlocstr);\n\t\tresult = write(zephyr->totzc[ZEPHYR_FD_WRITE],zlocstr,len);\n\t\tif (result != len) {\n\t\t\tpurple_debug_error(\"zephyr\", \"Unable to write a message: %s\\n\", g_strerror(errno));\n\t\t}\n\t\tg_free(zlocstr);\n\t}\n}\n", "bug_type": null, "idx": 519}
{"project": "Pidgin", "target": 0, "func": "static const char *\nlookup_locale (const PurpleDesktopItem *item, const char *key, const char *locale)\n{\n\tif (locale == NULL ||\n\t    purple_strequal (locale, \"C\")) {\n\t\treturn lookup (item, key);\n\t} else {\n\t\tconst char *ret;\n\t\tchar *full = g_strdup_printf (\"%s[%s]\", key, locale);\n\t\tret = lookup (item, full);\n\t\tg_free (full);\n\t\treturn ret;\n\t}\n}\n", "bug_type": null, "idx": 520}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_entry_size_request(GntWidget *widget)\n{\n\tif (!GNT_WIDGET_IS_FLAG_SET(widget, GNT_WIDGET_MAPPED))\n\t{\n\t\twidget->priv.height = 1;\n\t\twidget->priv.width = 20;\n\t}\n}\n", "bug_type": null, "idx": 521}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_media_get_property (GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)\n{\n\tFinchMedia *media;\n\tg_return_if_fail(FINCH_IS_MEDIA(object));\n\tmedia = FINCH_MEDIA(object);\n\tswitch (prop_id) {\n\t\tcase PROP_MEDIA:\n\t\t\tg_value_set_object(value, media->priv->media);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 522}
{"project": "Pidgin", "target": 0, "func": "void gnt_text_view_attach_editor_widget(GntTextView *view, GntWidget *wid)\n{\n\tg_signal_connect(wid, \"key_pressed\", G_CALLBACK(check_for_ext_cb), view);\n\tg_object_set_data(G_OBJECT(wid), \"editor-for\", view);\n}\n", "bug_type": null, "idx": 523}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_blist_buddies_cache_remove_account(const PurpleAccount *account)\n{\n\tg_hash_table_remove(buddies_cache, account);\n}\n", "bug_type": null, "idx": 524}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddy_idle_changed(PurpleBuddy *buddy, int old, int new, FinchBlist *ggblist)\n{\n\tupdate_buddy_display(buddy, ggblist);\n}\n", "bug_type": null, "idx": 525}
{"project": "Pidgin", "target": 0, "func": "static inline uint64_t\nparse_fixed_uint64(const uint8_t *data)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tuint64_t t;\n\tmemcpy(&t, data, 8);\n\treturn t;\n#else\n\treturn (uint64_t) parse_fixed_uint32(data) |\n\t\t(((uint64_t) parse_fixed_uint32(data + 4)) << 32);\n#endif\n}\n", "bug_type": null, "idx": 526}
{"project": "Pidgin", "target": 0, "func": "static void\nirssi_window_resized(GntWM *wm, GntNode *node)\n{\n\tif (!is_budddylist(node->me))\n\t\treturn;\n\tgnt_widget_get_size(node->me, &((Irssi*)wm)->buddylistwidth, NULL);\n\tdraw_line_separators((Irssi*)wm);\n}\n", "bug_type": null, "idx": 527}
{"project": "Pidgin", "target": 0, "func": "};\nPurpleDebugUiOps *finch_debug_get_ui_ops()\n{\n\treturn &uiops;\n}\n", "bug_type": null, "idx": 528}
{"project": "Pidgin", "target": 0, "func": "\nint wpurple_fcntl(int socket, int command, ...) {\n\tswitch( command ) {\n\tcase F_GETFL:\n\t\treturn 0;\n\tcase F_SETFL:\n\t{\n\t\tva_list args;\n\t\tint val;\n\t\tint ret=0;\n\t\tva_start(args, command);\n\t\tval = va_arg(args, int);\n\t\tva_end(args);\n\t\tswitch( val ) {\n\t\tcase O_NONBLOCK:\n\t\t{\n\t\t\tu_long imode=1;\n\t\t\tret = ioctlsocket(socket, FIONBIO, &imode);\n\t\t\tbreak;\n\t\t}\n\t\tcase 0:\n\t\t{\n\t\t\tu_long imode=0;\n\t\t\tret = ioctlsocket(socket, FIONBIO, &imode);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tif( ret == SOCKET_ERROR ) {\n\t\t\terrno = WSAGetLastError();\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n                purple_debug(PURPLE_DEBUG_WARNING, \"wpurple\", \"wpurple_fcntl: Unsupported command\\n\");\n\t\treturn -1;\n\t}\n}\n\nint wpurple_fcntl(int socket, int command, ...) {\n\tswitch( command ) {\n\tcase F_GETFL:\n\t\treturn 0;\n\tcase F_SETFL:\n\t{\n\t\tva_list args;\n\t\tint val;\n\t\tint ret=0;\n\t\tva_start(args, command);\n\t\tval = va_arg(args, int);\n\t\tva_end(args);\n\t\tswitch( val ) {\n\t\tcase O_NONBLOCK:\n\t\t{\n\t\t\tu_long imode=1;\n\t\t\tret = ioctlsocket(socket, FIONBIO, &imode);\n\t\t\tbreak;\n\t\t}\n\t\tcase 0:\n\t\t{\n\t\t\tu_long imode=0;\n\t\t\tret = ioctlsocket(socket, FIONBIO, &imode);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tif( ret == SOCKET_ERROR ) {\n\t\t\terrno = WSAGetLastError();\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n                purple_debug(PURPLE_DEBUG_WARNING, \"wpurple\", \"wpurple_fcntl: Unsupported command\\n\");\n\t\treturn -1;\n\t}\n}\n", "bug_type": null, "idx": 529}
{"project": "Pidgin", "target": 0, "func": "static void\nreceived_chat_msg(PurpleAccount *account, const char *sender, const char *msg,\n\t\tPurpleConversation *conv, PurpleMessageFlags flags, gpointer null)\n{\n\tconst char *nick;\n\tif (flags & PURPLE_MESSAGE_WHISPER)\n\t\treturn;\n\tnick = PURPLE_CONV_CHAT(conv)->nick;\n\tif (g_utf8_collate(sender, nick) == 0)\n\t\treturn;\n\tif (purple_prefs_get_bool(PREFS_EVENT_CHAT_NICK) &&\n\t\t\t(purple_utf8_has_word(msg, nick)))\n\t\tnotify(conv, _(\"%s said your nick in %s\"), sender, purple_conversation_get_name(conv));\n\telse if (purple_prefs_get_bool(PREFS_EVENT_CHAT_MSG))\n\t\tnotify(conv, _(\"%s sent a message in %s\"), sender, purple_conversation_get_name(conv));\n}\n", "bug_type": null, "idx": 530}
{"project": "Pidgin", "target": 0, "func": "static GstElement *\ncreate_default_audio_sink(PurpleMedia *media,\n\t\tconst gchar *session_id, const gchar *participant)\n{\n\tGstElement *sink;\n\tsink = gst_element_factory_make(\"gconfaudiosink\", NULL);\n\tif (sink == NULL)\n\t\tsink = gst_element_factory_make(\"autoaudiosink\",NULL);\n\tif (sink == NULL) {\n\t\tpurple_debug_error(\"gtkmedia\", \"Unable to find a suitable \"\n\t\t\t\t\"element for the default audio sink.\\n\");\n\t\treturn NULL;\n\t}\n\treturn sink;\n}\n", "bug_type": null, "idx": 531}
{"project": "Pidgin", "target": 0, "func": "GType\ngnt_entry_get_gtype(void)\n{\n\tstatic GType type = 0;\n\tif(type == 0)\n\t{\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(GntEntryClass),\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tNULL,\t\t\t\t\t\n\t\t\t(GClassInitFunc)gnt_entry_class_init,\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tsizeof(GntEntry),\n\t\t\t0,\t\t\t\t\t\t\n\t\t\tgnt_entry_init,\t\t\t\n\t\t\tNULL\t\t\t\t\t\n\t\t};\n\t\ttype = g_type_register_static(GNT_TYPE_WIDGET,\n\t\t\t\t\t\t\t\t\t  \"GntEntry\",\n\t\t\t\t\t\t\t\t\t  &info, 0);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 532}
{"project": "Pidgin", "target": 0, "func": "gchar *\npurple_certificate_get_unique_id(PurpleCertificate *crt)\n{\n\tg_return_val_if_fail(crt, NULL);\n\tg_return_val_if_fail(crt->scheme, NULL);\n\tg_return_val_if_fail(crt->scheme->get_unique_id, NULL);\n\treturn (crt->scheme->get_unique_id)(crt);\n}\n", "bug_type": null, "idx": 533}
{"project": "Pidgin", "target": 0, "func": "static void\nbonjour_xfer_receive(PurpleConnection *pc, const char *id, const char *sid, const char *from,\n\t\t     const int filesize, const char *filename, int option)\n{\n\tPurpleXfer *xfer;\n\tXepXfer *xf;\n\tBonjourData *bd;\n\tif(pc == NULL || id == NULL || from == NULL)\n\t\treturn;\n\tbd = (BonjourData*) pc->proto_data;\n\tif(bd == NULL)\n\t\treturn;\n\tpurple_debug_info(\"bonjour\", \"bonjour-xfer-receive.\\n\");\n\t\n\txfer = purple_xfer_new(pc->account, PURPLE_XFER_RECEIVE, from);\n\txfer->data = xf = g_new0(XepXfer, 1);\n\txf->data = bd;\n\tpurple_xfer_set_filename(xfer, filename);\n\txf->iq_id = g_strdup(id);\n\txf->sid = g_strdup(sid);\n\tif(filesize > 0)\n\t\tpurple_xfer_set_size(xfer, filesize);\n\tpurple_xfer_set_init_fnc(xfer, bonjour_xfer_init);\n\tpurple_xfer_set_request_denied_fnc(xfer, bonjour_xfer_request_denied);\n\tpurple_xfer_set_cancel_recv_fnc(xfer, bonjour_xfer_cancel_recv);\n\tpurple_xfer_set_end_fnc(xfer, bonjour_xfer_end);\n\tbd->xfer_lists = g_slist_append(bd->xfer_lists, xfer);\n\tpurple_xfer_request(xfer);\n}\n", "bug_type": null, "idx": 534}
{"project": "Pidgin", "target": 0, "func": "void purple_whiteboard_set_brush(PurpleWhiteboard *wb, int size, int color)\n{\n\tif (whiteboard_ui_ops && whiteboard_ui_ops->set_brush)\n\t\twhiteboard_ui_ops->set_brush(wb, size, color);\n}\n", "bug_type": null, "idx": 535}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_savedstatus_get_message(const PurpleSavedStatus *saved_status)\n{\n\tg_return_val_if_fail(saved_status != NULL, NULL);\n\treturn saved_status->message;\n}\n", "bug_type": null, "idx": 536}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_account_set_filter(PurpleRequestField *field,\n\t\t\t\t\t\t\t\t\t  PurpleFilterAccountFunc filter_func)\n{\n\tg_return_if_fail(field != NULL);\n\tg_return_if_fail(field->type == PURPLE_REQUEST_FIELD_ACCOUNT);\n\tfield->u.account.filter_func = filter_func;\n}\n", "bug_type": null, "idx": 537}
{"project": "Pidgin", "target": 0, "func": "void pidgin_log_show(PurpleLogType type, const char *buddyname, PurpleAccount *account) {\n\tstruct log_viewer_hash_t *ht;\n\tPidginLogViewer *lv = NULL;\n\tconst char *name = buddyname;\n\tchar *title;\n\tGdkPixbuf *prpl_icon;\n\tg_return_if_fail(account != NULL);\n\tg_return_if_fail(buddyname != NULL);\n\tht = g_new0(struct log_viewer_hash_t, 1);\n\tht->type = type;\n\tht->buddyname = g_strdup(buddyname);\n\tht->account = account;\n\tif (log_viewers == NULL) {\n\t\tlog_viewers = g_hash_table_new(log_viewer_hash, log_viewer_equal);\n\t} else if ((lv = g_hash_table_lookup(log_viewers, ht))) {\n\t\tgtk_window_present(GTK_WINDOW(lv->window));\n\t\tg_free(ht->buddyname);\n\t\tg_free(ht);\n\t\treturn;\n\t}\n\tif (type == PURPLE_LOG_CHAT) {\n\t\tPurpleChat *chat;\n\t\tchat = purple_blist_find_chat(account, buddyname);\n\t\tif (chat != NULL)\n\t\t\tname = purple_chat_get_name(chat);\n\t\ttitle = g_strdup_printf(_(\"Conversations in %s\"), name);\n\t} else {\n\t\tPurpleBuddy *buddy;\n\t\tbuddy = purple_find_buddy(account, buddyname);\n\t\tif (buddy != NULL)\n\t\t\tname = purple_buddy_get_contact_alias(buddy);\n\t\ttitle = g_strdup_printf(_(\"Conversations with %s\"), name);\n\t}\n\tprpl_icon = pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_MEDIUM);\n\tdisplay_log_viewer(ht, purple_log_get_logs(type, buddyname, account),\n\t\t\ttitle, gtk_image_new_from_pixbuf(prpl_icon),\n\t\t\tpurple_log_get_total_size(type, buddyname, account));\n\tif (prpl_icon)\n\t\tg_object_unref(prpl_icon);\n\tg_free(title);\n}\n", "bug_type": null, "idx": 538}
{"project": "Pidgin", "target": 0, "func": "};\nvoid jabber_iq_callbackdata_free(JabberIqCallbackData *jcd)\n{\n\tjabber_id_free(jcd->to);\n\tg_free(jcd);\n}\n", "bug_type": null, "idx": 539}
{"project": "Pidgin", "target": 0, "func": "const ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field_by_name(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\t\tconst char *name)\n{\n\tunsigned start = 0;\n\tunsigned count = desc->n_fields;\n\tconst ProtobufCFieldDescriptor *field;\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv;\n\t\tfield = desc->fields + desc->fields_sorted_by_name[mid];\n\t\trv = strcmp(field->name, name);\n\t\tif (rv == 0)\n\t\t\treturn field;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tfield = desc->fields + desc->fields_sorted_by_name[start];\n\tif (strcmp(field->name, name) == 0)\n\t\treturn field;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 540}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_remove_buddy(PurpleAccount *account, PurpleBuddy *buddy,\n\t\tPurpleGroup *group)\n{\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tPurpleConnection *gc = purple_account_get_connection(account);\n\tPurplePlugin *prpl = NULL;\n\tif (gc != NULL)\n\t\tprpl = purple_connection_get_prpl(gc);\n\tif (prpl != NULL)\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\tif (prpl_info && prpl_info->remove_buddy)\n\t\tprpl_info->remove_buddy(gc, buddy, group);\n}\n", "bug_type": null, "idx": 541}
{"project": "Pidgin", "target": 0, "func": "static gboolean account_filter_func(PurpleAccount *account)\n{\n\tPurpleConnection *conn = purple_account_get_connection(account);\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tif (conn && PURPLE_CONNECTION_IS_CONNECTED(conn))\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(conn->prpl);\n\treturn (prpl_info && prpl_info->roomlist_get_list != NULL);\n}\n", "bug_type": null, "idx": 542}
{"project": "Pidgin", "target": 0, "func": "gchar *\npurple_theme_get_image_full(PurpleTheme *theme)\n{\n\tconst gchar *filename = purple_theme_get_image(theme);\n\tif (filename)\n\t\treturn g_build_filename(purple_theme_get_dir(PURPLE_THEME(theme)), filename, NULL);\n\telse\n\t\treturn NULL;\n}\n", "bug_type": null, "idx": 543}
{"project": "Pidgin", "target": 0, "func": "#include \"oscar.h\"\nint byte_stream_new(ByteStream *bs, size_t len)\n{\n\tif (bs == NULL)\n\t\treturn -1;\n\treturn byte_stream_init(bs, g_malloc(len), len);\n}\n", "bug_type": null, "idx": 544}
{"project": "Pidgin", "target": 0, "func": "void\npurple_ssl_input_add(PurpleSslConnection *gsc, PurpleSslInputFunction func,\n\t\t\t\t   void *data)\n{\n\tg_return_if_fail(func != NULL);\n\tg_return_if_fail(purple_ssl_is_supported());\n\tgsc->recv_cb_data = data;\n\tgsc->recv_cb      = func;\n\tgsc->inpa = purple_input_add(gsc->fd, PURPLE_INPUT_READ, recv_cb, gsc);\n}\n", "bug_type": null, "idx": 545}
{"project": "Pidgin", "target": 0, "func": "void\noscar_auth_sendrequest(PurpleConnection *gc, const char *bname, const char *msg)\n{\n\tOscarData *od;\n\tPurpleAccount *account;\n\tPurpleBuddy *buddy;\n\tPurpleGroup *group;\n\tconst char *gname;\n\tod = purple_connection_get_protocol_data(gc);\n\taccount = purple_connection_get_account(gc);\n\tbuddy = purple_find_buddy(account, bname);\n\tif (buddy != NULL)\n\t\tgroup = purple_buddy_get_group(buddy);\n\telse\n\t\tgroup = NULL;\n\tif (group != NULL)\n\t{\n\t\tgname = purple_group_get_name(group);\n\t\tpurple_debug_info(\"oscar\", \"ssi: adding buddy %s to group %s\\n\",\n\t\t\t\t   bname, gname);\n\t\taim_ssi_sendauthrequest(od, bname, msg ? msg : _(\"Please authorize me so I can add you to my buddy list.\"));\n\t\tif (!aim_ssi_itemlist_finditem(od->ssi.local, gname, bname, AIM_SSI_TYPE_BUDDY))\n\t\t{\n\t\t\taim_ssi_addbuddy(od, bname, gname, NULL, purple_buddy_get_alias_only(buddy), NULL, NULL, TRUE);\n\t\t\t\n\t\t\tif (bname[0] == '+') {\n\t\t\t\tpurple_prpl_got_user_status(account,\n\t\t\t\t\t\tpurple_buddy_get_name(buddy),\n\t\t\t\t\t\tOSCAR_STATUS_ID_AVAILABLE, NULL);\n\t\t\t\tpurple_prpl_got_user_status(account,\n\t\t\t\t\t\tpurple_buddy_get_name(buddy),\n\t\t\t\t\t\tOSCAR_STATUS_ID_MOBILE, NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 546}
{"project": "Pidgin", "target": 0, "func": "static void\nx509_tls_cached_cert_in_cache(PurpleCertificateVerificationRequest *vrq,\n                              PurpleCertificateInvalidityFlags flags)\n{\n\t\n\tPurpleCertificatePool *tls_peers =\n\t\tpurple_certificate_find_pool(x509_tls_cached.scheme_name,\n\t\t\t\t\t     \"tls_peers\");\n\t\n\tPurpleCertificate *peer_crt =\n\t\t(PurpleCertificate *) vrq->cert_chain->data;\n\tPurpleCertificate *cached_crt;\n\tGByteArray *peer_fpr, *cached_fpr;\n\t\n\tcached_crt = purple_certificate_pool_retrieve(\n\t\ttls_peers, vrq->subject_name);\n\tif ( !cached_crt ) {\n\t\tpurple_debug_warning(\"certificate/x509/tls_cached\",\n\t\t\t\t   \"Lookup failed on cached certificate!\\n\"\n\t\t\t\t   \"Falling back to full verification.\\n\");\n\t\t\n\t\tx509_tls_cached_unknown_peer(vrq, flags);\n\t\treturn;\n\t}\n\t\n\t\n\tpeer_fpr = purple_certificate_get_fingerprint_sha256(peer_crt, TRUE);\n\tcached_fpr = purple_certificate_get_fingerprint_sha256(cached_crt, TRUE);\n\tif (!memcmp(peer_fpr->data, cached_fpr->data, peer_fpr->len)) {\n\t\tpurple_debug_info(\"certificate/x509/tls_cached\",\n\t\t\t\t  \"Peer cert matched cached\\n\");\n\t\tx509_tls_cached_complete(vrq, flags);\n\t} else {\n\t\tpurple_debug_error(\"certificate/x509/tls_cached\",\n\t\t\t\t  \"Peer cert did NOT match cached\\n\");\n\t\t\n\t\tx509_tls_cached_unknown_peer(vrq, flags);\n\t}\n\tpurple_certificate_destroy(cached_crt);\n\tg_byte_array_free(peer_fpr, TRUE);\n\tg_byte_array_free(cached_fpr, TRUE);\n}\n", "bug_type": null, "idx": 547}
{"project": "Pidgin", "target": 0, "func": "static Section *\nfind_section (PurpleDesktopItem *item, const char *section)\n{\n\tGList *li;\n\tSection *sec;\n\tif (section == NULL)\n\t\treturn NULL;\n\tif (purple_strequal (section, \"Desktop Entry\"))\n\t\treturn NULL;\n\tfor (li = item->sections; li != NULL; li = li->next) {\n\t\tsec = li->data;\n\t\tif (purple_strequal (sec->name, section))\n\t\t\treturn sec;\n\t}\n\tsec = g_new0 (Section, 1);\n\tsec->name = g_strdup (section);\n\tsec->keys = NULL;\n\titem->sections = g_list_append (item->sections, sec);\n\t\n\treturn sec;\n}\n", "bug_type": null, "idx": 548}
{"project": "Pidgin", "target": 0, "func": "static uint64_t\nparse_uint64(unsigned len, const uint8_t *data)\n{\n\tunsigned shift, i;\n\tuint64_t rv;\n\tif (len < 5)\n\t\treturn parse_uint32(len, data);\n\trv = ((uint64_t) (data[0] & 0x7f)) |\n\t\t((uint64_t) (data[1] & 0x7f) << 7) |\n\t\t((uint64_t) (data[2] & 0x7f) << 14) |\n\t\t((uint64_t) (data[3] & 0x7f) << 21);\n\tshift = 28;\n\tfor (i = 4; i < len; i++) {\n\t\trv |= (((uint64_t) (data[i] & 0x7f)) << shift);\n\t\tshift += 7;\n\t}\n\treturn rv;\n}\n", "bug_type": null, "idx": 549}
{"project": "Pidgin", "target": 0, "func": "int tcl_cmd_plugins(ClientData unused, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])\n{\n\tconst char *cmds[] = { \"handle\", NULL };\n\tenum { CMD_PLUGINS_HANDLE } cmd;\n\tint error;\n\tif (objc < 2) {\n\t\tTcl_WrongNumArgs(interp, 1, objv, \"subcommand ?args?\");\n\t\treturn TCL_ERROR;\n\t}\n\tif ((error = Tcl_GetIndexFromObj(interp, objv[1], cmds, \"subcommand\", 0, (int *)&cmd)) != TCL_OK)\n\t\treturn error;\n\tswitch (cmd) {\n\tcase CMD_PLUGINS_HANDLE:\n\t\tif (objc != 2) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tTcl_SetObjResult(interp,\n\t\t\t\tpurple_tcl_ref_new(PurpleTclRefHandle,\n\t\t\t\t\t\t   purple_plugins_get_handle()));\n\t\tbreak;\n\t}\n\treturn TCL_OK;\n}\n", "bug_type": null, "idx": 550}
{"project": "Pidgin", "target": 0, "func": "void silcpurple_wb_end(PurpleWhiteboard *wb)\n{\n\tsilc_free(wb->proto_data);\n\twb->proto_data = NULL;\n}\n", "bug_type": null, "idx": 551}
{"project": "Pidgin", "target": 0, "func": "static void\ntree_selection_changed(GntTree *tree, GntTreeRow *old, GntTreeRow *current)\n{\n\tg_signal_emit(tree, signals[SIG_SELECTION_CHANGED], 0, old ? old->key : NULL,\n\t\t\t\tcurrent ? current->key : NULL);\n}\n", "bug_type": null, "idx": 552}
{"project": "Pidgin", "target": 0, "func": "static gulong\nsignal_connect_common(void *instance, const char *signal, void *handle,\n\t\t\t\t\t  PurpleCallback func, void *data, int priority, gboolean use_vargs)\n{\n\tPurpleInstanceData *instance_data;\n\tPurpleSignalData *signal_data;\n\tPurpleSignalHandlerData *handler_data;\n\tg_return_val_if_fail(instance != NULL, 0);\n\tg_return_val_if_fail(signal   != NULL, 0);\n\tg_return_val_if_fail(handle   != NULL, 0);\n\tg_return_val_if_fail(func     != NULL, 0);\n\t\n\tinstance_data =\n\t\t(PurpleInstanceData *)g_hash_table_lookup(instance_table, instance);\n\tif (instance_data == NULL)\n\t{\n\t\tpurple_debug_warning(\"signals\", \"Something tried to register a callback \"\n\t\t\t\t\"for the '%s' signal, but we do not have any signals \"\n\t\t\t\t\"registered with the given handle\\n\", signal);\n\t\tg_return_val_if_reached(0);\n\t}\n\t\n\tsignal_data =\n\t\t(PurpleSignalData *)g_hash_table_lookup(instance_data->signals, signal);\n\tif (signal_data == NULL)\n\t{\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"signals\",\n\t\t\t\t   \"Signal data for %s not found!\\n\", signal);\n\t\treturn 0;\n\t}\n\t\n\thandler_data = g_new0(PurpleSignalHandlerData, 1);\n\thandler_data->id        = signal_data->next_handler_id;\n\thandler_data->cb        = func;\n\thandler_data->handle    = handle;\n\thandler_data->data      = data;\n\thandler_data->use_vargs = use_vargs;\n\thandler_data->priority = priority;\n\tsignal_data->handlers = g_list_insert_sorted(signal_data->handlers, handler_data, (GCompareFunc)handler_priority);\n\tsignal_data->handler_count++;\n\tsignal_data->next_handler_id++;\n\treturn handler_data->id;\n}\n", "bug_type": null, "idx": 553}
{"project": "Pidgin", "target": 0, "func": "void gnt_menuitem_check_set_checked(GntMenuItemCheck *item, gboolean set)\n{\n\t\titem->checked = set;\n}\n", "bug_type": null, "idx": 554}
{"project": "Pidgin", "target": 0, "func": "PurpleMimeDocument *\npurple_mime_document_parse(const char *buf)\n{\n\tg_return_val_if_fail(buf != NULL, NULL);\n\treturn purple_mime_document_parsen(buf, strlen(buf));\n}\n", "bug_type": null, "idx": 555}
{"project": "Pidgin", "target": 0, "func": "static void\npounces_manager_modify_cb(GntButton *button, gpointer user_data)\n{\n\tPouncesManager *dialog = user_data;\n\tPurplePounce *pounce = gnt_tree_get_selection_data(GNT_TREE(dialog->tree));\n\tif (pounce)\n\t\tfinch_pounce_editor_show(NULL, NULL, pounce);\n}\n", "bug_type": null, "idx": 556}
{"project": "Pidgin", "target": 0, "func": "static PurpleMediaBackendFs2Stream *\nget_stream(PurpleMediaBackendFs2 *self,\n\t\tconst gchar *sess_id, const gchar *name)\n{\n\tPurpleMediaBackendFs2Private *priv;\n\tGList *streams;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_BACKEND_FS2(self), NULL);\n\tpriv = PURPLE_MEDIA_BACKEND_FS2_GET_PRIVATE(self);\n\tstreams = priv->streams;\n\tfor (; streams; streams = g_list_next(streams)) {\n\t\tPurpleMediaBackendFs2Stream *stream = streams->data;\n\t\tif (!strcmp(stream->session->id, sess_id) &&\n\t\t\t\t!strcmp(stream->participant, name))\n\t\t\treturn stream;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 557}
{"project": "Pidgin", "target": 0, "func": "gboolean gnt_file_sel_set_current_location(GntFileSel *sel, const char *path)\n{\n\tchar *old;\n\tGError *error = NULL;\n\tgboolean ret = TRUE;\n\told = sel->current;\n\tsel->current = process_path(path);\n\tif (!location_changed(sel, &error)) {\n\t\tg_error_free(error);\n\t\terror = NULL;\n\t\tg_free(sel->current);\n\t\tsel->current = old;\n\t\tlocation_changed(sel, &error);\n\t\tret = FALSE;\n\t} else\n\t\tg_free(old);\n\tupdate_location(sel);\n\treturn ret;\n}\n", "bug_type": null, "idx": 558}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_button_class_init(GntWidgetClass *klass)\n{\n\tchar *style;\n\tGntBindableClass *bindable = GNT_BINDABLE_CLASS(klass);\n\tparent_class = GNT_WIDGET_CLASS(klass);\n\tparent_class->draw = gnt_button_draw;\n\tparent_class->map = gnt_button_map;\n\tparent_class->size_request = gnt_button_size_request;\n\tparent_class->clicked = gnt_button_clicked;\n\tparent_class->destroy = gnt_button_destroy;\n\tstyle = gnt_style_get_from_name(NULL, \"small-button\");\n\tsmall_button = gnt_style_parse_bool(style);\n\tg_free(style);\n\tgnt_bindable_class_register_action(bindable, \"activate\", button_activate,\n\t\t\t\tGNT_KEY_ENTER, NULL);\n\tgnt_style_read_actions(G_OBJECT_CLASS_TYPE(klass), GNT_BINDABLE_CLASS(klass));\n}\n", "bug_type": null, "idx": 559}
{"project": "Pidgin", "target": 0, "func": "void\nnm_release_request(NMRequest * req)\n{\n\tif (req && (--req->ref_count == 0)) {\n\t\tif (req->cmd)\n\t\t\tg_free(req->cmd);\n\t\tg_free(req);\n\t\tpurple_debug_info(\"novell\",\n\t\t\t\t\t\t\"Releasing NMRequest instance, total=%d\\n\", --count);\n\t}\n}\n", "bug_type": null, "idx": 560}
{"project": "Pidgin", "target": 0, "func": "void gnt_box_set_pad(GntBox *box, int pad)\n{\n\tbox->pad = pad;\n\t\n}\n", "bug_type": null, "idx": 561}
{"project": "Pidgin", "target": 0, "func": "static void\nsend_im_cb(PidginMiniDialog *mini_dialog,\n           GtkButton *button,\n           gpointer data)\n{\n\tstruct auth_request *ar = data;\n\tpidgin_dialogs_im_with_user(ar->account, ar->username);\n}\n", "bug_type": null, "idx": 562}
{"project": "Pidgin", "target": 0, "func": "static void\nmenu_cb(GtkWidget *item, gpointer data)\n{\n\tPurplePlugin *plugin = data;\n\tGtkWidget *frame = pidgin_plugin_get_config_frame(plugin), *dialog;\n\tif (!frame)\n\t\treturn;\n\tdialog = gtk_dialog_new_with_buttons(PIDGIN_ALERT_TITLE, NULL,\n\t\t\tGTK_DIALOG_NO_SEPARATOR | GTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\tGTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE,\n\t\t\tNULL);\n\tg_signal_connect_after(G_OBJECT(dialog), \"response\", G_CALLBACK(gtk_widget_destroy), dialog);\n#if GTK_CHECK_VERSION(2,14,0)\n\tgtk_container_add(GTK_CONTAINER(gtk_dialog_get_content_area(GTK_DIALOG(dialog))), frame);\n#else\n\tgtk_container_add(GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), frame);\n#endif\n\tgtk_window_set_role(GTK_WINDOW(dialog), \"plugin_config\");\n\tgtk_window_set_title(GTK_WINDOW(dialog), _(purple_plugin_get_name(plugin)));\n\tgtk_widget_show_all(dialog);\n}\n", "bug_type": null, "idx": 563}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nmove_first_action(GntBindable *bind, GList *null)\n{\n\tGntTree *tree = GNT_TREE(bind);\n\tGntTreeRow *row = tree->root;\n\tGntTreeRow *old = tree->current;\n\tif (row && !row_matches_search(row))\n\t\trow = get_next(row);\n\tif (row) {\n\t\ttree->current = row;\n\t\tredraw_tree(tree);\n\t\tif (old != tree->current)\n\t\t\ttree_selection_changed(tree, old, tree->current);\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 564}
{"project": "Pidgin", "target": 0, "func": "static GParameter *\njabber_google_session_get_params(JabberStream *js, const gchar *relay_ip,\n\tguint16 relay_udp, guint16 relay_tcp, guint16 relay_ssltcp,\n    const gchar *relay_username, const gchar *relay_password, guint *num)\n{\n\tguint num_params;\n\tGParameter *params =\n\t\tjingle_get_params(js, relay_ip, relay_udp, relay_tcp, relay_ssltcp,\n\t    \trelay_username, relay_password, &num_params);\n\tGParameter *new_params = g_new0(GParameter, num_params + 1);\n\tmemcpy(new_params, params, sizeof(GParameter) * num_params);\n\tpurple_debug_info(\"jabber\", \"setting Google jingle compatibility param\\n\");\n\tnew_params[num_params].name = \"compatibility-mode\";\n\tg_value_init(&new_params[num_params].value, G_TYPE_UINT);\n\tg_value_set_uint(&new_params[num_params].value, 1); \n\tg_free(params);\n\t*num = num_params + 1;\n\treturn new_params;\n}\n", "bug_type": null, "idx": 565}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nclipboard_paste(GntBindable *bind, GList *n)\n{\n\tGntEntry *entry = GNT_ENTRY(bind);\n\tgchar *i, *text, *a, *all;\n\ttext = i = gnt_get_clipboard_string();\n\twhile (*i != '\\0') {\n\t\ti = g_utf8_next_char(i);\n\t\tif (*i == '\\r' || *i == '\\n')\n\t\t\t*i = ' ';\n\t}\n\ta = g_strndup(entry->start, entry->cursor - entry->start);\n\tall = g_strconcat(a, text, entry->cursor, NULL);\n\tgnt_entry_set_text_internal(entry, all);\n\tupdate_kill_ring(entry, ENTRY_JAIL, NULL, 0);\n\tg_free(a);\n\tg_free(text);\n\tg_free(all);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 566}
{"project": "Pidgin", "target": 0, "func": "int\nchat_modfirst(OscarData *od, aim_module_t *mod)\n{\n\tmod->family = SNAC_FAMILY_CHAT;\n\tmod->version = 0x0001;\n\tmod->toolid = 0x0010;\n\tmod->toolversion = 0x0629;\n\tmod->flags = 0;\n\tstrncpy(mod->name, \"chat\", sizeof(mod->name));\n\tmod->snachandler = snachandler;\n\treturn 0;\n}\n", "bug_type": null, "idx": 567}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_status_is_available(const PurpleStatus *status)\n{\n\tg_return_val_if_fail(status != NULL, FALSE);\n\treturn purple_status_type_is_available(purple_status_get_type(status));\n}\n", "bug_type": null, "idx": 568}
{"project": "Pidgin", "target": 0, "func": "static void session_shutdown_cancelled(SmcConn conn, SmPointer data) {\n\tpurple_debug(PURPLE_DEBUG_INFO, \"Session Management\",\n\t\t\t   \"Received shutdown_cancelled\\n\");\n}\n", "bug_type": null, "idx": 569}
{"project": "Pidgin", "target": 0, "func": "static void\nperson_info_changed_cb(GtkEntry *entry, GevoNewPersonDialog *dialog)\n{\n\tgtk_widget_set_sensitive(dialog->add_button,\n\t\t(*gtk_entry_get_text(GTK_ENTRY(dialog->firstname)) != '\\0' ||\n\t\t *gtk_entry_get_text(GTK_ENTRY(dialog->lastname))  != '\\0'));\n}\n", "bug_type": null, "idx": 570}
{"project": "Pidgin", "target": 0, "func": "static void\nnovell_ssl_recv_cb(gpointer data, PurpleSslConnection * gsc,\n\t\t\t\t   PurpleInputCondition condition)\n{\n\tPurpleConnection *gc = data;\n\tNMUser *user;\n\tNMERR_T rc;\n\tif (gc == NULL)\n\t\treturn;\n\tuser = gc->proto_data;\n\tif (user == NULL)\n\t\treturn;\n\trc = nm_process_new_data(user);\n\tif (rc != NM_OK) {\n\t\tif (_is_disconnect_error(rc)) {\n\t\t\tpurple_connection_error_reason(gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t\t_(\"Error communicating with server. Closing connection.\"));\n\t\t} else {\n\t\t\tpurple_debug(PURPLE_DEBUG_INFO, \"novell\",\n\t\t\t\t\t   \"Error processing event or response (%d).\\n\", rc);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 571}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_chat_permanent(PurpleBlistNode *node, gpointer data)\n{\n\tPurpleChat *chat;\n\tPurpleConnection *gc;\n\tSilcPurple sg;\n\tconst char *channel;\n\tg_return_if_fail(PURPLE_BLIST_NODE_IS_CHAT(node));\n\tchat = (PurpleChat *) node;\n\tgc = purple_account_get_connection(chat->account);\n\tsg = gc->proto_data;\n\tif (!sg->conn)\n\t\treturn;\n\t\n\t\n\tchannel = g_hash_table_lookup(chat->components, \"channel\");\n\tsilc_client_command_call(sg->client, sg->conn, NULL, \"CMODE\", channel,\n\t\t\t\t \"+f\", NULL);\n}\n", "bug_type": null, "idx": 572}
{"project": "Pidgin", "target": 0, "func": "static void\nauth_shutdown(OscarData *od, aim_module_t *mod)\n{\n\tif (od->authinfo != NULL)\n\t{\n\t\tg_free(od->authinfo->bn);\n\t\tg_free(od->authinfo->bosip);\n\t\tg_free(od->authinfo->errorurl);\n\t\tg_free(od->authinfo->email);\n\t\tg_free(od->authinfo->chpassurl);\n\t\tg_free(od->authinfo->latestrelease.name);\n\t\tg_free(od->authinfo->latestrelease.url);\n\t\tg_free(od->authinfo->latestrelease.info);\n\t\tg_free(od->authinfo->latestbeta.name);\n\t\tg_free(od->authinfo->latestbeta.url);\n\t\tg_free(od->authinfo->latestbeta.info);\n\t\tg_free(od->authinfo);\n\t}\n}\n", "bug_type": null, "idx": 573}
{"project": "Pidgin", "target": 0, "func": "#include \"mono-glue.h\"\nMonoObject* purple_status_build_status_object(void* data)\n{\n\tMonoObject *obj = NULL;\n\tPurpleStatus *status = (PurpleStatus*)data;\n\tobj = ml_create_api_object(\"Status\");\n\tg_return_val_if_fail(obj != NULL, NULL);\n\tml_set_prop_string(obj, \"Id\", (char*)purple_status_get_id(status));\n\treturn obj;\n}\n", "bug_type": null, "idx": 574}
{"project": "Pidgin", "target": 0, "func": "static void\nremove_avatar_0_12_nodes(JabberStream *js)\n{\n#if 0\n\t\n\t\n\txmlnode *publish, *item, *metadata;\n\t\n\tpublish = xmlnode_new(\"publish\");\n\txmlnode_set_attrib(publish, \"node\", NS_AVATAR_0_12_METADATA);\n\titem = xmlnode_new_child(publish, \"item\");\n\txmlnode_set_attrib(item, \"id\", \"stop\");\n\tmetadata = xmlnode_new_child(item, \"metadata\");\n\txmlnode_set_namespace(metadata, NS_AVATAR_0_12_METADATA);\n\txmlnode_new_child(metadata, \"stop\");\n\t\n\tjabber_pep_publish(js, publish);\n#endif\n\t\n\tjabber_pep_delete_node(js, NS_AVATAR_0_12_METADATA);\n\tjabber_pep_delete_node(js, NS_AVATAR_0_12_DATA);\n}\n", "bug_type": null, "idx": 575}
{"project": "Pidgin", "target": 0, "func": "void\npurple_value_set_uchar(PurpleValue *value, unsigned char data)\n{\n\tg_return_if_fail(value != NULL);\n\tvalue->data.uchar_data = data;\n}\n", "bug_type": null, "idx": 576}
{"project": "Pidgin", "target": 0, "func": "static void\nconv_created(PurpleConversation *conv)\n{\n\tpurple_conversation_set_data(conv, \"notify-message-count\",\n\t                           GINT_TO_POINTER(0));\n\t\n\tattach_signals(conv);\n}\n", "bug_type": null, "idx": 577}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *smiley_list_create(SmileyManager *dialog)\n{\n\tGtkWidget *treeview;\n\tGtkTreeSelection *sel;\n\tGtkTargetEntry te[3] = {\n\t\t{\"text/plain\", 0, 0},\n\t\t{\"text/uri-list\", 0, 1},\n\t\t{\"STRING\", 0, 2}\n\t};\n\t\n\tdialog->model = gtk_list_store_new(N_COL,\n\t\t\tGDK_TYPE_PIXBUF,\t\n\t\t\tG_TYPE_STRING,\t\t\n\t\t\tG_TYPE_OBJECT\t\t\n\t\t\t);\n\t\n\ttreeview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(dialog->model));\n\tdialog->treeview = treeview;\n\tgtk_tree_view_set_rules_hint(GTK_TREE_VIEW(treeview), TRUE);\n\tgtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(dialog->model), SHORTCUT, GTK_SORT_ASCENDING);\n\tg_object_unref(G_OBJECT(dialog->model));\n\tsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));\n\tgtk_tree_selection_set_mode(sel, GTK_SELECTION_MULTIPLE);\n\tg_signal_connect(G_OBJECT(sel), \"changed\", G_CALLBACK(smile_selected_cb), dialog);\n\tg_signal_connect(G_OBJECT(treeview), \"row_activated\", G_CALLBACK(smiley_edit_cb), dialog);\n\tgtk_drag_dest_set(treeview,\n\t                  GTK_DEST_DEFAULT_MOTION | GTK_DEST_DEFAULT_HIGHLIGHT | GTK_DEST_DEFAULT_DROP,\n\t                  te, G_N_ELEMENTS(te), GDK_ACTION_COPY | GDK_ACTION_MOVE);\n\tg_signal_connect(G_OBJECT(treeview), \"drag_data_received\", G_CALLBACK(smiley_dnd_recv), dialog);\n\tgtk_widget_show(treeview);\n\tadd_columns(treeview, dialog);\n\tpopulate_smiley_list(dialog);\n\treturn pidgin_make_scrollable(treeview, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC, GTK_SHADOW_IN, -1, -1);\n}\n", "bug_type": null, "idx": 578}
{"project": "Pidgin", "target": 0, "func": "void purple_blist_add_account(PurpleAccount *account)\n{\n\tPurpleBlistUiOps *ops = purple_blist_get_ui_ops();\n\tPurpleBlistNode *gnode, *cnode, *bnode;\n\tg_return_if_fail(purplebuddylist != NULL);\n\tif (!ops || !ops->update)\n\t\treturn;\n\tfor (gnode = purplebuddylist->root; gnode; gnode = gnode->next) {\n\t\tif (!PURPLE_BLIST_NODE_IS_GROUP(gnode))\n\t\t\tcontinue;\n\t\tfor (cnode = gnode->child; cnode; cnode = cnode->next) {\n\t\t\tif (PURPLE_BLIST_NODE_IS_CONTACT(cnode)) {\n\t\t\t\tgboolean recompute = FALSE;\n\t\t\t\t\tfor (bnode = cnode->child; bnode; bnode = bnode->next) {\n\t\t\t\t\t\tif (PURPLE_BLIST_NODE_IS_BUDDY(bnode) &&\n\t\t\t\t\t\t\t\t((PurpleBuddy*)bnode)->account == account) {\n\t\t\t\t\t\t\trecompute = TRUE;\n\t\t\t\t\t\t\t((PurpleContact*)cnode)->currentsize++;\n\t\t\t\t\t\t\tif (((PurpleContact*)cnode)->currentsize == 1)\n\t\t\t\t\t\t\t\t((PurpleGroup*)gnode)->currentsize++;\n\t\t\t\t\t\t\tops->update(purplebuddylist, bnode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recompute ||\n\t\t\t\t\t\t\tpurple_blist_node_get_bool(cnode, \"show_offline\")) {\n\t\t\t\t\t\tpurple_contact_invalidate_priority_buddy((PurpleContact*)cnode);\n\t\t\t\t\t\tops->update(purplebuddylist, cnode);\n\t\t\t\t\t}\n\t\t\t} else if (PURPLE_BLIST_NODE_IS_CHAT(cnode) &&\n\t\t\t\t\t((PurpleChat*)cnode)->account == account) {\n\t\t\t\t((PurpleGroup *)gnode)->online++;\n\t\t\t\t((PurpleGroup *)gnode)->currentsize++;\n\t\t\t\tops->update(purplebuddylist, cnode);\n\t\t\t}\n\t\t}\n\t\tops->update(purplebuddylist, gnode);\n\t}\n}\n", "bug_type": null, "idx": 579}
{"project": "Pidgin", "target": 0, "func": "static char *\nprocess_path(const char *path)\n{\n\tchar **splits = NULL;\n\tint i, j;\n\tchar *str, *ret;\n\tsplits = g_strsplit(path, G_DIR_SEPARATOR_S, -1);\n\tfor (i = 0, j = 0; splits[i]; i++) {\n\t\tif (strcmp(splits[i], \".\") == 0) {\n\t\t\tg_free(splits[i]);\n\t\t\tsplits[i] = NULL;\n\t\t} else if (strcmp(splits[i], \"..\") == 0) {\n\t\t\tif (j)\n\t\t\t\tj--;\n\t\t\tg_free(splits[i]);\n\t\t\tsplits[i] = NULL;\n\t\t} else {\n\t\t\tif (i != j) {\n\t\t\t\tg_free(splits[j]);\n\t\t\t\tsplits[j] = splits[i];\n\t\t\t\tsplits[i] = NULL;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\tg_free(splits[j]);\n\tsplits[j] = NULL;\n\tstr = g_build_pathv(G_DIR_SEPARATOR_S, splits);\n\tret = g_strdup_printf(G_DIR_SEPARATOR_S \"%s\", str);\n\tg_free(str);\n\tg_strfreev(splits);\n\treturn ret;\n}\n", "bug_type": null, "idx": 580}
{"project": "Pidgin", "target": 0, "func": "int\nnm_folder_get_id(NMFolder * folder)\n{\n\tif (folder == NULL) {\n\t\treturn  -1;\n\t}\n\treturn folder->id;\n}\n", "bug_type": null, "idx": 581}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_adhoc_got_server_list(JabberStream *js, const char *from, xmlnode *query)\n{\n\txmlnode *item;\n\tif(!query)\n\t\treturn;\n\t\n\twhile(js->commands) {\n\t\tJabberAdHocCommands *cmd = js->commands->data;\n\t\tg_free(cmd->jid);\n\t\tg_free(cmd->node);\n\t\tg_free(cmd->name);\n\t\tg_free(cmd);\n\t\tjs->commands = g_list_delete_link(js->commands, js->commands);\n\t}\n\t\n\tfor(item = query->child; item; item = item->next) {\n\t\tJabberAdHocCommands *cmd;\n\t\tif(item->type != XMLNODE_TYPE_TAG)\n\t\t\tcontinue;\n\t\tif(strcmp(item->name, \"item\"))\n\t\t\tcontinue;\n\t\tcmd = g_new0(JabberAdHocCommands, 1);\n\t\tcmd->jid = g_strdup(xmlnode_get_attrib(item,\"jid\"));\n\t\tcmd->node = g_strdup(xmlnode_get_attrib(item,\"node\"));\n\t\tcmd->name = g_strdup(xmlnode_get_attrib(item,\"name\"));\n\t\tjs->commands = g_list_append(js->commands,cmd);\n\t}\n\tif (js->state == JABBER_STREAM_CONNECTED)\n\t\tpurple_prpl_got_account_actions(purple_connection_get_account(js->gc));\n}\n", "bug_type": null, "idx": 582}
{"project": "Pidgin", "target": 0, "func": "static void\naccount_removed_cb(PurpleAccount *account, gpointer user_data)\n{\n\tg_hash_table_remove(hash, account);\n}\n", "bug_type": null, "idx": 583}
{"project": "Pidgin", "target": 0, "func": "static EContact *\ngevo_run_query_in_uri(const gchar *uri, EBookQuery *query)\n{\n\tEBook *book;\n\tgboolean status;\n\tGList *cards;\n\tGError *err = NULL;\n\tif (!gevo_load_addressbook(uri, &book, &err))\n\t{\n\t\tpurple_debug_error(\"evolution\",\n\t\t\t\t\t\t \"Error retrieving addressbook: %s\\n\", err->message);\n\t\tg_error_free(err);\n\t\treturn NULL;\n\t}\n\tstatus = e_book_get_contacts(book, query, &cards, NULL);\n\tif (!status)\n\t{\n\t\tpurple_debug_error(\"evolution\", \"Error %d in getting card list\\n\",\n\t\t\t\t\t\t status);\n\t\tg_object_unref(book);\n\t\treturn NULL;\n\t}\n\tg_object_unref(book);\n\tif (cards != NULL)\n\t{\n\t\tEContact *contact = E_CONTACT(cards->data);\n\t\tGList *cards2 = cards->next;\n\t\tif (cards2 != NULL)\n\t\t{\n\t\t\t\n\t\t\tcards->next = NULL;\n\t\t\tcards2->prev = NULL;\n\t\t\tg_list_foreach(cards2, (GFunc)g_object_unref, NULL);\n\t\t}\n\t\t\n\t\tg_list_free(cards);\n\t\treturn contact;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 584}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_media_set_state(PidginMedia *gtkmedia, PidginMediaState state)\n{\n\tgtkmedia->priv->state = state;\n}\n", "bug_type": null, "idx": 585}
{"project": "Pidgin", "target": 0, "func": "void xmlnode_set_prefix(xmlnode *node, const char *prefix)\n{\n\tg_return_if_fail(node != NULL);\n\tg_free(node->prefix);\n\tnode->prefix = g_strdup(prefix);\n}\n", "bug_type": null, "idx": 586}
{"project": "Pidgin", "target": 0, "func": "void finch_blist_uninstall_manager(const FinchBlistManager *manager)\n{\n\tif (g_list_find(managers, manager)) {\n\t\tmanagers = g_list_remove(managers, manager);\n\t\treconstruct_grouping_menu();\n\t\tif (strcmp(manager->id, purple_prefs_get_string(PREF_ROOT \"/grouping\")) == 0)\n\t\t\tpurple_prefs_trigger_callback(PREF_ROOT \"/grouping\");\n\t}\n}\n", "bug_type": null, "idx": 587}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nend_search_action(GntBindable *bindable, GList *list)\n{\n\tGntTree *tree = GNT_TREE(bindable);\n\tif (tree->priv->search == NULL)\n\t\treturn FALSE;\n\tGNT_WIDGET_UNSET_FLAGS(GNT_WIDGET(tree), GNT_WIDGET_DISABLE_ACTIONS);\n\tend_search(tree);\n\tredraw_tree(tree);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 588}
{"project": "Pidgin", "target": 0, "func": "void purple_whiteboard_destroy(PurpleWhiteboard *wb)\n{\n\tg_return_if_fail(wb != NULL);\n\tif(wb->ui_data)\n\t{\n\t\t\n\t\tif(whiteboard_ui_ops && whiteboard_ui_ops->destroy)\n\t\t\twhiteboard_ui_ops->destroy(wb);\n\t}\n\t\n\tif(wb->prpl_ops && wb->prpl_ops->end)\n\t\twb->prpl_ops->end(wb);\n\tg_free(wb->who);\n\twbList = g_list_remove(wbList, wb);\n\tg_free(wb);\n}\n", "bug_type": null, "idx": 589}
{"project": "Pidgin", "target": 0, "func": "GType\npurple_media_element_type_get_type()\n{\n\tstatic GType type = 0;\n\tif (type == 0) {\n\t\tstatic const GFlagsValue values[] = {\n\t\t\t{ PURPLE_MEDIA_ELEMENT_NONE,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_NONE\", \"none\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_AUDIO,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_AUDIO\", \"audio\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_VIDEO,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_VIDEO\", \"video\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_AUDIO_VIDEO,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_AUDIO_VIDEO\",\n\t\t\t\t\"audio-video\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_NO_SRCS,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_NO_SRCS\", \"no-srcs\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_ONE_SRC,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_ONE_SRC\", \"one-src\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_MULTI_SRC,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_MULTI_SRC\",\n\t\t\t\t\"multi-src\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_REQUEST_SRC,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_REQUEST_SRC\",\n\t\t\t\t\"request-src\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_NO_SINKS,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_NO_SINKS\", \"no-sinks\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_ONE_SINK,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_ONE_SINK\", \"one-sink\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_MULTI_SINK,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_MULTI_SINK\",\n\t\t\t\t\"multi-sink\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_REQUEST_SINK,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_REQUEST_SINK\",\n\t\t\t\t\"request-sink\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_UNIQUE,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_UNIQUE\", \"unique\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_SRC,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_SRC\", \"src\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_SINK,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_SINK\", \"sink\" },\n\t\t\t{ PURPLE_MEDIA_ELEMENT_APPLICATION,\n\t\t\t\t\"PURPLE_MEDIA_ELEMENT_APPLICATION\", \"application\" },\n\t\t\t{ 0, NULL, NULL }\n\t\t};\n\t\ttype = g_flags_register_static(\n\t\t\t\t\"PurpleMediaElementType\", values);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 590}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_media_element_info_get_property (GObject *object, guint prop_id,\n\t\tGValue *value, GParamSpec *pspec)\n{\n\tPurpleMediaElementInfoPrivate *priv;\n\tg_return_if_fail(PURPLE_IS_MEDIA_ELEMENT_INFO(object));\n\tpriv = PURPLE_MEDIA_ELEMENT_INFO_GET_PRIVATE(object);\n\tswitch (prop_id) {\n\t\tcase PROP_ID:\n\t\t\tg_value_set_string(value, priv->id);\n\t\t\tbreak;\n\t\tcase PROP_NAME:\n\t\t\tg_value_set_string(value, priv->name);\n\t\t\tbreak;\n\t\tcase PROP_TYPE:\n\t\t\tg_value_set_flags(value, priv->type);\n\t\t\tbreak;\n\t\tcase PROP_CREATE_CB:\n\t\t\tg_value_set_pointer(value, priv->create);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID(\n\t\t\t\t\tobject, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 591}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_signal_emit_return_1(void *instance, const char *signal, ...)\n{\n\tvoid *ret_val;\n\tva_list args;\n\tg_return_val_if_fail(instance != NULL, NULL);\n\tg_return_val_if_fail(signal   != NULL, NULL);\n\tva_start(args, signal);\n\tret_val = purple_signal_emit_vargs_return_1(instance, signal, args);\n\tva_end(args);\n\treturn ret_val;\n}\n", "bug_type": null, "idx": 592}
{"project": "Pidgin", "target": 0, "func": "static void\nsent_im_msg_cb(PurpleAccount *account, const char *recipient, const char *buffer, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"sent-im-msg (%s, %s, %s)\\n\",\n\t\t\t\t\tpurple_account_get_username(account), recipient, buffer);\n}\n", "bug_type": null, "idx": 593}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_mime_part_get_field(PurpleMimePart *part, const char *field)\n{\n\tg_return_val_if_fail(part != NULL, NULL);\n\treturn fields_get(&part->fields, field);\n}\n", "bug_type": null, "idx": 594}
{"project": "Pidgin", "target": 0, "func": "gboolean\ngnt_widget_set_focus(GntWidget *widget, gboolean set)\n{\n\tif (!(GNT_WIDGET_FLAGS(widget) & GNT_WIDGET_CAN_TAKE_FOCUS))\n\t\treturn FALSE;\n\tif (set && !GNT_WIDGET_IS_FLAG_SET(widget, GNT_WIDGET_HAS_FOCUS))\n\t{\n\t\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_HAS_FOCUS);\n\t\tg_signal_emit(widget, signals[SIG_GIVE_FOCUS], 0);\n\t}\n\telse if (!set && GNT_WIDGET_IS_FLAG_SET(widget, GNT_WIDGET_HAS_FOCUS))\n\t{\n\t\tGNT_WIDGET_UNSET_FLAGS(widget, GNT_WIDGET_HAS_FOCUS);\n\t\tg_signal_emit(widget, signals[SIG_LOST_FOCUS], 0);\n\t}\n\telse\n\t\treturn FALSE;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 595}
{"project": "Pidgin", "target": 0, "func": "static void pref_dialog_response_cb(GtkWidget *d, int response, PurplePlugin *plug)\n{\n\tswitch (response) {\n\tcase GTK_RESPONSE_CLOSE:\n\tcase GTK_RESPONSE_DELETE_EVENT:\n\t\tg_hash_table_remove(plugin_pref_dialogs, plug);\n\t\tif (g_hash_table_size(plugin_pref_dialogs) == 0) {\n\t\t\tg_hash_table_destroy(plugin_pref_dialogs);\n\t\t\tplugin_pref_dialogs = NULL;\n\t\t}\n\t\tgtk_widget_destroy(d);\n\t\tif (plug->info->prefs_info && plug->info->prefs_info->frame) {\n\t\t\tpurple_plugin_pref_frame_destroy(plug->info->prefs_info->frame);\n\t\t\tplug->info->prefs_info->frame = NULL;\n\t\t}\n\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 596}
{"project": "Pidgin", "target": 0, "func": "static void url_fetched(PurpleUtilFetchUrlData *url_data, gpointer cb_data,\n\t\t\t\tconst gchar *url_text, gsize len, const gchar *error_message)\n{\n\tCbInfo *data = (CbInfo *)cb_data;\n\tPurpleConversation *conv = data->conv;\n\tGList *convs = purple_get_conversations();\n\t\n\tfor (; convs; convs = convs->next) {\n\t\tif ((PurpleConversation *)(convs->data) == conv) {\n\t\t\tFinchConv *fconv = FINCH_CONV(conv);\n\t\t\tgchar *str = g_strdup_printf(\"[%d] %s\", data->num, url_text);\n\t\t\tGntTextView *tv = GNT_TEXT_VIEW(fconv->tv);\n\t\t\tgnt_text_view_tag_change(tv, data->tag, str, FALSE);\n\t\t\tg_free(str);\n\t\t\tg_free(data->tag);\n\t\t\tg_free(data);\n\t\t\treturn;\n\t\t}\n\t}\n\tg_free(data->tag);\n\tg_free(data);\n\tpurple_debug_info(\"TinyURL\", \"Conversation no longer exists... :(\\n\");\n}\n", "bug_type": null, "idx": 597}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_smiley_editor_set_data(PidginSmiley *editor, gpointer data, gsize datasize)\n{\n\teditor->data = data;\n\teditor->datasize = datasize;\n}\n", "bug_type": null, "idx": 598}
{"project": "Pidgin", "target": 0, "func": "static void try_srv_connect(JabberStream *js)\n{\n\twhile (js->srv_rec != NULL && js->srv_rec_idx < js->max_srv_rec_idx) {\n\t\tPurpleSrvResponse *tmp_resp = js->srv_rec + (js->srv_rec_idx++);\n\t\tif (jabber_login_connect(js, tmp_resp->hostname, tmp_resp->hostname, tmp_resp->port, FALSE))\n\t\t\treturn;\n\t}\n\tg_free(js->srv_rec);\n\tjs->srv_rec = NULL;\n\t\n\tjabber_login_connect(js, js->user->domain, js->user->domain,\n\t\t\tpurple_account_get_int(purple_connection_get_account(js->gc), \"port\", 5222),\n\t\t\tTRUE);\n}\n", "bug_type": null, "idx": 599}
{"project": "Pidgin", "target": 0, "func": "const gchar *\npurple_sound_theme_get_file(PurpleSoundTheme *theme,\n\t\tconst gchar *event)\n{\n\tPurpleSoundThemePrivate *priv;\n\tg_return_val_if_fail(PURPLE_IS_SOUND_THEME(theme), NULL);\n\tpriv = PURPLE_SOUND_THEME_GET_PRIVATE(theme);\n\treturn g_hash_table_lookup(priv->sound_files, event);\n}\n", "bug_type": null, "idx": 600}
{"project": "Pidgin", "target": 0, "func": "static void\nremove_send_button_pidgin(PidginConversation *gtkconv)\n{\n\tGtkWidget *send_button = NULL;\n\tsend_button = g_object_get_data(G_OBJECT(gtkconv->lower_hbox),\n\t                                \"send_button\");\n\tif (send_button != NULL) {\n\t\tGtkTextBuffer *buf;\n\t\tguint signal_id;\n\t\tbuf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));\n\t\tsignal_id = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(send_button),\n\t\t                                              \"buffer-signal\"));\n\t\tif (buf && signal_id)\n\t\t\tg_signal_handler_disconnect(G_OBJECT(buf), signal_id);\n\t\tgtk_widget_destroy(send_button);\n\t\tg_object_set_data(G_OBJECT(gtkconv->lower_hbox),\n\t\t                  \"send_button\", NULL);\n\t}\n}\n", "bug_type": null, "idx": 601}
{"project": "Pidgin", "target": 0, "func": "static GSList *\nx509_importcerts_from_file(const gchar * filename)\n{\n\tPurpleCertificate *crt;  \n\tgchar *buf;        \n\tgchar *begin, *end;\n\tGSList *crts = NULL;\n\tgsize buf_sz;      \n\tgnutls_datum_t dt; \n\tpurple_debug_info(\"gnutls\",\n\t\t\t  \"Attempting to load X.509 certificates from %s\\n\",\n\t\t\t  filename);\n\t\n\t\n\tg_return_val_if_fail(\n\t\tg_file_get_contents(filename,\n\t\t\t    &buf,\n\t\t\t    &buf_sz,\n\t\t\t    NULL      \n\t\t),\n\t\tNULL);\n\tbegin = buf;\n\twhile((end = strstr(begin, \"-----END CERTIFICATE-----\")) != NULL) {\n\t\tend += sizeof(\"-----END CERTIFICATE-----\")-1;\n\t\t\n\t\tdt.data = (unsigned char *) begin;\n\t\tdt.size = (end-begin);\n\t\t\n\t\tcrt = x509_import_from_datum(dt, GNUTLS_X509_FMT_PEM);\n\t\tif (crt != NULL) {\n\t\t\tcrts = g_slist_prepend(crts, crt);\n\t\t}\n\t\tbegin = end;\n\t}\n\t\n\tg_free(buf);\n\treturn crts;\n}\n", "bug_type": null, "idx": 602}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ndestroy_timeout_handler(PurplePerlTimeoutHandler *handler)\n{\n\tgboolean ret = FALSE;\n\ttimeout_handlers = g_slist_remove(timeout_handlers, handler);\n\tif (handler->iotag > 0)\n\t\tret = purple_timeout_remove(handler->iotag);\n\tif (handler->callback != NULL)\n\t\tSvREFCNT_dec(handler->callback);\n\tif (handler->data != NULL)\n\t\tSvREFCNT_dec(handler->data);\n\tg_free(handler);\n\treturn ret;\n}\n", "bug_type": null, "idx": 603}
{"project": "Pidgin", "target": 0, "func": "static void\nx509_singleuse_destroy_request (PurpleCertificateVerificationRequest *vrq)\n{\n\t\n}\n", "bug_type": null, "idx": 604}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_conversation_chat_cleanup_for_rejoin(PurpleConversation *conv)\n{\n\tconst char *disp;\n\tPurpleAccount *account;\n\tPurpleConnection *gc;\n\taccount = purple_conversation_get_account(conv);\n\tpurple_conversation_close_logs(conv);\n\topen_log(conv);\n\tgc = purple_account_get_connection(account);\n\tif ((disp = purple_connection_get_display_name(gc)) != NULL)\n\t\tpurple_conv_chat_set_nick(PURPLE_CONV_CHAT(conv), disp);\n\telse\n\t{\n\t\tpurple_conv_chat_set_nick(PURPLE_CONV_CHAT(conv),\n\t\t\t\t\t\t\t\tpurple_account_get_username(account));\n\t}\n\tpurple_conv_chat_clear_users(PURPLE_CONV_CHAT(conv));\n\tpurple_conv_chat_set_topic(PURPLE_CONV_CHAT(conv), NULL, NULL);\n\tPURPLE_CONV_CHAT(conv)->left = FALSE;\n\tpurple_conversation_update(conv, PURPLE_CONV_UPDATE_CHATLEFT);\n}\n", "bug_type": null, "idx": 605}
{"project": "Pidgin", "target": 0, "func": "static void\n_evt_conference_invite_notify(NMUser * user, NMEvent * event)\n{\n\tPurpleConversation *gconv;\n\tNMConference *conference;\n\tNMUserRecord *user_record = NULL;\n\tchar *str = NULL;\n\tuser_record = nm_find_user_record(user, nm_event_get_source(event));\n\tconference = nm_event_get_conference(event);\n\tif (user_record && conference) {\n\t\tgconv = nm_conference_get_data(conference);\n\t\tstr = g_strdup_printf(_(\"%s has been invited to this conversation.\"),\n\t\t\t\t\t\t\t  nm_user_record_get_display_id(user_record));\n\t\tpurple_conversation_write(gconv, NULL, str,\n\t\t\t\t\t\t\t\tPURPLE_MESSAGE_SYSTEM, time(NULL));\n\t\tg_free(str);\n\t}\n}\n", "bug_type": null, "idx": 606}
{"project": "Pidgin", "target": 0, "func": "PurpleSrvTxtQueryUiOps *\npurple_srv_txt_query_get_ui_ops(void)\n{\n\t\n\treturn srv_txt_query_ui_ops;\n}\n", "bug_type": null, "idx": 607}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_status_get_attr_string(const PurpleStatus *status, const char *id)\n{\n\tconst PurpleValue *value;\n\tg_return_val_if_fail(status != NULL, NULL);\n\tg_return_val_if_fail(id     != NULL, NULL);\n\tif ((value = purple_status_get_attr_value(status, id)) == NULL)\n\t\treturn NULL;\n\tg_return_val_if_fail(purple_value_get_type(value) == PURPLE_TYPE_STRING, NULL);\n\treturn purple_value_get_string(value);\n}\n", "bug_type": null, "idx": 608}
{"project": "Pidgin", "target": 0, "func": "static const char *simple_list_icon(PurpleAccount *a, PurpleBuddy *b) {\n\treturn \"simple\";\n}\n", "bug_type": null, "idx": 609}
{"project": "Pidgin", "target": 0, "func": "PurpleMood*\nicq_get_purple_moods(PurpleAccount *account)\n{\n\treturn icq_purple_moods;\n}\n", "bug_type": null, "idx": 610}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddy_typing_stopped_cb(PurpleAccount *account, const char *name, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"buddy-typing-stopped (%s, %s)\\n\",\n\t\t\t\t\tpurple_account_get_username(account), name);\n}\n", "bug_type": null, "idx": 611}
{"project": "Pidgin", "target": 0, "func": "static void\n_rename_folder_resp_cb(NMUser * user, NMERR_T ret_code,\n\t\t\t\t\t   gpointer resp_data, gpointer user_data)\n{\n\tif (ret_code != NM_OK) {\n\t\t\n\t\tpurple_debug(PURPLE_DEBUG_INFO, \"novell\",\n\t\t\t\t   \"_rename_folder_resp_cb(): rc = 0x%x\\n\", ret_code);\n\t}\n}\n", "bug_type": null, "idx": 612}
{"project": "Pidgin", "target": 0, "func": "static void\ncipher_added_cb(PurpleCipher *cipher, void *data) {\n\tpurple_debug_misc(\"signals test\", \"cipher %s added\\n\",\n\t\t\t\t\tpurple_cipher_get_name(cipher));\n}\n", "bug_type": null, "idx": 613}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\nget_voice_test_frame(PurplePlugin *plugin)\n{\n\tGtkWidget *vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BORDER);\n\tGtkWidget *level = gtk_progress_bar_new();\n\tGtkWidget *volume = gtk_hscale_new_with_range(0, 100, 1);\n\tGtkWidget *threshold = gtk_hscale_new_with_range(0, 100, 1);\n\tGtkWidget *label;\n\tGtkTable *table = GTK_TABLE(gtk_table_new(2, 2, FALSE));\n\tGstElement *pipeline;\n\tGstBus *bus;\n\tBusCbCtx *ctx;\n\tg_object_set(vbox, \"width-request\", 500, NULL);\n\tgtk_table_set_row_spacings(table, PIDGIN_HIG_BOX_SPACE);\n\tgtk_table_set_col_spacings(table, PIDGIN_HIG_BOX_SPACE);\n\tlabel = gtk_label_new(_(\"Volume:\"));\n\tg_object_set(label, \"xalign\", 0.0, NULL);\n\tgtk_table_attach(table, label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);\n\tgtk_table_attach_defaults(table, volume, 1, 2, 0, 1);\n\tlabel = gtk_label_new(_(\"Silence threshold:\"));\n\tg_object_set(label, \"xalign\", 0.0, \"yalign\", 1.0, NULL);\n\tgtk_table_attach(table, label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0);\n\tgtk_table_attach_defaults(table, threshold, 1, 2, 1, 2);\n\tgtk_container_add(GTK_CONTAINER(vbox), level);\n\tgtk_container_add(GTK_CONTAINER(vbox), GTK_WIDGET(table));\n\tgtk_widget_show_all(vbox);\n\tpipeline = create_pipeline();\n\tbus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));\n\tgst_bus_add_signal_watch(bus);\n\tctx = g_new(BusCbCtx, 1);\n\tctx->level = GTK_PROGRESS_BAR(level);\n\tctx->threshold = GTK_RANGE(threshold);\n\tg_signal_connect_data(bus, \"message\", G_CALLBACK(gst_bus_cb),\n\t\t\tctx, (GClosureNotify)g_free, 0);\n\tgst_object_unref(bus);\n\tg_signal_connect(volume, \"value-changed\",\n\t\t\t(GCallback)on_volume_change_cb, pipeline);\n\tgtk_range_set_value(GTK_RANGE(volume),\n\t\t\tpurple_prefs_get_int(\"/purple/media/audio/volume/input\"));\n\tgtk_widget_set(volume, \"draw-value\", FALSE, NULL);\n\tgtk_range_set_value(GTK_RANGE(threshold),\n\t\t\tpurple_prefs_get_int(\"/purple/media/audio/silence_threshold\"));\n\tg_signal_connect(vbox, \"destroy\",\n\t\t\tG_CALLBACK(voice_test_frame_destroy_cb), pipeline);\n\tg_signal_connect(volume, \"destroy\",\n\t\t\tG_CALLBACK(volume_scale_destroy_cb), NULL);\n\tg_signal_connect(threshold, \"format-value\",\n\t\t\tG_CALLBACK(threshold_value_format_cb), NULL);\n\tg_signal_connect(threshold, \"destroy\",\n\t\t\tG_CALLBACK(threshold_scale_destroy_cb), NULL);\n\treturn vbox;\n}\n", "bug_type": null, "idx": 614}
{"project": "Pidgin", "target": 0, "func": "static void\nsmiley_theme_pref_cb(const char *name, PurplePrefType type,\n\t\t\t\t\t gconstpointer value, gpointer data)\n{\n\tconst char *themename = value;\n\tGSList *themes;\n\tfor (themes = smiley_themes; themes; themes = themes->next) {\n\t\tstruct smiley_theme *smile = themes->data;\n\t\tif (smile->name && strcmp(themename, smile->name) == 0) {\n\t\t\tpidgin_themes_load_smiley_theme(smile->path, TRUE);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 615}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_si_xfer_ibb_error_cb(JabberIBBSession *sess)\n{\n\tPurpleXfer *xfer = (PurpleXfer *) jabber_ibb_session_get_user_data(sess);\n\tpurple_debug_error(\"jabber\", \"an error occurred during IBB file transfer\\n\");\n\tpurple_xfer_cancel_remote(xfer);\n}\n", "bug_type": null, "idx": 616}
{"project": "Pidgin", "target": 0, "func": "int gg_userlist_remove_watch_fd(struct gg_http *h)\n{\n\terrno = EINVAL;\n\treturn -1;\n}\n", "bug_type": null, "idx": 617}
{"project": "Pidgin", "target": 0, "func": "static PurpleCmdRet\nperl_cmd_cb(PurpleConversation *conv, const gchar *command,\n            gchar **args, gchar **error, void *data)\n{\n\tint i = 0, count, ret_value = PURPLE_CMD_RET_OK;\n\tSV *cmdSV, *tmpSV, *convSV;\n\tPurplePerlCmdHandler *handler = data;\n\tdSP;\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\t\n\tconvSV = sv_2mortal(purple_perl_bless_object(conv, \"Purple::Conversation\"));\n\tXPUSHs(convSV);\n\t\n\tcmdSV = newSVpv(command, 0);\n\tcmdSV = sv_2mortal(cmdSV);\n\tXPUSHs(cmdSV);\n\t\n\tXPUSHs((SV *)handler->data);\n\t\n\tfor (i = 0; args[i] != NULL; i++) {\n\t\t\n\t\ttmpSV = newSVpv(args[i], 0);\n\t\ttmpSV = sv_2mortal(tmpSV);\n\t\tXPUSHs(tmpSV);\n\t}\n\tPUTBACK;\n\tcount = call_sv(handler->callback, G_EVAL | G_SCALAR);\n\tif (count != 1)\n\t\tcroak(\"call_sv: Did not return the correct number of values.\\n\");\n\tif (SvTRUE(ERRSV)) {\n\t\tpurple_debug_error(\"perl\",\n\t\t                 \"Perl plugin command function exited abnormally: %s\\n\",\n\t\t                 SvPVutf8_nolen(ERRSV));\n\t}\n\tSPAGAIN;\n\tret_value = POPi;\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n\treturn ret_value;\n}\n", "bug_type": null, "idx": 618}
{"project": "Pidgin", "target": 0, "func": "size_t gg105_login__get_packed_size\n                     (const GG105Login *message)\n{\n  assert(message->base.descriptor == &gg105_login__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\n", "bug_type": null, "idx": 619}
{"project": "Pidgin", "target": 0, "func": "void\npurple_prefs_trigger_callback(const char *name)\n{\n\tstruct purple_pref *pref;\n\tPurplePrefsUiOps *uiop = purple_prefs_get_ui_ops();\n\tif (uiop && uiop->connect_callback) {\n\t\tdo_ui_callbacks(name);\n\t\treturn;\n\t}\n\tpref = find_pref(name);\n\tif(!pref) {\n\t\tpurple_debug_error(\"prefs\",\n\t\t\t\t\"purple_prefs_trigger_callback: Unknown pref %s\\n\", name);\n\t\treturn;\n\t}\n\tdo_callbacks(name, pref);\n}\n", "bug_type": null, "idx": 620}
{"project": "Pidgin", "target": 0, "func": "static void\n_add_folders(NMFolder * root, NMField * fields)\n{\n\tNMFolder *folder = NULL;\n\tNMField *locate = NULL;\n\tlocate = nm_locate_field(NM_A_FA_FOLDER, fields);\n\twhile (locate != NULL) {\n\t\t\n\t\tfolder = nm_create_folder_from_fields(locate);\n\t\t\n\t\tnm_folder_add_folder_to_list(root, folder);\n\t\t\n\t\tnm_release_folder(folder);\n\t\t\n\t\tlocate = nm_locate_field(NM_A_FA_FOLDER, locate+1);\n\t}\n}\n", "bug_type": null, "idx": 621}
{"project": "Pidgin", "target": 0, "func": "size_t gg112_transfer_info_uin__get_packed_size\n                     (const GG112TransferInfoUin *message)\n{\n  assert(message->base.descriptor == &gg112_transfer_info_uin__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\n", "bug_type": null, "idx": 622}
{"project": "Pidgin", "target": 0, "func": "struct gg_http *gg_change_passwd2(uin_t uin, const char *passwd,\n\tconst char *newpasswd, const char *email, const char *newemail,\n\tint async)\n{\n\tgg_debug(GG_DEBUG_MISC, \"// gg_change_passwd2() is obsolete. use gg_change_passwd4() instead!\\n\");\n\terrno = EINVAL;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 623}
{"project": "Pidgin", "target": 0, "func": "static void\ninsert_smiley_text(GtkWidget *widget, GtkIMHtmlToolbar *toolbar)\n{\n\tchar *smiley_text, *escaped_smiley;\n\tsmiley_text = g_object_get_data(G_OBJECT(widget), \"smiley_text\");\n\tescaped_smiley = g_markup_escape_text(smiley_text, -1);\n\tgtk_imhtml_insert_smiley(GTK_IMHTML(toolbar->imhtml),\n\t\t\t\t\t\t\t GTK_IMHTML(toolbar->imhtml)->protocol_name,\n\t\t\t\t\t\t\t escaped_smiley);\n\tg_free(escaped_smiley);\n\tclose_smiley_dialog(toolbar);\n}\n", "bug_type": null, "idx": 624}
{"project": "Pidgin", "target": 0, "func": " */\ngboolean aim_ssi_waitingforauth(struct aim_ssi_item *list, const char *gn, const char *bn)\n{\n\tstruct aim_ssi_item *cur = aim_ssi_itemlist_finditem(list, gn, bn, AIM_SSI_TYPE_BUDDY);\n\tif (cur) {\n\t\tif (aim_tlv_gettlv(cur->data, 0x0066, 1))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 625}
{"project": "Pidgin", "target": 0, "func": "static void\nchat_sent_im(PurpleAccount *account, const char *message, int id)\n{\n\tPurpleConversation *conv = NULL;\n\tif (purple_prefs_get_bool(\"/plugins/gtk/X11/notify/notify_send\")) {\n\t\tconv = purple_find_chat(purple_account_get_connection(account), id);\n\t\tunnotify(conv, TRUE);\n\t}\n}\n", "bug_type": null, "idx": 626}
{"project": "Pidgin", "target": 0, "func": "static void\njingle_content_finalize (GObject *content)\n{\n\tJingleContentPrivate *priv = JINGLE_CONTENT_GET_PRIVATE(content);\n\tpurple_debug_info(\"jingle\",\"jingle_content_finalize\\n\");\n\tg_free(priv->description_type);\n\tg_free(priv->creator);\n\tg_free(priv->disposition);\n\tg_free(priv->name);\n\tg_free(priv->senders);\n\tg_object_unref(priv->transport);\n\tif (priv->pending_transport)\n\t\tg_object_unref(priv->pending_transport);\n\tparent_class->finalize(content);\n}\n", "bug_type": null, "idx": 627}
{"project": "Pidgin", "target": 0, "func": "void\npurple_connection_set_protocol_data(PurpleConnection *connection, void *proto_data) {\n\tg_return_if_fail(connection != NULL);\n\tconnection->proto_data = proto_data;\n}\n", "bug_type": null, "idx": 628}
{"project": "Pidgin", "target": 0, "func": "static void simple_send_message(struct simple_account_data *sip, const char *to, const char *msg, const char *type) {\n\tgchar *hdr;\n\tgchar *fullto;\n\tif(strncmp(to, \"sip:\", 4))\n\t\tfullto = g_strdup_printf(\"sip:%s\", to);\n\telse\n\t\tfullto = g_strdup(to);\n\tif(type) {\n\t\thdr = g_strdup_printf(\"Content-Type: %s\\r\\n\", type);\n\t} else {\n\t\thdr = g_strdup(\"Content-Type: text/plain\\r\\n\");\n\t}\n\tsend_sip_request(sip->gc, \"MESSAGE\", fullto, fullto, hdr, msg, NULL, NULL);\n\tg_free(hdr);\n\tg_free(fullto);\n}\n", "bug_type": null, "idx": 629}
{"project": "Pidgin", "target": 0, "func": "void finch_log_init(void)\n{\n\tvoid *handle = finch_log_get_handle();\n\tpurple_signal_register(handle, \"log-displaying\",\n\t                     purple_marshal_VOID__POINTER_POINTER,\n\t                     NULL, 2,\n\t                     purple_value_new(PURPLE_TYPE_BOXED,\n\t                                    \"FinchLogViewer *\"),\n\t                     purple_value_new(PURPLE_TYPE_SUBTYPE,\n\t                                    PURPLE_SUBTYPE_LOG));\n}\n", "bug_type": null, "idx": 630}
{"project": "Pidgin", "target": 0, "func": "void gnt_text_view_append_text_with_tag(GntTextView *view, const char *text,\n\t\t\tGntTextFormatFlags flags, const char *tagname)\n{\n\tGntWidget *widget = GNT_WIDGET(view);\n\tchtype fl = 0;\n\tconst char *start, *end;\n\tGList *list = view->list;\n\tGntTextLine *line;\n\tint len;\n\tgboolean has_scroll = !(view->flags & GNT_TEXT_VIEW_NO_SCROLL);\n\tgboolean wrap_word = !(view->flags & GNT_TEXT_VIEW_WRAP_CHAR);\n\tif (text == NULL || *text == '\\0')\n\t\treturn;\n\tfl = gnt_text_format_flag_to_chtype(flags);\n\tlen = view->string->len;\n\tview->string = g_string_append(view->string, text);\n\tif (tagname) {\n\t\tGntTextTag *tag = g_new0(GntTextTag, 1);\n\t\ttag->name = g_strdup(tagname);\n\t\ttag->start = len;\n\t\ttag->end = view->string->len;\n\t\tview->tags = g_list_append(view->tags, tag);\n\t}\n\tview->list = g_list_first(view->list);\n\tstart = end = view->string->str + len;\n\twhile (*start) {\n\t\tGntTextLine *oldl;\n\t\tGntTextSegment *seg = NULL;\n\t\tif (*end == '\\n' || *end == '\\r') {\n\t\t\tif (!strncmp(end, \"\\r\\n\", 2))\n\t\t\t\tend++;\n\t\t\tend++;\n\t\t\tstart = end;\n\t\t\tgnt_text_view_next_line(view);\n\t\t\tview->list = g_list_first(view->list);\n\t\t\tcontinue;\n\t\t}\n\t\tline = view->list->data;\n\t\tif (line->length == widget->priv.width - has_scroll) {\n\t\t\t\n\t\t\tline = g_new0(GntTextLine, 1);\n\t\t\tline->soft = TRUE;\n\t\t\tview->list = g_list_prepend(view->list, line);\n\t\t}\n\t\tif ((end = strchr(start, '\\r')) != NULL ||\n\t\t\t(end = strchr(start, '\\n')) != NULL) {\n\t\t\tlen = gnt_util_onscreen_width(start, end - has_scroll);\n\t\t\tif (widget->priv.width > 0 &&\n\t\t\t\t\tlen >= widget->priv.width - line->length - has_scroll) {\n\t\t\t\tend = NULL;\n\t\t\t}\n\t\t}\n\t\tif (end == NULL)\n\t\t\tend = gnt_util_onscreen_width_to_pointer(start,\n\t\t\t\t\twidget->priv.width - line->length - has_scroll, &len);\n\t\t\n\t\tif (line->segments) {\n\t\t\tseg = g_list_last(line->segments)->data;\n\t\t\tif (seg->flags != fl)\n\t\t\t\tseg = NULL;\n\t\t}\n\t\tif (seg == NULL) {\n\t\t\tseg = g_new0(GntTextSegment, 1);\n\t\t\tseg->start = start - view->string->str;\n\t\t\tseg->tvflag = flags;\n\t\t\tseg->flags = fl;\n\t\t\tline->segments = g_list_append(line->segments, seg);\n\t\t}\n\t\toldl = line;\n\t\tif (wrap_word && *end && *end != '\\n' && *end != '\\r') {\n\t\t\tconst char *tmp = end;\n\t\t\twhile (end && *end != '\\n' && *end != '\\r' && !g_ascii_isspace(*end)) {\n\t\t\t\tend = g_utf8_find_prev_char(seg->start + view->string->str, end);\n\t\t\t}\n\t\t\tif (!end || !g_ascii_isspace(*end))\n\t\t\t\tend = tmp;\n\t\t\telse\n\t\t\t\tend++; \n\t\t\tline = g_new0(GntTextLine, 1);\n\t\t\tline->soft = TRUE;\n\t\t\tview->list = g_list_prepend(view->list, line);\n\t\t}\n\t\tseg->end = end - view->string->str;\n\t\toldl->length += len;\n\t\tstart = end;\n\t}\n\tview->list = list;\n\tgnt_widget_draw(widget);\n}\n", "bug_type": null, "idx": 631}
{"project": "Pidgin", "target": 0, "func": "void\naim_admin_setemail(OscarData *od, FlapConnection *conn, const char *newemail)\n{\n\tByteStream bs;\n\taim_snacid_t snacid;\n\tGSList *tlvlist = NULL;\n\tbyte_stream_new(&bs, 2+2+strlen(newemail));\n\taim_tlvlist_add_str(&tlvlist, 0x0011, newemail);\n\taim_tlvlist_write(&bs, &tlvlist);\n\taim_tlvlist_free(tlvlist);\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_ADMIN, 0x0004, 0x0000, NULL, 0);\n\tflap_connection_send_snac(od, conn, SNAC_FAMILY_ADMIN, 0x0004, snacid, &bs);\n\tbyte_stream_destroy(&bs);\n}\n", "bug_type": null, "idx": 632}
{"project": "Pidgin", "target": 0, "func": "char **gnt_style_get_string_list(const char *group, const char *key, gsize *length)\n{\n#if GLIB_CHECK_VERSION(2,6,0)\n\tconst char *prg = g_get_prgname();\n\tif ((group == NULL || *group == '\\0') && prg &&\n\t\t\tg_key_file_has_group(gkfile, prg))\n\t\tgroup = prg;\n\tif (!group)\n\t\tgroup = \"general\";\n\treturn g_key_file_get_string_list(gkfile, group, key, length, NULL);\n#else\n\treturn NULL;\n#endif\n}\n", "bug_type": null, "idx": 633}
{"project": "Pidgin", "target": 0, "func": "void\npurple_plugins_register_unload_notify_cb(void (*func)(PurplePlugin *, void *),\n\t\t\t\t\t\t\t\t\t   void *data)\n{\n\tunload_cb = func;\n\tunload_cb_data = data;\n}\n", "bug_type": null, "idx": 634}
{"project": "Pidgin", "target": 0, "func": "static gboolean on_offline_can_add_node(PurpleBlistNode *node)\n{\n\tswitch (purple_blist_node_get_type(node)) {\n\t\tcase PURPLE_BLIST_CONTACT_NODE:\n\t\t\t{\n\t\t\t\tPurpleContact *contact = (PurpleContact*)node;\n\t\t\t\tif (contact->currentsize > 0)\n\t\t\t\t\treturn TRUE;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_BLIST_BUDDY_NODE:\n\t\t\t{\n\t\t\t\tPurpleBuddy *buddy = (PurpleBuddy*)node;\n\t\t\t\tif (PURPLE_BUDDY_IS_ONLINE(buddy))\n\t\t\t\t\treturn TRUE;\n\t\t\t\tif (purple_prefs_get_bool(\"/finch/blist/showoffline\") &&\n\t\t\t\t\t\tpurple_account_is_connected(purple_buddy_get_account(buddy)))\n\t\t\t\t\treturn TRUE;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_BLIST_CHAT_NODE:\n\t\t\t{\n\t\t\t\tPurpleChat *chat = (PurpleChat*)node;\n\t\t\t\treturn purple_account_is_connected(purple_chat_get_account(chat));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n}\n", "bug_type": null, "idx": 635}
{"project": "Pidgin", "target": 0, "func": "static void\nchat_sent_im(PurpleAccount *account, const char *message, int id)\n{\n\tPurpleConversation *conv = NULL;\n\tconv = purple_find_chat(purple_account_get_connection(account), id);\n\tunalert(conv);\n}\n", "bug_type": null, "idx": 636}
{"project": "Pidgin", "target": 0, "func": " */\nchar *irc_mirc2html(const char *string)\n{\n\tconst char *cur, *end;\n\tchar fg[3] = \"\\0\\0\", bg[3] = \"\\0\\0\";\n\tint fgnum, bgnum;\n\tint font = 0, bold = 0, underline = 0, italic = 0;\n\tGString *decoded;\n\tif (string == NULL)\n\t\treturn NULL;\n\tdecoded = g_string_sized_new(strlen(string));\n\tcur = string;\n\tdo {\n\t\tend = strpbrk(cur, \"\\002\\003\\007\\017\\026\\037\");\n\t\tdecoded = g_string_append_len(decoded, cur, (end ? (gssize)(end - cur) : (gssize)strlen(cur)));\n\t\tcur = end ? end : cur + strlen(cur);\n\t\tswitch (*cur) {\n\t\tcase '\\002':\n\t\t\tcur++;\n\t\t\tif (!bold) {\n\t\t\t\tdecoded = g_string_append(decoded, \"<B>\");\n\t\t\t\tbold = TRUE;\n\t\t\t} else {\n\t\t\t\tdecoded = g_string_append(decoded, \"</B>\");\n\t\t\t\tbold = FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\003':\n\t\t\tcur++;\n\t\t\tfg[0] = fg[1] = bg[0] = bg[1] = '\\0';\n\t\t\tif (isdigit(*cur))\n\t\t\t\tfg[0] = *cur++;\n\t\t\tif (isdigit(*cur))\n\t\t\t\tfg[1] = *cur++;\n\t\t\tif (*cur == ',') {\n\t\t\t\tcur++;\n\t\t\t\tif (isdigit(*cur))\n\t\t\t\t\tbg[0] = *cur++;\n\t\t\t\tif (isdigit(*cur))\n\t\t\t\t\tbg[1] = *cur++;\n\t\t\t}\n\t\t\tif (font) {\n\t\t\t\tdecoded = g_string_append(decoded, \"</FONT>\");\n\t\t\t\tfont = FALSE;\n\t\t\t}\n\t\t\tif (fg[0]) {\n\t\t\t\tfgnum = atoi(fg);\n\t\t\t\tif (fgnum < 0 || fgnum > 15)\n\t\t\t\t\tcontinue;\n\t\t\t\tfont = TRUE;\n\t\t\t\tg_string_append_printf(decoded, \"<FONT COLOR=\\\"%s\\\"\", irc_mirc_colors[fgnum]);\n\t\t\t\tif (bg[0]) {\n\t\t\t\t\tbgnum = atoi(bg);\n\t\t\t\t\tif (bgnum >= 0 && bgnum < 16)\n\t\t\t\t\t\tg_string_append_printf(decoded, \" BACK=\\\"%s\\\"\", irc_mirc_colors[bgnum]);\n\t\t\t\t}\n\t\t\t\tdecoded = g_string_append_c(decoded, '>');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\011':\n\t\t\tcur++;\n\t\t\tif (!italic) {\n\t\t\t\tdecoded = g_string_append(decoded, \"<I>\");\n\t\t\t\titalic = TRUE;\n\t\t\t} else {\n\t\t\t\tdecoded = g_string_append(decoded, \"</I>\");\n\t\t\t\titalic = FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\037':\n\t\t\tcur++;\n\t\t\tif (!underline) {\n\t\t\t\tdecoded = g_string_append(decoded, \"<U>\");\n\t\t\t\tunderline = TRUE;\n\t\t\t} else {\n\t\t\t\tdecoded = g_string_append(decoded, \"</U>\");\n\t\t\t\tunderline = FALSE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\007':\n\t\tcase '\\026':\n\t\t\tcur++;\n\t\t\tbreak;\n\t\tcase '\\017':\n\t\t\tcur++;\n\t\t\t\n\t\tcase '\\000':\n\t\t\tif (bold)\n\t\t\t\tdecoded = g_string_append(decoded, \"</B>\");\n\t\t\tif (italic)\n\t\t\t\tdecoded = g_string_append(decoded, \"</I>\");\n\t\t\tif (underline)\n\t\t\t\tdecoded = g_string_append(decoded, \"</U>\");\n\t\t\tif (font)\n\t\t\t\tdecoded = g_string_append(decoded, \"</FONT>\");\n\t\t\tbold = italic = underline = font = FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"irc\", \"Unexpected mIRC formatting character %d\\n\", *cur);\n\t\t}\n\t} while (*cur);\n\treturn g_string_free(decoded, FALSE);\n}\n", "bug_type": null, "idx": 637}
{"project": "Pidgin", "target": 0, "func": "static void\ncalc_resp(guint8 *keys, const guint8 *plaintext, unsigned char *results)\n{\n\tguint8 key[8];\n\tsetup_des_key(keys, key);\n\tdes_ecb_encrypt(plaintext, results, key);\n\tsetup_des_key(keys + 7, key);\n\tdes_ecb_encrypt(plaintext, results + 8, key);\n\tsetup_des_key(keys + 14, key);\n\tdes_ecb_encrypt(plaintext, results + 16, key);\n}\n", "bug_type": null, "idx": 638}
{"project": "Pidgin", "target": 0, "func": "static gboolean\naccount_autojoin_cb(PurpleConnection *gc, gpointer null)\n{\n\tg_idle_add(auto_join_chats, gc);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 639}
{"project": "Pidgin", "target": 0, "func": " */\nstruct gg_http *gg_register3(const char *email, const char *password,\n\tconst char *tokenid, const char *tokenval, int async)\n{\n\tstruct gg_http *h;\n\tchar *__pwd, *__email, *__tokenid, *__tokenval, *form, *query;\n\tif (!email || !password || !tokenid || !tokenval) {\n\t\tgg_debug(GG_DEBUG_MISC, \"=> register, NULL parameter\\n\");\n\t\terrno = EFAULT;\n\t\treturn NULL;\n\t}\n\t__pwd = gg_urlencode(password);\n\t__email = gg_urlencode(email);\n\t__tokenid = gg_urlencode(tokenid);\n\t__tokenval = gg_urlencode(tokenval);\n\tif (!__pwd || !__email || !__tokenid || !__tokenval) {\n\t\tgg_debug(GG_DEBUG_MISC, \"=> register, not enough memory for form fields\\n\");\n\t\tfree(__pwd);\n\t\tfree(__email);\n\t\tfree(__tokenid);\n\t\tfree(__tokenval);\n\t\treturn NULL;\n\t}\n\tform = gg_saprintf(\"pwd=%s&email=%s&tokenid=%s&tokenval=%s&code=%u\",\n\t\t\t__pwd, __email, __tokenid, __tokenval,\n\t\t\tgg_http_hash(\"ss\", email, password));\n\tfree(__pwd);\n\tfree(__email);\n\tfree(__tokenid);\n\tfree(__tokenval);\n\tif (!form) {\n\t\tgg_debug(GG_DEBUG_MISC, \"=> register, not enough memory for form query\\n\");\n\t\treturn NULL;\n\t}\n\tgg_debug(GG_DEBUG_MISC, \"=> register, %s\\n\", form);\n\tquery = gg_saprintf(\n\t\t\"Host: \" GG_REGISTER_HOST \"\\r\\n\"\n\t\t\"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n\t\t\"User-Agent: \" GG_HTTP_USERAGENT \"\\r\\n\"\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"Pragma: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%s\",\n\t\t(int) strlen(form), form);\n\tfree(form);\n\tif (!query) {\n\t\tgg_debug(GG_DEBUG_MISC, \"=> register, not enough memory for query\\n\");\n\t\treturn NULL;\n\t}\n\tif (!(h = gg_http_connect(GG_REGISTER_HOST, GG_REGISTER_PORT, async,\n\t\t\"POST\", \"/appsvc/fmregister3.asp\", query)))\n\t{\n\t\tgg_debug(GG_DEBUG_MISC, \"=> register, gg_http_connect() failed mysteriously\\n\");\n\t\tfree(query);\n\t\treturn NULL;\n\t}\n\th->type = GG_SESSION_REGISTER;\n\tfree(query);\n\th->callback = gg_pubdir_watch_fd;\n\th->destroy = gg_pubdir_free;\n\tif (!async)\n\t\tgg_pubdir_watch_fd(h);\n\treturn h;\n}\n", "bug_type": null, "idx": 640}
{"project": "Pidgin", "target": 0, "func": "PidginBlistLayout *\npidgin_blist_theme_get_layout(PidginBlistTheme *theme)\n{\n\tPidginBlistThemePrivate *priv;\n\tg_return_val_if_fail(PIDGIN_IS_BLIST_THEME(theme), NULL);\n\tpriv = PIDGIN_BLIST_THEME_GET_PRIVATE(G_OBJECT(theme));\n\treturn priv->layout;\n}\n", "bug_type": null, "idx": 641}
{"project": "Pidgin", "target": 0, "func": "void finch_accounts_init()\n{\n\tGList *iter;\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-added\",\n\t\t\tfinch_accounts_get_handle(), PURPLE_CALLBACK(account_added_callback),\n\t\t\tNULL);\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-removed\",\n\t\t\tfinch_accounts_get_handle(), PURPLE_CALLBACK(account_removed_callback),\n\t\t\tNULL);\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-disabled\",\n\t\t\tfinch_accounts_get_handle(),\n\t\t\tPURPLE_CALLBACK(account_abled_cb), GINT_TO_POINTER(FALSE));\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-enabled\",\n\t\t\tfinch_accounts_get_handle(),\n\t\t\tPURPLE_CALLBACK(account_abled_cb), GINT_TO_POINTER(TRUE));\n\titer = purple_accounts_get_all();\n\tif (iter) {\n\t\tfor (; iter; iter = iter->next) {\n\t\t\tif (purple_account_get_enabled(iter->data, FINCH_UI))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!iter)\n\t\t\tfinch_accounts_show_all();\n\t} else {\n\t\tedit_account(NULL);\n\t\tfinch_accounts_show_all();\n\t}\n}\n", "bug_type": null, "idx": 642}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_do_uninit(void)\n{\n\t\n\tjabber_bosh_uninit();\n\tjabber_data_uninit();\n\tjabber_si_uninit();\n\tjabber_ibb_uninit();\n\t\n\tjabber_pep_uninit();\n\tjabber_caps_uninit();\n\tjabber_presence_uninit();\n\tjabber_iq_uninit();\n#ifdef USE_VV\n\tg_signal_handlers_disconnect_by_func(G_OBJECT(purple_media_manager_get()),\n\t\t\tG_CALLBACK(jabber_caps_broadcast_change), NULL);\n#endif\n\tjabber_auth_uninit();\n\tjabber_features_destroy();\n\tjabber_identities_destroy();\n\tg_hash_table_destroy(jabber_cmds);\n\tjabber_cmds = NULL;\n}\n", "bug_type": null, "idx": 643}
{"project": "Pidgin", "target": 0, "func": "static GSList *generate_presence_txt_records(BonjourDnsSd *data) {\n\tGSList *ret = NULL;\n\tPurpleKeyValuePair *kvp;\n\tchar portstring[6];\n\tconst char *jid, *aim, *email;\n\t\n\tsnprintf(portstring, sizeof(portstring), \"%d\", data->port_p2pj);\n\tjid = purple_account_get_string(data->account, \"jid\", NULL);\n\taim = purple_account_get_string(data->account, \"AIM\", NULL);\n\temail = purple_account_get_string(data->account, \"email\", NULL);\n#define _M_ADD_R(k, v) \\\n\tkvp = g_new0(PurpleKeyValuePair, 1); \\\n\tkvp->key = g_strdup(k); \\\n\tkvp->value = g_strdup(get_max_txt_record_value(k, v)); \\\n\tret = g_slist_prepend(ret, kvp); \\\n\t\n\t\n\t\n\t_M_ADD_R(\"txtvers\", \"1\")\n\t\n\t_M_ADD_R(\"1st\", data->first)\n\t\n\t_M_ADD_R(\"last\", data->last)\n\t\n\t_M_ADD_R(\"port.p2pj\", portstring)\n\t\n\t_M_ADD_R(\"status\", data->status)\n\t_M_ADD_R(\"node\", \"libpurple\")\n\t_M_ADD_R(\"ver\", VERSION)\n\t\n\t_M_ADD_R(\"vc\", data->vc)\n\tif (email != NULL && *email != '\\0') {\n\t\t_M_ADD_R(\"email\", email)\n\t}\n\tif (jid != NULL && *jid != '\\0') {\n\t\t_M_ADD_R(\"jid\", jid)\n\t}\n\t\n\tif (aim != NULL && *aim != '\\0') {\n\t\t_M_ADD_R(\"AIM\", aim)\n\t}\n\tif (data->msg != NULL && *data->msg != '\\0') {\n\t\t_M_ADD_R(\"msg\", data->msg)\n\t}\n\tif (data->phsh != NULL && *data->phsh != '\\0') {\n\t\t_M_ADD_R(\"phsh\", data->phsh)\n\t}\n\t\n\treturn ret;\n}\n", "bug_type": null, "idx": 644}
{"project": "Pidgin", "target": 0, "func": "gchar *\npurple_media_candidate_get_base_ip(PurpleMediaCandidate *candidate)\n{\n\tgchar *base_ip;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_CANDIDATE(candidate), NULL);\n\tg_object_get(candidate, \"base-ip\", &base_ip, NULL);\n\treturn base_ip;\n}\n", "bug_type": null, "idx": 645}
{"project": "Pidgin", "target": 0, "func": "size_t gg110_login_ok__pack\n                     (const GG110LoginOK *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &gg110_login_ok__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\n}\nsize_t gg110_login_ok__pack_to_buffer\n                     (const GG110LoginOK *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &gg110_login_ok__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\n", "bug_type": null, "idx": 646}
{"project": "Pidgin", "target": 0, "func": "void pidgin_blist_sort_method_set(const char *id){\n\tGList *l = pidgin_blist_sort_methods;\n\tif(!id)\n\t\tid = \"none\";\n\twhile (l && strcmp(((struct pidgin_blist_sort_method*)l->data)->id, id))\n\t\tl = l->next;\n\tif (l) {\n\t\tcurrent_sort_method = l->data;\n\t} else if (!current_sort_method) {\n\t\tpidgin_blist_sort_method_set(\"none\");\n\t\treturn;\n\t}\n\tif (!strcmp(id, \"none\")) {\n\t\tredo_buddy_list(purple_get_blist(), TRUE, FALSE);\n\t} else {\n\t\tredo_buddy_list(purple_get_blist(), FALSE, FALSE);\n\t}\n}\n", "bug_type": null, "idx": 647}
{"project": "Pidgin", "target": 0, "func": "int byte_stream_put8(ByteStream *bs, guint8 v)\n{\n\tg_return_val_if_fail(byte_stream_bytes_left(bs) >= 1, 0);\n\tbs->offset += aimutil_put8(bs->data + bs->offset, v);\n\treturn 1;\n}\n", "bug_type": null, "idx": 648}
{"project": "Pidgin", "target": 0, "func": "static void\nadd_account_statuses(GtkWidget *menu, PurpleAccount *account)\n{\n\tGList *l;\n\tfor (l = purple_account_get_status_types(account); l != NULL; l = l->next) {\n\t\tPurpleStatusType *status_type = (PurpleStatusType *)l->data;\n\t\tPurpleStatusPrimitive prim;\n\t\tif (!purple_status_type_is_user_settable(status_type))\n\t\t\tcontinue;\n\t\tprim = purple_status_type_get_primitive(status_type);\n\t\tnew_menu_item_with_status_icon(menu,\n\t\t\tpurple_status_type_get_name(status_type),\n\t\t\tprim, G_CALLBACK(activate_status_account_cb),\n\t\t\tstatus_type, 0, 0, NULL);\n\t}\n}\n", "bug_type": null, "idx": 649}
{"project": "Pidgin", "target": 0, "func": "static void\ntls_peers_mgmt_import_cancel2_cb(gpointer data, const char *result)\n{\n\tPurpleCertificate *crt = (PurpleCertificate *) data;\n\tpurple_certificate_destroy(crt);\n}\n", "bug_type": null, "idx": 650}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_menu_tray_class_init(PidginMenuTrayClass *klass) {\n\tGObjectClass *object_class = G_OBJECT_CLASS(klass);\n\tGtkItemClass *item_class = GTK_ITEM_CLASS(klass);\n\tGtkWidgetClass *widget_class = GTK_WIDGET_CLASS(klass);\n\tGParamSpec *pspec;\n\tparent_class = g_type_class_peek_parent(klass);\n\tobject_class->finalize = pidgin_menu_tray_finalize;\n\tobject_class->get_property = pidgin_menu_tray_get_property;\n\titem_class->select = pidgin_menu_tray_select;\n\titem_class->deselect = pidgin_menu_tray_deselect;\n\twidget_class->map = pidgin_menu_tray_map;\n\tpspec = g_param_spec_object(\"box\", \"The box\",\n\t\t\t\t\t\t\t\t\"The box\",\n\t\t\t\t\t\t\t\tGTK_TYPE_BOX,\n\t\t\t\t\t\t\t\tG_PARAM_READABLE);\n\tg_object_class_install_property(object_class, PROP_BOX, pspec);\n}\n", "bug_type": null, "idx": 651}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_si_xfer_bytestreams_listen_cb(int sock, gpointer data)\n{\n\tPurpleXfer *xfer = data;\n\tJabberSIXfer *jsx;\n\tJabberIq *iq;\n\txmlnode *query, *streamhost;\n\tchar port[6];\n\tGList *tmp;\n\tJabberBytestreamsStreamhost *sh, *sh2;\n\tint streamhost_count = 0;\n\tjsx = xfer->data;\n\tjsx->listen_data = NULL;\n\t\n\tif (purple_xfer_get_status(xfer) == PURPLE_XFER_STATUS_CANCEL_LOCAL) {\n\t\tpurple_xfer_unref(xfer);\n\t\treturn;\n\t}\n\tpurple_xfer_unref(xfer);\n\tiq = jabber_iq_new_query(jsx->js, JABBER_IQ_SET, NS_BYTESTREAMS);\n\txmlnode_set_attrib(iq->node, \"to\", xfer->who);\n\tquery = xmlnode_get_child(iq->node, \"query\");\n\txmlnode_set_attrib(query, \"sid\", jsx->stream_id);\n\t\n\tif (sock >= 0) {\n\t\tgchar *jid;\n\t\tGList *local_ips =\n\t\t\tpurple_network_get_all_local_system_ips();\n\t\tconst char *public_ip;\n\t\tgboolean has_public_ip = FALSE;\n\t\tjsx->local_streamhost_fd = sock;\n\t\tjid = g_strdup_printf(\"%s@%s/%s\", jsx->js->user->node,\n\t\t\tjsx->js->user->domain, jsx->js->user->resource);\n\t\txfer->local_port = purple_network_get_port_from_fd(sock);\n\t\tg_snprintf(port, sizeof(port), \"%hu\", (guint16)xfer->local_port);\n\t\tpublic_ip = purple_network_get_my_ip(jsx->js->fd);\n\t\t\n\t\twhile (local_ips) {\n\t\t\tgchar *local_ip = local_ips->data;\n\t\t\tstreamhost_count++;\n\t\t\tstreamhost = xmlnode_new_child(query, \"streamhost\");\n\t\t\txmlnode_set_attrib(streamhost, \"jid\", jid);\n\t\t\txmlnode_set_attrib(streamhost, \"host\", local_ip);\n\t\t\txmlnode_set_attrib(streamhost, \"port\", port);\n\t\t\tif (purple_strequal(local_ip, public_ip))\n\t\t\t\thas_public_ip = TRUE;\n\t\t\tg_free(local_ip);\n\t\t\tlocal_ips = g_list_delete_link(local_ips, local_ips);\n\t\t}\n\t\t\n\t\tif (!has_public_ip && strcmp(public_ip, \"0.0.0.0\") != 0) {\n\t\t\tstreamhost_count++;\n\t\t\tstreamhost = xmlnode_new_child(query, \"streamhost\");\n\t\t\txmlnode_set_attrib(streamhost, \"jid\", jid);\n\t\t\txmlnode_set_attrib(streamhost, \"host\", public_ip);\n\t\t\txmlnode_set_attrib(streamhost, \"port\", port);\n\t\t}\n\t\tg_free(jid);\n\t\t\n\t\txfer->watcher = purple_input_add(sock, PURPLE_INPUT_READ,\n\t\t\t\tjabber_si_xfer_bytestreams_send_connected_cb, xfer);\n\t}\n\tfor (tmp = jsx->js->bs_proxies; tmp; tmp = tmp->next) {\n\t\tsh = tmp->data;\n\t\t\n\t\tif (!(sh->jid && sh->host && sh->port > 0))\n\t\t\tcontinue;\n\t\tpurple_debug_info(\"jabber\", \"jabber_si_xfer_bytestreams_listen_cb() will be looking at jsx %p: jsx->streamhosts %p and sh->jid %p\\n\",\n\t\t\t\t\t\t  jsx, jsx->streamhosts, sh->jid);\n\t\tif(g_list_find_custom(jsx->streamhosts, sh->jid, jabber_si_compare_jid) != NULL)\n\t\t\tcontinue;\n\t\tstreamhost_count++;\n\t\tstreamhost = xmlnode_new_child(query, \"streamhost\");\n\t\txmlnode_set_attrib(streamhost, \"jid\", sh->jid);\n\t\txmlnode_set_attrib(streamhost, \"host\", sh->host);\n\t\tg_snprintf(port, sizeof(port), \"%hu\", (guint16)sh->port);\n\t\txmlnode_set_attrib(streamhost, \"port\", port);\n\t\tsh2 = g_new0(JabberBytestreamsStreamhost, 1);\n\t\tsh2->jid = g_strdup(sh->jid);\n\t\tsh2->host = g_strdup(sh->host);\n\t\t\n\t\tsh2->port = sh->port;\n\t\tjsx->streamhosts = g_list_prepend(jsx->streamhosts, sh2);\n\t}\n\t\n\tif (streamhost_count == 0) {\n\t\tjabber_iq_free(iq);\n\t\t\n\t\tif (jsx->stream_method & STREAM_METHOD_IBB) {\n\t\t\tpurple_debug_info(\"jabber\",\n\t\t\t\t\"jabber_si_xfer_bytestreams_listen_cb: trying to revert to IBB\\n\");\n\t\t\tif (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND) {\n\t\t\t\t\n\t\t\t\tjabber_si_xfer_ibb_send_init(jsx->js, xfer);\n\t\t\t} else {\n\t\t\t\tjsx->ibb_timeout_handle = purple_timeout_add_seconds(30,\n\t\t\t\t\tjabber_si_bytestreams_ibb_timeout_cb, xfer);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tpurple_xfer_cancel_local(xfer);\n\t\t}\n\t\treturn;\n\t}\n\tjabber_iq_set_callback(iq, jabber_si_connect_proxy_cb, xfer);\n\tjabber_iq_send(iq);\n}\n", "bug_type": null, "idx": 652}
{"project": "Pidgin", "target": 0, "func": "static void\nfree_add_user_data(AddUserData *data)\n{\n\tg_free(data->username);\n\tif (data->alias != NULL)\n\t\tg_free(data->alias);\n\tg_free(data);\n}\n", "bug_type": null, "idx": 653}
{"project": "Pidgin", "target": 0, "func": "void\npurple_certificate_pool_destroy_idlist(GList *idlist)\n{\n\tGList *l;\n\t\n\tfor ( l = idlist; l; l = l->next ) {\n\t\tg_free(l->data);\n\t}\n\tg_list_free(idlist);\n}\n", "bug_type": null, "idx": 654}
{"project": "Pidgin", "target": 0, "func": "static guint _purple_logsize_user_hash(struct _purple_logsize_user *lu)\n{\n\treturn g_str_hash(lu->name);\n}\n", "bug_type": null, "idx": 655}
{"project": "Pidgin", "target": 0, "func": "static void\nfile_ok_check_if_exists_cb(GtkWidget *widget, gint response, PidginRequestData *data)\n{\n\tgchar *current_folder;\n\tgeneric_response_start(data);\n\tif (response != GTK_RESPONSE_ACCEPT) {\n\t\tif (data->cbs[0] != NULL)\n\t\t\t((PurpleRequestFileCb)data->cbs[0])(data->user_data, NULL);\n\t\tpurple_request_close(data->type, data);\n\t\treturn;\n\t}\n\tdata->u.file.name = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(data->dialog));\n\tcurrent_folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(data->dialog));\n\tif (current_folder != NULL) {\n\t\tif (data->u.file.savedialog) {\n\t\t\tpurple_prefs_set_path(PIDGIN_PREFS_ROOT \"/filelocations/last_save_folder\", current_folder);\n\t\t} else {\n\t\t\tpurple_prefs_set_path(PIDGIN_PREFS_ROOT \"/filelocations/last_open_folder\", current_folder);\n\t\t}\n\t\tg_free(current_folder);\n\t}\n\tif ((data->u.file.savedialog == TRUE) &&\n\t\t(g_file_test(data->u.file.name, G_FILE_TEST_EXISTS))) {\n\t\tpurple_request_action(data, NULL, _(\"That file already exists\"),\n\t\t\t\t\t\t\t_(\"Would you like to overwrite it?\"), 0,\n\t\t\t\t\t\t\tNULL, NULL, NULL,\n\t\t\t\t\t\t\tdata, 2,\n\t\t\t\t\t\t\t_(\"Overwrite\"), G_CALLBACK(file_yes_no_cb),\n\t\t\t\t\t\t\t_(\"Choose New Name\"), G_CALLBACK(file_yes_no_cb));\n\t} else\n\t\tfile_yes_no_cb(data, 1);\n}\n", "bug_type": null, "idx": 656}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_multilogon_disconnect(struct gg_session *gs, gg_multilogon_id_t conn_id)\n{\n\tstruct gg_multilogon_disconnect pkt;\n\tpkt.conn_id = conn_id;\n\treturn gg_send_packet(gs, GG_MULTILOGON_DISCONNECT, &pkt, sizeof(pkt), NULL);\n}\n", "bug_type": null, "idx": 657}
{"project": "Pidgin", "target": 0, "func": "static inline void md4_transform_helper(struct MD4_Context *ctx)\n{\n\tle32_to_cpu_array(ctx->block, sizeof(ctx->block) / sizeof(guint32));\n\tmd4_transform(ctx->hash, ctx->block);\n}\n", "bug_type": null, "idx": 658}
{"project": "Pidgin", "target": 0, "func": "static char * trillian_logger_read (PurpleLog *log, PurpleLogReadFlags *flags)\n{\n\tstruct trillian_logger_data *data;\n\tchar *read;\n\tFILE *file;\n\tPurpleBuddy *buddy;\n\tchar *escaped;\n\tGString *formatted;\n\tchar *c;\n\tconst char *line;\n\tif (flags != NULL)\n\t\t*flags = PURPLE_LOG_READ_NO_NEWLINE;\n\tg_return_val_if_fail(log != NULL, g_strdup(\"\"));\n\tdata = log->logger_data;\n\tg_return_val_if_fail(data->path != NULL, g_strdup(\"\"));\n\tg_return_val_if_fail(data->length > 0, g_strdup(\"\"));\n\tg_return_val_if_fail(data->their_nickname != NULL, g_strdup(\"\"));\n\tpurple_debug_info(\"Trillian log read\", \"Reading %s\\n\", data->path);\n\tfile = g_fopen(data->path, \"rb\");\n\tg_return_val_if_fail(file != NULL, g_strdup(\"\"));\n\tread = g_malloc(data->length + 2);\n\tif (fseek(file, data->offset, SEEK_SET) != 0) {\n\t\tfclose(file);\n\t\tg_free(read);\n\t\tg_return_val_if_reached(g_strdup(\"\"));\n\t}\n\tdata->length = fread(read, 1, data->length, file);\n\tfclose(file);\n\tif (read[data->length-1] == '\\n') {\n\t\tread[data->length] = '\\0';\n\t} else {\n\t\tread[data->length] = '\\n';\n\t\tread[data->length+1] = '\\0';\n\t}\n\t\n\tbuddy = purple_find_buddy(log->account, log->name);\n\tescaped = g_markup_escape_text(read, -1);\n\tg_free(read);\n\tread = escaped;\n\t\n\tformatted = g_string_sized_new(strlen(read));\n\tc = read;\n\tline = read;\n\twhile (c)\n\t{\n\t\tconst char *link;\n\t\tconst char *footer = NULL;\n\t\tGString *temp = NULL;\n\t\t\n\t\tc = strchr(c, '\\n');\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*c = '\\0';\n\t\tc++;\n\t\t\n\t\twhile (line && (link = strstr(line, \"(Link: \")))\n\t\t{\n\t\t\tconst char *tmp = link;\n\t\t\tlink += 7;\n\t\t\tif (*link)\n\t\t\t{\n\t\t\t\tchar *end_paren;\n\t\t\t\tchar *space;\n\t\t\t\tif (!(end_paren = strchr(link, ')')))\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!temp)\n\t\t\t\t\ttemp = g_string_sized_new(strlen(line));\n\t\t\t\tg_string_append_len(temp, line, (tmp - line));\n\t\t\t\t\n\t\t\t\tg_string_append(temp, \"<a href=\\\"\");\n\t\t\t\t\n\t\t\t\tg_string_append_len(temp, link, end_paren - link);\n\t\t\t\t\n\t\t\t\tg_string_append(temp, \"\\\">\");\n\t\t\t\t\n\t\t\t\tif ((space = strchr(end_paren, ' ')) || (space = strchr(end_paren, '\\r')))\n\t\t\t\t{\n\t\t\t\t\tg_string_append_len(temp, end_paren + 1, space - end_paren - 1);\n\t\t\t\t\t\n\t\t\t\t\tg_string_append(temp, \"</a>\");\n\t\t\t\t\tspace++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tg_string_append(temp, end_paren + 1);\n\t\t\t\t\t\n\t\t\t\t\tg_string_append(temp, \"</a>\");\n\t\t\t\t}\n\t\t\t\tline = space;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (temp)\n\t\t{\n\t\t\tif (line)\n\t\t\t\tg_string_append(temp, line);\n\t\t\tline = temp->str;\n\t\t}\n\t\tif (line && *line == '[') {\n\t\t\tconst char *timestamp;\n\t\t\tif ((timestamp = strchr(line, ']'))) {\n\t\t\t\tline++;\n\t\t\t\t\n\t\t\t\tg_string_append(formatted, \"<font size=\\\"2\\\">(\");\n\t\t\t\tg_string_append_len(formatted, line, (timestamp - line));\n\t\t\t\tg_string_append(formatted,\")</font> \");\n\t\t\t\tline = timestamp + 1;\n\t\t\t\tif (line[0] && line[1])\n\t\t\t\t\tline++;\n\t\t\t}\n\t\t\tif (purple_str_has_prefix(line, \"*** \")) {\n\t\t\t\tline += (sizeof(\"*** \") - 1);\n\t\t\t\tg_string_append(formatted, \"<b>\");\n\t\t\t\tfooter = \"</b>\";\n\t\t\t\tif (purple_str_has_prefix(line, \"NOTE: This user is offline.\")) {\n\t\t\t\t\tline = _(\"User is offline.\");\n\t\t\t\t} else if (purple_str_has_prefix(line,\n\t\t\t\t\t\t\"NOTE: Your status is currently set to \")) {\n\t\t\t\t\tline += (sizeof(\"NOTE: \") - 1);\n\t\t\t\t} else if (purple_str_has_prefix(line, \"Auto-response sent to \")) {\n\t\t\t\t\tg_string_append(formatted, _(\"Auto-response sent:\"));\n\t\t\t\t\twhile (*line && *line != ':')\n\t\t\t\t\t\tline++;\n\t\t\t\t\tif (*line)\n\t\t\t\t\t\tline++;\n\t\t\t\t\tg_string_append(formatted, \"</b>\");\n\t\t\t\t\tfooter = NULL;\n\t\t\t\t} else if (strstr(line, \" signed off \")) {\n\t\t\t\t\tconst char *alias = NULL;\n\t\t\t\t\tif (buddy != NULL)\n\t\t\t\t\t\talias = purple_buddy_get_alias(buddy);\n\t\t\t\t\tif (alias != NULL) {\n\t\t\t\t\t\tg_string_append_printf(formatted,\n\t\t\t\t\t\t\t_(\"%s has signed off.\"), alias);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg_string_append_printf(formatted,\n\t\t\t\t\t\t\t_(\"%s has signed off.\"), log->name);\n\t\t\t\t\t}\n\t\t\t\t\tline = \"\";\n\t\t\t\t} else if (strstr(line, \" signed on \")) {\n\t\t\t\t\tconst char *alias = NULL;\n\t\t\t\t\tif (buddy != NULL)\n\t\t\t\t\t\talias = purple_buddy_get_alias(buddy);\n\t\t\t\t\tif (alias != NULL)\n\t\t\t\t\t\tg_string_append(formatted, alias);\n\t\t\t\t\telse\n\t\t\t\t\t\tg_string_append(formatted, log->name);\n\t\t\t\t\tline = \" logged in.\";\n\t\t\t\t} else if (purple_str_has_prefix(line,\n\t\t\t\t\t\"One or more messages may have been undeliverable.\")) {\n\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t\"<span style=\\\"color: #ff0000;\\\">\");\n\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t_(\"One or more messages may have been \"\n\t\t\t\t\t\t  \"undeliverable.\"));\n\t\t\t\t\tline = \"\";\n\t\t\t\t\tfooter = \"</span></b>\";\n\t\t\t\t} else if (purple_str_has_prefix(line,\n\t\t\t\t\t\t\"You have been disconnected.\")) {\n\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t\"<span style=\\\"color: #ff0000;\\\">\");\n\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t_(\"You were disconnected from the server.\"));\n\t\t\t\t\tline = \"\";\n\t\t\t\t\tfooter = \"</span></b>\";\n\t\t\t\t} else if (purple_str_has_prefix(line,\n\t\t\t\t\t\t\"You are currently disconnected.\")) {\n\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t\"<span style=\\\"color: #ff0000;\\\">\");\n\t\t\t\t\tline = _(\"You are currently disconnected. Messages \"\n\t\t\t\t\t         \"will not be received unless you are \"\n\t\t\t\t\t         \"logged in.\");\n\t\t\t\t\tfooter = \"</span></b>\";\n\t\t\t\t} else if (purple_str_has_prefix(line,\n\t\t\t\t\t\t\"Your previous message has not been sent.\")) {\n\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t\"<span style=\\\"color: #ff0000;\\\">\");\n\t\t\t\t\tif (purple_str_has_prefix(line,\n\t\t\t\t\t\t\"Your previous message has not been sent.  \"\n\t\t\t\t\t\t\"Reason: Maximum length exceeded.\")) {\n\t\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t\t_(\"Message could not be sent because \"\n\t\t\t\t\t\t\t  \"the maximum length was exceeded.\"));\n\t\t\t\t\t\tline = \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg_string_append(formatted,\n\t\t\t\t\t\t\t_(\"Message could not be sent.\"));\n\t\t\t\t\t\tline += (sizeof(\n\t\t\t\t\t\t\t\"Your previous message \"\n\t\t\t\t\t\t\t\"has not been sent. \") - 1);\n\t\t\t\t\t}\n\t\t\t\t\tfooter = \"</span></b>\";\n\t\t\t\t}\n\t\t\t} else if (purple_str_has_prefix(line, data->their_nickname)) {\n\t\t\t\tif (buddy != NULL) {\n\t\t\t\t\tconst char *alias = purple_buddy_get_alias(buddy);\n\t\t\t\t\tif (alias != NULL) {\n\t\t\t\t\t\tline += strlen(data->their_nickname) + 2;\n\t\t\t\t\t\tg_string_append_printf(formatted,\n\t\t\t\t\t\t\t\"<span style=\\\"color: #A82F2F;\\\">\"\n\t\t\t\t\t\t\t\"<b>%s</b></span>: \", alias);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *line2 = strchr(line, ':');\n\t\t\t\tif (line2) {\n\t\t\t\t\tconst char *acct_name;\n\t\t\t\t\tline2++;\n\t\t\t\t\tline = line2;\n\t\t\t\t\tacct_name = purple_account_get_alias(log->account);\n\t\t\t\t\tif (!acct_name)\n\t\t\t\t\t\tacct_name = purple_account_get_username(log->account);\n\t\t\t\t\tg_string_append_printf(formatted,\n\t\t\t\t\t\t\"<span style=\\\"color: #16569E;\\\">\"\n\t\t\t\t\t\t\"<b>%s</b></span>:\", acct_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (line)\n\t\t\tg_string_append(formatted, line);\n\t\tline = c;\n\t\tif (temp)\n\t\t\tg_string_free(temp, TRUE);\n\t\tif (footer)\n\t\t\tg_string_append(formatted, footer);\n\t\tg_string_append(formatted, \"<br>\");\n\t}\n\tg_free(read);\n\t\n\t\n\treturn g_strchomp(g_string_free(formatted, FALSE));\n}\n", "bug_type": null, "idx": 659}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nhandle_fprintf_stderr_cb(GIOChannel *source, GIOCondition cond, gpointer null)\n{\n\tgssize size;\n\tchar message[1024];\n\tsize = read(g_io_channel_unix_get_fd(source), message, sizeof(message) - 1);\n\tif (size <= 0) {\n\t\t\n\t} else {\n\t\tmessage[size] = '\\0';\n\t\tg_log(\"stderr\", G_LOG_LEVEL_WARNING, \"%s\", message);\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 660}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conversation_set_ui_ops(PurpleConversation *conv,\n\t\t\t\t\t\t\t PurpleConversationUiOps *ops)\n{\n\tg_return_if_fail(conv != NULL);\n\tif (conv->ui_ops == ops)\n\t\treturn;\n\tif (conv->ui_ops != NULL && conv->ui_ops->destroy_conversation != NULL)\n\t\tconv->ui_ops->destroy_conversation(conv);\n\tconv->ui_data = NULL;\n\tconv->ui_ops = ops;\n}\n", "bug_type": null, "idx": 661}
{"project": "Pidgin", "target": 0, "func": "PurpleValue *\npurple_status_attr_get_value(const PurpleStatusAttr *attr)\n{\n\tg_return_val_if_fail(attr != NULL, NULL);\n\treturn attr->value_type;\n}\n", "bug_type": null, "idx": 662}
{"project": "Pidgin", "target": 0, "func": "static void DNSSD_API\n_mdns_resolve_host_callback(DNSServiceRef sdRef, DNSServiceFlags flags,\n\tuint32_t interfaceIndex, DNSServiceErrorType errorCode,\n\tconst char *hostname, const struct sockaddr *address,\n\tuint32_t ttl, void *context)\n{\n\tResolveCallbackArgs *args = (ResolveCallbackArgs*) context;\n\tWin32BuddyImplData *idata = args->bb->mdns_impl_data;\n\tgboolean delete_buddy = FALSE;\n\tPurpleBuddy *pb = NULL;\n\tpurple_input_remove(args->resolver_query->input_handler);\n\tDNSServiceRefDeallocate(args->resolver_query->sdRef);\n\tg_free(args->resolver_query);\n\targs->resolver_query = NULL;\n\tif ((pb = purple_find_buddy(args->account, args->res_data->name))) {\n\t\tif (pb->proto_data != args->bb) {\n\t\t\tpurple_debug_error(\"bonjour\", \"Found purple buddy for %s not matching bonjour buddy record.\",\n\t\t\t\targs->res_data->name);\n\t\t\tgoto cleanup;\n\t\t}\n\t\n\t} else if (g_slist_find(pending_buddies, args->bb) == NULL) {\n\t\tpurple_debug_error(\"bonjour\", \"host resolution - complete, but buddy no longer pending.\\n\");\n\t\tgoto cleanup;\n\t}\n\tif (errorCode != kDNSServiceErr_NoError) {\n\t\tpurple_debug_error(\"bonjour\", \"host resolution - callback error (%d).\\n\", errorCode);\n\t\tdelete_buddy = TRUE;\n\t} else {\n\t\tDNSServiceRef txt_query_sr;\n\t\t\n\t\terrorCode = DNSServiceQueryRecord(&txt_query_sr, kDNSServiceFlagsLongLivedQuery,\n\t\t\t\tkDNSServiceInterfaceIndexAny, args->full_service_name, kDNSServiceType_TXT,\n\t\t\t\tkDNSServiceClass_IN, _mdns_record_query_callback, args->bb);\n\t\tif (errorCode == kDNSServiceErr_NoError) {\n\t\t\tconst char *ip = inet_ntoa(((struct sockaddr_in *) address)->sin_addr);\n\t\t\tpurple_debug_info(\"bonjour\", \"Found buddy %s at %s:%d\\n\", args->bb->name, ip, args->bb->port_p2pj);\n\t\t\targs->bb->ips = g_slist_prepend(args->bb->ips, g_strdup(ip));\n\t\t\targs->res_data->ip = args->bb->ips->data;\n\t\t\targs->res_data->txt_query = g_new(DnsSDServiceRefHandlerData, 1);\n\t\t\targs->res_data->txt_query->sdRef = txt_query_sr;\n\t\t\targs->res_data->txt_query->account = args->account;\n\t\t\targs->res_data->txt_query->input_handler = purple_input_add(DNSServiceRefSockFD(txt_query_sr),\n\t\t\t\tPURPLE_INPUT_READ, _mdns_handle_event, args->res_data->txt_query);\n\t\t\tbonjour_buddy_add_to_purple(args->bb, NULL);\n\t\t} else {\n\t\t\tpurple_debug_error(\"bonjour\", \"Unable to set up record watcher for buddy %s (%d)\\n\", args->bb->name, errorCode);\n\t\t\tdelete_buddy = TRUE;\n\t\t}\n\t}\n\tcleanup:\n\tif (delete_buddy) {\n\t\tidata->resolvers = g_slist_remove(idata->resolvers, args->res_data);\n\t\t_cleanup_resolver_data(args->res_data);\n\t\t\n\t\tif (idata->resolvers == NULL) {\n\t\t\tif (pb)\n\t\t\t\tbonjour_buddy_signed_off(pb);\n\t\t\telse\n\t\t\t\tbonjour_buddy_delete(args->bb);\n\t\t\t\n\t\t\tpending_buddies = g_slist_remove(pending_buddies, args->bb);\n\t\t}\n\t} else {\n\t\t\n\t\tpending_buddies = g_slist_remove(pending_buddies, args->bb);\n\t}\n\t\n\tg_free(args->full_service_name);\n\tg_free(args);\n}\n", "bug_type": null, "idx": 663}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conv_im_set_type_again(PurpleConvIm *im, unsigned int val)\n{\n\tg_return_if_fail(im != NULL);\n\tif (val == 0)\n\t\tim->type_again = 0;\n\telse\n\t\tim->type_again = time(NULL) + val;\n}\n", "bug_type": null, "idx": 664}
{"project": "Pidgin", "target": 0, "func": "PurpleCmdId tcl_cmd_register(struct tcl_cmd_handler *handler)\n{\n\tint id;\n\tGString *proc;\n\tif ((id = purple_cmd_register(Tcl_GetString(handler->cmd),\n\t\t\t\t    handler->args, handler->priority,\n\t\t\t\t    handler->flags, handler->prpl_id,\n\t\t\t\t    PURPLE_CMD_FUNC(tcl_cmd_callback),\n\t\t\t\t    handler->helpstr, (void *)handler)) == 0)\n\t\treturn 0;\n\thandler->namespace = new_cmd_cb_namespace ();\n\tTcl_IncrRefCount(handler->namespace);\n\tproc = g_string_new(\"\");\n\tg_string_append_printf(proc, \"namespace eval %s { proc cb { conv cmd arglist } { %s } }\",\n\t                       Tcl_GetString(handler->namespace),\n\t                       Tcl_GetString(handler->proc));\n\tif (Tcl_Eval(handler->interp, proc->str) != TCL_OK) {\n\t\tTcl_DecrRefCount(handler->namespace);\n\t\tg_string_free(proc, TRUE);\n\t\treturn 0;\n\t}\n\tg_string_free(proc, TRUE);\n\ttcl_cmd_callbacks = g_list_append(tcl_cmd_callbacks, (gpointer)handler);\n\treturn id;\n}\n", "bug_type": null, "idx": 665}
{"project": "Pidgin", "target": 0, "func": "static void\noscar_set_info_and_status(PurpleAccount *account, gboolean setinfo, const char *rawinfo,\n\t\t\t\t\t\t  gboolean setstatus, PurpleStatus *status)\n{\n\tPurpleConnection *gc = purple_account_get_connection(account);\n\tOscarData *od = purple_connection_get_protocol_data(gc);\n\tPurpleStatusType *status_type;\n\tPurpleStatusPrimitive primitive;\n\tchar *info_encoding = NULL;\n\tchar *info = NULL;\n\tgsize infolen = 0;\n\tchar *away_encoding = NULL;\n\tchar *away = NULL;\n\tgsize awaylen = 0;\n\tchar *status_text = NULL;\n\tconst char *itmsurl = NULL;\n\tstatus_type = purple_status_get_type(status);\n\tprimitive = purple_status_type_get_primitive(status_type);\n\tif (!setinfo)\n\t{\n\t\t\n\t}\n\telse if (od->rights.maxsiglen == 0)\n\t{\n\t\tpurple_notify_warning(gc, NULL, _(\"Unable to set AIM profile.\"),\n\t\t\t\t\t\t\t_(\"You have probably requested to set your \"\n\t\t\t\t\t\t\t  \"profile before the login procedure completed.  \"\n\t\t\t\t\t\t\t  \"Your profile remains unset; try setting it \"\n\t\t\t\t\t\t\t  \"again when you are fully connected.\"));\n\t}\n\telse if (rawinfo != NULL)\n\t{\n\t\tchar *htmlinfo = purple_strdup_withhtml(rawinfo);\n\t\tinfo = oscar_encode_im(htmlinfo, &infolen, NULL, &info_encoding);\n\t\tg_free(htmlinfo);\n\t\tif (infolen > od->rights.maxsiglen)\n\t\t{\n\t\t\tgchar *errstr;\n\t\t\terrstr = g_strdup_printf(dngettext(PACKAGE, \"The maximum profile length of %d byte \"\n\t\t\t\t\t\t\t\t\t \"has been exceeded.  It has been truncated for you.\",\n\t\t\t\t\t\t\t\t\t \"The maximum profile length of %d bytes \"\n\t\t\t\t\t\t\t\t\t \"has been exceeded.  It has been truncated for you.\",\n\t\t\t\t\t\t\t\t\t od->rights.maxsiglen), od->rights.maxsiglen);\n\t\t\tpurple_notify_warning(gc, NULL, _(\"Profile too long.\"), errstr);\n\t\t\tg_free(errstr);\n\t\t}\n\t}\n\tif (setstatus)\n\t{\n\t\tconst char *status_html;\n\t\tstatus_html = purple_status_get_attr_string(status, \"message\");\n\t\tif (status_html == NULL || primitive == PURPLE_STATUS_AVAILABLE || primitive == PURPLE_STATUS_INVISIBLE)\n\t\t{\n\t\t\t\n\t\t\taway = g_strdup(\"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgchar *linkified;\n\t\t\t\n\t\t\tlinkified = purple_markup_linkify(status_html);\n\t\t\taway = oscar_encode_im(linkified, &awaylen, NULL, &away_encoding);\n\t\t\tg_free(linkified);\n\t\t\tif (awaylen > od->rights.maxawaymsglen)\n\t\t\t{\n\t\t\t\tgchar *errstr;\n\t\t\t\terrstr = g_strdup_printf(dngettext(PACKAGE, \"The maximum away message length of %d byte \"\n\t\t\t\t\t\t\t\t\t\t \"has been exceeded.  It has been truncated for you.\",\n\t\t\t\t\t\t\t\t\t\t \"The maximum away message length of %d bytes \"\n\t\t\t\t\t\t\t\t\t\t \"has been exceeded.  It has been truncated for you.\",\n\t\t\t\t\t\t\t\t\t\t od->rights.maxawaymsglen), od->rights.maxawaymsglen);\n\t\t\t\tpurple_notify_warning(gc, NULL, _(\"Away message too long.\"), errstr);\n\t\t\t\tg_free(errstr);\n\t\t\t}\n\t\t}\n\t}\n\taim_locate_setprofile(od,\n\t\t\tinfo_encoding, info, MIN(infolen, od->rights.maxsiglen),\n\t\t\taway_encoding, away, MIN(awaylen, od->rights.maxawaymsglen));\n\tg_free(info);\n\tg_free(away);\n\tif (setstatus)\n\t{\n\t\tconst char *status_html;\n\t\tstatus_html = purple_status_get_attr_string(status, \"message\");\n\t\tif (status_html != NULL)\n\t\t{\n\t\t\tstatus_text = purple_markup_strip_html(status_html);\n\t\t\t\n\t\t\tif (strlen(status_text) > MAXAVAILMSGLEN)\n\t\t\t{\n\t\t\t\tchar *tmp = g_utf8_find_prev_char(status_text, &status_text[MAXAVAILMSGLEN - 2]);\n\t\t\t\tstrcpy(tmp, \"...\");\n\t\t\t}\n\t\t}\n\t\titmsurl = purple_status_get_attr_string(status, \"itmsurl\");\n\t\taim_srv_setextrainfo(od, TRUE, oscar_get_extended_status(gc), TRUE, status_text, itmsurl);\n\t\tg_free(status_text);\n\t}\n}\n", "bug_type": null, "idx": 666}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int aim_ssi_itemlist_del(struct aim_ssi_item **list, struct aim_ssi_item *del)\n{\n\tif (!(*list) || !del)\n\t\treturn -EINVAL;\n\t\n\tif (*list == del) {\n\t\t*list = (*list)->next;\n\t} else {\n\t\tstruct aim_ssi_item *cur;\n\t\tfor (cur=*list; (cur->next && (cur->next!=del)); cur=cur->next);\n\t\tif (cur->next)\n\t\t\tcur->next = del->next;\n\t}\n\t\n\tg_free(del->name);\n\taim_tlvlist_free(del->data);\n\tg_free(del);\n\treturn 0;\n}\n", "bug_type": null, "idx": 667}
{"project": "Pidgin", "target": 0, "func": "static void\nattach_signals(PurpleConversation *conv)\n{\n\tPidginConversation *gtkconv;\n\tgtkconv = PIDGIN_CONVERSATION(conv);\n\tgstroke_enable(gtkconv->imhtml);\n\tgstroke_signal_connect(gtkconv->imhtml, \"14789\",  stroke_close,    conv);\n\tgstroke_signal_connect(gtkconv->imhtml, \"1456\",   stroke_close,    conv);\n\tgstroke_signal_connect(gtkconv->imhtml, \"1489\",   stroke_close,    conv);\n\tgstroke_signal_connect(gtkconv->imhtml, \"74123\",  stroke_next_tab, conv);\n\tgstroke_signal_connect(gtkconv->imhtml, \"7456\",   stroke_next_tab, conv);\n\tgstroke_signal_connect(gtkconv->imhtml, \"96321\",  stroke_prev_tab, conv);\n\tgstroke_signal_connect(gtkconv->imhtml, \"9654\",   stroke_prev_tab, conv);\n\tgstroke_signal_connect(gtkconv->imhtml, \"25852\",  stroke_new_win,  conv);\n}\n", "bug_type": null, "idx": 668}
{"project": "Pidgin", "target": 0, "func": "const JabberData *\njabber_data_find_local_by_cid(const gchar *cid)\n{\n\tpurple_debug_info(\"jabber\", \"lookup local data object with cid = %s\\n\", cid);\n\treturn g_hash_table_lookup(local_data_by_cid, cid);\n}\n", "bug_type": null, "idx": 669}
{"project": "Pidgin", "target": 0, "func": "};\nPurpleRequestUiOps *finch_request_get_ui_ops()\n{\n\treturn &uiops;\n}\n", "bug_type": null, "idx": 670}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_xfer_dialog_add_xfer(PidginXferDialog *dialog, PurpleXfer *xfer)\n{\n\tPidginXferUiData *data;\n\tPurpleXferType type;\n\tGdkPixbuf *pixbuf;\n\tchar *size_str, *remaining_str;\n\tchar *lfilename, *utf8;\n\tg_return_if_fail(dialog != NULL);\n\tg_return_if_fail(xfer != NULL);\n\tpurple_xfer_ref(xfer);\n\tdata = PIDGINXFER(xfer);\n\tdata->in_list = TRUE;\n\tpidgin_xfer_dialog_show(dialog);\n\tdata->last_updated_time = 0;\n\ttype = purple_xfer_get_type(xfer);\n\tsize_str      = purple_str_size_to_units(purple_xfer_get_size(xfer));\n\tremaining_str = purple_str_size_to_units(purple_xfer_get_bytes_remaining(xfer));\n\tpixbuf = gtk_widget_render_icon(dialog->window,\n\t\t\t\t\t\t\t\t\t(type == PURPLE_XFER_RECEIVE\n\t\t\t\t\t\t\t\t\t ? PIDGIN_STOCK_DOWNLOAD\n\t\t\t\t\t\t\t\t\t : PIDGIN_STOCK_UPLOAD),\n\t\t\t\t\t\t\t\t\tGTK_ICON_SIZE_MENU, NULL);\n\tgtk_list_store_append(dialog->model, &data->iter);\n\tlfilename = g_path_get_basename(purple_xfer_get_local_filename(xfer));\n\tutf8 = g_filename_to_utf8(lfilename, -1, NULL, NULL, NULL);\n\tg_free(lfilename);\n\tlfilename = utf8;\n\tgtk_list_store_set(dialog->model, &data->iter,\n\t\t\t\t\t   COLUMN_STATUS, pixbuf,\n\t\t\t\t\t   COLUMN_PROGRESS, 0,\n\t\t\t\t\t   COLUMN_FILENAME, (type == PURPLE_XFER_RECEIVE)\n\t\t\t\t\t                     ? purple_xfer_get_filename(xfer)\n\t\t\t\t\t\t\t     : lfilename,\n\t\t\t\t\t   COLUMN_SIZE, size_str,\n\t\t\t\t\t   COLUMN_REMAINING, _(\"Waiting for transfer to begin\"),\n\t\t\t\t\t   COLUMN_DATA, xfer,\n\t\t\t\t\t   -1);\n\tg_free(lfilename);\n\tgtk_tree_view_columns_autosize(GTK_TREE_VIEW(dialog->tree));\n\tg_object_unref(pixbuf);\n\tg_free(size_str);\n\tg_free(remaining_str);\n\tdialog->num_transfers++;\n\tensure_row_selected(dialog);\n\tupdate_title_progress(dialog);\n}\n", "bug_type": null, "idx": 671}
{"project": "Pidgin", "target": 0, "func": "static void *\npidgin_request_input(const char *title, const char *primary,\n\t\t\t\t\t   const char *secondary, const char *default_value,\n\t\t\t\t\t   gboolean multiline, gboolean masked, gchar *hint,\n\t\t\t\t\t   const char *ok_text, GCallback ok_cb,\n\t\t\t\t\t   const char *cancel_text, GCallback cancel_cb,\n\t\t\t\t\t   PurpleAccount *account, const char *who, PurpleConversation *conv,\n\t\t\t\t\t   void *user_data)\n{\n\tPidginRequestData *data;\n\tGtkWidget *dialog;\n\tGtkWidget *vbox;\n\tGtkWidget *hbox;\n\tGtkWidget *label;\n\tGtkWidget *entry;\n\tGtkWidget *img;\n\tGtkWidget *toolbar;\n\tchar *label_text;\n\tchar *primary_esc, *secondary_esc;\n\tdata            = g_new0(PidginRequestData, 1);\n\tdata->type      = PURPLE_REQUEST_INPUT;\n\tdata->user_data = user_data;\n\tdata->cb_count = 2;\n\tdata->cbs = g_new0(GCallback, 2);\n\tdata->cbs[0] = ok_cb;\n\tdata->cbs[1] = cancel_cb;\n\t\n\tdialog = gtk_dialog_new_with_buttons(title ? title : PIDGIN_ALERT_TITLE,\n\t\t\t\t\t     NULL, 0,\n\t\t\t\t\t     text_to_stock(cancel_text), 1,\n\t\t\t\t\t     text_to_stock(ok_text),     0,\n\t\t\t\t\t     NULL);\n\tdata->dialog = dialog;\n\tg_signal_connect(G_OBJECT(dialog), \"response\",\n\t\t\t\t\t G_CALLBACK(input_response_cb), data);\n\t\n\tgtk_container_set_border_width(GTK_CONTAINER(dialog), PIDGIN_HIG_BORDER/2);\n\tgtk_container_set_border_width(GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), PIDGIN_HIG_BORDER/2);\n\tif (!multiline)\n\t\tgtk_window_set_resizable(GTK_WINDOW(dialog), FALSE);\n\tgtk_dialog_set_has_separator(GTK_DIALOG(dialog), FALSE);\n\tgtk_dialog_set_default_response(GTK_DIALOG(dialog), 0);\n\tgtk_box_set_spacing(GTK_BOX(GTK_DIALOG(dialog)->vbox), PIDGIN_HIG_BORDER);\n\t\n\thbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BORDER);\n\tgtk_container_add(GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), hbox);\n\t\n\timg = gtk_image_new_from_stock(PIDGIN_STOCK_DIALOG_QUESTION,\n\t\t\t\t\tgtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_HUGE));\n\tgtk_misc_set_alignment(GTK_MISC(img), 0, 0);\n\tgtk_box_pack_start(GTK_BOX(hbox), img, FALSE, FALSE, 0);\n\t\n\tvbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BORDER);\n\tgtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 0);\n\tpidgin_widget_decorate_account(hbox, account);\n\t\n\tprimary_esc = (primary != NULL) ? g_markup_escape_text(primary, -1) : NULL;\n\tsecondary_esc = (secondary != NULL) ? g_markup_escape_text(secondary, -1) : NULL;\n\tlabel_text = g_strdup_printf((primary ? \"<span weight=\\\"bold\\\" size=\\\"larger\\\">\"\n\t\t\t\t\t\t\t\t \"%s</span>%s%s\" : \"%s%s%s\"),\n\t\t\t\t\t\t\t\t (primary ? primary_esc : \"\"),\n\t\t\t\t\t\t\t\t ((primary && secondary) ? \"\\n\\n\" : \"\"),\n\t\t\t\t\t\t\t\t (secondary ? secondary_esc : \"\"));\n\tg_free(primary_esc);\n\tg_free(secondary_esc);\n\tlabel = gtk_label_new(NULL);\n\tgtk_label_set_markup(GTK_LABEL(label), label_text);\n\tgtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0);\n\tgtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\tg_free(label_text);\n\t\n\tdata->u.input.multiline = multiline;\n\tdata->u.input.hint = g_strdup(hint);\n\tgtk_widget_show_all(hbox);\n\tif ((data->u.input.hint != NULL) && (!strcmp(data->u.input.hint, \"html\"))) {\n\t\tGtkWidget *frame;\n\t\t\n\t\tframe = pidgin_create_imhtml(TRUE, &entry, &toolbar, NULL);\n\t\tgtk_widget_set_size_request(entry, 320, 130);\n\t\tgtk_widget_set_name(entry, \"pidgin_request_imhtml\");\n\t\tif (default_value != NULL)\n\t\t\tgtk_imhtml_append_text(GTK_IMHTML(entry), default_value, GTK_IMHTML_NO_SCROLL);\n\t\tgtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);\n\t\tgtk_widget_show(frame);\n\t\tgtk_imhtml_set_return_inserts_newline(GTK_IMHTML(entry));\n\t}\n\telse {\n\t\tif (multiline) {\n\t\t\t\n\t\t\tentry = gtk_text_view_new();\n\t\t\tgtk_text_view_set_editable(GTK_TEXT_VIEW(entry), TRUE);\n\t\t\tif (default_value != NULL) {\n\t\t\t\tGtkTextBuffer *buffer;\n\t\t\t\tbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(entry));\n\t\t\t\tgtk_text_buffer_set_text(buffer, default_value, -1);\n\t\t\t}\n\t\t\tgtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(entry), GTK_WRAP_WORD_CHAR);\n\t\t\tif (purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/conversations/spellcheck\"))\n\t\t\t\tpidgin_setup_gtkspell(GTK_TEXT_VIEW(entry));\n\t\t\tgtk_box_pack_start(GTK_BOX(vbox), \n\t\t\t\tpidgin_make_scrollable(entry, GTK_POLICY_NEVER, GTK_POLICY_ALWAYS, GTK_SHADOW_IN, 320, 130),\n\t\t\t\tTRUE, TRUE, 0);\n\t\t}\n\t\telse {\n\t\t\tentry = gtk_entry_new();\n\t\t\tgtk_entry_set_activates_default(GTK_ENTRY(entry), TRUE);\n\t\t\tgtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);\n\t\t\tif (default_value != NULL)\n\t\t\t\tgtk_entry_set_text(GTK_ENTRY(entry), default_value);\n\t\t\tif (masked)\n\t\t\t{\n\t\t\t\tgtk_entry_set_visibility(GTK_ENTRY(entry), FALSE);\n#if !GTK_CHECK_VERSION(2,16,0)\n\t\t\t\tif (gtk_entry_get_invisible_char(GTK_ENTRY(entry)) == '*')\n\t\t\t\t\tgtk_entry_set_invisible_char(GTK_ENTRY(entry), PIDGIN_INVISIBLE_CHAR);\n#endif \n\t\t\t}\n\t\t}\n\t\tgtk_widget_show_all(vbox);\n\t}\n\tpidgin_set_accessible_label (entry, label);\n\tdata->u.input.entry = entry;\n\tpidgin_auto_parent_window(dialog);\n\t\n\tgtk_widget_show(dialog);\n\treturn data;\n}\n", "bug_type": null, "idx": 672}
{"project": "Pidgin", "target": 0, "func": "static void\nroomlist_account_changed(GntWidget *widget, gpointer old, gpointer current, gpointer null)\n{\n\tif (froomlist.account == current) {\n\t\treturn;\n\t}\n\tfroomlist.account = current;\n\tif (froomlist.roomlist) {\n\t\tif (purple_roomlist_get_in_progress(froomlist.roomlist))\n\t\t\tpurple_roomlist_cancel_get_list(froomlist.roomlist);\n\t\tupdate_roomlist(NULL);\n\t}\n\tgnt_tree_remove_all(GNT_TREE(froomlist.tree));\n\tgnt_widget_draw(froomlist.tree);\n}\n", "bug_type": null, "idx": 673}
{"project": "Pidgin", "target": 0, "func": "void jabber_scram_data_destroy(JabberScramData *data)\n{\n\tg_free(data->cnonce);\n\tif (data->auth_message)\n\t\tg_string_free(data->auth_message, TRUE);\n\tif (data->client_proof)\n\t\tg_string_free(data->client_proof, TRUE);\n\tif (data->server_signature)\n\t\tg_string_free(data->server_signature, TRUE);\n\tif (data->password) {\n\t\tmemset(data->password, 0, strlen(data->password));\n\t\tg_free(data->password);\n\t}\n\tg_free(data);\n}\n", "bug_type": null, "idx": 674}
{"project": "Pidgin", "target": 0, "func": "static void\nload_statuses(void)\n{\n\txmlnode *statuses, *status;\n\tstatuses_loaded = TRUE;\n\tstatuses = purple_util_read_xml_from_file(\"status.xml\", _(\"saved statuses\"));\n\tif (statuses == NULL)\n\t\treturn;\n\tfor (status = xmlnode_get_child(statuses, \"status\"); status != NULL;\n\t\t\tstatus = xmlnode_get_next_twin(status))\n\t{\n\t\tPurpleSavedStatus *new;\n\t\tnew = parse_status(status);\n\t\tsaved_statuses = g_list_prepend(saved_statuses, new);\n\t}\n\tsaved_statuses = g_list_sort(saved_statuses, saved_statuses_sort_func);\n\txmlnode_free(statuses);\n}\n", "bug_type": null, "idx": 675}
{"project": "Pidgin", "target": 0, "func": "static void\nnovell_ssl_connected_cb(gpointer data, PurpleSslConnection * gsc,\n\t\t\t\t\t\tPurpleInputCondition cond)\n{\n\tPurpleConnection *gc = data;\n\tNMUser *user;\n\tNMConn *conn;\n\tNMERR_T rc = 0;\n\tconst char *pwd = NULL;\n\tconst char *my_addr = NULL;\n\tchar *ua = NULL;\n\tif (gc == NULL || gsc == NULL)\n\t\treturn;\n\tuser = gc->proto_data;\n\tif ((user == NULL) || (conn = user->conn) == NULL)\n\t\treturn;\n\tpurple_connection_update_progress(gc, _(\"Authenticating...\"),\n\t\t\t\t\t\t\t\t\t2, NOVELL_CONNECT_STEPS);\n\tmy_addr = purple_network_get_my_ip(gsc->fd);\n\tpwd = purple_connection_get_password(gc);\n\tua = _user_agent_string();\n\trc = nm_send_login(user, pwd, my_addr, ua, _login_resp_cb, NULL);\n\tif (rc == NM_OK) {\n\t\tconn->connected = TRUE;\n\t\tpurple_ssl_input_add(gsc, novell_ssl_recv_cb, gc);\n\t} else {\n\t\tpurple_connection_error_reason(gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t_(\"Unable to connect\"));\n\t}\n\tpurple_connection_update_progress(gc, _(\"Waiting for response...\"),\n\t\t\t\t\t\t\t\t\t3, NOVELL_CONNECT_STEPS);\n\tg_free(ua);\n}\n", "bug_type": null, "idx": 676}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nshow_suggest_dropdown(GntEntry *entry)\n{\n\tchar *suggest = NULL;\n\tgsize len;\n\tint offset = 0, x, y;\n\tint count = 0;\n\tGList *iter;\n\tconst char *text = NULL;\n\tconst char *sgst = NULL;\n\tint max = -1;\n\tif (entry->word)\n\t{\n\t\tchar *s = get_beginning_of_word(entry);\n\t\tsuggest = g_strndup(s, entry->cursor - s);\n\t\tif (entry->scroll < s)\n\t\t\toffset = gnt_util_onscreen_width(entry->scroll, s);\n\t}\n\telse\n\t\tsuggest = g_strdup(entry->start);\n\tlen = strlen(suggest);  \n\tif (entry->ddown == NULL)\n\t{\n\t\tGntWidget *box = gnt_vbox_new(FALSE);\n\t\tentry->ddown = gnt_tree_new();\n\t\tgnt_tree_set_compare_func(GNT_TREE(entry->ddown), (GCompareFunc)g_utf8_collate);\n\t\tgnt_box_add_widget(GNT_BOX(box), entry->ddown);\n\t\tGNT_WIDGET_SET_FLAGS(box, GNT_WIDGET_TRANSIENT);\n\t\tgnt_widget_get_position(GNT_WIDGET(entry), &x, &y);\n\t\tx += offset;\n\t\ty++;\n\t\tif (y + 10 >= getmaxy(stdscr))\n\t\t\ty -= 11;\n\t\tgnt_widget_set_position(box, x, y);\n\t}\n\telse\n\t\tgnt_tree_remove_all(GNT_TREE(entry->ddown));\n\tfor (count = 0, iter = entry->suggests; iter; iter = iter->next)\n\t{\n\t\ttext = iter->data;\n\t\tif (g_ascii_strncasecmp(suggest, text, len) == 0 && strlen(text) >= len)\n\t\t{\n\t\t\tgnt_tree_add_row_after(GNT_TREE(entry->ddown), (gpointer)text,\n\t\t\t\t\tgnt_tree_create_row(GNT_TREE(entry->ddown), text),\n\t\t\t\t\tNULL, NULL);\n\t\t\tcount++;\n\t\t\tif (max == -1)\n\t\t\t\tmax = strlen(text) - len;\n\t\t\telse if (max)\n\t\t\t\tmax = MIN(max, max_common_prefix(sgst + len, text + len));\n\t\t\tsgst = text;\n\t\t}\n\t}\n\tg_free(suggest);\n\tif (count == 0) {\n\t\tdestroy_suggest(entry);\n\t\treturn FALSE;\n\t} else if (count == 1) {\n\t\tchar *store = g_strndup(entry->start, entry->end - entry->start);\n\t\tgboolean ret;\n\t\tdestroy_suggest(entry);\n\t\tcomplete_suggest(entry, sgst);\n\t\tret = (strncmp(store, entry->start, entry->end - entry->start) != 0);\n\t\tg_free(store);\n\t\treturn ret;\n\t} else {\n\t\tif (max > 0) {\n\t\t\tGntWidget *ddown = entry->ddown;\n\t\t\tchar *match = g_strndup(sgst + len, max);\n\t\t\tentry->ddown = NULL;\n\t\t\tgnt_entry_key_pressed(GNT_WIDGET(entry), match);\n\t\t\tg_free(match);\n\t\t\tif (entry->ddown)\n\t\t\t\tgnt_widget_destroy(ddown);\n\t\t\telse\n\t\t\t\tentry->ddown = ddown;\n\t\t}\n\t\tgnt_widget_draw(entry->ddown->parent);\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 677}
{"project": "Pidgin", "target": 0, "func": "const char *purple_chat_get_name(PurpleChat *chat)\n{\n\tchar *ret = NULL;\n\tPurplePlugin *prpl;\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tg_return_val_if_fail(chat != NULL, NULL);\n\tif ((chat->alias != NULL) && (*chat->alias != '\\0'))\n\t\treturn chat->alias;\n\tprpl = purple_find_prpl(purple_account_get_protocol_id(chat->account));\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\tif (prpl_info->chat_info) {\n\t\tstruct proto_chat_entry *pce;\n\t\tGList *parts = prpl_info->chat_info(purple_account_get_connection(chat->account));\n\t\tpce = parts->data;\n\t\tret = g_hash_table_lookup(chat->components, pce->identifier);\n\t\tg_list_foreach(parts, (GFunc)g_free, NULL);\n\t\tg_list_free(parts);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 678}
{"project": "Pidgin", "target": 0, "func": "static void\nfree_session(PurpleMediaBackendFs2Session *session)\n{\n\tg_free(session->id);\n\tg_free(session);\n}\n", "bug_type": null, "idx": 679}
{"project": "Pidgin", "target": 0, "func": "static void\ncall_appsink_readable_locked (PurpleMediaAppDataInfo *info)\n{\n\tPurpleMediaManager *manager = purple_media_manager_get ();\n\t\n\tg_cond_broadcast (&info->readable_cond);\n\t\n\tif (info->readable_cb_token || info->callbacks.readable == NULL)\n\t\treturn;\n\tinfo->readable_cb_token = ++manager->priv->appdata_cb_token;\n\tinfo->readable_timer_id = purple_timeout_add (0, appsink_readable, info);\n}\n", "bug_type": null, "idx": 680}
{"project": "Pidgin", "target": 0, "func": "static void\nfree_tag(gpointer data, gpointer null)\n{\n\tGntTextTag *tag = data;\n\tg_free(tag->name);\n\tg_free(tag);\n}\n", "bug_type": null, "idx": 681}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_media_codec_get_property (GObject *object, guint prop_id,\n\t\tGValue *value, GParamSpec *pspec)\n{\n\tPurpleMediaCodecPrivate *priv;\n\tg_return_if_fail(PURPLE_IS_MEDIA_CODEC(object));\n\tpriv = PURPLE_MEDIA_CODEC_GET_PRIVATE(object);\n\tswitch (prop_id) {\n\t\tcase PROP_ID:\n\t\t\tg_value_set_uint(value, priv->id);\n\t\t\tbreak;\n\t\tcase PROP_ENCODING_NAME:\n\t\t\tg_value_set_string(value, priv->encoding_name);\n\t\t\tbreak;\n\t\tcase PROP_MEDIA_TYPE:\n\t\t\tg_value_set_flags(value, priv->media_type);\n\t\t\tbreak;\n\t\tcase PROP_CLOCK_RATE:\n\t\t\tg_value_set_uint(value, priv->clock_rate);\n\t\t\tbreak;\n\t\tcase PROP_CHANNELS:\n\t\t\tg_value_set_uint(value, priv->channels);\n\t\t\tbreak;\n\t\tcase PROP_OPTIONAL_PARAMS:\n\t\t\tg_value_set_pointer(value, priv->optional_params);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID(\n\t\t\t\t\tobject, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 682}
{"project": "Pidgin", "target": 0, "func": "void serv_rem_deny(PurpleConnection *gc, const char *name)\n{\n\tPurplePlugin *prpl;\n\tPurplePluginProtocolInfo *prpl_info;\n\tif (gc) {\n\t\tprpl = purple_connection_get_prpl(gc);\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\t\tif (prpl_info->rem_deny)\n\t\t\tprpl_info->rem_deny(gc, name);\n\t}\n}\n", "bug_type": null, "idx": 683}
{"project": "Pidgin", "target": 0, "func": "void\npurple_buddy_icons_init()\n{\n\taccount_cache = g_hash_table_new_full(\n\t\tg_direct_hash, g_direct_equal,\n\t\tNULL, (GFreeFunc)g_hash_table_destroy);\n\ticon_data_cache = g_hash_table_new_full(g_str_hash, g_str_equal,\n\t                                        g_free, NULL);\n\ticon_file_cache = g_hash_table_new_full(g_str_hash, g_str_equal,\n\t                                        g_free, NULL);\n\tpointer_icon_cache = g_hash_table_new(g_direct_hash, g_direct_equal);\n\tif (!cache_dir)\n\t\tcache_dir = g_build_filename(purple_user_dir(), \"icons\", NULL);\n\tpurple_signal_connect(purple_imgstore_get_handle(), \"image-deleting\",\n\t                      purple_buddy_icons_get_handle(),\n\t                      G_CALLBACK(image_deleting_cb), NULL);\n}\n", "bug_type": null, "idx": 684}
{"project": "Pidgin", "target": 0, "func": "static int\nget_root_distance(GntTreeRow *row)\n{\n\tif (row == NULL)\n\t\treturn -1;\n\treturn get_root_distance(get_prev(row)) + 1;\n}\n", "bug_type": null, "idx": 685}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_account_get_ui_string(const PurpleAccount *account, const char *ui,\n\t\t\t\t\t\t   const char *name, const char *default_value)\n{\n\tPurpleAccountSetting *setting;\n\tGHashTable *table;\n\tg_return_val_if_fail(account != NULL, default_value);\n\tg_return_val_if_fail(ui      != NULL, default_value);\n\tg_return_val_if_fail(name    != NULL, default_value);\n\tif ((table = g_hash_table_lookup(account->ui_settings, ui)) == NULL)\n\t\treturn default_value;\n\tif ((setting = g_hash_table_lookup(table, name)) == NULL)\n\t\treturn default_value;\n\tg_return_val_if_fail(setting->type == PURPLE_PREF_STRING, default_value);\n\treturn setting->value.string;\n}\n", "bug_type": null, "idx": 686}
{"project": "Pidgin", "target": 0, "func": "void gtk_ticker_start_scroll(GtkTicker *ticker)\n{\n\tg_return_if_fail (ticker != NULL);\n\tg_return_if_fail (GTK_IS_TICKER (ticker));\n\tif ( ticker->timer != 0 )\n\t\treturn;\n\tticker->timer = g_timeout_add(ticker->interval, ticker_timeout, ticker);\n}\n", "bug_type": null, "idx": 687}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nrealize_cb_cb(PidginMediaRealizeData *data)\n{\n\tPidginMediaPrivate *priv = data->gtkmedia->priv;\n\tGdkWindow *window = NULL;\n\tif (data->participant == NULL)\n#if GTK_CHECK_VERSION(2, 14, 0)\n\t\twindow = gtk_widget_get_window(priv->local_video);\n#else\n\t\twindow = (priv->local_video)->window;\n#endif\n\telse {\n\t\tGtkWidget *widget = pidgin_media_get_widget(data->gtkmedia,\n\t\t\t\tdata->session_id, data->participant);\n\t\tif (widget)\n#if GTK_CHECK_VERSION(2, 14, 0)\n\t\t\twindow = gtk_widget_get_window(widget);\n#else\n\t\t\twindow = widget->window;\n#endif\n\t}\n\tif (window) {\n\t\tgulong window_id;\n#ifdef _WIN32\n\t\twindow_id = GDK_WINDOW_HWND(window);\n#elif defined(HAVE_X11)\n\t\twindow_id = GDK_WINDOW_XWINDOW(window);\n#else\n#\t\terror \"Unsupported windowing system\"\n#endif\n\t\tpurple_media_set_output_window(priv->media, data->session_id,\n\t\t\t\tdata->participant, window_id);\n\t}\n\tg_free(data->session_id);\n\tg_free(data->participant);\n\tg_free(data);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 688}
{"project": "Pidgin", "target": 0, "func": "void\npurple_prefs_uninit()\n{\n\tif (save_timer != 0)\n\t{\n\t\tpurple_timeout_remove(save_timer);\n\t\tsave_cb(NULL);\n\t}\n\tpurple_prefs_disconnect_by_handle(purple_prefs_get_handle());\n\tprefs_loaded = FALSE;\n\tpurple_prefs_destroy();\n\tg_hash_table_destroy(prefs_hash);\n\tprefs_hash = NULL;\n}\n", "bug_type": null, "idx": 689}
{"project": "Pidgin", "target": 0, "func": "void\npurple_connection_error(PurpleConnection *gc, const char *text)\n{\n\t\n\tPurpleConnectionError reason = gc->wants_to_die\n\t                             ? PURPLE_CONNECTION_ERROR_OTHER_ERROR\n\t                             : PURPLE_CONNECTION_ERROR_NETWORK_ERROR;\n\tpurple_connection_error_reason (gc, reason, text);\n}\n", "bug_type": null, "idx": 690}
{"project": "Pidgin", "target": 0, "func": "int gg_pubdir50_handle_reply(struct gg_event *e, const char *packet, int length)\n{\n\treturn -1;\n}\n", "bug_type": null, "idx": 691}
{"project": "Pidgin", "target": 0, "func": "void finch_connections_init()\n{\n\thash = g_hash_table_new_full(\n\t\t\t\t\t\t\tg_direct_hash, g_direct_equal,\n\t\t\t\t\t\t\tNULL, free_auto_recon);\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-removed\",\n\t\t\t\t\t\tfinch_connection_get_handle(),\n\t\t\t\t\t\tPURPLE_CALLBACK(account_removed_cb), NULL);\n}\n", "bug_type": null, "idx": 692}
{"project": "Pidgin", "target": 0, "func": "xmlnode *\nxmlnode_from_str(const char *str, gssize size)\n{\n\tstruct _xmlnode_parser_data *xpd;\n\txmlnode *ret;\n\tgsize real_size;\n\tg_return_val_if_fail(str != NULL, NULL);\n\treal_size = size < 0 ? strlen(str) : (gsize)size;\n\txpd = g_new0(struct _xmlnode_parser_data, 1);\n\tif (xmlSAXUserParseMemory(&xmlnode_parser_libxml, xpd, str, real_size) < 0) {\n\t\twhile(xpd->current && xpd->current->parent)\n\t\t\txpd->current = xpd->current->parent;\n\t\tif(xpd->current)\n\t\t\txmlnode_free(xpd->current);\n\t\txpd->current = NULL;\n\t}\n\tret = xpd->current;\n\tif (xpd->error) {\n\t\tret = NULL;\n\t\tif (xpd->current)\n\t\t\txmlnode_free(xpd->current);\n\t}\n\tg_free(xpd);\n\treturn ret;\n}\n", "bug_type": null, "idx": 693}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_tree_class_init(GntTreeClass *klass)\n{\n\tGntBindableClass *bindable = GNT_BINDABLE_CLASS(klass);\n\tGObjectClass *gclass = G_OBJECT_CLASS(klass);\n\tparent_class = GNT_WIDGET_CLASS(klass);\n\tparent_class->destroy = gnt_tree_destroy;\n\tparent_class->draw = gnt_tree_draw;\n\tparent_class->map = gnt_tree_map;\n\tparent_class->size_request = gnt_tree_size_request;\n\tparent_class->key_pressed = gnt_tree_key_pressed;\n\tparent_class->clicked = gnt_tree_clicked;\n\tparent_class->size_changed = gnt_tree_size_changed;\n\tgclass->set_property = gnt_tree_set_property;\n\tgclass->get_property = gnt_tree_get_property;\n\tg_object_class_install_property(gclass,\n\t\t\tPROP_COLUMNS,\n\t\t\tg_param_spec_int(\"columns\", \"Columns\",\n\t\t\t\t\"Number of columns in the tree.\",\n\t\t\t\t1, G_MAXINT, 1,\n\t\t\t\tG_PARAM_READWRITE|G_PARAM_STATIC_NAME|G_PARAM_STATIC_NICK|G_PARAM_STATIC_BLURB\n\t\t\t)\n\t\t);\n\tg_object_class_install_property(gclass,\n\t\t\tPROP_EXPANDER,\n\t\t\tg_param_spec_int(\"expander-level\", \"Expander level\",\n\t\t\t\t\"Number of levels to show expander in the tree.\",\n\t\t\t\t0, G_MAXINT, 1,\n\t\t\t\tG_PARAM_READWRITE|G_PARAM_STATIC_NAME|G_PARAM_STATIC_NICK|G_PARAM_STATIC_BLURB\n\t\t\t)\n\t\t);\n\tsignals[SIG_SELECTION_CHANGED] =\n\t\tg_signal_new(\"selection-changed\",\n\t\t\t\t\t G_TYPE_FROM_CLASS(klass),\n\t\t\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t\t\t G_STRUCT_OFFSET(GntTreeClass, selection_changed),\n\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t gnt_closure_marshal_VOID__POINTER_POINTER,\n\t\t\t\t\t G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_POINTER);\n\tsignals[SIG_SCROLLED] =\n\t\tg_signal_new(\"scrolled\",\n\t\t\t\t\t G_TYPE_FROM_CLASS(klass),\n\t\t\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t\t\t 0,\n\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t g_cclosure_marshal_VOID__INT,\n\t\t\t\t\t G_TYPE_NONE, 1, G_TYPE_INT);\n\tsignals[SIG_TOGGLED] =\n\t\tg_signal_new(\"toggled\",\n\t\t\t\t\t G_TYPE_FROM_CLASS(klass),\n\t\t\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t\t\t G_STRUCT_OFFSET(GntTreeClass, toggled),\n\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t g_cclosure_marshal_VOID__POINTER,\n\t\t\t\t\t G_TYPE_NONE, 1, G_TYPE_POINTER);\n\tsignals[SIG_COLLAPSED] =\n\t\tg_signal_new(\"collapse-toggled\",\n\t\t\t\t\t G_TYPE_FROM_CLASS(klass),\n\t\t\t\t\t G_SIGNAL_RUN_LAST,\n\t\t\t\t\t 0,\n\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t gnt_closure_marshal_VOID__POINTER_BOOLEAN,\n\t\t\t\t\t G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_BOOLEAN);\n\tgnt_bindable_class_register_action(bindable, \"move-up\", action_up,\n\t\t\t\tGNT_KEY_UP, NULL);\n\tgnt_bindable_register_binding(bindable, \"move-up\", GNT_KEY_CTRL_P, NULL);\n\tgnt_bindable_class_register_action(bindable, \"move-down\", action_down,\n\t\t\t\tGNT_KEY_DOWN, NULL);\n\tgnt_bindable_register_binding(bindable, \"move-down\", GNT_KEY_CTRL_N, NULL);\n\tgnt_bindable_class_register_action(bindable, \"move-parent\", action_move_parent,\n\t\t\t\tGNT_KEY_BACKSPACE, NULL);\n\tgnt_bindable_class_register_action(bindable, \"page-up\", action_page_up,\n\t\t\t\tGNT_KEY_PGUP, NULL);\n\tgnt_bindable_class_register_action(bindable, \"page-down\", action_page_down,\n\t\t\t\tGNT_KEY_PGDOWN, NULL);\n\tgnt_bindable_class_register_action(bindable, \"start-search\", start_search,\n\t\t\t\t\"/\", NULL);\n\tgnt_bindable_class_register_action(bindable, \"end-search\", end_search_action,\n\t\t\t\t\"\\033\", NULL);\n\tgnt_bindable_class_register_action(bindable, \"move-first\", move_first_action,\n\t\t\tGNT_KEY_HOME, NULL);\n\tgnt_bindable_class_register_action(bindable, \"move-last\", move_last_action,\n\t\t\tGNT_KEY_END, NULL);\n\tgnt_style_read_actions(G_OBJECT_CLASS_TYPE(klass), bindable);\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 694}
{"project": "Pidgin", "target": 0, "func": "void\ngnt_widget_destroy(GntWidget *obj)\n{\n\tg_return_if_fail(GNT_IS_WIDGET(obj));\n\tif(!(GNT_WIDGET_FLAGS(obj) & GNT_WIDGET_DESTROYING)) {\n\t\tGNT_WIDGET_SET_FLAGS(obj, GNT_WIDGET_DESTROYING);\n\t\tgnt_widget_hide(obj);\n\t\tdelwin(obj->window);\n\t\tg_object_run_dispose(G_OBJECT(obj));\n\t}\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 695}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ndel_prev_word(GntBindable *bind, GList *null)\n{\n\tGntWidget *widget = GNT_WIDGET(bind);\n\tGntEntry *entry = GNT_ENTRY(bind);\n\tchar *iter = g_utf8_find_prev_char(entry->start, entry->cursor);\n\tint count;\n\tif (iter < entry->start)\n\t\treturn TRUE;\n\titer = (char*)begin_word(iter, entry->start);\n\tcount = entry->cursor - iter;\n\tupdate_kill_ring(entry, ENTRY_DEL_BWD_WORD, iter, count);\n\tmemmove(iter, entry->cursor, entry->end - entry->cursor);\n\tentry->end -= count;\n\tentry->cursor = iter;\n\tif (entry->cursor <= entry->scroll) {\n\t\tentry->scroll = entry->cursor - widget->priv.width + 2;\n\t\tif (entry->scroll < entry->start)\n\t\t\tentry->scroll = entry->start;\n\t}\n\tmemset(entry->end, '\\0', entry->buffer - (entry->end - entry->start));\n\tentry_redraw(widget);\n\tentry_text_changed(entry);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 696}
{"project": "Pidgin", "target": 0, "func": "GType\npidgin_blist_theme_loader_get_type(void)\n{\n\tstatic GType type = 0;\n\tif (type == 0) {\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(PidginBlistThemeLoaderClass),\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\t(GClassInitFunc)pidgin_blist_theme_loader_class_init, \n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tsizeof(PidginBlistThemeLoader),\n\t\t\t0, \n\t\t\tNULL, \n\t\t\tNULL, \n\t\t};\n\t\ttype = g_type_register_static(PURPLE_TYPE_THEME_LOADER,\n\t\t\t\t\"PidginBlistThemeLoader\", &info, 0);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 697}
{"project": "Pidgin", "target": 0, "func": "static int gg_win32_map_wsa_error_to_errno(int wsaewouldblock_map)\n{\n\tint wsa_error;\n\twsa_error = WSAGetLastError();\n\t\n\tswitch (wsa_error)\n\t{\n\t\n\tcase WSAEINTR:\n\t\treturn EINTR;\n\tcase WSAEWOULDBLOCK:\n\t\treturn wsaewouldblock_map;\n\t\n\tcase WSAECONNRESET:\n\t\treturn ECONNRESET;\n\tcase WSAEFAULT:\n\t\treturn EFAULT;\n\tcase WSAEINVAL:\n\t\treturn EINVAL;\n\tcase WSAENOTCONN:\n\t\treturn ENOTCONN;\n\tcase WSAETIMEDOUT:\n\t\treturn ETIMEDOUT;\n\tdefault:\n\t\t\n\t\treturn wsa_error;\n\t}\n}\n", "bug_type": null, "idx": 698}
{"project": "Pidgin", "target": 0, "func": "static void\nssl_connection_error_cb(PurpleSslConnection *gsc, PurpleSslErrorType error,\n\t\tgpointer data)\n{\n\tFlapConnection *conn;\n\tconn = data;\n\tif (conn->watcher_outgoing)\n\t{\n\t\tpurple_input_remove(conn->watcher_outgoing);\n\t\tconn->watcher_outgoing = 0;\n\t}\n\t\n\tconn->gsc = NULL;\n\tconnection_common_error_cb(conn, purple_ssl_strerror(error));\n}\n", "bug_type": null, "idx": 699}
{"project": "Pidgin", "target": 0, "func": "GType\npidgin_icon_theme_loader_get_type (void)\n{\n\tstatic GType type = 0;\n\tif (type == 0) {\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(PidginIconThemeLoaderClass),\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\t(GClassInitFunc)pidgin_icon_theme_loader_class_init, \n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tsizeof (PidginIconThemeLoader),\n\t\t\t0, \n\t\t\tNULL, \n\t\t\tNULL, \n\t\t};\n\t\ttype = g_type_register_static (PURPLE_TYPE_THEME_LOADER,\n\t\t\t\t\"PidginIconThemeLoader\", &info, 0);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 700}
{"project": "Pidgin", "target": 0, "func": "gboolean\nnm_conference_is_instantiated(NMConference * conference)\n{\n\tif (conference == NULL)\n\t\treturn FALSE;\n\treturn (strncmp(conference->guid, BLANK_GUID, CONF_GUID_END) != 0);\n}\n", "bug_type": null, "idx": 701}
{"project": "Pidgin", "target": 0, "func": "static void\ntls_peers_mgmt_mod_cb(PurpleCertificatePool *pool, const gchar *id, gpointer data)\n{\n\tg_assert (pool == tpm_dat->tls_peers);\n\ttls_peers_mgmt_repopulate_list();\n}\n", "bug_type": null, "idx": 702}
{"project": "Pidgin", "target": 0, "func": "static void hbn_cb(GSList *hosts, gpointer data, const char *error_message) {\n\tif(!hosts || !hosts->data) {\n\t\tnattype.status = PURPLE_STUN_STATUS_UNDISCOVERED;\n\t\tnattype.lookup_time = time(NULL);\n\t\tdo_callbacks();\n\t\treturn;\n\t}\n\tif (!purple_network_listen_range(12108, 12208, SOCK_DGRAM, hbn_listen_cb, hosts)) {\n\t\twhile (hosts) {\n\t\t\thosts = g_slist_delete_link(hosts, hosts);\n\t\t\tg_free(hosts->data);\n\t\t\thosts = g_slist_delete_link(hosts, hosts);\n\t\t}\n\t\tnattype.status = PURPLE_STUN_STATUS_UNKNOWN;\n\t\tnattype.lookup_time = time(NULL);\n\t\tdo_callbacks();\n\t\treturn;\n\t}\n}\n}\nstatic void hbn_cb(GSList *hosts, gpointer data, const char *error_message) {\n\tif(!hosts || !hosts->data) {\n\t\tnattype.status = PURPLE_STUN_STATUS_UNDISCOVERED;\n\t\tnattype.lookup_time = time(NULL);\n\t\tdo_callbacks();\n\t\treturn;\n\t}\n\tif (!purple_network_listen_range(12108, 12208, SOCK_DGRAM, hbn_listen_cb, hosts)) {\n\t\twhile (hosts) {\n\t\t\thosts = g_slist_delete_link(hosts, hosts);\n\t\t\tg_free(hosts->data);\n\t\t\thosts = g_slist_delete_link(hosts, hosts);\n\t\t}\n\t\tnattype.status = PURPLE_STUN_STATUS_UNKNOWN;\n\t\tnattype.lookup_time = time(NULL);\n\t\tdo_callbacks();\n\t\treturn;\n\t}\n}\n", "bug_type": null, "idx": 703}
{"project": "Pidgin", "target": 0, "func": "static void\nadd_buddy_icon_menu_items(GtkWidget *menu, PurpleBlistNode *node)\n{\n\tGtkWidget *item;\n\tpidgin_new_item_from_stock(menu, _(\"Set Custom Icon\"), NULL,\n\t                           G_CALLBACK(set_node_custom_icon), node, 0,\n\t                           0, NULL);\n\titem = pidgin_new_item_from_stock(menu, _(\"Remove Custom Icon\"), NULL,\n\t                           G_CALLBACK(remove_node_custom_icon), node,\n\t                           0, 0, NULL);\n\tif (!purple_buddy_icons_node_has_custom_icon(node))\n\t\tgtk_widget_set_sensitive(item, FALSE);\n}\n", "bug_type": null, "idx": 704}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_add_group(PurpleBlistNode *selected, PurpleGroup *grp)\n{\n\tpurple_blist_request_add_group();\n}\n", "bug_type": null, "idx": 705}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conversation_set_account(PurpleConversation *conv, PurpleAccount *account)\n{\n\tg_return_if_fail(conv != NULL);\n\tif (account == purple_conversation_get_account(conv))\n\t\treturn;\n\tconv->account = account;\n\tpurple_conversation_update(conv, PURPLE_CONV_UPDATE_ACCOUNT);\n}\n", "bug_type": null, "idx": 706}
{"project": "Pidgin", "target": 0, "func": "int irc_cmd_ping(struct irc_conn *irc, const char *cmd, const char *target, const char **args)\n{\n\tchar *stamp;\n\tchar *buf;\n\tif (args && args[0]) {\n\t\tif (irc_ischannel(args[0]))\n\t\t\treturn 0;\n\t\tstamp = g_strdup_printf(\"\\001PING %lu\\001\", time(NULL));\n\t\tbuf = irc_format(irc, \"vn:\", \"PRIVMSG\", args[0], stamp);\n\t\tg_free(stamp);\n\t} else if (target) {\n\t\tstamp = g_strdup_printf(\"%s %lu\", target, time(NULL));\n\t\tbuf = irc_format(irc, \"v:\", \"PING\", stamp);\n\t\tg_free(stamp);\n\t} else {\n\t\tstamp = g_strdup_printf(\"%lu\", time(NULL));\n\t\tbuf = irc_format(irc, \"vv\", \"PING\", stamp);\n\t\tg_free(stamp);\n\t}\n\tirc_send(irc, buf);\n\tg_free(buf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 707}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_option_destroy(PurpleAccountOption *option)\n{\n\tg_return_if_fail(option != NULL);\n\tg_free(option->text);\n\tg_free(option->pref_name);\n\tif (option->type == PURPLE_PREF_STRING)\n\t{\n\t\tg_free(option->default_value.string);\n\t}\n\telse if (option->type == PURPLE_PREF_STRING_LIST)\n\t{\n\t\tif (option->default_value.list != NULL)\n\t\t{\n\t\t\tg_list_foreach(option->default_value.list, purple_account_option_list_free, NULL);\n\t\t\tg_list_free(option->default_value.list);\n\t\t}\n\t}\n\tg_free(option);\n}\n", "bug_type": null, "idx": 708}
{"project": "Pidgin", "target": 0, "func": "static void\nsave_savedstatus_cb(GntWidget *button, EditStatus *edit)\n{\n\tconst char *title, *message;\n\tPurpleStatusPrimitive prim;\n\tPurpleSavedStatus *find;\n\ttitle = gnt_entry_get_text(GNT_ENTRY(edit->title));\n\tmessage = gnt_entry_get_text(GNT_ENTRY(edit->message));\n\tif (!message || !*message)\n\t\tmessage = NULL;\n\tprim = GPOINTER_TO_INT(gnt_combo_box_get_selected_data(GNT_COMBO_BOX(edit->type)));\n\tif (!title || !*title)\n\t{\n\t\tpurple_notify_error(edit, _(\"Error\"), _(\"Invalid title\"),\n\t\t\t\t_(\"Please enter a non-empty title for the status.\"));\n\t\tgnt_box_give_focus_to_child(GNT_BOX(edit->window), edit->title);\n\t\treturn;\n\t}\n\tfind = purple_savedstatus_find(title);\n\tif (find && find != edit->saved)\n\t{\n\t\tpurple_notify_error(edit, _(\"Error\"), _(\"Duplicate title\"),\n\t\t\t\t_(\"Please enter a different title for the status.\"));\n\t\tgnt_box_give_focus_to_child(GNT_BOX(edit->window), edit->title);\n\t\treturn;\n\t}\n\tif (edit->saved == NULL)\n\t{\n\t\tedit->saved = purple_savedstatus_new(title, prim);\n\t\tpurple_savedstatus_set_message(edit->saved, message);\n\t\tset_substatuses(edit);\n\t\tif (statuses.tree)\n\t\t\tgnt_tree_add_row_last(GNT_TREE(statuses.tree), edit->saved,\n\t\t\t\t\tgnt_tree_create_row(GNT_TREE(statuses.tree), title,\n\t\t\t\t\t\tpurple_primitive_get_name_from_type(prim), message), NULL);\n\t}\n\telse\n\t{\n\t\tpurple_savedstatus_set_title(edit->saved, title);\n\t\tpurple_savedstatus_set_type(edit->saved, prim);\n\t\tpurple_savedstatus_set_message(edit->saved, message);\n\t\tif (statuses.tree)\n\t\t{\n\t\t\tgnt_tree_change_text(GNT_TREE(statuses.tree), edit->saved, 0, title);\n\t\t\tgnt_tree_change_text(GNT_TREE(statuses.tree), edit->saved, 1,\n\t\t\t\t\t\tpurple_primitive_get_name_from_type(prim));\n\t\t\tgnt_tree_change_text(GNT_TREE(statuses.tree), edit->saved, 2, message);\n\t\t}\n\t}\n\tif (g_object_get_data(G_OBJECT(button), \"use\"))\n\t\tpurple_savedstatus_activate(edit->saved);\n\tgnt_widget_destroy(edit->window);\n}\n", "bug_type": null, "idx": 709}
{"project": "Pidgin", "target": 0, "func": "static int\nrtf_dispatch_control(NMRtfContext *ctx, char *keyword, int param, gboolean param_set)\n{\n    int idx;\n    for (idx = 0; idx < table_size; idx++) {\n        if (strcmp(keyword, rtf_symbols[idx].keyword) == 0)\n            break;\n\t}\n    if (idx == table_size)  {\n        if (ctx->skip_unknown)\n            ctx->rds = NMRTF_STATE_SKIP;\n        ctx->skip_unknown = FALSE;\n        return NMRTF_OK;\n    }\n    \n    ctx->skip_unknown = FALSE;\n    switch (rtf_symbols[idx].kwd_type) {\n\t\tcase NMRTF_KWD_PROP:\n\t\t\tif (rtf_symbols[idx].pass_default || !param_set)\n\t\t\t\tparam = rtf_symbols[idx].default_val;\n\t\t\treturn rtf_apply_property(ctx, rtf_symbols[idx].action, param);\n\t\tcase NMRTF_KWD_CHAR:\n\t\t\treturn rtf_dispatch_char(ctx, rtf_symbols[idx].action);\n\t\tcase NMRTF_KWD_DEST:\n\t\t\treturn rtf_change_destination(ctx, rtf_symbols[idx].action);\n\t\tcase NMRTF_KWD_SPEC:\n\t\t\treturn rtf_dispatch_special(ctx, rtf_symbols[idx].action);\n\t\tdefault:\n\t\t\treturn NMRTF_BAD_TABLE;\n    }\n    return NMRTF_BAD_TABLE;\n}\n", "bug_type": null, "idx": 710}
{"project": "Pidgin", "target": 0, "func": "static void\nhandle_next_queued_request(void)\n{\n\tPurpleDnsQueryData *query_data;\n\tPurpleDnsQueryResolverProcess *resolver;\n\tif (queued_requests == NULL)\n\t\t\n\t\treturn;\n\tquery_data = queued_requests->data;\n\tqueued_requests = g_slist_delete_link(queued_requests, queued_requests);\n\t\n\twhile (free_dns_children != NULL)\n\t{\n\t\tresolver = free_dns_children->data;\n\t\tfree_dns_children = g_slist_remove(free_dns_children, resolver);\n\t\tif (send_dns_request_to_child(query_data, resolver))\n\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\tif (query_data->resolver == NULL)\n\t{\n\t\tif (number_of_dns_children >= MAX_DNS_CHILDREN)\n\t\t{\n\t\t\t\n\t\t\tqueued_requests = g_slist_prepend(queued_requests, query_data);\n\t\t\treturn;\n\t\t}\n\t\tresolver = purple_dnsquery_resolver_new(purple_debug_is_enabled());\n\t\tif (resolver == NULL)\n\t\t{\n\t\t\tpurple_dnsquery_failed(query_data, _(\"Unable to create new resolver process\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tif (!send_dns_request_to_child(query_data, resolver))\n\t\t{\n\t\t\tpurple_dnsquery_failed(query_data, _(\"Unable to send request to resolver process\\n\"));\n\t\t\treturn;\n\t\t}\n\t}\n\tquery_data->resolver->inpa = purple_input_add(query_data->resolver->fd_out,\n\t\t\tPURPLE_INPUT_READ, host_resolved, query_data);\n}\n", "bug_type": null, "idx": 711}
{"project": "Pidgin", "target": 0, "func": "\nstatic gchar *roster_groups_join(GSList *list)\n{\n\tGString *out = g_string_new(NULL);\n\tfor ( ; list; list = list->next) {\n\t\tout = g_string_append(out, (const char *)list->data);\n\t\tif (list->next)\n\t\t\tout = g_string_append(out, \", \");\n\t}\n\treturn g_string_free(out, FALSE);\n}\n", "bug_type": null, "idx": 712}
{"project": "Pidgin", "target": 0, "func": "static void\ndeny_no_add_cb(auth_and_add *aa)\n{\n\taa->deny_cb(aa->data);\n}\n", "bug_type": null, "idx": 713}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_status_is_independent(const PurpleStatus *status)\n{\n\tg_return_val_if_fail(status != NULL, FALSE);\n\treturn purple_status_type_is_independent(purple_status_get_type(status));\n}\n", "bug_type": null, "idx": 714}
{"project": "Pidgin", "target": 0, "func": "\nstatic void remove_convs_wintrans(gboolean remove_signal) {\n\tGList *wins;\n\tfor (wins = pidgin_conv_windows_get_list(); wins; wins = wins->next) {\n\t\tPidginWindow *win = wins->data;\n\t\tGtkWidget *window = win->window;\n\t\tif (purple_prefs_get_bool(OPT_WINTRANS_IM_ENABLED))\n\t\t\tset_wintrans(window, 0, FALSE, FALSE);\n\t\t\n\t\tif (remove_signal)\n\t\t\tg_signal_handlers_disconnect_by_func(G_OBJECT(window),\n\t\t\t\tG_CALLBACK(focus_conv_win_cb), window);\n\t}\n\tremove_sliders();\n}\n", "bug_type": null, "idx": 715}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_mini_dialog_init(PidginMiniDialog *self)\n{\n\tGtkBox *self_box = GTK_BOX(self);\n\tguint blist_width = purple_prefs_get_int(BLIST_WIDTH_PREF);\n\tguint label_width = blist_width - BLIST_WIDTH_OTHER_THAN_LABEL;\n\tPidginMiniDialogPrivate *priv = g_new0(PidginMiniDialogPrivate, 1);\n\tself->priv = priv;\n\tgtk_container_set_border_width(GTK_CONTAINER(self), PIDGIN_HIG_BOX_SPACE);\n\tpriv->title_box = GTK_BOX(gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE));\n\tpriv->icon = GTK_IMAGE(gtk_image_new());\n\tgtk_misc_set_alignment(GTK_MISC(priv->icon), 0, 0);\n\tpriv->title = GTK_LABEL(gtk_label_new(NULL));\n\tgtk_widget_set_size_request(GTK_WIDGET(priv->title), label_width, -1);\n\tgtk_label_set_line_wrap(priv->title, TRUE);\n\tgtk_label_set_selectable(priv->title, TRUE);\n\tgtk_misc_set_alignment(GTK_MISC(priv->title), 0, 0);\n\tgtk_box_pack_start(priv->title_box, GTK_WIDGET(priv->icon), FALSE, FALSE, 0);\n\tgtk_box_pack_start(priv->title_box, GTK_WIDGET(priv->title), TRUE, TRUE, 0);\n\tpriv->desc = GTK_LABEL(gtk_label_new(NULL));\n\tgtk_widget_set_size_request(GTK_WIDGET(priv->desc), label_width, -1);\n\tgtk_label_set_line_wrap(priv->desc, TRUE);\n\tgtk_misc_set_alignment(GTK_MISC(priv->desc), 0, 0);\n\tgtk_label_set_selectable(priv->desc, TRUE);\n\t\n\tg_object_set(G_OBJECT(priv->desc), \"no-show-all\", TRUE, NULL);\n\tpurple_prefs_connect_callback(self, BLIST_WIDTH_PREF,\n\t\tblist_width_changed_cb, self);\n\tself->contents = GTK_BOX(gtk_vbox_new(FALSE, 0));\n\tpriv->buttons = GTK_BOX(gtk_hbox_new(FALSE, 0));\n\tgtk_box_pack_start(self_box, GTK_WIDGET(priv->title_box), FALSE, FALSE, 0);\n\tgtk_box_pack_start(self_box, GTK_WIDGET(priv->desc), FALSE, FALSE, 0);\n\tgtk_box_pack_start(self_box, GTK_WIDGET(self->contents), TRUE, TRUE, 0);\n\tgtk_box_pack_start(self_box, GTK_WIDGET(priv->buttons), FALSE, FALSE, 0);\n\tgtk_widget_show_all(GTK_WIDGET(self));\n}\n", "bug_type": null, "idx": 716}
{"project": "Pidgin", "target": 0, "func": "void jabber_set_status(PurpleAccount *account, PurpleStatus *status)\n{\n\tPurpleConnection *gc;\n\tJabberStream *js;\n\tif (!purple_account_is_connected(account))\n\t\treturn;\n\tif (purple_status_is_exclusive(status) && !purple_status_is_active(status)) {\n\t\t\n\t\treturn;\n\t}\n\tgc = purple_account_get_connection(account);\n\tjs = purple_connection_get_protocol_data(gc);\n\t\n\tif (purple_status_type_get_primitive(purple_status_get_type(status)) == PURPLE_STATUS_MOOD) {\n\t\tconst char *mood =\n\t\t\tpurple_status_get_attr_string(status, PURPLE_MOOD_NAME);\n\t\tconst char *mood_text =\n\t\t\tpurple_status_get_attr_string(status, PURPLE_MOOD_COMMENT);\n\t\tjabber_mood_set(js, mood, mood_text);\n\t\treturn;\n\t}\n\tjabber_presence_send(js, FALSE);\n}\n", "bug_type": null, "idx": 717}
{"project": "Pidgin", "target": 0, "func": "void gnt_wm_raise_window(GntWM *wm, GntWidget *widget)\n{\n\tGntWS *ws = gnt_wm_widget_find_workspace(wm, widget);\n\tif (wm->cws != ws)\n\t\tgnt_wm_switch_workspace(wm, g_list_index(wm->workspaces, ws));\n\tif (widget != wm->cws->ordered->data) {\n\t\tGntWidget *wid = wm->cws->ordered->data;\n\t\twm->cws->ordered = g_list_bring_to_front(wm->cws->ordered, widget);\n\t\tgnt_widget_set_focus(wid, FALSE);\n\t\tgnt_widget_draw(wid);\n\t}\n\tgnt_widget_set_focus(widget, TRUE);\n\tgnt_widget_draw(widget);\n\tg_signal_emit(wm, signals[SIG_GIVE_FOCUS], 0, widget);\n}\n", "bug_type": null, "idx": 718}
{"project": "Pidgin", "target": 0, "func": "int purple_log_get_size(PurpleLog *log)\n{\n\tg_return_val_if_fail(log && log->logger, 0);\n\tif (log->logger->size)\n\t\treturn log->logger->size(log);\n\treturn 0;\n}\n", "bug_type": null, "idx": 719}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int receiveadded(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tint ret = 0;\n\taim_rxcallback_t userfunc;\n\tguint16 tmp;\n\tchar *bn;\n\t\n\ttmp = byte_stream_get8(bs);\n\tif (!tmp) {\n\t\tpurple_debug_warning(\"oscar\", \"Dropping 'you were added' SNAC \"\n\t\t\t\t\"because username was empty\\n\");\n\t\treturn 0;\n\t}\n\tbn = byte_stream_getstr(bs, tmp);\n\tif (!g_utf8_validate(bn, -1, NULL)) {\n\t\tpurple_debug_warning(\"oscar\", \"Dropping 'you were added' SNAC \"\n\t\t\t\t\"because the username was not valid UTF-8\\n\");\n\t\tg_free(bn);\n\t}\n\tif ((userfunc = aim_callhandler(od, snac->family, snac->subtype)))\n\t\tret = userfunc(od, conn, frame, bn);\n\tg_free(bn);\n\treturn ret;\n}\n", "bug_type": null, "idx": 720}
{"project": "Pidgin", "target": 0, "func": "static void do_register_exp(struct simple_account_data *sip, int expire) {\n\tchar *uri, *to, *contact, *hdr;\n\tsip->reregister = time(NULL) + expire - 50;\n\turi = g_strdup_printf(\"sip:%s\", sip->servername);\n\tto = g_strdup_printf(\"sip:%s@%s\", sip->username, sip->servername);\n\tcontact = get_contact(sip);\n\thdr = g_strdup_printf(\"Contact: %s\\r\\nExpires: %d\\r\\n\", contact, expire);\n\tg_free(contact);\n\tsip->registerstatus = SIMPLE_REGISTER_SENT;\n\tsend_sip_request(sip->gc, \"REGISTER\", uri, to, hdr, \"\", NULL,\n\t\tprocess_register_response);\n\tg_free(hdr);\n\tg_free(uri);\n\tg_free(to);\n}\n", "bug_type": null, "idx": 721}
{"project": "Pidgin", "target": 0, "func": "static void\nplugin_act(GtkObject *obj, PurplePluginAction *pam)\n{\n\tif (pam && pam->callback)\n\t\tpam->callback(pam);\n}\n", "bug_type": null, "idx": 722}
{"project": "Pidgin", "target": 0, "func": "static void do_add_file_cb(const char *filename, gpointer data)\n{\n\tPidginSmiley *s = data;\n\tGdkPixbuf *pixbuf;\n\tif (!filename)\n\t\treturn;\n\tg_free(s->filename);\n\ts->filename = g_strdup(filename);\n\tpixbuf = pidgin_pixbuf_new_from_file_at_scale(filename, 64, 64, FALSE);\n\tgtk_image_set_from_pixbuf(GTK_IMAGE(s->smiley_image), pixbuf);\n\tif (pixbuf)\n\t\tg_object_unref(G_OBJECT(pixbuf));\n\tgtk_widget_grab_focus(s->smile);\n\tif (s->entry_len > 0)\n\t\tgtk_dialog_set_response_sensitive(GTK_DIALOG(s->parent), GTK_RESPONSE_ACCEPT, TRUE);\n}\n", "bug_type": null, "idx": 723}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_userlist_request(struct gg_session *sess, char type, const char *request)\n{\n\tint len;\n\tif (!sess) {\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\tif (sess->state != GG_STATE_CONNECTED) {\n\t\terrno = ENOTCONN;\n\t\treturn -1;\n\t}\n\tif (!request) {\n\t\tsess->userlist_blocks = 1;\n\t\treturn gg_send_packet(sess, GG_USERLIST_REQUEST, &type, sizeof(type), NULL);\n\t}\n\tlen = strlen(request);\n\tsess->userlist_blocks = 0;\n\twhile (len > 2047) {\n\t\tsess->userlist_blocks++;\n\t\tif (gg_send_packet(sess, GG_USERLIST_REQUEST, &type, sizeof(type), request, 2047, NULL) == -1)\n\t\t\treturn -1;\n\t\tif (type == GG_USERLIST_PUT)\n\t\t\ttype = GG_USERLIST_PUT_MORE;\n\t\trequest += 2047;\n\t\tlen -= 2047;\n\t}\n\tsess->userlist_blocks++;\n\treturn gg_send_packet(sess, GG_USERLIST_REQUEST, &type, sizeof(type), request, len, NULL);\n}\n", "bug_type": null, "idx": 724}
{"project": "Pidgin", "target": 0, "func": "static FsNetworkProtocol\npurple_media_network_protocol_to_fs(PurpleMediaNetworkProtocol protocol)\n{\n\tswitch (protocol) {\n\t\tcase PURPLE_MEDIA_NETWORK_PROTOCOL_UDP:\n\t\t\treturn FS_NETWORK_PROTOCOL_UDP;\n#if GST_CHECK_VERSION(1,0,0)\n\t\tcase PURPLE_MEDIA_NETWORK_PROTOCOL_TCP_PASSIVE:\n\t\t\treturn FS_NETWORK_PROTOCOL_TCP_PASSIVE;\n\t\tcase PURPLE_MEDIA_NETWORK_PROTOCOL_TCP_ACTIVE:\n\t\t\treturn FS_NETWORK_PROTOCOL_TCP_ACTIVE;\n\t\tcase PURPLE_MEDIA_NETWORK_PROTOCOL_TCP_SO:\n\t\t\treturn FS_NETWORK_PROTOCOL_TCP_SO;\n#endif\n\t\tdefault:\n\t\t\tg_return_val_if_reached(FS_NETWORK_PROTOCOL_TCP);\n\t}\n}\n", "bug_type": null, "idx": 725}
{"project": "Pidgin", "target": 0, "func": "int tcl_cmd_presence(ClientData unused, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])\n{\n\tconst char *cmds[] = { \"account\", \"active_status\", \"available\",\n\t\t\t       \"chat_user\", \"context\", \"conversation\", \"idle\",\n\t\t\t       \"login\", \"online\", \"status\", \"statuses\", NULL };\n\tenum { CMD_PRESENCE_ACCOUNT, CMD_PRESENCE_ACTIVE_STATUS,\n\t       CMD_PRESENCE_AVAILABLE, CMD_PRESENCE_CHAT_USER,\n\t       CMD_PRESENCE_CONTEXT, CMD_PRESENCE_CONVERSATION,\n\t       CMD_PRESENCE_IDLE, CMD_PRESENCE_LOGIN, CMD_PRESENCE_ONLINE,\n\t       CMD_PRESENCE_STATUS, CMD_PRESENCE_STATUSES } cmd;\n\tTcl_Obj *result;\n\tTcl_Obj *list, *elem;\n\tPurplePresence *presence;\n\tGList *cur;\n\tint error, idle, idle_time, login_time;\n\tif (objc < 2) {\n\t\tTcl_WrongNumArgs(interp, 1, objv, \"subcommand ?args?\");\n\t\treturn TCL_ERROR;\n\t}\n\tif ((error = Tcl_GetIndexFromObj(interp, objv[1], cmds, \"subcommand\", 0, (int *)&cmd)) != TCL_OK)\n\t\treturn error;\n\tswitch (cmd) {\n\tcase CMD_PRESENCE_ACCOUNT:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp, purple_tcl_ref_new(PurpleTclRefAccount,\n\t\t                                          purple_presence_get_account(presence)));\n\t\tbreak;\n\tcase CMD_PRESENCE_ACTIVE_STATUS:\n\t\tif (objc != 3 && objc != 4 && objc != 5) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence [?status_id? | ?-primitive primitive?]\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tif (objc == 3) {\n\t\t\tTcl_SetObjResult(interp,\n\t\t\t\t\t purple_tcl_ref_new(PurpleTclRefStatus,\n\t\t\t\t\t\t\t  purple_presence_get_active_status(presence)));\n\t\t} else if (objc == 4) {\n\t\t\tTcl_SetObjResult(interp,\n                                         Tcl_NewBooleanObj(\n\t\t\t\t\t\t purple_presence_is_status_active(presence,\n\t\t\t\t\t\t\t\t\t\t  Tcl_GetString(objv[3]))));\n\t\t} else {\n\t\t\tPurpleStatusPrimitive primitive;\n\t\t\tif (strcmp(Tcl_GetString(objv[3]), \"-primitive\")) {\n\t\t\t\tresult = Tcl_NewStringObj(\"bad option \\\"\", -1);\n\t\t\t\tTcl_AppendObjToObj(result, objv[3]);\n\t\t\t\tTcl_AppendToObj(result,\n\t\t\t\t\t\t\"\\\": should be -primitive\", -1);\n\t\t\t\tTcl_SetObjResult(interp,result);\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t\tprimitive = purple_primitive_get_type_from_id(Tcl_GetString(objv[4]));\n\t\t\tif (primitive == PURPLE_STATUS_UNSET) {\n\t\t\t\tresult = Tcl_NewStringObj(\"invalid primitive \", -1);\n\t\t\t\tTcl_AppendObjToObj(result, objv[4]);\n\t\t\t\tTcl_SetObjResult(interp,result);\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t\tTcl_SetObjResult(interp,\n                                         Tcl_NewBooleanObj(\n\t\t\t\t\t\t purple_presence_is_status_primitive_active(presence, primitive)));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CMD_PRESENCE_AVAILABLE:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t Tcl_NewBooleanObj(purple_presence_is_available(presence)));\n\t\tbreak;\n\tcase CMD_PRESENCE_CHAT_USER:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t Tcl_NewStringObj(purple_presence_get_chat_user(presence), -1));\n\t\tbreak;\n\tcase CMD_PRESENCE_CONTEXT:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tswitch (purple_presence_get_context(presence)) {\n\t\tcase PURPLE_PRESENCE_CONTEXT_UNSET:\n\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"unset\", -1));\n\t\t\tbreak;\n\t\tcase PURPLE_PRESENCE_CONTEXT_ACCOUNT:\n\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"account\", -1));\n\t\t\tbreak;\n\t\tcase PURPLE_PRESENCE_CONTEXT_CONV:\n\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"conversation\", -1));\n\t\t\tbreak;\n\t\tcase PURPLE_PRESENCE_CONTEXT_BUDDY:\n\t\t\tTcl_SetObjResult(interp, Tcl_NewStringObj(\"buddy\", -1));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CMD_PRESENCE_CONVERSATION:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp, purple_tcl_ref_new(PurpleTclRefConversation,\n\t\t                                          purple_presence_get_conversation(presence)));\n\t\tbreak;\n\tcase CMD_PRESENCE_IDLE:\n\t\tif (objc < 3 || objc > 5) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence ?idle? ?time?\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tif (objc == 3) {\n\t\t\tif (purple_presence_is_idle(presence)) {\n\t\t\t\tidle_time = purple_presence_get_idle_time (presence);\n\t\t\t\tTcl_SetObjResult(interp, Tcl_NewIntObj(idle_time));\n\t\t\t} else {\n\t\t\t\tresult = Tcl_NewListObj(0, NULL);\n\t\t\t\tTcl_SetObjResult(interp, result);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = Tcl_GetBooleanFromObj(interp, objv[3], &idle)) != TCL_OK)\n\t\t\treturn TCL_ERROR;\n\t\tif (objc == 4) {\n\t\t\tpurple_presence_set_idle(presence, idle, time(NULL));\n\t\t} else if (objc == 5) {\n\t\t\tif ((error = Tcl_GetIntFromObj(interp,\n\t\t                                       objv[4],\n\t\t                                       &idle_time)) != TCL_OK)\n\t\t\t\treturn TCL_ERROR;\n\t\t\tpurple_presence_set_idle(presence, idle, idle_time);\n\t\t}\n\t\tbreak;\n\tcase CMD_PRESENCE_LOGIN:\n\t\tif (objc != 3 && objc != 4) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence ?time?\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tif (objc == 3) {\n\t\t\tTcl_SetObjResult(interp, Tcl_NewIntObj(purple_presence_get_login_time(presence)));\n\t\t} else {\n\t\t\tif ((error == Tcl_GetIntFromObj(interp,\n\t\t\t                                objv[3],\n\t\t\t                                &login_time)) != TCL_OK)\n\t\t\t\treturn TCL_ERROR;\n\t\t\tpurple_presence_set_login_time(presence, login_time);\n\t\t}\n\t\tbreak;\n\tcase CMD_PRESENCE_ONLINE:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t Tcl_NewBooleanObj(\n\t\t\t\t\t purple_presence_is_online(presence)));\n\t\tbreak;\n\tcase CMD_PRESENCE_STATUS:\n\t\tif (objc != 4) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence status_id\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tTcl_SetObjResult(interp,\n\t\t                 purple_tcl_ref_new(PurpleTclRefStatus,\n\t\t                                  purple_presence_get_status(presence,\n\t\t                                                           Tcl_GetString(objv[3]))));\n\t\tbreak;\n\tcase CMD_PRESENCE_STATUSES:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"presence\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((presence = purple_tcl_ref_get(interp, objv[2], PurpleTclRefPresence)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\tlist = Tcl_NewListObj(0, NULL);\n\t\tfor (cur = purple_presence_get_statuses(presence); cur != NULL;\n\t\t     cur = g_list_next(cur)) {\n\t\t\telem = purple_tcl_ref_new(PurpleTclRefStatus, cur->data);\n\t\t\tTcl_ListObjAppendElement(interp, list, elem);\n\t\t}\n\t\tTcl_SetObjResult(interp, list);\n\t\tbreak;\n\t}\n\treturn TCL_OK;\n}\n", "bug_type": null, "idx": 726}
{"project": "Pidgin", "target": 0, "func": "static void\ngtk_blist_do_personize(GList *merges)\n{\n\tPurpleBlistNode *contact = NULL;\n\tint max = 0;\n\tGList *tmp;\n\t\n\tfor (tmp = merges; tmp; tmp = tmp->next) {\n\t\tPurpleBlistNode *node = tmp->data;\n\t\tPurpleBlistNode *b;\n\t\tPurpleBlistNodeType type;\n\t\tint i = 0;\n\t\ttype = purple_blist_node_get_type(node);\n\t\tif (type == PURPLE_BLIST_BUDDY_NODE) {\n\t\t\tnode = purple_blist_node_get_parent(node);\n\t\t\ttype = purple_blist_node_get_type(node);\n\t\t}\n\t\tif (type != PURPLE_BLIST_CONTACT_NODE)\n\t\t\tcontinue;\n\t\tfor (b = purple_blist_node_get_first_child(node);\n\t\t     b;\n\t\t     b = purple_blist_node_get_sibling_next(b))\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (i > max) {\n\t\t\tcontact = node;\n\t\t\tmax = i;\n\t\t}\n\t}\n\tif (contact == NULL)\n\t\treturn;\n\t\n\tfor (tmp = merges; tmp; tmp = tmp->next) {\n\t\tPurpleBlistNode *node = tmp->data;\n\t\tif (purple_blist_node_get_type(node) == PURPLE_BLIST_BUDDY_NODE)\n\t\t\tnode = purple_blist_node_get_parent(node);\n\t\tif (node == contact)\n\t\t\tcontinue;\n\t\tpurple_blist_merge_contact((PurpleContact *)node, contact);\n\t}\n\t\n\tpidgin_blist_expand_contact_cb(NULL, contact);\n\tg_list_free(merges);\n}\n", "bug_type": null, "idx": 727}
{"project": "Pidgin", "target": 0, "func": "static void login_cb(gpointer data, gint source, const gchar *error_message) {\n\tPurpleConnection *gc = data;\n\tstruct simple_account_data *sip;\n\tstruct sip_connection *conn;\n\tif(source < 0) {\n\t\tgchar *tmp = g_strdup_printf(_(\"Unable to connect: %s\"),\n\t\t\t\terror_message);\n\t\tpurple_connection_error_reason(gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);\n\t\tg_free(tmp);\n\t\treturn;\n\t}\n\tsip = gc->proto_data;\n\tsip->fd = source;\n\tconn = connection_create(sip, source);\n\tsip->registertimeout = purple_timeout_add((rand()%100)+10*1000, (GSourceFunc)subscribe_timeout, sip);\n\tdo_register(sip);\n\tconn->inputhandler = purple_input_add(sip->fd, PURPLE_INPUT_READ, simple_input_cb, gc);\n}\n", "bug_type": null, "idx": 728}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_slider_map(GntWidget *widget)\n{\n\tif (widget->priv.width == 0 || widget->priv.height == 0)\n\t\tgnt_widget_size_request(widget);\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 729}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_blist_visibility_manager_add()\n{\n\tvisibility_manager_count++;\n\tpurple_debug_info(\"gtkblist\", \"added visibility manager: %d\\n\", visibility_manager_count);\n}\n", "bug_type": null, "idx": 730}
{"project": "Pidgin", "target": 0, "func": "static void\nidle_action(PurplePluginAction *action)\n{\n\t\n\tPurpleRequestFields *request;\n\tPurpleRequestFieldGroup *group;\n\tPurpleRequestField *field;\n\tgroup = purple_request_field_group_new(NULL);\n\tfield = purple_request_field_account_new(\"acct\", _(\"Account\"), NULL);\n\tpurple_request_field_account_set_filter(field, idleable_filter);\n\tpurple_request_field_account_set_show_all(field, FALSE);\n\tpurple_request_field_group_add_field(group, field);\n\tfield = purple_request_field_int_new(\"mins\", _(\"Minutes\"), 10);\n\tpurple_request_field_group_add_field(group, field);\n\trequest = purple_request_fields_new();\n\tpurple_request_fields_add_group(request, group);\n\tpurple_request_fields(action->plugin,\n\t\t\tN_(\"I'dle Mak'er\"),\n\t\t\t_(\"Set Account Idle Time\"),\n\t\t\tNULL,\n\t\t\trequest,\n\t\t\t_(\"_Set\"), G_CALLBACK(idle_action_ok),\n\t\t\t_(\"_Cancel\"), NULL,\n\t\t\tNULL, NULL, NULL,\n\t\t\tNULL);\n}\nstatic void\nunidle_action(PurplePluginAction *action)\n{\n\tPurpleRequestFields *request;\n\tPurpleRequestFieldGroup *group;\n\tPurpleRequestField *field;\n\tif (idled_accts == NULL)\n\t{\n\t\tpurple_notify_info(NULL, NULL, _(\"None of your accounts are idle.\"), NULL);\n\t\treturn;\n\t}\n\tgroup = purple_request_field_group_new(NULL);\n\tfield = purple_request_field_account_new(\"acct\", _(\"Account\"), NULL);\n\tpurple_request_field_account_set_filter(field, unidle_filter);\n\tpurple_request_field_account_set_show_all(field, FALSE);\n\tpurple_request_field_group_add_field(group, field);\n\trequest = purple_request_fields_new();\n\tpurple_request_fields_add_group(request, group);\n\tpurple_request_fields(action->plugin,\n\t\t\tN_(\"I'dle Mak'er\"),\n\t\t\t_(\"Unset Account Idle Time\"),\n\t\t\tNULL,\n\t\t\trequest,\n\t\t\t_(\"_Unset\"), G_CALLBACK(unidle_action_ok),\n\t\t\t_(\"_Cancel\"), NULL,\n\t\t\tNULL, NULL, NULL,\n\t\t\tNULL);\n}\n", "bug_type": null, "idx": 731}
{"project": "Pidgin", "target": 0, "func": "void finch_prefs_show_all()\n{\n\tPurpleRequestFields *fields;\n\tif (pref_request.showing) {\n\t\tgnt_window_present(pref_request.window);\n\t\treturn;\n\t}\n\tfields = purple_request_fields_new();\n\tadd_pref_group(fields, _(\"Buddy List\"), blist);\n\tadd_pref_group(fields, _(\"Conversations\"), convs);\n\tadd_pref_group(fields, _(\"Logging\"), logging);\n\tadd_pref_group(fields, _(\"Idle\"), idle);\n\tpref_request.showing = TRUE;\n\tpref_request.window = purple_request_fields(NULL, _(\"Preferences\"), NULL, NULL, fields,\n\t\t\t_(\"Save\"), G_CALLBACK(save_cb), _(\"Cancel\"), free_strings,\n\t\t\tNULL, NULL, NULL,\n\t\t\tNULL);\n}\n", "bug_type": null, "idx": 732}
{"project": "Pidgin", "target": 0, "func": "void\ngnt_widget_hide(GntWidget *widget)\n{\n\tg_signal_emit(widget, signals[SIG_HIDE], 0);\n\twbkgdset(widget->window, '\\0' | gnt_color_pair(GNT_COLOR_NORMAL));\n#if 0\n\t\n\tif (gnt_widget_has_shadow(widget))\n\t\tmvwvline(widget->window, 1, widget->priv.width, ' ', widget->priv.height);\n#endif\n\tgnt_screen_release(widget);\n\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_INVISIBLE);\n\tGNT_WIDGET_UNSET_FLAGS(widget, GNT_WIDGET_MAPPED);\n}\n", "bug_type": null, "idx": 733}
{"project": "Pidgin", "target": 0, "func": "static void irc_buddy_free(struct irc_buddy *ib)\n{\n\tg_free(ib->name);\n\tg_free(ib);\n}\n", "bug_type": null, "idx": 734}
{"project": "Pidgin", "target": 0, "func": "static void\ndump_file_cancel(GntWidget *w, GntFileSel *fs)\n{\n\tgnt_widget_destroy(GNT_WIDGET(fs));\n}\n", "bug_type": null, "idx": 735}
{"project": "Pidgin", "target": 0, "func": "void\npurple_attention_type_set_incoming_desc(PurpleAttentionType *type, const char *desc)\n{\n\tg_return_if_fail(type != NULL);\n\ttype->incoming_description = desc;\n}\n", "bug_type": null, "idx": 736}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\tPurpleNotifyUiOps *ops = purple_notify_get_ui_ops();\n\tplugin->extra = ops->notify_uri;\n\tops->notify_uri = tinyurl_notify_uri;\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\t\"wrote-im-msg\",\n\t\t\tplugin, PURPLE_CALLBACK(wrote_msg), NULL);\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\t\"wrote-chat-msg\",\n\t\t\tplugin, PURPLE_CALLBACK(wrote_msg), NULL);\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\t\"writing-im-msg\",\n\t\t\tplugin, PURPLE_CALLBACK(writing_msg), NULL);\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\t\"writing-chat-msg\",\n\t\t\tplugin, PURPLE_CALLBACK(writing_msg), NULL);\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\t\"deleting-conversation\",\n\t\t\tplugin, PURPLE_CALLBACK(free_conv_urls), NULL);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 737}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_pounce_get_data(const PurplePounce *pounce)\n{\n\tg_return_val_if_fail(pounce != NULL, NULL);\n\treturn pounce->data;\n}\n", "bug_type": null, "idx": 738}
{"project": "Pidgin", "target": 0, "func": "static xmlnode *\ncontact_to_xmlnode(PurpleBlistNode *cnode)\n{\n\txmlnode *node, *child;\n\tPurpleContact *contact;\n\tPurpleBlistNode *bnode;\n\tcontact = (PurpleContact *)cnode;\n\tnode = xmlnode_new(\"contact\");\n\tif (contact->alias != NULL)\n\t{\n\t\txmlnode_set_attrib(node, \"alias\", contact->alias);\n\t}\n\t\n\tfor (bnode = cnode->child; bnode != NULL; bnode = bnode->next)\n\t{\n\t\tif (!PURPLE_BLIST_NODE_SHOULD_SAVE(bnode))\n\t\t\tcontinue;\n\t\tif (PURPLE_BLIST_NODE_IS_BUDDY(bnode))\n\t\t{\n\t\t\tchild = buddy_to_xmlnode(bnode);\n\t\t\txmlnode_insert_child(node, child);\n\t\t}\n\t}\n\t\n\tg_hash_table_foreach(cnode->settings, value_to_xmlnode, node);\n\treturn node;\n}\n", "bug_type": null, "idx": 739}
{"project": "Pidgin", "target": 0, "func": "static void\nwrote_chat_msg_cb(PurpleAccount *account, const char *who, const char *buffer,\n\t\t\t\tPurpleConversation *conv, PurpleMessageFlags flags, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"wrote-chat-msg (%s, %s)\\n\",\n\t\t\t\t\tpurple_conversation_get_name(conv), buffer);\n}\n", "bug_type": null, "idx": 740}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_choice_set_value(PurpleRequestField *field,\n\t\t\t\t\t\t\t\t\t\t\tint value)\n{\n\tg_return_if_fail(field != NULL);\n\tg_return_if_fail(field->type == PURPLE_REQUEST_FIELD_CHOICE);\n\tfield->u.choice.value = value;\n}\n", "bug_type": null, "idx": 741}
{"project": "Pidgin", "target": 0, "func": "gchar *\npurple_media_candidate_get_username(PurpleMediaCandidate *candidate)\n{\n\tgchar *username;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_CANDIDATE(candidate), NULL);\n\tg_object_get(candidate, \"username\", &username, NULL);\n\treturn username;\n}\n", "bug_type": null, "idx": 742}
{"project": "Pidgin", "target": 0, "func": "static void gtk_blist_show_onlinehelp_cb(void)\n{\n\tpurple_notify_uri(NULL, PURPLE_WEBSITE \"documentation\");\n}\n", "bug_type": null, "idx": 743}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_request_close_info(PurpleRequestInfo *info)\n{\n\tPurpleRequestUiOps *ops;\n\tops = purple_request_get_ui_ops();\n\tpurple_notify_close_with_handle(info->ui_handle);\n\tpurple_request_close_with_handle(info->ui_handle);\n\tif (ops != NULL && ops->close_request != NULL)\n\t\tops->close_request(info->type, info->ui_handle);\n\tg_free(info);\n}\n", "bug_type": null, "idx": 744}
{"project": "Pidgin", "target": 0, "func": "NMRtfContext *\nnm_rtf_init()\n{\n\tNMRtfContext *ctx = g_new0(NMRtfContext, 1);\n\tctx->nextch_available = FALSE;\n\tctx->ansi = g_string_new(\"\");\n\tctx->output = g_string_new(\"\");\n\treturn ctx;\n}\n", "bug_type": null, "idx": 745}
{"project": "Pidgin", "target": 0, "func": "static GtkIMHtmlSmiley *smiley_purple_to_gtkimhtml(PurpleSmiley *smiley)\n{\n\tGtkIMHtmlSmiley *gtksmiley;\n\tgchar *filename;\n\tconst gchar *file;\n\tfile = purple_imgstore_get_filename(purple_smiley_get_stored_image(smiley));\n\tfilename = g_build_filename(purple_smileys_get_storing_dir(), file, NULL);\n\tgtksmiley = gtk_imhtml_smiley_create(filename, purple_smiley_get_shortcut(smiley),\n\t\t\tFALSE, GTK_IMHTML_SMILEY_CUSTOM);\n\tg_free(filename);\n\t\n\tg_signal_connect(G_OBJECT(smiley), \"notify::shortcut\",\n\t\t\tG_CALLBACK(shortcut_changed_cb), gtksmiley);\n\t\n\tg_signal_connect(G_OBJECT(smiley), \"notify::image\",\n\t\t\tG_CALLBACK(image_changed_cb), gtksmiley);\n\treturn gtksmiley;\n}\n", "bug_type": null, "idx": 746}
{"project": "Pidgin", "target": 0, "func": "gboolean\ngnt_bindable_check_key(GntBindable *bindable, const char *keys) {\n\tGntBindableClass *klass = GNT_BINDABLE_CLASS(GNT_BINDABLE_GET_CLASS(bindable));\n\tGntBindableActionParam *param = g_hash_table_lookup(klass->bindings, keys);\n\treturn (param && param->action);\n}\n", "bug_type": null, "idx": 747}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_media_backend_codecs_ready(PurpleMediaBackend *self,\n\t\tconst gchar *sess_id)\n{\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_BACKEND(self), FALSE);\n\treturn PURPLE_MEDIA_BACKEND_GET_INTERFACE(self)->codecs_ready(self,\n\t\t\tsess_id);\n}\n", "bug_type": null, "idx": 748}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nworkspace_new(GntBindable *bindable, GList *null)\n{\n\tGntWM *wm = GNT_WM(bindable);\n\tGntWS *ws = gnt_ws_new(NULL);\n\tgnt_wm_add_workspace(wm, ws);\n\tgnt_wm_switch_workspace(wm, g_list_index(wm->workspaces, ws));\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 749}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nsmall_step_back(GntBindable *bindable, GList *null)\n{\n\tGntSlider *slider = GNT_SLIDER(bindable);\n\tgnt_slider_set_value(slider, slider->current - slider->smallstep);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 750}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_themes_destroy_smiley_theme(struct smiley_theme *theme)\n{\n\tpidgin_themes_destroy_smiley_theme_smileys(theme);\n\tg_free(theme->name);\n\tg_free(theme->desc);\n\tg_free(theme->author);\n\tg_free(theme->icon);\n\tg_free(theme->path);\n\tg_free(theme);\n}\n", "bug_type": null, "idx": 751}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nbus_call (GstBus *bus, GstMessage *msg, gpointer data)\n{\n\tGstElement *play = data;\n\tGError *err = NULL;\n\tswitch (GST_MESSAGE_TYPE (msg)) {\n\tcase GST_MESSAGE_ERROR:\n\t\tgst_message_parse_error(msg, &err, NULL);\n\t\tpurple_debug_error(\"gstreamer\", \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\t\n\tcase GST_MESSAGE_EOS:\n\t\tgst_element_set_state(play, GST_STATE_NULL);\n\t\tgst_object_unref(GST_OBJECT(play));\n\t\treturn FALSE;\n\t\tbreak;\n\tcase GST_MESSAGE_WARNING:\n\t\tgst_message_parse_warning(msg, &err, NULL);\n\t\tpurple_debug_warning(\"gstreamer\", \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 752}
{"project": "Pidgin", "target": 0, "func": "const char *\nnm_user_record_get_display_id(NMUserRecord * user_record)\n{\n\tif (user_record == NULL)\n\t\treturn NULL;\n\tif (user_record->display_id == NULL) {\n\t\tuser_record->display_id = nm_typed_to_dotted(user_record->dn);\n\t}\n\treturn user_record->display_id;\n}\n", "bug_type": null, "idx": 753}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_sound_theme_init(GTypeInstance *instance,\n\t\tgpointer klass)\n{\n\tPurpleSoundThemePrivate *priv;\n\t(PURPLE_SOUND_THEME(instance))->priv = g_new0(PurpleSoundThemePrivate, 1);\n\tpriv = PURPLE_SOUND_THEME_GET_PRIVATE(instance);\n\tpriv->sound_files = g_hash_table_new_full(g_str_hash,\n\t\t\tg_str_equal, g_free, g_free);\n}\n", "bug_type": null, "idx": 754}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_media_get_property (GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)\n{\n\tPurpleMedia *media;\n\tg_return_if_fail(PURPLE_IS_MEDIA(object));\n\tmedia = PURPLE_MEDIA(object);\n\tswitch (prop_id) {\n\t\tcase PROP_MANAGER:\n\t\t\tg_value_set_object(value, media->priv->manager);\n\t\t\tbreak;\n\t\tcase PROP_BACKEND:\n\t\t\tg_value_set_object(value, media->priv->backend);\n\t\t\tbreak;\n\t\tcase PROP_ACCOUNT:\n\t\t\tg_value_set_pointer(value, media->priv->account);\n\t\t\tbreak;\n\t\tcase PROP_CONFERENCE_TYPE:\n\t\t\tg_value_set_string(value,\n\t\t\t\t\tmedia->priv->conference_type);\n\t\t\tbreak;\n\t\tcase PROP_INITIATOR:\n\t\t\tg_value_set_boolean(value, media->priv->initiator);\n\t\t\tbreak;\n\t\tcase PROP_PRPL_DATA:\n\t\t\tg_value_set_pointer(value, media->priv->prpl_data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 755}
{"project": "Pidgin", "target": 0, "func": "PurpleDesktopItem *\npurple_desktop_item_copy (const PurpleDesktopItem *item)\n{\n\tGList *li;\n\tPurpleDesktopItem *retval;\n\tg_return_val_if_fail (item != NULL, NULL);\n\tg_return_val_if_fail (item->refcount > 0, NULL);\n\tretval = _purple_desktop_item_new ();\n\tretval->type = item->type;\n\tretval->modified = item->modified;\n\tretval->location = g_strdup (item->location);\n\tretval->mtime = item->mtime;\n\t\n\tretval->languages = g_list_copy (item->languages);\n\tfor (li = retval->languages; li != NULL; li = li->next)\n\t\tli->data = g_strdup (li->data);\n\t\n\tretval->keys = g_list_copy (item->keys);\n\tfor (li = retval->keys; li != NULL; li = li->next)\n\t\tli->data = g_strdup (li->data);\n\t\n\tretval->sections = g_list_copy (item->sections);\n\tfor (li = retval->sections; li != NULL; li = li->next)\n\t\tli->data = dup_section (li->data);\n\tretval->main_hash = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t\t   (GDestroyNotify) g_free,\n\t\t\t\t\t\t   (GDestroyNotify) g_free);\n\tg_hash_table_foreach (item->main_hash,\n\t\t\t      copy_string_hash,\n\t\t\t      retval->main_hash);\n\treturn retval;\n}\n", "bug_type": null, "idx": 756}
{"project": "Pidgin", "target": 0, "func": " */\nSTART_TEST(test_xmlnode_billion_laughs_attack)\n{\n\tconst char *malicious_xml_doc = \"<!DOCTYPE root [ <!ENTITY ha \\\"Ha !\\\"><!ENTITY ha2 \\\"&ha; &ha;\\\"><!ENTITY ha3 \\\"&ha2; &ha2;\\\"> ]><root>&ha3;</root>\";\n\t\n\t\n\tfail_if(xmlnode_from_str(malicious_xml_doc, -1),\n\t\t\t\"xmlnode_from_str() returned an XML tree, but we didn't want it to\");\n}\n", "bug_type": null, "idx": 757}
{"project": "Pidgin", "target": 0, "func": "static void sendout_sipmsg(struct simple_account_data *sip, struct sipmsg *msg) {\n\tGSList *tmp = msg->headers;\n\tgchar *name;\n\tgchar *value;\n\tGString *outstr = g_string_new(\"\");\n\tg_string_append_printf(outstr, \"%s %s SIP/2.0\\r\\n\", msg->method, msg->target);\n\twhile(tmp) {\n\t\tname = ((struct siphdrelement*) (tmp->data))->name;\n\t\tvalue = ((struct siphdrelement*) (tmp->data))->value;\n\t\tg_string_append_printf(outstr, \"%s: %s\\r\\n\", name, value);\n\t\ttmp = g_slist_next(tmp);\n\t}\n\tg_string_append_printf(outstr, \"\\r\\n%s\", msg->body ? msg->body : \"\");\n\tsendout_pkt(sip->gc, outstr->str);\n\tg_string_free(outstr, TRUE);\n}\n", "bug_type": null, "idx": 758}
{"project": "Pidgin", "target": 0, "func": "static void\nsigning_off_cb(PurpleConnection *gc, void *data)\n{\n\tPurpleAccount *account;\n\taccount = purple_connection_get_account(gc);\n\tidled_accts = g_list_remove(idled_accts, account);\n}\n", "bug_type": null, "idx": 759}
{"project": "Pidgin", "target": 0, "func": "static void\nadd_sized_icon(GtkIconSet *iconset, GtkIconSize sizeid, PidginIconTheme *theme,\n\t\tconst char *size, SizedStockIcon sized_icon, gboolean translucent)\n{\n\tchar *filename;\n\tGtkIconSource *source;\n\tGdkPixbuf *pixbuf;\n\tfilename = find_icon_file(theme, size, sized_icon, FALSE);\n\tg_return_if_fail(filename != NULL);\n\tpixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\tif (translucent)\n\t\tdo_alphashift(pixbuf);\n\tsource = gtk_icon_source_new();\n\tgtk_icon_source_set_pixbuf(source, pixbuf);\n\tgtk_icon_source_set_direction(source, GTK_TEXT_DIR_LTR);\n\tgtk_icon_source_set_direction_wildcarded(source, !sized_icon.rtl);\n\tgtk_icon_source_set_size(source, sizeid);\n\tgtk_icon_source_set_size_wildcarded(source, FALSE);\n\tgtk_icon_source_set_state_wildcarded(source, TRUE);\n\tgtk_icon_set_add_source(iconset, source);\n\tgtk_icon_source_free(source);\n\tif (sizeid == gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL)) {\n\t\tsource = gtk_icon_source_new();\n\t\tgtk_icon_source_set_pixbuf(source, pixbuf);\n\t\tgtk_icon_source_set_direction_wildcarded(source, TRUE);\n\t\tgtk_icon_source_set_size(source, GTK_ICON_SIZE_MENU);\n\t\tgtk_icon_source_set_size_wildcarded(source, FALSE);\n\t\tgtk_icon_source_set_state_wildcarded(source, TRUE);\n\t\tgtk_icon_set_add_source(iconset, source);\n\t\tgtk_icon_source_free(source);\n\t}\n\tg_free(filename);\n\tg_object_unref(pixbuf);\n\tif (sized_icon.rtl) {\n\t\tfilename = find_icon_file(theme, size, sized_icon, TRUE);\n\t\tg_return_if_fail(filename != NULL);\n\t\tpixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\t\tif (translucent)\n\t\t\tdo_alphashift(pixbuf);\n\t\tsource = gtk_icon_source_new();\n\t\tgtk_icon_source_set_pixbuf(source, pixbuf);\n\t\tgtk_icon_source_set_filename(source, filename);\n\t\tgtk_icon_source_set_direction(source, GTK_TEXT_DIR_RTL);\n\t\tgtk_icon_source_set_size(source, sizeid);\n\t\tgtk_icon_source_set_size_wildcarded(source, FALSE);\n\t\tgtk_icon_source_set_state_wildcarded(source, TRUE);\n\t\tgtk_icon_set_add_source(iconset, source);\n\t\tg_free(filename);\n\t\tg_object_unref(pixbuf);\n\t\tgtk_icon_source_free(source);\n\t}\n}\n", "bug_type": null, "idx": 760}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_glib_log_handler(const gchar *domain, GLogLevelFlags flags,\n\t\t\t\t\t  const gchar *msg, gpointer user_data)\n{\n\tPurpleDebugLevel level;\n\tchar *new_msg = NULL;\n\tchar *new_domain = NULL;\n\tif ((flags & G_LOG_LEVEL_ERROR) == G_LOG_LEVEL_ERROR)\n\t\tlevel = PURPLE_DEBUG_ERROR;\n\telse if ((flags & G_LOG_LEVEL_CRITICAL) == G_LOG_LEVEL_CRITICAL)\n\t\tlevel = PURPLE_DEBUG_FATAL;\n\telse if ((flags & G_LOG_LEVEL_WARNING) == G_LOG_LEVEL_WARNING)\n\t\tlevel = PURPLE_DEBUG_WARNING;\n\telse if ((flags & G_LOG_LEVEL_MESSAGE) == G_LOG_LEVEL_MESSAGE)\n\t\tlevel = PURPLE_DEBUG_INFO;\n\telse if ((flags & G_LOG_LEVEL_INFO) == G_LOG_LEVEL_INFO)\n\t\tlevel = PURPLE_DEBUG_INFO;\n\telse if ((flags & G_LOG_LEVEL_DEBUG) == G_LOG_LEVEL_DEBUG)\n\t\tlevel = PURPLE_DEBUG_MISC;\n\telse\n\t{\n\t\tpurple_debug_warning(\"gntdebug\",\n\t\t\t\t   \"Unknown glib logging level in %d\\n\", flags);\n\t\tlevel = PURPLE_DEBUG_MISC; \n\t}\n\tif (msg != NULL)\n\t\tnew_msg = purple_utf8_try_convert(msg);\n\tif (domain != NULL)\n\t\tnew_domain = purple_utf8_try_convert(domain);\n\tif (new_msg != NULL)\n\t{\n\t\tpurple_debug(level, (new_domain != NULL ? new_domain : \"g_log\"),\n\t\t\t\t   \"%s\\n\", new_msg);\n\t\tg_free(new_msg);\n\t}\n\tg_free(new_domain);\n}\n", "bug_type": null, "idx": 761}
{"project": "Pidgin", "target": 0, "func": "static void\nnotify_added(PurpleAccount *account, const char *remote_user,\n\t\t\tconst char *id, const char *alias,\n\t\t\tconst char *msg)\n{\n\tchar *buffer;\n\tPurpleConnection *gc;\n\tgc = purple_account_get_connection(account);\n\tbuffer = make_info(account, gc, remote_user, id, alias, msg);\n\tpurple_notify_info(NULL, NULL, buffer, NULL);\n\tg_free(buffer);\n}\n", "bug_type": null, "idx": 762}
{"project": "Pidgin", "target": 0, "func": "static void\nremoveall_cb(GtkWidget *button, PidginPrivacyDialog *dialog)\n{\n\tGSList *l;\n\tif (dialog->in_allow_list)\n\t\tl = dialog->account->permit;\n\telse\n\t\tl = dialog->account->deny;\n\twhile (l) {\n\t\tchar *user;\n\t\tuser = l->data;\n\t\tl = l->next;\n\t\tif (dialog->in_allow_list)\n\t\t\tpurple_privacy_permit_remove(dialog->account, user, FALSE);\n\t\telse\n\t\t\tpurple_privacy_deny_remove(dialog->account, user, FALSE);\n\t}\n}\n", "bug_type": null, "idx": 763}
{"project": "Pidgin", "target": 0, "func": "void finch_syslog_show()\n{\n\tGList *accounts = NULL;\n\tGList *logs = NULL;\n\tif (syslog_viewer != NULL) {\n\t\tgnt_window_present(syslog_viewer->window);\n\t\treturn;\n\t}\n\tfor(accounts = purple_accounts_get_all(); accounts != NULL; accounts = accounts->next) {\n\t\tPurpleAccount *account = (PurpleAccount *)accounts->data;\n\t\tif(purple_find_prpl(purple_account_get_protocol_id(account)) == NULL)\n\t\t\tcontinue;\n\t\tlogs = g_list_concat(purple_log_get_system_logs(account), logs);\n\t}\n\tlogs = g_list_sort(logs, purple_log_compare);\n\tsyslog_viewer = display_log_viewer(NULL, logs, _(\"System Log\"), 0);\n}\n", "bug_type": null, "idx": 764}
{"project": "Pidgin", "target": 0, "func": "void finch_accounts_show_all()\n{\n\tGList *iter;\n\tGntWidget *box, *button;\n\tif (accounts.window) {\n\t\tgnt_window_present(accounts.window);\n\t\treturn;\n\t}\n\taccounts.window = gnt_vbox_new(FALSE);\n\tgnt_box_set_toplevel(GNT_BOX(accounts.window), TRUE);\n\tgnt_box_set_title(GNT_BOX(accounts.window), _(\"Accounts\"));\n\tgnt_box_set_pad(GNT_BOX(accounts.window), 0);\n\tgnt_box_set_alignment(GNT_BOX(accounts.window), GNT_ALIGN_MID);\n\tgnt_widget_set_name(accounts.window, \"accounts\");\n\tgnt_box_add_widget(GNT_BOX(accounts.window),\n\t\t\tgnt_label_new(_(\"You can enable/disable accounts from the following list.\")));\n\tgnt_box_add_widget(GNT_BOX(accounts.window), gnt_line_new(FALSE));\n\taccounts.tree = gnt_tree_new_with_columns(2);\n\tGNT_WIDGET_SET_FLAGS(accounts.tree, GNT_WIDGET_NO_BORDER);\n\tfor (iter = purple_accounts_get_all(); iter; iter = iter->next)\n\t{\n\t\tPurpleAccount *account = iter->data;\n\t\taccount_add(account);\n\t}\n\tg_signal_connect(G_OBJECT(accounts.tree), \"toggled\", G_CALLBACK(account_toggled), NULL);\n\tg_signal_connect(G_OBJECT(accounts.tree), \"key_pressed\", G_CALLBACK(account_list_key_pressed_cb), NULL);\n\tgnt_tree_set_col_width(GNT_TREE(accounts.tree), 0, 40);\n\tgnt_tree_set_col_width(GNT_TREE(accounts.tree), 1, 10);\n\tgnt_box_add_widget(GNT_BOX(accounts.window), accounts.tree);\n\tgnt_box_add_widget(GNT_BOX(accounts.window), gnt_line_new(FALSE));\n\tbox = gnt_hbox_new(FALSE);\n\tbutton = gnt_button_new(_(\"Add\"));\n\tgnt_box_add_widget(GNT_BOX(box), button);\n\tgnt_util_set_trigger_widget(GNT_WIDGET(accounts.tree), GNT_KEY_INS, button);\n\tg_signal_connect(G_OBJECT(button), \"activate\", G_CALLBACK(add_account_cb), NULL);\n\tbutton = gnt_button_new(_(\"Modify\"));\n\tgnt_box_add_widget(GNT_BOX(box), button);\n\tg_signal_connect(G_OBJECT(button), \"activate\", G_CALLBACK(modify_account_cb), accounts.tree);\n\tbutton = gnt_button_new(_(\"Delete\"));\n\tgnt_box_add_widget(GNT_BOX(box), button);\n\tgnt_util_set_trigger_widget(GNT_WIDGET(accounts.tree), GNT_KEY_DEL, button);\n\tg_signal_connect(G_OBJECT(button), \"activate\", G_CALLBACK(delete_account_cb), accounts.tree);\n\tgnt_box_add_widget(GNT_BOX(accounts.window), box);\n\tg_signal_connect(G_OBJECT(accounts.window), \"destroy\", G_CALLBACK(reset_accounts_win), NULL);\n\tgnt_widget_show(accounts.window);\n}\n", "bug_type": null, "idx": 765}
{"project": "Pidgin", "target": 0, "func": "static guint32\noscar_get_extended_status(PurpleConnection *gc)\n{\n\tPurpleAccount *account;\n\tPurpleStatus *status;\n\tconst gchar *status_id;\n\tguint32 data = 0x00000000;\n\taccount = purple_connection_get_account(gc);\n\tstatus = purple_account_get_active_status(account);\n\tstatus_id = purple_status_get_id(status);\n\tdata |= AIM_ICQ_STATE_HIDEIP;\n\tif (purple_account_get_bool(account, \"web_aware\", OSCAR_DEFAULT_WEB_AWARE))\n\t\tdata |= AIM_ICQ_STATE_WEBAWARE;\n\tif (!strcmp(status_id, OSCAR_STATUS_ID_AVAILABLE))\n\t\tdata |= AIM_ICQ_STATE_NORMAL;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_AWAY))\n\t\tdata |= AIM_ICQ_STATE_AWAY;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_DND))\n\t\tdata |= AIM_ICQ_STATE_AWAY | AIM_ICQ_STATE_DND | AIM_ICQ_STATE_BUSY;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_NA))\n\t\tdata |= AIM_ICQ_STATE_OUT | AIM_ICQ_STATE_AWAY;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_OCCUPIED))\n\t\tdata |= AIM_ICQ_STATE_AWAY | AIM_ICQ_STATE_BUSY;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_FREE4CHAT))\n\t\tdata |= AIM_ICQ_STATE_CHAT;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_INVISIBLE))\n\t\tdata |= AIM_ICQ_STATE_INVISIBLE;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_EVIL))\n\t\tdata |= AIM_ICQ_STATE_EVIL;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_DEPRESSION))\n\t\tdata |= AIM_ICQ_STATE_DEPRESSION;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_ATWORK))\n\t\tdata |= AIM_ICQ_STATE_ATWORK;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_ATHOME))\n\t\tdata |= AIM_ICQ_STATE_ATHOME;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_LUNCH))\n\t\tdata |= AIM_ICQ_STATE_LUNCH;\n\telse if (!strcmp(status_id, OSCAR_STATUS_ID_CUSTOM))\n\t\tdata |= AIM_ICQ_STATE_OUT | AIM_ICQ_STATE_AWAY;\n\treturn data;\n}\n", "bug_type": null, "idx": 766}
{"project": "Pidgin", "target": 0, "func": "void\npurple_accounts_reorder(PurpleAccount *account, gint new_index)\n{\n\tgint index;\n\tGList *l;\n\tg_return_if_fail(account != NULL);\n\tg_return_if_fail(new_index >= 0);\n\tg_return_if_fail((guint)new_index <= g_list_length(accounts));\n\tindex = g_list_index(accounts, account);\n\tif (index == -1) {\n\t\tpurple_debug_error(\"account\",\n\t\t\t\t   \"Unregistered account (%s) discovered during reorder!\\n\",\n\t\t\t\t   purple_account_get_username(account));\n\t\treturn;\n\t}\n\tl = g_list_nth(accounts, index);\n\tif (new_index > index)\n\t\tnew_index--;\n\t\n\taccounts = g_list_delete_link(accounts, l);\n\t\n\taccounts = g_list_insert(accounts, account, new_index);\n\tschedule_accounts_save();\n}\n", "bug_type": null, "idx": 767}
{"project": "Pidgin", "target": 0, "func": "static inline guint32 H(guint32 x, guint32 y, guint32 z)\n{\n\treturn x ^ y ^ z;\n}\n", "bug_type": null, "idx": 768}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nis_native(const char *filename)\n{\n\tconst char *last_period;\n\tlast_period = strrchr(filename, '.');\n\tif (last_period == NULL)\n\t\treturn FALSE;\n\treturn !(strcmp(last_period, \".dll\") &\n\t\t\t strcmp(last_period, \".sl\") &\n\t\t\t strcmp(last_period, \".so\"));\n}\n", "bug_type": null, "idx": 769}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nis_tagged(GntFileSel *sel, const char *f)\n{\n\tchar *ret = g_strdup_printf(\"%s%s%s\", sel->current, sel->current[1] ? G_DIR_SEPARATOR_S : \"\", f);\n\tgboolean find = g_list_find_custom(sel->tags, ret, (GCompareFunc)g_utf8_collate) != NULL;\n\tg_free(ret);\n\treturn find;\n}\n", "bug_type": null, "idx": 770}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ng_utf8_caselessnmatch (const char *s1, const char *s2,\n\t\t       gssize n1, gssize n2)\n{\n\tgchar *casefold;\n\tgchar *normalized_s1;\n\tgchar *normalized_s2;\n\tgint len_s1;\n\tgint len_s2;\n\tgboolean ret = FALSE;\n\tg_return_val_if_fail (s1 != NULL, FALSE);\n\tg_return_val_if_fail (s2 != NULL, FALSE);\n\tg_return_val_if_fail (n1 > 0, FALSE);\n\tg_return_val_if_fail (n2 > 0, FALSE);\n\tcasefold = g_utf8_casefold (s1, n1);\n\tnormalized_s1 = g_utf8_normalize (casefold, -1, G_NORMALIZE_NFD);\n\tg_free (casefold);\n\tcasefold = g_utf8_casefold (s2, n2);\n\tnormalized_s2 = g_utf8_normalize (casefold, -1, G_NORMALIZE_NFD);\n\tg_free (casefold);\n\tlen_s1 = strlen (normalized_s1);\n\tlen_s2 = strlen (normalized_s2);\n\tif (len_s1 < len_s2)\n\t\tgoto finally_2;\n\tret = (strncmp (normalized_s1, normalized_s2, len_s2) == 0);\nfinally_2:\n\tg_free (normalized_s1);\n\tg_free (normalized_s2);\n\treturn ret;\n}\n", "bug_type": null, "idx": 771}
{"project": "Pidgin", "target": 0, "func": "static void\nmd5_uninit(PurpleCipherContext *context) {\n\tstruct MD5Context *md5_context;\n\tpurple_cipher_context_reset(context, NULL);\n\tmd5_context = purple_cipher_context_get_data(context);\n\tmemset(md5_context, 0, sizeof(*md5_context));\n\tg_free(md5_context);\n\tmd5_context = NULL;\n}\n", "bug_type": null, "idx": 772}
{"project": "Pidgin", "target": 0, "func": "gboolean gnt_wm_process_click(GntWM *wm, GntMouseEvent event, int x, int y, GntWidget *widget)\n{\n\tgboolean ret = TRUE;\n\tidle_update = TRUE;\n\tg_signal_emit(wm, signals[SIG_MOUSE_CLICK], 0, event, x, y, widget, &ret);\n\treturn ret;\n}\n", "bug_type": null, "idx": 773}
{"project": "Pidgin", "target": 0, "func": "static PurpleCmdRet zephyr_purple_cmd_zi(PurpleConversation *conv,\n\t\t\t\t     const char *cmd, char **args, char **error, void *data)\n{\n\t\n\tzephyr_account *zephyr = purple_conversation_get_gc(conv)->proto_data;\n\tif ( zephyr_send_message(zephyr,\"message\",args[0],\"\",args[1],zephyr_get_signature(),\"\"))\n\t\treturn PURPLE_CMD_RET_OK;\n\telse\n\t\treturn PURPLE_CMD_RET_FAILED;\n}\n", "bug_type": null, "idx": 774}
{"project": "Pidgin", "target": 0, "func": "static void nullprpl_set_idle(PurpleConnection *gc, int idletime) {\n  purple_debug_info(\"nullprpl\",\n                    \"purple reports that %s has been idle for %d seconds\\n\",\n                    gc->account->username, idletime);\n}\n", "bug_type": null, "idx": 775}
{"project": "Pidgin", "target": 0, "func": "static inline size_t\nsint64_pack(int64_t value, uint8_t *out)\n{\n\treturn uint64_pack(zigzag64(value), out);\n}\n", "bug_type": null, "idx": 776}
{"project": "Pidgin", "target": 0, "func": "void\npurple_connections_uninit(void)\n{\n\tpurple_signals_unregister_by_instance(purple_connections_get_handle());\n}\n", "bug_type": null, "idx": 777}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nstart_handshake_cb(gpointer data)\n{\n\tPurpleSslConnection *gsc = data;\n\tPurpleSslNssData *nss_data = PURPLE_SSL_NSS_DATA(gsc);\n\tnss_data->handshake_timer = 0;\n\tssl_nss_handshake_cb(gsc, gsc->fd, PURPLE_INPUT_READ);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 778}
{"project": "Pidgin", "target": 0, "func": "static void\ndo_check(void)\n{\n\tint last_check = purple_prefs_get_int(\"/plugins/gtk/relnot/last_check\");\n\tif(!last_check || time(NULL) - last_check > MIN_CHECK_INTERVAL) {\n\t\tgchar *url, *request;\n\t\tconst char *host = \"pidgin.im\";\n\t\turl = g_strdup_printf(\"https://%s/version.php?version=%s&build=%s\",\n\t\t\t\thost,\n\t\t\t\tpurple_core_get_version(),\n#ifdef _WIN32\n\t\t\t\t\"purple-win32\"\n#else\n\t\t\t\t\"purple\"\n#endif\n\t\t);\n\t\trequest = g_strdup_printf(\n\t\t\t\t\"GET %s HTTP/1.0\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\"\n\t\t\t\t\"Accept: */*\\r\\n\"\n\t\t\t\t\"Host: %s\\r\\n\\r\\n\",\n\t\t\t\turl,\n\t\t\t\thost);\n\t\tpurple_util_fetch_url_request_len(url, TRUE, NULL, FALSE,\n\t\t\trequest, TRUE, -1, version_fetch_cb, NULL);\n\t\tg_free(request);\n\t\tg_free(url);\n\t\tpurple_prefs_set_int(\"/plugins/gtk/relnot/last_check\", time(NULL));\n\t}\n}\n", "bug_type": null, "idx": 779}
{"project": "Pidgin", "target": 0, "func": "int service_modfirst(OscarData *od, aim_module_t *mod)\n{\n\tmod->family = SNAC_FAMILY_OSERVICE;\n\tmod->version = 0x0003;\n\tmod->toolid = 0x0110;\n\tmod->toolversion = 0x0629;\n\tmod->flags = 0;\n\tstrncpy(mod->name, \"oservice\", sizeof(mod->name));\n\tmod->snachandler = snachandler;\n\treturn 0;\n}\n", "bug_type": null, "idx": 780}
{"project": "Pidgin", "target": 0, "func": "static void _purple_conversations_hconv_free_key(struct _purple_hconv *hc)\n{\n\tg_free(hc->name);\n\tg_free(hc);\n}\n", "bug_type": null, "idx": 781}
{"project": "Pidgin", "target": 0, "func": "aim_rxcallback_t\naim_callhandler(OscarData *od, guint16 family, guint16 subtype)\n{\n\tSnacHandler *snac_handler;\n\tsnac_handler = g_hash_table_lookup(od->handlerlist, GUINT_TO_POINTER((family << 16) + subtype));\n\treturn snac_handler ? snac_handler->handler : NULL;\n}\n", "bug_type": null, "idx": 782}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\nlogging_page(void)\n{\n\tGtkWidget *ret;\n\tGtkWidget *vbox;\n\tGList *names;\n\tret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);\n\tgtk_container_set_border_width (GTK_CONTAINER (ret), PIDGIN_HIG_BORDER);\n\tvbox = pidgin_make_frame (ret, _(\"Logging\"));\n\tnames = purple_log_logger_get_options();\n\tpidgin_prefs_dropdown_from_list(vbox, _(\"Log _format:\"), PURPLE_PREF_STRING,\n\t\t\t\t \"/purple/logging/format\", names);\n\tg_list_free(names);\n\tpidgin_prefs_checkbox(_(\"Log all _instant messages\"),\n\t\t\t\t  \"/purple/logging/log_ims\", vbox);\n\tpidgin_prefs_checkbox(_(\"Log all c_hats\"),\n\t\t\t\t  \"/purple/logging/log_chats\", vbox);\n\tpidgin_prefs_checkbox(_(\"Log all _status changes to system log\"),\n\t\t\t\t  \"/purple/logging/log_system\", vbox);\n\tgtk_widget_show_all(ret);\n\treturn ret;\n}\n", "bug_type": null, "idx": 783}
{"project": "Pidgin", "target": 0, "func": "\nint wpurple_ioctl(int fd, int command, void* val) {\n\tswitch( command ) {\n\tcase FIONBIO:\n\t{\n\t\tif (ioctlsocket(fd, FIONBIO, (unsigned long *)val) == SOCKET_ERROR) {\n\t\t\terrno = WSAGetLastError();\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase SIOCGIFCONF:\n\t{\n\t\tINTERFACE_INFO InterfaceList[20];\n\t\tunsigned long nBytesReturned;\n\t\tif (WSAIoctl(fd, SIO_GET_INTERFACE_LIST,\n\t\t\t\t0, 0, &InterfaceList,\n\t\t\t\tsizeof(InterfaceList), &nBytesReturned,\n\t\t\t\t0, 0) == SOCKET_ERROR) {\n\t\t\terrno = WSAGetLastError();\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tint i;\n\t\t\tstruct ifconf *ifc = val;\n\t\t\tchar *tmp = ifc->ifc_buf;\n\t\t\tint nNumInterfaces =\n\t\t\t\tnBytesReturned / sizeof(INTERFACE_INFO);\n\t\t\tfor (i = 0; i < nNumInterfaces; i++) {\n\t\t\t\tINTERFACE_INFO ii = InterfaceList[i];\n\t\t\t\tstruct ifreq *ifr = (struct ifreq *) tmp;\n\t\t\t\tstruct sockaddr_in *sa = (struct sockaddr_in *) &ifr->ifr_addr;\n\t\t\t\tsa->sin_family = ii.iiAddress.AddressIn.sin_family;\n\t\t\t\tsa->sin_port = ii.iiAddress.AddressIn.sin_port;\n\t\t\t\tsa->sin_addr.s_addr = ii.iiAddress.AddressIn.sin_addr.s_addr;\n\t\t\t\ttmp += sizeof(struct ifreq);\n\t\t\t\t\n\t\t\t\tif (tmp >= (ifc->ifc_buf + ifc->ifc_len + sizeof(struct ifreq))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tifc->ifc_len = ifc->ifc_len - (ifc->ifc_buf - tmp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n}\n\nint wpurple_ioctl(int fd, int command, void* val) {\n\tswitch( command ) {\n\tcase FIONBIO:\n\t{\n\t\tif (ioctlsocket(fd, FIONBIO, (unsigned long *)val) == SOCKET_ERROR) {\n\t\t\terrno = WSAGetLastError();\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase SIOCGIFCONF:\n\t{\n\t\tINTERFACE_INFO InterfaceList[20];\n\t\tunsigned long nBytesReturned;\n\t\tif (WSAIoctl(fd, SIO_GET_INTERFACE_LIST,\n\t\t\t\t0, 0, &InterfaceList,\n\t\t\t\tsizeof(InterfaceList), &nBytesReturned,\n\t\t\t\t0, 0) == SOCKET_ERROR) {\n\t\t\terrno = WSAGetLastError();\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tint i;\n\t\t\tstruct ifconf *ifc = val;\n\t\t\tchar *tmp = ifc->ifc_buf;\n\t\t\tint nNumInterfaces =\n\t\t\t\tnBytesReturned / sizeof(INTERFACE_INFO);\n\t\t\tfor (i = 0; i < nNumInterfaces; i++) {\n\t\t\t\tINTERFACE_INFO ii = InterfaceList[i];\n\t\t\t\tstruct ifreq *ifr = (struct ifreq *) tmp;\n\t\t\t\tstruct sockaddr_in *sa = (struct sockaddr_in *) &ifr->ifr_addr;\n\t\t\t\tsa->sin_family = ii.iiAddress.AddressIn.sin_family;\n\t\t\t\tsa->sin_port = ii.iiAddress.AddressIn.sin_port;\n\t\t\t\tsa->sin_addr.s_addr = ii.iiAddress.AddressIn.sin_addr.s_addr;\n\t\t\t\ttmp += sizeof(struct ifreq);\n\t\t\t\t\n\t\t\t\tif (tmp >= (ifc->ifc_buf + ifc->ifc_len + sizeof(struct ifreq))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tifc->ifc_len = ifc->ifc_len - (ifc->ifc_buf - tmp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n}\n", "bug_type": null, "idx": 784}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_chat_getinfo_res(SilcClient client,\n\t\t\t  SilcClientConnection conn,\n\t\t\t  SilcChannelEntry *channels,\n\t\t\t  SilcUInt32 channels_count,\n\t\t\t  void *context)\n{\n\tGHashTable *components = context;\n\tPurpleConnection *gc = client->application;\n\tconst char *chname;\n\tchar tmp[256];\n\tchname = g_hash_table_lookup(components, \"channel\");\n\tif (!chname)\n\t\treturn;\n\tif (!channels) {\n\t\tg_snprintf(tmp, sizeof(tmp),\n\t\t\t   _(\"Channel %s does not exist in the network\"), chname);\n\t\tpurple_notify_error(gc, _(\"Channel Information\"),\n\t\t\t\t  _(\"Cannot get channel information\"), tmp);\n\t\treturn;\n\t}\n\tsilcpurple_chat_getinfo(gc, components);\n}\n", "bug_type": null, "idx": 785}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n#ifdef HAVE_X11\n\tif (!XOpenDisplay(NULL)) {\n\t\tpurple_debug_warning(\"gntclipboard\", \"Couldn't find X display\\n\");\n\t\tpurple_notify_error(NULL, _(\"Error\"), _(\"Error loading the plugin.\"),\n\t\t\t\t_(\"Couldn't find X display\"));\n\t\treturn FALSE;\n\t}\n\tif (!getenv(\"WINDOWID\")) {\n\t\tpurple_debug_warning(\"gntclipboard\", \"Couldn't find window\\n\");\n\t\tpurple_notify_error(NULL, _(\"Error\"), _(\"Error loading the plugin.\"),\n\t\t\t\t_(\"Couldn't find window\"));\n\t\treturn FALSE;\n\t}\n\tsig_handle = g_signal_connect(G_OBJECT(gnt_get_clipboard()), \"clipboard_changed\", G_CALLBACK(clipboard_changed), NULL);\n\treturn TRUE;\n#else\n\tpurple_notify_error(NULL, _(\"Error\"), _(\"Error loading the plugin.\"),\n\t\t\t_(\"This plugin cannot be loaded because it was not built with X11 support.\"));\n\treturn FALSE;\n#endif\n}\n", "bug_type": null, "idx": 786}
{"project": "Pidgin", "target": 0, "func": "static void\npopup_dropdown(GntComboBox *box)\n{\n\tGntWidget *widget = GNT_WIDGET(box);\n\tGntWidget *parent = box->dropdown->parent;\n\tint height = g_list_length(GNT_TREE(box->dropdown)->list);\n\tint y = widget->priv.y + widget->priv.height - 1;\n\tgnt_widget_set_size(box->dropdown, widget->priv.width, height + 2);\n\tif (y + height + 2 >= getmaxy(stdscr))\n\t\ty = widget->priv.y - height - 1;\n\tgnt_widget_set_position(parent, widget->priv.x, y);\n\tif (parent->window)\n\t{\n\t\tmvwin(parent->window, y, widget->priv.x);\n\t\twresize(parent->window, height+2, widget->priv.width);\n\t}\n\tparent->priv.width = widget->priv.width;\n\tparent->priv.height = height + 2;\n\tGNT_WIDGET_UNSET_FLAGS(parent, GNT_WIDGET_INVISIBLE);\n\tgnt_widget_draw(parent);\n}\n", "bug_type": null, "idx": 787}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_certificate_register_verifier(PurpleCertificateVerifier *vr)\n{\n\tg_return_val_if_fail(vr != NULL, FALSE);\n\t\n\tif (purple_certificate_find_verifier(vr->scheme_name, vr->name) != NULL) {\n\t\treturn FALSE;\n\t}\n\t\n\tcert_verifiers = g_list_prepend(cert_verifiers, vr);\n\t\n\tpurple_debug_info(\"certificate\",\n\t\t\t  \"CertificateVerifier %s registered\\n\",\n\t\t\t  vr->name);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 788}
{"project": "Pidgin", "target": 0, "func": "static int\nnovell_chat_send(PurpleConnection * gc, int id, const char *text, PurpleMessageFlags flags)\n{\n\tNMConference *conference;\n\tPurpleConversation *chat;\n\tGSList *cnode;\n\tNMMessage *message;\n\tNMUser *user;\n\tNMERR_T rc = NM_OK;\n\tconst char *name;\n\tchar *str, *plain;\n\tif (gc == NULL || text == NULL)\n\t\treturn -1;\n\tuser = gc->proto_data;\n\tif (user == NULL)\n\t\treturn -1;\n\tplain = purple_unescape_html(text);\n\tmessage = nm_create_message(plain);\n\tg_free(plain);\n\tfor (cnode = user->conferences; cnode != NULL; cnode = cnode->next) {\n\t\tconference = cnode->data;\n\t\tif (conference && (chat = nm_conference_get_data(conference))) {\n\t\t\tif (purple_conv_chat_get_id(PURPLE_CONV_CHAT(chat)) == id) {\n\t\t\t\tnm_message_set_conference(message, conference);\n\t\t\t\t\n\t\t\t\tif (!nm_conference_is_instantiated(conference)) {\n\t\t\t\t\tnm_message_add_ref(message);\n\t\t\t\t\tnm_send_create_conference(user, conference, _createconf_resp_send_msg, message);\n\t\t\t\t} else {\n\t\t\t\t\trc = nm_send_message(user, message, _send_message_resp_cb);\n\t\t\t\t}\n\t\t\t\tnm_release_message(message);\n\t\t\t\tif (!_check_for_disconnect(user, rc)) {\n\t\t\t\t\t\n\t\t\t\t\tname = purple_account_get_alias(user->client_data);\n\t\t\t\t\tif (name == NULL || *name == '\\0') {\n\t\t\t\t\t\t\n\t\t\t\t\t\tname = nm_user_record_get_full_name(user->user_record);\n\t\t\t\t\t\tif (name == NULL || *name == '\\0') {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tname = purple_account_get_username(user->client_data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tserv_got_chat_in(gc, id, name, flags, text, time(NULL));\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchat = purple_find_chat(gc, id);\n\tif (chat) {\n\t\tstr = g_strdup(_(\"This conference has been closed.\"\n\t\t\t\t\t\t \" No more messages can be sent.\"));\n\t\tpurple_conversation_write(chat, NULL, str, PURPLE_MESSAGE_SYSTEM, time(NULL));\n\t\tg_free(str);\n\t}\n\tif (message)\n\t\tnm_release_message(message);\n\treturn -1;\n}\n", "bug_type": null, "idx": 789}
{"project": "Pidgin", "target": 0, "func": "static void\nparse_smiley(xmlnode *smiley_node)\n{\n\tconst char *shortcut = NULL;\n\tconst char *checksum = NULL;\n\tconst char *filename = NULL;\n\tshortcut = xmlnode_get_attrib(smiley_node, XML_SHORTCUT_ATTRIB_TAG);\n\tchecksum = xmlnode_get_attrib(smiley_node, XML_CHECKSUM_ATRIB_TAG);\n\tfilename = xmlnode_get_attrib(smiley_node, XML_FILENAME_ATRIB_TAG);\n\tif ((shortcut == NULL) || (checksum == NULL) || (filename == NULL))\n\t\treturn;\n\tpurple_smiley_load_file(shortcut, checksum, filename);\n}\n", "bug_type": null, "idx": 790}
{"project": "Pidgin", "target": 0, "func": "PurpleConvChatBuddy *\npurple_conv_chat_cb_new(const char *name, const char *alias, PurpleConvChatBuddyFlags flags)\n{\n\tPurpleConvChatBuddy *cb;\n\tg_return_val_if_fail(name != NULL, NULL);\n\tcb = g_new0(PurpleConvChatBuddy, 1);\n\tcb->name = g_strdup(name);\n\tcb->flags = flags;\n\tcb->alias = g_strdup(alias);\n\tcb->attributes = g_hash_table_new_full(g_str_hash, g_str_equal,\n\t\t\t\t\t\t\t\t\t\t   g_free, g_free);\n\tPURPLE_DBUS_REGISTER_POINTER(cb, PurpleConvChatBuddy);\n\treturn cb;\n}\n", "bug_type": null, "idx": 791}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_account_get_buddy_icon_path(const PurpleAccount *account)\n{\n\tg_return_val_if_fail(account != NULL, NULL);\n\treturn account->buddy_icon_path;\n}\n", "bug_type": null, "idx": 792}
{"project": "Pidgin", "target": 0, "func": "static unsigned int simple_typing(PurpleConnection *gc, const char *name, PurpleTypingState state) {\n\tstruct simple_account_data *sip = gc->proto_data;\n\tgchar *xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n\t\t\t\"<isComposing xmlns=\\\"urn:ietf:params:xml:ns:im-iscomposing\\\"\\n\"\n\t\t\t\"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n\t\t\t\"xsi:schemaLocation=\\\"urn:ietf:params:xml:ns:im-composing iscomposing.xsd\\\">\\n\"\n\t\t\t\"<state>%s</state>\\n\"\n\t\t\t\"<contenttype>text/plain</contenttype>\\n\"\n\t\t\t\"<refresh>60</refresh>\\n\"\n\t\t\t\"</isComposing>\";\n\tgchar *recv = g_strdup(name);\n\tif(state == PURPLE_TYPING) {\n\t\tgchar *msg = g_strdup_printf(xml, \"active\");\n\t\tsimple_send_message(sip, recv, msg, \"application/im-iscomposing+xml\");\n\t\tg_free(msg);\n\t} else  {\n\t\tgchar *msg = g_strdup_printf(xml, \"idle\");\n\t\tsimple_send_message(sip, recv, msg, \"application/im-iscomposing+xml\");\n\t\tg_free(msg);\n\t}\n\tg_free(recv);\n\t\n\treturn 1;\n}\n", "bug_type": null, "idx": 793}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin) {\n\tpurple_prefs_add_none(\"/plugins/gtk/musicmessaging\");\n\tpurple_prefs_add_string(\"/plugins/gtk/musicmessaging/editor_path\", \"/usr/bin/gscore\");\n}\n", "bug_type": null, "idx": 794}
{"project": "Pidgin", "target": 0, "func": "void\nxmlnode_set_attrib_with_namespace(xmlnode *node, const char *attr, const char *xmlns, const char *value)\n{\n\txmlnode_set_attrib_full(node, attr, xmlns, NULL, value);\n}\n", "bug_type": null, "idx": 795}
{"project": "Pidgin", "target": 0, "func": "static void\nport_popup_cb(GtkWidget *w, GtkMenu *menu, gpointer data)\n{\n\tGtkWidget *item1;\n\tGtkWidget *item2;\n\t\n\titem1 = gtk_menu_item_new_with_label(_(\"If you look real closely\"));\n\t\n\titem2 = gtk_menu_item_new_with_label(_(\"you can see the butterflies mating\"));\n\tgtk_widget_show(item1);\n\tgtk_widget_show(item2);\n\t\n\tgtk_menu_shell_prepend(GTK_MENU_SHELL(menu), item2);\n\tgtk_menu_shell_prepend(GTK_MENU_SHELL(menu), item1);\n}\n", "bug_type": null, "idx": 796}
{"project": "Pidgin", "target": 0, "func": "static inline int\nint_range_lookup(unsigned n_ranges, const ProtobufCIntRange *ranges, int value)\n{\n\tunsigned n;\n\tunsigned start;\n\tif (n_ranges == 0)\n\t\treturn -1;\n\tstart = 0;\n\tn = n_ranges;\n\twhile (n > 1) {\n\t\tunsigned mid = start + n / 2;\n\t\tif (value < ranges[mid].start_value) {\n\t\t\tn = mid - start;\n\t\t} else if (value >= ranges[mid].start_value +\n\t\t\t   (int) (ranges[mid + 1].orig_index -\n\t\t\t\t  ranges[mid].orig_index))\n\t\t{\n\t\t\tunsigned new_start = mid + 1;\n\t\t\tn = start + n - new_start;\n\t\t\tstart = new_start;\n\t\t} else\n\t\t\treturn (value - ranges[mid].start_value) +\n\t\t\t    ranges[mid].orig_index;\n\t}\n\tif (n > 0) {\n\t\tunsigned start_orig_index = ranges[start].orig_index;\n\t\tunsigned range_size =\n\t\t\tranges[start + 1].orig_index - start_orig_index;\n\t\tif (ranges[start].start_value <= value &&\n\t\t    value < (int) (ranges[start].start_value + range_size))\n\t\t{\n\t\t\treturn (value - ranges[start].start_value) +\n\t\t\t    start_orig_index;\n\t\t}\n\t}\n\treturn -1;\n}\n", "bug_type": null, "idx": 797}
{"project": "Pidgin", "target": 0, "func": "static void\nupdate_editable(PurpleConnection *gc, AccountPrefsDialog *dialog)\n{\n\tGtkStyle *style;\n\tgboolean set;\n\tGList *l;\n\tif (dialog->account == NULL)\n\t\treturn;\n\tif (gc != NULL && dialog->account != purple_connection_get_account(gc))\n\t\treturn;\n\tset = !(purple_account_is_connected(dialog->account) || purple_account_is_connecting(dialog->account));\n\tgtk_widget_set_sensitive(dialog->protocol_menu, set);\n\tgtk_editable_set_editable(GTK_EDITABLE(dialog->username_entry), set);\n\tstyle = set ? NULL : gtk_widget_get_style(dialog->username_entry);\n\tgtk_widget_modify_base(dialog->username_entry, GTK_STATE_NORMAL,\n\t\t\tstyle ? &style->base[GTK_STATE_INSENSITIVE] : NULL);\n\tfor (l = dialog->user_split_entries ; l != NULL ; l = l->next) {\n\t\tif (GTK_IS_EDITABLE(l->data)) {\n\t\t\tgtk_editable_set_editable(GTK_EDITABLE(l->data), set);\n\t\t\tstyle = set ? NULL : gtk_widget_get_style(GTK_WIDGET(l->data));\n\t\t\tgtk_widget_modify_base(GTK_WIDGET(l->data), GTK_STATE_NORMAL,\n\t\t\t\t\tstyle ? &style->base[GTK_STATE_INSENSITIVE] : NULL);\n\t\t} else {\n\t\t\tgtk_widget_set_sensitive(GTK_WIDGET(l->data), set);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 798}
{"project": "Pidgin", "target": 0, "func": "static gboolean _runtime_active = FALSE;\ngboolean ml_init()\n{\n\tMonoDomain *d;\n\tg_return_val_if_fail(_runtime_active == FALSE, TRUE);\n\td = mono_jit_init(\"purple\");\n\tif (!d) {\n\t\tml_set_domain(NULL);\n\t\treturn FALSE;\n\t}\n\tml_set_domain(d);\n\tml_init_internal_calls();\n\t_runtime_active = TRUE;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 799}
{"project": "Pidgin", "target": 0, "func": "void irc_buddy_query(struct irc_conn *irc)\n{\n\tGList *lp;\n\tGString *string;\n\tstruct irc_buddy *ib;\n\tchar *buf;\n\tstring = g_string_sized_new(512);\n\twhile ((lp = g_list_first(irc->buddies_outstanding))) {\n\t\tib = (struct irc_buddy *)lp->data;\n\t\tif (string->len + strlen(ib->name) + 1 > 450)\n\t\t\tbreak;\n\t\tg_string_append_printf(string, \"%s \", ib->name);\n\t\tib->new_online_status = FALSE;\n\t\tirc->buddies_outstanding = g_list_remove_link(irc->buddies_outstanding, lp);\n\t}\n\tif (string->len) {\n\t\tbuf = irc_format(irc, \"vn\", \"ISON\", string->str);\n\t\tirc_send(irc, buf);\n\t\tg_free(buf);\n\t\tirc->ison_outstanding = TRUE;\n\t} else\n\t\tirc->ison_outstanding = FALSE;\n\tg_string_free(string, TRUE);\n}\n", "bug_type": null, "idx": 800}
{"project": "Pidgin", "target": 0, "func": "void\npurple_prefs_add_int(const char *name, int value)\n{\n\tstruct purple_pref *pref;\n\tPURPLE_PREFS_UI_OP_CALL(add_int, name, value);\n\tpref = add_pref(PURPLE_PREF_INT, name);\n\tif(!pref)\n\t\treturn;\n\tpref->value.integer = value;\n}\n", "bug_type": null, "idx": 801}
{"project": "Pidgin", "target": 0, "func": "static char *nullprpl_get_chat_name(GHashTable *components) {\n  const char *room = g_hash_table_lookup(components, \"room\");\n  purple_debug_info(\"nullprpl\", \"reporting chat room name '%s'\\n\", room);\n  return g_strdup(room);\n}\n", "bug_type": null, "idx": 802}
{"project": "Pidgin", "target": 0, "func": "static void gtk_imhtmltoolbar_create_old_buttons(GtkIMHtmlToolbar *toolbar)\n{\n\tGtkWidget *hbox;\n\tGtkWidget *button;\n\tstruct {\n\t\tchar *stock;\n\t\tgpointer callback;\n\t\tGtkWidget **button;\n\t\tconst char *tooltip;\n\t} buttons[] = {\n\t\t{GTK_STOCK_BOLD, G_CALLBACK(do_bold), &toolbar->bold, _(\"Bold\")},\n\t\t{GTK_STOCK_ITALIC, do_italic, &toolbar->italic, _(\"Italic\")},\n\t\t{GTK_STOCK_UNDERLINE, do_underline, &toolbar->underline, _(\"Underline\")},\n\t\t{GTK_STOCK_STRIKETHROUGH, do_strikethrough, &toolbar->strikethrough, _(\"Strikethrough\")},\n\t\t{\"\", NULL, NULL, NULL},\n\t\t{PIDGIN_STOCK_TOOLBAR_TEXT_LARGER, do_big, &toolbar->larger_size, _(\"Increase Font Size\")},\n\t\t{PIDGIN_STOCK_TOOLBAR_TEXT_SMALLER, do_small, &toolbar->smaller_size, _(\"Decrease Font Size\")},\n\t\t{\"\", NULL, NULL, NULL},\n\t\t{PIDGIN_STOCK_TOOLBAR_FONT_FACE, toggle_font, &toolbar->font, _(\"Font Face\")},\n\t\t{PIDGIN_STOCK_TOOLBAR_FGCOLOR, toggle_fg_color, &toolbar->fgcolor, _(\"Foreground Color\")},\n\t\t{PIDGIN_STOCK_TOOLBAR_BGCOLOR, toggle_bg_color, &toolbar->bgcolor, _(\"Background Color\")},\n\t\t{\"\", NULL, NULL, NULL},\n\t\t{PIDGIN_STOCK_CLEAR, clear_formatting_cb, &toolbar->clear, _(\"Reset Formatting\")},\n\t\t{\"\", NULL, NULL, NULL},\n\t\t{PIDGIN_STOCK_TOOLBAR_INSERT_IMAGE, insert_image_cb, &toolbar->image, _(\"Insert IM Image\")},\n\t\t{PIDGIN_STOCK_TOOLBAR_INSERT_LINK, insert_link_cb, &toolbar->link, _(\"Insert Link\")},\n\t\t{\"\", NULL, NULL, NULL},\n\t\t{PIDGIN_STOCK_TOOLBAR_SMILEY, insert_smiley_cb, &toolbar->smiley, _(\"Insert Smiley\")},\n\t\t{NULL, NULL, NULL, NULL}\n\t};\n\tint iter;\n\thbox = gtk_hbox_new(FALSE, 0);\n\tfor (iter = 0; buttons[iter].stock; iter++) {\n\t\tif (buttons[iter].stock[0]) {\n\t\t\tbutton = pidgin_pixbuf_toolbar_button_from_stock(buttons[iter].stock);\n\t\t\tg_signal_connect(G_OBJECT(button), \"button-press-event\", G_CALLBACK(gtk_imhtmltoolbar_popup_menu), toolbar);\n\t\t\tg_signal_connect(G_OBJECT(button), \"clicked\",\n\t\t\t\t\t G_CALLBACK(buttons[iter].callback), toolbar);\n\t\t\t*(buttons[iter].button) = button;\n\t\t\tgtk_tooltips_set_tip(toolbar->tooltips, button, buttons[iter].tooltip, NULL);\n\t\t} else\n\t\t\tbutton = gtk_vseparator_new();\n\t\tgtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);\n\t}\n\t\n\tbutton = pidgin_pixbuf_toolbar_button_from_stock(PIDGIN_STOCK_TOOLBAR_SEND_ATTENTION);\n\tg_signal_connect(G_OBJECT(button), \"button-press-event\", G_CALLBACK(gtk_imhtmltoolbar_popup_menu), toolbar);\n\tg_signal_connect(G_OBJECT(button), \"clicked\",\n\t\tG_CALLBACK(send_attention_cb), toolbar);\n\tg_object_set_data(G_OBJECT(toolbar), \"attention\", button);\n\tgtk_tooltips_set_tip(toolbar->tooltips, button, _(\"Send Attention\"), NULL);\n\tgtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);\n\tgtk_box_pack_start(GTK_BOX(toolbar), hbox, FALSE, FALSE, 0);\n\tg_object_set_data(G_OBJECT(toolbar), \"wide-view\", hbox);\n}\n", "bug_type": null, "idx": 803}
{"project": "Pidgin", "target": 0, "func": "static void\naccount_status_changed_cb(PurpleAccount *account, PurpleStatus *oldstatus, PurpleStatus *newstatus, PidginStatusBox *status_box)\n{\n\tif (status_box->account == account)\n\t\tupdate_to_reflect_account_status(status_box, account, newstatus);\n\telse if (status_box->token_status_account == account)\n\t\tstatus_menu_refresh_iter(status_box, TRUE);\n}\n", "bug_type": null, "idx": 804}
{"project": "Pidgin", "target": 0, "func": "static void\nassoc_buddy_cb(GtkWidget *w, GevoAssociateBuddyDialog *dialog)\n{\n\tGtkTreeSelection *selection;\n\tGtkTreeIter iter;\n\tGList *list;\n\tconst char *fullname;\n\tEContactField protocol_field;\n\tEContact *contact;\n\tselection = gtk_tree_view_get_selection(GTK_TREE_VIEW(dialog->treeview));\n\tif (!gtk_tree_selection_get_selected(selection, NULL, &iter))\n\t\treturn;\n\tgtk_tree_model_get(GTK_TREE_MODEL(dialog->model), &iter,\n\t\t\t\t\t   COLUMN_NAME, &fullname,\n\t\t\t\t\t   COLUMN_DATA, &contact,\n\t\t\t\t\t   -1);\n\tprotocol_field = gevo_prpl_get_field(dialog->buddy->account, dialog->buddy);\n\tif (protocol_field == 0)\n\t\treturn; \n\tlist = e_contact_get(contact, protocol_field);\n\tlist = g_list_append(list, g_strdup(dialog->buddy->name));\n\te_contact_set(contact, protocol_field, list);\n\tif (!e_book_commit_contact(dialog->book, contact, NULL))\n\t\tpurple_debug_error(\"evolution\", \"Error adding contact to book\\n\");\n\t\n\tg_list_foreach(list, (GFunc)g_free, NULL);\n\tg_list_free(list);\n\tdelete_win_cb(NULL, NULL, dialog);\n}\n", "bug_type": null, "idx": 805}
{"project": "Pidgin", "target": 0, "func": "static void insert_status_change(CapStatistics *statistics) {\n\tinsert_status_change_from_purple_status(statistics, get_status_for(statistics->buddy));\n}\n", "bug_type": null, "idx": 806}
{"project": "Pidgin", "target": 0, "func": "};\nvoid gg_protobuf_expected(struct gg_session *gs, const char *field_name,\n\tuint32_t value, uint32_t expected)\n{\n\tif (value == expected) {\n\t\treturn;\n\t}\n\tgg_debug_session(gs, GG_DEBUG_WARNING, \"// gg_packet: field %s was \"\n\t\t\"expected to be %#x, but its value was %#x\\n\",\n\t\tfield_name, expected, value);\n}\n", "bug_type": null, "idx": 807}
{"project": "Pidgin", "target": 0, "func": "static int\nparseinfo(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tint ret = 0;\n\taim_rxcallback_t userfunc;\n\tstruct aim_emailinfo *new;\n\tGSList *tlvlist;\n\tguint8 *cookie8, *cookie16;\n\tint tmp, havenewmail = 0; \n\tchar *alertitle = NULL, *alerturl = NULL;\n\tcookie8 = byte_stream_getraw(bs, 8); \n\tcookie16 = byte_stream_getraw(bs, 16); \n\t\n\tfor (new = od->emailinfo; (new && memcmp(cookie16, new->cookie16, 16)); new = new->next);\n\tif (new) {\n\t\t\n\t\tg_free(new->cookie8);\n\t\tg_free(new->cookie16);\n\t\tg_free(new->url);\n\t\tg_free(new->domain);\n\t} else {\n\t\t\n\t\tnew = g_new0(struct aim_emailinfo, 1);\n\t\tnew->next = od->emailinfo;\n\t\tod->emailinfo = new;\n\t}\n\tnew->cookie8 = cookie8;\n\tnew->cookie16 = cookie16;\n\ttlvlist = aim_tlvlist_readnum(bs, byte_stream_get16(bs));\n\ttmp = aim_tlv_get16(tlvlist, 0x0080, 1);\n\tif (tmp) {\n\t\tif (new->nummsgs < tmp)\n\t\t\thavenewmail = 1;\n\t\tnew->nummsgs = tmp;\n\t} else {\n\t\t\n\t\t\n\t\thavenewmail = 1;\n\t\tnew->nummsgs++; \n\t}\n\tnew->url = aim_tlv_getstr(tlvlist, 0x0007, 1);\n\tif (!(new->unread = aim_tlv_get8(tlvlist, 0x0081, 1))) {\n\t\thavenewmail = 0;\n\t\tnew->nummsgs = 0;\n\t}\n\tnew->domain = aim_tlv_getstr(tlvlist, 0x0082, 1);\n\tnew->flag = aim_tlv_get16(tlvlist, 0x0084, 1);\n\talertitle = aim_tlv_getstr(tlvlist, 0x0005, 1);\n\talerturl  = aim_tlv_getstr(tlvlist, 0x000d, 1);\n\tif ((userfunc = aim_callhandler(od, snac->family, snac->subtype)))\n\t\tret = userfunc(od, conn, frame, new, havenewmail, alertitle, (alerturl ? alerturl + 2 : NULL));\n\taim_tlvlist_free(tlvlist);\n\tg_free(alertitle);\n\tg_free(alerturl);\n\treturn ret;\n}\n", "bug_type": null, "idx": 808}
{"project": "Pidgin", "target": 0, "func": "static void\nserver_info_cb(PurpleConnection *pc, const char *type, const char *id,\n               const char *from, xmlnode *iq, gpointer data)\n{\n\tstruct item_data *cb_data = data;\n\tPidginDiscoList *list = cb_data->list;\n\txmlnode *query;\n\txmlnode *error;\n\tgboolean items = FALSE;\n\t--list->fetch_count;\n\tif (g_str_equal(type, \"result\") &&\n\t\t\t(query = xmlnode_get_child(iq, \"query\"))) {\n\t\txmlnode *feature;\n\t\tfor (feature = xmlnode_get_child(query, \"feature\"); feature;\n\t\t\t\tfeature = xmlnode_get_next_twin(feature)) {\n\t\t\tconst char *var = xmlnode_get_attrib(feature, \"var\");\n\t\t\tif (purple_strequal(var, NS_DISCO_ITEMS)) {\n\t\t\t\titems = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (items) {\n\t\t\txmpp_disco_items_do(pc, cb_data, from, NULL , server_items_cb);\n\t\t\t++list->fetch_count;\n\t\t\tpidgin_disco_list_ref(list);\n\t\t}\n\t\telse {\n\t\t\tpidgin_disco_list_set_in_progress(list, FALSE);\n\t\t\tg_free(cb_data);\n\t\t}\n\t}\n\telse {\n\t\terror = xmlnode_get_child(iq, \"error\");\n\t\tif (xmlnode_get_child(error, \"remote-server-not-found\")\n\t\t || xmlnode_get_child(error, \"jid-malformed\")) {\n\t\t\tpurple_notify_error(my_plugin, _(\"Error\"),\n\t\t\t                    _(\"Server does not exist\"),\n \t\t\t                    NULL);\n\t\t}\n\t\telse {\n\t\t\tpurple_notify_error(my_plugin, _(\"Error\"),\n\t\t\t                    _(\"Server does not support service discovery\"),\n\t\t\t                    NULL);\n\t\t}\n\t\tpidgin_disco_list_set_in_progress(list, FALSE);\n\t\tg_free(cb_data);\n\t}\n\tpidgin_disco_list_unref(list);\n}\n", "bug_type": null, "idx": 809}
{"project": "Pidgin", "target": 0, "func": "static void\nset_selection(GntComboBox *box, gpointer key)\n{\n\tif (box->selected != key)\n\t{\n\t\t\n\t\tgpointer old = box->selected;\n\t\tbox->selected = key;\n\t\tif (GNT_WIDGET(box)->window)\n\t\t\tgnt_widget_draw(GNT_WIDGET(box));\n\t\tif (box->dropdown)\n\t\t\tgnt_tree_set_selected(GNT_TREE(box->dropdown), key);\n\t\tg_signal_emit(box, signals[SIG_SELECTION_CHANGED], 0, old, key);\n\t}\n}\n", "bug_type": null, "idx": 810}
{"project": "Pidgin", "target": 0, "func": "static int purple_parse_oncoming(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)\n{\n\tPurpleConnection *gc;\n\tPurpleAccount *account;\n\tPurpleBuddy *buddy = NULL;\n\tPurpleStatus *previous_status = NULL;\n\tstruct buddyinfo *bi;\n\ttime_t time_idle = 0, signon = 0;\n\tint type = 0;\n\tgboolean buddy_is_away = FALSE;\n\tconst char *status_id;\n\tva_list ap;\n\taim_userinfo_t *info;\n\tchar *message;\n\tchar *itmsurl = NULL;\n\tgc = od->gc;\n\taccount = purple_connection_get_account(gc);\n\tva_start(ap, fr);\n\tinfo = va_arg(ap, aim_userinfo_t *);\n\tva_end(ap);\n\tg_return_val_if_fail(info != NULL, 1);\n\tg_return_val_if_fail(info->bn != NULL, 1);\n\tbuddy = purple_find_buddy(account, info->bn);\n\tif (buddy) {\n\t\tprevious_status = purple_presence_get_active_status(purple_buddy_get_presence(buddy));\n\t}\n\t\n\tif (!oscar_util_valid_name_icq(info->bn)) {\n\t\tgboolean bn_has_formatting = FALSE;\n\t\tchar *c;\n\t\tfor (c = info->bn; *c != '\\0'; c++) {\n\t\t\tif (!islower(*c)) {\n\t\t\t\tbn_has_formatting = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tserv_got_alias(gc, info->bn,\n\t\t\t\tbn_has_formatting ? info->bn : NULL);\n\t}\n\tif (info->present & AIM_USERINFO_PRESENT_FLAGS) {\n\t\tif (info->flags & AIM_FLAG_AWAY)\n\t\t\tbuddy_is_away = TRUE;\n\t}\n\tif (info->present & AIM_USERINFO_PRESENT_ICQEXTSTATUS) {\n\t\ttype = info->icqinfo.status;\n\t\tif (!(info->icqinfo.status & AIM_ICQ_STATE_CHAT) &&\n\t\t      (info->icqinfo.status != AIM_ICQ_STATE_NORMAL)) {\n\t\t\tbuddy_is_away = TRUE;\n\t\t}\n\t}\n\tif (oscar_util_valid_name_icq(info->bn)) {\n\t\tif (type & AIM_ICQ_STATE_CHAT)\n\t\t\tstatus_id = OSCAR_STATUS_ID_FREE4CHAT;\n\t\telse if (type & AIM_ICQ_STATE_DND)\n\t\t\tstatus_id = OSCAR_STATUS_ID_DND;\n\t\telse if (type & AIM_ICQ_STATE_OUT)\n\t\t\tstatus_id = OSCAR_STATUS_ID_NA;\n\t\telse if (type & AIM_ICQ_STATE_BUSY)\n\t\t\tstatus_id = OSCAR_STATUS_ID_OCCUPIED;\n\t\telse if (type & AIM_ICQ_STATE_AWAY)\n\t\t\tstatus_id = OSCAR_STATUS_ID_AWAY;\n\t\telse if (type & AIM_ICQ_STATE_INVISIBLE)\n\t\t\tstatus_id = OSCAR_STATUS_ID_INVISIBLE;\n\t\telse if (type & AIM_ICQ_STATE_EVIL)\n\t\t\tstatus_id = OSCAR_STATUS_ID_EVIL;\n\t\telse if (type & AIM_ICQ_STATE_DEPRESSION)\n\t\t\tstatus_id = OSCAR_STATUS_ID_DEPRESSION;\n\t\telse if (type & AIM_ICQ_STATE_ATHOME)\n\t\t\tstatus_id = OSCAR_STATUS_ID_ATHOME;\n\t\telse if (type & AIM_ICQ_STATE_ATWORK)\n\t\t\tstatus_id = OSCAR_STATUS_ID_ATWORK;\n\t\telse if (type & AIM_ICQ_STATE_LUNCH)\n\t\t\tstatus_id = OSCAR_STATUS_ID_LUNCH;\n\t\telse\n\t\t\tstatus_id = OSCAR_STATUS_ID_AVAILABLE;\n\t} else {\n\t\tif (type & AIM_ICQ_STATE_INVISIBLE)\n\t\t\tstatus_id = OSCAR_STATUS_ID_INVISIBLE;\n\t\telse if (buddy_is_away)\n\t\t\tstatus_id = OSCAR_STATUS_ID_AWAY;\n\t\telse\n\t\t\tstatus_id = OSCAR_STATUS_ID_AVAILABLE;\n\t}\n\tif (info->flags & AIM_FLAG_WIRELESS) {\n\t\tpurple_prpl_got_user_status(account, info->bn, OSCAR_STATUS_ID_MOBILE, NULL);\n\t} else {\n\t\tpurple_prpl_got_user_status_deactive(account, info->bn, OSCAR_STATUS_ID_MOBILE);\n\t}\n\tmessage = (info->status && info->status_len > 0)\n\t\t\t? oscar_encoding_to_utf8(info->status_encoding, info->status, info->status_len)\n\t\t\t: NULL;\n\tif (purple_strequal(status_id, OSCAR_STATUS_ID_AVAILABLE)) {\n\t\t\n\t\tif (info->itmsurl != NULL) {\n\t\t\titmsurl = (info->itmsurl_len > 0) ? oscar_encoding_to_utf8(info->itmsurl_encoding, info->itmsurl, info->itmsurl_len) : NULL;\n\t\t} else if (previous_status != NULL && purple_status_is_available(previous_status)) {\n\t\t\titmsurl = g_strdup(purple_status_get_attr_string(previous_status, \"itmsurl\"));\n\t\t}\n\t\tpurple_debug_info(\"oscar\", \"Activating status '%s' for buddy %s, message = '%s', itmsurl = '%s'\\n\", status_id, info->bn, message ? message : \"(null)\", itmsurl ? itmsurl : \"(null)\");\n\t\tpurple_prpl_got_user_status(account, info->bn, status_id, \"message\", message, \"itmsurl\", itmsurl, NULL);\n\t} else {\n\t\tpurple_debug_info(\"oscar\", \"Activating status '%s' for buddy %s, message = '%s'\\n\", status_id, info->bn, message ? message : \"(null)\");\n\t\tpurple_prpl_got_user_status(account, info->bn, status_id, \"message\", message, NULL);\n\t}\n\tg_free(message);\n\tg_free(itmsurl);\n\t\n\tif (info->present & AIM_USERINFO_PRESENT_ONLINESINCE)\n\t\tsignon = info->onlinesince;\n\telse if (info->present & AIM_USERINFO_PRESENT_SESSIONLEN)\n\t\tsignon = time(NULL) - info->sessionlen;\n\tpurple_prpl_got_user_login_time(account, info->bn, signon);\n\t\n\t\n\tif (info->present & AIM_USERINFO_PRESENT_IDLE)\n\t\ttime_idle = time(NULL) - info->idletime * 60;\n\tif (time_idle > 0)\n\t\tpurple_prpl_got_user_idle(account, info->bn, TRUE, time_idle);\n\telse\n\t\tpurple_prpl_got_user_idle(account, info->bn, FALSE, 0);\n\t\n\tbi = g_hash_table_lookup(od->buddyinfo, purple_normalize(account, info->bn));\n\tif (!bi) {\n\t\tbi = g_new0(struct buddyinfo, 1);\n\t\tg_hash_table_insert(od->buddyinfo, g_strdup(purple_normalize(account, info->bn)), bi);\n\t}\n\tbi->typingnot = FALSE;\n\tbi->ico_informed = FALSE;\n\tbi->ipaddr = info->icqinfo.ipaddr;\n\tif (info->iconcsumlen) {\n\t\tconst char *saved_b16 = NULL;\n\t\tchar *b16 = NULL;\n\t\tPurpleBuddy *b = NULL;\n\t\tb16 = purple_base16_encode(info->iconcsum, info->iconcsumlen);\n\t\tb = purple_find_buddy(account, info->bn);\n\t\tif (b != NULL)\n\t\t\tsaved_b16 = purple_buddy_icons_get_checksum_for_user(b);\n\t\tif (!b16 || !saved_b16 || strcmp(b16, saved_b16)) {\n\t\t\t\n\t\t\tpurple_buddy_icons_set_for_user(account, info->bn, NULL, 0, NULL);\n\t\t\t\n\t\t\tif (g_slist_find_custom(od->requesticon, info->bn,\n\t\t\t\t\t(GCompareFunc)oscar_util_name_compare) == NULL)\n\t\t\t{\n\t\t\t\tod->requesticon = g_slist_prepend(od->requesticon,\n\t\t\t\t\t\tg_strdup(purple_normalize(account, info->bn)));\n\t\t\t\tpurple_icons_fetch(gc);\n\t\t\t}\n\t\t}\n\t\tg_free(b16);\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 811}
{"project": "Pidgin", "target": 0, "func": "static void\nblist_node_removed_cb(PurpleBlistNode *bnode, void *data)\n{\n\tconst char *name;\n\tif (PURPLE_BLIST_NODE_IS_GROUP(bnode))\n\t\tname = purple_group_get_name(PURPLE_GROUP(bnode));\n\telse if (PURPLE_BLIST_NODE_IS_CONTACT(bnode))\n\t\t\n\t\tname = purple_contact_get_alias(PURPLE_CONTACT(bnode));\n\telse if (PURPLE_BLIST_NODE_IS_BUDDY(bnode))\n\t\tname = purple_buddy_get_name(PURPLE_BUDDY(bnode));\n\telse\n\t\tname = \"(unknown)\";\n\tpurple_debug_misc(\"signals test\", \"blist_node_removed_cb (%s)\\n\",\n\t                  name ? name : \"(null)\");\n}\n", "bug_type": null, "idx": 812}
{"project": "Pidgin", "target": 0, "func": "gboolean\ngnt_widget_clicked(GntWidget *widget, GntMouseEvent event, int x, int y)\n{\n\tgboolean ret;\n\tg_signal_emit(widget, signals[SIG_CLICKED], 0, event, x, y, &ret);\n\tif (!ret && event == GNT_RIGHT_MOUSE_DOWN)\n\t\tret = gnt_bindable_perform_action_named(GNT_BINDABLE(widget), \"context-menu\", NULL);\n\treturn ret;\n}\n", "bug_type": null, "idx": 813}
{"project": "Pidgin", "target": 0, "func": "static void\npurplerc_make_changes(void)\n{\n\tGString *str = make_gtkrc_string();\n\tGtkSettings *setting = NULL;\n\tgtk_rc_parse_string(str->str);\n\tg_string_free(str, TRUE);\n\tsetting = gtk_settings_get_default();\n\tgtk_rc_reset_styles(setting);\n}\n", "bug_type": null, "idx": 814}
{"project": "Pidgin", "target": 0, "func": "static RECT\nget_actualWindowRect(HWND hwnd)\n{\n\tRECT winR;\n\tGetWindowRect(hwnd, &winR);\n\tif (dwmapi_module == NULL) {\n\t\tdwmapi_module = GetModuleHandleW(L\"dwmapi.dll\");\n\t\tif (dwmapi_module != NULL) {\n\t\t\tDwmIsCompositionEnabled = (DwmIsCompositionEnabledFunction) GetProcAddress(dwmapi_module, \"DwmIsCompositionEnabled\");\n\t\t\tDwmGetWindowAttribute = (DwmGetWindowAttributeFunction) GetProcAddress(dwmapi_module, \"DwmGetWindowAttribute\");\n\t\t}\n\t}\n\tif (DwmIsCompositionEnabled != NULL && DwmGetWindowAttribute != NULL) {\n\t\tBOOL pfEnabled;\n\t\tif (SUCCEEDED(DwmIsCompositionEnabled(&pfEnabled))) {\n\t\t\tRECT tempR;\n\t\t\tif (SUCCEEDED(DwmGetWindowAttribute(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, &tempR, sizeof(tempR)))) {\n\t\t\t\twinR = tempR;\n\t\t\t}\n\t\t}\n\t}\n\treturn winR;\n}\n", "bug_type": null, "idx": 815}
{"project": "Pidgin", "target": 0, "func": "static void\nwidget_hide(gpointer data, gpointer nodes)\n{\n\tGntWidget *widget = GNT_WIDGET(data);\n\tGntNode *node = g_hash_table_lookup(nodes, widget);\n\tif (GNT_IS_WINDOW(widget))\n\t\tgnt_window_workspace_hiding(GNT_WINDOW(widget));\n\tif (node)\n\t\thide_panel(node->panel);\n}\n", "bug_type": null, "idx": 816}
{"project": "Pidgin", "target": 0, "func": "PurpleBuddyIcon *\npurple_buddy_icon_new(PurpleAccount *account, const char *username,\n                      void *icon_data, size_t icon_len,\n                      const char *checksum)\n{\n\tPurpleBuddyIcon *icon;\n\tg_return_val_if_fail(account   != NULL, NULL);\n\tg_return_val_if_fail(username  != NULL, NULL);\n\tg_return_val_if_fail(icon_data != NULL, NULL);\n\tg_return_val_if_fail(icon_len  > 0,    NULL);\n\t\n\ticon = purple_buddy_icons_find(account, username);\n\t\n\tif (icon == NULL)\n\t\ticon = purple_buddy_icon_create(account, username);\n\t\n\ticon->img = NULL;\n\tpurple_buddy_icon_set_data(icon, icon_data, icon_len, checksum);\n\treturn icon;\n}\n", "bug_type": null, "idx": 817}
{"project": "Pidgin", "target": 0, "func": "dbus_bool_t\npurple_dbus_message_iter_get_args_valist(DBusMessageIter *iter,\n\t\tDBusError *error, int first_arg_type, va_list var_args)\n{\n\tint spec_type, msg_type, i;\n\tspec_type = first_arg_type;\n\tfor (i = 0; spec_type != DBUS_TYPE_INVALID; i++)\n\t{\n\t\tmsg_type = dbus_message_iter_get_arg_type(iter);\n\t\tif (msg_type != spec_type)\n\t\t{\n\t\t\tdbus_set_error(error, DBUS_ERROR_INVALID_ARGS,\n\t\t\t\t\t\"Argument %d is specified to be of type \\\"%i\\\", but \"\n\t\t\t\t\t\"is actually of type \\\"%i\\\"\\n\", i,\n\t\t\t\t\tspec_type, msg_type);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!TYPE_IS_CONTAINER(spec_type))\n\t\t{\n\t\t\tgpointer ptr;\n\t\t\tptr = va_arg (var_args, gpointer);\n\t\t\tdbus_message_iter_get_basic(iter, ptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDBusMessageIter *sub;\n\t\t\tsub = va_arg (var_args, DBusMessageIter*);\n\t\t\tdbus_message_iter_recurse(iter, sub);\n\t\t\tpurple_debug_info(\"dbus\", \"subiter %p:%p\\n\", sub, * (gpointer*) sub);\n\t\t\tbreak; \n\t\t}\n\t\tspec_type = va_arg(var_args, int);\n\t\tif (!dbus_message_iter_next(iter) && spec_type != DBUS_TYPE_INVALID)\n\t\t{\n\t\t\tdbus_set_error (error, DBUS_ERROR_INVALID_ARGS,\n\t\t\t\t\t\"Message has only %d arguments, but more were expected\", i);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 818}
{"project": "Pidgin", "target": 0, "func": "static char *get_mood_icon_path(const char *mood)\n{\n\tchar *path;\n\tif (!strcmp(mood, \"busy\")) {\n\t\tpath = g_build_filename(DATADIR, \"pixmaps\", \"pidgin\",\n\t\t                        \"status\", \"16\", \"busy.png\", NULL);\n\t} else if (!strcmp(mood, \"hiptop\")) {\n\t\tpath = g_build_filename(DATADIR, \"pixmaps\", \"pidgin\",\n\t\t                        \"emblems\", \"16\", \"hiptop.png\", NULL);\n\t} else {\n\t\tchar *filename = g_strdup_printf(\"%s.png\", mood);\n\t\tpath = g_build_filename(DATADIR, \"pixmaps\", \"pidgin\",\n\t\t                        \"emotes\", \"small\", filename, NULL);\n\t\tg_free(filename);\n\t}\n\treturn path;\n}\n", "bug_type": null, "idx": 819}
{"project": "Pidgin", "target": 0, "func": "static GtkSpell* wgtkspell_get_from_text_view(GtkTextView *view) {return NULL;}\nstatic void wgtkspell_detach(GtkSpell *spell) {}\nstatic gboolean wgtkspell_set_language(GtkSpell *spell, const gchar *lang, GError **error) {return FALSE;}\nstatic GtkSpell* wgtkspell_get_from_text_view(GtkTextView *view) {return NULL;}\nstatic void wgtkspell_detach(GtkSpell *spell) {}\nstatic gboolean wgtkspell_set_language(GtkSpell *spell, const gchar *lang, GError **error) {return FALSE;}\n", "bug_type": null, "idx": 820}
{"project": "Pidgin", "target": 0, "func": " */\nstatic gboolean flap_connection_send_snac_queue(FlapConnection *conn, struct timeval now, GQueue *queue)\n{\n\twhile (!g_queue_is_empty(queue))\n\t{\n\t\tQueuedSnac *queued_snac;\n\t\tstruct rateclass *rateclass;\n\t\tqueued_snac = g_queue_peek_head(queue);\n\t\trateclass = flap_connection_get_rateclass(conn, queued_snac->family, queued_snac->subtype);\n\t\tif (rateclass != NULL)\n\t\t{\n\t\t\tguint32 new_current;\n\t\t\tnew_current = rateclass_get_new_current(conn, rateclass, &now);\n\t\t\tif (rateclass->dropping_snacs || new_current <= rateclass->alert)\n\t\t\t\t\n\t\t\t\treturn FALSE;\n\t\t\trateclass->current = new_current;\n\t\t\trateclass->last.tv_sec = now.tv_sec;\n\t\t\trateclass->last.tv_usec = now.tv_usec;\n\t\t}\n\t\tflap_connection_send(conn, queued_snac->frame);\n\t\tg_free(queued_snac);\n\t\tg_queue_pop_head(queue);\n\t}\n\t\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 821}
{"project": "Pidgin", "target": 0, "func": "static void gtk_ticker_init (GtkTicker *ticker)\n{\n#if GTK_CHECK_VERSION(2,18,0)\n\tgtk_widget_set_has_window (GTK_WIDGET (ticker), TRUE);\n#else\n\tGTK_WIDGET_UNSET_FLAGS (ticker, GTK_NO_WINDOW);\n#endif\n\tticker->interval = (guint) 200;\n\tticker->scootch = (guint) 2;\n\tticker->children = NULL;\n\tticker->timer = 0;\n\tticker->dirty = TRUE;\n}\n", "bug_type": null, "idx": 822}
{"project": "Pidgin", "target": 0, "func": "PurpleMediaManager *\npurple_media_get_manager(PurpleMedia *media)\n{\n\tPurpleMediaManager *ret;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA(media), NULL);\n\tg_object_get(media, \"manager\", &ret, NULL);\n\treturn ret;\n}\n", "bug_type": null, "idx": 823}
{"project": "Pidgin", "target": 0, "func": "PurpleAccountOption *\npurple_account_option_string_new(const char *text, const char *pref_name,\n\t\t\t\t\t\t\t   const char *default_value)\n{\n\tPurpleAccountOption *option;\n\toption = purple_account_option_new(PURPLE_PREF_STRING, text, pref_name);\n\tif (option == NULL)\n\t\treturn NULL;\n\toption->default_value.string = g_strdup(default_value);\n\treturn option;\n}\n", "bug_type": null, "idx": 824}
{"project": "Pidgin", "target": 0, "func": "void\njabber_si_uninit(void)\n{\n\tjabber_ibb_unregister_open_handler(jabber_si_xfer_ibb_open_cb);\n}\n", "bug_type": null, "idx": 825}
{"project": "Pidgin", "target": 0, "func": "#define AMSN_LOG_CONV_EXTRA \"01 Aug 2001 00:00:00]\"\nstatic GList *amsn_logger_parse_file(char *filename, const char *sn, PurpleAccount *account)\n{\n\tGList *list = NULL;\n\tGError *error;\n\tchar *contents;\n\tstruct amsn_logger_data *data;\n\tPurpleLog *log;\n\tpurple_debug_info(\"aMSN logger\", \"Reading %s\\n\", filename);\n\terror = NULL;\n\tif (!g_file_get_contents(filename, &contents, NULL, &error)) {\n\t\tpurple_debug_error(\"aMSN logger\",\n\t\t                   \"Couldn't read file %s: %s \\n\", filename,\n\t\t                   (error && error->message) ?\n\t\t                    error->message : \"Unknown error\");\n\t\tif (error)\n\t\t\tg_error_free(error);\n\t} else {\n\t\tchar *c = contents;\n\t\tgboolean found_start = FALSE;\n\t\tchar *start_log = c;\n\t\tint offset = 0;\n\t\tstruct tm tm;\n\t\twhile (c && *c) {\n\t\t\tif (purple_str_has_prefix(c, AMSN_LOG_CONV_START)) {\n\t\t\t\tchar month[4];\n\t\t\t\tif (sscanf(c + strlen(AMSN_LOG_CONV_START),\n\t\t\t\t           \"%u %3s %u %u:%u:%u\",\n\t\t\t\t           &tm.tm_mday, (char*)&month, &tm.tm_year,\n\t\t\t\t           &tm.tm_hour, &tm.tm_min, &tm.tm_sec) != 6) {\n\t\t\t\t\tfound_start = FALSE;\n\t\t\t\t\tpurple_debug_error(\"aMSN logger\",\n\t\t\t\t\t                   \"Error parsing start date for %s\\n\",\n\t\t\t\t\t                   filename);\n\t\t\t\t} else {\n\t\t\t\t\ttm.tm_year -= 1900;\n\t\t\t\t\t\n\t\t\t\t\ttm.tm_isdst = -1;\n\t\t\t\t\ttm.tm_mon = get_month(month);\n\t\t\t\t\tfound_start = TRUE;\n\t\t\t\t\toffset = c - contents;\n\t\t\t\t\tstart_log = c;\n\t\t\t\t}\n\t\t\t} else if (purple_str_has_prefix(c, AMSN_LOG_CONV_END) && found_start) {\n\t\t\t\tdata = g_new0(struct amsn_logger_data, 1);\n\t\t\t\tdata->path = g_strdup(filename);\n\t\t\t\tdata->offset = offset;\n\t\t\t\tdata->length = c - start_log\n\t\t\t\t\t             + strlen(AMSN_LOG_CONV_END)\n\t\t\t\t\t             + strlen(AMSN_LOG_CONV_EXTRA);\n\t\t\t\tlog = purple_log_new(PURPLE_LOG_IM, sn, account, NULL, mktime(&tm), NULL);\n\t\t\t\tlog->logger = amsn_logger;\n\t\t\t\tlog->logger_data = data;\n\t\t\t\tlist = g_list_prepend(list, log);\n\t\t\t\tfound_start = FALSE;\n\t\t\t\tpurple_debug_info(\"aMSN logger\",\n\t\t\t\t                  \"Found log for %s:\"\n\t\t\t\t                  \" path = (%s),\"\n\t\t\t\t                  \" offset = (%d),\"\n\t\t\t\t                  \" length = (%d)\\n\",\n\t\t\t\t                  sn, data->path, data->offset, data->length);\n\t\t\t}\n\t\t\tc = strchr(c, '\\n');\n\t\t\tif (c)\n\t\t\t\tc++;\n\t\t}\n\t\t\n\t\tif (found_start) {\n\t\t\tdata = g_new0(struct amsn_logger_data, 1);\n\t\t\tdata->path = g_strdup(filename);\n\t\t\tdata->offset = offset;\n\t\t\tdata->length = c - start_log\n\t\t\t\t             + strlen(AMSN_LOG_CONV_END)\n\t\t\t\t             + strlen(AMSN_LOG_CONV_EXTRA);\n\t\t\tlog = purple_log_new(PURPLE_LOG_IM, sn, account, NULL, mktime(&tm), NULL);\n\t\t\tlog->logger = amsn_logger;\n\t\t\tlog->logger_data = data;\n\t\t\tlist = g_list_prepend(list, log);\n\t\t\tfound_start = FALSE;\n\t\t\tpurple_debug_info(\"aMSN logger\",\n\t\t\t                  \"Found log for %s:\"\n\t\t\t                  \" path = (%s),\"\n\t\t\t                  \" offset = (%d),\"\n\t\t\t                  \" length = (%d)\\n\",\n\t\t\t                  sn, data->path, data->offset, data->length);\n\t\t}\n\t\tg_free(contents);\n\t}\n\treturn list;\n}\n", "bug_type": null, "idx": 826}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_change_pass(PurplePluginAction *action)\n{\n\tPurpleConnection *gc = (PurpleConnection *) action->context;\n\tpurple_account_request_change_password(purple_connection_get_account(gc));\n}\n", "bug_type": null, "idx": 827}
{"project": "Pidgin", "target": 0, "func": "static void\nremove_from_signed_on_elsewhere(PurpleAccount *account)\n{\n\tPidginBuddyListPrivate *priv = PIDGIN_BUDDY_LIST_GET_PRIVATE(gtkblist);\n\tPidginMiniDialog *mini_dialog = priv->signed_on_elsewhere;\n\tif(mini_dialog == NULL)\n\t\treturn;\n\tremove_child_widget_by_account(GTK_CONTAINER(mini_dialog->contents), account);\n\tupdate_signed_on_elsewhere_minidialog_title();\n}\n", "bug_type": null, "idx": 828}
{"project": "Pidgin", "target": 0, "func": "static void\nend_search(GntTree *tree)\n{\n\tif (tree->priv->search) {\n\t\tg_source_remove(tree->priv->search_timeout);\n\t\tg_string_free(tree->priv->search, TRUE);\n\t\ttree->priv->search = NULL;\n\t\ttree->priv->search_timeout = 0;\n\t\tGNT_WIDGET_UNSET_FLAGS(GNT_WIDGET(tree), GNT_WIDGET_DISABLE_ACTIONS);\n\t}\n}\n", "bug_type": null, "idx": 829}
{"project": "Pidgin", "target": 0, "func": "int irc_cmd_ctcp_action(struct irc_conn *irc, const char *cmd, const char *target, const char **args)\n{\n\tPurpleConnection *gc = purple_account_get_connection(irc->account);\n\tchar *action, *escaped, *dst, **newargs;\n\tconst char *src;\n\tchar *msg;\n\tPurpleConversation *convo;\n\tif (!args || !args[0] || !gc)\n\t\treturn 0;\n\tconvo = purple_find_conversation_with_account(PURPLE_CONV_TYPE_ANY,\n\t\ttarget, irc->account);\n\tmsg = g_strdup_printf(\"/me %s\", args[0]);\n\t\n\tif (purple_conversation_get_type(convo) == PURPLE_CONV_TYPE_IM) {\n\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\"sending-im-msg\", irc->account,\n\t\t\tpurple_conversation_get_name(convo), &msg);\n\t} else {\n\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\"sending-chat-msg\", irc->account, &msg,\n\t\t\tpurple_conv_chat_get_id(PURPLE_CONV_CHAT(convo)));\n\t}\n\tif (!msg || !msg[0]) {\n\t\tg_free(msg);\n\t\treturn 0;\n\t}\n\tif (strncmp(msg, \"/me \", 4) != 0) {\n\t\tnewargs = g_new0(char *, 2);\n\t\tnewargs[0] = g_strdup(target);\n\t\tnewargs[1] = msg;\n\t\tirc_cmd_privmsg(irc, cmd, target, (const char **)newargs);\n\t\tg_free(newargs[0]);\n\t\tg_free(newargs);\n\t} else {\n\t\taction = g_malloc(strlen(&msg[4]) + 10);\n\t\tsprintf(action, \"\\001ACTION \");\n\t\tsrc = &msg[4];\n\t\tdst = action + 8;\n\t\twhile (*src) {\n\t\t\tif (*src == '\\n') {\n\t\t\t\tif (*(src + 1) == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t*dst++ = ' ';\n\t\t\t\t\tsrc++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*dst++ = *src++;\n\t\t}\n\t\t*dst++ = '\\001';\n\t\t*dst = '\\0';\n\t\tnewargs = g_new0(char *, 2);\n\t\tnewargs[0] = g_strdup(target);\n\t\tnewargs[1] = action;\n\t\tirc_cmd_privmsg(irc, cmd, target, (const char **)newargs);\n\t\tg_free(newargs[0]);\n\t\tg_free(newargs);\n\t\tg_free(action);\n\t}\n\t\n\tif (purple_conversation_get_type(convo) == PURPLE_CONV_TYPE_IM) {\n\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\"sent-im-msg\", irc->account,\n\t\t\tpurple_conversation_get_name(convo), msg);\n\t} else {\n\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\"sent-chat-msg\", irc->account, msg,\n\t\t\tpurple_conv_chat_get_id(PURPLE_CONV_CHAT(convo)));\n\t}\n\tg_free(msg);\n\tif (convo) {\n\t\tescaped = g_markup_escape_text(args[0], -1);\n\t\taction = g_strdup_printf(\"/me %s\", escaped);\n\t\tg_free(escaped);\n\t\tif (action[strlen(action) - 1] == '\\n')\n\t\t\taction[strlen(action) - 1] = '\\0';\n\t\tif (purple_conversation_get_type(convo) == PURPLE_CONV_TYPE_CHAT)\n\t\t\tserv_got_chat_in(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(convo)),\n\t\t\t                 purple_connection_get_display_name(gc),\n\t\t\t                 PURPLE_MESSAGE_SEND, action, time(NULL));\n\t\telse\n\t\t\tpurple_conv_im_write(PURPLE_CONV_IM(convo), purple_connection_get_display_name(gc),\n\t\t\t                     action, PURPLE_MESSAGE_SEND, time(NULL));\n\t\tg_free(action);\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 830}
{"project": "Pidgin", "target": 0, "func": "int _wpurple_DNSServiceRefSockFD(DNSServiceRef sdRef) {\n\tg_return_val_if_fail(_DNSServiceRefSockFD != NULL, -1);\n\treturn (_DNSServiceRefSockFD)(sdRef);\n}\n", "bug_type": null, "idx": 831}
{"project": "Pidgin", "target": 0, "func": " ****************************/\ngboolean _mdns_init_session(BonjourDnsSd *data) {\n\tdata->mdns_impl_data = g_new0(Win32SessionImplData, 1);\n\tbonjour_dns_sd_set_jid(data->account, purple_get_host_name());\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 832}
{"project": "Pidgin", "target": 0, "func": "void tcl_glib_init ()\n{\n\tTcl_NotifierProcs notifier;\n\tmemset(&notifier, 0, sizeof(notifier));\n\tnotifier.createFileHandlerProc = tcl_create_file_handler;\n\tnotifier.deleteFileHandlerProc = tcl_delete_file_handler;\n\tnotifier.setTimerProc = tcl_set_timer;\n\tnotifier.waitForEventProc = tcl_wait_for_event;\n\tTcl_SetNotifier(&notifier);\n\tTcl_SetServiceMode(TCL_SERVICE_ALL);\n\ttcl_timer_pending = FALSE;\n\ttcl_file_handlers = g_hash_table_new(g_direct_hash, g_direct_equal);\n}\n", "bug_type": null, "idx": 833}
{"project": "Pidgin", "target": 0, "func": "static void\nshortcut_changed_cb(PurpleSmiley *smiley, gpointer dontcare, GtkIMHtmlSmiley *gtksmiley)\n{\n\tg_free(gtksmiley->smile);\n\tgtksmiley->smile = g_strdup(purple_smiley_get_shortcut(smiley));\n}\n", "bug_type": null, "idx": 834}
{"project": "Pidgin", "target": 0, "func": "PurpleRoomlist *purple_roomlist_get_list(PurpleConnection *gc)\n{\n\tPurplePlugin *prpl = NULL;\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tg_return_val_if_fail(gc != NULL, NULL);\n\tg_return_val_if_fail(PURPLE_CONNECTION_IS_CONNECTED(gc), NULL);\n\tprpl = purple_connection_get_prpl(gc);\n\tif(prpl != NULL)\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\tif(prpl_info && prpl_info->roomlist_get_list)\n\t\treturn prpl_info->roomlist_get_list(gc);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 835}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nis_budddylist(GntWidget *win)\n{\n\tconst char *name = gnt_widget_get_name(win);\n\tif (name && strcmp(name, \"buddylist\") == 0)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 836}
{"project": "Pidgin", "target": 0, "func": "static gboolean G_GNUC_CONST\nstandard_is_strings (const char *key)\n{\n\tstatic GHashTable *strings = NULL;\n\tif (strings == NULL) {\n\t\tstrings = g_hash_table_new (g_str_hash, g_str_equal);\n\t\tg_hash_table_insert (strings,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_FILE_PATTERN,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_FILE_PATTERN);\n\t\tg_hash_table_insert (strings,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_ACTIONS,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_ACTIONS);\n\t\tg_hash_table_insert (strings,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_MIME_TYPE,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_MIME_TYPE);\n\t\tg_hash_table_insert (strings,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_PATTERNS,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_PATTERNS);\n\t\tg_hash_table_insert (strings,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_SORT_ORDER,\n\t\t\t\t     PURPLE_DESKTOP_ITEM_SORT_ORDER);\n\t}\n\treturn g_hash_table_lookup (strings, key) != NULL;\n}\n", "bug_type": null, "idx": 837}
{"project": "Pidgin", "target": 0, "func": "static void store_smiley_add(PurpleSmiley *smiley)\n{\n\tGtkTreeIter iter;\n\tPurpleStoredImage *img;\n\tGdkPixbuf *sized_smiley = NULL;\n\tif (smiley_manager == NULL)\n\t\treturn;\n\timg = purple_smiley_get_stored_image(smiley);\n\tif (img != NULL) {\n\t\tGdkPixbuf *smiley_image = pidgin_pixbuf_from_imgstore(img);\n\t\tpurple_imgstore_unref(img);\n\t\tif (smiley_image != NULL) {\n\t\t\tif (gdk_pixbuf_get_width(smiley_image) > 22 ||\n\t\t\t\tgdk_pixbuf_get_height(smiley_image) > 22) {\n\t\t\t\tsized_smiley = gdk_pixbuf_scale_simple(smiley_image,\n\t\t\t\t\t22, 22, GDK_INTERP_HYPER);\n\t\t\t\tg_object_unref(G_OBJECT(smiley_image));\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tsized_smiley = smiley_image;\n\t\t\t}\n\t\t}\n\t}\n\tgtk_list_store_append(smiley_manager->model, &iter);\n\tgtk_list_store_set(smiley_manager->model, &iter,\n\t\t\tICON, sized_smiley,\n\t\t\tSHORTCUT, purple_smiley_get_shortcut(smiley),\n\t\t\tSMILEY, smiley,\n\t\t\t-1);\n\tif (sized_smiley != NULL)\n\t\tg_object_unref(G_OBJECT(sized_smiley));\n}\n", "bug_type": null, "idx": 838}
{"project": "Pidgin", "target": 0, "func": "static void\nsha256_uninit(PurpleCipherContext *context) {\n\tstruct SHA256Context *sha256_ctx;\n\tpurple_cipher_context_reset(context, NULL);\n\tsha256_ctx = purple_cipher_context_get_data(context);\n\tmemset(sha256_ctx, 0, sizeof(struct SHA256Context));\n\tg_free(sha256_ctx);\n\tsha256_ctx = NULL;\n}\n", "bug_type": null, "idx": 839}
{"project": "Pidgin", "target": 0, "func": "int\npurple_request_fields_get_integer(const PurpleRequestFields *fields,\n\t\t\t\t\t\t\t\tconst char *id)\n{\n\tPurpleRequestField *field;\n\tg_return_val_if_fail(fields != NULL, 0);\n\tg_return_val_if_fail(id     != NULL, 0);\n\tif ((field = purple_request_fields_get_field(fields, id)) == NULL)\n\t\treturn 0;\n\treturn purple_request_field_int_get_value(field);\n}\n", "bug_type": null, "idx": 840}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin)\n{\n\tpurple_prefs_add_none(\"/plugins/gtk/timestamp\");\n\tpurple_prefs_add_int(\"/plugins/gtk/timestamp/interval\", interval * 1000);\n}\n", "bug_type": null, "idx": 841}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_session_handle_xml_event(struct gg_session *gs, uint32_t type,\n\tconst char *ptr, size_t len, struct gg_event *ge)\n{\n\tgg_debug_session(gs, GG_DEBUG_MISC, \"// gg_watch_fd_connected() received XML event\\n\");\n\tge->type = GG_EVENT_XML_EVENT;\n\tge->event.xml_event.data = malloc(len + 1);\n\tif (ge->event.xml_event.data == NULL) {\n\t\tgg_debug_session(gs, GG_DEBUG_MISC, \"// gg_watch_fd_connected() out of memory\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(ge->event.xml_event.data, ptr, len);\n\tge->event.xml_event.data[len] = 0;\n\treturn 0;\n}\n", "bug_type": null, "idx": 842}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npidgin_roomlist_paint_tooltip(GtkWidget *widget, gpointer user_data)\n{\n\tPurpleRoomlist *list = user_data;\n\tPidginRoomlist *grl = list->ui_data;\n\tGtkStyle *style;\n\tint current_height, max_width;\n\tint max_text_width;\n\tGtkTextDirection dir = gtk_widget_get_direction(GTK_WIDGET(grl->tree));\n\tstyle = grl->tipwindow->style;\n\tmax_text_width = MAX(grl->tip_width, grl->tip_name_width);\n\tmax_width = TOOLTIP_BORDER + SMALL_SPACE + max_text_width + TOOLTIP_BORDER;\n\tcurrent_height = 12;\n\tif (dir == GTK_TEXT_DIR_RTL) {\n\t\tgtk_paint_layout(style, grl->tipwindow->window, GTK_STATE_NORMAL, FALSE,\n\t\t\t\tNULL, grl->tipwindow, \"tooltip\",\n\t\t\t\tmax_width - (TOOLTIP_BORDER + SMALL_SPACE) - PANGO_PIXELS(600000),\n\t\t\t\tcurrent_height, grl->tip_name_layout);\n\t} else {\n\t\tgtk_paint_layout (style, grl->tipwindow->window, GTK_STATE_NORMAL, FALSE,\n\t\t\t\tNULL, grl->tipwindow, \"tooltip\",\n\t\t\t\tTOOLTIP_BORDER + SMALL_SPACE, current_height, grl->tip_name_layout);\n\t}\n\tif (dir != GTK_TEXT_DIR_RTL) {\n\t\tgtk_paint_layout (style, grl->tipwindow->window, GTK_STATE_NORMAL, FALSE,\n\t\t\t\tNULL, grl->tipwindow, \"tooltip\",\n\t\t\t\tTOOLTIP_BORDER + SMALL_SPACE, current_height + grl->tip_name_height, grl->tip_layout);\n\t} else {\n\t\tgtk_paint_layout(style, grl->tipwindow->window, GTK_STATE_NORMAL, FALSE,\n\t\t\t\tNULL, grl->tipwindow, \"tooltip\",\n\t\t\t\tmax_width - (TOOLTIP_BORDER + SMALL_SPACE) - PANGO_PIXELS(600000),\n\t\t\t\tcurrent_height + grl->tip_name_height,\n\t\t\t\tgrl->tip_layout);\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 843}
{"project": "Pidgin", "target": 0, "func": "void\npurple_perl_signal_disconnect(PurplePlugin *plugin, void *instance,\n                            const char *signal)\n{\n\tPurplePerlSignalHandler *handler;\n\thandler = find_signal_handler(plugin, instance, signal);\n\tif (handler == NULL) {\n\t\tcroak(\"Invalid signal handler information in \"\n\t\t      \"disconnecting a perl signal handler.\\n\");\n\t\treturn;\n\t}\n\tdestroy_signal_handler(handler);\n}\n", "bug_type": null, "idx": 844}
{"project": "Pidgin", "target": 0, "func": "void finch_notify_init()\n{\n\tuserinfo = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);\n}\n", "bug_type": null, "idx": 845}
{"project": "Pidgin", "target": 0, "func": "static void\nconversation_created_cb(PurpleConversation *conv, PidginBuddyList *gtkblist)\n{\n\tswitch (conv->type) {\n\t\tcase PURPLE_CONV_TYPE_IM:\n\t\t\t{\n\t\t\t\tGSList *buddies = purple_find_buddies(conv->account, conv->name);\n\t\t\t\twhile (buddies) {\n\t\t\t\t\tPurpleBlistNode *buddy = buddies->data;\n\t\t\t\t\tstruct _pidgin_blist_node *ui = buddy->ui_data;\n\t\t\t\t\tbuddies = g_slist_delete_link(buddies, buddies);\n\t\t\t\t\tif (!ui)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tui->conv.conv = conv;\n\t\t\t\t\tui->conv.flags = 0;\n\t\t\t\t\tui->conv.last_message = 0;\n\t\t\t\t\tpurple_signal_connect(purple_conversations_get_handle(), \"deleting-conversation\",\n\t\t\t\t\t\t\tui, PURPLE_CALLBACK(conversation_deleted_update_ui_cb), ui);\n\t\t\t\t\tpurple_signal_connect(purple_conversations_get_handle(), \"wrote-im-msg\",\n\t\t\t\t\t\t\tui, PURPLE_CALLBACK(written_msg_update_ui_cb), buddy);\n\t\t\t\t\tpurple_signal_connect(pidgin_conversations_get_handle(), \"conversation-displayed\",\n\t\t\t\t\t\t\tui, PURPLE_CALLBACK(displayed_msg_update_ui_cb), buddy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PURPLE_CONV_TYPE_CHAT:\n\t\t\t{\n\t\t\t\tPurpleChat *chat = purple_blist_find_chat(conv->account, conv->name);\n\t\t\t\tstruct _pidgin_blist_node *ui;\n\t\t\t\tif (!chat)\n\t\t\t\t\tbreak;\n\t\t\t\tui = chat->node.ui_data;\n\t\t\t\tif (!ui)\n\t\t\t\t\tbreak;\n\t\t\t\tui->conv.conv = conv;\n\t\t\t\tui->conv.flags = 0;\n\t\t\t\tui->conv.last_message = 0;\n\t\t\t\tpurple_signal_connect(purple_conversations_get_handle(), \"deleting-conversation\",\n\t\t\t\t\t\tui, PURPLE_CALLBACK(conversation_deleted_update_ui_cb), ui);\n\t\t\t\tpurple_signal_connect(purple_conversations_get_handle(), \"wrote-chat-msg\",\n\t\t\t\t\t\tui, PURPLE_CALLBACK(written_msg_update_ui_cb), chat);\n\t\t\t\tpurple_signal_connect(pidgin_conversations_get_handle(), \"conversation-displayed\",\n\t\t\t\t\t\tui, PURPLE_CALLBACK(displayed_msg_update_ui_cb), chat);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 846}
{"project": "Pidgin", "target": 0, "func": "static void\ntls_peers_mgmt_delete_confirm_cb(gchar *id, gint dontcare)\n{\n\tif (!purple_certificate_pool_delete(certmgr.pool, id)) {\n\t\tpurple_debug_warning(\"gntcertmgr/tls_peers_mgmt\",\n\t\t\t\t\"Deletion failed on id %s\\n\", id);\n\t};\n\tg_free(id);\n}\n", "bug_type": null, "idx": 847}
{"project": "Pidgin", "target": 0, "func": "uin_t gg_protobuf_get_uin(ProtobufCBinaryData uin_data)\n{\n\tuint8_t magic;\n\tsize_t uin_len;\n\tconst char *uin_str;\n\tuin_t uin;\n\tmagic = (uin_data.len > 0) ? uin_data.data[0] : 0;\n\tuin_len = (uin_data.len > 1) ? uin_data.data[1] : 0;\n\tif (uin_data.len != uin_len + 2 || uin_len > 10) {\n\t\tgg_debug(GG_DEBUG_ERROR, \"// gg_protobuf_get_uin: \"\n\t\t\t\"invalid length\\n\");\n\t\treturn 0;\n\t}\n\tif (magic != 0) {\n\t\tgg_debug(GG_DEBUG_WARNING, \"// gg_protobuf_get_uin: \"\n\t\t\t\"unexpected magic value=%#x\\n\", magic);\n\t}\n\tuin_str = (char*)(uin_data.data + 2);\n\tuin = gg_str_to_uin(uin_str, uin_len);\n\tif (uin == 0) {\n\t\tgg_debug(GG_DEBUG_ERROR, \"// gg_protobuf_get_uin: \"\n\t\t\t\"invalid uin\\n\");\n\t}\n\treturn uin;\n}\n", "bug_type": null, "idx": 848}
{"project": "Pidgin", "target": 0, "func": " */\nconst char *gg_libgadu_version(void)\n{\n\treturn GG_LIBGADU_VERSION;\n}\n", "bug_type": null, "idx": 849}
{"project": "Pidgin", "target": 0, "func": "NMERR_T\nnm_send_request(NMConn *conn, char *cmd, NMField *fields,\n\t\t\t\tnm_response_cb cb, gpointer data, NMRequest **request)\n{\n\tNMERR_T rc = NM_OK;\n\tchar buffer[512];\n\tint bytes_to_send;\n\tint ret;\n\tNMField *request_fields = NULL;\n\tchar *str = NULL;\n\tif (conn == NULL || cmd == NULL)\n\t\treturn NMERR_BAD_PARM;\n\t\n\tbytes_to_send = g_snprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t\t   \"POST /%s HTTP/1.0\\r\\n\", cmd);\n\tret = nm_tcp_write(conn, buffer, bytes_to_send);\n\tif (ret < 0) {\n\t\trc = NMERR_TCP_WRITE;\n\t}\n\t\n\tif (rc == NM_OK) {\n\t\tif (strcmp(\"login\", cmd) == 0) {\n\t\t\tbytes_to_send = g_snprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t\t\t\t   \"Host: %s:%d\\r\\n\\r\\n\", conn->addr, conn->port);\n\t\t\tret = nm_tcp_write(conn, buffer, bytes_to_send);\n\t\t\tif (ret < 0) {\n\t\t\t\trc = NMERR_TCP_WRITE;\n\t\t\t}\n\t\t} else {\n\t\t\tbytes_to_send = g_snprintf(buffer, sizeof(buffer), \"\\r\\n\");\n\t\t\tret = nm_tcp_write(conn, buffer, bytes_to_send);\n\t\t\tif (ret < 0) {\n\t\t\t\trc = NMERR_TCP_WRITE;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (rc == NM_OK) {\n\t\tif (fields)\n\t\t\trequest_fields = nm_copy_field_array(fields);\n\t\tstr = g_strdup_printf(\"%d\", ++(conn->trans_id));\n\t\trequest_fields = nm_field_add_pointer(request_fields, NM_A_SZ_TRANSACTION_ID, 0,\n\t\t\t\t\t\t\t\t\t\t\t  NMFIELD_METHOD_VALID, 0,\n\t\t\t\t\t\t\t\t\t\t\t  str, NMFIELD_TYPE_UTF8);\n\t}\n\t\n\tif (rc == NM_OK) {\n\t\trc = nm_write_fields(conn, request_fields);\n\t}\n\t\n\tif (rc == NM_OK) {\n\t\tret = nm_tcp_write(conn, \"\\r\\n\", strlen(\"\\r\\n\"));\n\t\tif (ret < 0) {\n\t\t\trc = NMERR_TCP_WRITE;\n\t\t}\n\t}\n\t\n\tif (rc == NM_OK) {\n\t\tNMRequest *new_request = nm_create_request(cmd, conn->trans_id,\n\t\t\t\t\t\t\t\t\t\t\t\t   time(0), cb, NULL, data);\n\t\tnm_conn_add_request_item(conn, new_request);\n\t\t\n\t\tif (request)\n\t\t\t*request = new_request;\n\t\telse\n\t\t\tnm_release_request(new_request);\n\t}\n\tif (request_fields != NULL)\n\t\tnm_free_fields(&request_fields);\n\treturn rc;\n}\n", "bug_type": null, "idx": 850}
{"project": "Pidgin", "target": 0, "func": "static size_t\nrc4_get_key_size (PurpleCipherContext *context)\n{\n\tstruct RC4Context *ctx;\n\tg_return_val_if_fail(context, -1);\n\tctx = purple_cipher_context_get_data(context);\n\tg_return_val_if_fail(ctx, -1);\n\treturn ctx->key_len;\n}\n", "bug_type": null, "idx": 851}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\tPurplePlugin *jabber;\n\tjabber = purple_find_prpl(\"prpl-jabber\");\n\tif (!jabber)\n\t\treturn FALSE;\n\txmpp_console_handle = plugin;\n\tpurple_signal_connect(jabber, \"jabber-receiving-xmlnode\", xmpp_console_handle,\n\t\t\t    PURPLE_CALLBACK(xmlnode_received_cb), NULL);\n\tpurple_signal_connect(jabber, \"jabber-sending-text\", xmpp_console_handle,\n\t\t\t    PURPLE_CALLBACK(xmlnode_sent_cb), NULL);\n\tpurple_signal_connect(purple_connections_get_handle(), \"signing-on\",\n\t\t\t    plugin, PURPLE_CALLBACK(signing_on_cb), NULL);\n\tpurple_signal_connect(purple_connections_get_handle(), \"signed-off\",\n\t\t\t    plugin, PURPLE_CALLBACK(signed_off_cb), NULL);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 852}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_xfer_destroy(PurpleXfer *xfer)\n{\n\tPidginXferUiData *data;\n\tdata = PIDGINXFER(xfer);\n\tif (data) {\n\t\tg_free(data->name);\n\t\tg_free(data);\n\t\txfer->ui_data = NULL;\n\t}\n}\n", "bug_type": null, "idx": 853}
{"project": "Pidgin", "target": 0, "func": "static void silcpurple_verify_details_cb(PublicKeyVerify verify)\n{\n\t\n\tsilcpurple_verify_ask(verify->entity, verify->fingerprint,\n\t\t\t    verify->babbleprint, verify);\n}\n", "bug_type": null, "idx": 854}
{"project": "Pidgin", "target": 0, "func": "void gnt_keys_del_combination(const char *path)\n{\n\tdel_path(&root, path);\n}\n", "bug_type": null, "idx": 855}
{"project": "Pidgin", "target": 0, "func": " */\nvoid serv_alias_buddy(PurpleBuddy *b)\n{\n\tPurpleAccount *account;\n\tPurpleConnection *gc;\n\tPurplePlugin *prpl;\n\tPurplePluginProtocolInfo *prpl_info;\n\tif (b) {\n\t\taccount = purple_buddy_get_account(b);\n\t\tif (account) {\n\t\t\tgc = purple_account_get_connection(account);\n\t\t\tif (gc) {\n\t\t\t\tprpl = purple_connection_get_prpl(gc);\n\t\t\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\t\t\t\tif (prpl_info->alias_buddy)\n\t\t\t\t\tprpl_info->alias_buddy(gc,\n\t\t\t\t\t\t\tpurple_buddy_get_name(b),\n\t\t\t\t\t\t\tpurple_buddy_get_local_buddy_alias(b));\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 856}
{"project": "Pidgin", "target": 0, "func": "static void\nfind_next_focus(GntBox *box)\n{\n\tgpointer last = box->active;\n\tdo\n\t{\n\t\tGList *iter = g_list_find(box->focus, box->active);\n\t\tif (iter && iter->next)\n\t\t\tbox->active = iter->next->data;\n\t\telse if (box->focus)\n\t\t\tbox->active = box->focus->data;\n\t\tif (!GNT_WIDGET_IS_FLAG_SET(box->active, GNT_WIDGET_INVISIBLE) &&\n\t\t\t\tGNT_WIDGET_IS_FLAG_SET(box->active, GNT_WIDGET_CAN_TAKE_FOCUS))\n\t\t\tbreak;\n\t} while (box->active != last);\n}\n", "bug_type": null, "idx": 857}
{"project": "Pidgin", "target": 0, "func": "static time_t\nfinch_get_idle_time(void)\n{\n\treturn gnt_wm_get_idle_time();\n}\n", "bug_type": null, "idx": 858}
{"project": "Pidgin", "target": 0, "func": "static void\nblist_show(PurpleBuddyList *list)\n{\n\tif (ggblist == NULL)\n\t\tnew_list(list);\n\telse if (ggblist->window) {\n\t\tgnt_window_present(ggblist->window);\n\t\treturn;\n\t}\n\tggblist->window = gnt_vwindow_new(FALSE);\n\tgnt_widget_set_name(ggblist->window, \"buddylist\");\n\tgnt_box_set_toplevel(GNT_BOX(ggblist->window), TRUE);\n\tgnt_box_set_title(GNT_BOX(ggblist->window), _(\"Buddy List\"));\n\tgnt_box_set_pad(GNT_BOX(ggblist->window), 0);\n\tggblist->tree = gnt_tree_new();\n\tGNT_WIDGET_SET_FLAGS(ggblist->tree, GNT_WIDGET_NO_BORDER);\n\tgnt_widget_set_size(ggblist->tree, purple_prefs_get_int(PREF_ROOT \"/size/width\"),\n\t\t\tpurple_prefs_get_int(PREF_ROOT \"/size/height\"));\n\tgnt_widget_set_position(ggblist->window, purple_prefs_get_int(PREF_ROOT \"/position/x\"),\n\t\t\tpurple_prefs_get_int(PREF_ROOT \"/position/y\"));\n\tgnt_box_add_widget(GNT_BOX(ggblist->window), ggblist->tree);\n\tggblist->status = gnt_combo_box_new();\n\tgnt_box_add_widget(GNT_BOX(ggblist->window), ggblist->status);\n\tggblist->statustext = gnt_entry_new(NULL);\n\tgnt_box_add_widget(GNT_BOX(ggblist->window), ggblist->statustext);\n\tgnt_widget_show(ggblist->window);\n\tpurple_signal_connect(purple_connections_get_handle(), \"signed-on\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(reconstruct_accounts_menu), NULL);\n\tpurple_signal_connect(purple_connections_get_handle(), \"signed-off\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(reconstruct_accounts_menu), NULL);\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-actions-changed\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(reconstruct_accounts_menu), NULL);\n\tpurple_signal_connect(purple_blist_get_handle(), \"buddy-status-changed\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(buddy_status_changed), ggblist);\n\tpurple_signal_connect(purple_blist_get_handle(), \"buddy-idle-changed\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(buddy_idle_changed), ggblist);\n\tpurple_signal_connect(purple_plugins_get_handle(), \"plugin-load\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(reconstruct_plugins_menu), NULL);\n\tpurple_signal_connect(purple_plugins_get_handle(), \"plugin-unload\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(reconstruct_plugins_menu), NULL);\n\tpurple_signal_connect(purple_blist_get_handle(), \"buddy-signed-on\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(buddy_signed_on_off), ggblist);\n\tpurple_signal_connect(purple_blist_get_handle(), \"buddy-signed-off\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(buddy_signed_on_off), ggblist);\n#if 0\n\t\n\tpurple_signal_connect(purple_conversations_get_handle(), \"received-im-msg\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(received_im_msg), list);\n\tpurple_signal_connect(purple_conversations_get_handle(), \"sent-im-msg\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(sent_im_msg), NULL);\n\tpurple_signal_connect(purple_conversations_get_handle(), \"received-chat-msg\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(received_chat_msg), list);\n#endif\n\tg_signal_connect(G_OBJECT(ggblist->tree), \"selection_changed\", G_CALLBACK(selection_changed), ggblist);\n\tg_signal_connect(G_OBJECT(ggblist->tree), \"key_pressed\", G_CALLBACK(key_pressed), ggblist);\n\tg_signal_connect(G_OBJECT(ggblist->tree), \"context-menu\", G_CALLBACK(context_menu), ggblist);\n\tg_signal_connect(G_OBJECT(ggblist->tree), \"collapse-toggled\", G_CALLBACK(group_collapsed), NULL);\n\tg_signal_connect(G_OBJECT(ggblist->tree), \"activate\", G_CALLBACK(selection_activate), ggblist);\n\tg_signal_connect_data(G_OBJECT(ggblist->tree), \"gained-focus\", G_CALLBACK(draw_tooltip),\n\t\t\t\tggblist, 0, G_CONNECT_AFTER | G_CONNECT_SWAPPED);\n\tg_signal_connect_data(G_OBJECT(ggblist->tree), \"lost-focus\", G_CALLBACK(remove_peripherals),\n\t\t\t\tggblist, 0, G_CONNECT_AFTER | G_CONNECT_SWAPPED);\n\tg_signal_connect_data(G_OBJECT(ggblist->window), \"workspace-hidden\", G_CALLBACK(remove_peripherals),\n\t\t\t\tggblist, 0, G_CONNECT_AFTER | G_CONNECT_SWAPPED);\n\tg_signal_connect(G_OBJECT(ggblist->tree), \"size_changed\", G_CALLBACK(size_changed_cb), NULL);\n\tg_signal_connect(G_OBJECT(ggblist->window), \"position_set\", G_CALLBACK(save_position_cb), NULL);\n\tg_signal_connect(G_OBJECT(ggblist->window), \"destroy\", G_CALLBACK(reset_blist_window), NULL);\n\t\n\tpurple_signal_connect(purple_savedstatuses_get_handle(), \"savedstatus-changed\", finch_blist_get_handle(),\n\t\t\t\tPURPLE_CALLBACK(savedstatus_changed), NULL);\n\tg_signal_connect(G_OBJECT(ggblist->status), \"selection_changed\",\n\t\t\t\tG_CALLBACK(status_selection_changed), NULL);\n\tg_signal_connect(G_OBJECT(ggblist->statustext), \"key_pressed\",\n\t\t\t\tG_CALLBACK(status_text_changed), NULL);\n\tcreate_menu();\n\tpopulate_buddylist();\n\tsavedstatus_changed(purple_savedstatus_get_current(), NULL);\n}\n", "bug_type": null, "idx": 859}
{"project": "Pidgin", "target": 0, "func": "static int\naim_encode_password_md5(const char *password, size_t password_len, const char *key, guint8 *digest)\n{\n\tPurpleCipherContext *context;\n\tcontext = purple_cipher_context_new_by_name(\"md5\", NULL);\n\tpurple_cipher_context_append(context, (const guchar *)key, strlen(key));\n\tpurple_cipher_context_append(context, (const guchar *)password, password_len);\n\tpurple_cipher_context_append(context, (const guchar *)AIM_MD5_STRING, strlen(AIM_MD5_STRING));\n\tpurple_cipher_context_digest(context, 16, digest, NULL);\n\tpurple_cipher_context_destroy(context);\n\treturn 0;\n}\nstatic int\naim_encode_password_md5(const char *password, size_t password_len, const char *key, guint8 *digest)\n{\n\tPurpleCipher *cipher;\n\tPurpleCipherContext *context;\n\tguchar passdigest[16];\n\tcipher = purple_ciphers_find_cipher(\"md5\");\n\tcontext = purple_cipher_context_new(cipher, NULL);\n\tpurple_cipher_context_append(context, (const guchar *)password, password_len);\n\tpurple_cipher_context_digest(context, 16, passdigest, NULL);\n\tpurple_cipher_context_destroy(context);\n\tcontext = purple_cipher_context_new(cipher, NULL);\n\tpurple_cipher_context_append(context, (const guchar *)key, strlen(key));\n\tpurple_cipher_context_append(context, passdigest, 16);\n\tpurple_cipher_context_append(context, (const guchar *)AIM_MD5_STRING, strlen(AIM_MD5_STRING));\n\tpurple_cipher_context_digest(context, 16, digest, NULL);\n\tpurple_cipher_context_destroy(context);\n\treturn 0;\n}\n", "bug_type": null, "idx": 860}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_media_set_encryption_parameters(PurpleMedia *media, const gchar *sess_id,\n\t\tconst gchar *cipher, const gchar *auth,\n\t\tconst gchar *key, gsize key_len)\n{\n#ifdef USE_VV\n\tg_return_val_if_fail(PURPLE_IS_MEDIA(media), FALSE);\n\treturn purple_media_backend_set_encryption_parameters(media->priv->backend,\n\t\t\tsess_id, cipher, auth, key, key_len);\n#else\n\treturn FALSE;\n#endif\n}\n", "bug_type": null, "idx": 861}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ndropdown_store_row_separator_func(GtkTreeModel *model,\n\t\t\t\t\t\t\t\t  GtkTreeIter *iter, gpointer data)\n{\n\tPidginStatusBoxItemType type;\n\tgtk_tree_model_get(model, iter, TYPE_COLUMN, &type, -1);\n\tif (type == PIDGIN_STATUS_BOX_TYPE_SEPARATOR)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 862}
{"project": "Pidgin", "target": 0, "func": "} pref_request;\nvoid finch_prefs_init()\n{\n\tpurple_prefs_add_none(\"/finch\");\n\tpurple_prefs_add_none(\"/finch/plugins\");\n\tpurple_prefs_add_path_list(\"/finch/plugins/loaded\", NULL);\n\tpurple_prefs_add_path_list(\"/finch/plugins/seen\", NULL);\n\tpurple_prefs_add_none(\"/finch/conversations\");\n\tpurple_prefs_add_bool(\"/finch/conversations/timestamps\", TRUE);\n\tpurple_prefs_add_bool(\"/finch/conversations/notify_typing\", FALSE);\n\tpurple_prefs_add_none(\"/finch/filelocations\");\n\tpurple_prefs_add_path(\"/finch/filelocations/last_save_folder\", \"\");\n\tpurple_prefs_add_path(\"/finch/filelocations/last_save_folder\", \"\");\n}\n", "bug_type": null, "idx": 863}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_prefs_get_path(const char *name)\n{\n\tstruct purple_pref *pref;\n\tPURPLE_PREFS_UI_OP_CALL_RETURN(get_string, name);\n\tpref = find_pref(name);\n\tif(!pref) {\n\t\tpurple_debug_error(\"prefs\",\n\t\t\t\t\"purple_prefs_get_path: Unknown pref %s\\n\", name);\n\t\treturn NULL;\n\t} else if(pref->type != PURPLE_PREF_PATH) {\n\t\tpurple_debug_error(\"prefs\",\n\t\t\t\t\"purple_prefs_get_path: %s not a path pref\\n\", name);\n\t\treturn NULL;\n\t}\n\treturn pref->value.string;\n}\n", "bug_type": null, "idx": 864}
{"project": "Pidgin", "target": 0, "func": "static PurplePerlSignalHandler *\nfind_signal_handler(PurplePlugin *plugin, void *instance, const char *signal)\n{\n\tPurplePerlSignalHandler *handler;\n\tGSList *l;\n\tfor (l = signal_handlers; l != NULL; l = l->next) {\n\t\thandler = l->data;\n\t\tif (handler->plugin == plugin &&\n\t\t\thandler->instance == instance &&\n\t\t\t!strcmp(handler->signal, signal)) {\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 865}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nmove_forward(GntBindable *bind, GList *list)\n{\n\tGntEntry *entry = GNT_ENTRY(bind);\n\tif (entry->cursor >= entry->end)\n\t\treturn FALSE;\n\tentry->cursor = g_utf8_find_next_char(entry->cursor, NULL);\n\twhile (gnt_util_onscreen_width(entry->scroll, entry->cursor) >= GNT_WIDGET(entry)->priv.width)\n\t\tentry->scroll = g_utf8_find_next_char(entry->scroll, NULL);\n\tupdate_kill_ring(entry, ENTRY_JAIL, NULL, 0);\n\tentry_redraw(GNT_WIDGET(entry));\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 866}
{"project": "Pidgin", "target": 0, "func": "static void qip_logger_finalize(PurpleLog *log)\n{\n\tstruct qip_logger_data *data;\n\tg_return_if_fail(log != NULL);\n\tdata = log->logger_data;\n\tg_free(data->path);\n\tg_free(data);\n}\n", "bug_type": null, "idx": 867}
{"project": "Pidgin", "target": 0, "func": "static void smiley_manager_select_cb(GtkWidget *widget, gint resp, SmileyManager *dialog)\n{\n\tGtkTreeSelection *selection = NULL;\n\tswitch (resp) {\n\t\tcase GTK_RESPONSE_YES:\n\t\t\tpidgin_smiley_edit(dialog->window, NULL);\n\t\t\tbreak;\n\t\tcase GTK_RESPONSE_NO:\n\t\t\tsmiley_delete(dialog);\n\t\t\tbreak;\n\t\tcase GTK_RESPONSE_DELETE_EVENT:\n\t\tcase GTK_RESPONSE_CLOSE:\n\t\t\tgtk_widget_destroy(dialog->window);\n\t\t\tg_free(smiley_manager);\n\t\t\tsmiley_manager = NULL;\n\t\t\tbreak;\n\t\tcase PIDGIN_RESPONSE_MODIFY:\n\t\t\t\n\t\t\tselection = gtk_tree_view_get_selection(GTK_TREE_VIEW(dialog->treeview));\n\t\t\tgtk_tree_selection_selected_foreach(selection, edit_selected_cb, dialog);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpurple_debug_info(\"gtksmiley\", \"No valid selection\\n\");\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 868}
{"project": "Pidgin", "target": 0, "func": "static void\n_purple_desktop_item_set_string (PurpleDesktopItem *item,\n\t\t\t       const char *attr,\n\t\t\t       const char *value)\n{\n\tg_return_if_fail (item != NULL);\n\tg_return_if_fail (item->refcount > 0);\n\tg_return_if_fail (attr != NULL);\n\tset (item, attr, value);\n\tif (purple_strequal (attr, PURPLE_DESKTOP_ITEM_TYPE))\n\t\titem->type = type_from_string (value);\n}\n", "bug_type": null, "idx": 869}
{"project": "Pidgin", "target": 0, "func": "void\noscar_convo_closed(PurpleConnection *gc, const char *who)\n{\n\tOscarData *od;\n\tPeerConnection *conn;\n\tod = purple_connection_get_protocol_data(gc);\n\tconn = peer_connection_find_by_type(od, who, OSCAR_CAPABILITY_DIRECTIM);\n\tif (conn != NULL)\n\t{\n\t\tif (!conn->ready)\n\t\t\taim_im_sendch2_cancel(conn);\n\t\tpeer_connection_destroy(conn, OSCAR_DISCONNECT_LOCAL_CLOSED, NULL);\n\t}\n}\n", "bug_type": null, "idx": 870}
{"project": "Pidgin", "target": 0, "func": "static void\nadd_user_cb(PidginAccountAddUserData *data)\n{\n\tPurpleConnection *gc = purple_account_get_connection(data->account);\n\tif (g_list_find(purple_connections_get_all(), gc))\n\t{\n\t\tpurple_blist_request_add_buddy(data->account, data->username,\n\t\t\t\t\t\t\t\t\t NULL, data->alias);\n\t}\n\tfree_add_user_data(data);\n}\n", "bug_type": null, "idx": 871}
{"project": "Pidgin", "target": 0, "func": "int\naim_locate_getinfoshort(OscarData *od, const char *bn, guint32 flags)\n{\n\tFlapConnection *conn;\n\tByteStream bs;\n\taim_snacid_t snacid;\n\tif (!od || !(conn = flap_connection_findbygroup(od, SNAC_FAMILY_LOCATE)) || !bn)\n\t\treturn -EINVAL;\n\tbyte_stream_new(&bs, 4 + 1 + strlen(bn));\n\tbyte_stream_put32(&bs, flags);\n\tbyte_stream_put8(&bs, strlen(bn));\n\tbyte_stream_putstr(&bs, bn);\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_LOCATE, 0x0015, 0x0000, bn, strlen(bn)+1);\n\tflap_connection_send_snac_with_priority(od, conn, SNAC_FAMILY_LOCATE, 0x0015, snacid, &bs, FALSE);\n\tbyte_stream_destroy(&bs);\n\treturn 0;\n}\n", "bug_type": null, "idx": 872}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_buddy_privkey_menu(PurpleBlistNode *node, gpointer data)\n{\n\tPurpleBuddy *buddy;\n\tPurpleConnection *gc;\n\tg_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));\n\tbuddy = (PurpleBuddy *) node;\n\tgc = purple_account_get_connection(buddy->account);\n\tsilcpurple_buddy_privkey(gc, buddy->name);\n}\n", "bug_type": null, "idx": 873}
{"project": "Pidgin", "target": 0, "func": "static void int_cell_data_func(GtkTreeViewColumn *col, GtkCellRenderer *renderer,\n                                   GtkTreeModel *model, GtkTreeIter *iter, gpointer user_data)\n{\n\tgchar buf[16];\n\tint myint;\n\tgtk_tree_model_get(model, iter, GPOINTER_TO_INT(user_data), &myint, -1);\n\tif (myint)\n\t\tg_snprintf(buf, sizeof(buf), \"%d\", myint);\n\telse\n\t\tbuf[0] = '\\0';\n\tg_object_set(renderer, \"text\", buf, NULL);\n}\n", "bug_type": null, "idx": 874}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_certificate_pool_store(PurpleCertificatePool *pool, const gchar *id, PurpleCertificate *crt)\n{\n\tgboolean ret = FALSE;\n\tg_return_val_if_fail(pool, FALSE);\n\tg_return_val_if_fail(id, FALSE);\n\tg_return_val_if_fail(pool->put_cert, FALSE);\n\t\n\tg_return_val_if_fail(\n\t\tg_ascii_strcasecmp(pool->scheme_name, crt->scheme->name) == 0,\n\t\tFALSE);\n\tret = (pool->put_cert)(id, crt);\n\t\n\tif (ret) {\n\t\tpurple_signal_emit(pool, \"certificate-stored\",\n\t\t\t\t   pool, id);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 875}
{"project": "Pidgin", "target": 0, "func": "static gboolean flap_connection_send_queued(gpointer data)\n{\n\tFlapConnection *conn;\n\tstruct timeval now;\n\tconn = data;\n\tgettimeofday(&now, NULL);\n\tpurple_debug_info(\"oscar\", \"Attempting to send %u queued SNACs and %u queued low-priority SNACs for %p\\n\",\n\t\t\t\t\t  (conn->queued_snacs ? conn->queued_snacs->length : 0),\n\t\t\t\t\t  (conn->queued_lowpriority_snacs ? conn->queued_lowpriority_snacs->length : 0),\n\t\t\t\t\t  conn);\n\tif (!conn->queued_snacs || flap_connection_send_snac_queue(conn, now, conn->queued_snacs)) {\n\t\tif (!conn->queued_lowpriority_snacs || flap_connection_send_snac_queue(conn, now, conn->queued_lowpriority_snacs)) {\n\t\t\t\n\t\t\tconn->queued_timeout = 0;\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 876}
{"project": "Pidgin", "target": 0, "func": "void\npurple_presence_switch_status(PurplePresence *presence, const char *status_id)\n{\n\tpurple_presence_set_status_active(presence, status_id, TRUE);\n}\n", "bug_type": null, "idx": 877}
{"project": "Pidgin", "target": 0, "func": "size_t\npurple_ssl_read(PurpleSslConnection *gsc, void *data, size_t len)\n{\n\tPurpleSslOps *ops;\n\tg_return_val_if_fail(gsc  != NULL, 0);\n\tg_return_val_if_fail(data != NULL, 0);\n\tg_return_val_if_fail(len  >  0,    0);\n\tops = purple_ssl_get_ops();\n\treturn (ops->read)(gsc, data, len);\n}\n", "bug_type": null, "idx": 878}
{"project": "Pidgin", "target": 0, "func": " */\nint aim_ssi_editcomment(OscarData *od, const char *gn, const char *bn, const char *comment)\n{\n\tstruct aim_ssi_item *tmp;\n\tif (!od || !gn || !bn)\n\t\treturn -EINVAL;\n\tif (!(tmp = aim_ssi_itemlist_finditem(od->ssi.local, gn, bn, AIM_SSI_TYPE_BUDDY)))\n\t\treturn -EINVAL;\n\t\n\tif ((comment != NULL) && (strlen(comment) > 0))\n\t\taim_tlvlist_replace_str(&tmp->data, 0x013c, comment);\n\telse\n\t\taim_tlvlist_remove(&tmp->data, 0x013c);\n\t\n\treturn aim_ssi_sync(od);\n}\n", "bug_type": null, "idx": 879}
{"project": "Pidgin", "target": 0, "func": "char *irc_format(struct irc_conn *irc, const char *format, ...)\n{\n\tGString *string = g_string_new(\"\");\n\tchar *tok, *tmp;\n\tconst char *cur;\n\tva_list ap;\n\tva_start(ap, format);\n\tfor (cur = format; *cur; cur++) {\n\t\tif (cur != format)\n\t\t\tg_string_append_c(string, ' ');\n\t\ttok = va_arg(ap, char *);\n\t\tswitch (*cur) {\n\t\tcase 'v':\n\t\t\tg_string_append(string, tok);\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tg_string_append_c(string, ':');\n\t\t\t\n\t\tcase 't':\n\t\tcase 'n':\n\t\tcase 'c':\n\t\t\ttmp = irc_send_convert(irc, tok);\n\t\t\tg_string_append(string, tmp ? tmp : tok);\n\t\t\tg_free(tmp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"irc\", \"Invalid format character '%c'\\n\", *cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\tva_end(ap);\n\tg_string_append(string, \"\\r\\n\");\n\treturn (g_string_free(string, FALSE));\n}\n", "bug_type": null, "idx": 880}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_button_draw(GntWidget *widget)\n{\n\tGntButton *button = GNT_BUTTON(widget);\n\tGntColorType type;\n\tgboolean focus;\n\tif ((focus = gnt_widget_has_focus(widget)))\n\t\ttype = GNT_COLOR_HIGHLIGHT;\n\telse\n\t\ttype = GNT_COLOR_NORMAL;\n\twbkgdset(widget->window, '\\0' | gnt_color_pair(type));\n\tmvwaddstr(widget->window, (small_button) ? 0 : 1, 2, C_(button->priv->text));\n\tif (small_button) {\n\t\ttype = GNT_COLOR_HIGHLIGHT;\n\t\tmvwchgat(widget->window, 0, 0, widget->priv.width, focus ? A_BOLD : A_REVERSE, type, NULL);\n\t}\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 881}
{"project": "Pidgin", "target": 0, "func": "void\npurple_prefs_set_generic(const char *name, gpointer value)\n{\n\tstruct purple_pref *pref = find_pref(name);\n\tif(!pref) {\n\t\tpurple_debug_error(\"prefs\",\n\t\t\t\t\"purple_prefs_set_generic: Unknown pref %s\\n\", name);\n\t\treturn;\n\t}\n\tpref->value.generic = value;\n\tdo_callbacks(name, pref);\n}\n", "bug_type": null, "idx": 882}
{"project": "Pidgin", "target": 0, "func": "void\njingle_session_add_pending_content(JingleSession *session, JingleContent* content)\n{\n\tsession->priv->pending_contents =\n\t\t\tg_list_append(session->priv->pending_contents, content);\n\tjingle_content_set_session(content, session);\n}\n", "bug_type": null, "idx": 883}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nkey_pressed(GntWidget *widget, const char *text, FinchBlist *ggblist)\n{\n\tif (text[0] == 27 && text[1] == 0) {\n\t\t\n\t\tif (gnt_tree_is_searching(GNT_TREE(ggblist->tree)))\n\t\t\tgnt_bindable_perform_action_named(GNT_BINDABLE(ggblist->tree), \"end-search\", NULL);\n\t\tremove_peripherals(ggblist);\n\t} else if (strcmp(text, GNT_KEY_INS) == 0) {\n\t\tPurpleBlistNode *node = gnt_tree_get_selection_data(GNT_TREE(ggblist->tree));\n\t\tpurple_blist_request_add_buddy(NULL, NULL,\n\t\t\t\tnode && PURPLE_BLIST_NODE_IS_GROUP(node) ? purple_group_get_name(PURPLE_GROUP(node)) : NULL,\n\t\t\t\tNULL);\n\t} else if (!gnt_tree_is_searching(GNT_TREE(ggblist->tree))) {\n\t\tif (strcmp(text, \"t\") == 0) {\n\t\t\tfinch_blist_toggle_tag_buddy(gnt_tree_get_selection_data(GNT_TREE(ggblist->tree)));\n\t\t\tgnt_bindable_perform_action_named(GNT_BINDABLE(ggblist->tree), \"move-down\", NULL);\n\t\t} else if (strcmp(text, \"a\") == 0) {\n\t\t\tfinch_blist_place_tagged(gnt_tree_get_selection_data(GNT_TREE(ggblist->tree)));\n\t\t} else\n\t\t\treturn FALSE;\n\t} else\n\t\treturn FALSE;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 884}
{"project": "Pidgin", "target": 0, "func": "gboolean\nnm_are_guids_equal(const char *guid1, const char *guid2)\n{\n\tif (guid1 == NULL || guid2 == NULL)\n\t\treturn FALSE;\n\treturn (strncmp(guid1, guid2, CONF_GUID_END) == 0);\n}\n", "bug_type": null, "idx": 885}
{"project": "Pidgin", "target": 0, "func": "void gnt_entry_add_suggest(GntEntry *entry, const char *text)\n{\n\tGList *find;\n\tif (!text || !*text)\n\t\treturn;\n\tfind = g_list_find_custom(entry->suggests, text, (GCompareFunc)g_utf8_collate);\n\tif (find)\n\t\treturn;\n\tentry->suggests = g_list_append(entry->suggests, g_strdup(text));\n}\n", "bug_type": null, "idx": 886}
{"project": "Pidgin", "target": 0, "func": "static void oscar_ssi_editcomment(struct name_data *data, const char *text) {\n\tPurpleConnection *gc;\n\tPurpleAccount *account;\n\tOscarData *od;\n\tPurpleBuddy *b;\n\tPurpleGroup *g;\n\tgc = data->gc;\n\tod = purple_connection_get_protocol_data(gc);\n\taccount = purple_connection_get_account(gc);\n\tb = purple_find_buddy(account, data->name);\n\tif (b == NULL) {\n\t\toscar_free_name_data(data);\n\t\treturn;\n\t}\n\tg = purple_buddy_get_group(b);\n\tif (g == NULL) {\n\t\toscar_free_name_data(data);\n\t\treturn;\n\t}\n\taim_ssi_editcomment(od, purple_group_get_name(g), data->name, text);\n\toscar_free_name_data(data);\n}\n", "bug_type": null, "idx": 887}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ntoggle_tag_selection(GntBindable *bind, GList *null)\n{\n\tGntFileSel *sel = GNT_FILE_SEL(bind);\n\tchar *str;\n\tGList *find;\n\tchar *file;\n\tGntWidget *tree;\n\tif (!sel->multiselect)\n\t\treturn FALSE;\n\ttree = sel->dirsonly ? sel->dirs : sel->files;\n\tif (!gnt_widget_has_focus(tree) ||\n\t\t\tgnt_tree_is_searching(GNT_TREE(tree)))\n\t\treturn FALSE;\n\tfile = gnt_tree_get_selection_data(GNT_TREE(tree));\n\tstr = gnt_file_sel_get_selected_file(sel);\n\tif ((find = g_list_find_custom(sel->tags, str, (GCompareFunc)g_utf8_collate)) != NULL) {\n\t\tg_free(find->data);\n\t\tsel->tags = g_list_delete_link(sel->tags, find);\n\t\tgnt_tree_set_row_flags(GNT_TREE(tree), file, GNT_TEXT_FLAG_NORMAL);\n\t\tg_free(str);\n\t} else {\n\t\tsel->tags = g_list_prepend(sel->tags, str);\n\t\tgnt_tree_set_row_flags(GNT_TREE(tree), file, GNT_TEXT_FLAG_BOLD);\n\t}\n\tgnt_bindable_perform_action_named(GNT_BINDABLE(tree), \"move-down\", NULL);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 888}
{"project": "Pidgin", "target": 0, "func": "void gnt_entry_remove_suggest(GntEntry *entry, const char *text)\n{\n\tGList *find = g_list_find_custom(entry->suggests, text, (GCompareFunc)g_utf8_collate);\n\tif (find)\n\t{\n\t\tg_free(find->data);\n\t\tentry->suggests = g_list_delete_link(entry->suggests, find);\n\t}\n}\n", "bug_type": null, "idx": 889}
{"project": "Pidgin", "target": 0, "func": "static void\nfree_pref_value(struct purple_pref *pref)\n{\n\tswitch(pref->type) {\n\t\tcase PURPLE_PREF_BOOLEAN:\n\t\t\tpref->value.boolean = FALSE;\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_INT:\n\t\t\tpref->value.integer = 0;\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_STRING:\n\t\tcase PURPLE_PREF_PATH:\n\t\t\tg_free(pref->value.string);\n\t\t\tpref->value.string = NULL;\n\t\t\tbreak;\n\t\tcase PURPLE_PREF_STRING_LIST:\n\t\tcase PURPLE_PREF_PATH_LIST:\n\t\t\t{\n\t\t\t\tg_list_foreach(pref->value.stringlist, (GFunc)g_free, NULL);\n\t\t\t\tg_list_free(pref->value.stringlist);\n\t\t\t} break;\n\t\tcase PURPLE_PREF_NONE:\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 890}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_theme_set_property(GObject *obj, guint param_id, const GValue *value,\n\t\tGParamSpec *psec)\n{\n\tPurpleTheme *theme = PURPLE_THEME(obj);\n\tswitch (param_id) {\n\t\tcase PROP_NAME:\n\t\t\tpurple_theme_set_name(theme, g_value_get_string(value));\n\t\t\tbreak;\n\t\tcase PROP_DESCRIPTION:\n\t\t\tpurple_theme_set_description(theme, g_value_get_string(value));\n\t\t\tbreak;\n\t\tcase PROP_AUTHOR:\n\t\t\tpurple_theme_set_author(theme, g_value_get_string(value));\n\t\t\tbreak;\n\t\tcase PROP_TYPE:\n\t\t\tpurple_theme_set_type_string(theme, g_value_get_string(value));\n\t\t\tbreak;\n\t\tcase PROP_DIR:\n\t\t\tpurple_theme_set_dir(theme, g_value_get_string(value));\n\t\t\tbreak;\n\t\tcase PROP_IMAGE:\n\t\t\tpurple_theme_set_image(theme, g_value_get_string(value));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID(obj, param_id, psec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 891}
{"project": "Pidgin", "target": 0, "func": "void\ngstroke_set_mouse_button(gint button)\n{\n\tmouse_button = button;\n}\n", "bug_type": null, "idx": 892}
{"project": "Pidgin", "target": 0, "func": "PurpleMediaCandidate *\npurple_media_candidate_copy(PurpleMediaCandidate *candidate)\n{\n\tPurpleMediaCandidatePrivate *priv;\n\tPurpleMediaCandidate *new_candidate;\n\tif (candidate == NULL)\n\t\treturn NULL;\n\tpriv = PURPLE_MEDIA_CANDIDATE_GET_PRIVATE(candidate);\n\tnew_candidate = purple_media_candidate_new(priv->foundation,\n\t\t\tpriv->component_id, priv->type, priv->proto,\n\t\t\tpriv->ip, priv->port);\n\tg_object_set(new_candidate,\n\t\t\t\"base-ip\", priv->base_ip,\n\t\t\t\"base-port\", priv->base_port,\n\t\t\t\"priority\", priv->priority,\n\t\t\t\"username\", priv->username,\n\t\t\t\"password\", priv->password,\n\t\t\t\"ttl\", priv->ttl, NULL);\n\treturn new_candidate;\n}\n", "bug_type": null, "idx": 893}
{"project": "Pidgin", "target": 0, "func": " */\nuint64_t gg_tvbuff_read_packed_uint(gg_tvbuff_t *tvb)\n{\n\tuint64_t val = 0;\n\tint i, val_len = 0;\n\tif (!gg_tvbuff_is_valid(tvb))\n\t\treturn 0;\n\twhile (gg_tvbuff_have_remaining(tvb, 1)) {\n\t\tval_len++;\n\t\tif (!(gg_tvbuff_read_uint8(tvb) & 0x80))\n\t\t\tbreak;\n\t}\n\tif (!gg_tvbuff_is_valid(tvb)) {\n\t\tgg_debug(GG_DEBUG_WARNING,\n\t\t\t\"// gg_tvbuff_read_packed_uint() failed\\n\");\n\t\treturn 0;\n\t}\n\tif (val_len > 9) {\n\t\tgg_debug(GG_DEBUG_WARNING, \"// gg_tvbuff_read_packed_uint() \"\n\t\t\t\"packed uint size too big: %d\\n\", val_len);\n\t\ttvb->valid = 0;\n\t\treturn 0;\n\t}\n\tfor (i = 1; i <= val_len; i++) {\n\t\tuint64_t old_val = val;\n\t\tval <<= 7;\n\t\tif (old_val != (val >> 7)) {\n\t\t\tgg_debug(GG_DEBUG_WARNING,\n\t\t\t\t\"// gg_tvbuff_read_packed_uint() overflow\\n\");\n\t\t\ttvb->valid = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tval |= (uint8_t)(tvb->buffer[tvb->offset - i] & ~0x80);\n\t}\n\treturn val;\n}\n", "bug_type": null, "idx": 894}
{"project": "Pidgin", "target": 0, "func": "static void\ndnd_hints_init(void)\n{\n\tstatic gboolean done = FALSE;\n\tgint i;\n\tif (done)\n\t\treturn;\n\tdone = TRUE;\n\tfor (i = 0; hint_windows[i].filename != NULL; i++) {\n\t\tgchar *fname;\n\t\tfname = g_build_filename(DATADIR, \"pixmaps\", \"pidgin\",\n\t\t\t\t\t\t\t\t hint_windows[i].filename, NULL);\n\t\thint_windows[i].widget = dnd_hints_init_window(fname);\n\t\tg_free(fname);\n\t}\n}\n", "bug_type": null, "idx": 895}
{"project": "Pidgin", "target": 0, "func": "void\njabber_iq_set_callback(JabberIq *iq, JabberIqCallback *callback, gpointer data)\n{\n\tiq->callback = callback;\n\tiq->callback_data = data;\n}\n", "bug_type": null, "idx": 896}
{"project": "Pidgin", "target": 0, "func": "PurpleAccountUiOps *\npidgin_accounts_get_ui_ops(void)\n{\n\treturn &ui_ops;\n}\n", "bug_type": null, "idx": 897}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-status-changed\",\n\t\t\t\t\t\tplugin, PURPLE_CALLBACK(iconify_windows), NULL);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 898}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_unload(PurplePlugin *plugin)\n{\n\tPurpleConversation *conv;\n\tPidginConversation *gtkconv;\n\tGList *l;\n\tfor (l = purple_get_conversations(); l != NULL; l = l->next) {\n\t\tconv = (PurpleConversation *)l->data;\n\t\tif (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))\n\t\t\tcontinue;\n\t\tgtkconv = PIDGIN_CONVERSATION(conv);\n\t\tgstroke_cleanup(gtkconv->imhtml);\n\t\tgstroke_disable(gtkconv->imhtml);\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 899}
{"project": "Pidgin", "target": 0, "func": "static const char *log_get_date(PurpleLog *log)\n{\n\tif (log->tm)\n\t\treturn purple_date_format_full(log->tm);\n\telse\n\t\treturn purple_date_format_full(localtime(&log->time));\n}\n", "bug_type": null, "idx": 900}
{"project": "Pidgin", "target": 0, "func": "static gboolean pidgin_blist_drag_motion_cb(GtkWidget *tv, GdkDragContext *drag_context,\n\t\t\t\t\t      gint x, gint y, guint time, gpointer user_data)\n{\n\tGtkTreePath *path;\n\tint delay;\n\tGdkRectangle rect;\n\t\n\tdelay = 900;\n\tif (gtkblist->drag_timeout) {\n\t\tif ((y > gtkblist->tip_rect.y) && ((y - gtkblist->tip_rect.height) < gtkblist->tip_rect.y))\n\t\t\treturn FALSE;\n\t\t\n\t\tg_source_remove(gtkblist->drag_timeout);\n\t}\n\tgtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), x, y, &path, NULL, NULL, NULL);\n\tgtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, &rect);\n\tif (path)\n\t\tgtk_tree_path_free(path);\n\t\n\tif (y < rect.y + (rect.height / 3) ||\n\t    y > rect.y + (2 * (rect.height /3)))\n\t\treturn FALSE;\n\trect.height = rect.height / 3;\n\trect.y += rect.height;\n\tgtkblist->tip_rect = rect;\n\tgtkblist->drag_timeout = g_timeout_add(delay, (GSourceFunc)pidgin_blist_expand_timeout, tv);\n\tif (gtkblist->mouseover_contact) {\n\t\tif ((y < gtkblist->contact_rect.y) || ((y - gtkblist->contact_rect.height) > gtkblist->contact_rect.y)) {\n\t\t\tpidgin_blist_collapse_contact_cb(NULL, gtkblist->mouseover_contact);\n\t\t\tgtkblist->mouseover_contact = NULL;\n\t\t}\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 901}
{"project": "Pidgin", "target": 0, "func": "#endif\nvoid jabber_si_parse(JabberStream *js, const char *from, JabberIqType type,\n                     const char *id, xmlnode *si)\n{\n\tJabberSIXfer *jsx;\n\tPurpleXfer *xfer;\n\txmlnode *file, *feature, *x, *field, *option, *value;\n#if ENABLE_FT_THUMBNAILS\n\txmlnode *thumbnail;\n#endif\n\tconst char *stream_id, *filename, *filesize_c, *profile;\n\tguint64 filesize_64 = 0;\n\tsize_t filesize = 0;\n\tif(!(profile = xmlnode_get_attrib(si, \"profile\")) ||\n\t\t\tstrcmp(profile, NS_SI_FILE_TRANSFER))\n\t\treturn;\n\tif(!(stream_id = xmlnode_get_attrib(si, \"id\")))\n\t\treturn;\n\tif(!(file = xmlnode_get_child(si, \"file\")))\n\t\treturn;\n\tif(!(filename = xmlnode_get_attrib(file, \"name\")))\n\t\treturn;\n\tif((filesize_c = xmlnode_get_attrib(file, \"size\")))\n\t\tfilesize_64 = g_ascii_strtoull(filesize_c, NULL, 10);\n#ifndef __COVERITY__\n\t\n\tif (filesize_64 > G_MAXSIZE) {\n\t\t\n\t\tpurple_debug_warning(\"jabber\", \"Unable to transfer file (too large)\"\n\t\t                     \" -- see #8477 for more details.\");\n\t\treturn;\n\t}\n#endif\n\tfilesize = filesize_64;\n\tif(!(feature = xmlnode_get_child(si, \"feature\")))\n\t\treturn;\n\tif(!(x = xmlnode_get_child_with_namespace(feature, \"x\", \"jabber:x:data\")))\n\t\treturn;\n\tif(!from)\n\t\treturn;\n\t\n\tif(jabber_si_xfer_find(js, stream_id, from) != NULL)\n\t\treturn;\n\tjsx = g_new0(JabberSIXfer, 1);\n\tjsx->local_streamhost_fd = -1;\n\tjsx->ibb_session = NULL;\n\tfor(field = xmlnode_get_child(x, \"field\"); field; field = xmlnode_get_next_twin(field)) {\n\t\tconst char *var = xmlnode_get_attrib(field, \"var\");\n\t\tif(var && !strcmp(var, \"stream-method\")) {\n\t\t\tfor(option = xmlnode_get_child(field, \"option\"); option;\n\t\t\t\t\toption = xmlnode_get_next_twin(option)) {\n\t\t\t\tif((value = xmlnode_get_child(option, \"value\"))) {\n\t\t\t\t\tchar *val;\n\t\t\t\t\tif((val = xmlnode_get_data(value))) {\n\t\t\t\t\t\tif(!strcmp(val, NS_BYTESTREAMS)) {\n\t\t\t\t\t\t\tjsx->stream_method |= STREAM_METHOD_BYTESTREAMS;\n\t\t\t\t\t\t} else if(!strcmp(val, NS_IBB)) {\n\t\t\t\t\t\t\tjsx->stream_method |= STREAM_METHOD_IBB;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tg_free(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(jsx->stream_method == STREAM_METHOD_UNKNOWN) {\n\t\tg_free(jsx);\n\t\treturn;\n\t}\n\tjsx->js = js;\n\tjsx->stream_id = g_strdup(stream_id);\n\tjsx->iq_id = g_strdup(id);\n\txfer = purple_xfer_new(js->gc->account, PURPLE_XFER_RECEIVE, from);\n\tg_return_if_fail(xfer != NULL);\n\txfer->data = jsx;\n\tpurple_xfer_set_filename(xfer, filename);\n\tif(filesize > 0)\n\t\tpurple_xfer_set_size(xfer, filesize);\n\tpurple_xfer_set_init_fnc(xfer, jabber_si_xfer_init);\n\tpurple_xfer_set_request_denied_fnc(xfer, jabber_si_xfer_request_denied);\n\tpurple_xfer_set_cancel_recv_fnc(xfer, jabber_si_xfer_cancel_recv);\n\tpurple_xfer_set_end_fnc(xfer, jabber_si_xfer_end);\n\tjs->file_transfers = g_list_append(js->file_transfers, xfer);\n#if ENABLE_FT_THUMBNAILS\n\t\n\tif ((thumbnail = xmlnode_get_child_with_namespace(file, \"thumbnail\",\n\t\tNS_THUMBS))) {\n\t\tconst char *cid = xmlnode_get_attrib(thumbnail, \"cid\");\n\t\tif (cid) {\n\t\t\tjabber_data_request(js, cid, purple_xfer_get_remote_user(xfer),\n\t\t\t    NULL, TRUE, jabber_si_thumbnail_cb, xfer);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\tpurple_xfer_request(xfer);\n}\n", "bug_type": null, "idx": 902}
{"project": "Pidgin", "target": 0, "func": "static void\nappsrc_need_data (GstAppSrc *appsrc, guint length, gpointer user_data)\n{\n\tPurpleMediaAppDataInfo *info = user_data;\n\tPurpleMediaManager *manager = purple_media_manager_get ();\n\tg_mutex_lock (&manager->priv->appdata_mutex);\n\tif (!info->writable) {\n\t\tinfo->writable = TRUE;\n\t\t\n\t\tif (info->connected)\n\t\t\tcall_appsrc_writable_locked (info);\n\t}\n\tg_mutex_unlock (&manager->priv->appdata_mutex);\n}\n", "bug_type": null, "idx": 903}
{"project": "Pidgin", "target": 0, "func": "static gboolean pending_zloc(zephyr_account *zephyr, const char *who)\n{\n\tGList *curr;\n\tfor (curr = zephyr->pending_zloc_names; curr != NULL; curr = curr->next) {\n\t\tchar* normalized_who = local_zephyr_normalize(zephyr,who);\n\t\tif (!g_ascii_strcasecmp(normalized_who, (char *)curr->data)) {\n\t\t\tg_free((char *)curr->data);\n\t\t\tzephyr->pending_zloc_names = g_list_remove(zephyr->pending_zloc_names, curr->data);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 904}
{"project": "Pidgin", "target": 0, "func": "int tcl_cmd_buddy(ClientData unused, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])\n{\n\tTcl_Obj *list, *tclgroup, *tclgrouplist, *tclcontact, *tclcontactlist, *tclbud, **elems, *result;\n\tconst char *cmds[] = { \"alias\", \"handle\", \"info\", \"list\", NULL };\n\tenum { CMD_BUDDY_ALIAS, CMD_BUDDY_HANDLE, CMD_BUDDY_INFO, CMD_BUDDY_LIST } cmd;\n\tPurpleBlistNodeType type;\n\tPurpleBlistNode *node, *gnode, *bnode;\n\tPurpleAccount *account;\n\tPurpleBuddy *bud;\n\tPurpleChat *cnode;\n\tint error, all = 0, count;\n\tif (objc < 2) {\n\t\tTcl_WrongNumArgs(interp, 1, objv, \"subcommand ?args?\");\n\t\treturn TCL_ERROR;\n\t}\n\tif ((error = Tcl_GetIndexFromObj(interp, objv[1], cmds, \"subcommand\", 0, (int *)&cmd)) != TCL_OK)\n\t\treturn error;\n\tswitch (cmd) {\n\tcase CMD_BUDDY_ALIAS:\n\t\tif (objc != 3) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"buddy\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif ((error = Tcl_ListObjGetElements(interp, objv[2], &count, &elems)) != TCL_OK)\n\t\t\treturn error;\n\t\tif ((node = tcl_list_to_buddy(interp, count, elems)) == NULL)\n\t\t\treturn TCL_ERROR;\n\t\ttype = purple_blist_node_get_type(node);\n\t\tif (type == PURPLE_BLIST_CHAT_NODE)\n\t\t\tTcl_SetObjResult(interp,\n\t\t\t\t\t Tcl_NewStringObj(purple_chat_get_name((PurpleChat *)node), -1));\n\t\telse if (type == PURPLE_BLIST_BUDDY_NODE)\n\t\t\tTcl_SetObjResult(interp,\n                                         Tcl_NewStringObj((char *)purple_buddy_get_alias((PurpleBuddy *)node), -1));\n\t\treturn TCL_OK;\n\t\tbreak;\n\tcase CMD_BUDDY_HANDLE:\n\t\tif (objc != 2) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tTcl_SetObjResult(interp,\n\t\t\t\t purple_tcl_ref_new(PurpleTclRefHandle,\n\t\t\t\t\t\t    purple_blist_get_handle()));\n\t\tbreak;\n\tcase CMD_BUDDY_INFO:\n\t\tif (objc != 3 && objc != 4) {\n\t\t\tTcl_WrongNumArgs(interp, 2, objv, \"( buddy | account username )\");\n\t\t\treturn TCL_ERROR;\n\t\t}\n\t\tif (objc == 3) {\n\t\t\tif ((error = Tcl_ListObjGetElements(interp, objv[2], &count, &elems)) != TCL_OK)\n\t\t\t\treturn error;\n\t\t\tif (count < 3) {\n\t\t\t\tTcl_SetObjResult(interp,\n\t\t\t\t\t\t Tcl_NewStringObj(\"buddy too short\", -1));\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t\tif (strcmp(\"buddy\", Tcl_GetString(elems[0]))) {\n\t\t\t\tTcl_SetObjResult(interp,\n\t\t\t\t\t\t Tcl_NewStringObj(\"invalid buddy\", -1));\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t\tif ((account = tcl_validate_account(elems[2], interp)) == NULL)\n\t\t\t\treturn TCL_ERROR;\n\t\t\tserv_get_info(purple_account_get_connection(account), Tcl_GetString(elems[1]));\n\t\t} else {\n\t\t\tif ((account = tcl_validate_account(objv[2], interp)) == NULL)\n\t\t\t\treturn TCL_ERROR;\n\t\t\tserv_get_info(purple_account_get_connection(account), Tcl_GetString(objv[3]));\n\t\t}\n\t\tbreak;\n\tcase CMD_BUDDY_LIST:\n\t\tif (objc == 3) {\n\t\t\tif (!strcmp(\"-all\", Tcl_GetString(objv[2]))) {\n\t\t\t\tall = 1;\n\t\t\t} else {\n\t\t\t\tresult = Tcl_NewStringObj(\"\",-1);\n\t\t\t\tTcl_AppendStringsToObj(result, \"unknown option: \", Tcl_GetString(objv[2]), NULL);\n\t\t\t\tTcl_SetObjResult(interp,result);\n\t\t\t\treturn TCL_ERROR;\n\t\t\t}\n\t\t}\n\t\tlist = Tcl_NewListObj(0, NULL);\n\t\tfor (gnode = purple_blist_get_root(); gnode != NULL; gnode = purple_blist_node_get_sibling_next(gnode)) {\n\t\t\ttclgroup = Tcl_NewListObj(0, NULL);\n\t\t\tTcl_ListObjAppendElement(interp, tclgroup, Tcl_NewStringObj(\"group\", -1));\n\t\t\tTcl_ListObjAppendElement(interp, tclgroup,\n\t\t\t\t\t\t Tcl_NewStringObj(purple_group_get_name((PurpleGroup *)gnode), -1));\n\t\t\ttclgrouplist = Tcl_NewListObj(0, NULL);\n\t\t\tfor (node = purple_blist_node_get_first_child(gnode); node != NULL; node = purple_blist_node_get_sibling_next(node)) {\n\t\t\t\tPurpleAccount *account;\n\t\t\t\ttype = purple_blist_node_get_type(node);\n\t\t\t\tswitch (type) {\n\t\t\t\tcase PURPLE_BLIST_CONTACT_NODE:\n\t\t\t\t\ttclcontact = Tcl_NewListObj(0, NULL);\n\t\t\t\t\tTcl_IncrRefCount(tclcontact);\n\t\t\t\t\tTcl_ListObjAppendElement(interp, tclcontact, Tcl_NewStringObj(\"contact\", -1));\n\t\t\t\t\ttclcontactlist = Tcl_NewListObj(0, NULL);\n\t\t\t\t\tTcl_IncrRefCount(tclcontactlist);\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (bnode = purple_blist_node_get_first_child(node); bnode != NULL; bnode = purple_blist_node_get_sibling_next(bnode)) {\n\t\t\t\t\t\tif (purple_blist_node_get_type(bnode) != PURPLE_BLIST_BUDDY_NODE)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tbud = (PurpleBuddy *)bnode;\n\t\t\t\t\t\taccount = purple_buddy_get_account(bud);\n\t\t\t\t\t\tif (!all && !purple_account_is_connected(account))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\ttclbud = Tcl_NewListObj(0, NULL);\n\t\t\t\t\t\tTcl_ListObjAppendElement(interp, tclbud, Tcl_NewStringObj(\"buddy\", -1));\n\t\t\t\t\t\tTcl_ListObjAppendElement(interp, tclbud, Tcl_NewStringObj(purple_buddy_get_name(bud), -1));\n\t\t\t\t\t\tTcl_ListObjAppendElement(interp, tclbud, purple_tcl_ref_new(PurpleTclRefAccount, account));\n\t\t\t\t\t\tTcl_ListObjAppendElement(interp, tclcontactlist, tclbud);\n\t\t\t\t\t}\n\t\t\t\t\tif (count) {\n\t\t\t\t\t\tTcl_ListObjAppendElement(interp, tclcontact, tclcontactlist);\n\t\t\t\t\t\tTcl_ListObjAppendElement(interp, tclgrouplist, tclcontact);\n\t\t\t\t\t}\n\t\t\t\t\tTcl_DecrRefCount(tclcontact);\n\t\t\t\t\tTcl_DecrRefCount(tclcontactlist);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PURPLE_BLIST_CHAT_NODE:\n\t\t\t\t\tcnode = (PurpleChat *)node;\n\t\t\t\t\taccount = purple_chat_get_account(cnode);\n\t\t\t\t\tif (!all && !purple_account_is_connected(account))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttclbud = Tcl_NewListObj(0, NULL);\n\t\t\t\t\tTcl_ListObjAppendElement(interp, tclbud, Tcl_NewStringObj(\"chat\", -1));\n\t\t\t\t\tTcl_ListObjAppendElement(interp, tclbud, Tcl_NewStringObj(purple_chat_get_name(cnode), -1));\n\t\t\t\t\tTcl_ListObjAppendElement(interp, tclbud, purple_tcl_ref_new(PurpleTclRefAccount, account));\n\t\t\t\t\tTcl_ListObjAppendElement(interp, tclgrouplist, tclbud);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpurple_debug(PURPLE_DEBUG_WARNING, \"tcl\", \"Unexpected buddy type %d\", type);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tTcl_ListObjAppendElement(interp, tclgroup, tclgrouplist);\n\t\t\tTcl_ListObjAppendElement(interp, list, tclgroup);\n\t\t}\n\t\tTcl_SetObjResult(interp, list);\n\t\tbreak;\n\t}\n\treturn TCL_OK;\n}\n", "bug_type": null, "idx": 905}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_smiley_themes_remove_non_existing(void)\n{\n\tstatic struct smiley_theme *theme = NULL;\n\tGSList *iter = NULL;\n\tif (!smiley_themes) return ;\n\tfor (iter = smiley_themes ; iter ; iter = iter->next) {\n\t\ttheme = ((struct smiley_theme *)(iter->data));\n\t\tif (!g_file_test(theme->path, G_FILE_TEST_EXISTS)) {\n\t\t\tif (theme == current_smiley_theme)\n\t\t\t\tcurrent_smiley_theme = ((struct smiley_theme *)(NULL == iter->next ? NULL : iter->next->data));\n\t\t\tpidgin_themes_destroy_smiley_theme(theme);\n\t\t\titer->data = NULL;\n\t\t}\n\t}\n\t\n\tsmiley_themes = g_slist_remove_all(smiley_themes, NULL);\n\tif (!current_smiley_theme && smiley_themes) {\n\t\tstruct smiley_theme *smile = g_slist_last(smiley_themes)->data;\n\t\tpidgin_themes_load_smiley_theme(smile->path, TRUE);\n\t}\n}\n", "bug_type": null, "idx": 906}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nbutton_activate(GntBindable *bind, GList *null)\n{\n\tgnt_widget_activate(GNT_WIDGET(bind));\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 907}
{"project": "Pidgin", "target": 0, "func": "void silcpurple_wb_set_dimensions(PurpleWhiteboard *wb, int width, int height)\n{\n\tSilcPurpleWb wbs = wb->proto_data;\n\twbs->width = width > SILCPURPLE_WB_WIDTH_MAX ? SILCPURPLE_WB_WIDTH_MAX :\n\t\t\twidth;\n\twbs->height = height > SILCPURPLE_WB_HEIGHT_MAX ? SILCPURPLE_WB_HEIGHT_MAX :\n\t\t\theight;\n\t\n\tpurple_whiteboard_set_dimensions(wb, wbs->width, wbs->height);\n}\n", "bug_type": null, "idx": 908}
{"project": "Pidgin", "target": 0, "func": "static void\nour_logging_blows(PurpleLogSet *set, PurpleLogSet *setagain, GList **list)\n{\n\t\n\tif (set->type != PURPLE_LOG_IM)\n\t\treturn;\n\t*list = g_list_concat(purple_log_get_logs(PURPLE_LOG_IM, set->name, set->account), *list);\n}\n", "bug_type": null, "idx": 909}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_clear_settings(PurpleAccount *account)\n{\n\tg_return_if_fail(account != NULL);\n\tg_hash_table_destroy(account->settings);\n\taccount->settings = g_hash_table_new_full(g_str_hash, g_str_equal,\n\t\t\t\t\t\t\t\t\t\t\t  g_free, delete_setting);\n}\n", "bug_type": null, "idx": 910}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_dialogs_alias_chat(PurpleChat *chat)\n{\n\tg_return_if_fail(chat != NULL);\n\tpurple_request_input(NULL, _(\"Alias Chat\"), NULL,\n\t\t\t\t\t   _(\"Enter an alias for this chat.\"),\n\t\t\t\t\t   chat->alias, FALSE, FALSE, NULL,\n\t\t\t\t\t   _(\"Alias\"), G_CALLBACK(pidgin_dialogs_alias_chat_cb),\n\t\t\t\t\t   _(\"Cancel\"), NULL,\n\t\t\t\t\t   chat->account, NULL, NULL,\n\t\t\t\t\t   chat);\n}\n", "bug_type": null, "idx": 911}
{"project": "Pidgin", "target": 0, "func": "static void\nssl_connection_established_cb(gpointer data, PurpleSslConnection *psc,\n                              PurpleInputCondition cond)\n{\n\tPurpleHTTPConnection *conn = data;\n\tpurple_ssl_input_add(psc, http_connection_read_cb_ssl, conn);\n\tconnection_common_established_cb(conn);\n}\n", "bug_type": null, "idx": 912}
{"project": "Pidgin", "target": 0, "func": "const gchar *\npurple_plugin_get_author(const PurplePlugin *plugin) {\n\tg_return_val_if_fail(plugin, NULL);\n\tg_return_val_if_fail(plugin->info, NULL);\n\treturn _(plugin->info->author);\n}\n", "bug_type": null, "idx": 913}
{"project": "Pidgin", "target": 0, "func": " */\nvoid gg_remind_free(struct gg_http *h)\n{\n\treturn gg_pubdir_free(h);\n}\n", "bug_type": null, "idx": 914}
{"project": "Pidgin", "target": 0, "func": "void serv_got_typing(PurpleConnection *gc, const char *name, int timeout,\n\t\t\t\t\t PurpleTypingState state) {\n\tPurpleConversation *conv;\n\tPurpleConvIm *im = NULL;\n\tconv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, name, gc->account);\n\tif (conv != NULL) {\n\t\tim = PURPLE_CONV_IM(conv);\n\t\tpurple_conv_im_set_typing_state(im, state);\n\t} else {\n\t\tswitch (state)\n\t\t{\n\t\t\tcase PURPLE_TYPING:\n\t\t\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\t\t\t\t\t   \"buddy-typing\", gc->account, name);\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_TYPED:\n\t\t\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\t\t\t\t\t   \"buddy-typed\", gc->account, name);\n\t\t\t\tbreak;\n\t\t\tcase PURPLE_NOT_TYPING:\n\t\t\t\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\t\t\t\t\t   \"buddy-typing-stopped\", gc->account, name);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (conv != NULL && timeout > 0)\n\t\tpurple_conv_im_start_typing_timeout(im, timeout);\n}\n", "bug_type": null, "idx": 915}
{"project": "Pidgin", "target": 0, "func": "static char *nullprpl_status_text(PurpleBuddy *buddy) {\n  purple_debug_info(\"nullprpl\", \"getting %s's status text for %s\\n\",\n                    buddy->name, buddy->account->username);\n  if (purple_find_buddy(buddy->account, buddy->name)) {\n    PurplePresence *presence = purple_buddy_get_presence(buddy);\n    PurpleStatus *status = purple_presence_get_active_status(presence);\n    const char *name = purple_status_get_name(status);\n    const char *message = purple_status_get_attr_string(status, \"message\");\n    char *text;\n    if (message && strlen(message) > 0)\n      text = g_strdup_printf(\"%s: %s\", name, message);\n    else\n      text = g_strdup(name);\n    purple_debug_info(\"nullprpl\", \"%s's status text is %s\\n\", buddy->name, text);\n    return text;\n  } else {\n    purple_debug_info(\"nullprpl\", \"...but %s is not logged in\\n\", buddy->name);\n    return g_strdup(\"Not logged in\");\n  }\n}\n}\nstatic char *nullprpl_status_text(PurpleBuddy *buddy) {\n  purple_debug_info(\"nullprpl\", \"getting %s's status text for %s\\n\",\n                    buddy->name, buddy->account->username);\n  if (purple_find_buddy(buddy->account, buddy->name)) {\n    PurplePresence *presence = purple_buddy_get_presence(buddy);\n    PurpleStatus *status = purple_presence_get_active_status(presence);\n    const char *name = purple_status_get_name(status);\n    const char *message = purple_status_get_attr_string(status, \"message\");\n    char *text;\n    if (message && strlen(message) > 0)\n      text = g_strdup_printf(\"%s: %s\", name, message);\n    else\n      text = g_strdup(name);\n    purple_debug_info(\"nullprpl\", \"%s's status text is %s\\n\", buddy->name, text);\n    return text;\n  } else {\n    purple_debug_info(\"nullprpl\", \"...but %s is not logged in\\n\", buddy->name);\n    return g_strdup(\"Not logged in\");\n  }\n}\n", "bug_type": null, "idx": 916}
{"project": "Pidgin", "target": 0, "func": "static gboolean\naction_focus_next(GntBindable *bindable, GList *null)\n{\n\treturn box_focus_change(GNT_BOX(bindable), TRUE);\n}\n", "bug_type": null, "idx": 917}
{"project": "Pidgin", "target": 0, "func": "static void\nui_setting_to_xmlnode(gpointer key, gpointer value, gpointer user_data)\n{\n\tconst char *ui;\n\tGHashTable *table;\n\txmlnode *node, *child;\n\tui    = (const char *)key;\n\ttable = (GHashTable *)value;\n\tnode  = (xmlnode *)user_data;\n\tif (g_hash_table_size(table) > 0)\n\t{\n\t\tchild = xmlnode_new_child(node, \"settings\");\n\t\txmlnode_set_attrib(child, \"ui\", ui);\n\t\tg_hash_table_foreach(table, setting_to_xmlnode, child);\n\t}\n}\n", "bug_type": null, "idx": 918}
{"project": "Pidgin", "target": 0, "func": " */\nstatic GList *nullprpl_actions(PurplePlugin *plugin, gpointer context)\n{\n  PurplePluginAction *action = purple_plugin_action_new(\n    _(\"Set User Info...\"), nullprpl_input_user_info);\n  return g_list_append(NULL, action);\n}\n", "bug_type": null, "idx": 919}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nregex_show_all_cb(GtkTreeModel *m, GtkTreePath *p, GtkTreeIter *iter,\n\t\t\t\t  gpointer data)\n{\n\tDebugWindow *win = (DebugWindow *)data;\n\tgchar *text;\n\tPurpleDebugLevel level;\n\tgtk_tree_model_get(m, iter, 0, &text, 1, &level, -1);\n\tif (level >= (PurpleDebugLevel)purple_prefs_get_int(PIDGIN_PREFS_ROOT \"/debug/filterlevel\"))\n\t\tgtk_imhtml_append_text(GTK_IMHTML(win->text), text, 0);\n\tg_free(text);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 920}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_chat_ulimit_cb(SilcPurpleChatInput s, const char *limit)\n{\n\tSilcChannelEntry channel;\n\tint ulimit = 0;\n\tchannel = silc_client_get_channel(s->sg->client, s->sg->conn,\n\t\t\t\t\t  (char *)s->channel);\n\tif (!channel)\n\t\treturn;\n\tif (limit)\n\t\tulimit = atoi(limit);\n\tif (!limit || !(*limit) || *limit == '0') {\n\t\tif (limit && ulimit == channel->user_limit) {\n\t\t\tsilc_free(s);\n\t\t\treturn;\n\t\t}\n\t\tsilc_client_command_call(s->sg->client, s->sg->conn, NULL, \"CMODE\",\n\t\t\t\t\t s->channel, \"-l\", NULL);\n\t\tsilc_free(s);\n\t\treturn;\n\t}\n\tif (ulimit == channel->user_limit) {\n\t\tsilc_free(s);\n\t\treturn;\n\t}\n\t\n\tsilc_client_command_call(s->sg->client, s->sg->conn, NULL, \"CMODE\",\n\t\t\t\t s->channel, \"+l\", limit, NULL);\n\tsilc_free(s);\n}\n", "bug_type": null, "idx": 921}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nssl_init(void)\n{\n\tPurplePlugin *plugin;\n\tPurpleSslOps *ops;\n\tif (_ssl_initialized)\n\t\treturn FALSE;\n\tplugin = purple_plugins_find_with_id(\"core-ssl\");\n\tif (plugin != NULL && !purple_plugin_is_loaded(plugin))\n\t\tpurple_plugin_load(plugin);\n\tops = purple_ssl_get_ops();\n\tif ((ops == NULL) || (ops->init == NULL) || (ops->uninit == NULL) ||\n\t\t(ops->connectfunc == NULL) || (ops->close == NULL) ||\n\t\t(ops->read == NULL) || (ops->write == NULL))\n\t{\n\t\treturn FALSE;\n\t}\n\treturn (_ssl_initialized = ops->init());\n}\nvoid\npurple_ssl_init(void)\n{\n\t\n\tif (!ssl_init()) {\n\t\tpurple_debug_error(\"sslconn\", \"Unable to initialize SSL.\\n\");\n\t}\n}\n", "bug_type": null, "idx": 922}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_box_draw(GntWidget *widget)\n{\n\tGntBox *box = GNT_BOX(widget);\n\tif (box->focus == NULL && widget->parent == NULL)\n\t\tg_list_foreach(box->list, add_to_focus, box);\n\tg_list_foreach(box->list, (GFunc)gnt_widget_draw, NULL);\n\tif (box->title && !GNT_WIDGET_IS_FLAG_SET(widget, GNT_WIDGET_NO_BORDER))\n\t{\n\t\tint pos, right;\n\t\tchar *title = g_strdup(box->title);\n\t\tget_title_thingies(box, title, &pos, &right);\n\t\tif (gnt_widget_has_focus(widget))\n\t\t\twbkgdset(widget->window, '\\0' | gnt_color_pair(GNT_COLOR_TITLE));\n\t\telse\n\t\t\twbkgdset(widget->window, '\\0' | gnt_color_pair(GNT_COLOR_TITLE_D));\n\t\tmvwaddch(widget->window, 0, pos-1, ACS_RTEE | gnt_color_pair(GNT_COLOR_NORMAL));\n\t\tmvwaddstr(widget->window, 0, pos, C_(title));\n\t\tmvwaddch(widget->window, 0, right, ACS_LTEE | gnt_color_pair(GNT_COLOR_NORMAL));\n\t\tg_free(title);\n\t}\n\tgnt_box_sync_children(box);\n}\n", "bug_type": null, "idx": 923}
{"project": "Pidgin", "target": 0, "func": "static void\nfl_destroy(PurpleRoomlist *list)\n{\n\tif (!froomlist.window)\n\t\treturn;\n\tif (froomlist.roomlist == list) {\n\t\tfroomlist.roomlist = NULL;\n\t\tgnt_tree_remove_all(GNT_TREE(froomlist.tree));\n\t\tgnt_widget_draw(froomlist.tree);\n\t}\n}\n", "bug_type": null, "idx": 924}
{"project": "Pidgin", "target": 0, "func": "static void\ndo_alphashift(GdkPixbuf *pixbuf, int shift)\n{\n\tgint i, j;\n\tgint width, height, padding;\n\tguchar *pixels;\n\tint val;\n\tif (!gdk_pixbuf_get_has_alpha(pixbuf))\n\t  return;\n\twidth = gdk_pixbuf_get_width(pixbuf);\n\theight = gdk_pixbuf_get_height(pixbuf);\n\tpadding = gdk_pixbuf_get_rowstride(pixbuf) - width * 4;\n\tpixels = gdk_pixbuf_get_pixels(pixbuf);\n\tfor (i = 0; i < height; i++) {\n\t\tfor (j = 0; j < width; j++) {\n\t\t\tpixels++;\n\t\t\tpixels++;\n\t\t\tpixels++;\n\t\t\tval = *pixels - shift;\n\t\t\t*(pixels++) = CLAMP(val, 0, 255);\n\t\t}\n\t\tpixels += padding;\n\t}\n}\n", "bug_type": null, "idx": 925}
{"project": "Pidgin", "target": 0, "func": "};\nguchar *jabber_scram_hi(const JabberScramHash *hash, const GString *str,\n                        GString *salt, guint iterations)\n{\n\tPurpleCipherContext *context;\n\tguchar *result;\n\tguint i;\n\tguchar *prev, *tmp;\n\tg_return_val_if_fail(hash != NULL, NULL);\n\tg_return_val_if_fail(str != NULL && str->len > 0, NULL);\n\tg_return_val_if_fail(salt != NULL && salt->len > 0, NULL);\n\tg_return_val_if_fail(iterations > 0, NULL);\n\tprev   = g_new0(guint8, hash->size);\n\ttmp    = g_new0(guint8, hash->size);\n\tresult = g_new0(guint8, hash->size);\n\tcontext = purple_cipher_context_new_by_name(\"hmac\", NULL);\n\t\n\tg_string_append_len(salt, \"\\0\\0\\0\\1\", 4);\n\t\n\tpurple_cipher_context_set_option(context, \"hash\", (gpointer)hash->name);\n\tpurple_cipher_context_set_key_with_len(context, (guchar *)str->str, str->len);\n\tpurple_cipher_context_append(context, (guchar *)salt->str, salt->len);\n\tpurple_cipher_context_digest(context, hash->size, result, NULL);\n\tmemcpy(prev, result, hash->size);\n\t\n\tfor (i = 1; i < iterations; ++i) {\n\t\tguint j;\n\t\tpurple_cipher_context_set_option(context, \"hash\", (gpointer)hash->name);\n\t\tpurple_cipher_context_set_key_with_len(context, (guchar *)str->str, str->len);\n\t\tpurple_cipher_context_append(context, prev, hash->size);\n\t\tpurple_cipher_context_digest(context, hash->size, tmp, NULL);\n\t\tfor (j = 0; j < hash->size; ++j)\n\t\t\tresult[j] ^= tmp[j];\n\t\tmemcpy(prev, tmp, hash->size);\n\t}\n\tpurple_cipher_context_destroy(context);\n\tg_free(tmp);\n\tg_free(prev);\n\treturn result;\n}\n", "bug_type": null, "idx": 926}
{"project": "Pidgin", "target": 0, "func": "void purple_blist_remove_chat(PurpleChat *chat)\n{\n\tPurpleBlistUiOps *ops = purple_blist_get_ui_ops();\n\tPurpleBlistNode *node, *gnode;\n\tPurpleGroup *group;\n\tg_return_if_fail(chat != NULL);\n\tnode = (PurpleBlistNode *)chat;\n\tgnode = node->parent;\n\tgroup = (PurpleGroup *)gnode;\n\tif (gnode != NULL)\n\t{\n\t\t\n\t\tif (gnode->child == node)\n\t\t\tgnode->child = node->next;\n\t\tif (node->prev)\n\t\t\tnode->prev->next = node->next;\n\t\tif (node->next)\n\t\t\tnode->next->prev = node->prev;\n\t\t\n\t\tif (purple_account_is_connected(chat->account)) {\n\t\t\tgroup->online--;\n\t\t\tgroup->currentsize--;\n\t\t}\n\t\tgroup->totalsize--;\n\t}\n\t\n\tif (ops && ops->remove)\n\t\tops->remove(purplebuddylist, node);\n\tif (ops && ops->remove_node)\n\t\tops->remove_node(node);\n\tpurple_signal_emit(purple_blist_get_handle(), \"blist-node-removed\",\n\t\t\tPURPLE_BLIST_NODE(chat));\n\t\n\tpurple_chat_destroy(chat);\n}\n", "bug_type": null, "idx": 927}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nstatus_window_find_savedstatus(GtkTreeIter *iter, const char *title)\n{\n\tGtkTreeModel *model;\n\tchar *cur;\n\tif ((status_window == NULL) || (title == NULL))\n\t\treturn FALSE;\n\tmodel = GTK_TREE_MODEL(status_window->model);\n\tif (!gtk_tree_model_get_iter_first(model, iter))\n\t\treturn FALSE;\n\tdo {\n\t\tgtk_tree_model_get(model, iter, STATUS_WINDOW_COLUMN_TITLE, &cur, -1);\n\t\tif (!strcmp(title, cur))\n\t\t{\n\t\t\tg_free(cur);\n\t\t\treturn TRUE;\n\t\t}\n\t\tg_free(cur);\n\t} while (gtk_tree_model_iter_next(model, iter));\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 928}
{"project": "Pidgin", "target": 0, "func": "static xmlnode *\njingle_rtp_to_xml_internal(JingleContent *rtp, xmlnode *content, JingleActionType action)\n{\n\txmlnode *node = parent_class->to_xml(rtp, content, action);\n\txmlnode *description = xmlnode_get_child(node, \"description\");\n\tif (description != NULL) {\n\t\tJingleSession *session = jingle_content_get_session(rtp);\n\t\tPurpleMedia *media = jingle_rtp_get_media(session);\n\t\tgchar *media_type = jingle_rtp_get_media_type(rtp);\n\t\tgchar *ssrc = jingle_rtp_get_ssrc(rtp);\n\t\tgchar *name = jingle_content_get_name(rtp);\n\t\tGList *codecs = purple_media_get_codecs(media, name);\n\t\txmlnode_set_attrib(description, \"media\", media_type);\n\t\tif (ssrc != NULL)\n\t\t\txmlnode_set_attrib(description, \"ssrc\", ssrc);\n\t\tg_free(media_type);\n\t\tg_free(name);\n\t\tg_object_unref(session);\n\t\tjingle_rtp_add_payloads(description, codecs);\n\t\tpurple_media_codec_list_free(codecs);\n\t}\n\treturn node;\n}\n", "bug_type": null, "idx": 929}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_session_handle_recv_msg(struct gg_session *sess, uint32_t type,\n\tconst char *packet, size_t length, struct gg_event *e)\n{\n\tconst struct gg_recv_msg *r = (const struct gg_recv_msg*) packet;\n\tconst char *payload = packet + sizeof(struct gg_recv_msg);\n\tconst char *payload_end = packet + length;\n\tsize_t len;\n\tgg_debug_session(sess, GG_DEBUG_FUNCTION, \"** gg_handle_recv_msg(%p, %\"\n\t\tGG_SIZE_FMT \", %p);\\n\", packet, length, e);\n\tif (sess == NULL)\n\t\tgoto fail;\n\tif ((r->seq == 0) && (r->msgclass == 0)) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_handle_recv_msg() oops, silently ignoring the bait\\n\");\n\t\tgoto malformed;\n\t}\n\t\n\tif (*payload == GG_MSG_CALLBACK && payload == payload_end - 1) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_handle_recv_msg() received ctcp packet\\n\");\n\t\tlength = 1;\n\t} else {\n\t\tconst char *options;\n\t\toptions = memchr(payload, 0, (size_t) (payload_end - payload));\n\t\tif (options == NULL) {\n\t\t\tgg_debug_session(sess, GG_DEBUG_MISC,\n\t\t\t\t\"// gg_handle_recv_msg() malformed packet, \"\n\t\t\t\t\"message out of bounds (0)\\n\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tlength = (size_t) (options - payload);\n\t\tswitch (gg_handle_recv_msg_options(sess, e, gg_fix32(r->sender), options + 1, payload_end, type)) {\n\t\t\tcase -1:\t\n\t\t\t\tgg_session_send_msg_ack(sess, gg_fix32(r->seq));\n\t\t\t\treturn 0;\n\t\t\tcase -2:\t\n\t\t\t\tgoto fail;\n\t\t\tcase -3:\t\n\t\t\t\tgoto malformed;\n\t\t}\n\t}\n\te->type = GG_EVENT_MSG;\n\te->event.msg.msgclass = gg_fix32(r->msgclass);\n\te->event.msg.sender = gg_fix32(r->sender);\n\te->event.msg.time = gg_fix32(r->time);\n\te->event.msg.seq = gg_fix32(r->seq);\n\te->event.msg.message = (unsigned char*)gg_encoding_convert(payload,\n\t\tGG_ENCODING_CP1250, sess->encoding, length, -1);\n\tif (e->event.msg.message == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_session_handle_recv_msg() out of memory\\n\");\n\t\tgoto fail;\n\t}\n\tlen = gg_message_text_to_html(NULL, (char*)e->event.msg.message,\n\t\tsess->encoding, e->event.msg.formats,\n\t\te->event.msg.formats_length);\n\te->event.msg.xhtml_message = malloc(len + 1);\n\tif (e->event.msg.xhtml_message == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"// gg_session_handle_recv_msg() out of memory\\n\");\n\t\tgoto fail;\n\t}\n\tgg_message_text_to_html(e->event.msg.xhtml_message,\n\t\t(char*)e->event.msg.message, sess->encoding,\n\t\te->event.msg.formats, e->event.msg.formats_length);\n\tgg_session_send_msg_ack(sess, gg_fix32(r->seq));\n\treturn 0;\nfail:\n\tfree(e->event.msg.message);\n\tfree(e->event.msg.xhtml_message);\n\tfree(e->event.msg.recipients);\n\tfree(e->event.msg.formats);\n\treturn -1;\nmalformed:\n\te->type = GG_EVENT_NONE;\n\tfree(e->event.msg.message);\n\tfree(e->event.msg.xhtml_message);\n\tfree(e->event.msg.recipients);\n\tfree(e->event.msg.formats);\n\tgg_session_send_msg_ack(sess, gg_fix32(r->seq));\n\treturn 0;\n}\n", "bug_type": null, "idx": 930}
{"project": "Pidgin", "target": 0, "func": "static gint\ncompare_prpl(PurplePlugin *a, PurplePlugin *b)\n{\n\tif(PURPLE_IS_PROTOCOL_PLUGIN(a)) {\n\t\tif(PURPLE_IS_PROTOCOL_PLUGIN(b))\n\t\t\treturn strcmp(a->info->name, b->info->name);\n\t\telse\n\t\t\treturn -1;\n\t} else {\n\t\tif(PURPLE_IS_PROTOCOL_PLUGIN(b))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n", "bug_type": null, "idx": 931}
{"project": "Pidgin", "target": 0, "func": "static gpointer\n_win32_name_lookup_thread(gpointer data) {\n\tgchar *fullname = NULL;\n\twchar_t username[UNLEN + 1];\n\tDWORD dwLenUsername = UNLEN + 1;\n\tGetUserNameW((LPWSTR) &username, &dwLenUsername);\n\tif (username != NULL && *username != '\\0') {\n\t\tLPBYTE servername = NULL;\n\t\tLPBYTE info = NULL;\n\t\tNetGetDCName(NULL, NULL, &servername);\n\t\t\n\t\tif (NetUserGetInfo((LPCWSTR) servername, username, 10, &info) == NERR_Success\n\t\t\t\t&& info != NULL && ((LPUSER_INFO_10) info)->usri10_full_name != NULL\n\t\t\t\t&& *(((LPUSER_INFO_10) info)->usri10_full_name) != '\\0') {\n\t\t\tfullname = g_utf16_to_utf8(\n\t\t\t\t((LPUSER_INFO_10) info)->usri10_full_name,\n\t\t\t\t-1, NULL, NULL, NULL);\n\t\t}\n\t\t\n\t\telse if (servername != NULL) {\n\t\t\t\n\t\t\tif (info != NULL) NetApiBufferFree(info);\n\t\t\tinfo = NULL;\n\t\t\tif (NetUserGetInfo(NULL, username, 10, &info) == NERR_Success\n\t\t\t\t\t&& info != NULL && ((LPUSER_INFO_10) info)->usri10_full_name != NULL\n\t\t\t\t\t&& *(((LPUSER_INFO_10) info)->usri10_full_name) != '\\0') {\n\t\t\t\tfullname = g_utf16_to_utf8(\n\t\t\t\t\t((LPUSER_INFO_10) info)->usri10_full_name,\n\t\t\t\t\t-1, NULL, NULL, NULL);\n\t\t\t}\n\t\t}\n\t\tif (info != NULL) NetApiBufferFree(info);\n\t\tif (servername != NULL) NetApiBufferFree(servername);\n\t\tif (!fullname)\n\t\t\tfullname = g_utf16_to_utf8(username, -1, NULL, NULL, NULL);\n\t}\n\tpurple_timeout_add(0, _set_default_name_cb, fullname);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 932}
{"project": "Pidgin", "target": 0, "func": "static void\nremove_userinfo(GtkWidget *widget, gpointer key)\n{\n\tPidginUserInfo *pinfo = g_hash_table_lookup(userinfo, key);\n\twhile (pinfo->count--)\n\t\tpurple_notify_close(PURPLE_NOTIFY_USERINFO, widget);\n\tg_hash_table_remove(userinfo, key);\n}\n", "bug_type": null, "idx": 933}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nsuggest_prev_page(GntBindable *bind, GList *null)\n{\n\tGntEntry *entry = GNT_ENTRY(bind);\n\tif (entry->ddown) {\n\t\tgnt_bindable_perform_action_named(GNT_BINDABLE(entry->ddown), \"page-up\", NULL);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 934}
{"project": "Pidgin", "target": 0, "func": "void\ngnt_ws_hide(GntWS *ws, GHashTable *nodes)\n{\n\tg_list_foreach(ws->ordered, widget_hide, nodes);\n}\n", "bug_type": null, "idx": 935}
{"project": "Pidgin", "target": 0, "func": "static GList *ggp_status_types(PurpleAccount *account)\n{\n\tPurpleStatusType *type;\n\tGList *types = NULL;\n\ttype = purple_status_type_new_with_attrs(\n\t\t\tPURPLE_STATUS_AVAILABLE, NULL, NULL, TRUE, TRUE, FALSE,\n\t\t\t\"message\", _(\"Message\"), purple_value_new(PURPLE_TYPE_STRING),\n\t\t\tNULL);\n\ttypes = g_list_append(types, type);\n\t\n\ttype = purple_status_type_new_with_attrs(\n\t\t\tPURPLE_STATUS_INVISIBLE, NULL, NULL, TRUE, TRUE, FALSE,\n\t\t\t\"message\", _(\"Message\"), purple_value_new(PURPLE_TYPE_STRING),\n\t\t\tNULL);\n\ttypes = g_list_append(types, type);\n\ttype = purple_status_type_new_with_attrs(\n\t\t\tPURPLE_STATUS_AWAY, NULL, NULL, TRUE, TRUE, FALSE,\n\t\t\t\"message\", _(\"Message\"), purple_value_new(PURPLE_TYPE_STRING),\n\t\t\tNULL);\n\ttypes = g_list_append(types, type);\n \t\n\ttype = purple_status_type_new_with_attrs(\n\t\t\tPURPLE_STATUS_UNAVAILABLE, NULL, NULL, TRUE, TRUE, FALSE,\n\t\t\t\"message\", _(\"Message\"), purple_value_new(PURPLE_TYPE_STRING),\n\t\t\tNULL);\n\ttypes = g_list_append(types, type);\n\t\n\ttype = purple_status_type_new_with_attrs(\n\t\t\tPURPLE_STATUS_INVISIBLE, \"blocked\", _(\"Blocked\"), TRUE, FALSE, FALSE,\n\t\t\t\"message\", _(\"Message\"), purple_value_new(PURPLE_TYPE_STRING), NULL);\n\ttypes = g_list_append(types, type);\n\ttype = purple_status_type_new_with_attrs(\n\t\t\tPURPLE_STATUS_OFFLINE, NULL, NULL, TRUE, TRUE, FALSE,\n\t\t\t\"message\", _(\"Message\"), purple_value_new(PURPLE_TYPE_STRING),\n\t\t\tNULL);\n\ttypes = g_list_append(types, type);\n\treturn types;\n}\n", "bug_type": null, "idx": 936}
{"project": "Pidgin", "target": 0, "func": "static void color_select_dialog(GtkWidget *widget, PidginWhiteboard *gtkwb)\n{\n\tGdkColor color;\n\tGtkColorSelectionDialog *dialog;\n\tdialog = (GtkColorSelectionDialog *)gtk_color_selection_dialog_new(_(\"Select color\"));\n\tg_object_set_data(G_OBJECT(gtkwb->window), \"colour-dialog\", dialog);\n\tg_signal_connect(G_OBJECT(dialog->colorsel), \"color-changed\",\n\t\t\t\t\tG_CALLBACK(change_color_cb), gtkwb);\n\tgtk_widget_destroy(dialog->cancel_button);\n\tgtk_widget_destroy(dialog->help_button);\n\tg_signal_connect(G_OBJECT(dialog->ok_button), \"clicked\",\n\t\t\t\t\tG_CALLBACK(color_selection_dialog_destroy), gtkwb);\n\tgtk_color_selection_set_has_palette(GTK_COLOR_SELECTION(dialog->colorsel), TRUE);\n\tpidgin_whiteboard_rgb24_to_rgb48(gtkwb->brush_color, &color);\n\tgtk_color_selection_set_current_color(GTK_COLOR_SELECTION(dialog->colorsel), &color);\n\tgtk_widget_show_all(GTK_WIDGET(dialog));\n}\n", "bug_type": null, "idx": 937}
{"project": "Pidgin", "target": 0, "func": "NMConference *\nnm_conference_list_find(NMUser * user, const char *guid)\n{\n\tGSList *cnode;\n\tNMConference *conference = NULL, *tmp;\n\tif (user == NULL || guid == NULL)\n\t\treturn NULL;\n\tif (user->conferences) {\n\t\tfor (cnode = user->conferences; cnode; cnode = cnode->next) {\n\t\t\ttmp = cnode->data;\n\t\t\tif (nm_are_guids_equal(nm_conference_get_guid(tmp), guid)) {\n\t\t\t\tconference = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn conference;\n}\n", "bug_type": null, "idx": 938}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nhandle_presence_contact(JabberStream *js, JabberPresence *presence)\n{\n\tJabberBuddyResource *jbr;\n\tPurpleAccount *account;\n\tPurpleBuddy *b;\n\tchar *buddy_name;\n\tPurpleConversation *conv;\n\tbuddy_name = jabber_id_get_bare_jid(presence->jid_from);\n\taccount = purple_connection_get_account(js->gc);\n\tb = purple_find_buddy(account, buddy_name);\n\t\n\tconv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM,\n\t\t\tbuddy_name, account);\n\tif (conv) {\n\t\tpurple_debug_info(\"jabber\", \"Changed conversation binding from %s to %s\\n\",\n\t\t\t\tpurple_conversation_get_name(conv), buddy_name);\n\t\tpurple_conversation_set_name(conv, buddy_name);\n\t}\n\tif (b == NULL) {\n\t\tif (presence->jb != js->user_jb) {\n\t\t\tpurple_debug_warning(\"jabber\", \"Got presence for unknown buddy %s on account %s (%p)\\n\",\n\t\t\t\t\tbuddy_name, purple_account_get_username(account), account);\n\t\t\tg_free(buddy_name);\n\t\t\treturn FALSE;\n\t\t} else {\n\t\t\t\n\t\t}\n\t}\n\tif (b && presence->vcard_avatar_hash) {\n\t\tconst char *ah = presence->vcard_avatar_hash[0] != '\\0' ?\n\t\t\t\tpresence->vcard_avatar_hash : NULL;\n\t\tconst char *ah2 = purple_buddy_icons_get_checksum_for_user(b);\n\t\tif (!purple_strequal(ah, ah2)) {\n\t\t\t\n\t\t\tif(!g_slist_find(js->pending_avatar_requests, presence->jb)) {\n\t\t\t\tJabberIq *iq;\n\t\t\t\txmlnode *vcard;\n\t\t\t\tjs->pending_avatar_requests =\n\t\t\t\t\tg_slist_prepend(js->pending_avatar_requests, presence->jb);\n\t\t\t\tiq = jabber_iq_new(js, JABBER_IQ_GET);\n\t\t\t\txmlnode_set_attrib(iq->node, \"to\", buddy_name);\n\t\t\t\tvcard = xmlnode_new_child(iq->node, \"vCard\");\n\t\t\t\txmlnode_set_namespace(vcard, \"vcard-temp\");\n\t\t\t\tjabber_iq_set_callback(iq, jabber_vcard_parse_avatar, NULL);\n\t\t\t\tjabber_iq_send(iq);\n\t\t\t}\n\t\t}\n\t}\n\tif (presence->state == JABBER_BUDDY_STATE_ERROR ||\n\t\t\tpresence->type == JABBER_PRESENCE_UNAVAILABLE ||\n\t\t\tpresence->type == JABBER_PRESENCE_UNSUBSCRIBED) {\n\t\tjabber_buddy_remove_resource(presence->jb, presence->jid_from->resource);\n\t} else {\n\t\tjbr = jabber_buddy_track_resource(presence->jb,\n\t\t\t\tpresence->jid_from->resource, presence->priority,\n\t\t\t\tpresence->state, presence->status);\n\t\tjbr->idle = presence->idle ? time(NULL) - presence->idle : 0;\n\t}\n\tjbr = jabber_buddy_find_resource(presence->jb, NULL);\n\tif (jbr) {\n\t\tjabber_google_presence_incoming(js, buddy_name, jbr);\n\t\tpurple_prpl_got_user_status(account, buddy_name,\n\t\t\t\tjabber_buddy_state_get_status_id(jbr->state),\n\t\t\t\t\"priority\", jbr->priority,\n\t\t\t\t\"message\", jbr->status,\n\t\t\t\tNULL);\n\t\tpurple_prpl_got_user_idle(account, buddy_name,\n\t\t\t\tjbr->idle, jbr->idle);\n\t\tif (presence->nickname)\n\t\t\tserv_got_alias(js->gc, buddy_name, presence->nickname);\n\t} else {\n\t\tpurple_prpl_got_user_status(account, buddy_name,\n\t\t\t\tjabber_buddy_state_get_status_id(JABBER_BUDDY_STATE_UNAVAILABLE),\n\t\t\t\tpresence->status ? \"message\" : NULL, presence->status,\n\t\t\t\tNULL);\n\t}\n\tg_free(buddy_name);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 939}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ndo_jabber_caps_store(gpointer data)\n{\n\tchar *str;\n\tint length = 0;\n\txmlnode *root = xmlnode_new(\"capabilities\");\n\tg_hash_table_foreach(capstable, jabber_caps_store_client, root);\n\tstr = xmlnode_to_formatted_str(root, &length);\n\txmlnode_free(root);\n\tpurple_util_write_data_to_file(JABBER_CAPS_FILENAME, str, length);\n\tg_free(str);\n\tsave_timer = 0;\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 940}
{"project": "Pidgin", "target": 0, "func": "static PidginLogViewer *display_log_viewer(struct log_viewer_hash_t *ht, GList *logs,\n\t\t\t\t\t\tconst char *title, GtkWidget *icon, int log_size)\n{\n\tPidginLogViewer *lv;\n\tGtkWidget *title_box;\n\tchar *text;\n\tGtkWidget *pane;\n\tGtkCellRenderer *rend;\n\tGtkTreeViewColumn *col;\n\tGtkTreeSelection *sel;\n\tGtkWidget *vbox;\n\tGtkWidget *frame;\n\tGtkWidget *hbox;\n\tGtkWidget *find_button;\n\tGtkWidget *size_label;\n\tif (logs == NULL)\n\t{\n\t\t\n\t\tconst char *log_preferences = NULL;\n\t\tif (ht == NULL) {\n\t\t\tif (!purple_prefs_get_bool(\"/purple/logging/log_system\"))\n\t\t\t\tlog_preferences = _(\"System events will only be logged if the \\\"Log all status changes to system log\\\" preference is enabled.\");\n\t\t} else {\n\t\t\tif (ht->type == PURPLE_LOG_IM) {\n\t\t\t\tif (!purple_prefs_get_bool(\"/purple/logging/log_ims\"))\n\t\t\t\t\tlog_preferences = _(\"Instant messages will only be logged if the \\\"Log all instant messages\\\" preference is enabled.\");\n\t\t\t} else if (ht->type == PURPLE_LOG_CHAT) {\n\t\t\t\tif (!purple_prefs_get_bool(\"/purple/logging/log_chats\"))\n\t\t\t\t\tlog_preferences = _(\"Chats will only be logged if the \\\"Log all chats\\\" preference is enabled.\");\n\t\t\t}\n\t\t\tg_free(ht->buddyname);\n\t\t\tg_free(ht);\n\t\t}\n\t\tif(icon != NULL)\n\t\t\tgtk_widget_destroy(icon);\n\t\tpurple_notify_info(NULL, title, _(\"No logs were found\"), log_preferences);\n\t\treturn NULL;\n\t}\n\tlv = g_new0(PidginLogViewer, 1);\n\tlv->logs = logs;\n\tif (ht != NULL)\n\t\tg_hash_table_insert(log_viewers, ht, lv);\n\t\n\tlv->window = gtk_dialog_new_with_buttons(title, NULL, 0,\n\t\t\t\t\t     GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE, NULL);\n#ifdef _WIN32\n\t\n\tgtk_dialog_add_button(GTK_DIALOG(lv->window), _(\"_Browse logs folder\"), GTK_RESPONSE_HELP);\n#endif\n\tgtk_container_set_border_width (GTK_CONTAINER(lv->window), PIDGIN_HIG_BOX_SPACE);\n\tgtk_dialog_set_has_separator(GTK_DIALOG(lv->window), FALSE);\n\tgtk_box_set_spacing(GTK_BOX(GTK_DIALOG(lv->window)->vbox), 0);\n\tg_signal_connect(G_OBJECT(lv->window), \"response\",\n\t\t\t\t\t G_CALLBACK(destroy_cb), ht);\n\tgtk_window_set_role(GTK_WINDOW(lv->window), \"log_viewer\");\n\t\n\tif (icon != NULL) {\n\t\ttitle_box = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);\n\t\tgtk_container_set_border_width(GTK_CONTAINER(title_box), PIDGIN_HIG_BOX_SPACE);\n\t\tgtk_box_pack_start(GTK_BOX(GTK_DIALOG(lv->window)->vbox), title_box, FALSE, FALSE, 0);\n\t\tgtk_box_pack_start(GTK_BOX(title_box), icon, FALSE, FALSE, 0);\n\t} else\n\t\ttitle_box = GTK_DIALOG(lv->window)->vbox;\n\t\n\tlv->label = gtk_label_new(NULL);\n\ttext = g_strdup_printf(\"<span size='larger' weight='bold'>%s</span>\", title);\n\tgtk_label_set_markup(GTK_LABEL(lv->label), text);\n\tgtk_misc_set_alignment(GTK_MISC(lv->label), 0, 0);\n\tgtk_box_pack_start(GTK_BOX(title_box), lv->label, FALSE, FALSE, 0);\n\tg_free(text);\n\t\n\tpane = gtk_hpaned_new();\n\tgtk_container_set_border_width(GTK_CONTAINER(pane), PIDGIN_HIG_BOX_SPACE);\n\tgtk_box_pack_start(GTK_BOX(GTK_DIALOG(lv->window)->vbox), pane, TRUE, TRUE, 0);\n\t\n\tlv->treestore = gtk_tree_store_new (2, G_TYPE_STRING, G_TYPE_POINTER);\n\tlv->treeview = gtk_tree_view_new_with_model (GTK_TREE_MODEL (lv->treestore));\n\tg_object_unref(G_OBJECT(lv->treestore));\n\trend = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes (\"time\", rend, \"markup\", 0, NULL);\n\tgtk_tree_view_append_column (GTK_TREE_VIEW(lv->treeview), col);\n\tgtk_tree_view_set_headers_visible (GTK_TREE_VIEW (lv->treeview), FALSE);\n\tgtk_paned_add1(GTK_PANED(pane), \n\t\tpidgin_make_scrollable(lv->treeview, GTK_POLICY_NEVER, GTK_POLICY_ALWAYS, GTK_SHADOW_IN, -1, -1));\n\tpopulate_log_tree(lv);\n\tsel = gtk_tree_view_get_selection (GTK_TREE_VIEW (lv->treeview));\n\tg_signal_connect (G_OBJECT (sel), \"changed\",\n\t\t\tG_CALLBACK (log_select_cb),\n\t\t\tlv);\n\tg_signal_connect (G_OBJECT(lv->treeview), \"row-activated\",\n\t\t\tG_CALLBACK(log_row_activated_cb),\n\t\t\tlv);\n\tpidgin_set_accessible_label(lv->treeview, lv->label);\n\tg_signal_connect(lv->treeview, \"button-press-event\", G_CALLBACK(log_button_press_cb), lv);\n\tg_signal_connect(lv->treeview, \"popup-menu\", G_CALLBACK(log_popup_menu_cb), lv);\n\t\n\tif(log_size) {\n\t\tchar *sz_txt = purple_str_size_to_units(log_size);\n\t\ttext = g_strdup_printf(\"<span weight='bold'>%s</span> %s\", _(\"Total log size:\"), sz_txt);\n\t\tsize_label = gtk_label_new(NULL);\n\t\tgtk_label_set_markup(GTK_LABEL(size_label), text);\n\t\t\n\t\tgtk_misc_set_alignment(GTK_MISC(size_label), 0, 0);\n\t\tgtk_box_pack_end(GTK_BOX(GTK_DIALOG(lv->window)->vbox), size_label, FALSE, FALSE, 0);\n\t\tg_free(sz_txt);\n\t\tg_free(text);\n\t}\n\t\n\tvbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);\n\tgtk_paned_add2(GTK_PANED(pane), vbox);\n\t\n\tframe = pidgin_create_imhtml(FALSE, &lv->imhtml, NULL, NULL);\n\tgtk_widget_set_name(lv->imhtml, \"pidgin_log_imhtml\");\n\tgtk_widget_set_size_request(lv->imhtml, 320, 200);\n\tgtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);\n\tgtk_widget_show(frame);\n\t\n\thbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlv->entry = gtk_entry_new();\n\tgtk_box_pack_start(GTK_BOX(hbox), lv->entry, TRUE, TRUE, 0);\n\tfind_button = gtk_button_new_from_stock(GTK_STOCK_FIND);\n\tgtk_box_pack_start(GTK_BOX(hbox), find_button, FALSE, FALSE, 0);\n\tg_signal_connect(GTK_ENTRY(lv->entry), \"activate\", G_CALLBACK(search_cb), lv);\n\tg_signal_connect(GTK_BUTTON(find_button), \"clicked\", G_CALLBACK(search_cb), lv);\n\tselect_first_log(lv);\n\tgtk_widget_show_all(lv->window);\n\treturn lv;\n}\n", "bug_type": null, "idx": 941}
{"project": "Pidgin", "target": 0, "func": "void pidgin_notify_uninit(void)\n{\n\tpurple_signals_disconnect_by_handle(pidgin_notify_get_handle());\n}\n", "bug_type": null, "idx": 942}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin) {\n}\n", "bug_type": null, "idx": 943}
{"project": "Pidgin", "target": 0, "func": "void\noscar_user_info_append_status(PurpleConnection *gc, PurpleNotifyUserInfo *user_info, PurpleBuddy *b, aim_userinfo_t *userinfo, gboolean use_html_status)\n{\n\tPurpleAccount *account = purple_connection_get_account(gc);\n\tOscarData *od;\n\tPurplePresence *presence = NULL;\n\tPurpleStatus *status = NULL;\n\tgchar *message = NULL, *itmsurl = NULL, *tmp;\n\tgboolean escaping_needed = TRUE;\n\tod = purple_connection_get_protocol_data(gc);\n\tif (b == NULL && userinfo == NULL)\n\t\treturn;\n\tif (b == NULL)\n\t\tb = purple_find_buddy(purple_connection_get_account(gc), userinfo->bn);\n\telse\n\t\tuserinfo = aim_locate_finduserinfo(od, purple_buddy_get_name(b));\n\tif (b) {\n\t\tpresence = purple_buddy_get_presence(b);\n\t\tstatus = purple_presence_get_active_status(presence);\n\t}\n\t\n\tif (userinfo) {\n\t\tif ((userinfo->flags & AIM_FLAG_AWAY) && use_html_status && userinfo->away_len > 0 && userinfo->away != NULL && userinfo->away_encoding != NULL) {\n\t\t\t\n\t\t\tmessage = oscar_encoding_to_utf8(userinfo->away_encoding, userinfo->away, userinfo->away_len);\n\t\t\tescaping_needed = FALSE;\n\t\t} else {\n\t\t\t\n\t\t\tif ((userinfo->status != NULL) && userinfo->status[0] != '\\0') {\n\t\t\t\tmessage = oscar_encoding_to_utf8(userinfo->status_encoding, userinfo->status, userinfo->status_len);\n\t\t\t}\n#if defined (_WIN32) || defined (__APPLE__)\n\t\t\tif (userinfo->itmsurl && (userinfo->itmsurl[0] != '\\0')) {\n\t\t\t\titmsurl = oscar_encoding_to_utf8(userinfo->itmsurl_encoding, userinfo->itmsurl, userinfo->itmsurl_len);\n\t\t\t}\n#endif\n\t\t}\n\t} else {\n\t\tmessage = g_strdup(purple_status_get_attr_string(status, \"message\"));\n\t\titmsurl = g_strdup(purple_status_get_attr_string(status, \"itmsurl\"));\n\t}\n\tif (message) {\n\t\ttmp = oscar_util_format_string(message, purple_account_get_username(account));\n\t\tg_free(message);\n\t\tmessage = tmp;\n\t\tif (escaping_needed) {\n\t\t\ttmp = purple_markup_escape_text(message, -1);\n\t\t\tg_free(message);\n\t\t\tmessage = tmp;\n\t\t}\n\t}\n\tif (use_html_status && itmsurl) {\n\t\ttmp = g_strdup_printf(\"<a href=\\\"%s\\\">%s</a>\", itmsurl, message);\n\t\tg_free(message);\n\t\tmessage = tmp;\n\t}\n\tif (b) {\n\t\tif (purple_presence_is_online(presence)) {\n\t\t\tgboolean is_away = ((status && !purple_status_is_available(status)) || (userinfo && (userinfo->flags & AIM_FLAG_AWAY)));\n\t\t\tif (oscar_util_valid_name_icq(purple_buddy_get_name(b)) || is_away || !message || !(*message)) {\n\t\t\t\t\n\t\t\t\tconst char *status_name = purple_status_get_name(status);\n\t\t\t\tif (status_name && message && !strcmp(status_name, message))\n\t\t\t\t\tstatus_name = NULL;\n\t\t\t\ttmp = g_strdup_printf(\"%s%s%s\",\n\t\t\t\t\t\t\t\t\t   status_name ? status_name : \"\",\n\t\t\t\t\t\t\t\t\t   ((status_name && message) && *message) ? \": \" : \"\",\n\t\t\t\t\t\t\t\t\t   (message && *message) ? message : \"\");\n\t\t\t\tg_free(message);\n\t\t\t\tmessage = tmp;\n\t\t\t}\n\t\t} else if (aim_ssi_waitingforauth(od->ssi.local,\n\t\t\taim_ssi_itemlist_findparentname(od->ssi.local, purple_buddy_get_name(b)),\n\t\t\tpurple_buddy_get_name(b)))\n\t\t{\n\t\t\t\n\t\t\ttmp = g_strdup_printf(\"%s%s%s\",\n\t\t\t\t\t_(\"Not Authorized\"),\n\t\t\t\t\t(message && *message) ? \": \" : \"\",\n\t\t\t\t\t(message && *message) ? message : \"\");\n\t\t\tg_free(message);\n\t\t\tmessage = tmp;\n\t\t} else {\n\t\t\tg_free(message);\n\t\t\tmessage = g_strdup(_(\"Offline\"));\n\t\t}\n\t}\n\tif (presence) {\n\t\tconst char *mood;\n\t\tconst char *comment;\n\t\tchar *description;\n\t\tstatus = purple_presence_get_status(presence, \"mood\");\n\t\tmood = icq_get_custom_icon_description(purple_status_get_attr_string(status, PURPLE_MOOD_NAME));\n\t\tif (mood) {\n\t\t\tcomment = purple_status_get_attr_string(status, PURPLE_MOOD_COMMENT);\n\t\t\tif (comment) {\n\t\t\t\tchar *escaped_comment = purple_markup_escape_text(comment, -1);\n\t\t\t\tdescription = g_strdup_printf(\"%s (%s)\", _(mood), escaped_comment);\n\t\t\t\tg_free(escaped_comment);\n\t\t\t} else {\n\t\t\t\tdescription = g_strdup(_(mood));\n\t\t\t}\n\t\t\tpurple_notify_user_info_add_pair(user_info, _(\"Mood\"), description);\n\t\t\tg_free(description);\n\t\t}\n\t}\n\tpurple_notify_user_info_add_pair(user_info, _(\"Status\"), message);\n\tg_free(message);\n}\n", "bug_type": null, "idx": 944}
{"project": "Pidgin", "target": 0, "func": "void\njingle_session_add_content(JingleSession *session, JingleContent* content)\n{\n\tsession->priv->contents =\n\t\t\tg_list_append(session->priv->contents, content);\n\tjingle_content_set_session(content, session);\n}\n", "bug_type": null, "idx": 945}
{"project": "Pidgin", "target": 0, "func": "static void\ngtk_source_undo_manager_finalize (GObject *object)\n{\n\tGtkSourceUndoManager *um;\n\tg_return_if_fail (object != NULL);\n\tg_return_if_fail (GTK_SOURCE_IS_UNDO_MANAGER (object));\n   \tum = GTK_SOURCE_UNDO_MANAGER (object);\n\tg_return_if_fail (um->priv != NULL);\n\tif (um->priv->actions != NULL)\n\t{\n\t\tgtk_source_undo_manager_free_action_list (um);\n\t}\n\tg_signal_handlers_disconnect_by_func (G_OBJECT (um->priv->document),\n\t\t\t  G_CALLBACK (gtk_source_undo_manager_delete_range_handler),\n\t\t\t  um);\n\tg_signal_handlers_disconnect_by_func (G_OBJECT (um->priv->document),\n\t\t\t  G_CALLBACK (gtk_source_undo_manager_insert_text_handler),\n\t\t\t  um);\n\tg_signal_handlers_disconnect_by_func (G_OBJECT (um->priv->document),\n\t\t\t  G_CALLBACK (gtk_source_undo_manager_insert_anchor_handler),\n\t\t\t  um);\n\tg_signal_handlers_disconnect_by_func (G_OBJECT (um->priv->document),\n\t\t\t  G_CALLBACK (gtk_source_undo_manager_begin_user_action_handler),\n\t\t\t  um);\n\tg_free (um->priv);\n\tG_OBJECT_CLASS (parent_class)->finalize (object);\n}\n", "bug_type": null, "idx": 946}
{"project": "Pidgin", "target": 0, "func": "PurpleSoundUiOps *\nfinch_sound_get_ui_ops(void)\n{\n\treturn &sound_ui_ops;\n}\n", "bug_type": null, "idx": 947}
{"project": "Pidgin", "target": 0, "func": "void pidgin_disco_add_service(PidginDiscoList *pdl, XmppDiscoService *service, XmppDiscoService *parent)\n{\n\tPidginDiscoDialog *dialog;\n\tGtkTreeIter iter, parent_iter, child;\n\tGdkPixbuf *pixbuf = NULL;\n\tgboolean append = TRUE;\n\tdialog = pdl->dialog;\n\tg_return_if_fail(dialog != NULL);\n\tif (service != NULL)\n\t\tpurple_debug_info(\"xmppdisco\", \"Adding service \\\"%s\\\"\\n\", service->name);\n\telse\n\t\tpurple_debug_info(\"xmppdisco\", \"Service \\\"%s\\\" has no childrens\\n\", parent->name);\n\tgtk_progress_bar_pulse(GTK_PROGRESS_BAR(dialog->progress));\n\tif (parent) {\n\t\tGtkTreeRowReference *rr;\n\t\tGtkTreePath *path;\n\t\trr = g_hash_table_lookup(pdl->services, parent);\n\t\tpath = gtk_tree_row_reference_get_path(rr);\n\t\tif (path) {\n\t\t\tgtk_tree_model_get_iter(GTK_TREE_MODEL(pdl->model), &parent_iter, path);\n\t\t\tgtk_tree_path_free(path);\n\t\t\tif (gtk_tree_model_iter_children(GTK_TREE_MODEL(pdl->model), &child,\n\t\t\t                                 &parent_iter)) {\n\t\t\t\tPidginDiscoList *tmp;\n\t\t\t\tgtk_tree_model_get(GTK_TREE_MODEL(pdl->model), &child,\n\t\t\t\t                   SERVICE_COLUMN, &tmp, -1);\n\t\t\t\tif (!tmp)\n\t\t\t\t\tappend = FALSE;\n\t\t\t}\n\t\t}\n\t}\n\tif (service == NULL) {\n\t\tif (parent != NULL && !append)\n\t\t\tgtk_tree_store_remove(pdl->model, &child);\n\t\treturn;\n\t}\n\tif (append)\n\t\tgtk_tree_store_append(pdl->model, &iter, (parent ? &parent_iter : NULL));\n\telse\n\t\titer = child;\n\tif (service->flags & XMPP_DISCO_BROWSE) {\n\t\tGtkTreeRowReference *rr;\n\t\tGtkTreePath *path;\n\t\tgtk_tree_store_append(pdl->model, &child, &iter);\n\t\tpath = gtk_tree_model_get_path(GTK_TREE_MODEL(pdl->model), &iter);\n\t\trr = gtk_tree_row_reference_new(GTK_TREE_MODEL(pdl->model), path);\n\t\tg_hash_table_insert(pdl->services, service, rr);\n\t\tgtk_tree_path_free(path);\n\t}\n\tpixbuf = pidgin_disco_load_icon(service, \"16\");\n\tgtk_tree_store_set(pdl->model, &iter,\n\t\t\tPIXBUF_COLUMN, pixbuf,\n\t\t\tNAME_COLUMN, service->name,\n\t\t\tDESCRIPTION_COLUMN, service->description,\n\t\t\tSERVICE_COLUMN, service,\n\t\t\t-1);\n\tif (pixbuf)\n\t\tg_object_unref(pixbuf);\n}\n", "bug_type": null, "idx": 948}
{"project": "Pidgin", "target": 0, "func": "GHashTable* purple_core_get_ui_info() {\n\tPurpleCoreUiOps *ops = purple_core_get_ui_ops();\n\tif(NULL == ops || NULL == ops->get_ui_info)\n\t\treturn NULL;\n\treturn ops->get_ui_info();\n}\n", "bug_type": null, "idx": 949}
{"project": "Pidgin", "target": 0, "func": "GntFile* gnt_file_new(const char *name, unsigned long size)\n{\n\tGntFile *file = g_new0(GntFile, 1);\n\tfile->basename = g_strdup(name);\n\tfile->type = GNT_FILE_REGULAR;\n\tfile->size = size;\n\treturn file;\n}\n", "bug_type": null, "idx": 950}
{"project": "Pidgin", "target": 0, "func": "static void\nconfig_destroy(GtkObject *w, gpointer nul)\n{\n\tpurple_debug_info(\"vvconfig\", \"closing vv configuration window\\n\");\n\twindow = NULL;\n}\n", "bug_type": null, "idx": 951}
{"project": "Pidgin", "target": 0, "func": "static void ggp_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy,\n\t\t\t\t\t\t PurpleGroup *group)\n{\n\tGGPInfo *info = gc->proto_data;\n\tgg_remove_notify(info->session, ggp_str_to_uin(purple_buddy_get_name(buddy)));\n}\n", "bug_type": null, "idx": 952}
{"project": "Pidgin", "target": 0, "func": "void *\npidgin_pounces_get_handle() {\n\tstatic int handle;\n\treturn &handle;\n}\n", "bug_type": null, "idx": 953}
{"project": "Pidgin", "target": 0, "func": "void jabber_roster_request(JabberStream *js)\n{\n\tJabberIq *iq;\n\txmlnode *query;\n\tiq = jabber_iq_new_query(js, JABBER_IQ_GET, \"jabber:iq:roster\");\n\tquery = xmlnode_get_child(iq->node, \"query\");\n\tif (js->server_caps & JABBER_CAP_GOOGLE_ROSTER) {\n\t\txmlnode_set_attrib(query, \"xmlns:gr\", NS_GOOGLE_ROSTER);\n\t\txmlnode_set_attrib(query, \"gr:ext\", \"2\");\n\t}\n\tjabber_iq_set_callback(iq, roster_request_cb, NULL);\n\tjabber_iq_send(iq);\n}\n", "bug_type": null, "idx": 954}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_debug_init(void)\n{\n\t\n\t\n\tpurple_prefs_add_none(PIDGIN_PREFS_ROOT \"/debug\");\n\t\n\tpurple_prefs_add_bool(PIDGIN_PREFS_ROOT \"/debug/enabled\", FALSE);\n\tpurple_prefs_add_int(PIDGIN_PREFS_ROOT \"/debug/filterlevel\", PURPLE_DEBUG_ALL);\n\tpurple_prefs_add_int(PIDGIN_PREFS_ROOT \"/debug/style\", GTK_TOOLBAR_BOTH_HORIZ);\n\tpurple_prefs_add_bool(PIDGIN_PREFS_ROOT \"/debug/toolbar\", TRUE);\n\tpurple_prefs_add_int(PIDGIN_PREFS_ROOT \"/debug/width\",  450);\n\tpurple_prefs_add_int(PIDGIN_PREFS_ROOT \"/debug/height\", 250);\n#ifdef USE_REGEX\n\tpurple_prefs_add_string(PIDGIN_PREFS_ROOT \"/debug/regex\", \"\");\n\tpurple_prefs_add_bool(PIDGIN_PREFS_ROOT \"/debug/filter\", FALSE);\n\tpurple_prefs_add_bool(PIDGIN_PREFS_ROOT \"/debug/invert\", FALSE);\n\tpurple_prefs_add_bool(PIDGIN_PREFS_ROOT \"/debug/case_insensitive\", FALSE);\n\tpurple_prefs_add_bool(PIDGIN_PREFS_ROOT \"/debug/highlight\", FALSE);\n#endif \n\tpurple_prefs_connect_callback(NULL, PIDGIN_PREFS_ROOT \"/debug/enabled\",\n\t\t\t\t\t\t\t\tdebug_enabled_cb, NULL);\n#define REGISTER_G_LOG_HANDLER(name) \\\n\tg_log_set_handler((name), G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL \\\n\t\t\t\t\t  | G_LOG_FLAG_RECURSION, \\\n\t\t\t\t\t  pidgin_glib_log_handler, NULL)\n\t\n\tREGISTER_G_LOG_HANDLER(NULL);\n\tREGISTER_G_LOG_HANDLER(\"Gdk\");\n\tREGISTER_G_LOG_HANDLER(\"Gtk\");\n\tREGISTER_G_LOG_HANDLER(\"GdkPixbuf\");\n\tREGISTER_G_LOG_HANDLER(\"GLib\");\n\tREGISTER_G_LOG_HANDLER(\"GModule\");\n\tREGISTER_G_LOG_HANDLER(\"GLib-GObject\");\n\tREGISTER_G_LOG_HANDLER(\"GThread\");\n#ifdef USE_GSTREAMER\n\tREGISTER_G_LOG_HANDLER(\"GStreamer\");\n#endif\n#ifdef _WIN32\n\tif (!purple_debug_is_enabled())\n\t\tg_set_print_handler(pidgin_glib_dummy_print_handler);\n#endif\n}\n", "bug_type": null, "idx": 955}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_media_finalize (GObject *media)\n{\n\tFinchMedia *gntmedia = FINCH_MEDIA(media);\n\tpurple_debug_info(\"gntmedia\", \"finch_media_finalize\\n\");\n\tif (gntmedia->priv->media)\n\t\tg_object_unref(gntmedia->priv->media);\n}\n", "bug_type": null, "idx": 956}
{"project": "Pidgin", "target": 0, "func": "\nstatic gchar **session_make_command(gchar *client_id, gchar *config_dir) {\n\tgint i = 4;\n\tgint j = 0;\n\tgchar **ret;\n\tif (client_id) i += 2;\n\tif (config_dir)\ti += 2; \n\tret = g_new(gchar *, i);\n\tret[j++] = g_strdup(myself);\n\tif (client_id) {\n\t\tret[j++] = g_strdup(\"--session\");\n\t\tret[j++] = g_strdup(client_id);\n\t}\n\tif (config_dir) {\n\t\tret[j++] = g_strdup(\"--config\");\n\t\tret[j++] = g_strdup(config_dir);\n\t}\n\tret[j++] = g_strdup(\"--display\");\n\tret[j++] = g_strdup((gchar *)gdk_display_get_name(gdk_display_get_default()));\n\tret[j] = NULL;\n\treturn ret;\n}\n", "bug_type": null, "idx": 957}
{"project": "Pidgin", "target": 0, "func": "static void\nwork_around_for_ncurses_bug(void)\n{\n#ifndef NO_WIDECHAR\n\tPANEL *panel = NULL;\n\twhile ((panel = panel_below(panel)) != NULL) {\n\t\tint sx, ex, sy, ey, w, y;\n\t\tcchar_t ch;\n\t\tPANEL *below = panel;\n\t\tsx = panel->win->_begx;\n\t\tex = panel->win->_maxx + sx;\n\t\tsy = panel->win->_begy;\n\t\tey = panel->win->_maxy + sy;\n\t\twhile ((below = panel_below(below)) != NULL) {\n\t\t\tif (sy > below->win->_begy + below->win->_maxy ||\n\t\t\t\t\tey < below->win->_begy)\n\t\t\t\tcontinue;\n\t\t\tif (sx > below->win->_begx + below->win->_maxx ||\n\t\t\t\t\tex < below->win->_begx)\n\t\t\t\tcontinue;\n\t\t\tfor (y = MAX(sy, below->win->_begy); y <= MIN(ey, below->win->_begy + below->win->_maxy); y++) {\n\t\t\t\tif (mvwin_wch(below->win, y - below->win->_begy, sx - 1 - below->win->_begx, &ch) != OK)\n\t\t\t\t\tgoto right;\n\t\t\t\tw = widestringwidth(ch.chars);\n\t\t\t\tif (w > 1 && (ch.attr & 1)) {\n\t\t\t\t\tch.chars[0] = ' ';\n\t\t\t\t\tch.attr &= ~ A_CHARTEXT;\n\t\t\t\t\tmvwadd_wch(below->win, y - below->win->_begy, sx - 1 - below->win->_begx, &ch);\n\t\t\t\t\ttouchline(below->win, y - below->win->_begy, 1);\n\t\t\t\t}\nright:\n\t\t\t\tif (mvwin_wch(below->win, y - below->win->_begy, ex + 1 - below->win->_begx, &ch) != OK)\n\t\t\t\t\tcontinue;\n\t\t\t\tw = widestringwidth(ch.chars);\n\t\t\t\tif (w > 1 && !(ch.attr & 1)) {\n\t\t\t\t\tch.chars[0] = ' ';\n\t\t\t\t\tch.attr &= ~ A_CHARTEXT;\n\t\t\t\t\tmvwadd_wch(below->win, y - below->win->_begy, ex + 1 - below->win->_begx, &ch);\n\t\t\t\t\ttouchline(below->win, y - below->win->_begy, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n", "bug_type": null, "idx": 958}
{"project": "Pidgin", "target": 0, "func": "static gchar *escape_username(const gchar *in)\n{\n\tgchar *tmp, *tmp2;\n\ttmp = purple_strreplace(in, \"=\", \"=3D\");\n\ttmp2 = purple_strreplace(tmp, \",\", \"=2C\");\n\tg_free(tmp);\n\treturn tmp2;\n}\n", "bug_type": null, "idx": 959}
{"project": "Pidgin", "target": 0, "func": "void\npurple_presence_set_login_time(PurplePresence *presence, time_t login_time)\n{\n\tg_return_if_fail(presence != NULL);\n\tif (presence->login_time == login_time)\n\t\treturn;\n\tpresence->login_time = login_time;\n}\n", "bug_type": null, "idx": 960}
{"project": "Pidgin", "target": 0, "func": "static void\nbuddy_typing_cb(PurpleAccount *account, const char *name, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"buddy-typing (%s, %s)\\n\",\n\t\t\t\t\tpurple_account_get_username(account), name);\n}\n", "bug_type": null, "idx": 961}
{"project": "Pidgin", "target": 0, "func": "void gtk_ticker_stop_scroll(GtkTicker *ticker)\n{\n\tg_return_if_fail (ticker != NULL);\n\tg_return_if_fail (GTK_IS_TICKER (ticker));\n\tif ( ticker->timer == 0 )\n\t\treturn;\n\tg_source_remove(ticker->timer);\n\tticker->timer = 0;\n}\n", "bug_type": null, "idx": 962}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_registration_result_cb(JabberStream *js, const char *from,\n                              JabberIqType type, const char *id,\n                              xmlnode *packet, gpointer data)\n{\n\tPurpleAccount *account = purple_connection_get_account(js->gc);\n\tchar *buf;\n\tchar *to = data;\n\tif (type == JABBER_IQ_RESULT) {\n\t\tif(js->registration) {\n\t\t\tbuf = g_strdup_printf(_(\"Registration of %s@%s successful\"),\n\t\t\t\t\tjs->user->node, js->user->domain);\n\t\t\tif(account->registration_cb)\n\t\t\t\t(account->registration_cb)(account, TRUE, account->registration_cb_user_data);\n\t\t} else {\n\t\t\tg_return_if_fail(to != NULL);\n\t\t\tbuf = g_strdup_printf(_(\"Registration to %s successful\"),\n\t\t\t\tto);\n\t\t}\n\t\tpurple_notify_info(NULL, _(\"Registration Successful\"),\n\t\t\t\t_(\"Registration Successful\"), buf);\n\t\tg_free(buf);\n\t} else {\n\t\tchar *msg = jabber_parse_error(js, packet, NULL);\n\t\tif(!msg)\n\t\t\tmsg = g_strdup(_(\"Unknown Error\"));\n\t\tpurple_notify_error(NULL, _(\"Registration Failed\"),\n\t\t\t\t_(\"Registration Failed\"), msg);\n\t\tg_free(msg);\n\t\tif(account->registration_cb)\n\t\t\t(account->registration_cb)(account, FALSE, account->registration_cb_user_data);\n\t}\n\tg_free(to);\n\tif(js->registration)\n\t\tjabber_connection_schedule_close(js);\n}\n", "bug_type": null, "idx": 963}
{"project": "Pidgin", "target": 0, "func": "\nstatic void gtk_appbar_dispatch_dock_cbs(GtkAppBar *ab, gboolean val) {\n        GSList *lst = ab->dock_cbs;\n        while(lst) {\n                GtkAppBarDockCB dock_cb = lst->data;\n                dock_cb(val);\n                lst = lst->next;\n        }\n}\n", "bug_type": null, "idx": 964}
{"project": "Pidgin", "target": 0, "func": "static void\nunnotify(PurpleConversation *conv, gboolean reset)\n{\n\tPurpleConversation *active_conv = NULL;\n\tPidginWindow *purplewin = NULL;\n\tg_return_if_fail(conv != NULL);\n\tif (PIDGIN_CONVERSATION(conv) == NULL)\n\t\treturn;\n\tpurplewin = PIDGIN_CONVERSATION(conv)->win;\n\tactive_conv = pidgin_conv_window_get_active_conversation(purplewin);\n\t\n\tpurple_conversation_autoset_title(active_conv);\n\tif (reset) {\n\t\t\n\t\thandle_urgent(purplewin, FALSE);\n\t\tpurple_conversation_set_data(conv, \"notify-message-count\", GINT_TO_POINTER(0));\n\t\t\n\t\thandle_count_xprop(purplewin);\n\t}\n\treturn;\n}\n", "bug_type": null, "idx": 965}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_conv_chat_is_user_ignored(const PurpleConvChat *chat, const char *user)\n{\n\tg_return_val_if_fail(chat != NULL, FALSE);\n\tg_return_val_if_fail(user != NULL, FALSE);\n\treturn (purple_conv_chat_get_ignored_user(chat, user) != NULL);\n}\n", "bug_type": null, "idx": 966}
{"project": "Pidgin", "target": 0, "func": "void\nnm_user_add_user_record(NMUser * user, NMUserRecord * user_record)\n{\n\tconst char *display_id;\n\tconst char *dn;\n\tif (!user || !user_record)\n\t\treturn;\n\tdisplay_id = nm_user_record_get_display_id(user_record);\n\tdn = nm_user_record_get_dn(user_record);\n\tif (!dn || !display_id)\n\t\treturn;\n\tnm_user_record_add_ref(user_record);\n\tg_hash_table_insert(user->user_records,\n\t\t\t\t\t\tg_utf8_strdown(dn, -1),\n\t\t\t\t\t\tuser_record);\n\tg_hash_table_insert(user->display_id_to_dn,\n\t\t\t\t\t\tg_utf8_strdown(display_id, -1),\n\t\t\t\t\t\tg_utf8_strdown(dn, -1));\n}\n", "bug_type": null, "idx": 967}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nauto_join_chats(gpointer data)\n{\n\tPurpleBlistNode *node;\n\tPurpleConnection *pc = data;\n\tPurpleAccount *account = purple_connection_get_account(pc);\n\tfor (node = purple_blist_get_root(); node;\n\t\t\tnode = purple_blist_node_next(node, FALSE)) {\n\t\tif (PURPLE_BLIST_NODE_IS_CHAT(node)) {\n\t\t\tPurpleChat *chat = (PurpleChat*)node;\n\t\t\tif (purple_chat_get_account(chat) == account &&\n\t\t\t\t\tpurple_blist_node_get_bool(node, \"gnt-autojoin\"))\n\t\t\t\tserv_join_chat(purple_account_get_connection(account), purple_chat_get_components(chat));\n\t\t}\n\t}\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 968}
{"project": "Pidgin", "target": 0, "func": "GType s_get_gtype(void)\n{\n\tstatic GType type = 0;\n\tif(type == 0) {\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(SClass),\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tNULL,\t\t\t\t\t\n\t\t\t(GClassInitFunc)s_class_init,\n\t\t\tNULL,\n\t\t\tNULL,                   \n\t\t\tsizeof(S),\n\t\t\t0,                      \n\t\t\tNULL,\t            \n\t\t\tNULL\n\t\t};\n\t\ttype = g_type_register_static(GNT_TYPE_WM,\n\t\t\t\t\t\t\t\t\t  \"GntS\",\n\t\t\t\t\t\t\t\t\t  &info, 0);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 969}
{"project": "Pidgin", "target": 0, "func": "GType\npurple_theme_loader_get_type(void)\n{\n\tstatic GType type = 0;\n\tif (type == 0) {\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(PurpleThemeLoaderClass),\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\t(GClassInitFunc)purple_theme_loader_class_init, \n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tsizeof(PurpleThemeLoader),\n\t\t\t0, \n\t\t\tpurple_theme_loader_init, \n\t\t\tNULL, \n\t\t};\n\t\ttype = g_type_register_static(G_TYPE_OBJECT,\n\t\t\t\t\"PurpleThemeLoader\", &info, G_TYPE_FLAG_ABSTRACT);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 970}
{"project": "Pidgin", "target": 0, "func": " */\nstatic gboolean plugin_load(PurplePlugin *plugin) {\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\"conversation-created\", plugin,\n\t\tPURPLE_CALLBACK(new_conversation_cb), NULL);\n\t\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\"deleting-conversation\", plugin,\n\t\tPURPLE_CALLBACK(conversation_delete_cb), NULL);\n\tpurple_signal_connect(pidgin_conversations_get_handle(),\n\t\t\"conversation-dragging\", plugin,\n\t\tPURPLE_CALLBACK(set_conv_window_trans), NULL);\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\"conversation-updated\", plugin,\n\t\tPURPLE_CALLBACK(conv_updated_cb), NULL);\n\tupdate_existing_convs();\n\tif (blist)\n\t\tblist_created_cb(NULL, NULL);\n\telse\n\t\tpurple_signal_connect(pidgin_blist_get_handle(),\n\t\t\t\"gtkblist-created\", plugin,\n\t\t\tPURPLE_CALLBACK(blist_created_cb), NULL);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 971}
{"project": "Pidgin", "target": 0, "func": "void\noscar_chat_destroy(struct chat_connection *cc)\n{\n\tg_free(cc->name);\n\tg_free(cc->show);\n\tg_free(cc);\n}\n", "bug_type": null, "idx": 972}
{"project": "Pidgin", "target": 0, "func": "gpointer\npurple_media_get_prpl_data(PurpleMedia *media)\n{\n#ifdef USE_VV\n\tgpointer prpl_data;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA(media), NULL);\n\tg_object_get(G_OBJECT(media), \"prpl-data\", &prpl_data, NULL);\n\treturn prpl_data;\n#else\n\treturn NULL;\n#endif\n}\n", "bug_type": null, "idx": 973}
{"project": "Pidgin", "target": 0, "func": "GList *\npurple_plugins_get_loaded(void)\n{\n\treturn loaded_plugins;\n}\n", "bug_type": null, "idx": 974}
{"project": "Pidgin", "target": 0, "func": "PurpleSslConnection *\npurple_ssl_connect(PurpleAccount *account, const char *host, int port,\n\t\t\t\t PurpleSslInputFunction func, PurpleSslErrorFunction error_func,\n\t\t\t\t void *data)\n{\n\treturn purple_ssl_connect_with_ssl_cn(account, host, port, func, error_func,\n\t                                  NULL, data);\n}\n", "bug_type": null, "idx": 975}
{"project": "Pidgin", "target": 0, "func": "static PurpleBuddy *\nfind_buddy_for_conversation(PurpleConversation *conv)\n{\n\treturn purple_find_buddy(purple_conversation_get_account(conv),\n\t\t\tpurple_conversation_get_name(conv));\n}\n", "bug_type": null, "idx": 976}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_dialogs_im_with_user(PurpleAccount *account, const char *username)\n{\n\tPurpleConversation *conv;\n\tg_return_if_fail(account != NULL);\n\tg_return_if_fail(username != NULL);\n\tconv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, username, account);\n\tif (conv == NULL)\n\t\tconv = purple_conversation_new(PURPLE_CONV_TYPE_IM, account, username);\n\tpidgin_conv_attach_to_conversation(conv);\n\tpurple_conversation_present(conv);\n}\n", "bug_type": null, "idx": 977}
{"project": "Pidgin", "target": 0, "func": "PurpleSavedStatus *\npurple_savedstatus_get_startup()\n{\n\ttime_t creation_time;\n\tPurpleSavedStatus *saved_status = NULL;\n\tcreation_time = purple_prefs_get_int(\"/purple/savedstatus/startup\");\n\tif (creation_time != 0)\n\t\tsaved_status = g_hash_table_lookup(creation_times, (gconstpointer)creation_time);\n\tif (saved_status == NULL)\n\t{\n\t\t\n\t\tsaved_status = purple_savedstatus_get_current();\n\t}\n\treturn saved_status;\n}\n", "bug_type": null, "idx": 978}
{"project": "Pidgin", "target": 0, "func": "SV *\nnewSVGChar(const char *str)\n{\n\tSV *sv;\n\tif (str == NULL)\n\t\treturn &PL_sv_undef;\n\tsv = newSVpv(str, 0);\n\tSvUTF8_on(sv);\n\treturn sv;\n}\n", "bug_type": null, "idx": 979}
{"project": "Pidgin", "target": 0, "func": "void gtk_appbar_dock(GtkAppBar *ab, UINT side) {\n\tHWND hwnd;\n\tg_return_if_fail(ab != NULL);\n\thwnd = GDK_WINDOW_HWND(ab->win->window);\n\tg_return_if_fail(IsWindow(hwnd));\n\tab->iconized = IsIconic(hwnd);\n\tif (!ab->docked && !ab->iconized)\n\t\tShowWindow(hwnd, SW_HIDE);\n\tgtk_appbar_do_dock(ab, side);\n\tset_toolbar(hwnd, TRUE);\n\tif (!ab->iconized)\n\t\tShowWindow(hwnd, SW_SHOW);\n}\n", "bug_type": null, "idx": 980}
{"project": "Pidgin", "target": 0, "func": "static GstFlowReturn\nappsink_new_preroll (GstAppSink *appsink, gpointer user_data)\n{\n\treturn GST_FLOW_OK;\n}\n", "bug_type": null, "idx": 981}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ngoogle_session_id_equal(gconstpointer a, gconstpointer b)\n{\n\tGoogleSessionId *c = (GoogleSessionId*)a;\n\tGoogleSessionId *d = (GoogleSessionId*)b;\n\treturn !strcmp(c->id, d->id) && !strcmp(c->initiator, d->initiator);\n}\n", "bug_type": null, "idx": 982}
{"project": "Pidgin", "target": 0, "func": "static int\nrtf_print_unicode_char(NMRtfContext *ctx, gunichar ch)\n{\n\tchar buf[7];\n\tint num;\n\t\n\trtf_flush_data(ctx);\n\t\n\tnum = g_unichar_to_utf8((gunichar) ch, buf);\n\tbuf[num] = 0;\n\tpurple_debug_info(\"novell\", \"converted unichar 0x%X to utf8 char %s\\n\", ch, buf);\n\tctx->output = g_string_append(ctx->output, buf);\n\treturn NMRTF_OK;\n}\n", "bug_type": null, "idx": 983}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_button_map(GntWidget *widget)\n{\n\tif (widget->priv.width == 0 || widget->priv.height == 0)\n\t\tgnt_widget_size_request(widget);\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 984}
{"project": "Pidgin", "target": 0, "func": "static void\nwidget_move_ws(gpointer wid, gpointer w)\n{\n\tGntWM *wm = GNT_WM(w);\n\tgnt_wm_widget_move_workspace(wm, wm->cws, GNT_WIDGET(wid));\n}\n", "bug_type": null, "idx": 985}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nclose_button_left_cb(GtkWidget *widget, GdkEventCrossing *event, GtkLabel *label)\n{\n\tstatic GdkCursor *ptr = NULL;\n\tif (ptr == NULL) {\n\t\tptr = gdk_cursor_new(GDK_LEFT_PTR);\n\t}\n\tgtk_label_set_markup(label, \"\u00c3\u2014\");\n\tgdk_window_set_cursor(event->window, ptr);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 986}
{"project": "Pidgin", "target": 0, "func": "static void\nsync_pounces(void)\n{\n\txmlnode *node;\n\tchar *data;\n\tif (!pounces_loaded)\n\t{\n\t\tpurple_debug_error(\"pounce\", \"Attempted to save buddy pounces before \"\n\t\t\t\t\t\t \"they were read!\\n\");\n\t\treturn;\n\t}\n\tnode = pounces_to_xmlnode();\n\tdata = xmlnode_to_formatted_str(node, NULL);\n\tpurple_util_write_data_to_file(\"pounces.xml\", data, -1);\n\tg_free(data);\n\txmlnode_free(node);\n}\n", "bug_type": null, "idx": 987}
{"project": "Pidgin", "target": 0, "func": "static void connection_remove(struct simple_account_data *sip, int fd) {\n\tstruct sip_connection *conn = connection_find(sip, fd);\n\tsip->openconns = g_slist_remove(sip->openconns, conn);\n\tif(conn->inputhandler) purple_input_remove(conn->inputhandler);\n\tg_free(conn->inbuf);\n\tg_free(conn);\n}\n", "bug_type": null, "idx": 988}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_set_silence_suppression(PurpleAccount *account, gboolean value)\n{\n\tg_return_if_fail(account != NULL);\n\tpurple_account_set_bool(account, \"silence-suppression\", value);\n}\n", "bug_type": null, "idx": 989}
{"project": "Pidgin", "target": 1, "func": "static void mxit_cb_http_read( gpointer user_data, gint source, PurpleInputCondition cond )\n{\n\tstruct MXitSession*\tsession\t\t= (struct MXitSession*) user_data;\n\tchar\t\t\t\tbuf[256];\n\tint\t\t\t\t\tbuflen;\n\tchar*\t\t\t\tbody;\n\tint\t\t\t\t\tbodylen;\n\tchar*\t\t\t\tch;\n\tint\t\t\t\t\tlen;\n\tchar*\t\t\t\ttmp;\n\tint\t\t\t\t\tres;\n\tchar*\t\t\t\tnext;\n\tpurple_debug_info( MXIT_PLUGIN_ID, \"mxit_cb_http_read\\n\" );\n\tif ( session->rx_state == RX_STATE_RLEN ) {\n\t\t\n\t\t\n\t\tmemcpy( buf, session->rx_dbuf, session->rx_i );\n\t\tbuflen = session->rx_i;\n\t\t\n\t\tlen = read( session->fd, buf + buflen, sizeof( buf ) - buflen );\n\t\tif ( len <= 0 ) {\n\t\t\t\n\t\t\tgoto done;\n\t\t}\n//nextpacket:\n#ifdef\tDEBUG_HTTP\n\t\tpurple_debug_info( MXIT_PLUGIN_ID, \"HTTP POST READ 1: (%i)\\n\", len );\n\t\tdump_bytes( session, buf + buflen, len );\n#endif\n\t\t\n\t\tch = strstr( buf, HTTP_11_SEPERATOR );\n\t\tif ( !ch ) {\n\t\t\t\n\t\t\tsession->rx_i = buflen + len;\n\t\t\tmemcpy( session->rx_dbuf, buf, session->rx_i );\n\t\t\treturn;\n\t\t}\n\t\tbuflen += len;\n\t\t\n\t\tch += strlen( HTTP_11_SEPERATOR );\n\t\t*(ch - 1) = '\\0';\n\t\tbody = ch;\n\t\tres = buflen - ( ch - buf );\n\t\tif ( res > 0 ) {\n\t\t\t\n\t\t\tmemcpy( session->rx_dbuf, ch, res );\n\t\t\tsession->rx_i = res;\n\t\t}\n\t\telse {\n\t\t\tsession->rx_i = 0;\n\t\t}\n\t\t\n\t\tif ( ( strncmp( buf, HTTP_11_200_OK, strlen( HTTP_11_200_OK ) ) != 0 ) && ( strncmp( buf, HTTP_11_100_CONT, strlen( HTTP_11_100_CONT ) ) != 0 ) ) {\n\t\t\t\n\t\t\tpurple_debug_error( MXIT_PLUGIN_ID, \"HTTP error: %s\\n\", ch );\n\t\t\tgoto done;\n\t\t}\n\t\t\n\t\tch = (char*) purple_strcasestr( buf, HTTP_CONTENT_LEN );\n\t\tif ( !ch ) {\n\t\t\t\n\t\t\tpurple_debug_error( MXIT_PLUGIN_ID, \"HTTP reply received without content-length header (ignoring packet)\\n\" );\n\t\t\tgoto done;\n\t\t}\n\t\t\n\t\tch += strlen( HTTP_CONTENT_LEN );\n\t\ttmp = strchr( ch, '\\r' );\n\t\tif ( !tmp ) {\n\t\t\tpurple_debug_error( MXIT_PLUGIN_ID, \"Received bad HTTP reply packet (ignoring packet)\\n\" );\n\t\t\tgoto done;\n\t\t}\n\t\ttmp = g_strndup( ch, tmp - ch );\n\t\tbodylen = atoi( tmp );\n\t\tg_free( tmp );\n\t\ttmp = NULL;\n\t\tif ( buflen > ( ( body - buf ) + bodylen ) ) {\n\t\t\t\n\t\t\tnext = body + bodylen;\n\t\t\tsession->rx_res = 0;\n\t\t}\n\t\telse {\n\t\t\tsession->rx_res = bodylen - session->rx_i;\n\t\t}\n\t\tif ( session->rx_res == 0 ) {\n\t\t\t\n\t\t\tsession->rx_i = bodylen;\n\t\t\tsession->rx_state = RX_STATE_PROC;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tsession->rx_state = RX_STATE_DATA;\n\t\t}\n\t}\n\telse if ( session->rx_state == RX_STATE_DATA ) {\n\t\t\n\t\t\n\t\tlen = read( session->fd, &session->rx_dbuf[session->rx_i], session->rx_res );\n\t\tif ( len <= 0 ) {\n\t\t\t\n\t\t\tgoto done;\n\t\t}\n#ifdef\tDEBUG_HTTP\n\t\tpurple_debug_info( MXIT_PLUGIN_ID, \"HTTP POST READ 2: (%i)\\n\", len );\n\t\tdump_bytes( session, &session->rx_dbuf[session->rx_i], len );\n#endif\n\t\tsession->rx_i += len;\n\t\tsession->rx_res -= len;\n\t\tif ( session->rx_res == 0 ) {\n\t\t\t\n\t\t\tsession->rx_state = RX_STATE_PROC;\n\t\t}\n\t}\n\tif ( session->rx_state == RX_STATE_PROC ) {\n\t\tmxit_parse_packet( session );\n#if\t0\n\t\tif ( next ) {\n\t\t\t\n\t\t\t\n\t\t\tsession->rx_state = RX_STATE_RLEN;\n\t\t\tsession->rx_lbuf[0] = '\\0';\n\t\t\tsession->rx_i = 0;\n\t\t\tsession->rx_res = 0;\n\t\t\t\n\t\t\tlen = next - buf;\n\t\t\tbuflen = len;\n\t\t\tmemcpy( buf, next, len );\n\t\t\tgoto nextpacket;\n\t\t}\n#endif\n\t\t\n\t\tgoto done;\n\t}\n\treturn;\ndone:\n\tclose( session->fd );\n\tpurple_input_remove( session->http_handler );\n\tsession->http_handler = 0;\n}\n", "bug_type": "CVE-2013-0272", "idx": 990}
{"project": "Pidgin", "target": 0, "func": " */\nint aim_tlvlist_replace_32(GSList **list, const guint16 type, const guint32 value)\n{\n\tguint8 v32[4];\n\t(void)aimutil_put32(v32, value);\n\treturn aim_tlvlist_replace_raw(list, type, 4, v32);\n}\n", "bug_type": null, "idx": 991}
{"project": "Pidgin", "target": 0, "func": "void purple_conversation_clear_message_history(PurpleConversation *conv)\n{\n\tGList *list = conv->message_history;\n\tmessage_history_free(list);\n\tconv->message_history = NULL;\n\tpurple_signal_emit(purple_conversations_get_handle(),\n\t\t\t\"cleared-message-history\", conv);\n}\n", "bug_type": null, "idx": 992}
{"project": "Pidgin", "target": 0, "func": "static int\nsnachandler(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tif (snac->subtype == 0x0001)\n\t\treturn error(od, conn, mod, frame, snac, bs);\n\telse if (snac->subtype == 0x0009)\n\t\treturn parseinfo(od, conn, mod, frame, snac, bs);\n\treturn 0;\n}\n", "bug_type": null, "idx": 993}
{"project": "Pidgin", "target": 0, "func": "static void\nupdate_user_splits(AccountEditDialog *dialog)\n{\n\tGntWidget *hbox;\n\tPurplePlugin *plugin;\n\tPurplePluginProtocolInfo *prplinfo;\n\tGList *iter, *entries;\n\tchar *username = NULL;\n\tif (dialog->splits)\n\t{\n\t\tgnt_box_remove_all(GNT_BOX(dialog->splits));\n\t\tg_list_free(dialog->split_entries);\n\t}\n\telse\n\t{\n\t\tdialog->splits = gnt_vbox_new(FALSE);\n\t\tgnt_box_set_pad(GNT_BOX(dialog->splits), 0);\n\t\tgnt_box_set_fill(GNT_BOX(dialog->splits), TRUE);\n\t}\n\tdialog->split_entries = NULL;\n\tplugin = gnt_combo_box_get_selected_data(GNT_COMBO_BOX(dialog->protocol));\n\tif (!plugin)\n\t\treturn;\n\tprplinfo = PURPLE_PLUGIN_PROTOCOL_INFO(plugin);\n\tusername = dialog->account ? g_strdup(purple_account_get_username(dialog->account)) : NULL;\n\tfor (iter = prplinfo->user_splits; iter; iter = iter->next)\n\t{\n\t\tPurpleAccountUserSplit *split = iter->data;\n\t\tGntWidget *entry;\n\t\tchar *buf;\n\t\thbox = gnt_hbox_new(TRUE);\n\t\tgnt_box_add_widget(GNT_BOX(dialog->splits), hbox);\n\t\tbuf = g_strdup_printf(\"%s:\", purple_account_user_split_get_text(split));\n\t\tgnt_box_add_widget(GNT_BOX(hbox), gnt_label_new(buf));\n\t\tentry = gnt_entry_new(NULL);\n\t\tgnt_box_add_widget(GNT_BOX(hbox), entry);\n\t\tdialog->split_entries = g_list_append(dialog->split_entries, entry);\n\t\tg_free(buf);\n\t}\n\tfor (iter = g_list_last(prplinfo->user_splits), entries = g_list_last(dialog->split_entries);\n\t\t\titer && entries; iter = iter->prev, entries = entries->prev)\n\t{\n\t\tGntWidget *entry = entries->data;\n\t\tPurpleAccountUserSplit *split = iter->data;\n\t\tconst char *value = NULL;\n\t\tchar *s;\n\t\tif (dialog->account)\n\t\t{\n\t\t\tif(purple_account_user_split_get_reverse(split))\n\t\t\t\ts = strrchr(username, purple_account_user_split_get_separator(split));\n\t\t\telse\n\t\t\t\ts = strchr(username, purple_account_user_split_get_separator(split));\n\t\t\tif (s != NULL)\n\t\t\t{\n\t\t\t\t*s = '\\0';\n\t\t\t\ts++;\n\t\t\t\tvalue = s;\n\t\t\t}\n\t\t}\n\t\tif (value == NULL)\n\t\t\tvalue = purple_account_user_split_get_default_value(split);\n\t\tif (value != NULL)\n\t\t\tgnt_entry_set_text(GNT_ENTRY(entry), value);\n\t}\n\tif (username != NULL)\n\t\tgnt_entry_set_text(GNT_ENTRY(dialog->username), username);\n\tg_free(username);\n}\n", "bug_type": null, "idx": 994}
{"project": "Pidgin", "target": 0, "func": "#include <string.h>\nvoid jabber_message_free(JabberMessage *jm)\n{\n\tg_free(jm->from);\n\tg_free(jm->to);\n\tg_free(jm->id);\n\tg_free(jm->subject);\n\tg_free(jm->body);\n\tg_free(jm->xhtml);\n\tg_free(jm->password);\n\tg_free(jm->error);\n\tg_free(jm->thread_id);\n\tg_list_free(jm->etc);\n\tg_list_free(jm->eventitems);\n\tg_free(jm);\n}\n", "bug_type": null, "idx": 995}
{"project": "Pidgin", "target": 0, "func": "PurpleAccount *\npurple_media_get_account(PurpleMedia *media)\n{\n#ifdef USE_VV\n\tPurpleAccount *account;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA(media), NULL);\n\tg_object_get(G_OBJECT(media), \"account\", &account, NULL);\n\treturn account;\n#else\n\treturn NULL;\n#endif\n}\n", "bug_type": null, "idx": 996}
{"project": "Pidgin", "target": 0, "func": "GList *\npurple_get_ims(void)\n{\n\treturn ims;\n}\n", "bug_type": null, "idx": 997}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_blist_get_ui_data()\n{\n\treturn purplebuddylist->ui_data;\n}\n", "bug_type": null, "idx": 998}
{"project": "Pidgin", "target": 0, "func": "PurpleMedia *\npurple_media_manager_create_media(PurpleMediaManager *manager,\n\t\t\t\t  PurpleAccount *account,\n\t\t\t\t  const char *conference_type,\n\t\t\t\t  const char *remote_user,\n\t\t\t\t  gboolean initiator)\n{\n\treturn create_media (manager, account, conference_type,\n\t\t\t\t\t\t  remote_user, initiator, FALSE);\n}\n", "bug_type": null, "idx": 999}
{"project": "Pidgin", "target": 0, "func": "GType\ngnt_ws_get_gtype(void)\n{\n\tstatic GType type = 0;\n\tif(type == 0) {\n\t\tstatic const GTypeInfo info = {\n\t\t\tsizeof(GntWSClass),\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tNULL,\n\t\t\t\n\t\t\tNULL,\n\t\t\tNULL,\t\t\t\t\t\n\t\t\tsizeof(GntWS),\n\t\t\t0,\t\t\t\t\t\t\n\t\t\tgnt_ws_init,\t\t\t\n\t\t\tNULL\t\t\t\t\t\n\t\t};\n\t\ttype = g_type_register_static(GNT_TYPE_BINDABLE,\n\t\t\t\t\t\t\t\t\t  \"GntWS\",\n\t\t\t\t\t\t\t\t\t  &info, 0);\n\t}\n\treturn type;\n}\n", "bug_type": null, "idx": 1000}
{"project": "Pidgin", "target": 0, "func": "static void\njingle_terminate_sessions_gh(gpointer key, gpointer value, gpointer user_data)\n{\n\tg_object_unref(value);\n}\n", "bug_type": null, "idx": 1001}
{"project": "Pidgin", "target": 0, "func": "gboolean\njabber_video_enabled(JabberStream *js, const char *namespace)\n{\n\tPurpleMediaManager *manager = purple_media_manager_get();\n\tPurpleMediaCaps caps = purple_media_manager_get_ui_caps(manager);\n\treturn (caps & (PURPLE_MEDIA_CAPS_VIDEO | PURPLE_MEDIA_CAPS_VIDEO_SINGLE_DIRECTION));\n}\n", "bug_type": null, "idx": 1002}
{"project": "Pidgin", "target": 0, "func": "const gchar *\njabber_roster_group_get_global_name(PurpleGroup *group)\n{\n\tconst gchar *name = NULL;\n\tif (group)\n\t\tname = purple_group_get_name(group);\n\tif (name == NULL)\n\t\tname = JABBER_ROSTER_DEFAULT_GROUP;\n\telse if (g_strcmp0(name, _(\"Buddies\")) == 0)\n\t\tname = JABBER_ROSTER_DEFAULT_GROUP;\n\t\n\treturn name;\n}\n", "bug_type": null, "idx": 1003}
{"project": "Pidgin", "target": 0, "func": "static char *\nuserinfo_hash(PurpleAccount *account, const char *who)\n{\n\tchar key[256];\n\tsnprintf(key, sizeof(key), \"%s - %s\", purple_account_get_username(account), purple_normalize(account, who));\n\treturn g_utf8_strup(key, -1);\n}\n", "bug_type": null, "idx": 1004}
{"project": "Pidgin", "target": 0, "func": "static void *finch_notify_formatted(const char *title, const char *primary,\n\t\tconst char *secondary, const char *text)\n{\n\tchar *xhtml = NULL;\n\tchar *t = g_strdup_printf(\"<span>%s%s%s</span>\",\n\t\t\tsecondary ? secondary : \"\",\n\t\t\tsecondary ? \"\\n\" : \"\",\n\t\t\ttext ? text : \"\");\n\tvoid *ret;\n\tpurple_markup_html_to_xhtml(t, &xhtml, NULL);\n\tret = finch_notify_common(PURPLE_NOTIFY_FORMATTED,\n\t\tPURPLE_NOTIFY_MSG_INFO, title, primary, xhtml);\n\tg_free(t);\n\tg_free(xhtml);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1005}
{"project": "Pidgin", "target": 0, "func": "static void\nsignoff_cb(PurpleConnection *gc)\n{\n\tTickerData *td;\n\tif (!purple_connections_get_all()) {\n\t\twhile (tickerbuds) {\n\t\t\ttd = tickerbuds->data;\n\t\t\ttickerbuds = g_list_delete_link(tickerbuds, tickerbuds);\n\t\t\tif (td->timeout != 0)\n\t\t\t\tg_source_remove(td->timeout);\n\t\t\tg_free(td);\n\t\t}\n\t\tgtk_widget_destroy(tickerwindow);\n\t\ttickerwindow = NULL;\n\t\tticker = NULL;\n\t} else {\n\t\tGList *t = tickerbuds;\n\t\twhile (t) {\n\t\t\ttd = t->data;\n\t\t\tt = t->next;\n\t\t\tbuddy_ticker_update_contact(td->contact);\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1006}
{"project": "Pidgin", "target": 0, "func": "static void\nremove_pref(struct purple_pref *pref)\n{\n\tchar *name;\n\tGSList *l;\n\tif(!pref)\n\t\treturn;\n\twhile(pref->first_child)\n\t\tremove_pref(pref->first_child);\n\tif(pref == &prefs)\n\t\treturn;\n\tif(pref->parent->first_child == pref) {\n\t\tpref->parent->first_child = pref->sibling;\n\t} else {\n\t\tstruct purple_pref *sib = pref->parent->first_child;\n\t\twhile(sib && sib->sibling != pref)\n\t\t\tsib = sib->sibling;\n\t\tif(sib)\n\t\t\tsib->sibling = pref->sibling;\n\t}\n\tname = pref_full_name(pref);\n\tif (prefs_loaded)\n\t\tpurple_debug_info(\"prefs\", \"removing pref %s\\n\", name);\n\tg_hash_table_remove(prefs_hash, name);\n\tg_free(name);\n\tfree_pref_value(pref);\n\twhile((l = pref->callbacks) != NULL) {\n\t\tpref->callbacks = pref->callbacks->next;\n\t\tg_free(l->data);\n\t\tg_slist_free_1(l);\n\t}\n\tg_free(pref->name);\n\tg_free(pref);\n}\n", "bug_type": null, "idx": 1007}
{"project": "Pidgin", "target": 0, "func": "char *irc_mirc2txt (const char *string)\n{\n\tchar *result;\n\tint i, j;\n\tif (string == NULL)\n\t\treturn NULL;\n\tresult = g_strdup (string);\n\tfor (i = 0, j = 0; result[i]; i++) {\n\t\tswitch (result[i]) {\n\t\tcase '\\002':\n\t\tcase '\\003':\n\t\t\t\n\t\t\tif (isdigit(result[i + 1]))\n\t\t\t\ti++;\n\t\t\tif (isdigit(result[i + 1]))\n\t\t\t\ti++;\n\t\t\t\n\t\t\tif (result[i + 1] == ',') {\n\t\t\t\ti++;\n\t\t\t\tif (isdigit(result[i + 1]))\n\t\t\t\t\ti++;\n\t\t\t\tif (isdigit(result[i + 1]))\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\tcontinue;\n\t\tcase '\\007':\n\t\tcase '\\017':\n\t\tcase '\\026':\n\t\tcase '\\037':\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tresult[j++] = result[i];\n\t\t}\n\t}\n\tresult[j] = '\\0';\n\treturn result;\n}\n", "bug_type": null, "idx": 1008}
{"project": "Pidgin", "target": 0, "func": "guint16 byte_stream_getle16(ByteStream *bs)\n{\n\tg_return_val_if_fail(byte_stream_bytes_left(bs) >= 2, 0);\n\tbs->offset += 2;\n\treturn aimutil_getle16(bs->data + bs->offset - 2);\n}\n", "bug_type": null, "idx": 1009}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ngnt_tree_key_pressed(GntWidget *widget, const char *text)\n{\n\tGntTree *tree = GNT_TREE(widget);\n\tGntTreeRow *old = tree->current;\n\tif (text[0] == '\\r' || text[0] == '\\n') {\n\t\tend_search(tree);\n\t\tgnt_widget_activate(widget);\n\t} else if (tree->priv->search) {\n\t\tgboolean changed = TRUE;\n\t\tif (g_unichar_isprint(*text)) {\n\t\t\ttree->priv->search = g_string_append_c(tree->priv->search, *text);\n\t\t} else if (g_utf8_collate(text, GNT_KEY_BACKSPACE) == 0) {\n\t\t\tif (tree->priv->search->len)\n\t\t\t\ttree->priv->search->str[--tree->priv->search->len] = '\\0';\n\t\t} else\n\t\t\tchanged = FALSE;\n\t\tif (changed) {\n\t\t\tredraw_tree(tree);\n\t\t} else {\n\t\t\tgnt_bindable_perform_action_key(GNT_BINDABLE(tree), text);\n\t\t}\n\t\tg_source_remove(tree->priv->search_timeout);\n\t\ttree->priv->search_timeout = g_timeout_add_seconds(SEARCH_TIMEOUT_S, search_timeout, tree);\n\t\treturn TRUE;\n\t} else if (text[0] == ' ' && text[1] == 0) {\n\t\t\n\t\tGntTreeRow *row = tree->current;\n\t\tif (row && row->child)\n\t\t{\n\t\t\trow->collapsed = !row->collapsed;\n\t\t\tredraw_tree(tree);\n\t\t\tg_signal_emit(tree, signals[SIG_COLLAPSED], 0, row->key, row->collapsed);\n\t\t}\n\t\telse if (row && row->choice)\n\t\t{\n\t\t\trow->isselected = !row->isselected;\n\t\t\tg_signal_emit(tree, signals[SIG_TOGGLED], 0, row->key);\n\t\t\tredraw_tree(tree);\n\t\t}\n\t} else {\n\t\treturn FALSE;\n\t}\n\tif (old != tree->current)\n\t{\n\t\ttree_selection_changed(tree, old, tree->current);\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1010}
{"project": "Pidgin", "target": 0, "func": "NMRequest *\nnm_conn_find_request(NMConn * conn, int trans_id)\n{\n\tNMRequest *req = NULL;\n\tGSList *itr = NULL;\n\tif (conn == NULL)\n\t\treturn NULL;\n\titr = conn->requests;\n\twhile (itr) {\n\t\treq = (NMRequest *) itr->data;\n\t\tif (req != NULL && nm_request_get_trans_id(req) == trans_id) {\n\t\t\treturn req;\n\t\t}\n\t\titr = g_slist_next(itr);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1011}
{"project": "Pidgin", "target": 0, "func": "static int\nhttp_connection_do_send(PurpleHTTPConnection *conn, const char *data, int len)\n{\n\tint ret;\n\tif (conn->psc)\n\t\tret = purple_ssl_write(conn->psc, data, len);\n\telse\n\t\tret = write(conn->fd, data, len);\n\tif (purple_debug_is_verbose())\n\t\tpurple_debug_misc(\"jabber\", \"BOSH (%p): wrote %d bytes\\n\", conn, ret);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1012}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nx509_export_certificate(const gchar *filename, PurpleCertificate *crt)\n{\n\tgnutls_x509_crt_t crt_dat; \n\tint ret;\n\tgchar * out_buf; \n\tsize_t out_size; \n\tgboolean success = FALSE;\n\t\n\tg_return_val_if_fail(filename, FALSE);\n\tg_return_val_if_fail(crt, FALSE);\n\tg_return_val_if_fail(crt->scheme == &x509_gnutls, FALSE);\n\tg_return_val_if_fail(crt->data, FALSE);\n\tcrt_dat = X509_GET_GNUTLS_DATA(crt);\n\t\n\tout_size = 0;\n\tret = gnutls_x509_crt_export(crt_dat, GNUTLS_X509_FMT_PEM,\n\t\t\t\t     NULL, \n\t\t\t\t     &out_size \n\t\t);\n\tg_return_val_if_fail(ret == GNUTLS_E_SHORT_MEMORY_BUFFER, FALSE);\n\t\n\tout_buf = g_new0(gchar, out_size);\n\tret = gnutls_x509_crt_export(crt_dat, GNUTLS_X509_FMT_PEM,\n\t\t\t\t     out_buf, \n\t\t\t\t     &out_size \n\t\t);\n\tif (ret != 0) {\n\t\tpurple_debug_error(\"gnutls/x509\",\n\t\t\t\t   \"Failed to export cert to buffer with code %d\\n\",\n\t\t\t\t   ret);\n\t\tg_free(out_buf);\n\t\treturn FALSE;\n\t}\n\t\n\tsuccess = purple_util_write_data_to_file_absolute(filename,\n\t\t\t\t\t\t\t  out_buf, out_size);\n\tg_free(out_buf);\n\treturn success;\n}\n", "bug_type": null, "idx": 1013}
{"project": "Pidgin", "target": 0, "func": "static HICON\npixbuf_to_hicon (GdkPixbuf *pixbuf)\n{\n  gint x = 0, y = 0;\n  gboolean is_icon = TRUE;\n  ICONINFO ii;\n  HICON icon;\n  gboolean success;\n  if (pixbuf == NULL)\n    return NULL;\n  if (_gdk_win32_pixbuf_to_hicon_supports_alpha() && gdk_pixbuf_get_has_alpha (pixbuf))\n    success = pixbuf_to_hbitmaps_alpha_winxp (pixbuf, &ii.hbmColor, &ii.hbmMask);\n  else\n    success = pixbuf_to_hbitmaps_normal (pixbuf, &ii.hbmColor, &ii.hbmMask);\n  if (!success)\n    return NULL;\n  ii.fIcon = is_icon;\n  ii.xHotspot = x;\n  ii.yHotspot = y;\n  icon = CreateIconIndirect (&ii);\n  DeleteObject (ii.hbmColor);\n  DeleteObject (ii.hbmMask);\n  return icon;\n}\n", "bug_type": null, "idx": 1014}
{"project": "Pidgin", "target": 0, "func": "static void\nft_recv_start_cb(PurpleXfer *xfer, gpointer data) {\n\tpurple_debug_misc(\"signals test\", \"file receive started\\n\");\n}\n", "bug_type": null, "idx": 1015}
{"project": "Pidgin", "target": 0, "func": "void\npurple_connection_destroy(PurpleConnection *gc)\n{\n\t_purple_connection_destroy(gc);\n}\nvoid\n_purple_connection_destroy(PurpleConnection *gc)\n{\n\tPurpleAccount *account;\n\tGSList *buddies;\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tgboolean remove = FALSE;\n\tg_return_if_fail(gc != NULL);\n\taccount = purple_connection_get_account(gc);\n\tpurple_debug_info(\"connection\", \"Disconnecting connection %p\\n\", gc);\n\tif (purple_connection_get_state(gc) != PURPLE_CONNECTING)\n\t\tremove = TRUE;\n\tpurple_signal_emit(purple_connections_get_handle(), \"signing-off\", gc);\n\twhile (gc->buddy_chats)\n\t{\n\t\tPurpleConversation *b = gc->buddy_chats->data;\n\t\tgc->buddy_chats = g_slist_remove(gc->buddy_chats, b);\n\t\tpurple_conv_chat_left(PURPLE_CONV_CHAT(b));\n\t}\n\tupdate_keepalive(gc, FALSE);\n\tpurple_proxy_connect_cancel_with_handle(gc);\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);\n\tif (prpl_info->close)\n\t\t(prpl_info->close)(gc);\n\t\n\tbuddies = purple_find_buddies(account, NULL);\n\twhile (buddies != NULL) {\n\t\tPurpleBuddy *buddy = buddies->data;\n\t\tpurple_buddy_set_protocol_data(buddy, NULL);\n\t\tbuddies = g_slist_delete_link(buddies, buddies);\n\t}\n\tconnections = g_list_remove(connections, gc);\n\tpurple_connection_set_state(gc, PURPLE_DISCONNECTED);\n\tif (remove)\n\t\tpurple_blist_remove_account(account);\n\tpurple_signal_emit(purple_connections_get_handle(), \"signed-off\", gc);\n\tpurple_account_request_close_with_account(account);\n\tpurple_request_close_with_handle(gc);\n\tpurple_notify_close_with_handle(gc);\n\tpurple_debug_info(\"connection\", \"Destroying connection %p\\n\", gc);\n\tpurple_account_set_connection(account, NULL);\n\tg_free(gc->password);\n\tg_free(gc->display_name);\n\tif (gc->disconnect_timeout > 0)\n\t\tpurple_timeout_remove(gc->disconnect_timeout);\n\tPURPLE_DBUS_UNREGISTER_POINTER(gc);\n\tg_free(gc);\n}\n", "bug_type": null, "idx": 1016}
{"project": "Pidgin", "target": 0, "func": "static void\nsilcpurple_buddy_getkey_cb(SilcPurpleBuddyGetkey g,\n\t\t\t SilcClientCommandReplyContext cmd)\n{\n\tSilcClientEntry client_entry;\n\tunsigned char *pk;\n\tSilcUInt32 pk_len;\n\t\n\tclient_entry = silc_client_get_client_by_id(g->client, g->conn,\n\t\t\t\t\t\t    &g->client_id);\n\tif (!client_entry) {\n\t\tpurple_notify_error(g->client->application, _(\"Get Public Key\"),\n\t\t\t\t  _(\"The remote user is not present in the network any more\"),\n\t\t\t\t  NULL);\n\t\tsilc_free(g);\n\t\treturn;\n\t}\n\tif (!client_entry->public_key) {\n\t\tsilc_free(g);\n\t\treturn;\n\t}\n\t\n\tpk = silc_pkcs_public_key_encode(client_entry->public_key, &pk_len);\n\tsilcpurple_verify_public_key(g->client, g->conn, client_entry->nickname,\n\t\t\t\t   SILC_SOCKET_TYPE_CLIENT,\n\t\t\t\t   pk, pk_len, SILC_SKE_PK_TYPE_SILC,\n\t\t\t\t   NULL, NULL);\n\tsilc_free(pk);\n\tsilc_free(g);\n}\n", "bug_type": null, "idx": 1017}
{"project": "Pidgin", "target": 0, "func": "struct gg_http *gg_change_passwd(uin_t uin, const char *passwd, const char *newpasswd, const char *newemail, int async)\n{\n\tgg_debug(GG_DEBUG_MISC, \"// gg_change_passwd() is obsolete. use gg_change_passwd4() instead!\\n\");\n\terrno = EINVAL;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1018}
{"project": "Pidgin", "target": 0, "func": "static void\ndestroy_signal_data(PurpleSignalData *signal_data)\n{\n\tg_list_foreach(signal_data->handlers, (GFunc)g_free, NULL);\n\tg_list_free(signal_data->handlers);\n\tif (signal_data->values != NULL)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < signal_data->num_values; i++)\n\t\t\tpurple_value_destroy((PurpleValue *)signal_data->values[i]);\n\t\tg_free(signal_data->values);\n\t}\n\tif (signal_data->ret_value != NULL)\n\t\tpurple_value_destroy(signal_data->ret_value);\n\tg_free(signal_data);\n}\n", "bug_type": null, "idx": 1019}
{"project": "Pidgin", "target": 0, "func": " */\nvoid gg_tvbuilder_write_str(gg_tvbuilder_t *tvb, const char *buffer,\n\tssize_t length)\n{\n\tif (!gg_tvbuilder_is_valid(tvb))\n\t\treturn;\n\tif (length == -1)\n\t\tlength = strlen(buffer);\n\tgg_tvbuilder_write_packed_uint(tvb, length);\n\tgg_tvbuilder_write_buff(tvb, buffer, length);\n}\n", "bug_type": null, "idx": 1020}
{"project": "Pidgin", "target": 0, "func": "static void\nnovell_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)\n{\n\tNMContact *contact;\n\tNMFolder *folder;\n\tNMUser *user;\n\tconst char *dn, *gname;\n\tNMERR_T rc = NM_OK;\n\tif (gc == NULL || buddy == NULL || group == NULL)\n\t\treturn;\n\tuser = (NMUser *) gc->proto_data;\n\tif (user && (dn = nm_lookup_dn(user, purple_buddy_get_name(buddy)))) {\n\t\tgname = purple_group_get_name(group);\n\t\tif (strcmp(gname, NM_ROOT_FOLDER_NAME) == 0) {\n\t\t\tgname = \"\";\n\t\t}\n\t\tfolder = nm_find_folder(user, gname);\n\t\tif (folder) {\n\t\t\tcontact = nm_folder_find_contact(folder, dn);\n\t\t\tif (contact) {\n\t\t\t\t\n\t\t\t\tnm_contact_set_data(contact, NULL);\n\t\t\t\t\n\t\t\t\trc = nm_send_remove_contact(user, folder, contact,\n\t\t\t\t\t\t\t\t\t\t\t_remove_contact_resp_cb, NULL);\n\t\t\t\t_check_for_disconnect(user, rc);\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1021}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_menu_draw(GntWidget *widget)\n{\n\tGntMenu *menu = GNT_MENU(widget);\n\tGList *iter;\n\tchtype type;\n\tint i;\n\tif (menu->type == GNT_MENU_TOPLEVEL) {\n\t\twbkgdset(widget->window, '\\0' | gnt_color_pair(GNT_COLOR_HIGHLIGHT));\n\t\twerase(widget->window);\n\t\tfor (i = 0, iter = menu->list; iter; iter = iter->next, i++) {\n\t\t\tGntMenuItem *item = GNT_MENU_ITEM(iter->data);\n\t\t\ttype = ' ' | gnt_color_pair(GNT_COLOR_HIGHLIGHT);\n\t\t\tif (i == menu->selected)\n\t\t\t\ttype |= A_REVERSE;\n\t\t\titem->priv.x = getcurx(widget->window) + widget->priv.x;\n\t\t\titem->priv.y = getcury(widget->window) + widget->priv.y + 1;\n\t\t\twbkgdset(widget->window, type);\n\t\t\twprintw(widget->window, \" %s   \", C_(item->text));\n\t\t}\n\t} else {\n\t\torg_draw(widget);\n\t}\n\tGNTDEBUG;\n}\n", "bug_type": null, "idx": 1022}
{"project": "Pidgin", "target": 0, "func": "static void\nsigned_on_off_cb(PurpleConnection *gc, gpointer user_data)\n{\n\tupdate_pounces();\n}\n", "bug_type": null, "idx": 1023}
{"project": "Pidgin", "target": 0, "func": "static void\npeer_oft_copy_xfer_data(PeerConnection *conn, OftFrame *frame)\n{\n\tg_free(conn->xferdata.name);\n\tmemcpy(&(conn->xferdata), frame, sizeof(OftFrame));\n\tconn->xferdata.name = g_memdup(frame->name, frame->name_length);\n}\n", "bug_type": null, "idx": 1024}
{"project": "Pidgin", "target": 0, "func": "void\npeer_proxy_connection_established_cb(gpointer data, gint source, const gchar *error_message)\n{\n\tPeerConnection *conn;\n\tconn = data;\n\tconn->verified_connect_data = NULL;\n\tif (source < 0)\n\t{\n\t\tpeer_connection_trynext(conn);\n\t\treturn;\n\t}\n\tconn->fd = source;\n\tconn->watcher_incoming = purple_input_add(conn->fd,\n\t\t\tPURPLE_INPUT_READ, peer_proxy_connection_recv_cb, conn);\n\tif (conn->proxyip != NULL)\n\t\t\n\t\tpeer_proxy_send_join_existing_conn(conn, conn->port);\n\telse\n\t\t\n\t\tpeer_proxy_send_create_new_conn(conn);\n}\n", "bug_type": null, "idx": 1025}
{"project": "Pidgin", "target": 0, "func": "static void\ntoggle_draw_cb(GtkToggleButton *toggle, gpointer data)\n{\n\tpurple_prefs_set_bool(\"/plugins/gtk/X11/gestures/visual\",\n\t\tgtk_toggle_button_get_active(toggle));\n}\n", "bug_type": null, "idx": 1026}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin)\n{\n}\n", "bug_type": null, "idx": 1027}
{"project": "Pidgin", "target": 0, "func": "static int purple_ssi_gotadded(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {\n\tPurpleConnection *gc = od->gc;\n\tPurpleAccount *account = purple_connection_get_account(gc);\n\tva_list ap;\n\tchar *bn;\n\tPurpleBuddy *buddy;\n\tva_start(ap, fr);\n\tbn = va_arg(ap, char *);\n\tva_end(ap);\n\tbuddy = purple_find_buddy(account, bn);\n\tpurple_debug_info(\"oscar\", \"ssi: %s added you to their buddy list\\n\", bn);\n\tpurple_account_notify_added(account, bn, NULL,\n\t\t\t(buddy ? purple_buddy_get_alias_only(buddy) : NULL), NULL);\n\treturn 1;\n}\n", "bug_type": null, "idx": 1028}
{"project": "Pidgin", "target": 0, "func": "#include <time.h>\nstatic const char *format_12hour_hour(const struct tm *tm)\n{\n\tstatic char hr[3];\n\tint hour = tm->tm_hour % 12;\n\tif (hour == 0)\n\t\thour = 12;\n\tg_snprintf(hr, sizeof(hr), \"%d\", hour);\n\treturn hr;\n}\n", "bug_type": null, "idx": 1029}
{"project": "Pidgin", "target": 0, "func": "static void\nstatus_window_delete_confirm_cb(gpointer data)\n{\n\tGtkTreeIter iter;\n\tGList *sel_titles = data, *l;\n\tchar *title;\n\tfor (l = sel_titles; l != NULL; l = l->next) {\n\t\ttitle = l->data;\n\t\tif (purple_savedstatus_find(title) != purple_savedstatus_get_current()) {\n\t\t\tif (status_window_find_savedstatus(&iter, title))\n\t\t\t\tgtk_list_store_remove(status_window->model, &iter);\n\t\t\tpurple_savedstatus_delete(title);\n\t\t}\n\t\tg_free(title);\n\t}\n\tg_list_free(sel_titles);\n}\n", "bug_type": null, "idx": 1030}
{"project": "Pidgin", "target": 0, "func": "static void gtk_blist_row_activated_cb(GtkTreeView *tv, GtkTreePath *path, GtkTreeViewColumn *col, gpointer data) {\n\tPurpleBlistNode *node;\n\tGtkTreeIter iter;\n\tgtk_tree_model_get_iter(GTK_TREE_MODEL(gtkblist->treemodel), &iter, path);\n\tgtk_tree_model_get(GTK_TREE_MODEL(gtkblist->treemodel), &iter, NODE_COLUMN, &node, -1);\n\tif(PURPLE_BLIST_NODE_IS_CONTACT(node) || PURPLE_BLIST_NODE_IS_BUDDY(node)) {\n\t\tPurpleBuddy *buddy;\n\t\tif(PURPLE_BLIST_NODE_IS_CONTACT(node))\n\t\t\tbuddy = purple_contact_get_priority_buddy((PurpleContact*)node);\n\t\telse\n\t\t\tbuddy = (PurpleBuddy*)node;\n\t\tpidgin_dialogs_im_with_user(purple_buddy_get_account(buddy), purple_buddy_get_name(buddy));\n\t} else if (PURPLE_BLIST_NODE_IS_CHAT(node)) {\n\t\tgtk_blist_join_chat((PurpleChat *)node);\n\t} else if (PURPLE_BLIST_NODE_IS_GROUP(node)) {\n\n\t}\n}\n", "bug_type": null, "idx": 1031}
{"project": "Pidgin", "target": 0, "func": "static void\nfind_cb(GtkWidget *w, DebugWindow *win)\n{\n\tGtkWidget *hbox, *img, *label;\n\tstruct _find *f;\n\tif(win->find)\n\t{\n\t\tgtk_window_present(GTK_WINDOW(win->find));\n\t\treturn;\n\t}\n\tf = g_malloc(sizeof(struct _find));\n\tf->window = win;\n\twin->find = gtk_dialog_new_with_buttons(_(\"Find\"),\n\t\t\t\t\tGTK_WINDOW(win->window), GTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\tGTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE,\n\t\t\t\t\tGTK_STOCK_FIND, GTK_RESPONSE_OK, NULL);\n\tgtk_dialog_set_default_response(GTK_DIALOG(win->find),\n\t\t\t\t\t GTK_RESPONSE_OK);\n\tg_signal_connect(G_OBJECT(win->find), \"response\",\n\t\t\t\t\tG_CALLBACK(do_find_cb), f);\n\tgtk_container_set_border_width(GTK_CONTAINER(win->find), PIDGIN_HIG_BOX_SPACE);\n\tgtk_window_set_resizable(GTK_WINDOW(win->find), FALSE);\n\tgtk_dialog_set_has_separator(GTK_DIALOG(win->find), FALSE);\n\tgtk_box_set_spacing(GTK_BOX(GTK_DIALOG(win->find)->vbox), PIDGIN_HIG_BORDER);\n\tgtk_container_set_border_width(\n\t\tGTK_CONTAINER(GTK_DIALOG(win->find)->vbox), PIDGIN_HIG_BOX_SPACE);\n\thbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BORDER);\n\tgtk_container_add(GTK_CONTAINER(GTK_DIALOG(win->find)->vbox),\n\t\t\t\t\t  hbox);\n\timg = gtk_image_new_from_stock(PIDGIN_STOCK_DIALOG_QUESTION,\n\t\t\t\t       gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_HUGE));\n\tgtk_box_pack_start(GTK_BOX(hbox), img, FALSE, FALSE, 0);\n\tgtk_misc_set_alignment(GTK_MISC(img), 0, 0);\n\tgtk_dialog_set_response_sensitive(GTK_DIALOG(win->find),\n\t\t\t\t\t\t\t\t\t  GTK_RESPONSE_OK, FALSE);\n\tlabel = gtk_label_new(NULL);\n\tgtk_label_set_markup_with_mnemonic(GTK_LABEL(label), _(\"_Search for:\"));\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\tf->entry = gtk_entry_new();\n\tgtk_entry_set_activates_default(GTK_ENTRY(f->entry), TRUE);\n\tgtk_label_set_mnemonic_widget(GTK_LABEL(label), GTK_WIDGET(f->entry));\n\tg_signal_connect(G_OBJECT(f->entry), \"changed\",\n\t\t\t\t\t G_CALLBACK(pidgin_set_sensitive_if_input),\n\t\t\t\t\t win->find);\n\tgtk_box_pack_start(GTK_BOX(hbox), f->entry, FALSE, FALSE, 0);\n\tgtk_widget_show_all(win->find);\n\tgtk_widget_grab_focus(f->entry);\n}\n", "bug_type": null, "idx": 1032}
{"project": "Pidgin", "target": 0, "func": "static void ice_connection_watch(IceConn connection, IcePointer client_data,\n\t      Bool opening, IcePointer *watch_data) {\n\tstruct ice_connection_info *conninfo = NULL;\n\tif (opening) {\n\t\tpurple_debug(PURPLE_DEBUG_INFO, \"Session Management\",\n\t\t\t\t   \"Handling new ICE connection... \\n\");\n\t\t\n\t\tif (fcntl(IceConnectionNumber(connection), F_SETFD, FD_CLOEXEC) != 0)\n\t\t\tpurple_debug_warning(\"gtksession\", \"couldn't set FD_CLOEXEC\\n\");\n\t\tconninfo = g_new(struct ice_connection_info, 1);\n\t\tconninfo->connection = connection;\n\t\t\n\t\tconninfo->input_id = purple_input_add(IceConnectionNumber(connection), PURPLE_INPUT_READ,\n\t\t\t\t\t\t\t\t\t\t\tice_process_messages, conninfo);\n\t\t*watch_data = conninfo;\n\t} else {\n\t\tpurple_debug(PURPLE_DEBUG_INFO, \"Session Management\",\n\t\t\t\t   \"Handling closed ICE connection... \\n\");\n\t\t\n\t\tconninfo = (struct ice_connection_info*) *watch_data;\n\t\tpurple_input_remove(conninfo->input_id);\n\t\tg_free(conninfo);\n\t}\n\tpurple_debug(PURPLE_DEBUG_INFO, NULL, \"done.\\n\");\n}\n", "bug_type": null, "idx": 1033}
{"project": "Pidgin", "target": 0, "func": " */\nvoid gg_resolver_cleaner(void *data)\n{\n\tvoid **buf_ptr = (void **) data;\n\tif (buf_ptr != NULL) {\n\t\tfree(*buf_ptr);\n\t\t*buf_ptr = NULL;\n\t}\n}\n", "bug_type": null, "idx": 1034}
{"project": "Pidgin", "target": 0, "func": "void\nnm_folder_add_ref(NMFolder * folder)\n{\n\tif (folder)\n\t\tfolder->ref_count++;\n}\n", "bug_type": null, "idx": 1035}
{"project": "Pidgin", "target": 0, "func": "void\npurple_pounce_destroy_all_by_account(PurpleAccount *account)\n{\n\tPurpleAccount *pouncer;\n\tPurplePounce *pounce;\n\tGList *l, *l_next;\n\tg_return_if_fail(account != NULL);\n\tfor (l = purple_pounces_get_all(); l != NULL; l = l_next)\n\t{\n\t\tpounce = (PurplePounce *)l->data;\n\t\tl_next = l->next;\n\t\tpouncer = purple_pounce_get_pouncer(pounce);\n\t\tif (pouncer == account)\n\t\t\tpurple_pounce_destroy(pounce);\n\t}\n}\n", "bug_type": null, "idx": 1036}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_sound_play_file(const char *filename)\n{\n\tconst char *method;\n#ifdef USE_GSTREAMER\n\tfloat volume;\n\tchar *uri;\n\tGstElement *sink = NULL;\n\tGstElement *play = NULL;\n\tGstBus *bus = NULL;\n#endif\n\tif (purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/sound/mute\"))\n\t\treturn;\n\tmethod = purple_prefs_get_string(PIDGIN_PREFS_ROOT \"/sound/method\");\n\tif (!strcmp(method, \"none\")) {\n\t\treturn;\n\t} else if (!strcmp(method, \"beep\")) {\n\t\tgdk_beep();\n\t\treturn;\n\t}\n\tif (!g_file_test(filename, G_FILE_TEST_EXISTS)) {\n\t\tpurple_debug_error(\"gtksound\", \"sound file (%s) does not exist.\\n\", filename);\n\t\treturn;\n\t}\n#ifndef _WIN32\n\tif (!strcmp(method, \"custom\")) {\n\t\tconst char *sound_cmd;\n\t\tchar *command;\n\t\tchar *esc_filename;\n\t\tchar **argv = NULL;\n\t\tGError *error = NULL;\n\t\tGPid pid;\n\t\tsound_cmd = purple_prefs_get_path(PIDGIN_PREFS_ROOT \"/sound/command\");\n\t\tif (!sound_cmd || *sound_cmd == '\\0') {\n\t\t\tpurple_debug_error(\"gtksound\",\n\t\t\t\t\t \"'Command' sound method has been chosen, \"\n\t\t\t\t\t \"but no command has been set.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tesc_filename = g_shell_quote(filename);\n\t\tif(strstr(sound_cmd, \"%s\"))\n\t\t\tcommand = purple_strreplace(sound_cmd, \"%s\", esc_filename);\n\t\telse\n\t\t\tcommand = g_strdup_printf(\"%s %s\", sound_cmd, esc_filename);\n\t\tif (!g_shell_parse_argv(command, NULL, &argv, &error)) {\n\t\t\tpurple_debug_error(\"gtksound\", \"error parsing command %s (%s)\\n\",\n\t\t\t\t\t\t\t   command, error->message);\n\t\t\tg_error_free(error);\n\t\t\tg_free(esc_filename);\n\t\t\tg_free(command);\n\t\t\treturn;\n\t\t}\n\t\tif (!g_spawn_async(NULL, argv, NULL, G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD,\n\t\t\t\t\t\t  NULL, NULL, &pid, &error)) {\n\t\t\tpurple_debug_error(\"gtksound\", \"sound command could not be launched: %s\\n\",\n\t\t\t\t\t\t\t   error->message);\n\t\t\tg_error_free(error);\n\t\t} else {\n\t\t\tpurple_timeout_add_seconds(15, expire_old_child, GINT_TO_POINTER(pid));\n\t\t}\n\t\tg_strfreev(argv);\n\t\tg_free(esc_filename);\n\t\tg_free(command);\n\t\treturn;\n\t}\n#endif \n#ifdef USE_GSTREAMER\n\tif (gst_init_failed)  \n\t\treturn;\n\tvolume = (float)(CLAMP(purple_prefs_get_int(PIDGIN_PREFS_ROOT \"/sound/volume\"),0,100)) / 50;\n\tif (!strcmp(method, \"automatic\")) {\n\t\tsink = gst_element_factory_make(\"gconfaudiosink\", \"sink\");\n\t}\n#ifndef _WIN32\n\telse if (!strcmp(method, \"esd\")) {\n\t\tsink = gst_element_factory_make(\"esdsink\", \"sink\");\n\t} else if (!strcmp(method, \"alsa\")) {\n\t\tsink = gst_element_factory_make(\"alsasink\", \"sink\");\n\t}\n#endif\n\telse {\n\t\tpurple_debug_error(\"sound\", \"Unknown sound method '%s'\\n\", method);\n\t\treturn;\n\t}\n\tif (strcmp(method, \"automatic\") != 0 && !sink) {\n\t\tpurple_debug_error(\"sound\", \"Unable to create GStreamer audiosink.\\n\");\n\t\treturn;\n\t}\n\tplay = gst_element_factory_make(\"playbin\", \"play\");\n\tif (play == NULL) {\n\t\treturn;\n\t}\n\turi = g_strdup_printf(\"file://%s\", filename);\n\tg_object_set(G_OBJECT(play), \"uri\", uri,\n\t\t                     \"volume\", volume,\n\t\t                     \"audio-sink\", sink, NULL);\n\tbus = gst_pipeline_get_bus(GST_PIPELINE(play));\n\tgst_bus_add_watch(bus, bus_call, play);\n\tgst_element_set_state(play, GST_STATE_PLAYING);\n\tgst_object_unref(bus);\n\tg_free(uri);\n#else \n#ifndef _WIN32\n\tgdk_beep();\n#else \n\tpurple_debug_info(\"sound\", \"Playing %s\\n\", filename);\n\t{\n\t\twchar_t *wc_filename = g_utf8_to_utf16(filename,\n\t\t\t\t-1, NULL, NULL, NULL);\n\t\tif (!PlaySoundW(wc_filename, NULL, SND_ASYNC | SND_FILENAME))\n\t\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"sound\", \"Error playing sound.\\n\");\n\t\tg_free(wc_filename);\n\t}\n#endif \n#endif \n}\n", "bug_type": null, "idx": 1037}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\npidgin_media_get_widget(PidginMedia *gtkmedia,\n\t\tconst gchar *session_id, const gchar *participant)\n{\n\tGtkWidget *widget = NULL;\n\tgchar *key = create_key(session_id, participant);\n\tPurpleMediaSessionType type =\n\t\t\tpurple_media_get_session_type(gtkmedia->priv->media, session_id);\n\tif (type & PURPLE_MEDIA_AUDIO)\n\t\twidget = g_hash_table_lookup(gtkmedia->priv->recv_progressbars, key);\n\telse if (type & PURPLE_MEDIA_VIDEO)\n\t\twidget = g_hash_table_lookup(gtkmedia->priv->remote_videos, key);\n\tg_free(key);\n\treturn widget;\n}\n", "bug_type": null, "idx": 1038}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_string_set_value(PurpleRequestField *field, const char *value)\n{\n\tg_return_if_fail(field != NULL);\n\tg_return_if_fail(field->type == PURPLE_REQUEST_FIELD_STRING);\n\tg_free(field->u.string.value);\n\tfield->u.string.value = g_strdup(value);\n}\n", "bug_type": null, "idx": 1039}
{"project": "Pidgin", "target": 0, "func": "static int\nmax_common_prefix(const char *s, const char *t)\n{\n\tconst char *f = s;\n\twhile (*f && *t && *f == *t++)\n\t\tf++;\n\treturn f - s;\n}\n", "bug_type": null, "idx": 1040}
{"project": "Pidgin", "target": 0, "func": "static void oscar_show_set_info(PurplePluginAction *action)\n{\n\tPurpleConnection *gc = (PurpleConnection *) action->context;\n\tpurple_account_request_change_user_info(purple_connection_get_account(gc));\n}\n", "bug_type": null, "idx": 1041}
{"project": "Pidgin", "target": 0, "func": "static void html_logger_finalize(PurpleLog *log)\n{\n\tPurpleLogCommonLoggerData *data = log->logger_data;\n\tif (data) {\n\t\tif(data->file) {\n\t\t\tfprintf(data->file, \"</body></html>\\n\");\n\t\t\tfclose(data->file);\n\t\t}\n\t\tg_free(data->path);\n\t\tg_slice_free(PurpleLogCommonLoggerData, data);\n\t}\n}\n", "bug_type": null, "idx": 1042}
{"project": "Pidgin", "target": 0, "func": "static void\nnotify_toggle_cb(GtkWidget *widget, gpointer data)\n{\n\tgboolean on = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));\n\tgchar pref[256];\n\tg_snprintf(pref, sizeof(pref), \"/plugins/gtk/X11/notify/%s\",\n\t           (char *)data);\n\tpurple_prefs_set_bool(pref, on);\n\tapply_notify();\n}\n", "bug_type": null, "idx": 1043}
{"project": "Pidgin", "target": 0, "func": "void *\npurple_accounts_get_handle(void)\n{\n\tstatic int handle;\n\treturn &handle;\n}\n", "bug_type": null, "idx": 1044}
{"project": "Pidgin", "target": 0, "func": "static void write_stats_on_unload(gpointer key, gpointer value, gpointer user_data) {\n\tCapStatistics *stats = value;\n\tif(stats->last_message != -1 && stats->buddy != NULL) {\n\t\tinsert_cap_failure(stats);\n\t}\n}\n", "bug_type": null, "idx": 1045}
{"project": "Pidgin", "target": 0, "func": "static void\nxmpp_disco_info_do(PurpleConnection *pc, gpointer cbdata, const char *jid,\n                   const char *node, XmppIqCallback cb)\n{\n\txmlnode *iq, *query;\n\tchar *id = generate_next_id();\n\tiq = xmlnode_new(\"iq\");\n\txmlnode_set_attrib(iq, \"type\", \"get\");\n\txmlnode_set_attrib(iq, \"to\", jid);\n\txmlnode_set_attrib(iq, \"id\", id);\n\tquery = xmlnode_new_child(iq, \"query\");\n\txmlnode_set_namespace(query, NS_DISCO_INFO);\n\tif (node)\n\t\txmlnode_set_attrib(query, \"node\", node);\n\t\n\txmpp_iq_register_callback(pc, id, cbdata, cb);\n\tpurple_signal_emit(purple_connection_get_prpl(pc), \"jabber-sending-xmlnode\",\n\t                   pc, &iq);\n\tif (iq != NULL)\n\t\txmlnode_free(iq);\n}\n", "bug_type": null, "idx": 1046}
{"project": "Pidgin", "target": 0, "func": "static gboolean\npeer_oft_checksum_calculated_cb(gpointer data)\n{\n\tChecksumData *checksum_data;\n\tPeerConnection *conn;\n\tchecksum_data = data;\n\tconn = checksum_data->conn;\n\tconn->xferdata.checksum = checksum_data->checksum;\n\t\n\tpeer_connection_trynext(checksum_data->conn);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 1047}
{"project": "Pidgin", "target": 0, "func": "void\npurple_chat_destroy(PurpleChat *chat)\n{\n\tg_hash_table_destroy(chat->components);\n\tg_hash_table_destroy(chat->node.settings);\n\tg_free(chat->alias);\n\tPURPLE_DBUS_UNREGISTER_POINTER(chat);\n\tg_free(chat);\n}\n", "bug_type": null, "idx": 1048}
{"project": "Pidgin", "target": 0, "func": "static void\nx509_tls_cached_unknown_peer(PurpleCertificateVerificationRequest *vrq,\n                             PurpleCertificateInvalidityFlags flags)\n{\n\tPurpleCertificatePool *ca;\n\tPurpleCertificate *peer_crt;\n\tPurpleCertificate *ca_crt, *end_crt;\n\tPurpleCertificate *failing_crt;\n\tGList *chain = vrq->cert_chain;\n\tGSList *ca_crts, *cur;\n\tGByteArray *last_fpr, *ca_fpr;\n\tgboolean valid = FALSE;\n\tgchar *ca_id, *ca2_id;\n\tpeer_crt = (PurpleCertificate *) chain->data;\n\tif (peer_crt->scheme->verify_cert) {\n\t\t\n\t\tg_return_if_fail(x509_ca_lazy_init());\n\t\tpeer_crt->scheme->verify_cert(vrq, &flags);\n\t\tx509_tls_cached_complete(vrq, flags);\n\t\treturn;\n\t}\n\t\n\tif ( purple_certificate_signed_by(peer_crt, peer_crt) ) {\n\t\tflags |= PURPLE_CERTIFICATE_SELF_SIGNED;\n\t\tpurple_debug_info(\"certificate/x509/tls_cached\",\n\t\t\t\t  \"Certificate for %s is self-signed.\\n\",\n\t\t\t\t  vrq->subject_name);\n\t\tx509_tls_cached_check_subject_name(vrq, flags);\n\t\treturn;\n\t} \n\tca = purple_certificate_find_pool(x509_tls_cached.scheme_name, \"ca\");\n\t\n\tif (!purple_certificate_check_signature_chain_with_failing(chain,\n\t\t\t\t&failing_crt))\n\t{\n\t\tgboolean chain_validated = FALSE;\n\t\t\n\t\tif (ca) {\n\t\t\tgchar *uid = purple_certificate_get_unique_id(failing_crt);\n\t\t\tPurpleCertificate *ca_crt = purple_certificate_pool_retrieve(ca, uid);\n\t\t\tif (ca_crt != NULL) {\n\t\t\t\tGByteArray *failing_fpr;\n\t\t\t\tGByteArray *ca_fpr;\n\t\t\t\tfailing_fpr = purple_certificate_get_fingerprint_sha256(failing_crt, TRUE);\n\t\t\t\tca_fpr = purple_certificate_get_fingerprint_sha256(ca_crt, TRUE);\n\t\t\t\tif (byte_arrays_equal(failing_fpr, ca_fpr)) {\n\t\t\t\t\tpurple_debug_info(\"certificate/x509/tls_cached\",\n\t\t\t\t\t\t\t\"Full chain verification failed (probably a bad \"\n\t\t\t\t\t\t\t\"signature algorithm), but found the last \"\n\t\t\t\t\t\t\t\"certificate %s in the CA pool.\\n\", uid);\n\t\t\t\t\tchain_validated = TRUE;\n\t\t\t\t}\n\t\t\t\tg_byte_array_free(failing_fpr, TRUE);\n\t\t\t\tg_byte_array_free(ca_fpr, TRUE);\n\t\t\t}\n\t\t\tpurple_certificate_destroy(ca_crt);\n\t\t\tg_free(uid);\n\t\t}\n\t\t\n\t\tif (!chain_validated)\n\t\t\t\n\t\t\tflags |= PURPLE_CERTIFICATE_INVALID_CHAIN;\n\t\tx509_tls_cached_check_subject_name(vrq, flags);\n\t\treturn;\n\t} \n\t\n\t\n\tif ( !ca ) {\n\t\tpurple_debug_error(\"certificate/x509/tls_cached\",\n\t\t\t\t   \"No X.509 Certificate Authority pool \"\n\t\t\t\t   \"could be found!\\n\");\n\t\tflags |= PURPLE_CERTIFICATE_NO_CA_POOL;\n\t\tx509_tls_cached_check_subject_name(vrq, flags);\n\t\treturn;\n\t}\n\tend_crt = g_list_last(chain)->data;\n\t\n\tca_id  = purple_certificate_get_issuer_unique_id(end_crt);\n\tca2_id = purple_certificate_get_unique_id(end_crt);\n\tpurple_debug_info(\"certificate/x509/tls_cached\",\n\t\t\t  \"Checking for a CA with DN=%s\\n\",\n\t\t\t  ca_id);\n\tpurple_debug_info(\"certificate/x509/tls_cached\",\n\t\t\t  \"Also checking for a CA with DN=%s\\n\",\n\t\t\t  ca2_id);\n\tca_crts = g_slist_concat(x509_ca_get_certs(ca_id), x509_ca_get_certs(ca2_id));\n\tg_free(ca_id);\n\tg_free(ca2_id);\n\tif ( NULL == ca_crts ) {\n\t\tflags |= PURPLE_CERTIFICATE_CA_UNKNOWN;\n\t\tpurple_debug_warning(\"certificate/x509/tls_cached\",\n\t\t\t\t  \"No Certificate Authorities with either DN found \"\n\t\t\t\t  \"found. I'll prompt the user, I guess.\\n\");\n\t\tx509_tls_cached_check_subject_name(vrq, flags);\n\t\treturn;\n\t}\n\t\n\tlast_fpr = purple_certificate_get_fingerprint_sha256(end_crt, TRUE);\n\tca_id = purple_certificate_get_unique_id(end_crt);\n\tfor (cur = ca_crts; cur; cur = cur->next) {\n\t\tca_crt = cur->data;\n\t\tca_fpr = purple_certificate_get_fingerprint_sha256(ca_crt, TRUE);\n\t\tca2_id = purple_certificate_get_unique_id(ca_crt);\n\t\tif ( byte_arrays_equal(last_fpr, ca_fpr) ||\n\t\t\t\t(purple_strequal(ca_id, ca2_id) &&\n\t\t\t\t purple_certificate_compare_pubkeys(end_crt, ca_crt)) ||\n\t\t\t\tpurple_certificate_signed_by(end_crt, ca_crt) )\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\tvalid = TRUE;\n\t\t\tg_byte_array_free(ca_fpr, TRUE);\n\t\t\tg_free(ca2_id);\n\t\t\tbreak;\n\t\t}\n\t\tg_byte_array_free(ca_fpr, TRUE);\n\t\tg_free(ca2_id);\n\t}\n\tg_free(ca_id);\n\tif (valid == FALSE)\n\t\tflags |= PURPLE_CERTIFICATE_INVALID_CHAIN;\n\tg_slist_foreach(ca_crts, (GFunc)purple_certificate_destroy, NULL);\n\tg_slist_free(ca_crts);\n\tg_byte_array_free(last_fpr, TRUE);\n\tx509_tls_cached_check_subject_name(vrq, flags);\n}\n", "bug_type": null, "idx": 1049}
{"project": "Pidgin", "target": 0, "func": "\nstatic void cleanup_conv_window(PidginWindow *win) {\n\tGtkWidget *window = win->window;\n\tslider_win *slidwin = NULL;\n\t\n\tpurple_debug_info(WINTRANS_PLUGIN_ID,\n\t\t\"Conv window destroyed... removing from list\\n\");\n\tif ((slidwin = find_slidwin(window))) {\n\t\twindow_list = g_slist_remove(window_list, slidwin);\n\t\tg_free(slidwin);\n\t}\n\t\n\tg_signal_handlers_disconnect_by_func(G_OBJECT(window),\n\t\tG_CALLBACK(focus_conv_win_cb), window);\n}\n", "bug_type": null, "idx": 1050}
{"project": "Pidgin", "target": 0, "func": "static void append_to_list(GtkTreeModel *model, GtkTreePath *path,\n\t\tGtkTreeIter *iter, gpointer data)\n{\n\tGList **list = data;\n\t*list = g_list_prepend(*list, gtk_tree_path_copy(path));\n}\n", "bug_type": null, "idx": 1051}
{"project": "Pidgin", "target": 0, "func": "static PurpleCertificate *\nx509_tls_peers_get_cert(const gchar *id)\n{\n\tPurpleCertificateScheme *x509;\n\tPurpleCertificate *crt;\n\tgchar *keypath;\n\tg_return_val_if_fail(id, NULL);\n\t\n\tif ( !x509_tls_peers_cert_in_pool(id) ) {\n\t\treturn NULL;\n\t}\n\t\n\tx509 = purple_certificate_find_scheme(\"x509\");\n\tg_return_val_if_fail(x509, NULL);\n\t\n\tkeypath = purple_certificate_pool_mkpath(&x509_tls_peers, id);\n\tcrt = purple_certificate_import(x509, keypath);\n\tg_free(keypath);\n\treturn crt;\n}\n", "bug_type": null, "idx": 1052}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin)\n{\n}\n", "bug_type": null, "idx": 1053}
{"project": "Pidgin", "target": 0, "func": "static void bonjour_xfer_cancel_recv(PurpleXfer *xfer)\n{\n\tpurple_debug_info(\"bonjour\", \"Bonjour-xfer-cancel-recv.\\n\");\n\tbonjour_free_xfer(xfer);\n}\n", "bug_type": null, "idx": 1054}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\tpurple_signal_connect(purple_conversations_get_handle(),\n\t\t\t\t\t\t\"conversation-created\",\n\t\t\t\t\t\tplugin, PURPLE_CALLBACK(historize), NULL);\n\t\n\tpurple_prefs_connect_callback(plugin, \"/purple/logging/log_ims\",\n\t\t\t\t\t\t\t\thistory_prefs_cb, plugin);\n\tpurple_prefs_connect_callback(plugin, \"/purple/logging/log_chats\",\n\t\t\t\t\t\t\t\thistory_prefs_cb, plugin);\n\thistory_prefs_check(plugin);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1055}
{"project": "Pidgin", "target": 0, "func": "static void\nsmiley_dnd_recv(GtkWidget *widget, GdkDragContext *dc, guint x, guint y,\n\t\tGtkSelectionData *sd, guint info, guint t, gpointer user_data)\n{\n\tSmileyManager *dialog = user_data;\n\tgchar *name = g_strchomp((gchar *)sd->data);\n\tif ((sd->length >= 0) && (sd->format == 8)) {\n\t\t\n\t\tif (!g_ascii_strncasecmp(name, \"file://\", 7)) {\n\t\t\tGError *converr = NULL;\n\t\t\tgchar *tmp;\n\t\t\tPidginSmiley *ps;\n\t\t\t\n\t\t\tif(!(tmp = g_filename_from_uri(name, NULL, &converr))) {\n\t\t\t\tpurple_debug_error(\"smiley dnd\", \"%s\\n\",\n\t\t\t\t\t\t   (converr ? converr->message :\n\t\t\t\t\t\t\t\"g_filename_from_uri error\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tps = pidgin_smiley_edit(dialog->window, NULL);\n\t\t\tdo_add_file_cb(tmp, ps);\n\t\t\tif (gtk_image_get_pixbuf(GTK_IMAGE(ps->smiley_image)) == NULL)\n\t\t\t\tgtk_dialog_response(GTK_DIALOG(ps->parent), GTK_RESPONSE_CANCEL);\n\t\t\tg_free(tmp);\n\t\t} else if (!g_ascii_strncasecmp(name, \"http://\", 7)) {\n\t\t\t\n\t\t\tpurple_util_fetch_url(name, TRUE, NULL, FALSE, smiley_got_url, dialog);\n\t\t} else if (!g_ascii_strncasecmp(name, \"https://\", 8)) {\n\t\t\t\n\t\t\tchar *tmp = g_strdup(name + 1);\n\t\t\ttmp[0] = 'h';\n\t\t\ttmp[1] = 't';\n\t\t\ttmp[2] = 't';\n\t\t\ttmp[3] = 'p';\n\t\t\tpurple_util_fetch_url(tmp, TRUE, NULL, FALSE, smiley_got_url, dialog);\n\t\t\tg_free(tmp);\n\t\t}\n\t\tgtk_drag_finish(dc, TRUE, FALSE, t);\n\t}\n\tgtk_drag_finish(dc, FALSE, FALSE, t);\n}\n", "bug_type": null, "idx": 1056}
{"project": "Pidgin", "target": 0, "func": "void\npurple_request_field_bool_set_default_value(PurpleRequestField *field,\n\t\t\t\t\t\t\t\t\t\t  gboolean default_value)\n{\n\tg_return_if_fail(field != NULL);\n\tg_return_if_fail(field->type == PURPLE_REQUEST_FIELD_BOOLEAN);\n\tfield->u.boolean.default_value = default_value;\n}\n", "bug_type": null, "idx": 1057}
{"project": "Pidgin", "target": 0, "func": "static Tcl_Obj *new_cb_namespace ()\n{\n\tstatic int cbnum;\n\tchar name[32];\n\tg_snprintf (name, sizeof(name), \"::purple::_callback::cb_%d\", cbnum++);\n\treturn Tcl_NewStringObj (name, -1);\n}\n", "bug_type": null, "idx": 1058}
{"project": "Pidgin", "target": 0, "func": "PurpleStringref *purple_stringref_printf(const char *format, ...)\n{\n\tPurpleStringref *newref;\n\tva_list ap;\n\tif (format == NULL)\n\t\treturn NULL;\n\tva_start(ap, format);\n\tnewref = g_malloc(sizeof(PurpleStringref) + g_printf_string_upper_bound(format, ap));\n\tvsprintf(newref->value, format, ap);\n\tva_end(ap);\n\tnewref->ref = 1;\n\treturn newref;\n}\n", "bug_type": null, "idx": 1059}
{"project": "Pidgin", "target": 0, "func": "char *\npurple_log_get_log_dir(PurpleLogType type, const char *name, PurpleAccount *account)\n{\n\tPurplePlugin *prpl;\n\tPurplePluginProtocolInfo *prpl_info;\n\tconst char *prpl_name;\n\tchar *acct_name;\n\tconst char *target;\n\tchar *dir;\n\tprpl = purple_find_prpl(purple_account_get_protocol_id(account));\n\tif (!prpl)\n\t\treturn NULL;\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\tprpl_name = prpl_info->list_icon(account, NULL);\n\tacct_name = g_strdup(purple_escape_filename(purple_normalize(account,\n\t\t\t\tpurple_account_get_username(account))));\n\tif (type == PURPLE_LOG_CHAT) {\n\t\tchar *temp = g_strdup_printf(\"%s.chat\", purple_normalize(account, name));\n\t\ttarget = purple_escape_filename(temp);\n\t\tg_free(temp);\n\t} else if(type == PURPLE_LOG_SYSTEM) {\n\t\ttarget = \".system\";\n\t} else {\n\t\ttarget = purple_escape_filename(purple_normalize(account, name));\n\t}\n\tdir = g_build_filename(purple_user_dir(), \"logs\", prpl_name, acct_name, target, NULL);\n\tg_free(acct_name);\n\treturn dir;\n}\n", "bug_type": null, "idx": 1060}
{"project": "Pidgin", "target": 0, "func": "void\npurple_media_backend_add_remote_candidates(PurpleMediaBackend *self,\n\t\tconst gchar *sess_id, const gchar *participant,\n\t\tGList *remote_candidates)\n{\n\tg_return_if_fail(PURPLE_IS_MEDIA_BACKEND(self));\n\tPURPLE_MEDIA_BACKEND_GET_INTERFACE(self)->add_remote_candidates(self,\n\t\t\tsess_id, participant, remote_candidates);\n}\n", "bug_type": null, "idx": 1061}
{"project": "Pidgin", "target": 0, "func": "};\nstatic gboolean load_plugin (PurplePlugin *plugin) {\n\tpurple_signal_register(plugin, \"irc-sending-text\",\n\t\t\t     purple_marshal_VOID__POINTER_POINTER, NULL, 2,\n\t\t\t     purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),\n\t\t\t     purple_value_new_outgoing(PURPLE_TYPE_STRING));\n\tpurple_signal_register(plugin, \"irc-receiving-text\",\n\t\t\t     purple_marshal_VOID__POINTER_POINTER, NULL, 2,\n\t\t\t     purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),\n\t\t\t     purple_value_new_outgoing(PURPLE_TYPE_STRING));\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1062}
{"project": "Pidgin", "target": 0, "func": "PurpleConversation *\npurple_conv_chat_get_conversation(const PurpleConvChat *chat)\n{\n\tg_return_val_if_fail(chat != NULL, NULL);\n\treturn chat->conv;\n}\n", "bug_type": null, "idx": 1063}
{"project": "Pidgin", "target": 0, "func": "static void\nadd_chat_resp_cb(GtkWidget *w, int resp, PidginAddChatData *data)\n{\n\tif (resp == GTK_RESPONSE_OK)\n\t{\n\t\tadd_chat_cb(NULL, data);\n\t}\n\telse if (resp == 1)\n\t{\n\t\tpidgin_roomlist_dialog_show_with_account(data->chat_data.rq_data.account);\n\t}\n\telse\n\t{\n\t\tgtk_widget_destroy(data->chat_data.rq_data.window);\n\t\tg_free(data->chat_data.default_chat_name);\n\t\tg_list_free(data->chat_data.entries);\n\t\tg_free(data);\n\t}\n}\n", "bug_type": null, "idx": 1064}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_media_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)\n{\n\tPidginMedia *media;\n\tg_return_if_fail(PIDGIN_IS_MEDIA(object));\n\tmedia = PIDGIN_MEDIA(object);\n\tswitch (prop_id) {\n\t\tcase PROP_MEDIA:\n\t\t{\n\t\t\tif (media->priv->media)\n\t\t\t\tg_object_unref(media->priv->media);\n\t\t\tmedia->priv->media = g_value_get_object(value);\n\t\t\tg_object_ref(media->priv->media);\n\t\t\tif (purple_media_is_initiator(media->priv->media,\n\t\t\t\t\t NULL, NULL) == TRUE)\n\t\t\t\tpidgin_media_set_state(media, PIDGIN_MEDIA_WAITING);\n\t\t\telse\n\t\t\t\tpidgin_media_set_state(media, PIDGIN_MEDIA_REQUESTED);\n\t\t\tg_signal_connect(G_OBJECT(media->priv->media), \"error\",\n\t\t\t\tG_CALLBACK(pidgin_media_error_cb), media);\n\t\t\tg_signal_connect(G_OBJECT(media->priv->media), \"state-changed\",\n\t\t\t\tG_CALLBACK(pidgin_media_state_changed_cb), media);\n\t\t\tg_signal_connect(G_OBJECT(media->priv->media), \"stream-info\",\n\t\t\t\tG_CALLBACK(pidgin_media_stream_info_cb), media);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROP_SCREENNAME:\n\t\t\tif (media->priv->screenname)\n\t\t\t\tg_free(media->priv->screenname);\n\t\t\tmedia->priv->screenname = g_value_dup_string(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1065}
{"project": "Pidgin", "target": 0, "func": " */\nvoid gg_tvbuilder_write_buff(gg_tvbuilder_t *tvb, const char *buffer,\n\tsize_t length)\n{\n\tchar *buff = gg_tvbuilder_extend(tvb, length);\n\tif (!buff)\n\t\treturn;\n\tmemcpy(buff, buffer, length);\n}\n", "bug_type": null, "idx": 1066}
{"project": "Pidgin", "target": 0, "func": "static void ggp_keepalive(PurpleConnection *gc)\n{\n\tGGPInfo *info = gc->proto_data;\n\t\n\tif (gg_ping(info->session) < 0) {\n\t\tpurple_debug_info(\"gg\", \"Not connected to the server \"\n\t\t\t\t\"or gg_session is not correct\\n\");\n\t\tpurple_connection_error_reason (gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t_(\"Not connected to the server\"));\n\t}\n}\n", "bug_type": null, "idx": 1067}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_blist_toggle_tag_buddy(PurpleBlistNode *node)\n{\n\tGList *iter;\n\tif (node == NULL)\n\t\treturn;\n\tif (ggblist->tagged && (iter = g_list_find(ggblist->tagged, node)) != NULL) {\n\t\tggblist->tagged = g_list_delete_link(ggblist->tagged, iter);\n\t} else {\n\t\tggblist->tagged = g_list_prepend(ggblist->tagged, node);\n\t}\n\tif (PURPLE_BLIST_NODE_IS_CONTACT(node))\n\t\tupdate_buddy_display(purple_contact_get_priority_buddy(PURPLE_CONTACT(node)), ggblist);\n\telse if (PURPLE_BLIST_NODE_IS_BUDDY(node))\n\t\tupdate_buddy_display((PurpleBuddy*)node, ggblist);\n\telse\n\t\tupdate_node_display(node, ggblist);\n}\n", "bug_type": null, "idx": 1068}
{"project": "Pidgin", "target": 0, "func": "static void\nconv_created(PidginConversation *gtkconv, gpointer null)\n{\n\tPidginWindow *win;\n\twin = pidgin_conv_get_window(gtkconv);\n\tif (!win)\n\t\treturn;\n\tdetach_from_pidgin_window(win, NULL);\n\tattach_to_pidgin_window(win, NULL);\n}\n", "bug_type": null, "idx": 1069}
{"project": "Pidgin", "target": 0, "func": "unsigned int\nserv_send_typing(PurpleConnection *gc, const char *name, PurpleTypingState state)\n{\n\tPurplePlugin *prpl;\n\tPurplePluginProtocolInfo *prpl_info;\n\tif (gc) {\n\t\tprpl = purple_connection_get_prpl(gc);\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\t\tif (prpl_info->send_typing)\n\t\t\treturn prpl_info->send_typing(gc, name, state);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1070}
{"project": "Pidgin", "target": 0, "func": "static void\n_rename_contact_resp_cb(NMUser * user, NMERR_T ret_code,\n\t\t\t\t\t\tgpointer resp_data, gpointer user_data)\n{\n\tif (ret_code != NM_OK) {\n\t\tpurple_debug(PURPLE_DEBUG_INFO, \"novell\",\n\t\t\t\t   \"_rename_contact_resp_cb(): rc = 0x%X\\n\", ret_code);\n\t}\n}\n", "bug_type": null, "idx": 1071}
{"project": "Pidgin", "target": 0, "func": "PidginXferDialog *\npidgin_get_xfer_dialog(void)\n{\n\treturn xfer_dialog;\n}\n", "bug_type": null, "idx": 1072}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_icon_theme_class_init(PidginIconThemeClass *klass)\n{\n\tGObjectClass *obj_class = G_OBJECT_CLASS(klass);\n\tparent_class = g_type_class_peek_parent(klass);\n\tobj_class->finalize = pidgin_icon_theme_finalize;\n}\n", "bug_type": null, "idx": 1073}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin)\n{\n}\n", "bug_type": null, "idx": 1074}
{"project": "Pidgin", "target": 0, "func": "static void pidgin_whiteboard_destroy(PurpleWhiteboard *wb)\n{\n\tPidginWhiteboard *gtkwb;\n\tGtkWidget *colour_dialog;\n\tg_return_if_fail(wb != NULL);\n\tgtkwb = wb->ui_data;\n\tg_return_if_fail(gtkwb != NULL);\n\t\n\t\n\tif(gtkwb->pixmap)\n\t{\n\t\tcairo_t *cr = g_object_get_data(G_OBJECT(gtkwb->pixmap), \"cairo-context\");\n\t\tif (cr)\n\t\t\tcairo_destroy(cr);\n\t\tg_object_unref(gtkwb->pixmap);\n\t\tgtkwb->pixmap = NULL;\n\t}\n\tcolour_dialog = g_object_get_data(G_OBJECT(gtkwb->window), \"colour-dialog\");\n\tif (colour_dialog) {\n\t\tgtk_widget_destroy(colour_dialog);\n\t\tg_object_set_data(G_OBJECT(gtkwb->window), \"colour-dialog\", NULL);\n\t}\n\tif(gtkwb->window)\n\t{\n\t\tgtk_widget_destroy(gtkwb->window);\n\t\tgtkwb->window = NULL;\n\t}\n\tg_free(gtkwb);\n\twb->ui_data = NULL;\n}\n", "bug_type": null, "idx": 1075}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conversation_set_logging(PurpleConversation *conv, gboolean log)\n{\n\tg_return_if_fail(conv != NULL);\n\tif (conv->logging != log)\n\t{\n\t\tconv->logging = log;\n\t\tpurple_conversation_update(conv, PURPLE_CONV_UPDATE_LOGGING);\n\t}\n}\n", "bug_type": null, "idx": 1076}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_write_common(struct gg_session *sess, const char *buf, int length)\n{\n\tstruct gg_session_private *p = sess->private_data;\n\tint res;\n#ifdef GG_CONFIG_HAVE_GNUTLS\n\tif (sess->ssl != NULL) {\n\t\tfor (;;) {\n\t\t\tres = gnutls_record_send(GG_SESSION_GNUTLS(sess), buf, length);\n\t\t\tif (res < 0) {\n\t\t\t\tif (!gnutls_error_is_fatal(res) || res == GNUTLS_E_INTERRUPTED)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (res == GNUTLS_E_AGAIN)\n\t\t\t\t\terrno = EAGAIN;\n\t\t\t\telse\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n#endif\n#ifdef GG_CONFIG_HAVE_OPENSSL\n\tif (sess->ssl != NULL) {\n\t\tfor (;;) {\n\t\t\tint err;\n\t\t\tres = SSL_write(sess->ssl, buf, length);\n\t\t\tif (res < 0) {\n\t\t\t\terr = SSL_get_error(sess->ssl, res);\n\t\t\t\tif (err == SSL_ERROR_SYSCALL && errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (err == SSL_ERROR_WANT_WRITE)\n\t\t\t\t\terrno = EAGAIN;\n\t\t\t\telse if (err != SSL_ERROR_SYSCALL)\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n#endif\n\tif (p->socket_handle != NULL) {\n\t\tif (p->socket_manager.write_cb == NULL) {\n\t\t\tgg_debug_session(sess, GG_DEBUG_MISC | GG_DEBUG_ERROR,\n\t\t\t\t\"// gg_write_common() socket_manager.write \"\n\t\t\t\t\"callback is empty\\n\");\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tdo {\n\t\t\tres = p->socket_manager.write_cb(\n\t\t\t\tp->socket_manager.cb_data, p->socket_handle,\n\t\t\t\t(const unsigned char*)buf, length);\n\t\t} while (res < 0 && errno == EINTR);\n\t\tif (res < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tgg_debug_session(sess, GG_DEBUG_MISC | GG_DEBUG_ERROR,\n\t\t\t\t\"// gg_read() unexpected errno=%d\\n\", errno);\n\t\t\terrno = EINVAL;\n\t\t}\n\t\treturn res;\n\t}\n\tfor (;;) {\n\t\tres = send(sess->fd, buf, length, 0);\n\t\tif (res == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\treturn res;\n\t}\n}\n", "bug_type": null, "idx": 1077}
{"project": "Pidgin", "target": 0, "func": "static GValueArray *\njingle_create_relay_info(const gchar *ip, guint port, const gchar *username,\n\tconst gchar *password, const gchar *relay_type, GValueArray *relay_info)\n{\n\tGValue value;\n\tGstStructure *turn_setup = gst_structure_new(\"relay-info\",\n\t\t\"ip\", G_TYPE_STRING, ip,\n\t\t\"port\", G_TYPE_UINT, port,\n\t\t\"username\", G_TYPE_STRING, username,\n\t\t\"password\", G_TYPE_STRING, password,\n\t\t\"relay-type\", G_TYPE_STRING, relay_type,\n\t\tNULL);\n\tpurple_debug_info(\"jabber\", \"created gst_structure %p\\n\",\n\t\tturn_setup);\n\tif (turn_setup) {\n\t\tmemset(&value, 0, sizeof(GValue));\n\t\tg_value_init(&value, GST_TYPE_STRUCTURE);\n\t\tgst_value_set_structure(&value, turn_setup);\nG_GNUC_BEGIN_IGNORE_DEPRECATIONS\n\t\trelay_info = g_value_array_append(relay_info, &value);\nG_GNUC_END_IGNORE_DEPRECATIONS\n\t\tgst_structure_free(turn_setup);\n\t}\n\treturn relay_info;\n}\n", "bug_type": null, "idx": 1078}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nio_invoke(GIOChannel *source, GIOCondition cond, gpointer null)\n{\n\tchar keys[256];\n\tgssize rd;\n\tchar *k;\n\tchar *cvrt = NULL;\n\tif (wm->mode == GNT_KP_MODE_WAIT_ON_CHILD)\n\t\treturn FALSE;\n\trd = read(STDIN_FILENO, keys + HOLDING_ESCAPE, sizeof(keys) - 1 - HOLDING_ESCAPE);\n\tif (rd < 0)\n\t{\n\t\tint ch = getch(); \n\t\tendwin();\n\t\tprintf(\"ERROR: %s\\n\", strerror(errno));\n\t\tprintf(\"File descriptor is: %d\\n\\nGIOChannel is: %p\\ngetch() = %d\\n\", STDIN_FILENO, source, ch);\n\t\traise(SIGABRT);\n\t}\n\telse if (rd == 0)\n\t{\n\t\tendwin();\n\t\tprintf(\"EOF\\n\");\n\t\traise(SIGABRT);\n\t}\n\trd += HOLDING_ESCAPE;\n\tif (HOLDING_ESCAPE) {\n\t\tkeys[0] = '\\033';\n\t\tg_source_remove(escape_stuff.timer);\n\t\tescape_stuff.timer = 0;\n\t}\n\tkeys[rd] = 0;\n\tgnt_wm_set_event_stack(wm, TRUE);\n\tcvrt = g_locale_to_utf8(keys, rd, (gsize*)&rd, NULL, NULL);\n\tk = cvrt ? cvrt : keys;\n\tif (mouse_enabled && detect_mouse_action(k))\n\t\tgoto end;\n#if 0\n\t\n\tif (*k < 0) { \n\t\t*(k + 1) = 128 - *k;\n\t\t*k = 27;\n\t\t*(k + 2) = 0;\n\t\trd++;\n\t}\n#endif\n\twhile (rd) {\n\t\tchar back;\n\t\tint p;\n\t\tif (k[0] == '\\033' && rd == 1) {\n\t\t\tescape_stuff.timer = g_timeout_add(250, escape_timeout, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tgnt_keys_refine(k);\n\t\tp = MAX(1, gnt_keys_find_combination(k));\n\t\tback = k[p];\n\t\tk[p] = '\\0';\n\t\tgnt_wm_process_input(wm, k);     \n\t\tk[p] = back;\n\t\trd -= p;\n\t\tk += p;\n\t}\nend:\n\tif (wm)\n\t\tgnt_wm_set_event_stack(wm, FALSE);\n\tg_free(cvrt);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1079}
{"project": "Pidgin", "target": 0, "func": "guint\npurple_input_add(int source, PurpleInputCondition condition, PurpleInputFunction func, gpointer user_data)\n{\n\tPurpleEventLoopUiOps *ops = purple_eventloop_get_ui_ops();\n\treturn ops->input_add(source, condition, func, user_data);\n}\n", "bug_type": null, "idx": 1080}
{"project": "Pidgin", "target": 0, "func": "PurplePlugin *\npurple_find_prpl(const char *id)\n{\n\tGList *l;\n\tPurplePlugin *plugin;\n\tg_return_val_if_fail(id != NULL, NULL);\n\t\n\tif (g_strcmp0(id, \"prpl-xmpp\") == 0 ||\n\t\tg_strcmp0(id, \"prpl-gtalk\") == 0)\n\t{\n\t\tid = \"prpl-jabber\";\n\t}\n\tfor (l = purple_plugins_get_protocols(); l != NULL; l = l->next) {\n\t\tplugin = (PurplePlugin *)l->data;\n\t\tif (purple_strequal(plugin->info->id, id))\n\t\t\treturn plugin;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1081}
{"project": "Pidgin", "target": 0, "func": "static void\ndump_file_save(GntFileSel *fs, const char *path, const char *f, gpointer n)\n{\n\tFILE *file;\n\tint x, y;\n\tchtype old = 0, now = 0;\n\tstruct {\n\t\tchar ascii;\n\t\tchar *unicode;\n\t} unis[] = {\n\t\t{'q', \"&#x2500;\"},\n\t\t{'t', \"&#x251c;\"},\n\t\t{'u', \"&#x2524;\"},\n\t\t{'x', \"&#x2502;\"},\n\t\t{'-', \"&#x2191;\"},\n\t\t{'.', \"&#x2193;\"},\n\t\t{'l', \"&#x250c;\"},\n\t\t{'k', \"&#x2510;\"},\n\t\t{'m', \"&#x2514;\"},\n\t\t{'j', \"&#x2518;\"},\n\t\t{'a', \"&#x2592;\"},\n\t\t{'n', \"&#x253c;\"},\n\t\t{'w', \"&#x252c;\"},\n\t\t{'v', \"&#x2534;\"},\n\t\t{'\\0', NULL}\n\t};\n\tgnt_widget_destroy(GNT_WIDGET(fs));\n\tif ((file = g_fopen(path, \"w+\")) == NULL) {\n\t\treturn;\n\t}\n\tfprintf(file, \"<head>\\n  <meta http-equiv='Content-Type' content='text/html; charset=utf-8' />\\n</head>\\n<body>\\n\");\n\tfprintf(file, \"<pre>\");\n\tfor (y = 0; y < getmaxy(stdscr); y++) {\n\t\tfor (x = 0; x < getmaxx(stdscr); x++) {\n\t\t\tchar ch[2] = {0, 0}, *print;\n#ifdef NO_WIDECHAR\n\t\t\tnow = mvwinch(curscr, y, x);\n\t\t\tch[0] = now & A_CHARTEXT;\n\t\t\tnow ^= ch[0];\n#else\n\t\t\tcchar_t wch;\n\t\t\tchar unicode[12];\n\t\t\tmvwin_wch(curscr, y, x, &wch);\n\t\t\tnow = wch.attr;\n\t\t\tch[0] = (char)(wch.chars[0] & 0xff);\n#endif\n#define CHECK(attr, start, end) \\\n\t\t\tdo \\\n\t\t\t{  \\\n\t\t\t\tif (now & attr)  \\\n\t\t\t\t{  \\\n\t\t\t\t\tif (!(old & attr))  \\\n\t\t\t\t\t\tfprintf(file, \"%s\", start);  \\\n\t\t\t\t}  \\\n\t\t\t\telse if (old & attr)  \\\n\t\t\t\t{  \\\n\t\t\t\t\tfprintf(file, \"%s\", end);  \\\n\t\t\t\t}  \\\n\t\t\t} while (0)\n\t\t\tCHECK(A_BOLD, \"<b>\", \"</b>\");\n\t\t\tCHECK(A_UNDERLINE, \"<u>\", \"</u>\");\n\t\t\tCHECK(A_BLINK, \"<blink>\", \"</blink>\");\n\t\t\tif ((now & A_COLOR) != (old & A_COLOR) ||\n\t\t\t\t(now & A_REVERSE) != (old & A_REVERSE))\n\t\t\t{\n\t\t\t\tshort fgp, bgp, r, g, b;\n\t\t\t\tstruct\n\t\t\t\t{\n\t\t\t\t\tint r, g, b;\n\t\t\t\t} fg, bg;\n\t\t\t\tif (pair_content(PAIR_NUMBER(now & A_COLOR), &fgp, &bgp) != OK) {\n\t\t\t\t\tfgp = -1;\n\t\t\t\t\tbgp = -1;\n\t\t\t\t}\n\t\t\t\tif (fgp == -1)\n\t\t\t\t\tfgp = COLOR_BLACK;\n\t\t\t\tif (bgp == -1)\n\t\t\t\t\tbgp = COLOR_WHITE;\n\t\t\t\tif (now & A_REVERSE)\n\t\t\t\t{\n\t\t\t\t\tshort tmp = fgp;\n\t\t\t\t\tfgp = bgp;\n\t\t\t\t\tbgp = tmp;\n\t\t\t\t}\n\t\t\t\tif (color_content(fgp, &r, &g, &b) != OK) {\n\t\t\t\t\tr = g = b = 0;\n\t\t\t\t}\n\t\t\t\tfg.r = r; fg.b = b; fg.g = g;\n\t\t\t\tif (color_content(bgp, &r, &g, &b) != OK) {\n\t\t\t\t\tr = g = b = 255;\n\t\t\t\t}\n\t\t\t\tbg.r = r; bg.b = b; bg.g = g;\n#define ADJUST(x) (x = x * 255 / 1000)\n\t\t\t\tADJUST(fg.r);\n\t\t\t\tADJUST(fg.g);\n\t\t\t\tADJUST(fg.b);\n\t\t\t\tADJUST(bg.r);\n\t\t\t\tADJUST(bg.b);\n\t\t\t\tADJUST(bg.g);\n\t\t\t\tif (x) fprintf(file, \"</span>\");\n\t\t\t\tfprintf(file, \"<span style=\\\"background:#%02x%02x%02x;color:#%02x%02x%02x\\\">\",\n\t\t\t\t\t\tbg.r, bg.g, bg.b, fg.r, fg.g, fg.b);\n\t\t\t}\n\t\t\tprint = ch;\n#ifndef NO_WIDECHAR\n\t\t\tif (wch.chars[0] > 255) {\n\t\t\t\tsnprintf(unicode, sizeof(unicode), \"&#x%x;\", (unsigned int)wch.chars[0]);\n\t\t\t\tprint = unicode;\n\t\t\t}\n#endif\n\t\t\tif (now & A_ALTCHARSET)\n\t\t\t{\n\t\t\t\tint u;\n\t\t\t\tfor (u = 0; unis[u].ascii; u++) {\n\t\t\t\t\tif (ch[0] == unis[u].ascii) {\n\t\t\t\t\t\tprint = unis[u].unicode;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!unis[u].ascii)\n\t\t\t\t\tprint = \" \";\n\t\t\t}\n\t\t\tif (ch[0] == '&')\n\t\t\t\tfprintf(file, \"&amp;\");\n\t\t\telse if (ch[0] == '<')\n\t\t\t\tfprintf(file, \"&lt;\");\n\t\t\telse if (ch[0] == '>')\n\t\t\t\tfprintf(file, \"&gt;\");\n\t\t\telse\n\t\t\t\tfprintf(file, \"%s\", print);\n\t\t\told = now;\n\t\t}\n\t\tfprintf(file, \"</span>\\n\");\n\t\told = 0;\n\t}\n\tfprintf(file, \"</pre>\\n</body>\");\n\tfclose(file);\n}\n", "bug_type": null, "idx": 1082}
{"project": "Pidgin", "target": 0, "func": "static gboolean pidgin_progress_bar_pulse(gpointer data)\n{\n\tPurpleRoomlist *list = data;\n\tPidginRoomlist *rl = list->ui_data;\n\tif (!rl || !rl->dialog || !rl->dialog->pg_needs_pulse) {\n\t\tif (rl && rl->dialog)\n\t\t\trl->dialog->pg_update_to = 0;\n\t\tpurple_roomlist_unref(list);\n\t\treturn FALSE;\n\t}\n\tgtk_progress_bar_pulse(GTK_PROGRESS_BAR(rl->dialog->progress));\n\trl->dialog->pg_needs_pulse = FALSE;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1083}
{"project": "Pidgin", "target": 0, "func": " */\nstatic void gg_image_queue_parse(struct gg_event *e, const char *p,\n\tunsigned int len, struct gg_session *sess, uin_t sender,\n\tuint32_t type)\n{\n\tconst struct gg_msg_image_reply *i = (const void*) p;\n\tstruct gg_image_queue *q, *qq;\n\tgg_debug_session(sess, GG_DEBUG_VERBOSE,\n\t\t\"// gg_image_queue_parse(%p, %p, %d, %p, %u, %d)\\n\",\n\t\te, p, len, sess, sender, type);\n\tif (!p || !sess || !e) {\n\t\terrno = EFAULT;\n\t\treturn;\n\t}\n\tif (i->flag == GG_MSG_OPTION_IMAGE_REQUEST) {\n\t\te->type = GG_EVENT_IMAGE_REQUEST;\n\t\te->event.image_request.sender = sender;\n\t\te->event.image_reply.size = i->size;\n\t\te->event.image_request.crc32 = i->crc32;\n\t\treturn;\n\t}\n\t\n\tfor (qq = sess->images, q = NULL; qq; qq = qq->next) {\n\t\tif (sender == qq->sender && i->size == qq->size && i->crc32 == qq->crc32) {\n\t\t\tq = qq;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!q) {\n\t\tgg_debug_session(sess, GG_DEBUG_WARNING,\n\t\t\t\"// gg_image_queue_parse() unknown image from %d, \"\n\t\t\t\"size=%d, crc32=%.8x\\n\", sender, i->size, i->crc32);\n\t\treturn;\n\t}\n\tif (q->packet_type == 0)\n\t\tq->packet_type = type;\n\tif (q->packet_type != type)\n\t\treturn;\n\tif (i->flag == GG_MSG_OPTION_IMAGE_REPLY) {\n\t\tq->done = 0;\n\t\tlen -= sizeof(struct gg_msg_image_reply);\n\t\tp += sizeof(struct gg_msg_image_reply);\n\t\tif (memchr(p, 0, len) == NULL) {\n\t\t\tgg_debug_session(sess, GG_DEBUG_ERROR,\n\t\t\t\t\"// gg_image_queue_parse() malformed packet \"\n\t\t\t\t\"from %d, unlimited filename\\n\", sender);\n\t\t\treturn;\n\t\t}\n\t\tif (!(q->filename = strdup(p))) {\n\t\t\tgg_debug_session(sess, GG_DEBUG_ERROR, \"// gg_image_queue_parse() out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t\tlen -= strlen(p) + 1;\n\t\tp += strlen(p) + 1;\n\t} else if (i->flag == GG_MSG_OPTION_IMAGE_REPLY_MORE) {\n\t\tlen -= sizeof(struct gg_msg_image_reply);\n\t\tp += sizeof(struct gg_msg_image_reply);\n\t} else {\n\t\tgg_debug_session(sess, GG_DEBUG_WARNING, \"// gg_image_queue_parse() unexpected flag\\n\");\n\t\treturn;\n\t}\n\tif (q->done + len > q->size) {\n\t\tgg_debug_session(sess, GG_DEBUG_ERROR, \"// gg_image_queue_parse() got too much\\n\");\n\t\tlen = q->size - q->done;\n\t}\n\tmemcpy(q->image + q->done, p, len);\n\tq->done += len;\n\tgg_debug_session(sess, GG_DEBUG_VERBOSE,\n\t\t\"// gg_image_queue_parse() got image part (done: %d of %d)\\n\",\n\t\tq->done, q->size);\n\t\n\tif (q->done >= q->size) {\n\t\tgg_debug_session(sess, GG_DEBUG_VERBOSE,\n\t\t\t\"// gg_image_queue_parse() image ready\\n\");\n\t\te->type = GG_EVENT_IMAGE_REPLY;\n\t\te->event.image_reply.sender = sender;\n\t\te->event.image_reply.size = q->size;\n\t\te->event.image_reply.crc32 = q->crc32;\n\t\te->event.image_reply.filename = q->filename;\n\t\te->event.image_reply.image = q->image;\n\t\tgg_image_queue_remove(sess, q, 0);\n\t\tfree(q);\n\t}\n}\n", "bug_type": null, "idx": 1084}
{"project": "Pidgin", "target": 0, "func": "NMContact *\nnm_folder_find_contact_by_userid(NMFolder * folder, const char *userid)\n{\n\tint cnt, i;\n\tNMContact *tmp, *contact = NULL;\n\tif (folder == NULL || userid == NULL)\n\t\treturn NULL;\n\tcnt = nm_folder_get_contact_count(folder);\n\tfor (i = 0; i < cnt; i++) {\n\t\ttmp = nm_folder_get_contact(folder, i);\n\t\tif (tmp && nm_utf8_str_equal(nm_contact_get_userid(tmp), userid)) {\n\t\t\tcontact = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn contact;\n}\n", "bug_type": null, "idx": 1085}
{"project": "Pidgin", "target": 0, "func": "static guint16\nget_simplest_charset(const char *utf8)\n{\n\twhile (*utf8)\n\t{\n\t\tif ((unsigned char)(*utf8) > 0x7f) {\n\t\t\t\n\t\t\treturn AIM_CHARSET_UNICODE;\n\t\t}\n\t\tutf8++;\n\t}\n\treturn AIM_CHARSET_ASCII;\n}\n", "bug_type": null, "idx": 1086}
{"project": "Pidgin", "target": 0, "func": " */\nchar *aim_ssi_getcomment(struct aim_ssi_item *list, const char *gn, const char *bn)\n{\n\tstruct aim_ssi_item *cur = aim_ssi_itemlist_finditem(list, gn, bn, AIM_SSI_TYPE_BUDDY);\n\tif (cur) {\n\t\taim_tlv_t *tlv = aim_tlv_gettlv(cur->data, 0x013c, 1);\n\t\tif (tlv && tlv->length) {\n\t\t\treturn g_strndup((const gchar *)tlv->value, tlv->length);\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1087}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_savedstatus_is_idleaway()\n{\n\treturn purple_prefs_get_bool(\"/purple/savedstatus/isidleaway\");\n}\n\tg_list_free(accounts);\n\tif (purple_savedstatus_is_idleaway()) {\n\t\tpurple_savedstatus_set_idleaway(FALSE);\n\t} else {\n\t\tpurple_signal_emit(purple_savedstatuses_get_handle(), \"savedstatus-changed\",\n\t\t\t\t\t \t   saved_status, old);\n\t}\n\tg_list_free(accounts);\n\tif (purple_savedstatus_is_idleaway()) {\n\t\tpurple_savedstatus_set_idleaway(FALSE);\n\t} else {\n\t\tpurple_signal_emit(purple_savedstatuses_get_handle(), \"savedstatus-changed\",\n\t\t\t\t\t \t   saved_status, old);\n\t}\n", "bug_type": null, "idx": 1088}
{"project": "Pidgin", "target": 0, "func": "static void do_add_select_cb(GtkWidget *widget, gint resp, PidginSmiley *s)\n{\n\tswitch (resp) {\n\t\tcase GTK_RESPONSE_ACCEPT:\n\t\t\tdo_add(widget, s);\n\t\t\tbreak;\n\t\tcase GTK_RESPONSE_DELETE_EVENT:\n\t\tcase GTK_RESPONSE_CANCEL:\n\t\t\tgtk_widget_destroy(s->parent);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpurple_debug_error(\"gtksmiley\", \"no valid response\\n\");\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1089}
{"project": "Pidgin", "target": 0, "func": "void\npurple_signals_unregister_by_instance(void *instance)\n{\n\tgboolean found;\n\tg_return_if_fail(instance != NULL);\n\tfound = g_hash_table_remove(instance_table, instance);\n\t\n\tg_return_if_fail(found);\n}\n", "bug_type": null, "idx": 1090}
{"project": "Pidgin", "target": 0, "func": "GG110Event *\n       gg110_event__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (GG110Event *)\n     protobuf_c_message_unpack (&gg110_event__descriptor,\n                                allocator, len, data);\n}\n", "bug_type": null, "idx": 1091}
{"project": "Pidgin", "target": 0, "func": " ****************************************************************************/\nstatic char *log_get_timestamp(PurpleLog *log, time_t when)\n{\n\tgboolean show_date;\n\tchar *date;\n\tstruct tm *tm;\n\tshow_date = (log->type == PURPLE_LOG_SYSTEM) || (time(NULL) > when + 20*60);\n\tdate = purple_signal_emit_return_1(purple_log_get_handle(),\n\t                          \"log-timestamp\",\n\t                          log, when, show_date);\n\tif (date != NULL)\n\t\treturn date;\n\ttm = localtime(&when);\n\tif (show_date)\n\t\treturn g_strdup(purple_date_format_long(tm));\n\telse\n\t\treturn g_strdup(purple_time_format(tm));\n}\n", "bug_type": null, "idx": 1092}
{"project": "Pidgin", "target": 0, "func": "gint\n_gstroke_canonical (gchar *sequence, struct gstroke_metrics *metrics)\n{\n  return _gstroke_trans (sequence, metrics);\n}\n", "bug_type": null, "idx": 1093}
{"project": "Pidgin", "target": 0, "func": "static void\nclear_scrollback_cb(GntMenuItem *item, gpointer ggconv)\n{\n\tFinchConv *ggc = ggconv;\n\tpurple_conversation_clear_message_history(ggc->active_conv);\n}\n", "bug_type": null, "idx": 1094}
{"project": "Pidgin", "target": 0, "func": "gboolean\ngstroke_draw_strokes(void)\n{\n\treturn draw_strokes;\n}\n", "bug_type": null, "idx": 1095}
{"project": "Pidgin", "target": 0, "func": "static void\ninit_plugin(PurplePlugin *plugin)\n{\n#if 0\n\tpurple_prefs_add_none(\"/plugins\");\n\tpurple_prefs_add_none(\"/plugins/gtk\");\n\tpurple_prefs_add_none(\"/plugins/gtk/spellchk\");\n\tpurple_prefs_add_bool(\"/plugins/gtk/spellchk/last_word_replace\", TRUE);\n#endif\n}\n", "bug_type": null, "idx": 1096}
{"project": "Pidgin", "target": 0, "func": "PurpleProxyInfo *\npurple_account_get_proxy_info(const PurpleAccount *account)\n{\n\tg_return_val_if_fail(account != NULL, NULL);\n\treturn account->proxy_info;\n}\n", "bug_type": null, "idx": 1097}
{"project": "Pidgin", "target": 0, "func": "void\ninit_file()\n{\n\t\n\tstruct stat finfo;\n\tchar filename[MAXPATHLEN];\n\tsnprintf(filename, MAXPATHLEN, \"%s\" G_DIR_SEPARATOR_S \"control\", purple_user_dir());\n\tif ((g_stat(filename, &finfo) == 0) && (finfo.st_size > 0))\n\t\trun_commands();\n}\n", "bug_type": null, "idx": 1098}
{"project": "Pidgin", "target": 0, "func": "const char *wpurple_install_dir(void) {\n\tstatic gboolean initialized = FALSE;\n\tif (!initialized) {\n\t\tchar *tmp = NULL;\n\t\twchar_t winstall_dir[MAXPATHLEN];\n\t\tif (GetModuleFileNameW(libpurpledll_hInstance, winstall_dir,\n\t\t\t\tMAXPATHLEN) > 0) {\n\t\t\ttmp = g_utf16_to_utf8(winstall_dir, -1,\n\t\t\t\tNULL, NULL, NULL);\n\t\t}\n\t\tif (tmp == NULL) {\n\t\t\ttmp = g_win32_error_message(GetLastError());\n\t\t\tpurple_debug_error(\"wpurple\",\n\t\t\t\t\"GetModuleFileName error: %s\\n\", tmp);\n\t\t\tg_free(tmp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tinstall_dir = g_path_get_dirname(tmp);\n\t\t\tg_free(tmp);\n\t\t\tinitialized = TRUE;\n\t\t}\n\t}\n\treturn install_dir;\n}\n", "bug_type": null, "idx": 1099}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_parser_element_start_libxml(void *user_data,\n\t\t\t\t   const xmlChar *element_name, const xmlChar *prefix, const xmlChar *namespace,\n\t\t\t\t   int nb_namespaces, const xmlChar **namespaces,\n\t\t\t\t   int nb_attributes, int nb_defaulted, const xmlChar **attributes)\n{\n\tJabberStream *js = user_data;\n\txmlnode *node;\n\tint i, j;\n\tif(!element_name) {\n\t\treturn;\n\t} else if (js->stream_id == NULL) {\n\t\t\n\t\tif (0 != xmlStrcmp(element_name, (xmlChar *) \"stream\") ||\n\t\t\t\t0 != xmlStrcmp(namespace, (xmlChar *) NS_XMPP_STREAMS)) {\n\t\t\t\n\t\t\tpurple_debug_error(\"jabber\", \"Expecting stream header, got %s with \"\n\t\t\t                   \"xmlns %s\\n\", element_name, namespace);\n\t\t\tpurple_connection_error_reason(js->gc,\n\t\t\t\t\tPURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,\n\t\t\t\t\t_(\"XMPP stream header missing\"));\n\t\t\treturn;\n\t\t}\n\t\tjs->protocol_version.major = 0;\n\t\tjs->protocol_version.minor = 9;\n\t\tfor (i = 0; i < nb_attributes * 5; i += 5) {\n\t\t\tint attrib_len = attributes[i+4] - attributes[i+3];\n\t\t\tchar *attrib = g_strndup((gchar *)attributes[i+3], attrib_len);\n\t\t\tif(!xmlStrcmp(attributes[i], (xmlChar*) \"version\")) {\n\t\t\t\tconst char *dot = strchr(attrib, '.');\n\t\t\t\tjs->protocol_version.major = atoi(attrib);\n\t\t\t\tjs->protocol_version.minor = dot ? atoi(dot + 1) : 0;\n\t\t\t\tif (js->protocol_version.major > 1) {\n\t\t\t\t\t\n\t\t\t\t\tpurple_connection_error_reason(js->gc,\n\t\t\t\t\t\t\tPURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,\n\t\t\t\t\t\t\t_(\"XMPP Version Mismatch\"));\n\t\t\t\t\tg_free(attrib);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (js->protocol_version.major == 0 && js->protocol_version.minor != 9) {\n\t\t\t\t\tpurple_debug_warning(\"jabber\", \"Treating version %s as 0.9 for backward \"\n\t\t\t\t\t                     \"compatibility\\n\", attrib);\n\t\t\t\t}\n\t\t\t\tg_free(attrib);\n\t\t\t} else if(!xmlStrcmp(attributes[i], (xmlChar*) \"id\")) {\n\t\t\t\tg_free(js->stream_id);\n\t\t\t\tjs->stream_id = attrib;\n\t\t\t} else {\n\t\t\t\tg_free(attrib);\n\t\t\t}\n\t\t}\n\t\tif (js->stream_id == NULL) {\n#if 0\n\t\t\t\n\t\t\tpurple_connection_error_reason(js->gc,\n\t\t\t\t\tPURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,\n\t\t\t\t\t_(\"XMPP stream missing ID\"));\n#else\n\t\t\t\n\t\t\tjs->stream_id = g_strdup(\"\");\n\t\t\tpurple_debug_info(\"jabber\", \"Server failed to specify a stream \"\n\t\t\t                  \"ID (underspecified in rfc3920, but intended \"\n\t\t\t                  \"to be a MUST; digest legacy auth may fail.\\n\");\n#endif\n\t\t}\n\t} else {\n\t\tif(js->current)\n\t\t\tnode = xmlnode_new_child(js->current, (const char*) element_name);\n\t\telse\n\t\t\tnode = xmlnode_new((const char*) element_name);\n\t\txmlnode_set_namespace(node, (const char*) namespace);\n\t\txmlnode_set_prefix(node, (const char *)prefix);\n\t\tif (nb_namespaces != 0) {\n\t\t\tnode->namespace_map = g_hash_table_new_full(\n\t\t\t\tg_str_hash, g_str_equal, g_free, g_free);\n\t\t\tfor (i = 0, j = 0; i < nb_namespaces; i++, j += 2) {\n\t\t\t\tconst char *key = (const char *)namespaces[j];\n\t\t\t\tconst char *val = (const char *)namespaces[j + 1];\n\t\t\t\tg_hash_table_insert(node->namespace_map,\n\t\t\t\t\tg_strdup(key ? key : \"\"), g_strdup(val ? val : \"\"));\n\t\t\t}\n\t\t}\n\t\tfor(i=0; i < nb_attributes * 5; i+=5) {\n\t\t\tconst char *name = (const char *)attributes[i];\n\t\t\tconst char *prefix = (const char *)attributes[i+1];\n\t\t\tconst char *attrib_ns = (const char *)attributes[i+2];\n\t\t\tchar *txt;\n\t\t\tint attrib_len = attributes[i+4] - attributes[i+3];\n\t\t\tchar *attrib = g_strndup((gchar *)attributes[i+3], attrib_len);\n\t\t\ttxt = attrib;\n\t\t\tattrib = purple_unescape_text(txt);\n\t\t\tg_free(txt);\n\t\t\txmlnode_set_attrib_full(node, name, attrib_ns, prefix, attrib);\n\t\t\tg_free(attrib);\n\t\t}\n\t\tjs->current = node;\n\t}\n}\n", "bug_type": null, "idx": 1100}
{"project": "Pidgin", "target": 0, "func": "static void cancel_conversation_timeouts(gpointer key, gpointer value, gpointer user_data) {\n\tCapStatistics *stats = value;\n\tif(stats->timeout_source_id != 0) {\n\t\tpurple_timeout_remove(stats->timeout_source_id);\n\t\tstats->timeout_source_id = 0;\n\t}\n}\n", "bug_type": null, "idx": 1101}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\tGList *convs = purple_get_conversations();\n\tvoid *conv_handle = purple_conversations_get_handle();\n\tvoid *gtk_conv_handle = pidgin_conversations_get_handle();\n\tmy_plugin = plugin;\n\tpurple_signal_connect(gtk_conv_handle, \"displayed-im-msg\", plugin,\n\t                    PURPLE_CALLBACK(message_displayed_cb), NULL);\n\tpurple_signal_connect(gtk_conv_handle, \"displayed-chat-msg\", plugin,\n\t                    PURPLE_CALLBACK(message_displayed_cb), NULL);\n\tpurple_signal_connect(gtk_conv_handle, \"conversation-switched\", plugin,\n\t                    PURPLE_CALLBACK(conv_switched), NULL);\n\tpurple_signal_connect(conv_handle, \"sent-im-msg\", plugin,\n\t                    PURPLE_CALLBACK(im_sent_im), NULL);\n\tpurple_signal_connect(conv_handle, \"sent-chat-msg\", plugin,\n\t                    PURPLE_CALLBACK(chat_sent_im), NULL);\n\tpurple_signal_connect(conv_handle, \"conversation-created\", plugin,\n\t                    PURPLE_CALLBACK(conv_created), NULL);\n\tpurple_signal_connect(conv_handle, \"deleting-conversation\", plugin,\n\t                    PURPLE_CALLBACK(deleting_conv), NULL);\n#if 0\n\tpurple_signal_connect(gtk_conv_handle, \"conversation-dragging\", plugin,\n\t                    PURPLE_CALLBACK(conversation_dragging), NULL);\n#endif\n\twhile (convs) {\n\t\tPurpleConversation *conv = (PurpleConversation *)convs->data;\n\t\t\n\t\tattach_signals(conv);\n\t\tconvs = convs->next;\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1102}
{"project": "Pidgin", "target": 0, "func": "static gboolean call_callback(gpointer data) {\n\tStunCallback cb = data;\n\tcb(&nattype);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 1103}
{"project": "Pidgin", "target": 0, "func": "void pidgin_disco_list_unref(PidginDiscoList *list)\n{\n\tg_return_if_fail(list != NULL);\n\t--list->ref;\n\tpurple_debug_misc(\"xmppdisco\", \"unreffing list, ref count now %d\\n\", list->ref);\n\tif (list->ref == 0)\n\t\tpidgin_disco_list_destroy(list);\n}\n", "bug_type": null, "idx": 1104}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\nget_config_frame(PurplePlugin *plugin)\n{\n\tGtkWidget *ret;\n\tGtkWidget *frame;\n\tint i;\n\tret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);\n\tgtk_container_set_border_width(GTK_CONTAINER(ret), PIDGIN_HIG_BORDER);\n\tfor (i = 0; formats[i].prefix; i++)\n\t{\n\t\tchar tmp[128];\n\t\tchar tmp2[128];\n\t\tint f;\n\t\tgboolean e;\n\t\tGtkWidget *vbox, *hbox, *button;\n\t\tg_snprintf(tmp2, sizeof(tmp2), \"%s/enabled\", formats[i].prefix);\n\t\te = purple_prefs_get_bool(tmp2);\n\t\tg_snprintf(tmp, sizeof(tmp), \"%s/format\", formats[i].prefix);\n\t\tf = purple_prefs_get_int(tmp);\n\t\tframe = pidgin_make_frame(ret, _(formats[i].text));\n\t\tvbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);\n\t\tgtk_box_pack_start(GTK_BOX(frame), vbox, FALSE, FALSE, 0);\n\t\thbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);\n\t\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\t\tbutton = gtk_check_button_new_with_label(_(\"Enabled\"));\n\t\tgtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);\n\t\tif (e)\n\t\t\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);\n\t\tg_signal_connect(G_OBJECT(button), \"clicked\", G_CALLBACK(toggle_enabled),\n\t\t\t\tformats[i].prefix);\n\t\tbutton = pidgin_pixbuf_button_from_stock(\" Color\", GTK_STOCK_SELECT_COLOR,\n\t\t\t\tPIDGIN_BUTTON_HORIZONTAL);\n\t\tgtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);\n\t\tg_signal_connect(G_OBJECT(button), \"clicked\", G_CALLBACK(set_color),\n\t\t\t\tformats[i].prefix);\n\t\tgtk_widget_set_sensitive(button, e);\n\t\tpurple_prefs_connect_callback(plugin, tmp2, enable_toggled, button);\n\t\tbutton = gtk_check_button_new_with_label(_(\"Bold\"));\n\t\tgtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);\n\t\tif (f & FONT_BOLD)\n\t\t\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);\n\t\tg_signal_connect(G_OBJECT(button), \"clicked\", G_CALLBACK(toggle_bold),\n\t\t\t\tformats[i].prefix);\n\t\tgtk_widget_set_sensitive(button, e);\n\t\tpurple_prefs_connect_callback(plugin, tmp2, enable_toggled, button);\n\t\tbutton = gtk_check_button_new_with_label(_(\"Italic\"));\n\t\tgtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);\n\t\tif (f & FONT_ITALIC)\n\t\t\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);\n\t\tg_signal_connect(G_OBJECT(button), \"clicked\", G_CALLBACK(toggle_italic),\n\t\t\t\tformats[i].prefix);\n\t\tgtk_widget_set_sensitive(button, e);\n\t\tpurple_prefs_connect_callback(plugin, tmp2, enable_toggled, button);\n\t\tbutton = gtk_check_button_new_with_label(_(\"Underline\"));\n\t\tgtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);\n\t\tif (f & FONT_UNDERLINE)\n\t\t\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);\n\t\tg_signal_connect(G_OBJECT(button), \"clicked\",\n\t\t\t\tG_CALLBACK(toggle_underline), formats[i].prefix);\n\t\tgtk_widget_set_sensitive(button, e);\n\t\tpurple_prefs_connect_callback(plugin, tmp2, enable_toggled, button);\n\t}\n\tg_signal_connect(GTK_OBJECT(ret), \"destroy\", G_CALLBACK(disconnect_prefs_callbacks), plugin);\n\tframe = pidgin_make_frame(ret, _(\"General\"));\n\tpidgin_prefs_checkbox(_(\"Ignore incoming format\"), PREF_IGNORE, frame);\n\tpidgin_prefs_checkbox(_(\"Apply in Chats\"), PREF_CHATS, frame);\n\tpidgin_prefs_checkbox(_(\"Apply in IMs\"), PREF_IMS, frame);\n\tgtk_widget_show_all(ret);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1105}
{"project": "Pidgin", "target": 0, "func": "GntWidget *gnt_line_new(gboolean vertical)\n{\n\tGntWidget *widget = g_object_new(GNT_TYPE_LINE, \"vertical\", vertical, NULL);\n\treturn widget;\n}\n", "bug_type": null, "idx": 1106}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_box_gained_focus(GntWidget *widget)\n{\n\tGntWidget *w = GNT_BOX(widget)->active;\n\tif (w)\n\t\tgnt_widget_set_focus(w, TRUE);\n\tgnt_widget_draw(widget);\n}\n", "bug_type": null, "idx": 1107}
{"project": "Pidgin", "target": 0, "func": "static GList *txt_logger_list_syslog(PurpleAccount *account)\n{\n\treturn purple_log_common_lister(PURPLE_LOG_SYSTEM, \".system\", account, \".txt\", txt_logger);\n}\n", "bug_type": null, "idx": 1108}
{"project": "Pidgin", "target": 0, "func": "#endif \nstatic void tcl_init_plugin(PurplePlugin *plugin)\n{\n#ifdef USE_TCL_STUBS\n\tTcl_Interp *interp = NULL;\n#endif\n\t_tcl_plugin = plugin;\n#ifdef USE_TCL_STUBS\n#ifdef _WIN32\n\tif(!tcl_win32_init())\n\t\treturn;\n#endif\n\tif(!(interp = Tcl_CreateInterp()))\n\t\treturn;\n\tif(!Tcl_InitStubs(interp, TCL_VERSION, 0)) {\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"tcl\", \"Tcl_InitStubs: %s\\n\", interp->result);\n\t\treturn;\n\t}\n#endif\n\tTcl_FindExecutable(\"purple\");\n#if defined(USE_TK_STUBS) && defined(HAVE_TK)\n\tTk_Init(interp);\n\tif(!Tk_InitStubs(interp, TK_VERSION, 0)) {\n\t\tpurple_debug(PURPLE_DEBUG_ERROR, \"tcl\", \"Error Tk_InitStubs: %s\\n\", interp->result);\n\t\tTcl_DeleteInterp(interp);\n\t\treturn;\n\t}\n#endif\n\ttcl_loaded = TRUE;\n#ifdef USE_TCL_STUBS\n\tTcl_DeleteInterp(interp);\n#endif\n\ttcl_loader_info.exts = g_list_append(tcl_loader_info.exts, \"tcl\");\n}\n", "bug_type": null, "idx": 1109}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\t\n\tnotify_example = plugin;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1110}
{"project": "Pidgin", "target": 0, "func": "gboolean gnt_wm_process_input(GntWM *wm, const char *keys)\n{\n\tgboolean ret = FALSE;\n\tkeys = gnt_bindable_remap_keys(GNT_BINDABLE(wm), keys);\n\tidle_update = TRUE;\n\tif(ignore_keys){\n\t\tif(keys && !strcmp(keys, \"\\033\" GNT_KEY_CTRL_G)){\n\t\t\tif(gnt_bindable_perform_action_key(GNT_BINDABLE(wm), keys)){\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\treturn wm->cws->ordered ? gnt_widget_key_pressed(GNT_WIDGET(wm->cws->ordered->data), keys) : FALSE;\n\t}\n\tif (gnt_bindable_perform_action_key(GNT_BINDABLE(wm), keys)) {\n\t\treturn TRUE;\n\t}\n\t\n\tif (wm->cws->ordered && wm->mode != GNT_KP_MODE_NORMAL) {\n\t\tint xmin = 0, ymin = 0, xmax = getmaxx(stdscr), ymax = getmaxy(stdscr) - 1;\n\t\tint x, y, w, h;\n\t\tGntWidget *widget = GNT_WIDGET(wm->cws->ordered->data);\n\t\tint ox, oy, ow, oh;\n\t\tgnt_widget_get_position(widget, &x, &y);\n\t\tgnt_widget_get_size(widget, &w, &h);\n\t\tox = x;\toy = y;\n\t\tow = w;\toh = h;\n\t\tif (wm->mode == GNT_KP_MODE_MOVE) {\n\t\t\tif (strcmp(keys, GNT_KEY_LEFT) == 0) {\n\t\t\t\tif (x > xmin)\n\t\t\t\t\tx--;\n\t\t\t} else if (strcmp(keys, GNT_KEY_RIGHT) == 0) {\n\t\t\t\tif (x + w < xmax)\n\t\t\t\t\tx++;\n\t\t\t} else if (strcmp(keys, GNT_KEY_UP) == 0) {\n\t\t\t\tif (y > ymin)\n\t\t\t\t\ty--;\n\t\t\t} else if (strcmp(keys, GNT_KEY_DOWN) == 0) {\n\t\t\t\tif (y + h < ymax)\n\t\t\t\t\ty++;\n\t\t\t}\n\t\t\tif (ox != x || oy != y) {\n\t\t\t\tgnt_screen_move_widget(widget, x, y);\n\t\t\t\twindow_reverse(widget, TRUE, wm);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t} else if (wm->mode == GNT_KP_MODE_RESIZE) {\n\t\t\tif (strcmp(keys, GNT_KEY_LEFT) == 0) {\n\t\t\t\tw--;\n\t\t\t} else if (strcmp(keys, GNT_KEY_RIGHT) == 0) {\n\t\t\t\tif (x + w < xmax)\n\t\t\t\t\tw++;\n\t\t\t} else if (strcmp(keys, GNT_KEY_UP) == 0) {\n\t\t\t\th--;\n\t\t\t} else if (strcmp(keys, GNT_KEY_DOWN) == 0) {\n\t\t\t\tif (y + h < ymax)\n\t\t\t\t\th++;\n\t\t\t}\n\t\t\tif (oh != h || ow != w) {\n\t\t\t\tgnt_screen_resize_widget(widget, w, h);\n\t\t\t\twindow_reverse(widget, TRUE, wm);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(keys, \"\\r\") == 0 || strcmp(keys, \"\\033\") == 0) {\n\t\t\twindow_reverse(widget, FALSE, wm);\n\t\t\twm->mode = GNT_KP_MODE_NORMAL;\n\t\t}\n\t\treturn TRUE;\n\t}\n\t\n\tif (strcmp(keys, \"\\033\") == 0) {\n\t\tif (wm->_list.window) {\n\t\t\tgnt_widget_destroy(wm->_list.window);\n\t\t\treturn TRUE;\n\t\t}\n\t} else if (keys[0] == '\\033' && isdigit(keys[1]) && keys[2] == '\\0') {\n\t\t\n\t\tint n = *(keys + 1) - '0';\n\t\tGList *list = NULL;\n\t\tif (n == 0)\n\t\t\tn = 10;\n\t\tlist = g_list_append(list, GINT_TO_POINTER(n - 1));\n\t\tswitch_window_n(GNT_BINDABLE(wm), list);\n\t\tg_list_free(list);\n\t\treturn TRUE;\n\t}\n\tif (wm->menu)\n\t\tret = gnt_widget_key_pressed(GNT_WIDGET(wm->menu), keys);\n\telse if (wm->_list.window)\n\t\tret = gnt_widget_key_pressed(wm->_list.window, keys);\n\telse if (wm->cws->ordered) {\n\t\tGntWidget *win = wm->cws->ordered->data;\n\t\tif (GNT_IS_WINDOW(win)) {\n\t\t\tGntMenu *menu = GNT_WINDOW(win)->menu;\n\t\t\tif (menu) {\n\t\t\t\tconst char *id = gnt_window_get_accel_item(GNT_WINDOW(win), keys);\n\t\t\t\tif (id) {\n\t\t\t\t\tGntMenuItem *item = gnt_menu_get_item(menu, id);\n\t\t\t\t\tif (item)\n\t\t\t\t\t\tret = gnt_menuitem_activate(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ret)\n\t\t\tret = gnt_widget_key_pressed(win, keys);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 1111}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ngtk_imhtmltoolbar_popup_menu(GtkWidget *widget, GdkEventButton *event, GtkIMHtmlToolbar *toolbar)\n{\n\tGtkWidget *menu;\n\tGtkWidget *item;\n\tgboolean wide;\n\tif (event->button != 3)\n\t\treturn FALSE;\n\twide = GTK_WIDGET_VISIBLE(toolbar->bold);\n\tmenu = gtk_menu_new();\n\titem = gtk_menu_item_new_with_mnemonic(wide ? _(\"Group Items\") : _(\"Ungroup Items\"));\n\tg_signal_connect(G_OBJECT(item), \"activate\", G_CALLBACK(switch_toolbar_view), toolbar);\n\tgtk_menu_shell_append(GTK_MENU_SHELL(menu), item);\n\tgtk_widget_show(item);\n\tgtk_menu_popup(GTK_MENU(menu), NULL, NULL, pidgin_menu_position_func_helper,\n\t\t\t\twidget, event->button, event->time);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1112}
{"project": "Pidgin", "target": 0, "func": "static void\ndo_small(GtkWidget *smalltb, GtkIMHtmlToolbar *toolbar)\n{\n\tg_return_if_fail(toolbar != NULL);\n\t\n\tif (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(smalltb)))\n\t\tgtk_imhtml_font_shrink(GTK_IMHTML(toolbar->imhtml));\n\tgtk_widget_grab_focus(toolbar->imhtml);\n}\n", "bug_type": null, "idx": 1113}
{"project": "Pidgin", "target": 0, "func": "static void\nsendframe_flap(FlapConnection *conn, FlapFrame *frame)\n{\n\tByteStream bs;\n\tint payloadlen, bslen;\n\tpayloadlen = byte_stream_curpos(&frame->data);\n\tbyte_stream_new(&bs, 6 + payloadlen);\n\t\n\tbyte_stream_put8(&bs, 0x2a);\n\tbyte_stream_put8(&bs, frame->channel);\n\tbyte_stream_put16(&bs, frame->seqnum);\n\tbyte_stream_put16(&bs, payloadlen);\n\t\n\tbyte_stream_rewind(&frame->data);\n\tbyte_stream_putbs(&bs, &frame->data, payloadlen);\n\tbslen = byte_stream_curpos(&bs);\n\tbyte_stream_rewind(&bs);\n\tflap_connection_send_byte_stream(&bs, conn, bslen);\n\tbyte_stream_destroy(&bs);\n}\n", "bug_type": null, "idx": 1114}
{"project": "Pidgin", "target": 0, "func": "static void\nreconnect_elsewhere_accounts(PidginMiniDialog *mini_dialog,\n                             GtkButton *button,\n                             gpointer unused)\n{\n\telsewhere_foreach_account(mini_dialog, enable_account);\n}\n", "bug_type": null, "idx": 1115}
{"project": "Pidgin", "target": 0, "func": "void\npeer_connection_propose(OscarData *od, guint64 type, const char *bn)\n{\n\tPeerConnection *conn;\n\tif (type == OSCAR_CAPABILITY_DIRECTIM)\n\t{\n\t\tconn = peer_connection_find_by_type(od, bn, type);\n\t\tif (conn != NULL)\n\t\t{\n\t\t\tif (conn->ready)\n\t\t\t{\n\t\t\t\tPurpleAccount *account;\n\t\t\t\tPurpleConversation *conv;\n\t\t\t\tpurple_debug_info(\"oscar\", \"Already have a direct IM \"\n\t\t\t\t\t\t\"session with %s.\\n\", bn);\n\t\t\t\taccount = purple_connection_get_account(od->gc);\n\t\t\t\tconv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM,\n\t\t\t\t\t\tbn, account);\n\t\t\t\tif (conv != NULL)\n\t\t\t\t\tpurple_conversation_present(conv);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tpeer_connection_destroy(conn, OSCAR_DISCONNECT_RETRYING, NULL);\n\t\t}\n\t}\n\tconn = peer_connection_new(od, type, bn);\n\tconn->flags |= PEER_CONNECTION_FLAG_INITIATED_BY_ME;\n\tconn->flags |= PEER_CONNECTION_FLAG_APPROVED;\n\taim_icbm_makecookie(conn->cookie);\n\tpeer_connection_trynext(conn);\n}\n", "bug_type": null, "idx": 1116}
{"project": "Pidgin", "target": 0, "func": "void\npurple_dnsquery_init(void)\n{\n}\n", "bug_type": null, "idx": 1117}
{"project": "Pidgin", "target": 0, "func": "EContact *\ngevo_search_buddy_in_contacts(PurpleBuddy *buddy, EBookQuery *query)\n{\n\tESourceList *addressbooks;\n\tGError *err = NULL;\n\tEBookQuery *full_query;\n\tGSList *groups, *g;\n\tEContact *result;\n\tEContactField protocol_field = gevo_prpl_get_field(buddy->account, buddy);\n\tif (protocol_field == 0)\n\t\treturn NULL;\n\tif (query != NULL)\n\t{\n\t\tEBookQuery *queries[2];\n\t\tqueries[0] = query;\n\t\tqueries[1] = e_book_query_field_test(protocol_field, E_BOOK_QUERY_IS, buddy->name);\n\t\tif (queries[1] == NULL)\n\t\t{\n\t\t\tpurple_debug_error(\"evolution\", \"Error in creating protocol query\\n\");\n\t\t\te_book_query_unref(query);\n\t\t\treturn NULL;\n\t\t}\n\t\tfull_query = e_book_query_and(2, queries, TRUE);\n\t}\n\telse\n\t{\n\t\tfull_query = e_book_query_field_test(protocol_field, E_BOOK_QUERY_IS, buddy->name);\n\t\tif (full_query == NULL)\n\t\t{\n\t\t\tpurple_debug_error(\"evolution\", \"Error in creating protocol query\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (!e_book_get_addressbooks(&addressbooks, &err))\n\t{\n\t\tpurple_debug_error(\"evolution\",\n\t\t\t\t\t\t \"Unable to fetch list of address books.\\n\");\n\t\te_book_query_unref(full_query);\n\t\tif (err != NULL)\n\t\t\tg_error_free(err);\n\t\treturn NULL;\n\t}\n\tgroups = e_source_list_peek_groups(addressbooks);\n\tif (groups == NULL)\n\t{\n\t\tg_object_unref(addressbooks);\n\t\te_book_query_unref(full_query);\n\t\treturn NULL;\n\t}\n\tfor (g = groups; g != NULL; g = g->next)\n\t{\n\t\tGSList *sources, *s;\n\t\tsources = e_source_group_peek_sources(g->data);\n\t\tfor (s = sources; s != NULL; s = s->next)\n\t\t{\n\t\t\tresult = gevo_run_query_in_uri(e_source_get_uri(E_SOURCE(s->data)), full_query);\n\t\t\tif (result != NULL) {\n\t\t\t    g_object_unref(addressbooks);\n\t\t\t\te_book_query_unref(full_query);\n\t\t\t    return result;\n\t\t\t}\n\t\t}\n\t}\n\tg_object_unref(addressbooks);\n\te_book_query_unref(full_query);\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1118}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_notify_sr_new_rows(PurpleConnection *gc,\n\t\tPurpleNotifySearchResults *results, void *data)\n{\n\tGntTree *tree = GNT_TREE(data);\n\tGList *o;\n\t\n\tfor (o = results->rows; o; o = o->next)\n\t{\n\t\tgnt_tree_add_row_after(GNT_TREE(tree), o->data,\n\t\t\t\tgnt_tree_create_row_from_list(GNT_TREE(tree), o->data),\n\t\t\t\tNULL, NULL);\n\t}\n}\n", "bug_type": null, "idx": 1119}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int parsedata(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs)\n{\n\tint ret = 0;\n\taim_rxcallback_t userfunc;\n\tguint8 fmtver; \n\tguint16 namelen, gid, bid, type;\n\tchar *name;\n\tGSList *data;\n\tGString *debugstr = g_string_new(\"\");\n\tfmtver = byte_stream_get8(bs); \n\tod->ssi.numitems += byte_stream_get16(bs); \n\t\n\twhile (byte_stream_bytes_left(bs) > 4) { \n\t\tif ((namelen = byte_stream_get16(bs)))\n\t\t\tname = byte_stream_getstr(bs, namelen);\n\t\telse\n\t\t\tname = NULL;\n\t\tgid = byte_stream_get16(bs);\n\t\tbid = byte_stream_get16(bs);\n\t\ttype = byte_stream_get16(bs);\n\t\tdata = aim_tlvlist_readlen(bs, byte_stream_get16(bs));\n\t\taim_ssi_item_debug_append(debugstr, \"\\t\", aim_ssi_itemlist_add(&od->ssi.official, name, gid, bid, type, data));\n\t\tg_free(name);\n\t\taim_tlvlist_free(data);\n\t}\n\tpurple_debug_misc(\"oscar\", \"Reading items from tlvlist for account %s:\\n%s\",\n\t\tpurple_connection_get_account(od->gc)->username, debugstr->str);\n\tg_string_free(debugstr, TRUE);\n\t\n\tod->ssi.timestamp = byte_stream_get32(bs);\n\tif (!(snac->flags & 0x0001)) {\n\t\t\n\t\tstruct aim_ssi_item *cur;\n\t\tfor (cur=od->ssi.official; cur; cur=cur->next)\n\t\t\taim_ssi_itemlist_add(&od->ssi.local, cur->name, cur->gid, cur->bid, cur->type, cur->data);\n\t\tod->ssi.received_data = TRUE;\n\t\tif ((userfunc = aim_callhandler(od, snac->family, snac->subtype)))\n\t\t\tret = userfunc(od, conn, frame, fmtver, od->ssi.numitems, od->ssi.timestamp);\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 1120}
{"project": "Pidgin", "target": 0, "func": "static void\naccount_update(GtkWidget *widget, GtkOptionMenu *optmenu)\n{\n\tPurpleAccount *account = NULL;\n\taccount = g_object_get_data(G_OBJECT(gtk_menu_get_active(GTK_MENU(gtk_option_menu_get_menu(optmenu)))), \"account\");\n\tpurple_account_set_int(account, \"score\", gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(widget)));\n}\n", "bug_type": null, "idx": 1121}
{"project": "Pidgin", "target": 0, "func": "static void\ngnt_tree_set_property(GObject *obj, guint prop_id, const GValue *value,\n\t\tGParamSpec *spec)\n{\n\tGntTree *tree = GNT_TREE(obj);\n\tswitch (prop_id) {\n\t\tcase PROP_COLUMNS:\n\t\t\t_gnt_tree_init_internals(tree, g_value_get_int(value));\n\t\t\tbreak;\n\t\tcase PROP_EXPANDER:\n\t\t\tif (tree->priv->expander_level == g_value_get_int(value))\n\t\t\t\tbreak;\n\t\t\ttree->priv->expander_level = g_value_get_int(value);\n\t\t\tg_object_notify(obj, \"expander-level\");\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1122}
{"project": "Pidgin", "target": 0, "func": "\nGHashTable* jabber_auth_digest_md5_parse(const char *challenge)\n{\n\tconst char *token_start, *val_start, *val_end, *cur;\n\tGHashTable *ret = g_hash_table_new_full(g_str_hash, g_str_equal,\n\t\t\tg_free, g_free);\n\tcur = challenge;\n\twhile(*cur != '\\0') {\n\t\t\n\t\tgboolean in_quotes = FALSE;\n\t\tchar *name, *value = NULL;\n\t\ttoken_start = cur;\n\t\twhile(*cur != '\\0' && (in_quotes || (!in_quotes && *cur != ','))) {\n\t\t\tif (*cur == '\"')\n\t\t\t\tin_quotes = !in_quotes;\n\t\t\tcur++;\n\t\t}\n\t\t\n\t\tval_start = strchr(token_start, '=');\n\t\tif (val_start == NULL || val_start > cur)\n\t\t\tval_start = cur;\n\t\tif (token_start != val_start) {\n\t\t\tname = g_strndup(token_start, val_start - token_start);\n\t\t\tif (val_start != cur) {\n\t\t\t\tval_start++;\n\t\t\t\twhile (val_start != cur && (*val_start == ' ' || *val_start == '\\t'\n\t\t\t\t\t\t|| *val_start == '\\r' || *val_start == '\\n'\n\t\t\t\t\t\t|| *val_start == '\"'))\n\t\t\t\t\tval_start++;\n\t\t\t\tval_end = cur;\n\t\t\t\twhile (val_end >= val_start && (*val_end == ' ' || *val_end == ',' || *val_end == '\\t'\n\t\t\t\t\t\t|| *val_end == '\\r' || *val_end == '\\n'\n\t\t\t\t\t\t|| *val_end == '\"'  || *val_end == '\\0'))\n\t\t\t\t\tval_end--;\n\t\t\t\tif (val_end - val_start + 1 >= 0)\n\t\t\t\t\tvalue = g_strndup(val_start, val_end - val_start + 1);\n\t\t\t}\n\t\t\tg_hash_table_replace(ret, name, value);\n\t\t}\n\t\t\n\t\tif (*cur != '\\0') {\n\t\t\tcur++;\n\t\t\twhile (*cur == ' ' || *cur == ',' || *cur == '\\t'\n\t\t\t\t\t|| *cur == '\\r' || *cur == '\\n')\n\t\t\t\tcur++;\n\t\t}\n\t}\n\treturn ret;\n}\n", "bug_type": null, "idx": 1123}
{"project": "Pidgin", "target": 0, "func": "int irc_cmd_service(struct irc_conn *irc, const char *cmd, const char *target, const char **args)\n{\n\tchar *capital_cmd, *buf;\n\tif (!args || !args[0])\n\t\treturn 0;\n\t\n\tcapital_cmd = g_ascii_strup(cmd, -1);\n\tbuf = irc_format(irc, \"v:\", capital_cmd, args[0]);\n\tirc_send(irc, buf);\n\tg_free(capital_cmd);\n\tg_free(buf);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1124}
{"project": "Pidgin", "target": 0, "func": "static int purple_ssi_parseack(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {\n\tPurpleConnection *gc = od->gc;\n\tva_list ap;\n\tstruct aim_ssi_tmp *retval;\n\tva_start(ap, fr);\n\tretval = va_arg(ap, struct aim_ssi_tmp *);\n\tva_end(ap);\n\twhile (retval) {\n\t\tpurple_debug_misc(\"oscar\",\n\t\t\t\t   \"ssi: status is 0x%04hx for a 0x%04hx action with name %s\\n\", retval->ack,  retval->action, retval->item ? (retval->item->name ? retval->item->name : \"no name\") : \"no item\");\n\t\tif (retval->ack != 0xffff)\n\t\tswitch (retval->ack) {\n\t\t\tcase 0x0000: { \n\t\t\t} break;\n\t\t\tcase 0x000c: { \n\t\t\t\tgchar *buf;\n\t\t\t\tbuf = g_strdup_printf(_(\"Unable to add the buddy %s because you have too many buddies in your buddy list.  Please remove one and try again.\"), (retval->name ? retval->name : _(\"(no name)\")));\n\t\t\t\tif ((retval->name != NULL) && !purple_conv_present_error(retval->name, purple_connection_get_account(gc), buf))\n\t\t\t\t\tpurple_notify_error(gc, NULL, _(\"Unable to Add\"), buf);\n\t\t\t\tg_free(buf);\n\t\t\t} break;\n\t\t\tcase 0x000e: { \n\t\t\t\tif ((retval->action == SNAC_SUBTYPE_FEEDBAG_ADD) && (retval->name))\n\t\t\t\t\toscar_auth_sendrequest(gc, retval->name, NULL);\n\t\t\t} break;\n\t\t\tdefault: { \n\t\t\t\tgchar *buf;\n\t\t\t\tpurple_debug_error(\"oscar\", \"ssi: Action 0x%04hx was unsuccessful with error 0x%04hx\\n\", retval->action, retval->ack);\n\t\t\t\tbuf = g_strdup_printf(_(\"Unable to add the buddy %s for an unknown reason.\"),\n\t\t\t\t\t\t(retval->name ? retval->name : _(\"(no name)\")));\n\t\t\t\tif ((retval->name != NULL) && !purple_conv_present_error(retval->name, purple_connection_get_account(gc), buf))\n\t\t\t\t\tpurple_notify_error(gc, NULL, _(\"Unable to Add\"), buf);\n\t\t\t\tg_free(buf);\n\t\t\t} break;\n\t\t}\n\t\tretval = retval->next;\n\t}\n\treturn 1;\n}\n", "bug_type": null, "idx": 1125}
{"project": "Pidgin", "target": 0, "func": "const char *gnt_entry_get_text(GntEntry *entry)\n{\n\treturn entry->start;\n}\n", "bug_type": null, "idx": 1126}
{"project": "Pidgin", "target": 0, "func": "int\nicq_modfirst(OscarData *od, aim_module_t *mod)\n{\n\tmod->family = SNAC_FAMILY_ICQ;\n\tmod->version = 0x0001;\n\tmod->toolid = 0x0110;\n\tmod->toolversion = 0x047c;\n\tmod->flags = 0;\n\tstrncpy(mod->name, \"icq\", sizeof(mod->name));\n\tmod->snachandler = snachandler;\n\tmod->shutdown = icq_shutdown;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1127}
{"project": "Pidgin", "target": 0, "func": "static int\nsound_playing_event_cb(PurpleSoundEventID event, const PurpleAccount *account) {\n\tif (account != NULL)\n\t\tpurple_debug_misc(\"signals test\", \"sound playing event: %d for account: %s\\n\",\n\t    \t            event, purple_account_get_username(account));\n\telse\n\t\tpurple_debug_misc(\"signals test\", \"sound playing event: %d\\n\", event);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1128}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_xfer_new_xfer(PurpleXfer *xfer)\n{\n\tPidginXferUiData *data;\n\t\n\tdata = g_new0(PidginXferUiData, 1);\n\txfer->ui_data = data;\n}\n", "bug_type": null, "idx": 1129}
{"project": "Pidgin", "target": 0, "func": "guint32 byte_stream_getle32(ByteStream *bs)\n{\n\tg_return_val_if_fail(byte_stream_bytes_left(bs) >= 4, 0);\n\tbs->offset += 4;\n\treturn aimutil_getle32(bs->data + bs->offset - 4);\n}\n", "bug_type": null, "idx": 1130}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_debug_print(PurpleDebugLevel level, const char *category,\n\t\t\t\t\t const char *arg_s)\n{\n#ifdef USE_REGEX\n\tGtkTreeIter iter;\n#endif \n\tgchar *ts_s;\n\tgchar *esc_s, *cat_s, *tmp, *s;\n\tconst char *mdate;\n\ttime_t mtime;\n\tif (debug_win == NULL ||\n\t\t!purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/debug/enabled\"))\n\t{\n\t\treturn;\n\t}\n\tmtime = time(NULL);\n\tmdate = purple_utf8_strftime(\"%H:%M:%S\", localtime(&mtime));\n\tts_s = g_strdup_printf(\"(%s) \", mdate);\n\tif (category == NULL)\n\t\tcat_s = g_strdup(\"\");\n\telse\n\t\tcat_s = g_strdup_printf(\"<b>%s:</b> \", category);\n\tesc_s = g_markup_escape_text(arg_s, -1);\n\ts = g_strdup_printf(\"<font color=\\\"%s\\\">%s%s%s</font>\",\n\t\t\t\t\t\tdebug_fg_colors[level], ts_s, cat_s, esc_s);\n\tg_free(ts_s);\n\tg_free(cat_s);\n\tg_free(esc_s);\n\ttmp = purple_utf8_try_convert(s);\n\tg_free(s);\n\ts = tmp;\n\tif (level == PURPLE_DEBUG_FATAL) {\n\t\ttmp = g_strdup_printf(\"<b>%s</b>\", s);\n\t\tg_free(s);\n\t\ts = tmp;\n\t}\n#ifdef USE_REGEX\n\t\n\tgtk_list_store_append(debug_win->store, &iter);\n\tgtk_list_store_set(debug_win->store, &iter, 0, s, 1, level, -1);\n#else \n\tif(!debug_win->paused && level >= purple_prefs_get_int(PIDGIN_PREFS_ROOT \"/debug/filterlevel\"))\n\t\tgtk_imhtml_append_text(GTK_IMHTML(debug_win->text), s, 0);\n#endif \n\tg_free(s);\n}\n", "bug_type": null, "idx": 1131}
{"project": "Pidgin", "target": 0, "func": "void\ngnt_wm_add_workspace(GntWM *wm, GntWS *ws)\n{\n\twm->workspaces = g_list_append(wm->workspaces, ws);\n}\n", "bug_type": null, "idx": 1132}
{"project": "Pidgin", "target": 0, "func": "static gboolean log_popup_menu_cb(GtkWidget *treeview, PidginLogViewer *lv)\n{\n\tGtkTreeSelection *sel;\n\tGtkTreeIter *iter;\n\tGValue val;\n\tPurpleLog *log;\n\tgpointer *data;\n\titer = g_new(GtkTreeIter, 1);\n\tsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(lv->treeview));\n\tif (!gtk_tree_selection_get_selected(sel, NULL, iter))\n\t{\n\t\treturn FALSE;\n\t}\n\tval.g_type = 0;\n\tgtk_tree_model_get_value(GTK_TREE_MODEL(lv->treestore),\n\t                         iter, NODE_COLUMN, &val);\n\tlog = g_value_get_pointer(&val);\n\tif (log == NULL)\n\t\treturn FALSE;\n\tdata = g_new(gpointer, 4);\n\tdata[0] = lv;\n\tdata[1] = log;\n\tdata[2] = pidgin_treeview_popup_menu_position_func;\n\tdata[3] = iter;\n\tlog_show_popup_menu(treeview, NULL, data);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1133}
{"project": "Pidgin", "target": 0, "func": "gboolean\npidgin_mini_dialog_links_supported()\n{\n#if GTK_CHECK_VERSION(2,18,0)\n\treturn TRUE;\n#else\n\treturn FALSE;\n#endif\n}\n", "bug_type": null, "idx": 1134}
{"project": "Pidgin", "target": 0, "func": "static void\nx509_destroy_certificate(PurpleCertificate * crt)\n{\n\tCERTCertificate *crt_dat;\n\tg_return_if_fail(crt);\n\tg_return_if_fail(crt->scheme == &x509_nss);\n\tcrt_dat = X509_NSS_DATA(crt);\n\tg_return_if_fail(crt_dat);\n\t\n\t\n\tCERT_DestroyCertificate(crt_dat);\n\t\n\tg_free(crt);\n}\n", "bug_type": null, "idx": 1135}
{"project": "Pidgin", "target": 0, "func": "const char *\njabber_data_get_cid(const JabberData *data)\n{\n\tg_return_val_if_fail(data != NULL, NULL);\n\treturn data->cid;\n}\n", "bug_type": null, "idx": 1136}
{"project": "Pidgin", "target": 0, "func": "static void\ninsert_image_cb(GtkWidget *save, GtkIMHtmlToolbar *toolbar)\n{\n\tGtkWidget *window;\n\tif (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->image))) {\n\t\twindow = gtk_file_chooser_dialog_new(_(\"Insert Image\"),\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tGTK_FILE_CHOOSER_ACTION_OPEN,\n\t\t\t\t\t\tGTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,\n\t\t\t\t\t\tGTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,\n\t\t\t\t\t\tNULL);\n\t\tgtk_dialog_set_default_response(GTK_DIALOG(window), GTK_RESPONSE_ACCEPT);\n\t\tg_signal_connect(G_OBJECT(GTK_FILE_CHOOSER(window)),\n\t\t\t\t\"response\", G_CALLBACK(do_insert_image_cb), toolbar);\n\t\tgtk_widget_show(window);\n\t\ttoolbar->image_dialog = window;\n\t} else {\n\t\tgtk_widget_destroy(toolbar->image_dialog);\n\t\ttoolbar->image_dialog = NULL;\n\t}\n\tgtk_widget_grab_focus(toolbar->imhtml);\n}\n", "bug_type": null, "idx": 1137}
{"project": "Pidgin", "target": 0, "func": "void\npurple_plugin_pref_set_format_type(PurplePluginPref *pref, PurpleStringFormatType format)\n{\n\tg_return_if_fail(pref != NULL);\n\tg_return_if_fail(pref->type == PURPLE_PLUGIN_PREF_STRING_FORMAT);\n\tpref->format = format;\n}\n", "bug_type": null, "idx": 1138}
{"project": "Pidgin", "target": 0, "func": "static void\naccount_signon_cb(PurpleConnection *gc, gpointer data)\n{\n\tif (mute_login_sounds_timeout != 0)\n\t\tpurple_timeout_remove(mute_login_sounds_timeout);\n\tmute_login_sounds = TRUE;\n\tmute_login_sounds_timeout = purple_timeout_add_seconds(10, unmute_login_sounds_cb, NULL);\n}\n", "bug_type": null, "idx": 1139}
{"project": "Pidgin", "target": 0, "func": "PurpleCipherOps *\npurple_md4_cipher_get_ops(void) {\n\treturn &MD4Ops;\n}\n", "bug_type": null, "idx": 1140}
{"project": "Pidgin", "target": 0, "func": " */\nint aim_ssi_getpermdeny(struct aim_ssi_item *list)\n{\n\tstruct aim_ssi_item *cur = aim_ssi_itemlist_finditem(list, NULL, NULL, AIM_SSI_TYPE_PDINFO);\n\tif (cur) {\n\t\taim_tlv_t *tlv = aim_tlv_gettlv(cur->data, 0x00ca, 1);\n\t\tif (tlv && tlv->value)\n\t\t\treturn aimutil_get8(tlv->value);\n\t}\n\treturn 0;\n}\n", "bug_type": null, "idx": 1141}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_recv_cb_ssl(gpointer data, PurpleSslConnection *gsc,\n\t\tPurpleInputCondition cond)\n{\n\tPurpleConnection *gc = data;\n\tJabberStream *js = gc->proto_data;\n\tint len;\n\tstatic char buf[4096];\n\t\n\tif(!PURPLE_CONNECTION_IS_VALID(gc)) {\n\t\tpurple_ssl_close(gsc);\n\t\tg_return_if_reached();\n\t}\n\twhile((len = purple_ssl_read(gsc, buf, sizeof(buf) - 1)) > 0) {\n\t\tgc->last_received = time(NULL);\n\t\tbuf[len] = '\\0';\n\t\tpurple_debug_info(\"jabber\", \"Recv (ssl)(%d): %s\\n\", len, buf);\n\t\tjabber_parser_process(js, buf, len);\n\t\tif(js->reinit)\n\t\t\tjabber_stream_init(js);\n\t}\n\tif(len < 0 && errno == EAGAIN)\n\t\treturn;\n\telse {\n\t\tgchar *tmp;\n\t\tif (len == 0)\n\t\t\ttmp = g_strdup(_(\"Server closed the connection\"));\n\t\telse\n\t\t\ttmp = g_strdup_printf(_(\"Lost connection with server: %s\"),\n\t\t\t\t\tg_strerror(errno));\n\t\tpurple_connection_error_reason(js->gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);\n\t\tg_free(tmp);\n\t}\n}\n", "bug_type": null, "idx": 1142}
{"project": "Pidgin", "target": 0, "func": "static char *\nnovell_status_text(PurpleBuddy * buddy)\n{\n\tconst char *text = NULL;\n\tconst char *dn = NULL;\n\tPurpleAccount *account;\n\taccount = buddy ? purple_buddy_get_account(buddy) : NULL;\n\tif (buddy && account) {\n\t\tPurpleConnection *gc = purple_account_get_connection(account);\n\t\tif (gc && gc->proto_data) {\n\t\t\tNMUser *user = gc->proto_data;\n\t\t\tdn = nm_lookup_dn(user, purple_buddy_get_name(buddy));\n\t\t\tif (dn) {\n\t\t\t\tNMUserRecord *user_record = nm_find_user_record(user, dn);\n\t\t\t\tif (user_record) {\n\t\t\t\t\ttext = nm_user_record_get_status_text(user_record);\n\t\t\t\t\tif (text)\n\t\t\t\t\t\treturn g_strdup(text);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1143}
{"project": "Pidgin", "target": 0, "func": "static void\npeer_odc_recv_cb(gpointer data, gint source, PurpleInputCondition cond)\n{\n\tPeerConnection *conn;\n\tOdcFrame *frame;\n\tByteStream *bs;\n\tgssize read;\n\tconn = data;\n\tframe = conn->frame;\n\tbs = &frame->payload;\n\t\n\tread = recv(conn->fd,\n\t\t\t\t&bs->data[bs->offset],\n\t\t\t\tbs->len - bs->offset,\n\t\t\t\t0);\n\t\n\tif (read == 0)\n\t{\n\t\tpeer_connection_destroy(conn, OSCAR_DISCONNECT_REMOTE_CLOSED, NULL);\n\t\treturn;\n\t}\n\tif (read < 0)\n\t{\n\t\tif ((errno == EAGAIN) || (errno == EWOULDBLOCK))\n\t\t\t\n\t\t\treturn;\n\t\tpeer_connection_destroy(conn,\n\t\t\t\tOSCAR_DISCONNECT_LOST_CONNECTION, g_strerror(errno));\n\t\treturn;\n\t}\n\tbs->offset += read;\n\tif (bs->offset < bs->len)\n\t\t\n\t\treturn;\n\t\n\tbs->data[bs->len] = '\\0';\n\t\n\tbyte_stream_rewind(bs);\n\tpeer_odc_handle_payload(conn, (const char *)bs->data,\n\t\t\tbs->len, frame->encoding, frame->flags & 0x0001);\n\tg_free(bs->data);\n\tbs->data = NULL;\n\tg_free(frame);\n\tconn->frame = NULL;\n\tpurple_input_remove(conn->watcher_incoming);\n\tconn->watcher_incoming = purple_input_add(conn->fd,\n\t\t\tPURPLE_INPUT_READ, peer_connection_recv_cb, conn);\n}\n", "bug_type": null, "idx": 1144}
{"project": "Pidgin", "target": 0, "func": "void\npurple_buddy_icons_uninit()\n{\n\tpurple_signals_disconnect_by_handle(purple_buddy_icons_get_handle());\n\tg_hash_table_destroy(account_cache);\n\tg_hash_table_destroy(icon_data_cache);\n\tg_hash_table_destroy(icon_file_cache);\n\tg_hash_table_destroy(pointer_icon_cache);\n\tg_free(old_icons_dir);\n\tg_free(cache_dir);\n\tcache_dir = NULL;\n\told_icons_dir = NULL;\n}\n", "bug_type": null, "idx": 1145}
{"project": "Pidgin", "target": 0, "func": "void gnt_widget_set_take_focus(GntWidget *widget, gboolean can)\n{\n\tif (can)\n\t\tGNT_WIDGET_SET_FLAGS(widget, GNT_WIDGET_CAN_TAKE_FOCUS);\n\telse\n\t\tGNT_WIDGET_UNSET_FLAGS(widget, GNT_WIDGET_CAN_TAKE_FOCUS);\n}\n", "bug_type": null, "idx": 1146}
{"project": "Pidgin", "target": 0, "func": "static void\nsigned_on_off_cb(PurpleConnection *gc, gpointer user_data)\n{\n\tPurpleAccount *account;\n\tGtkTreeModel *model;\n\tGtkTreeIter iter;\n\tGdkPixbuf *pixbuf;\n\tsize_t index;\n\t\n\tif (accounts_window == NULL)\n\t\treturn;\n\taccount = purple_connection_get_account(gc);\n\tmodel = GTK_TREE_MODEL(accounts_window->model);\n\tindex = g_list_index(purple_accounts_get_all(), account);\n\tif (gtk_tree_model_iter_nth_child(model, &iter, NULL, index))\n\t{\n\t\tpixbuf = pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_MEDIUM);\n\t\tif ((pixbuf != NULL) && purple_account_is_disconnected(account))\n\t\t\tgdk_pixbuf_saturate_and_pixelate(pixbuf, pixbuf, 0.0, FALSE);\n\t\tgtk_list_store_set(accounts_window->model, &iter,\n\t\t\t\t   COLUMN_ICON, pixbuf,\n\t\t\t\t   -1);\n\t\tif (pixbuf != NULL)\n\t\t\tg_object_unref(G_OBJECT(pixbuf));\n\t}\n}\n", "bug_type": null, "idx": 1147}
{"project": "Pidgin", "target": 0, "func": "static void\nset_dialog_icon(AccountPrefsDialog *dialog, gpointer data, size_t len, gchar *new_icon_path)\n{\n\tGdkPixbuf *pixbuf = NULL;\n\tdialog->icon_img = purple_imgstore_unref(dialog->icon_img);\n\tif (data != NULL)\n\t{\n\t\tif (len > 0)\n\t\t\tdialog->icon_img = purple_imgstore_add(data, len, new_icon_path);\n\t\telse\n\t\t\tg_free(data);\n\t}\n\tif (dialog->icon_img != NULL) {\n\t\tpixbuf = pidgin_pixbuf_from_imgstore(dialog->icon_img);\n\t}\n\tif (pixbuf && dialog->prpl_info &&\n\t    (dialog->prpl_info->icon_spec.scale_rules & PURPLE_ICON_SCALE_DISPLAY))\n\t{\n\t\t\n\t\tint width, height;\n\t\tGdkPixbuf *scale;\n\t\tpidgin_buddy_icon_get_scale_size(pixbuf, &dialog->prpl_info->icon_spec,\n\t\t\t\tPURPLE_ICON_SCALE_DISPLAY, &width, &height);\n\t\tscale = gdk_pixbuf_scale_simple(pixbuf, width, height, GDK_INTERP_BILINEAR);\n\t\tg_object_unref(G_OBJECT(pixbuf));\n\t\tpixbuf = scale;\n\t}\n\tif (pixbuf == NULL)\n\t{\n\t\t\n\t\tGtkIconSize icon_size = gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_SMALL);\n\t\tpixbuf = gtk_widget_render_icon(dialog->window, PIDGIN_STOCK_TOOLBAR_SELECT_AVATAR,\n\t\t                                icon_size, \"PidginAccount\");\n\t}\n\tgtk_image_set_from_pixbuf(GTK_IMAGE(dialog->icon_entry), pixbuf);\n\tif (pixbuf != NULL)\n\t\tg_object_unref(G_OBJECT(pixbuf));\n}\n", "bug_type": null, "idx": 1148}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_privacy_permit_add(PurpleAccount *account, const char *who,\n\t\t\t\t\t\tgboolean local_only)\n{\n\tGSList *l;\n\tchar *name;\n\tPurpleBuddy *buddy;\n\tPurpleBlistUiOps *blist_ops;\n\tg_return_val_if_fail(account != NULL, FALSE);\n\tg_return_val_if_fail(who     != NULL, FALSE);\n\tname = g_strdup(purple_normalize(account, who));\n\tfor (l = account->permit; l != NULL; l = l->next) {\n\t\tif (g_str_equal(name, l->data))\n\t\t\t\n\t\t\tbreak;\n\t}\n\tif (l != NULL)\n\t{\n\t\t\n\t\tg_free(name);\n\t\treturn FALSE;\n\t}\n\taccount->permit = g_slist_append(account->permit, name);\n\tif (!local_only && purple_account_is_connected(account))\n\t\tserv_add_permit(purple_account_get_connection(account), who);\n\tif (privacy_ops != NULL && privacy_ops->permit_added != NULL)\n\t\tprivacy_ops->permit_added(account, who);\n\tblist_ops = purple_blist_get_ui_ops();\n\tif (blist_ops != NULL && blist_ops->save_account != NULL)\n\t\tblist_ops->save_account(account);\n\t\n\tbuddy = purple_find_buddy(account, name);\n\tif (buddy != NULL) {\n\t\tpurple_signal_emit(purple_blist_get_handle(),\n                \"buddy-privacy-changed\", buddy);\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1149}
{"project": "Pidgin", "target": 0, "func": "static void _pidgin_themes_smiley_themeize(GtkWidget *imhtml, gboolean custom)\n{\n\tstruct smiley_list *list;\n\tif (!current_smiley_theme)\n\t\treturn;\n\tgtk_imhtml_remove_smileys(GTK_IMHTML(imhtml));\n\tlist = current_smiley_theme->list;\n\twhile (list) {\n\t\tchar *sml = !strcmp(list->sml, \"default\") ? NULL : list->sml;\n\t\tGSList *icons = list->smileys;\n\t\twhile (icons) {\n\t\t\tgtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), sml, icons->data);\n\t\t\ticons = icons->next;\n\t\t}\n\t\tif (custom == TRUE) {\n\t\t\ticons = pidgin_smileys_get_all();\n\t\t\twhile (icons) {\n\t\t\t\tgtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), sml, icons->data);\n\t\t\t\ticons = icons->next;\n\t\t\t}\n\t\t}\n\t\tlist = list->next;\n\t}\n}\n", "bug_type": null, "idx": 1150}
{"project": "Pidgin", "target": 0, "func": "void purple_roomlist_expand_category(PurpleRoomlist *list, PurpleRoomlistRoom *category)\n{\n\tPurplePlugin *prpl = NULL;\n\tPurplePluginProtocolInfo *prpl_info = NULL;\n\tPurpleConnection *gc;\n\tg_return_if_fail(list != NULL);\n\tg_return_if_fail(category != NULL);\n\tg_return_if_fail(category->type & PURPLE_ROOMLIST_ROOMTYPE_CATEGORY);\n\tgc = purple_account_get_connection(list->account);\n\tg_return_if_fail(gc != NULL);\n\tif(gc)\n\t\tprpl = purple_connection_get_prpl(gc);\n\tif(prpl)\n\t\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n\tif(prpl_info && prpl_info->roomlist_expand_category)\n\t\tprpl_info->roomlist_expand_category(list, category);\n}\n", "bug_type": null, "idx": 1151}
{"project": "Pidgin", "target": 0, "func": "static void\nstatus_editor_set_account(GtkListStore *store, PurpleAccount *account,\n\t\t\t\t\t\t  GtkTreeIter *iter, PurpleSavedStatusSub *substatus)\n{\n\tGdkPixbuf *pixbuf;\n\tconst char *id = NULL, *name = NULL, *message = NULL;\n\tPurpleStatusPrimitive prim = PURPLE_STATUS_UNSET;\n\tpixbuf = pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_MEDIUM);\n\tif ((pixbuf != NULL) && !purple_account_is_connected(account))\n\t{\n\t\tgdk_pixbuf_saturate_and_pixelate(pixbuf, pixbuf, 0.0, FALSE);\n\t}\n\tif (substatus != NULL)\n\t{\n\t\tconst PurpleStatusType *type;\n\t\ttype = purple_savedstatus_substatus_get_type(substatus);\n\t\tid = purple_status_type_get_id(type);\n\t\tname = purple_status_type_get_name(type);\n\t\tprim = purple_status_type_get_primitive(type);\n\t\tif (purple_status_type_get_attr(type, \"message\"))\n\t\t\tmessage = purple_savedstatus_substatus_get_message(substatus);\n\t}\n\tgtk_list_store_set(store, iter,\n\t\t\tSTATUS_EDITOR_COLUMN_ACCOUNT, account,\n\t\t\tSTATUS_EDITOR_COLUMN_ENABLE_SUBSTATUS, (substatus != NULL),\n\t\t\tSTATUS_EDITOR_COLUMN_ICON, pixbuf,\n\t\t\tSTATUS_EDITOR_COLUMN_USERNAME, purple_account_get_username(account),\n\t\t\tSTATUS_EDITOR_COLUMN_STATUS_ID, id,\n\t\t\tSTATUS_EDITOR_COLUMN_STATUS_NAME, name,\n\t\t\tSTATUS_EDITOR_COLUMN_STATUS_MESSAGE, message,\n\t\t\tSTATUS_EDITOR_COLUMN_STATUS_ICON, get_stock_icon_from_primitive(prim),\n\t\t\t-1);\n\tif (pixbuf != NULL)\n\t\tg_object_unref(G_OBJECT(pixbuf));\n}\n", "bug_type": null, "idx": 1152}
{"project": "Pidgin", "target": 0, "func": "static void\ndocklet_plugin_actions(GtkWidget *menu)\n{\n\tGtkWidget *menuitem, *submenu;\n\tPurplePlugin *plugin = NULL;\n\tGList *l;\n\tint c = 0;\n\tg_return_if_fail(menu != NULL);\n\t\n\tfor (l = purple_plugins_get_loaded(); l; l = l->next) {\n\t\tplugin = (PurplePlugin *) l->data;\n\t\tif (PURPLE_IS_PROTOCOL_PLUGIN(plugin))\n\t\t\tcontinue;\n\t\tif (!PURPLE_PLUGIN_HAS_ACTIONS(plugin))\n\t\t\tcontinue;\n\t\tmenuitem = gtk_image_menu_item_new_with_label(_(plugin->info->name));\n\t\tgtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);\n\t\tsubmenu = gtk_menu_new();\n\t\tgtk_menu_item_set_submenu(GTK_MENU_ITEM(menuitem), submenu);\n\t\tbuild_plugin_actions(submenu, plugin, NULL);\n\t\tc++;\n\t}\n\tif(c>0)\n\t\tpidgin_separator(menu);\n}\n", "bug_type": null, "idx": 1153}
{"project": "Pidgin", "target": 0, "func": "static void\npounce_cb(PurplePounce *pounce, PurplePounceEvent events, void *data)\n{\n\tPurpleConversation *conv;\n\tPurpleAccount *account;\n\tPurpleBuddy *buddy;\n\tconst char *pouncee;\n\tconst char *alias;\n\tpouncee = purple_pounce_get_pouncee(pounce);\n\taccount = purple_pounce_get_pouncer(pounce);\n\tbuddy = purple_find_buddy(account, pouncee);\n\tif (buddy != NULL)\n\t{\n\t\talias = purple_buddy_get_alias(buddy);\n\t\tif (alias == NULL)\n\t\t\talias = pouncee;\n\t}\n\telse\n\t\talias = pouncee;\n\tif (purple_pounce_action_is_enabled(pounce, \"open-window\"))\n\t{\n\t\tif (!purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, pouncee, account))\n\t\t\tpurple_conversation_new(PURPLE_CONV_TYPE_IM, account, pouncee);\n\t}\n\tif (purple_pounce_action_is_enabled(pounce, \"popup-notify\"))\n\t{\n\t\tchar *tmp = NULL;\n\t\tconst char *name_shown;\n\t\tconst char *reason;\n\t\tstruct {\n\t\t\tPurplePounceEvent event;\n\t\t\tconst char *format;\n\t\t} messages[] = {\n\t\t\t{PURPLE_POUNCE_TYPING, _(\"%s has started typing to you (%s)\")},\n\t\t\t{PURPLE_POUNCE_TYPED, _(\"%s has paused while typing to you (%s)\")},\n\t\t\t{PURPLE_POUNCE_SIGNON, _(\"%s has signed on (%s)\")},\n\t\t\t{PURPLE_POUNCE_IDLE_RETURN, _(\"%s has returned from being idle (%s)\")},\n\t\t\t{PURPLE_POUNCE_AWAY_RETURN, _(\"%s has returned from being away (%s)\")},\n\t\t\t{PURPLE_POUNCE_TYPING_STOPPED, _(\"%s has stopped typing to you (%s)\")},\n\t\t\t{PURPLE_POUNCE_SIGNOFF, _(\"%s has signed off (%s)\")},\n\t\t\t{PURPLE_POUNCE_IDLE, _(\"%s has become idle (%s)\")},\n\t\t\t{PURPLE_POUNCE_AWAY, _(\"%s has gone away. (%s)\")},\n\t\t\t{PURPLE_POUNCE_MESSAGE_RECEIVED, _(\"%s has sent you a message. (%s)\")},\n\t\t\t{0, NULL}\n\t\t};\n\t\tint i;\n\t\treason = purple_pounce_action_get_attribute(pounce, \"popup-notify\",\n\t\t\t\t\"reason\");\n\t\t\n\t\tfor (i = 0; messages[i].format != NULL; i++) {\n\t\t\tif (messages[i].event & events) {\n\t\t\t\ttmp = g_strdup_printf(messages[i].format, alias,\n\t\t\t\t\t\tpurple_account_get_protocol_name(account));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (tmp == NULL)\n\t\t\ttmp = g_strdup(_(\"Unknown pounce event. Please report this!\"));\n\t\t\n\t\tif ((name_shown = purple_account_get_alias(account)) == NULL)\n\t\t\tname_shown = purple_account_get_username(account);\n\t\tif (reason == NULL)\n\t\t{\n\t\t\tpurple_notify_info(NULL, name_shown, tmp, purple_date_format_full(NULL));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar *tmp2 = g_strdup_printf(\"%s\\n\\n%s\", reason, purple_date_format_full(NULL));\n\t\t\tpurple_notify_info(NULL, name_shown, tmp, tmp2);\n\t\t\tg_free(tmp2);\n\t\t}\n\t\tg_free(tmp);\n\t}\n\tif (purple_pounce_action_is_enabled(pounce, \"send-message\"))\n\t{\n\t\tconst char *message;\n\t\tmessage = purple_pounce_action_get_attribute(pounce, \"send-message\",\n\t\t\t\t\t\t\t\t\t\t\t\t   \"message\");\n\t\tif (message != NULL)\n\t\t{\n\t\t\tconv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, pouncee, account);\n\t\t\tif (conv == NULL)\n\t\t\t\tconv = purple_conversation_new(PURPLE_CONV_TYPE_IM, account, pouncee);\n\t\t\tpurple_conversation_write(conv, NULL, message,\n\t\t\t\t\t\t\t\t\tPURPLE_MESSAGE_SEND, time(NULL));\n\t\t\tserv_send_im(purple_account_get_connection(account), (char *)pouncee, (char *)message, 0);\n\t\t}\n\t}\n\tif (purple_pounce_action_is_enabled(pounce, \"execute-command\"))\n\t{\n\t\tconst char *command;\n\t\tcommand = purple_pounce_action_get_attribute(pounce,\n\t\t\t\t\"execute-command\", \"command\");\n\t\tif (command != NULL)\n\t\t{\n\t\t\tchar *localecmd = g_locale_from_utf8(command, -1, NULL,\n\t\t\t\t\tNULL, NULL);\n\t\t\tif (localecmd != NULL)\n\t\t\t{\n\t\t\t\tint pid = fork();\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\tchar *args[4];\n\t\t\t\t\targs[0] = \"sh\";\n\t\t\t\t\targs[1] = \"-c\";\n\t\t\t\t\targs[2] = (char *)localecmd;\n\t\t\t\t\targs[3] = NULL;\n\t\t\t\t\texecvp(args[0], args);\n\t\t\t\t\t_exit(0);\n\t\t\t\t}\n\t\t\t\tg_free(localecmd);\n\t\t\t}\n\t\t}\n\t}\n\tif (purple_pounce_action_is_enabled(pounce, \"play-beep\"))\n\t{\n\t\tbeep();\n\t}\n}\n", "bug_type": null, "idx": 1154}
{"project": "Pidgin", "target": 0, "func": "PurpleConnectionFlags\npurple_conversation_get_features(PurpleConversation *conv)\n{\n\tg_return_val_if_fail(conv != NULL, 0);\n\treturn conv->features;\n}\n", "bug_type": null, "idx": 1155}
{"project": "Pidgin", "target": 0, "func": "char *\npurple_srv_txt_query_get_query(PurpleSrvTxtQueryData *query_data)\n{\n\tg_return_val_if_fail(query_data != NULL, NULL);\n\treturn query_data->query;\n}\n", "bug_type": null, "idx": 1156}
{"project": "Pidgin", "target": 0, "func": "static void\nregex_change_color(GtkWidget *w, guint16 r, guint16 g, guint16 b) {\n\tGdkColor color;\n\tcolor.red = r;\n\tcolor.green = g;\n\tcolor.blue = b;\n\tgtk_widget_modify_base(w, GTK_STATE_NORMAL, &color);\n}\n", "bug_type": null, "idx": 1157}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_media_element_info_finalize(GObject *info)\n{\n\tPurpleMediaElementInfoPrivate *priv =\n\t\t\tPURPLE_MEDIA_ELEMENT_INFO_GET_PRIVATE(info);\n\tg_free(priv->id);\n\tg_free(priv->name);\n}\n", "bug_type": null, "idx": 1158}
{"project": "Pidgin", "target": 0, "func": "static void\non_volume_change_cb(GtkRange *range, GstBin *pipeline)\n{\n\tGstElement *volume;\n\tg_return_if_fail(pipeline != NULL);\n\tvolume = gst_bin_get_by_name(pipeline, \"volume\");\n\tg_object_set(volume, \"volume\", gtk_range_get_value(range) / 10.0, NULL);\n}\n", "bug_type": null, "idx": 1159}
{"project": "Pidgin", "target": 0, "func": "static GList *\nget_available_browsers(void)\n{\n\tstruct browser {\n\t\tchar *name;\n\t\tchar *command;\n\t};\n\t\n\tstatic const struct browser possible_browsers[] = {\n\t\t{N_(\"Seamonkey\"), \"seamonkey\"},\n\t\t{N_(\"Opera\"), \"opera\"},\n\t\t{N_(\"Netscape\"), \"netscape\"},\n\t\t{N_(\"Mozilla\"), \"mozilla\"},\n\t\t{N_(\"Konqueror\"), \"kfmclient\"},\n\t\t{N_(\"Google Chrome\"), \"google-chrome\"},\n\t\t\n\t\t{N_(\"Desktop Default\"), \"xdg-open\"},\n\t\t{N_(\"GNOME Default\"), \"gnome-open\"},\n\t\t{N_(\"Galeon\"), \"galeon\"},\n\t\t{N_(\"Firefox\"), \"firefox\"},\n\t\t{N_(\"Firebird\"), \"mozilla-firebird\"},\n\t\t{N_(\"Epiphany\"), \"epiphany\"},\n\t\t\n\t\t{N_(\"Chromium (chromium-browser)\"), \"chromium-browser\"},\n\t\t\n\t\t{N_(\"Chromium (chrome)\"), \"chrome\"}\n\t};\n\tstatic const int num_possible_browsers = G_N_ELEMENTS(possible_browsers);\n\tGList *browsers = NULL;\n\tint i = 0;\n\tchar *browser_setting = (char *)purple_prefs_get_string(PIDGIN_PREFS_ROOT \"/browsers/browser\");\n\tbrowsers = g_list_prepend(browsers, (gpointer)\"custom\");\n\tbrowsers = g_list_prepend(browsers, (gpointer)_(\"Manual\"));\n\tfor (i = 0; i < num_possible_browsers; i++) {\n\t\tif (purple_program_is_valid(possible_browsers[i].command)) {\n\t\t\tbrowsers = g_list_prepend(browsers,\n\t\t\t\t\t\t\t\t\t  possible_browsers[i].command);\n\t\t\tbrowsers = g_list_prepend(browsers, (gpointer)_(possible_browsers[i].name));\n\t\t\tif(browser_setting && !strcmp(possible_browsers[i].command, browser_setting))\n\t\t\t\tbrowser_setting = NULL;\n\t\t\t\n\t\t\tif(!strcmp(possible_browsers[i].command, \"xdg-open\")) {\n\t\t\t\tif (browser_setting && !strcmp(\"gnome-open\", browser_setting)) {\n\t\t\t\t\tpurple_prefs_set_string(PIDGIN_PREFS_ROOT \"/browsers/browser\", possible_browsers[i].command);\n\t\t\t\t\tbrowser_setting = NULL;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif(browser_setting)\n\t\tpurple_prefs_set_string(PIDGIN_PREFS_ROOT \"/browsers/browser\", \"custom\");\n\treturn browsers;\n}\n", "bug_type": null, "idx": 1160}
{"project": "Pidgin", "target": 0, "func": "static gboolean\naction_move_parent(GntBindable *bind, GList *null)\n{\n\tGntTree *tree = GNT_TREE(bind);\n\tGntTreeRow *row = tree->current;\n\tint dist;\n\tif (!row || !row->parent || SEARCHING(tree))\n\t\treturn FALSE;\n\ttree->current = row->parent;\n\tif ((dist = get_distance(tree->current, tree->top)) > 0)\n\t\tgnt_tree_scroll(tree, -dist);\n\telse\n\t\tredraw_tree(tree);\n\ttree_selection_changed(tree, row, tree->current);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1161}
{"project": "Pidgin", "target": 0, "func": "static void irc_close(PurpleConnection *gc)\n{\n\tstruct irc_conn *irc = gc->proto_data;\n\tif (irc == NULL)\n\t\treturn;\n\tif (irc->gsc || (irc->fd >= 0))\n\t\tirc_cmd_quit(irc, \"quit\", NULL, NULL);\n\tif (gc->inpa)\n\t\tpurple_input_remove(gc->inpa);\n\tg_free(irc->inbuf);\n\tif (irc->gsc) {\n\t\tpurple_ssl_close(irc->gsc);\n\t} else if (irc->fd >= 0) {\n\t\tclose(irc->fd);\n\t}\n\tif (irc->timer)\n\t\tpurple_timeout_remove(irc->timer);\n\tg_hash_table_destroy(irc->cmds);\n\tg_hash_table_destroy(irc->msgs);\n\tg_hash_table_destroy(irc->buddies);\n\tif (irc->motd)\n\t\tg_string_free(irc->motd, TRUE);\n\tg_free(irc->server);\n\tif (irc->writeh)\n\t\tpurple_input_remove(irc->writeh);\n\tpurple_circ_buffer_destroy(irc->outbuf);\n\tg_free(irc->mode_chars);\n\tg_free(irc->reqnick);\n#ifdef HAVE_CYRUS_SASL\n\tif (irc->sasl_conn) {\n\t\tsasl_dispose(&irc->sasl_conn);\n\t\tirc->sasl_conn = NULL;\n\t}\n\tg_free(irc->sasl_cb);\n\tif(irc->sasl_mechs)\n\t\tg_string_free(irc->sasl_mechs, TRUE);\n#endif\n\tg_free(irc);\n}\n", "bug_type": null, "idx": 1162}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nset_public_alias_unsupported(gpointer data)\n{\n\tstruct public_alias_closure *closure = data;\n\tPurpleSetPublicAliasFailureCallback failure_cb = closure->failure_cb;\n\tfailure_cb(closure->account,\n\t           _(\"This protocol does not support setting a public alias.\"));\n\tg_free(closure);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 1163}
{"project": "Pidgin", "target": 0, "func": "void purple_log_set_free(PurpleLogSet *set)\n{\n\tg_return_if_fail(set != NULL);\n\tg_free(set->name);\n\tif (set->normalized_name != set->name)\n\t\tg_free(set->normalized_name);\n\tg_slice_free(PurpleLogSet, set);\n}\n", "bug_type": null, "idx": 1164}
{"project": "Pidgin", "target": 0, "func": "void finch_connections_uninit()\n{\n\tpurple_signals_disconnect_by_handle(finch_connection_get_handle());\n\tg_hash_table_destroy(hash);\n}\n", "bug_type": null, "idx": 1165}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nplugin_load(PurplePlugin *plugin)\n{\n\tPurplePlugin *server_plugin;\n\tgboolean ok;\n\tint result;\n\tserver_plugin = purple_plugins_find_with_id(\"core-ipc-test-server\");\n\tif (server_plugin == NULL)\n\t{\n\t\tpurple_debug_error(\"ipc-test-client\",\n\t\t\t\t\t\t \"Unable to locate plugin core-ipc-test-server, \"\n\t\t\t\t\t\t \"needed for IPC.\\n\");\n\t\treturn TRUE;\n\t}\n\tresult = (int)purple_plugin_ipc_call(server_plugin, \"add\", &ok, 36, 6);\n\tif (!ok)\n\t{\n\t\tpurple_debug_error(\"ipc-test-client\",\n\t\t\t\t\t\t \"Unable to call IPC function 'add' in \"\n\t\t\t\t\t\t \"core-ipc-test-server plugin.\");\n\t\treturn TRUE;\n\t}\n\tpurple_debug_info(\"ipc-test-client\", \"36 + 6 = %d\\n\", result);\n\tresult = (int)purple_plugin_ipc_call(server_plugin, \"sub\", &ok, 50, 8);\n\tif (!ok)\n\t{\n\t\tpurple_debug_error(\"ipc-test-client\",\n\t\t\t\t\t\t \"Unable to call IPC function 'sub' in \"\n\t\t\t\t\t\t \"core-ipc-test-server plugin.\");\n\t\treturn TRUE;\n\t}\n\tpurple_debug_info(\"ipc-test-client\", \"50 - 8 = %d\\n\", result);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1166}
{"project": "Pidgin", "target": 0, "func": " */\nvoid gg_dcc_free(struct gg_dcc *d)\n{\n\tgg_debug(GG_DEBUG_FUNCTION, \"** gg_dcc_free(%p);\\n\", d);\n\tif (!d)\n\t\treturn;\n\tif (d->fd != -1)\n\t\tclose(d->fd);\n\tif (d->file_fd != -1)\n\t\tgg_file_close(d->file_fd);\n\tfree(d->chunk_buf);\n\tfree(d);\n}\n", "bug_type": null, "idx": 1167}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nwinpidgin_conv_im_blink(PurpleAccount *account, const char *who, char **message,\n\t\tPurpleConversation *conv, PurpleMessageFlags flags, void *data)\n{\n\tif (purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/win32/blink_im\"))\n\t\twinpidgin_conv_blink(conv, flags);\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 1168}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nscroll_left_cb(PidginScrollBook *scroll_book, GdkEventButton *event)\n{\n\tint index;\n\tif (event->type != GDK_BUTTON_PRESS)\n\t\treturn FALSE;\n\tindex = gtk_notebook_get_current_page(GTK_NOTEBOOK(scroll_book->notebook));\n\tif (index > 0)\n\t\tgtk_notebook_set_current_page(GTK_NOTEBOOK(scroll_book->notebook), index - 1);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1169}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_srv_query_resolved(PurpleSrvTxtQueryData *query_data, GList *records)\n{\n\tGList *l;\n\tPurpleSrvResponse *records_array;\n\tint i = 0, length;\n\tg_return_if_fail(records != NULL);\n\tif (query_data->cb.srv == NULL) {\n\t\tpurple_srv_txt_query_destroy(query_data);\n\t\twhile (records) {\n\t\t\tg_free(records->data);\n\t\t\trecords = g_list_delete_link(records, records);\n\t\t}\n\t\treturn;\n\t}\n\trecords = purple_srv_sort(records);\n\tlength = g_list_length(records);\n\tpurple_debug_info(\"dnssrv\", \"SRV records resolved for %s, count: %d\\n\",\n\t                            query_data->query, length);\n\trecords_array = g_new(PurpleSrvResponse, length);\n\tfor (l = records; l; l = l->next, i++) {\n\t\trecords_array[i] = *(PurpleSrvResponse *)l->data;\n\t}\n\tquery_data->cb.srv(records_array, length, query_data->extradata);\n\tpurple_srv_txt_query_destroy(query_data);\n\twhile (records) {\n\t\tg_free(records->data);\n\t\trecords = g_list_delete_link(records, records);\n\t}\n}\n", "bug_type": null, "idx": 1170}
{"project": "Pidgin", "target": 0, "func": "static void pidgin_cell_renderer_expander_init (PidginCellRendererExpander *cellexpander)\n{\n\tGTK_CELL_RENDERER(cellexpander)->mode = GTK_CELL_RENDERER_MODE_ACTIVATABLE;\n\tGTK_CELL_RENDERER(cellexpander)->xpad = 0;\n\tGTK_CELL_RENDERER(cellexpander)->ypad = 2;\n}\n", "bug_type": null, "idx": 1171}
{"project": "Pidgin", "target": 0, "func": "static void try_srv_connect(JabberStream *js);\nstatic void jabber_stream_init(JabberStream *js)\n{\n\tchar *open_stream;\n\tif (js->stream_id) {\n\t\tg_free(js->stream_id);\n\t\tjs->stream_id = NULL;\n\t}\n\topen_stream = g_strdup_printf(\"<stream:stream to='%s' \"\n\t\t\t\t          \"xmlns='\" NS_XMPP_CLIENT \"' \"\n\t\t\t\t\t\t  \"xmlns:stream='\" NS_XMPP_STREAMS \"' \"\n\t\t\t\t\t\t  \"version='1.0'>\",\n\t\t\t\t\t\t  js->user->domain);\n\t\n\tjabber_parser_setup(js);\n\tjabber_send_raw(js, open_stream, -1);\n\tjs->reinit = FALSE;\n\tg_free(open_stream);\n}\n", "bug_type": null, "idx": 1172}
{"project": "Pidgin", "target": 0, "func": "};\nstatic void damn_you(gpointer data, gint source, PurpleInputCondition c)\n{\n\tstruct pieceofcrap *pos = data;\n\tOscarData *od = purple_connection_get_protocol_data(pos->gc);\n\tchar in = '\\0';\n\tint x = 0;\n\tunsigned char m[17];\n\tGString *msg;\n\twhile (read(pos->fd, &in, 1) == 1) {\n\t\tif (in == '\\n')\n\t\t\tx++;\n\t\telse if (in != '\\r')\n\t\t\tx = 0;\n\t\tif (x == 2)\n\t\t\tbreak;\n\t\tin = '\\0';\n\t}\n\tif (in != '\\n') {\n\t\tchar buf[256];\n\t\tg_snprintf(buf, sizeof(buf), _(\"You may be disconnected shortly.  \"\n\t\t\t\t\"If so, check %s for updates.\"),\n\t\t\t\toscar_get_ui_info_string(\"website\", PURPLE_WEBSITE));\n\t\tpurple_notify_warning(pos->gc, NULL,\n\t\t\t\t\t\t\t_(\"Unable to get a valid AIM login hash.\"),\n\t\t\t\t\t\t\tbuf);\n\t\tpurple_input_remove(pos->inpa);\n\t\tclose(pos->fd);\n\t\tg_free(pos);\n\t\treturn;\n\t}\n\tif (read(pos->fd, m, 16) != 16)\n\t{\n\t\tpurple_debug_warning(\"oscar\", \"Could not read full AIM login hash \"\n\t\t\t\t\"from \" AIMHASHDATA \"--that's bad.\\n\");\n\t}\n\tm[16] = '\\0';\n\tmsg = g_string_new(\"Sending hash: \");\n\tfor (x = 0; x < 16; x++)\n\t\tg_string_append_printf(msg, \"%02hhx \", (unsigned char)m[x]);\n\tg_string_append(msg, \"\\n\");\n\tpurple_debug_misc(\"oscar\", \"%s\", msg->str);\n\tg_string_free(msg, TRUE);\n\tpurple_input_remove(pos->inpa);\n\tclose(pos->fd);\n\taim_sendmemblock(od, pos->conn, 0, 16, m, AIM_SENDMEMBLOCK_FLAG_ISHASH);\n\tg_free(pos);\n}\n", "bug_type": null, "idx": 1173}
{"project": "Pidgin", "target": 0, "func": "const char *\npurple_request_field_group_get_title(const PurpleRequestFieldGroup *group)\n{\n\tg_return_val_if_fail(group != NULL, NULL);\n\treturn group->title;\n}\n", "bug_type": null, "idx": 1174}
{"project": "Pidgin", "target": 0, "func": "NMERR_T\nnm_send_remove_contact(NMUser * user, NMFolder * folder,\n\t\t\t\t\t   NMContact * contact, nm_response_cb callback,\n\t\t\t\t\t   gpointer data)\n{\n\tNMERR_T rc = NM_OK;\n\tNMField *fields = NULL;\n\tNMRequest *req = NULL;\n\tif (user == NULL || folder == NULL || contact == NULL) {\n\t\treturn NMERR_BAD_PARM;\n\t}\n\t\n\tfields = nm_field_add_pointer(fields, NM_A_SZ_PARENT_ID, 0, NMFIELD_METHOD_VALID, 0,\n\t\t\t\t\t\t\t\t  g_strdup_printf(\"%d\", nm_folder_get_id(folder)),\n\t\t\t\t\t\t\t\t  NMFIELD_TYPE_UTF8);\n\t\n\tfields = nm_field_add_pointer(fields, NM_A_SZ_OBJECT_ID, 0, NMFIELD_METHOD_VALID, 0,\n\t\t\t\t\t\t\t\t  g_strdup_printf(\"%d\", nm_contact_get_id(contact)),\n\t\t\t\t\t\t\t\t  NMFIELD_TYPE_UTF8);\n\t\n\trc = nm_send_request(user->conn, \"deletecontact\", fields, callback, data, &req);\n\tif (rc == NM_OK && req)\n\t\tnm_request_set_data(req, contact);\n\tif (req)\n\t\tnm_release_request(req);\n\tnm_free_fields(&fields);\n\treturn rc;\n}\n", "bug_type": null, "idx": 1175}
{"project": "Pidgin", "target": 0, "func": "static void gtk_appbar_do_dock(GtkAppBar *ab, UINT side) {\n\tRECT orig, windowRect;\n        purple_debug(PURPLE_DEBUG_INFO, \"gtkappbar\", \"gtk_appbar_do_dock\\n\");\n        if(!ab || !IsWindow(GDK_WINDOW_HWND(ab->win->window)))\n                return;\n        ab->side = side;\n        get_window_normal_rc(GDK_WINDOW_HWND(ab->win->window), &(ab->docked_rect));\n        CopyRect(&orig, &(ab->docked_rect));\n\tget_rect_of_window(GDK_WINDOW_HWND(ab->win->window), &windowRect);\n\tgtk_appbar_querypos(ab, GDK_WINDOW_HWND(ab->win->window), windowRect);\n        if(EqualRect(&orig, &(ab->docked_rect)) == 0)\n                MoveWindow(GDK_WINDOW_HWND(ab->win->window),\n                           ab->docked_rect.left,\n                           ab->docked_rect.top,\n                           ab->docked_rect.right - ab->docked_rect.left,\n                           ab->docked_rect.bottom - ab->docked_rect.top, TRUE);\n        gtk_appbar_setpos(ab, GDK_WINDOW_HWND(ab->win->window));\n        ab->docked = TRUE;\n}\n", "bug_type": null, "idx": 1176}
{"project": "Pidgin", "target": 0, "func": "static GList *\nx509_ca_get_idlist(void)\n{\n\tGList *l, *idlist;\n\tg_return_val_if_fail(x509_ca_lazy_init(), NULL);\n\tidlist = NULL;\n\tfor (l = x509_ca_certs; l; l = l->next) {\n\t\tx509_ca_element *el = l->data;\n\t\tidlist = g_list_prepend(idlist, g_strdup(el->dn));\n\t}\n\treturn idlist;\n}\n", "bug_type": null, "idx": 1177}
{"project": "Pidgin", "target": 0, "func": "};\nstatic void _init_plugin(PurplePlugin *plugin)\n{\n\tPurpleAccountUserSplit *split;\n\tPurpleAccountOption *option;\n\tsplit = purple_account_user_split_new(_(\"Server\"), \"\", '@');\n\tprpl_info.user_splits = g_list_append(prpl_info.user_splits, split);\n\toption = purple_account_option_bool_new(_(\"Publish status (note: everyone may watch you)\"), \"dopublish\", TRUE);\n\tprpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);\n\toption = purple_account_option_int_new(_(\"Connect port\"), \"port\", 0);\n\tprpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);\n\toption = purple_account_option_bool_new(_(\"Use UDP\"), \"udp\", FALSE);\n\tprpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);\n\toption = purple_account_option_bool_new(_(\"Use proxy\"), \"useproxy\", FALSE);\n\tprpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);\n\toption = purple_account_option_string_new(_(\"Proxy\"), \"proxy\", \"\");\n\tprpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);\n\toption = purple_account_option_string_new(_(\"Auth User\"), \"authuser\", \"\");\n\tprpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);\n\toption = purple_account_option_string_new(_(\"Auth Domain\"), \"authdomain\", \"\");\n\tprpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);\n}\n", "bug_type": null, "idx": 1178}
{"project": "Pidgin", "target": 0, "func": "guint32 byte_stream_get32(ByteStream *bs)\n{\n\tg_return_val_if_fail(byte_stream_bytes_left(bs) >= 4, 0);\n\tbs->offset += 4;\n\treturn aimutil_get32(bs->data + bs->offset - 4);\n}\n", "bug_type": null, "idx": 1179}
{"project": "Pidgin", "target": 0, "func": "static void\nplay_conv_event(PurpleConversation *conv, PurpleSoundEventID event)\n{\n\t\n\tif (conv != NULL && PIDGIN_IS_PIDGIN_CONVERSATION(conv))\n\t{\n\t\tPidginConversation *gtkconv;\n\t\tgboolean has_focus;\n\t\tgtkconv = PIDGIN_CONVERSATION(conv);\n\t\thas_focus = purple_conversation_has_focus(conv);\n\t\tif (!gtkconv->make_sound ||\n\t\t\t(has_focus && !purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/sound/conv_focus\")))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\tpurple_sound_play_event(event, conv ? purple_conversation_get_account(conv) : NULL);\n}\n", "bug_type": null, "idx": 1180}
{"project": "Pidgin", "target": 0, "func": "static void\nclosing_window(GntWidget *window, FinchConv *ggconv)\n{\n\tGList *list = ggconv->list;\n\tggconv->window = NULL;\n\twhile (list) {\n\t\tPurpleConversation *conv = list->data;\n\t\tlist = list->next;\n\t\tpurple_conversation_destroy(conv);\n\t}\n}\n", "bug_type": null, "idx": 1181}
{"project": "Pidgin", "target": 0, "func": "void\npurple_certificate_verify_complete(PurpleCertificateVerificationRequest *vrq,\n\t\t\t\t   PurpleCertificateVerificationStatus st)\n{\n\tPurpleCertificateVerifier *vr;\n\tg_return_if_fail(vrq);\n\tif (st == PURPLE_CERTIFICATE_VALID) {\n\t\tpurple_debug_info(\"certificate\",\n\t\t\t\t  \"Successfully verified certificate for %s\\n\",\n\t\t\t\t  vrq->subject_name);\n\t} else {\n\t\tpurple_debug_error(\"certificate\",\n\t\t\t\t  \"Failed to verify certificate for %s\\n\",\n\t\t\t\t  vrq->subject_name);\n\t}\n\t\n\t(vrq->cb)(st, vrq->cb_data);\n\t\n\t\n\tvr = vrq->verifier;\n\t\n\t(vr->destroy_request)(vrq);\n\t\n\tg_free(vrq->subject_name);\n\tpurple_certificate_destroy_list(vrq->cert_chain);\n\t\n\tg_free(vrq);\n}\n", "bug_type": null, "idx": 1182}
{"project": "Pidgin", "target": 0, "func": "};\nPurpleAccountUiOps *finch_accounts_get_ui_ops()\n{\n\treturn &ui_ops;\n}\n", "bug_type": null, "idx": 1183}
{"project": "Pidgin", "target": 0, "func": "void jabber_bosh_connection_close(PurpleBOSHConnection *conn)\n{\n\tif (conn->state == BOSH_CONN_ONLINE)\n\t\tjabber_bosh_connection_send(conn, PACKET_TERMINATE, NULL);\n}\n", "bug_type": null, "idx": 1184}
{"project": "Pidgin", "target": 0, "func": "void\npurple_conv_chat_unignore(PurpleConvChat *chat, const char *name)\n{\n\tGList *item;\n\tg_return_if_fail(chat != NULL);\n\tg_return_if_fail(name != NULL);\n\t\n\tif (!purple_conv_chat_is_user_ignored(chat, name))\n\t\treturn;\n\titem = g_list_find(purple_conv_chat_get_ignored(chat),\n\t\t\t\t\t   purple_conv_chat_get_ignored_user(chat, name));\n\tpurple_conv_chat_set_ignored(chat,\n\t\tg_list_remove_link(chat->ignored, item));\n\tg_free(item->data);\n\tg_list_free_1(item);\n}\n", "bug_type": null, "idx": 1185}
{"project": "Pidgin", "target": 0, "func": "static void jabber_time_parse(JabberStream *js, const char *from,\n                              JabberIqType type, const char *id,\n                              xmlnode *child)\n{\n\tJabberIq *iq;\n\ttime_t now_t;\n\tstruct tm *tm;\n\ttime(&now_t);\n\tif(type == JABBER_IQ_GET) {\n\t\txmlnode *tzo, *utc;\n\t\tconst char *date, *tz;\n\t\tiq = jabber_iq_new(js, JABBER_IQ_RESULT);\n\t\tjabber_iq_set_id(iq, id);\n\t\tif (from)\n\t\t\txmlnode_set_attrib(iq->node, \"to\", from);\n\t\tchild = xmlnode_new_child(iq->node, child->name);\n\t\txmlnode_set_namespace(child, NS_ENTITY_TIME);\n\t\t\n\t\ttm = localtime(&now_t);\n\t\ttz = purple_get_tzoff_str(tm, TRUE);\n\t\ttzo = xmlnode_new_child(child, \"tzo\");\n\t\txmlnode_insert_data(tzo, tz, -1);\n\t\t\n\t\ttm = gmtime(&now_t);\n\t\tdate = purple_utf8_strftime(\"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\tutc = xmlnode_new_child(child, \"utc\");\n\t\txmlnode_insert_data(utc, date, -1);\n\t\tjabber_iq_send(iq);\n\t} else {\n\t\t\n\t}\n}\n", "bug_type": null, "idx": 1186}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\ncreate_image_field(PurpleRequestField *field)\n{\n\tGtkWidget *widget;\n\tGdkPixbuf *buf, *scale;\n\tbuf = pidgin_pixbuf_from_data(\n\t\t\t(const guchar *)purple_request_field_image_get_buffer(field),\n\t\t\tpurple_request_field_image_get_size(field));\n\tscale = gdk_pixbuf_scale_simple(buf,\n\t\t\tpurple_request_field_image_get_scale_x(field) * gdk_pixbuf_get_width(buf),\n\t\t\tpurple_request_field_image_get_scale_y(field) * gdk_pixbuf_get_height(buf),\n\t\t\tGDK_INTERP_BILINEAR);\n\twidget = gtk_image_new_from_pixbuf(scale);\n\tg_object_unref(G_OBJECT(buf));\n\tg_object_unref(G_OBJECT(scale));\n\treturn widget;\n}\n", "bug_type": null, "idx": 1187}
{"project": "Pidgin", "target": 0, "func": "static GHashTable *pep_handlers = NULL;\nvoid jabber_pep_init(void) {\n\tif(!pep_handlers) {\n\t\tpep_handlers = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);\n\t\t\n\t\tjabber_avatar_init();\n\t\tjabber_mood_init();\n\t\tjabber_tune_init();\n\t\tjabber_nick_init();\n\t}\n}\nstatic GHashTable *pep_handlers = NULL;\nvoid jabber_pep_init(void) {\n\tif(!pep_handlers) {\n\t\tpep_handlers = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);\n\t\t\n\t\tjabber_avatar_init();\n\t\tjabber_mood_init();\n\t\tjabber_tune_init();\n\t\tjabber_nick_init();\n\t}\n}\n", "bug_type": null, "idx": 1188}
{"project": "Pidgin", "target": 0, "func": "gboolean jabber_stream_is_ssl(JabberStream *js)\n{\n\treturn (js->bosh && jabber_bosh_connection_is_ssl(js->bosh)) ||\n\t       (!js->bosh && js->gsc);\n}\n", "bug_type": null, "idx": 1189}
{"project": "Pidgin", "target": 0, "func": "static JingleTransport *\njingle_rawudp_parse_internal(xmlnode *rawudp)\n{\n\tJingleTransport *transport = parent_class->parse(rawudp);\n\tJingleRawUdpPrivate *priv = JINGLE_RAWUDP_GET_PRIVATE(transport);\n\txmlnode *candidate = xmlnode_get_child(rawudp, \"candidate\");\n\tJingleRawUdpCandidate *rawudp_candidate = NULL;\n\tfor (; candidate; candidate = xmlnode_get_next_twin(candidate)) {\n\t\tconst gchar *id = xmlnode_get_attrib(candidate, \"id\");\n\t\tconst gchar *generation = xmlnode_get_attrib(candidate, \"generation\");\n\t\tconst gchar *component = xmlnode_get_attrib(candidate, \"component\");\n\t\tconst gchar *ip = xmlnode_get_attrib(candidate, \"ip\");\n\t\tconst gchar *port = xmlnode_get_attrib(candidate, \"port\");\n\t\tif (!id || !generation || !component || !ip || !port)\n\t\t\tcontinue;\n\t\trawudp_candidate = jingle_rawudp_candidate_new(\n\t\t\t\tid,\n\t\t\t\tatoi(generation),\n\t\t\t\tatoi(component),\n\t\t\t\tip,\n\t\t\t\tatoi(port));\n\t\trawudp_candidate->rem_known = TRUE;\n\t\tjingle_rawudp_add_remote_candidate(JINGLE_RAWUDP(transport), rawudp_candidate);\n\t}\n\tif (rawudp_candidate != NULL &&\n\t\t\tg_list_length(priv->remote_candidates) == 1) {\n\t\t\n\t\trawudp_candidate = g_boxed_copy(JINGLE_TYPE_RAWUDP_CANDIDATE, rawudp_candidate);\n\t\trawudp_candidate->component = 2;\n\t\trawudp_candidate->port = rawudp_candidate->port + 1;\n\t\trawudp_candidate->rem_known = TRUE;\n\t\tjingle_rawudp_add_remote_candidate(JINGLE_RAWUDP(transport), rawudp_candidate);\n\t}\n\treturn transport;\n}\n", "bug_type": null, "idx": 1190}
{"project": "Pidgin", "target": 0, "func": "static void\nparse_chat(PurpleGroup *group, xmlnode *cnode)\n{\n\tPurpleChat *chat;\n\tPurpleAccount *account;\n\tconst char *acct_name, *proto, *protocol;\n\txmlnode *x;\n\tchar *alias = NULL;\n\tGHashTable *components;\n\tacct_name = xmlnode_get_attrib(cnode, \"account\");\n\tprotocol = xmlnode_get_attrib(cnode, \"protocol\");\n\tproto = xmlnode_get_attrib(cnode, \"proto\");\n\tif (!acct_name || (!proto && !protocol))\n\t\treturn;\n\taccount = purple_accounts_find(acct_name, proto ? proto : protocol);\n\tif (!account)\n\t\treturn;\n\tif ((x = xmlnode_get_child(cnode, \"alias\")))\n\t\talias = xmlnode_get_data(x);\n\tcomponents = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\tfor (x = xmlnode_get_child(cnode, \"component\"); x; x = xmlnode_get_next_twin(x)) {\n\t\tconst char *name;\n\t\tchar *value;\n\t\tname = xmlnode_get_attrib(x, \"name\");\n\t\tvalue = xmlnode_get_data(x);\n\t\tg_hash_table_replace(components, g_strdup(name), value);\n\t}\n\tchat = purple_chat_new(account, alias, components);\n\tpurple_blist_add_chat(chat, group,\n\t\t\tpurple_blist_get_last_child((PurpleBlistNode*)group));\n\tfor (x = xmlnode_get_child(cnode, \"setting\"); x; x = xmlnode_get_next_twin(x)) {\n\t\tparse_setting((PurpleBlistNode*)chat, x);\n\t}\n\tg_free(alias);\n}\n", "bug_type": null, "idx": 1191}
{"project": "Pidgin", "target": 0, "func": "void\npurple_marshal_VOID__POINTER_POINTER_UINT(PurpleCallback cb, va_list args,\n\t\t\t\t\t\t\t\t\t\tvoid *data, void **return_val)\n{\n\tvoid *arg1 = va_arg(args, void *);\n\tvoid *arg2 = va_arg(args, void *);\n\tguint arg3 = va_arg(args, guint);\n\t((void (*)(void *, void *, guint, void *))cb)(arg1, arg2, arg3, data);\n}\n", "bug_type": null, "idx": 1192}
{"project": "Pidgin", "target": 0, "func": "size_t gg112_transfer_info_file__pack_to_buffer\n                     (const GG112TransferInfoFile *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &gg112_transfer_info_file__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\n", "bug_type": null, "idx": 1193}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nsend_dns_request_to_child(PurpleDnsQueryData *query_data,\n\t\tPurpleDnsQueryResolverProcess *resolver)\n{\n\tpid_t pid;\n\tdns_params_t dns_params;\n\tssize_t rc;\n\t\n\tpid = waitpid(resolver->dns_pid, NULL, WNOHANG);\n\tif (pid > 0) {\n\t\tpurple_debug_warning(\"dns\", \"DNS child %d no longer exists\\n\",\n\t\t\t\tresolver->dns_pid);\n\t\tpurple_dnsquery_resolver_destroy(resolver);\n\t\treturn FALSE;\n\t} else if (pid < 0) {\n\t\tpurple_debug_warning(\"dns\", \"Wait for DNS child %d failed: %s\\n\",\n\t\t\t\tresolver->dns_pid, g_strerror(errno));\n\t\tpurple_dnsquery_resolver_destroy(resolver);\n\t\treturn FALSE;\n\t}\n\t\n\tstrncpy(dns_params.hostname, query_data->hostname, sizeof(dns_params.hostname) - 1);\n\tdns_params.hostname[sizeof(dns_params.hostname) - 1] = '\\0';\n\tdns_params.port = query_data->port;\n\t\n\trc = write(resolver->fd_in, &dns_params, sizeof(dns_params));\n\tif (rc < 0) {\n\t\tpurple_debug_error(\"dns\", \"Unable to write to DNS child %d: %s\\n\",\n\t\t\t\tresolver->dns_pid, g_strerror(errno));\n\t\tpurple_dnsquery_resolver_destroy(resolver);\n\t\treturn FALSE;\n\t}\n\tif ((gsize)rc < sizeof(dns_params)) {\n\t\tpurple_debug_error(\"dns\", \"Tried to write %\" G_GSSIZE_FORMAT\n\t\t\t\t\" bytes to child but only wrote %\" G_GSSIZE_FORMAT \"\\n\",\n\t\t\t\tsizeof(dns_params), rc);\n\t\tpurple_dnsquery_resolver_destroy(resolver);\n\t\treturn FALSE;\n\t}\n\tpurple_debug_info(\"dns\",\n\t\t\t\"Successfully sent DNS request to child %d\\n\",\n\t\t\tresolver->dns_pid);\n\tquery_data->resolver = resolver;\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1194}
{"project": "Pidgin", "target": 0, "func": "void silcpurple_wb_get_dimensions(const PurpleWhiteboard *wb, int *width, int *height)\n{\n\tSilcPurpleWb wbs = wb->proto_data;\n\t*width = wbs->width;\n\t*height = wbs->height;\n}\n", "bug_type": null, "idx": 1195}
{"project": "Pidgin", "target": 0, "func": "static PurpleTheme *\npidgin_blist_loader_build(const gchar *dir)\n{\n\txmlnode *root_node = NULL, *sub_node, *sub_sub_node;\n\tgchar *filename_full, *data = NULL;\n\tconst gchar *temp, *name;\n\tgboolean success = TRUE;\n\tGdkColor *bgcolor, *expanded_bgcolor, *collapsed_bgcolor, *contact_color;\n\tPidginThemeFont *expanded, *collapsed, *contact, *online, *away, *offline, *idle, *message, *message_nick_said, *status;\n\tPidginBlistLayout layout;\n\tPidginBlistTheme *theme;\n\tint i;\n\tstruct {\n\t\tconst char *tag;\n\t\tPidginThemeFont **font;\n\t} lookups[] = {\n\t\t{\"contact_text\", &contact},\n\t\t{\"online_text\", &online},\n\t\t{\"away_text\", &away},\n\t\t{\"offline_text\", &offline},\n\t\t{\"idle_text\", &idle},\n\t\t{\"message_text\", &message},\n\t\t{\"message_nick_said_text\", &message_nick_said},\n\t\t{\"status_text\", &status},\n\t\t{NULL, NULL}\n\t};\n\tbgcolor = expanded_bgcolor = collapsed_bgcolor = contact_color = NULL;\n\texpanded          = NULL;\n\tcollapsed         = NULL;\n\tcontact           = NULL;\n\tonline            = NULL;\n\taway              = NULL;\n\toffline           = NULL;\n\tidle              = NULL;\n\tmessage           = NULL;\n\tmessage_nick_said = NULL;\n\tstatus            = NULL;\n\t\n\tg_return_val_if_fail(dir != NULL, NULL);\n\tfilename_full = g_build_filename(dir, \"theme.xml\", NULL);\n\tif (g_file_test(filename_full, G_FILE_TEST_IS_REGULAR))\n\t\troot_node = xmlnode_from_file(dir, \"theme.xml\", \"buddy list themes\", \"blist-loader\");\n\tg_free(filename_full);\n\tif (root_node == NULL)\n\t\treturn NULL;\n\tsub_node = xmlnode_get_child(root_node, \"description\");\n\tdata = xmlnode_get_data(sub_node);\n\tname = xmlnode_get_attrib(root_node, \"name\");\n\t\n\tsuccess = name && purple_strequal(xmlnode_get_attrib(root_node, \"type\"), \"pidgin buddy list\");\n\tif (!success)\n\t\tpurple_debug_warning(\"gtkblist-theme-loader\", \"Missing attribute or problem with the root element\\n\");\n\tif (success) {\n\t\tif ((success = (sub_node = xmlnode_get_child(root_node, \"blist\")) != NULL))\n\t\t\tbgcolor = parse_color(sub_node, \"color\");\n\t\telse\n\t\t\tpurple_debug_warning(\"gtkblist-theme-loader\", \"Missing or problem with tags: <blist>.\\n\");\n\t}\n\t\n\tif (success) {\n\t\tif ((success = (sub_node = xmlnode_get_child(root_node, \"groups\")) != NULL\n\t\t\t     && (sub_sub_node = xmlnode_get_child(sub_node, \"expanded\")) != NULL)) {\n\t\t\texpanded = pidgin_theme_font_parse(sub_sub_node);\n\t\t\texpanded_bgcolor = parse_color(sub_sub_node, \"background\");\n\t\t} else\n\t\t\tpurple_debug_warning(\"gtkblist-theme-loader\", \"Missing or problem with tags: <groups> <expanded>.\\n\");\n\t}\n\tif (success) {\n\t\tif ((success = sub_node != NULL && (sub_sub_node = xmlnode_get_child(sub_node, \"collapsed\")) != NULL)) {\n\t\t\tcollapsed = pidgin_theme_font_parse(sub_sub_node);\n\t\t\tcollapsed_bgcolor = parse_color(sub_sub_node, \"background\");\n\t\t} else\n\t\t\tpurple_debug_warning(\"gtkblist-theme-loader\", \"Missing or problem with tags: <groups> <collapsed>.\\n\");\n\t}\n\t\n\tif (success) {\n\t\tif ((success = (sub_node = xmlnode_get_child(root_node, \"buddys\")) != NULL &&\n\t\t\t     (sub_sub_node = xmlnode_get_child(sub_node, \"placement\")) != NULL)) {\n\t\t\tlayout.status_icon = (temp = xmlnode_get_attrib(sub_sub_node, \"status_icon\")) != NULL ? atoi(temp) : 0;\n\t\t\tlayout.text = (temp = xmlnode_get_attrib(sub_sub_node, \"name\")) != NULL ? atoi(temp) : 1;\n\t\t\tlayout.emblem = (temp = xmlnode_get_attrib(sub_sub_node, \"emblem\")) != NULL ? atoi(temp) : 2;\n\t\t\tlayout.protocol_icon = (temp = xmlnode_get_attrib(sub_sub_node, \"protocol_icon\")) != NULL ? atoi(temp) : 3;\n\t\t\tlayout.buddy_icon = (temp = xmlnode_get_attrib(sub_sub_node, \"buddy_icon\")) != NULL ? atoi(temp) : 4;\n\t\t\tlayout.show_status = (temp = xmlnode_get_attrib(sub_sub_node, \"status_icon\")) != NULL ? atoi(temp) != 0 : 1;\n\t\t} else purple_debug_warning(\"gtkblist-theme-loader\", \"Missing or problem with tags: <buddys> <placement>.\\n\");\n\t}\n\tif (success) {\n\t\tif ((success = (sub_node != NULL && (sub_sub_node = xmlnode_get_child(sub_node, \"background\")) != NULL)))\n\t\t\tcontact_color = parse_color(sub_sub_node, \"color\");\n\t\telse\n\t\t\tpurple_debug_warning(\"gtkblist-theme-loader\", \"Missing or problem with tags: <buddys> <background>.\\n\");\n\t}\n\tfor (i = 0; success && lookups[i].tag; i++) {\n\t\tif ((success = (sub_node != NULL &&\n\t\t\t\t\t\t(sub_sub_node = xmlnode_get_child(sub_node, lookups[i].tag)) != NULL))) {\n\t\t\t*(lookups[i].font) = pidgin_theme_font_parse(sub_sub_node);\n\t\t} else {\n\t\t\t*(lookups[i].font) = NULL;\n\t\t}\n\t}\n\t\n\tsuccess = (success && xmlnode_get_attrib(root_node, \"name\") != NULL);\n\t\n\ttheme = g_object_new(PIDGIN_TYPE_BLIST_THEME,\n\t\t\t\"type\", \"blist\",\n\t\t\t\"name\", name,\n\t\t\t\"author\", xmlnode_get_attrib(root_node, \"author\"),\n\t\t\t\"image\", xmlnode_get_attrib(root_node, \"image\"),\n\t\t\t\"directory\", dir,\n\t\t\t\"description\", data,\n\t\t\t\"background-color\", bgcolor,\n\t\t\t\"layout\", &layout,\n\t\t\t\"expanded-color\", expanded_bgcolor,\n\t\t\t\"expanded-text\", expanded,\n\t\t\t\"collapsed-color\", collapsed_bgcolor,\n\t\t\t\"collapsed-text\", collapsed,\n\t\t\t\"contact-color\", contact_color,\n\t\t\t\"contact\", contact,\n\t\t\t\"online\", online,\n\t\t\t\"away\", away,\n\t\t\t\"offline\", offline,\n\t\t\t\"idle\", idle,\n\t\t\t\"message\", message,\n\t\t\t\"message_nick_said\", message_nick_said,\n\t\t\t\"status\", status, NULL);\n\tfor (i = 0; lookups[i].tag; i++) {\n\t\tif (*lookups[i].font) {\n\t\t\tpidgin_theme_font_free(*lookups[i].font);\n\t\t}\n\t}\n\tpidgin_theme_font_free(expanded);\n\tpidgin_theme_font_free(collapsed);\n\txmlnode_free(root_node);\n\tg_free(data);\n\t\n\tif (!success) {\n\t\tg_object_unref(theme);\n\t\ttheme = NULL;\n\t}\n\tif (bgcolor)\n\t\tgdk_color_free(bgcolor);\n\tif (expanded_bgcolor)\n\t\tgdk_color_free(expanded_bgcolor);\n\tif (collapsed_bgcolor)\n\t\tgdk_color_free(collapsed_bgcolor);\n\tif (contact_color)\n\t\tgdk_color_free(contact_color);\n\treturn PURPLE_THEME(theme);\n}\n", "bug_type": null, "idx": 1196}
{"project": "Pidgin", "target": 0, "func": "void purple_status_to_jabber(const PurpleStatus *status, JabberBuddyState *state, char **msg, int *priority)\n{\n\tconst char *status_id = NULL;\n\tconst char *formatted_msg = NULL;\n\tif(state) *state = JABBER_BUDDY_STATE_UNKNOWN;\n\tif(msg) *msg = NULL;\n\tif(priority) *priority = 0;\n\tif(!status) {\n\t\tif(state) *state = JABBER_BUDDY_STATE_UNAVAILABLE;\n\t} else {\n\t\tif(state) {\n\t\t\tstatus_id = purple_status_get_id(status);\n\t\t\t*state = jabber_buddy_status_id_get_state(status_id);\n\t\t}\n\t\tif(msg) {\n\t\t\tformatted_msg = purple_status_get_attr_string(status, \"message\");\n\t\t\t\n\t\t\tif(formatted_msg && *formatted_msg)\n\t\t\t\t*msg = purple_markup_strip_html(formatted_msg);\n\t\t}\n\t\tif(priority)\n\t\t\t*priority = purple_status_get_attr_int(status, \"priority\");\n\t}\n}\n", "bug_type": null, "idx": 1197}
{"project": "Pidgin", "target": 0, "func": "*/\nint main (int argc, char **argv)\n{\n\tGList *alist, *node;\n\tpurple_init();\n\talist = purple_accounts_get_all();\n\tfor (node = alist; node != NULL; node = node->next)\n\t{\n\t\tPurpleAccount *account = (PurpleAccount*) node->data;\n\t\tchar *name = purple_account_get_username(account);\n\t\tg_print(\"Name: %s\\n\", name);\n\t\tg_free(name);\n\t}\n\tg_list_free(alist);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1198}
{"project": "Pidgin", "target": 0, "func": "static void *\nrc4_get_opt(PurpleCipherContext *context, const gchar *name) {\n\tstruct RC4Context *ctx;\n\tctx = purple_cipher_context_get_data(context);\n\tif(purple_strequal(name, \"key_len\")) {\n\t\treturn GINT_TO_POINTER(ctx->key_len);\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1199}
{"project": "Pidgin", "target": 0, "func": "static gboolean\n_is_disconnect_error(NMERR_T err)\n{\n\treturn (err == NMERR_TCP_WRITE ||\n\t\t\terr == NMERR_TCP_READ || err == NMERR_PROTOCOL);\n}\n", "bug_type": null, "idx": 1200}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_pubdir50_add_n(gg_pubdir50_t req, int num, const char *field, const char *value)\n{\n\tstruct gg_pubdir50_entry *tmp = NULL, *entry;\n\tchar *dupfield, *dupvalue;\n\tint i;\n\tgg_debug(GG_DEBUG_FUNCTION, \"** gg_pubdir50_add_n(%p, %d, \\\"%s\\\", \\\"%s\\\");\\n\", req, num, field, value);\n\tif (!(dupvalue = strdup(value))) {\n\t\tgg_debug(GG_DEBUG_MISC, \"// gg_pubdir50_add_n() out of memory\\n\");\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < req->entries_count; i++) {\n\t\tif (req->entries[i].num != num || strcmp(req->entries[i].field, field))\n\t\t\tcontinue;\n\t\tfree(req->entries[i].value);\n\t\treq->entries[i].value = dupvalue;\n\t\treturn 0;\n\t}\n\tif (!(dupfield = strdup(field))) {\n\t\tgg_debug(GG_DEBUG_MISC, \"// gg_pubdir50_add_n() out of memory\\n\");\n\t\tfree(dupvalue);\n\t\treturn -1;\n\t}\n\tif (!(tmp = realloc(req->entries, sizeof(struct gg_pubdir50_entry) * (req->entries_count + 1)))) {\n\t\tgg_debug(GG_DEBUG_MISC, \"// gg_pubdir50_add_n() out of memory\\n\");\n\t\tfree(dupfield);\n\t\tfree(dupvalue);\n\t\treturn -1;\n\t}\n\treq->entries = tmp;\n\tentry = &req->entries[req->entries_count];\n\tentry->num = num;\n\tentry->field = dupfield;\n\tentry->value = dupvalue;\n\treq->entries_count++;\n\treturn 0;\n}\n", "bug_type": null, "idx": 1201}
{"project": "Pidgin", "target": 0, "func": "void gnt_screen_update(GntWidget *widget)\n{\n\tgnt_wm_update_window(wm, widget);\n}\n", "bug_type": null, "idx": 1202}
{"project": "Pidgin", "target": 0, "func": "static void\npeer_oft_dirconvert_tostupid(char *name)\n{\n\twhile (name[0]) {\n\t\tif (name[0] == 0x01)\n\t\t\tname[0] = G_DIR_SEPARATOR;\n\t\tname++;\n\t}\n}\n", "bug_type": null, "idx": 1203}
{"project": "Pidgin", "target": 0, "func": "static int\nmail_window_focus_cb(GtkWidget *widget, GdkEventFocus *focus, gpointer null)\n{\n\tpidgin_set_urgent(GTK_WINDOW(widget), FALSE);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1204}
{"project": "Pidgin", "target": 0, "func": "static void\nstream_info_cb(PurpleMedia *media, PurpleMediaInfoType type,\n\t\tgchar *sid, gchar *name, gboolean local,\n\t\tPurpleMediaBackendFs2 *self)\n{\n\tif (type == PURPLE_MEDIA_INFO_ACCEPT && sid != NULL && name != NULL) {\n\t\tPurpleMediaBackendFs2Stream *stream =\n\t\t\t\tget_stream(self, sid, name);\n\t\tGError *err = NULL;\n\t\tg_object_set(G_OBJECT(stream->stream), \"direction\",\n\t\t\t\tsession_type_to_fs_stream_direction(\n\t\t\t\tstream->session->type), NULL);\n\t\tif (stream->remote_candidates == NULL ||\n\t\t\t\tpurple_media_is_initiator(media, sid, name))\n\t\t\treturn;\n#ifdef HAVE_FARSIGHT\n\t\tfs_stream_set_remote_candidates(stream->stream,\n\t\t\t\tstream->remote_candidates, &err);\n#else\n\t\tif (stream->supports_add)\n\t\t\tfs_stream_add_remote_candidates(stream->stream,\n\t\t\t\t\tstream->remote_candidates, &err);\n\t\telse\n\t\t\tfs_stream_force_remote_candidates(stream->stream,\n\t\t\t\t\tstream->remote_candidates, &err);\n#endif\n\t\tif (err == NULL)\n\t\t\treturn;\n\t\tpurple_debug_error(\"backend-fs2\", \"Error adding \"\n\t\t\t\t\"remote candidates: %s\\n\",\n\t\t\t\terr->message);\n\t\tg_error_free(err);\n\t} else if (local == TRUE && (type == PURPLE_MEDIA_INFO_MUTE ||\n\t\t\ttype == PURPLE_MEDIA_INFO_UNMUTE)) {\n\t\tPurpleMediaBackendFs2Private *priv =\n\t\t\t\tPURPLE_MEDIA_BACKEND_FS2_GET_PRIVATE(self);\n\t\tgboolean active = (type == PURPLE_MEDIA_INFO_MUTE);\n\t\tGList *sessions;\n\t\tif (sid == NULL)\n\t\t\tsessions = g_hash_table_get_values(priv->sessions);\n\t\telse\n\t\t\tsessions = g_list_prepend(NULL,\n\t\t\t\t\tget_session(self, sid));\n\t\tpurple_debug_info(\"media\", \"Turning mute %s\\n\",\n\t\t\t\tactive ? \"on\" : \"off\");\n\t\tfor (; sessions; sessions = g_list_delete_link(\n\t\t\t\tsessions, sessions)) {\n\t\t\tPurpleMediaBackendFs2Session *session =\n\t\t\t\t\tsessions->data;\n\t\t\tif (session->type & PURPLE_MEDIA_SEND_AUDIO) {\n\t\t\t\tgchar *name = g_strdup_printf(\"volume_%s\",\n\t\t\t\t\t\tsession->id);\n\t\t\t\tGstElement *volume = gst_bin_get_by_name(\n\t\t\t\t\t\tGST_BIN(priv->confbin), name);\n\t\t\t\tg_free(name);\n\t\t\t\tg_object_set(volume, \"mute\", active, NULL);\n\t\t\t}\n\t\t}\n\t} else if (local == TRUE && (type == PURPLE_MEDIA_INFO_HOLD ||\n\t\t\ttype == PURPLE_MEDIA_INFO_UNHOLD)) {\n\t\tgboolean active = (type == PURPLE_MEDIA_INFO_HOLD);\n\t\tGList *streams = get_streams(self, sid, name);\n\t\tfor (; streams; streams =\n\t\t\t\tg_list_delete_link(streams, streams)) {\n\t\t\tPurpleMediaBackendFs2Stream *stream = streams->data;\n\t\t\tif (stream->session->type & PURPLE_MEDIA_SEND_AUDIO) {\n\t\t\t\tg_object_set(stream->stream, \"direction\",\n\t\t\t\t\t\tsession_type_to_fs_stream_direction(\n\t\t\t\t\t\tstream->session->type & ((active) ?\n\t\t\t\t\t\t~PURPLE_MEDIA_SEND_AUDIO :\n\t\t\t\t\t\tPURPLE_MEDIA_AUDIO)), NULL);\n\t\t\t}\n\t\t}\n\t} else if (local == TRUE && (type == PURPLE_MEDIA_INFO_PAUSE ||\n\t\t\ttype == PURPLE_MEDIA_INFO_UNPAUSE)) {\n\t\tgboolean active = (type == PURPLE_MEDIA_INFO_PAUSE);\n\t\tGList *streams = get_streams(self, sid, name);\n\t\tfor (; streams; streams =\n\t\t\t\tg_list_delete_link(streams, streams)) {\n\t\t\tPurpleMediaBackendFs2Stream *stream = streams->data;\n\t\t\tif (stream->session->type & PURPLE_MEDIA_SEND_VIDEO) {\n\t\t\t\tg_object_set(stream->stream, \"direction\",\n\t\t\t\t\t\tsession_type_to_fs_stream_direction(\n\t\t\t\t\t\tstream->session->type & ((active) ?\n\t\t\t\t\t\t~PURPLE_MEDIA_SEND_VIDEO :\n\t\t\t\t\t\tPURPLE_MEDIA_VIDEO)), NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1205}
{"project": "Pidgin", "target": 0, "func": "static DNSServiceErrorType (DNSSD_API* _TXTRecordSetValue)(TXTRecordRef *txtRecord, const char *key, uint8_t valueSize, const void *value);\ngboolean dns_sd_available(void) {\n\tstatic gboolean initialized = FALSE;\n\tstatic gboolean loaded = FALSE;\n\tif (!initialized) {\n\t\tinitialized = TRUE;\n\t\tif ((_DNSServiceAddRecord = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceAddRecord\"))\n\t\t\t\t&& (_DNSServiceBrowse = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceBrowse\"))\n\t\t\t\t&& (_DNSServiceConstructFullName = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceConstructFullName\"))\n\t\t\t\t&& (_DNSServiceGetAddrInfo = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceGetAddrInfo\"))\n\t\t\t\t&& (_DNSServiceProcessResult = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceProcessResult\"))\n\t\t\t\t&& (_DNSServiceQueryRecord = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceQueryRecord\"))\n\t\t\t\t&& (_DNSServiceRefDeallocate = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceRefDeallocate\"))\n\t\t\t\t&& (_DNSServiceRefSockFD = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceRefSockFD\"))\n\t\t\t\t&& (_DNSServiceRegister = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceRegister\"))\n\t\t\t\t&& (_DNSServiceResolve = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceResolve\"))\n\t\t\t\t&& (_DNSServiceRemoveRecord = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceRemoveRecord\"))\n\t\t\t\t&& (_DNSServiceUpdateRecord = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"DNSServiceUpdateRecord\"))\n\t\t\t\t&& (_TXTRecordCreate = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"TXTRecordCreate\"))\n\t\t\t\t&& (_TXTRecordDeallocate = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"TXTRecordDeallocate\"))\n\t\t\t\t&& (_TXTRecordGetBytesPtr = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"TXTRecordGetBytesPtr\"))\n\t\t\t\t&& (_TXTRecordGetLength = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"TXTRecordGetLength\"))\n\t\t\t\t&& (_TXTRecordGetValuePtr = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"TXTRecordGetValuePtr\"))\n\t\t\t\t&& (_TXTRecordSetValue = (void *) wpurple_find_and_loadproc(\"dnssd.dll\", \"TXTRecordSetValue\"))) {\n\t\t\tloaded = TRUE;\n\t\t}\n\t}\n\treturn loaded;\n}\n", "bug_type": null, "idx": 1206}
{"project": "Pidgin", "target": 0, "func": "const ProtobufCMethodDescriptor *\nprotobuf_c_service_descriptor_get_method_by_name(const ProtobufCServiceDescriptor *desc,\n\t\t\t\t\t\t const char *name)\n{\n\tunsigned start = 0;\n\tunsigned count = desc->n_methods;\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tunsigned mid_index = desc->method_indices_by_name[mid];\n\t\tconst char *mid_name = desc->methods[mid_index].name;\n\t\tint rv = strcmp(mid_name, name);\n\t\tif (rv == 0)\n\t\t\treturn desc->methods + desc->method_indices_by_name[mid];\n\t\tif (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else {\n\t\t\tcount = mid - start;\n\t\t}\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tif (strcmp(desc->methods[desc->method_indices_by_name[start]].name, name) == 0)\n\t\treturn desc->methods + desc->method_indices_by_name[start];\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1207}
{"project": "Pidgin", "target": 0, "func": "static void\nfinch_media_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)\n{\n\tFinchMedia *media;\n\tg_return_if_fail(FINCH_IS_MEDIA(object));\n\tmedia = FINCH_MEDIA(object);\n\tswitch (prop_id) {\n\t\tcase PROP_MEDIA:\n\t\t{\n\t\t\tif (media->priv->media)\n\t\t\t\tg_object_unref(media->priv->media);\n\t\t\tmedia->priv->media = g_value_get_object(value);\n\t\t\tg_object_ref(media->priv->media);\n\t\t\tg_signal_connect_swapped(G_OBJECT(media->priv->accept), \"activate\",\n\t\t\t\t G_CALLBACK(finch_media_accept_cb), media->priv->media);\n\t\t\tg_signal_connect_swapped(G_OBJECT(media->priv->reject), \"activate\",\n\t\t\t\t G_CALLBACK(finch_media_reject_cb), media->priv->media);\n\t\t\tg_signal_connect_swapped(G_OBJECT(media->priv->hangup), \"activate\",\n\t\t\t\t G_CALLBACK(finch_media_hangup_cb), media->priv->media);\n\t\t\tif (purple_media_is_initiator(media->priv->media,\n\t\t\t\t\tNULL, NULL) == TRUE) {\n\t\t\t\tfinch_media_wait_cb(media->priv->media, media);\n\t\t\t}\n\t\t\tg_signal_connect(G_OBJECT(media->priv->media), \"state-changed\",\n\t\t\t\tG_CALLBACK(finch_media_state_changed_cb), media);\n\t\t\tg_signal_connect(G_OBJECT(media->priv->media), \"stream-info\",\n\t\t\t\tG_CALLBACK(finch_media_stream_info_cb), media);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1208}
{"project": "Pidgin", "target": 0, "func": "xmlnode *jabber_presence_create_js(JabberStream *js, JabberBuddyState state, const char *msg, int priority)\n{\n\txmlnode *show, *status, *presence, *pri, *c;\n\tconst char *show_string = NULL;\n#ifdef USE_VV\n\tgboolean audio_enabled, video_enabled;\n#endif\n\tpresence = xmlnode_new(\"presence\");\n\tif(state == JABBER_BUDDY_STATE_UNAVAILABLE)\n\t\txmlnode_set_attrib(presence, \"type\", \"unavailable\");\n\telse if(state != JABBER_BUDDY_STATE_ONLINE &&\n\t\t\tstate != JABBER_BUDDY_STATE_UNKNOWN &&\n\t\t\tstate != JABBER_BUDDY_STATE_ERROR)\n\t\tshow_string = jabber_buddy_state_get_show(state);\n\tif(show_string) {\n\t\tshow = xmlnode_new_child(presence, \"show\");\n\t\txmlnode_insert_data(show, show_string, -1);\n\t}\n\tif(msg) {\n\t\tstatus = xmlnode_new_child(presence, \"status\");\n\t\txmlnode_insert_data(status, msg, -1);\n\t}\n\tif(priority) {\n\t\tchar *pstr = g_strdup_printf(\"%d\", priority);\n\t\tpri = xmlnode_new_child(presence, \"priority\");\n\t\txmlnode_insert_data(pri, pstr, -1);\n\t\tg_free(pstr);\n\t}\n\t\n\tif (js->idle && state != JABBER_BUDDY_STATE_UNAVAILABLE) {\n\t\txmlnode *query = xmlnode_new_child(presence, \"query\");\n\t\tgchar seconds[10];\n\t\tg_snprintf(seconds, 10, \"%d\", (int) (time(NULL) - js->idle));\n\t\txmlnode_set_namespace(query, NS_LAST_ACTIVITY);\n\t\txmlnode_set_attrib(query, \"seconds\", seconds);\n\t}\n\t\n\t\n\tjabber_caps_calculate_own_hash(js);\n\t\n\tc = xmlnode_new_child(presence, \"c\");\n\txmlnode_set_namespace(c, \"http://jabber.org/protocol/caps\");\n\txmlnode_set_attrib(c, \"node\", CAPS0115_NODE);\n\txmlnode_set_attrib(c, \"hash\", \"sha-1\");\n\txmlnode_set_attrib(c, \"ver\", jabber_caps_get_own_hash(js));\n#ifdef USE_VV\n\t\n\taudio_enabled = jabber_audio_enabled(js, NULL );\n\tvideo_enabled = jabber_video_enabled(js, NULL );\n\tif (audio_enabled && video_enabled)\n\t\txmlnode_set_attrib(c, \"ext\", \"voice-v1 camera-v1 video-v1\");\n\telse if (audio_enabled)\n\t\txmlnode_set_attrib(c, \"ext\", \"voice-v1\");\n\telse if (video_enabled)\n\t\txmlnode_set_attrib(c, \"ext\", \"camera-v1 video-v1\");\n#endif\n\treturn presence;\n}\n", "bug_type": null, "idx": 1209}
{"project": "Pidgin", "target": 0, "func": "static void\ndo_strikethrough(GtkWidget *strikethrough, GtkIMHtmlToolbar *toolbar)\n{\n\tg_return_if_fail(toolbar != NULL);\n\tgtk_imhtml_toggle_strike(GTK_IMHTML(toolbar->imhtml));\n\tgtk_widget_grab_focus(toolbar->imhtml);\n}\n", "bug_type": null, "idx": 1210}
{"project": "Pidgin", "target": 0, "func": "JingleContent *\njingle_content_create(const gchar *type, const gchar *creator,\n\t\tconst gchar *disposition, const gchar *name,\n\t\tconst gchar *senders, JingleTransport *transport)\n{\n\tJingleContent *content = g_object_new(jingle_get_type(type),\n\t\t\t\"creator\", creator,\n\t\t\t\"disposition\", disposition != NULL ? disposition : \"session\",\n\t\t\t\"name\", name,\n\t\t\t\"senders\", senders != NULL ? senders : \"both\",\n\t\t\t\"transport\", transport,\n\t\t\tNULL);\n\treturn content;\n}\n", "bug_type": null, "idx": 1211}
{"project": "Pidgin", "target": 0, "func": "DNSServiceErrorType _wpurple_DNSServiceAddRecord(DNSServiceRef sdRef, DNSRecordRef *RecordRef, DNSServiceFlags flags,\n\t\tuint16_t rrtype, uint16_t rdlen, const void *rdata, uint32_t ttl) {\n\tg_return_val_if_fail(_DNSServiceAddRecord != NULL, kDNSServiceErr_Unknown);\n\treturn (_DNSServiceAddRecord)(sdRef, RecordRef, flags, rrtype, rdlen, rdata, ttl);\n}\n", "bug_type": null, "idx": 1212}
{"project": "Pidgin", "target": 0, "func": "void\npurple_theme_manager_uninit(void)\n{\n\tg_hash_table_destroy(theme_table);\n}\n", "bug_type": null, "idx": 1213}
{"project": "Pidgin", "target": 0, "func": "void\npurple_media_end(PurpleMedia *media,\n\t\tconst gchar *session_id, const gchar *participant)\n{\n#ifdef USE_VV\n\tGList *iter, *sessions = NULL, *participants = NULL;\n\tg_return_if_fail(PURPLE_IS_MEDIA(media));\n\titer = purple_media_get_streams(media, session_id, participant);\n\t\n\tfor (; iter; iter = g_list_delete_link(iter, iter)) {\n\t\tPurpleMediaStream *stream = iter->data;\n\t\tg_signal_emit(media, purple_media_signals[STATE_CHANGED],\n\t\t\t\t0, PURPLE_MEDIA_STATE_END,\n\t\t\t\tstream->session->id, stream->participant);\n\t\tmedia->priv->streams =\n\t\t\t\tg_list_remove(media->priv->streams, stream);\n\t\tif (g_list_find(sessions, stream->session) == NULL)\n\t\t\tsessions = g_list_prepend(sessions, stream->session);\n\t\tif (g_list_find_custom(participants, stream->participant,\n\t\t\t\t(GCompareFunc)strcmp) == NULL)\n\t\t\tparticipants = g_list_prepend(participants,\n\t\t\t\t\tg_strdup(stream->participant));\n\t\tpurple_media_stream_free(stream);\n\t}\n\titer = media->priv->streams;\n\t\n\tfor (; iter; iter = g_list_next(iter)) {\n\t\tPurpleMediaStream *stream = iter->data;\n\t\tsessions = g_list_remove(sessions, stream->session);\n\t}\n\t\n\tfor (; sessions; sessions = g_list_delete_link(sessions, sessions)) {\n\t\tPurpleMediaSession *session = sessions->data;\n\t\tg_signal_emit(media, purple_media_signals[STATE_CHANGED],\n\t\t\t\t0, PURPLE_MEDIA_STATE_END,\n\t\t\t\tsession->id, NULL);\n\t\tg_hash_table_remove(media->priv->sessions, session->id);\n\t\tpurple_media_session_free(session);\n\t}\n\titer = media->priv->streams;\n\t\n\tfor (; iter; iter = g_list_next(iter)) {\n\t\tPurpleMediaStream *stream = iter->data;\n\t\tGList *tmp;\n\t\ttmp = g_list_find_custom(participants,\n\t\t\t\tstream->participant, (GCompareFunc)strcmp);\n\t\tif (tmp != NULL) {\n\t\t\tg_free(tmp->data);\n\t\t\tparticipants = g_list_delete_link(participants,\ttmp);\n\t\t}\n\t}\n\t\n\tfor (; participants; participants =\n\t\t\tg_list_delete_link(participants, participants)) {\n\t\tgchar *participant = participants->data;\n\t\tGList *link = g_list_find_custom(media->priv->participants,\n\t\t\t\tparticipant, (GCompareFunc)strcmp);\n\t\tg_signal_emit(media, purple_media_signals[STATE_CHANGED],\n\t\t\t\t0, PURPLE_MEDIA_STATE_END,\n\t\t\t\tNULL, participant);\n\t\tif (link != NULL) {\n\t\t\tg_free(link->data);\n\t\t\tmedia->priv->participants = g_list_delete_link(\n\t\t\t\t\tmedia->priv->participants, link);\n\t\t}\n\t\tg_free(participant);\n\t}\n\t\n\tif (media->priv->sessions != NULL &&\n\t\t\tg_hash_table_size(media->priv->sessions) == 0) {\n\t\tg_signal_emit(media, purple_media_signals[STATE_CHANGED],\n\t\t\t\t0, PURPLE_MEDIA_STATE_END,\n\t\t\t\tNULL, NULL);\n\t\tg_object_unref(media);\n\t\treturn;\n\t}\n#endif\n}\n", "bug_type": null, "idx": 1214}
{"project": "Pidgin", "target": 0, "func": "static void blist_create_cb(PurpleBuddyList *purple_blist, void *data) {\n\tpurple_debug_info(WINPREFS_PLUGIN_ID, \"buddy list created\\n\");\n\tblist = PIDGIN_BLIST(purple_blist)->window;\n\tif(purple_prefs_get_bool(PREF_DBLIST_DOCKABLE)) {\n\t\tblist_set_dockable(TRUE);\n\t\tif(purple_prefs_get_bool(PREF_DBLIST_DOCKED)) {\n\t\t\tblist_ab->undocked_height = purple_prefs_get_int(PREF_DBLIST_HEIGHT);\n\t\t\tif(!(gdk_window_get_state(blist->window)\n\t\t\t\t\t& GDK_WINDOW_STATE_WITHDRAWN)) {\n\t\t\t\tgtk_appbar_dock(blist_ab,\n\t\t\t\t\tpurple_prefs_get_int(PREF_DBLIST_SIDE));\n\t\t\t\tif(purple_prefs_get_int(PREF_BLIST_ON_TOP)\n\t\t\t\t\t\t== BLIST_TOP_DOCKED)\n\t\t\t\t\tblist_set_ontop(TRUE);\n\t\t\t} else {\n\t\t\t\tg_idle_add(listen_for_blist_visible_cb, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif(purple_prefs_get_int(PREF_BLIST_ON_TOP) == BLIST_TOP_ALWAYS)\n\t\tblist_set_ontop(TRUE);\n}\n", "bug_type": null, "idx": 1215}
{"project": "Pidgin", "target": 0, "func": "void\npurple_dbus_init(void)\n{\n\tif (g_thread_supported())\n\t\tdbus_g_thread_init();\n\tpurple_dbus_init_ids();\n\tg_free(init_error);\n\tinit_error = NULL;\n\tpurple_dbus_dispatch_init();\n\tif (init_error != NULL)\n\t\tpurple_debug_error(\"dbus\", \"%s\\n\", init_error);\n}\n", "bug_type": null, "idx": 1216}
{"project": "Pidgin", "target": 0, "func": "static void\nsetup_buddy_list_suggestion(GntEntry *entry, gboolean offline)\n{\n\tPurpleBlistNode *node = purple_blist_get_root();\n\tfor (; node; node = purple_blist_node_next(node, offline)) {\n\t\tif (!PURPLE_BLIST_NODE_IS_BUDDY(node))\n\t\t\tcontinue;\n\t\tgnt_entry_add_suggest(entry, purple_buddy_get_name((PurpleBuddy*)node));\n\t}\n}\n", "bug_type": null, "idx": 1217}
{"project": "Pidgin", "target": 0, "func": "static gint check_notify_tzc(gpointer data)\n{\n\tPurpleConnection *gc = (PurpleConnection *)data;\n\tzephyr_account* zephyr = gc->proto_data;\n\tparse_tree *newparsetree = read_from_tzc(zephyr);\n\tif (newparsetree != NULL) {\n\t\tgchar *spewtype;\n\t\tif ( (spewtype =  tree_child(find_node(newparsetree,\"tzcspew\"),2)->contents) ) {\n\t\t\tif (!g_ascii_strncasecmp(spewtype,\"message\",7)) {\n\t\t\t\tZNotice_t notice;\n\t\t\t\tparse_tree *msgnode = tree_child(find_node(newparsetree,\"message\"),2);\n\t\t\t\tparse_tree *bodynode = tree_child(msgnode,1);\n\t\t\t\t \n\t\t\t\tchar *msg  = zephyr_tzc_deescape_str(bodynode->contents);\n\t\t\t\tsize_t bufsize = strlen(msg) + 3;\n\t\t\t\tchar *buf = g_new0(char,bufsize);\n\t\t\t\tg_snprintf(buf,1+strlen(msg)+2,\" %c%s\",'\\0',msg);\n\t\t\t\tmemset((char *)&notice, 0, sizeof(notice));\n\t\t\t\tnotice.z_kind = ACKED;\n\t\t\t\tnotice.z_port = 0;\n\t\t\t\tnotice.z_opcode = tree_child(find_node(newparsetree,\"opcode\"),2)->contents;\n\t\t\t\tnotice.z_class = zephyr_tzc_deescape_str(tree_child(find_node(newparsetree,\"class\"),2)->contents);\n\t\t\t\tnotice.z_class_inst = tree_child(find_node(newparsetree,\"instance\"),2)->contents;\n\t\t\t\tnotice.z_recipient = local_zephyr_normalize(zephyr,tree_child(find_node(newparsetree,\"recipient\"),2)->contents);\n\t\t\t\tnotice.z_sender = local_zephyr_normalize(zephyr,tree_child(find_node(newparsetree,\"sender\"),2)->contents);\n\t\t\t\tnotice.z_default_format = \"Class $class, Instance $instance:\\n\" \"To: @bold($recipient) at $time $date\\n\" \"From: @bold($1) <$sender>\\n\\n$2\";\n\t\t\t\tnotice.z_message_len = strlen(msg) + 3;\n\t\t\t\tnotice.z_message = buf;\n\t\t\t\thandle_message(gc, &notice);\n\t\t\t\tg_free(msg);\n\t\t\t\t\n\t\t\t\tg_free(buf);\n\t\t\t\t\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(spewtype,\"zlocation\",9)) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tchar *user;\n\t\t\t\tPurpleBuddy *b;\n\t\t\t\tconst char *bname;\n\t\t\t\tint nlocs = 0;\n\t\t\t\tparse_tree *locations;\n\t\t\t\tgchar *locval;\n\t\t\t\tuser = tree_child(find_node(newparsetree,\"user\"),2)->contents;\n\t\t\t\tif ((b = purple_find_buddy(gc->account, user)) == NULL) {\n\t\t\t\t\tgchar *stripped_user = zephyr_strip_local_realm(zephyr,user);\n\t\t\t\t\tb = purple_find_buddy(gc->account, stripped_user);\n\t\t\t\t\tg_free(stripped_user);\n\t\t\t\t}\n\t\t\t\tlocations = find_node(newparsetree,\"locations\");\n\t\t\t\tlocval = tree_child(tree_child(tree_child(tree_child(locations,2),0),0),2)->contents;\n\t\t\t\tif (!locval || !g_ascii_strcasecmp(locval,\" \") || (strlen(locval) == 0)) {\n\t\t\t\t\tnlocs = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnlocs = 1;\n\t\t\t\t}\n\t\t\t\tbname = b ? purple_buddy_get_name(b) : NULL;\n\t\t\t\tif ((b && pending_zloc(zephyr,bname)) || pending_zloc(zephyr,user) || pending_zloc(zephyr,local_zephyr_normalize(zephyr,user))){\n\t\t\t\t\tPurpleNotifyUserInfo *user_info = purple_notify_user_info_new();\n\t\t\t\t\tchar *tmp;\n\t\t\t\t\tconst char *balias;\n\t\t\t\t\tpurple_notify_user_info_add_pair(user_info, _(\"User\"), (b ? bname : user));\n\t\t\t\t\tbalias = b ? purple_buddy_get_local_buddy_alias(b) : NULL;\n\t\t\t\t\tif (balias)\n\t\t\t\t\t\tpurple_notify_user_info_add_pair(user_info, _(\"Alias\"), balias);\n\t\t\t\t\tif (!nlocs) {\n\t\t\t\t\t\tpurple_notify_user_info_add_pair(user_info, NULL, _(\"Hidden or not logged-in\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp = g_strdup_printf(_(\"<br>At %s since %s\"),\n\t\t\t\t\t\t\t\t\t  tree_child(tree_child(tree_child(tree_child(locations,2),0),0),2)->contents,\n\t\t\t\t\t\t\t\t\t  tree_child(tree_child(tree_child(tree_child(locations,2),0),2),2)->contents);\n\t\t\t\t\t\tpurple_notify_user_info_add_pair(user_info, _(\"Location\"), tmp);\n\t\t\t\t\t\tg_free(tmp);\n\t\t\t\t\t}\n\t\t\t\t\tpurple_notify_userinfo(gc, b ? bname : user,\n\t\t\t\t\t\t\t     user_info, NULL, NULL);\n\t\t\t\t\tpurple_notify_user_info_destroy(user_info);\n\t\t\t\t} else {\n\t\t\t\t\tif (nlocs>0)\n\t\t\t\t\t\tpurple_prpl_got_user_status(gc->account, b ? bname : user, \"available\", NULL);\n\t\t\t\t\telse\n\t\t\t\t\t\tpurple_prpl_got_user_status(gc->account, b ? bname : user, \"offline\", NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(spewtype,\"subscribed\",10)) {\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(spewtype,\"start\",5)) {\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(spewtype,\"error\",5)) {\n\t\t\t\t\n\t\t\t}\n\t\t} else {\n\t\t}\n\t} else {\n\t}\n\tfree_parse_tree(newparsetree);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1218}
{"project": "Pidgin", "target": 0, "func": "static void\naccount_changed_cb(GtkWidget *dropdown, PurpleAccount *new_account,\n\t\t\t\t   void *user_data)\n{\n\taccount = new_account;\n}\n", "bug_type": null, "idx": 1219}
{"project": "Pidgin", "target": 0, "func": "void\npurple_accounts_set_ui_ops(PurpleAccountUiOps *ops)\n{\n\taccount_ui_ops = ops;\n}\n", "bug_type": null, "idx": 1220}
{"project": "Pidgin", "target": 0, "func": "static void\nflap_frame_destroy(FlapFrame *frame)\n{\n\tg_free(frame->data.data);\n\tg_free(frame);\n}\n", "bug_type": null, "idx": 1221}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_blist_make_buddy_menu(GtkWidget *menu, PurpleBuddy *buddy, gboolean sub) {\n\tPurpleAccount *account = NULL;\n\tPurpleConnection *pc = NULL;\n\tPurplePluginProtocolInfo *prpl_info;\n\tPurpleContact *contact;\n\tPurpleBlistNode *node;\n\tgboolean contact_expanded = FALSE;\n\tg_return_if_fail(menu);\n\tg_return_if_fail(buddy);\n\taccount = purple_buddy_get_account(buddy);\n\tpc = purple_account_get_connection(account);\n\tprpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(purple_connection_get_prpl(pc));\n\tnode = PURPLE_BLIST_NODE(buddy);\n\tcontact = purple_buddy_get_contact(buddy);\n\tif (contact) {\n\t\tPidginBlistNode *node = purple_blist_node_get_ui_data(PURPLE_BLIST_NODE(contact));\n\t\tcontact_expanded = node->contact_expanded;\n\t}\n\tif (prpl_info && prpl_info->get_info) {\n\t\tpidgin_new_item_from_stock(menu, _(\"Get _Info\"), PIDGIN_STOCK_TOOLBAR_USER_INFO,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_info_cb), buddy, 0, 0, NULL);\n\t}\n\tpidgin_new_item_from_stock(menu, _(\"I_M\"), PIDGIN_STOCK_TOOLBAR_MESSAGE_NEW,\n\t\t\tG_CALLBACK(gtk_blist_menu_im_cb), buddy, 0, 0, NULL);\n#ifdef USE_VV\n\tif (prpl_info && prpl_info->get_media_caps) {\n\t\tPurpleAccount *account = purple_buddy_get_account(buddy);\n\t\tconst gchar *who = purple_buddy_get_name(buddy);\n\t\tPurpleMediaCaps caps = purple_prpl_get_media_caps(account, who);\n\t\tif (caps & PURPLE_MEDIA_CAPS_AUDIO) {\n\t\t\tpidgin_new_item_from_stock(menu, _(\"_Audio Call\"),\n\t\t\t\tPIDGIN_STOCK_TOOLBAR_AUDIO_CALL,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_audio_call_cb), buddy, 0, 0, NULL);\n\t\t}\n\t\tif (caps & PURPLE_MEDIA_CAPS_AUDIO_VIDEO) {\n\t\t\tpidgin_new_item_from_stock(menu, _(\"Audio/_Video Call\"),\n\t\t\t\tPIDGIN_STOCK_TOOLBAR_VIDEO_CALL,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_video_call_cb), buddy, 0, 0, NULL);\n\t\t} else if (caps & PURPLE_MEDIA_CAPS_VIDEO) {\n\t\t\tpidgin_new_item_from_stock(menu, _(\"_Video Call\"),\n\t\t\t\tPIDGIN_STOCK_TOOLBAR_VIDEO_CALL,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_video_call_cb), buddy, 0, 0, NULL);\n\t\t}\n\t}\n#endif\n\tif (prpl_info && prpl_info->send_file) {\n\t\tif (!prpl_info->can_receive_file ||\n\t\t\tprpl_info->can_receive_file(buddy->account->gc, buddy->name))\n\t\t{\n\t\t\tpidgin_new_item_from_stock(menu, _(\"_Send File...\"),\n\t\t\t\t\t\t\t\t\t PIDGIN_STOCK_TOOLBAR_SEND_FILE,\n\t\t\t\t\t\t\t\t\t G_CALLBACK(gtk_blist_menu_send_file_cb),\n\t\t\t\t\t\t\t\t\t buddy, 0, 0, NULL);\n\t\t}\n\t}\n\tpidgin_new_item_from_stock(menu, _(\"Add Buddy _Pounce...\"), NULL,\n\t\t\tG_CALLBACK(gtk_blist_menu_bp_cb), buddy, 0, 0, NULL);\n\tif (node->parent && node->parent->child->next &&\n\t      !sub && !contact_expanded) {\n\t\tpidgin_new_item_from_stock(menu, _(\"View _Log\"), NULL,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_showlog_cb),\n\t\t\t\tcontact, 0, 0, NULL);\n\t} else if (!sub) {\n\t\tpidgin_new_item_from_stock(menu, _(\"View _Log\"), NULL,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_showlog_cb), buddy, 0, 0, NULL);\n\t}\n\tif (!PURPLE_BLIST_NODE_HAS_FLAG(node, PURPLE_BLIST_NODE_FLAG_NO_SAVE)) {\n\t\tgboolean show_offline = purple_blist_node_get_bool(node, \"show_offline\");\n\t\tpidgin_new_item_from_stock(menu, show_offline ? _(\"Hide When Offline\") : _(\"Show When Offline\"),\n\t\t\t\tNULL, G_CALLBACK(gtk_blist_menu_showoffline_cb), node, 0, 0, NULL);\n\t}\n\tpidgin_append_blist_node_proto_menu(menu, buddy->account->gc, node);\n\tpidgin_append_blist_node_extended_menu(menu, node);\n\tif (!contact_expanded && contact != NULL)\n\t\tpidgin_append_blist_node_move_to_menu(menu, (PurpleBlistNode *)contact);\n\tif (node->parent && node->parent->child->next &&\n              !sub && !contact_expanded) {\n\t\tpidgin_separator(menu);\n\t\tpidgin_append_blist_node_privacy_menu(menu, node);\n\t\tpidgin_new_item_from_stock(menu, _(\"_Alias...\"), PIDGIN_STOCK_ALIAS,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_alias_cb),\n\t\t\t\tcontact, 0, 0, NULL);\n\t\tpidgin_new_item_from_stock(menu, _(\"_Remove\"), GTK_STOCK_REMOVE,\n\t\t\t\tG_CALLBACK(pidgin_blist_remove_cb),\n\t\t\t\tcontact, 0, 0, NULL);\n\t} else if (!sub || contact_expanded) {\n\t\tpidgin_separator(menu);\n\t\tpidgin_append_blist_node_privacy_menu(menu, node);\n\t\tpidgin_new_item_from_stock(menu, _(\"_Alias...\"), PIDGIN_STOCK_ALIAS,\n\t\t\t\tG_CALLBACK(gtk_blist_menu_alias_cb), buddy, 0, 0, NULL);\n\t\tpidgin_new_item_from_stock(menu, _(\"_Remove\"), GTK_STOCK_REMOVE,\n\t\t\t\tG_CALLBACK(pidgin_blist_remove_cb), buddy,\n\t\t\t\t0, 0, NULL);\n\t}\n}\n", "bug_type": null, "idx": 1222}
{"project": "Pidgin", "target": 0, "func": "static void\nview_log_select_cb(gpointer data, PurpleRequestFields *fields)\n{\n\tPurpleAccount *account;\n\tconst char *name;\n\tPurpleBuddy *buddy;\n\tPurpleContact *contact;\n\taccount = purple_request_fields_get_account(fields, \"account\");\n\tname = purple_request_fields_get_string(fields,  \"screenname\");\n\tbuddy = purple_find_buddy(account, name);\n\tif (buddy) {\n\t\tcontact = purple_buddy_get_contact(buddy);\n\t} else {\n\t\tcontact = NULL;\n\t}\n\tif (contact) {\n\t\tfinch_log_show_contact(contact);\n\t} else {\n\t\tfinch_log_show(PURPLE_LOG_IM, name, account);\n\t}\n}\n", "bug_type": null, "idx": 1223}
{"project": "Pidgin", "target": 0, "func": "static void\n_add_contacts_to_purple_blist(NMUser * user, NMFolder * folder)\n{\n\tNMUserRecord *user_record = NULL;\n\tNMContact *contact = NULL;\n\tPurpleBuddy *buddy = NULL;\n\tPurpleGroup *group;\n\tNMERR_T cnt = 0, i;\n\tconst char *name = NULL;\n\tconst char *fname = NULL;\n\tint status = 0;\n\t\n\tfname = nm_folder_get_name(folder);\n\tif (fname == NULL || *fname == '\\0') {\n\t\tfname = NM_ROOT_FOLDER_NAME;\n\t}\n\t\n\tgroup = purple_find_group(fname);\n\tif (group == NULL) {\n\t\tgroup = purple_group_new(fname);\n\t\tpurple_blist_add_group(group, NULL);\n\t}\n\t\n\tcnt = nm_folder_get_contact_count(folder);\n\tfor (i = 0; i < cnt; i++) {\n\t\tcontact = nm_folder_get_contact(folder, i);\n\t\tif (contact) {\n\t\t\tname = nm_contact_get_display_id(contact);\n\t\t\tif (name) {\n\t\t\t\tbuddy = purple_find_buddy_in_group(user->client_data, name, group);\n\t\t\t\tif (buddy == NULL) {\n\t\t\t\t\t\n\t\t\t\t\tbuddy = purple_buddy_new(user->client_data,\n\t\t\t\t\t\t\t\t\t\t   name,\n\t\t\t\t\t\t\t\t\t\t   nm_contact_get_display_name(contact));\n\t\t\t\t\tpurple_blist_add_buddy(buddy, NULL, group, NULL);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tuser_record = nm_contact_get_user_record(contact);\n\t\t\t\tif (user_record) {\n\t\t\t\t\tstatus = nm_user_record_get_status(user_record);\n\t\t\t\t}\n\t\t\t\t_update_buddy_status(user, buddy, status, time(0));\n\t\t\t\t\n\t\t\t\tnm_contact_set_data(contact, (gpointer) buddy);\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "bug_type": null, "idx": 1224}
{"project": "Pidgin", "target": 0, "func": "static void\npurple_smiley_load_file(const char *shortcut, const char *checksum, const char *filename)\n{\n\tPurpleSmiley *smiley = NULL;\n\tguchar *smiley_data;\n\tsize_t smiley_data_len;\n\tchar *fullpath = NULL;\n\tg_return_if_fail(shortcut  != NULL);\n\tg_return_if_fail(checksum  != NULL);\n\tg_return_if_fail(filename != NULL);\n\tfullpath = get_file_full_path(filename);\n\tif (!fullpath) {\n\t\tpurple_debug_error(SMILEYS_LOG_ID, \"Path for filename %s doesn't exist\\n\", filename);\n\t\treturn;\n\t}\n\tsmiley = purple_smiley_create(shortcut);\n\tif (!smiley) {\n\t\tg_free(fullpath);\n\t\treturn;\n\t}\n\tsmiley->checksum = g_strdup(checksum);\n\tif (read_smiley_file(fullpath, &smiley_data, &smiley_data_len))\n\t\tpurple_smiley_set_data_impl(smiley, smiley_data,\n\t\t\t\tsmiley_data_len);\n\telse\n\t\tpurple_smiley_delete(smiley);\n\tg_free(fullpath);\n}\n", "bug_type": null, "idx": 1225}
{"project": "Pidgin", "target": 0, "func": "void\nprotobuf_c_buffer_simple_append(ProtobufCBuffer *buffer,\n\t\t\t\tsize_t len, const uint8_t *data)\n{\n\tProtobufCBufferSimple *simp = (ProtobufCBufferSimple *) buffer;\n\tsize_t new_len = simp->len + len;\n\tif (new_len > simp->alloced) {\n\t\tProtobufCAllocator *allocator = simp->allocator;\n\t\tsize_t new_alloced = simp->alloced * 2;\n\t\tuint8_t *new_data;\n\t\tif (allocator == NULL)\n\t\t\tallocator = &protobuf_c__allocator;\n\t\twhile (new_alloced < new_len)\n\t\t\tnew_alloced += new_alloced;\n\t\tnew_data = do_alloc(allocator, new_alloced);\n\t\tif (!new_data)\n\t\t\treturn;\n\t\tmemcpy(new_data, simp->data, simp->len);\n\t\tif (simp->must_free_data)\n\t\t\tdo_free(allocator, simp->data);\n\t\telse\n\t\t\tsimp->must_free_data = TRUE;\n\t\tsimp->data = new_data;\n\t\tsimp->alloced = new_alloced;\n\t}\n\tmemcpy(simp->data + simp->len, data, len);\n\tsimp->len = new_len;\n}\n", "bug_type": null, "idx": 1226}
{"project": "Pidgin", "target": 0, "func": "GList *\npurple_request_fields_get_required(const PurpleRequestFields *fields)\n{\n\tg_return_val_if_fail(fields != NULL, NULL);\n\treturn fields->required_fields;\n}\n", "bug_type": null, "idx": 1227}
{"project": "Pidgin", "target": 0, "func": "static gchar *\nx509_issuer_dn (PurpleCertificate *crt)\n{\n\tgnutls_x509_crt_t cert_dat;\n\tgchar *dn = NULL;\n\tsize_t dn_size;\n\tg_return_val_if_fail(crt, NULL);\n\tg_return_val_if_fail(crt->scheme == &x509_gnutls, NULL);\n\tcert_dat = X509_GET_GNUTLS_DATA(crt);\n\t\n\t\n\tdn_size = 0;\n\tgnutls_x509_crt_get_issuer_dn(cert_dat, dn, &dn_size);\n\t\n\t\n\tdn = g_new0(gchar, ++dn_size);\n\tif (0 != gnutls_x509_crt_get_issuer_dn(cert_dat, dn, &dn_size)) {\n\t\tpurple_debug_error(\"gnutls/x509\",\n\t\t\t\t   \"Failed to get issuer's Distinguished \"\n\t\t\t\t   \"Name\\n\");\n\t\tg_free(dn);\n\t\treturn NULL;\n\t}\n\treturn dn;\n}\n", "bug_type": null, "idx": 1228}
{"project": "Pidgin", "target": 0, "func": " */\nint aim_ssi_reqdata(OscarData *od)\n{\n\tFlapConnection *conn;\n\tif (!od || !(conn = flap_connection_findbygroup(od, SNAC_FAMILY_FEEDBAG)))\n\t\treturn -EINVAL;\n\t\n\taim_ssi_freelist(od);\n\taim_genericreq_n_snacid(od, conn, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_REQDATA);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1229}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_blist_theme_set_property(GObject *obj, guint param_id, const GValue *value,\n\t\tGParamSpec *psec)\n{\n\tPidginBlistTheme *theme = PIDGIN_BLIST_THEME(obj);\n\tswitch (param_id) {\n\t\tcase PROP_BACKGROUND_COLOR:\n\t\t\tpidgin_blist_theme_set_background_color(theme, g_value_get_boxed(value));\n\t\t\tbreak;\n\t\tcase PROP_OPACITY:\n\t\t\tpidgin_blist_theme_set_opacity(theme, g_value_get_double(value));\n\t\t\tbreak;\n\t\tcase PROP_LAYOUT:\n\t\t\tpidgin_blist_theme_set_layout(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_EXPANDED_COLOR:\n\t\t\tpidgin_blist_theme_set_expanded_background_color(theme, g_value_get_boxed(value));\n\t\t\tbreak;\n\t\tcase PROP_EXPANDED_TEXT:\n\t\t\tpidgin_blist_theme_set_expanded_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_COLLAPSED_COLOR:\n\t\t\tpidgin_blist_theme_set_collapsed_background_color(theme, g_value_get_boxed(value));\n\t\t\tbreak;\n\t\tcase PROP_COLLAPSED_TEXT:\n\t\t\tpidgin_blist_theme_set_collapsed_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_CONTACT_COLOR:\n\t\t\tpidgin_blist_theme_set_contact_color(theme, g_value_get_boxed(value));\n\t\t\tbreak;\n\t\tcase PROP_CONTACT:\n\t\t\tpidgin_blist_theme_set_contact_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_ONLINE:\n\t\t\tpidgin_blist_theme_set_online_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_AWAY:\n\t\t\tpidgin_blist_theme_set_away_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_OFFLINE:\n\t\t\tpidgin_blist_theme_set_offline_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_IDLE:\n\t\t\tpidgin_blist_theme_set_idle_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_MESSAGE:\n\t\t\tpidgin_blist_theme_set_unread_message_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_MESSAGE_NICK_SAID:\n\t\t\tpidgin_blist_theme_set_unread_message_nick_said_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tcase PROP_STATUS:\n\t\t\tpidgin_blist_theme_set_status_text_info(theme, g_value_get_pointer(value));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID(obj, param_id, psec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1230}
{"project": "Pidgin", "target": 0, "func": "struct gg_http *gg_remind_passwd(uin_t uin, int async)\n{\n\tgg_debug(GG_DEBUG_MISC, \"// gg_remind_passwd() is obsolete. use gg_remind_passwd3() instead!\\n\");\n\terrno = EINVAL;\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1231}
{"project": "Pidgin", "target": 0, "func": "GntMenuItem *gnt_menuitem_check_new(const char *text)\n{\n\tGntMenuItem *item = g_object_new(GNT_TYPE_MENU_ITEM_CHECK, NULL);\n\tGntMenuItem *menuitem = GNT_MENU_ITEM(item);\n\tmenuitem->text = g_strdup(text);\n\treturn item;\n}\n", "bug_type": null, "idx": 1232}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_mini_dialog_add_button(PidginMiniDialog *self,\n                              const char *text,\n                              PidginMiniDialogCallback clicked_cb,\n                              gpointer user_data)\n{\n\tmini_dialog_add_button(self, text, clicked_cb, user_data, TRUE);\n}\n", "bug_type": null, "idx": 1233}
{"project": "Pidgin", "target": 0, "func": "void purple_log_logger_set (PurpleLogLogger *logger)\n{\n\tg_return_if_fail(logger);\n\tcurrent_logger = logger;\n}\n", "bug_type": null, "idx": 1234}
{"project": "Pidgin", "target": 0, "func": "size_t gg110_message_ack_link__pack_to_buffer\n                     (const GG110MessageAckLink *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &gg110_message_ack_link__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\n", "bug_type": null, "idx": 1235}
{"project": "Pidgin", "target": 0, "func": "void gg_compat_message_ack(struct gg_session *sess, int seq)\n{\n\tgg_msg_list_t *sm;\n\tsize_t i;\n\tif (sess->protocol_version < GG_PROTOCOL_VERSION_110)\n\t\treturn;\n\tif (!gg_compat_feature_is_enabled(sess, GG_COMPAT_FEATURE_ACK_EVENT))\n\t\treturn;\n\tsm = gg_compat_find_sent_message(sess, seq, 1);\n\tif (!sm)\n\t\treturn;\n\tfor (i = 0; i < sm->recipients_count; i++) {\n\t\tstruct gg_event *qev;\n\t\tqev = gg_eventqueue_add(sess);\n\t\tqev->type = GG_EVENT_ACK;\n\t\tqev->event.ack.status = GG_ACK_DELIVERED;\n\t\tqev->event.ack.recipient = sm->recipients[i];\n\t\tqev->event.ack.seq = seq;\n\t}\n\tfree(sm->recipients);\n\tfree(sm);\n}\n", "bug_type": null, "idx": 1236}
{"project": "Pidgin", "target": 0, "func": "void\nprotobuf_c_message_init(const ProtobufCMessageDescriptor * descriptor,\n\t\t\tvoid *message)\n{\n\tdescriptor->message_init((ProtobufCMessage *) (message));\n}\n", "bug_type": null, "idx": 1237}
{"project": "Pidgin", "target": 0, "func": "static void cmds_free_func(gpointer value)\n{\n\tGSList *commands = value;\n\twhile (commands) {\n\t\tpurple_cmd_unregister(GPOINTER_TO_UINT(commands->data));\n\t\tcommands = g_slist_delete_link(commands, commands);\n\t}\n}\n", "bug_type": null, "idx": 1238}
{"project": "Pidgin", "target": 0, "func": "static void\nclipboard_changed(GntWM *wm, gchar *string)\n{\n\tif (child) {\n\t\tkill(child, SIGTERM);\n\t}\n\tif ((child = fork() == 0)) {\n\t\tset_clip(string);\n\t\t_exit(0);\n\t}\n}\n", "bug_type": null, "idx": 1239}
{"project": "Pidgin", "target": 0, "func": "gint purple_log_set_compare(gconstpointer y, gconstpointer z)\n{\n\tconst PurpleLogSet *a = y;\n\tconst PurpleLogSet *b = z;\n\tgint ret = 0;\n\t\n\tif (a->account != NULL && b->account != NULL) {\n\t\tret = strcmp(purple_account_get_username(a->account), purple_account_get_username(b->account));\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\tret = strcmp(a->normalized_name, b->normalized_name);\n\tif (ret != 0)\n\t\treturn ret;\n\treturn (gint)b->type - (gint)a->type;\n}\n", "bug_type": null, "idx": 1240}
{"project": "Pidgin", "target": 0, "func": "static void chat_invite_reject(struct chat_invite_data *cid)\n{\n\tserv_reject_chat(cid->gc, cid->components);\n\tchat_invite_data_free(cid);\n}\n", "bug_type": null, "idx": 1241}
{"project": "Pidgin", "target": 0, "func": "static void\ntoggle_underline(GtkWidget *widget, gpointer data)\n{\n\ttoggle_something(data, FONT_UNDERLINE);\n}\n", "bug_type": null, "idx": 1242}
{"project": "Pidgin", "target": 0, "func": " */\nint gg_chat_create(struct gg_session *gs)\n{\n\tstruct gg_chat_create pkt;\n\tint seq;\n\tif (!gg_required_proto(gs, GG_PROTOCOL_VERSION_110))\n\t\treturn -1;\n\tseq = ++gs->seq;\n\tpkt.seq = gg_fix32(seq);\n\tpkt.dummy = 0;\n\tif (gg_send_packet(gs, GG_CHAT_CREATE, &pkt, sizeof(pkt), NULL) == -1)\n\t\treturn -1;\n\treturn seq;\n}\n", "bug_type": null, "idx": 1243}
{"project": "Pidgin", "target": 0, "func": "const char *\nnm_user_record_get_status_text(NMUserRecord * user_record)\n{\n\tif (user_record == NULL)\n\t\treturn NULL;\n\treturn user_record->status_text;\n}\n", "bug_type": null, "idx": 1244}
{"project": "Pidgin", "target": 0, "func": "static gboolean\ndisco_paint_tooltip(GtkWidget *tipwindow, gpointer data)\n{\n\tPangoLayout *layout = g_object_get_data(G_OBJECT(tipwindow), \"tooltip-plugin\");\n#if GTK_CHECK_VERSION(2,14,0)\n\tgtk_paint_layout(gtk_widget_get_style(tipwindow),\n\t\t\tgtk_widget_get_window(tipwindow),\n\t\t\tGTK_STATE_NORMAL, FALSE,\n#else\n\tgtk_paint_layout(tipwindow->style, tipwindow->window, GTK_STATE_NORMAL, FALSE,\n#endif\n\t\t\tNULL, tipwindow, \"tooltip\",\n\t\t\t6, 6, layout);\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1245}
{"project": "Pidgin", "target": 0, "func": "PurpleConvChatBuddyFlags\npurple_conv_chat_user_get_flags(PurpleConvChat *chat, const char *user)\n{\n\tPurpleConvChatBuddy *cb;\n\tg_return_val_if_fail(chat != NULL, 0);\n\tg_return_val_if_fail(user != NULL, 0);\n\tcb = purple_conv_chat_cb_find(chat, user);\n\tif (!cb)\n\t\treturn PURPLE_CBFLAGS_NONE;\n\treturn cb->flags;\n}\n", "bug_type": null, "idx": 1246}
{"project": "Pidgin", "target": 0, "func": "void\npurple_mime_part_set_data(PurpleMimePart *part, const char *data)\n{\n\tg_return_if_fail(part != NULL);\n\tg_string_free(part->data, TRUE);\n\tpart->data = g_string_new(data);\n}\n", "bug_type": null, "idx": 1247}
{"project": "Pidgin", "target": 0, "func": "int\naim_request_login(OscarData *od, FlapConnection *conn, const char *sn)\n{\n\tFlapFrame *frame;\n\taim_snacid_t snacid;\n\tGSList *tlvlist = NULL;\n\tif (!od || !conn || !sn)\n\t\treturn -EINVAL;\n#ifdef USE_XOR_FOR_ICQ\n\tif (aim_snvalid_icq(sn))\n\t\treturn goddamnicq(od, conn, sn);\n#endif\n\tframe = flap_frame_new(od, 0x02, 10+2+2+strlen(sn)+8);\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_AUTH, 0x0006, 0x0000, NULL, 0);\n\taim_putsnac(&frame->data, SNAC_FAMILY_AUTH, 0x0006, snacid);\n\taim_tlvlist_add_str(&tlvlist, 0x0001, sn);\n\t\n\taim_tlvlist_add_noval(&tlvlist, 0x004b);\n\t\n\taim_tlvlist_add_noval(&tlvlist, 0x005a);\n\taim_tlvlist_write(&frame->data, &tlvlist);\n\taim_tlvlist_free(tlvlist);\n\tflap_connection_send(conn, frame);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1248}
{"project": "Pidgin", "target": 0, "func": "static inline void *\ndo_alloc(ProtobufCAllocator *allocator, size_t size)\n{\n\treturn allocator->alloc(allocator->allocator_data, size);\n}\n", "bug_type": null, "idx": 1249}
{"project": "Pidgin", "target": 0, "func": "const char *gnt_key_lookup(const char *key)\n{\n\tgntkey k = {NULL, key};\n\tg_hash_table_foreach(specials, get_key_name, &k);\n\treturn k.name;\n}\n", "bug_type": null, "idx": 1250}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\nconv_page(void)\n{\n\tGtkWidget *ret;\n\tGtkWidget *vbox;\n\tGtkWidget *toolbar;\n\tGtkWidget *iconpref1;\n\tGtkWidget *iconpref2;\n\tGtkWidget *imhtml;\n\tGtkWidget *frame;\n\tGtkWidget *hbox;\n\tGtkWidget *checkbox;\n\tGtkWidget *spin_button;\n\tret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);\n\tgtk_container_set_border_width(GTK_CONTAINER(ret), PIDGIN_HIG_BORDER);\n\tvbox = pidgin_make_frame(ret, _(\"Conversations\"));\n\tpidgin_prefs_checkbox(_(\"Show _formatting on incoming messages\"),\n\t\t\t\tPIDGIN_PREFS_ROOT \"/conversations/show_incoming_formatting\", vbox);\n\tpidgin_prefs_checkbox(_(\"Close IMs immediately when the tab is closed\"),\n\t\t\t\tPIDGIN_PREFS_ROOT \"/conversations/im/close_immediately\", vbox);\n\ticonpref1 = pidgin_prefs_checkbox(_(\"Show _detailed information\"),\n\t\t\tPIDGIN_PREFS_ROOT \"/conversations/im/show_buddy_icons\", vbox);\n\ticonpref2 = pidgin_prefs_checkbox(_(\"Enable buddy ic_on animation\"),\n\t\t\tPIDGIN_PREFS_ROOT \"/conversations/im/animate_buddy_icons\", vbox);\n\tif (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/conversations/im/show_buddy_icons\"))\n\t\tgtk_widget_set_sensitive(iconpref2, FALSE);\n\tg_signal_connect(G_OBJECT(iconpref1), \"clicked\",\n\t\t\t\t\t G_CALLBACK(pidgin_toggle_sensitive), iconpref2);\n\tpidgin_prefs_checkbox(_(\"_Notify buddies that you are typing to them\"),\n\t\t\t\"/purple/conversations/im/send_typing\", vbox);\n#ifdef USE_GTKSPELL\n\tpidgin_prefs_checkbox(_(\"Highlight _misspelled words\"),\n\t\t\tPIDGIN_PREFS_ROOT \"/conversations/spellcheck\", vbox);\n#endif\n\tpidgin_prefs_checkbox(_(\"Use smooth-scrolling\"), PIDGIN_PREFS_ROOT \"/conversations/use_smooth_scrolling\", vbox);\n#ifdef _WIN32\n\tpidgin_prefs_checkbox(_(\"F_lash window when IMs are received\"), PIDGIN_PREFS_ROOT \"/win32/blink_im\", vbox);\n#endif\n\thbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);\n\tcheckbox = pidgin_prefs_checkbox(_(\"Resize incoming custom smileys\"),\n\t\t\tPIDGIN_PREFS_ROOT \"/conversations/resize_custom_smileys\", hbox);\n\tspin_button = pidgin_prefs_labeled_spin_button(hbox,\n\t\t_(\"Maximum size:\"),\n\t\tPIDGIN_PREFS_ROOT \"/conversations/custom_smileys_size\",\n\t\t16, 512, NULL);\n\tif (!purple_prefs_get_bool(\n\t\t\t\tPIDGIN_PREFS_ROOT \"/conversations/resize_custom_smileys\"))\n\t\tgtk_widget_set_sensitive(GTK_WIDGET(spin_button), FALSE);\n\tg_signal_connect(G_OBJECT(checkbox), \"clicked\",\n\t\t\t\t\t G_CALLBACK(pidgin_toggle_sensitive), spin_button);\n\tpidgin_add_widget_to_vbox(GTK_BOX(vbox), NULL, NULL, hbox, TRUE, NULL);\n\tpidgin_prefs_labeled_spin_button(vbox,\n\t\t_(\"Minimum input area height in lines:\"),\n\t\tPIDGIN_PREFS_ROOT \"/conversations/minimum_entry_lines\",\n\t\t1, 8, NULL);\n#ifdef _WIN32\n\t{\n\tGtkWidget *fontpref, *font_button, *hbox;\n\tconst char *font_name;\n\tvbox = pidgin_make_frame(ret, _(\"Font\"));\n\tfontpref = pidgin_prefs_checkbox(_(\"Use font from _theme\"),\n\t\t\t\t\t\t\t\t\t PIDGIN_PREFS_ROOT \"/conversations/use_theme_font\", vbox);\n\tfont_name = purple_prefs_get_string(PIDGIN_PREFS_ROOT \"/conversations/custom_font\");\n\tif ((font_name == NULL) || (*font_name == '\\0')) {\n\t\tfont_button = gtk_font_button_new();\n\t} else {\n\t\tfont_button = gtk_font_button_new_with_font(font_name);\n\t}\n\tgtk_font_button_set_show_style(GTK_FONT_BUTTON(font_button), TRUE);\n\thbox = pidgin_add_widget_to_vbox(GTK_BOX(vbox), _(\"Conversation _font:\"), NULL, font_button, FALSE, NULL);\n\tif (purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/conversations/use_theme_font\"))\n\t\tgtk_widget_set_sensitive(hbox, FALSE);\n\tg_signal_connect(G_OBJECT(fontpref), \"clicked\", G_CALLBACK(pidgin_toggle_sensitive), hbox);\n\tg_signal_connect(G_OBJECT(fontpref), \"clicked\", G_CALLBACK(apply_custom_font), hbox);\n\tg_signal_connect(G_OBJECT(font_button), \"font-set\", G_CALLBACK(pidgin_custom_font_set), NULL);\n\t}\n#endif\n\tvbox = pidgin_make_frame(ret, _(\"Default Formatting\"));\n\tframe = pidgin_create_imhtml(TRUE, &imhtml, &toolbar, NULL);\n\tgtk_widget_show(frame);\n\tgtk_widget_set_name(imhtml, \"pidgin_prefs_font_imhtml\");\n\tgtk_widget_set_size_request(frame, 450, -1);\n\tgtk_imhtml_set_whole_buffer_formatting_only(GTK_IMHTML(imhtml), TRUE);\n\tgtk_imhtml_set_format_functions(GTK_IMHTML(imhtml),\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_BOLD |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_ITALIC |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_UNDERLINE |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_GROW |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_SHRINK |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_FACE |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_FORECOLOR |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_BACKCOLOR |\n\t\t\t\t\t\t\t\t\tGTK_IMHTML_BACKGROUND);\n\tgtk_imhtml_append_text(GTK_IMHTML(imhtml), _(\"This is how your outgoing message text will appear when you use protocols that support formatting.\"), 0);\n\tgtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);\n\tgtk_imhtml_setup_entry(GTK_IMHTML(imhtml), PURPLE_CONNECTION_HTML | PURPLE_CONNECTION_FORMATTING_WBFO);\n\tg_signal_connect_after(G_OBJECT(imhtml), \"format_function_toggle\",\n\t\t\t\t\t G_CALLBACK(formatting_toggle_cb), toolbar);\n\tg_signal_connect_after(G_OBJECT(imhtml), \"format_function_clear\",\n\t\t\t\t\t G_CALLBACK(formatting_clear_cb), NULL);\n\tsample_imhtml = imhtml;\n\tgtk_widget_show(ret);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1251}
{"project": "Pidgin", "target": 0, "func": "static void\njabber_si_xfer_bytestreams_send_read_again_resp_cb(gpointer data, gint source,\n\t\tPurpleInputCondition cond)\n{\n\tPurpleXfer *xfer = data;\n\tJabberSIXfer *jsx = xfer->data;\n\tint len;\n\tlen = write(source, jsx->rxqueue + jsx->rxlen, jsx->rxmaxlen - jsx->rxlen);\n\tif (len < 0 && errno == EAGAIN)\n\t\treturn;\n\telse if (len < 0) {\n\t\tpurple_input_remove(xfer->watcher);\n\t\txfer->watcher = 0;\n\t\tg_free(jsx->rxqueue);\n\t\tjsx->rxqueue = NULL;\n\t\tclose(source);\n\t\tpurple_xfer_cancel_remote(xfer);\n\t\treturn;\n\t}\n\tjsx->rxlen += len;\n\tif (jsx->rxlen < jsx->rxmaxlen)\n\t\treturn;\n\tpurple_input_remove(xfer->watcher);\n\txfer->watcher = 0;\n\tg_free(jsx->rxqueue);\n\tjsx->rxqueue = NULL;\n\t\n\tpurple_debug_info(\"jabber\", \"SOCKS5 connection negotiation completed. \"\n\t\t\t\t\t  \"Waiting for IQ result to start file transfer.\\n\");\n}\n", "bug_type": null, "idx": 1252}
{"project": "Pidgin", "target": 0, "func": "static void conv_destroyed (PurpleConversation *conv)\n{\n\tMMConversation *mmconv = mmconv_from_conv(conv);\n\tremove_widget(mmconv->button);\n\tremove_widget(mmconv->seperator);\n\tif (mmconv->started)\n\t{\n\t\tkill_editor(mmconv);\n\t}\n\tconversations = g_list_remove(conversations, mmconv);\n}\n", "bug_type": null, "idx": 1253}
{"project": "Pidgin", "target": 0, "func": "   plugin is unloaded, when quitting */\nstatic void purple_quit_cb() {\n\tpurple_debug_info(WINPREFS_PLUGIN_ID, \"purple_quit_cb: removing appbar\\n\");\n\tblist_save_state();\n\tblist_set_dockable(FALSE);\n}\n", "bug_type": null, "idx": 1254}
{"project": "Pidgin", "target": 0, "func": "static void msn_logger_finalize(PurpleLog *log)\n{\n\tstruct msn_logger_data *data;\n\tg_return_if_fail(log != NULL);\n\tdata = log->logger_data;\n\tif (data->last_log)\n\t\txmlnode_free(data->root);\n\tif (data->text)\n\t\tg_string_free(data->text, FALSE);\n\tg_free(data);\n}\n", "bug_type": null, "idx": 1255}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_status_box_init (PidginStatusBox *status_box)\n{\n\tGtkCellRenderer *text_rend;\n\tGtkCellRenderer *icon_rend;\n\tGtkCellRenderer *emblem_rend;\n\tGtkTextBuffer *buffer;\n\tGtkWidget *toplevel;\n\tGtkTreeSelection *sel;\n\tGTK_WIDGET_SET_FLAGS (status_box, GTK_NO_WINDOW);\n\tstatus_box->imhtml_visible = FALSE;\n\tstatus_box->network_available = purple_network_is_available();\n\tstatus_box->connecting = FALSE;\n\tstatus_box->typing = 0;\n\tstatus_box->toggle_button = gtk_toggle_button_new();\n\tstatus_box->hbox = gtk_hbox_new(FALSE, 6);\n\tstatus_box->cell_view = gtk_cell_view_new();\n\tstatus_box->vsep = gtk_vseparator_new();\n\tstatus_box->arrow = gtk_arrow_new (GTK_ARROW_DOWN, GTK_SHADOW_NONE);\n\tstatus_box->store = gtk_list_store_new(NUM_COLUMNS, G_TYPE_INT, G_TYPE_STRING, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING,\n\t\t\t\t\t       G_TYPE_STRING, G_TYPE_POINTER, GDK_TYPE_PIXBUF, G_TYPE_BOOLEAN);\n\tstatus_box->dropdown_store = gtk_list_store_new(NUM_COLUMNS, G_TYPE_INT, G_TYPE_STRING, GDK_TYPE_PIXBUF, G_TYPE_STRING,\n\t\t\t\t\t\t\tG_TYPE_STRING, G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_STRING, G_TYPE_BOOLEAN);\n\tgtk_cell_view_set_model(GTK_CELL_VIEW(status_box->cell_view), GTK_TREE_MODEL(status_box->store));\n\tgtk_list_store_append(status_box->store, &(status_box->iter));\n\tatk_object_set_name(gtk_widget_get_accessible(status_box->toggle_button), _(\"Status Selector\"));\n\tgtk_container_add(GTK_CONTAINER(status_box->toggle_button), status_box->hbox);\n\tgtk_box_pack_start(GTK_BOX(status_box->hbox), status_box->cell_view, TRUE, TRUE, 0);\n\tgtk_box_pack_start(GTK_BOX(status_box->hbox), status_box->vsep, FALSE, FALSE, 0);\n\tgtk_box_pack_start(GTK_BOX(status_box->hbox), status_box->arrow, FALSE, FALSE, 0);\n\tgtk_widget_show_all(status_box->toggle_button);\n\tgtk_button_set_focus_on_click(GTK_BUTTON(status_box->toggle_button), FALSE);\n\ttext_rend = gtk_cell_renderer_text_new();\n\ticon_rend = gtk_cell_renderer_pixbuf_new();\n\temblem_rend = gtk_cell_renderer_pixbuf_new();\n\tstatus_box->popup_window = gtk_window_new (GTK_WINDOW_POPUP);\n\ttoplevel = gtk_widget_get_toplevel (GTK_WIDGET (status_box));\n\tif (GTK_IS_WINDOW (toplevel))  {\n\t\tgtk_window_set_transient_for (GTK_WINDOW (status_box->popup_window),\n\t\t\t\tGTK_WINDOW (toplevel));\n\t}\n\tgtk_window_set_resizable (GTK_WINDOW (status_box->popup_window), FALSE);\n\tgtk_window_set_type_hint (GTK_WINDOW (status_box->popup_window),\n\t\t\tGDK_WINDOW_TYPE_HINT_POPUP_MENU);\n\tgtk_window_set_screen (GTK_WINDOW (status_box->popup_window),\n\t\t\tgtk_widget_get_screen (GTK_WIDGET (status_box)));\n\tstatus_box->popup_frame = gtk_frame_new (NULL);\n\tgtk_frame_set_shadow_type (GTK_FRAME (status_box->popup_frame),\n\t\t\tGTK_SHADOW_ETCHED_IN);\n\tgtk_container_add (GTK_CONTAINER (status_box->popup_window),\n\t\t\tstatus_box->popup_frame);\n\tgtk_widget_show (status_box->popup_frame);\n\tstatus_box->tree_view = gtk_tree_view_new ();\n\tsel = gtk_tree_view_get_selection (GTK_TREE_VIEW (status_box->tree_view));\n\tgtk_tree_selection_set_mode (sel, GTK_SELECTION_BROWSE);\n\tgtk_tree_view_set_headers_visible (GTK_TREE_VIEW (status_box->tree_view),\n\t\t\tFALSE);\n\tgtk_tree_view_set_hover_selection (GTK_TREE_VIEW (status_box->tree_view),\n\t\t\tTRUE);\n\tgtk_tree_view_set_model (GTK_TREE_VIEW (status_box->tree_view),\n\t\t\tGTK_TREE_MODEL(status_box->dropdown_store));\n\tstatus_box->column = gtk_tree_view_column_new ();\n\tgtk_tree_view_append_column (GTK_TREE_VIEW (status_box->tree_view),\n\t\t\tstatus_box->column);\n\tgtk_tree_view_column_pack_start(status_box->column, icon_rend, FALSE);\n\tgtk_tree_view_column_pack_start(status_box->column, text_rend, TRUE);\n\tgtk_tree_view_column_pack_start(status_box->column, emblem_rend, FALSE);\n\tgtk_tree_view_column_set_attributes(status_box->column, icon_rend, \"stock-id\", ICON_STOCK_COLUMN, NULL);\n\tgtk_tree_view_column_set_attributes(status_box->column, text_rend, \"markup\", TEXT_COLUMN, NULL);\n\tgtk_tree_view_column_set_attributes(status_box->column, emblem_rend, \"stock-id\", EMBLEM_COLUMN, \"visible\", EMBLEM_VISIBLE_COLUMN, NULL);\n\tstatus_box->scrolled_window = pidgin_make_scrollable(status_box->tree_view, GTK_POLICY_NEVER, GTK_POLICY_NEVER, GTK_SHADOW_NONE, -1, -1);\n\tgtk_container_add (GTK_CONTAINER (status_box->popup_frame),\n\t\t\tstatus_box->scrolled_window);\n\tgtk_widget_show(status_box->tree_view);\n\tgtk_tree_view_set_search_column(GTK_TREE_VIEW(status_box->tree_view), TEXT_COLUMN);\n\tgtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(status_box->tree_view),\n\t\t\t\tpidgin_tree_view_search_equal_func, NULL, NULL);\n\tg_object_set(text_rend, \"ellipsize\", PANGO_ELLIPSIZE_END, NULL);\n\tstatus_box->icon_rend = gtk_cell_renderer_pixbuf_new();\n\tstatus_box->text_rend = gtk_cell_renderer_text_new();\n\temblem_rend = gtk_cell_renderer_pixbuf_new();\n\tgtk_cell_layout_pack_start(GTK_CELL_LAYOUT(status_box->cell_view), status_box->icon_rend, FALSE);\n\tgtk_cell_layout_pack_start(GTK_CELL_LAYOUT(status_box->cell_view), status_box->text_rend, TRUE);\n\tgtk_cell_layout_pack_start(GTK_CELL_LAYOUT(status_box->cell_view), emblem_rend, FALSE);\n\tgtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(status_box->cell_view), status_box->icon_rend, \"stock-id\", ICON_STOCK_COLUMN, NULL);\n\tgtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(status_box->cell_view), status_box->text_rend, \"markup\", TEXT_COLUMN, NULL);\n\tgtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(status_box->cell_view), emblem_rend, \"pixbuf\", EMBLEM_COLUMN, \"visible\", EMBLEM_VISIBLE_COLUMN, NULL);\n\tg_object_set(status_box->text_rend, \"ellipsize\", PANGO_ELLIPSIZE_END, NULL);\n\tstatus_box->vbox = gtk_vbox_new(0, FALSE);\n\tstatus_box->sw = pidgin_create_imhtml(FALSE, &status_box->imhtml, NULL, NULL);\n\tgtk_imhtml_set_editable(GTK_IMHTML(status_box->imhtml), TRUE);\n\tbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(status_box->imhtml));\n#if 0\n\tg_signal_connect(G_OBJECT(status_box->toggle_button), \"button-press-event\",\n\t\t\t G_CALLBACK(button_pressed_cb), status_box);\n\tg_signal_connect(G_OBJECT(status_box->toggle_button), \"button-release-event\",\n\t\t\t G_CALLBACK(button_released_cb), status_box);\n#endif\n\tg_signal_connect(G_OBJECT(status_box->toggle_button), \"key-press-event\",\n\t                 G_CALLBACK(toggle_key_press_cb), status_box);\n\tg_signal_connect(G_OBJECT(status_box->toggle_button), \"button-press-event\",\n\t                 G_CALLBACK(toggled_cb), status_box);\n\tg_signal_connect(G_OBJECT(buffer), \"changed\", G_CALLBACK(imhtml_changed_cb), status_box);\n\tg_signal_connect(G_OBJECT(status_box->imhtml), \"format_function_toggle\",\n\t\t\t G_CALLBACK(imhtml_format_changed_cb), status_box);\n\tg_signal_connect_swapped(G_OBJECT(status_box->imhtml), \"move_cursor\",\n\t\t\t G_CALLBACK(imhtml_cursor_moved_cb), status_box);\n\tg_signal_connect(G_OBJECT(status_box->imhtml), \"key_press_event\",\n\t\t\t G_CALLBACK(imhtml_remove_focus), status_box);\n\tg_signal_connect_swapped(G_OBJECT(status_box->imhtml), \"message_send\", G_CALLBACK(remove_typing_cb), status_box);\n#ifdef USE_GTKSPELL\n\tif (purple_prefs_get_bool(PIDGIN_PREFS_ROOT \"/conversations/spellcheck\"))\n\t\tpidgin_setup_gtkspell(GTK_TEXT_VIEW(status_box->imhtml));\n#endif\n\tgtk_widget_set_parent(status_box->vbox, GTK_WIDGET(status_box));\n\tgtk_widget_show_all(status_box->vbox);\n\tgtk_widget_set_parent(status_box->toggle_button, GTK_WIDGET(status_box));\n\tgtk_box_pack_start(GTK_BOX(status_box->vbox), status_box->sw, TRUE, TRUE, 0);\n\tg_signal_connect(G_OBJECT(status_box), \"scroll_event\", G_CALLBACK(combo_box_scroll_event_cb), NULL);\n\tg_signal_connect(G_OBJECT(status_box->imhtml), \"scroll_event\",\n\t\t\t\t\tG_CALLBACK(imhtml_scroll_event_cb), status_box->imhtml);\n\tg_signal_connect(G_OBJECT(status_box->popup_window), \"button_release_event\", G_CALLBACK(treeview_button_release_cb), status_box);\n\tg_signal_connect(G_OBJECT(status_box->popup_window), \"key_press_event\", G_CALLBACK(treeview_key_press_event), status_box);\n\tg_signal_connect(G_OBJECT(status_box->tree_view), \"cursor-changed\",\n\t\t\t\t\t G_CALLBACK(treeview_cursor_changed_cb), status_box->dropdown_store);\n\tgtk_tree_view_set_row_separator_func(GTK_TREE_VIEW(status_box->tree_view), dropdown_store_row_separator_func, NULL, NULL);\n\tstatus_box->token_status_account = check_active_accounts_for_identical_statuses();\n\tcache_pixbufs(status_box);\n\tpidgin_status_box_regenerate(status_box, TRUE);\n\tpurple_signal_connect(purple_savedstatuses_get_handle(), \"savedstatus-changed\",\n\t\t\t\t\t\tstatus_box,\n\t\t\t\t\t\tPURPLE_CALLBACK(current_savedstatus_changed_cb),\n\t\t\t\t\t\tstatus_box);\n\tpurple_signal_connect(purple_savedstatuses_get_handle(),\n\t\t\t\"savedstatus-added\", status_box,\n\t\t\tPURPLE_CALLBACK(saved_status_updated_cb), status_box);\n\tpurple_signal_connect(purple_savedstatuses_get_handle(),\n\t\t\t\"savedstatus-deleted\", status_box,\n\t\t\tPURPLE_CALLBACK(saved_status_updated_cb), status_box);\n\tpurple_signal_connect(purple_savedstatuses_get_handle(),\n\t\t\t\"savedstatus-modified\", status_box,\n\t\t\tPURPLE_CALLBACK(saved_status_updated_cb), status_box);\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-enabled\", status_box,\n\t\t\t\t\t\tPURPLE_CALLBACK(account_enabled_cb),\n\t\t\t\t\t\tstatus_box);\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-disabled\", status_box,\n\t\t\t\t\t\tPURPLE_CALLBACK(account_enabled_cb),\n\t\t\t\t\t\tstatus_box);\n\tpurple_signal_connect(purple_accounts_get_handle(), \"account-status-changed\", status_box,\n\t\t\t\t\t\tPURPLE_CALLBACK(account_status_changed_cb),\n\t\t\t\t\t\tstatus_box);\n\tpurple_prefs_connect_callback(status_box, PIDGIN_PREFS_ROOT \"/conversations/spellcheck\",\n\t\t\t\t\t\t\t\tspellcheck_prefs_cb, status_box);\n\tpurple_prefs_connect_callback(status_box, PIDGIN_PREFS_ROOT \"/accounts/buddyicon\",\n\t                            update_buddyicon_cb, status_box);\n\tpurple_signal_connect(purple_get_core(), \"uri-handler\", status_box,\n\t\t\t\t\tPURPLE_CALLBACK(statusbox_uri_handler), status_box);\n}\n", "bug_type": null, "idx": 1256}
{"project": "Pidgin", "target": 0, "func": "int\naim_chat_send_im(OscarData *od, FlapConnection *conn, guint16 flags, const gchar *msg, int msglen, const char *encoding, const char *language)\n{\n\tint i;\n\tByteStream bs;\n\tIcbmCookie *cookie;\n\taim_snacid_t snacid;\n\tguint8 ckstr[8];\n\tGSList *tlvlist = NULL, *inner_tlvlist = NULL;\n\tif (!od || !conn || !msg || (msglen <= 0))\n\t\treturn 0;\n\tbyte_stream_new(&bs, 1142);\n\tsnacid = aim_cachesnac(od, SNAC_FAMILY_CHAT, 0x0005, 0x0000, NULL, 0);\n\t\n\tfor (i = 0; i < 8; i++)\n\t\tckstr[i] = (guint8)rand();\n\tcookie = aim_mkcookie(ckstr, AIM_COOKIETYPE_CHAT, NULL);\n\tcookie->data = NULL; \n\taim_cachecookie(od, cookie);\n\t\n\tbyte_stream_putraw(&bs, ckstr, 8); \n\tbyte_stream_put16(&bs, 0x0003); \n\t\n\taim_tlvlist_add_noval(&tlvlist, 0x0001);\n\t\n\tif (!(flags & AIM_CHATFLAGS_NOREFLECT))\n\t\taim_tlvlist_add_noval(&tlvlist, 0x0006);\n\t\n\tif (flags & AIM_CHATFLAGS_AWAY)\n\t\taim_tlvlist_add_noval(&tlvlist, 0x0007);\n\t\n\taim_tlvlist_add_raw(&inner_tlvlist, 0x0001, msglen, (guchar *)msg);\n\t\n\tif (encoding != NULL)\n\t\taim_tlvlist_add_str(&inner_tlvlist, 0x0002, encoding);\n\t\n\tif (language != NULL)\n\t\taim_tlvlist_add_str(&inner_tlvlist, 0x0003, language);\n\t\n\taim_tlvlist_add_frozentlvlist(&tlvlist, 0x0005, &inner_tlvlist);\n\taim_tlvlist_write(&bs, &tlvlist);\n\taim_tlvlist_free(inner_tlvlist);\n\taim_tlvlist_free(tlvlist);\n\tflap_connection_send_snac(od, conn, SNAC_FAMILY_CHAT, 0x0005, snacid, &bs);\n\tbyte_stream_destroy(&bs);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1257}
{"project": "Pidgin", "target": 0, "func": "void purple_blist_add_buddy(PurpleBuddy *buddy, PurpleContact *contact, PurpleGroup *group, PurpleBlistNode *node)\n{\n\tPurpleBlistNode *cnode, *bnode;\n\tPurpleGroup *g;\n\tPurpleContact *c;\n\tPurpleBlistUiOps *ops = purple_blist_get_ui_ops();\n\tstruct _purple_hbuddy *hb, *hb2;\n\tGHashTable *account_buddies;\n\tg_return_if_fail(buddy != NULL);\n\tg_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY((PurpleBlistNode*)buddy));\n\tbnode = (PurpleBlistNode *)buddy;\n\t\n\tif (bnode == node || (!node && bnode->parent &&\n\t\t\t\tcontact && bnode->parent == (PurpleBlistNode*)contact\n\t\t\t\t&& bnode == bnode->parent->child))\n\t\treturn;\n\tif (node && PURPLE_BLIST_NODE_IS_BUDDY(node)) {\n\t\tc = (PurpleContact*)node->parent;\n\t\tg = (PurpleGroup*)node->parent->parent;\n\t} else if (contact) {\n\t\tc = contact;\n\t\tg = PURPLE_GROUP(PURPLE_BLIST_NODE(c)->parent);\n\t} else {\n\t\tg = group;\n\t\tif (g == NULL)\n\t\t\tg = purple_group_new(_(\"Buddies\"));\n\t\t\n\t\tif (!purple_find_group(g->name)) {\n\t\t\tpurple_blist_add_group(g,\n\t\t\t\t\tpurple_blist_get_last_sibling(purplebuddylist->root));\n\t\t}\n\t\tc = purple_contact_new();\n\t\tpurple_blist_add_contact(c, g,\n\t\t\t\tpurple_blist_get_last_child((PurpleBlistNode*)g));\n\t}\n\tcnode = (PurpleBlistNode *)c;\n\tif (bnode->parent) {\n\t\tif (PURPLE_BUDDY_IS_ONLINE(buddy)) {\n\t\t\t((PurpleContact*)bnode->parent)->online--;\n\t\t\tif (((PurpleContact*)bnode->parent)->online == 0)\n\t\t\t\t((PurpleGroup*)bnode->parent->parent)->online--;\n\t\t}\n\t\tif (purple_account_is_connected(buddy->account)) {\n\t\t\t((PurpleContact*)bnode->parent)->currentsize--;\n\t\t\tif (((PurpleContact*)bnode->parent)->currentsize == 0)\n\t\t\t\t((PurpleGroup*)bnode->parent->parent)->currentsize--;\n\t\t}\n\t\t((PurpleContact*)bnode->parent)->totalsize--;\n\t\t\n\t\tif (bnode->parent->parent != (PurpleBlistNode*)g) {\n\t\t\tpurple_signal_emit(purple_blist_get_handle(), \"buddy-removed-from-group\", buddy);\n\t\t\tserv_move_buddy(buddy, (PurpleGroup *)bnode->parent->parent, g);\n\t\t}\n\t\tif (bnode->next)\n\t\t\tbnode->next->prev = bnode->prev;\n\t\tif (bnode->prev)\n\t\t\tbnode->prev->next = bnode->next;\n\t\tif (bnode->parent->child == bnode)\n\t\t\tbnode->parent->child = bnode->next;\n\t\tif (ops && ops->remove)\n\t\t\tops->remove(purplebuddylist, bnode);\n\t\tif (bnode->parent->parent != (PurpleBlistNode*)g) {\n\t\t\tstruct _purple_hbuddy hb;\n\t\t\thb.name = (gchar *)purple_normalize(buddy->account, buddy->name);\n\t\t\thb.account = buddy->account;\n\t\t\thb.group = bnode->parent->parent;\n\t\t\tg_hash_table_remove(purplebuddylist->buddies, &hb);\n\t\t\taccount_buddies = g_hash_table_lookup(buddies_cache, buddy->account);\n\t\t\tg_hash_table_remove(account_buddies, &hb);\n\t\t}\n\t\tif (!bnode->parent->child) {\n\t\t\tpurple_blist_remove_contact((PurpleContact*)bnode->parent);\n\t\t} else {\n\t\t\tpurple_contact_invalidate_priority_buddy((PurpleContact*)bnode->parent);\n\t\t\tif (ops && ops->update)\n\t\t\t\tops->update(purplebuddylist, bnode->parent);\n\t\t}\n\t}\n\tif (node && PURPLE_BLIST_NODE_IS_BUDDY(node)) {\n\t\tif (node->next)\n\t\t\tnode->next->prev = bnode;\n\t\tbnode->next = node->next;\n\t\tbnode->prev = node;\n\t\tbnode->parent = node->parent;\n\t\tnode->next = bnode;\n\t} else {\n\t\tif (cnode->child)\n\t\t\tcnode->child->prev = bnode;\n\t\tbnode->prev = NULL;\n\t\tbnode->next = cnode->child;\n\t\tcnode->child = bnode;\n\t\tbnode->parent = cnode;\n\t}\n\tif (PURPLE_BUDDY_IS_ONLINE(buddy)) {\n\t\tif (++(PURPLE_CONTACT(bnode->parent)->online) == 1)\n\t\t\tPURPLE_GROUP(bnode->parent->parent)->online++;\n\t}\n\tif (purple_account_is_connected(buddy->account)) {\n\t\tif (++(PURPLE_CONTACT(bnode->parent)->currentsize) == 1)\n\t\t\tPURPLE_GROUP(bnode->parent->parent)->currentsize++;\n\t}\n\tPURPLE_CONTACT(bnode->parent)->totalsize++;\n\thb = g_new(struct _purple_hbuddy, 1);\n\thb->name = g_strdup(purple_normalize(buddy->account, buddy->name));\n\thb->account = buddy->account;\n\thb->group = ((PurpleBlistNode*)buddy)->parent->parent;\n\tg_hash_table_replace(purplebuddylist->buddies, hb, buddy);\n\taccount_buddies = g_hash_table_lookup(buddies_cache, buddy->account);\n\thb2 = g_new(struct _purple_hbuddy, 1);\n\thb2->name = g_strdup(hb->name);\n\thb2->account = buddy->account;\n\thb2->group = ((PurpleBlistNode*)buddy)->parent->parent;\n\tg_hash_table_replace(account_buddies, hb2, buddy);\n\tpurple_contact_invalidate_priority_buddy(purple_buddy_get_contact(buddy));\n\tif (ops && ops->save_node)\n\t\tops->save_node((PurpleBlistNode*) buddy);\n\tif (ops && ops->update)\n\t\tops->update(purplebuddylist, (PurpleBlistNode*)buddy);\n\t\n\tpurple_signal_emit(purple_blist_get_handle(), \"buddy-added\", buddy);\n\tpurple_signal_emit(purple_blist_get_handle(), \"blist-node-added\",\n\t\t\tPURPLE_BLIST_NODE(buddy));\n}\n", "bug_type": null, "idx": 1258}
{"project": "Pidgin", "target": 0, "func": "Suite*\nmaster_suite(void)\n{\n\tSuite *s = suite_create(\"Master Suite\");\n\treturn s;\n}\n", "bug_type": null, "idx": 1259}
{"project": "Pidgin", "target": 0, "func": "gboolean\npurple_certificate_check_signature_chain_with_failing(GList *chain,\n                                                      PurpleCertificate **failing)\n{\n\tGList *cur;\n\tPurpleCertificate *crt, *issuer;\n\tgchar *uid;\n\ttime_t now, activation, expiration;\n\tgboolean ret;\n\tg_return_val_if_fail(chain, FALSE);\n\tif (failing)\n\t\t*failing = NULL;\n\tuid = purple_certificate_get_unique_id((PurpleCertificate *) chain->data);\n\tpurple_debug_info(\"certificate\",\n\t\t\t  \"Checking signature chain for uid=%s\\n\",\n\t\t\t  uid);\n\tg_free(uid);\n\t\n\tif (chain->next == NULL) {\n\t\tpurple_debug_info(\"certificate\",\n\t\t\t\t  \"...Singleton. We'll say it's valid.\\n\");\n\t\treturn TRUE;\n\t}\n\tnow = time(NULL);\n\t\n\tcrt = (PurpleCertificate *)(chain->data);\n\t\n\tfor ( cur = chain->next; cur; cur = cur->next ) {\n\t\tissuer = (PurpleCertificate *)(cur->data);\n\t\tuid = purple_certificate_get_unique_id(issuer);\n\t\tret = purple_certificate_get_times(issuer, &activation, &expiration);\n\t\tif (!ret || now < activation || now > expiration) {\n\t\t\tif (!ret)\n\t\t\t\tpurple_debug_error(\"certificate\",\n\t\t\t\t\t\t\"...Failed to get validity times for certificate %s\\n\"\n\t\t\t\t\t\t\"Chain is INVALID\\n\", uid);\n\t\t\telse if (now > expiration)\n\t\t\t\tpurple_debug_error(\"certificate\",\n\t\t\t\t\t\t\"...Issuer %s expired at %s\\nChain is INVALID\\n\",\n\t\t\t\t\t\tuid, ctime(&expiration));\n\t\t\telse\n\t\t\t\tpurple_debug_error(\"certificate\",\n\t\t\t\t\t\t\"...Not-yet-activated issuer %s will be valid at %s\\n\"\n\t\t\t\t\t\t\"Chain is INVALID\\n\", uid, ctime(&activation));\n\t\t\tif (failing)\n\t\t\t\t*failing = crt;\n\t\t\tg_free(uid);\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\tif (! purple_certificate_signed_by(crt, issuer) ) {\n\t\t\tpurple_debug_error(\"certificate\",\n\t\t\t\t\t  \"...Bad or missing signature by %s\\nChain is INVALID\\n\",\n\t\t\t\t\t  uid);\n\t\t\tg_free(uid);\n\t\t\tif (failing)\n\t\t\t\t*failing = crt;\n\t\t\treturn FALSE;\n\t\t}\n\t\tpurple_debug_info(\"certificate\",\n\t\t\t\t  \"...Good signature by %s\\n\",\n\t\t\t\t  uid);\n\t\tg_free(uid);\n\t\t\n\t\tcrt = issuer;\n\t}\n\t\n\tpurple_debug_info(\"certificate\", \"Chain is VALID\\n\");\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1260}
{"project": "Pidgin", "target": 0, "func": "PurpleConversationType\npurple_conversation_get_type(const PurpleConversation *conv)\n{\n\tg_return_val_if_fail(conv != NULL, PURPLE_CONV_TYPE_UNKNOWN);\n\treturn conv->type;\n}\n", "bug_type": null, "idx": 1261}
{"project": "Pidgin", "target": 0, "func": "static void\nfree_conv_urls(PurpleConversation *conv)\n{\n\tGList *urls = purple_conversation_get_data(conv, \"TinyURLs\");\n\tif (urls)\n\t\tg_list_foreach(urls, free_urls, NULL);\n\tg_list_free(urls);\n}\n", "bug_type": null, "idx": 1262}
{"project": "Pidgin", "target": 0, "func": "static void\ngeneric_response_start(PidginRequestData *data)\n{\n\tg_return_if_fail(data != NULL);\n\t\n\tpidgin_set_cursor(GTK_WIDGET(data->dialog), GDK_WATCH);\n}\n", "bug_type": null, "idx": 1263}
{"project": "Pidgin", "target": 0, "func": "static int purple_parse_searcherror(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {\n\tva_list ap;\n\tchar *email;\n\tchar *buf;\n\tva_start(ap, fr);\n\temail = va_arg(ap, char *);\n\tva_end(ap);\n\tbuf = g_strdup_printf(_(\"No results found for email address %s\"), email);\n\tpurple_notify_error(od->gc, NULL, buf, NULL);\n\tg_free(buf);\n\treturn 1;\n}\n", "bug_type": null, "idx": 1264}
{"project": "Pidgin", "target": 0, "func": "static void\ndocklet_conv_updated_cb(PurpleConversation *conv, PurpleConvUpdateType type)\n{\n\tif (type == PURPLE_CONV_UPDATE_UNSEEN)\n\t\tdocklet_update_status();\n}\n", "bug_type": null, "idx": 1265}
{"project": "Pidgin", "target": 0, "func": "void jabber_roster_group_rename(PurpleConnection *gc, const char *old_name,\n\t\tPurpleGroup *group, GList *moved_buddies)\n{\n\tGList *l;\n\tconst char *gname = jabber_roster_group_get_global_name(group);\n\tfor(l = moved_buddies; l; l = l->next) {\n\t\tPurpleBuddy *buddy = l->data;\n\t\tjabber_roster_group_change(gc, purple_buddy_get_name(buddy), old_name, gname);\n\t}\n}\n", "bug_type": null, "idx": 1266}
{"project": "Pidgin", "target": 0, "func": "void jabber_iq_send(JabberIq *iq)\n{\n\tJabberIqCallbackData *jcd;\n\tg_return_if_fail(iq != NULL);\n\tjabber_send(iq->js, iq->node);\n\tif(iq->id && iq->callback) {\n\t\tjcd = g_new0(JabberIqCallbackData, 1);\n\t\tjcd->callback = iq->callback;\n\t\tjcd->data = iq->callback_data;\n\t\tjcd->to = jabber_id_new(xmlnode_get_attrib(iq->node, \"to\"));\n\t\tg_hash_table_insert(iq->js->iq_callbacks, g_strdup(iq->id), jcd);\n\t}\n\tjabber_iq_free(iq);\n}\n", "bug_type": null, "idx": 1267}
{"project": "Pidgin", "target": 0, "func": "static gboolean\nstatus_window_destroy_cb(GtkWidget *widget, GdkEvent *event, gpointer user_data)\n{\n\tStatusWindow *dialog = user_data;\n\tdialog->window = NULL;\n\tpidgin_status_window_hide();\n\treturn FALSE;\n}\n", "bug_type": null, "idx": 1268}
{"project": "Pidgin", "target": 0, "func": "static void\ngot_attention_cb(PurpleAccount *account, const char *who,\n\tPurpleConversation *conv, guint type, PurpleSoundEventID event)\n{\n\tplay_conv_event(conv, event);\n}\n", "bug_type": null, "idx": 1269}
{"project": "Pidgin", "target": 0, "func": "void\npurple_account_notify_added(PurpleAccount *account, const char *remote_user,\n                          const char *id, const char *alias,\n                          const char *message)\n{\n\tPurpleAccountUiOps *ui_ops;\n\tg_return_if_fail(account     != NULL);\n\tg_return_if_fail(remote_user != NULL);\n\tui_ops = purple_accounts_get_ui_ops();\n\tif (ui_ops != NULL && ui_ops->notify_added != NULL)\n\t\tui_ops->notify_added(account, remote_user, id, alias, message);\n}\n", "bug_type": null, "idx": 1270}
{"project": "Pidgin", "target": 0, "func": "static GtkWidget *\ncreate_choice_field(PurpleRequestField *field)\n{\n\tGtkWidget *widget;\n\tGList *labels = purple_request_field_choice_get_labels(field);\n\tint num_labels = g_list_length(labels);\n\tGList *l;\n\tif (num_labels > 5)\n\t{\n\t\twidget = gtk_combo_box_new_text();\n\t\tfor (l = labels; l != NULL; l = l->next)\n\t\t{\n\t\t\tconst char *text = l->data;\n\t\t\tgtk_combo_box_append_text(GTK_COMBO_BOX(widget), text);\n\t\t}\n\t\tgtk_combo_box_set_active(GTK_COMBO_BOX(widget),\n\t\t\t\t\t\tpurple_request_field_choice_get_default_value(field));\n\t\tg_signal_connect(G_OBJECT(widget), \"changed\",\n\t\t\t\t\t\t G_CALLBACK(field_choice_menu_cb), field);\n\t}\n\telse\n\t{\n\t\tGtkWidget *box;\n\t\tGtkWidget *first_radio = NULL;\n\t\tGtkWidget *radio;\n\t\tgint i;\n\t\tif (num_labels == 2)\n\t\t\tbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);\n\t\telse\n\t\t\tbox = gtk_vbox_new(FALSE, 0);\n\t\twidget = box;\n\t\tfor (l = labels, i = 0; l != NULL; l = l->next, i++)\n\t\t{\n\t\t\tconst char *text = l->data;\n\t\t\tradio = gtk_radio_button_new_with_label_from_widget(\n\t\t\t\tGTK_RADIO_BUTTON(first_radio), text);\n\t\t\tif (first_radio == NULL)\n\t\t\t\tfirst_radio = radio;\n\t\t\tif (i == purple_request_field_choice_get_default_value(field))\n\t\t\t\tgtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio), TRUE);\n\t\t\tgtk_box_pack_start(GTK_BOX(box), radio, TRUE, TRUE, 0);\n\t\t\tgtk_widget_show(radio);\n\t\t\tg_signal_connect(G_OBJECT(radio), \"toggled\",\n\t\t\t\t\t\t\t G_CALLBACK(field_choice_option_cb), field);\n\t\t}\n\t}\n\treturn widget;\n}\n", "bug_type": null, "idx": 1271}
{"project": "Pidgin", "target": 0, "func": "static PurpleConversation *\nfind_conversation_with_buddy(PurpleBuddy *buddy)\n{\n\tPidginBlistNode *ui = purple_blist_node_get_ui_data(PURPLE_BLIST_NODE(buddy));\n\tif (ui)\n\t\treturn ui->conv.conv;\n\treturn purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM,\n\t\t\t\t\t\t\t\t\t     purple_buddy_get_name(buddy),\n\t\t\t\t\t\t\t\t\t     purple_buddy_get_account(buddy));\n}\n", "bug_type": null, "idx": 1272}
{"project": "Pidgin", "target": 0, "func": "static void\nrequest_deny_cb(void *data)\n{\n\tPurpleAccountRequestInfo *info = data;\n\thandles = g_list_remove(handles, info);\n\tif (info->deny_cb != NULL)\n\t\tinfo->deny_cb(info->userdata);\n\tpurple_signal_emit(purple_accounts_get_handle(),\n\t\t\t\"account-authorization-denied\", info->account, info->user);\n\tpurple_account_request_info_unref(info);\n}\n", "bug_type": null, "idx": 1273}
{"project": "Pidgin", "target": 0, "func": "static PurpleCipherBatchMode\ndes3_get_batch(PurpleCipherContext *context)\n{\n\tstruct _des3_ctx *ctx = purple_cipher_context_get_data(context);\n\treturn ctx->mode;\n}\n", "bug_type": null, "idx": 1274}
{"project": "Pidgin", "target": 0, "func": "static void\nplugin_action_test_cb (PurplePluginAction * action)\n{\n\tpurple_notify_message (helloworld_plugin, PURPLE_NOTIFY_MSG_INFO,\n\t\t\"Plugin Actions Test\", \"This is a plugin actions test :)\", NULL, NULL,\n\t\tNULL);\n}\n", "bug_type": null, "idx": 1275}
{"project": "Pidgin", "target": 0, "func": "static void\npidgin_media_mute_toggled(GtkToggleButton *toggle, PidginMedia *media)\n{\n\tpurple_media_stream_info(media->priv->media,\n\t\t\tgtk_toggle_button_get_active(toggle) ?\n\t\t\tPURPLE_MEDIA_INFO_MUTE : PURPLE_MEDIA_INFO_UNMUTE,\n\t\t\tNULL, NULL, TRUE);\n}\n", "bug_type": null, "idx": 1276}
{"project": "Pidgin", "target": 0, "func": "static void read_input(struct irc_conn *irc, int len)\n{\n\tchar *cur, *end;\n\tirc->account->gc->last_received = time(NULL);\n\tirc->inbufused += len;\n\tirc->inbuf[irc->inbufused] = '\\0';\n\tcur = irc->inbuf;\n\t\n\twhile ((cur < (irc->inbuf + irc->inbufused)) && !*cur)\n\t\tcur++;\n\twhile (cur < irc->inbuf + irc->inbufused &&\n\t       ((end = strstr(cur, \"\\r\\n\")) || (end = strstr(cur, \"\\n\")))) {\n\t\tint step = (*end == '\\r' ? 2 : 1);\n\t\t*end = '\\0';\n\t\tirc_parse_msg(irc, cur);\n\t\tcur = end + step;\n\t}\n\tif (cur != irc->inbuf + irc->inbufused) { \n\t\tirc->inbufused -= (cur - irc->inbuf);\n\t\tmemmove(irc->inbuf, cur, irc->inbufused);\n\t} else {\n\t\tirc->inbufused = 0;\n\t}\n}\n", "bug_type": null, "idx": 1277}
{"project": "Pidgin", "target": 0, "func": "static void\nssl_gnutls_close(PurpleSslConnection *gsc)\n{\n\tPurpleSslGnutlsData *gnutls_data = PURPLE_SSL_GNUTLS_DATA(gsc);\n\tif(!gnutls_data)\n\t\treturn;\n\tif(gnutls_data->handshake_handler)\n\t\tpurple_input_remove(gnutls_data->handshake_handler);\n\tif (gnutls_data->handshake_timer)\n\t\tpurple_timeout_remove(gnutls_data->handshake_timer);\n\tgnutls_bye(gnutls_data->session, GNUTLS_SHUT_RDWR);\n\tgnutls_deinit(gnutls_data->session);\n\tg_free(gnutls_data);\n\tgsc->private_data = NULL;\n}\n", "bug_type": null, "idx": 1278}
{"project": "Pidgin", "target": 0, "func": " ******************************************/\nstatic void sort_method_none(PurpleBlistNode *node, PurpleBuddyList *blist, GtkTreeIter parent_iter, GtkTreeIter *cur, GtkTreeIter *iter)\n{\n\tPurpleBlistNode *sibling = node->prev;\n\tGtkTreeIter sibling_iter;\n\tif (cur != NULL) {\n\t\t*iter = *cur;\n\t\treturn;\n\t}\n\twhile (sibling && !get_iter_from_node(sibling, &sibling_iter)) {\n\t\tsibling = sibling->prev;\n\t}\n\tgtk_tree_store_insert_after(gtkblist->treemodel, iter,\n\t\t\tnode->parent ? &parent_iter : NULL,\n\t\t\tsibling ? &sibling_iter : NULL);\n}\n", "bug_type": null, "idx": 1279}
{"project": "Pidgin", "target": 0, "func": "static GstElement *\ncreate_audio_sink(PurpleMedia *media,\n\t\tconst gchar *session_id, const gchar *participant)\n{\n\tconst gchar *plugin = purple_prefs_get_string(\n\t\t\t\"/plugins/core/vvconfig/audio/sink/plugin\");\n\tconst gchar *device = purple_prefs_get_string(\n\t\t\t\"/plugins/core/vvconfig/audio/sink/device\");\n\tGstElement *ret;\n\tif (plugin[0] == '\\0')\n\t\treturn purple_media_element_info_call_create(old_audio_sink,\n\t\t\t\tmedia, session_id, participant);\n\tret = gst_element_factory_make(plugin, NULL);\n\tif (device[0] != '\\0')\n\t\tg_object_set(G_OBJECT(ret), \"device\", device, NULL);\n\treturn ret;\n}\n", "bug_type": null, "idx": 1280}
{"project": "Pidgin", "target": 0, "func": "static void\nchat_joined_cb(PurpleConversation *conv, void *data)\n{\n\tpurple_debug_misc(\"signals test\", \"chat-joined (%s)\\n\",\n\t\t\t\t\tpurple_conversation_get_name(conv));\n}\n", "bug_type": null, "idx": 1281}
{"project": "Pidgin", "target": 0, "func": "aim_userinfo_t *aim_locate_finduserinfo(OscarData *od, const char *bn) {\n\taim_userinfo_t *cur = NULL;\n\tif (bn == NULL)\n\t\treturn NULL;\n\tcur = od->locate.userinfo;\n\twhile (cur != NULL) {\n\t\tif (oscar_util_name_compare(cur->bn, bn) == 0)\n\t\t\treturn cur;\n\t\tcur = cur->next;\n\t}\n\treturn NULL;\n}\n", "bug_type": null, "idx": 1282}
{"project": "Pidgin", "target": 0, "func": "static void\nreally_delete_account(PurpleAccount *account)\n{\n\tGList *iter;\n\tfor (iter = accountdialogs; iter; iter = iter->next)\n\t{\n\t\tAccountEditDialog *dlg = iter->data;\n\t\tif (dlg->account == account)\n\t\t{\n\t\t\tgnt_widget_destroy(dlg->window);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpurple_request_close_with_handle(account); \n\tpurple_accounts_delete(account);\n}\n", "bug_type": null, "idx": 1283}
{"project": "Pidgin", "target": 0, "func": "static void iq_clicked_cb(GtkWidget *w, gpointer nul)\n{\n\tGtkWidget *vbox, *hbox, *to_entry, *label, *type_combo;\n\tGtkSizeGroup *sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);\n\tGtkTextIter iter;\n\tGtkTextBuffer *buffer;\n\tconst char *to;\n\tint result;\n\tchar *stanza;\n\tGtkWidget *dialog = gtk_dialog_new_with_buttons(\"<iq/>\",\n\t\t\t\t\t\t\tGTK_WINDOW(console->window),\n\t\t\t\t\t\t\tGTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\t\t\tGTK_STOCK_CANCEL,\n\t\t\t\t\t\t\tGTK_RESPONSE_REJECT,\n\t\t\t\t\t\t\tGTK_STOCK_OK,\n\t\t\t\t\t\t\tGTK_RESPONSE_ACCEPT,\n\t\t\t\t\t\t\tNULL);\n\tgtk_dialog_set_has_separator(GTK_DIALOG(dialog), FALSE);\n\tgtk_dialog_set_default_response (GTK_DIALOG(dialog), GTK_RESPONSE_ACCEPT);\n\tgtk_container_set_border_width(GTK_CONTAINER(dialog), 12);\n#if GTK_CHECK_VERSION(2,14,0)\n\tvbox = gtk_dialog_get_content_area(GTK_DIALOG(dialog));\n#else\n\tvbox = GTK_DIALOG(dialog)->vbox;\n#endif\n\thbox = gtk_hbox_new(FALSE, 3);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlabel = gtk_label_new(\"To:\");\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);\n\tgtk_size_group_add_widget(sg, label);\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\tto_entry = gtk_entry_new();\n\tgtk_entry_set_activates_default (GTK_ENTRY (to_entry), TRUE);\n\tgtk_box_pack_start(GTK_BOX(hbox), to_entry, FALSE, FALSE, 0);\n\thbox = gtk_hbox_new(FALSE, 3);\n\tgtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\n\tlabel = gtk_label_new(\"Type:\");\n\tgtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);\n\tgtk_size_group_add_widget(sg, label);\n\tgtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\n\ttype_combo = gtk_combo_box_new_text();\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"get\");\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"set\");\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"result\");\n\tgtk_combo_box_append_text(GTK_COMBO_BOX(type_combo), \"error\");\n\tgtk_combo_box_set_active(GTK_COMBO_BOX(type_combo), 0);\n\tgtk_box_pack_start(GTK_BOX(hbox), type_combo, FALSE, FALSE, 0);\n\tgtk_widget_show_all(vbox);\n\tresult = gtk_dialog_run(GTK_DIALOG(dialog));\n\tif (result != GTK_RESPONSE_ACCEPT) {\n\t\tgtk_widget_destroy(dialog);\n\t\treturn;\n\t}\n\tto = gtk_entry_get_text(GTK_ENTRY(to_entry));\n\tstanza = g_strdup_printf(\"<iq %s%s%s id='console%x' type='%s'></iq>\",\n\t\t\t\t to && *to ? \"to='\" : \"\",\n\t\t\t\t to && *to ? to : \"\",\n\t\t\t\t to && *to ? \"'\" : \"\",\n\t\t\t\t g_random_int(),\n\t\t\t\t gtk_combo_box_get_active_text(GTK_COMBO_BOX(type_combo)));\n\tbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(console->entry));\n\tgtk_text_buffer_set_text(buffer, stanza, -1);\n\tgtk_text_buffer_get_iter_at_offset(buffer, &iter, strstr(stanza, \"</iq>\") - stanza);\n\tgtk_text_buffer_place_cursor(buffer, &iter);\n\tg_free(stanza);\n\tgtk_widget_destroy(dialog);\n\tg_object_unref(sg);\n}\n", "bug_type": null, "idx": 1284}
{"project": "Pidgin", "target": 0, "func": "gboolean jabber_send_attention(PurpleConnection *gc, const char *username, guint code)\n{\n\tJabberStream *js = gc->proto_data;\n\tgchar *error = NULL;\n\tif (!_jabber_send_buzz(js, username, &error)) {\n\t\tPurpleAccount *account = purple_connection_get_account(gc);\n\t\tPurpleConversation *conv =\n\t\t\tpurple_find_conversation_with_account(PURPLE_CONV_TYPE_ANY, username, account);\n\t\tpurple_debug_error(\"jabber\", \"jabber_send_attention: jabber_cmd_buzz failed with error: %s\\n\", error ? error : \"(NULL)\");\n\t\tif (conv) {\n\t\t\tpurple_conversation_write(conv, username, error, PURPLE_MESSAGE_ERROR,\n\t\t\t    time(NULL));\n\t\t}\n\t\tg_free(error);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n", "bug_type": null, "idx": 1285}
{"project": "Pidgin", "target": 0, "func": "PurpleMediaElementType\npurple_media_element_info_get_element_type(PurpleMediaElementInfo *info)\n{\n#ifdef USE_VV\n\tPurpleMediaElementType type;\n\tg_return_val_if_fail(PURPLE_IS_MEDIA_ELEMENT_INFO(info),\n\t\t\tPURPLE_MEDIA_ELEMENT_NONE);\n\tg_object_get(info, \"type\", &type, NULL);\n\treturn type;\n#else\n\treturn PURPLE_MEDIA_ELEMENT_NONE;\n#endif\n}\n", "bug_type": null, "idx": 1286}
{"project": "Pidgin", "target": 0, "func": "static void\nicon_check_cb(GtkWidget *checkbox, AccountPrefsDialog *dialog)\n{\n\tgtk_widget_set_sensitive(dialog->icon_hbox, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(dialog->icon_check)));\n}\n", "bug_type": null, "idx": 1287}
{"project": "Pidgin", "target": 0, "func": "static GList *ggp_chat_info(PurpleConnection *gc)\n{\n\tGList *m = NULL;\n\tstruct proto_chat_entry *pce;\n\tpce = g_new0(struct proto_chat_entry, 1);\n\tpce->label = _(\"Chat _name:\");\n\tpce->identifier = \"name\";\n\tpce->required = TRUE;\n\tm = g_list_append(m, pce);\n\treturn m;\n}\n", "bug_type": null, "idx": 1288}
{"project": "Pidgin", "target": 0, "func": "PurpleSslConnection *\npurple_ssl_connect_with_host_fd(PurpleAccount *account, int fd,\n                      PurpleSslInputFunction func,\n                      PurpleSslErrorFunction error_func,\n                      const char *host,\n                      void *data)\n{\n\tPurpleSslConnection *gsc;\n\tPurpleSslOps *ops;\n\tg_return_val_if_fail(fd != -1,                NULL);\n\tg_return_val_if_fail(func != NULL,            NULL);\n\tg_return_val_if_fail(purple_ssl_is_supported(), NULL);\n\tif (!_ssl_initialized)\n\t{\n\t\tif (!ssl_init())\n\t\t\treturn NULL;\n\t}\n\tgsc = g_new0(PurpleSslConnection, 1);\n\tgsc->connect_cb_data = data;\n\tgsc->connect_cb      = func;\n\tgsc->error_cb        = error_func;\n\tgsc->fd              = fd;\n\tif (host) {\n\t\tgsc->host = g_strdup(host);\n\t}\n\t\n\tgsc->verifier = purple_certificate_find_verifier(\"x509\",\"tls_cached\");\n\tops = purple_ssl_get_ops();\n\tops->connectfunc(gsc);\n\treturn (PurpleSslConnection *)gsc;\n}\n", "bug_type": null, "idx": 1289}
{"project": "Pidgin", "target": 0, "func": "static void\njingle_iceudp_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)\n{\n\tJingleIceUdp *iceudp;\n\tg_return_if_fail(object != NULL);\n\tg_return_if_fail(JINGLE_IS_ICEUDP(object));\n\ticeudp = JINGLE_ICEUDP(object);\n\tswitch (prop_id) {\n\t\tcase PROP_LOCAL_CANDIDATES:\n\t\t\ticeudp->priv->local_candidates =\n\t\t\t\t\tg_value_get_pointer(value);\n\t\t\tbreak;\n\t\tcase PROP_REMOTE_CANDIDATES:\n\t\t\ticeudp->priv->remote_candidates =\n\t\t\t\t\tg_value_get_pointer(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tG_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n\t\t\tbreak;\n\t}\n}\n", "bug_type": null, "idx": 1290}
{"project": "Pidgin", "target": 0, "func": "void gnt_tree_sort_row(GntTree *tree, gpointer key)\n{\n\tGntTreeRow *row, *q, *s;\n\tint current, newp;\n\tif (!tree->priv->compare)\n\t\treturn;\n\trow = g_hash_table_lookup(tree->hash, key);\n\tg_return_if_fail(row != NULL);\n\tcurrent = g_list_index(tree->list, key);\n\tif (row->parent)\n\t\ts = row->parent->child;\n\telse\n\t\ts = tree->root;\n\tq = NULL;\n\twhile (s) {\n\t\tif (tree->priv->compare(row->key, s->key) < 0)\n\t\t\tbreak;\n\t\tq = s;\n\t\ts = s->next;\n\t}\n\t\n\tif (row == q || row == s)\n\t\treturn;\n\tif (q == NULL) {\n\t\t\n\t\trow->prev->next = row->next;  \n\t\tif (row->next)\n\t\t\trow->next->prev = row->prev;\n\t\tif (row->parent)\n\t\t\trow->parent->child = row;\n\t\telse\n\t\t\ttree->root = row;\n\t\trow->next = s;\n\t\ts->prev = row;  \n\t\trow->prev = NULL;\n\t\tnewp = g_list_index(tree->list, s) - 1;\n\t} else {\n\t\tif (row->prev) {\n\t\t\trow->prev->next = row->next;\n\t\t} else {\n\t\t\t\n\t\t\tif (row->parent)\n\t\t\t\trow->parent->child = row->next;\n\t\t\telse\n\t\t\t\ttree->top = row->next;\n\t\t}\n\t\tif (row->next)\n\t\t\trow->next->prev = row->prev;\n\t\tq->next = row;\n\t\trow->prev = q;\n\t\tif (s)\n\t\t\ts->prev = row;\n\t\trow->next = s;\n\t\tnewp = g_list_index(tree->list, q) + 1;\n\t}\n\ttree->list = g_list_reposition_child(tree->list, current, newp);\n\tredraw_tree(tree);\n}\n", "bug_type": null, "idx": 1291}
{"project": "Pidgin", "target": 0, "func": " */\nstatic int gg_session_handle_send_msg_ack_110(struct gg_session *gs,\n\tuint32_t type, const char *ptr, size_t len, struct gg_event *ge)\n{\n\tstruct gg_session_private *p = gs->private_data;\n\tGG110MessageAck *msg = gg110_message_ack__unpack(NULL, len, (uint8_t*)ptr);\n\tsize_t i;\n\tif (!GG_PROTOBUF_VALID(gs, \"GG110MessageAck\", msg))\n\t\treturn -1;\n\tif (msg->dummy1 == 0x4000) {\n\t\t\n\t\tgg_debug_session(gs, GG_DEBUG_MISC | GG_DEBUG_WARNING,\n\t\t\t\"// gg_session_handle_send_msg_ack_110() magic dummy1 \"\n\t\t\t\"value 0x4000\\n\");\n\t} else if (msg->dummy1 != 0) {\n\t\tgg_debug_session(gs, GG_DEBUG_MISC | GG_DEBUG_WARNING,\n\t\t\t\"// gg_session_handle_send_msg_ack_110() unknown dummy1 \"\n\t\t\t\"value: %x\\n\", msg->dummy1);\n\t}\n\tgg_debug_session(gs, GG_DEBUG_VERBOSE,\n\t\t\"// gg_session_handle_send_msg_ack_110() \"\n\t\t\"%s=%016\" PRIx64 \" %s=%016\" PRIx64 \"\\n\",\n\t\tmsg->has_msg_id ? \"msg_id\" : \"0\", msg->msg_id,\n\t\tmsg->has_conv_id ? \"conv_id\" : \"0\", msg->conv_id);\n\tfor (i = 0; i < msg->n_links; i++) {\n\t\tGG110MessageAckLink *link = msg->links[i];\n\t\tif (!GG_PROTOBUF_VALID(gs, \"GG110MessageAckLink\", link))\n\t\t\tcontinue;\n\t\tgg_debug_session(gs, GG_DEBUG_MISC,\n\t\t\t\"// gg_session_handle_send_msg_ack_110() \"\n\t\t\t\"got link (id=%\" PRIx64 \") \\\"%s\\\"\\n\", link->id, link->url);\n\t}\n\tge->type = GG_EVENT_ACK110;\n\tge->event.ack110.msg_type = msg->msg_type;\n\tge->event.ack110.seq = msg->seq;\n\tge->event.ack110.time = msg->time;\n\tgg_compat_message_ack(gs, msg->seq);\n\tgg110_message_ack__free_unpacked(msg, NULL);\n\tif (msg->seq == 0 && p->imgout_waiting_ack > 0)\n\t\tp->imgout_waiting_ack--;\n\tgg_image_sendout(gs);\n\treturn 0;\n}\n", "bug_type": null, "idx": 1292}
{"project": "Pidgin", "target": 0, "func": "void\npidgin_blist_theme_set_expanded_text_info(PidginBlistTheme *theme, const PidginThemeFont *pair)\n{\n\tPidginBlistThemePrivate *priv;\n\tg_return_if_fail(PIDGIN_IS_BLIST_THEME(theme));\n\tpriv = PIDGIN_BLIST_THEME_GET_PRIVATE(G_OBJECT(theme));\n\tpidgin_theme_font_free(priv->expanded);\n\tpriv->expanded = copy_font_and_color(pair);\n}\n", "bug_type": null, "idx": 1293}
{"project": "Pidgin", "target": 0, "func": "static void\nupdate_to_reflect_account_status(PidginStatusBox *status_box, PurpleAccount *account, PurpleStatus *newstatus)\n{\n\tGList *l;\n\tint status_no = -1;\n\tconst PurpleStatusType *statustype = NULL;\n\tconst char *message;\n\tstatustype = purple_status_type_find_with_id((GList *)purple_account_get_status_types(account),\n\t                                           (char *)purple_status_type_get_id(purple_status_get_type(newstatus)));\n\tfor (l = purple_account_get_status_types(account); l != NULL; l = l->next) {\n\t\tPurpleStatusType *status_type = (PurpleStatusType *)l->data;\n\t\tif (!purple_status_type_is_user_settable(status_type) ||\n\t\t\t\tpurple_status_type_is_independent(status_type))\n\t\t\tcontinue;\n\t\tstatus_no++;\n\t\tif (statustype == status_type)\n\t\t\tbreak;\n\t}\n\tgtk_imhtml_set_populate_primary_clipboard(\n\t\tGTK_IMHTML(status_box->imhtml), TRUE);\n\tif (status_no != -1) {\n\t\tGtkTreePath *path;\n\t\tgtk_widget_set_sensitive(GTK_WIDGET(status_box), FALSE);\n\t\tpath = gtk_tree_path_new_from_indices(status_no, -1);\n\t\tif (status_box->active_row)\n\t\t\tgtk_tree_row_reference_free(status_box->active_row);\n\t\tstatus_box->active_row = gtk_tree_row_reference_new(GTK_TREE_MODEL(status_box->dropdown_store), path);\n\t\tgtk_tree_path_free(path);\n\t\tmessage = purple_status_get_attr_string(newstatus, \"message\");\n\t\tif (!message || !*message)\n\t\t{\n\t\t\tgtk_widget_hide_all(status_box->vbox);\n\t\t\tstatus_box->imhtml_visible = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgtk_widget_show_all(status_box->vbox);\n\t\t\tstatus_box->imhtml_visible = TRUE;\n\t\t\tgtk_imhtml_clear(GTK_IMHTML(status_box->imhtml));\n\t\t\tgtk_imhtml_clear_formatting(GTK_IMHTML(status_box->imhtml));\n\t\t\tgtk_imhtml_append_text(GTK_IMHTML(status_box->imhtml), message, 0);\n\t\t}\n\t\tgtk_widget_set_sensitive(GTK_WIDGET(status_box), TRUE);\n\t\tpidgin_status_box_refresh(status_box);\n\t}\n}\n", "bug_type": null, "idx": 1294}
{"project": "Pidgin", "target": 0, "func": "#include \"status.h\"\nstatic void jabber_nick_cb(JabberStream *js, const char *from, xmlnode *items) {\n\t\n\txmlnode *item = xmlnode_get_child(items, \"item\");\n\tJabberBuddy *buddy = jabber_buddy_find(js, from, FALSE);\n\txmlnode *nick;\n\tchar *nickname = NULL;\n\t\n\tif (!buddy || !item)\n\t\treturn;\n\tnick = xmlnode_get_child_with_namespace(item, \"nick\", \"http://jabber.org/protocol/nick\");\n\tif (!nick)\n\t\treturn;\n\tnickname = xmlnode_get_data(nick);\n\tserv_got_alias(js->gc, from, nickname);\n\tg_free(nickname);\n}\n", "bug_type": null, "idx": 1295}
{"project": "Pidgin", "target": 0, "func": "unsigned int\npurple_request_field_image_get_scale_y(PurpleRequestField *field)\n{\n\tg_return_val_if_fail(field != NULL, 0);\n\tg_return_val_if_fail(field->type == PURPLE_REQUEST_FIELD_IMAGE, 0);\n\treturn field->u.image.scale_y;\n}\n", "bug_type": null, "idx": 1296}
{"project": "Pidgin", "target": 0, "func": "static xmlnode *\nchat_to_xmlnode(PurpleBlistNode *cnode)\n{\n\txmlnode *node, *child;\n\tPurpleChat *chat;\n\tchat = (PurpleChat *)cnode;\n\tnode = xmlnode_new(\"chat\");\n\txmlnode_set_attrib(node, \"proto\", purple_account_get_protocol_id(chat->account));\n\txmlnode_set_attrib(node, \"account\", purple_account_get_username(chat->account));\n\tif (chat->alias != NULL)\n\t{\n\t\tchild = xmlnode_new_child(node, \"alias\");\n\t\txmlnode_insert_data(child, chat->alias, -1);\n\t}\n\t\n\tg_hash_table_foreach(chat->components, chat_component_to_xmlnode, node);\n\t\n\tg_hash_table_foreach(chat->node.settings, value_to_xmlnode, node);\n\treturn node;\n}\n", "bug_type": null, "idx": 1297}
