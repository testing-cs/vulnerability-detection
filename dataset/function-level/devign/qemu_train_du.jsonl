{"project": "qemu", "commit_id": "fa1298c2d623522eda7b4f1f721fcb935abb7360", "target": 1, "func": "static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n", "idx": 2131}
{"project": "qemu", "commit_id": "30aa5c0d303c334c646e9db1ebadda0c0db8b13f", "target": 1, "func": "static uint32_t nvram_readb (void *opaque, target_phys_addr_t addr)\r\n\n{\r\n\n    ds1225y_t *NVRAM = opaque;\r\n\n    int64_t pos;\r\n\n\r\n\n    pos = addr - NVRAM->mem_base;\r\n\n    if (addr >= NVRAM->capacity)\r\n\n        addr -= NVRAM->capacity;\r\n\n\r\n\n    if (!ds1225y_set_to_mode(NVRAM, readmode, \"rb\"))\r\n\n        return 0;\r\n\n    qemu_fseek(NVRAM->file, pos, SEEK_SET);\r\n\n    return (uint32_t)qemu_get_byte(NVRAM->file);\r\n\n}\r\n", "idx": 8356}
{"project": "qemu", "commit_id": "db486cc334aafd3dbdaf107388e37fc3d6d3e171", "target": 1, "func": "static gint range_compare(gconstpointer a, gconstpointer b)\n\n{\n\n    Range *ra = (Range *)a, *rb = (Range *)b;\n\n    if (ra->begin == rb->begin && ra->end == rb->end) {\n\n        return 0;\n\n    } else if (range_get_last(ra->begin, ra->end) <\n\n               range_get_last(rb->begin, rb->end)) {\n\n        return -1;\n\n    } else {\n\n        return 1;\n\n    }\n\n}\n", "idx": 1456}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n", "idx": 5613}
{"project": "qemu", "commit_id": "827b17c468b0dae69f82f852958d16f4bf6d6bf0", "target": 1, "func": "int spapr_h_cas_compose_response(sPAPRMachineState *spapr,\n                                 target_ulong addr, target_ulong size,\n                                 sPAPROptionVector *ov5_updates)\n{\n    void *fdt, *fdt_skel;\n    sPAPRDeviceTreeUpdateHeader hdr = { .version_id = 1 };\n    if (spapr_hotplugged_dev_before_cas()) {\n        return 1;\n    size -= sizeof(hdr);\n    /* Create skeleton */\n    fdt_skel = g_malloc0(size);\n    _FDT((fdt_create(fdt_skel, size)));\n    _FDT((fdt_begin_node(fdt_skel, \"\")));\n    _FDT((fdt_end_node(fdt_skel)));\n    _FDT((fdt_finish(fdt_skel)));\n    fdt = g_malloc0(size);\n    _FDT((fdt_open_into(fdt_skel, fdt, size)));\n    g_free(fdt_skel);\n    /* Fixup cpu nodes */\n    _FDT((spapr_fixup_cpu_dt(fdt, spapr)));\n    if (spapr_dt_cas_updates(spapr, fdt, ov5_updates)) {\n        return -1;\n    /* Pack resulting tree */\n    _FDT((fdt_pack(fdt)));\n    if (fdt_totalsize(fdt) + sizeof(hdr) > size) {\n        trace_spapr_cas_failed(size);\n        return -1;\n    cpu_physical_memory_write(addr, &hdr, sizeof(hdr));\n    cpu_physical_memory_write(addr + sizeof(hdr), fdt, fdt_totalsize(fdt));\n    trace_spapr_cas_continue(fdt_totalsize(fdt) + sizeof(hdr));\n    g_free(fdt);\n    return 0;", "idx": 6370}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n", "idx": 11895}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 1);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 10743}
{"project": "qemu", "commit_id": "aef4acb6616ab7fb5c105660aa8a2cee4e250e75", "target": 1, "func": "static int copy_sectors(BlockDriverState *bs, uint64_t start_sect,\n\n                        uint64_t cluster_offset, int n_start, int n_end)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int n, ret;\n\n    void *buf;\n\n\n\n    /*\n\n     * If this is the last cluster and it is only partially used, we must only\n\n     * copy until the end of the image, or bdrv_check_request will fail for the\n\n     * bdrv_read/write calls below.\n\n     */\n\n    if (start_sect + n_end > bs->total_sectors) {\n\n        n_end = bs->total_sectors - start_sect;\n\n    }\n\n\n\n    n = n_end - n_start;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, n * BDRV_SECTOR_SIZE);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_READ);\n\n    ret = bdrv_read(bs, start_sect + n_start, buf, n);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (s->crypt_method) {\n\n        qcow2_encrypt_sectors(s, start_sect + n_start,\n\n                        buf, buf, n, 1,\n\n                        &s->aes_encrypt_key);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_WRITE);\n\n    ret = bdrv_write(bs->file, (cluster_offset >> 9) + n_start, buf, n);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    qemu_vfree(buf);\n\n    return ret;\n\n}\n", "idx": 2712}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static void unix_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_un addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (unsigned long)opaque;\n\n    QEMUFile *f;\n\n    int c, ret;\n\n\n\n    do {\n\n        c = accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n\n\n    dprintf(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        return;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c);\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    ret = qemu_loadvm_state(f);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        goto out_fopen;\n\n    }\n\n    qemu_announce_self();\n\n    dprintf(\"successfully loaded vm state\\n\");\n\n\n\n    /* we've successfully migrated, close the server socket */\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    close(s);\n\n\n\nout_fopen:\n\n    qemu_fclose(f);\n\nout:\n\n    close(c);\n\n}\n", "idx": 524}
{"project": "qemu", "commit_id": "389775d1f67b2c8f44f9473b1e5363735972e389", "target": 1, "func": "MigrationState *migrate_init(const MigrationParams *params)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    int64_t bandwidth_limit = s->bandwidth_limit;\n\n    bool enabled_capabilities[MIGRATION_CAPABILITY_MAX];\n\n    int64_t xbzrle_cache_size = s->xbzrle_cache_size;\n\n    int compress_level = s->parameters[MIGRATION_PARAMETER_COMPRESS_LEVEL];\n\n    int compress_thread_count =\n\n            s->parameters[MIGRATION_PARAMETER_COMPRESS_THREADS];\n\n    int decompress_thread_count =\n\n            s->parameters[MIGRATION_PARAMETER_DECOMPRESS_THREADS];\n\n    int x_cpu_throttle_initial =\n\n            s->parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INITIAL];\n\n    int x_cpu_throttle_increment =\n\n            s->parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INCREMENT];\n\n\n\n    memcpy(enabled_capabilities, s->enabled_capabilities,\n\n           sizeof(enabled_capabilities));\n\n\n\n    memset(s, 0, sizeof(*s));\n\n    s->params = *params;\n\n    memcpy(s->enabled_capabilities, enabled_capabilities,\n\n           sizeof(enabled_capabilities));\n\n    s->xbzrle_cache_size = xbzrle_cache_size;\n\n\n\n    s->parameters[MIGRATION_PARAMETER_COMPRESS_LEVEL] = compress_level;\n\n    s->parameters[MIGRATION_PARAMETER_COMPRESS_THREADS] =\n\n               compress_thread_count;\n\n    s->parameters[MIGRATION_PARAMETER_DECOMPRESS_THREADS] =\n\n               decompress_thread_count;\n\n    s->parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INITIAL] =\n\n                x_cpu_throttle_initial;\n\n    s->parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INCREMENT] =\n\n                x_cpu_throttle_increment;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n    migrate_set_state(s, MIGRATION_STATUS_NONE, MIGRATION_STATUS_SETUP);\n\n\n\n    QSIMPLEQ_INIT(&s->src_page_requests);\n\n\n\n    s->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    return s;\n\n}\n", "idx": 6338}
{"project": "qemu", "commit_id": "6bf45d59f98c898b7d7997a333765c8ee41236ea", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n                                int64_t cluster_index, void **refcount_block)\n{\n    BDRVQcow2State *s = bs->opaque;\n    unsigned int refcount_table_index;\n    int64_t ret;\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n    /* Find the refcount block for the given cluster */\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n    if (refcount_table_index < s->refcount_table_size) {\n        uint64_t refcount_block_offset =\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n        /* If it's already there, we're done */\n        if (refcount_block_offset) {\n            if (offset_into_cluster(s, refcount_block_offset)) {\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n                                        PRIx64 \" unaligned (reftable index: \"\n                                        \"%#x)\", refcount_block_offset,\n                                        refcount_table_index);\n             return load_refcount_block(bs, refcount_block_offset,\n                                        refcount_block);\n    /*\n     * If we came here, we need to allocate something. Something is at least\n     * a cluster for the new refcount block. It may also include a new refcount\n     * table if the old refcount table is too small.\n     *\n     * Note that allocating clusters here needs some special care:\n     *\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n     *   increase the refcount and very likely we would end up with an endless\n     *   recursion. Instead we must place the refcount blocks in a way that\n     *   they can describe them themselves.\n     *\n     * - We need to consider that at this point we are inside update_refcounts\n     *   and potentially doing an initial refcount increase. This means that\n     *   some clusters have already been allocated by the caller, but their\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n     *   the search for free clusters.\n     *\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n     *   refcount block into the cache\n     */\n    *refcount_block = NULL;\n    /* We write to the refcount table, so we might depend on L2 tables */\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n    if (ret < 0) {\n        return ret;\n    /* Allocate the refcount block itself and mark it as used */\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n    if (new_block < 0) {\n        return new_block;\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n        \" at %\" PRIx64 \"\\n\",\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n#endif\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n        /* Zero the new refcount block before updating it */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n                                    refcount_block);\n        if (ret < 0) {\n            goto fail;\n        memset(*refcount_block, 0, s->cluster_size);\n        /* The block describes itself, need to update the cache */\n        int block_index = (new_block >> s->cluster_bits) &\n            (s->refcount_block_size - 1);\n        s->set_refcount(*refcount_block, block_index, 1);\n    } else {\n        /* Described somewhere else. This can recurse at most twice before we\n         * arrive at a block that describes itself. */\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n                              QCOW2_DISCARD_NEVER);\n        if (ret < 0) {\n            goto fail;\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n        if (ret < 0) {\n            goto fail;\n        /* Initialize the new refcount block only after updating its refcount,\n         * update_refcount uses the refcount cache itself */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n                                    refcount_block);\n        if (ret < 0) {\n            goto fail;\n        memset(*refcount_block, 0, s->cluster_size);\n    /* Now the new refcount block needs to be written to disk */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n    qcow2_cache_entry_mark_dirty(bs, s->refcount_block_cache, *refcount_block);\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail;\n    /* If the refcount table is big enough, just hook the block up there */\n    if (refcount_table_index < s->refcount_table_size) {\n        uint64_t data64 = cpu_to_be64(new_block);\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n        ret = bdrv_pwrite_sync(bs->file,\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n            &data64, sizeof(data64));\n        if (ret < 0) {\n            goto fail;\n        s->refcount_table[refcount_table_index] = new_block;\n        /* If there's a hole in s->refcount_table then it can happen\n         * that refcount_table_index < s->max_refcount_table_index */\n        s->max_refcount_table_index =\n            MAX(s->max_refcount_table_index, refcount_table_index);\n        /* The new refcount block may be where the caller intended to put its\n         * data, so let it restart the search. */\n        return -EAGAIN;\n    qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n    /*\n     * If we come here, we need to grow the refcount table. Again, a new\n     * refcount table needs some space and we can't simply allocate to avoid\n     * endless recursion.\n     *\n     * Therefore let's grab new refcount blocks at the end of the image, which\n     * will describe themselves and the new refcount table. This way we can\n     * reference them only in the new table and do the switch to the new\n     * refcount table at once without producing an inconsistent state in\n     * between.\n     */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n    /* Calculate the number of refcount blocks needed so far; this will be the\n     * basis for calculating the index of the first cluster used for the\n     * self-describing refcount structures which we are about to create.\n     *\n     * Because we reached this point, there cannot be any refcount entries for\n     * cluster_index or higher indices yet. However, because new_block has been\n     * allocated to describe that cluster (and it will assume this role later\n     * on), we cannot use that index; also, new_block may actually have a higher\n     * cluster index than cluster_index, so it needs to be taken into account\n     * here (and 1 needs to be added to its value because that cluster is used).\n     */\n    uint64_t blocks_used = DIV_ROUND_UP(MAX(cluster_index + 1,\n                                            (new_block >> s->cluster_bits) + 1),\n                                        s->refcount_block_size);\n    /* Create the new refcount table and blocks */\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n        s->cluster_size;\n    ret = qcow2_refcount_area(bs, meta_offset, 0, false,\n                              refcount_table_index, new_block);\n    if (ret < 0) {\n        return ret;\n    ret = load_refcount_block(bs, new_block, refcount_block);\n    if (ret < 0) {\n        return ret;\n    /* If we were trying to do the initial refcount update for some cluster\n     * allocation, we might have used the same clusters to store newly\n     * allocated metadata. Make the caller search some new space. */\n    return -EAGAIN;\nfail:\n    if (*refcount_block != NULL) {\n        qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n    return ret;", "idx": 4826}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_start_struct(Visitor *v, const char *name, void **obj,\n\n                                       size_t size, Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n\n\n    if (obj) {\n\n        *obj = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"QDict\");\n\n        return;\n\n    }\n\n\n\n    qobject_input_push(qiv, qobj, obj);\n\n\n\n    if (obj) {\n\n        *obj = g_malloc0(size);\n\n    }\n\n}\n", "idx": 2593}
{"project": "qemu", "commit_id": "089f26bb735fb414b79f5fa3753910d5339d2a1d", "target": 1, "func": "static void test_primitives(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    PrimitiveType *pt = args->test_data;\n\n    PrimitiveType *pt_copy = g_malloc0(sizeof(*pt_copy));\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n    char *double1, *double2;\n\n\n\n    pt_copy->type = pt->type;\n\n    ops->serialize(pt, &serialize_data, visit_primitive_type, &err);\n\n    ops->deserialize((void **)&pt_copy, serialize_data, visit_primitive_type, &err);\n\n\n\n    g_assert(err == NULL);\n\n    g_assert(pt_copy != NULL);\n\n    if (pt->type == PTYPE_STRING) {\n\n        g_assert_cmpstr(pt->value.string, ==, pt_copy->value.string);\n\n        g_free((char *)pt_copy->value.string);\n\n    } else if (pt->type == PTYPE_NUMBER) {\n\n        /* we serialize with %f for our reference visitors, so rather than fuzzy\n\n         * floating math to test \"equality\", just compare the formatted values\n\n         */\n\n        double1 = g_malloc0(calc_float_string_storage(pt->value.number));\n\n        double2 = g_malloc0(calc_float_string_storage(pt_copy->value.number));\n\n        g_assert_cmpstr(double1, ==, double2);\n\n        g_free(double1);\n\n        g_free(double2);\n\n    } else if (pt->type == PTYPE_BOOLEAN) {\n\n        g_assert_cmpint(!!pt->value.max, ==, !!pt->value.max);\n\n    } else {\n\n        g_assert_cmpint(pt->value.max, ==, pt_copy->value.max);\n\n    }\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n    g_free(pt_copy);\n\n}\n", "idx": 731}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void qvirtio_pci_set_status(QVirtioDevice *d, uint8_t status)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    qpci_io_writeb(dev->pdev, dev->addr + VIRTIO_PCI_STATUS, status);\n\n}\n", "idx": 95}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static BlockAIOCB *blkverify_aio_readv(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    BlkverifyAIOCB *acb = blkverify_aio_get(bs, false, sector_num, qiov,\n\n                                            nb_sectors, cb, opaque);\n\n\n\n    acb->verify = blkverify_verify_readv;\n\n    acb->buf = qemu_blockalign(bs->file->bs, qiov->size);\n\n    qemu_iovec_init(&acb->raw_qiov, acb->qiov->niov);\n\n    qemu_iovec_clone(&acb->raw_qiov, qiov, acb->buf);\n\n\n\n    bdrv_aio_readv(s->test_file, sector_num, qiov, nb_sectors,\n\n                   blkverify_aio_cb, acb);\n\n    bdrv_aio_readv(bs->file, sector_num, &acb->raw_qiov, nb_sectors,\n\n                   blkverify_aio_cb, acb);\n\n    return &acb->common;\n\n}\n", "idx": 12194}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "int qcow2_grow_l1_table(BlockDriverState *bs, int min_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int new_l1_size, new_l1_size2, ret, i;\n\n    uint64_t *new_l1_table;\n\n    int64_t new_l1_table_offset;\n\n    uint8_t data[12];\n\n\n\n    new_l1_size = s->l1_size;\n\n    if (min_size <= new_l1_size)\n\n        return 0;\n\n    if (new_l1_size == 0) {\n\n        new_l1_size = 1;\n\n    }\n\n    while (min_size > new_l1_size) {\n\n        new_l1_size = (new_l1_size * 3 + 1) / 2;\n\n    }\n\n#ifdef DEBUG_ALLOC2\n\n    printf(\"grow l1_table from %d to %d\\n\", s->l1_size, new_l1_size);\n\n#endif\n\n\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n\n    new_l1_table = qemu_mallocz(align_offset(new_l1_size2, 512));\n\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n\n\n    /* write new table (align to cluster) */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n\n    if (new_l1_table_offset < 0) {\n\n        qemu_free(new_l1_table);\n\n        return new_l1_table_offset;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n\n    ret = bdrv_pwrite(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n\n    if (ret != new_l1_size2)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n\n\n    /* set new table */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n\n    cpu_to_be64w((uint64_t*)(data + 4), new_l1_table_offset);\n\n    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n\n    if (ret != sizeof(data)) {\n\n        goto fail;\n\n    }\n\n    qemu_free(s->l1_table);\n\n    qcow2_free_clusters(bs, s->l1_table_offset, s->l1_size * sizeof(uint64_t));\n\n    s->l1_table_offset = new_l1_table_offset;\n\n    s->l1_table = new_l1_table;\n\n    s->l1_size = new_l1_size;\n\n    return 0;\n\n fail:\n\n    qemu_free(new_l1_table);\n\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2);\n\n    return ret < 0 ? ret : -EIO;\n\n}\n", "idx": 2703}
{"project": "qemu", "commit_id": "e92f0e1910f0655a0edd8d87c5a7262d36517a89", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_prw_vector(BdrvChild *child,\n\n                                          int64_t offset,\n\n                                          QEMUIOVector *qiov,\n\n                                          BdrvRequestFlags flags,\n\n                                          BlockCompletionFunc *cb,\n\n                                          void *opaque,\n\n                                          bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    /* Matched by bdrv_co_complete's bdrv_dec_in_flight.  */\n\n    bdrv_inc_in_flight(child->bs);\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.offset = offset;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw, acb);\n\n    qemu_coroutine_enter(co);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 8246}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_getattr(void *opaque)\n\n{\n\n    int32_t fid;\n\n    size_t offset = 7;\n\n    ssize_t retval = 0;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    uint64_t request_mask;\n\n    V9fsStatDotl v9stat_dotl;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    /*\n\n     * Currently we only support BASIC fields in stat, so there is no\n\n     * need to look at request_mask.\n\n     */\n\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (retval < 0) {\n\n        goto out;\n\n    }\n\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n\n\n    /*  fill st_gen if requested and supported by underlying fs */\n\n    if (request_mask & P9_STATS_GEN) {\n\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n\n        if (retval < 0) {\n\n            goto out;\n\n        }\n\n        v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n\n                              v9stat_dotl.st_gid);\n\n\n\n    complete_pdu(s, pdu, retval);\n\n}", "idx": 4173}
{"project": "qemu", "commit_id": "34e46f604d3cf26144b4e02989f2f096e3dc2a41", "target": 1, "func": "static void add_pc_test_cases(void)\n\n{\n\n    QDict *response, *minfo;\n\n    QList *list;\n\n    const QListEntry *p;\n\n    QObject *qobj;\n\n    QString *qstr;\n\n    const char *mname, *path;\n\n    PCTestData *data;\n\n\n\n    qtest_start(\"-machine none\");\n\n    response = qmp(\"{ 'execute': 'query-machines' }\");\n\n    g_assert(response);\n\n    list = qdict_get_qlist(response, \"return\");\n\n    g_assert(list);\n\n\n\n    for (p = qlist_first(list); p; p = qlist_next(p)) {\n\n        minfo = qobject_to_qdict(qlist_entry_obj(p));\n\n        g_assert(minfo);\n\n        qobj = qdict_get(minfo, \"name\");\n\n        g_assert(qobj);\n\n        qstr = qobject_to_qstring(qobj);\n\n        g_assert(qstr);\n\n        mname = qstring_get_str(qstr);\n\n        if (!g_str_has_prefix(mname, \"pc-\")) {\n\n            continue;\n\n        }\n\n        data = g_malloc(sizeof(PCTestData));\n\n        data->machine = mname;\n\n        data->cpu_model = \"Haswell\"; /* 1.3+ theoretically */\n\n        data->sockets = 1;\n\n        data->cores = 3;\n\n        data->threads = 2;\n\n        data->maxcpus = data->sockets * data->cores * data->threads * 2;\n\n        if (g_str_has_suffix(mname, \"-1.4\") ||\n\n            (strcmp(mname, \"pc-1.3\") == 0) ||\n\n            (strcmp(mname, \"pc-1.2\") == 0) ||\n\n            (strcmp(mname, \"pc-1.1\") == 0) ||\n\n            (strcmp(mname, \"pc-1.0\") == 0) ||\n\n            (strcmp(mname, \"pc-0.15\") == 0) ||\n\n            (strcmp(mname, \"pc-0.14\") == 0) ||\n\n            (strcmp(mname, \"pc-0.13\") == 0) ||\n\n            (strcmp(mname, \"pc-0.12\") == 0) ||\n\n            (strcmp(mname, \"pc-0.11\") == 0) ||\n\n            (strcmp(mname, \"pc-0.10\") == 0)) {\n\n            path = g_strdup_printf(\"cpu/%s/init/%ux%ux%u&maxcpus=%u\",\n\n                                   mname, data->sockets, data->cores,\n\n                                   data->threads, data->maxcpus);\n\n            qtest_add_data_func(path, data, test_pc_without_cpu_add);\n\n        } else {\n\n            path = g_strdup_printf(\"cpu/%s/add/%ux%ux%u&maxcpus=%u\",\n\n                                   mname, data->sockets, data->cores,\n\n                                   data->threads, data->maxcpus);\n\n            qtest_add_data_func(path, data, test_pc_with_cpu_add);\n\n        }\n\n    }\n\n    qtest_end();\n\n}\n", "idx": 528}
{"project": "qemu", "commit_id": "38ee14f4f33f8836fc0e209ca59c6ae8c6edf380", "target": 1, "func": "static int vnc_update_client_sync(VncState *vs, int has_dirty)\n\n{\n\n    int ret = vnc_update_client(vs, has_dirty);\n\n    vnc_jobs_join(vs);\n\n    return ret;\n\n}\n", "idx": 4273}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static DeviceState *sun4c_intctl_init(target_phys_addr_t addr,\n\n                                      qemu_irq *parent_irq)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    unsigned int i;\n\n\n\n    dev = qdev_create(NULL, \"sun4c_intctl\");\n\n    qdev_init(dev);\n\n\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    for (i = 0; i < MAX_PILS; i++) {\n\n        sysbus_connect_irq(s, i, parent_irq[i]);\n\n    }\n\n    sysbus_mmio_map(s, 0, addr);\n\n\n\n    return dev;\n\n}\n", "idx": 9268}
{"project": "qemu", "commit_id": "890241ab6942a0186eaf485dabf266a5a7aac428", "target": 1, "func": "static void migrate_check_parameter(QTestState *who, const char *parameter,\n\n                                    const char *value)\n\n{\n\n    QDict *rsp, *rsp_return;\n\n    const char *result;\n\n\n\n    rsp = wait_command(who, \"{ 'execute': 'query-migrate-parameters' }\");\n\n    rsp_return = qdict_get_qdict(rsp, \"return\");\n\n    result = g_strdup_printf(\"%\" PRId64,\n\n                             qdict_get_try_int(rsp_return,  parameter, -1));\n\n    g_assert_cmpstr(result, ==, value);\n\n    QDECREF(rsp);\n\n}\n", "idx": 7788}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "uint64_t qemu_get_be64(QEMUFile *f)\n\n{\n\n    uint64_t v;\n\n    v = (uint64_t)qemu_get_be32(f) << 32;\n\n    v |= qemu_get_be32(f);\n\n    return v;\n\n}\n", "idx": 3046}
{"project": "qemu", "commit_id": "c27ff60871aff588a35e51d1a90faed410993e55", "target": 1, "func": "ssize_t qemu_sendv_packet(VLANClientState *vc1, const struct iovec *iov,\n\n                          int iovcnt)\n\n{\n\n    VLANState *vlan = vc1->vlan;\n\n    VLANClientState *vc;\n\n    ssize_t max_len = 0;\n\n\n\n    if (vc1->link_down)\n\n        return calc_iov_length(iov, iovcnt);\n\n\n\n    for (vc = vlan->first_client; vc != NULL; vc = vc->next) {\n\n        ssize_t len = 0;\n\n\n\n        if (vc == vc1)\n\n            continue;\n\n\n\n        if (vc->link_down)\n\n            len = calc_iov_length(iov, iovcnt);\n\n        else if (vc->fd_readv)\n\n            len = vc->fd_readv(vc->opaque, iov, iovcnt);\n\n        else if (vc->fd_read)\n\n            len = vc_sendv_compat(vc, iov, iovcnt);\n\n\n\n        max_len = MAX(max_len, len);\n\n    }\n\n\n\n    return max_len;\n\n}\n", "idx": 3534}
{"project": "qemu", "commit_id": "7ef8cf9a0861b6f67f5e57428478c31bfd811651", "target": 1, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    cmd->xfer = scsi_cdb_length(buf);\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        if ((buf[1] & 2) == 0) {\n\n            cmd->xfer = 0;\n\n        } else if ((buf[1] & 4) == 1) {\n\n            cmd->xfer = 1;\n\n        }\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6508}
{"project": "qemu", "commit_id": "f35e44e7645edbb08e35b111c10c2fc57e2905c7", "target": 1, "func": "static void tcg_commit(MemoryListener *listener)\n\n{\n\n    CPUAddressSpace *cpuas;\n\n    AddressSpaceDispatch *d;\n\n\n\n    /* since each CPU stores ram addresses in its TLB cache, we must\n\n       reset the modified entries */\n\n    cpuas = container_of(listener, CPUAddressSpace, tcg_as_listener);\n\n    cpu_reloading_memory_map();\n\n    /* The CPU and TLB are protected by the iothread lock.\n\n     * We reload the dispatch pointer now because cpu_reloading_memory_map()\n\n     * may have split the RCU critical section.\n\n     */\n\n    d = atomic_rcu_read(&cpuas->as->dispatch);\n\n    cpuas->memory_dispatch = d;\n\n    tlb_flush(cpuas->cpu, 1);\n\n}\n", "idx": 7965}
{"project": "qemu", "commit_id": "555a608c5d5dcc44e45a483ca09b449d8db519d1", "target": 1, "func": "static int parallels_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    int64_t total_size, cl_size;\n\n    uint8_t tmp[BDRV_SECTOR_SIZE];\n\n    Error *local_err = NULL;\n\n    BlockBackend *file;\n\n    uint32_t bat_entries, bat_sectors;\n\n    ParallelsHeader header;\n\n    int ret;\n\n\n\n    total_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                          BDRV_SECTOR_SIZE);\n\n    cl_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_CLUSTER_SIZE,\n\n                          DEFAULT_CLUSTER_SIZE), BDRV_SECTOR_SIZE);\n\n\n\n\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n\n\n\n    file = blk_new_open(filename, NULL, NULL,\n\n                        BDRV_O_RDWR | BDRV_O_PROTOCOL, &local_err);\n\n    if (file == NULL) {\n\n\n        return -EIO;\n\n\n\n\n    blk_set_allow_write_beyond_eof(file, true);\n\n\n\n    ret = blk_truncate(file, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n\n\n\n    bat_entries = DIV_ROUND_UP(total_size, cl_size);\n\n    bat_sectors = DIV_ROUND_UP(bat_entry_off(bat_entries), cl_size);\n\n    bat_sectors = (bat_sectors *  cl_size) >> BDRV_SECTOR_BITS;\n\n\n\n    memset(&header, 0, sizeof(header));\n\n    memcpy(header.magic, HEADER_MAGIC2, sizeof(header.magic));\n\n    header.version = cpu_to_le32(HEADER_VERSION);\n\n    /* don't care much about geometry, it is not used on image level */\n\n    header.heads = cpu_to_le32(16);\n\n    header.cylinders = cpu_to_le32(total_size / BDRV_SECTOR_SIZE / 16 / 32);\n\n    header.tracks = cpu_to_le32(cl_size >> BDRV_SECTOR_BITS);\n\n    header.bat_entries = cpu_to_le32(bat_entries);\n\n    header.nb_sectors = cpu_to_le64(DIV_ROUND_UP(total_size, BDRV_SECTOR_SIZE));\n\n    header.data_off = cpu_to_le32(bat_sectors);\n\n\n\n    /* write all the data */\n\n    memset(tmp, 0, sizeof(tmp));\n\n    memcpy(tmp, &header, sizeof(header));\n\n\n\n    ret = blk_pwrite(file, 0, tmp, BDRV_SECTOR_SIZE, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n\n    ret = blk_pwrite_zeroes(file, BDRV_SECTOR_SIZE,\n\n                            (bat_sectors - 1) << BDRV_SECTOR_BITS, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n\n    ret = 0;\n\n\n\ndone:\n\n    blk_unref(file);\n\n    return ret;\n\n\n\nexit:\n\n    error_setg_errno(errp, -ret, \"Failed to create Parallels image\");\n\n    goto done;\n", "idx": 1662}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "int qcow2_grow_l1_table(BlockDriverState *bs, int min_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int new_l1_size, new_l1_size2, ret, i;\n\n    uint64_t *new_l1_table;\n\n    int64_t new_l1_table_offset;\n\n    uint8_t data[12];\n\n\n\n    new_l1_size = s->l1_size;\n\n    if (min_size <= new_l1_size)\n\n        return 0;\n\n    if (new_l1_size == 0) {\n\n        new_l1_size = 1;\n\n    }\n\n    while (min_size > new_l1_size) {\n\n        new_l1_size = (new_l1_size * 3 + 1) / 2;\n\n    }\n\n#ifdef DEBUG_ALLOC2\n\n    printf(\"grow l1_table from %d to %d\\n\", s->l1_size, new_l1_size);\n\n#endif\n\n\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n\n    new_l1_table = qemu_mallocz(align_offset(new_l1_size2, 512));\n\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n\n\n    /* write new table (align to cluster) */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n\n    if (new_l1_table_offset < 0) {\n\n        qemu_free(new_l1_table);\n\n        return new_l1_table_offset;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n\n    ret = bdrv_pwrite(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n\n    if (ret != new_l1_size2)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n\n\n    /* set new table */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n\n    cpu_to_be64w((uint64_t*)(data + 4), new_l1_table_offset);\n\n    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n\n    if (ret != sizeof(data)) {\n\n        goto fail;\n\n    }\n\n    qemu_free(s->l1_table);\n\n    qcow2_free_clusters(bs, s->l1_table_offset, s->l1_size * sizeof(uint64_t));\n\n    s->l1_table_offset = new_l1_table_offset;\n\n    s->l1_table = new_l1_table;\n\n    s->l1_size = new_l1_size;\n\n    return 0;\n\n fail:\n\n    qemu_free(new_l1_table);\n\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2);\n\n    return ret < 0 ? ret : -EIO;\n\n}\n", "idx": 2703}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_addmeo_64 (void)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca + (-1);\n\n    if (likely(!((uint64_t)T1 &\n\n                 ((uint64_t)T1 ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T1 != 0))\n\n        xer_ca = 1;\n\n}\n", "idx": 4143}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "static int write_reftable_entry(BlockDriverState *bs, int rt_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[RT_ENTRIES_PER_SECTOR];\n\n    int rt_start_index;\n\n    int i, ret;\n\n\n\n    rt_start_index = rt_index & ~(RT_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < RT_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->refcount_table[rt_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_REFCOUNT_TABLE,\n\n            s->refcount_table_offset + rt_start_index * sizeof(uint64_t),\n\n            sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->refcount_table_offset +\n\n            rt_start_index * sizeof(uint64_t), buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4576}
{"project": "qemu", "commit_id": "4e27e819bea0ea6c8108dc7e9fa48afd6ec13c46", "target": 1, "func": "static void visit_type_int32(Visitor *v, int *value, const char *name, Error **errp)\n\n{\n\n    int64_t val = *value;\n\n    visit_type_int(v, &val, name, errp);\n\n}\n", "idx": 5432}
{"project": "qemu", "commit_id": "feeee5aca765606818e00f5a19d19f141f4ae365", "target": 1, "func": "static BlockDriverState *get_bs_snapshots(void)\n\n{\n\n    BlockDriverState *bs;\n\n    DriveInfo *dinfo;\n\n\n\n    if (bs_snapshots)\n\n        return bs_snapshots;\n\n    QTAILQ_FOREACH(dinfo, &drives, next) {\n\n        bs = dinfo->bdrv;\n\n        if (bdrv_can_snapshot(bs))\n\n            goto ok;\n\n    }\n\n    return NULL;\n\n ok:\n\n    bs_snapshots = bs;\n\n    return bs;\n\n}\n", "idx": 3733}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "static CharDriverState *net_vhost_parse_chardev(\n\n    const NetdevVhostUserOptions *opts, Error **errp)\n\n{\n\n    CharDriverState *chr = qemu_chr_find(opts->chardev);\n\n    VhostUserChardevProps props;\n\n\n\n    if (chr == NULL) {\n\n        error_setg(errp, \"chardev \\\"%s\\\" not found\", opts->chardev);\n\n        return NULL;\n\n    }\n\n\n\n    /* inspect chardev opts */\n\n    memset(&props, 0, sizeof(props));\n\n    if (qemu_opt_foreach(chr->opts, net_vhost_chardev_opts, &props, errp)) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!props.is_socket || !props.is_unix) {\n\n        error_setg(errp, \"chardev \\\"%s\\\" is not a unix socket\",\n\n                   opts->chardev);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_chr_fe_claim_no_fail(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 6397}
{"project": "qemu", "commit_id": "cc689485ee3e9dca05765326ee8fd619a6ec48f0", "target": 1, "func": "void tb_phys_invalidate(TranslationBlock *tb, tb_page_addr_t page_addr)\n\n{\n\n    CPUState *cpu;\n\n    PageDesc *p;\n\n    uint32_t h;\n\n    tb_page_addr_t phys_pc;\n\n\n\n    assert_tb_locked();\n\n\n\n    atomic_set(&tb->cflags, tb->cflags | CF_INVALID);\n\n\n\n    /* remove the TB from the hash list */\n\n    phys_pc = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);\n\n    h = tb_hash_func(phys_pc, tb->pc, tb->flags, tb->cflags & CF_HASH_MASK,\n\n                     tb->trace_vcpu_dstate);\n\n    qht_remove(&tb_ctx.htable, tb, h);\n\n\n\n    /* remove the TB from the page list */\n\n    if (tb->page_addr[0] != page_addr) {\n\n        p = page_find(tb->page_addr[0] >> TARGET_PAGE_BITS);\n\n        tb_page_remove(&p->first_tb, tb);\n\n        invalidate_page_bitmap(p);\n\n    }\n\n    if (tb->page_addr[1] != -1 && tb->page_addr[1] != page_addr) {\n\n        p = page_find(tb->page_addr[1] >> TARGET_PAGE_BITS);\n\n        tb_page_remove(&p->first_tb, tb);\n\n        invalidate_page_bitmap(p);\n\n    }\n\n\n\n    /* remove the TB from the hash list */\n\n    h = tb_jmp_cache_hash_func(tb->pc);\n\n    CPU_FOREACH(cpu) {\n\n        if (atomic_read(&cpu->tb_jmp_cache[h]) == tb) {\n\n            atomic_set(&cpu->tb_jmp_cache[h], NULL);\n\n        }\n\n    }\n\n\n\n    /* suppress this TB from the two jump lists */\n\n    tb_remove_from_jmp_list(tb, 0);\n\n    tb_remove_from_jmp_list(tb, 1);\n\n\n\n    /* suppress any remaining jumps to this TB */\n\n    tb_jmp_unlink(tb);\n\n\n\n    tb_ctx.tb_phys_invalidate_count++;\n\n}\n", "idx": 5066}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "static CharDriverState *net_vhost_parse_chardev(\n\n    const NetdevVhostUserOptions *opts, Error **errp)\n\n{\n\n    CharDriverState *chr = qemu_chr_find(opts->chardev);\n\n    VhostUserChardevProps props;\n\n\n\n    if (chr == NULL) {\n\n        error_setg(errp, \"chardev \\\"%s\\\" not found\", opts->chardev);\n\n        return NULL;\n\n    }\n\n\n\n    /* inspect chardev opts */\n\n    memset(&props, 0, sizeof(props));\n\n    if (qemu_opt_foreach(chr->opts, net_vhost_chardev_opts, &props, errp)) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!props.is_socket || !props.is_unix) {\n\n        error_setg(errp, \"chardev \\\"%s\\\" is not a unix socket\",\n\n                   opts->chardev);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_chr_fe_claim_no_fail(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 6397}
{"project": "qemu", "commit_id": "165d9b82eb8c877ee691a7b7bde5930bc2d07037", "target": 1, "func": "void helper_wrmsr(void)\n\n{\n\n    uint64_t val;\n\n\n\n    helper_svm_check_intercept_param(SVM_EXIT_MSR, 1);\n\n\n\n    val = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n\n\n    switch((uint32_t)ECX) {\n\n    case MSR_IA32_SYSENTER_CS:\n\n        env->sysenter_cs = val & 0xffff;\n\n\n    case MSR_IA32_SYSENTER_ESP:\n\n        env->sysenter_esp = val;\n\n\n    case MSR_IA32_SYSENTER_EIP:\n\n        env->sysenter_eip = val;\n\n\n    case MSR_IA32_APICBASE:\n\n        cpu_set_apic_base(env, val);\n\n\n    case MSR_EFER:\n\n        {\n\n            uint64_t update_mask;\n\n            update_mask = 0;\n\n            if (env->cpuid_ext2_features & CPUID_EXT2_SYSCALL)\n\n                update_mask |= MSR_EFER_SCE;\n\n            if (env->cpuid_ext2_features & CPUID_EXT2_LM)\n\n                update_mask |= MSR_EFER_LME;\n\n            if (env->cpuid_ext2_features & CPUID_EXT2_FFXSR)\n\n                update_mask |= MSR_EFER_FFXSR;\n\n            if (env->cpuid_ext2_features & CPUID_EXT2_NX)\n\n                update_mask |= MSR_EFER_NXE;\n\n            if (env->cpuid_ext3_features & CPUID_EXT3_SVM)\n\n                update_mask |= MSR_EFER_SVME;\n\n            cpu_load_efer(env, (env->efer & ~update_mask) |\n\n                          (val & update_mask));\n\n        }\n\n\n    case MSR_STAR:\n\n        env->star = val;\n\n\n    case MSR_PAT:\n\n        env->pat = val;\n\n\n    case MSR_VM_HSAVE_PA:\n\n        env->vm_hsave = val;\n\n\n#ifdef TARGET_X86_64\n\n    case MSR_LSTAR:\n\n        env->lstar = val;\n\n\n    case MSR_CSTAR:\n\n        env->cstar = val;\n\n\n    case MSR_FMASK:\n\n        env->fmask = val;\n\n\n    case MSR_FSBASE:\n\n        env->segs[R_FS].base = val;\n\n\n    case MSR_GSBASE:\n\n        env->segs[R_GS].base = val;\n\n\n    case MSR_KERNELGSBASE:\n\n        env->kernelgsbase = val;\n\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    default:\n\n        /* XXX: exception ? */\n\n\n    }\n\n}", "idx": 4168}
{"project": "qemu", "commit_id": "09d7ae9000fe27d1861cb0348cbf71563ded6148", "target": 1, "func": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset, mingap = ULONG_MAX;\n\n\n\n    if (QLIST_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = ULONG_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QLIST_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset =  end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n    return offset;\n\n}\n", "idx": 4533}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 4618}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_muls_i64_i32(TCGv a, TCGv b)\n\n{\n\n    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(tmp1, a);\n\n    dead_tmp(a);\n\n    tcg_gen_ext_i32_i64(tmp2, b);\n\n    dead_tmp(b);\n\n    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n    tcg_temp_free_i64(tmp2);\n\n    return tmp1;\n\n}\n", "idx": 3926}
{"project": "qemu", "commit_id": "d451008e0fdf7fb817c791397e7999d5f3687e58", "target": 1, "func": "static void vfio_rtl8168_window_quirk_write(void *opaque, hwaddr addr,\n\n                                            uint64_t data, unsigned size)\n\n{\n\n    VFIOQuirk *quirk = opaque;\n\n    VFIOPCIDevice *vdev = quirk->vdev;\n\n\n\n    switch (addr) {\n\n    case 4: /* address */\n\n        if ((data & 0x7fff0000) == 0x10000) {\n\n            if (data & 0x80000000U &&\n\n                vdev->pdev.cap_present & QEMU_PCI_CAP_MSIX) {\n\n\n\n                trace_vfio_rtl8168_window_quirk_write_table(\n\n                        memory_region_name(&quirk->mem),\n\n                        vdev->vbasedev.name);\n\n\n\n                memory_region_dispatch_write(&vdev->pdev.msix_table_mmio,\n\n                                             (hwaddr)(data & 0xfff),\n\n                                             (uint64_t)quirk->data.address_mask,\n\n                                             size, MEMTXATTRS_UNSPECIFIED);\n\n            }\n\n\n\n            quirk->data.flags = 1;\n\n            quirk->data.address_match = data;\n\n\n\n            return;\n\n        }\n\n        quirk->data.flags = 0;\n\n        break;\n\n    case 0: /* data */\n\n        quirk->data.address_mask = data;\n\n        break;\n\n    }\n\n\n\n    trace_vfio_rtl8168_window_quirk_write_direct(\n\n            memory_region_name(&quirk->mem),\n\n            vdev->vbasedev.name);\n\n\n\n    vfio_region_write(&vdev->bars[quirk->data.bar].region,\n\n                      addr + 0x70, data, size);\n\n}\n", "idx": 5692}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static int of_dpa_cmd_group_add(OfDpa *of_dpa, uint32_t group_id,\n\n                                RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *group = of_dpa_group_find(of_dpa, group_id);\n\n    int err;\n\n\n\n    if (group) {\n\n        return -ROCKER_EEXIST;\n\n    }\n\n\n\n    group = of_dpa_group_alloc(group_id);\n\n    if (!group) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    err = of_dpa_cmd_group_do(of_dpa, group_id, group, group_tlvs);\n\n    if (err) {\n\n        goto err_cmd_add;\n\n    }\n\n\n\n    err = of_dpa_group_add(of_dpa, group);\n\n    if (err) {\n\n        goto err_cmd_add;\n\n    }\n\n\n\n    return ROCKER_OK;\n\n\n\nerr_cmd_add:\n\n    g_free(group);\n\n    return err;\n\n}\n", "idx": 7281}
{"project": "qemu", "commit_id": "96a8b92ed8f02d5e86ad380d3299d9f41f99b072", "target": 1, "func": "void register_cp_regs_for_features(ARMCPU *cpu)\n\n{\n\n    /* Register all the coprocessor registers based on feature bits */\n\n    CPUARMState *env = &cpu->env;\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        /* M profile has no coprocessor registers */\n\n        return;\n\n    }\n\n\n\n    define_arm_cp_regs(cpu, cp_reginfo);\n\n    if (!arm_feature(env, ARM_FEATURE_V8)) {\n\n        /* Must go early as it is full of wildcards that may be\n\n         * overridden by later definitions.\n\n         */\n\n        define_arm_cp_regs(cpu, not_v8_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        /* The ID registers all have impdef reset values */\n\n        ARMCPRegInfo v6_idregs[] = {\n\n            { .name = \"ID_PFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_pfr0 },\n\n            { .name = \"ID_PFR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_pfr1 },\n\n            { .name = \"ID_DFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_dfr0 },\n\n            { .name = \"ID_AFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_afr0 },\n\n            { .name = \"ID_MMFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr0 },\n\n            { .name = \"ID_MMFR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr1 },\n\n            { .name = \"ID_MMFR2\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr2 },\n\n            { .name = \"ID_MMFR3\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr3 },\n\n            { .name = \"ID_ISAR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar0 },\n\n            { .name = \"ID_ISAR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar1 },\n\n            { .name = \"ID_ISAR2\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar2 },\n\n            { .name = \"ID_ISAR3\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar3 },\n\n            { .name = \"ID_ISAR4\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar4 },\n\n            { .name = \"ID_ISAR5\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar5 },\n\n            { .name = \"ID_MMFR4\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr4 },\n\n            /* 7 is as yet unallocated and must RAZ */\n\n            { .name = \"ID_ISAR7_RESERVED\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        define_arm_cp_regs(cpu, v6_idregs);\n\n        define_arm_cp_regs(cpu, v6_cp_reginfo);\n\n    } else {\n\n        define_arm_cp_regs(cpu, not_v6_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        define_arm_cp_regs(cpu, v6k_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7MP) &&\n\n        !arm_feature(env, ARM_FEATURE_PMSA)) {\n\n        define_arm_cp_regs(cpu, v7mp_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        /* v7 performance monitor control register: same implementor\n\n         * field as main ID register, and we implement only the cycle\n\n         * count register.\n\n         */\n\n#ifndef CONFIG_USER_ONLY\n\n        ARMCPRegInfo pmcr = {\n\n            .name = \"PMCR\", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 0,\n\n            .access = PL0_RW,\n\n            .type = ARM_CP_IO | ARM_CP_ALIAS,\n\n            .fieldoffset = offsetoflow32(CPUARMState, cp15.c9_pmcr),\n\n            .accessfn = pmreg_access, .writefn = pmcr_write,\n\n            .raw_writefn = raw_write,\n\n        };\n\n        ARMCPRegInfo pmcr64 = {\n\n            .name = \"PMCR_EL0\", .state = ARM_CP_STATE_AA64,\n\n            .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 0,\n\n            .access = PL0_RW, .accessfn = pmreg_access,\n\n            .type = ARM_CP_IO,\n\n            .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcr),\n\n            .resetvalue = cpu->midr & 0xff000000,\n\n            .writefn = pmcr_write, .raw_writefn = raw_write,\n\n        };\n\n        define_one_arm_cp_reg(cpu, &pmcr);\n\n        define_one_arm_cp_reg(cpu, &pmcr64);\n\n#endif\n\n        ARMCPRegInfo clidr = {\n\n            .name = \"CLIDR\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = 1,\n\n            .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->clidr\n\n        };\n\n        define_one_arm_cp_reg(cpu, &clidr);\n\n        define_arm_cp_regs(cpu, v7_cp_reginfo);\n\n        define_debug_regs(cpu);\n\n    } else {\n\n        define_arm_cp_regs(cpu, not_v7_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V8)) {\n\n        /* AArch64 ID registers, which all have impdef reset values.\n\n         * Note that within the ID register ranges the unused slots\n\n         * must all RAZ, not UNDEF; future architecture versions may\n\n         * define new registers here.\n\n         */\n\n        ARMCPRegInfo v8_idregs[] = {\n\n            { .name = \"ID_AA64PFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64pfr0 },\n\n            { .name = \"ID_AA64PFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64pfr1},\n\n            { .name = \"ID_AA64PFR2_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64PFR3_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64PFR4_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64PFR5_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64PFR6_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64PFR7_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64DFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64dfr0 },\n\n            { .name = \"ID_AA64DFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64dfr1 },\n\n            { .name = \"ID_AA64DFR2_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64DFR3_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64AFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64afr0 },\n\n            { .name = \"ID_AA64AFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64afr1 },\n\n            { .name = \"ID_AA64AFR2_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64AFR3_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64ISAR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64isar0 },\n\n            { .name = \"ID_AA64ISAR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64isar1 },\n\n            { .name = \"ID_AA64ISAR2_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64ISAR3_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64ISAR4_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64ISAR5_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64ISAR6_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64ISAR7_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64MMFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64mmfr0 },\n\n            { .name = \"ID_AA64MMFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64mmfr1 },\n\n            { .name = \"ID_AA64MMFR2_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64MMFR3_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64MMFR4_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64MMFR5_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64MMFR6_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_AA64MMFR7_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"MVFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr0 },\n\n            { .name = \"MVFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr1 },\n\n            { .name = \"MVFR2_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr2 },\n\n            { .name = \"MVFR3_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"MVFR4_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"MVFR5_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"MVFR6_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"MVFR7_EL1_RESERVED\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"PMCEID0\", .state = ARM_CP_STATE_AA32,\n\n              .cp = 15, .opc1 = 0, .crn = 9, .crm = 12, .opc2 = 6,\n\n              .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->pmceid0 },\n\n            { .name = \"PMCEID0_EL0\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 6,\n\n              .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->pmceid0 },\n\n            { .name = \"PMCEID1\", .state = ARM_CP_STATE_AA32,\n\n              .cp = 15, .opc1 = 0, .crn = 9, .crm = 12, .opc2 = 7,\n\n              .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->pmceid1 },\n\n            { .name = \"PMCEID1_EL0\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 7,\n\n              .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->pmceid1 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        /* RVBAR_EL1 is only implemented if EL1 is the highest EL */\n\n        if (!arm_feature(env, ARM_FEATURE_EL3) &&\n\n            !arm_feature(env, ARM_FEATURE_EL2)) {\n\n            ARMCPRegInfo rvbar = {\n\n                .name = \"RVBAR_EL1\", .state = ARM_CP_STATE_AA64,\n\n                .opc0 = 3, .opc1 = 0, .crn = 12, .crm = 0, .opc2 = 1,\n\n                .type = ARM_CP_CONST, .access = PL1_R, .resetvalue = cpu->rvbar\n\n            };\n\n            define_one_arm_cp_reg(cpu, &rvbar);\n\n        }\n\n        define_arm_cp_regs(cpu, v8_idregs);\n\n        define_arm_cp_regs(cpu, v8_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_EL2)) {\n\n        uint64_t vmpidr_def = mpidr_read_val(env);\n\n        ARMCPRegInfo vpidr_regs[] = {\n\n            { .name = \"VPIDR\", .state = ARM_CP_STATE_AA32,\n\n              .cp = 15, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 0,\n\n              .access = PL2_RW, .accessfn = access_el3_aa32ns,\n\n              .resetvalue = cpu->midr,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.vpidr_el2) },\n\n            { .name = \"VPIDR_EL2\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 0,\n\n              .access = PL2_RW, .resetvalue = cpu->midr,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.vpidr_el2) },\n\n            { .name = \"VMPIDR\", .state = ARM_CP_STATE_AA32,\n\n              .cp = 15, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 5,\n\n              .access = PL2_RW, .accessfn = access_el3_aa32ns,\n\n              .resetvalue = vmpidr_def,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.vmpidr_el2) },\n\n            { .name = \"VMPIDR_EL2\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 5,\n\n              .access = PL2_RW,\n\n              .resetvalue = vmpidr_def,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.vmpidr_el2) },\n\n            REGINFO_SENTINEL\n\n        };\n\n        define_arm_cp_regs(cpu, vpidr_regs);\n\n        define_arm_cp_regs(cpu, el2_cp_reginfo);\n\n        /* RVBAR_EL2 is only implemented if EL2 is the highest EL */\n\n        if (!arm_feature(env, ARM_FEATURE_EL3)) {\n\n            ARMCPRegInfo rvbar = {\n\n                .name = \"RVBAR_EL2\", .state = ARM_CP_STATE_AA64,\n\n                .opc0 = 3, .opc1 = 4, .crn = 12, .crm = 0, .opc2 = 1,\n\n                .type = ARM_CP_CONST, .access = PL2_R, .resetvalue = cpu->rvbar\n\n            };\n\n            define_one_arm_cp_reg(cpu, &rvbar);\n\n        }\n\n    } else {\n\n        /* If EL2 is missing but higher ELs are enabled, we need to\n\n         * register the no_el2 reginfos.\n\n         */\n\n        if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n            /* When EL3 exists but not EL2, VPIDR and VMPIDR take the value\n\n             * of MIDR_EL1 and MPIDR_EL1.\n\n             */\n\n            ARMCPRegInfo vpidr_regs[] = {\n\n                { .name = \"VPIDR_EL2\", .state = ARM_CP_STATE_BOTH,\n\n                  .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 0,\n\n                  .access = PL2_RW, .accessfn = access_el3_aa32ns_aa64any,\n\n                  .type = ARM_CP_CONST, .resetvalue = cpu->midr,\n\n                  .fieldoffset = offsetof(CPUARMState, cp15.vpidr_el2) },\n\n                { .name = \"VMPIDR_EL2\", .state = ARM_CP_STATE_BOTH,\n\n                  .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 5,\n\n                  .access = PL2_RW, .accessfn = access_el3_aa32ns_aa64any,\n\n                  .type = ARM_CP_NO_RAW,\n\n                  .writefn = arm_cp_write_ignore, .readfn = mpidr_read },\n\n                REGINFO_SENTINEL\n\n            };\n\n            define_arm_cp_regs(cpu, vpidr_regs);\n\n            define_arm_cp_regs(cpu, el3_no_el2_cp_reginfo);\n\n        }\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n        define_arm_cp_regs(cpu, el3_cp_reginfo);\n\n        ARMCPRegInfo el3_regs[] = {\n\n            { .name = \"RVBAR_EL3\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 6, .crn = 12, .crm = 0, .opc2 = 1,\n\n              .type = ARM_CP_CONST, .access = PL3_R, .resetvalue = cpu->rvbar },\n\n            { .name = \"SCTLR_EL3\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 0, .opc2 = 0,\n\n              .access = PL3_RW,\n\n              .raw_writefn = raw_write, .writefn = sctlr_write,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.sctlr_el[3]),\n\n              .resetvalue = cpu->reset_sctlr },\n\n            REGINFO_SENTINEL\n\n        };\n\n\n\n        define_arm_cp_regs(cpu, el3_regs);\n\n    }\n\n    /* The behaviour of NSACR is sufficiently various that we don't\n\n     * try to describe it in a single reginfo:\n\n     *  if EL3 is 64 bit, then trap to EL3 from S EL1,\n\n     *     reads as constant 0xc00 from NS EL1 and NS EL2\n\n     *  if EL3 is 32 bit, then RW at EL3, RO at NS EL1 and NS EL2\n\n     *  if v7 without EL3, register doesn't exist\n\n     *  if v8 without EL3, reads as constant 0xc00 from NS EL1 and NS EL2\n\n     */\n\n    if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n        if (arm_feature(env, ARM_FEATURE_AARCH64)) {\n\n            ARMCPRegInfo nsacr = {\n\n                .name = \"NSACR\", .type = ARM_CP_CONST,\n\n                .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 2,\n\n                .access = PL1_RW, .accessfn = nsacr_access,\n\n                .resetvalue = 0xc00\n\n            };\n\n            define_one_arm_cp_reg(cpu, &nsacr);\n\n        } else {\n\n            ARMCPRegInfo nsacr = {\n\n                .name = \"NSACR\",\n\n                .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 2,\n\n                .access = PL3_RW | PL1_R,\n\n                .resetvalue = 0,\n\n                .fieldoffset = offsetof(CPUARMState, cp15.nsacr)\n\n            };\n\n            define_one_arm_cp_reg(cpu, &nsacr);\n\n        }\n\n    } else {\n\n        if (arm_feature(env, ARM_FEATURE_V8)) {\n\n            ARMCPRegInfo nsacr = {\n\n                .name = \"NSACR\", .type = ARM_CP_CONST,\n\n                .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 2,\n\n                .access = PL1_R,\n\n                .resetvalue = 0xc00\n\n            };\n\n            define_one_arm_cp_reg(cpu, &nsacr);\n\n        }\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_PMSA)) {\n\n        if (arm_feature(env, ARM_FEATURE_V6)) {\n\n            /* PMSAv6 not implemented */\n\n            assert(arm_feature(env, ARM_FEATURE_V7));\n\n            define_arm_cp_regs(cpu, vmsa_pmsa_cp_reginfo);\n\n            define_arm_cp_regs(cpu, pmsav7_cp_reginfo);\n\n        } else {\n\n            define_arm_cp_regs(cpu, pmsav5_cp_reginfo);\n\n        }\n\n    } else {\n\n        define_arm_cp_regs(cpu, vmsa_pmsa_cp_reginfo);\n\n        define_arm_cp_regs(cpu, vmsa_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_THUMB2EE)) {\n\n        define_arm_cp_regs(cpu, t2ee_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_GENERIC_TIMER)) {\n\n        define_arm_cp_regs(cpu, generic_timer_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VAPA)) {\n\n        define_arm_cp_regs(cpu, vapa_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_TEST_CLEAN)) {\n\n        define_arm_cp_regs(cpu, cache_test_clean_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_DIRTY_REG)) {\n\n        define_arm_cp_regs(cpu, cache_dirty_status_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_BLOCK_OPS)) {\n\n        define_arm_cp_regs(cpu, cache_block_ops_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_OMAPCP)) {\n\n        define_arm_cp_regs(cpu, omap_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_STRONGARM)) {\n\n        define_arm_cp_regs(cpu, strongarm_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n        define_arm_cp_regs(cpu, xscale_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_DUMMY_C15_REGS)) {\n\n        define_arm_cp_regs(cpu, dummy_c15_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        define_arm_cp_regs(cpu, lpae_cp_reginfo);\n\n    }\n\n    /* Slightly awkwardly, the OMAP and StrongARM cores need all of\n\n     * cp15 crn=0 to be writes-ignored, whereas for other cores they should\n\n     * be read-only (ie write causes UNDEF exception).\n\n     */\n\n    {\n\n        ARMCPRegInfo id_pre_v8_midr_cp_reginfo[] = {\n\n            /* Pre-v8 MIDR space.\n\n             * Note that the MIDR isn't a simple constant register because\n\n             * of the TI925 behaviour where writes to another register can\n\n             * cause the MIDR value to change.\n\n             *\n\n             * Unimplemented registers in the c15 0 0 0 space default to\n\n             * MIDR. Define MIDR first as this entire space, then CTR, TCMTR\n\n             * and friends override accordingly.\n\n             */\n\n            { .name = \"MIDR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .resetvalue = cpu->midr,\n\n              .writefn = arm_cp_write_ignore, .raw_writefn = raw_write,\n\n              .readfn = midr_read,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.c0_cpuid),\n\n              .type = ARM_CP_OVERRIDE },\n\n            /* crn = 0 op1 = 0 crm = 3..7 : currently unassigned; we RAZ. */\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 3, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 4, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 5, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 6, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 7, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo id_v8_midr_cp_reginfo[] = {\n\n            { .name = \"MIDR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_NO_RAW, .resetvalue = cpu->midr,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.c0_cpuid),\n\n              .readfn = midr_read },\n\n            /* crn = 0 op1 = 0 crm = 0 op2 = 4,7 : AArch32 aliases of MIDR */\n\n            { .name = \"MIDR\", .type = ARM_CP_ALIAS | ARM_CP_CONST,\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 4,\n\n              .access = PL1_R, .resetvalue = cpu->midr },\n\n            { .name = \"MIDR\", .type = ARM_CP_ALIAS | ARM_CP_CONST,\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 7,\n\n              .access = PL1_R, .resetvalue = cpu->midr },\n\n            { .name = \"REVIDR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->revidr },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo id_cp_reginfo[] = {\n\n            /* These are common to v8 and pre-v8 */\n\n            { .name = \"CTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->ctr },\n\n            { .name = \"CTR_EL0\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 3, .opc2 = 1, .crn = 0, .crm = 0,\n\n              .access = PL0_R, .accessfn = ctr_el0_access,\n\n              .type = ARM_CP_CONST, .resetvalue = cpu->ctr },\n\n            /* TCMTR and TLBTR exist in v8 but have no 64-bit versions */\n\n            { .name = \"TCMTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        /* TLBTR is specific to VMSA */\n\n        ARMCPRegInfo id_tlbtr_reginfo = {\n\n              .name = \"TLBTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0,\n\n        };\n\n        /* MPUIR is specific to PMSA V6+ */\n\n        ARMCPRegInfo id_mpuir_reginfo = {\n\n              .name = \"MPUIR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->pmsav7_dregion << 8\n\n        };\n\n        ARMCPRegInfo crn0_wi_reginfo = {\n\n            .name = \"CRN0_WI\", .cp = 15, .crn = 0, .crm = CP_ANY,\n\n            .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_W,\n\n            .type = ARM_CP_NOP | ARM_CP_OVERRIDE\n\n        };\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP) ||\n\n            arm_feature(env, ARM_FEATURE_STRONGARM)) {\n\n            ARMCPRegInfo *r;\n\n            /* Register the blanket \"writes ignored\" value first to cover the\n\n             * whole space. Then update the specific ID registers to allow write\n\n             * access, so that they ignore writes rather than causing them to\n\n             * UNDEF.\n\n             */\n\n            define_one_arm_cp_reg(cpu, &crn0_wi_reginfo);\n\n            for (r = id_pre_v8_midr_cp_reginfo;\n\n                 r->type != ARM_CP_SENTINEL; r++) {\n\n                r->access = PL1_RW;\n\n            }\n\n            for (r = id_cp_reginfo; r->type != ARM_CP_SENTINEL; r++) {\n\n                r->access = PL1_RW;\n\n            }\n\n            id_tlbtr_reginfo.access = PL1_RW;\n\n            id_tlbtr_reginfo.access = PL1_RW;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_V8)) {\n\n            define_arm_cp_regs(cpu, id_v8_midr_cp_reginfo);\n\n        } else {\n\n            define_arm_cp_regs(cpu, id_pre_v8_midr_cp_reginfo);\n\n        }\n\n        define_arm_cp_regs(cpu, id_cp_reginfo);\n\n        if (!arm_feature(env, ARM_FEATURE_PMSA)) {\n\n            define_one_arm_cp_reg(cpu, &id_tlbtr_reginfo);\n\n        } else if (arm_feature(env, ARM_FEATURE_V7)) {\n\n            define_one_arm_cp_reg(cpu, &id_mpuir_reginfo);\n\n        }\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_MPIDR)) {\n\n        define_arm_cp_regs(cpu, mpidr_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_AUXCR)) {\n\n        ARMCPRegInfo auxcr_reginfo[] = {\n\n            { .name = \"ACTLR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 1,\n\n              .access = PL1_RW, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->reset_auxcr },\n\n            { .name = \"ACTLR_EL2\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 0, .opc2 = 1,\n\n              .access = PL2_RW, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ACTLR_EL3\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 0, .opc2 = 1,\n\n              .access = PL3_RW, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        define_arm_cp_regs(cpu, auxcr_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_CBAR)) {\n\n        if (arm_feature(env, ARM_FEATURE_AARCH64)) {\n\n            /* 32 bit view is [31:18] 0...0 [43:32]. */\n\n            uint32_t cbar32 = (extract64(cpu->reset_cbar, 18, 14) << 18)\n\n                | extract64(cpu->reset_cbar, 32, 12);\n\n            ARMCPRegInfo cbar_reginfo[] = {\n\n                { .name = \"CBAR\",\n\n                  .type = ARM_CP_CONST,\n\n                  .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,\n\n                  .access = PL1_R, .resetvalue = cpu->reset_cbar },\n\n                { .name = \"CBAR_EL1\", .state = ARM_CP_STATE_AA64,\n\n                  .type = ARM_CP_CONST,\n\n                  .opc0 = 3, .opc1 = 1, .crn = 15, .crm = 3, .opc2 = 0,\n\n                  .access = PL1_R, .resetvalue = cbar32 },\n\n                REGINFO_SENTINEL\n\n            };\n\n            /* We don't implement a r/w 64 bit CBAR currently */\n\n            assert(arm_feature(env, ARM_FEATURE_CBAR_RO));\n\n            define_arm_cp_regs(cpu, cbar_reginfo);\n\n        } else {\n\n            ARMCPRegInfo cbar = {\n\n                .name = \"CBAR\",\n\n                .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,\n\n                .access = PL1_R|PL3_W, .resetvalue = cpu->reset_cbar,\n\n                .fieldoffset = offsetof(CPUARMState,\n\n                                        cp15.c15_config_base_address)\n\n            };\n\n            if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {\n\n                cbar.access = PL1_R;\n\n                cbar.fieldoffset = 0;\n\n                cbar.type = ARM_CP_CONST;\n\n            }\n\n            define_one_arm_cp_reg(cpu, &cbar);\n\n        }\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_VBAR)) {\n\n        ARMCPRegInfo vbar_cp_reginfo[] = {\n\n            { .name = \"VBAR\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .crn = 12, .crm = 0, .opc1 = 0, .opc2 = 0,\n\n              .access = PL1_RW, .writefn = vbar_write,\n\n              .bank_fieldoffsets = { offsetof(CPUARMState, cp15.vbar_s),\n\n                                     offsetof(CPUARMState, cp15.vbar_ns) },\n\n              .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        define_arm_cp_regs(cpu, vbar_cp_reginfo);\n\n    }\n\n\n\n    /* Generic registers whose values depend on the implementation */\n\n    {\n\n        ARMCPRegInfo sctlr = {\n\n            .name = \"SCTLR\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 0,\n\n            .access = PL1_RW,\n\n            .bank_fieldoffsets = { offsetof(CPUARMState, cp15.sctlr_s),\n\n                                   offsetof(CPUARMState, cp15.sctlr_ns) },\n\n            .writefn = sctlr_write, .resetvalue = cpu->reset_sctlr,\n\n            .raw_writefn = raw_write,\n\n        };\n\n        if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n            /* Normally we would always end the TB on an SCTLR write, but Linux\n\n             * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n             * an MMU enable to execute from cache.  Imitate this behaviour.\n\n             */\n\n            sctlr.type |= ARM_CP_SUPPRESS_TB_END;\n\n        }\n\n        define_one_arm_cp_reg(cpu, &sctlr);\n\n    }\n\n}\n", "idx": 4402}
{"project": "qemu", "commit_id": "cde31a0e3dc0e4ac83e454d6096350cec584adf1", "target": 1, "func": "static int rtl8139_cplus_transmit_one(RTL8139State *s)\n\n{\n\n    if (!rtl8139_transmitter_enabled(s))\n\n    {\n\n        DPRINTF(\"+++ C+ mode: transmitter disabled\\n\");\n\n        return 0;\n\n    }\n\n\n\n    if (!rtl8139_cp_transmitter_enabled(s))\n\n    {\n\n        DPRINTF(\"+++ C+ mode: C+ transmitter disabled\\n\");\n\n        return 0 ;\n\n    }\n\n\n\n    int descriptor = s->currCPlusTxDesc;\n\n\n\n    dma_addr_t cplus_tx_ring_desc = rtl8139_addr64(s->TxAddr[0], s->TxAddr[1]);\n\n\n\n    /* Normal priority ring */\n\n    cplus_tx_ring_desc += 16 * descriptor;\n\n\n\n    DPRINTF(\"+++ C+ mode reading TX descriptor %d from host memory at \"\n\n        \"%08x %08x = 0x\"DMA_ADDR_FMT\"\\n\", descriptor, s->TxAddr[1],\n\n        s->TxAddr[0], cplus_tx_ring_desc);\n\n\n\n    uint32_t val, txdw0,txdw1,txbufLO,txbufHI;\n\n\n\n    pci_dma_read(&s->dev, cplus_tx_ring_desc,    (uint8_t *)&val, 4);\n\n    txdw0 = le32_to_cpu(val);\n\n    pci_dma_read(&s->dev, cplus_tx_ring_desc+4,  (uint8_t *)&val, 4);\n\n    txdw1 = le32_to_cpu(val);\n\n    pci_dma_read(&s->dev, cplus_tx_ring_desc+8,  (uint8_t *)&val, 4);\n\n    txbufLO = le32_to_cpu(val);\n\n    pci_dma_read(&s->dev, cplus_tx_ring_desc+12, (uint8_t *)&val, 4);\n\n    txbufHI = le32_to_cpu(val);\n\n\n\n    DPRINTF(\"+++ C+ mode TX descriptor %d %08x %08x %08x %08x\\n\", descriptor,\n\n        txdw0, txdw1, txbufLO, txbufHI);\n\n\n\n/* w0 ownership flag */\n\n#define CP_TX_OWN (1<<31)\n\n/* w0 end of ring flag */\n\n#define CP_TX_EOR (1<<30)\n\n/* first segment of received packet flag */\n\n#define CP_TX_FS (1<<29)\n\n/* last segment of received packet flag */\n\n#define CP_TX_LS (1<<28)\n\n/* large send packet flag */\n\n#define CP_TX_LGSEN (1<<27)\n\n/* large send MSS mask, bits 16...25 */\n\n#define CP_TC_LGSEN_MSS_MASK ((1 << 12) - 1)\n\n\n\n/* IP checksum offload flag */\n\n#define CP_TX_IPCS (1<<18)\n\n/* UDP checksum offload flag */\n\n#define CP_TX_UDPCS (1<<17)\n\n/* TCP checksum offload flag */\n\n#define CP_TX_TCPCS (1<<16)\n\n\n\n/* w0 bits 0...15 : buffer size */\n\n#define CP_TX_BUFFER_SIZE (1<<16)\n\n#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)\n\n/* w1 add tag flag */\n\n#define CP_TX_TAGC (1<<17)\n\n/* w1 bits 0...15 : VLAN tag (big endian) */\n\n#define CP_TX_VLAN_TAG_MASK ((1<<16) - 1)\n\n/* w2 low  32bit of Rx buffer ptr */\n\n/* w3 high 32bit of Rx buffer ptr */\n\n\n\n/* set after transmission */\n\n/* FIFO underrun flag */\n\n#define CP_TX_STATUS_UNF (1<<25)\n\n/* transmit error summary flag, valid if set any of three below */\n\n#define CP_TX_STATUS_TES (1<<23)\n\n/* out-of-window collision flag */\n\n#define CP_TX_STATUS_OWC (1<<22)\n\n/* link failure flag */\n\n#define CP_TX_STATUS_LNKF (1<<21)\n\n/* excessive collisions flag */\n\n#define CP_TX_STATUS_EXC (1<<20)\n\n\n\n    if (!(txdw0 & CP_TX_OWN))\n\n    {\n\n        DPRINTF(\"C+ Tx mode : descriptor %d is owned by host\\n\", descriptor);\n\n        return 0 ;\n\n    }\n\n\n\n    DPRINTF(\"+++ C+ Tx mode : transmitting from descriptor %d\\n\", descriptor);\n\n\n\n    if (txdw0 & CP_TX_FS)\n\n    {\n\n        DPRINTF(\"+++ C+ Tx mode : descriptor %d is first segment \"\n\n            \"descriptor\\n\", descriptor);\n\n\n\n        /* reset internal buffer offset */\n\n        s->cplus_txbuffer_offset = 0;\n\n    }\n\n\n\n    int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK;\n\n    dma_addr_t tx_addr = rtl8139_addr64(txbufLO, txbufHI);\n\n\n\n    /* make sure we have enough space to assemble the packet */\n\n    if (!s->cplus_txbuffer)\n\n    {\n\n        s->cplus_txbuffer_len = CP_TX_BUFFER_SIZE;\n\n        s->cplus_txbuffer = g_malloc(s->cplus_txbuffer_len);\n\n        s->cplus_txbuffer_offset = 0;\n\n\n\n        DPRINTF(\"+++ C+ mode transmission buffer allocated space %d\\n\",\n\n            s->cplus_txbuffer_len);\n\n    }\n\n\n\n    while (s->cplus_txbuffer && s->cplus_txbuffer_offset + txsize >= s->cplus_txbuffer_len)\n\n    {\n\n        s->cplus_txbuffer_len += CP_TX_BUFFER_SIZE;\n\n        s->cplus_txbuffer = g_realloc(s->cplus_txbuffer, s->cplus_txbuffer_len);\n\n\n\n        DPRINTF(\"+++ C+ mode transmission buffer space changed to %d\\n\",\n\n            s->cplus_txbuffer_len);\n\n    }\n\n\n\n    if (!s->cplus_txbuffer)\n\n    {\n\n        /* out of memory */\n\n\n\n        DPRINTF(\"+++ C+ mode transmiter failed to reallocate %d bytes\\n\",\n\n            s->cplus_txbuffer_len);\n\n\n\n        /* update tally counter */\n\n        ++s->tally_counters.TxERR;\n\n        ++s->tally_counters.TxAbt;\n\n\n\n        return 0;\n\n    }\n\n\n\n    /* append more data to the packet */\n\n\n\n    DPRINTF(\"+++ C+ mode transmit reading %d bytes from host memory at \"\n\n            DMA_ADDR_FMT\" to offset %d\\n\", txsize, tx_addr,\n\n            s->cplus_txbuffer_offset);\n\n\n\n    pci_dma_read(&s->dev, tx_addr,\n\n                 s->cplus_txbuffer + s->cplus_txbuffer_offset, txsize);\n\n    s->cplus_txbuffer_offset += txsize;\n\n\n\n    /* seek to next Rx descriptor */\n\n    if (txdw0 & CP_TX_EOR)\n\n    {\n\n        s->currCPlusTxDesc = 0;\n\n    }\n\n    else\n\n    {\n\n        ++s->currCPlusTxDesc;\n\n        if (s->currCPlusTxDesc >= 64)\n\n            s->currCPlusTxDesc = 0;\n\n    }\n\n\n\n    /* transfer ownership to target */\n\n    txdw0 &= ~CP_RX_OWN;\n\n\n\n    /* reset error indicator bits */\n\n    txdw0 &= ~CP_TX_STATUS_UNF;\n\n    txdw0 &= ~CP_TX_STATUS_TES;\n\n    txdw0 &= ~CP_TX_STATUS_OWC;\n\n    txdw0 &= ~CP_TX_STATUS_LNKF;\n\n    txdw0 &= ~CP_TX_STATUS_EXC;\n\n\n\n    /* update ring data */\n\n    val = cpu_to_le32(txdw0);\n\n    pci_dma_write(&s->dev, cplus_tx_ring_desc, (uint8_t *)&val, 4);\n\n\n\n    /* Now decide if descriptor being processed is holding the last segment of packet */\n\n    if (txdw0 & CP_TX_LS)\n\n    {\n\n        uint8_t dot1q_buffer_space[VLAN_HLEN];\n\n        uint16_t *dot1q_buffer;\n\n\n\n        DPRINTF(\"+++ C+ Tx mode : descriptor %d is last segment descriptor\\n\",\n\n            descriptor);\n\n\n\n        /* can transfer fully assembled packet */\n\n\n\n        uint8_t *saved_buffer  = s->cplus_txbuffer;\n\n        int      saved_size    = s->cplus_txbuffer_offset;\n\n        int      saved_buffer_len = s->cplus_txbuffer_len;\n\n\n\n        /* create vlan tag */\n\n        if (txdw1 & CP_TX_TAGC) {\n\n            /* the vlan tag is in BE byte order in the descriptor\n\n             * BE + le_to_cpu() + ~swap()~ = cpu */\n\n            DPRINTF(\"+++ C+ Tx mode : inserting vlan tag with \"\"tci: %u\\n\",\n\n                bswap16(txdw1 & CP_TX_VLAN_TAG_MASK));\n\n\n\n            dot1q_buffer = (uint16_t *) dot1q_buffer_space;\n\n            dot1q_buffer[0] = cpu_to_be16(ETH_P_8021Q);\n\n            /* BE + le_to_cpu() + ~cpu_to_le()~ = BE */\n\n            dot1q_buffer[1] = cpu_to_le16(txdw1 & CP_TX_VLAN_TAG_MASK);\n\n        } else {\n\n            dot1q_buffer = NULL;\n\n        }\n\n\n\n        /* reset the card space to protect from recursive call */\n\n        s->cplus_txbuffer = NULL;\n\n        s->cplus_txbuffer_offset = 0;\n\n        s->cplus_txbuffer_len = 0;\n\n\n\n        if (txdw0 & (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN))\n\n        {\n\n            DPRINTF(\"+++ C+ mode offloaded task checksum\\n\");\n\n\n\n            /* ip packet header */\n\n            ip_header *ip = NULL;\n\n            int hlen = 0;\n\n            uint8_t  ip_protocol = 0;\n\n            uint16_t ip_data_len = 0;\n\n\n\n            uint8_t *eth_payload_data = NULL;\n\n            size_t   eth_payload_len  = 0;\n\n\n\n            int proto = be16_to_cpu(*(uint16_t *)(saved_buffer + 12));\n\n            if (proto == ETH_P_IP)\n\n            {\n\n                DPRINTF(\"+++ C+ mode has IP packet\\n\");\n\n\n\n                /* not aligned */\n\n                eth_payload_data = saved_buffer + ETH_HLEN;\n\n                eth_payload_len  = saved_size   - ETH_HLEN;\n\n\n\n                ip = (ip_header*)eth_payload_data;\n\n\n\n                if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) {\n\n                    DPRINTF(\"+++ C+ mode packet has bad IP version %d \"\n\n                        \"expected %d\\n\", IP_HEADER_VERSION(ip),\n\n                        IP_HEADER_VERSION_4);\n\n                    ip = NULL;\n\n                } else {\n\n                    hlen = IP_HEADER_LENGTH(ip);\n\n                    ip_protocol = ip->ip_p;\n\n                    ip_data_len = be16_to_cpu(ip->ip_len) - hlen;\n\n                }\n\n            }\n\n\n\n            if (ip)\n\n            {\n\n                if (txdw0 & CP_TX_IPCS)\n\n                {\n\n                    DPRINTF(\"+++ C+ mode need IP checksum\\n\");\n\n\n\n                    if (hlen<sizeof(ip_header) || hlen>eth_payload_len) {/* min header length */\n\n                        /* bad packet header len */\n\n                        /* or packet too short */\n\n                    }\n\n                    else\n\n                    {\n\n                        ip->ip_sum = 0;\n\n                        ip->ip_sum = ip_checksum(ip, hlen);\n\n                        DPRINTF(\"+++ C+ mode IP header len=%d checksum=%04x\\n\",\n\n                            hlen, ip->ip_sum);\n\n                    }\n\n                }\n\n\n\n                if ((txdw0 & CP_TX_LGSEN) && ip_protocol == IP_PROTO_TCP)\n\n                {\n\n                    int large_send_mss = (txdw0 >> 16) & CP_TC_LGSEN_MSS_MASK;\n\n\n\n                    DPRINTF(\"+++ C+ mode offloaded task TSO MTU=%d IP data %d \"\n\n                        \"frame data %d specified MSS=%d\\n\", ETH_MTU,\n\n                        ip_data_len, saved_size - ETH_HLEN, large_send_mss);\n\n\n\n                    int tcp_send_offset = 0;\n\n                    int send_count = 0;\n\n\n\n                    /* maximum IP header length is 60 bytes */\n\n                    uint8_t saved_ip_header[60];\n\n\n\n                    /* save IP header template; data area is used in tcp checksum calculation */\n\n                    memcpy(saved_ip_header, eth_payload_data, hlen);\n\n\n\n                    /* a placeholder for checksum calculation routine in tcp case */\n\n                    uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n\n                    //                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;\n\n\n\n                    /* pointer to TCP header */\n\n                    tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);\n\n\n\n                    int tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);\n\n\n\n                    /* ETH_MTU = ip header len + tcp header len + payload */\n\n                    int tcp_data_len = ip_data_len - tcp_hlen;\n\n                    int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;\n\n\n\n                    DPRINTF(\"+++ C+ mode TSO IP data len %d TCP hlen %d TCP \"\n\n                        \"data len %d TCP chunk size %d\\n\", ip_data_len,\n\n                        tcp_hlen, tcp_data_len, tcp_chunk_size);\n\n\n\n                    /* note the cycle below overwrites IP header data,\n\n                       but restores it from saved_ip_header before sending packet */\n\n\n\n                    int is_last_frame = 0;\n\n\n\n                    for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)\n\n                    {\n\n                        uint16_t chunk_size = tcp_chunk_size;\n\n\n\n                        /* check if this is the last frame */\n\n                        if (tcp_send_offset + tcp_chunk_size >= tcp_data_len)\n\n                        {\n\n                            is_last_frame = 1;\n\n                            chunk_size = tcp_data_len - tcp_send_offset;\n\n                        }\n\n\n\n                        DPRINTF(\"+++ C+ mode TSO TCP seqno %08x\\n\",\n\n                            be32_to_cpu(p_tcp_hdr->th_seq));\n\n\n\n                        /* add 4 TCP pseudoheader fields */\n\n                        /* copy IP source and destination fields */\n\n                        memcpy(data_to_checksum, saved_ip_header + 12, 8);\n\n\n\n                        DPRINTF(\"+++ C+ mode TSO calculating TCP checksum for \"\n\n                            \"packet with %d bytes data\\n\", tcp_hlen +\n\n                            chunk_size);\n\n\n\n                        if (tcp_send_offset)\n\n                        {\n\n                            memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);\n\n                        }\n\n\n\n                        /* keep PUSH and FIN flags only for the last frame */\n\n                        if (!is_last_frame)\n\n                        {\n\n                            TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);\n\n                        }\n\n\n\n                        /* recalculate TCP checksum */\n\n                        ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n\n                        p_tcpip_hdr->zeros      = 0;\n\n                        p_tcpip_hdr->ip_proto   = IP_PROTO_TCP;\n\n                        p_tcpip_hdr->ip_payload = cpu_to_be16(tcp_hlen + chunk_size);\n\n\n\n                        p_tcp_hdr->th_sum = 0;\n\n\n\n                        int tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + 12);\n\n                        DPRINTF(\"+++ C+ mode TSO TCP checksum %04x\\n\",\n\n                            tcp_checksum);\n\n\n\n                        p_tcp_hdr->th_sum = tcp_checksum;\n\n\n\n                        /* restore IP header */\n\n                        memcpy(eth_payload_data, saved_ip_header, hlen);\n\n\n\n                        /* set IP data length and recalculate IP checksum */\n\n                        ip->ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);\n\n\n\n                        /* increment IP id for subsequent frames */\n\n                        ip->ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip->ip_id));\n\n\n\n                        ip->ip_sum = 0;\n\n                        ip->ip_sum = ip_checksum(eth_payload_data, hlen);\n\n                        DPRINTF(\"+++ C+ mode TSO IP header len=%d \"\n\n                            \"checksum=%04x\\n\", hlen, ip->ip_sum);\n\n\n\n                        int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;\n\n                        DPRINTF(\"+++ C+ mode TSO transferring packet size \"\n\n                            \"%d\\n\", tso_send_size);\n\n                        rtl8139_transfer_frame(s, saved_buffer, tso_send_size,\n\n                            0, (uint8_t *) dot1q_buffer);\n\n\n\n                        /* add transferred count to TCP sequence number */\n\n                        p_tcp_hdr->th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr->th_seq));\n\n                        ++send_count;\n\n                    }\n\n\n\n                    /* Stop sending this frame */\n\n                    saved_size = 0;\n\n                }\n\n                else if (txdw0 & (CP_TX_TCPCS|CP_TX_UDPCS))\n\n                {\n\n                    DPRINTF(\"+++ C+ mode need TCP or UDP checksum\\n\");\n\n\n\n                    /* maximum IP header length is 60 bytes */\n\n                    uint8_t saved_ip_header[60];\n\n                    memcpy(saved_ip_header, eth_payload_data, hlen);\n\n\n\n                    uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n\n                    //                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;\n\n\n\n                    /* add 4 TCP pseudoheader fields */\n\n                    /* copy IP source and destination fields */\n\n                    memcpy(data_to_checksum, saved_ip_header + 12, 8);\n\n\n\n                    if ((txdw0 & CP_TX_TCPCS) && ip_protocol == IP_PROTO_TCP)\n\n                    {\n\n                        DPRINTF(\"+++ C+ mode calculating TCP checksum for \"\n\n                            \"packet with %d bytes data\\n\", ip_data_len);\n\n\n\n                        ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n\n                        p_tcpip_hdr->zeros      = 0;\n\n                        p_tcpip_hdr->ip_proto   = IP_PROTO_TCP;\n\n                        p_tcpip_hdr->ip_payload = cpu_to_be16(ip_data_len);\n\n\n\n                        tcp_header* p_tcp_hdr = (tcp_header *) (data_to_checksum+12);\n\n\n\n                        p_tcp_hdr->th_sum = 0;\n\n\n\n                        int tcp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n\n                        DPRINTF(\"+++ C+ mode TCP checksum %04x\\n\",\n\n                            tcp_checksum);\n\n\n\n                        p_tcp_hdr->th_sum = tcp_checksum;\n\n                    }\n\n                    else if ((txdw0 & CP_TX_UDPCS) && ip_protocol == IP_PROTO_UDP)\n\n                    {\n\n                        DPRINTF(\"+++ C+ mode calculating UDP checksum for \"\n\n                            \"packet with %d bytes data\\n\", ip_data_len);\n\n\n\n                        ip_pseudo_header *p_udpip_hdr = (ip_pseudo_header *)data_to_checksum;\n\n                        p_udpip_hdr->zeros      = 0;\n\n                        p_udpip_hdr->ip_proto   = IP_PROTO_UDP;\n\n                        p_udpip_hdr->ip_payload = cpu_to_be16(ip_data_len);\n\n\n\n                        udp_header *p_udp_hdr = (udp_header *) (data_to_checksum+12);\n\n\n\n                        p_udp_hdr->uh_sum = 0;\n\n\n\n                        int udp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n\n                        DPRINTF(\"+++ C+ mode UDP checksum %04x\\n\",\n\n                            udp_checksum);\n\n\n\n                        p_udp_hdr->uh_sum = udp_checksum;\n\n                    }\n\n\n\n                    /* restore IP header */\n\n                    memcpy(eth_payload_data, saved_ip_header, hlen);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* update tally counter */\n\n        ++s->tally_counters.TxOk;\n\n\n\n        DPRINTF(\"+++ C+ mode transmitting %d bytes packet\\n\", saved_size);\n\n\n\n        rtl8139_transfer_frame(s, saved_buffer, saved_size, 1,\n\n            (uint8_t *) dot1q_buffer);\n\n\n\n        /* restore card space if there was no recursion and reset offset */\n\n        if (!s->cplus_txbuffer)\n\n        {\n\n            s->cplus_txbuffer        = saved_buffer;\n\n            s->cplus_txbuffer_len    = saved_buffer_len;\n\n            s->cplus_txbuffer_offset = 0;\n\n        }\n\n        else\n\n        {\n\n            g_free(saved_buffer);\n\n        }\n\n    }\n\n    else\n\n    {\n\n        DPRINTF(\"+++ C+ mode transmission continue to next descriptor\\n\");\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 10762}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_wait_io_event(CPUState *cpu)\n\n{\n\n    while (all_cpu_threads_idle()) {\n\n        stop_tcg_kick_timer();\n\n        qemu_cond_wait(cpu->halt_cond, &qemu_global_mutex);\n\n    }\n\n\n\n    start_tcg_kick_timer();\n\n\n\n    CPU_FOREACH(cpu) {\n\n        qemu_wait_io_event_common(cpu);\n\n    }\n\n}\n", "idx": 12009}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "void do_blockdev_backup(BlockdevBackup *backup, BlockJobTxn *txn, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    Error *local_err = NULL;\n\n    AioContext *aio_context;\n\n\n\n    if (!backup->has_speed) {\n\n        backup->speed = 0;\n\n    }\n\n    if (!backup->has_on_source_error) {\n\n        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_on_target_error) {\n\n        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_job_id) {\n\n        backup->job_id = NULL;\n\n    }\n\n    if (!backup->has_compress) {\n\n        backup->compress = false;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    target_bs = bdrv_lookup_bs(backup->target, backup->target, errp);\n\n    if (!target_bs) {\n\n        goto out;\n\n    }\n\n\n\n    if (bdrv_get_aio_context(target_bs) != aio_context) {\n\n        if (!bdrv_has_blk(target_bs)) {\n\n            /* The target BDS is not attached, we can safely move it to another\n\n             * AioContext. */\n\n            bdrv_set_aio_context(target_bs, aio_context);\n\n        } else {\n\n            error_setg(errp, \"Target is attached to a different thread from \"\n\n                             \"source.\");\n\n            goto out;\n\n        }\n\n    }\n\n    backup_start(backup->job_id, bs, target_bs, backup->speed, backup->sync,\n\n                 NULL, backup->compress, backup->on_source_error,\n\n                 backup->on_target_error, BLOCK_JOB_DEFAULT,\n\n                 NULL, NULL, txn, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n    }\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 3019}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 7737}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "void cpu_exec_init(CPUState *cpu, Error **errp)\n\n{\n\n    CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);\n\n\n\n    cpu_list_add(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);\n\n    }\n\n    if (cc->vmsd != NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, cc->vmsd, cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 7077}
{"project": "qemu", "commit_id": "828808f5ece20fd606218e000139799921c89d93", "target": 1, "func": "static void tcg_out_op (TCGContext *s, int opc, const TCGArg *args,\n\n                        const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        tcg_out_movi (s, TCG_TYPE_I64, TCG_REG_R3, args[0]);\n\n        tcg_out_b (s, 0, (tcg_target_long) tb_ret_addr);\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n            s->code_ptr += 28;\n\n        }\n\n        else {\n\n            tcg_abort ();\n\n        }\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_br:\n\n        {\n\n            TCGLabel *l = &s->labels[args[0]];\n\n\n\n            if (l->has_value) {\n\n                tcg_out_b (s, 0, l->u.value);\n\n            }\n\n            else {\n\n                uint32_t val = *(uint32_t *) s->code_ptr;\n\n\n\n                /* Thanks to Andrzej Zaborowski */\n\n                tcg_out32 (s, B | (val & 0x3fffffc));\n\n                tcg_out_reloc (s, s->code_ptr - 4, R_PPC_REL24, args[0], 0);\n\n            }\n\n        }\n\n        break;\n\n    case INDEX_op_call:\n\n        tcg_out_call (s, args[0], const_args[0]);\n\n        break;\n\n    case INDEX_op_jmp:\n\n        if (const_args[0]) {\n\n            tcg_out_b (s, 0, args[0]);\n\n        }\n\n        else {\n\n            tcg_out32 (s, MTSPR | RS (args[0]) | CTR);\n\n            tcg_out32 (s, BCCTR | BO_ALWAYS);\n\n        }\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi (s, TCG_TYPE_I32, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi (s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld8u_i32:\n\n    case INDEX_op_ld8u_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LBZ, LBZX);\n\n        break;\n\n    case INDEX_op_ld8s_i32:\n\n    case INDEX_op_ld8s_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LBZ, LBZX);\n\n        tcg_out32 (s, EXTSB | RS (args[0]) | RA (args[0]));\n\n        break;\n\n    case INDEX_op_ld16u_i32:\n\n    case INDEX_op_ld16u_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LHZ, LHZX);\n\n        break;\n\n    case INDEX_op_ld16s_i32:\n\n    case INDEX_op_ld16s_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LHA, LHAX);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n    case INDEX_op_ld32u_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LWZ, LWZX);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LWA, LWAX);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LD, LDX);\n\n        break;\n\n    case INDEX_op_st8_i32:\n\n    case INDEX_op_st8_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STB, STBX);\n\n        break;\n\n    case INDEX_op_st16_i32:\n\n    case INDEX_op_st16_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STH, STHX);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n    case INDEX_op_st32_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STW, STWX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STD, STDX);\n\n        break;\n\n\n\n    case INDEX_op_add_i32:\n\n        if (const_args[2])\n\n            ppc_addi32 (s, args[0], args[1], args[2]);\n\n        else\n\n            tcg_out32 (s, ADD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_sub_i32:\n\n        if (const_args[2])\n\n            ppc_addi32 (s, args[0], args[1], -args[2]);\n\n        else\n\n            tcg_out32 (s, SUBF | TAB (args[0], args[2], args[1]));\n\n        break;\n\n\n\n    case INDEX_op_and_i64:\n\n    case INDEX_op_and_i32:\n\n        if (const_args[2]) {\n\n            if ((args[2] & 0xffff) == args[2])\n\n                tcg_out32 (s, ANDI | RS (args[1]) | RA (args[0]) | args[2]);\n\n            else if ((args[2] & 0xffff0000) == args[2])\n\n                tcg_out32 (s, ANDIS | RS (args[1]) | RA (args[0])\n\n                           | ((args[2] >> 16) & 0xffff));\n\n            else {\n\n                tcg_out_movi (s, (opc == INDEX_op_and_i32\n\n                                  ? TCG_TYPE_I32\n\n                                  : TCG_TYPE_I64),\n\n                              0, args[2]);\n\n                tcg_out32 (s, AND | SAB (args[1], args[0], 0));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, AND | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_or_i64:\n\n    case INDEX_op_or_i32:\n\n        if (const_args[2]) {\n\n            if (args[2] & 0xffff) {\n\n                tcg_out32 (s, ORI | RS (args[1]) | RA (args[0])\n\n                           | (args[2] & 0xffff));\n\n                if (args[2] >> 16)\n\n                    tcg_out32 (s, ORIS | RS (args[0])  | RA (args[0])\n\n                               | ((args[2] >> 16) & 0xffff));\n\n            }\n\n            else {\n\n                tcg_out32 (s, ORIS | RS (args[1])  | RA (args[0])\n\n                           | ((args[2] >> 16) & 0xffff));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, OR | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_xor_i64:\n\n    case INDEX_op_xor_i32:\n\n        if (const_args[2]) {\n\n            if ((args[2] & 0xffff) == args[2])\n\n                tcg_out32 (s, XORI | RS (args[1])  | RA (args[0])\n\n                           | (args[2] & 0xffff));\n\n            else if ((args[2] & 0xffff0000) == args[2])\n\n                tcg_out32 (s, XORIS | RS (args[1])  | RA (args[0])\n\n                           | ((args[2] >> 16) & 0xffff));\n\n            else {\n\n                tcg_out_movi (s, (opc == INDEX_op_and_i32\n\n                                  ? TCG_TYPE_I32\n\n                                  : TCG_TYPE_I64),\n\n                              0, args[2]);\n\n                tcg_out32 (s, XOR | SAB (args[1], args[0], 0));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, XOR | SAB (args[1], args[0], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_mul_i32:\n\n        if (const_args[2]) {\n\n            if (args[2] == (int16_t) args[2])\n\n                tcg_out32 (s, MULLI | RT (args[0]) | RA (args[1])\n\n                           | (args[2] & 0xffff));\n\n            else {\n\n                tcg_out_movi (s, TCG_TYPE_I32, 0, args[2]);\n\n                tcg_out32 (s, MULLW | TAB (args[0], args[1], 0));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, MULLW | TAB (args[0], args[1], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out32 (s, DIVW | TAB (args[0], args[1], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_divu_i32:\n\n        tcg_out32 (s, DIVWU | TAB (args[0], args[1], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_rem_i32:\n\n        tcg_out32 (s, DIVW | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLW | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n\n\n    case INDEX_op_remu_i32:\n\n        tcg_out32 (s, DIVWU | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLW | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n\n\n    case INDEX_op_shl_i32:\n\n        if (const_args[2]) {\n\n            tcg_out32 (s, (RLWINM\n\n                           | RA (args[0])\n\n                           | RS (args[1])\n\n                           | SH (args[2])\n\n                           | MB (0)\n\n                           | ME (31 - args[2])\n\n                           )\n\n                );\n\n        }\n\n        else\n\n            tcg_out32 (s, SLW | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_shr_i32:\n\n        if (const_args[2]) {\n\n            tcg_out32 (s, (RLWINM\n\n                           | RA (args[0])\n\n                           | RS (args[1])\n\n                           | SH (32 - args[2])\n\n                           | MB (args[2])\n\n                           | ME (31)\n\n                           )\n\n                );\n\n        }\n\n        else\n\n            tcg_out32 (s, SRW | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_sar_i32:\n\n        if (const_args[2])\n\n            tcg_out32 (s, SRAWI | RS (args[1]) | RA (args[0]) | SH (args[2]));\n\n        else\n\n            tcg_out32 (s, SRAW | SAB (args[1], args[0], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond (s, args[2], args[0], args[1], const_args[1], args[3], 0);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond (s, args[2], args[0], args[1], const_args[1], args[3], 1);\n\n        break;\n\n\n\n    case INDEX_op_neg_i32:\n\n    case INDEX_op_neg_i64:\n\n        tcg_out32 (s, NEG | RT (args[0]) | RA (args[1]));\n\n        break;\n\n\n\n    case INDEX_op_add_i64:\n\n        if (const_args[2])\n\n            ppc_addi64 (s, args[0], args[1], args[2]);\n\n        else\n\n            tcg_out32 (s, ADD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_sub_i64:\n\n        if (const_args[2])\n\n            ppc_addi64 (s, args[0], args[1], -args[2]);\n\n        else\n\n            tcg_out32 (s, SUBF | TAB (args[0], args[2], args[1]));\n\n        break;\n\n\n\n    case INDEX_op_shl_i64:\n\n        if (const_args[2])\n\n            tcg_out_rld (s, RLDICR, args[0], args[1], args[2], 63 - args[2]);\n\n        else\n\n            tcg_out32 (s, SLD | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_shr_i64:\n\n        if (const_args[2])\n\n            tcg_out_rld (s, RLDICL, args[0], args[1], 64 - args[2], args[2]);\n\n        else\n\n            tcg_out32 (s, SRD | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_sar_i64:\n\n        if (const_args[2]) {\n\n            int sh = SH (args[2] & 0x1f) | (((args[2] >> 5) & 1) << 1);\n\n            tcg_out32 (s, SRADI | RA (args[0]) | RS (args[1]) | sh);\n\n        }\n\n        else\n\n            tcg_out32 (s, SRAD | SAB (args[1], args[0], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_mul_i64:\n\n        tcg_out32 (s, MULLD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_div_i64:\n\n        tcg_out32 (s, DIVD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_divu_i64:\n\n        tcg_out32 (s, DIVDU | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_rem_i64:\n\n        tcg_out32 (s, DIVD | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLD | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n    case INDEX_op_remu_i64:\n\n        tcg_out32 (s, DIVDU | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLD | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n\n\n    case INDEX_op_qemu_ld8u:\n\n        tcg_out_qemu_ld (s, args, 0);\n\n        break;\n\n    case INDEX_op_qemu_ld8s:\n\n        tcg_out_qemu_ld (s, args, 0 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld16u:\n\n        tcg_out_qemu_ld (s, args, 1);\n\n        break;\n\n    case INDEX_op_qemu_ld16s:\n\n        tcg_out_qemu_ld (s, args, 1 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld32u:\n\n        tcg_out_qemu_ld (s, args, 2);\n\n        break;\n\n    case INDEX_op_qemu_ld32s:\n\n        tcg_out_qemu_ld (s, args, 2 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld64:\n\n        tcg_out_qemu_ld (s, args, 3);\n\n        break;\n\n    case INDEX_op_qemu_st8:\n\n        tcg_out_qemu_st (s, args, 0);\n\n        break;\n\n    case INDEX_op_qemu_st16:\n\n        tcg_out_qemu_st (s, args, 1);\n\n        break;\n\n    case INDEX_op_qemu_st32:\n\n        tcg_out_qemu_st (s, args, 2);\n\n        break;\n\n    case INDEX_op_qemu_st64:\n\n        tcg_out_qemu_st (s, args, 3);\n\n        break;\n\n\n\n    case INDEX_op_ext8s_i32:\n\n    case INDEX_op_ext8s_i64:\n\n        c = EXTSB;\n\n        goto gen_ext;\n\n    case INDEX_op_ext16s_i32:\n\n    case INDEX_op_ext16s_i64:\n\n        c = EXTSH;\n\n        goto gen_ext;\n\n    case INDEX_op_ext32s_i64:\n\n        c = EXTSW;\n\n        goto gen_ext;\n\n    gen_ext:\n\n        tcg_out32 (s, c | RS (args[1]) | RA (args[0]));\n\n        break;\n\n\n\n    default:\n\n        tcg_dump_ops (s, stderr);\n\n        tcg_abort ();\n\n    }\n\n}\n", "idx": 11497}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_bar_quirk_teardown(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    while (!QLIST_EMPTY(&bar->quirks)) {\n\n        VFIOQuirk *quirk = QLIST_FIRST(&bar->quirks);\n\n        memory_region_del_subregion(&bar->mem, &quirk->mem);\n\n\n        QLIST_REMOVE(quirk, next);\n\n        g_free(quirk);\n\n    }\n\n}", "idx": 3458}
{"project": "qemu", "commit_id": "1984745ea8ad309a06690a83e91d031d21d709ff", "target": 1, "func": "static void nand_command(NANDFlashState *s)\n\n{\n\n    unsigned int offset;\n\n    switch (s->cmd) {\n\n    case NAND_CMD_READ0:\n\n        s->iolen = 0;\n\n        break;\n\n\n\n    case NAND_CMD_READID:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        nand_pushio_byte(s, s->manf_id);\n\n        nand_pushio_byte(s, s->chip_id);\n\n        nand_pushio_byte(s, 'Q'); /* Don't-care byte (often 0xa5) */\n\n        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) {\n\n            /* Page Size, Block Size, Spare Size; bit 6 indicates\n\n             * 8 vs 16 bit width NAND.\n\n             */\n\n            nand_pushio_byte(s, (s->buswidth == 2) ? 0x55 : 0x15);\n\n        } else {\n\n            nand_pushio_byte(s, 0xc0); /* Multi-plane */\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_RANDOMREAD2:\n\n    case NAND_CMD_NOSERIALREAD2:\n\n        if (!(nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP))\n\n            break;\n\n        offset = s->addr & ((1 << s->addr_shift) - 1);\n\n        s->blk_load(s, s->addr, offset);\n\n        if (s->gnd)\n\n            s->iolen = (1 << s->page_shift) - offset;\n\n        else\n\n            s->iolen = (1 << s->page_shift) + (1 << s->oob_shift) - offset;\n\n        break;\n\n\n\n    case NAND_CMD_RESET:\n\n        nand_reset(&s->busdev.qdev);\n\n        break;\n\n\n\n    case NAND_CMD_PAGEPROGRAM1:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        break;\n\n\n\n    case NAND_CMD_PAGEPROGRAM2:\n\n        if (s->wp) {\n\n            s->blk_write(s);\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_BLOCKERASE1:\n\n        break;\n\n\n\n    case NAND_CMD_BLOCKERASE2:\n\n        s->addr &= (1ull << s->addrlen * 8) - 1;\n\n        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP)\n\n            s->addr <<= 16;\n\n        else\n\n            s->addr <<= 8;\n\n\n\n        if (s->wp) {\n\n            s->blk_erase(s);\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_READSTATUS:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        nand_pushio_byte(s, s->status);\n\n        break;\n\n\n\n    default:\n\n        printf(\"%s: Unknown NAND command 0x%02x\\n\", __FUNCTION__, s->cmd);\n\n    }\n\n}\n", "idx": 3374}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "TCGOp *tcg_op_insert_after(TCGContext *s, TCGOp *old_op,\n\n                           TCGOpcode opc, int nargs)\n\n{\n\n    int oi = s->gen_next_op_idx;\n\n    int prev = old_op - s->gen_op_buf;\n\n    int next = old_op->next;\n\n    TCGOp *new_op;\n\n\n\n    tcg_debug_assert(oi < OPC_BUF_SIZE);\n\n    s->gen_next_op_idx = oi + 1;\n\n\n\n    new_op = &s->gen_op_buf[oi];\n\n    *new_op = (TCGOp){\n\n        .opc = opc,\n\n        .prev = prev,\n\n        .next = next\n\n    };\n\n    s->gen_op_buf[next].prev = oi;\n\n    old_op->next = oi;\n\n\n\n    return new_op;\n\n}\n", "idx": 2247}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void memory_region_transaction_commit(void)\n{\n    AddressSpace *as;\n    assert(memory_region_transaction_depth);\n    --memory_region_transaction_depth;\n    if (!memory_region_transaction_depth) {\n        if (memory_region_update_pending) {\n            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_topology(as);\n            }\n            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);\n        } else if (ioeventfd_update_pending) {\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_ioeventfds(as);\n            }\n        }\n        memory_region_clear_pending();\n   }\n}", "idx": 60}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void add_to_iovec(QEMUFile *f, const uint8_t *buf, int size)\n\n{\n\n    /* check for adjacent buffer and coalesce them */\n\n    if (f->iovcnt > 0 && buf == f->iov[f->iovcnt - 1].iov_base +\n\n        f->iov[f->iovcnt - 1].iov_len) {\n\n        f->iov[f->iovcnt - 1].iov_len += size;\n\n    } else {\n\n        f->iov[f->iovcnt].iov_base = (uint8_t *)buf;\n\n        f->iov[f->iovcnt++].iov_len = size;\n\n    }\n\n\n\n    if (f->iovcnt >= MAX_IOV_SIZE) {\n\n        qemu_fflush(f);\n\n    }\n\n}\n", "idx": 11200}
{"project": "qemu", "commit_id": "e2f0c49ffae8d3a00272c3cbc68850cc5aafbffa", "target": 1, "func": "static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    if (toclen > req->cmd.xfer) {\n\n        toclen = req->cmd.xfer;\n\n    }\n\n    return toclen;\n\n}\n", "idx": 5729}
{"project": "qemu", "commit_id": "b307446e04232b3a87e9da04886895a8e5a4a407", "target": 1, "func": "void mips_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                         int flags)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx\n\n                \" LO=0x\" TARGET_FMT_lx \" ds %04x \"\n\n                TARGET_FMT_lx \" \" TARGET_FMT_ld \"\\n\",\n\n                env->active_tc.PC, env->active_tc.HI[0], env->active_tc.LO[0],\n\n                env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->active_tc.gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x%016\"\n\n                PRIx64 \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->lladdr);\n\n    cpu_fprintf(f, \"    Config2 0x%08x Config3 0x%08x\\n\",\n\n                env->CP0_Config2, env->CP0_Config3);\n\n    cpu_fprintf(f, \"    Config4 0x%08x Config5 0x%08x\\n\",\n\n                env->CP0_Config4, env->CP0_Config5);\n\n    if (env->hflags & MIPS_HFLAG_FPU)\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 5351}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 8918}
{"project": "qemu", "commit_id": "910f738b851a263396fc85b2052e47f884ffead3", "target": 1, "func": "static void test_qga_invalid_args(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    QDict *ret, *error;\n\n    const gchar *class, *desc;\n\n\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-ping', \"\n\n                 \"'arguments': {'foo': 42 }}\");\n\n    g_assert_nonnull(ret);\n\n\n\n    error = qdict_get_qdict(ret, \"error\");\n\n    class = qdict_get_try_str(error, \"class\");\n\n    desc = qdict_get_try_str(error, \"desc\");\n\n\n\n    g_assert_cmpstr(class, ==, \"GenericError\");\n\n    g_assert_cmpstr(desc, ==, \"QMP input object member 'foo' is unexpected\");\n\n\n\n    QDECREF(ret);\n\n}\n", "idx": 174}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void dpy_gl_scanout(QemuConsole *con,\n\n                    uint32_t backing_id, bool backing_y_0_top,\n\n\n                    uint32_t x, uint32_t y, uint32_t width, uint32_t height)\n\n{\n\n    assert(con->gl);\n\n    con->gl->ops->dpy_gl_scanout(con->gl, backing_id,\n\n                                 backing_y_0_top,\n\n\n                                 x, y, width, height);\n\n}", "idx": 5460}
{"project": "qemu", "commit_id": "7f0278435df1fa845b3bd9556942f89296d4246b", "target": 1, "func": "const char *qdict_get_str(const QDict *qdict, const char *key)\n\n{\n\n    QObject *obj = qdict_get_obj(qdict, key, QTYPE_QSTRING);\n\n    return qstring_get_str(qobject_to_qstring(obj));\n\n}\n", "idx": 8015}
{"project": "qemu", "commit_id": "503b3b33feca818baa4459aba286e54a528e5567", "target": 1, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    DisplaySurface *surface;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = qxl_phys2virt(qxl,\n\n                                                qxl->guest_primary.surface.mem,\n\n                                                MEMSLOT_GROUP_GUEST);\n\n        if (!qxl->guest_primary.data) {\n\n            return;\n\n        }\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            surface = qemu_create_displaysurface_from\n\n                (qxl->guest_primary.surface.width,\n\n                 qxl->guest_primary.surface.height,\n\n                 qxl->guest_primary.bits_pp,\n\n                 qxl->guest_primary.abs_stride,\n\n                 qxl->guest_primary.data,\n\n                 false);\n\n        } else {\n\n            surface = qemu_create_displaysurface\n\n                (qxl->guest_primary.surface.width,\n\n                 qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_replace_surface(vga->con, surface);\n\n    }\n\n\n\n    if (!qxl->guest_primary.data) {\n\n        return;\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        if (qxl->dirty[i].left > qxl->dirty[i].right ||\n\n            qxl->dirty[i].top > qxl->dirty[i].bottom ||\n\n            qxl->dirty[i].right > qxl->guest_primary.surface.width ||\n\n            qxl->dirty[i].bottom > qxl->guest_primary.surface.height) {\n\n            continue;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->con,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 11398}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stb_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint8_t val)\n\n{\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 8882}
{"project": "qemu", "commit_id": "d9123d09f711bf1b855de2b5a907d4c85f46d6c3", "target": 1, "func": "QTestState *qtest_init_without_qmp_handshake(const char *extra_args)\n{\n    QTestState *s;\n    int sock, qmpsock, i;\n    gchar *socket_path;\n    gchar *qmp_socket_path;\n    gchar *command;\n    const char *qemu_binary;\n    qemu_binary = getenv(\"QTEST_QEMU_BINARY\");\n    g_assert(qemu_binary != NULL);\n    s = g_malloc(sizeof(*s));\n    socket_path = g_strdup_printf(\"/tmp/qtest-%d.sock\", getpid());\n    qmp_socket_path = g_strdup_printf(\"/tmp/qtest-%d.qmp\", getpid());\n    sock = init_socket(socket_path);\n    qmpsock = init_socket(qmp_socket_path);\n    qtest_add_abrt_handler(kill_qemu_hook_func, s);\n    s->qemu_pid = fork();\n    if (s->qemu_pid == 0) {\n        setenv(\"QEMU_AUDIO_DRV\", \"none\", true);\n        command = g_strdup_printf(\"exec %s \"\n                                  \"-qtest unix:%s,nowait \"\n                                  \"-qtest-log %s \"\n                                  \"-qmp unix:%s,nowait \"\n                                  \"-machine accel=qtest \"\n                                  \"-display none \"\n                                  \"%s\", qemu_binary, socket_path,\n                                  getenv(\"QTEST_LOG\") ? \"/dev/fd/2\" : \"/dev/null\",\n                                  qmp_socket_path,\n                                  extra_args ?: \"\");\n        execlp(\"/bin/sh\", \"sh\", \"-c\", command, NULL);\n        exit(1);\n    }\n    s->fd = socket_accept(sock);\n    if (s->fd >= 0) {\n        s->qmp_fd = socket_accept(qmpsock);\n    }\n    g_free(socket_path);\n    g_free(qmp_socket_path);\n    g_assert(s->fd >= 0 && s->qmp_fd >= 0);\n    s->rx = g_string_new(\"\");\n    for (i = 0; i < MAX_IRQ; i++) {\n        s->irq_level[i] = false;\n    }\n    if (getenv(\"QTEST_STOP\")) {\n        kill(s->qemu_pid, SIGSTOP);\n    }\n    /* ask endianness of the target */\n    s->big_endian = qtest_query_target_endianness(s);\n    return s;\n}", "idx": 6409}
{"project": "qemu", "commit_id": "90527d2a8bb08ca5b4774eacfdd6b8fe9671c077", "target": 1, "func": "static int get_real_id(const char *devpath, const char *idname, uint16_t *val)\n\n{\n\n    FILE *f;\n\n    char name[128];\n\n    long id;\n\n\n\n    snprintf(name, sizeof(name), \"%s%s\", devpath, idname);\n\n    f = fopen(name, \"r\");\n\n    if (f == NULL) {\n\n        error_report(\"%s: %s: %m\", __func__, name);\n\n        return -1;\n\n    }\n\n    if (fscanf(f, \"%li\\n\", &id) == 1) {\n\n        *val = id;\n\n    } else {\n\n\n        return -1;\n\n    }\n\n\n\n\n    return 0;\n\n}", "idx": 8085}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static void virtio_device_free_virtqueues(VirtIODevice *vdev)\n\n{\n\n    int i;\n\n    if (!vdev->vq) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n\n        VRingMemoryRegionCaches *caches;\n\n        if (vdev->vq[i].vring.num == 0) {\n\n            break;\n\n        }\n\n        caches = atomic_read(&vdev->vq[i].vring.caches);\n\n        atomic_set(&vdev->vq[i].vring.caches, NULL);\n\n        virtio_free_region_cache(caches);\n\n    }\n\n    g_free(vdev->vq);\n\n}\n", "idx": 12251}
{"project": "qemu", "commit_id": "09aaa1602f9381c0e0fb539390b1793e51bdfc7b", "target": 1, "func": "void watchdog_pc_init(PCIBus *pci_bus)\n\n{\n\n    if (watchdog)\n\n        watchdog->wdt_pc_init(pci_bus);\n\n}\n", "idx": 3466}
{"project": "qemu", "commit_id": "7f3be0f20ff8d976ab982cc06026cac0600f1fb6", "target": 1, "func": "static void virtio_gpu_cleanup_mapping(struct virtio_gpu_simple_resource *res)\n\n{\n\n    virtio_gpu_cleanup_mapping_iov(res->iov, res->iov_cnt);\n\n    g_free(res->iov);\n\n    res->iov = NULL;\n\n    res->iov_cnt = 0;\n\n}\n", "idx": 5067}
{"project": "qemu", "commit_id": "a70dadc7f1a3e96a7179c6c3a6ccd1a0ea65760a", "target": 1, "func": "static void tswap_siginfo(target_siginfo_t *tinfo,\n\n                          const target_siginfo_t *info)\n\n{\n\n    int sig = info->si_signo;\n\n    tinfo->si_signo = tswap32(sig);\n\n    tinfo->si_errno = tswap32(info->si_errno);\n\n    tinfo->si_code = tswap32(info->si_code);\n\n\n\n    if (sig == TARGET_SIGILL || sig == TARGET_SIGFPE || sig == TARGET_SIGSEGV\n\n        || sig == TARGET_SIGBUS || sig == TARGET_SIGTRAP) {\n\n        tinfo->_sifields._sigfault._addr\n\n            = tswapal(info->_sifields._sigfault._addr);\n\n    } else if (sig == TARGET_SIGIO) {\n\n        tinfo->_sifields._sigpoll._band\n\n            = tswap32(info->_sifields._sigpoll._band);\n\n        tinfo->_sifields._sigpoll._fd = tswap32(info->_sifields._sigpoll._fd);\n\n    } else if (sig == TARGET_SIGCHLD) {\n\n        tinfo->_sifields._sigchld._pid\n\n            = tswap32(info->_sifields._sigchld._pid);\n\n        tinfo->_sifields._sigchld._uid\n\n            = tswap32(info->_sifields._sigchld._uid);\n\n        tinfo->_sifields._sigchld._status\n\n            = tswap32(info->_sifields._sigchld._status);\n\n        tinfo->_sifields._sigchld._utime\n\n            = tswapal(info->_sifields._sigchld._utime);\n\n        tinfo->_sifields._sigchld._stime\n\n            = tswapal(info->_sifields._sigchld._stime);\n\n    } else if (sig >= TARGET_SIGRTMIN) {\n\n        tinfo->_sifields._rt._pid = tswap32(info->_sifields._rt._pid);\n\n        tinfo->_sifields._rt._uid = tswap32(info->_sifields._rt._uid);\n\n        tinfo->_sifields._rt._sigval.sival_ptr\n\n            = tswapal(info->_sifields._rt._sigval.sival_ptr);\n\n    }\n\n}\n", "idx": 10598}
{"project": "qemu", "commit_id": "1a71992376792a0d11ea27688bd1a21cdffd1826", "target": 1, "func": "static void do_mchk_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    MchkQueue *q;\n\n    int i;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_MCHECK)) {\n\n        cpu_abort(CPU(cpu), \"Machine check w/o mchk mask\\n\");\n\n    }\n\n\n\n    if (env->mchk_index < 0 || env->mchk_index > MAX_MCHK_QUEUE) {\n\n        cpu_abort(CPU(cpu), \"Mchk queue overrun: %d\\n\", env->mchk_index);\n\n    }\n\n\n\n    q = &env->mchk_queue[env->mchk_index];\n\n\n\n    if (q->type != 1) {\n\n        /* Don't know how to handle this... */\n\n        cpu_abort(CPU(cpu), \"Unknown machine check type %d\\n\", q->type);\n\n    }\n\n    if (!(env->cregs[14] & (1 << 28))) {\n\n        /* CRW machine checks disabled */\n\n        return;\n\n    }\n\n\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        lowcore->floating_pt_save_area[i] = cpu_to_be64(env->fregs[i].ll);\n\n        lowcore->gpregs_save_area[i] = cpu_to_be64(env->regs[i]);\n\n        lowcore->access_regs_save_area[i] = cpu_to_be32(env->aregs[i]);\n\n        lowcore->cregs_save_area[i] = cpu_to_be64(env->cregs[i]);\n\n    }\n\n    lowcore->prefixreg_save_area = cpu_to_be32(env->psa);\n\n    lowcore->fpt_creg_save_area = cpu_to_be32(env->fpc);\n\n    lowcore->tod_progreg_save_area = cpu_to_be32(env->todpr);\n\n    lowcore->cpu_timer_save_area[0] = cpu_to_be32(env->cputm >> 32);\n\n    lowcore->cpu_timer_save_area[1] = cpu_to_be32((uint32_t)env->cputm);\n\n    lowcore->clock_comp_save_area[0] = cpu_to_be32(env->ckc >> 32);\n\n    lowcore->clock_comp_save_area[1] = cpu_to_be32((uint32_t)env->ckc);\n\n\n\n    lowcore->mcck_interruption_code[0] = cpu_to_be32(0x00400f1d);\n\n    lowcore->mcck_interruption_code[1] = cpu_to_be32(0x40330000);\n\n    lowcore->mcck_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->mcck_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n    mask = be64_to_cpu(lowcore->mcck_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->mcck_new_psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    env->mchk_index--;\n\n    if (env->mchk_index == -1) {\n\n        env->pending_int &= ~INTERRUPT_MCHK;\n\n    }\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 6239}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "int qcow2_grow_l1_table(BlockDriverState *bs, int min_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int new_l1_size, new_l1_size2, ret, i;\n\n    uint64_t *new_l1_table;\n\n    int64_t new_l1_table_offset;\n\n    uint8_t data[12];\n\n\n\n    new_l1_size = s->l1_size;\n\n    if (min_size <= new_l1_size)\n\n        return 0;\n\n    if (new_l1_size == 0) {\n\n        new_l1_size = 1;\n\n    }\n\n    while (min_size > new_l1_size) {\n\n        new_l1_size = (new_l1_size * 3 + 1) / 2;\n\n    }\n\n#ifdef DEBUG_ALLOC2\n\n    printf(\"grow l1_table from %d to %d\\n\", s->l1_size, new_l1_size);\n\n#endif\n\n\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n\n    new_l1_table = qemu_mallocz(align_offset(new_l1_size2, 512));\n\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n\n\n    /* write new table (align to cluster) */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n\n    if (new_l1_table_offset < 0) {\n\n        qemu_free(new_l1_table);\n\n        return new_l1_table_offset;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n\n    ret = bdrv_pwrite(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n\n    if (ret != new_l1_size2)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n\n\n    /* set new table */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n\n    cpu_to_be64w((uint64_t*)(data + 4), new_l1_table_offset);\n\n    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n\n    if (ret != sizeof(data)) {\n\n        goto fail;\n\n    }\n\n    qemu_free(s->l1_table);\n\n    qcow2_free_clusters(bs, s->l1_table_offset, s->l1_size * sizeof(uint64_t));\n\n    s->l1_table_offset = new_l1_table_offset;\n\n    s->l1_table = new_l1_table;\n\n    s->l1_size = new_l1_size;\n\n    return 0;\n\n fail:\n\n    qemu_free(new_l1_table);\n\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2);\n\n    return ret < 0 ? ret : -EIO;\n\n}\n", "idx": 2703}
{"project": "qemu", "commit_id": "7cd1e32a860895ccca89eb90a0226efbcd969b55", "target": 1, "func": "int bdrv_write(BlockDriverState *bs, int64_t sector_num,\n\n               const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!bs->drv)\n\n        return -ENOMEDIUM;\n\n    if (bs->read_only)\n\n        return -EACCES;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return -EIO;\n\n\n\n    return drv->bdrv_write(bs, sector_num, buf, nb_sectors);\n\n}\n", "idx": 7404}
{"project": "qemu", "commit_id": "e5c67ab552fb056827b5b40356c0ef235e975e7e", "target": 1, "func": "static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_bh_schedule_oneshot(bdrv_get_aio_context(bs), error_callback_bh,\n\n                                qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n", "idx": 5557}
{"project": "qemu", "commit_id": "a9175169cc55ecff23a158dfee7d9cbb0b75d185", "target": 1, "func": "long do_rt_sigreturn(CPUTLGState *env)\n\n{\n\n    abi_ulong frame_addr = env->regs[TILEGX_R_SP];\n\n    struct target_rt_sigframe *frame;\n\n    sigset_t set;\n\n\n\n    trace_user_do_rt_sigreturn(env, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    restore_sigcontext(env, &frame->uc.tuc_mcontext);\n\n    if (do_sigaltstack(frame_addr + offsetof(struct target_rt_sigframe,\n\n                                             uc.tuc_stack),\n\n                       0, env->regs[TILEGX_R_SP]) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->regs[TILEGX_R_RE];\n\n\n\n\n\n badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 2762}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "void ppc_tlb_invalidate_all (CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL_4xx:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_601:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model %d\\n\", env->mmu_model);\n\n        break;\n\n    }\n\n}\n", "idx": 2780}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_store_exclusive(DisasContext *s, int rd, int rt, int rt2,\n\n                                TCGv addr, int size)\n\n{\n\n    TCGv tmp;\n\n    int done_label;\n\n    int fail_label;\n\n\n\n    /* if (env->exclusive_addr == addr && env->exclusive_val == [addr]) {\n\n         [addr] = {Rt};\n\n         {Rd} = 0;\n\n       } else {\n\n         {Rd} = 1;\n\n       } */\n\n    fail_label = gen_new_label();\n\n    done_label = gen_new_label();\n\n    tcg_gen_brcond_i32(TCG_COND_NE, addr, cpu_exclusive_addr, fail_label);\n\n    switch (size) {\n\n    case 0:\n\n        tmp = gen_ld8u(addr, IS_USER(s));\n\n        break;\n\n    case 1:\n\n        tmp = gen_ld16u(addr, IS_USER(s));\n\n        break;\n\n    case 2:\n\n    case 3:\n\n        tmp = gen_ld32(addr, IS_USER(s));\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    tcg_gen_brcond_i32(TCG_COND_NE, tmp, cpu_exclusive_val, fail_label);\n\n    dead_tmp(tmp);\n\n    if (size == 3) {\n\n        TCGv tmp2 = new_tmp();\n\n        tcg_gen_addi_i32(tmp2, addr, 4);\n\n        tmp = gen_ld32(tmp2, IS_USER(s));\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcond_i32(TCG_COND_NE, tmp, cpu_exclusive_high, fail_label);\n\n        dead_tmp(tmp);\n\n    }\n\n    tmp = load_reg(s, rt);\n\n    switch (size) {\n\n    case 0:\n\n        gen_st8(tmp, addr, IS_USER(s));\n\n        break;\n\n    case 1:\n\n        gen_st16(tmp, addr, IS_USER(s));\n\n        break;\n\n    case 2:\n\n    case 3:\n\n        gen_st32(tmp, addr, IS_USER(s));\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (size == 3) {\n\n        tcg_gen_addi_i32(addr, addr, 4);\n\n        tmp = load_reg(s, rt2);\n\n        gen_st32(tmp, addr, IS_USER(s));\n\n    }\n\n    tcg_gen_movi_i32(cpu_R[rd], 0);\n\n    tcg_gen_br(done_label);\n\n    gen_set_label(fail_label);\n\n    tcg_gen_movi_i32(cpu_R[rd], 1);\n\n    gen_set_label(done_label);\n\n    tcg_gen_movi_i32(cpu_exclusive_addr, -1);\n\n}\n", "idx": 11418}
{"project": "qemu", "commit_id": "2ba82852894c762299b7d05e9a2be184116b80f0", "target": 1, "func": "static void *file_ram_alloc(RAMBlock *block,\n\n                            ram_addr_t memory,\n\n                            const char *path)\n\n{\n\n    char *filename;\n\n    char *sanitized_name;\n\n    char *c;\n\n    void *area;\n\n    int fd;\n\n    unsigned long hpagesize;\n\n\n\n    hpagesize = gethugepagesize(path);\n\n    if (!hpagesize) {\n\n        return NULL;\n\n    }\n\n\n\n    if (memory < hpagesize) {\n\n        return NULL;\n\n    }\n\n\n\n    if (kvm_enabled() && !kvm_has_sync_mmu()) {\n\n        fprintf(stderr, \"host lacks kvm mmu notifiers, -mem-path unsupported\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    /* Make name safe to use with mkstemp by replacing '/' with '_'. */\n\n    sanitized_name = g_strdup(block->mr->name);\n\n    for (c = sanitized_name; *c != '\\0'; c++) {\n\n        if (*c == '/')\n\n            *c = '_';\n\n    }\n\n\n\n    filename = g_strdup_printf(\"%s/qemu_back_mem.%s.XXXXXX\", path,\n\n                               sanitized_name);\n\n    g_free(sanitized_name);\n\n\n\n    fd = mkstemp(filename);\n\n    if (fd < 0) {\n\n        perror(\"unable to create backing store for hugepages\");\n\n        g_free(filename);\n\n        return NULL;\n\n    }\n\n    unlink(filename);\n\n    g_free(filename);\n\n\n\n    memory = (memory+hpagesize-1) & ~(hpagesize-1);\n\n\n\n    /*\n\n     * ftruncate is not supported by hugetlbfs in older\n\n     * hosts, so don't bother bailing out on errors.\n\n     * If anything goes wrong with it under other filesystems,\n\n     * mmap will fail.\n\n     */\n\n    if (ftruncate(fd, memory))\n\n        perror(\"ftruncate\");\n\n\n\n    area = mmap(0, memory, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\n    if (area == MAP_FAILED) {\n\n        perror(\"file_ram_alloc: can't mmap RAM pages\");\n\n        close(fd);\n\n        return (NULL);\n\n    }\n\n\n\n    if (mem_prealloc) {\n\n        int ret, i;\n\n        struct sigaction act, oldact;\n\n        sigset_t set, oldset;\n\n\n\n        memset(&act, 0, sizeof(act));\n\n        act.sa_handler = &sigbus_handler;\n\n        act.sa_flags = 0;\n\n\n\n        ret = sigaction(SIGBUS, &act, &oldact);\n\n        if (ret) {\n\n            perror(\"file_ram_alloc: failed to install signal handler\");\n\n            exit(1);\n\n        }\n\n\n\n        /* unblock SIGBUS */\n\n        sigemptyset(&set);\n\n        sigaddset(&set, SIGBUS);\n\n        pthread_sigmask(SIG_UNBLOCK, &set, &oldset);\n\n\n\n        if (sigsetjmp(sigjump, 1)) {\n\n            fprintf(stderr, \"file_ram_alloc: failed to preallocate pages\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* MAP_POPULATE silently ignores failures */\n\n        for (i = 0; i < (memory/hpagesize)-1; i++) {\n\n            memset(area + (hpagesize*i), 0, 1);\n\n        }\n\n\n\n        ret = sigaction(SIGBUS, &oldact, NULL);\n\n        if (ret) {\n\n            perror(\"file_ram_alloc: failed to reinstall signal handler\");\n\n            exit(1);\n\n        }\n\n\n\n        pthread_sigmask(SIG_SETMASK, &oldset, NULL);\n\n    }\n\n\n\n    block->fd = fd;\n\n    return area;\n\n}\n", "idx": 4639}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int i;\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        for (i = 0; i < TB_JMP_CACHE_SIZE; ++i) {\n\n            atomic_set(&cpu->tb_jmp_cache[i], NULL);\n\n        }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n", "idx": 506}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbli_6xx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_6xx_tlbi(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 11003}
{"project": "qemu", "commit_id": "57d84cf35302fe51789c18354bf09a521bb603df", "target": 1, "func": "static void remove_port(VirtIOSerial *vser, uint32_t port_id)\n\n{\n\n    VirtIOSerialPort *port;\n\n    unsigned int i;\n\n\n\n    i = port_id / 32;\n\n    vser->ports_map[i] &= ~(1U << (port_id % 32));\n\n\n\n    port = find_port_by_id(vser, port_id);\n\n    /*\n\n     * This function is only called from qdev's unplug callback; if we\n\n     * get a NULL port here, we're in trouble.\n\n     */\n\n    assert(port);\n\n\n\n    /* Flush out any unconsumed buffers first */\n\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n\n\n    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);\n\n}\n", "idx": 1006}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_mig_unlock(void)\n\n{\n\n    qemu_mutex_unlock(&block_mig_state.lock);\n\n}\n", "idx": 233}
{"project": "qemu", "commit_id": "6f9faa91f5fb3a866f5bf592207c9498a017740d", "target": 1, "func": "void sh_intc_register_sources(struct intc_desc *desc,\n\n\t\t\t      struct intc_vect *vectors,\n\n\t\t\t      int nr_vectors,\n\n\t\t\t      struct intc_group *groups,\n\n\t\t\t      int nr_groups)\n\n{\n\n    unsigned int i, k;\n\n    struct intc_source *s;\n\n\n\n    for (i = 0; i < nr_vectors; i++) {\n\n\tstruct intc_vect *vect = vectors + i;\n\n\n\n\tsh_intc_register_source(desc, vect->enum_id, groups, nr_groups);\n\n\ts = sh_intc_source(desc, vect->enum_id);\n\n\tif (s)\n\n\t    s->vect = vect->vect;\n\n\n\n#ifdef DEBUG_INTC_SOURCES\n\n\tprintf(\"sh_intc: registered source %d -> 0x%04x (%d/%d)\\n\",\n\n\t       vect->enum_id, s->vect, s->enable_count, s->enable_max);\n\n#endif\n\n    }\n\n\n\n    if (groups) {\n\n        for (i = 0; i < nr_groups; i++) {\n\n\t    struct intc_group *gr = groups + i;\n\n\n\n\t    s = sh_intc_source(desc, gr->enum_id);\n\n\t    s->next_enum_id = gr->enum_ids[0];\n\n\n\n\t    for (k = 1; k < ARRAY_SIZE(gr->enum_ids); k++) {\n\n                if (!gr->enum_ids[k])\n\n                    continue;\n\n\n\n\t\ts = sh_intc_source(desc, gr->enum_ids[k - 1]);\n\n\t\ts->next_enum_id = gr->enum_ids[k];\n\n\t    }\n\n\n\n#ifdef DEBUG_INTC_SOURCES\n\n\t    printf(\"sh_intc: registered group %d (%d/%d)\\n\",\n\n\t\t   gr->enum_id, s->enable_count, s->enable_max);\n\n#endif\n\n\t}\n\n    }\n\n}\n", "idx": 3962}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static int serial_can_receive(SerialState *s)\n\n{\n\n    return !(s->lsr & UART_LSR_DR);\n\n}\n", "idx": 3958}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        TCGLabel *l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n", "idx": 6395}
{"project": "qemu", "commit_id": "61c7480fa36775cc2baa2f8141f0c64a15f827b5", "target": 1, "func": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n", "idx": 376}
{"project": "qemu", "commit_id": "62f94fc94f98095173146e753a1f03d7c2cc7ba3", "target": 1, "func": "static void icp_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->vmsd = &vmstate_icp_server;\n\n    dc->realize = icp_realize;\n\n\n}", "idx": 951}
{"project": "qemu", "commit_id": "53111180946a56d314a9c1d07d09b9ef91e847b9", "target": 1, "func": "static int arm_gic_init(SysBusDevice *dev)\n\n{\n\n    /* Device instance init function for the GIC sysbus device */\n\n    int i;\n\n    GICState *s = FROM_SYSBUS(GICState, dev);\n\n    ARMGICClass *agc = ARM_GIC_GET_CLASS(s);\n\n\n\n    agc->parent_init(dev);\n\n\n\n    gic_init_irqs_and_distributor(s, s->num_irq);\n\n\n\n    /* Memory regions for the CPU interfaces (NVIC doesn't have these):\n\n     * a region for \"CPU interface for this core\", then a region for\n\n     * \"CPU interface for core 0\", \"for core 1\", ...\n\n     * NB that the memory region size of 0x100 applies for the 11MPCore\n\n     * and also cores following the GIC v1 spec (ie A9).\n\n     * GIC v2 defines a larger memory region (0x1000) so this will need\n\n     * to be extended when we implement A15.\n\n     */\n\n    memory_region_init_io(&s->cpuiomem[0], &gic_thiscpu_ops, s,\n\n                          \"gic_cpu\", 0x100);\n\n    for (i = 0; i < NUM_CPU(s); i++) {\n\n        s->backref[i] = s;\n\n        memory_region_init_io(&s->cpuiomem[i+1], &gic_cpu_ops, &s->backref[i],\n\n                              \"gic_cpu\", 0x100);\n\n    }\n\n    /* Distributor */\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n    /* cpu interfaces (one for \"current cpu\" plus one per cpu) */\n\n    for (i = 0; i <= NUM_CPU(s); i++) {\n\n        sysbus_init_mmio(dev, &s->cpuiomem[i]);\n\n    }\n\n    return 0;\n\n}\n", "idx": 9015}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix4_ide_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = pci_piix_ide_initfn;\n\n    k->exit = pci_piix_ide_exitfn;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82371AB;\n\n    k->class_id = PCI_CLASS_STORAGE_IDE;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    dc->no_user = 1;\n\n}\n", "idx": 10149}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void lsi_do_dma(LSIState *s, int out)\n\n{\n\n    uint32_t count, id;\n\n    target_phys_addr_t addr;\n\n    SCSIDevice *dev;\n\n\n\n    assert(s->current);\n\n    if (!s->current->dma_len) {\n\n        /* Wait until data is available.  */\n\n        DPRINTF(\"DMA no data available\\n\");\n\n        return;\n\n    }\n\n\n\n    id = (s->current->tag >> 8) & 0xf;\n\n    dev = s->bus.devs[id];\n\n    if (!dev) {\n\n        lsi_bad_selection(s, id);\n\n        return;\n\n    }\n\n\n\n    count = s->dbc;\n\n    if (count > s->current->dma_len)\n\n        count = s->current->dma_len;\n\n\n\n    addr = s->dnad;\n\n    /* both 40 and Table Indirect 64-bit DMAs store upper bits in dnad64 */\n\n    if (lsi_dma_40bit(s) || lsi_dma_ti64bit(s))\n\n        addr |= ((uint64_t)s->dnad64 << 32);\n\n    else if (s->dbms)\n\n        addr |= ((uint64_t)s->dbms << 32);\n\n    else if (s->sbms)\n\n        addr |= ((uint64_t)s->sbms << 32);\n\n\n\n    DPRINTF(\"DMA addr=0x\" TARGET_FMT_plx \" len=%d\\n\", addr, count);\n\n    s->csbc += count;\n\n    s->dnad += count;\n\n    s->dbc -= count;\n\n\n\n    if (s->current->dma_buf == NULL) {\n\n        s->current->dma_buf = dev->info->get_buf(dev, s->current->tag);\n\n    }\n\n\n\n    /* ??? Set SFBR to first data byte.  */\n\n    if (out) {\n\n        cpu_physical_memory_read(addr, s->current->dma_buf, count);\n\n    } else {\n\n        cpu_physical_memory_write(addr, s->current->dma_buf, count);\n\n    }\n\n    s->current->dma_len -= count;\n\n    if (s->current->dma_len == 0) {\n\n        s->current->dma_buf = NULL;\n\n        if (out) {\n\n            /* Write the data.  */\n\n            dev->info->write_data(dev, s->current->tag);\n\n        } else {\n\n            /* Request any remaining data.  */\n\n            dev->info->read_data(dev, s->current->tag);\n\n        }\n\n    } else {\n\n        s->current->dma_buf += count;\n\n        lsi_resume_script(s);\n\n    }\n\n}\n", "idx": 7831}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void usb_msd_cancel_io(USBPacket *p, void *opaque)\n\n{\n\n    MSDState *s = opaque;\n\n    s->scsi_dev->info->cancel_io(s->scsi_dev, s->tag);\n\n    s->packet = NULL;\n\n    s->scsi_len = 0;\n\n}\n", "idx": 9965}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfsrin_64b(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    tcg_gen_shri_tl(t0, cpu_gpr[rB(ctx->opcode)], 28);\n\n    tcg_gen_andi_tl(t0, t0, 0xF);\n\n    gen_helper_load_sr(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 1169}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static uint64_t master_abort_mem_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n   return -1ULL;\n\n}\n", "idx": 10215}
{"project": "qemu", "commit_id": "80b262e1439a22708e1c535b75363d4b90c3b41d", "target": 1, "func": "static void qemu_rdma_cleanup(RDMAContext *rdma)\n\n{\n\n    struct rdma_cm_event *cm_event;\n\n    int ret, idx;\n\n\n\n    if (rdma->cm_id && rdma->connected) {\n\n        if (rdma->error_state) {\n\n            RDMAControlHeader head = { .len = 0,\n\n                                       .type = RDMA_CONTROL_ERROR,\n\n                                       .repeat = 1,\n\n                                     };\n\n            error_report(\"Early error. Sending error.\");\n\n            qemu_rdma_post_send_control(rdma, NULL, &head);\n\n        }\n\n\n\n        ret = rdma_disconnect(rdma->cm_id);\n\n        if (!ret) {\n\n            trace_qemu_rdma_cleanup_waiting_for_disconnect();\n\n            ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n            if (!ret) {\n\n                rdma_ack_cm_event(cm_event);\n\n            }\n\n        }\n\n        trace_qemu_rdma_cleanup_disconnect();\n\n        rdma->connected = false;\n\n    }\n\n\n\n    g_free(rdma->block);\n\n    rdma->block = NULL;\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        if (rdma->wr_data[idx].control_mr) {\n\n            rdma->total_registrations--;\n\n            ibv_dereg_mr(rdma->wr_data[idx].control_mr);\n\n        }\n\n        rdma->wr_data[idx].control_mr = NULL;\n\n    }\n\n\n\n    if (rdma->local_ram_blocks.block) {\n\n        while (rdma->local_ram_blocks.nb_blocks) {\n\n            rdma_delete_block(rdma, rdma->local_ram_blocks.block->offset);\n\n        }\n\n    }\n\n\n\n    if (rdma->cq) {\n\n        ibv_destroy_cq(rdma->cq);\n\n        rdma->cq = NULL;\n\n    }\n\n    if (rdma->comp_channel) {\n\n        ibv_destroy_comp_channel(rdma->comp_channel);\n\n        rdma->comp_channel = NULL;\n\n    }\n\n    if (rdma->pd) {\n\n        ibv_dealloc_pd(rdma->pd);\n\n        rdma->pd = NULL;\n\n    }\n\n    if (rdma->listen_id) {\n\n        rdma_destroy_id(rdma->listen_id);\n\n        rdma->listen_id = NULL;\n\n    }\n\n    if (rdma->cm_id) {\n\n        if (rdma->qp) {\n\n            rdma_destroy_qp(rdma->cm_id);\n\n            rdma->qp = NULL;\n\n        }\n\n        rdma_destroy_id(rdma->cm_id);\n\n        rdma->cm_id = NULL;\n\n    }\n\n    if (rdma->channel) {\n\n        rdma_destroy_event_channel(rdma->channel);\n\n        rdma->channel = NULL;\n\n    }\n\n    g_free(rdma->host);\n\n    rdma->host = NULL;\n\n}\n", "idx": 7599}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int qcow2_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret, new_l1_size;\n\n\n\n    if (offset & 511) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* cannot proceed if image has snapshots */\n\n    if (s->nb_snapshots) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    /* shrinking is currently not supported */\n\n    if (offset < bs->total_sectors * 512) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    new_l1_size = size_to_l1(s, offset);\n\n    ret = qcow2_grow_l1_table(bs, new_l1_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* write updated header.size */\n\n    offset = cpu_to_be64(offset);\n\n    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, size),\n\n                      &offset, sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    s->l1_vm_state_index = new_l1_size;\n\n    return 0;\n\n}\n", "idx": 9850}
{"project": "qemu", "commit_id": "e864cabdc0a38bb598ddcf88b264896dc6f3e3b2", "target": 1, "func": "PPC_OP(clear_xer_cr)\n\n{\n\n    xer_so = 0;\n\n    xer_ov = 0;\n\n    xer_ca = 0;\n\n    RETURN();\n\n}\n", "idx": 3094}
{"project": "qemu", "commit_id": "576c6eb6700d241c9d4a6883d25720c7bbaaeccd", "target": 1, "func": "int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n\n             int vnet_hdr_required, int mq_required, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    char  dev[10]=\"\";\n\n    int fd;\n\n    if( (fd = tap_alloc(dev, sizeof(dev))) < 0 ){\n\n       fprintf(stderr, \"Cannot allocate TAP device\\n\");\n\n       return -1;\n\n    }\n\n    pstrcpy(ifname, ifname_size, dev);\n\n    if (*vnet_hdr) {\n\n        /* Solaris doesn't have IFF_VNET_HDR */\n\n        *vnet_hdr = 0;\n\n\n\n        if (vnet_hdr_required && !*vnet_hdr) {\n\n            error_report(\"vnet_hdr=1 requested, but no kernel \"\n\n                         \"support for IFF_VNET_HDR available\");\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    }\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n    return fd;\n\n}\n", "idx": 10425}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void mips_cpu_class_init(ObjectClass *c, void *data)\n\n{\n\n    MIPSCPUClass *mcc = MIPS_CPU_CLASS(c);\n\n    CPUClass *cc = CPU_CLASS(c);\n\n    DeviceClass *dc = DEVICE_CLASS(c);\n\n\n\n    mcc->parent_realize = dc->realize;\n\n    dc->realize = mips_cpu_realizefn;\n\n\n\n    mcc->parent_reset = cc->reset;\n\n    cc->reset = mips_cpu_reset;\n\n\n\n    cc->has_work = mips_cpu_has_work;\n\n    cc->do_interrupt = mips_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = mips_cpu_exec_interrupt;\n\n    cc->dump_state = mips_cpu_dump_state;\n\n    cc->set_pc = mips_cpu_set_pc;\n\n    cc->synchronize_from_tb = mips_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = mips_cpu_gdb_read_register;\n\n    cc->gdb_write_register = mips_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = mips_cpu_handle_mmu_fault;\n\n#else\n\n    cc->do_unassigned_access = mips_cpu_unassigned_access;\n\n    cc->do_unaligned_access = mips_cpu_do_unaligned_access;\n\n    cc->get_phys_page_debug = mips_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_mips_cpu;\n\n#endif\n\n    cc->disas_set_info = mips_cpu_disas_set_info;\n\n\n\n    cc->gdb_num_core_regs = 73;\n\n    cc->gdb_stop_before_watchpoint = true;\n\n\n\n    /*\n\n     * Reason: mips_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 483}
{"project": "qemu", "commit_id": "fdd26fca3ce66863e547560fbde1a444fc5d71b7", "target": 1, "func": "void qtest_quit(QTestState *s)\n\n{\n\n    int status;\n\n\n\n    pid_t pid = qtest_qemu_pid(s);\n\n    if (pid != -1) {\n\n        kill(pid, SIGTERM);\n\n        waitpid(pid, &status, 0);\n\n    }\n\n\n\n\n\n\n    unlink(s->pid_file);\n\n    unlink(s->socket_path);\n\n    unlink(s->qmp_socket_path);\n\n    g_free(s->pid_file);\n\n    g_free(s->socket_path);\n\n    g_free(s->qmp_socket_path);\n\n\n}", "idx": 4025}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "ISABus *isa_bus_new(DeviceState *dev)\n\n{\n\n    if (isabus) {\n\n        fprintf(stderr, \"Can't create a second ISA bus\\n\");\n\n        return NULL;\n\n    }\n\n    if (NULL == dev) {\n\n        dev = qdev_create(NULL, \"isabus-bridge\");\n\n        qdev_init(dev);\n\n    }\n\n\n\n    isabus = FROM_QBUS(ISABus, qbus_create(&isa_bus_info, dev, NULL));\n\n    return isabus;\n\n}\n", "idx": 4358}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static int vnc_display_disable_login(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -1;\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n    }\n\n\n\n    vs->password = NULL;\n\n    if (vs->auth == VNC_AUTH_NONE) {\n\n        vs->auth = VNC_AUTH_VNC;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6433}
{"project": "qemu", "commit_id": "88affa1c77c9019f3450f851495997897bd14e40", "target": 1, "func": "static void do_info_trace(Monitor *mon)\n\n{\n\n    st_print_trace((FILE *)mon, &monitor_fprintf);\n\n}\n", "idx": 10593}
{"project": "qemu", "commit_id": "540c79fec9e8b6a6582ec4c65aa2c4c5366e4b89", "target": 1, "func": "int inet_connect_opts(QemuOpts *opts, bool *in_progress, Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock,rc;\n\n    bool block;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (in_progress) {\n\n        *in_progress = false;\n\n    }\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    block = qemu_opt_get_bool(opts, \"block\", 0);\n\n    if (addr == NULL || port == NULL) {\n\n        fprintf(stderr, \"inet_connect: host and/or port not specified\\n\");\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    /* lookup */\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &res))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n\treturn -1;\n\n    }\n\n\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        if (getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n                            uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                            NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n            fprintf(stderr,\"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n            continue;\n\n        }\n\n        sock = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (sock < 0) {\n\n            fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n            inet_strfamily(e->ai_family), strerror(errno));\n\n            continue;\n\n        }\n\n        setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n        if (!block) {\n\n            socket_set_nonblock(sock);\n\n        }\n\n        /* connect to peer */\n\n        do {\n\n            rc = 0;\n\n            if (connect(sock, e->ai_addr, e->ai_addrlen) < 0) {\n\n                rc = -socket_error();\n\n            }\n\n        } while (rc == -EINTR);\n\n\n\n  #ifdef _WIN32\n\n        if (!block && (rc == -EINPROGRESS || rc == -EWOULDBLOCK\n\n                       || rc == -WSAEALREADY)) {\n\n  #else\n\n        if (!block && (rc == -EINPROGRESS)) {\n\n  #endif\n\n            if (in_progress) {\n\n                *in_progress = true;\n\n            }\n\n\n\n            error_set(errp, QERR_SOCKET_CONNECT_IN_PROGRESS);\n\n        } else if (rc < 0) {\n\n            if (NULL == e->ai_next)\n\n                fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                        inet_strfamily(e->ai_family),\n\n                        e->ai_canonname, uaddr, uport, strerror(errno));\n\n            closesocket(sock);\n\n            continue;\n\n        }\n\n        freeaddrinfo(res);\n\n        return sock;\n\n    }\n\n    error_set(errp, QERR_SOCKET_CONNECT_FAILED);\n\n    freeaddrinfo(res);\n\n    return -1;\n\n}\n", "idx": 974}
{"project": "qemu", "commit_id": "4c2e5f8f46a17966dc45b5a3e07b97434c0eabdf", "target": 1, "func": "static int qcow2_mark_clean(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_DIRTY) {\n\n        int ret = bdrv_flush(bs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        s->incompatible_features &= ~QCOW2_INCOMPAT_DIRTY;\n\n        return qcow2_update_header(bs);\n\n    }\n\n    return 0;\n\n}\n", "idx": 8776}
{"project": "qemu", "commit_id": "792b45b142e6b901e1de20886bc3369211582b8c", "target": 1, "func": "static void checkpoint(void) {\n\n    assert(((mapping_t*)array_get(&(vvv->mapping), 0))->end == 2);\n\n    check1(vvv);\n\n    check2(vvv);\n\n    assert(!vvv->current_mapping || vvv->current_fd || (vvv->current_mapping->mode & MODE_DIRECTORY));\n\n#if 0\n\n    if (((direntry_t*)vvv->directory.pointer)[1].attributes != 0xf)\n\n\tfprintf(stderr, \"Nonono!\\n\");\n\n    mapping_t* mapping;\n\n    direntry_t* direntry;\n\n    assert(vvv->mapping.size >= vvv->mapping.item_size * vvv->mapping.next);\n\n    assert(vvv->directory.size >= vvv->directory.item_size * vvv->directory.next);\n\n    if (vvv->mapping.next<47)\n\n\treturn;\n\n    assert((mapping = array_get(&(vvv->mapping), 47)));\n\n    assert(mapping->dir_index < vvv->directory.next);\n\n    direntry = array_get(&(vvv->directory), mapping->dir_index);\n\n    assert(!memcmp(direntry->name, \"USB     H  \", 11) || direntry->name[0]==0);\n\n#endif\n\n    return;\n\n    /* avoid compiler warnings: */\n\n    hexdump(NULL, 100);\n\n    remove_mapping(vvv, NULL);\n\n    print_mapping(NULL);\n\n    print_direntry(NULL);\n\n}\n", "idx": 6420}
{"project": "qemu", "commit_id": "ac58fe7b2c67a9be142beacd4c6ee51f3264d90f", "target": 1, "func": "static void pmac_ide_transfer_cb(void *opaque, int ret)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    int64_t sector_num;\n\n    int nsector, remainder;\n\n    int64_t offset;\n\n\n\n    MACIO_DPRINTF(\"pmac_ide_transfer_cb\\n\");\n\n\n\n    if (ret < 0) {\n\n        MACIO_DPRINTF(\"DMA error\\n\");\n\n        m->aiocb = NULL;\n\n        ide_dma_error(s);\n\n        io->remainder_len = 0;\n\n        goto done;\n\n    }\n\n\n\n    if (!m->dma_active) {\n\n        MACIO_DPRINTF(\"waiting for data (%#x - %#x - %x)\\n\",\n\n                      s->nsector, io->len, s->status);\n\n        /* data not ready yet, wait for the channel to get restarted */\n\n        io->processing = false;\n\n        return;\n\n    }\n\n\n\n    if (s->io_buffer_size <= 0) {\n\n        MACIO_DPRINTF(\"end of transfer\\n\");\n\n        s->status = READY_STAT | SEEK_STAT;\n\n        ide_set_irq(s->bus);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    if (io->len == 0) {\n\n        MACIO_DPRINTF(\"End of DMA transfer\\n\");\n\n        goto done;\n\n    }\n\n\n\n    /* Calculate number of sectors */\n\n    sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    offset = (ide_get_sector(s) << 9) + s->io_buffer_index;\n\n    nsector = (io->len + 0x1ff) >> 9;\n\n    remainder = io->len & 0x1ff;\n\n\n\n    s->nsector -= nsector;\n\n\n\n    MACIO_DPRINTF(\"nsector: %d   remainder: %x\\n\", nsector, remainder);\n\n    MACIO_DPRINTF(\"sector: %\"PRIx64\"   %x\\n\", sector_num, nsector);\n\n\n\n    switch (s->dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        pmac_dma_read(s->blk, offset, io->len, pmac_ide_transfer_cb, io);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        pmac_dma_write(s->blk, sector_num, nsector, pmac_ide_transfer_cb, io);\n\n        break;\n\n    case IDE_DMA_TRIM:\n\n        MACIO_DPRINTF(\"TRIM command issued!\");\n\n        break;\n\n    }\n\n\n\n    return;\n\n\n\ndone:\n\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n    }\n\n    io->dma_end(opaque);\n\n}\n", "idx": 11028}
{"project": "qemu", "commit_id": "a697a334b3c4d3250e6420f5d38550ea10eb5319", "target": 1, "func": "static void virtio_net_handle_tx(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIONet *n = to_virtio_net(vdev);\n\n\n\n    if (n->tx_waiting) {\n\n        virtio_queue_set_notification(vq, 1);\n\n        qemu_del_timer(n->tx_timer);\n\n        n->tx_waiting = 0;\n\n        virtio_net_flush_tx(n, vq);\n\n    } else {\n\n        qemu_mod_timer(n->tx_timer,\n\n                       qemu_get_clock(vm_clock) + n->tx_timeout);\n\n        n->tx_waiting = 1;\n\n        virtio_queue_set_notification(vq, 0);\n\n    }\n\n}\n", "idx": 4636}
{"project": "qemu", "commit_id": "0187688f3270433269fc7d4909ad36dc5c5db7aa", "target": 1, "func": "static void dec_load(DisasContext *dc)\n\n{\n\n    TCGv t, *addr;\n\n    unsigned int size;\n\n\n\n    size = 1 << (dc->opcode & 3);\n\n\n\n\n\n\n\n\n\n    LOG_DIS(\"l %x %d\\n\", dc->opcode, size);\n\n    t_sync_flags(dc);\n\n    addr = compute_ldst_addr(dc, &t);\n\n\n\n    /* If we get a fault on a dslot, the jmpstate better be in sync.  */\n\n    sync_jmpstate(dc);\n\n\n\n    /* Verify alignment if needed.  */\n\n    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {\n\n        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),\n\n                            tcg_const_tl(0), tcg_const_tl(size - 1));\n\n\n\n\n    if (dc->rd) {\n\n        gen_load(dc, cpu_R[dc->rd], *addr, size);\n\n    } else {\n\n        gen_load(dc, env_imm, *addr, size);\n\n\n\n\n    if (addr == &t)\n\n        tcg_temp_free(t);\n", "idx": 4688}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static int ram_find_and_save_block(RAMState *rs, bool last_stage)\n\n{\n\n    PageSearchStatus pss;\n\n    int pages = 0;\n\n    bool again, found;\n\n    ram_addr_t dirty_ram_abs; /* Address of the start of the dirty page in\n\n                                 ram_addr_t space */\n\n\n\n    /* No dirty page as there is zero RAM */\n\n    if (!ram_bytes_total()) {\n\n        return pages;\n\n    }\n\n\n\n    pss.block = rs->last_seen_block;\n\n    pss.offset = rs->last_offset;\n\n    pss.complete_round = false;\n\n\n\n    if (!pss.block) {\n\n        pss.block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n    }\n\n\n\n    do {\n\n        again = true;\n\n        found = get_queued_page(rs, &pss, &dirty_ram_abs);\n\n\n\n        if (!found) {\n\n            /* priority queue empty, so just search for something dirty */\n\n            found = find_dirty_block(rs, &pss, &again, &dirty_ram_abs);\n\n        }\n\n\n\n        if (found) {\n\n            pages = ram_save_host_page(rs, &pss, last_stage, dirty_ram_abs);\n\n        }\n\n    } while (!pages && again);\n\n\n\n    rs->last_seen_block = pss.block;\n\n    rs->last_offset = pss.offset;\n\n\n\n    return pages;\n\n}\n", "idx": 2149}
{"project": "qemu", "commit_id": "de5dca1b792ada25c29a95c8f84e01f4300aef9c", "target": 1, "func": "e1000e_io_write(void *opaque, hwaddr addr,\n\n                uint64_t val, unsigned size)\n\n{\n\n    E1000EState *s = opaque;\n\n    uint32_t idx;\n\n\n\n    switch (addr) {\n\n    case E1000_IOADDR:\n\n        trace_e1000e_io_write_addr(val);\n\n        s->ioaddr = (uint32_t) val;\n\n        return;\n\n    case E1000_IODATA:\n\n        if (e1000e_io_get_reg_index(s, &idx)) {\n\n            trace_e1000e_io_write_data(idx, val);\n\n            e1000e_core_write(&s->core, idx, val, sizeof(val));\n\n        }\n\n        return;\n\n    default:\n\n        trace_e1000e_wrn_io_write_unknown(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 7363}
{"project": "qemu", "commit_id": "fff895dfdbe41965f7b0430e3d9e8b7bd8fc8eda", "target": 1, "func": "static bool adding_first_cpu(void)\n\n{\n\n    CPUState *cpu;\n\n    size_t count = 0;\n\n    CPU_FOREACH(cpu) {\n\n        count++;\n\n        if (count > 1) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n", "idx": 3084}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_win_path(const char *filename)\n\n{\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 10091}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static int of_dpa_cmd_group_add(OfDpa *of_dpa, uint32_t group_id,\n\n                                RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *group = of_dpa_group_find(of_dpa, group_id);\n\n    int err;\n\n\n\n    if (group) {\n\n        return -ROCKER_EEXIST;\n\n    }\n\n\n\n    group = of_dpa_group_alloc(group_id);\n\n    if (!group) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    err = of_dpa_cmd_group_do(of_dpa, group_id, group, group_tlvs);\n\n    if (err) {\n\n        goto err_cmd_add;\n\n    }\n\n\n\n    err = of_dpa_group_add(of_dpa, group);\n\n    if (err) {\n\n        goto err_cmd_add;\n\n    }\n\n\n\n    return ROCKER_OK;\n\n\n\nerr_cmd_add:\n\n    g_free(group);\n\n    return err;\n\n}\n", "idx": 7281}
{"project": "qemu", "commit_id": "f4a769abaa51badea666093077c50c568c35de17", "target": 1, "func": "static int64_t coroutine_fn raw_co_get_block_status(BlockDriverState *bs,\n\n                                                    int64_t sector_num,\n\n                                                    int nb_sectors, int *pnum)\n\n{\n\n    off_t start, data = 0, hole = 0;\n\n    int64_t total_size;\n\n    int ret;\n\n\n\n    ret = fd_open(bs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    start = sector_num * BDRV_SECTOR_SIZE;\n\n    total_size = bdrv_getlength(bs);\n\n    if (total_size < 0) {\n\n        return total_size;\n\n    } else if (start >= total_size) {\n\n        *pnum = 0;\n\n        return 0;\n\n    } else if (start + nb_sectors * BDRV_SECTOR_SIZE > total_size) {\n\n        nb_sectors = DIV_ROUND_UP(total_size - start, BDRV_SECTOR_SIZE);\n\n    }\n\n\n\n    ret = find_allocation(bs, start, &data, &hole);\n\n    if (ret == -ENXIO) {\n\n        /* Trailing hole */\n\n        *pnum = nb_sectors;\n\n        ret = BDRV_BLOCK_ZERO;\n\n    } else if (ret < 0) {\n\n        /* No info available, so pretend there are no holes */\n\n        *pnum = nb_sectors;\n\n        ret = BDRV_BLOCK_DATA;\n\n    } else if (data == start) {\n\n        /* On a data extent, compute sectors to the end of the extent.  */\n\n        *pnum = MIN(nb_sectors, (hole - start) / BDRV_SECTOR_SIZE);\n\n        ret = BDRV_BLOCK_DATA;\n\n    } else {\n\n        /* On a hole, compute sectors to the beginning of the next extent.  */\n\n        assert(hole == start);\n\n        *pnum = MIN(nb_sectors, (data - start) / BDRV_SECTOR_SIZE);\n\n        ret = BDRV_BLOCK_ZERO;\n\n    }\n\n    return ret | BDRV_BLOCK_OFFSET_VALID | start;\n\n}\n", "idx": 1374}
{"project": "qemu", "commit_id": "02c4f26b1517d9e403ec10d6f6ca3c0276d19e43", "target": 1, "func": "static int sd_snapshot_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab)\n\n{\n\n    Error *local_err = NULL;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    SheepdogReq req;\n\n    int fd, nr = 1024, ret, max = BITS_TO_LONGS(SD_NR_VDIS) * sizeof(long);\n\n    QEMUSnapshotInfo *sn_tab = NULL;\n\n    unsigned wlen, rlen;\n\n    int found = 0;\n\n    static SheepdogInode inode;\n\n    unsigned long *vdi_inuse;\n\n    unsigned int start_nr;\n\n    uint64_t hval;\n\n    uint32_t vid;\n\n\n\n    vdi_inuse = g_malloc(max);\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report(\"%s\", error_get_pretty(local_err));;\n\n        error_free(local_err);\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    rlen = max;\n\n    wlen = 0;\n\n\n\n    memset(&req, 0, sizeof(req));\n\n\n\n    req.opcode = SD_OP_READ_VDIS;\n\n    req.data_length = max;\n\n\n\n    ret = do_req(fd, s->aio_context, (SheepdogReq *)&req,\n\n                 vdi_inuse, &wlen, &rlen);\n\n\n\n    closesocket(fd);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    sn_tab = g_malloc0(nr * sizeof(*sn_tab));\n\n\n\n    /* calculate a vdi id with hash function */\n\n    hval = fnv_64a_buf(s->name, strlen(s->name), FNV1A_64_INIT);\n\n    start_nr = hval & (SD_NR_VDIS - 1);\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report(\"%s\", error_get_pretty(local_err));;\n\n        error_free(local_err);\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    for (vid = start_nr; found < nr; vid = (vid + 1) % SD_NR_VDIS) {\n\n        if (!test_bit(vid, vdi_inuse)) {\n\n            break;\n\n        }\n\n\n\n        /* we don't need to read entire object */\n\n        ret = read_object(fd, s->aio_context, (char *)&inode,\n\n                          vid_to_vdi_oid(vid),\n\n                          0, SD_INODE_SIZE - sizeof(inode.data_vdi_id), 0,\n\n                          s->cache_flags);\n\n\n\n        if (ret) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(inode.name, s->name) && is_snapshot(&inode)) {\n\n            sn_tab[found].date_sec = inode.snap_ctime >> 32;\n\n            sn_tab[found].date_nsec = inode.snap_ctime & 0xffffffff;\n\n            sn_tab[found].vm_state_size = inode.vm_state_size;\n\n            sn_tab[found].vm_clock_nsec = inode.vm_clock_nsec;\n\n\n\n            snprintf(sn_tab[found].id_str, sizeof(sn_tab[found].id_str),\n\n                     \"%\" PRIu32, inode.snap_id);\n\n            pstrcpy(sn_tab[found].name,\n\n                    MIN(sizeof(sn_tab[found].name), sizeof(inode.tag)),\n\n                    inode.tag);\n\n            found++;\n\n        }\n\n    }\n\n\n\n    closesocket(fd);\n\nout:\n\n    *psn_tab = sn_tab;\n\n\n\n    g_free(vdi_inuse);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return found;\n\n}\n", "idx": 1019}
{"project": "qemu", "commit_id": "e0d9c6f93729c9bfc98fcafcd73098bb8e131aeb", "target": 1, "func": "static void qcow2_aio_read_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n\n\n    acb->hd_aiocb = NULL;\n\n    if (ret < 0)\n\n        goto done;\n\n\n\n    /* post process the read buffer */\n\n    if (!acb->cluster_offset) {\n\n        /* nothing to do */\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* nothing to do */\n\n    } else {\n\n        if (s->crypt_method) {\n\n            qcow2_encrypt_sectors(s, acb->sector_num,  acb->cluster_data,\n\n                acb->cluster_data, acb->cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n            qemu_iovec_reset(&acb->hd_qiov);\n\n            qemu_iovec_copy(&acb->hd_qiov, acb->qiov, acb->bytes_done,\n\n                acb->cur_nr_sectors * 512);\n\n            qemu_iovec_from_buffer(&acb->hd_qiov, acb->cluster_data,\n\n                512 * acb->cur_nr_sectors);\n\n        }\n\n    }\n\n\n\n    acb->remaining_sectors -= acb->cur_nr_sectors;\n\n    acb->sector_num += acb->cur_nr_sectors;\n\n    acb->bytes_done += acb->cur_nr_sectors * 512;\n\n\n\n    if (acb->remaining_sectors == 0) {\n\n        /* request completed */\n\n        ret = 0;\n\n        goto done;\n\n    }\n\n\n\n    /* prepare next AIO request */\n\n    acb->cur_nr_sectors = acb->remaining_sectors;\n\n    if (s->crypt_method) {\n\n        acb->cur_nr_sectors = MIN(acb->cur_nr_sectors,\n\n            QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n    }\n\n\n\n    ret = qcow2_get_cluster_offset(bs, acb->sector_num << 9,\n\n        &acb->cur_nr_sectors, &acb->cluster_offset);\n\n    if (ret < 0) {\n\n        goto done;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n\n\n    qemu_iovec_reset(&acb->hd_qiov);\n\n    qemu_iovec_copy(&acb->hd_qiov, acb->qiov, acb->bytes_done,\n\n        acb->cur_nr_sectors * 512);\n\n\n\n    if (!acb->cluster_offset) {\n\n\n\n        if (bs->backing_hd) {\n\n            /* read from the base image */\n\n            n1 = qcow2_backing_read1(bs->backing_hd, &acb->hd_qiov,\n\n                acb->sector_num, acb->cur_nr_sectors);\n\n            if (n1 > 0) {\n\n                BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                acb->hd_aiocb = bdrv_aio_readv(bs->backing_hd, acb->sector_num,\n\n                                    &acb->hd_qiov, acb->cur_nr_sectors,\n\n\t\t\t\t    qcow2_aio_read_cb, acb);\n\n                if (acb->hd_aiocb == NULL)\n\n                    goto done;\n\n            } else {\n\n                ret = qcow2_schedule_bh(qcow2_aio_read_bh, acb);\n\n                if (ret < 0)\n\n                    goto done;\n\n            }\n\n        } else {\n\n            /* Note: in this case, no need to wait */\n\n            qemu_iovec_memset(&acb->hd_qiov, 0, 512 * acb->cur_nr_sectors);\n\n            ret = qcow2_schedule_bh(qcow2_aio_read_bh, acb);\n\n            if (ret < 0)\n\n                goto done;\n\n        }\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* add AIO support for compressed blocks ? */\n\n        if (qcow2_decompress_cluster(bs, acb->cluster_offset) < 0)\n\n            goto done;\n\n\n\n        qemu_iovec_from_buffer(&acb->hd_qiov,\n\n            s->cluster_cache + index_in_cluster * 512,\n\n            512 * acb->cur_nr_sectors);\n\n\n\n        ret = qcow2_schedule_bh(qcow2_aio_read_bh, acb);\n\n        if (ret < 0)\n\n            goto done;\n\n    } else {\n\n        if ((acb->cluster_offset & 511) != 0) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n\n\n        if (s->crypt_method) {\n\n            /*\n\n             * For encrypted images, read everything into a temporary\n\n             * contiguous buffer on which the AES functions can work.\n\n             */\n\n            if (!acb->cluster_data) {\n\n                acb->cluster_data =\n\n                    qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            }\n\n\n\n            assert(acb->cur_nr_sectors <=\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n            qemu_iovec_reset(&acb->hd_qiov);\n\n            qemu_iovec_add(&acb->hd_qiov, acb->cluster_data,\n\n                512 * acb->cur_nr_sectors);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n        acb->hd_aiocb = bdrv_aio_readv(bs->file,\n\n                            (acb->cluster_offset >> 9) + index_in_cluster,\n\n                            &acb->hd_qiov, acb->cur_nr_sectors,\n\n                            qcow2_aio_read_cb, acb);\n\n        if (acb->hd_aiocb == NULL) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    return;\n\ndone:\n\n    acb->common.cb(acb->common.opaque, ret);\n\n    qemu_iovec_destroy(&acb->hd_qiov);\n\n    qemu_aio_release(acb);\n\n}\n", "idx": 10530}
{"project": "qemu", "commit_id": "9201bb9a8c7cd3ba2382b7db5b2e40f603e61528", "target": 1, "func": "sdhci_write(void *opaque, hwaddr offset, uint64_t val, unsigned size)\n{\n    SDHCIState *s = (SDHCIState *)opaque;\n    unsigned shift =  8 * (offset & 0x3);\n    uint32_t mask = ~(((1ULL << (size * 8)) - 1) << shift);\n    uint32_t value = val;\n    value <<= shift;\n    switch (offset & ~0x3) {\n    case SDHC_SYSAD:\n        s->sdmasysad = (s->sdmasysad & mask) | value;\n        MASKED_WRITE(s->sdmasysad, mask, value);\n        /* Writing to last byte of sdmasysad might trigger transfer */\n        if (!(mask & 0xFF000000) && TRANSFERRING_DATA(s->prnsts) && s->blkcnt &&\n                s->blksize && SDHC_DMA_TYPE(s->hostctl) == SDHC_CTRL_SDMA) {\n            sdhci_sdma_transfer_multi_blocks(s);\n        break;\n    case SDHC_BLKSIZE:\n        if (!TRANSFERRING_DATA(s->prnsts)) {\n            MASKED_WRITE(s->blksize, mask, value);\n            MASKED_WRITE(s->blkcnt, mask >> 16, value >> 16);\n        break;\n    case SDHC_ARGUMENT:\n        MASKED_WRITE(s->argument, mask, value);\n        break;\n    case SDHC_TRNMOD:\n        /* DMA can be enabled only if it is supported as indicated by\n         * capabilities register */\n        if (!(s->capareg & SDHC_CAN_DO_DMA)) {\n            value &= ~SDHC_TRNS_DMA;\n        MASKED_WRITE(s->trnmod, mask, value);\n        MASKED_WRITE(s->cmdreg, mask >> 16, value >> 16);\n        /* Writing to the upper byte of CMDREG triggers SD command generation */\n        if ((mask & 0xFF000000) || !sdhci_can_issue_command(s)) {\n            break;\n        sdhci_send_command(s);\n        break;\n    case  SDHC_BDATA:\n        if (sdhci_buff_access_is_sequential(s, offset - SDHC_BDATA)) {\n            sdhci_write_dataport(s, value >> shift, size);\n        break;\n    case SDHC_HOSTCTL:\n        if (!(mask & 0xFF0000)) {\n            sdhci_blkgap_write(s, value >> 16);\n        MASKED_WRITE(s->hostctl, mask, value);\n        MASKED_WRITE(s->pwrcon, mask >> 8, value >> 8);\n        MASKED_WRITE(s->wakcon, mask >> 24, value >> 24);\n        if (!(s->prnsts & SDHC_CARD_PRESENT) || ((s->pwrcon >> 1) & 0x7) < 5 ||\n                !(s->capareg & (1 << (31 - ((s->pwrcon >> 1) & 0x7))))) {\n            s->pwrcon &= ~SDHC_POWER_ON;\n        break;\n    case SDHC_CLKCON:\n        if (!(mask & 0xFF000000)) {\n            sdhci_reset_write(s, value >> 24);\n        MASKED_WRITE(s->clkcon, mask, value);\n        MASKED_WRITE(s->timeoutcon, mask >> 16, value >> 16);\n        if (s->clkcon & SDHC_CLOCK_INT_EN) {\n            s->clkcon |= SDHC_CLOCK_INT_STABLE;\n        } else {\n            s->clkcon &= ~SDHC_CLOCK_INT_STABLE;\n        break;\n    case SDHC_NORINTSTS:\n        if (s->norintstsen & SDHC_NISEN_CARDINT) {\n            value &= ~SDHC_NIS_CARDINT;\n        s->norintsts &= mask | ~value;\n        s->errintsts &= (mask >> 16) | ~(value >> 16);\n        if (s->errintsts) {\n            s->norintsts |= SDHC_NIS_ERR;\n        } else {\n            s->norintsts &= ~SDHC_NIS_ERR;\n        sdhci_update_irq(s);\n        break;\n    case SDHC_NORINTSTSEN:\n        MASKED_WRITE(s->norintstsen, mask, value);\n        MASKED_WRITE(s->errintstsen, mask >> 16, value >> 16);\n        s->norintsts &= s->norintstsen;\n        s->errintsts &= s->errintstsen;\n        if (s->errintsts) {\n            s->norintsts |= SDHC_NIS_ERR;\n        } else {\n            s->norintsts &= ~SDHC_NIS_ERR;\n        sdhci_update_irq(s);\n        break;\n    case SDHC_NORINTSIGEN:\n        MASKED_WRITE(s->norintsigen, mask, value);\n        MASKED_WRITE(s->errintsigen, mask >> 16, value >> 16);\n        sdhci_update_irq(s);\n        break;\n    case SDHC_ADMAERR:\n        MASKED_WRITE(s->admaerr, mask, value);\n        break;\n    case SDHC_ADMASYSADDR:\n        s->admasysaddr = (s->admasysaddr & (0xFFFFFFFF00000000ULL |\n                (uint64_t)mask)) | (uint64_t)value;\n        break;\n    case SDHC_ADMASYSADDR + 4:\n        s->admasysaddr = (s->admasysaddr & (0x00000000FFFFFFFFULL |\n                ((uint64_t)mask << 32))) | ((uint64_t)value << 32);\n        break;\n    case SDHC_FEAER:\n        s->acmd12errsts |= value;\n        s->errintsts |= (value >> 16) & s->errintstsen;\n        if (s->acmd12errsts) {\n            s->errintsts |= SDHC_EIS_CMD12ERR;\n        if (s->errintsts) {\n            s->norintsts |= SDHC_NIS_ERR;\n        sdhci_update_irq(s);\n        break;\n    default:\n        ERRPRINT(\"bad %ub write offset: addr[0x%04x] <- %u(0x%x)\\n\",\n                 size, (int)offset, value >> shift, value >> shift);\n        break;\n    DPRINT_L2(\"write %ub: addr[0x%04x] <- %u(0x%x)\\n\",\n              size, (int)offset, value >> shift, value >> shift);", "idx": 3718}
{"project": "qemu", "commit_id": "c9c3c80af71dd2b7813d1ada9b14cb51df584221", "target": 1, "func": "static void rtas_ibm_write_pci_config(sPAPREnvironment *spapr,\n\n                                      uint32_t token, uint32_t nargs,\n\n                                      target_ulong args,\n\n                                      uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t val, size, addr;\n\n    uint64_t buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    PCIDevice *dev = find_dev(spapr, buid, rtas_ld(args, 0));\n\n\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n    val = rtas_ld(args, 4);\n\n    size = rtas_ld(args, 3);\n\n    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));\n\n    pci_default_write_config(dev, addr, val, size);\n\n    rtas_st(rets, 0, 0);\n\n}\n", "idx": 967}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq *arm_gic_init(uint32_t base, qemu_irq parent_irq)\n\n{\n\n    gic_state *s;\n\n    qemu_irq *qi;\n\n    int iomemtype;\n\n\n\n    s = (gic_state *)qemu_mallocz(sizeof(gic_state));\n\n    if (!s)\n\n        return NULL;\n\n    qi = qemu_allocate_irqs(gic_set_irq, s, GIC_NIRQ);\n\n    s->parent_irq = parent_irq;\n\n    if (base != 0xffffffff) {\n\n        iomemtype = cpu_register_io_memory(0, gic_cpu_readfn,\n\n                                           gic_cpu_writefn, s);\n\n        cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n        iomemtype = cpu_register_io_memory(0, gic_dist_readfn,\n\n                                           gic_dist_writefn, s);\n\n        cpu_register_physical_memory(base + 0x1000, 0x00000fff, iomemtype);\n\n        s->base = base;\n\n    } else {\n\n        s->base = 0;\n\n    }\n\n    gic_reset(s);\n\n    return qi;\n\n}\n", "idx": 3383}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static int tty_serial_ioctl(CharDriverState *chr, int cmd, void *arg)\n\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    switch(cmd) {\n\n    case CHR_IOCTL_SERIAL_SET_PARAMS:\n\n\n            QEMUSerialSetParams *ssp = arg;\n\n            tty_serial_init(s->fd_in, ssp->speed, ssp->parity,\n\n                            ssp->data_bits, ssp->stop_bits);\n\n\n\n    case CHR_IOCTL_SERIAL_SET_BREAK:\n\n\n            int enable = *(int *)arg;\n\n            if (enable)\n\n                tcsendbreak(s->fd_in, 1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    default:\n\n        return -ENOTSUP;\n\n\n    return 0;\n", "idx": 6517}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int oss_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n\n    struct oss_params req, obt;\n\n    int endianness;\n\n    int err;\n\n    int fd;\n\n    audfmt_e effective_fmt;\n\n    struct audsettings obt_as;\n\n\n\n    oss->fd = -1;\n\n\n\n    req.fmt = aud_to_ossfmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.fragsize = conf.fragsize;\n\n    req.nfrags = conf.nfrags;\n\n\n\n    if (oss_open (0, &req, &obt, &fd)) {\n\n        return -1;\n\n    }\n\n\n\n    err = oss_to_audfmt (obt.fmt, &effective_fmt, &endianness);\n\n    if (err) {\n\n        oss_anal_close (&fd);\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = effective_fmt;\n\n    obt_as.endianness = endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    oss->nfrags = obt.nfrags;\n\n    oss->fragsize = obt.fragsize;\n\n\n\n    if (obt.nfrags * obt.fragsize & hw->info.align) {\n\n        dolog (\"warning: Misaligned DAC buffer, size %d, alignment %d\\n\",\n\n               obt.nfrags * obt.fragsize, hw->info.align + 1);\n\n    }\n\n\n\n    hw->samples = (obt.nfrags * obt.fragsize) >> hw->info.shift;\n\n\n\n    oss->mmapped = 0;\n\n    if (conf.try_mmap) {\n\n        oss->pcm_buf = mmap (\n\n            NULL,\n\n            hw->samples << hw->info.shift,\n\n            PROT_READ | PROT_WRITE,\n\n            MAP_SHARED,\n\n            fd,\n\n            0\n\n            );\n\n        if (oss->pcm_buf == MAP_FAILED) {\n\n            oss_logerr (errno, \"Failed to map %d bytes of DAC\\n\",\n\n                        hw->samples << hw->info.shift);\n\n        }\n\n        else {\n\n            int err;\n\n            int trig = 0;\n\n            if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                oss_logerr (errno, \"SNDCTL_DSP_SETTRIGGER 0 failed\\n\");\n\n            }\n\n            else {\n\n                trig = PCM_ENABLE_OUTPUT;\n\n                if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                    oss_logerr (\n\n                        errno,\n\n                        \"SNDCTL_DSP_SETTRIGGER PCM_ENABLE_OUTPUT failed\\n\"\n\n                        );\n\n                }\n\n                else {\n\n                    oss->mmapped = 1;\n\n                }\n\n            }\n\n\n\n            if (!oss->mmapped) {\n\n                err = munmap (oss->pcm_buf, hw->samples << hw->info.shift);\n\n                if (err) {\n\n                    oss_logerr (errno, \"Failed to unmap buffer %p size %d\\n\",\n\n                                oss->pcm_buf, hw->samples << hw->info.shift);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!oss->mmapped) {\n\n        oss->pcm_buf = audio_calloc (\n\n            AUDIO_FUNC,\n\n            hw->samples,\n\n            1 << hw->info.shift\n\n            );\n\n        if (!oss->pcm_buf) {\n\n            dolog (\n\n                \"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n                hw->samples,\n\n                1 << hw->info.shift\n\n                );\n\n            oss_anal_close (&fd);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    oss->fd = fd;\n\n    return 0;\n\n}\n", "idx": 2180}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_negotiate_handle_info(NBDClient *client, uint16_t myflags,\n\n                                     Error **errp)\n\n{\n\n    int rc;\n\n    char name[NBD_MAX_NAME_SIZE + 1];\n\n    NBDExport *exp;\n\n    uint16_t requests;\n\n    uint16_t request;\n\n    uint32_t namelen;\n\n    bool sendname = false;\n\n    bool blocksize = false;\n\n    uint32_t sizes[3];\n\n    char buf[sizeof(uint64_t) + sizeof(uint16_t)];\n\n    const char *msg;\n\n\n\n    /* Client sends:\n\n        4 bytes: L, name length (can be 0)\n\n        L bytes: export name\n\n        2 bytes: N, number of requests (can be 0)\n\n        N * 2 bytes: N requests\n\n    */\n\n    if (client->optlen < sizeof(namelen) + sizeof(requests)) {\n\n        msg = \"overall request too short\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&namelen);\n\n    client->optlen -= sizeof(namelen);\n\n    if (namelen > client->optlen - sizeof(requests) ||\n\n        (client->optlen - namelen) % 2)\n\n    {\n\n        msg = \"name length is incorrect\";\n\n        goto invalid;\n\n    }\n\n    if (namelen >= sizeof(name)) {\n\n        msg = \"name too long for qemu\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, name, namelen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    name[namelen] = '\\0';\n\n    client->optlen -= namelen;\n\n    trace_nbd_negotiate_handle_export_name_request(name);\n\n\n\n    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be16_to_cpus(&requests);\n\n    client->optlen -= sizeof(requests);\n\n    trace_nbd_negotiate_handle_info_requests(requests);\n\n    if (requests != client->optlen / sizeof(request)) {\n\n        msg = \"incorrect number of  requests for overall length\";\n\n        goto invalid;\n\n    }\n\n    while (requests--) {\n\n        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        be16_to_cpus(&request);\n\n        client->optlen -= sizeof(request);\n\n        trace_nbd_negotiate_handle_info_request(request,\n\n                                                nbd_info_lookup(request));\n\n        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;\n\n         * everything else is either a request we don't know or\n\n         * something we send regardless of request */\n\n        switch (request) {\n\n        case NBD_INFO_NAME:\n\n            sendname = true;\n\n            break;\n\n        case NBD_INFO_BLOCK_SIZE:\n\n            blocksize = true;\n\n            break;\n\n        }\n\n    }\n\n    assert(client->optlen == 0);\n\n\n\n    exp = nbd_export_find(name);\n\n    if (!exp) {\n\n        return nbd_negotiate_send_rep_err(client, NBD_REP_ERR_UNKNOWN,\n\n                                          errp, \"export '%s' not present\",\n\n                                          name);\n\n    }\n\n\n\n    /* Don't bother sending NBD_INFO_NAME unless client requested it */\n\n    if (sendname) {\n\n        rc = nbd_negotiate_send_info(client, NBD_INFO_NAME, namelen, name,\n\n                                     errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_DESCRIPTION only if available, regardless of\n\n     * client request */\n\n    if (exp->description) {\n\n        size_t len = strlen(exp->description);\n\n\n\n        rc = nbd_negotiate_send_info(client, NBD_INFO_DESCRIPTION,\n\n                                     len, exp->description, errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size\n\n     * according to whether the client requested it, and according to\n\n     * whether this is OPT_INFO or OPT_GO. */\n\n    /* minimum - 1 for back-compat, or 512 if client is new enough.\n\n     * TODO: consult blk_bs(blk)->bl.request_alignment? */\n\n    sizes[0] =\n\n            (client->opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;\n\n    /* preferred - Hard-code to 4096 for now.\n\n     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */\n\n    sizes[1] = 4096;\n\n    /* maximum - At most 32M, but smaller as appropriate. */\n\n    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);\n\n    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);\n\n    cpu_to_be32s(&sizes[0]);\n\n    cpu_to_be32s(&sizes[1]);\n\n    cpu_to_be32s(&sizes[2]);\n\n    rc = nbd_negotiate_send_info(client, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (client->opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client, NBD_REP_ACK, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (client->opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID,\n\n                                      errp, \"%s\", msg);\n\n}\n", "idx": 12140}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "void vnc_display_open(DisplayState *ds, const char *display, Error **errp)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n    const char *options;\n\n    int password = 0;\n\n    int reverse = 0;\n\n#ifdef CONFIG_VNC_TLS\n\n    int tls = 0, x509 = 0;\n\n#endif\n\n#ifdef CONFIG_VNC_SASL\n\n    int sasl = 0;\n\n    int saslErr;\n\n#endif\n\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n\n    int acl = 0;\n\n#endif\n\n    int lock_key_sync = 1;\n\n\n\n    if (!vnc_display) {\n\n        error_setg(errp, \"VNC display not active\");\n\n        return;\n\n    }\n\n    vnc_display_close(ds);\n\n    if (strcmp(display, \"none\") == 0)\n\n        return;\n\n\n\n    vs->display = g_strdup(display);\n\n    vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n\n\n\n    options = display;\n\n    while ((options = strchr(options, ','))) {\n\n        options++;\n\n        if (strncmp(options, \"password\", 8) == 0) {\n\n            if (fips_get_state()) {\n\n                error_setg(errp,\n\n                           \"VNC password auth disabled due to FIPS mode, \"\n\n                           \"consider using the VeNCrypt or SASL authentication \"\n\n                           \"methods as an alternative\");\n\n                goto fail;\n\n            }\n\n            password = 1; /* Require password auth */\n\n        } else if (strncmp(options, \"reverse\", 7) == 0) {\n\n            reverse = 1;\n\n        } else if (strncmp(options, \"no-lock-key-sync\", 16) == 0) {\n\n            lock_key_sync = 0;\n\n#ifdef CONFIG_VNC_SASL\n\n        } else if (strncmp(options, \"sasl\", 4) == 0) {\n\n            sasl = 1; /* Require SASL auth */\n\n#endif\n\n#ifdef CONFIG_VNC_WS\n\n        } else if (strncmp(options, \"websocket\", 9) == 0) {\n\n            char *start, *end;\n\n            vs->websocket = 1;\n\n\n\n            /* Check for 'websocket=<port>' */\n\n            start = strchr(options, '=');\n\n            end = strchr(options, ',');\n\n            if (start && (!end || (start < end))) {\n\n                int len = end ? end-(start+1) : strlen(start+1);\n\n                if (len < 6) {\n\n                    /* extract the host specification from display */\n\n                    char  *host = NULL, *port = NULL, *host_end = NULL;\n\n                    port = g_strndup(start + 1, len);\n\n\n\n                    /* ipv6 hosts have colons */\n\n                    end = strchr(display, ',');\n\n                    host_end = g_strrstr_len(display, end - display, \":\");\n\n\n\n                    if (host_end) {\n\n                        host = g_strndup(display, host_end - display + 1);\n\n                    } else {\n\n                        host = g_strndup(\":\", 1);\n\n                    }\n\n                    vs->ws_display = g_strconcat(host, port, NULL);\n\n                    g_free(host);\n\n                    g_free(port);\n\n                }\n\n            }\n\n#endif /* CONFIG_VNC_WS */\n\n#ifdef CONFIG_VNC_TLS\n\n        } else if (strncmp(options, \"tls\", 3) == 0) {\n\n            tls = 1; /* Require TLS */\n\n        } else if (strncmp(options, \"x509\", 4) == 0) {\n\n            char *start, *end;\n\n            x509 = 1; /* Require x509 certificates */\n\n            if (strncmp(options, \"x509verify\", 10) == 0)\n\n                vs->tls.x509verify = 1; /* ...and verify client certs */\n\n\n\n            /* Now check for 'x509=/some/path' postfix\n\n             * and use that to setup x509 certificate/key paths */\n\n            start = strchr(options, '=');\n\n            end = strchr(options, ',');\n\n            if (start && (!end || (start < end))) {\n\n                int len = end ? end-(start+1) : strlen(start+1);\n\n                char *path = g_strndup(start + 1, len);\n\n\n\n                VNC_DEBUG(\"Trying certificate path '%s'\\n\", path);\n\n                if (vnc_tls_set_x509_creds_dir(vs, path) < 0) {\n\n                    error_setg(errp, \"Failed to find x509 certificates/keys in %s\", path);\n\n                    g_free(path);\n\n                    goto fail;\n\n                }\n\n                g_free(path);\n\n            } else {\n\n                error_setg(errp, \"No certificate path provided\");\n\n                goto fail;\n\n            }\n\n#endif\n\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n\n        } else if (strncmp(options, \"acl\", 3) == 0) {\n\n            acl = 1;\n\n#endif\n\n        } else if (strncmp(options, \"lossy\", 5) == 0) {\n\n            vs->lossy = true;\n\n        } else if (strncmp(options, \"non-adaptive\", 12) == 0) {\n\n            vs->non_adaptive = true;\n\n        } else if (strncmp(options, \"share=\", 6) == 0) {\n\n            if (strncmp(options+6, \"ignore\", 6) == 0) {\n\n                vs->share_policy = VNC_SHARE_POLICY_IGNORE;\n\n            } else if (strncmp(options+6, \"allow-exclusive\", 15) == 0) {\n\n                vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n\n            } else if (strncmp(options+6, \"force-shared\", 12) == 0) {\n\n                vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n\n            } else {\n\n                error_setg(errp, \"unknown vnc share= option\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (acl && x509 && vs->tls.x509verify) {\n\n        if (!(vs->tls.acl = qemu_acl_init(\"vnc.x509dname\"))) {\n\n            fprintf(stderr, \"Failed to create x509 dname ACL\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n#endif\n\n#ifdef CONFIG_VNC_SASL\n\n    if (acl && sasl) {\n\n        if (!(vs->sasl.acl = qemu_acl_init(\"vnc.username\"))) {\n\n            fprintf(stderr, \"Failed to create username ACL\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /*\n\n     * Combinations we support here:\n\n     *\n\n     *  - no-auth                (clear text, no auth)\n\n     *  - password               (clear text, weak auth)\n\n     *  - sasl                   (encrypt, good auth *IF* using Kerberos via GSSAPI)\n\n     *  - tls                    (encrypt, weak anonymous creds, no auth)\n\n     *  - tls + password         (encrypt, weak anonymous creds, weak auth)\n\n     *  - tls + sasl             (encrypt, weak anonymous creds, good auth)\n\n     *  - tls + x509             (encrypt, good x509 creds, no auth)\n\n     *  - tls + x509 + password  (encrypt, good x509 creds, weak auth)\n\n     *  - tls + x509 + sasl      (encrypt, good x509 creds, good auth)\n\n     *\n\n     * NB1. TLS is a stackable auth scheme.\n\n     * NB2. the x509 schemes have option to validate a client cert dname\n\n     */\n\n    if (password) {\n\n#ifdef CONFIG_VNC_TLS\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n\n            }\n\n        } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n\n            vs->auth = VNC_AUTH_VNC;\n\n#ifdef CONFIG_VNC_TLS\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    } else if (sasl) {\n\n#ifdef CONFIG_VNC_TLS\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n\n            }\n\n        } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n\n            vs->auth = VNC_AUTH_SASL;\n\n#ifdef CONFIG_VNC_TLS\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n#endif /* CONFIG_VNC_TLS */\n\n#endif /* CONFIG_VNC_SASL */\n\n    } else {\n\n#ifdef CONFIG_VNC_TLS\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n\n            }\n\n        } else {\n\n#endif\n\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n\n            vs->auth = VNC_AUTH_NONE;\n\n#ifdef CONFIG_VNC_TLS\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n#endif\n\n    }\n\n\n\n#ifdef CONFIG_VNC_SASL\n\n    if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {\n\n        error_setg(errp, \"Failed to initialize SASL auth: %s\",\n\n                   sasl_errstring(saslErr, NULL, NULL));\n\n        goto fail;\n\n    }\n\n#endif\n\n    vs->lock_key_sync = lock_key_sync;\n\n\n\n    if (reverse) {\n\n        /* connect to viewer */\n\n        int csock;\n\n        vs->lsock = -1;\n\n#ifdef CONFIG_VNC_WS\n\n        vs->lwebsock = -1;\n\n#endif\n\n        if (strncmp(display, \"unix:\", 5) == 0) {\n\n            csock = unix_connect(display+5, errp);\n\n        } else {\n\n            csock = inet_connect(display, errp);\n\n        }\n\n        if (csock < 0) {\n\n            goto fail;\n\n        }\n\n        vnc_connect(vs, csock, 0, 0);\n\n    } else {\n\n        /* listen for connects */\n\n        char *dpy;\n\n        dpy = g_malloc(256);\n\n        if (strncmp(display, \"unix:\", 5) == 0) {\n\n            pstrcpy(dpy, 256, \"unix:\");\n\n            vs->lsock = unix_listen(display+5, dpy+5, 256-5, errp);\n\n        } else {\n\n            vs->lsock = inet_listen(display, dpy, 256,\n\n                                    SOCK_STREAM, 5900, errp);\n\n            if (vs->lsock < 0) {\n\n                g_free(dpy);\n\n                goto fail;\n\n            }\n\n#ifdef CONFIG_VNC_WS\n\n            if (vs->websocket) {\n\n                if (vs->ws_display) {\n\n                    vs->lwebsock = inet_listen(vs->ws_display, NULL, 256,\n\n                        SOCK_STREAM, 0, errp);\n\n                } else {\n\n                    vs->lwebsock = inet_listen(vs->display, NULL, 256,\n\n                        SOCK_STREAM, 5700, errp);\n\n                }\n\n\n\n                if (vs->lwebsock < 0) {\n\n                    if (vs->lsock) {\n\n                        close(vs->lsock);\n\n                        vs->lsock = -1;\n\n                    }\n\n                    g_free(dpy);\n\n                    goto fail;\n\n                }\n\n            }\n\n#endif /* CONFIG_VNC_WS */\n\n        }\n\n        g_free(vs->display);\n\n        vs->display = dpy;\n\n        qemu_set_fd_handler2(vs->lsock, NULL,\n\n                vnc_listen_regular_read, NULL, vs);\n\n#ifdef CONFIG_VNC_WS\n\n        if (vs->websocket) {\n\n            qemu_set_fd_handler2(vs->lwebsock, NULL,\n\n                    vnc_listen_websocket_read, NULL, vs);\n\n        }\n\n#endif /* CONFIG_VNC_WS */\n\n    }\n\n    return;\n\n\n\nfail:\n\n    g_free(vs->display);\n\n    vs->display = NULL;\n\n#ifdef CONFIG_VNC_WS\n\n    g_free(vs->ws_display);\n\n    vs->ws_display = NULL;\n\n#endif /* CONFIG_VNC_WS */\n\n}\n", "idx": 1068}
{"project": "qemu", "commit_id": "5af2ae2305143f1805a696f9554231e1fc246edc", "target": 1, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n\n\n    if (bus->iommu_fn) {\n\n        return bus->iommu_fn(bus, bus->iommu_opaque, dev->devfn);\n\n    }\n\n\n\n    if (bus->parent_dev) {\n\n        /** We are ignoring the bus master DMA bit of the bridge\n\n         *  as it would complicate things such as VFIO for no good reason */\n\n        return pci_device_iommu_address_space(bus->parent_dev);\n\n    }\n\n\n\n    return &address_space_memory;\n\n}\n", "idx": 2638}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n", "idx": 9188}
{"project": "qemu", "commit_id": "86e18cae209f8101ff9a6013a1ff6ae620c06944", "target": 1, "func": "static inline int ohci_put_hcca(OHCIState *ohci,\n\n                                uint32_t addr, struct ohci_hcca *hcca)\n\n{\n\n    cpu_physical_memory_write(addr + ohci->localmem_base, hcca, sizeof(*hcca));\n\n    return 1;\n\n}\n", "idx": 11990}
{"project": "qemu", "commit_id": "3456a8d1852e970688b73d03fdc44dde851759e1", "target": 1, "func": "static void qcow2_invalidate_cache(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    int flags = s->flags;\n    AES_KEY aes_encrypt_key;\n    AES_KEY aes_decrypt_key;\n    uint32_t crypt_method = 0;\n    QDict *options;\n    /*\n     * Backing files are read-only which makes all of their metadata immutable,\n     * that means we don't have to worry about reopening them here.\n     */\n    if (s->crypt_method) {\n        crypt_method = s->crypt_method;\n        memcpy(&aes_encrypt_key, &s->aes_encrypt_key, sizeof(aes_encrypt_key));\n        memcpy(&aes_decrypt_key, &s->aes_decrypt_key, sizeof(aes_decrypt_key));\n    }\n    qcow2_close(bs);\n    options = qdict_new();\n    qdict_put(options, QCOW2_OPT_LAZY_REFCOUNTS,\n              qbool_from_int(s->use_lazy_refcounts));\n    memset(s, 0, sizeof(BDRVQcowState));\n    qcow2_open(bs, options, flags, NULL);\n    QDECREF(options);\n    if (crypt_method) {\n        s->crypt_method = crypt_method;\n        memcpy(&s->aes_encrypt_key, &aes_encrypt_key, sizeof(aes_encrypt_key));\n        memcpy(&s->aes_decrypt_key, &aes_decrypt_key, sizeof(aes_decrypt_key));\n    }\n}", "idx": 2249}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void vnc_dpy_resize(DisplayChangeListener *dcl,\n\n                           DisplayState *ds)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs;\n\n\n\n    vnc_abort_display_jobs(vd);\n\n\n\n    /* server surface */\n\n    qemu_pixman_image_unref(vd->server);\n\n    vd->server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,\n\n                                          ds_get_width(ds),\n\n                                          ds_get_height(ds),\n\n                                          NULL, 0);\n\n\n\n    /* guest surface */\n\n#if 0 /* FIXME */\n\n    if (ds_get_bytes_per_pixel(ds) != vd->guest.ds->pf.bytes_per_pixel)\n\n        console_color_init(ds);\n\n#endif\n\n    qemu_pixman_image_unref(vd->guest.fb);\n\n    vd->guest.fb = pixman_image_ref(ds->surface->image);\n\n    vd->guest.format = ds->surface->format;\n\n    memset(vd->guest.dirty, 0xFF, sizeof(vd->guest.dirty));\n\n\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n        vnc_colordepth(vs);\n\n        vnc_desktop_resize(vs);\n\n        if (vs->vd->cursor) {\n\n            vnc_cursor_define(vs);\n\n        }\n\n        memset(vs->dirty, 0xFF, sizeof(vs->dirty));\n\n    }\n\n}\n", "idx": 8375}
{"project": "qemu", "commit_id": "8841d9dfc7f871cec7c3401a8a2d31ad34e881f7", "target": 1, "func": "static inline void check_privileged(DisasContext *s)\n\n{\n\n    if (s->tb->flags & (PSW_MASK_PSTATE >> 32)) {\n\n        gen_program_exception(s, PGM_PRIVILEGED);\n\n    }\n\n}\n", "idx": 11482}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "static void uhci_async_cancel_device(UHCIState *s, USBDevice *dev)\n\n{\n\n    UHCIAsync *curr, *n;\n\n\n\n    QTAILQ_FOREACH_SAFE(curr, &s->async_pending, next, n) {\n\n        if (curr->packet.owner == NULL ||\n\n            curr->packet.owner->dev != dev) {\n\n            continue;\n\n        }\n\n        uhci_async_unlink(s, curr);\n\n        uhci_async_cancel(s, curr);\n\n    }\n\n}\n", "idx": 11534}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int bdrv_rd_badreq_sectors(BlockDriverState *bs,\n\n                                  int64_t sector_num, int nb_sectors)\n\n{\n\n    return\n\n        nb_sectors < 0 ||\n\n        sector_num < 0 ||\n\n        nb_sectors > bs->total_sectors ||\n\n        sector_num > bs->total_sectors - nb_sectors;\n\n}\n", "idx": 7939}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbli_6xx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_6xx_tlbi(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 11003}
{"project": "qemu", "commit_id": "2ee73ac3a855fb0cfba3db91fdd1ecebdbc6f971", "target": 1, "func": "void OPPROTO op_fdiv_STN_ST0(void)\n\n{\n\n    ST(PARAM1) /= ST0;\n\n}\n", "idx": 7372}
{"project": "qemu", "commit_id": "cdd85eb2804018ab46a742ebf64dc5366b9fae73", "target": 1, "func": "static void update_msix_table_msg_data(S390PCIBusDevice *pbdev, uint64_t offset,\n\n                                       uint64_t *data, uint8_t len)\n\n{\n\n    uint32_t val;\n\n    uint8_t *msg_data;\n\n\n\n    if (offset % PCI_MSIX_ENTRY_SIZE != 8) {\n\n        return;\n\n    }\n\n\n\n    if (len != 4) {\n\n        DPRINTF(\"access msix table msg data but len is %d\\n\", len);\n\n        return;\n\n    }\n\n\n\n    msg_data = (uint8_t *)data - offset % PCI_MSIX_ENTRY_SIZE +\n\n               PCI_MSIX_ENTRY_VECTOR_CTRL;\n\n    val = pci_get_long(msg_data) | (pbdev->fid << ZPCI_MSI_VEC_BITS);\n\n    pci_set_long(msg_data, val);\n\n    DPRINTF(\"update msix msg_data to 0x%\" PRIx64 \"\\n\", *data);\n\n}\n", "idx": 8899}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static void integratorcm_init(int memsz, uint32_t flash_offset)\n\n{\n\n    int iomemtype;\n\n    integratorcm_state *s;\n\n\n\n    s = (integratorcm_state *)qemu_mallocz(sizeof(integratorcm_state));\n\n    s->cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->flash_offset = flash_offset;\n\n\n\n    iomemtype = cpu_register_io_memory(0, integratorcm_readfn,\n\n                                       integratorcm_writefn, s);\n\n    cpu_register_physical_memory(0x10000000, 0x007fffff, iomemtype);\n\n    integratorcm_do_remap(s, 1);\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 3172}
{"project": "qemu", "commit_id": "908bcd540f489f7adf2d804347905b0025d808d3", "target": 1, "func": "int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)\n\n{\n\n\n\n\n    if (bs->drv->bdrv_check == NULL) {\n\n        return -ENOTSUP;\n\n\n\n\n    memset(res, 0, sizeof(*res));\n\n    return bs->drv->bdrv_check(bs, res, fix);\n", "idx": 5001}
{"project": "qemu", "commit_id": "326b9e98a391d542cc33c4c91782ff4ba51edfc5", "target": 1, "func": "floatx80 floatx80_scalbn( floatx80 a, int n STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp;\n\n    uint64_t aSig;\n\n\n\n    aSig = extractFloatx80Frac( a );\n\n    aExp = extractFloatx80Exp( a );\n\n    aSign = extractFloatx80Sign( a );\n\n\n\n    if ( aExp == 0x7FF ) {\n\n        return a;\n\n    }\n\n    if (aExp == 0 && aSig == 0)\n\n        return a;\n\n\n\n    aExp += n;\n\n    return normalizeRoundAndPackFloatx80( STATUS(floatx80_rounding_precision),\n\n                                          aSign, aExp, aSig, 0 STATUS_VAR );\n\n}\n", "idx": 9202}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "void bdrv_close(BlockDriverState *bs)\n\n{\n\n    if (bs->drv) {\n\n        if (bs->backing_hd)\n\n            bdrv_delete(bs->backing_hd);\n\n        bs->drv->bdrv_close(bs);\n\n        qemu_free(bs->opaque);\n\n#ifdef _WIN32\n\n        if (bs->is_temporary) {\n\n            unlink(bs->filename);\n\n        }\n\n#endif\n\n        bs->opaque = NULL;\n\n        bs->drv = NULL;\n\n\n\n        /* call the change callback */\n\n        bs->total_sectors = 0;\n\n        bs->media_changed = 1;\n\n        if (bs->change_cb)\n\n            bs->change_cb(bs->change_opaque);\n\n    }\n\n}\n", "idx": 3998}
{"project": "qemu", "commit_id": "abc981bf292fb361f8a509c3611ddf2ba2c43360", "target": 1, "func": "static void test_io_channel_ipv4_fd(void)\n{\n    QIOChannel *ioc;\n    int fd = -1;\n    fd = socket(AF_INET, SOCK_STREAM, 0);\n    g_assert_cmpint(fd, >, -1);\n    ioc = qio_channel_new_fd(fd, &error_abort);\n    g_assert_cmpstr(object_get_typename(OBJECT(ioc)),\n                    ==,\n                    TYPE_QIO_CHANNEL_SOCKET);\n    object_unref(OBJECT(ioc));", "idx": 3709}
{"project": "qemu", "commit_id": "d19a4d4ef448e736d341df47bd1adc78c8e40814", "target": 1, "func": "static void kvm_arm_gicv3_realize(DeviceState *dev, Error **errp)\n\n{\n\n    GICv3State *s = KVM_ARM_GICV3(dev);\n\n    KVMARMGICv3Class *kgc = KVM_ARM_GICV3_GET_CLASS(s);\n\n    Error *local_err = NULL;\n\n\n\n\n    DPRINTF(\"kvm_arm_gicv3_realize\\n\");\n\n\n\n    kgc->parent_realize(dev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (s->security_extn) {\n\n        error_setg(errp, \"the in-kernel VGICv3 does not implement the \"\n\n                   \"security extensions\");\n\n        return;\n\n    }\n\n\n\n    gicv3_init_irqs_and_mmio(s, kvm_arm_gicv3_set_irq, NULL);\n\n\n\n    /* Try to create the device via the device control API */\n\n    s->dev_fd = kvm_create_device(kvm_state, KVM_DEV_TYPE_ARM_VGIC_V3, false);\n\n    if (s->dev_fd < 0) {\n\n        error_setg_errno(errp, -s->dev_fd, \"error creating in-kernel VGIC\");\n\n        return;\n\n    }\n\n\n\n    kvm_device_access(s->dev_fd, KVM_DEV_ARM_VGIC_GRP_NR_IRQS,\n\n                      0, &s->num_irq, true);\n\n\n\n    /* Tell the kernel to complete VGIC initialization now */\n\n    kvm_device_access(s->dev_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\n                      KVM_DEV_ARM_VGIC_CTRL_INIT, NULL, true);\n\n\n\n    kvm_arm_register_device(&s->iomem_dist, -1, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\n                            KVM_VGIC_V3_ADDR_TYPE_DIST, s->dev_fd);\n\n    kvm_arm_register_device(&s->iomem_redist, -1, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\n                            KVM_VGIC_V3_ADDR_TYPE_REDIST, s->dev_fd);\n\n\n\n    /* Block migration of a KVM GICv3 device: the API for saving and restoring\n\n     * the state in the kernel is not yet finalised in the kernel or\n\n     * implemented in QEMU.\n\n     */\n\n    error_setg(&s->migration_blocker, \"vGICv3 migration is not implemented\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    if (kvm_has_gsi_routing()) {\n\n        /* set up irq routing */\n\n        kvm_init_irq_routing(kvm_state);\n\n        for (i = 0; i < s->num_irq - GIC_INTERNAL; ++i) {\n\n            kvm_irqchip_add_irq_route(kvm_state, i, 0, i);\n\n        }\n\n\n\n        kvm_gsi_routing_allowed = true;\n\n\n\n        kvm_irqchip_commit_routes(kvm_state);\n\n    }\n\n}", "idx": 9113}
{"project": "qemu", "commit_id": "e03c902cb617414dae49d77a810f6957ff7affac", "target": 1, "func": "static uint32_t icp_accept(struct icp_server_state *ss)\n\n{\n\n    uint32_t xirr = ss->xirr;\n\n\n\n    qemu_irq_lower(ss->output);\n\n    ss->xirr = ss->pending_priority << 24;\n\n\n\n\n    trace_xics_icp_accept(xirr, ss->xirr);\n\n\n\n    return xirr;\n\n}", "idx": 9307}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static inline void qemu_assert(int cond, const char *msg)\n\n{\n\n    if (!cond) {\n\n        fprintf (stderr, \"badness: %s\\n\", msg);\n\n        abort();\n\n    }\n\n}\n", "idx": 5297}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int paio_init(void)\n\n{\n\n    struct sigaction act;\n\n    PosixAioState *s;\n\n    int fds[2];\n\n    int ret;\n\n\n\n    if (posix_aio_state)\n\n        return 0;\n\n\n\n    s = qemu_malloc(sizeof(PosixAioState));\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0; /* do not restart syscalls to interrupt select() */\n\n    act.sa_handler = aio_signal_handler;\n\n    sigaction(SIGUSR2, &act, NULL);\n\n\n\n    s->first_aio = NULL;\n\n    if (pipe(fds) == -1) {\n\n        fprintf(stderr, \"failed to create pipe\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->rfd = fds[0];\n\n    s->wfd = fds[1];\n\n\n\n    fcntl(s->rfd, F_SETFL, O_NONBLOCK);\n\n    fcntl(s->wfd, F_SETFL, O_NONBLOCK);\n\n\n\n    qemu_aio_set_fd_handler(s->rfd, posix_aio_read, NULL, posix_aio_flush,\n\n        posix_aio_process_queue, s);\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret)\n\n        die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret)\n\n        die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    QTAILQ_INIT(&request_list);\n\n\n\n    posix_aio_state = s;\n\n    return 0;\n\n}\n", "idx": 7133}
{"project": "qemu", "commit_id": "a46667ea29218565473e430ceae62e2838f6ce3f", "target": 1, "func": "static int net_socket_listen_init(VLANState *vlan,\n\n                                  const char *model,\n\n                                  const char *name,\n\n                                  const char *host_str)\n\n{\n\n    NetSocketListenState *s;\n\n    int fd, val, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    s = g_malloc0(sizeof(NetSocketListenState));\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        g_free(s);\n\n        return -1;\n\n    }\n\n    socket_set_nonblock(fd);\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char *)&val, sizeof(val));\n\n\n\n    ret = bind(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n        g_free(s);\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n        g_free(s);\n\n\n        return -1;\n\n    }\n\n    s->vlan = vlan;\n\n    s->model = g_strdup(model);\n\n    s->name = name ? g_strdup(name) : NULL;\n\n    s->fd = fd;\n\n    qemu_set_fd_handler(fd, net_socket_accept, NULL, s);\n\n    return 0;\n\n}", "idx": 1310}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_full_empty(void)\n\n{\n\n    const char *str = \"\";\n\n    long res = 999L;\n\n    int err;\n\n\n\n    err =  qemu_strtol(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n}\n", "idx": 3096}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_read_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 1793}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "struct pxa2xx_state_s *pxa270_init(unsigned int sdram_size,\n\n                DisplayState *ds, const char *revision)\n\n{\n\n    struct pxa2xx_state_s *s;\n\n    struct pxa2xx_ssp_s *ssp;\n\n    int iomemtype, i;\n\n    s = (struct pxa2xx_state_s *) qemu_mallocz(sizeof(struct pxa2xx_state_s));\n\n\n\n    if (revision && strncmp(revision, \"pxa27\", 5)) {\n\n        fprintf(stderr, \"Machine requires a PXA27x processor.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    s->env = cpu_init();\n\n    cpu_arm_set_model(s->env, revision ?: \"pxa270\");\n\n    register_savevm(\"cpu\", 0, 0, cpu_save, cpu_load, s->env);\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE,\n\n                    sdram_size, qemu_ram_alloc(sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE,\n\n                    0x40000, qemu_ram_alloc(0x40000) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa27x_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa27x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0],\n\n                    s->pic[PXA27X_PIC_OST_4_11]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 121);\n\n\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa270_serial[i].io_base; i ++)\n\n        if (serial_hds[i])\n\n            serial_mm_init(pxa270_serial[i].io_base, 2,\n\n                            s->pic[pxa270_serial[i].irqn], serial_hds[i], 1);\n\n        else\n\n            break;\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    if (ds)\n\n        s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD], ds);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 4] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s);\n\n    cpu_register_physical_memory(s->cm_base, 0xfff, iomemtype);\n\n    register_savevm(\"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s);\n\n    cpu_register_physical_memory(s->mm_base, 0xfff, iomemtype);\n\n    register_savevm(\"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s);\n\n    cpu_register_physical_memory(s->pm_base, 0xff, iomemtype);\n\n    register_savevm(\"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++);\n\n    s->ssp = (struct pxa2xx_ssp_s **)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s *) * i);\n\n    ssp = (struct pxa2xx_ssp_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s) * i);\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++) {\n\n        s->ssp[i] = &ssp[i];\n\n        ssp[i].base = pxa27x_ssp[i].io_base;\n\n        ssp[i].irq = s->pic[pxa27x_ssp[i].irqn];\n\n\n\n        iomemtype = cpu_register_io_memory(0, pxa2xx_ssp_readfn,\n\n                        pxa2xx_ssp_writefn, &ssp[i]);\n\n        cpu_register_physical_memory(ssp[i].base, 0xfff, iomemtype);\n\n        register_savevm(\"pxa2xx_ssp\", i, 0,\n\n                        pxa2xx_ssp_save, pxa2xx_ssp_load, s);\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pxa(0x4c000000, 3, -1, s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s);\n\n    cpu_register_physical_memory(s->rtc_base, 0xfff, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(\"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overriden by board-specific code */\n\n    pxa2xx_gpio_handler_set(s->gpio, 1, pxa2xx_reset, s);\n\n    return s;\n\n}\n", "idx": 8521}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_tt_update(rc4030State *s, uint32_t new_tl_base,\n\n                                 uint32_t new_tl_limit)\n\n{\n\n    int entries, i;\n\n    dma_pagetable_entry *dma_tl_contents;\n\n\n\n    if (s->dma_tl_limit) {\n\n        /* write old dma tl table to physical memory */\n\n        memory_region_del_subregion(get_system_memory(), &s->dma_tt_alias);\n\n        cpu_physical_memory_write(s->dma_tl_limit & 0x7fffffff,\n\n                                  memory_region_get_ram_ptr(&s->dma_tt),\n\n                                  memory_region_size(&s->dma_tt_alias));\n\n    }\n\n    object_unparent(OBJECT(&s->dma_tt_alias));\n\n\n\n    s->dma_tl_base = new_tl_base;\n\n    s->dma_tl_limit = new_tl_limit;\n\n    new_tl_base &= 0x7fffffff;\n\n\n\n    if (s->dma_tl_limit) {\n\n        uint64_t dma_tt_size;\n\n        if (s->dma_tl_limit <= memory_region_size(&s->dma_tt)) {\n\n            dma_tt_size = s->dma_tl_limit;\n\n        } else {\n\n            dma_tt_size = memory_region_size(&s->dma_tt);\n\n        }\n\n        memory_region_init_alias(&s->dma_tt_alias, OBJECT(s),\n\n                                 \"dma-table-alias\",\n\n                                 &s->dma_tt, 0, dma_tt_size);\n\n        dma_tl_contents = memory_region_get_ram_ptr(&s->dma_tt);\n\n        cpu_physical_memory_read(new_tl_base, dma_tl_contents, dma_tt_size);\n\n\n\n        memory_region_transaction_begin();\n\n        entries = dma_tt_size / sizeof(dma_pagetable_entry);\n\n        for (i = 0; i < entries; i++) {\n\n            rc4030_dma_as_update_one(s, i, dma_tl_contents[i].frame);\n\n        }\n\n        memory_region_add_subregion(get_system_memory(), new_tl_base,\n\n                                    &s->dma_tt_alias);\n\n        memory_region_transaction_commit();\n\n    } else {\n\n        memory_region_init(&s->dma_tt_alias, OBJECT(s),\n\n                           \"dma-table-alias\", 0);\n\n    }\n\n}\n", "idx": 12184}
{"project": "qemu", "commit_id": "246f65838d19db6db55bfb41117c35645a2c4789", "target": 1, "func": "static int64_t seek_to_sector(BlockDriverState *bs, int64_t sector_num)\n\n{\n\n    BDRVBochsState *s = bs->opaque;\n\n    int64_t offset = sector_num * 512;\n\n    int64_t extent_index, extent_offset, bitmap_offset;\n\n    char bitmap_entry;\n\n\n\n    // seek to sector\n\n    extent_index = offset / s->extent_size;\n\n    extent_offset = (offset % s->extent_size) / 512;\n\n\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\n\treturn -1; /* not allocated */\n\n    }\n\n\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\n\t(s->extent_blocks + s->bitmap_blocks));\n\n\n\n    /* read in bitmap for current extent */\n\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n\n                   &bitmap_entry, 1) != 1) {\n\n        return -1;\n\n    }\n\n\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\n\treturn -1; /* not allocated */\n\n    }\n\n\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n\n}\n", "idx": 2163}
{"project": "qemu", "commit_id": "640601c7cb1b6b41d3e1a435b986266c2b71e9bc", "target": 1, "func": "vu_queue_empty(VuDev *dev, VuVirtq *vq)\n\n{\n\n    if (vq->shadow_avail_idx != vq->last_avail_idx) {\n\n        return 0;\n\n    }\n\n\n\n    return vring_avail_idx(vq) == vq->last_avail_idx;\n\n}\n", "idx": 7126}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n                const void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pwrite)\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n}", "idx": 6295}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static FlatView generate_memory_topology(MemoryRegion *mr)\n\n{\n\n    FlatView view;\n\n\n\n    flatview_init(&view);\n\n\n\n    render_memory_region(&view, mr, 0, addrrange_make(0, UINT64_MAX));\n\n    flatview_simplify(&view);\n\n\n\n    return view;\n\n}\n", "idx": 9967}
{"project": "qemu", "commit_id": "eabc977973103527bbb8fed69c91cfaa6691f8ab", "target": 1, "func": "void aio_notify(AioContext *ctx)\n\n{\n\n    /* Write e.g. bh->scheduled before reading ctx->dispatching.  */\n\n    smp_mb();\n\n    if (!ctx->dispatching) {\n\n        event_notifier_set(&ctx->notifier);\n\n    }\n\n}\n", "idx": 8784}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "bool io_mem_read(MemoryRegion *mr, hwaddr addr, uint64_t *pval, unsigned size)\n\n{\n\n    return memory_region_dispatch_read(mr, addr, pval, size);\n\n}\n", "idx": 10186}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 9400}
{"project": "qemu", "commit_id": "8f94a6e40e46cbc8e8014da825d25824b1803b34", "target": 1, "func": "static int bdrv_open_common(BlockDriverState *bs, BlockDriverState *file,\n\n    QDict *options, int flags, BlockDriver *drv, Error **errp)\n\n{\n\n    int ret, open_flags;\n\n    const char *filename;\n\n    Error *local_err = NULL;\n\n\n\n    assert(drv != NULL);\n\n    assert(bs->file == NULL);\n\n    assert(options != NULL && bs->options != options);\n\n\n\n    if (file != NULL) {\n\n        filename = file->filename;\n\n    } else {\n\n        filename = qdict_get_try_str(options, \"filename\");\n\n    }\n\n\n\n    trace_bdrv_open_common(bs, filename ?: \"\", flags, drv->format_name);\n\n\n\n    /* bdrv_open() with directly using a protocol as drv. This layer is already\n\n     * opened, so assign it to bs (while file becomes a closed BlockDriverState)\n\n     * and return immediately. */\n\n    if (file != NULL && drv->bdrv_file_open) {\n\n        bdrv_swap(file, bs);\n\n        return 0;\n\n    }\n\n\n\n    bs->open_flags = flags;\n\n    bs->buffer_alignment = 512;\n\n    bs->zero_beyond_eof = true;\n\n    open_flags = bdrv_open_flags(bs, flags);\n\n    bs->read_only = !(open_flags & BDRV_O_RDWR);\n\n\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv, bs->read_only)) {\n\n        error_setg(errp, \"Driver '%s' is not whitelisted\", drv->format_name);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    assert(bs->copy_on_read == 0); /* bdrv_new() and bdrv_close() make it so */\n\n    if (!bs->read_only && (flags & BDRV_O_COPY_ON_READ)) {\n\n        bdrv_enable_copy_on_read(bs);\n\n    }\n\n\n\n    if (filename != NULL) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), filename);\n\n    } else {\n\n        bs->filename[0] = '\\0';\n\n    }\n\n\n\n    bs->drv = drv;\n\n    bs->opaque = g_malloc0(drv->instance_size);\n\n\n\n    bs->enable_write_cache = !!(flags & BDRV_O_CACHE_WB);\n\n\n\n    /* Open the image, either directly or using a protocol */\n\n    if (drv->bdrv_file_open) {\n\n        assert(file == NULL);\n\n        assert(!drv->bdrv_needs_filename || filename != NULL);\n\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n\n    } else {\n\n        if (file == NULL) {\n\n            error_setg(errp, \"Can't use '%s' as a block driver for the \"\n\n                       \"protocol level\", drv->format_name);\n\n            ret = -EINVAL;\n\n            goto free_and_fail;\n\n        }\n\n        bs->file = file;\n\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (error_is_set(&local_err)) {\n\n            error_propagate(errp, local_err);\n\n        } else if (bs->filename[0]) {\n\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n\n        } else {\n\n            error_setg_errno(errp, -ret, \"Could not open image\");\n\n        }\n\n        goto free_and_fail;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        goto free_and_fail;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    if (bs->is_temporary) {\n\n        assert(bs->filename[0] != '\\0');\n\n        unlink(bs->filename);\n\n    }\n\n#endif\n\n    return 0;\n\n\n\nfree_and_fail:\n\n    bs->file = NULL;\n\n    g_free(bs->opaque);\n\n    bs->opaque = NULL;\n\n    bs->drv = NULL;\n\n    return ret;\n\n}\n", "idx": 1053}
{"project": "qemu", "commit_id": "4a9c9ea0d318bec2f67848c5ceaf4ad5bcb91d09", "target": 1, "func": "int64_t bdrv_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret = bdrv_nb_sectors(bs);\n\n\n\n\n    return ret < 0 ? ret : ret * BDRV_SECTOR_SIZE;\n\n}", "idx": 2730}
{"project": "qemu", "commit_id": "04920fc0faa4760f9c4fc0e73b992b768099be70", "target": 1, "func": "void do_info_roms(Monitor *mon, const QDict *qdict)\n\n{\n\n    Rom *rom;\n\n\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n\n        if (!rom->fw_file) {\n\n            monitor_printf(mon, \"addr=\" TARGET_FMT_plx\n\n                           \" size=0x%06zx mem=%s name=\\\"%s\\\"\\n\",\n\n                           rom->addr, rom->romsize,\n\n                           rom->isrom ? \"rom\" : \"ram\",\n\n                           rom->name);\n\n        } else {\n\n            monitor_printf(mon, \"fw=%s/%s\"\n\n                           \" size=0x%06zx name=\\\"%s\\\"\\n\",\n\n                           rom->fw_dir,\n\n                           rom->fw_file,\n\n                           rom->romsize,\n\n                           rom->name);\n\n        }\n\n    }\n\n}\n", "idx": 1143}
{"project": "qemu", "commit_id": "d9123d09f711bf1b855de2b5a907d4c85f46d6c3", "target": 1, "func": "QTestState *qtest_init_without_qmp_handshake(const char *extra_args)\n{\n    QTestState *s;\n    int sock, qmpsock, i;\n    gchar *socket_path;\n    gchar *qmp_socket_path;\n    gchar *command;\n    const char *qemu_binary;\n    qemu_binary = getenv(\"QTEST_QEMU_BINARY\");\n    g_assert(qemu_binary != NULL);\n    s = g_malloc(sizeof(*s));\n    socket_path = g_strdup_printf(\"/tmp/qtest-%d.sock\", getpid());\n    qmp_socket_path = g_strdup_printf(\"/tmp/qtest-%d.qmp\", getpid());\n    sock = init_socket(socket_path);\n    qmpsock = init_socket(qmp_socket_path);\n    qtest_add_abrt_handler(kill_qemu_hook_func, s);\n    s->qemu_pid = fork();\n    if (s->qemu_pid == 0) {\n        setenv(\"QEMU_AUDIO_DRV\", \"none\", true);\n        command = g_strdup_printf(\"exec %s \"\n                                  \"-qtest unix:%s,nowait \"\n                                  \"-qtest-log %s \"\n                                  \"-qmp unix:%s,nowait \"\n                                  \"-machine accel=qtest \"\n                                  \"-display none \"\n                                  \"%s\", qemu_binary, socket_path,\n                                  getenv(\"QTEST_LOG\") ? \"/dev/fd/2\" : \"/dev/null\",\n                                  qmp_socket_path,\n                                  extra_args ?: \"\");\n        execlp(\"/bin/sh\", \"sh\", \"-c\", command, NULL);\n        exit(1);\n    }\n    s->fd = socket_accept(sock);\n    if (s->fd >= 0) {\n        s->qmp_fd = socket_accept(qmpsock);\n    }\n    g_free(socket_path);\n    g_free(qmp_socket_path);\n    g_assert(s->fd >= 0 && s->qmp_fd >= 0);\n    s->rx = g_string_new(\"\");\n    for (i = 0; i < MAX_IRQ; i++) {\n        s->irq_level[i] = false;\n    }\n    if (getenv(\"QTEST_STOP\")) {\n        kill(s->qemu_pid, SIGSTOP);\n    }\n    /* ask endianness of the target */\n    s->big_endian = qtest_query_target_endianness(s);\n    return s;\n}", "idx": 6409}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usb_msd_send_status(MSDState *s, USBPacket *p)\n\n{\n\n    struct usb_msd_csw csw;\n\n    int len;\n\n\n\n    csw.sig = cpu_to_le32(0x53425355);\n\n    csw.tag = cpu_to_le32(s->tag);\n\n    csw.residue = s->residue;\n\n    csw.status = s->result;\n\n\n\n    len = MIN(sizeof(csw), p->len);\n\n    memcpy(p->data, &csw, len);\n\n}\n", "idx": 2185}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 11751}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power8nvl_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER8NVL\";\n\n    k->chip_type = PNV_CHIP_POWER8NVL;\n\n    k->chip_cfam_id = 0x120d304980000000ull;  /* P8 Naples DD1.0 */\n\n    k->cores_mask = POWER8_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p8;\n\n\n    dc->desc = \"PowerNV Chip POWER8NVL\";\n\n}", "idx": 2728}
{"project": "qemu", "commit_id": "271a916e8a4188b0ec94bafff18aa93de0047820", "target": 1, "func": "static always_inline void gen_rldimi (DisasContext *ctx, int mbn, int shn)\n\n{\n\n    uint64_t mask;\n\n    uint32_t sh, mb;\n\n\n\n    sh = SH(ctx->opcode) | (shn << 5);\n\n    mb = MB(ctx->opcode) | (mbn << 5);\n\n    if (likely(sh == 0)) {\n\n        if (likely(mb == 0)) {\n\n            gen_op_load_gpr_T0(rS(ctx->opcode));\n\n            goto do_store;\n\n        } else if (likely(mb == 63)) {\n\n            gen_op_load_gpr_T0(rA(ctx->opcode));\n\n            goto do_store;\n\n        }\n\n        gen_op_load_gpr_T0(rS(ctx->opcode));\n\n        gen_op_load_gpr_T1(rA(ctx->opcode));\n\n        goto do_mask;\n\n    }\n\n    gen_op_load_gpr_T0(rS(ctx->opcode));\n\n    gen_op_load_gpr_T1(rA(ctx->opcode));\n\n    gen_op_rotli64_T0(sh);\n\n do_mask:\n\n    mask = MASK(mb, 63 - sh);\n\n    gen_andi_T0_64(ctx, mask);\n\n    gen_andi_T1_64(ctx, ~mask);\n\n    gen_op_or();\n\n do_store:\n\n    gen_op_store_T0_gpr(rA(ctx->opcode));\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx);\n\n}\n", "idx": 10515}
{"project": "qemu", "commit_id": "f7c40aa1e7feb50bc4d4bc171fa811bdd9a93e51", "target": 1, "func": "void s390_pci_iommu_enable(S390PCIBusDevice *pbdev)\n\n{\n\n    uint64_t size = pbdev->pal - pbdev->pba + 1;\n\n\n\n    memory_region_init_iommu(&pbdev->iommu_mr, OBJECT(&pbdev->mr),\n\n                             &s390_iommu_ops, \"iommu-s390\", size);\n\n    memory_region_add_subregion(&pbdev->mr, pbdev->pba, &pbdev->iommu_mr);\n\n    pbdev->iommu_enabled = true;\n\n}\n", "idx": 751}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "AUXBus *aux_init_bus(DeviceState *parent, const char *name)\n\n{\n\n    AUXBus *bus;\n\n\n\n    bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));\n\n    bus->bridge = AUXTOI2C(qdev_create(BUS(bus), TYPE_AUXTOI2C));\n\n\n\n    /* Memory related. */\n\n    bus->aux_io = g_malloc(sizeof(*bus->aux_io));\n\n    memory_region_init(bus->aux_io, OBJECT(bus), \"aux-io\", (1 << 20));\n\n    address_space_init(&bus->aux_addr_space, bus->aux_io, \"aux-io\");\n\n    return bus;\n\n}\n", "idx": 11647}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,\n\n                               unsigned int *out_bytes,\n\n                               unsigned max_in_bytes, unsigned max_out_bytes)\n\n{\n\n    VirtIODevice *vdev = vq->vdev;\n\n    unsigned int max, idx;\n\n    unsigned int total_bufs, in_total, out_total;\n\n    VRingMemoryRegionCaches *caches;\n\n    MemoryRegionCache indirect_desc_cache = MEMORY_REGION_CACHE_INVALID;\n\n    int64_t len = 0;\n\n    int rc;\n\n\n\n    if (unlikely(!vq->vring.desc)) {\n\n        if (in_bytes) {\n\n            *in_bytes = 0;\n\n        }\n\n        if (out_bytes) {\n\n            *out_bytes = 0;\n\n        }\n\n        return;\n\n    }\n\n\n\n    rcu_read_lock();\n\n    idx = vq->last_avail_idx;\n\n    total_bufs = in_total = out_total = 0;\n\n\n\n    max = vq->vring.num;\n\n    caches = atomic_rcu_read(&vq->vring.caches);\n\n    if (caches->desc.len < max * sizeof(VRingDesc)) {\n\n        virtio_error(vdev, \"Cannot map descriptor ring\");\n\n        goto err;\n\n    }\n\n\n\n    while ((rc = virtqueue_num_heads(vq, idx)) > 0) {\n\n        MemoryRegionCache *desc_cache = &caches->desc;\n\n        unsigned int num_bufs;\n\n        VRingDesc desc;\n\n        unsigned int i;\n\n\n\n        num_bufs = total_bufs;\n\n\n\n        if (!virtqueue_get_head(vq, idx++, &i)) {\n\n            goto err;\n\n        }\n\n\n\n        vring_desc_read(vdev, &desc, desc_cache, i);\n\n\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n\n            if (desc.len % sizeof(VRingDesc)) {\n\n                virtio_error(vdev, \"Invalid size for indirect buffer table\");\n\n                goto err;\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                virtio_error(vdev, \"Looped descriptor\");\n\n                goto err;\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            len = address_space_cache_init(&indirect_desc_cache,\n\n                                           vdev->dma_as,\n\n                                           desc.addr, desc.len, false);\n\n            desc_cache = &indirect_desc_cache;\n\n            if (len < desc.len) {\n\n                virtio_error(vdev, \"Cannot map indirect buffer\");\n\n                goto err;\n\n            }\n\n\n\n            max = desc.len / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            vring_desc_read(vdev, &desc, desc_cache, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                virtio_error(vdev, \"Looped descriptor\");\n\n                goto err;\n\n            }\n\n\n\n            if (desc.flags & VRING_DESC_F_WRITE) {\n\n                in_total += desc.len;\n\n            } else {\n\n                out_total += desc.len;\n\n            }\n\n            if (in_total >= max_in_bytes && out_total >= max_out_bytes) {\n\n                goto done;\n\n            }\n\n\n\n            rc = virtqueue_read_next_desc(vdev, &desc, desc_cache, max, &i);\n\n        } while (rc == VIRTQUEUE_READ_DESC_MORE);\n\n\n\n        if (rc == VIRTQUEUE_READ_DESC_ERROR) {\n\n            goto err;\n\n        }\n\n\n\n        if (desc_cache == &indirect_desc_cache) {\n\n            address_space_cache_destroy(&indirect_desc_cache);\n\n            total_bufs++;\n\n        } else {\n\n            total_bufs = num_bufs;\n\n        }\n\n    }\n\n\n\n    if (rc < 0) {\n\n        goto err;\n\n    }\n\n\n\ndone:\n\n    address_space_cache_destroy(&indirect_desc_cache);\n\n    if (in_bytes) {\n\n        *in_bytes = in_total;\n\n    }\n\n    if (out_bytes) {\n\n        *out_bytes = out_total;\n\n    }\n\n    rcu_read_unlock();\n\n    return;\n\n\n\nerr:\n\n    in_total = out_total = 0;\n\n    goto done;\n\n}\n", "idx": 1470}
{"project": "qemu", "commit_id": "8c6c0478996e8f77374e69b6df68655b0b4ba689", "target": 1, "func": "vmxnet3_init_msi(VMXNET3State *s)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    int res;\n\n\n\n    res = msi_init(d, VMXNET3_MSI_OFFSET, VMXNET3_MSI_NUM_VECTORS,\n\n                   VMXNET3_USE_64BIT, VMXNET3_PER_VECTOR_MASK);\n\n    if (0 > res) {\n\n        VMW_WRPRN(\"Failed to initialize MSI, error %d\", res);\n\n        s->msi_used = false;\n\n    } else {\n\n        s->msi_used = true;\n\n    }\n\n\n\n    return s->msi_used;\n\n}\n", "idx": 6988}
{"project": "qemu", "commit_id": "e61da14d60ba1cceacad8396adcb9662c7f690af", "target": 1, "func": "static void handle_control_message(VirtIOSerial *vser, void *buf)\n\n{\n\n    struct VirtIOSerialPort *port;\n\n    struct virtio_console_control cpkt, *gcpkt;\n\n    uint8_t *buffer;\n\n    size_t buffer_len;\n\n\n\n    gcpkt = buf;\n\n\n\n    cpkt.event = lduw_p(&gcpkt->event);\n\n    cpkt.value = lduw_p(&gcpkt->value);\n\n\n\n    port = find_port_by_id(vser, ldl_p(&gcpkt->id));\n\n    if (!port && cpkt.event != VIRTIO_CONSOLE_DEVICE_READY)\n\n        return;\n\n\n\n    switch(cpkt.event) {\n\n    case VIRTIO_CONSOLE_DEVICE_READY:\n\n        if (!cpkt.value) {\n\n            error_report(\"virtio-serial-bus: Guest failure in adding device %s\\n\",\n\n                         vser->bus->qbus.name);\n\n            break;\n\n        }\n\n        /*\n\n         * The device is up, we can now tell the device about all the\n\n         * ports we have here.\n\n         */\n\n        QTAILQ_FOREACH(port, &vser->ports, next) {\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_ADD, 1);\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_CONSOLE_PORT_READY:\n\n        if (!cpkt.value) {\n\n            error_report(\"virtio-serial-bus: Guest failure in adding port %u for device %s\\n\",\n\n                         port->id, vser->bus->qbus.name);\n\n            break;\n\n        }\n\n        /*\n\n         * Now that we know the guest asked for the port name, we're\n\n         * sure the guest has initialised whatever state is necessary\n\n         * for this port. Now's a good time to let the guest know if\n\n         * this port is a console port so that the guest can hook it\n\n         * up to hvc.\n\n         */\n\n        if (port->is_console) {\n\n            send_control_event(port, VIRTIO_CONSOLE_CONSOLE_PORT, 1);\n\n        }\n\n\n\n        if (port->name) {\n\n            stw_p(&cpkt.event, VIRTIO_CONSOLE_PORT_NAME);\n\n            stw_p(&cpkt.value, 1);\n\n\n\n            buffer_len = sizeof(cpkt) + strlen(port->name) + 1;\n\n            buffer = qemu_malloc(buffer_len);\n\n\n\n            memcpy(buffer, &cpkt, sizeof(cpkt));\n\n            memcpy(buffer + sizeof(cpkt), port->name, strlen(port->name));\n\n            buffer[buffer_len - 1] = 0;\n\n\n\n            send_control_msg(port, buffer, buffer_len);\n\n            qemu_free(buffer);\n\n        }\n\n\n\n        if (port->host_connected) {\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\n\n        }\n\n\n\n        /*\n\n         * When the guest has asked us for this information it means\n\n         * the guest is all setup and has its virtqueues\n\n         * initialised. If some app is interested in knowing about\n\n         * this event, let it know.\n\n         */\n\n        if (port->info->guest_ready) {\n\n            port->info->guest_ready(port);\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_CONSOLE_PORT_OPEN:\n\n        port->guest_connected = cpkt.value;\n\n        if (cpkt.value && port->info->guest_open) {\n\n            /* Send the guest opened notification if an app is interested */\n\n            port->info->guest_open(port);\n\n        }\n\n\n\n        if (!cpkt.value && port->info->guest_close) {\n\n            /* Send the guest closed notification if an app is interested */\n\n            port->info->guest_close(port);\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 7102}
{"project": "qemu", "commit_id": "4f8eb8daebd72bdc214c63a3b2577f95bbadb27d", "target": 1, "func": "void pxa27x_register_keypad(struct pxa2xx_keypad_s *kp, struct keymap *map,\n\n        int size)\n\n{\n\n    kp->map = (struct keymap *) qemu_mallocz(sizeof(struct keymap) * size);\n\n\n\n    if(!map || size < 0x80) {\n\n        fprintf(stderr, \"%s - No PXA keypad map defined\\n\", __FUNCTION__);\n\n        exit(-1);\n\n    }\n\n\n\n    kp->map = map;\n\n    qemu_add_kbd_event_handler((QEMUPutKBDEvent *) pxa27x_keyboard_event, kp);\n\n}\n", "idx": 979}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_reset(VMXNET3State *s)\n\n{\n\n    VMW_CBPRN(\"Resetting vmxnet3...\");\n\n\n\n    vmxnet3_deactivate_device(s);\n\n    vmxnet3_reset_interrupt_states(s);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    s->drv_shmem = 0;\n\n    s->tx_sop = true;\n\n    s->skip_current_tx_pkt = false;\n\n}\n", "idx": 1100}
{"project": "qemu", "commit_id": "b25f23e7dbc6bc0dcda010222a4f178669d1aedc", "target": 1, "func": "static QObject *qdict_get_obj(const QDict *qdict, const char *key, QType type)\n\n{\n\n    QObject *obj;\n\n\n\n    obj = qdict_get(qdict, key);\n\n    assert(obj != NULL);\n\n    assert(qobject_type(obj) == type);\n\n\n\n    return obj;\n\n}\n", "idx": 1774}
{"project": "qemu", "commit_id": "503b3b33feca818baa4459aba286e54a528e5567", "target": 1, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    DisplaySurface *surface;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = qxl_phys2virt(qxl,\n\n                                                qxl->guest_primary.surface.mem,\n\n                                                MEMSLOT_GROUP_GUEST);\n\n        if (!qxl->guest_primary.data) {\n\n            return;\n\n        }\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            surface = qemu_create_displaysurface_from\n\n                (qxl->guest_primary.surface.width,\n\n                 qxl->guest_primary.surface.height,\n\n                 qxl->guest_primary.bits_pp,\n\n                 qxl->guest_primary.abs_stride,\n\n                 qxl->guest_primary.data,\n\n                 false);\n\n        } else {\n\n            surface = qemu_create_displaysurface\n\n                (qxl->guest_primary.surface.width,\n\n                 qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_replace_surface(vga->con, surface);\n\n    }\n\n\n\n    if (!qxl->guest_primary.data) {\n\n        return;\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        if (qxl->dirty[i].left > qxl->dirty[i].right ||\n\n            qxl->dirty[i].top > qxl->dirty[i].bottom ||\n\n            qxl->dirty[i].right > qxl->guest_primary.surface.width ||\n\n            qxl->dirty[i].bottom > qxl->guest_primary.surface.height) {\n\n            continue;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->con,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 11398}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 340}
{"project": "qemu", "commit_id": "47985727e383eee191a39cc007541c17cd8680ee", "target": 1, "func": "static int vfio_setup_pcie_cap(VFIOPCIDevice *vdev, int pos, uint8_t size,\n                               Error **errp)\n{\n    uint16_t flags;\n    uint8_t type;\n    flags = pci_get_word(vdev->pdev.config + pos + PCI_CAP_FLAGS);\n    type = (flags & PCI_EXP_FLAGS_TYPE) >> 4;\n    if (type != PCI_EXP_TYPE_ENDPOINT &&\n        type != PCI_EXP_TYPE_LEG_END &&\n        type != PCI_EXP_TYPE_RC_END) {\n        error_setg(errp, \"assignment of PCIe type 0x%x \"\n                   \"devices is not currently supported\", type);\n        return -EINVAL;\n    if (!pci_bus_is_express(vdev->pdev.bus)) {\n        PCIBus *bus = vdev->pdev.bus;\n        PCIDevice *bridge;\n         * Traditionally PCI device assignment exposes the PCIe capability\n         * as-is on non-express buses.  The reason being that some drivers\n         * simply assume that it's there, for example tg3.  However when\n         * we're running on a native PCIe machine type, like Q35, we need\n         * to hide the PCIe capability.  The reason for this is twofold;\n         * first Windows guests get a Code 10 error when the PCIe capability\n         * is exposed in this configuration.  Therefore express devices won't\n         * work at all unless they're attached to express buses in the VM.\n         * Second, a native PCIe machine introduces the possibility of fine\n         * granularity IOMMUs supporting both translation and isolation.\n         * Guest code to discover the IOMMU visibility of a device, such as\n         * IOMMU grouping code on Linux, is very aware of device types and\n         * valid transitions between bus types.  An express device on a non-\n         * express bus is not a valid combination on bare metal systems.\n         *\n         * Drivers that require a PCIe capability to make the device\n         * functional are simply going to need to have their devices placed\n         * on a PCIe bus in the VM.\n        while (!pci_bus_is_root(bus)) {\n            bridge = pci_bridge_get_device(bus);\n            bus = bridge->bus;\n        if (pci_bus_is_express(bus)) {\n            return 0;\n    } else if (pci_bus_is_root(vdev->pdev.bus)) {\n         * On a Root Complex bus Endpoints become Root Complex Integrated\n         * Endpoints, which changes the type and clears the LNK & LNK2 fields.\n        if (type == PCI_EXP_TYPE_ENDPOINT) {\n                                   PCI_EXP_TYPE_RC_END << 4,\n                                   PCI_EXP_FLAGS_TYPE);\n            /* Link Capabilities, Status, and Control goes away */\n            if (size > PCI_EXP_LNKCTL) {\n                vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP, 0, ~0);\n                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);\n                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA, 0, ~0);\n#ifndef PCI_EXP_LNKCAP2\n#define PCI_EXP_LNKCAP2 44\n#endif\n#ifndef PCI_EXP_LNKSTA2\n#define PCI_EXP_LNKSTA2 50\n#endif\n                /* Link 2 Capabilities, Status, and Control goes away */\n                if (size > PCI_EXP_LNKCAP2) {\n                    vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP2, 0, ~0);\n                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL2, 0, ~0);\n                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA2, 0, ~0);\n        } else if (type == PCI_EXP_TYPE_LEG_END) {\n             * Legacy endpoints don't belong on the root complex.  Windows\n             * seems to be happier with devices if we skip the capability.\n            return 0;\n    } else {\n         * Convert Root Complex Integrated Endpoints to regular endpoints.\n         * These devices don't support LNK/LNK2 capabilities, so make them up.\n        if (type == PCI_EXP_TYPE_RC_END) {\n                                   PCI_EXP_TYPE_ENDPOINT << 4,\n                                   PCI_EXP_FLAGS_TYPE);\n            vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP,\n                                   PCI_EXP_LNK_MLW_1 | PCI_EXP_LNK_LS_25, ~0);\n            vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);\n        /* Mark the Link Status bits as emulated to allow virtual negotiation */\n        vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA,\n                               pci_get_word(vdev->pdev.config + pos +\n                                            PCI_EXP_LNKSTA),\n                               PCI_EXP_LNKCAP_MLW | PCI_EXP_LNKCAP_SLS);\n    pos = pci_add_capability(&vdev->pdev, PCI_CAP_ID_EXP, pos, size,\n                             errp);\n    if (pos < 0) {\n        return pos;\n    vdev->pdev.exp.exp_cap = pos;\n    return pos;", "idx": 10295}
{"project": "qemu", "commit_id": "5e52e5f903b2648c59030637e1610b32e965d615", "target": 1, "func": "static uint32_t get_features(VirtIODevice *vdev, uint32_t features)\n\n{\n\n    VirtIOSerial *vser;\n\n\n\n    vser = DO_UPCAST(VirtIOSerial, vdev, vdev);\n\n\n\n    if (vser->bus->max_nr_ports > 1) {\n\n        features |= (1 << VIRTIO_CONSOLE_F_MULTIPORT);\n\n    }\n\n    return features;\n\n}\n", "idx": 5201}
{"project": "qemu", "commit_id": "e7c8526b2a1482a9b14319fda9f8ad4bfda5b958", "target": 1, "func": "void ahci_hba_enable(AHCIQState *ahci)\n\n{\n\n    /* Bits of interest in this section:\n\n     * GHC.AE     Global Host Control / AHCI Enable\n\n     * PxCMD.ST   Port Command: Start\n\n     * PxCMD.SUD  \"Spin Up Device\"\n\n     * PxCMD.POD  \"Power On Device\"\n\n     * PxCMD.FRE  \"FIS Receive Enable\"\n\n     * PxCMD.FR   \"FIS Receive Running\"\n\n     * PxCMD.CR   \"Command List Running\"\n\n     */\n\n    uint32_t reg, ports_impl;\n\n    uint16_t i;\n\n    uint8_t num_cmd_slots;\n\n\n\n    g_assert(ahci != NULL);\n\n\n\n    /* Set GHC.AE to 1 */\n\n    ahci_set(ahci, AHCI_GHC, AHCI_GHC_AE);\n\n    reg = ahci_rreg(ahci, AHCI_GHC);\n\n    ASSERT_BIT_SET(reg, AHCI_GHC_AE);\n\n\n\n    /* Cache CAP and CAP2. */\n\n    ahci->cap = ahci_rreg(ahci, AHCI_CAP);\n\n    ahci->cap2 = ahci_rreg(ahci, AHCI_CAP2);\n\n\n\n    /* Read CAP.NCS, how many command slots do we have? */\n\n    num_cmd_slots = ((ahci->cap & AHCI_CAP_NCS) >> ctzl(AHCI_CAP_NCS)) + 1;\n\n    g_test_message(\"Number of Command Slots: %u\", num_cmd_slots);\n\n\n\n    /* Determine which ports are implemented. */\n\n    ports_impl = ahci_rreg(ahci, AHCI_PI);\n\n\n\n    for (i = 0; ports_impl; ports_impl >>= 1, ++i) {\n\n        if (!(ports_impl & 0x01)) {\n\n            continue;\n\n        }\n\n\n\n        g_test_message(\"Initializing port %u\", i);\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n        if (BITCLR(reg, AHCI_PX_CMD_ST | AHCI_PX_CMD_CR |\n\n                   AHCI_PX_CMD_FRE | AHCI_PX_CMD_FR)) {\n\n            g_test_message(\"port is idle\");\n\n        } else {\n\n            g_test_message(\"port needs to be idled\");\n\n            ahci_px_clr(ahci, i, AHCI_PX_CMD,\n\n                        (AHCI_PX_CMD_ST | AHCI_PX_CMD_FRE));\n\n            /* The port has 500ms to disengage. */\n\n            usleep(500000);\n\n            reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n            ASSERT_BIT_CLEAR(reg, AHCI_PX_CMD_CR);\n\n            ASSERT_BIT_CLEAR(reg, AHCI_PX_CMD_FR);\n\n            g_test_message(\"port is now idle\");\n\n            /* The spec does allow for possibly needing a PORT RESET\n\n             * or HBA reset if we fail to idle the port. */\n\n        }\n\n\n\n        /* Allocate Memory for the Command List Buffer & FIS Buffer */\n\n        /* PxCLB space ... 0x20 per command, as in 4.2.2 p 36 */\n\n        ahci->port[i].clb = ahci_alloc(ahci, num_cmd_slots * 0x20);\n\n        qmemset(ahci->port[i].clb, 0x00, num_cmd_slots * 0x20);\n\n        g_test_message(\"CLB: 0x%08\" PRIx64, ahci->port[i].clb);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_CLB, ahci->port[i].clb);\n\n        g_assert_cmphex(ahci->port[i].clb, ==,\n\n                        ahci_px_rreg(ahci, i, AHCI_PX_CLB));\n\n\n\n        /* PxFB space ... 0x100, as in 4.2.1 p 35 */\n\n        ahci->port[i].fb = ahci_alloc(ahci, 0x100);\n\n        qmemset(ahci->port[i].fb, 0x00, 0x100);\n\n        g_test_message(\"FB: 0x%08\" PRIx64, ahci->port[i].fb);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_FB, ahci->port[i].fb);\n\n        g_assert_cmphex(ahci->port[i].fb, ==,\n\n                        ahci_px_rreg(ahci, i, AHCI_PX_FB));\n\n\n\n        /* Clear PxSERR, PxIS, then IS.IPS[x] by writing '1's. */\n\n        ahci_px_wreg(ahci, i, AHCI_PX_SERR, 0xFFFFFFFF);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_IS, 0xFFFFFFFF);\n\n        ahci_wreg(ahci, AHCI_IS, (1 << i));\n\n\n\n        /* Verify Interrupts Cleared */\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_SERR);\n\n        g_assert_cmphex(reg, ==, 0);\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_IS);\n\n        g_assert_cmphex(reg, ==, 0);\n\n\n\n        reg = ahci_rreg(ahci, AHCI_IS);\n\n        ASSERT_BIT_CLEAR(reg, (1 << i));\n\n\n\n        /* Enable All Interrupts: */\n\n        ahci_px_wreg(ahci, i, AHCI_PX_IE, 0xFFFFFFFF);\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_IE);\n\n        g_assert_cmphex(reg, ==, ~((uint32_t)AHCI_PX_IE_RESERVED));\n\n\n\n        /* Enable the FIS Receive Engine. */\n\n        ahci_px_set(ahci, i, AHCI_PX_CMD, AHCI_PX_CMD_FRE);\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n        ASSERT_BIT_SET(reg, AHCI_PX_CMD_FR);\n\n\n\n        /* AHCI 1.3 spec: if !STS.BSY, !STS.DRQ and PxSSTS.DET indicates\n\n         * physical presence, a device is present and may be started. However,\n\n         * PxSERR.DIAG.X /may/ need to be cleared a priori. */\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_SERR);\n\n        if (BITSET(reg, AHCI_PX_SERR_DIAG_X)) {\n\n            ahci_px_set(ahci, i, AHCI_PX_SERR, AHCI_PX_SERR_DIAG_X);\n\n        }\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_TFD);\n\n        if (BITCLR(reg, AHCI_PX_TFD_STS_BSY | AHCI_PX_TFD_STS_DRQ)) {\n\n            reg = ahci_px_rreg(ahci, i, AHCI_PX_SSTS);\n\n            if ((reg & AHCI_PX_SSTS_DET) == SSTS_DET_ESTABLISHED) {\n\n                /* Device Found: set PxCMD.ST := 1 */\n\n                ahci_px_set(ahci, i, AHCI_PX_CMD, AHCI_PX_CMD_ST);\n\n                ASSERT_BIT_SET(ahci_px_rreg(ahci, i, AHCI_PX_CMD),\n\n                               AHCI_PX_CMD_CR);\n\n                g_test_message(\"Started Device %u\", i);\n\n            } else if ((reg & AHCI_PX_SSTS_DET)) {\n\n                /* Device present, but in some unknown state. */\n\n                g_assert_not_reached();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* Enable GHC.IE */\n\n    ahci_set(ahci, AHCI_GHC, AHCI_GHC_IE);\n\n    reg = ahci_rreg(ahci, AHCI_GHC);\n\n    ASSERT_BIT_SET(reg, AHCI_GHC_IE);\n\n\n\n\n    /* TODO: The device should now be idling and waiting for commands.\n\n     * In the future, a small test-case to inspect the Register D2H FIS\n\n     * and clear the initial interrupts might be good. */\n\n}", "idx": 1172}
{"project": "qemu", "commit_id": "b41d320fef705289d2b73f4949731eb2e189161d", "target": 1, "func": "static void spapr_alloc_htab(sPAPRMachineState *spapr)\n\n{\n\n    long shift;\n\n    int index;\n\n\n\n    /* allocate hash page table.  For now we always make this 16mb,\n\n     * later we should probably make it scale to the size of guest\n\n     * RAM */\n\n\n\n    shift = kvmppc_reset_htab(spapr->htab_shift);\n\n\n\n    if (shift > 0) {\n\n        /* Kernel handles htab, we don't need to allocate one */\n\n        if (shift != spapr->htab_shift) {\n\n            error_setg(&error_abort, \"Failed to allocate HTAB of requested size, try with smaller maxmem\");\n\n        }\n\n\n\n        spapr->htab_shift = shift;\n\n        kvmppc_kern_htab = true;\n\n    } else {\n\n        /* Allocate htab */\n\n        spapr->htab = qemu_memalign(HTAB_SIZE(spapr), HTAB_SIZE(spapr));\n\n\n\n        /* And clear it */\n\n        memset(spapr->htab, 0, HTAB_SIZE(spapr));\n\n\n\n        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n\n            DIRTY_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n    }\n\n}\n", "idx": 10865}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_xattrcreate(void *opaque)\n\n{\n\n    int flags;\n\n    int32_t fid;\n\n    int64_t size;\n\n    ssize_t err = 0;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    V9fsFidState *file_fidp;\n\n    V9fsFidState *xattr_fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dsqd\",\n\n                  &fid, &name, &size, &flags);\n\n\n\n\n    file_fidp = get_fid(pdu, fid);\n\n    if (file_fidp == NULL) {\n\n        err = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    /* Make the file fid point to xattr */\n\n    xattr_fidp = file_fidp;\n\n    xattr_fidp->fid_type = P9_FID_XATTR;\n\n    xattr_fidp->fs.xattr.copied_len = 0;\n\n    xattr_fidp->fs.xattr.len = size;\n\n    xattr_fidp->fs.xattr.flags = flags;\n\n    v9fs_string_init(&xattr_fidp->fs.xattr.name);\n\n    v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n\n    if (size) {\n\n        xattr_fidp->fs.xattr.value = g_malloc(size);\n\n    } else {\n\n        xattr_fidp->fs.xattr.value = NULL;\n\n    }\n\n    err = offset;\n\n    put_fid(pdu, file_fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n    v9fs_string_free(&name);\n\n}", "idx": 10443}
{"project": "qemu", "commit_id": "d2e9fd8f703203c2eeeed120b1ef6c3a6574e0ab", "target": 1, "func": "static always_inline void gen_op_arith_subf(DisasContext *ctx, TCGv ret, TCGv arg1, TCGv arg2,\n\n                                            int add_ca, int compute_ca, int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret, arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_andi_tl(t1, cpu_xer, (1 << XER_CA));\n\n        tcg_gen_shri_tl(t1, t1, XER_CA);\n\n\n\n    }\n\n\n\n    if (compute_ca && compute_ov) {\n\n        /* Start with XER CA and OV disabled, the most likely case */\n\n        tcg_gen_andi_tl(cpu_xer, cpu_xer, ~((1 << XER_CA) | (1 << XER_OV)));\n\n    } else if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_andi_tl(cpu_xer, cpu_xer, ~(1 << XER_CA));\n\n    } else if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_andi_tl(cpu_xer, cpu_xer, ~(1 << XER_OV));\n\n    }\n\n\n\n    if (add_ca) {\n\n        tcg_gen_not_tl(t0, arg1);\n\n        tcg_gen_add_tl(t0, t0, arg2);\n\n        gen_op_arith_compute_ca(ctx, t0, arg2, 0);\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n\n        tcg_gen_sub_tl(t0, arg2, arg1);\n\n        if (compute_ca) {\n\n            gen_op_arith_compute_ca(ctx, t0, arg2, 1);\n\n        }\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 1);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}", "idx": 9031}
{"project": "qemu", "commit_id": "ff4b91c2f7e51dab148aba4bf43c2f39f219e495", "target": 1, "func": "static uint64_t get_cluster_offset(BlockDriverState *bs,\n\n                                   uint64_t offset, int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int l1_bits, c;\n\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n\n\n\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n\n    nb_needed = *num + index_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the offset and\n\n     * the end of the l1 entry\n\n     */\n\n\n\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n", "idx": 10293}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_er_reset(XHCIState *xhci, int v)\n\n{\n\n    XHCIInterrupter *intr = &xhci->intr[v];\n\n    XHCIEvRingSeg seg;\n\n\n\n    if (intr->erstsz == 0) {\n\n        /* disabled */\n\n        intr->er_start = 0;\n\n        intr->er_size = 0;\n\n        return;\n\n    }\n\n    /* cache the (sole) event ring segment location */\n\n    if (intr->erstsz != 1) {\n\n        DPRINTF(\"xhci: invalid value for ERSTSZ: %d\\n\", intr->erstsz);\n\n        xhci_die(xhci);\n\n        return;\n\n    }\n\n    dma_addr_t erstba = xhci_addr64(intr->erstba_low, intr->erstba_high);\n\n    pci_dma_read(PCI_DEVICE(xhci), erstba, &seg, sizeof(seg));\n\n    le32_to_cpus(&seg.addr_low);\n\n    le32_to_cpus(&seg.addr_high);\n\n    le32_to_cpus(&seg.size);\n\n    if (seg.size < 16 || seg.size > 4096) {\n\n        DPRINTF(\"xhci: invalid value for segment size: %d\\n\", seg.size);\n\n        xhci_die(xhci);\n\n        return;\n\n    }\n\n    intr->er_start = xhci_addr64(seg.addr_low, seg.addr_high);\n\n    intr->er_size = seg.size;\n\n\n\n    intr->er_ep_idx = 0;\n\n    intr->er_pcs = 1;\n\n    intr->er_full = 0;\n\n\n\n    DPRINTF(\"xhci: event ring[%d]:\" DMA_ADDR_FMT \" [%d]\\n\",\n\n            v, intr->er_start, intr->er_size);\n\n}\n", "idx": 8626}
{"project": "qemu", "commit_id": "983bff3530782d51c46c8d7c0e17e2a9dfe5fb77", "target": 1, "func": "static void usb_mtp_handle_reset(USBDevice *dev)\n\n{\n\n    MTPState *s = USB_MTP(dev);\n\n\n\n    trace_usb_mtp_reset(s->dev.addr);\n\n\n\n#ifdef __linux__\n\n    usb_mtp_inotify_cleanup(s);\n\n#endif\n\n    usb_mtp_object_free(s, QTAILQ_FIRST(&s->objects));\n\n    s->session = 0;\n\n    usb_mtp_data_free(s->data_in);\n\n    s->data_in = NULL;\n\n    usb_mtp_data_free(s->data_out);\n\n    s->data_out = NULL;\n\n    g_free(s->result);\n\n    s->result = NULL;\n\n}\n", "idx": 11481}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_lcreate(void *opaque)\n\n{\n\n    int32_t dfid, flags, mode;\n\n    gid_t gid;\n\n    ssize_t err = 0;\n\n    ssize_t offset = 7;\n\n    V9fsString name;\n\n    V9fsFidState *fidp;\n\n    struct stat stbuf;\n\n    V9fsQID qid;\n\n    int32_t iounit;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dsddd\", &dfid, &name, &flags,\n\n                  &mode, &gid);\n\n\n\n\n    fidp = get_fid(pdu, dfid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    flags = get_dotl_openflags(pdu->s, flags);\n\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n\n                        flags | O_CREAT, mode, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    fidp->fid_type = P9_FID_FILE;\n\n    fidp->open_flags = flags;\n\n    if (flags & O_EXCL) {\n\n        /*\n\n         * We let the host file system do O_EXCL check\n\n         * We should not reclaim such fd\n\n         */\n\n        fidp->flags |= FID_NON_RECLAIMABLE;\n\n    }\n\n    iounit =  get_iounit(pdu, &fidp->path);\n\n    stat_to_qid(&stbuf, &qid);\n\n    offset += pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n    err = offset;\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n\n                              qid.type, qid.version, qid.path, iounit);\n\n    complete_pdu(pdu->s, pdu, err);\n\n    v9fs_string_free(&name);\n\n}", "idx": 9295}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void send_framebuffer_update_hextile(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, 5);\n\n\n\n    last_fg = (uint8_t *) malloc(vs->depth);\n\n    last_bg = (uint8_t *) malloc(vs->depth);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n\tfor (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n\t}\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n}\n", "idx": 5799}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                    QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_pwritev(bs->file, offset, bytes, qiov, flags);", "idx": 7283}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void vm_stop(int reason)\n\n{\n\n    do_vm_stop(reason);\n\n}\n", "idx": 3500}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "monitor_protocol_event_queue(MonitorEvent event,\n\n                             QObject *data)\n\n{\n\n    MonitorEventState *evstate;\n\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    assert(event < QEVENT_MAX);\n\n\n\n    qemu_mutex_lock(&monitor_event_state_lock);\n\n    evstate = &(monitor_event_state[event]);\n\n    trace_monitor_protocol_event_queue(event,\n\n                                       data,\n\n                                       evstate->rate,\n\n                                       evstate->last,\n\n                                       now);\n\n\n\n    /* Rate limit of 0 indicates no throttling */\n\n    if (!evstate->rate) {\n\n        monitor_protocol_event_emit(event, data);\n\n        evstate->last = now;\n\n    } else {\n\n        int64_t delta = now - evstate->last;\n\n        if (evstate->data ||\n\n            delta < evstate->rate) {\n\n            /* If there's an existing event pending, replace\n\n             * it with the new event, otherwise schedule a\n\n             * timer for delayed emission\n\n             */\n\n            if (evstate->data) {\n\n                qobject_decref(evstate->data);\n\n            } else {\n\n                int64_t then = evstate->last + evstate->rate;\n\n                timer_mod_ns(evstate->timer, then);\n\n            }\n\n            evstate->data = data;\n\n            qobject_incref(evstate->data);\n\n        } else {\n\n            monitor_protocol_event_emit(event, data);\n\n            evstate->last = now;\n\n        }\n\n    }\n\n    qemu_mutex_unlock(&monitor_event_state_lock);\n\n}\n", "idx": 1705}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 5180}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void openrisc_sim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    OpenRISCCPU *cpu = NULL;\n\n    MemoryRegion *ram;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"or1200\";\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find CPU definition!\\n\");\n\n            exit(1);\n\n        }\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n        main_cpu_reset(cpu);\n\n    }\n\n\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"openrisc.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram);\n\n\n\n    cpu_openrisc_pic_init(cpu);\n\n    cpu_openrisc_clock_init(cpu);\n\n\n\n    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],\n\n                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n\n\n    if (nd_table[0].used) {\n\n        openrisc_sim_net_init(get_system_memory(), 0x92000000,\n\n                              0x92000400, cpu->env.irq[4], nd_table);\n\n    }\n\n\n\n    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);\n\n}\n", "idx": 9234}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static CharDriverState *qemu_chr_open_file_out(QemuOpts *opts)\n\n{\n\n    int fd_out;\n\n\n\n    TFR(fd_out = open(qemu_opt_get(opts, \"path\"),\n\n                      O_WRONLY | O_TRUNC | O_CREAT | O_BINARY, 0666));\n\n    if (fd_out < 0)\n\n        return NULL;\n\n    return qemu_chr_open_fd(-1, fd_out);\n\n}\n", "idx": 2630}
{"project": "qemu", "commit_id": "2d3e302ec2246d703ffa8d8f8769a3fa448d8145", "target": 1, "func": "bool kvmppc_is_mem_backend_page_size_ok(const char *obj_path)\n\n{\n\n    Object *mem_obj = object_resolve_path(obj_path, NULL);\n\n    char *mempath = object_property_get_str(mem_obj, \"mem-path\", NULL);\n\n    long pagesize;\n\n\n\n    if (mempath) {\n\n        pagesize = qemu_mempath_getpagesize(mempath);\n\n\n    } else {\n\n        pagesize = getpagesize();\n\n    }\n\n\n\n    return pagesize >= max_cpu_page_size;\n\n}", "idx": 11285}
{"project": "qemu", "commit_id": "b25f23e7dbc6bc0dcda010222a4f178669d1aedc", "target": 1, "func": "QList *qdict_get_qlist(const QDict *qdict, const char *key)\n\n{\n\n    return qobject_to_qlist(qdict_get_obj(qdict, key, QTYPE_QLIST));\n\n}\n", "idx": 7585}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 7684}
{"project": "qemu", "commit_id": "159d2e39a8602c369542a92573a52acb5f5f58f2", "target": 1, "func": "static long getrampagesize(void)\n\n{\n\n    long hpsize = LONG_MAX;\n\n    Object *memdev_root;\n\n\n\n    if (mem_path) {\n\n        return gethugepagesize(mem_path);\n\n    }\n\n\n\n    /* it's possible we have memory-backend objects with\n\n     * hugepage-backed RAM. these may get mapped into system\n\n     * address space via -numa parameters or memory hotplug\n\n     * hooks. we want to take these into account, but we\n\n     * also want to make sure these supported hugepage\n\n     * sizes are applicable across the entire range of memory\n\n     * we may boot from, so we take the min across all\n\n     * backends, and assume normal pages in cases where a\n\n     * backend isn't backed by hugepages.\n\n     */\n\n    memdev_root = object_resolve_path(\"/objects\", NULL);\n\n    if (!memdev_root) {\n\n        return getpagesize();\n\n    }\n\n\n\n    object_child_foreach(memdev_root, find_max_supported_pagesize, &hpsize);\n\n\n\n    if (hpsize == LONG_MAX) {\n\n        return getpagesize();\n\n    }\n\n\n\n    if (nb_numa_nodes == 0 && hpsize > getpagesize()) {\n\n        /* No NUMA nodes and normal RAM without -mem-path ==> no huge pages! */\n\n        static bool warned;\n\n        if (!warned) {\n\n            error_report(\"Huge page support disabled (n/a for main memory).\");\n\n            warned = true;\n\n        }\n\n        return getpagesize();\n\n    }\n\n\n\n    return hpsize;\n\n}\n", "idx": 6863}
{"project": "qemu", "commit_id": "b1fe60cd3525871a4c593ad8c2b39b89c19c00d0", "target": 1, "func": "static void intel_hda_update_irq(IntelHDAState *d)\n\n{\n\n    int msi = d->msi && msi_enabled(&d->pci);\n\n    int level;\n\n\n\n    intel_hda_update_int_sts(d);\n\n    if (d->int_sts & (1 << 31) && d->int_ctl & (1 << 31)) {\n\n        level = 1;\n\n    } else {\n\n        level = 0;\n\n    }\n\n    dprint(d, 2, \"%s: level %d [%s]\\n\", __FUNCTION__,\n\n           level, msi ? \"msi\" : \"intx\");\n\n    if (msi) {\n\n        if (level) {\n\n            msi_notify(&d->pci, 0);\n\n        }\n\n    } else {\n\n        pci_set_irq(&d->pci, level);\n\n    }\n\n}\n", "idx": 3041}
{"project": "qemu", "commit_id": "da4bc86c540991902e32e4e840c6ada573240254", "target": 1, "func": "static int proxy_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,\n\n                       const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_MKDIR, NULL, &fullname,\n\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    v9fs_string_free(&fullname);\n\n    return retval;\n\n}\n", "idx": 1353}
{"project": "qemu", "commit_id": "cfc87e00c22ab4ea0262c9771c803ed03d754001", "target": 1, "func": "vpc_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n\n               QEMUIOVector *qiov, int flags)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t image_offset;\n\n    int64_t n_bytes;\n\n    int64_t bytes_done = 0;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n    QEMUIOVector local_qiov;\n\n\n\n    if (be32_to_cpu(footer->type) == VHD_FIXED) {\n\n        return bdrv_co_pwritev(bs->file, offset, bytes, qiov, 0);\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    qemu_iovec_init(&local_qiov, qiov->niov);\n\n\n\n    while (bytes > 0) {\n\n        image_offset = get_image_offset(bs, offset, true);\n\n        n_bytes = MIN(bytes, s->block_size - (offset % s->block_size));\n\n\n\n        if (image_offset == -1) {\n\n            image_offset = alloc_block(bs, offset);\n\n            if (image_offset < 0) {\n\n                ret = image_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        qemu_iovec_reset(&local_qiov);\n\n        qemu_iovec_concat(&local_qiov, qiov, bytes_done, n_bytes);\n\n\n\n        ret = bdrv_co_pwritev(bs->file, image_offset, n_bytes,\n\n                              &local_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        bytes -= n_bytes;\n\n        offset += n_bytes;\n\n        bytes_done += n_bytes;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_iovec_destroy(&local_qiov);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return ret;\n\n}\n", "idx": 4142}
{"project": "qemu", "commit_id": "262a69f4282e44426c7a132138581d400053e0a1", "target": 1, "func": "static void *mptsas_load_request(QEMUFile *f, SCSIRequest *sreq)\n\n{\n\n    SCSIBus *bus = sreq->bus;\n\n    MPTSASState *s = container_of(bus, MPTSASState, bus);\n\n    PCIDevice *pci = PCI_DEVICE(s);\n\n    MPTSASRequest *req;\n\n    int i, n;\n\n\n\n    req = g_new(MPTSASRequest, 1);\n\n    qemu_get_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n\n\n\n    n = qemu_get_be32(f);\n\n    /* TODO: add a way for SCSIBusInfo's load_request to fail,\n\n     * and fail migration instead of asserting here.\n\n     * When we do, we might be able to re-enable NDEBUG below.\n\n     */\n\n#ifdef NDEBUG\n\n#error building with NDEBUG is not supported\n\n#endif\n\n    assert(n >= 0);\n\n\n\n    pci_dma_sglist_init(&req->qsg, pci, n);\n\n    for (i = 0; i < n; i++) {\n\n        uint64_t base = qemu_get_be64(f);\n\n        uint64_t len = qemu_get_be64(f);\n\n        qemu_sglist_add(&req->qsg, base, len);\n\n    }\n\n\n\n    scsi_req_ref(sreq);\n\n    req->sreq = sreq;\n\n    req->dev = s;\n\n\n\n    return req;\n\n}\n", "idx": 11793}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_do_adma(SDHCIState *s)\n\n{\n\n    unsigned int n, begin, length;\n\n    const uint16_t block_size = s->blksize & 0x0fff;\n\n    ADMADescr dscr;\n\n    int i;\n\n\n\n    for (i = 0; i < SDHC_ADMA_DESCS_PER_DELAY; ++i) {\n\n        s->admaerr &= ~SDHC_ADMAERR_LENGTH_MISMATCH;\n\n\n\n        get_adma_description(s, &dscr);\n\n        DPRINT_L2(\"ADMA loop: addr=\" TARGET_FMT_plx \", len=%d, attr=%x\\n\",\n\n                dscr.addr, dscr.length, dscr.attr);\n\n\n\n        if ((dscr.attr & SDHC_ADMA_ATTR_VALID) == 0) {\n\n            /* Indicate that error occurred in ST_FDS state */\n\n            s->admaerr &= ~SDHC_ADMAERR_STATE_MASK;\n\n            s->admaerr |= SDHC_ADMAERR_STATE_ST_FDS;\n\n\n\n            /* Generate ADMA error interrupt */\n\n            if (s->errintstsen & SDHC_EISEN_ADMAERR) {\n\n                s->errintsts |= SDHC_EIS_ADMAERR;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n\n\n            sdhci_update_irq(s);\n\n            return;\n\n        }\n\n\n\n        length = dscr.length ? dscr.length : 65536;\n\n\n\n        switch (dscr.attr & SDHC_ADMA_ATTR_ACT_MASK) {\n\n        case SDHC_ADMA_ATTR_ACT_TRAN:  /* data transfer */\n\n\n\n            if (s->trnmod & SDHC_TRNS_READ) {\n\n                while (length) {\n\n                    if (s->data_count == 0) {\n\n                        for (n = 0; n < block_size; n++) {\n\n                            s->fifo_buffer[n] = sdbus_read_data(&s->sdbus);\n\n                        }\n\n                    }\n\n                    begin = s->data_count;\n\n                    if ((length + begin) < block_size) {\n\n                        s->data_count = length + begin;\n\n                        length = 0;\n\n                     } else {\n\n                        s->data_count = block_size;\n\n                        length -= block_size - begin;\n\n                    }\n\n                    dma_memory_write(&address_space_memory, dscr.addr,\n\n                                     &s->fifo_buffer[begin],\n\n                                     s->data_count - begin);\n\n                    dscr.addr += s->data_count - begin;\n\n                    if (s->data_count == block_size) {\n\n                        s->data_count = 0;\n\n                        if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                            s->blkcnt--;\n\n                            if (s->blkcnt == 0) {\n\n                                break;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                while (length) {\n\n                    begin = s->data_count;\n\n                    if ((length + begin) < block_size) {\n\n                        s->data_count = length + begin;\n\n                        length = 0;\n\n                     } else {\n\n                        s->data_count = block_size;\n\n                        length -= block_size - begin;\n\n                    }\n\n                    dma_memory_read(&address_space_memory, dscr.addr,\n\n                                    &s->fifo_buffer[begin],\n\n                                    s->data_count - begin);\n\n                    dscr.addr += s->data_count - begin;\n\n                    if (s->data_count == block_size) {\n\n                        for (n = 0; n < block_size; n++) {\n\n                            sdbus_write_data(&s->sdbus, s->fifo_buffer[n]);\n\n                        }\n\n                        s->data_count = 0;\n\n                        if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                            s->blkcnt--;\n\n                            if (s->blkcnt == 0) {\n\n                                break;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            s->admasysaddr += dscr.incr;\n\n            break;\n\n        case SDHC_ADMA_ATTR_ACT_LINK:   /* link to next descriptor table */\n\n            s->admasysaddr = dscr.addr;\n\n            DPRINT_L1(\"ADMA link: admasysaddr=0x%\" PRIx64 \"\\n\",\n\n                      s->admasysaddr);\n\n            break;\n\n        default:\n\n            s->admasysaddr += dscr.incr;\n\n            break;\n\n        }\n\n\n\n        if (dscr.attr & SDHC_ADMA_ATTR_INT) {\n\n            DPRINT_L1(\"ADMA interrupt: admasysaddr=0x%\" PRIx64 \"\\n\",\n\n                      s->admasysaddr);\n\n            if (s->norintstsen & SDHC_NISEN_DMA) {\n\n                s->norintsts |= SDHC_NIS_DMA;\n\n            }\n\n\n\n            sdhci_update_irq(s);\n\n        }\n\n\n\n        /* ADMA transfer terminates if blkcnt == 0 or by END attribute */\n\n        if (((s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&\n\n                    (s->blkcnt == 0)) || (dscr.attr & SDHC_ADMA_ATTR_END)) {\n\n            DPRINT_L2(\"ADMA transfer completed\\n\");\n\n            if (length || ((dscr.attr & SDHC_ADMA_ATTR_END) &&\n\n                (s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&\n\n                s->blkcnt != 0)) {\n\n                ERRPRINT(\"SD/MMC host ADMA length mismatch\\n\");\n\n                s->admaerr |= SDHC_ADMAERR_LENGTH_MISMATCH |\n\n                        SDHC_ADMAERR_STATE_ST_TFR;\n\n                if (s->errintstsen & SDHC_EISEN_ADMAERR) {\n\n                    ERRPRINT(\"Set ADMA error flag\\n\");\n\n                    s->errintsts |= SDHC_EIS_ADMAERR;\n\n                    s->norintsts |= SDHC_NIS_ERR;\n\n                }\n\n\n\n                sdhci_update_irq(s);\n\n            }\n\n            sdhci_end_transfer(s);\n\n            return;\n\n        }\n\n\n\n    }\n\n\n\n    /* we have unfinished business - reschedule to continue ADMA */\n\n    timer_mod(s->transfer_timer,\n\n                   qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + SDHC_TRANSFER_DELAY);\n\n}\n", "idx": 3727}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_socket(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    CharDriverState *chr = NULL;\n\n    TCPCharDriver *s = NULL;\n\n    int fd = -1;\n\n    int is_listen;\n\n    int is_waitconnect;\n\n    int do_nodelay;\n\n    int is_unix;\n\n    int is_telnet;\n\n    int ret;\n\n\n\n    is_listen      = qemu_opt_get_bool(opts, \"server\", 0);\n\n    is_waitconnect = qemu_opt_get_bool(opts, \"wait\", 1);\n\n    is_telnet      = qemu_opt_get_bool(opts, \"telnet\", 0);\n\n    do_nodelay     = !qemu_opt_get_bool(opts, \"delay\", 1);\n\n    is_unix        = qemu_opt_get(opts, \"path\") != NULL;\n\n    if (!is_listen)\n\n        is_waitconnect = 0;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(TCPCharDriver));\n\n\n\n    if (is_unix) {\n\n        if (is_listen) {\n\n            fd = unix_listen_opts(opts);\n\n        } else {\n\n            fd = unix_connect_opts(opts);\n\n        }\n\n    } else {\n\n        if (is_listen) {\n\n            fd = inet_listen_opts(opts, 0);\n\n        } else {\n\n            fd = inet_connect_opts(opts);\n\n        }\n\n    }\n\n    if (fd < 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n\n\n    if (!is_waitconnect)\n\n        socket_set_nonblock(fd);\n\n\n\n    s->connected = 0;\n\n    s->fd = -1;\n\n    s->listen_fd = -1;\n\n    s->msgfd = -1;\n\n    s->is_unix = is_unix;\n\n    s->do_nodelay = do_nodelay && !is_unix;\n\n\n\n    chr->opaque = s;\n\n    chr->chr_write = tcp_chr_write;\n\n    chr->chr_close = tcp_chr_close;\n\n    chr->get_msgfd = tcp_get_msgfd;\n\n    chr->chr_add_client = tcp_chr_add_client;\n\n\n\n    if (is_listen) {\n\n        s->listen_fd = fd;\n\n        qemu_set_fd_handler2(s->listen_fd, NULL, tcp_chr_accept, NULL, chr);\n\n        if (is_telnet)\n\n            s->do_telnetopt = 1;\n\n\n\n    } else {\n\n        s->connected = 1;\n\n        s->fd = fd;\n\n        socket_set_nodelay(fd);\n\n        tcp_chr_connect(chr);\n\n    }\n\n\n\n    /* for \"info chardev\" monitor command */\n\n    chr->filename = g_malloc(256);\n\n    if (is_unix) {\n\n        snprintf(chr->filename, 256, \"unix:%s%s\",\n\n                 qemu_opt_get(opts, \"path\"),\n\n                 qemu_opt_get_bool(opts, \"server\", 0) ? \",server\" : \"\");\n\n    } else if (is_telnet) {\n\n        snprintf(chr->filename, 256, \"telnet:%s:%s%s\",\n\n                 qemu_opt_get(opts, \"host\"), qemu_opt_get(opts, \"port\"),\n\n                 qemu_opt_get_bool(opts, \"server\", 0) ? \",server\" : \"\");\n\n    } else {\n\n        snprintf(chr->filename, 256, \"tcp:%s:%s%s\",\n\n                 qemu_opt_get(opts, \"host\"), qemu_opt_get(opts, \"port\"),\n\n                 qemu_opt_get_bool(opts, \"server\", 0) ? \",server\" : \"\");\n\n    }\n\n\n\n    if (is_listen && is_waitconnect) {\n\n        printf(\"QEMU waiting for connection on: %s\\n\",\n\n               chr->filename);\n\n        tcp_chr_accept(chr);\n\n        socket_set_nonblock(s->listen_fd);\n\n    }\n\n\n\n    *_chr = chr;\n\n    return 0;\n\n\n\n fail:\n\n    if (fd >= 0)\n\n        closesocket(fd);\n\n    g_free(s);\n\n    g_free(chr);\n\n    return ret;\n\n}\n", "idx": 10336}
{"project": "qemu", "commit_id": "6da67de6803e93cbb7e93ac3497865832f8c00ea", "target": 1, "func": "static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n\n                                                MemTxAttrs attrs,\n\n                                                const uint8_t *buf,\n\n                                                int len, hwaddr addr1,\n\n                                                hwaddr l, MemoryRegion *mr)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemTxResult result = MEMTX_OK;\n\n    bool release_lock = false;\n\n\n\n    for (;;) {\n\n        if (!memory_access_is_direct(mr, true)) {\n\n            release_lock |= prepare_mmio_access(mr);\n\n            l = memory_access_size(mr, l, addr1);\n\n            /* XXX: could force current_cpu to NULL to avoid\n\n               potential bugs */\n\n            switch (l) {\n\n            case 8:\n\n                /* 64 bit write access */\n\n                val = ldq_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 8,\n\n                                                       attrs);\n\n                break;\n\n            case 4:\n\n                /* 32 bit write access */\n\n                val = ldl_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 4,\n\n                                                       attrs);\n\n                break;\n\n            case 2:\n\n                /* 16 bit write access */\n\n                val = lduw_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 2,\n\n                                                       attrs);\n\n                break;\n\n            case 1:\n\n                /* 8 bit write access */\n\n                val = ldub_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 1,\n\n                                                       attrs);\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            /* RAM case */\n\n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n\n            memcpy(ptr, buf, l);\n\n            invalidate_and_set_dirty(mr, addr1, l);\n\n        }\n\n\n\n        if (release_lock) {\n\n            qemu_mutex_unlock_iothread();\n\n            release_lock = false;\n\n        }\n\n\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n\n\n        if (!len) {\n\n            break;\n\n        }\n\n\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 3420}
{"project": "qemu", "commit_id": "84961407a50bb02d34ab9cca7a21cdb4ff7c25fe", "target": 1, "func": "static void gd_set_keycode_type(GtkDisplayState *s)\n{\n#ifdef GDK_WINDOWING_X11\n    GdkDisplay *display = gtk_widget_get_display(s->window);\n    if (GDK_IS_X11_DISPLAY(display)) {\n        Display *x11_display = gdk_x11_display_get_xdisplay(display);\n        XkbDescPtr desc = XkbGetKeyboard(x11_display, XkbGBN_AllComponentsMask,\n                                         XkbUseCoreKbd);\n        char *keycodes = NULL;\n        if (desc && desc->names) {\n            keycodes = XGetAtomName(x11_display, desc->names->keycodes);\n        if (keycodes == NULL) {\n            fprintf(stderr, \"could not lookup keycode name\\n\");\n        } else if (strstart(keycodes, \"evdev\", NULL)) {\n            s->has_evdev = true;\n        } else if (!strstart(keycodes, \"xfree86\", NULL)) {\n            fprintf(stderr, \"unknown keycodes `%s', please report to \"\n                    \"qemu-devel@nongnu.org\\n\", keycodes);\n#endif", "idx": 6600}
{"project": "qemu", "commit_id": "66b9b43c42049bcae37668e890fedde9a72c8167", "target": 1, "func": "static uint64_t watch_mem_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, size, BP_MEM_READ);\n\n    switch (size) {\n\n    case 1: return ldub_phys(&address_space_memory, addr);\n\n    case 2: return lduw_phys(&address_space_memory, addr);\n\n    case 4: return ldl_phys(&address_space_memory, addr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 10246}
{"project": "qemu", "commit_id": "8bcbf37caa87ba89bc391bad70039f942a98c7e3", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n    switch (ri->accessfn(env, ri)) {\n\n    case CP_ACCESS_OK:\n\n        return;\n\n    case CP_ACCESS_TRAP:\n\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n\n        /* These cases will eventually need to generate different\n\n         * syndrome information.\n\n         */\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n    raise_exception(env, EXCP_UDEF);\n\n}\n", "idx": 9782}
{"project": "qemu", "commit_id": "7696414729b2d0f870c80ad1dd637d854bc78847", "target": 1, "func": "static void gen_ld(DisasContext *ctx, uint32_t opc,\n\n                   int rt, int base, int16_t offset)\n\n{\n\n    TCGv t0, t1, t2;\n\n    int mem_idx = ctx->mem_idx;\n\n\n\n    if (rt == 0 && ctx->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F)) {\n\n        /* Loongson CPU uses a load to zero register for prefetch.\n\n           We emulate it as a NOP. On other CPU we must perform the\n\n           actual memory access. */\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_LWU:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUL |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LD:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LLD:\n\n    case R6_OPC_LLD:\n\n        op_ld_lld(t0, t0, mem_idx, ctx);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LDL:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 7);\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 7);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~7);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ);\n\n        tcg_gen_shl_tl(t0, t0, t1);\n\n        t2 = tcg_const_tl(-1);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_andc_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LDR:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 7);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 7);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~7);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ);\n\n        tcg_gen_shr_tl(t0, t0, t1);\n\n        tcg_gen_xori_tl(t1, t1, 63);\n\n        t2 = tcg_const_tl(0xfffffffffffffffeull);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_and_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LDPC:\n\n        t1 = tcg_const_tl(pc_relative_pc(ctx));\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#endif\n\n    case OPC_LWPC:\n\n        t1 = tcg_const_tl(pc_relative_pc(ctx));\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TESL);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LWE:\n\n\n\n    case OPC_LW:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TESL |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LHE:\n\n\n\n    case OPC_LH:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TESW |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LHUE:\n\n\n\n    case OPC_LHU:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUW |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LBE:\n\n\n\n    case OPC_LB:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_SB);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LBUE:\n\n\n\n    case OPC_LBU:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_UB);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LWLE:\n\n\n\n    case OPC_LWL:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 3);\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 3);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~3);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUL);\n\n        tcg_gen_shl_tl(t0, t0, t1);\n\n        t2 = tcg_const_tl(-1);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_andc_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_ext32s_tl(t0, t0);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n\n\n\n    case OPC_LWR:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 3);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 3);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~3);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUL);\n\n        tcg_gen_shr_tl(t0, t0, t1);\n\n        tcg_gen_xori_tl(t1, t1, 31);\n\n        t2 = tcg_const_tl(0xfffffffeull);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_and_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_ext32s_tl(t0, t0);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LLE:\n\n\n\n    case OPC_LL:\n\n    case R6_OPC_LL:\n\n        op_ld_ll(t0, t0, mem_idx, ctx);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}", "idx": 5268}
{"project": "qemu", "commit_id": "c76f4952bbf47116255bc00780ceae3bc8a657c0", "target": 1, "func": "static BlockDriverAIOCB *curl_aio_readv(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVCURLState *s = bs->opaque;\n\n    CURLAIOCB *acb;\n\n    size_t start = sector_num * SECTOR_SIZE;\n\n    size_t end;\n\n    CURLState *state;\n\n\n\n    acb = qemu_aio_get(&curl_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n\n\n    acb->qiov = qiov;\n\n\n\n    // In case we have the requested data already (e.g. read-ahead),\n\n    // we can just call the callback and be done.\n\n\n\n    switch (curl_find_buf(s, start, nb_sectors * SECTOR_SIZE, acb)) {\n\n        case FIND_RET_OK:\n\n            qemu_aio_release(acb);\n\n            // fall through\n\n        case FIND_RET_WAIT:\n\n            return &acb->common;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    // No cache found, so let's start a new request\n\n\n\n    state = curl_init_state(s);\n\n    if (!state)\n\n        return NULL;\n\n\n\n    acb->start = 0;\n\n    acb->end = (nb_sectors * SECTOR_SIZE);\n\n\n\n    state->buf_off = 0;\n\n    if (state->orig_buf)\n\n        qemu_free(state->orig_buf);\n\n    state->buf_start = start;\n\n    state->buf_len = acb->end + READ_AHEAD_SIZE;\n\n    end = MIN(start + state->buf_len, s->len) - 1;\n\n    state->orig_buf = qemu_malloc(state->buf_len);\n\n    state->acb[0] = acb;\n\n\n\n    snprintf(state->range, 127, \"%lld-%lld\", (long long)start, (long long)end);\n\n    dprintf(\"CURL (AIO): Reading %d at %lld (%s)\\n\", (nb_sectors * SECTOR_SIZE), start, state->range);\n\n    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);\n\n\n\n    curl_multi_add_handle(s->multi, state->curl);\n\n    curl_multi_do(s);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 12113}
{"project": "qemu", "commit_id": "71b3c3dea21a310c5df7406cdc1cffc64cf14c18", "target": 1, "func": "static int disas_vfp_insn(CPUState * env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd, rn, rm, op, i, n, offset, delta_d, delta_m, bank_mask;\n\n    int dp, veclen;\n\n    TCGv addr;\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_VFP))\n\n        return 1;\n\n\n\n    if (!vfp_enabled(env)) {\n\n        /* VFP disabled.  Only allow fmxr/fmrx to/from some control regs.  */\n\n        if ((insn & 0x0fe00fff) != 0x0ee00a10)\n\n            return 1;\n\n        rn = (insn >> 16) & 0xf;\n\n        if (rn != ARM_VFP_FPSID && rn != ARM_VFP_FPEXC\n\n            && rn != ARM_VFP_MVFR1 && rn != ARM_VFP_MVFR0)\n\n            return 1;\n\n    }\n\n    dp = ((insn & 0xf00) == 0xb00);\n\n    switch ((insn >> 24) & 0xf) {\n\n    case 0xe:\n\n        if (insn & (1 << 4)) {\n\n            /* single register transfer */\n\n            rd = (insn >> 12) & 0xf;\n\n            if (dp) {\n\n                int size;\n\n                int pass;\n\n\n\n                VFP_DREG_N(rn, insn);\n\n                if (insn & 0xf)\n\n                    return 1;\n\n                if (insn & 0x00c00060\n\n                    && !arm_feature(env, ARM_FEATURE_NEON))\n\n                    return 1;\n\n\n\n                pass = (insn >> 21) & 1;\n\n                if (insn & (1 << 22)) {\n\n                    size = 0;\n\n                    offset = ((insn >> 5) & 3) * 8;\n\n                } else if (insn & (1 << 5)) {\n\n                    size = 1;\n\n                    offset = (insn & (1 << 6)) ? 16 : 0;\n\n                } else {\n\n                    size = 2;\n\n                    offset = 0;\n\n                }\n\n                if (insn & ARM_CP_RW_BIT) {\n\n                    /* vfp->arm */\n\n                    tmp = neon_load_reg(rn, pass);\n\n                    switch (size) {\n\n                    case 0:\n\n                        if (offset)\n\n                            tcg_gen_shri_i32(tmp, tmp, offset);\n\n                        if (insn & (1 << 23))\n\n                            gen_uxtb(tmp);\n\n                        else\n\n                            gen_sxtb(tmp);\n\n                        break;\n\n                    case 1:\n\n                        if (insn & (1 << 23)) {\n\n                            if (offset) {\n\n                                tcg_gen_shri_i32(tmp, tmp, 16);\n\n                            } else {\n\n                                gen_uxth(tmp);\n\n                            }\n\n                        } else {\n\n                            if (offset) {\n\n                                tcg_gen_sari_i32(tmp, tmp, 16);\n\n                            } else {\n\n                                gen_sxth(tmp);\n\n                            }\n\n                        }\n\n                        break;\n\n                    case 2:\n\n                        break;\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    /* arm->vfp */\n\n                    tmp = load_reg(s, rd);\n\n                    if (insn & (1 << 23)) {\n\n                        /* VDUP */\n\n                        if (size == 0) {\n\n                            gen_neon_dup_u8(tmp, 0);\n\n                        } else if (size == 1) {\n\n                            gen_neon_dup_low16(tmp);\n\n                        }\n\n                        for (n = 0; n <= pass * 2; n++) {\n\n                            tmp2 = new_tmp();\n\n                            tcg_gen_mov_i32(tmp2, tmp);\n\n                            neon_store_reg(rn, n, tmp2);\n\n                        }\n\n                        neon_store_reg(rn, n, tmp);\n\n                    } else {\n\n                        /* VMOV */\n\n                        switch (size) {\n\n                        case 0:\n\n                            tmp2 = neon_load_reg(rn, pass);\n\n                            gen_bfi(tmp, tmp2, tmp, offset, 0xff);\n\n                            dead_tmp(tmp2);\n\n                            break;\n\n                        case 1:\n\n                            tmp2 = neon_load_reg(rn, pass);\n\n                            gen_bfi(tmp, tmp2, tmp, offset, 0xffff);\n\n                            dead_tmp(tmp2);\n\n                            break;\n\n                        case 2:\n\n                            break;\n\n                        }\n\n                        neon_store_reg(rn, pass, tmp);\n\n                    }\n\n                }\n\n            } else { /* !dp */\n\n                if ((insn & 0x6f) != 0x00)\n\n                    return 1;\n\n                rn = VFP_SREG_N(insn);\n\n                if (insn & ARM_CP_RW_BIT) {\n\n                    /* vfp->arm */\n\n                    if (insn & (1 << 21)) {\n\n                        /* system register */\n\n                        rn >>= 1;\n\n\n\n                        switch (rn) {\n\n                        case ARM_VFP_FPSID:\n\n                            /* VFP2 allows access to FSID from userspace.\n\n                               VFP3 restricts all id registers to privileged\n\n                               accesses.  */\n\n                            if (IS_USER(s)\n\n                                && arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPEXC:\n\n                            if (IS_USER(s))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPINST:\n\n                        case ARM_VFP_FPINST2:\n\n                            /* Not present in VFP3.  */\n\n                            if (IS_USER(s)\n\n                                || arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPSCR:\n\n                            if (rd == 15) {\n\n                                tmp = load_cpu_field(vfp.xregs[ARM_VFP_FPSCR]);\n\n                                tcg_gen_andi_i32(tmp, tmp, 0xf0000000);\n\n                            } else {\n\n                                tmp = new_tmp();\n\n                                gen_helper_vfp_get_fpscr(tmp, cpu_env);\n\n                            }\n\n                            break;\n\n                        case ARM_VFP_MVFR0:\n\n                        case ARM_VFP_MVFR1:\n\n                            if (IS_USER(s)\n\n                                || !arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        default:\n\n                            return 1;\n\n                        }\n\n                    } else {\n\n                        gen_mov_F0_vreg(0, rn);\n\n                        tmp = gen_vfp_mrs();\n\n                    }\n\n                    if (rd == 15) {\n\n                        /* Set the 4 flag bits in the CPSR.  */\n\n                        gen_set_nzcv(tmp);\n\n                        dead_tmp(tmp);\n\n                    } else {\n\n                        store_reg(s, rd, tmp);\n\n                    }\n\n                } else {\n\n                    /* arm->vfp */\n\n                    tmp = load_reg(s, rd);\n\n                    if (insn & (1 << 21)) {\n\n                        rn >>= 1;\n\n                        /* system register */\n\n                        switch (rn) {\n\n                        case ARM_VFP_FPSID:\n\n                        case ARM_VFP_MVFR0:\n\n                        case ARM_VFP_MVFR1:\n\n                            /* Writes are ignored.  */\n\n                            break;\n\n                        case ARM_VFP_FPSCR:\n\n                            gen_helper_vfp_set_fpscr(cpu_env, tmp);\n\n                            dead_tmp(tmp);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        case ARM_VFP_FPEXC:\n\n                            if (IS_USER(s))\n\n                                return 1;\n\n\n\n\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        case ARM_VFP_FPINST:\n\n                        case ARM_VFP_FPINST2:\n\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n\n                            break;\n\n                        default:\n\n                            return 1;\n\n                        }\n\n                    } else {\n\n                        gen_vfp_msr(tmp);\n\n                        gen_mov_vreg_F0(0, rn);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            /* data processing */\n\n            /* The opcode is in bits 23, 21, 20 and 6.  */\n\n            op = ((insn >> 20) & 8) | ((insn >> 19) & 6) | ((insn >> 6) & 1);\n\n            if (dp) {\n\n                if (op == 15) {\n\n                    /* rn is opcode */\n\n                    rn = ((insn >> 15) & 0x1e) | ((insn >> 7) & 1);\n\n                } else {\n\n                    /* rn is register number */\n\n                    VFP_DREG_N(rn, insn);\n\n                }\n\n\n\n                if (op == 15 && (rn == 15 || rn > 17)) {\n\n                    /* Integer or single precision destination.  */\n\n                    rd = VFP_SREG_D(insn);\n\n                } else {\n\n                    VFP_DREG_D(rd, insn);\n\n                }\n\n\n\n                if (op == 15 && (rn == 16 || rn == 17)) {\n\n                    /* Integer source.  */\n\n                    rm = ((insn << 1) & 0x1e) | ((insn >> 5) & 1);\n\n                } else {\n\n                    VFP_DREG_M(rm, insn);\n\n                }\n\n            } else {\n\n                rn = VFP_SREG_N(insn);\n\n                if (op == 15 && rn == 15) {\n\n                    /* Double precision destination.  */\n\n                    VFP_DREG_D(rd, insn);\n\n                } else {\n\n                    rd = VFP_SREG_D(insn);\n\n                }\n\n                rm = VFP_SREG_M(insn);\n\n            }\n\n\n\n            veclen = env->vfp.vec_len;\n\n            if (op == 15 && rn > 3)\n\n                veclen = 0;\n\n\n\n            /* Shut up compiler warnings.  */\n\n            delta_m = 0;\n\n            delta_d = 0;\n\n            bank_mask = 0;\n\n\n\n            if (veclen > 0) {\n\n                if (dp)\n\n                    bank_mask = 0xc;\n\n                else\n\n                    bank_mask = 0x18;\n\n\n\n                /* Figure out what type of vector operation this is.  */\n\n                if ((rd & bank_mask) == 0) {\n\n                    /* scalar */\n\n                    veclen = 0;\n\n                } else {\n\n                    if (dp)\n\n                        delta_d = (env->vfp.vec_stride >> 1) + 1;\n\n                    else\n\n                        delta_d = env->vfp.vec_stride + 1;\n\n\n\n                    if ((rm & bank_mask) == 0) {\n\n                        /* mixed scalar/vector */\n\n                        delta_m = 0;\n\n                    } else {\n\n                        /* vector */\n\n                        delta_m = delta_d;\n\n                    }\n\n                }\n\n            }\n\n\n\n            /* Load the initial operands.  */\n\n            if (op == 15) {\n\n                switch (rn) {\n\n                case 16:\n\n                case 17:\n\n                    /* Integer source */\n\n                    gen_mov_F0_vreg(0, rm);\n\n                    break;\n\n                case 8:\n\n                case 9:\n\n                    /* Compare */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_mov_F1_vreg(dp, rm);\n\n                    break;\n\n                case 10:\n\n                case 11:\n\n                    /* Compare with zero */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_F1_ld0(dp);\n\n                    break;\n\n                case 20:\n\n                case 21:\n\n                case 22:\n\n                case 23:\n\n                case 28:\n\n                case 29:\n\n                case 30:\n\n                case 31:\n\n                    /* Source and destination the same.  */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    break;\n\n                default:\n\n                    /* One source operand.  */\n\n                    gen_mov_F0_vreg(dp, rm);\n\n                    break;\n\n                }\n\n            } else {\n\n                /* Two source operands.  */\n\n                gen_mov_F0_vreg(dp, rn);\n\n                gen_mov_F1_vreg(dp, rm);\n\n            }\n\n\n\n            for (;;) {\n\n                /* Perform the calculation.  */\n\n                switch (op) {\n\n                case 0: /* mac: fd + (fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 1: /* nmac: fd - (fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_neg(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 2: /* msc: -fd + (fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_sub(dp);\n\n                    break;\n\n                case 3: /* nmsc: -fd - (fn * fm)  */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_neg(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_sub(dp);\n\n                    break;\n\n                case 4: /* mul: fn * fm */\n\n                    gen_vfp_mul(dp);\n\n                    break;\n\n                case 5: /* nmul: -(fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_neg(dp);\n\n                    break;\n\n                case 6: /* add: fn + fm */\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 7: /* sub: fn - fm */\n\n                    gen_vfp_sub(dp);\n\n                    break;\n\n                case 8: /* div: fn / fm */\n\n                    gen_vfp_div(dp);\n\n                    break;\n\n                case 14: /* fconst */\n\n                    if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                      return 1;\n\n\n\n                    n = (insn << 12) & 0x80000000;\n\n                    i = ((insn >> 12) & 0x70) | (insn & 0xf);\n\n                    if (dp) {\n\n                        if (i & 0x40)\n\n                            i |= 0x3f80;\n\n                        else\n\n                            i |= 0x4000;\n\n                        n |= i << 16;\n\n                        tcg_gen_movi_i64(cpu_F0d, ((uint64_t)n) << 32);\n\n                    } else {\n\n                        if (i & 0x40)\n\n                            i |= 0x780;\n\n                        else\n\n                            i |= 0x800;\n\n                        n |= i << 19;\n\n                        tcg_gen_movi_i32(cpu_F0s, n);\n\n                    }\n\n                    break;\n\n                case 15: /* extension space */\n\n                    switch (rn) {\n\n                    case 0: /* cpy */\n\n                        /* no-op */\n\n                        break;\n\n                    case 1: /* abs */\n\n                        gen_vfp_abs(dp);\n\n                        break;\n\n                    case 2: /* neg */\n\n                        gen_vfp_neg(dp);\n\n                        break;\n\n                    case 3: /* sqrt */\n\n                        gen_vfp_sqrt(dp);\n\n                        break;\n\n                    case 8: /* cmp */\n\n                        gen_vfp_cmp(dp);\n\n                        break;\n\n                    case 9: /* cmpe */\n\n                        gen_vfp_cmpe(dp);\n\n                        break;\n\n                    case 10: /* cmpz */\n\n                        gen_vfp_cmp(dp);\n\n                        break;\n\n                    case 11: /* cmpez */\n\n                        gen_vfp_F1_ld0(dp);\n\n                        gen_vfp_cmpe(dp);\n\n                        break;\n\n                    case 15: /* single<->double conversion */\n\n                        if (dp)\n\n                            gen_helper_vfp_fcvtsd(cpu_F0s, cpu_F0d, cpu_env);\n\n                        else\n\n                            gen_helper_vfp_fcvtds(cpu_F0d, cpu_F0s, cpu_env);\n\n                        break;\n\n                    case 16: /* fuito */\n\n                        gen_vfp_uito(dp);\n\n                        break;\n\n                    case 17: /* fsito */\n\n                        gen_vfp_sito(dp);\n\n                        break;\n\n                    case 20: /* fshto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_shto(dp, 16 - rm);\n\n                        break;\n\n                    case 21: /* fslto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_slto(dp, 32 - rm);\n\n                        break;\n\n                    case 22: /* fuhto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_uhto(dp, 16 - rm);\n\n                        break;\n\n                    case 23: /* fulto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_ulto(dp, 32 - rm);\n\n                        break;\n\n                    case 24: /* ftoui */\n\n                        gen_vfp_toui(dp);\n\n                        break;\n\n                    case 25: /* ftouiz */\n\n                        gen_vfp_touiz(dp);\n\n                        break;\n\n                    case 26: /* ftosi */\n\n                        gen_vfp_tosi(dp);\n\n                        break;\n\n                    case 27: /* ftosiz */\n\n                        gen_vfp_tosiz(dp);\n\n                        break;\n\n                    case 28: /* ftosh */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_tosh(dp, 16 - rm);\n\n                        break;\n\n                    case 29: /* ftosl */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_tosl(dp, 32 - rm);\n\n                        break;\n\n                    case 30: /* ftouh */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_touh(dp, 16 - rm);\n\n                        break;\n\n                    case 31: /* ftoul */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_toul(dp, 32 - rm);\n\n                        break;\n\n                    default: /* undefined */\n\n                        printf (\"rn:%d\\n\", rn);\n\n                        return 1;\n\n                    }\n\n                    break;\n\n                default: /* undefined */\n\n                    printf (\"op:%d\\n\", op);\n\n                    return 1;\n\n                }\n\n\n\n                /* Write back the result.  */\n\n                if (op == 15 && (rn >= 8 && rn <= 11))\n\n                    ; /* Comparison, do nothing.  */\n\n                else if (op == 15 && rn > 17)\n\n                    /* Integer result.  */\n\n                    gen_mov_vreg_F0(0, rd);\n\n                else if (op == 15 && rn == 15)\n\n                    /* conversion */\n\n                    gen_mov_vreg_F0(!dp, rd);\n\n                else\n\n                    gen_mov_vreg_F0(dp, rd);\n\n\n\n                /* break out of the loop if we have finished  */\n\n                if (veclen == 0)\n\n                    break;\n\n\n\n                if (op == 15 && delta_m == 0) {\n\n                    /* single source one-many */\n\n                    while (veclen--) {\n\n                        rd = ((rd + delta_d) & (bank_mask - 1))\n\n                             | (rd & bank_mask);\n\n                        gen_mov_vreg_F0(dp, rd);\n\n                    }\n\n                    break;\n\n                }\n\n                /* Setup the next operands.  */\n\n                veclen--;\n\n                rd = ((rd + delta_d) & (bank_mask - 1))\n\n                     | (rd & bank_mask);\n\n\n\n                if (op == 15) {\n\n                    /* One source operand.  */\n\n                    rm = ((rm + delta_m) & (bank_mask - 1))\n\n                         | (rm & bank_mask);\n\n                    gen_mov_F0_vreg(dp, rm);\n\n                } else {\n\n                    /* Two source operands.  */\n\n                    rn = ((rn + delta_d) & (bank_mask - 1))\n\n                         | (rn & bank_mask);\n\n                    gen_mov_F0_vreg(dp, rn);\n\n                    if (delta_m) {\n\n                        rm = ((rm + delta_m) & (bank_mask - 1))\n\n                             | (rm & bank_mask);\n\n                        gen_mov_F1_vreg(dp, rm);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 0xc:\n\n    case 0xd:\n\n        if (dp && (insn & 0x03e00000) == 0x00400000) {\n\n            /* two-register transfer */\n\n            rn = (insn >> 16) & 0xf;\n\n            rd = (insn >> 12) & 0xf;\n\n            if (dp) {\n\n                VFP_DREG_M(rm, insn);\n\n            } else {\n\n                rm = VFP_SREG_M(insn);\n\n            }\n\n\n\n            if (insn & ARM_CP_RW_BIT) {\n\n                /* vfp->arm */\n\n                if (dp) {\n\n                    gen_mov_F0_vreg(0, rm * 2);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rd, tmp);\n\n                    gen_mov_F0_vreg(0, rm * 2 + 1);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rn, tmp);\n\n                } else {\n\n                    gen_mov_F0_vreg(0, rm);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rn, tmp);\n\n                    gen_mov_F0_vreg(0, rm + 1);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rd, tmp);\n\n                }\n\n            } else {\n\n                /* arm->vfp */\n\n                if (dp) {\n\n                    tmp = load_reg(s, rd);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm * 2);\n\n                    tmp = load_reg(s, rn);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm * 2 + 1);\n\n                } else {\n\n                    tmp = load_reg(s, rn);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm);\n\n                    tmp = load_reg(s, rd);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm + 1);\n\n                }\n\n            }\n\n        } else {\n\n            /* Load/store */\n\n            rn = (insn >> 16) & 0xf;\n\n            if (dp)\n\n                VFP_DREG_D(rd, insn);\n\n            else\n\n                rd = VFP_SREG_D(insn);\n\n            if (s->thumb && rn == 15) {\n\n                addr = new_tmp();\n\n                tcg_gen_movi_i32(addr, s->pc & ~2);\n\n            } else {\n\n                addr = load_reg(s, rn);\n\n            }\n\n            if ((insn & 0x01200000) == 0x01000000) {\n\n                /* Single load/store */\n\n                offset = (insn & 0xff) << 2;\n\n                if ((insn & (1 << 23)) == 0)\n\n                    offset = -offset;\n\n                tcg_gen_addi_i32(addr, addr, offset);\n\n                if (insn & (1 << 20)) {\n\n                    gen_vfp_ld(s, dp, addr);\n\n                    gen_mov_vreg_F0(dp, rd);\n\n                } else {\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_st(s, dp, addr);\n\n                }\n\n                dead_tmp(addr);\n\n            } else {\n\n                /* load/store multiple */\n\n                if (dp)\n\n                    n = (insn >> 1) & 0x7f;\n\n                else\n\n                    n = insn & 0xff;\n\n\n\n                if (insn & (1 << 24)) /* pre-decrement */\n\n                    tcg_gen_addi_i32(addr, addr, -((insn & 0xff) << 2));\n\n\n\n                if (dp)\n\n                    offset = 8;\n\n                else\n\n                    offset = 4;\n\n                for (i = 0; i < n; i++) {\n\n                    if (insn & ARM_CP_RW_BIT) {\n\n                        /* load */\n\n                        gen_vfp_ld(s, dp, addr);\n\n                        gen_mov_vreg_F0(dp, rd + i);\n\n                    } else {\n\n                        /* store */\n\n                        gen_mov_F0_vreg(dp, rd + i);\n\n                        gen_vfp_st(s, dp, addr);\n\n                    }\n\n                    tcg_gen_addi_i32(addr, addr, offset);\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* writeback */\n\n                    if (insn & (1 << 24))\n\n                        offset = -offset * n;\n\n                    else if (dp && (insn & 1))\n\n                        offset = 4;\n\n                    else\n\n                        offset = 0;\n\n\n\n                    if (offset != 0)\n\n                        tcg_gen_addi_i32(addr, addr, offset);\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    dead_tmp(addr);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen.  */\n\n        return 1;\n\n    }\n\n    return 0;\n\n}", "idx": 3927}
{"project": "qemu", "commit_id": "0e2fa9cab9c124788077de728f1e6744d1dd8bb2", "target": 1, "func": "void helper_ldf_asi(target_ulong addr, int asi, int size, int rd)\n{\n    unsigned int i;\n    target_ulong val;\n    helper_check_align(addr, 3);\n    addr = asi_address_mask(env, asi, addr);\n    switch (asi) {\n    case 0xf0: // Block load primary\n    case 0xf1: // Block load secondary\n    case 0xf8: // Block load primary LE\n    case 0xf9: // Block load secondary LE\n            *(uint32_t *)&env->fpr[rd++] = helper_ld_asi(addr, asi & 0x8f, 4,\n    default:\n        break;\n    val = helper_ld_asi(addr, asi, size, 0);\n    switch(size) {\n    default:\n    case 4:\n        *((uint32_t *)&env->fpr[rd]) = val;\n        break;\n    case 8:\n        *((int64_t *)&DT0) = val;\n        break;\n    case 16:\n        // XXX\n        break;", "idx": 9185}
{"project": "qemu", "commit_id": "31ca6d077c24b7aaa322d8930e3e5debbdb4a047", "target": 1, "func": "static void mirror_complete(BlockJob *job, Error **errp)\n\n{\n\n    MirrorBlockJob *s = container_of(job, MirrorBlockJob, common);\n\n    int ret;\n\n\n\n    ret = bdrv_open_backing_file(s->target);\n\n    if (ret < 0) {\n\n        char backing_filename[PATH_MAX];\n\n        bdrv_get_full_backing_filename(s->target, backing_filename,\n\n                                       sizeof(backing_filename));\n\n        error_set(errp, QERR_OPEN_FILE_FAILED, backing_filename);\n\n        return;\n\n    }\n\n    if (!s->synced) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_READY, job->bs->device_name);\n\n        return;\n\n    }\n\n\n\n    s->should_complete = true;\n\n    block_job_resume(job);\n\n}\n", "idx": 1285}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file(HANDLE fd_out, CharDriverState **pchr)\n\n{\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    s->hcom = fd_out;\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    qemu_chr_generic_open(chr);\n\n    *pchr = chr;\n\n    return 0;\n\n}\n", "idx": 9830}
{"project": "qemu", "commit_id": "6e13610aa454beba52944e8df6d93158d68ab911", "target": 1, "func": "static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                              int64_t pos)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t total_sectors = bs->total_sectors;\n\n    int growable = bs->growable;\n\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);\n\n    bs->growable = 1;\n\n\n    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);\n\n    bs->growable = growable;\n\n\n\n\n    /* bdrv_co_do_writev will have increased the total_sectors value to include\n\n     * the VM state - the VM state is however not an actual part of the block\n\n     * device, therefore, we need to restore the old value. */\n\n    bs->total_sectors = total_sectors;\n\n\n\n    return ret;\n\n}", "idx": 12200}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int64_t get_remaining_dirty(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n    int64_t dirty = 0;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        dirty += bdrv_get_dirty_count(bmds->bs, bmds->dirty_bitmap);\n\n    }\n\n\n\n    return dirty << BDRV_SECTOR_BITS;\n\n}\n", "idx": 9089}
{"project": "qemu", "commit_id": "7843c0d60db694b6d97e14ec5538fb97424016c1", "target": 1, "func": "static void powerpc_set_compat(Object *obj, Visitor *v, const char *name,\n\n                               void *opaque, Error **errp)\n\n{\n\n    Error *error = NULL;\n\n    char *value = NULL;\n\n    Property *prop = opaque;\n\n    uint32_t *max_compat = qdev_get_prop_ptr(DEVICE(obj), prop);\n\n\n\n    visit_type_str(v, name, &value, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n\n\n    if (strcmp(value, \"power6\") == 0) {\n\n        *max_compat = CPU_POWERPC_LOGICAL_2_05;\n\n    } else if (strcmp(value, \"power7\") == 0) {\n\n        *max_compat = CPU_POWERPC_LOGICAL_2_06;\n\n    } else if (strcmp(value, \"power8\") == 0) {\n\n        *max_compat = CPU_POWERPC_LOGICAL_2_07;\n\n    } else {\n\n        error_setg(errp, \"Invalid compatibility mode \\\"%s\\\"\", value);\n\n    }\n\n\n\n    g_free(value);\n\n}\n", "idx": 7791}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "I2CBus *aux_get_i2c_bus(AUXBus *bus)\n\n{\n\n    return aux_bridge_get_i2c_bus(bus->bridge);\n\n}\n", "idx": 6410}
{"project": "qemu", "commit_id": "326b9e98a391d542cc33c4c91782ff4ba51edfc5", "target": 1, "func": "float32 float32_scalbn( float32 a, int n STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp;\n\n    uint32_t aSig;\n\n\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n\n\n    if ( aExp == 0xFF ) {\n\n        return a;\n\n    }\n\n    if ( aExp != 0 )\n\n        aSig |= 0x00800000;\n\n    else if ( aSig == 0 )\n\n        return a;\n\n\n\n    aExp += n - 1;\n\n    aSig <<= 7;\n\n    return normalizeRoundAndPackFloat32( aSign, aExp, aSig STATUS_VAR );\n\n}\n", "idx": 5484}
{"project": "qemu", "commit_id": "f2d089425d43735b5369f70f3a36b712440578e5", "target": 1, "func": "static MemTxResult memory_region_oldmmio_read_accessor(MemoryRegion *mr,\n\n                                                       hwaddr addr,\n\n                                                       uint64_t *value,\n\n                                                       unsigned size,\n\n                                                       unsigned shift,\n\n                                                       uint64_t mask,\n\n                                                       MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = mr->ops->old_mmio.read[ctz32(size)](mr->opaque, addr);\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    *value |= (tmp & mask) << shift;\n\n    return MEMTX_OK;\n\n}", "idx": 8432}
{"project": "qemu", "commit_id": "93b91c59dbccde6e4d25661150c1529bd5ee4a06", "target": 1, "func": "QObject *qmp_dispatch(QObject *request)\n\n{\n\n    Error *err = NULL;\n\n    QObject *ret;\n\n    QDict *rsp;\n\n\n\n    ret = do_qmp_dispatch(request, &err);\n\n\n\n    rsp = qdict_new();\n\n    if (err) {\n\n        qdict_put_obj(rsp, \"error\", error_get_qobject(err));\n\n        error_free(err);\n\n    } else if (ret) {\n\n        qdict_put_obj(rsp, \"return\", ret);\n\n    } else {\n\n        QDECREF(rsp);\n\n        return NULL;\n\n    }\n\n\n\n    return QOBJECT(rsp);\n\n}\n", "idx": 2655}
{"project": "qemu", "commit_id": "b5d3b039221f056befb3715471fee1f68214815c", "target": 1, "func": "uint64_t pc_dimm_get_free_addr(uint64_t address_space_start,\n\n                               uint64_t address_space_size,\n\n                               uint64_t *hint, uint64_t align, uint64_t size,\n\n                               Error **errp)\n\n{\n\n    GSList *list = NULL, *item;\n\n    uint64_t new_addr, ret = 0;\n\n    uint64_t address_space_end = address_space_start + address_space_size;\n\n\n\n    g_assert(QEMU_ALIGN_UP(address_space_start, align) == address_space_start);\n\n    g_assert(QEMU_ALIGN_UP(address_space_size, align) == address_space_size);\n\n\n\n    if (!address_space_size) {\n\n        error_setg(errp, \"memory hotplug is not enabled, \"\n\n                         \"please add maxmem option\");\n\n        goto out;\n\n    }\n\n\n\n    if (hint && QEMU_ALIGN_UP(*hint, align) != *hint) {\n\n        error_setg(errp, \"address must be aligned to 0x%\" PRIx64 \" bytes\",\n\n                   align);\n\n        goto out;\n\n    }\n\n\n\n    if (QEMU_ALIGN_UP(size, align) != size) {\n\n        error_setg(errp, \"backend memory size must be multiple of 0x%\"\n\n                   PRIx64, align);\n\n        goto out;\n\n    }\n\n\n\n    assert(address_space_end > address_space_start);\n\n    object_child_foreach(qdev_get_machine(), pc_dimm_built_list, &list);\n\n\n\n    if (hint) {\n\n        new_addr = *hint;\n\n    } else {\n\n        new_addr = address_space_start;\n\n    }\n\n\n\n    /* find address range that will fit new DIMM */\n\n    for (item = list; item; item = g_slist_next(item)) {\n\n        PCDIMMDevice *dimm = item->data;\n\n        uint64_t dimm_size = object_property_get_int(OBJECT(dimm),\n\n                                                     PC_DIMM_SIZE_PROP,\n\n                                                     errp);\n\n        if (errp && *errp) {\n\n            goto out;\n\n        }\n\n\n\n        if (ranges_overlap(dimm->addr, dimm_size, new_addr, size)) {\n\n            if (hint) {\n\n                DeviceState *d = DEVICE(dimm);\n\n                error_setg(errp, \"address range conflicts with '%s'\", d->id);\n\n                goto out;\n\n            }\n\n            new_addr = QEMU_ALIGN_UP(dimm->addr + dimm_size, align);\n\n        }\n\n    }\n\n    ret = new_addr;\n\n\n\n    if (new_addr < address_space_start) {\n\n        error_setg(errp, \"can't add memory [0x%\" PRIx64 \":0x%\" PRIx64\n\n                   \"] at 0x%\" PRIx64, new_addr, size, address_space_start);\n\n    } else if ((new_addr + size) > address_space_end) {\n\n        error_setg(errp, \"can't add memory [0x%\" PRIx64 \":0x%\" PRIx64\n\n                   \"] beyond 0x%\" PRIx64, new_addr, size, address_space_end);\n\n    }\n\n\n\nout:\n\n    g_slist_free(list);\n\n    return ret;\n\n}\n", "idx": 3303}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "ssize_t vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_read_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = qemu_recv(vs->csock, data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Read wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n", "idx": 4415}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static void io_write(IPackDevice *ip, uint8_t addr, uint16_t val)\n\n{\n\n    IPOctalState *dev = IPOCTAL(ip);\n\n    unsigned reg = val & 0xFF;\n\n    /* addr[7:6]: block   (A-D)\n\n       addr[7:5]: channel (a-h)\n\n       addr[5:0]: register */\n\n    unsigned block = addr >> 5;\n\n    unsigned channel = addr >> 4;\n\n    /* Big endian, accessed using 8-bit bytes at odd locations */\n\n    unsigned offset = (addr & 0x1F) ^ 1;\n\n    SCC2698Channel *ch = &dev->ch[channel];\n\n    SCC2698Block *blk = &dev->blk[block];\n\n    uint8_t old_isr = blk->isr;\n\n    uint8_t old_imr = blk->imr;\n\n\n\n    switch (offset) {\n\n\n\n    case REG_MRa:\n\n    case REG_MRb:\n\n        ch->mr[ch->mr_idx] = reg;\n\n        DPRINTF(\"Write MR%u%c 0x%x\\n\", ch->mr_idx + 1, channel + 'a', reg);\n\n        ch->mr_idx = 1;\n\n        break;\n\n\n\n    /* Not implemented */\n\n    case REG_CSRa:\n\n    case REG_CSRb:\n\n        DPRINTF(\"Write CSR%c: 0x%x\\n\", channel + 'a', reg);\n\n        break;\n\n\n\n    case REG_CRa:\n\n    case REG_CRb:\n\n        write_cr(dev, channel, reg);\n\n        break;\n\n\n\n    case REG_THRa:\n\n    case REG_THRb:\n\n        if (ch->sr & SR_TXRDY) {\n\n            DPRINTF(\"Write THR%c (0x%x)\\n\", channel + 'a', reg);\n\n            if (ch->dev) {\n\n                uint8_t thr = reg;\n\n                qemu_chr_fe_write(ch->dev, &thr, 1);\n\n            }\n\n        } else {\n\n            DPRINTF(\"Write THR%c (0x%x), Tx disabled\\n\", channel + 'a', reg);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented */\n\n    case REG_ACR:\n\n        DPRINTF(\"Write ACR%c 0x%x\\n\", block + 'A', val);\n\n        break;\n\n\n\n    case REG_IMR:\n\n        DPRINTF(\"Write IMR%c 0x%x\\n\", block + 'A', val);\n\n        blk->imr = reg;\n\n        break;\n\n\n\n    /* Not implemented */\n\n    case REG_OPCR:\n\n        DPRINTF(\"Write OPCR%c 0x%x\\n\", block + 'A', val);\n\n        break;\n\n\n\n    default:\n\n        DPRINTF(\"Write unknown/unsupported register 0x%02x %u\\n\", offset, val);\n\n    }\n\n\n\n    if (old_isr != blk->isr || old_imr != blk->imr) {\n\n        update_irq(dev, block);\n\n    }\n\n}\n", "idx": 11666}
{"project": "qemu", "commit_id": "6a5b69a959483c7404576a7dc54221ced41e6515", "target": 1, "func": "static target_ulong helper_sdiv_common(CPUSPARCState *env, target_ulong a,\n\n                                       target_ulong b, int cc)\n\n{\n\n    SPARCCPU *cpu = sparc_env_get_cpu(env);\n\n    int overflow = 0;\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        cpu_restore_state(CPU(cpu), GETPC());\n\n        helper_raise_exception(env, TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        x0 = x0 < 0 ? 0x80000000 : 0x7fffffff;\n\n        overflow = 1;\n\n    }\n\n\n\n    if (cc) {\n\n        env->cc_dst = x0;\n\n        env->cc_src2 = overflow;\n\n        env->cc_op = CC_OP_DIV;\n\n    }\n\n    return x0;\n\n}\n", "idx": 9933}
{"project": "qemu", "commit_id": "e1f2641b5926d20f63d36f0de45206be774da8da", "target": 1, "func": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        assert(mon->outbuf_index < sizeof(mon->outbuf) - 1);\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n')\n\n            mon->outbuf[mon->outbuf_index++] = '\\r';\n\n        mon->outbuf[mon->outbuf_index++] = c;\n\n        if (mon->outbuf_index >= (sizeof(mon->outbuf) - 1)\n\n            || c == '\\n')\n\n            monitor_flush(mon);\n\n    }\n\n}\n", "idx": 5235}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static int coroutine_enter_func(void *arg)\n\n{\n\n    Coroutine *co = arg;\n\n    qemu_coroutine_enter(co, NULL);\n\n    return 0;\n\n}\n", "idx": 6455}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop_cell(void *fdt, const char *node_path,\n\n                              const char *property, uint32_t val)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_cell(fdt, offset, property, val);\n\n}\n", "idx": 3007}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void set_bmc_global_enables(IPMIBmcSim *ibs,\n\n                                   uint8_t *cmd, unsigned int cmd_len,\n\n                                   uint8_t *rsp, unsigned int *rsp_len,\n\n                                   unsigned int max_rsp_len)\n\n{\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    set_global_enables(ibs, cmd[2]);\n\n}\n", "idx": 9410}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_optional(Visitor *v, bool *present, const char *name,\n\n                    Error **errp)\n\n{\n\n    if (!error_is_set(errp) && v->optional) {\n\n        v->optional(v, present, name, errp);\n\n    }\n\n}\n", "idx": 9583}
{"project": "qemu", "commit_id": "b181e04777da67acbc7448f87e4ae9f1518e08b2", "target": 1, "func": "static CharDriverState *qemu_chr_open_pp(QemuOpts *opts)\n\n{\n\n    const char *filename = qemu_opt_get(opts, \"path\");\n\n    CharDriverState *chr;\n\n    int fd;\n\n\n\n    fd = open(filename, O_RDWR);\n\n    if (fd < 0)\n\n        return NULL;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    chr->opaque = (void *)(intptr_t)fd;\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    return chr;\n\n}\n", "idx": 2380}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void r2d_init(ram_addr_t ram_size,\n\n              const char *boot_device,\n\n\t      const char *kernel_filename, const char *kernel_cmdline,\n\n\t      const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    struct SH7750State *s;\n\n    ram_addr_t sdram_addr;\n\n    qemu_irq *irq;\n\n    PCIBus *pci;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"SH7751R\";\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Allocate memory space */\n\n    sdram_addr = qemu_ram_alloc(SDRAM_SIZE);\n\n    cpu_register_physical_memory(SDRAM_BASE, SDRAM_SIZE, sdram_addr);\n\n    /* Register peripherals */\n\n    s = sh7750_init(env);\n\n    irq = r2d_fpga_init(0x04000000, sh7750_irl(s));\n\n    pci = sh_pci_register_bus(r2d_pci_set_irq, r2d_pci_map_irq, irq, 0, 4);\n\n\n\n    sm501_init(0x10000000, SM501_VRAM_SIZE, irq[SM501], serial_hds[2]);\n\n\n\n    /* onboard CF (True IDE mode, Master only). */\n\n    if ((dinfo = drive_get(IF_IDE, 0, 0)) != NULL)\n\n\tmmio_ide_init(0x14001000, 0x1400080c, irq[CF_IDE], 1,\n\n\t\t      dinfo, NULL);\n\n\n\n    /* NIC: rtl8139 on-board, and 2 slots. */\n\n    for (i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"rtl8139\", i==0 ? \"2\" : NULL);\n\n\n\n    /* Todo: register on board registers */\n\n    if (kernel_filename) {\n\n      int kernel_size;\n\n      /* initialization which should be done by firmware */\n\n      stl_phys(SH7750_BCR1, 1<<3); /* cs3 SDRAM */\n\n      stw_phys(SH7750_BCR2, 3<<(3*2)); /* cs3 32bit */\n\n\n\n      if (kernel_cmdline) {\n\n          kernel_size = load_image_targphys(kernel_filename,\n\n\t\t\t\t   SDRAM_BASE + LINUX_LOAD_OFFSET,\n\n\t\t\t\t   SDRAM_SIZE - LINUX_LOAD_OFFSET);\n\n          env->pc = (SDRAM_BASE + LINUX_LOAD_OFFSET) | 0xa0000000;\n\n          pstrcpy_targphys(SDRAM_BASE + 0x10100, 256, kernel_cmdline);\n\n      } else {\n\n          kernel_size = load_image_targphys(kernel_filename, SDRAM_BASE, SDRAM_SIZE);\n\n          env->pc = SDRAM_BASE | 0xa0000000; /* Start from P2 area */\n\n      }\n\n\n\n      if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n      }\n\n    }\n\n}\n", "idx": 9394}
{"project": "qemu", "commit_id": "072bdb07c5ef8b0351f9973ab5bba9e76be978a9", "target": 1, "func": "static void add_ptimer_tests(uint8_t policy)\n\n{\n\n    uint8_t *ppolicy = g_malloc(1);\n\n    char *policy_name = g_malloc0(256);\n\n\n\n    *ppolicy = policy;\n\n\n\n    if (policy == PTIMER_POLICY_DEFAULT) {\n\n        g_sprintf(policy_name, \"default\");\n\n    }\n\n\n\n    if (policy & PTIMER_POLICY_WRAP_AFTER_ONE_PERIOD) {\n\n        g_strlcat(policy_name, \"wrap_after_one_period,\", 256);\n\n    }\n\n\n\n    if (policy & PTIMER_POLICY_CONTINUOUS_TRIGGER) {\n\n        g_strlcat(policy_name, \"continuous_trigger,\", 256);\n\n    }\n\n\n\n    if (policy & PTIMER_POLICY_NO_IMMEDIATE_TRIGGER) {\n\n        g_strlcat(policy_name, \"no_immediate_trigger,\", 256);\n\n    }\n\n\n\n    if (policy & PTIMER_POLICY_NO_IMMEDIATE_RELOAD) {\n\n        g_strlcat(policy_name, \"no_immediate_reload,\", 256);\n\n    }\n\n\n\n    if (policy & PTIMER_POLICY_NO_COUNTER_ROUND_DOWN) {\n\n        g_strlcat(policy_name, \"no_counter_rounddown,\", 256);\n\n    }\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/set_count policy=%s\", policy_name),\n\n        ppolicy, check_set_count);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/set_limit policy=%s\", policy_name),\n\n        ppolicy, check_set_limit);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/oneshot policy=%s\", policy_name),\n\n        ppolicy, check_oneshot);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/periodic policy=%s\", policy_name),\n\n        ppolicy, check_periodic);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/on_the_fly_mode_change policy=%s\", policy_name),\n\n        ppolicy, check_on_the_fly_mode_change);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/on_the_fly_period_change policy=%s\", policy_name),\n\n        ppolicy, check_on_the_fly_period_change);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/on_the_fly_freq_change policy=%s\", policy_name),\n\n        ppolicy, check_on_the_fly_freq_change);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/run_with_period_0 policy=%s\", policy_name),\n\n        ppolicy, check_run_with_period_0);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/run_with_delta_0 policy=%s\", policy_name),\n\n        ppolicy, check_run_with_delta_0);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/periodic_with_load_0 policy=%s\", policy_name),\n\n        ppolicy, check_periodic_with_load_0);\n\n\n\n    g_test_add_data_func(\n\n        g_strdup_printf(\"/ptimer/oneshot_with_load_0 policy=%s\", policy_name),\n\n        ppolicy, check_oneshot_with_load_0);\n\n}\n", "idx": 448}
{"project": "qemu", "commit_id": "6eaeae37a5fdd0a1ef88ed9ab4b807669ffc0e2d", "target": 1, "func": "static void config_parse(GAConfig *config, int argc, char **argv)\n\n{\n\n    const char *sopt = \"hVvdm:p:l:f:F::b:s:t:D\";\n\n    int opt_ind = 0, ch;\n\n    const struct option lopt[] = {\n\n        { \"help\", 0, NULL, 'h' },\n\n        { \"version\", 0, NULL, 'V' },\n\n        { \"dump-conf\", 0, NULL, 'D' },\n\n        { \"logfile\", 1, NULL, 'l' },\n\n        { \"pidfile\", 1, NULL, 'f' },\n\n#ifdef CONFIG_FSFREEZE\n\n        { \"fsfreeze-hook\", 2, NULL, 'F' },\n\n#endif\n\n        { \"verbose\", 0, NULL, 'v' },\n\n        { \"method\", 1, NULL, 'm' },\n\n        { \"path\", 1, NULL, 'p' },\n\n        { \"daemonize\", 0, NULL, 'd' },\n\n        { \"blacklist\", 1, NULL, 'b' },\n\n#ifdef _WIN32\n\n        { \"service\", 1, NULL, 's' },\n\n#endif\n\n        { \"statedir\", 1, NULL, 't' },\n\n        { NULL, 0, NULL, 0 }\n\n    };\n\n\n\n    config->log_level = G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL;\n\n\n\n    while ((ch = getopt_long(argc, argv, sopt, lopt, &opt_ind)) != -1) {\n\n        switch (ch) {\n\n        case 'm':\n\n            g_free(config->method);\n\n            config->method = g_strdup(optarg);\n\n            break;\n\n        case 'p':\n\n            g_free(config->channel_path);\n\n            config->channel_path = g_strdup(optarg);\n\n            break;\n\n        case 'l':\n\n            g_free(config->log_filepath);\n\n            config->log_filepath = g_strdup(optarg);\n\n            break;\n\n        case 'f':\n\n            g_free(config->pid_filepath);\n\n            config->pid_filepath = g_strdup(optarg);\n\n            break;\n\n#ifdef CONFIG_FSFREEZE\n\n        case 'F':\n\n            g_free(config->fsfreeze_hook);\n\n            config->fsfreeze_hook = g_strdup(optarg ?: QGA_FSFREEZE_HOOK_DEFAULT);\n\n            break;\n\n#endif\n\n        case 't':\n\n            g_free(config->state_dir);\n\n            config->state_dir = g_strdup(optarg);\n\n            break;\n\n        case 'v':\n\n            /* enable all log levels */\n\n            config->log_level = G_LOG_LEVEL_MASK;\n\n            break;\n\n        case 'V':\n\n            printf(\"QEMU Guest Agent %s\\n\", QEMU_VERSION);\n\n            exit(EXIT_SUCCESS);\n\n        case 'd':\n\n            config->daemonize = 1;\n\n            break;\n\n        case 'D':\n\n            config->dumpconf = 1;\n\n            break;\n\n        case 'b': {\n\n            if (is_help_option(optarg)) {\n\n                qmp_for_each_command(ga_print_cmd, NULL);\n\n                exit(EXIT_SUCCESS);\n\n            }\n\n            config->blacklist = g_list_concat(config->blacklist,\n\n                                             split_list(optarg, \",\"));\n\n            break;\n\n        }\n\n#ifdef _WIN32\n\n        case 's':\n\n            config->service = optarg;\n\n            if (strcmp(config->service, \"install\") == 0) {\n\n                if (ga_install_vss_provider()) {\n\n                    exit(EXIT_FAILURE);\n\n                }\n\n                if (ga_install_service(config->channel_path,\n\n                                       config->log_filepath, config->state_dir)) {\n\n                    exit(EXIT_FAILURE);\n\n                }\n\n                exit(EXIT_SUCCESS);\n\n            } else if (strcmp(config->service, \"uninstall\") == 0) {\n\n                ga_uninstall_vss_provider();\n\n                exit(ga_uninstall_service());\n\n            } else if (strcmp(config->service, \"vss-install\") == 0) {\n\n                if (ga_install_vss_provider()) {\n\n                    exit(EXIT_FAILURE);\n\n                }\n\n                exit(EXIT_SUCCESS);\n\n            } else if (strcmp(config->service, \"vss-uninstall\") == 0) {\n\n                ga_uninstall_vss_provider();\n\n                exit(EXIT_SUCCESS);\n\n            } else {\n\n                printf(\"Unknown service command.\\n\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n            break;\n\n#endif\n\n        case 'h':\n\n            usage(argv[0]);\n\n            exit(EXIT_SUCCESS);\n\n        case '?':\n\n            g_print(\"Unknown option, try '%s --help' for more information.\\n\",\n\n                    argv[0]);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n    }\n\n}\n", "idx": 7762}
{"project": "qemu", "commit_id": "24df3371d97a7516605aef8abbc253a8c162b211", "target": 1, "func": "static int handle_utimensat(FsContext *ctx, V9fsPath *fs_path,\n\n                            const struct timespec *buf)\n\n{\n\n    int ret;\n\n#ifdef CONFIG_UTIMENSAT\n\n    int fd;\n\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n    ret = futimens(fd, buf);\n\n    close(fd);\n\n#else\n\n    ret = -1;\n\n    errno = ENOSYS;\n\n#endif\n\n    return ret;\n\n}\n", "idx": 4640}
{"project": "qemu", "commit_id": "58a83c61496eeb0d31571a07a51bc1947e3379ac", "target": 1, "func": "void virtqueue_discard(VirtQueue *vq, const VirtQueueElement *elem,\n\n                       unsigned int len)\n\n{\n\n    vq->last_avail_idx--;\n\n\n    virtqueue_unmap_sg(vq, elem, len);\n\n}", "idx": 5984}
{"project": "qemu", "commit_id": "848696bf353750899832c51005f1bd3540da5c29", "target": 1, "func": "static int qxl_init_primary(PCIDevice *dev)\n\n{\n\n    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);\n\n    VGACommonState *vga = &qxl->vga;\n\n    PortioList *qxl_vga_port_list = g_new(PortioList, 1);\n\n    int rc;\n\n\n\n    qxl->id = 0;\n\n    qxl_init_ramsize(qxl);\n\n    vga->vram_size_mb = qxl->vga.vram_size >> 20;\n\n    vga_common_init(vga, OBJECT(dev), true);\n\n    vga_init(vga, OBJECT(dev),\n\n             pci_address_space(dev), pci_address_space_io(dev), false);\n\n    portio_list_init(qxl_vga_port_list, OBJECT(dev), qxl_vga_portio_list,\n\n                     vga, \"vga\");\n\n    portio_list_set_flush_coalesced(qxl_vga_port_list);\n\n    portio_list_add(qxl_vga_port_list, pci_address_space_io(dev), 0x3b0);\n\n\n\n    vga->con = graphic_console_init(DEVICE(dev), 0, &qxl_ops, qxl);\n\n    qemu_spice_display_init_common(&qxl->ssd);\n\n\n\n    rc = qxl_init_common(qxl);\n\n    if (rc != 0) {\n\n        return rc;\n\n    }\n\n\n\n    qxl->ssd.dcl.ops = &display_listener_ops;\n\n    qxl->ssd.dcl.con = vga->con;\n\n    register_displaychangelistener(&qxl->ssd.dcl);\n\n    return rc;\n\n}\n", "idx": 8248}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n", "idx": 6217}
{"project": "qemu", "commit_id": "f0c9d64a68b776374ec4732424a3e27753ce37b6", "target": 1, "func": "static void acpi_set_pci_info(void)\n\n{\n\n    PCIBus *bus = find_i440fx(); /* TODO: Q35 support */\n\n    unsigned bsel_alloc = 0;\n\n\n\n    if (bus) {\n\n        /* Scan all PCI buses. Set property to enable acpi based hotplug. */\n\n        pci_for_each_bus_depth_first(bus, acpi_set_bsel, NULL, &bsel_alloc);\n\n    }\n\n}\n", "idx": 1827}
{"project": "qemu", "commit_id": "7f1e9d4e138f5baf1e862a1221ba13eee7dcce9e", "target": 1, "func": "static void eepro100_cu_command(EEPRO100State * s, uint8_t val)\n\n{\n\n    eepro100_tx_t tx;\n\n    uint32_t cb_address;\n\n    switch (val) {\n\n    case CU_NOP:\n\n        /* No operation. */\n\n        break;\n\n    case CU_START:\n\n        if (get_cu_state(s) != cu_idle) {\n\n            /* Intel documentation says that CU must be idle for the CU\n\n             * start command. Intel driver for Linux also starts the CU\n\n             * from suspended state. */\n\n            logout(\"CU state is %u, should be %u\\n\", get_cu_state(s), cu_idle);\n\n            //~ assert(!\"wrong CU state\");\n\n        }\n\n        set_cu_state(s, cu_active);\n\n        s->cu_offset = s->pointer;\n\n      next_command:\n\n        cb_address = s->cu_base + s->cu_offset;\n\n        cpu_physical_memory_read(cb_address, (uint8_t *) & tx, sizeof(tx));\n\n        uint16_t status = le16_to_cpu(tx.status);\n\n        uint16_t command = le16_to_cpu(tx.command);\n\n        logout\n\n            (\"val=0x%02x (cu start), status=0x%04x, command=0x%04x, link=0x%08x\\n\",\n\n             val, status, command, tx.link);\n\n        bool bit_el = ((command & 0x8000) != 0);\n\n        bool bit_s = ((command & 0x4000) != 0);\n\n        bool bit_i = ((command & 0x2000) != 0);\n\n        bool bit_nc = ((command & 0x0010) != 0);\n\n        //~ bool bit_sf = ((command & 0x0008) != 0);\n\n        uint16_t cmd = command & 0x0007;\n\n        s->cu_offset = le32_to_cpu(tx.link);\n\n        switch (cmd) {\n\n        case CmdNOp:\n\n            /* Do nothing. */\n\n            break;\n\n        case CmdIASetup:\n\n            cpu_physical_memory_read(cb_address + 8, &s->macaddr[0], 6);\n\n            TRACE(OTHER, logout(\"macaddr: %s\\n\", nic_dump(&s->macaddr[0], 6)));\n\n            break;\n\n        case CmdConfigure:\n\n            cpu_physical_memory_read(cb_address + 8, &s->configuration[0],\n\n                                     sizeof(s->configuration));\n\n            TRACE(OTHER, logout(\"configuration: %s\\n\", nic_dump(&s->configuration[0], 16)));\n\n            break;\n\n        case CmdMulticastList:\n\n            //~ missing(\"multicast list\");\n\n            break;\n\n        case CmdTx:\n\n            (void)0;\n\n            uint32_t tbd_array = le32_to_cpu(tx.tx_desc_addr);\n\n            uint16_t tcb_bytes = (le16_to_cpu(tx.tcb_bytes) & 0x3fff);\n\n            TRACE(RXTX, logout\n\n                (\"transmit, TBD array address 0x%08x, TCB byte count 0x%04x, TBD count %u\\n\",\n\n                 tbd_array, tcb_bytes, tx.tbd_count));\n\n            assert(!bit_nc);\n\n            //~ assert(!bit_sf);\n\n            assert(tcb_bytes <= 2600);\n\n            /* Next assertion fails for local configuration. */\n\n            //~ assert((tcb_bytes > 0) || (tbd_array != 0xffffffff));\n\n            if (!((tcb_bytes > 0) || (tbd_array != 0xffffffff))) {\n\n                logout\n\n                    (\"illegal values of TBD array address and TCB byte count!\\n\");\n\n            }\n\n            // sends larger than MAX_ETH_FRAME_SIZE are allowed, up to 2600 bytes\n\n            uint8_t buf[2600];\n\n            uint16_t size = 0;\n\n            uint32_t tbd_address = cb_address + 0x10;\n\n            assert(tcb_bytes <= sizeof(buf));\n\n            while (size < tcb_bytes) {\n\n                uint32_t tx_buffer_address = ldl_phys(tbd_address);\n\n                uint16_t tx_buffer_size = lduw_phys(tbd_address + 4);\n\n                //~ uint16_t tx_buffer_el = lduw_phys(tbd_address + 6);\n\n                tbd_address += 8;\n\n                TRACE(RXTX, logout\n\n                    (\"TBD (simplified mode): buffer address 0x%08x, size 0x%04x\\n\",\n\n                     tx_buffer_address, tx_buffer_size));\n\n                tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);\n\n                cpu_physical_memory_read(tx_buffer_address, &buf[size],\n\n                                         tx_buffer_size);\n\n                size += tx_buffer_size;\n\n            }\n\n            if (tbd_array == 0xffffffff) {\n\n                /* Simplified mode. Was already handled by code above. */\n\n            } else {\n\n                /* Flexible mode. */\n\n                uint8_t tbd_count = 0;\n\n                if (device_supports_eTxCB(s) && !(s->configuration[6] & BIT(4))) {\n\n                    /* Extended Flexible TCB. */\n\n                    assert(tcb_bytes == 0);\n\n                    for (; tbd_count < 2; tbd_count++) {\n\n                        uint32_t tx_buffer_address = ldl_phys(tbd_address);\n\n                        uint16_t tx_buffer_size = lduw_phys(tbd_address + 4);\n\n                        uint16_t tx_buffer_el = lduw_phys(tbd_address + 6);\n\n                        tbd_address += 8;\n\n                        TRACE(RXTX, logout\n\n                            (\"TBD (extended flexible mode): buffer address 0x%08x, size 0x%04x\\n\",\n\n                             tx_buffer_address, tx_buffer_size));\n\n                        tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);\n\n                        cpu_physical_memory_read(tx_buffer_address, &buf[size],\n\n                                                 tx_buffer_size);\n\n                        size += tx_buffer_size;\n\n                        if (tx_buffer_el & 1) {\n\n                            break;\n\n                        }\n\n                    }\n\n                }\n\n                tbd_address = tbd_array;\n\n                for (; tbd_count < tx.tbd_count; tbd_count++) {\n\n                    uint32_t tx_buffer_address = ldl_phys(tbd_address);\n\n                    uint16_t tx_buffer_size = lduw_phys(tbd_address + 4);\n\n                    uint16_t tx_buffer_el = lduw_phys(tbd_address + 6);\n\n                    tbd_address += 8;\n\n                    TRACE(RXTX, logout\n\n                        (\"TBD (flexible mode): buffer address 0x%08x, size 0x%04x\\n\",\n\n                         tx_buffer_address, tx_buffer_size));\n\n                    tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);\n\n                    cpu_physical_memory_read(tx_buffer_address, &buf[size],\n\n                                             tx_buffer_size);\n\n                    size += tx_buffer_size;\n\n                    if (tx_buffer_el & 1) {\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            TRACE(RXTX, logout(\"%p sending frame, len=%d,%s\\n\", s, size, nic_dump(buf, size)));\n\n            qemu_send_packet(s->vc, buf, size);\n\n            s->statistics.tx_good_frames++;\n\n            /* Transmit with bad status would raise an CX/TNO interrupt.\n\n             * (82557 only). Emulation never has bad status. */\n\n            //~ eepro100_cx_interrupt(s);\n\n            break;\n\n        case CmdTDR:\n\n            TRACE(OTHER, logout(\"load microcode\\n\"));\n\n            /* Starting with offset 8, the command contains\n\n             * 64 dwords microcode which we just ignore here. */\n\n            break;\n\n        default:\n\n            missing(\"undefined command\");\n\n        }\n\n        /* Write new status (success). */\n\n        stw_phys(cb_address, status | 0x8000 | 0x2000);\n\n        if (bit_i) {\n\n            /* CU completed action. */\n\n            eepro100_cx_interrupt(s);\n\n        }\n\n        if (bit_el) {\n\n            /* CU becomes idle. Terminate command loop. */\n\n            set_cu_state(s, cu_idle);\n\n            eepro100_cna_interrupt(s);\n\n        } else if (bit_s) {\n\n            /* CU becomes suspended. */\n\n            set_cu_state(s, cu_suspended);\n\n            eepro100_cna_interrupt(s);\n\n        } else {\n\n            /* More entries in list. */\n\n            TRACE(OTHER, logout(\"CU list with at least one more entry\\n\"));\n\n            goto next_command;\n\n        }\n\n        TRACE(OTHER, logout(\"CU list empty\\n\"));\n\n        /* List is empty. Now CU is idle or suspended. */\n\n        break;\n\n    case CU_RESUME:\n\n        if (get_cu_state(s) != cu_suspended) {\n\n            logout(\"bad CU resume from CU state %u\\n\", get_cu_state(s));\n\n            /* Workaround for bad Linux eepro100 driver which resumes\n\n             * from idle state. */\n\n            //~ missing(\"cu resume\");\n\n            set_cu_state(s, cu_suspended);\n\n        }\n\n        if (get_cu_state(s) == cu_suspended) {\n\n            TRACE(OTHER, logout(\"CU resuming\\n\"));\n\n            set_cu_state(s, cu_active);\n\n            goto next_command;\n\n        }\n\n        break;\n\n    case CU_STATSADDR:\n\n        /* Load dump counters address. */\n\n        s->statsaddr = s->pointer;\n\n        TRACE(OTHER, logout(\"val=0x%02x (status address)\\n\", val));\n\n        break;\n\n    case CU_SHOWSTATS:\n\n        /* Dump statistical counters. */\n\n        TRACE(OTHER, logout(\"val=0x%02x (dump stats)\\n\", val));\n\n        dump_statistics(s);\n\n        break;\n\n    case CU_CMD_BASE:\n\n        /* Load CU base. */\n\n        TRACE(OTHER, logout(\"val=0x%02x (CU base address)\\n\", val));\n\n        s->cu_base = s->pointer;\n\n        break;\n\n    case CU_DUMPSTATS:\n\n        /* Dump and reset statistical counters. */\n\n        TRACE(OTHER, logout(\"val=0x%02x (dump stats and reset)\\n\", val));\n\n        dump_statistics(s);\n\n        memset(&s->statistics, 0, sizeof(s->statistics));\n\n        break;\n\n    case CU_SRESUME:\n\n        /* CU static resume. */\n\n        missing(\"CU static resume\");\n\n        break;\n\n    default:\n\n        missing(\"Undefined CU command\");\n\n    }\n\n}\n", "idx": 11710}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n\n{\n\n    int ret = p->len;\n\n    int sz = sizeof(s->out_buf) - s->out_ptr;\n\n    struct rndis_packet_msg_type *msg =\n\n            (struct rndis_packet_msg_type *) s->out_buf;\n\n    uint32_t len;\n\n\n\n#ifdef TRAFFIC_DEBUG\n\n    fprintf(stderr, \"usbnet: data out len %u\\n\", p->len);\n\n    {\n\n        int i;\n\n        fprintf(stderr, \":\");\n\n        for (i = 0; i < p->len; i++) {\n\n            if (!(i & 15))\n\n                fprintf(stderr, \"\\n%04x:\", i);\n\n            fprintf(stderr, \" %02x\", p->data[i]);\n\n        }\n\n        fprintf(stderr, \"\\n\\n\");\n\n    }\n\n#endif\n\n\n\n    if (sz > ret)\n\n        sz = ret;\n\n    memcpy(&s->out_buf[s->out_ptr], p->data, sz);\n\n    s->out_ptr += sz;\n\n\n\n    if (!is_rndis(s)) {\n\n        if (ret < 64) {\n\n            qemu_send_packet(&s->nic->nc, s->out_buf, s->out_ptr);\n\n            s->out_ptr = 0;\n\n        }\n\n        return ret;\n\n    }\n\n    len = le32_to_cpu(msg->MessageLength);\n\n    if (s->out_ptr < 8 || s->out_ptr < len)\n\n        return ret;\n\n    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n\n        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n\n        uint32_t size = le32_to_cpu(msg->DataLength);\n\n        if (offs + size <= len)\n\n            qemu_send_packet(&s->nic->nc, s->out_buf + offs, size);\n\n    }\n\n    s->out_ptr -= len;\n\n    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n\n\n\n    return ret;\n\n}\n", "idx": 2587}
{"project": "qemu", "commit_id": "6133b39f3c36623425a6ede9e89d93175fde15cd", "target": 1, "func": "void coroutine_fn co_aio_sleep_ns(AioContext *ctx, QEMUClockType type,\n                                  int64_t ns)\n{\n    CoSleepCB sleep_cb = {\n        .co = qemu_coroutine_self(),\n    };\n    sleep_cb.ts = aio_timer_new(ctx, type, SCALE_NS, co_sleep_cb, &sleep_cb);\n    timer_mod(sleep_cb.ts, qemu_clock_get_ns(type) + ns);\n    qemu_coroutine_yield();\n    timer_del(sleep_cb.ts);\n    timer_free(sleep_cb.ts);", "idx": 2316}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_read_backing_file(BDRVQEDState *s, uint64_t pos,\n\n                                  QEMUIOVector *qiov,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    uint64_t backing_length = 0;\n\n    size_t size;\n\n\n\n    /* If there is a backing file, get its length.  Treat the absence of a\n\n     * backing file like a zero length backing file.\n\n     */\n\n    if (s->bs->backing_hd) {\n\n        int64_t l = bdrv_getlength(s->bs->backing_hd);\n\n        if (l < 0) {\n\n            cb(opaque, l);\n\n            return;\n\n        }\n\n        backing_length = l;\n\n    }\n\n\n\n    /* Zero all sectors if reading beyond the end of the backing file */\n\n    if (pos >= backing_length ||\n\n        pos + qiov->size > backing_length) {\n\n        qemu_iovec_memset(qiov, 0, 0, qiov->size);\n\n    }\n\n\n\n    /* Complete now if there are no backing file sectors to read */\n\n    if (pos >= backing_length) {\n\n        cb(opaque, 0);\n\n        return;\n\n    }\n\n\n\n    /* If the read straddles the end of the backing file, shorten it */\n\n    size = MIN((uint64_t)backing_length - pos, qiov->size);\n\n\n\n    BLKDBG_EVENT(s->bs->file, BLKDBG_READ_BACKING_AIO);\n\n    bdrv_aio_readv(s->bs->backing_hd, pos / BDRV_SECTOR_SIZE,\n\n                   qiov, size / BDRV_SECTOR_SIZE, cb, opaque);\n\n}\n", "idx": 11196}
{"project": "qemu", "commit_id": "17cce735780f0ff6a2ef173c34614bd47acd56e5", "target": 1, "func": "static int vdi_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    int ret = 0;\n\n    uint64_t bytes = 0;\n\n    uint32_t blocks;\n\n    size_t block_size = DEFAULT_CLUSTER_SIZE;\n\n    uint32_t image_type = VDI_TYPE_DYNAMIC;\n\n    VdiHeader header;\n\n    size_t i;\n\n    size_t bmap_size;\n\n    int64_t offset = 0;\n\n    Error *local_err = NULL;\n\n    BlockDriverState *bs = NULL;\n\n    uint32_t *bmap = NULL;\n\n\n\n    logout(\"\\n\");\n\n\n\n    /* Read out options. */\n\n    bytes = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0);\n\n#if defined(CONFIG_VDI_BLOCK_SIZE)\n\n    /* TODO: Additional checks (SECTOR_SIZE * 2^n, ...). */\n\n    block_size = qemu_opt_get_size_del(opts,\n\n                                       BLOCK_OPT_CLUSTER_SIZE,\n\n                                       DEFAULT_CLUSTER_SIZE);\n\n#endif\n\n#if defined(CONFIG_VDI_STATIC_IMAGE)\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_STATIC, false)) {\n\n        image_type = VDI_TYPE_STATIC;\n\n    }\n\n#endif\n\n\n\n    if (bytes > VDI_DISK_SIZE_MAX) {\n\n        ret = -ENOTSUP;\n\n        error_setg(errp, \"Unsupported VDI image size (size is 0x%\" PRIx64\n\n                          \", max supported is 0x%\" PRIx64 \")\",\n\n                          bytes, VDI_DISK_SIZE_MAX);\n\n        goto exit;\n\n    }\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n    ret = bdrv_open(&bs, filename, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL,\n\n                    NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    /* We need enough blocks to store the given disk size,\n\n       so always round up. */\n\n    blocks = (bytes + block_size - 1) / block_size;\n\n\n\n    bmap_size = blocks * sizeof(uint32_t);\n\n    bmap_size = ((bmap_size + SECTOR_SIZE - 1) & ~(SECTOR_SIZE -1));\n\n\n\n    memset(&header, 0, sizeof(header));\n\n    pstrcpy(header.text, sizeof(header.text), VDI_TEXT);\n\n    header.signature = VDI_SIGNATURE;\n\n    header.version = VDI_VERSION_1_1;\n\n    header.header_size = 0x180;\n\n    header.image_type = image_type;\n\n    header.offset_bmap = 0x200;\n\n    header.offset_data = 0x200 + bmap_size;\n\n    header.sector_size = SECTOR_SIZE;\n\n    header.disk_size = bytes;\n\n    header.block_size = block_size;\n\n    header.blocks_in_image = blocks;\n\n    if (image_type == VDI_TYPE_STATIC) {\n\n        header.blocks_allocated = blocks;\n\n    }\n\n    uuid_generate(header.uuid_image);\n\n    uuid_generate(header.uuid_last_snap);\n\n    /* There is no need to set header.uuid_link or header.uuid_parent here. */\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n    vdi_header_to_le(&header);\n\n    ret = bdrv_pwrite_sync(bs, offset, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error writing header to %s\", filename);\n\n        goto exit;\n\n    }\n\n    offset += sizeof(header);\n\n\n\n    if (bmap_size > 0) {\n\n        bmap = g_malloc0(bmap_size);\n\n        for (i = 0; i < blocks; i++) {\n\n            if (image_type == VDI_TYPE_STATIC) {\n\n                bmap[i] = i;\n\n            } else {\n\n                bmap[i] = VDI_UNALLOCATED;\n\n            }\n\n        }\n\n        ret = bdrv_pwrite_sync(bs, offset, bmap, bmap_size);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Error writing bmap to %s\", filename);\n\n            goto exit;\n\n        }\n\n        offset += bmap_size;\n\n    }\n\n\n\n    if (image_type == VDI_TYPE_STATIC) {\n\n        ret = bdrv_truncate(bs, offset + blocks * block_size);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to statically allocate %s\", filename);\n\n            goto exit;\n\n        }\n\n    }\n\n\n\nexit:\n\n    bdrv_unref(bs);\n\n    g_free(bmap);\n\n    return ret;\n\n}\n", "idx": 5819}
{"project": "qemu", "commit_id": "326b9e98a391d542cc33c4c91782ff4ba51edfc5", "target": 1, "func": "float32 float32_scalbn( float32 a, int n STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp;\n\n    uint32_t aSig;\n\n\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n\n\n    if ( aExp == 0xFF ) {\n\n        return a;\n\n    }\n\n    if ( aExp != 0 )\n\n        aSig |= 0x00800000;\n\n    else if ( aSig == 0 )\n\n        return a;\n\n\n\n    aExp += n - 1;\n\n    aSig <<= 7;\n\n    return normalizeRoundAndPackFloat32( aSign, aExp, aSig STATUS_VAR );\n\n}\n", "idx": 5484}
{"project": "qemu", "commit_id": "f811f97040a48358b456b46ecbc9167f0131034f", "target": 1, "func": "static void virtio_serial_device_unrealize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n    QLIST_REMOVE(vser, next);\n    g_free(vser->ivqs);\n    g_free(vser->ovqs);\n    g_free(vser->ports_map);\n    if (vser->post_load) {\n        g_free(vser->post_load->connected);\n        timer_del(vser->post_load->timer);\n        timer_free(vser->post_load->timer);\n        g_free(vser->post_load);\n    }\n    virtio_cleanup(vdev);\n}", "idx": 2116}
{"project": "qemu", "commit_id": "2cf7cfa1cde6672b8a35bbed3fbc989f28c05dce", "target": 1, "func": "int qcow2_grow_l1_table(BlockDriverState *bs, int min_size, bool exact_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int new_l1_size, new_l1_size2, ret, i;\n\n    uint64_t *new_l1_table;\n\n    int64_t new_l1_table_offset;\n\n    uint8_t data[12];\n\n\n\n    if (min_size <= s->l1_size)\n\n        return 0;\n\n\n\n    if (exact_size) {\n\n        new_l1_size = min_size;\n\n    } else {\n\n        /* Bump size up to reduce the number of times we have to grow */\n\n        new_l1_size = s->l1_size;\n\n        if (new_l1_size == 0) {\n\n            new_l1_size = 1;\n\n        }\n\n        while (min_size > new_l1_size) {\n\n            new_l1_size = (new_l1_size * 3 + 1) / 2;\n\n        }\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"grow l1_table from %d to %d\\n\", s->l1_size, new_l1_size);\n\n#endif\n\n\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n\n    new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n\n\n    /* write new table (align to cluster) */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n\n    if (new_l1_table_offset < 0) {\n\n        g_free(new_l1_table);\n\n        return new_l1_table_offset;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n\n    ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n\n    if (ret < 0)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n\n\n    /* set new table */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n\n    cpu_to_be64wu((uint64_t*)(data + 4), new_l1_table_offset);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    g_free(s->l1_table);\n\n    qcow2_free_clusters(bs, s->l1_table_offset, s->l1_size * sizeof(uint64_t));\n\n    s->l1_table_offset = new_l1_table_offset;\n\n    s->l1_table = new_l1_table;\n\n    s->l1_size = new_l1_size;\n\n    return 0;\n\n fail:\n\n    g_free(new_l1_table);\n\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2);\n\n    return ret;\n\n}\n", "idx": 2506}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "SPARCCPU *sparc64_cpu_devinit(const char *cpu_model,\n\n                              const char *default_cpu_model, uint64_t prom_addr)\n\n{\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n    ResetData *reset_info;\n\n\n\n    uint32_t   tick_frequency = 100 * 1000000;\n\n    uint32_t  stick_frequency = 100 * 1000000;\n\n    uint32_t hstick_frequency = 100 * 1000000;\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = default_cpu_model;\n\n    }\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    env->tick = cpu_timer_create(\"tick\", cpu, tick_irq,\n\n                                  tick_frequency, TICK_INT_DIS,\n\n                                  TICK_NPT_MASK);\n\n\n\n    env->stick = cpu_timer_create(\"stick\", cpu, stick_irq,\n\n                                   stick_frequency, TICK_INT_DIS,\n\n                                   TICK_NPT_MASK);\n\n\n\n    env->hstick = cpu_timer_create(\"hstick\", cpu, hstick_irq,\n\n                                    hstick_frequency, TICK_INT_DIS,\n\n                                    TICK_NPT_MASK);\n\n\n\n    reset_info = g_malloc0(sizeof(ResetData));\n\n    reset_info->cpu = cpu;\n\n    reset_info->prom_addr = prom_addr;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n\n\n    return cpu;\n\n}\n", "idx": 10240}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "void vga_common_init(VGACommonState *s, Object *obj, bool global_vmstate)\n\n{\n\n    int i, j, v, b;\n\n\n\n    for(i = 0;i < 256; i++) {\n\n        v = 0;\n\n        for(j = 0; j < 8; j++) {\n\n            v |= ((i >> j) & 1) << (j * 4);\n\n        }\n\n        expand4[i] = v;\n\n\n\n        v = 0;\n\n        for(j = 0; j < 4; j++) {\n\n            v |= ((i >> (2 * j)) & 3) << (j * 4);\n\n        }\n\n        expand2[i] = v;\n\n    }\n\n    for(i = 0; i < 16; i++) {\n\n        v = 0;\n\n        for(j = 0; j < 4; j++) {\n\n            b = ((i >> j) & 1);\n\n            v |= b << (2 * j);\n\n            v |= b << (2 * j + 1);\n\n        }\n\n        expand4to8[i] = v;\n\n    }\n\n\n\n    s->vram_size_mb = uint_clamp(s->vram_size_mb, 1, 512);\n\n    s->vram_size_mb = pow2ceil(s->vram_size_mb);\n\n    s->vram_size = s->vram_size_mb << 20;\n\n\n\n    if (!s->vbe_size) {\n\n        s->vbe_size = s->vram_size;\n\n    }\n\n\n\n    s->is_vbe_vmstate = 1;\n\n    memory_region_init_ram(&s->vram, obj, \"vga.vram\", s->vram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram(&s->vram, global_vmstate ? NULL : DEVICE(obj));\n\n    xen_register_framebuffer(&s->vram);\n\n    s->vram_ptr = memory_region_get_ram_ptr(&s->vram);\n\n    s->get_bpp = vga_get_bpp;\n\n    s->get_offsets = vga_get_offsets;\n\n    s->get_resolution = vga_get_resolution;\n\n    s->hw_ops = &vga_ops;\n\n    switch (vga_retrace_method) {\n\n    case VGA_RETRACE_DUMB:\n\n        s->retrace = vga_dumb_retrace;\n\n        s->update_retrace_info = vga_dumb_update_retrace_info;\n\n        break;\n\n\n\n    case VGA_RETRACE_PRECISE:\n\n        s->retrace = vga_precise_retrace;\n\n        s->update_retrace_info = vga_precise_update_retrace_info;\n\n        break;\n\n    }\n\n\n\n    /*\n\n     * Set default fb endian based on target, could probably be turned\n\n     * into a device attribute set by the machine/platform to remove\n\n     * all target endian dependencies from this file.\n\n     */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    s->default_endian_fb = true;\n\n#else\n\n    s->default_endian_fb = false;\n\n#endif\n\n    vga_dirty_log_start(s);\n\n}\n", "idx": 5927}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_mmc_s *omap_mmc_init(hwaddr base,\n\n                MemoryRegion *sysmem,\n\n                BlockBackend *blk,\n\n                qemu_irq irq, qemu_irq dma[], omap_clk clk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = clk;\n\n    s->lines = 1;\t/* TODO: needs to be settable per-board */\n\n    s->rev = 1;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\", 0x800);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(blk, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 9649}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static TAPState *net_tap_fd_init(VLANState *vlan,\n\n                                 const char *model,\n\n                                 const char *name,\n\n                                 int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = qemu_mallocz(sizeof(TAPState));\n\n    s->fd = fd;\n\n    s->vc = qemu_new_vlan_client(vlan, model, name, tap_receive, NULL, s);\n\n    s->vc->fd_readv = tap_receive_iov;\n\n    qemu_set_fd_handler(s->fd, tap_send, NULL, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str), \"fd=%d\", fd);\n\n    return s;\n\n}\n", "idx": 2592}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "static FlatRange *address_space_lookup(AddressSpace *as, AddrRange addr)\n\n{\n\n    return bsearch(&addr, as->current_map.ranges, as->current_map.nr,\n\n                   sizeof(FlatRange), cmp_flatrange_addr);\n\n}\n", "idx": 4536}
{"project": "qemu", "commit_id": "5e6b701aba8689a336297dda047bf760ffc05291", "target": 1, "func": "static int con_init(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n    char *type, *dom;\n\n\n\n    /* setup */\n\n    dom = xs_get_domain_path(xenstore, con->xendev.dom);\n\n    snprintf(con->console, sizeof(con->console), \"%s/console\", dom);\n\n    free(dom);\n\n\n\n    type = xenstore_read_str(con->console, \"type\");\n\n    if (!type || strcmp(type, \"ioemu\") != 0) {\n\n\txen_be_printf(xendev, 1, \"not for me (type=%s)\\n\", type);\n\n\treturn -1;\n\n    }\n\n\n\n    if (!serial_hds[con->xendev.dev])\n\n\txen_be_printf(xendev, 1, \"WARNING: serial line %d not configured\\n\",\n\n                      con->xendev.dev);\n\n    else\n\n        con->chr = serial_hds[con->xendev.dev];\n\n\n\n    return 0;\n\n}\n", "idx": 6543}
{"project": "qemu", "commit_id": "16fde5f2c2788232b16c06d34d0459a5c1ec1f6c", "target": 1, "func": "static int get_cluster_table(BlockDriverState *bs, uint64_t offset,\n\n                             uint64_t **new_l2_table,\n\n                             uint64_t *new_l2_offset,\n\n                             int *new_l2_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int l1_index, l2_index;\n\n    uint64_t l2_offset;\n\n    uint64_t *l2_table = NULL;\n\n    int ret;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> (s->l2_bits + s->cluster_bits);\n\n    if (l1_index >= s->l1_size) {\n\n        ret = qcow2_grow_l1_table(bs, l1_index + 1, false);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (l2_offset & QCOW_OFLAG_COPIED) {\n\n        /* load the l2 table in memory */\n\n        l2_offset &= ~QCOW_OFLAG_COPIED;\n\n        ret = l2_load(bs, l2_offset, &l2_table);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* FIXME Order */\n\n        if (l2_offset)\n\n            qcow2_free_clusters(bs, l2_offset, s->l2_size * sizeof(uint64_t));\n\n        ret = l2_allocate(bs, l1_index, &l2_table);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        l2_offset = s->l1_table[l1_index] & ~QCOW_OFLAG_COPIED;\n\n    }\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n\n\n    *new_l2_table = l2_table;\n\n    *new_l2_offset = l2_offset;\n\n    *new_l2_index = l2_index;\n\n\n\n    return 0;\n\n}\n", "idx": 3954}
{"project": "qemu", "commit_id": "c4843a45e3d4f3698b214275ab5e78cdb6a3d212", "target": 1, "func": "static int vhost_user_set_vring_addr(struct vhost_dev *dev,\n\n                                     struct vhost_vring_addr *addr)\n\n{\n\n    VhostUserMsg msg = {\n\n        .request = VHOST_USER_SET_VRING_ADDR,\n\n        .flags = VHOST_USER_VERSION,\n\n        .payload.addr = *addr,\n\n        .size = sizeof(msg.payload.addr),\n\n    };\n\n\n\n    vhost_user_write(dev, &msg, NULL, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 5317}
{"project": "qemu", "commit_id": "4172a00373b2c81374293becc02b16b7f8c76659", "target": 1, "func": "static void run_block_job(BlockJob *job, Error **errp)\n\n{\n\n    AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n    /* FIXME In error cases, the job simply goes away and we access a dangling\n\n     * pointer below. */\n\n    aio_context_acquire(aio_context);\n\n    do {\n\n        aio_poll(aio_context, true);\n\n        qemu_progress_print(job->len ?\n\n                            ((float)job->offset / job->len * 100.f) : 0.0f, 0);\n\n    } while (!job->ready);\n\n\n\n    block_job_complete_sync(job, errp);\n\n    aio_context_release(aio_context);\n\n\n\n    /* A block job may finish instantaneously without publishing any progress,\n\n     * so just signal completion here */\n\n    qemu_progress_print(100.f, 0);\n\n}\n", "idx": 759}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void disas_arm_insn(DisasContext *s, unsigned int insn)\n\n{\n\n    unsigned int cond, val, op1, i, shift, rm, rs, rn, rd, sh;\n\n    TCGv_i32 tmp;\n\n    TCGv_i32 tmp2;\n\n    TCGv_i32 tmp3;\n\n    TCGv_i32 addr;\n\n    TCGv_i64 tmp64;\n\n\n\n    /* M variants do not implement ARM mode.  */\n\n    if (arm_dc_feature(s, ARM_FEATURE_M)) {\n\n        goto illegal_op;\n\n    }\n\n    cond = insn >> 28;\n\n    if (cond == 0xf){\n\n        /* In ARMv3 and v4 the NV condition is UNPREDICTABLE; we\n\n         * choose to UNDEF. In ARMv5 and above the space is used\n\n         * for miscellaneous unconditional instructions.\n\n         */\n\n        ARCH(5);\n\n\n\n        /* Unconditional instructions.  */\n\n        if (((insn >> 25) & 7) == 1) {\n\n            /* NEON Data processing.  */\n\n            if (!arm_dc_feature(s, ARM_FEATURE_NEON)) {\n\n                goto illegal_op;\n\n            }\n\n\n\n            if (disas_neon_data_insn(s, insn)) {\n\n                goto illegal_op;\n\n            }\n\n            return;\n\n        }\n\n        if ((insn & 0x0f100000) == 0x04000000) {\n\n            /* NEON load/store.  */\n\n            if (!arm_dc_feature(s, ARM_FEATURE_NEON)) {\n\n                goto illegal_op;\n\n            }\n\n\n\n            if (disas_neon_ls_insn(s, insn)) {\n\n                goto illegal_op;\n\n            }\n\n            return;\n\n        }\n\n        if ((insn & 0x0f000e10) == 0x0e000a00) {\n\n            /* VFP.  */\n\n            if (disas_vfp_insn(s, insn)) {\n\n                goto illegal_op;\n\n            }\n\n            return;\n\n        }\n\n        if (((insn & 0x0f30f000) == 0x0510f000) ||\n\n            ((insn & 0x0f30f010) == 0x0710f000)) {\n\n            if ((insn & (1 << 22)) == 0) {\n\n                /* PLDW; v7MP */\n\n                if (!arm_dc_feature(s, ARM_FEATURE_V7MP)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            /* Otherwise PLD; v5TE+ */\n\n            ARCH(5TE);\n\n            return;\n\n        }\n\n        if (((insn & 0x0f70f000) == 0x0450f000) ||\n\n            ((insn & 0x0f70f010) == 0x0650f000)) {\n\n            ARCH(7);\n\n            return; /* PLI; V7 */\n\n        }\n\n        if (((insn & 0x0f700000) == 0x04100000) ||\n\n            ((insn & 0x0f700010) == 0x06100000)) {\n\n            if (!arm_dc_feature(s, ARM_FEATURE_V7MP)) {\n\n                goto illegal_op;\n\n            }\n\n            return; /* v7MP: Unallocated memory hint: must NOP */\n\n        }\n\n\n\n        if ((insn & 0x0ffffdff) == 0x01010000) {\n\n            ARCH(6);\n\n            /* setend */\n\n            if (((insn >> 9) & 1) != s->bswap_code) {\n\n                /* Dynamic endianness switching not implemented. */\n\n                qemu_log_mask(LOG_UNIMP, \"arm: unimplemented setend\\n\");\n\n                goto illegal_op;\n\n            }\n\n            return;\n\n        } else if ((insn & 0x0fffff00) == 0x057ff000) {\n\n            switch ((insn >> 4) & 0xf) {\n\n            case 1: /* clrex */\n\n                ARCH(6K);\n\n                gen_clrex(s);\n\n                return;\n\n            case 4: /* dsb */\n\n            case 5: /* dmb */\n\n                ARCH(7);\n\n                /* We don't emulate caches so these are a no-op.  */\n\n                return;\n\n            case 6: /* isb */\n\n                /* We need to break the TB after this insn to execute\n\n                 * self-modifying code correctly and also to take\n\n                 * any pending interrupts immediately.\n\n                 */\n\n                gen_lookup_tb(s);\n\n                return;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n        } else if ((insn & 0x0e5fffe0) == 0x084d0500) {\n\n            /* srs */\n\n            if (IS_USER(s)) {\n\n                goto illegal_op;\n\n            }\n\n            ARCH(6);\n\n            gen_srs(s, (insn & 0x1f), (insn >> 23) & 3, insn & (1 << 21));\n\n            return;\n\n        } else if ((insn & 0x0e50ffe0) == 0x08100a00) {\n\n            /* rfe */\n\n            int32_t offset;\n\n            if (IS_USER(s))\n\n                goto illegal_op;\n\n            ARCH(6);\n\n            rn = (insn >> 16) & 0xf;\n\n            addr = load_reg(s, rn);\n\n            i = (insn >> 23) & 3;\n\n            switch (i) {\n\n            case 0: offset = -4; break; /* DA */\n\n            case 1: offset = 0; break; /* IA */\n\n            case 2: offset = -8; break; /* DB */\n\n            case 3: offset = 4; break; /* IB */\n\n            default: abort();\n\n            }\n\n            if (offset)\n\n                tcg_gen_addi_i32(addr, addr, offset);\n\n            /* Load PC into tmp and CPSR into tmp2.  */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(tmp, addr, get_mem_index(s));\n\n            tcg_gen_addi_i32(addr, addr, 4);\n\n            tmp2 = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(tmp2, addr, get_mem_index(s));\n\n            if (insn & (1 << 21)) {\n\n                /* Base writeback.  */\n\n                switch (i) {\n\n                case 0: offset = -8; break;\n\n                case 1: offset = 4; break;\n\n                case 2: offset = -4; break;\n\n                case 3: offset = 0; break;\n\n                default: abort();\n\n                }\n\n                if (offset)\n\n                    tcg_gen_addi_i32(addr, addr, offset);\n\n                store_reg(s, rn, addr);\n\n            } else {\n\n                tcg_temp_free_i32(addr);\n\n            }\n\n            gen_rfe(s, tmp, tmp2);\n\n            return;\n\n        } else if ((insn & 0x0e000000) == 0x0a000000) {\n\n            /* branch link and change to thumb (blx <offset>) */\n\n            int32_t offset;\n\n\n\n            val = (uint32_t)s->pc;\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, val);\n\n            store_reg(s, 14, tmp);\n\n            /* Sign-extend the 24-bit offset */\n\n            offset = (((int32_t)insn) << 8) >> 8;\n\n            /* offset * 4 + bit24 * 2 + (thumb bit) */\n\n            val += (offset << 2) | ((insn >> 23) & 2) | 1;\n\n            /* pipeline offset */\n\n            val += 4;\n\n            /* protected by ARCH(5); above, near the start of uncond block */\n\n            gen_bx_im(s, val);\n\n            return;\n\n        } else if ((insn & 0x0e000f00) == 0x0c000100) {\n\n            if (arm_dc_feature(s, ARM_FEATURE_IWMMXT)) {\n\n                /* iWMMXt register transfer.  */\n\n                if (extract32(s->c15_cpar, 1, 1)) {\n\n                    if (!disas_iwmmxt_insn(s, insn)) {\n\n                        return;\n\n                    }\n\n                }\n\n            }\n\n        } else if ((insn & 0x0fe00000) == 0x0c400000) {\n\n            /* Coprocessor double register transfer.  */\n\n            ARCH(5TE);\n\n        } else if ((insn & 0x0f000010) == 0x0e000010) {\n\n            /* Additional coprocessor register transfer.  */\n\n        } else if ((insn & 0x0ff10020) == 0x01000000) {\n\n            uint32_t mask;\n\n            uint32_t val;\n\n            /* cps (privileged) */\n\n            if (IS_USER(s))\n\n                return;\n\n            mask = val = 0;\n\n            if (insn & (1 << 19)) {\n\n                if (insn & (1 << 8))\n\n                    mask |= CPSR_A;\n\n                if (insn & (1 << 7))\n\n                    mask |= CPSR_I;\n\n                if (insn & (1 << 6))\n\n                    mask |= CPSR_F;\n\n                if (insn & (1 << 18))\n\n                    val |= mask;\n\n            }\n\n            if (insn & (1 << 17)) {\n\n                mask |= CPSR_M;\n\n                val |= (insn & 0x1f);\n\n            }\n\n            if (mask) {\n\n                gen_set_psr_im(s, mask, 0, val);\n\n            }\n\n            return;\n\n        }\n\n        goto illegal_op;\n\n    }\n\n    if (cond != 0xe) {\n\n        /* if not always execute, we generate a conditional jump to\n\n           next instruction */\n\n        s->condlabel = gen_new_label();\n\n        arm_gen_test_cc(cond ^ 1, s->condlabel);\n\n        s->condjmp = 1;\n\n    }\n\n    if ((insn & 0x0f900000) == 0x03000000) {\n\n        if ((insn & (1 << 21)) == 0) {\n\n            ARCH(6T2);\n\n            rd = (insn >> 12) & 0xf;\n\n            val = ((insn >> 4) & 0xf000) | (insn & 0xfff);\n\n            if ((insn & (1 << 22)) == 0) {\n\n                /* MOVW */\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp, val);\n\n            } else {\n\n                /* MOVT */\n\n                tmp = load_reg(s, rd);\n\n                tcg_gen_ext16u_i32(tmp, tmp);\n\n                tcg_gen_ori_i32(tmp, tmp, val << 16);\n\n            }\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            if (((insn >> 12) & 0xf) != 0xf)\n\n                goto illegal_op;\n\n            if (((insn >> 16) & 0xf) == 0) {\n\n                gen_nop_hint(s, insn & 0xff);\n\n            } else {\n\n                /* CPSR = immediate */\n\n                val = insn & 0xff;\n\n                shift = ((insn >> 8) & 0xf) * 2;\n\n                if (shift)\n\n                    val = (val >> shift) | (val << (32 - shift));\n\n                i = ((insn & (1 << 22)) != 0);\n\n                if (gen_set_psr_im(s, msr_mask(s, (insn >> 16) & 0xf, i),\n\n                                   i, val)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n        }\n\n    } else if ((insn & 0x0f900000) == 0x01000000\n\n               && (insn & 0x00000090) != 0x00000090) {\n\n        /* miscellaneous instructions */\n\n        op1 = (insn >> 21) & 3;\n\n        sh = (insn >> 4) & 0xf;\n\n        rm = insn & 0xf;\n\n        switch (sh) {\n\n        case 0x0: /* move program status register */\n\n            if (op1 & 1) {\n\n                /* PSR = reg */\n\n                tmp = load_reg(s, rm);\n\n                i = ((op1 & 2) != 0);\n\n                if (gen_set_psr(s, msr_mask(s, (insn >> 16) & 0xf, i), i, tmp))\n\n                    goto illegal_op;\n\n            } else {\n\n                /* reg = PSR */\n\n                rd = (insn >> 12) & 0xf;\n\n                if (op1 & 2) {\n\n                    if (IS_USER(s))\n\n                        goto illegal_op;\n\n                    tmp = load_cpu_field(spsr);\n\n                } else {\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_helper_cpsr_read(tmp, cpu_env);\n\n                }\n\n                store_reg(s, rd, tmp);\n\n            }\n\n            break;\n\n        case 0x1:\n\n            if (op1 == 1) {\n\n                /* branch/exchange thumb (bx).  */\n\n                ARCH(4T);\n\n                tmp = load_reg(s, rm);\n\n                gen_bx(s, tmp);\n\n            } else if (op1 == 3) {\n\n                /* clz */\n\n                ARCH(5);\n\n                rd = (insn >> 12) & 0xf;\n\n                tmp = load_reg(s, rm);\n\n                gen_helper_clz(tmp, tmp);\n\n                store_reg(s, rd, tmp);\n\n            } else {\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n        case 0x2:\n\n            if (op1 == 1) {\n\n                ARCH(5J); /* bxj */\n\n                /* Trivial implementation equivalent to bx.  */\n\n                tmp = load_reg(s, rm);\n\n                gen_bx(s, tmp);\n\n            } else {\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n        case 0x3:\n\n            if (op1 != 1)\n\n              goto illegal_op;\n\n\n\n            ARCH(5);\n\n            /* branch link/exchange thumb (blx) */\n\n            tmp = load_reg(s, rm);\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, s->pc);\n\n            store_reg(s, 14, tmp2);\n\n            gen_bx(s, tmp);\n\n            break;\n\n        case 0x4:\n\n        {\n\n            /* crc32/crc32c */\n\n            uint32_t c = extract32(insn, 8, 4);\n\n\n\n            /* Check this CPU supports ARMv8 CRC instructions.\n\n             * op1 == 3 is UNPREDICTABLE but handle as UNDEFINED.\n\n             * Bits 8, 10 and 11 should be zero.\n\n             */\n\n            if (!arm_dc_feature(s, ARM_FEATURE_CRC) || op1 == 0x3 ||\n\n                (c & 0xd) != 0) {\n\n                goto illegal_op;\n\n            }\n\n\n\n            rn = extract32(insn, 16, 4);\n\n            rd = extract32(insn, 12, 4);\n\n\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            if (op1 == 0) {\n\n                tcg_gen_andi_i32(tmp2, tmp2, 0xff);\n\n            } else if (op1 == 1) {\n\n                tcg_gen_andi_i32(tmp2, tmp2, 0xffff);\n\n            }\n\n            tmp3 = tcg_const_i32(1 << op1);\n\n            if (c & 0x2) {\n\n                gen_helper_crc32c(tmp, tmp, tmp2, tmp3);\n\n            } else {\n\n                gen_helper_crc32(tmp, tmp, tmp2, tmp3);\n\n            }\n\n            tcg_temp_free_i32(tmp2);\n\n            tcg_temp_free_i32(tmp3);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n        case 0x5: /* saturating add/subtract */\n\n            ARCH(5TE);\n\n            rd = (insn >> 12) & 0xf;\n\n            rn = (insn >> 16) & 0xf;\n\n            tmp = load_reg(s, rm);\n\n            tmp2 = load_reg(s, rn);\n\n            if (op1 & 2)\n\n                gen_helper_double_saturate(tmp2, cpu_env, tmp2);\n\n            if (op1 & 1)\n\n                gen_helper_sub_saturate(tmp, cpu_env, tmp, tmp2);\n\n            else\n\n                gen_helper_add_saturate(tmp, cpu_env, tmp, tmp2);\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 7:\n\n        {\n\n            int imm16 = extract32(insn, 0, 4) | (extract32(insn, 8, 12) << 4);\n\n            switch (op1) {\n\n            case 1:\n\n                /* bkpt */\n\n                ARCH(5);\n\n                gen_exception_insn(s, 4, EXCP_BKPT,\n\n                                   syn_aa32_bkpt(imm16, false),\n\n                                   default_exception_el(s));\n\n                break;\n\n            case 2:\n\n                /* Hypervisor call (v7) */\n\n                ARCH(7);\n\n                if (IS_USER(s)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_hvc(s, imm16);\n\n                break;\n\n            case 3:\n\n                /* Secure monitor call (v6+) */\n\n                ARCH(6K);\n\n                if (IS_USER(s)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_smc(s);\n\n                break;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n        }\n\n        case 0x8: /* signed multiply */\n\n        case 0xa:\n\n        case 0xc:\n\n        case 0xe:\n\n            ARCH(5TE);\n\n            rs = (insn >> 8) & 0xf;\n\n            rn = (insn >> 12) & 0xf;\n\n            rd = (insn >> 16) & 0xf;\n\n            if (op1 == 1) {\n\n                /* (32 * 16) >> 16 */\n\n                tmp = load_reg(s, rm);\n\n                tmp2 = load_reg(s, rs);\n\n                if (sh & 4)\n\n                    tcg_gen_sari_i32(tmp2, tmp2, 16);\n\n                else\n\n                    gen_sxth(tmp2);\n\n                tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                tcg_gen_shri_i64(tmp64, tmp64, 16);\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_extrl_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                if ((sh & 2) == 0) {\n\n                    tmp2 = load_reg(s, rn);\n\n                    gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n                store_reg(s, rd, tmp);\n\n            } else {\n\n                /* 16 * 16 */\n\n                tmp = load_reg(s, rm);\n\n                tmp2 = load_reg(s, rs);\n\n                gen_mulxy(tmp, tmp2, sh & 2, sh & 4);\n\n                tcg_temp_free_i32(tmp2);\n\n                if (op1 == 2) {\n\n                    tmp64 = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                    gen_addq(s, tmp64, rn, rd);\n\n                    gen_storeq_reg(s, rn, rd, tmp64);\n\n                    tcg_temp_free_i64(tmp64);\n\n                } else {\n\n                    if (op1 == 0) {\n\n                        tmp2 = load_reg(s, rn);\n\n                        gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n    } else if (((insn & 0x0e000000) == 0 &&\n\n                (insn & 0x00000090) != 0x90) ||\n\n               ((insn & 0x0e000000) == (1 << 25))) {\n\n        int set_cc, logic_cc, shiftop;\n\n\n\n        op1 = (insn >> 21) & 0xf;\n\n        set_cc = (insn >> 20) & 1;\n\n        logic_cc = table_logic_cc[op1] & set_cc;\n\n\n\n        /* data processing instruction */\n\n        if (insn & (1 << 25)) {\n\n            /* immediate operand */\n\n            val = insn & 0xff;\n\n            shift = ((insn >> 8) & 0xf) * 2;\n\n            if (shift) {\n\n                val = (val >> shift) | (val << (32 - shift));\n\n            }\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, val);\n\n            if (logic_cc && shift) {\n\n                gen_set_CF_bit31(tmp2);\n\n            }\n\n        } else {\n\n            /* register */\n\n            rm = (insn) & 0xf;\n\n            tmp2 = load_reg(s, rm);\n\n            shiftop = (insn >> 5) & 3;\n\n            if (!(insn & (1 << 4))) {\n\n                shift = (insn >> 7) & 0x1f;\n\n                gen_arm_shift_im(tmp2, shiftop, shift, logic_cc);\n\n            } else {\n\n                rs = (insn >> 8) & 0xf;\n\n                tmp = load_reg(s, rs);\n\n                gen_arm_shift_reg(tmp2, shiftop, tmp, logic_cc);\n\n            }\n\n        }\n\n        if (op1 != 0x0f && op1 != 0x0d) {\n\n            rn = (insn >> 16) & 0xf;\n\n            tmp = load_reg(s, rn);\n\n        } else {\n\n            TCGV_UNUSED_I32(tmp);\n\n        }\n\n        rd = (insn >> 12) & 0xf;\n\n        switch(op1) {\n\n        case 0x00:\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            if (logic_cc) {\n\n                gen_logic_CC(tmp);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x01:\n\n            tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n            if (logic_cc) {\n\n                gen_logic_CC(tmp);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x02:\n\n            if (set_cc && rd == 15) {\n\n                /* SUBS r15, ... is used for exception return.  */\n\n                if (IS_USER(s)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                gen_exception_return(s, tmp);\n\n            } else {\n\n                if (set_cc) {\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                }\n\n                store_reg_bx(s, rd, tmp);\n\n            }\n\n            break;\n\n        case 0x03:\n\n            if (set_cc) {\n\n                gen_sub_CC(tmp, tmp2, tmp);\n\n            } else {\n\n                tcg_gen_sub_i32(tmp, tmp2, tmp);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x04:\n\n            if (set_cc) {\n\n                gen_add_CC(tmp, tmp, tmp2);\n\n            } else {\n\n                tcg_gen_add_i32(tmp, tmp, tmp2);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x05:\n\n            if (set_cc) {\n\n                gen_adc_CC(tmp, tmp, tmp2);\n\n            } else {\n\n                gen_add_carry(tmp, tmp, tmp2);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x06:\n\n            if (set_cc) {\n\n                gen_sbc_CC(tmp, tmp, tmp2);\n\n            } else {\n\n                gen_sub_carry(tmp, tmp, tmp2);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x07:\n\n            if (set_cc) {\n\n                gen_sbc_CC(tmp, tmp2, tmp);\n\n            } else {\n\n                gen_sub_carry(tmp, tmp2, tmp);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x08:\n\n            if (set_cc) {\n\n                tcg_gen_and_i32(tmp, tmp, tmp2);\n\n                gen_logic_CC(tmp);\n\n            }\n\n            tcg_temp_free_i32(tmp);\n\n            break;\n\n        case 0x09:\n\n            if (set_cc) {\n\n                tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n                gen_logic_CC(tmp);\n\n            }\n\n            tcg_temp_free_i32(tmp);\n\n            break;\n\n        case 0x0a:\n\n            if (set_cc) {\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n            }\n\n            tcg_temp_free_i32(tmp);\n\n            break;\n\n        case 0x0b:\n\n            if (set_cc) {\n\n                gen_add_CC(tmp, tmp, tmp2);\n\n            }\n\n            tcg_temp_free_i32(tmp);\n\n            break;\n\n        case 0x0c:\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            if (logic_cc) {\n\n                gen_logic_CC(tmp);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        case 0x0d:\n\n            if (logic_cc && rd == 15) {\n\n                /* MOVS r15, ... is used for exception return.  */\n\n                if (IS_USER(s)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_exception_return(s, tmp2);\n\n            } else {\n\n                if (logic_cc) {\n\n                    gen_logic_CC(tmp2);\n\n                }\n\n                store_reg_bx(s, rd, tmp2);\n\n            }\n\n            break;\n\n        case 0x0e:\n\n            tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n            if (logic_cc) {\n\n                gen_logic_CC(tmp);\n\n            }\n\n            store_reg_bx(s, rd, tmp);\n\n            break;\n\n        default:\n\n        case 0x0f:\n\n            tcg_gen_not_i32(tmp2, tmp2);\n\n            if (logic_cc) {\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            store_reg_bx(s, rd, tmp2);\n\n            break;\n\n        }\n\n        if (op1 != 0x0f && op1 != 0x0d) {\n\n            tcg_temp_free_i32(tmp2);\n\n        }\n\n    } else {\n\n        /* other instructions */\n\n        op1 = (insn >> 24) & 0xf;\n\n        switch(op1) {\n\n        case 0x0:\n\n        case 0x1:\n\n            /* multiplies, extra load/stores */\n\n            sh = (insn >> 5) & 3;\n\n            if (sh == 0) {\n\n                if (op1 == 0x0) {\n\n                    rd = (insn >> 16) & 0xf;\n\n                    rn = (insn >> 12) & 0xf;\n\n                    rs = (insn >> 8) & 0xf;\n\n                    rm = (insn) & 0xf;\n\n                    op1 = (insn >> 20) & 0xf;\n\n                    switch (op1) {\n\n                    case 0: case 1: case 2: case 3: case 6:\n\n                        /* 32 bit mul */\n\n                        tmp = load_reg(s, rs);\n\n                        tmp2 = load_reg(s, rm);\n\n                        tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        if (insn & (1 << 22)) {\n\n                            /* Subtract (mls) */\n\n                            ARCH(6T2);\n\n                            tmp2 = load_reg(s, rn);\n\n                            tcg_gen_sub_i32(tmp, tmp2, tmp);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        } else if (insn & (1 << 21)) {\n\n                            /* Add */\n\n                            tmp2 = load_reg(s, rn);\n\n                            tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                        if (insn & (1 << 20))\n\n                            gen_logic_CC(tmp);\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    case 4:\n\n                        /* 64 bit mul double accumulate (UMAAL) */\n\n                        ARCH(6);\n\n                        tmp = load_reg(s, rs);\n\n                        tmp2 = load_reg(s, rm);\n\n                        tmp64 = gen_mulu_i64_i32(tmp, tmp2);\n\n                        gen_addq_lo(s, tmp64, rn);\n\n                        gen_addq_lo(s, tmp64, rd);\n\n                        gen_storeq_reg(s, rn, rd, tmp64);\n\n                        tcg_temp_free_i64(tmp64);\n\n                        break;\n\n                    case 8: case 9: case 10: case 11:\n\n                    case 12: case 13: case 14: case 15:\n\n                        /* 64 bit mul: UMULL, UMLAL, SMULL, SMLAL. */\n\n                        tmp = load_reg(s, rs);\n\n                        tmp2 = load_reg(s, rm);\n\n                        if (insn & (1 << 22)) {\n\n                            tcg_gen_muls2_i32(tmp, tmp2, tmp, tmp2);\n\n                        } else {\n\n                            tcg_gen_mulu2_i32(tmp, tmp2, tmp, tmp2);\n\n                        }\n\n                        if (insn & (1 << 21)) { /* mult accumulate */\n\n                            TCGv_i32 al = load_reg(s, rn);\n\n                            TCGv_i32 ah = load_reg(s, rd);\n\n                            tcg_gen_add2_i32(tmp, tmp2, tmp, tmp2, al, ah);\n\n                            tcg_temp_free_i32(al);\n\n                            tcg_temp_free_i32(ah);\n\n                        }\n\n                        if (insn & (1 << 20)) {\n\n                            gen_logicq_cc(tmp, tmp2);\n\n                        }\n\n                        store_reg(s, rn, tmp);\n\n                        store_reg(s, rd, tmp2);\n\n                        break;\n\n                    default:\n\n                        goto illegal_op;\n\n                    }\n\n                } else {\n\n                    rn = (insn >> 16) & 0xf;\n\n                    rd = (insn >> 12) & 0xf;\n\n                    if (insn & (1 << 23)) {\n\n                        /* load/store exclusive */\n\n                        int op2 = (insn >> 8) & 3;\n\n                        op1 = (insn >> 21) & 0x3;\n\n\n\n                        switch (op2) {\n\n                        case 0: /* lda/stl */\n\n                            if (op1 == 1) {\n\n                                goto illegal_op;\n\n                            }\n\n                            ARCH(8);\n\n                            break;\n\n                        case 1: /* reserved */\n\n                            goto illegal_op;\n\n                        case 2: /* ldaex/stlex */\n\n                            ARCH(8);\n\n                            break;\n\n                        case 3: /* ldrex/strex */\n\n                            if (op1) {\n\n                                ARCH(6K);\n\n                            } else {\n\n                                ARCH(6);\n\n                            }\n\n                            break;\n\n                        }\n\n\n\n                        addr = tcg_temp_local_new_i32();\n\n                        load_reg_var(s, addr, rn);\n\n\n\n                        /* Since the emulation does not have barriers,\n\n                           the acquire/release semantics need no special\n\n                           handling */\n\n                        if (op2 == 0) {\n\n                            if (insn & (1 << 20)) {\n\n                                tmp = tcg_temp_new_i32();\n\n                                switch (op1) {\n\n                                case 0: /* lda */\n\n                                    gen_aa32_ld32u(tmp, addr, get_mem_index(s));\n\n                                    break;\n\n                                case 2: /* ldab */\n\n                                    gen_aa32_ld8u(tmp, addr, get_mem_index(s));\n\n                                    break;\n\n                                case 3: /* ldah */\n\n                                    gen_aa32_ld16u(tmp, addr, get_mem_index(s));\n\n                                    break;\n\n                                default:\n\n                                    abort();\n\n                                }\n\n                                store_reg(s, rd, tmp);\n\n                            } else {\n\n                                rm = insn & 0xf;\n\n                                tmp = load_reg(s, rm);\n\n                                switch (op1) {\n\n                                case 0: /* stl */\n\n                                    gen_aa32_st32(tmp, addr, get_mem_index(s));\n\n                                    break;\n\n                                case 2: /* stlb */\n\n                                    gen_aa32_st8(tmp, addr, get_mem_index(s));\n\n                                    break;\n\n                                case 3: /* stlh */\n\n                                    gen_aa32_st16(tmp, addr, get_mem_index(s));\n\n                                    break;\n\n                                default:\n\n                                    abort();\n\n                                }\n\n                                tcg_temp_free_i32(tmp);\n\n                            }\n\n                        } else if (insn & (1 << 20)) {\n\n                            switch (op1) {\n\n                            case 0: /* ldrex */\n\n                                gen_load_exclusive(s, rd, 15, addr, 2);\n\n                                break;\n\n                            case 1: /* ldrexd */\n\n                                gen_load_exclusive(s, rd, rd + 1, addr, 3);\n\n                                break;\n\n                            case 2: /* ldrexb */\n\n                                gen_load_exclusive(s, rd, 15, addr, 0);\n\n                                break;\n\n                            case 3: /* ldrexh */\n\n                                gen_load_exclusive(s, rd, 15, addr, 1);\n\n                                break;\n\n                            default:\n\n                                abort();\n\n                            }\n\n                        } else {\n\n                            rm = insn & 0xf;\n\n                            switch (op1) {\n\n                            case 0:  /*  strex */\n\n                                gen_store_exclusive(s, rd, rm, 15, addr, 2);\n\n                                break;\n\n                            case 1: /*  strexd */\n\n                                gen_store_exclusive(s, rd, rm, rm + 1, addr, 3);\n\n                                break;\n\n                            case 2: /*  strexb */\n\n                                gen_store_exclusive(s, rd, rm, 15, addr, 0);\n\n                                break;\n\n                            case 3: /* strexh */\n\n                                gen_store_exclusive(s, rd, rm, 15, addr, 1);\n\n                                break;\n\n                            default:\n\n                                abort();\n\n                            }\n\n                        }\n\n                        tcg_temp_free_i32(addr);\n\n                    } else {\n\n                        /* SWP instruction */\n\n                        rm = (insn) & 0xf;\n\n\n\n                        /* ??? This is not really atomic.  However we know\n\n                           we never have multiple CPUs running in parallel,\n\n                           so it is good enough.  */\n\n                        addr = load_reg(s, rn);\n\n                        tmp = load_reg(s, rm);\n\n                        tmp2 = tcg_temp_new_i32();\n\n                        if (insn & (1 << 22)) {\n\n                            gen_aa32_ld8u(tmp2, addr, get_mem_index(s));\n\n                            gen_aa32_st8(tmp, addr, get_mem_index(s));\n\n                        } else {\n\n                            gen_aa32_ld32u(tmp2, addr, get_mem_index(s));\n\n                            gen_aa32_st32(tmp, addr, get_mem_index(s));\n\n                        }\n\n                        tcg_temp_free_i32(tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                        store_reg(s, rd, tmp2);\n\n                    }\n\n                }\n\n            } else {\n\n                int address_offset;\n\n                bool load = insn & (1 << 20);\n\n                bool doubleword = false;\n\n                /* Misc load/store */\n\n                rn = (insn >> 16) & 0xf;\n\n                rd = (insn >> 12) & 0xf;\n\n\n\n                if (!load && (sh & 2)) {\n\n                    /* doubleword */\n\n                    ARCH(5TE);\n\n                    if (rd & 1) {\n\n                        /* UNPREDICTABLE; we choose to UNDEF */\n\n                        goto illegal_op;\n\n                    }\n\n                    load = (sh & 1) == 0;\n\n                    doubleword = true;\n\n                }\n\n\n\n                addr = load_reg(s, rn);\n\n                if (insn & (1 << 24))\n\n                    gen_add_datah_offset(s, insn, 0, addr);\n\n                address_offset = 0;\n\n\n\n                if (doubleword) {\n\n                    if (!load) {\n\n                        /* store */\n\n                        tmp = load_reg(s, rd);\n\n                        gen_aa32_st32(tmp, addr, get_mem_index(s));\n\n                        tcg_temp_free_i32(tmp);\n\n                        tcg_gen_addi_i32(addr, addr, 4);\n\n                        tmp = load_reg(s, rd + 1);\n\n                        gen_aa32_st32(tmp, addr, get_mem_index(s));\n\n                        tcg_temp_free_i32(tmp);\n\n                    } else {\n\n                        /* load */\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_aa32_ld32u(tmp, addr, get_mem_index(s));\n\n                        store_reg(s, rd, tmp);\n\n                        tcg_gen_addi_i32(addr, addr, 4);\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_aa32_ld32u(tmp, addr, get_mem_index(s));\n\n                        rd++;\n\n                    }\n\n                    address_offset = -4;\n\n                } else if (load) {\n\n                    /* load */\n\n                    tmp = tcg_temp_new_i32();\n\n                    switch (sh) {\n\n                    case 1:\n\n                        gen_aa32_ld16u(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    case 2:\n\n                        gen_aa32_ld8s(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    default:\n\n                    case 3:\n\n                        gen_aa32_ld16s(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    }\n\n                } else {\n\n                    /* store */\n\n                    tmp = load_reg(s, rd);\n\n                    gen_aa32_st16(tmp, addr, get_mem_index(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                /* Perform base writeback before the loaded value to\n\n                   ensure correct behavior with overlapping index registers.\n\n                   ldrd with base writeback is undefined if the\n\n                   destination and index registers overlap.  */\n\n                if (!(insn & (1 << 24))) {\n\n                    gen_add_datah_offset(s, insn, address_offset, addr);\n\n                    store_reg(s, rn, addr);\n\n                } else if (insn & (1 << 21)) {\n\n                    if (address_offset)\n\n                        tcg_gen_addi_i32(addr, addr, address_offset);\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    tcg_temp_free_i32(addr);\n\n                }\n\n                if (load) {\n\n                    /* Complete the load.  */\n\n                    store_reg(s, rd, tmp);\n\n                }\n\n            }\n\n            break;\n\n        case 0x4:\n\n        case 0x5:\n\n            goto do_ldst;\n\n        case 0x6:\n\n        case 0x7:\n\n            if (insn & (1 << 4)) {\n\n                ARCH(6);\n\n                /* Armv6 Media instructions.  */\n\n                rm = insn & 0xf;\n\n                rn = (insn >> 16) & 0xf;\n\n                rd = (insn >> 12) & 0xf;\n\n                rs = (insn >> 8) & 0xf;\n\n                switch ((insn >> 23) & 3) {\n\n                case 0: /* Parallel add/subtract.  */\n\n                    op1 = (insn >> 20) & 7;\n\n                    tmp = load_reg(s, rn);\n\n                    tmp2 = load_reg(s, rm);\n\n                    sh = (insn >> 5) & 7;\n\n                    if ((op1 & 3) == 0 || sh == 5 || sh == 6)\n\n                        goto illegal_op;\n\n                    gen_arm_parallel_addsub(op1, sh, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                    store_reg(s, rd, tmp);\n\n                    break;\n\n                case 1:\n\n                    if ((insn & 0x00700020) == 0) {\n\n                        /* Halfword pack.  */\n\n                        tmp = load_reg(s, rn);\n\n                        tmp2 = load_reg(s, rm);\n\n                        shift = (insn >> 7) & 0x1f;\n\n                        if (insn & (1 << 6)) {\n\n                            /* pkhtb */\n\n                            if (shift == 0)\n\n                                shift = 31;\n\n                            tcg_gen_sari_i32(tmp2, tmp2, shift);\n\n                            tcg_gen_andi_i32(tmp, tmp, 0xffff0000);\n\n                            tcg_gen_ext16u_i32(tmp2, tmp2);\n\n                        } else {\n\n                            /* pkhbt */\n\n                            if (shift)\n\n                                tcg_gen_shli_i32(tmp2, tmp2, shift);\n\n                            tcg_gen_ext16u_i32(tmp, tmp);\n\n                            tcg_gen_andi_i32(tmp2, tmp2, 0xffff0000);\n\n                        }\n\n                        tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        store_reg(s, rd, tmp);\n\n                    } else if ((insn & 0x00200020) == 0x00200000) {\n\n                        /* [us]sat */\n\n                        tmp = load_reg(s, rm);\n\n                        shift = (insn >> 7) & 0x1f;\n\n                        if (insn & (1 << 6)) {\n\n                            if (shift == 0)\n\n                                shift = 31;\n\n                            tcg_gen_sari_i32(tmp, tmp, shift);\n\n                        } else {\n\n                            tcg_gen_shli_i32(tmp, tmp, shift);\n\n                        }\n\n                        sh = (insn >> 16) & 0x1f;\n\n                        tmp2 = tcg_const_i32(sh);\n\n                        if (insn & (1 << 22))\n\n                          gen_helper_usat(tmp, cpu_env, tmp, tmp2);\n\n                        else\n\n                          gen_helper_ssat(tmp, cpu_env, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        store_reg(s, rd, tmp);\n\n                    } else if ((insn & 0x00300fe0) == 0x00200f20) {\n\n                        /* [us]sat16 */\n\n                        tmp = load_reg(s, rm);\n\n                        sh = (insn >> 16) & 0x1f;\n\n                        tmp2 = tcg_const_i32(sh);\n\n                        if (insn & (1 << 22))\n\n                          gen_helper_usat16(tmp, cpu_env, tmp, tmp2);\n\n                        else\n\n                          gen_helper_ssat16(tmp, cpu_env, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        store_reg(s, rd, tmp);\n\n                    } else if ((insn & 0x00700fe0) == 0x00000fa0) {\n\n                        /* Select bytes.  */\n\n                        tmp = load_reg(s, rn);\n\n                        tmp2 = load_reg(s, rm);\n\n                        tmp3 = tcg_temp_new_i32();\n\n                        tcg_gen_ld_i32(tmp3, cpu_env, offsetof(CPUARMState, GE));\n\n                        gen_helper_sel_flags(tmp, tmp3, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp3);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        store_reg(s, rd, tmp);\n\n                    } else if ((insn & 0x000003e0) == 0x00000060) {\n\n                        tmp = load_reg(s, rm);\n\n                        shift = (insn >> 10) & 3;\n\n                        /* ??? In many cases it's not necessary to do a\n\n                           rotate, a shift is sufficient.  */\n\n                        if (shift != 0)\n\n                            tcg_gen_rotri_i32(tmp, tmp, shift * 8);\n\n                        op1 = (insn >> 20) & 7;\n\n                        switch (op1) {\n\n                        case 0: gen_sxtb16(tmp);  break;\n\n                        case 2: gen_sxtb(tmp);    break;\n\n                        case 3: gen_sxth(tmp);    break;\n\n                        case 4: gen_uxtb16(tmp);  break;\n\n                        case 6: gen_uxtb(tmp);    break;\n\n                        case 7: gen_uxth(tmp);    break;\n\n                        default: goto illegal_op;\n\n                        }\n\n                        if (rn != 15) {\n\n                            tmp2 = load_reg(s, rn);\n\n                            if ((op1 & 3) == 0) {\n\n                                gen_add16(tmp, tmp2);\n\n                            } else {\n\n                                tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                                tcg_temp_free_i32(tmp2);\n\n                            }\n\n                        }\n\n                        store_reg(s, rd, tmp);\n\n                    } else if ((insn & 0x003f0f60) == 0x003f0f20) {\n\n                        /* rev */\n\n                        tmp = load_reg(s, rm);\n\n                        if (insn & (1 << 22)) {\n\n                            if (insn & (1 << 7)) {\n\n                                gen_revsh(tmp);\n\n                            } else {\n\n                                ARCH(6T2);\n\n                                gen_helper_rbit(tmp, tmp);\n\n                            }\n\n                        } else {\n\n                            if (insn & (1 << 7))\n\n                                gen_rev16(tmp);\n\n                            else\n\n                                tcg_gen_bswap32_i32(tmp, tmp);\n\n                        }\n\n                        store_reg(s, rd, tmp);\n\n                    } else {\n\n                        goto illegal_op;\n\n                    }\n\n                    break;\n\n                case 2: /* Multiplies (Type 3).  */\n\n                    switch ((insn >> 20) & 0x7) {\n\n                    case 5:\n\n                        if (((insn >> 6) ^ (insn >> 7)) & 1) {\n\n                            /* op2 not 00x or 11x : UNDEF */\n\n                            goto illegal_op;\n\n                        }\n\n                        /* Signed multiply most significant [accumulate].\n\n                           (SMMUL, SMMLA, SMMLS) */\n\n                        tmp = load_reg(s, rm);\n\n                        tmp2 = load_reg(s, rs);\n\n                        tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n\n\n                        if (rd != 15) {\n\n                            tmp = load_reg(s, rd);\n\n                            if (insn & (1 << 6)) {\n\n                                tmp64 = gen_subq_msw(tmp64, tmp);\n\n                            } else {\n\n                                tmp64 = gen_addq_msw(tmp64, tmp);\n\n                            }\n\n                        }\n\n                        if (insn & (1 << 5)) {\n\n                            tcg_gen_addi_i64(tmp64, tmp64, 0x80000000u);\n\n                        }\n\n                        tcg_gen_shri_i64(tmp64, tmp64, 32);\n\n                        tmp = tcg_temp_new_i32();\n\n                        tcg_gen_extrl_i64_i32(tmp, tmp64);\n\n                        tcg_temp_free_i64(tmp64);\n\n                        store_reg(s, rn, tmp);\n\n                        break;\n\n                    case 0:\n\n                    case 4:\n\n                        /* SMLAD, SMUAD, SMLSD, SMUSD, SMLALD, SMLSLD */\n\n                        if (insn & (1 << 7)) {\n\n                            goto illegal_op;\n\n                        }\n\n                        tmp = load_reg(s, rm);\n\n                        tmp2 = load_reg(s, rs);\n\n                        if (insn & (1 << 5))\n\n                            gen_swap_half(tmp2);\n\n                        gen_smul_dual(tmp, tmp2);\n\n                        if (insn & (1 << 22)) {\n\n                            /* smlald, smlsld */\n\n                            TCGv_i64 tmp64_2;\n\n\n\n                            tmp64 = tcg_temp_new_i64();\n\n                            tmp64_2 = tcg_temp_new_i64();\n\n                            tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                            tcg_gen_ext_i32_i64(tmp64_2, tmp2);\n\n                            tcg_temp_free_i32(tmp);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            if (insn & (1 << 6)) {\n\n                                tcg_gen_sub_i64(tmp64, tmp64, tmp64_2);\n\n                            } else {\n\n                                tcg_gen_add_i64(tmp64, tmp64, tmp64_2);\n\n                            }\n\n                            tcg_temp_free_i64(tmp64_2);\n\n                            gen_addq(s, tmp64, rd, rn);\n\n                            gen_storeq_reg(s, rd, rn, tmp64);\n\n                            tcg_temp_free_i64(tmp64);\n\n                        } else {\n\n                            /* smuad, smusd, smlad, smlsd */\n\n                            if (insn & (1 << 6)) {\n\n                                /* This subtraction cannot overflow. */\n\n                                tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                            } else {\n\n                                /* This addition cannot overflow 32 bits;\n\n                                 * however it may overflow considered as a\n\n                                 * signed operation, in which case we must set\n\n                                 * the Q flag.\n\n                                 */\n\n                                gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                            if (rd != 15)\n\n                              {\n\n                                tmp2 = load_reg(s, rd);\n\n                                gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                                tcg_temp_free_i32(tmp2);\n\n                              }\n\n                            store_reg(s, rn, tmp);\n\n                        }\n\n                        break;\n\n                    case 1:\n\n                    case 3:\n\n                        /* SDIV, UDIV */\n\n                        if (!arm_dc_feature(s, ARM_FEATURE_ARM_DIV)) {\n\n                            goto illegal_op;\n\n                        }\n\n                        if (((insn >> 5) & 7) || (rd != 15)) {\n\n                            goto illegal_op;\n\n                        }\n\n                        tmp = load_reg(s, rm);\n\n                        tmp2 = load_reg(s, rs);\n\n                        if (insn & (1 << 21)) {\n\n                            gen_helper_udiv(tmp, tmp, tmp2);\n\n                        } else {\n\n                            gen_helper_sdiv(tmp, tmp, tmp2);\n\n                        }\n\n                        tcg_temp_free_i32(tmp2);\n\n                        store_reg(s, rn, tmp);\n\n                        break;\n\n                    default:\n\n                        goto illegal_op;\n\n                    }\n\n                    break;\n\n                case 3:\n\n                    op1 = ((insn >> 17) & 0x38) | ((insn >> 5) & 7);\n\n                    switch (op1) {\n\n                    case 0: /* Unsigned sum of absolute differences.  */\n\n                        ARCH(6);\n\n                        tmp = load_reg(s, rm);\n\n                        tmp2 = load_reg(s, rs);\n\n                        gen_helper_usad8(tmp, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        if (rd != 15) {\n\n                            tmp2 = load_reg(s, rd);\n\n                            tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                        store_reg(s, rn, tmp);\n\n                        break;\n\n                    case 0x20: case 0x24: case 0x28: case 0x2c:\n\n                        /* Bitfield insert/clear.  */\n\n                        ARCH(6T2);\n\n                        shift = (insn >> 7) & 0x1f;\n\n                        i = (insn >> 16) & 0x1f;\n\n                        if (i < shift) {\n\n                            /* UNPREDICTABLE; we choose to UNDEF */\n\n                            goto illegal_op;\n\n                        }\n\n                        i = i + 1 - shift;\n\n                        if (rm == 15) {\n\n                            tmp = tcg_temp_new_i32();\n\n                            tcg_gen_movi_i32(tmp, 0);\n\n                        } else {\n\n                            tmp = load_reg(s, rm);\n\n                        }\n\n                        if (i != 32) {\n\n                            tmp2 = load_reg(s, rd);\n\n                            tcg_gen_deposit_i32(tmp, tmp2, tmp, shift, i);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    case 0x12: case 0x16: case 0x1a: case 0x1e: /* sbfx */\n\n                    case 0x32: case 0x36: case 0x3a: case 0x3e: /* ubfx */\n\n                        ARCH(6T2);\n\n                        tmp = load_reg(s, rm);\n\n                        shift = (insn >> 7) & 0x1f;\n\n                        i = ((insn >> 16) & 0x1f) + 1;\n\n                        if (shift + i > 32)\n\n                            goto illegal_op;\n\n                        if (i < 32) {\n\n                            if (op1 & 0x20) {\n\n                                gen_ubfx(tmp, shift, (1u << i) - 1);\n\n                            } else {\n\n                                gen_sbfx(tmp, shift, i);\n\n                            }\n\n                        }\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    default:\n\n                        goto illegal_op;\n\n                    }\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        do_ldst:\n\n            /* Check for undefined extension instructions\n\n             * per the ARM Bible IE:\n\n             * xxxx 0111 1111 xxxx  xxxx xxxx 1111 xxxx\n\n             */\n\n            sh = (0xf << 20) | (0xf << 4);\n\n            if (op1 == 0x7 && ((insn & sh) == sh))\n\n            {\n\n                goto illegal_op;\n\n            }\n\n            /* load/store byte/word */\n\n            rn = (insn >> 16) & 0xf;\n\n            rd = (insn >> 12) & 0xf;\n\n            tmp2 = load_reg(s, rn);\n\n            if ((insn & 0x01200000) == 0x00200000) {\n\n                /* ldrt/strt */\n\n                i = get_a32_user_mem_index(s);\n\n            } else {\n\n                i = get_mem_index(s);\n\n            }\n\n            if (insn & (1 << 24))\n\n                gen_add_data_offset(s, insn, tmp2);\n\n            if (insn & (1 << 20)) {\n\n                /* load */\n\n                tmp = tcg_temp_new_i32();\n\n                if (insn & (1 << 22)) {\n\n                    gen_aa32_ld8u(tmp, tmp2, i);\n\n                } else {\n\n                    gen_aa32_ld32u(tmp, tmp2, i);\n\n                }\n\n            } else {\n\n                /* store */\n\n                tmp = load_reg(s, rd);\n\n                if (insn & (1 << 22)) {\n\n                    gen_aa32_st8(tmp, tmp2, i);\n\n                } else {\n\n                    gen_aa32_st32(tmp, tmp2, i);\n\n                }\n\n                tcg_temp_free_i32(tmp);\n\n            }\n\n            if (!(insn & (1 << 24))) {\n\n                gen_add_data_offset(s, insn, tmp2);\n\n                store_reg(s, rn, tmp2);\n\n            } else if (insn & (1 << 21)) {\n\n                store_reg(s, rn, tmp2);\n\n            } else {\n\n                tcg_temp_free_i32(tmp2);\n\n            }\n\n            if (insn & (1 << 20)) {\n\n                /* Complete the load.  */\n\n                store_reg_from_load(s, rd, tmp);\n\n            }\n\n            break;\n\n        case 0x08:\n\n        case 0x09:\n\n            {\n\n                int j, n, loaded_base;\n\n                bool exc_return = false;\n\n                bool is_load = extract32(insn, 20, 1);\n\n                bool user = false;\n\n                TCGv_i32 loaded_var;\n\n                /* load/store multiple words */\n\n                /* XXX: store correct base if write back */\n\n                if (insn & (1 << 22)) {\n\n                    /* LDM (user), LDM (exception return) and STM (user) */\n\n                    if (IS_USER(s))\n\n                        goto illegal_op; /* only usable in supervisor mode */\n\n\n\n                    if (is_load && extract32(insn, 15, 1)) {\n\n                        exc_return = true;\n\n                    } else {\n\n                        user = true;\n\n                    }\n\n                }\n\n                rn = (insn >> 16) & 0xf;\n\n                addr = load_reg(s, rn);\n\n\n\n                /* compute total size */\n\n                loaded_base = 0;\n\n                TCGV_UNUSED_I32(loaded_var);\n\n                n = 0;\n\n                for(i=0;i<16;i++) {\n\n                    if (insn & (1 << i))\n\n                        n++;\n\n                }\n\n                /* XXX: test invalid n == 0 case ? */\n\n                if (insn & (1 << 23)) {\n\n                    if (insn & (1 << 24)) {\n\n                        /* pre increment */\n\n                        tcg_gen_addi_i32(addr, addr, 4);\n\n                    } else {\n\n                        /* post increment */\n\n                    }\n\n                } else {\n\n                    if (insn & (1 << 24)) {\n\n                        /* pre decrement */\n\n                        tcg_gen_addi_i32(addr, addr, -(n * 4));\n\n                    } else {\n\n                        /* post decrement */\n\n                        if (n != 1)\n\n                        tcg_gen_addi_i32(addr, addr, -((n - 1) * 4));\n\n                    }\n\n                }\n\n                j = 0;\n\n                for(i=0;i<16;i++) {\n\n                    if (insn & (1 << i)) {\n\n                        if (is_load) {\n\n                            /* load */\n\n                            tmp = tcg_temp_new_i32();\n\n                            gen_aa32_ld32u(tmp, addr, get_mem_index(s));\n\n                            if (user) {\n\n                                tmp2 = tcg_const_i32(i);\n\n                                gen_helper_set_user_reg(cpu_env, tmp2, tmp);\n\n                                tcg_temp_free_i32(tmp2);\n\n                                tcg_temp_free_i32(tmp);\n\n                            } else if (i == rn) {\n\n                                loaded_var = tmp;\n\n                                loaded_base = 1;\n\n                            } else {\n\n                                store_reg_from_load(s, i, tmp);\n\n                            }\n\n                        } else {\n\n                            /* store */\n\n                            if (i == 15) {\n\n                                /* special case: r15 = PC + 8 */\n\n                                val = (long)s->pc + 4;\n\n                                tmp = tcg_temp_new_i32();\n\n                                tcg_gen_movi_i32(tmp, val);\n\n                            } else if (user) {\n\n                                tmp = tcg_temp_new_i32();\n\n                                tmp2 = tcg_const_i32(i);\n\n                                gen_helper_get_user_reg(tmp, cpu_env, tmp2);\n\n                                tcg_temp_free_i32(tmp2);\n\n                            } else {\n\n                                tmp = load_reg(s, i);\n\n                            }\n\n                            gen_aa32_st32(tmp, addr, get_mem_index(s));\n\n                            tcg_temp_free_i32(tmp);\n\n                        }\n\n                        j++;\n\n                        /* no need to add after the last transfer */\n\n                        if (j != n)\n\n                            tcg_gen_addi_i32(addr, addr, 4);\n\n                    }\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* write back */\n\n                    if (insn & (1 << 23)) {\n\n                        if (insn & (1 << 24)) {\n\n                            /* pre increment */\n\n                        } else {\n\n                            /* post increment */\n\n                            tcg_gen_addi_i32(addr, addr, 4);\n\n                        }\n\n                    } else {\n\n                        if (insn & (1 << 24)) {\n\n                            /* pre decrement */\n\n                            if (n != 1)\n\n                                tcg_gen_addi_i32(addr, addr, -((n - 1) * 4));\n\n                        } else {\n\n                            /* post decrement */\n\n                            tcg_gen_addi_i32(addr, addr, -(n * 4));\n\n                        }\n\n                    }\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    tcg_temp_free_i32(addr);\n\n                }\n\n                if (loaded_base) {\n\n                    store_reg(s, rn, loaded_var);\n\n                }\n\n                if (exc_return) {\n\n                    /* Restore CPSR from SPSR.  */\n\n                    tmp = load_cpu_field(spsr);\n\n                    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n                    tcg_temp_free_i32(tmp);\n\n                    s->is_jmp = DISAS_UPDATE;\n\n                }\n\n            }\n\n            break;\n\n        case 0xa:\n\n        case 0xb:\n\n            {\n\n                int32_t offset;\n\n\n\n                /* branch (and link) */\n\n                val = (int32_t)s->pc;\n\n                if (insn & (1 << 24)) {\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp, val);\n\n                    store_reg(s, 14, tmp);\n\n                }\n\n                offset = sextract32(insn << 2, 0, 26);\n\n                val += offset + 4;\n\n                gen_jmp(s, val);\n\n            }\n\n            break;\n\n        case 0xc:\n\n        case 0xd:\n\n        case 0xe:\n\n            if (((insn >> 8) & 0xe) == 10) {\n\n                /* VFP.  */\n\n                if (disas_vfp_insn(s, insn)) {\n\n                    goto illegal_op;\n\n                }\n\n            } else if (disas_coproc_insn(s, insn)) {\n\n                /* Coprocessor.  */\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n        case 0xf:\n\n            /* swi */\n\n            gen_set_pc_im(s, s->pc);\n\n            s->svc_imm = extract32(insn, 0, 24);\n\n            s->is_jmp = DISAS_SWI;\n\n            break;\n\n        default:\n\n        illegal_op:\n\n            gen_exception_insn(s, 4, EXCP_UDEF, syn_uncategorized(),\n\n                               default_exception_el(s));\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 11529}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static gnutls_certificate_credentials_t vnc_tls_initialize_x509_cred(VncDisplay *vd)\n\n{\n\n    gnutls_certificate_credentials_t x509_cred;\n\n    int ret;\n\n\n\n    if (!vd->tls.x509cacert) {\n\n        VNC_DEBUG(\"No CA x509 certificate specified\\n\");\n\n        return NULL;\n\n    }\n\n    if (!vd->tls.x509cert) {\n\n        VNC_DEBUG(\"No server x509 certificate specified\\n\");\n\n        return NULL;\n\n    }\n\n    if (!vd->tls.x509key) {\n\n        VNC_DEBUG(\"No server private key specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if ((ret = gnutls_certificate_allocate_credentials(&x509_cred)) < 0) {\n\n        VNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n        return NULL;\n\n    }\n\n    if ((ret = gnutls_certificate_set_x509_trust_file(x509_cred,\n\n                                                      vd->tls.x509cacert,\n\n                                                      GNUTLS_X509_FMT_PEM)) < 0) {\n\n        VNC_DEBUG(\"Cannot load CA certificate %s\\n\", gnutls_strerror(ret));\n\n        gnutls_certificate_free_credentials(x509_cred);\n\n        return NULL;\n\n    }\n\n\n\n    if ((ret = gnutls_certificate_set_x509_key_file (x509_cred,\n\n                                                     vd->tls.x509cert,\n\n                                                     vd->tls.x509key,\n\n                                                     GNUTLS_X509_FMT_PEM)) < 0) {\n\n        VNC_DEBUG(\"Cannot load certificate & key %s\\n\", gnutls_strerror(ret));\n\n        gnutls_certificate_free_credentials(x509_cred);\n\n        return NULL;\n\n    }\n\n\n\n    if (vd->tls.x509cacrl) {\n\n        if ((ret = gnutls_certificate_set_x509_crl_file(x509_cred,\n\n                                                        vd->tls.x509cacrl,\n\n                                                        GNUTLS_X509_FMT_PEM)) < 0) {\n\n            VNC_DEBUG(\"Cannot load CRL %s\\n\", gnutls_strerror(ret));\n\n            gnutls_certificate_free_credentials(x509_cred);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    gnutls_certificate_set_dh_params (x509_cred, dh_params);\n\n\n\n    return x509_cred;\n\n}\n", "idx": 6125}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static void mux_chr_read(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n    int m = chr->focus;\n\n    int i;\n\n\n\n    mux_chr_accept_input (opaque);\n\n\n\n    for(i = 0; i < size; i++)\n\n        if (mux_proc_byte(chr, d, buf[i])) {\n\n            if (d->prod == d->cons &&\n\n                d->chr_can_read[m] &&\n\n                d->chr_can_read[m](d->ext_opaque[m]))\n\n                d->chr_read[m](d->ext_opaque[m], &buf[i], 1);\n\n            else\n\n                d->buffer[d->prod++ & MUX_BUFFER_MASK] = buf[i];\n\n        }\n\n}\n", "idx": 1320}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)\n\n{\n\n    RTL8139State *s = opaque;\n\n    int ret;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            ret = s->phys[addr - MAC0];\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            ret = 0;\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            ret = s->mult[addr - MAR0];\n\n            break;\n\n        case ChipCmd:\n\n            ret = rtl8139_ChipCmd_read(s);\n\n            break;\n\n        case Cfg9346:\n\n            ret = rtl8139_Cfg9346_read(s);\n\n            break;\n\n        case Config0:\n\n            ret = rtl8139_Config0_read(s);\n\n            break;\n\n        case Config1:\n\n            ret = rtl8139_Config1_read(s);\n\n            break;\n\n        case Config3:\n\n            ret = rtl8139_Config3_read(s);\n\n            break;\n\n        case Config4:\n\n            ret = rtl8139_Config4_read(s);\n\n            break;\n\n        case Config5:\n\n            ret = rtl8139_Config5_read(s);\n\n            break;\n\n\n\n        case MediaStatus:\n\n            ret = 0xd0;\n\n            DPRINTF(\"MediaStatus read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case HltClk:\n\n            ret = s->clock_enabled;\n\n            DPRINTF(\"HltClk read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case PCIRevisionID:\n\n            ret = RTL8139_PCI_REVID;\n\n            DPRINTF(\"PCI Revision ID read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case TxThresh:\n\n            ret = s->TxThresh;\n\n            DPRINTF(\"C+ TxThresh read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        case 0x43: /* Part of TxConfig register. Windows driver tries to read it */\n\n            ret = s->TxConfig >> 24;\n\n            DPRINTF(\"RTL8139C TxConfig at 0x43 read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented read(b) addr=0x%x\\n\", addr);\n\n            ret = 0;\n\n            break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 6961}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static void vnc_resize(VncState *vs)\n\n{\n\n    DisplayState *ds = vs->ds;\n\n\n\n    int size_changed;\n\n\n\n    vs->old_data = qemu_realloc(vs->old_data, ds_get_linesize(ds) * ds_get_height(ds));\n\n\n\n    if (vs->old_data == NULL) {\n\n        fprintf(stderr, \"vnc: memory allocation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (ds_get_bytes_per_pixel(ds) != vs->serverds.pf.bytes_per_pixel)\n\n        console_color_init(ds);\n\n    vnc_colordepth(vs);\n\n    size_changed = ds_get_width(ds) != vs->serverds.width ||\n\n                   ds_get_height(ds) != vs->serverds.height;\n\n    vs->serverds = *(ds->surface);\n\n    if (size_changed) {\n\n        if (vs->csock != -1 && vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n\n            vnc_write_u8(vs, 0);  /* msg id */\n\n            vnc_write_u8(vs, 0);\n\n            vnc_write_u16(vs, 1); /* number of rects */\n\n            vnc_framebuffer_update(vs, 0, 0, ds_get_width(ds), ds_get_height(ds),\n\n                                   VNC_ENCODING_DESKTOPRESIZE);\n\n            vnc_flush(vs);\n\n        }\n\n    }\n\n\n\n    memset(vs->dirty_row, 0xFF, sizeof(vs->dirty_row));\n\n    memset(vs->old_data, 42, ds_get_linesize(vs->ds) * ds_get_height(vs->ds));\n\n}\n", "idx": 2409}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "GACommandState *ga_command_state_new(void)\n\n{\n\n    GACommandState *cs = g_malloc0(sizeof(GACommandState));\n\n    cs->groups = NULL;\n\n    return cs;\n\n}\n", "idx": 7796}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbiva(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_tlbiva(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 9643}
{"project": "qemu", "commit_id": "d451008e0fdf7fb817c791397e7999d5f3687e58", "target": 1, "func": "static void vfio_rtl8168_window_quirk_write(void *opaque, hwaddr addr,\n\n                                            uint64_t data, unsigned size)\n\n{\n\n    VFIOQuirk *quirk = opaque;\n\n    VFIOPCIDevice *vdev = quirk->vdev;\n\n\n\n    switch (addr) {\n\n    case 4: /* address */\n\n        if ((data & 0x7fff0000) == 0x10000) {\n\n            if (data & 0x80000000U &&\n\n                vdev->pdev.cap_present & QEMU_PCI_CAP_MSIX) {\n\n\n\n                trace_vfio_rtl8168_window_quirk_write_table(\n\n                        memory_region_name(&quirk->mem),\n\n                        vdev->vbasedev.name);\n\n\n\n                memory_region_dispatch_write(&vdev->pdev.msix_table_mmio,\n\n                                             (hwaddr)(data & 0xfff),\n\n                                             (uint64_t)quirk->data.address_mask,\n\n                                             size, MEMTXATTRS_UNSPECIFIED);\n\n            }\n\n\n\n            quirk->data.flags = 1;\n\n            quirk->data.address_match = data;\n\n\n\n            return;\n\n        }\n\n        quirk->data.flags = 0;\n\n        break;\n\n    case 0: /* data */\n\n        quirk->data.address_mask = data;\n\n        break;\n\n    }\n\n\n\n    trace_vfio_rtl8168_window_quirk_write_direct(\n\n            memory_region_name(&quirk->mem),\n\n            vdev->vbasedev.name);\n\n\n\n    vfio_region_write(&vdev->bars[quirk->data.bar].region,\n\n                      addr + 0x70, data, size);\n\n}\n", "idx": 5692}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(set_T1)\n\n{\n\n    T1 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 3813}
{"project": "qemu", "commit_id": "9bff5d8135fc3f37932d4177727d293aa93ce79b", "target": 1, "func": "int msix_init_exclusive_bar(PCIDevice *dev, unsigned short nentries,\n\n                            uint8_t bar_nr)\n\n{\n\n    int ret;\n\n    char *name;\n\n    uint32_t bar_size = 4096;\n\n    uint32_t bar_pba_offset = bar_size / 2;\n\n    uint32_t bar_pba_size = (nentries / 8 + 1) * 8;\n\n\n\n    /*\n\n     * Migration compatibility dictates that this remains a 4k\n\n     * BAR with the vector table in the lower half and PBA in\n\n     * the upper half for nentries which is lower or equal to 128.\n\n     * No need to care about using more than 65 entries for legacy\n\n     * machine types who has at most 64 queues.\n\n     */\n\n    if (nentries * PCI_MSIX_ENTRY_SIZE > bar_pba_offset) {\n\n        bar_pba_offset = nentries * PCI_MSIX_ENTRY_SIZE;\n\n    }\n\n\n\n    if (bar_pba_offset + bar_pba_size > 4096) {\n\n        bar_size = bar_pba_offset + bar_pba_size;\n\n    }\n\n\n\n    if (bar_size & (bar_size - 1)) {\n\n        bar_size = 1 << qemu_fls(bar_size);\n\n    }\n\n\n\n    name = g_strdup_printf(\"%s-msix\", dev->name);\n\n    memory_region_init(&dev->msix_exclusive_bar, OBJECT(dev), name, bar_size);\n\n    g_free(name);\n\n\n\n    ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,\n\n                    0, &dev->msix_exclusive_bar,\n\n                    bar_nr, bar_pba_offset,\n\n                    0);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    pci_register_bar(dev, bar_nr, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &dev->msix_exclusive_bar);\n\n\n\n    return 0;\n\n}\n", "idx": 3502}
{"project": "qemu", "commit_id": "0462faee67eb9ee39e51f764891fb6b767602eed", "target": 1, "func": "void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,\n                                          const char *name,\n                                          uint64_t ram_size)\n{\n    uint64_t addr = 0;\n    int i;\n    if (nb_numa_nodes == 0 || !have_memdevs) {\n        allocate_system_memory_nonnuma(mr, owner, name, ram_size);\n        return;\n    memory_region_init(mr, owner, name, ram_size);\n    for (i = 0; i < MAX_NODES; i++) {\n        Error *local_err = NULL;\n        uint64_t size = numa_info[i].node_mem;\n        HostMemoryBackend *backend = numa_info[i].node_memdev;\n        if (!backend) {\n            continue;\n        MemoryRegion *seg = host_memory_backend_get_memory(backend, &local_err);\n        if (local_err) {\n            qerror_report_err(local_err);\n        memory_region_add_subregion(mr, addr, seg);\n        vmstate_register_ram_global(seg);\n        addr += size;", "idx": 7328}
{"project": "qemu", "commit_id": "073de86aa934d46d596a2367e7501da5500e5b86", "target": 1, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     ppc_slb_t *slb, bool secondary,\n\n                                     target_ulong ptem, ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            unsigned pshift = hpte_page_shift(slb->sps, pte0, pte1);\n\n            /*\n\n             * If there is no match, ignore the PTE, it could simply\n\n             * be for a different segment size encoding and the\n\n             * architecture specifies we should not match. Linux will\n\n             * potentially leave behind PTEs for the wrong base page\n\n             * size when demoting segments.\n\n             */\n\n            if (pshift == 0) {\n\n                continue;\n\n            }\n\n            /* We don't do anything with pshift yet as qemu TLB only deals\n\n             * with 4K pages anyway\n\n             */\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(cpu, token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(cpu, token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 8205}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState *ssi_create_slave(SSIBus *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n    dev = qdev_create(&bus->qbus, name);\n\n    qdev_init(dev);\n\n    return dev;\n\n}\n", "idx": 2089}
{"project": "qemu", "commit_id": "6d74ca5aa83b83fb52332f7735c61ecb7a5328c1", "target": 1, "func": "static uint32_t virtio_ioport_read(VirtIOPCIProxy *proxy, uint32_t addr)\n\n{\n\n    VirtIODevice *vdev = proxy->vdev;\n\n    uint32_t ret = 0xFFFFFFFF;\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_HOST_FEATURES:\n\n        ret = vdev->get_features(vdev);\n\n        ret |= (1 << VIRTIO_F_NOTIFY_ON_EMPTY);\n\n        ret |= (1 << VIRTIO_RING_F_INDIRECT_DESC);\n\n        ret |= (1 << VIRTIO_F_BAD_FEATURE);\n\n        break;\n\n    case VIRTIO_PCI_GUEST_FEATURES:\n\n        ret = vdev->features;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_PFN:\n\n        ret = virtio_queue_get_addr(vdev, vdev->queue_sel)\n\n              >> VIRTIO_PCI_QUEUE_ADDR_SHIFT;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_NUM:\n\n        ret = virtio_queue_get_num(vdev, vdev->queue_sel);\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_SEL:\n\n        ret = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_STATUS:\n\n        ret = vdev->status;\n\n        break;\n\n    case VIRTIO_PCI_ISR:\n\n        /* reading from the ISR also clears it. */\n\n        ret = vdev->isr;\n\n        vdev->isr = 0;\n\n        qemu_set_irq(proxy->pci_dev.irq[0], 0);\n\n        break;\n\n    case VIRTIO_MSI_CONFIG_VECTOR:\n\n        ret = vdev->config_vector;\n\n        break;\n\n    case VIRTIO_MSI_QUEUE_VECTOR:\n\n        ret = virtio_queue_vector(vdev, vdev->queue_sel);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3361}
{"project": "qemu", "commit_id": "cba7054928b10a7fda57c64807451bbc9a31e42e", "target": 1, "func": "void cpu_exec_init(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    CPUState *some_cpu;\n\n    int cpu_index;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    cpu_list_lock();\n\n#endif\n\n    cpu_index = 0;\n\n    CPU_FOREACH(some_cpu) {\n\n        cpu_index++;\n\n    }\n\n    cpu->cpu_index = cpu_index;\n\n    cpu->numa_node = 0;\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n#ifndef CONFIG_USER_ONLY\n\n    cpu->as = &address_space_memory;\n\n    cpu->thread_id = qemu_get_thread_id();\n\n\n#endif\n\n    QTAILQ_INSERT_TAIL(&cpus, cpu, node);\n\n#if defined(CONFIG_USER_ONLY)\n\n    cpu_list_unlock();\n\n#endif\n\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n\n        vmstate_register(NULL, cpu_index, &vmstate_cpu_common, cpu);\n\n    }\n\n#if defined(CPU_SAVE_VERSION) && !defined(CONFIG_USER_ONLY)\n\n    register_savevm(NULL, \"cpu\", cpu_index, CPU_SAVE_VERSION,\n\n                    cpu_save, cpu_load, env);\n\n    assert(cc->vmsd == NULL);\n\n    assert(qdev_get_vmsd(DEVICE(cpu)) == NULL);\n\n#endif\n\n    if (cc->vmsd != NULL) {\n\n        vmstate_register(NULL, cpu_index, cc->vmsd, cpu);\n\n    }\n\n}", "idx": 1164}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "static bool memory_region_dispatch_write(MemoryRegion *mr,\n\n                                         hwaddr addr,\n\n                                         uint64_t data,\n\n                                         unsigned size)\n\n{\n\n    if (!memory_region_access_valid(mr, addr, size, true)) {\n\n        unassigned_mem_write(mr, addr, data, size);\n\n        return true;\n\n    }\n\n\n\n    adjust_endianness(mr, &data, size);\n\n\n\n    if (mr->ops->write) {\n\n        access_with_adjusted_size(addr, &data, size,\n\n                                  mr->ops->impl.min_access_size,\n\n                                  mr->ops->impl.max_access_size,\n\n                                  memory_region_write_accessor, mr);\n\n    } else {\n\n        access_with_adjusted_size(addr, &data, size, 1, 4,\n\n                                  memory_region_oldmmio_write_accessor, mr);\n\n    }\n\n    return false;\n\n}\n", "idx": 11677}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void *qpa_thread_in (void *arg)\n\n{\n\n    PAVoiceIn *pa = arg;\n\n    HWVoiceIn *hw = &pa->hw;\n\n\n\n    if (audio_pt_lock (&pa->pt, AUDIO_FUNC)) {\n\n        return NULL;\n\n    }\n\n\n\n    for (;;) {\n\n        int incr, to_grab, wpos;\n\n\n\n        for (;;) {\n\n            if (pa->done) {\n\n                goto exit;\n\n            }\n\n\n\n            if (pa->dead > 0) {\n\n                break;\n\n            }\n\n\n\n            if (audio_pt_wait (&pa->pt, AUDIO_FUNC)) {\n\n                goto exit;\n\n            }\n\n        }\n\n\n\n        incr = to_grab = audio_MIN (pa->dead, conf.samples >> 2);\n\n        wpos = pa->wpos;\n\n\n\n        if (audio_pt_unlock (&pa->pt, AUDIO_FUNC)) {\n\n            return NULL;\n\n        }\n\n\n\n        while (to_grab) {\n\n            int error;\n\n            int chunk = audio_MIN (to_grab, hw->samples - wpos);\n\n            void *buf = advance (pa->pcm_buf, wpos);\n\n\n\n            if (pa_simple_read (pa->s, buf,\n\n                                chunk << hw->info.shift, &error) < 0) {\n\n                qpa_logerr (error, \"pa_simple_read failed\\n\");\n\n                return NULL;\n\n            }\n\n\n\n            hw->conv (hw->conv_buf + wpos, buf, chunk);\n\n            wpos = (wpos + chunk) % hw->samples;\n\n            to_grab -= chunk;\n\n        }\n\n\n\n        if (audio_pt_lock (&pa->pt, AUDIO_FUNC)) {\n\n            return NULL;\n\n        }\n\n\n\n        pa->wpos = wpos;\n\n        pa->dead -= incr;\n\n        pa->incr += incr;\n\n    }\n\n\n\n exit:\n\n    audio_pt_unlock (&pa->pt, AUDIO_FUNC);\n\n    return NULL;\n\n}\n", "idx": 2411}
{"project": "qemu", "commit_id": "854e67fea6a6f181163a5467fc9ba04de8d181bb", "target": 1, "func": "void hmp_info_local_apic(Monitor *mon, const QDict *qdict)\n\n{\n\n    x86_cpu_dump_local_apic_state(mon_get_cpu(), (FILE *)mon, monitor_fprintf,\n\n                                  CPU_DUMP_FPU);\n\n}\n", "idx": 4432}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static QObject *qobject_input_get_object(QObjectInputVisitor *qiv,\n\n                                         const char *name,\n\n                                         bool consume, Error **errp)\n\n{\n\n    StackObject *tos;\n\n    QObject *qobj;\n\n    QObject *ret;\n\n\n\n    if (QSLIST_EMPTY(&qiv->stack)) {\n\n        /* Starting at root, name is ignored. */\n\n        assert(qiv->root);\n\n        return qiv->root;\n\n    }\n\n\n\n    /* We are in a container; find the next element. */\n\n    tos = QSLIST_FIRST(&qiv->stack);\n\n    qobj = tos->obj;\n\n    assert(qobj);\n\n\n\n    if (qobject_type(qobj) == QTYPE_QDICT) {\n\n        assert(name);\n\n        ret = qdict_get(qobject_to_qdict(qobj), name);\n\n        if (tos->h && consume && ret) {\n\n            bool removed = g_hash_table_remove(tos->h, name);\n\n            assert(removed);\n\n        }\n\n        if (!ret) {\n\n            error_setg(errp, QERR_MISSING_PARAMETER, name);\n\n        }\n\n    } else {\n\n        assert(qobject_type(qobj) == QTYPE_QLIST);\n\n        assert(!name);\n\n        ret = qlist_entry_obj(tos->entry);\n\n        assert(ret);\n\n        if (consume) {\n\n            tos->entry = qlist_next(tos->entry);\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11301}
{"project": "qemu", "commit_id": "e9a07334fb6ee08ddd61787c102d36e7e781efef", "target": 1, "func": "static void g364fb_screen_dump(void *opaque, const char *filename)\n{\n    G364State *s = opaque;\n    int y, x;\n    uint8_t index;\n    uint8_t *data_buffer;\n    FILE *f;\n    if (s->depth != 8) {\n        error_report(\"g364: unknown guest depth %d\", s->depth);\n        return;\n    }\n    f = fopen(filename, \"wb\");\n    if (!f)\n        return;\n    if (s->ctla & CTLA_FORCE_BLANK) {\n        /* blank screen */\n        fprintf(f, \"P4\\n%d %d\\n\",\n            s->width, s->height);\n        for (y = 0; y < s->height; y++)\n            for (x = 0; x < s->width; x++)\n                fputc(0, f);\n    } else {\n        data_buffer = s->vram + s->top_of_screen;\n        fprintf(f, \"P6\\n%d %d\\n%d\\n\",\n            s->width, s->height, 255);\n        for (y = 0; y < s->height; y++)\n            for (x = 0; x < s->width; x++, data_buffer++) {\n                index = *data_buffer;\n                fputc(s->color_palette[index][0], f);\n                fputc(s->color_palette[index][1], f);\n                fputc(s->color_palette[index][2], f);\n        }\n    }\n    fclose(f);\n}", "idx": 6640}
{"project": "qemu", "commit_id": "baa61b9870dd7e0bb07e0ae61c6ec805db13f699", "target": 1, "func": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_balloon_device_exit;\n\n    dc->props = virtio_balloon_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->init = virtio_balloon_device_init;\n\n    vdc->get_config = virtio_balloon_get_config;\n\n    vdc->set_config = virtio_balloon_set_config;\n\n    vdc->get_features = virtio_balloon_get_features;\n\n}\n", "idx": 282}
{"project": "qemu", "commit_id": "62a2554ec2630896d1299e1a282a64c7f3b00da0", "target": 1, "func": "void ccw_dstream_init(CcwDataStream *cds, CCW1 const *ccw, ORB const *orb)\n{\n    /*\n     * We don't support MIDA (an optional facility) yet and we\n     * catch this earlier. Just for expressing the precondition.\n     */\n    g_assert(!(orb->ctrl1 & ORB_CTRL1_MASK_MIDAW));\n    cds->flags = (orb->ctrl0 & ORB_CTRL0_MASK_I2K ? CDS_F_I2K : 0) |\n                 (orb->ctrl0 & ORB_CTRL0_MASK_C64 ? CDS_F_C64 : 0) |\n                 (ccw->flags & CCW_FLAG_IDA ? CDS_F_IDA : 0);\n    cds->count = ccw->count;\n    cds->cda_orig = ccw->cda;\n    ccw_dstream_rewind(cds);\n    if (!(cds->flags & CDS_F_IDA)) {\n        cds->op_handler = ccw_dstream_rw_noflags;\n    } else {\n        assert(false);\n    }\n}", "idx": 9112}
{"project": "qemu", "commit_id": "76f5159d7fc4cdea9574dfbb54307735b280bc66", "target": 1, "func": "static void msix_mmio_writel(void *opaque, target_phys_addr_t addr,\n\n                             uint32_t val)\n\n{\n\n    PCIDevice *dev = opaque;\n\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1);\n\n    int vector = offset / MSIX_ENTRY_SIZE;\n\n    memcpy(dev->msix_table_page + offset, &val, 4);\n\n    if (!msix_is_masked(dev, vector) && msix_is_pending(dev, vector)) {\n\n        msix_clr_pending(dev, vector);\n\n        msix_notify(dev, vector);\n\n    }\n\n}\n", "idx": 7576}
{"project": "qemu", "commit_id": "0a852417564bc59441dc09509beacf7b49bc1e57", "target": 1, "func": "bool trace_init_backends(void)\n{\n#ifdef CONFIG_TRACE_SIMPLE\n    if (!st_init()) {\n        fprintf(stderr, \"failed to initialize simple tracing backend.\\n\");\n        return false;\n    }\n#ifdef CONFIG_TRACE_FTRACE\n    if (!ftrace_init()) {\n        fprintf(stderr, \"failed to initialize ftrace backend.\\n\");\n        return false;\n    }\n    return true;\n}", "idx": 11273}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_dsdt(GArray *table_data, BIOSLinker *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           Range *pci_hole, Range *pci_hole64, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    CrsRangeSet crs_range_set;\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    if (pcmc->legacy_cpu_hotplug) {\n\n        build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    } else {\n\n        CPUHotplugFeatures opts = {\n\n            .apci_1_compatible = true, .has_legacy_cphp = true\n\n        };\n\n        build_cpus_aml(dsdt, machine, opts, pm->cpu_hp_io_base,\n\n                       \"\\\\_SB.PCI0\", \"\\\\_GPE._E02\");\n\n    }\n\n    build_memory_hotplug_aml(dsdt, nr_mem, \"\\\\_SB.PCI0\", \"\\\\_GPE._E03\");\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        if (pcms->acpi_nvdimm_state.is_enabled) {\n\n            method = aml_method(\"_E04\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method, aml_notify(aml_name(\"\\\\_SB.NVDR\"),\n\n                                          aml_int(0x80)));\n\n            aml_append(scope, method);\n\n        }\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    crs_range_set_init(&crs_range_set);\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n            if (pci_bus_is_express(bus)) {\n\n                aml_append(dev, build_q35_osc_method());\n\n            }\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent), &crs_range_set);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(crs_range_set.io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < crs_range_set.io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(crs_range_set.io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(crs_range_set.mem_ranges,\n\n                                 range_lob(pci_hole),\n\n                                 range_upb(pci_hole));\n\n    for (i = 0; i < crs_range_set.mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(crs_range_set.mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (!range_is_empty(pci_hole64)) {\n\n        crs_replace_with_free_ranges(crs_range_set.mem_64bit_ranges,\n\n                                     range_lob(pci_hole64),\n\n                                     range_upb(pci_hole64));\n\n        for (i = 0; i < crs_range_set.mem_64bit_ranges->len; i++) {\n\n            entry = g_ptr_array_index(crs_range_set.mem_64bit_ranges, i);\n\n            aml_append(crs,\n\n                       aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED,\n\n                                        AML_MAX_FIXED,\n\n                                        AML_CACHEABLE, AML_READ_WRITE,\n\n                                        0, entry->base, entry->limit,\n\n                                        0, entry->limit - entry->base + 1));\n\n        }\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    crs_range_set_free(&crs_range_set);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        Object *pci_host;\n\n        PCIBus *bus = NULL;\n\n\n\n        pci_host = acpi_get_i386_pci_host();\n\n        if (pci_host) {\n\n            bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n        }\n\n\n\n        if (bus) {\n\n            Aml *scope = aml_scope(\"PCI0\");\n\n            /* Scan all PCI buses. Generate tables to support hotplug. */\n\n            build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n            if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                dev = aml_device(\"ISA.TPM\");\n\n                aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                crs = aml_resource_template();\n\n                aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                           TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                /*\n\n                    FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                    Rewrite to take IRQ from TPM device model and\n\n                    fix default IRQ value there to use some unused IRQ\n\n                 */\n\n                /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                aml_append(scope, dev);\n\n            }\n\n\n\n            aml_append(sb_scope, scope);\n\n        }\n\n    }\n\n    aml_append(dsdt, sb_scope);\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 7414}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static int ioh3420_initfn(PCIDevice *d)\n\n{\n\n    PCIEPort *p = PCIE_PORT(d);\n\n    PCIESlot *s = PCIE_SLOT(d);\n\n    int rc;\n\n\n\n    pci_bridge_initfn(d, TYPE_PCIE_BUS);\n\n    pcie_port_init_reg(d);\n\n\n\n    rc = pci_bridge_ssvid_init(d, IOH_EP_SSVID_OFFSET,\n\n                               IOH_EP_SSVID_SVID, IOH_EP_SSVID_SSID);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = msi_init(d, IOH_EP_MSI_OFFSET, IOH_EP_MSI_NR_VECTOR,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_64BIT,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_MASKBIT);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = pcie_cap_init(d, IOH_EP_EXP_OFFSET, PCI_EXP_TYPE_ROOT_PORT, p->port);\n\n    if (rc < 0) {\n\n        goto err_msi;\n\n    }\n\n\n\n    pcie_cap_arifwd_init(d);\n\n    pcie_cap_deverr_init(d);\n\n    pcie_cap_slot_init(d, s->slot);\n\n    pcie_cap_root_init(d);\n\n\n\n    pcie_chassis_create(s->chassis);\n\n    rc = pcie_chassis_add_slot(s);\n\n    if (rc < 0) {\n\n        goto err_pcie_cap;\n\n    }\n\n\n\n    rc = pcie_aer_init(d, IOH_EP_AER_OFFSET, PCI_ERR_SIZEOF);\n\n    if (rc < 0) {\n\n        goto err;\n\n    }\n\n    pcie_aer_root_init(d);\n\n    ioh3420_aer_vector_update(d);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    pcie_chassis_del_slot(s);\n\nerr_pcie_cap:\n\n    pcie_cap_exit(d);\n\nerr_msi:\n\n    msi_uninit(d);\n\nerr_bridge:\n\n    pci_bridge_exitfn(d);\n\n    return rc;\n\n}\n", "idx": 7704}
{"project": "qemu", "commit_id": "ef4760626e88bc3e7a1b46c7370378cbd12d379f", "target": 1, "func": "static uint16_t eepro100_read2(EEPRO100State * s, uint32_t addr)\n\n{\n\n    uint16_t val;\n\n    if (addr <= sizeof(s->mem) - sizeof(val)) {\n\n        memcpy(&val, &s->mem[addr], sizeof(val));\n\n    }\n\n\n\n    switch (addr) {\n\n    case SCBStatus:\n\n    case SCBCmd:\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%04x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBeeprom:\n\n        val = eepro100_read_eeprom(s);\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%04x\\n\", regname(addr), val));\n\n        break;\n\n    default:\n\n        logout(\"addr=%s val=0x%04x\\n\", regname(addr), val);\n\n        missing(\"unknown word read\");\n\n    }\n\n    return val;\n\n}\n", "idx": 6027}
{"project": "qemu", "commit_id": "d7b7e580096255c766f7b1e7502a9151b95091e8", "target": 1, "func": "static int send_dma_request(int cmd, uint64_t sector, int nb_sectors,\n                            PrdtEntry *prdt, int prdt_entries)\n{\n    QPCIDevice *dev;\n    uint16_t bmdma_base;\n    uintptr_t guest_prdt;\n    size_t len;\n    bool from_dev;\n    uint8_t status;\n    int flags;\n    dev = get_pci_device(&bmdma_base);\n    flags = cmd & ~0xff;\n    cmd &= 0xff;\n    switch (cmd) {\n    case CMD_READ_DMA:\n        from_dev = true;\n        break;\n    case CMD_WRITE_DMA:\n        from_dev = false;\n        break;\n    default:\n        g_assert_not_reached();\n    /* Select device 0 */\n    outb(IDE_BASE + reg_device, 0 | LBA);\n    /* Stop any running transfer, clear any pending interrupt */\n    outb(bmdma_base + bmreg_cmd, 0);\n    outb(bmdma_base + bmreg_status, BM_STS_INTR);\n    /* Setup PRDT */\n    len = sizeof(*prdt) * prdt_entries;\n    guest_prdt = guest_alloc(guest_malloc, len);\n    memwrite(guest_prdt, prdt, len);\n    outl(bmdma_base + bmreg_prdt, guest_prdt);\n    /* ATA DMA command */\n    outb(IDE_BASE + reg_nsectors, nb_sectors);\n    outb(IDE_BASE + reg_lba_low,    sector & 0xff);\n    outb(IDE_BASE + reg_lba_middle, (sector >> 8) & 0xff);\n    outb(IDE_BASE + reg_lba_high,   (sector >> 16) & 0xff);\n    outb(IDE_BASE + reg_command, cmd);\n    /* Start DMA transfer */\n    outb(bmdma_base + bmreg_cmd, BM_CMD_START | (from_dev ? BM_CMD_WRITE : 0));\n    if (flags & CMDF_ABORT) {\n        outb(bmdma_base + bmreg_cmd, 0);\n    /* Wait for the DMA transfer to complete */\n    do {\n        status = inb(bmdma_base + bmreg_status);\n    } while ((status & (BM_STS_ACTIVE | BM_STS_INTR)) == BM_STS_ACTIVE);\n    g_assert_cmpint(get_irq(IDE_PRIMARY_IRQ), ==, !!(status & BM_STS_INTR));\n    /* Check IDE status code */\n    assert_bit_set(inb(IDE_BASE + reg_status), DRDY);\n    assert_bit_clear(inb(IDE_BASE + reg_status), BSY | DRQ);\n    /* Reading the status register clears the IRQ */\n    g_assert(!get_irq(IDE_PRIMARY_IRQ));\n    /* Stop DMA transfer if still active */\n    if (status & BM_STS_ACTIVE) {\n        outb(bmdma_base + bmreg_cmd, 0);\n    free_pci_device(dev);\n    return status;", "idx": 11167}
{"project": "qemu", "commit_id": "6bdcc018a6ed760b9dfe43539124e420aed83092", "target": 1, "func": "static void nbd_coroutine_start(NBDClientSession *s,\n\n                                NBDRequest *request)\n\n{\n\n    /* Poor man semaphore.  The free_sema is locked when no other request\n\n     * can be accepted, and unlocked after receiving one reply.  */\n\n    if (s->in_flight == MAX_NBD_REQUESTS) {\n\n        qemu_co_queue_wait(&s->free_sema, NULL);\n\n        assert(s->in_flight < MAX_NBD_REQUESTS);\n\n    }\n\n    s->in_flight++;\n\n\n\n    /* s->recv_coroutine[i] is set as soon as we get the send_lock.  */\n\n}\n", "idx": 11821}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void amdvi_class_init(ObjectClass *klass, void* data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    X86IOMMUClass *dc_class = X86_IOMMU_CLASS(klass);\n\n\n\n    dc->reset = amdvi_reset;\n\n    dc->vmsd = &vmstate_amdvi;\n\n    dc->hotpluggable = false;\n\n    dc_class->realize = amdvi_realize;\n\n\n\n\n\n\n}", "idx": 3076}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void moxiesim_init(MachineState *machine)\n\n{\n\n    MoxieCPU *cpu = NULL;\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUMoxieState *env;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    hwaddr ram_base = 0x200000;\n\n    LoaderParams loader_params;\n\n\n\n    /* Init CPUs. */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"MoxieLite-moxie-cpu\";\n\n    }\n\n    cpu = MOXIE_CPU(cpu_generic_init(TYPE_MOXIE_CPU, cpu_model));\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n\n\n    /* Allocate RAM. */\n\n    memory_region_init_ram(ram, NULL, \"moxiesim.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, ram_base, ram);\n\n\n\n    memory_region_init_ram(rom, NULL, \"moxie.rom\", 128 * 0x1000, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0x1000, rom);\n\n\n\n    if (kernel_filename) {\n\n        loader_params.ram_size = ram_size;\n\n        loader_params.kernel_filename = kernel_filename;\n\n        loader_params.kernel_cmdline = kernel_cmdline;\n\n        loader_params.initrd_filename = initrd_filename;\n\n        load_kernel(cpu, &loader_params);\n\n    }\n\n\n\n    /* A single 16450 sits at offset 0x3f8.  */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(address_space_mem, 0x3f8, 0, env->irq[4],\n\n                       8000000/16, serial_hds[0], DEVICE_LITTLE_ENDIAN);\n\n    }\n\n}\n", "idx": 3899}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "static int restore_sigcontext(CPUAlphaState *env,\n\n                              struct target_sigcontext *sc)\n\n{\n\n    uint64_t fpcr;\n\n    int i, err = 0;\n\n\n\n    __get_user(env->pc, &sc->sc_pc);\n\n\n\n    for (i = 0; i < 31; ++i) {\n\n        __get_user(env->ir[i], &sc->sc_regs[i]);\n\n    }\n\n    for (i = 0; i < 31; ++i) {\n\n        __get_user(env->fir[i], &sc->sc_fpregs[i]);\n\n    }\n\n\n\n    __get_user(fpcr, &sc->sc_fpcr);\n\n    cpu_alpha_store_fpcr(env, fpcr);\n\n\n\n    return err;\n\n}\n", "idx": 9909}
{"project": "qemu", "commit_id": "e92f0e1910f0655a0edd8d87c5a7262d36517a89", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_prw_vector(BdrvChild *child,\n\n                                          int64_t offset,\n\n                                          QEMUIOVector *qiov,\n\n                                          BdrvRequestFlags flags,\n\n                                          BlockCompletionFunc *cb,\n\n                                          void *opaque,\n\n                                          bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    /* Matched by bdrv_co_complete's bdrv_dec_in_flight.  */\n\n    bdrv_inc_in_flight(child->bs);\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.offset = offset;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw, acb);\n\n    qemu_coroutine_enter(co);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 8246}
{"project": "qemu", "commit_id": "78f27bd02ceba4a2f6ac5c725f4d4410eec205ef", "target": 1, "func": "static int enable_write_target(BDRVVVFATState *s)\n\n{\n\n    BlockDriver *bdrv_qcow;\n\n    QEMUOptionParameter *options;\n\n    int ret;\n\n    int size = sector2cluster(s, s->sector_count);\n\n    s->used_clusters = calloc(size, 1);\n\n\n\n    array_init(&(s->commits), sizeof(commit_t));\n\n\n\n    s->qcow_filename = g_malloc(1024);\n\n    ret = get_tmp_filename(s->qcow_filename, 1024);\n\n    if (ret < 0) {\n\n        g_free(s->qcow_filename);\n\n        s->qcow_filename = NULL;\n\n        return ret;\n\n    }\n\n\n\n    bdrv_qcow = bdrv_find_format(\"qcow\");\n\n    options = parse_option_parameters(\"\", bdrv_qcow->create_options, NULL);\n\n    set_option_parameter_int(options, BLOCK_OPT_SIZE, s->sector_count * 512);\n\n    set_option_parameter(options, BLOCK_OPT_BACKING_FILE, \"fat:\");\n\n\n\n    if (bdrv_create(bdrv_qcow, s->qcow_filename, options) < 0)\n\n\treturn -1;\n\n\n\n    s->qcow = bdrv_new(\"\");\n\n    if (s->qcow == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    ret = bdrv_open(s->qcow, s->qcow_filename, NULL,\n\n            BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, bdrv_qcow);\n\n    if (ret < 0) {\n\n\treturn ret;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    unlink(s->qcow_filename);\n\n#endif\n\n\n\n    s->bs->backing_hd = calloc(sizeof(BlockDriverState), 1);\n\n    s->bs->backing_hd->drv = &vvfat_write_target;\n\n    s->bs->backing_hd->opaque = g_malloc(sizeof(void*));\n\n    *(void**)s->bs->backing_hd->opaque = s;\n\n\n\n    return 0;\n\n}\n", "idx": 5789}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void *qpci_iomap(QPCIDevice *dev, int barno, uint64_t *sizeptr)\n\n{\n\n    QPCIBus *bus = dev->bus;\n\n    static const int bar_reg_map[] = {\n\n        PCI_BASE_ADDRESS_0, PCI_BASE_ADDRESS_1, PCI_BASE_ADDRESS_2,\n\n        PCI_BASE_ADDRESS_3, PCI_BASE_ADDRESS_4, PCI_BASE_ADDRESS_5,\n\n    };\n\n    int bar_reg;\n\n    uint32_t addr, size;\n\n    uint32_t io_type;\n\n    uint64_t loc;\n\n\n\n    g_assert(barno >= 0 && barno <= 5);\n\n    bar_reg = bar_reg_map[barno];\n\n\n\n    qpci_config_writel(dev, bar_reg, 0xFFFFFFFF);\n\n    addr = qpci_config_readl(dev, bar_reg);\n\n\n\n    io_type = addr & PCI_BASE_ADDRESS_SPACE;\n\n    if (io_type == PCI_BASE_ADDRESS_SPACE_IO) {\n\n        addr &= PCI_BASE_ADDRESS_IO_MASK;\n\n    } else {\n\n        addr &= PCI_BASE_ADDRESS_MEM_MASK;\n\n    }\n\n\n\n    g_assert(addr); /* Must have *some* size bits */\n\n\n\n    size = 1U << ctz32(addr);\n\n    if (sizeptr) {\n\n        *sizeptr = size;\n\n    }\n\n\n\n    if (io_type == PCI_BASE_ADDRESS_SPACE_IO) {\n\n        loc = QEMU_ALIGN_UP(bus->pio_alloc_ptr, size);\n\n\n\n        g_assert(loc >= bus->pio_alloc_ptr);\n\n        g_assert(loc + size <= QPCI_PIO_LIMIT); /* Keep PIO below 64kiB */\n\n\n\n        bus->pio_alloc_ptr = loc + size;\n\n\n\n        qpci_config_writel(dev, bar_reg, loc | PCI_BASE_ADDRESS_SPACE_IO);\n\n    } else {\n\n        loc = QEMU_ALIGN_UP(bus->mmio_alloc_ptr, size);\n\n\n\n        /* Check for space */\n\n        g_assert(loc >= bus->mmio_alloc_ptr);\n\n        g_assert(loc + size <= bus->mmio_limit);\n\n\n\n        bus->mmio_alloc_ptr = loc + size;\n\n\n\n        qpci_config_writel(dev, bar_reg, loc);\n\n    }\n\n\n\n    return (void *)(uintptr_t)loc;\n\n}\n", "idx": 3107}
{"project": "qemu", "commit_id": "f9aef99b3e6df88036436b0d3dc3d504b9346c8c", "target": 1, "func": "static void local_mapped_file_attr(FsContext *ctx, const char *path,\n\n                                   struct stat *stbuf)\n\n{\n\n    FILE *fp;\n\n    char buf[ATTR_MAX];\n\n    char *attr_path;\n\n\n\n    attr_path = local_mapped_attr_path(ctx, path);\n\n    fp = local_fopen(attr_path, \"r\");\n\n    g_free(attr_path);\n\n    if (!fp) {\n\n        return;\n\n    }\n\n    memset(buf, 0, ATTR_MAX);\n\n    while (fgets(buf, ATTR_MAX, fp)) {\n\n        if (!strncmp(buf, \"virtfs.uid\", 10)) {\n\n            stbuf->st_uid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.gid\", 10)) {\n\n            stbuf->st_gid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.mode\", 11)) {\n\n            stbuf->st_mode = atoi(buf+12);\n\n        } else if (!strncmp(buf, \"virtfs.rdev\", 11)) {\n\n            stbuf->st_rdev = atoi(buf+12);\n\n        }\n\n        memset(buf, 0, ATTR_MAX);\n\n    }\n\n    fclose(fp);\n\n}\n", "idx": 8478}
{"project": "qemu", "commit_id": "07e95cd529af345fdeea230913f68eff5b925bb6", "target": 1, "func": "static int qio_channel_websock_handshake_process(QIOChannelWebsock *ioc,\n\n                                                 const char *line,\n\n                                                 size_t size,\n\n                                                 Error **errp)\n\n{\n\n    int ret = -1;\n\n    char *protocols = qio_channel_websock_handshake_entry(\n\n        line, size, QIO_CHANNEL_WEBSOCK_HEADER_PROTOCOL);\n\n    char *version = qio_channel_websock_handshake_entry(\n\n        line, size, QIO_CHANNEL_WEBSOCK_HEADER_VERSION);\n\n    char *key = qio_channel_websock_handshake_entry(\n\n        line, size, QIO_CHANNEL_WEBSOCK_HEADER_KEY);\n\n\n\n    if (!protocols) {\n\n        error_setg(errp, \"Missing websocket protocol header data\");\n\n        goto cleanup;\n\n    }\n\n\n\n    if (!version) {\n\n        error_setg(errp, \"Missing websocket version header data\");\n\n        goto cleanup;\n\n    }\n\n\n\n    if (!key) {\n\n        error_setg(errp, \"Missing websocket key header data\");\n\n        goto cleanup;\n\n    }\n\n\n\n    if (!g_strrstr(protocols, QIO_CHANNEL_WEBSOCK_PROTOCOL_BINARY)) {\n\n        error_setg(errp, \"No '%s' protocol is supported by client '%s'\",\n\n                   QIO_CHANNEL_WEBSOCK_PROTOCOL_BINARY, protocols);\n\n        goto cleanup;\n\n    }\n\n\n\n    if (!g_str_equal(version, QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION)) {\n\n        error_setg(errp, \"Version '%s' is not supported by client '%s'\",\n\n                   QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION, version);\n\n        goto cleanup;\n\n    }\n\n\n\n    if (strlen(key) != QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN) {\n\n        error_setg(errp, \"Key length '%zu' was not as expected '%d'\",\n\n                   strlen(key), QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN);\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = qio_channel_websock_handshake_send_response(ioc, key, errp);\n\n\n\n cleanup:\n\n    g_free(protocols);\n\n    g_free(version);\n\n    g_free(key);\n\n    return ret;\n\n}\n", "idx": 3380}
{"project": "qemu", "commit_id": "857d4f46c31d2f4d57d2f0fad9dfb584262bf9b9", "target": 1, "func": "static void bdrv_aio_bh_cb(void *opaque)\n\n{\n\n    BlockDriverAIOCBSync *acb = opaque;\n\n\n\n    if (!acb->is_write)\n\n        qemu_iovec_from_buf(acb->qiov, 0, acb->bounce, acb->qiov->size);\n\n    qemu_vfree(acb->bounce);\n\n    acb->common.cb(acb->common.opaque, acb->ret);\n\n    qemu_bh_delete(acb->bh);\n\n    acb->bh = NULL;\n\n    qemu_aio_release(acb);\n\n}\n", "idx": 8829}
{"project": "qemu", "commit_id": "d63fb193e71644a073b77ff5ac6f1216f2f6cf6e", "target": 1, "func": "static void coroutine_fn v9fs_lcreate(void *opaque)\n\n{\n\n    int32_t dfid, flags, mode;\n\n    gid_t gid;\n\n    ssize_t err = 0;\n\n    ssize_t offset = 7;\n\n    V9fsString name;\n\n    V9fsFidState *fidp;\n\n    struct stat stbuf;\n\n    V9fsQID qid;\n\n    int32_t iounit;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    v9fs_string_init(&name);\n\n    err = pdu_unmarshal(pdu, offset, \"dsddd\", &dfid,\n\n                        &name, &flags, &mode, &gid);\n\n    if (err < 0) {\n\n        goto out_nofid;\n\n\n    trace_v9fs_lcreate(pdu->tag, pdu->id, dfid, flags, mode, gid);\n\n\n\n    if (name_is_illegal(name.data)) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n\n\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n\n        err = -EEXIST;\n\n        goto out_nofid;\n\n\n\n\n    fidp = get_fid(pdu, dfid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n\n\n\n\n\n\n\n    flags = get_dotl_openflags(pdu->s, flags);\n\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n\n                        flags | O_CREAT, mode, &stbuf);\n\n    if (err < 0) {\n\n\n\n    fidp->fid_type = P9_FID_FILE;\n\n    fidp->open_flags = flags;\n\n    if (flags & O_EXCL) {\n\n        /*\n\n         * We let the host file system do O_EXCL check\n\n         * We should not reclaim such fd\n\n         */\n\n        fidp->flags |= FID_NON_RECLAIMABLE;\n\n\n    iounit =  get_iounit(pdu, &fidp->path);\n\n    stat_to_qid(&stbuf, &qid);\n\n    err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n    if (err < 0) {\n\n\n\n    err += offset;\n\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n\n                              qid.type, qid.version, qid.path, iounit);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    pdu_complete(pdu, err);\n\n    v9fs_string_free(&name);\n", "idx": 1875}
{"project": "qemu", "commit_id": "49aa4058ac6dd0081aaa45776f07c98df397ca5e", "target": 1, "func": "QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n\n{\n\n    char host[65], port[33], width[8], height[8];\n\n    int pos;\n\n    const char *p;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n\n\n    opts = qemu_opts_create(qemu_find_opts(\"chardev\"), label, 1, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        return NULL;\n\n    }\n\n\n\n    if (strstart(filename, \"mon:\", &p)) {\n\n        filename = p;\n\n        qemu_opt_set(opts, \"mux\", \"on\");\n\n        if (strcmp(filename, \"stdio\") == 0) {\n\n            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default\n\n             * but pass it to the guest.  Handle this only for compat syntax,\n\n             * for -chardev syntax we have special option for this.\n\n             * This is what -nographic did, redirecting+muxing serial+monitor\n\n             * to stdio causing Ctrl+C to be passed to guest. */\n\n            qemu_opt_set(opts, \"signal\", \"off\");\n\n        }\n\n    }\n\n\n\n    if (strcmp(filename, \"null\")    == 0 ||\n\n        strcmp(filename, \"pty\")     == 0 ||\n\n        strcmp(filename, \"msmouse\") == 0 ||\n\n        strcmp(filename, \"braille\") == 0 ||\n\n        strcmp(filename, \"stdio\")   == 0) {\n\n        qemu_opt_set(opts, \"backend\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"vc\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"vc\");\n\n        if (*p == ':') {\n\n            if (sscanf(p+1, \"%8[0-9]x%8[0-9]\", width, height) == 2) {\n\n                /* pixels */\n\n                qemu_opt_set(opts, \"width\", width);\n\n                qemu_opt_set(opts, \"height\", height);\n\n            } else if (sscanf(p+1, \"%8[0-9]Cx%8[0-9]C\", width, height) == 2) {\n\n                /* chars */\n\n                qemu_opt_set(opts, \"cols\", width);\n\n                qemu_opt_set(opts, \"rows\", height);\n\n            } else {\n\n                goto fail;\n\n            }\n\n        }\n\n        return opts;\n\n    }\n\n    if (strcmp(filename, \"con:\") == 0) {\n\n        qemu_opt_set(opts, \"backend\", \"console\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"COM\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"serial\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"file:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"file\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"pipe:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"pipe\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"tcp:\", &p) ||\n\n        strstart(filename, \"telnet:\", &p)) {\n\n        if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1)\n\n                goto fail;\n\n        }\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == ',') {\n\n            if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n\n                goto fail;\n\n        }\n\n        if (strstart(filename, \"telnet:\", &p))\n\n            qemu_opt_set(opts, \"telnet\", \"on\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"udp:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"udp\");\n\n        if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) {\n\n                goto fail;\n\n            }\n\n        }\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == '@') {\n\n            p += pos + 1;\n\n            if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n                host[0] = 0;\n\n                if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) {\n\n                    goto fail;\n\n                }\n\n            }\n\n            qemu_opt_set(opts, \"localaddr\", host);\n\n            qemu_opt_set(opts, \"localport\", port);\n\n        }\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"unix:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        if (qemu_opts_do_parse(opts, p, \"path\") != 0)\n\n            goto fail;\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/parport\", NULL) ||\n\n        strstart(filename, \"/dev/ppi\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"parport\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"tty\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 9863}
{"project": "qemu", "commit_id": "b308c82cbda44e138ef990af64d44a5613c16092", "target": 1, "func": "static void pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIBus *parent = br->dev.bus;\n\n    uint16_t cmd = pci_get_word(br->dev.config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &br->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &br->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &br->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n   /* TODO: optinal VGA and VGA palette snooping support. */\n\n}\n", "idx": 5970}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_POWER_abso (void)\n\n{\n\n    if (T0 == INT32_MIN) {\n\n        T0 = INT32_MAX;\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    } else {\n\n        T0 = -T0;\n\n        xer_ov = 0;\n\n    }\n\n}\n", "idx": 6384}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_check_struct(Visitor *v, Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && !tos->entry);\n\n    if (qiv->strict) {\n\n        GHashTable *const top_ht = tos->h;\n\n        if (top_ht) {\n\n            GHashTableIter iter;\n\n            const char *key;\n\n\n\n            g_hash_table_iter_init(&iter, top_ht);\n\n            if (g_hash_table_iter_next(&iter, (void **)&key, NULL)) {\n\n                error_setg(errp, \"Parameter '%s' is unexpected\", key);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 6874}
{"project": "qemu", "commit_id": "41b5e892b7dbf553b356b51004a6966233e71a6d", "target": 1, "func": "static int print_drive(DeviceState *dev, Property *prop, char *dest, size_t len)\n\n{\n\n    DriveInfo **ptr = qdev_get_prop_ptr(dev, prop);\n\n    return snprintf(dest, len, \"%s\", (*ptr)->id);\n\n}\n", "idx": 2388}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void migrate_set_state(MigrationState *s, int old_state, int new_state)\n\n{\n\n    if (atomic_cmpxchg(&s->state, old_state, new_state) == new_state) {\n\n        trace_migrate_set_state(new_state);\n\n    }\n\n}\n", "idx": 7074}
{"project": "qemu", "commit_id": "59c9f437c59a4bf0594ed300d28fb24c645963a5", "target": 1, "func": "static bool run_poll_handlers_once(AioContext *ctx)\n\n{\n\n    bool progress = false;\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n            progress = true;\n\n        }\n\n\n\n        /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n    }\n\n\n\n    return progress;\n\n}\n", "idx": 8764}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void nbd_read(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n\n\n    if (client->recv_coroutine) {\n\n        qemu_coroutine_enter(client->recv_coroutine, NULL);\n\n    } else {\n\n        qemu_coroutine_enter(qemu_coroutine_create(nbd_trip), client);\n\n    }\n\n}\n", "idx": 12193}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmp)\n\n{\n\n    if (Ts0 < Ts1) {\n\n        T0 = 0x08;\n\n    } else if (Ts0 > Ts1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 3233}
{"project": "qemu", "commit_id": "874adf45dbfbae2810423527d777ba37bc5ca974", "target": 1, "func": "int virtio_load(VirtIODevice *vdev, QEMUFile *f, int version_id)\n\n{\n\n    int i, ret;\n\n    int32_t config_len;\n\n    uint32_t num;\n\n    uint32_t features;\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n\n\n    /*\n\n     * We poison the endianness to ensure it does not get used before\n\n     * subsections have been loaded.\n\n     */\n\n    vdev->device_endian = VIRTIO_DEVICE_ENDIAN_UNKNOWN;\n\n\n\n    if (k->load_config) {\n\n        ret = k->load_config(qbus->parent, f);\n\n        if (ret)\n\n            return ret;\n\n    }\n\n\n\n    qemu_get_8s(f, &vdev->status);\n\n    qemu_get_8s(f, &vdev->isr);\n\n    qemu_get_be16s(f, &vdev->queue_sel);\n\n    if (vdev->queue_sel >= VIRTIO_QUEUE_MAX) {\n\n        return -1;\n\n    }\n\n    qemu_get_be32s(f, &features);\n\n\n\n    /*\n\n     * Temporarily set guest_features low bits - needed by\n\n     * virtio net load code testing for VIRTIO_NET_F_CTRL_GUEST_OFFLOADS\n\n     * VIRTIO_NET_F_GUEST_ANNOUNCE and VIRTIO_NET_F_CTRL_VQ.\n\n     *\n\n     * Note: devices should always test host features in future - don't create\n\n     * new dependencies like this.\n\n     */\n\n    vdev->guest_features = features;\n\n\n\n    config_len = qemu_get_be32(f);\n\n\n\n    /*\n\n     * There are cases where the incoming config can be bigger or smaller\n\n     * than what we have; so load what we have space for, and skip\n\n     * any excess that's in the stream.\n\n     */\n\n    qemu_get_buffer(f, vdev->config, MIN(config_len, vdev->config_len));\n\n\n\n    while (config_len > vdev->config_len) {\n\n        qemu_get_byte(f);\n\n        config_len--;\n\n    }\n\n\n\n    num = qemu_get_be32(f);\n\n\n\n    if (num > VIRTIO_QUEUE_MAX) {\n\n        error_report(\"Invalid number of virtqueues: 0x%x\", num);\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < num; i++) {\n\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n\n        if (k->has_variable_vring_alignment) {\n\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n\n        }\n\n        vdev->vq[i].vring.desc = qemu_get_be64(f);\n\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n\n        vdev->vq[i].signalled_used_valid = false;\n\n        vdev->vq[i].notification = true;\n\n\n\n        if (vdev->vq[i].vring.desc) {\n\n            /* XXX virtio-1 devices */\n\n            virtio_queue_update_rings(vdev, i);\n\n        } else if (vdev->vq[i].last_avail_idx) {\n\n            error_report(\"VQ %d address 0x0 \"\n\n                         \"inconsistent with Host index 0x%x\",\n\n                         i, vdev->vq[i].last_avail_idx);\n\n                return -1;\n\n        }\n\n        if (k->load_queue) {\n\n            ret = k->load_queue(qbus->parent, i, f);\n\n            if (ret)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n\n\n\n    if (vdc->load != NULL) {\n\n        ret = vdc->load(vdev, f, version_id);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (vdc->vmsd) {\n\n        ret = vmstate_load_state(f, vdc->vmsd, vdev, version_id);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Subsections */\n\n    ret = vmstate_load_state(f, &vmstate_virtio, vdev, 1);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (vdev->device_endian == VIRTIO_DEVICE_ENDIAN_UNKNOWN) {\n\n        vdev->device_endian = virtio_default_endian();\n\n    }\n\n\n\n    if (virtio_64bit_features_needed(vdev)) {\n\n        /*\n\n         * Subsection load filled vdev->guest_features.  Run them\n\n         * through virtio_set_features to sanity-check them against\n\n         * host_features.\n\n         */\n\n        uint64_t features64 = vdev->guest_features;\n\n        if (virtio_set_features_nocheck(vdev, features64) < 0) {\n\n            error_report(\"Features 0x%\" PRIx64 \" unsupported. \"\n\n                         \"Allowed features: 0x%\" PRIx64,\n\n                         features64, vdev->host_features);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (virtio_set_features_nocheck(vdev, features) < 0) {\n\n            error_report(\"Features 0x%x unsupported. \"\n\n                         \"Allowed features: 0x%\" PRIx64,\n\n                         features, vdev->host_features);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    rcu_read_lock();\n\n    for (i = 0; i < num; i++) {\n\n        if (vdev->vq[i].vring.desc) {\n\n            uint16_t nheads;\n\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n\n            /* Check it isn't doing strange things with descriptor numbers. */\n\n            if (nheads > vdev->vq[i].vring.num) {\n\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n\n                             i, vdev->vq[i].vring.num,\n\n                             vring_avail_idx(&vdev->vq[i]),\n\n                             vdev->vq[i].last_avail_idx, nheads);\n\n                return -1;\n\n            }\n\n            vdev->vq[i].used_idx = vring_used_idx(&vdev->vq[i]);\n\n            vdev->vq[i].shadow_avail_idx = vring_avail_idx(&vdev->vq[i]);\n\n\n\n            /*\n\n             * Some devices migrate VirtQueueElements that have been popped\n\n             * from the avail ring but not yet returned to the used ring.\n\n             * Since max ring size < UINT16_MAX it's safe to use modulo\n\n             * UINT16_MAX + 1 subtraction.\n\n             */\n\n            vdev->vq[i].inuse = (uint16_t)(vdev->vq[i].last_avail_idx -\n\n                                vdev->vq[i].used_idx);\n\n            if (vdev->vq[i].inuse > vdev->vq[i].vring.num) {\n\n                error_report(\"VQ %d size 0x%x < last_avail_idx 0x%x - \"\n\n                             \"used_idx 0x%x\",\n\n                             i, vdev->vq[i].vring.num,\n\n                             vdev->vq[i].last_avail_idx,\n\n                             vdev->vq[i].used_idx);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 8843}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_reg_control(RDMAContext *rdma, int idx)\n\n{\n\n    rdma->wr_data[idx].control_mr = ibv_reg_mr(rdma->pd,\n\n            rdma->wr_data[idx].control, RDMA_CONTROL_MAX_BUFFER,\n\n            IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE);\n\n    if (rdma->wr_data[idx].control_mr) {\n\n        rdma->total_registrations++;\n\n        return 0;\n\n    }\n\n    fprintf(stderr, \"qemu_rdma_reg_control failed!\\n\");\n\n    return -1;\n\n}\n", "idx": 104}
{"project": "qemu", "commit_id": "8f2ad0a3fc5e3569183d44bf1c7fcb95294be4c0", "target": 1, "func": "static void ecc_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    ECCState *s = opaque;\n\n\n\n    switch (addr & ECC_ADDR_MASK) {\n\n    case ECC_MER:\n\n        s->regs[0] = (s->regs[0] & (ECC_MER_VER | ECC_MER_IMPL)) |\n\n                     (val & ~(ECC_MER_VER | ECC_MER_IMPL));\n\n        DPRINTF(\"Write memory enable %08x\\n\", val);\n\n        break;\n\n    case ECC_MDR:\n\n        s->regs[1] =  val & ECC_MDR_MASK;\n\n        DPRINTF(\"Write memory delay %08x\\n\", val);\n\n        break;\n\n    case ECC_MFSR:\n\n        s->regs[2] =  val;\n\n        DPRINTF(\"Write memory fault status %08x\\n\", val);\n\n        break;\n\n    case ECC_VCR:\n\n        s->regs[3] =  val;\n\n        DPRINTF(\"Write slot configuration %08x\\n\", val);\n\n        break;\n\n    case ECC_DR:\n\n        s->regs[6] =  val;\n\n        DPRINTF(\"Write diagnosiic %08x\\n\", val);\n\n        break;\n\n    case ECC_ECR0:\n\n        s->regs[7] =  val;\n\n        DPRINTF(\"Write event count 1 %08x\\n\", val);\n\n        break;\n\n    case ECC_ECR1:\n\n        s->regs[7] =  val;\n\n        DPRINTF(\"Write event count 2 %08x\\n\", val);\n\n        break;\n\n    }\n\n}\n", "idx": 316}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,\n                                 QEMUIOVector *iov, int nb_sectors,\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n{\n    return bdrv_aio_rw_vector(bs, sector_num, iov, nb_sectors,\n                              cb, opaque, 0);\n}", "idx": 9668}
{"project": "qemu", "commit_id": "c4c0e236beabb9de5ff472f77aeb811ec5484615", "target": 1, "func": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n\n{\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret, value, index;\n\n\n\n    /* \n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n    value = le16_to_cpu(s->ctrl.req.wValue);\n\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n\n        s->ctrl.len);\n\n\n\n    if (s->ctrl.req.bRequestType == 0) {\n\n        switch (s->ctrl.req.bRequest) {\n\n        case USB_REQ_SET_ADDRESS:\n\n            return usb_host_set_address(s, value);\n\n\n\n        case USB_REQ_SET_CONFIGURATION:\n\n            return usb_host_set_config(s, value & 0xff);\n\n        }\n\n    }\n\n\n\n    if (s->ctrl.req.bRequestType == 1 &&\n\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n\n        return usb_host_set_interface(s, index, value);\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    aurb = async_alloc();\n\n    aurb->hdev   = s;\n\n    aurb->packet = p;\n\n\n\n    /* \n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is layed out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */ \n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &s->ctrl.req;\n\n    urb->buffer_length = 8 + s->ctrl.len;\n\n\n\n    urb->usercontext = s;\n\n\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    usb_defer_packet(p, async_cancel, aurb);\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 8353}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_rt_sigreturn(CPUS390XState *env)\n\n{\n\n    rt_sigframe *frame;\n\n    abi_ulong frame_addr = env->regs[15];\n\n    sigset_t set;\n\n\n\n    trace_user_do_rt_sigreturn(env, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);\n\n\n\n    set_sigmask(&set); /* ~_BLOCKABLE? */\n\n\n\n    if (restore_sigregs(env, &frame->uc.tuc_mcontext)) {\n\n        goto badframe;\n\n    }\n\n\n\n    if (do_sigaltstack(frame_addr + offsetof(rt_sigframe, uc.tuc_stack), 0,\n\n                       get_sp_from_cpustate(env)) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 1322}
{"project": "qemu", "commit_id": "555a608c5d5dcc44e45a483ca09b449d8db519d1", "target": 1, "func": "static int parallels_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    int64_t total_size, cl_size;\n\n    uint8_t tmp[BDRV_SECTOR_SIZE];\n\n    Error *local_err = NULL;\n\n    BlockBackend *file;\n\n    uint32_t bat_entries, bat_sectors;\n\n    ParallelsHeader header;\n\n    int ret;\n\n\n\n    total_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                          BDRV_SECTOR_SIZE);\n\n    cl_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_CLUSTER_SIZE,\n\n                          DEFAULT_CLUSTER_SIZE), BDRV_SECTOR_SIZE);\n\n\n\n\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n\n\n\n    file = blk_new_open(filename, NULL, NULL,\n\n                        BDRV_O_RDWR | BDRV_O_PROTOCOL, &local_err);\n\n    if (file == NULL) {\n\n\n        return -EIO;\n\n\n\n\n    blk_set_allow_write_beyond_eof(file, true);\n\n\n\n    ret = blk_truncate(file, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n\n\n\n    bat_entries = DIV_ROUND_UP(total_size, cl_size);\n\n    bat_sectors = DIV_ROUND_UP(bat_entry_off(bat_entries), cl_size);\n\n    bat_sectors = (bat_sectors *  cl_size) >> BDRV_SECTOR_BITS;\n\n\n\n    memset(&header, 0, sizeof(header));\n\n    memcpy(header.magic, HEADER_MAGIC2, sizeof(header.magic));\n\n    header.version = cpu_to_le32(HEADER_VERSION);\n\n    /* don't care much about geometry, it is not used on image level */\n\n    header.heads = cpu_to_le32(16);\n\n    header.cylinders = cpu_to_le32(total_size / BDRV_SECTOR_SIZE / 16 / 32);\n\n    header.tracks = cpu_to_le32(cl_size >> BDRV_SECTOR_BITS);\n\n    header.bat_entries = cpu_to_le32(bat_entries);\n\n    header.nb_sectors = cpu_to_le64(DIV_ROUND_UP(total_size, BDRV_SECTOR_SIZE));\n\n    header.data_off = cpu_to_le32(bat_sectors);\n\n\n\n    /* write all the data */\n\n    memset(tmp, 0, sizeof(tmp));\n\n    memcpy(tmp, &header, sizeof(header));\n\n\n\n    ret = blk_pwrite(file, 0, tmp, BDRV_SECTOR_SIZE, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n\n    ret = blk_pwrite_zeroes(file, BDRV_SECTOR_SIZE,\n\n                            (bat_sectors - 1) << BDRV_SECTOR_BITS, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n\n    ret = 0;\n\n\n\ndone:\n\n    blk_unref(file);\n\n    return ret;\n\n\n\nexit:\n\n    error_setg_errno(errp, -ret, \"Failed to create Parallels image\");\n\n    goto done;\n", "idx": 1662}
{"project": "qemu", "commit_id": "7e09797c299712cafa7bc05dd57c1b13afcc6039", "target": 1, "func": "static uint64_t pmsav5_data_ap_read(CPUARMState *env, const ARMCPRegInfo *ri)\n\n{\n\n    return simple_mpu_ap_bits(env->cp15.c5_data);\n\n}\n", "idx": 7505}
{"project": "qemu", "commit_id": "521360267876d3b6518b328051a2e56bca55bef8", "target": 1, "func": "static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)\n\n{\n\n    struct vmsvga_state_s *s = opaque;\n\n\n\n    if (s->index >= SVGA_SCRATCH_BASE) {\n\n        trace_vmware_scratch_write(s->index, value);\n\n    } else if (s->index >= SVGA_PALETTE_BASE) {\n\n        trace_vmware_palette_write(s->index, value);\n\n    } else {\n\n        trace_vmware_value_write(s->index, value);\n\n    }\n\n    switch (s->index) {\n\n    case SVGA_REG_ID:\n\n        if (value == SVGA_ID_2 || value == SVGA_ID_1 || value == SVGA_ID_0) {\n\n            s->svgaid = value;\n\n        }\n\n        break;\n\n\n\n    case SVGA_REG_ENABLE:\n\n        s->enable = !!value;\n\n        s->invalidated = 1;\n\n        s->vga.hw_ops->invalidate(&s->vga);\n\n        if (s->enable && s->config) {\n\n            vga_dirty_log_stop(&s->vga);\n\n        } else {\n\n            vga_dirty_log_start(&s->vga);\n\n        }\n\n        break;\n\n\n\n    case SVGA_REG_WIDTH:\n\n        if (value <= SVGA_MAX_WIDTH) {\n\n            s->new_width = value;\n\n            s->invalidated = 1;\n\n        } else {\n\n            printf(\"%s: Bad width: %i\\n\", __func__, value);\n\n        }\n\n        break;\n\n\n\n    case SVGA_REG_HEIGHT:\n\n        if (value <= SVGA_MAX_HEIGHT) {\n\n            s->new_height = value;\n\n            s->invalidated = 1;\n\n        } else {\n\n            printf(\"%s: Bad height: %i\\n\", __func__, value);\n\n        }\n\n        break;\n\n\n\n    case SVGA_REG_BITS_PER_PIXEL:\n\n        if (value != 32) {\n\n            printf(\"%s: Bad bits per pixel: %i bits\\n\", __func__, value);\n\n            s->config = 0;\n\n            s->invalidated = 1;\n\n        }\n\n        break;\n\n\n\n    case SVGA_REG_CONFIG_DONE:\n\n        if (value) {\n\n            s->fifo = (uint32_t *) s->fifo_ptr;\n\n            /* Check range and alignment.  */\n\n            if ((CMD(min) | CMD(max) | CMD(next_cmd) | CMD(stop)) & 3) {\n\n                break;\n\n            }\n\n            if (CMD(min) < (uint8_t *) s->cmd->fifo - (uint8_t *) s->fifo) {\n\n                break;\n\n            }\n\n            if (CMD(max) > SVGA_FIFO_SIZE) {\n\n                break;\n\n            }\n\n            if (CMD(max) < CMD(min) + 10 * 1024) {\n\n                break;\n\n            }\n\n            vga_dirty_log_stop(&s->vga);\n\n        }\n\n        s->config = !!value;\n\n        break;\n\n\n\n    case SVGA_REG_SYNC:\n\n        s->syncing = 1;\n\n        vmsvga_fifo_run(s); /* Or should we just wait for update_display? */\n\n        break;\n\n\n\n    case SVGA_REG_GUEST_ID:\n\n        s->guest = value;\n\n#ifdef VERBOSE\n\n        if (value >= GUEST_OS_BASE && value < GUEST_OS_BASE +\n\n            ARRAY_SIZE(vmsvga_guest_id)) {\n\n            printf(\"%s: guest runs %s.\\n\", __func__,\n\n                   vmsvga_guest_id[value - GUEST_OS_BASE]);\n\n        }\n\n#endif\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_ID:\n\n        s->cursor.id = value;\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_X:\n\n        s->cursor.x = value;\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_Y:\n\n        s->cursor.y = value;\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_ON:\n\n        s->cursor.on |= (value == SVGA_CURSOR_ON_SHOW);\n\n        s->cursor.on &= (value != SVGA_CURSOR_ON_HIDE);\n\n#ifdef HW_MOUSE_ACCEL\n\n        if (value <= SVGA_CURSOR_ON_SHOW) {\n\n            dpy_mouse_set(s->vga.con, s->cursor.x, s->cursor.y, s->cursor.on);\n\n        }\n\n#endif\n\n        break;\n\n\n\n    case SVGA_REG_DEPTH:\n\n    case SVGA_REG_MEM_REGS:\n\n    case SVGA_REG_NUM_DISPLAYS:\n\n    case SVGA_REG_PITCHLOCK:\n\n    case SVGA_PALETTE_BASE ... SVGA_PALETTE_END:\n\n        break;\n\n\n\n    default:\n\n        if (s->index >= SVGA_SCRATCH_BASE &&\n\n                s->index < SVGA_SCRATCH_BASE + s->scratch_size) {\n\n            s->scratch[s->index - SVGA_SCRATCH_BASE] = value;\n\n            break;\n\n        }\n\n        printf(\"%s: Bad register %02x\\n\", __func__, s->index);\n\n    }\n\n}\n", "idx": 6460}
{"project": "qemu", "commit_id": "0188fadb7fe460d8c4c743372b1f7b25773e183e", "target": 1, "func": "static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUMBState *env)\n\n{\n\n    struct target_signal_frame *frame;\n\n    abi_ulong frame_addr;\n\n    int err = 0;\n\n    int i;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof *frame);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n        goto badframe;\n\n\n\n    /* Save the mask.  */\n\n    __put_user(set->sig[0], &frame->uc.tuc_mcontext.oldmask);\n\n    if (err)\n\n        goto badframe;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__put_user(set->sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    setup_sigcontext(&frame->uc.tuc_mcontext, env);\n\n\n\n    /* Set up to return from userspace. If provided, use a stub\n\n       already in userspace. */\n\n    /* minus 8 is offset to cater for \"rtsd r15,8\" offset */\n\n    if (ka->sa_flags & TARGET_SA_RESTORER) {\n\n        env->regs[15] = ((unsigned long)ka->sa_restorer)-8;\n\n    } else {\n\n        uint32_t t;\n\n        /* Note, these encodings are _big endian_! */\n\n        /* addi r12, r0, __NR_sigreturn */\n\n        t = 0x31800000UL | TARGET_NR_sigreturn;\n\n        __put_user(t, frame->tramp + 0);\n\n        /* brki r14, 0x8 */\n\n        t = 0xb9cc0008UL;\n\n        __put_user(t, frame->tramp + 1);\n\n\n\n        /* Return from sighandler will jump to the tramp.\n\n           Negative 8 offset because return is rtsd r15, 8 */\n\n        env->regs[15] = ((unsigned long)frame->tramp) - 8;\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    /* Set up registers for signal handler */\n\n    env->regs[1] = frame_addr;\n\n    /* Signal handler args: */\n\n    env->regs[5] = sig; /* Arg 0: signum */\n\n    env->regs[6] = 0;\n\n    /* arg 1: sigcontext */\n\n    env->regs[7] = frame_addr += offsetof(typeof(*frame), uc);\n\n\n\n    /* Offset of 4 to handle microblaze rtid r14, 0 */\n\n    env->sregs[SR_PC] = (unsigned long)ka->_sa_handler;\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n  badframe:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 179}
{"project": "qemu", "commit_id": "69d34a360dfe773e17e72c76d15931c9b9d190f6", "target": 1, "func": "static int dmg_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    off_t info_begin,info_end,last_in_offset,last_out_offset;\n\n    uint32_t count;\n\n    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;\n\n    int64_t offset;\n\n\n\n    bs->read_only = 1;\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n\n\n    /* read offset of info blocks */\n\n    offset = bdrv_getlength(bs->file);\n\n    if (offset < 0) {\n\n        goto fail;\n\n    }\n\n    offset -= 0x1d8;\n\n\n\n    info_begin = read_off(bs, offset);\n\n    if (info_begin == 0) {\n\n\tgoto fail;\n\n    }\n\n\n\n    if (read_uint32(bs, info_begin) != 0x100) {\n\n        goto fail;\n\n    }\n\n\n\n    count = read_uint32(bs, info_begin + 4);\n\n    if (count == 0) {\n\n        goto fail;\n\n    }\n\n    info_end = info_begin + count;\n\n\n\n    offset = info_begin + 0x100;\n\n\n\n    /* read offsets */\n\n    last_in_offset = last_out_offset = 0;\n\n    while (offset < info_end) {\n\n        uint32_t type;\n\n\n\n\tcount = read_uint32(bs, offset);\n\n\tif(count==0)\n\n\t    goto fail;\n\n        offset += 4;\n\n\n\n\ttype = read_uint32(bs, offset);\n\n\tif (type == 0x6d697368 && count >= 244) {\n\n\t    int new_size, chunk_count;\n\n\n\n            offset += 4;\n\n            offset += 200;\n\n\n\n\t    chunk_count = (count-204)/40;\n\n\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n\t    s->types = g_realloc(s->types, new_size/2);\n\n\t    s->offsets = g_realloc(s->offsets, new_size);\n\n\t    s->lengths = g_realloc(s->lengths, new_size);\n\n\t    s->sectors = g_realloc(s->sectors, new_size);\n\n\t    s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n\n\n\n\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\n\n\t\ts->types[i] = read_uint32(bs, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_chunk = g_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = g_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\nfail:\n\n    return -1;\n\n}\n", "idx": 3165}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_dup_u8(TCGv var, int shift)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    if (shift)\n\n        tcg_gen_shri_i32(var, var, shift);\n\n    tcg_gen_ext8u_i32(var, var);\n\n    tcg_gen_shli_i32(tmp, var, 8);\n\n    tcg_gen_or_i32(var, var, tmp);\n\n    tcg_gen_shli_i32(tmp, var, 16);\n\n    tcg_gen_or_i32(var, var, tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 4702}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_slave_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *k = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_MISC, k->categories);\n\n    k->bus_type = TYPE_AUX_BUS;\n\n}\n", "idx": 466}
{"project": "qemu", "commit_id": "48b3ed0a68b8c1b288b4e15743ea39b7b5b318c3", "target": 1, "func": "void qemu_spice_init(void)\n\n{\n\n    QemuOpts *opts = QTAILQ_FIRST(&qemu_spice_opts.head);\n\n    const char *password, *str, *x509_dir, *addr,\n\n        *x509_key_password = NULL,\n\n        *x509_dh_file = NULL,\n\n        *tls_ciphers = NULL;\n\n    char *x509_key_file = NULL,\n\n        *x509_cert_file = NULL,\n\n        *x509_cacert_file = NULL;\n\n    int port, tls_port, len, addr_flags;\n\n    spice_image_compression_t compression;\n\n    spice_wan_compression_t wan_compr;\n\n\n\n    if (!opts) {\n\n        return;\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    tls_port = qemu_opt_get_number(opts, \"tls-port\", 0);\n\n    if (!port && !tls_port) {\n\n        return;\n\n\n    password = qemu_opt_get(opts, \"password\");\n\n\n\n    if (tls_port) {\n\n        x509_dir = qemu_opt_get(opts, \"x509-dir\");\n\n        if (NULL == x509_dir) {\n\n            x509_dir = \".\";\n\n\n        len = strlen(x509_dir) + 32;\n\n\n\n        str = qemu_opt_get(opts, \"x509-key-file\");\n\n        if (str) {\n\n            x509_key_file = qemu_strdup(str);\n\n        } else {\n\n            x509_key_file = qemu_malloc(len);\n\n            snprintf(x509_key_file, len, \"%s/%s\", x509_dir, X509_SERVER_KEY_FILE);\n\n\n\n\n        str = qemu_opt_get(opts, \"x509-cert-file\");\n\n        if (str) {\n\n            x509_cert_file = qemu_strdup(str);\n\n        } else {\n\n            x509_cert_file = qemu_malloc(len);\n\n            snprintf(x509_cert_file, len, \"%s/%s\", x509_dir, X509_SERVER_CERT_FILE);\n\n\n\n\n        str = qemu_opt_get(opts, \"x509-cacert-file\");\n\n        if (str) {\n\n            x509_cacert_file = qemu_strdup(str);\n\n        } else {\n\n            x509_cacert_file = qemu_malloc(len);\n\n            snprintf(x509_cacert_file, len, \"%s/%s\", x509_dir, X509_CA_CERT_FILE);\n\n\n\n\n        x509_key_password = qemu_opt_get(opts, \"x509-key-password\");\n\n        x509_dh_file = qemu_opt_get(opts, \"x509-dh-file\");\n\n        tls_ciphers = qemu_opt_get(opts, \"tls-ciphers\");\n\n\n\n\n    addr = qemu_opt_get(opts, \"addr\");\n\n    addr_flags = 0;\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0)) {\n\n        addr_flags |= SPICE_ADDR_FLAG_IPV4_ONLY;\n\n    } else if (qemu_opt_get_bool(opts, \"ipv6\", 0)) {\n\n        addr_flags |= SPICE_ADDR_FLAG_IPV6_ONLY;\n\n\n\n\n    spice_server = spice_server_new();\n\n    spice_server_set_addr(spice_server, addr ? addr : \"\", addr_flags);\n\n    if (port) {\n\n        spice_server_set_port(spice_server, port);\n\n\n    if (tls_port) {\n\n        spice_server_set_tls(spice_server, tls_port,\n\n                             x509_cacert_file,\n\n                             x509_cert_file,\n\n                             x509_key_file,\n\n                             x509_key_password,\n\n                             x509_dh_file,\n\n                             tls_ciphers);\n\n\n    if (password) {\n\n        spice_server_set_ticket(spice_server, password, 0, 0, 0);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    if (qemu_opt_get_bool(opts, \"disable-ticketing\", 0)) {\n\n        auth = \"none\";\n\n        spice_server_set_noauth(spice_server);\n\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000801\n\n    if (qemu_opt_get_bool(opts, \"disable-copy-paste\", 0)) {\n\n        spice_server_set_agent_copypaste(spice_server, false);\n\n\n\n\n\n    compression = SPICE_IMAGE_COMPRESS_AUTO_GLZ;\n\n    str = qemu_opt_get(opts, \"image-compression\");\n\n    if (str) {\n\n        compression = parse_compression(str);\n\n\n    spice_server_set_image_compression(spice_server, compression);\n\n\n\n    wan_compr = SPICE_WAN_COMPRESSION_AUTO;\n\n    str = qemu_opt_get(opts, \"jpeg-wan-compression\");\n\n    if (str) {\n\n        wan_compr = parse_wan_compression(str);\n\n\n    spice_server_set_jpeg_compression(spice_server, wan_compr);\n\n\n\n    wan_compr = SPICE_WAN_COMPRESSION_AUTO;\n\n    str = qemu_opt_get(opts, \"zlib-glz-wan-compression\");\n\n    if (str) {\n\n        wan_compr = parse_wan_compression(str);\n\n\n    spice_server_set_zlib_glz_compression(spice_server, wan_compr);\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000600 /* 0.6.0 */\n\n\n\n    str = qemu_opt_get(opts, \"streaming-video\");\n\n    if (str) {\n\n        int streaming_video = parse_stream_video(str);\n\n        spice_server_set_streaming_video(spice_server, streaming_video);\n\n\n\n\n    spice_server_set_agent_mouse\n\n        (spice_server, qemu_opt_get_bool(opts, \"agent-mouse\", 1));\n\n    spice_server_set_playback_compression\n\n        (spice_server, qemu_opt_get_bool(opts, \"playback-compression\", 1));\n\n\n\n#endif /* >= 0.6.0 */\n\n\n\n    qemu_opt_foreach(opts, add_channel, NULL, 0);\n\n\n\n    spice_server_init(spice_server, &core_interface);\n\n    using_spice = 1;\n\n\n\n    migration_state.notify = migration_state_notifier;\n\n    add_migration_state_change_notifier(&migration_state);\n\n\n\n    qemu_spice_input_init();\n\n    qemu_spice_audio_init();\n\n\n\n    qemu_free(x509_key_file);\n\n    qemu_free(x509_cert_file);\n\n    qemu_free(x509_cacert_file);\n", "idx": 4979}
{"project": "qemu", "commit_id": "3a4dbe6aa934370a92372528c1255ee1504965ee", "target": 1, "func": "static void vfio_put_device(VFIOPCIDevice *vdev)\n\n{\n\n    g_free(vdev->vbasedev.name);\n\n    if (vdev->msix) {\n\n\n        g_free(vdev->msix);\n\n        vdev->msix = NULL;\n\n    }\n\n    vfio_put_base_device(&vdev->vbasedev);\n\n}", "idx": 6080}
{"project": "qemu", "commit_id": "4a41a2d68a684241aca96dba066e0699941b730d", "target": 1, "func": "static void nbd_teardown_connection(NbdClientSession *client)\n\n{\n\n    struct nbd_request request = {\n\n        .type = NBD_CMD_DISC,\n\n        .from = 0,\n\n        .len = 0\n\n    };\n\n\n\n    nbd_send_request(client->sock, &request);\n\n\n\n    /* finish any pending coroutines */\n\n    shutdown(client->sock, 2);\n\n    nbd_recv_coroutines_enter_all(client);\n\n\n\n    qemu_aio_set_fd_handler(client->sock, NULL, NULL, NULL);\n\n    closesocket(client->sock);\n\n    client->sock = -1;\n\n}\n", "idx": 10312}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_602 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;\n\n    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;\n\n    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;\n\n    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;\n\n    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001500;\n\n    env->excp_vectors[POWERPC_EXCP_EMUL]     = 0x00001600;\n\n    env->excp_prefix = 0xFFF00000;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0xFFFFFFFCUL;\n\n#endif\n\n}\n", "idx": 11119}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int16_t *v = pv;\n\n    qemu_get_sbe16s(f, v);\n\n    return 0;\n\n}\n", "idx": 4703}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 10936}
{"project": "qemu", "commit_id": "2cdff7f620ebd3b5246cf0c0d1f6fa0eededa4ca", "target": 1, "func": "static void qemu_laio_completion_cb(EventNotifier *e)\n\n{\n\n    struct qemu_laio_state *s = container_of(e, struct qemu_laio_state, e);\n\n\n\n    while (event_notifier_test_and_clear(&s->e)) {\n\n        struct io_event events[MAX_EVENTS];\n\n        struct timespec ts = { 0 };\n\n        int nevents, i;\n\n\n\n        do {\n\n            nevents = io_getevents(s->ctx, MAX_EVENTS, MAX_EVENTS, events, &ts);\n\n        } while (nevents == -EINTR);\n\n\n\n        for (i = 0; i < nevents; i++) {\n\n            struct iocb *iocb = events[i].obj;\n\n            struct qemu_laiocb *laiocb =\n\n                    container_of(iocb, struct qemu_laiocb, iocb);\n\n\n\n            laiocb->ret = io_event_ret(&events[i]);\n\n            qemu_laio_process_completion(s, laiocb);\n\n        }\n\n    }\n\n}\n", "idx": 10497}
{"project": "qemu", "commit_id": "dd793a74882477ca38d49e191110c17dfee51dcc", "target": 1, "func": "e1000_receive_iov(NetClientState *nc, const struct iovec *iov, int iovcnt)\n\n{\n\n    E1000State *s = qemu_get_nic_opaque(nc);\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    struct e1000_rx_desc desc;\n\n    dma_addr_t base;\n\n    unsigned int n, rdt;\n\n    uint32_t rdh_start;\n\n    uint16_t vlan_special = 0;\n\n    uint8_t vlan_status = 0;\n\n    uint8_t min_buf[MIN_BUF_SIZE];\n\n    struct iovec min_iov;\n\n    uint8_t *filter_buf = iov->iov_base;\n\n    size_t size = iov_size(iov, iovcnt);\n\n    size_t iov_ofs = 0;\n\n    size_t desc_offset;\n\n    size_t desc_size;\n\n    size_t total_size;\n\n    static const int PRCregs[6] = { PRC64, PRC127, PRC255, PRC511,\n\n                                    PRC1023, PRC1522 };\n\n\n\n    if (!(s->mac_reg[STATUS] & E1000_STATUS_LU)) {\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Pad to minimum Ethernet frame length */\n\n    if (size < sizeof(min_buf)) {\n\n        iov_to_buf(iov, iovcnt, 0, min_buf, size);\n\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n\n        inc_reg_if_not_full(s, RUC);\n\n        min_iov.iov_base = filter_buf = min_buf;\n\n        min_iov.iov_len = size = sizeof(min_buf);\n\n        iovcnt = 1;\n\n        iov = &min_iov;\n\n    } else if (iov->iov_len < MAXIMUM_ETHERNET_HDR_LEN) {\n\n        /* This is very unlikely, but may happen. */\n\n        iov_to_buf(iov, iovcnt, 0, min_buf, MAXIMUM_ETHERNET_HDR_LEN);\n\n        filter_buf = min_buf;\n\n    }\n\n\n\n    /* Discard oversized packets if !LPE and !SBP. */\n\n    if ((size > MAXIMUM_ETHERNET_LPE_SIZE ||\n\n        (size > MAXIMUM_ETHERNET_VLAN_SIZE\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_LPE)))\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_SBP)) {\n\n        inc_reg_if_not_full(s, ROC);\n\n        return size;\n\n    }\n\n\n\n    if (!receive_filter(s, filter_buf, size)) {\n\n        return size;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_packet(s, filter_buf)) {\n\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(filter_buf\n\n                                                                + 14)));\n\n        iov_ofs = 4;\n\n        if (filter_buf == iov->iov_base) {\n\n            memmove(filter_buf + 4, filter_buf, 12);\n\n        } else {\n\n            iov_from_buf(iov, iovcnt, 4, filter_buf, 12);\n\n            while (iov->iov_len <= iov_ofs) {\n\n                iov_ofs -= iov->iov_len;\n\n                iov++;\n\n            }\n\n        }\n\n        vlan_status = E1000_RXD_STAT_VP;\n\n        size -= 4;\n\n    }\n\n\n\n    rdh_start = s->mac_reg[RDH];\n\n    desc_offset = 0;\n\n    total_size = size + fcs_len(s);\n\n    if (!e1000_has_rxbufs(s, total_size)) {\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n    }\n\n    do {\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > s->rxbuf_size) {\n\n            desc_size = s->rxbuf_size;\n\n        }\n\n        base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];\n\n        pci_dma_read(d, base, &desc, sizeof(desc));\n\n        desc.special = vlan_special;\n\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n\n        if (desc.buffer_addr) {\n\n            if (desc_offset < size) {\n\n                size_t iov_copy;\n\n                hwaddr ba = le64_to_cpu(desc.buffer_addr);\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > s->rxbuf_size) {\n\n                    copy_size = s->rxbuf_size;\n\n                }\n\n                do {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    pci_dma_write(d, ba, iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n\n                    ba += iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                } while (copy_size);\n\n            }\n\n            desc_offset += desc_size;\n\n            desc.length = cpu_to_le16(desc_size);\n\n            if (desc_offset >= total_size) {\n\n                desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;\n\n            } else {\n\n                /* Guest zeroing out status is not a hardware requirement.\n\n                   Clear EOP in case guest didn't do it. */\n\n                desc.status &= ~E1000_RXD_STAT_EOP;\n\n            }\n\n        } else { // as per intel docs; skip descriptors with null buf addr\n\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n\n        }\n\n        pci_dma_write(d, base, &desc, sizeof(desc));\n\n\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n\n            s->mac_reg[RDH] = 0;\n\n        /* see comment in start_xmit; same here */\n\n        if (s->mac_reg[RDH] == rdh_start) {\n\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n        }\n\n    } while (desc_offset < total_size);\n\n\n\n    increase_size_stats(s, PRCregs, total_size);\n\n    inc_reg_if_not_full(s, TPR);\n\n    s->mac_reg[GPRC] = s->mac_reg[TPR];\n\n    /* TOR - Total Octets Received:\n\n     * This register includes bytes received in a packet from the <Destination\n\n     * Address> field through the <CRC> field, inclusively.\n\n     * Always include FCS length (4) in size.\n\n     */\n\n    grow_8reg_if_not_full(s, TORL, size+4);\n\n    s->mac_reg[GORCL] = s->mac_reg[TORL];\n\n    s->mac_reg[GORCH] = s->mac_reg[TORH];\n\n\n\n    n = E1000_ICS_RXT0;\n\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n\n        s->rxbuf_min_shift)\n\n        n |= E1000_ICS_RXDMT0;\n\n\n\n    set_ics(s, 0, n);\n\n\n\n    return size;\n\n}\n", "idx": 7003}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,\n\n                               uint32_t *byte_len)\n\n{\n\n    int ret;\n\n    struct ibv_wc wc;\n\n    uint64_t wr_id;\n\n\n\n    ret = ibv_poll_cq(rdma->cq, 1, &wc);\n\n\n\n    if (!ret) {\n\n        *wr_id_out = RDMA_WRID_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ibv_poll_cq return %d!\\n\", ret);\n\n        return ret;\n\n    }\n\n\n\n    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;\n\n\n\n    if (wc.status != IBV_WC_SUCCESS) {\n\n        fprintf(stderr, \"ibv_poll_cq wc.status=%d %s!\\n\",\n\n                        wc.status, ibv_wc_status_str(wc.status));\n\n        fprintf(stderr, \"ibv_poll_cq wrid=%s!\\n\", wrid_desc[wr_id]);\n\n\n\n        return -1;\n\n    }\n\n\n\n    if (rdma->control_ready_expected &&\n\n        (wr_id >= RDMA_WRID_RECV_CONTROL)) {\n\n        DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\"\n\n                  \" left %d\\n\", wrid_desc[RDMA_WRID_RECV_CONTROL],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n    if (byte_len) {\n\n        *byte_len = wc.byte_len;\n\n    }\n\n\n\n    return  0;\n\n}\n", "idx": 7376}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}", "idx": 4663}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_reset(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    s->divider = 0;\n\n    s->rbr = 0;\n\n    s->ier = 0;\n\n    s->iir = UART_IIR_NO_INT;\n\n    s->lcr = 0;\n\n    s->mcr = 0;\n\n    s->lsr = UART_LSR_TEMT | UART_LSR_THRE;\n\n    s->msr = UART_MSR_DCD | UART_MSR_DSR | UART_MSR_CTS;\n\n    s->scr = 0;\n\n\n\n    s->thr_ipending = 0;\n\n    s->last_break_enable = 0;\n\n    qemu_irq_lower(s->irq);\n\n}\n", "idx": 1132}
{"project": "qemu", "commit_id": "c364c974d9ab90e25e7887f516da65d2811ba5e3", "target": 1, "func": "static int pci_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    PCIDevice *pci_dev = (PCIDevice *)qdev;\n\n    PCIDeviceInfo *info = container_of(base, PCIDeviceInfo, qdev);\n\n    PCIBus *bus;\n\n    int devfn, rc;\n\n\n\n    /* initialize cap_present for pci_is_express() and pci_config_size() */\n\n    if (info->is_express) {\n\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    bus = FROM_QBUS(PCIBus, qdev_get_parent_bus(qdev));\n\n    devfn = pci_dev->devfn;\n\n    pci_dev = do_pci_register_device(pci_dev, bus, base->name, devfn,\n\n                                     info->config_read, info->config_write,\n\n                                     info->header_type);\n\n    assert(pci_dev);\n\n    rc = info->init(pci_dev);\n\n    if (rc != 0)\n\n        return rc;\n\n    if (qdev->hotplugged)\n\n        bus->hotplug(pci_dev, 1);\n\n    return 0;\n\n}\n", "idx": 1496}
{"project": "qemu", "commit_id": "6e5d97d01d9da6f295f9888d4b34e29fd737861a", "target": 1, "func": "void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n", "idx": 11073}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbiva(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_tlbiva(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 9643}
{"project": "qemu", "commit_id": "72902672dc2ed6281cdb205259c1d52ecf01f6b2", "target": 1, "func": "NEON_TYPE4(s8, int8_t)\nNEON_TYPE4(u8, uint8_t)\nNEON_TYPE2(s16, int16_t)\nNEON_TYPE2(u16, uint16_t)\nNEON_TYPE1(s32, int32_t)\nNEON_TYPE1(u32, uint32_t)\n#undef NEON_TYPE4\n#undef NEON_TYPE2\n#undef NEON_TYPE1\n/* Copy from a uint32_t to a vector structure type.  */\n#define NEON_UNPACK(vtype, dest, val) do { \\\n    union { \\\n        vtype v; \\\n        uint32_t i; \\\n    } conv_u; \\\n    conv_u.i = (val); \\\n    dest = conv_u.v; \\\n    } while(0)\n/* Copy from a vector structure type to a uint32_t.  */\n#define NEON_PACK(vtype, dest, val) do { \\\n    union { \\\n        vtype v; \\\n        uint32_t i; \\\n    } conv_u; \\\n    conv_u.v = (val); \\\n    dest = conv_u.i; \\\n    } while(0)\n#define NEON_DO1 \\\n    NEON_FN(vdest.v1, vsrc1.v1, vsrc2.v1);\n#define NEON_DO2 \\\n    NEON_FN(vdest.v1, vsrc1.v1, vsrc2.v1); \\\n    NEON_FN(vdest.v2, vsrc1.v2, vsrc2.v2);\n#define NEON_DO4 \\\n    NEON_FN(vdest.v1, vsrc1.v1, vsrc2.v1); \\\n    NEON_FN(vdest.v2, vsrc1.v2, vsrc2.v2); \\\n    NEON_FN(vdest.v3, vsrc1.v3, vsrc2.v3); \\\n    NEON_FN(vdest.v4, vsrc1.v4, vsrc2.v4);\n#define NEON_VOP_BODY(vtype, n) \\\n{ \\\n    uint32_t res; \\\n    vtype vsrc1; \\\n    vtype vsrc2; \\\n    vtype vdest; \\\n    NEON_UNPACK(vtype, vsrc1, arg1); \\\n    NEON_UNPACK(vtype, vsrc2, arg2); \\\n    NEON_DO##n; \\\n    NEON_PACK(vtype, res, vdest); \\\n    return res; \\\n#define NEON_VOP(name, vtype, n) \\\nuint32_t HELPER(glue(neon_,name))(uint32_t arg1, uint32_t arg2) \\\nNEON_VOP_BODY(vtype, n)\n#define NEON_VOP_ENV(name, vtype, n) \\\nuint32_t HELPER(glue(neon_,name))(CPUState *env, uint32_t arg1, uint32_t arg2) \\\nNEON_VOP_BODY(vtype, n)\n/* Pairwise operations.  */\n/* For 32-bit elements each segment only contains a single element, so\n   the elementwise and pairwise operations are the same.  */\n#define NEON_PDO2 \\\n    NEON_FN(vdest.v1, vsrc1.v1, vsrc1.v2); \\\n    NEON_FN(vdest.v2, vsrc2.v1, vsrc2.v2);\n#define NEON_PDO4 \\\n    NEON_FN(vdest.v1, vsrc1.v1, vsrc1.v2); \\\n    NEON_FN(vdest.v2, vsrc1.v3, vsrc1.v4); \\\n    NEON_FN(vdest.v3, vsrc2.v1, vsrc2.v2); \\\n    NEON_FN(vdest.v4, vsrc2.v3, vsrc2.v4); \\\n#define NEON_POP(name, vtype, n) \\\nuint32_t HELPER(glue(neon_,name))(uint32_t arg1, uint32_t arg2) \\\n{ \\\n    uint32_t res; \\\n    vtype vsrc1; \\\n    vtype vsrc2; \\\n    vtype vdest; \\\n    NEON_UNPACK(vtype, vsrc1, arg1); \\\n    NEON_UNPACK(vtype, vsrc2, arg2); \\\n    NEON_PDO##n; \\\n    NEON_PACK(vtype, res, vdest); \\\n    return res; \\\n/* Unary operators.  */\n#define NEON_VOP1(name, vtype, n) \\\nuint32_t HELPER(glue(neon_,name))(uint32_t arg) \\\n{ \\\n    vtype vsrc1; \\\n    vtype vdest; \\\n    NEON_UNPACK(vtype, vsrc1, arg); \\\n    NEON_DO##n; \\\n    NEON_PACK(vtype, arg, vdest); \\\n    return arg; \\\n#define NEON_USAT(dest, src1, src2, type) do { \\\n    uint32_t tmp = (uint32_t)src1 + (uint32_t)src2; \\\n    if (tmp != (type)tmp) { \\\n        SET_QC(); \\\n        dest = ~0; \\\n    } else { \\\n        dest = tmp; \\\n    }} while(0)\n#define NEON_FN(dest, src1, src2) NEON_USAT(dest, src1, src2, uint8_t)\nNEON_VOP_ENV(qadd_u8, neon_u8, 4)\n#undef NEON_FN\n#define NEON_FN(dest, src1, src2) NEON_USAT(dest, src1, src2, uint16_t)\nNEON_VOP_ENV(qadd_u16, neon_u16, 2)\n#undef NEON_FN\n#undef NEON_USAT", "idx": 10429}
{"project": "qemu", "commit_id": "cecd8504b80148b66cdc1ce32046429bc3549090", "target": 1, "func": "void HELPER(vfp_set_fpscr)(CPUState *env, uint32_t val)\n\n{\n\n    int i;\n\n    uint32_t changed;\n\n\n\n    changed = env->vfp.xregs[ARM_VFP_FPSCR];\n\n    env->vfp.xregs[ARM_VFP_FPSCR] = (val & 0xffc8ffff);\n\n    env->vfp.vec_len = (val >> 16) & 7;\n\n    env->vfp.vec_stride = (val >> 20) & 3;\n\n\n\n    changed ^= val;\n\n    if (changed & (3 << 22)) {\n\n        i = (val >> 22) & 3;\n\n        switch (i) {\n\n        case 0:\n\n            i = float_round_nearest_even;\n\n            break;\n\n        case 1:\n\n            i = float_round_up;\n\n            break;\n\n        case 2:\n\n            i = float_round_down;\n\n            break;\n\n        case 3:\n\n            i = float_round_to_zero;\n\n            break;\n\n        }\n\n        set_float_rounding_mode(i, &env->vfp.fp_status);\n\n    }\n\n    if (changed & (1 << 24))\n\n        set_flush_to_zero((val & (1 << 24)) != 0, &env->vfp.fp_status);\n\n    if (changed & (1 << 25))\n\n        set_default_nan_mode((val & (1 << 25)) != 0, &env->vfp.fp_status);\n\n\n\n    i = vfp_exceptbits_to_host(val);\n\n    set_float_exception_flags(i, &env->vfp.fp_status);\n\n}\n", "idx": 12209}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "    vmstate_get_subsection(const VMStateSubsection *sub, char *idstr)\n\n{\n\n    while (sub && sub->needed) {\n\n        if (strcmp(idstr, sub->vmsd->name) == 0) {\n\n            return sub->vmsd;\n\n        }\n\n        sub++;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 8366}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void blockdev_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n\n    BlockdevBackup *backup;\n\n    BlockDriverState *bs, *target;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP);\n\n    backup = common->action->u.blockdev_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    target = bdrv_lookup_bs(backup->target, backup->target, errp);\n\n    if (!target) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    if (state->aio_context != bdrv_get_aio_context(target)) {\n\n        state->aio_context = NULL;\n\n        error_setg(errp, \"Backup between two IO threads is not implemented\");\n\n        return;\n\n    }\n\n    aio_context_acquire(state->aio_context);\n\n    state->bs = bs;\n\n    bdrv_drained_begin(state->bs);\n\n\n\n    do_blockdev_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 6884}
{"project": "qemu", "commit_id": "680e60b6ba5a26332d684a60a6d9f39c0a999941", "target": 1, "func": "e1000e_set_pbaclr(E1000ECore *core, int index, uint32_t val)\n\n{\n\n    int i;\n\n\n\n    core->mac[PBACLR] = val & E1000_PBACLR_VALID_MASK;\n\n\n\n    if (msix_enabled(core->owner)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n\n        if (core->mac[PBACLR] & BIT(i)) {\n\n            msix_clr_pending(core->owner, i);\n\n        }\n\n    }\n\n}\n", "idx": 7000}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_uint32(Visitor *v, uint32_t *obj, const char *name, Error **errp)\n\n{\n\n    int64_t value;\n\n    if (!error_is_set(errp)) {\n\n        if (v->type_uint32) {\n\n            v->type_uint32(v, obj, name, errp);\n\n        } else {\n\n            value = *obj;\n\n            v->type_int(v, &value, name, errp);\n\n            if (value < 0 || value > UINT32_MAX) {\n\n                error_set(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n                          \"uint32_t\");\n\n                return;\n\n            }\n\n            *obj = value;\n\n        }\n\n    }\n\n}\n", "idx": 401}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 1234}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static int kvm_check_many_ioeventfds(void)\n\n{\n\n    /* Userspace can use ioeventfd for io notification.  This requires a host\n\n     * that supports eventfd(2) and an I/O thread; since eventfd does not\n\n     * support SIGIO it cannot interrupt the vcpu.\n\n     *\n\n     * Older kernels have a 6 device limit on the KVM io bus.  Find out so we\n\n     * can avoid creating too many ioeventfds.\n\n     */\n\n#if defined(CONFIG_EVENTFD) && defined(CONFIG_IOTHREAD)\n\n    int ioeventfds[7];\n\n    int i, ret = 0;\n\n    for (i = 0; i < ARRAY_SIZE(ioeventfds); i++) {\n\n        ioeventfds[i] = eventfd(0, EFD_CLOEXEC);\n\n        if (ioeventfds[i] < 0) {\n\n            break;\n\n        }\n\n        ret = kvm_set_ioeventfd_pio_word(ioeventfds[i], 0, i, true);\n\n        if (ret < 0) {\n\n            close(ioeventfds[i]);\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Decide whether many devices are supported or not */\n\n    ret = i == ARRAY_SIZE(ioeventfds);\n\n\n\n    while (i-- > 0) {\n\n        kvm_set_ioeventfd_pio_word(ioeventfds[i], 0, i, false);\n\n        close(ioeventfds[i]);\n\n    }\n\n    return ret;\n\n#else\n\n    return 0;\n\n#endif\n\n}\n", "idx": 9556}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_float64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    float64 *v = pv;\n\n\n\n    *v = make_float64(qemu_get_be64(f));\n\n    return 0;\n\n}\n", "idx": 6625}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_addzeo (void)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca;\n\n    if (likely(!((T1 ^ (-1)) & (T1 ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T0 >= T1)) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "idx": 6051}
{"project": "qemu", "commit_id": "bac658d1a4dc9dd637b2eb5006abda137071f17f", "target": 1, "func": "static char *spapr_get_fw_dev_path(FWPathProvider *p, BusState *bus,\n\n                                   DeviceState *dev)\n\n{\n\n#define CAST(type, obj, name) \\\n\n    ((type *)object_dynamic_cast(OBJECT(obj), (name)))\n\n    SCSIDevice *d = CAST(SCSIDevice,  dev, TYPE_SCSI_DEVICE);\n\n    sPAPRPHBState *phb = CAST(sPAPRPHBState, dev, TYPE_SPAPR_PCI_HOST_BRIDGE);\n\n    VHostSCSICommon *vsc = CAST(VHostSCSICommon, dev, TYPE_VHOST_SCSI_COMMON);\n\n\n\n    if (d) {\n\n        void *spapr = CAST(void, bus->parent, \"spapr-vscsi\");\n\n        VirtIOSCSI *virtio = CAST(VirtIOSCSI, bus->parent, TYPE_VIRTIO_SCSI);\n\n        USBDevice *usb = CAST(USBDevice, bus->parent, TYPE_USB_DEVICE);\n\n\n\n        if (spapr) {\n\n            /*\n\n             * Replace \"channel@0/disk@0,0\" with \"disk@8000000000000000\":\n\n             * We use SRP luns of the form 8000 | (bus << 8) | (id << 5) | lun\n\n             * in the top 16 bits of the 64-bit LUN\n\n             */\n\n            unsigned id = 0x8000 | (d->id << 8) | d->lun;\n\n            return g_strdup_printf(\"%s@%\"PRIX64, qdev_fw_name(dev),\n\n                                   (uint64_t)id << 48);\n\n        } else if (virtio) {\n\n            /*\n\n             * We use SRP luns of the form 01000000 | (target << 8) | lun\n\n             * in the top 32 bits of the 64-bit LUN\n\n             * Note: the quote above is from SLOF and it is wrong,\n\n             * the actual binding is:\n\n             * swap 0100 or 10 << or 20 << ( target lun-id -- srplun )\n\n             */\n\n            unsigned id = 0x1000000 | (d->id << 16) | d->lun;\n\n\n\n\n\n            return g_strdup_printf(\"%s@%\"PRIX64, qdev_fw_name(dev),\n\n                                   (uint64_t)id << 32);\n\n        } else if (usb) {\n\n            /*\n\n             * We use SRP luns of the form 01000000 | (usb-port << 16) | lun\n\n             * in the top 32 bits of the 64-bit LUN\n\n             */\n\n            unsigned usb_port = atoi(usb->port->path);\n\n            unsigned id = 0x1000000 | (usb_port << 16) | d->lun;\n\n            return g_strdup_printf(\"%s@%\"PRIX64, qdev_fw_name(dev),\n\n                                   (uint64_t)id << 32);\n\n\n\n\n\n    /*\n\n     * SLOF probes the USB devices, and if it recognizes that the device is a\n\n     * storage device, it changes its name to \"storage\" instead of \"usb-host\",\n\n     * and additionally adds a child node for the SCSI LUN, so the correct\n\n     * boot path in SLOF is something like .../storage@1/disk@xxx\" instead.\n\n     */\n\n    if (strcmp(\"usb-host\", qdev_fw_name(dev)) == 0) {\n\n        USBDevice *usbdev = CAST(USBDevice, dev, TYPE_USB_DEVICE);\n\n        if (usb_host_dev_is_scsi_storage(usbdev)) {\n\n            return g_strdup_printf(\"storage@%s/disk\", usbdev->port->path);\n\n\n\n\n\n    if (phb) {\n\n        /* Replace \"pci\" with \"pci@800000020000000\" */\n\n        return g_strdup_printf(\"pci@%\"PRIX64, phb->buid);\n\n\n\n\n    if (vsc) {\n\n        /* Same logic as virtio above */\n\n        unsigned id = 0x1000000 | (vsc->target << 16) | vsc->lun;\n\n        return g_strdup_printf(\"disk@%\"PRIX64, (uint64_t)id << 32);\n\n\n\n\n    if (g_str_equal(\"pci-bridge\", qdev_fw_name(dev))) {\n\n        /* SLOF uses \"pci\" instead of \"pci-bridge\" for PCI bridges */\n\n        PCIDevice *pcidev = CAST(PCIDevice, dev, TYPE_PCI_DEVICE);\n\n        return g_strdup_printf(\"pci@%x\", PCI_SLOT(pcidev->devfn));\n\n\n\n\n    return NULL;\n", "idx": 12171}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    rc4030State *s = RC4030(dev);\n\n    int i;\n\n\n\n    timer_free(s->periodic_timer);\n\n\n\n    address_space_destroy(&s->dma_as);\n\n    object_unparent(OBJECT(&s->dma_tt));\n\n    object_unparent(OBJECT(&s->dma_tt_alias));\n\n    object_unparent(OBJECT(&s->dma_mr));\n\n    for (i = 0; i < MAX_TL_ENTRIES; ++i) {\n\n        memory_region_del_subregion(&s->dma_mr, &s->dma_mrs[i]);\n\n        object_unparent(OBJECT(&s->dma_mrs[i]));\n\n    }\n\n}\n", "idx": 10197}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "void sm501_init(MemoryRegion *address_space_mem, uint32_t base,\n\n                uint32_t local_mem_bytes, qemu_irq irq, CharDriverState *chr)\n\n{\n\n    SM501State * s;\n\n    DeviceState *dev;\n\n    MemoryRegion *sm501_system_config = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sm501_disp_ctrl = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sm501_2d_engine = g_new(MemoryRegion, 1);\n\n\n\n    /* allocate management data region */\n\n    s = (SM501State *)g_malloc0(sizeof(SM501State));\n\n    s->base = base;\n\n    s->local_mem_size_index\n\n\t= get_local_mem_size_index(local_mem_bytes);\n\n    SM501_DPRINTF(\"local mem size=%x. index=%d\\n\", get_local_mem_size(s),\n\n\t\t  s->local_mem_size_index);\n\n    s->system_control = 0x00100000;\n\n    s->misc_control = 0x00001000; /* assumes SH, active=low */\n\n    s->dc_panel_control = 0x00010000;\n\n    s->dc_crt_control = 0x00010000;\n\n\n\n    /* allocate local memory */\n\n    memory_region_init_ram(&s->local_mem_region, NULL, \"sm501.local\",\n\n                           local_mem_bytes, &error_abort);\n\n    vmstate_register_ram_global(&s->local_mem_region);\n\n    memory_region_set_log(&s->local_mem_region, true, DIRTY_MEMORY_VGA);\n\n    s->local_mem = memory_region_get_ram_ptr(&s->local_mem_region);\n\n    memory_region_add_subregion(address_space_mem, base, &s->local_mem_region);\n\n\n\n    /* map mmio */\n\n    memory_region_init_io(sm501_system_config, NULL, &sm501_system_config_ops, s,\n\n                          \"sm501-system-config\", 0x6c);\n\n    memory_region_add_subregion(address_space_mem, base + MMIO_BASE_OFFSET,\n\n                                sm501_system_config);\n\n    memory_region_init_io(sm501_disp_ctrl, NULL, &sm501_disp_ctrl_ops, s,\n\n                          \"sm501-disp-ctrl\", 0x1000);\n\n    memory_region_add_subregion(address_space_mem,\n\n                                base + MMIO_BASE_OFFSET + SM501_DC,\n\n                                sm501_disp_ctrl);\n\n    memory_region_init_io(sm501_2d_engine, NULL, &sm501_2d_engine_ops, s,\n\n                          \"sm501-2d-engine\", 0x54);\n\n    memory_region_add_subregion(address_space_mem,\n\n                                base + MMIO_BASE_OFFSET + SM501_2D_ENGINE,\n\n                                sm501_2d_engine);\n\n\n\n    /* bridge to usb host emulation module */\n\n    dev = qdev_create(NULL, \"sysbus-ohci\");\n\n    qdev_prop_set_uint32(dev, \"num-ports\", 2);\n\n    qdev_prop_set_uint64(dev, \"dma-offset\", base);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0,\n\n                    base + MMIO_BASE_OFFSET + SM501_USB_HOST);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq);\n\n\n\n    /* bridge to serial emulation module */\n\n    if (chr) {\n\n        serial_mm_init(address_space_mem,\n\n                       base + MMIO_BASE_OFFSET + SM501_UART0, 2,\n\n                       NULL, /* TODO : chain irq to IRL */\n\n                       115200, chr, DEVICE_NATIVE_ENDIAN);\n\n    }\n\n\n\n    /* create qemu graphic console */\n\n    s->con = graphic_console_init(DEVICE(dev), 0, &sm501_ops, s);\n\n}\n", "idx": 8425}
{"project": "qemu", "commit_id": "4a41a2d68a684241aca96dba066e0699941b730d", "target": 1, "func": "static void nbd_teardown_connection(NbdClientSession *client)\n\n{\n\n    struct nbd_request request = {\n\n        .type = NBD_CMD_DISC,\n\n        .from = 0,\n\n        .len = 0\n\n    };\n\n\n\n    nbd_send_request(client->sock, &request);\n\n\n\n    /* finish any pending coroutines */\n\n    shutdown(client->sock, 2);\n\n    nbd_recv_coroutines_enter_all(client);\n\n\n\n    qemu_aio_set_fd_handler(client->sock, NULL, NULL, NULL);\n\n    closesocket(client->sock);\n\n    client->sock = -1;\n\n}\n", "idx": 10312}
{"project": "qemu", "commit_id": "f2ad97ff81da51c064b9e87720ff48a0874f45d4", "target": 1, "func": "static int usb_xhci_post_load(void *opaque, int version_id)\n\n{\n\n    XHCIState *xhci = opaque;\n\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    dma_addr_t dcbaap, pctx;\n\n    uint32_t slot_ctx[4];\n\n    uint32_t ep_ctx[5];\n\n    int slotid, epid, state, intr;\n\n\n\n    dcbaap = xhci_addr64(xhci->dcbaap_low, xhci->dcbaap_high);\n\n\n\n    for (slotid = 1; slotid <= xhci->numslots; slotid++) {\n\n        slot = &xhci->slots[slotid-1];\n\n        if (!slot->addressed) {\n\n\n\n        slot->ctx =\n\n            xhci_mask64(ldq_le_pci_dma(pci_dev, dcbaap + 8 * slotid));\n\n        xhci_dma_read_u32s(xhci, slot->ctx, slot_ctx, sizeof(slot_ctx));\n\n        slot->uport = xhci_lookup_uport(xhci, slot_ctx);\n\n\n\n\n\n\n\n        assert(slot->uport && slot->uport->dev);\n\n\n\n        for (epid = 1; epid <= 31; epid++) {\n\n            pctx = slot->ctx + 32 * epid;\n\n            xhci_dma_read_u32s(xhci, pctx, ep_ctx, sizeof(ep_ctx));\n\n            state = ep_ctx[0] & EP_STATE_MASK;\n\n            if (state == EP_DISABLED) {\n\n\n\n            epctx = xhci_alloc_epctx(xhci, slotid, epid);\n\n            slot->eps[epid-1] = epctx;\n\n            xhci_init_epctx(epctx, pctx, ep_ctx);\n\n            epctx->state = state;\n\n            if (state == EP_RUNNING) {\n\n                /* kick endpoint after vmload is finished */\n\n                timer_mod(epctx->kick_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL));\n\n\n\n\n\n\n    for (intr = 0; intr < xhci->numintrs; intr++) {\n\n        if (xhci->intr[intr].msix_used) {\n\n            msix_vector_use(pci_dev, intr);\n\n        } else {\n\n            msix_vector_unuse(pci_dev, intr);\n\n\n\n\n\n    return 0;\n", "idx": 1987}
{"project": "qemu", "commit_id": "5e39d89d20b17cf6fb7f09d181d34f17b2ae2160", "target": 1, "func": "static QList *get_cpus(QDict **resp)\n\n{\n\n    *resp = qmp(\"{ 'execute': 'query-cpus' }\");\n\n    g_assert(*resp);\n\n    g_assert(qdict_haskey(*resp, \"return\"));\n\n    return  qdict_get_qlist(*resp, \"return\");\n\n}\n", "idx": 10331}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    NE2000State *s = opaque;\n\n    uint8_t *p;\n\n    int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] = \n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n    \n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (!ne2000_can_receive(s))\n\n        return;\n\n    \n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&                   \n\n                   s->mem[4] == buf[2] &&            \n\n                   s->mem[6] == buf[3] &&            \n\n                   s->mem[8] == buf[4] &&            \n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        avail = s->stop - index;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have receive something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n}\n", "idx": 5020}
{"project": "qemu", "commit_id": "c001ed15f7bfeaa3cabde5c9cc79c4dfdb674769", "target": 1, "func": "void cpu_dump_state (CPUCRISState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                     int flags)\n\n{\n\n\tint i;\n\n\tuint32_t srs;\n\n\n\n\tif (!env || !f)\n\n\t\treturn;\n\n\n\n\tcpu_fprintf(f, \"PC=%x CCS=%x btaken=%d btarget=%x\\n\"\n\n\t\t    \"cc_op=%d cc_src=%d cc_dest=%d cc_result=%x cc_mask=%x\\n\",\n\n\t\t    env->pc, env->pregs[PR_CCS], env->btaken, env->btarget,\n\n\t\t    env->cc_op,\n\n\t\t    env->cc_src, env->cc_dest, env->cc_result, env->cc_mask);\n\n\n\n\n\n\tfor (i = 0; i < 16; i++) {\n\n\t\tcpu_fprintf(f, \"%s=%8.8x \",regnames[i], env->regs[i]);\n\n\t\tif ((i + 1) % 4 == 0)\n\n\t\t\tcpu_fprintf(f, \"\\n\");\n\n\t}\n\n\tcpu_fprintf(f, \"\\nspecial regs:\\n\");\n\n\tfor (i = 0; i < 16; i++) {\n\n\t\tcpu_fprintf(f, \"%s=%8.8x \", pregnames[i], env->pregs[i]);\n\n\t\tif ((i + 1) % 4 == 0)\n\n\t\t\tcpu_fprintf(f, \"\\n\");\n\n\t}\n\n\tsrs = env->pregs[PR_SRS];\n\n\tcpu_fprintf(f, \"\\nsupport function regs bank %x:\\n\", srs);\n\n\tif (srs < 256) {\n\n\t\tfor (i = 0; i < 16; i++) {\n\n\t\t\tcpu_fprintf(f, \"s%2.2d=%8.8x \",\n\n\t\t\t\t    i, env->sregs[srs][i]);\n\n\t\t\tif ((i + 1) % 4 == 0)\n\n\t\t\t\tcpu_fprintf(f, \"\\n\");\n\n\t\t}\n\n\t}\n\n\tcpu_fprintf(f, \"\\n\\n\");\n\n\n\n}\n", "idx": 4920}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void migrate_add_blocker(Error *reason)\n\n{\n\n    migration_blockers = g_slist_prepend(migration_blockers, reason);\n\n}\n", "idx": 4622}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "static void vga_mm_init(VGAState *s, target_phys_addr_t vram_base,\n\n                        target_phys_addr_t ctrl_base, int it_shift)\n\n{\n\n    int s_ioport_ctrl, vga_io_memory;\n\n\n\n    s->it_shift = it_shift;\n\n    s_ioport_ctrl = cpu_register_io_memory(0, vga_mm_read_ctrl, vga_mm_write_ctrl, s);\n\n    vga_io_memory = cpu_register_io_memory(0, vga_mem_read, vga_mem_write, s);\n\n\n\n    register_savevm(\"vga\", 0, 2, vga_save, vga_load, s);\n\n\n\n    cpu_register_physical_memory(ctrl_base, 0x100000, s_ioport_ctrl);\n\n    s->bank_offset = 0;\n\n    cpu_register_physical_memory(vram_base + 0x000a0000, 0x20000, vga_io_memory);\n\n\n}", "idx": 9169}
{"project": "qemu", "commit_id": "b8afb520e479e693c227aa39c2fb7670743e104f", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                            int64_t speed, int64_t granularity,\n\n                            int64_t buf_size,\n\n                            BlockdevOnError on_source_error,\n\n                            BlockdevOnError on_target_error,\n\n                            BlockDriverCompletionFunc *cb,\n\n                            void *opaque, Error **errp,\n\n                            const BlockJobDriver *driver,\n\n                            bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n    if (granularity == 0) {\n\n        /* Choose the default granularity based on the target file's cluster\n\n         * size, clamped between 4k and 64k.  */\n\n        BlockDriverInfo bdi;\n\n        if (bdrv_get_info(target, &bdi) >= 0 && bdi.cluster_size != 0) {\n\n            granularity = MAX(4096, bdi.cluster_size);\n\n            granularity = MIN(65536, granularity);\n\n        } else {\n\n            granularity = 65536;\n\n        }\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        !bdrv_iostatus_is_enabled(bs)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = MAX(buf_size, granularity);\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity);\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    bdrv_set_on_error(s->target, on_target_error, on_target_error);\n\n    bdrv_iostatus_enable(s->target);\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 11615}
{"project": "qemu", "commit_id": "1ae3f2f178087711f9591350abad133525ba93f2", "target": 1, "func": "static void ehci_advance_state(EHCIState *ehci, int async)\n\n{\n\n    EHCIQueue *q = NULL;\n\n    int again;\n\n\n\n    do {\n\n        switch(ehci_get_state(ehci, async)) {\n\n        case EST_WAITLISTHEAD:\n\n            again = ehci_state_waitlisthead(ehci, async);\n\n            break;\n\n\n\n        case EST_FETCHENTRY:\n\n            again = ehci_state_fetchentry(ehci, async);\n\n            break;\n\n\n\n        case EST_FETCHQH:\n\n            q = ehci_state_fetchqh(ehci, async);\n\n            if (q != NULL) {\n\n                assert(q->async == async);\n\n                again = 1;\n\n            } else {\n\n                again = 0;\n\n            }\n\n            break;\n\n\n\n        case EST_FETCHITD:\n\n            again = ehci_state_fetchitd(ehci, async);\n\n            break;\n\n\n\n        case EST_FETCHSITD:\n\n            again = ehci_state_fetchsitd(ehci, async);\n\n            break;\n\n\n\n        case EST_ADVANCEQUEUE:\n\n            assert(q != NULL);\n\n            again = ehci_state_advqueue(q);\n\n            break;\n\n\n\n        case EST_FETCHQTD:\n\n            assert(q != NULL);\n\n            again = ehci_state_fetchqtd(q);\n\n            break;\n\n\n\n        case EST_HORIZONTALQH:\n\n            assert(q != NULL);\n\n            again = ehci_state_horizqh(q);\n\n            break;\n\n\n\n        case EST_EXECUTE:\n\n            assert(q != NULL);\n\n            again = ehci_state_execute(q);\n\n            if (async) {\n\n                ehci->async_stepdown = 0;\n\n            }\n\n            break;\n\n\n\n        case EST_EXECUTING:\n\n            assert(q != NULL);\n\n            if (async) {\n\n                ehci->async_stepdown = 0;\n\n            }\n\n            again = ehci_state_executing(q);\n\n            break;\n\n\n\n        case EST_WRITEBACK:\n\n            assert(q != NULL);\n\n            again = ehci_state_writeback(q);\n\n            if (!async) {\n\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            fprintf(stderr, \"Bad state!\\n\");\n\n            again = -1;\n\n            g_assert_not_reached();\n\n            break;\n\n        }\n\n\n\n        if (again < 0) {\n\n            fprintf(stderr, \"processing error - resetting ehci HC\\n\");\n\n            ehci_reset(ehci);\n\n            again = 0;\n\n        }\n\n    }\n\n    while (again);\n\n}\n", "idx": 2069}
{"project": "qemu", "commit_id": "2466119c9551d606a0f92f9832e0c865bc04b488", "target": 1, "func": "static inline int target_to_host_errno(int err)\n\n{\n\n    if (target_to_host_errno_table[err])\n\n        return target_to_host_errno_table[err];\n\n    return err;\n\n}\n", "idx": 10127}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "struct omap_mpu_state_s *omap2420_mpu_init(MemoryRegion *sysmem,\n\n                unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    struct omap_mpu_state_s *s = g_new0(struct omap_mpu_state_s, 1);\n\n    qemu_irq dma_irqs[4];\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    SysBusDevice *busdev;\n\n    struct omap_target_agent_s *ta;\n\n\n\n    /* Core */\n\n    s->mpu_model = omap2420;\n\n    s->cpu = cpu_arm_init(core ?: \"arm1136-r2\");\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP242X_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    memory_region_allocate_system_memory(&s->sdram, NULL, \"omap2.dram\",\n\n                                         s->sdram_size);\n\n    memory_region_add_subregion(sysmem, OMAP2_Q2_BASE, &s->sdram);\n\n    memory_region_init_ram(&s->sram, NULL, \"omap2.sram\", s->sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->sram);\n\n    memory_region_add_subregion(sysmem, OMAP2_SRAM_BASE, &s->sram);\n\n\n\n    s->l4 = omap_l4_init(sysmem, OMAP2_L4_BASE, 54);\n\n\n\n    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */\n\n    s->ih[0] = qdev_create(NULL, \"omap2-intc\");\n\n    qdev_prop_set_uint8(s->ih[0], \"revision\", 0x21);\n\n    qdev_prop_set_ptr(s->ih[0], \"fclk\", omap_findclk(s, \"mpu_intc_fclk\"));\n\n    qdev_prop_set_ptr(s->ih[0], \"iclk\", omap_findclk(s, \"mpu_intc_iclk\"));\n\n    qdev_init_nofail(s->ih[0]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ));\n\n    sysbus_connect_irq(busdev, 1,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ));\n\n    sysbus_mmio_map(busdev, 0, 0x480fe000);\n\n    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n\n                             qdev_get_gpio_in(s->ih[0],\n\n                                              OMAP_INT_24XX_PRCM_MPU_IRQ),\n\n                             NULL, NULL, s);\n\n\n\n    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n\n                    omap_findclk(s, \"omapctrl_iclk\"), s);\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        dma_irqs[i] = qdev_get_gpio_in(s->ih[omap2_dma_irq_map[i].ih],\n\n                                       omap2_dma_irq_map[i].intr);\n\n    }\n\n    s->dma = omap_dma4_init(0x48056000, dma_irqs, sysmem, s, 256, 32,\n\n                    omap_findclk(s, \"sdma_iclk\"),\n\n                    omap_findclk(s, \"sdma_fclk\"));\n\n    s->port->addr_valid = omap2_validate_addr;\n\n\n\n    /* Register SDRAM and SRAM ports for fast DMA transfers.  */\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->sdram),\n\n                         OMAP2_Q2_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->sram),\n\n                         OMAP2_SRAM_BASE, s->sram_size);\n\n\n\n    s->uart[0] = omap2_uart_init(sysmem, omap_l4ta(s->l4, 19),\n\n                                 qdev_get_gpio_in(s->ih[0],\n\n                                                  OMAP_INT_24XX_UART1_IRQ),\n\n                    omap_findclk(s, \"uart1_fclk\"),\n\n                    omap_findclk(s, \"uart1_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART1_TX],\n\n                    s->drq[OMAP24XX_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap2_uart_init(sysmem, omap_l4ta(s->l4, 20),\n\n                                 qdev_get_gpio_in(s->ih[0],\n\n                                                  OMAP_INT_24XX_UART2_IRQ),\n\n                    omap_findclk(s, \"uart2_fclk\"),\n\n                    omap_findclk(s, \"uart2_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART2_TX],\n\n                    s->drq[OMAP24XX_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap2_uart_init(sysmem, omap_l4ta(s->l4, 21),\n\n                                 qdev_get_gpio_in(s->ih[0],\n\n                                                  OMAP_INT_24XX_UART3_IRQ),\n\n                    omap_findclk(s, \"uart3_fclk\"),\n\n                    omap_findclk(s, \"uart3_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART3_TX],\n\n                    s->drq[OMAP24XX_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER1),\n\n                    omap_findclk(s, \"wu_gpt1_clk\"),\n\n                    omap_findclk(s, \"wu_l4_iclk\"));\n\n    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER2),\n\n                    omap_findclk(s, \"core_gpt2_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER3),\n\n                    omap_findclk(s, \"core_gpt3_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER4),\n\n                    omap_findclk(s, \"core_gpt4_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER5),\n\n                    omap_findclk(s, \"core_gpt5_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER6),\n\n                    omap_findclk(s, \"core_gpt6_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER7),\n\n                    omap_findclk(s, \"core_gpt7_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER8),\n\n                    omap_findclk(s, \"core_gpt8_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER9),\n\n                    omap_findclk(s, \"core_gpt9_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER10),\n\n                    omap_findclk(s, \"core_gpt10_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER11),\n\n                    omap_findclk(s, \"core_gpt11_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER12),\n\n                    omap_findclk(s, \"core_gpt12_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    omap_tap_init(omap_l4ta(s->l4, 2), s);\n\n\n\n    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n\n                    omap_findclk(s, \"clk32-kHz\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    s->i2c[0] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[0], \"revision\", 0x34);\n\n    qdev_prop_set_ptr(s->i2c[0], \"iclk\", omap_findclk(s, \"i2c1.iclk\"));\n\n    qdev_prop_set_ptr(s->i2c[0], \"fclk\", omap_findclk(s, \"i2c1.fclk\"));\n\n    qdev_init_nofail(s->i2c[0]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_I2C1_IRQ));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP24XX_DMA_I2C1_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP24XX_DMA_I2C1_RX]);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(omap_l4tao(s->l4, 5), 0));\n\n\n\n    s->i2c[1] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[1], \"revision\", 0x34);\n\n    qdev_prop_set_ptr(s->i2c[1], \"iclk\", omap_findclk(s, \"i2c2.iclk\"));\n\n    qdev_prop_set_ptr(s->i2c[1], \"fclk\", omap_findclk(s, \"i2c2.fclk\"));\n\n    qdev_init_nofail(s->i2c[1]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[1]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_I2C2_IRQ));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP24XX_DMA_I2C2_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP24XX_DMA_I2C2_RX]);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(omap_l4tao(s->l4, 6), 0));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap2-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"iclk\", omap_findclk(s, \"gpio_iclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk0\", omap_findclk(s, \"gpio1_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk1\", omap_findclk(s, \"gpio2_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk2\", omap_findclk(s, \"gpio3_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk3\", omap_findclk(s, \"gpio4_dbclk\"));\n\n    if (s->mpu_model == omap2430) {\n\n        qdev_prop_set_ptr(s->gpio, \"fclk4\", omap_findclk(s, \"gpio5_dbclk\"));\n\n    }\n\n    qdev_init_nofail(s->gpio);\n\n    busdev = SYS_BUS_DEVICE(s->gpio);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK1));\n\n    sysbus_connect_irq(busdev, 3,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK2));\n\n    sysbus_connect_irq(busdev, 6,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK3));\n\n    sysbus_connect_irq(busdev, 9,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK4));\n\n    if (s->mpu_model == omap2430) {\n\n        sysbus_connect_irq(busdev, 12,\n\n                           qdev_get_gpio_in(s->ih[0],\n\n                                            OMAP_INT_243X_GPIO_BANK5));\n\n    }\n\n    ta = omap_l4ta(s->l4, 3);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n\n    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n\n    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n\n    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n\n    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n\n\n\n    s->sdrc = omap_sdrc_init(sysmem, 0x68009000);\n\n    s->gpmc = omap_gpmc_init(s, 0x6800a000,\n\n                             qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPMC_IRQ),\n\n                             s->drq[OMAP24XX_DMA_GPMC]);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9),\n\n                    blk_by_legacy_dinfo(dinfo),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_MMC_IRQ),\n\n                    &s->drq[OMAP24XX_DMA_MMC1_TX],\n\n                    omap_findclk(s, \"mmc_fclk\"), omap_findclk(s, \"mmc_iclk\"));\n\n\n\n    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_MCSPI1_IRQ),\n\n                    &s->drq[OMAP24XX_DMA_SPI1_TX0],\n\n                    omap_findclk(s, \"spi1_fclk\"),\n\n                    omap_findclk(s, \"spi1_iclk\"));\n\n    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_MCSPI2_IRQ),\n\n                    &s->drq[OMAP24XX_DMA_SPI2_TX0],\n\n                    omap_findclk(s, \"spi2_fclk\"),\n\n                    omap_findclk(s, \"spi2_iclk\"));\n\n\n\n    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), sysmem, 0x68000800,\n\n                    /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_DSS_IRQ),\n\n                           s->drq[OMAP24XX_DMA_DSS],\n\n                    omap_findclk(s, \"dss_clk1\"), omap_findclk(s, \"dss_clk2\"),\n\n                    omap_findclk(s, \"dss_54m_clk\"),\n\n                    omap_findclk(s, \"dss_l3_iclk\"),\n\n                    omap_findclk(s, \"dss_l4_iclk\"));\n\n\n\n    omap_sti_init(omap_l4ta(s->l4, 18), sysmem, 0x54000000,\n\n                  qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_STI),\n\n                  omap_findclk(s, \"emul_ck\"),\n\n                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n\n                    serial_hds[3] : NULL);\n\n\n\n    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n\n                           qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_EAC_IRQ),\n\n                    /* Ten consecutive lines */\n\n                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n\n                    omap_findclk(s, \"func_96m_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    /* All register mappings (includin those not currenlty implemented):\n\n     * SystemControlMod\t48000000 - 48000fff\n\n     * SystemControlL4\t48001000 - 48001fff\n\n     * 32kHz Timer Mod\t48004000 - 48004fff\n\n     * 32kHz Timer L4\t48005000 - 48005fff\n\n     * PRCM ModA\t48008000 - 480087ff\n\n     * PRCM ModB\t48008800 - 48008fff\n\n     * PRCM L4\t\t48009000 - 48009fff\n\n     * TEST-BCM Mod\t48012000 - 48012fff\n\n     * TEST-BCM L4\t48013000 - 48013fff\n\n     * TEST-TAP Mod\t48014000 - 48014fff\n\n     * TEST-TAP L4\t48015000 - 48015fff\n\n     * GPIO1 Mod\t48018000 - 48018fff\n\n     * GPIO Top\t\t48019000 - 48019fff\n\n     * GPIO2 Mod\t4801a000 - 4801afff\n\n     * GPIO L4\t\t4801b000 - 4801bfff\n\n     * GPIO3 Mod\t4801c000 - 4801cfff\n\n     * GPIO4 Mod\t4801e000 - 4801efff\n\n     * WDTIMER1 Mod\t48020000 - 48010fff\n\n     * WDTIMER Top\t48021000 - 48011fff\n\n     * WDTIMER2 Mod\t48022000 - 48012fff\n\n     * WDTIMER L4\t48023000 - 48013fff\n\n     * WDTIMER3 Mod\t48024000 - 48014fff\n\n     * WDTIMER3 L4\t48025000 - 48015fff\n\n     * WDTIMER4 Mod\t48026000 - 48016fff\n\n     * WDTIMER4 L4\t48027000 - 48017fff\n\n     * GPTIMER1 Mod\t48028000 - 48018fff\n\n     * GPTIMER1 L4\t48029000 - 48019fff\n\n     * GPTIMER2 Mod\t4802a000 - 4801afff\n\n     * GPTIMER2 L4\t4802b000 - 4801bfff\n\n     * L4-Config AP\t48040000 - 480407ff\n\n     * L4-Config IP\t48040800 - 48040fff\n\n     * L4-Config LA\t48041000 - 48041fff\n\n     * ARM11ETB Mod\t48048000 - 48049fff\n\n     * ARM11ETB L4\t4804a000 - 4804afff\n\n     * DISPLAY Top\t48050000 - 480503ff\n\n     * DISPLAY DISPC\t48050400 - 480507ff\n\n     * DISPLAY RFBI\t48050800 - 48050bff\n\n     * DISPLAY VENC\t48050c00 - 48050fff\n\n     * DISPLAY L4\t48051000 - 48051fff\n\n     * CAMERA Top\t48052000 - 480523ff\n\n     * CAMERA core\t48052400 - 480527ff\n\n     * CAMERA DMA\t48052800 - 48052bff\n\n     * CAMERA MMU\t48052c00 - 48052fff\n\n     * CAMERA L4\t48053000 - 48053fff\n\n     * SDMA Mod\t\t48056000 - 48056fff\n\n     * SDMA L4\t\t48057000 - 48057fff\n\n     * SSI Top\t\t48058000 - 48058fff\n\n     * SSI GDD\t\t48059000 - 48059fff\n\n     * SSI Port1\t4805a000 - 4805afff\n\n     * SSI Port2\t4805b000 - 4805bfff\n\n     * SSI L4\t\t4805c000 - 4805cfff\n\n     * USB Mod\t\t4805e000 - 480fefff\n\n     * USB L4\t\t4805f000 - 480fffff\n\n     * WIN_TRACER1 Mod\t48060000 - 48060fff\n\n     * WIN_TRACER1 L4\t48061000 - 48061fff\n\n     * WIN_TRACER2 Mod\t48062000 - 48062fff\n\n     * WIN_TRACER2 L4\t48063000 - 48063fff\n\n     * WIN_TRACER3 Mod\t48064000 - 48064fff\n\n     * WIN_TRACER3 L4\t48065000 - 48065fff\n\n     * WIN_TRACER4 Top\t48066000 - 480660ff\n\n     * WIN_TRACER4 ETT\t48066100 - 480661ff\n\n     * WIN_TRACER4 WT\t48066200 - 480662ff\n\n     * WIN_TRACER4 L4\t48067000 - 48067fff\n\n     * XTI Mod\t\t48068000 - 48068fff\n\n     * XTI L4\t\t48069000 - 48069fff\n\n     * UART1 Mod\t4806a000 - 4806afff\n\n     * UART1 L4\t\t4806b000 - 4806bfff\n\n     * UART2 Mod\t4806c000 - 4806cfff\n\n     * UART2 L4\t\t4806d000 - 4806dfff\n\n     * UART3 Mod\t4806e000 - 4806efff\n\n     * UART3 L4\t\t4806f000 - 4806ffff\n\n     * I2C1 Mod\t\t48070000 - 48070fff\n\n     * I2C1 L4\t\t48071000 - 48071fff\n\n     * I2C2 Mod\t\t48072000 - 48072fff\n\n     * I2C2 L4\t\t48073000 - 48073fff\n\n     * McBSP1 Mod\t48074000 - 48074fff\n\n     * McBSP1 L4\t48075000 - 48075fff\n\n     * McBSP2 Mod\t48076000 - 48076fff\n\n     * McBSP2 L4\t48077000 - 48077fff\n\n     * GPTIMER3 Mod\t48078000 - 48078fff\n\n     * GPTIMER3 L4\t48079000 - 48079fff\n\n     * GPTIMER4 Mod\t4807a000 - 4807afff\n\n     * GPTIMER4 L4\t4807b000 - 4807bfff\n\n     * GPTIMER5 Mod\t4807c000 - 4807cfff\n\n     * GPTIMER5 L4\t4807d000 - 4807dfff\n\n     * GPTIMER6 Mod\t4807e000 - 4807efff\n\n     * GPTIMER6 L4\t4807f000 - 4807ffff\n\n     * GPTIMER7 Mod\t48080000 - 48080fff\n\n     * GPTIMER7 L4\t48081000 - 48081fff\n\n     * GPTIMER8 Mod\t48082000 - 48082fff\n\n     * GPTIMER8 L4\t48083000 - 48083fff\n\n     * GPTIMER9 Mod\t48084000 - 48084fff\n\n     * GPTIMER9 L4\t48085000 - 48085fff\n\n     * GPTIMER10 Mod\t48086000 - 48086fff\n\n     * GPTIMER10 L4\t48087000 - 48087fff\n\n     * GPTIMER11 Mod\t48088000 - 48088fff\n\n     * GPTIMER11 L4\t48089000 - 48089fff\n\n     * GPTIMER12 Mod\t4808a000 - 4808afff\n\n     * GPTIMER12 L4\t4808b000 - 4808bfff\n\n     * EAC Mod\t\t48090000 - 48090fff\n\n     * EAC L4\t\t48091000 - 48091fff\n\n     * FAC Mod\t\t48092000 - 48092fff\n\n     * FAC L4\t\t48093000 - 48093fff\n\n     * MAILBOX Mod\t48094000 - 48094fff\n\n     * MAILBOX L4\t48095000 - 48095fff\n\n     * SPI1 Mod\t\t48098000 - 48098fff\n\n     * SPI1 L4\t\t48099000 - 48099fff\n\n     * SPI2 Mod\t\t4809a000 - 4809afff\n\n     * SPI2 L4\t\t4809b000 - 4809bfff\n\n     * MMC/SDIO Mod\t4809c000 - 4809cfff\n\n     * MMC/SDIO L4\t4809d000 - 4809dfff\n\n     * MS_PRO Mod\t4809e000 - 4809efff\n\n     * MS_PRO L4\t4809f000 - 4809ffff\n\n     * RNG Mod\t\t480a0000 - 480a0fff\n\n     * RNG L4\t\t480a1000 - 480a1fff\n\n     * DES3DES Mod\t480a2000 - 480a2fff\n\n     * DES3DES L4\t480a3000 - 480a3fff\n\n     * SHA1MD5 Mod\t480a4000 - 480a4fff\n\n     * SHA1MD5 L4\t480a5000 - 480a5fff\n\n     * AES Mod\t\t480a6000 - 480a6fff\n\n     * AES L4\t\t480a7000 - 480a7fff\n\n     * PKA Mod\t\t480a8000 - 480a9fff\n\n     * PKA L4\t\t480aa000 - 480aafff\n\n     * MG Mod\t\t480b0000 - 480b0fff\n\n     * MG L4\t\t480b1000 - 480b1fff\n\n     * HDQ/1-wire Mod\t480b2000 - 480b2fff\n\n     * HDQ/1-wire L4\t480b3000 - 480b3fff\n\n     * MPU interrupt\t480fe000 - 480fefff\n\n     * STI channel base\t54000000 - 5400ffff\n\n     * IVA RAM\t\t5c000000 - 5c01ffff\n\n     * IVA ROM\t\t5c020000 - 5c027fff\n\n     * IMG_BUF_A\t5c040000 - 5c040fff\n\n     * IMG_BUF_B\t5c042000 - 5c042fff\n\n     * VLCDS\t\t5c048000 - 5c0487ff\n\n     * IMX_COEF\t\t5c049000 - 5c04afff\n\n     * IMX_CMD\t\t5c051000 - 5c051fff\n\n     * VLCDQ\t\t5c053000 - 5c0533ff\n\n     * VLCDH\t\t5c054000 - 5c054fff\n\n     * SEQ_CMD\t\t5c055000 - 5c055fff\n\n     * IMX_REG\t\t5c056000 - 5c0560ff\n\n     * VLCD_REG\t\t5c056100 - 5c0561ff\n\n     * SEQ_REG\t\t5c056200 - 5c0562ff\n\n     * IMG_BUF_REG\t5c056300 - 5c0563ff\n\n     * SEQIRQ_REG\t5c056400 - 5c0564ff\n\n     * OCP_REG\t\t5c060000 - 5c060fff\n\n     * SYSC_REG\t\t5c070000 - 5c070fff\n\n     * MMU_REG\t\t5d000000 - 5d000fff\n\n     * sDMA R\t\t68000400 - 680005ff\n\n     * sDMA W\t\t68000600 - 680007ff\n\n     * Display Control\t68000800 - 680009ff\n\n     * DSP subsystem\t68000a00 - 68000bff\n\n     * MPU subsystem\t68000c00 - 68000dff\n\n     * IVA subsystem\t68001000 - 680011ff\n\n     * USB\t\t68001200 - 680013ff\n\n     * Camera\t\t68001400 - 680015ff\n\n     * VLYNQ (firewall)\t68001800 - 68001bff\n\n     * VLYNQ\t\t68001e00 - 68001fff\n\n     * SSI\t\t68002000 - 680021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     */\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 9227}
{"project": "qemu", "commit_id": "c9ad19c57b4e35dda507ec636443069048a4ad72", "target": 1, "func": "void helper_fxtract(void)\n\n{\n\n    CPU86_LDoubleU temp;\n\n    unsigned int expdif;\n\n\n\n    temp.d = ST0;\n\n    expdif = EXPD(temp) - EXPBIAS;\n\n    /*DP exponent bias*/\n\n    ST0 = expdif;\n\n    fpush();\n\n    BIASEXPONENT(temp);\n\n    ST0 = temp.d;\n\n}\n", "idx": 24}
{"project": "qemu", "commit_id": "7f0d763ce60fd0563cb71c85ae0f86ee71b7edcc", "target": 1, "func": "void DBDMA_register_channel(void *dbdma, int nchan, qemu_irq irq,\n\n                            DBDMA_rw rw, DBDMA_flush flush,\n\n                            void *opaque)\n\n{\n\n    DBDMAState *s = dbdma;\n\n    DBDMA_channel *ch = &s->channels[nchan];\n\n\n\n    DBDMA_DPRINTF(\"DBDMA_register_channel 0x%x\\n\", nchan);\n\n\n\n    ch->irq = irq;\n\n    ch->channel = nchan;\n\n    ch->rw = rw;\n\n    ch->flush = flush;\n\n    ch->io.opaque = opaque;\n\n    ch->io.channel = ch;\n\n}\n", "idx": 30}
{"project": "qemu", "commit_id": "3a3567d337d3ee6fb2e2fcc1d27cd045ed97ae9b", "target": 1, "func": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            io_remove_watch_poll(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (s->timer_tag) {\n\n            g_source_remove(s->timer_tag);\n\n            s->timer_tag = 0;\n\n        }\n\n        if (!s->connected) {\n\n            qemu_chr_be_generic_open(chr);\n\n            s->connected = 1;\n\n            s->fd_tag = io_add_watch_poll(s->fd, pty_chr_read_poll, pty_chr_read, chr);\n\n        }\n\n    }\n\n}\n", "idx": 9523}
{"project": "qemu", "commit_id": "038268e2e8087ee2fd8987a77ba580e15f14c147", "target": 1, "func": "void ide_dma_cb(void *opaque, int ret)\n\n{\n\n    IDEState *s = opaque;\n\n    int n;\n\n    int64_t sector_num;\n\n    bool stay_active = false;\n\n\n\n    if (ret < 0) {\n\n        int op = BM_STATUS_DMA_RETRY;\n\n\n\n        if (s->dma_cmd == IDE_DMA_READ)\n\n            op |= BM_STATUS_RETRY_READ;\n\n        else if (s->dma_cmd == IDE_DMA_TRIM)\n\n            op |= BM_STATUS_RETRY_TRIM;\n\n\n\n        if (ide_handle_rw_error(s, -ret, op)) {\n\n            return;\n\n\n\n\n\n    n = s->io_buffer_size >> 9;\n\n    if (n > s->nsector) {\n\n        /* The PRDs were longer than needed for this request. Shorten them so\n\n         * we don't get a negative remainder. The Active bit must remain set\n\n         * after the request completes. */\n\n        n = s->nsector;\n\n        stay_active = true;\n\n\n\n\n    sector_num = ide_get_sector(s);\n\n    if (n > 0) {\n\n        dma_buf_commit(s);\n\n        sector_num += n;\n\n        ide_set_sector(s, sector_num);\n\n        s->nsector -= n;\n\n\n\n\n    /* end of transfer ? */\n\n    if (s->nsector == 0) {\n\n        s->status = READY_STAT | SEEK_STAT;\n\n        ide_set_irq(s->bus);\n\n        goto eot;\n\n\n\n\n    /* launch next transfer */\n\n    n = s->nsector;\n\n    s->io_buffer_index = 0;\n\n    s->io_buffer_size = n * 512;\n\n    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {\n\n        /* The PRDs were too short. Reset the Active bit, but don't raise an\n\n         * interrupt. */\n\n        goto eot;\n\n\n\n\n#ifdef DEBUG_AIO\n\n    printf(\"ide_dma_cb: sector_num=%\" PRId64 \" n=%d, cmd_cmd=%d\\n\",\n\n           sector_num, n, s->dma_cmd);\n\n#endif\n\n\n\n    switch (s->dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        s->bus->dma->aiocb = dma_bdrv_read(s->bs, &s->sg, sector_num,\n\n                                           ide_dma_cb, s);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        s->bus->dma->aiocb = dma_bdrv_write(s->bs, &s->sg, sector_num,\n\n                                            ide_dma_cb, s);\n\n        break;\n\n    case IDE_DMA_TRIM:\n\n        s->bus->dma->aiocb = dma_bdrv_io(s->bs, &s->sg, sector_num,\n\n                                         ide_issue_trim, ide_dma_cb, s,\n\n                                         DMA_DIRECTION_TO_DEVICE);\n\n        break;\n\n\n    return;\n\n\n\neot:\n\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n\n        bdrv_acct_done(s->bs, &s->acct);\n\n\n    ide_set_inactive(s);\n\n\n\n", "idx": 2472}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsrd(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n        gen_helper_store_msr(cpu_env, cpu_gpr[rS(ctx->opcode)]);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 11829}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    int i;\n\n\n\n    vnc_jobs_join(vs); /* Wait encoding jobs */\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n\n\n    buffer_free(&vs->input);\n\n    buffer_free(&vs->output);\n\n    buffer_free(&vs->ws_input);\n\n    buffer_free(&vs->ws_output);\n\n\n\n    qapi_free_VncClientInfo(vs->info);\n\n\n\n    vnc_zlib_clear(vs);\n\n    vnc_tight_clear(vs);\n\n    vnc_zrle_clear(vs);\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n    audio_del(vs);\n\n    vnc_release_modifiers(vs);\n\n\n\n    if (vs->initialized) {\n\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n    }\n\n\n\n    if (vs->vd->lock_key_sync)\n\n        qemu_remove_led_event_handler(vs->led);\n\n    vnc_unlock_output(vs);\n\n\n\n    qemu_mutex_destroy(&vs->output_mutex);\n\n    if (vs->bh != NULL) {\n\n        qemu_bh_delete(vs->bh);\n\n    }\n\n    buffer_free(&vs->jobs_buffer);\n\n\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        g_free(vs->lossy_rect[i]);\n\n    }\n\n    g_free(vs->lossy_rect);\n\n    g_free(vs);\n\n}\n", "idx": 2514}
{"project": "qemu", "commit_id": "7f0278435df1fa845b3bd9556942f89296d4246b", "target": 1, "func": "static void qmp_input_type_str(Visitor *v, char **obj, const char *name,\n\n                               Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n\n\n\n    if (!qobj || qobject_type(qobj) != QTYPE_QSTRING) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"string\");\n\n        return;\n\n    }\n\n\n\n    *obj = g_strdup(qstring_get_str(qobject_to_qstring(qobj)));\n\n}\n", "idx": 5686}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n\n                                   int64_t count, Error **errp)\n\n{\n\n    GuestFileRead *read_data = NULL;\n\n    guchar *buf;\n\n    HANDLE fh;\n\n    bool is_ok;\n\n    DWORD read_count;\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n\n\n    if (!gfh) {\n\n        return NULL;\n\n    }\n\n    if (!has_count) {\n\n        count = QGA_READ_COUNT_DEFAULT;\n\n    } else if (count < 0) {\n\n        error_setg(errp, \"value '%\" PRId64\n\n                   \"' is invalid for argument count\", count);\n\n        return NULL;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    buf = g_malloc0(count+1);\n\n    is_ok = ReadFile(fh, buf, count, &read_count, NULL);\n\n    if (!is_ok) {\n\n        error_setg_win32(errp, GetLastError(), \"failed to read file\");\n\n        slog(\"guest-file-read failed, handle %\" PRId64, handle);\n\n    } else {\n\n        buf[read_count] = 0;\n\n        read_data = g_malloc0(sizeof(GuestFileRead));\n\n        read_data->count = (size_t)read_count;\n\n        read_data->eof = read_count == 0;\n\n\n\n        if (read_count != 0) {\n\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n\n        }\n\n    }\n\n    g_free(buf);\n\n\n\n    return read_data;\n\n}\n", "idx": 14}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_copy_from_backing_file(BDRVQEDState *s, uint64_t pos,\n\n                                       uint64_t len, uint64_t offset,\n\n                                       BlockDriverCompletionFunc *cb,\n\n                                       void *opaque)\n\n{\n\n    CopyFromBackingFileCB *copy_cb;\n\n\n\n    /* Skip copy entirely if there is no work to do */\n\n    if (len == 0) {\n\n        cb(opaque, 0);\n\n        return;\n\n    }\n\n\n\n    copy_cb = gencb_alloc(sizeof(*copy_cb), cb, opaque);\n\n    copy_cb->s = s;\n\n    copy_cb->offset = offset;\n\n    copy_cb->iov.iov_base = qemu_blockalign(s->bs, len);\n\n    copy_cb->iov.iov_len = len;\n\n    qemu_iovec_init_external(&copy_cb->qiov, &copy_cb->iov, 1);\n\n\n\n    qed_read_backing_file(s, pos, &copy_cb->qiov,\n\n                          qed_copy_from_backing_file_write, copy_cb);\n\n}\n", "idx": 10474}
{"project": "qemu", "commit_id": "baa61b9870dd7e0bb07e0ae61c6ec805db13f699", "target": 1, "func": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_balloon_device_exit;\n\n    dc->props = virtio_balloon_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->init = virtio_balloon_device_init;\n\n    vdc->get_config = virtio_balloon_get_config;\n\n    vdc->set_config = virtio_balloon_set_config;\n\n    vdc->get_features = virtio_balloon_get_features;\n\n}\n", "idx": 282}
{"project": "qemu", "commit_id": "491d68d9382dbb588f2ff5132ee3d87ce2f1b230", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n\n                               unsigned int epid)\n\n{\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_disable(slotid, epid);\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    assert(epid >= 1 && epid <= 31);\n\n\n\n    slot = &xhci->slots[slotid-1];\n\n\n\n    if (!slot->eps[epid-1]) {\n\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n\n        return CC_SUCCESS;\n\n    }\n\n\n\n    xhci_ep_nuke_xfers(xhci, slotid, epid, 0);\n\n\n\n    epctx = slot->eps[epid-1];\n\n\n\n    if (epctx->nr_pstreams) {\n\n        xhci_free_streams(epctx);\n\n    }\n\n\n\n    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) {\n\n        usb_packet_cleanup(&epctx->transfers[i].packet);\n\n    }\n\n\n\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n\n\n\n    timer_free(epctx->kick_timer);\n\n    g_free(epctx);\n\n    slot->eps[epid-1] = NULL;\n\n\n\n    return CC_SUCCESS;\n\n}\n", "idx": 2748}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4442}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mul(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_ov = tcg_temp_new();\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_ov, srca, srcb);\n\n    tcg_gen_sari_tl(t0, dest, TARGET_LONG_BITS - 1);\n\n    tcg_gen_setcond_tl(TCG_COND_NE, sr_ov, sr_ov, t0);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);\n\n\n\n    gen_ove_ov(dc, sr_ov);\n\n    tcg_temp_free(sr_ov);\n\n}\n", "idx": 11745}
{"project": "qemu", "commit_id": "949013ce111eb64f8bc81cf9a9f1cefd6a1678c3", "target": 1, "func": "static void disas_ldst_reg_imm9(DisasContext *s, uint32_t insn)\n\n{\n\n    int rt = extract32(insn, 0, 5);\n\n    int rn = extract32(insn, 5, 5);\n\n    int imm9 = sextract32(insn, 12, 9);\n\n    int opc = extract32(insn, 22, 2);\n\n    int size = extract32(insn, 30, 2);\n\n    int idx = extract32(insn, 10, 2);\n\n    bool is_signed = false;\n\n    bool is_store = false;\n\n    bool is_extended = false;\n\n    bool is_unpriv = (idx == 2);\n\n    bool is_vector = extract32(insn, 26, 1);\n\n    bool post_index;\n\n    bool writeback;\n\n\n\n    TCGv_i64 tcg_addr;\n\n\n\n    if (is_vector) {\n\n        size |= (opc & 2) << 1;\n\n        if (size > 4 || is_unpriv) {\n\n            unallocated_encoding(s);\n\n            return;\n\n        }\n\n        is_store = ((opc & 1) == 0);\n\n        if (!fp_access_check(s)) {\n\n            return;\n\n        }\n\n    } else {\n\n        if (size == 3 && opc == 2) {\n\n            /* PRFM - prefetch */\n\n            if (is_unpriv) {\n\n                unallocated_encoding(s);\n\n                return;\n\n            }\n\n            return;\n\n        }\n\n        if (opc == 3 && size > 1) {\n\n            unallocated_encoding(s);\n\n            return;\n\n        }\n\n        is_store = (opc == 0);\n\n        is_signed = opc & (1<<1);\n\n        is_extended = (size < 3) && (opc & 1);\n\n    }\n\n\n\n    switch (idx) {\n\n    case 0:\n\n    case 2:\n\n        post_index = false;\n\n        writeback = false;\n\n        break;\n\n    case 1:\n\n        post_index = true;\n\n        writeback = true;\n\n        break;\n\n    case 3:\n\n        post_index = false;\n\n        writeback = true;\n\n        break;\n\n    }\n\n\n\n    if (rn == 31) {\n\n        gen_check_sp_alignment(s);\n\n    }\n\n    tcg_addr = read_cpu_reg_sp(s, rn, 1);\n\n\n\n    if (!post_index) {\n\n        tcg_gen_addi_i64(tcg_addr, tcg_addr, imm9);\n\n    }\n\n\n\n    if (is_vector) {\n\n        if (is_store) {\n\n            do_fp_st(s, rt, tcg_addr, size);\n\n        } else {\n\n            do_fp_ld(s, rt, tcg_addr, size);\n\n        }\n\n    } else {\n\n        TCGv_i64 tcg_rt = cpu_reg(s, rt);\n\n        int memidx = is_unpriv ? 1 : get_mem_index(s);\n\n\n\n        if (is_store) {\n\n            do_gpr_st_memidx(s, tcg_rt, tcg_addr, size, memidx);\n\n        } else {\n\n            do_gpr_ld_memidx(s, tcg_rt, tcg_addr, size,\n\n                             is_signed, is_extended, memidx);\n\n        }\n\n    }\n\n\n\n    if (writeback) {\n\n        TCGv_i64 tcg_rn = cpu_reg_sp(s, rn);\n\n        if (post_index) {\n\n            tcg_gen_addi_i64(tcg_addr, tcg_addr, imm9);\n\n        }\n\n        tcg_gen_mov_i64(tcg_rn, tcg_addr);\n\n    }\n\n}\n", "idx": 1766}
{"project": "qemu", "commit_id": "661e32fb3cb71c7e019daee375be4bb487b9917c", "target": 1, "func": "void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,\n\n                            uint32_t event, uint32_t reason)\n\n{\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    VirtIOSCSIReq *req;\n\n    VirtIOSCSIEvent *evt;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n\n\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        return;\n\n    }\n\n\n\n    if (s->dataplane_started) {\n\n        assert(s->ctx);\n\n        aio_context_acquire(s->ctx);\n\n    }\n\n\n\n    req = virtio_scsi_pop_req(s, vs->event_vq);\n\n    if (!req) {\n\n        s->events_dropped = true;\n\n        goto out;\n\n    }\n\n\n\n    if (s->events_dropped) {\n\n        event |= VIRTIO_SCSI_T_EVENTS_MISSED;\n\n        s->events_dropped = false;\n\n    }\n\n\n\n    if (virtio_scsi_parse_req(req, 0, sizeof(VirtIOSCSIEvent))) {\n\n        virtio_scsi_bad_req();\n\n    }\n\n\n\n    evt = &req->resp.event;\n\n    memset(evt, 0, sizeof(VirtIOSCSIEvent));\n\n    evt->event = virtio_tswap32(vdev, event);\n\n    evt->reason = virtio_tswap32(vdev, reason);\n\n    if (!dev) {\n\n        assert(event == VIRTIO_SCSI_T_EVENTS_MISSED);\n\n    } else {\n\n        evt->lun[0] = 1;\n\n        evt->lun[1] = dev->id;\n\n\n\n        /* Linux wants us to keep the same encoding we use for REPORT LUNS.  */\n\n        if (dev->lun >= 256) {\n\n            evt->lun[2] = (dev->lun >> 8) | 0x40;\n\n        }\n\n        evt->lun[3] = dev->lun & 0xFF;\n\n    }\n\n    virtio_scsi_complete_req(req);\n\nout:\n\n    if (s->dataplane_started) {\n\n        aio_context_release(s->ctx);\n\n    }\n\n}\n", "idx": 10105}
{"project": "qemu", "commit_id": "c9c3c80af71dd2b7813d1ada9b14cb51df584221", "target": 1, "func": "static void rtas_ibm_read_pci_config(sPAPREnvironment *spapr,\n\n                                     uint32_t token, uint32_t nargs,\n\n                                     target_ulong args,\n\n                                     uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t val, size, addr;\n\n    uint64_t buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    PCIDevice *dev = find_dev(spapr, buid, rtas_ld(args, 0));\n\n\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n    size = rtas_ld(args, 3);\n\n    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));\n\n    val = pci_default_read_config(dev, addr, size);\n\n    rtas_st(rets, 0, 0);\n\n    rtas_st(rets, 1, val);\n\n}\n", "idx": 232}
{"project": "qemu", "commit_id": "42e38c1fd0199155d32f3464aedce282d3d7f6a1", "target": 1, "func": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n\n{\n\n    BlockRequest *blkreq;\n\n    uint64_t sector;\n\n\n\n    sector = virtio_ldq_p(VIRTIO_DEVICE(req->dev), &req->out.sector);\n\n\n\n    bdrv_acct_start(req->dev->bs, &req->acct, req->qiov.size, BDRV_ACCT_WRITE);\n\n\n\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n\n\n\n    if (!virtio_blk_sect_range_ok(req->dev, sector, req->qiov.size)) {\n\n        virtio_blk_rw_complete(req, -EIO);\n\n        return;\n\n    }\n\n\n\n    if (mrb->num_writes == 32) {\n\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n\n    }\n\n\n\n    blkreq = &mrb->blkreq[mrb->num_writes];\n\n    blkreq->sector = sector;\n\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n\n    blkreq->qiov = &req->qiov;\n\n    blkreq->cb = virtio_blk_rw_complete;\n\n    blkreq->opaque = req;\n\n    blkreq->error = 0;\n\n\n\n    mrb->num_writes++;\n\n}\n", "idx": 7233}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static uint32_t m5206_mbar_readw(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width > 2) {\n\n        uint32_t val;\n\n        val = m5206_mbar_readl(opaque, offset & ~3);\n\n        if ((offset & 3) == 0)\n\n            val >>= 16;\n\n        return val & 0xffff;\n\n    } else if (width < 2) {\n\n        uint16_t val;\n\n        val = m5206_mbar_readb(opaque, offset) << 8;\n\n        val |= m5206_mbar_readb(opaque, offset + 1);\n\n        return val;\n\n    }\n\n    return m5206_mbar_read(s, offset, 2);\n\n}\n", "idx": 814}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    ADBDeviceClass *adc = ADB_DEVICE_CLASS(oc);\n\n    ADBMouseClass *amc = ADB_MOUSE_CLASS(oc);\n\n\n\n    amc->parent_realize = dc->realize;\n\n    dc->realize = adb_mouse_realizefn;\n\n    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);\n\n\n\n    adc->devreq = adb_mouse_request;\n\n    dc->reset = adb_mouse_reset;\n\n    dc->vmsd = &vmstate_adb_mouse;\n\n}\n", "idx": 7621}
{"project": "qemu", "commit_id": "581fe784c3adf85dc167a47a4a60fd1245a98217", "target": 1, "func": "connect_to_qemu(\n\n    const char *host,\n\n    const char *port\n\n) {\n\n    struct addrinfo hints;\n\n    struct addrinfo *server;\n\n    int ret, sock;\n\n\n\n    sock = qemu_socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        /* Error */\n\n        fprintf(stderr, \"Error opening socket!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    memset(&hints, 0, sizeof(struct addrinfo));\n\n    hints.ai_family = AF_UNSPEC;\n\n    hints.ai_socktype = SOCK_STREAM;\n\n    hints.ai_flags = 0;\n\n    hints.ai_protocol = 0;          /* Any protocol */\n\n\n\n    ret = getaddrinfo(host, port, &hints, &server);\n\n\n\n    if (ret != 0) {\n\n        /* Error */\n\n        fprintf(stderr, \"getaddrinfo failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (connect(sock, server->ai_addr, server->ai_addrlen) < 0) {\n\n        /* Error */\n\n        fprintf(stderr, \"Could not connect\\n\");\n\n        return -1;\n\n    }\n\n    if (verbose) {\n\n        printf(\"Connected (sizeof Header=%zd)!\\n\", sizeof(VSCMsgHeader));\n\n    }\n\n    return sock;\n\n}\n", "idx": 10576}
{"project": "qemu", "commit_id": "458f3b2c953bdc7110896cb3691251023652523f", "target": 1, "func": "static void test_rtas_get_time_of_day(void)\n\n{\n\n    QOSState *qs;\n\n    struct tm tm;\n\n    uint32_t ns;\n\n    uint64_t ret;\n\n    time_t t1, t2;\n\n\n\n    qs = qtest_spapr_boot(\"-machine pseries\");\n\n    g_assert(qs != NULL);\n\n\n\n    t1 = time(NULL);\n\n    ret = qrtas_get_time_of_day(qs->alloc, &tm, &ns);\n\n    g_assert_cmpint(ret, ==, 0);\n\n    t2 = mktimegm(&tm);\n\n    g_assert(t2 - t1 < 5); /* 5 sec max to run the test */\n\n\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 8049}
{"project": "qemu", "commit_id": "fac7aa7fc2ebc26803b0a7b44b010f47ce3e1dd8", "target": 1, "func": "static void  ahci_port_write(AHCIState *s, int port, int offset, uint32_t val)\n\n{\n\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n\n\n\n    DPRINTF(port, \"offset: 0x%x val: 0x%x\\n\", offset, val);\n\n    switch (offset) {\n\n        case PORT_LST_ADDR:\n\n            pr->lst_addr = val;\n\n            map_page(s->as, &s->dev[port].lst,\n\n                     ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n\n            s->dev[port].cur_cmd = NULL;\n\n            break;\n\n        case PORT_LST_ADDR_HI:\n\n            pr->lst_addr_hi = val;\n\n            map_page(s->as, &s->dev[port].lst,\n\n                     ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n\n            s->dev[port].cur_cmd = NULL;\n\n            break;\n\n        case PORT_FIS_ADDR:\n\n            pr->fis_addr = val;\n\n            map_page(s->as, &s->dev[port].res_fis,\n\n                     ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n\n            break;\n\n        case PORT_FIS_ADDR_HI:\n\n            pr->fis_addr_hi = val;\n\n            map_page(s->as, &s->dev[port].res_fis,\n\n                     ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n\n            break;\n\n        case PORT_IRQ_STAT:\n\n            pr->irq_stat &= ~val;\n\n            ahci_check_irq(s);\n\n            break;\n\n        case PORT_IRQ_MASK:\n\n            pr->irq_mask = val & 0xfdc000ff;\n\n            ahci_check_irq(s);\n\n            break;\n\n        case PORT_CMD:\n\n            pr->cmd = val & ~(PORT_CMD_LIST_ON | PORT_CMD_FIS_ON);\n\n\n\n            if (pr->cmd & PORT_CMD_START) {\n\n                pr->cmd |= PORT_CMD_LIST_ON;\n\n            }\n\n\n\n            if (pr->cmd & PORT_CMD_FIS_RX) {\n\n                pr->cmd |= PORT_CMD_FIS_ON;\n\n            }\n\n\n\n            /* XXX usually the FIS would be pending on the bus here and\n\n                   issuing deferred until the OS enables FIS receival.\n\n                   Instead, we only submit it once - which works in most\n\n                   cases, but is a hack. */\n\n            if ((pr->cmd & PORT_CMD_FIS_ON) &&\n\n                !s->dev[port].init_d2h_sent) {\n\n                ahci_init_d2h(&s->dev[port]);\n\n                s->dev[port].init_d2h_sent = true;\n\n            }\n\n\n\n            check_cmd(s, port);\n\n            break;\n\n        case PORT_TFDATA:\n\n            s->dev[port].port.ifs[0].error = (val >> 8) & 0xff;\n\n            s->dev[port].port.ifs[0].status = val & 0xff;\n\n            break;\n\n        case PORT_SIG:\n\n            pr->sig = val;\n\n            break;\n\n        case PORT_SCR_STAT:\n\n            pr->scr_stat = val;\n\n            break;\n\n        case PORT_SCR_CTL:\n\n            if (((pr->scr_ctl & AHCI_SCR_SCTL_DET) == 1) &&\n\n                ((val & AHCI_SCR_SCTL_DET) == 0)) {\n\n                ahci_reset_port(s, port);\n\n            }\n\n            pr->scr_ctl = val;\n\n            break;\n\n        case PORT_SCR_ERR:\n\n            pr->scr_err &= ~val;\n\n            break;\n\n        case PORT_SCR_ACT:\n\n            /* RW1 */\n\n            pr->scr_act |= val;\n\n            break;\n\n        case PORT_CMD_ISSUE:\n\n            pr->cmd_issue |= val;\n\n            check_cmd(s, port);\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n}\n", "idx": 5383}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 7684}
{"project": "qemu", "commit_id": "1e2713384c58037ad44f716c31c08daca18862c5", "target": 1, "func": "static void test_qga_config(gconstpointer data)\n\n{\n\n    GError *error = NULL;\n\n    char *cwd, *cmd, *out, *err, *str, **strv, **argv = NULL;\n\n    char *env[2];\n\n    int status;\n\n    gsize n;\n\n    GKeyFile *kf;\n\n\n\n    cwd = g_get_current_dir();\n\n    cmd = g_strdup_printf(\"%s%cqemu-ga -D\",\n\n                          cwd, G_DIR_SEPARATOR);\n\n\n    g_shell_parse_argv(cmd, NULL, &argv, &error);\n\n\n    g_assert_no_error(error);\n\n\n\n    env[0] = g_strdup_printf(\"QGA_CONF=tests%cdata%ctest-qga-config\",\n\n                             G_DIR_SEPARATOR, G_DIR_SEPARATOR);\n\n    env[1] = NULL;\n\n    g_spawn_sync(NULL, argv, env, 0,\n\n                 NULL, NULL, &out, &err, &status, &error);\n\n    g_strfreev(argv);\n\n\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(err, ==, \"\");\n\n    g_assert_cmpint(status, ==, 0);\n\n\n\n    kf = g_key_file_new();\n\n    g_key_file_load_from_data(kf, out, -1, G_KEY_FILE_NONE, &error);\n\n    g_assert_no_error(error);\n\n\n\n    str = g_key_file_get_start_group(kf);\n\n    g_assert_cmpstr(str, ==, \"general\");\n\n    g_free(str);\n\n\n\n    g_assert_false(g_key_file_get_boolean(kf, \"general\", \"daemon\", &error));\n\n    g_assert_no_error(error);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"method\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"virtio-serial\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"path\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/path/to/org.qemu.guest_agent.0\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"pidfile\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/var/foo/qemu-ga.pid\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"statedir\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/var/state\");\n\n    g_free(str);\n\n\n\n    g_assert_true(g_key_file_get_boolean(kf, \"general\", \"verbose\", &error));\n\n    g_assert_no_error(error);\n\n\n\n    strv = g_key_file_get_string_list(kf, \"general\", \"blacklist\", &n, &error);\n\n    g_assert_cmpint(n, ==, 2);\n\n#if GLIB_CHECK_VERSION(2, 44, 0)\n\n    g_assert_true(g_strv_contains((const char * const *)strv,\n\n                                  \"guest-ping\"));\n\n    g_assert_true(g_strv_contains((const char * const *)strv,\n\n                                  \"guest-get-time\"));\n\n#endif\n\n    g_assert_no_error(error);\n\n    g_strfreev(strv);\n\n\n\n    g_free(out);\n\n    g_free(err);\n\n    g_free(env[0]);\n\n    g_key_file_free(kf);\n\n}", "idx": 5841}
{"project": "qemu", "commit_id": "689ed13e73bdb5a5ca3366524475e3065fae854a", "target": 1, "func": "static void test_io_channel_tls(const void *opaque)\n\n{\n\n    struct QIOChannelTLSTestData *data =\n\n        (struct QIOChannelTLSTestData *)opaque;\n\n    QCryptoTLSCreds *clientCreds;\n\n    QCryptoTLSCreds *serverCreds;\n\n    QIOChannelTLS *clientChanTLS;\n\n    QIOChannelTLS *serverChanTLS;\n\n    QIOChannelSocket *clientChanSock;\n\n    QIOChannelSocket *serverChanSock;\n\n    qemu_acl *acl;\n\n    const char * const *wildcards;\n\n    int channel[2];\n\n    struct QIOChannelTLSHandshakeData clientHandshake = { false, false };\n\n    struct QIOChannelTLSHandshakeData serverHandshake = { false, false };\n\n    Error *err = NULL;\n\n    QIOChannelTest *test;\n\n    GMainContext *mainloop;\n\n\n\n    /* We'll use this for our fake client-server connection */\n\n    g_assert(socketpair(AF_UNIX, SOCK_STREAM, 0, channel) == 0);\n\n\n\n#define CLIENT_CERT_DIR \"tests/test-io-channel-tls-client/\"\n\n#define SERVER_CERT_DIR \"tests/test-io-channel-tls-server/\"\n\n    mkdir(CLIENT_CERT_DIR, 0700);\n\n    mkdir(SERVER_CERT_DIR, 0700);\n\n\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_KEY);\n\n\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_KEY);\n\n\n\n    g_assert(link(data->servercacrt,\n\n                  SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT) == 0);\n\n    g_assert(link(data->servercrt,\n\n                  SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_CERT) == 0);\n\n    g_assert(link(KEYFILE,\n\n                  SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_KEY) == 0);\n\n\n\n    g_assert(link(data->clientcacrt,\n\n                  CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT) == 0);\n\n    g_assert(link(data->clientcrt,\n\n                  CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_CERT) == 0);\n\n    g_assert(link(KEYFILE,\n\n                  CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_KEY) == 0);\n\n\n\n    clientCreds = test_tls_creds_create(\n\n        QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT,\n\n        CLIENT_CERT_DIR,\n\n        &err);\n\n    g_assert(clientCreds != NULL);\n\n\n\n    serverCreds = test_tls_creds_create(\n\n        QCRYPTO_TLS_CREDS_ENDPOINT_SERVER,\n\n        SERVER_CERT_DIR,\n\n        &err);\n\n    g_assert(serverCreds != NULL);\n\n\n\n    acl = qemu_acl_init(\"channeltlsacl\");\n\n    qemu_acl_reset(acl);\n\n    wildcards = data->wildcards;\n\n    while (wildcards && *wildcards) {\n\n        qemu_acl_append(acl, 0, *wildcards);\n\n        wildcards++;\n\n    }\n\n\n\n    clientChanSock = qio_channel_socket_new_fd(\n\n        channel[0], &err);\n\n    g_assert(clientChanSock != NULL);\n\n    serverChanSock = qio_channel_socket_new_fd(\n\n        channel[1], &err);\n\n    g_assert(serverChanSock != NULL);\n\n\n\n    /*\n\n     * We have an evil loop to do the handshake in a single\n\n     * thread, so we need these non-blocking to avoid deadlock\n\n     * of ourselves\n\n     */\n\n    qio_channel_set_blocking(QIO_CHANNEL(clientChanSock), false, NULL);\n\n    qio_channel_set_blocking(QIO_CHANNEL(serverChanSock), false, NULL);\n\n\n\n    /* Now the real part of the test, setup the sessions */\n\n    clientChanTLS = qio_channel_tls_new_client(\n\n        QIO_CHANNEL(clientChanSock), clientCreds,\n\n        data->hostname, &err);\n\n    g_assert(clientChanTLS != NULL);\n\n\n\n    serverChanTLS = qio_channel_tls_new_server(\n\n        QIO_CHANNEL(serverChanSock), serverCreds,\n\n        \"channeltlsacl\", &err);\n\n    g_assert(serverChanTLS != NULL);\n\n\n\n    qio_channel_tls_handshake(clientChanTLS,\n\n                              test_tls_handshake_done,\n\n                              &clientHandshake,\n\n                              NULL);\n\n    qio_channel_tls_handshake(serverChanTLS,\n\n                              test_tls_handshake_done,\n\n                              &serverHandshake,\n\n                              NULL);\n\n\n\n    /*\n\n     * Finally we loop around & around doing handshake on each\n\n     * session until we get an error, or the handshake completes.\n\n     * This relies on the socketpair being nonblocking to avoid\n\n     * deadlocking ourselves upon handshake\n\n     */\n\n    mainloop = g_main_context_default();\n\n    do {\n\n        g_main_context_iteration(mainloop, TRUE);\n\n    } while (!clientHandshake.finished &&\n\n             !serverHandshake.finished);\n\n\n\n    g_assert(clientHandshake.failed == data->expectClientFail);\n\n    g_assert(serverHandshake.failed == data->expectServerFail);\n\n\n\n    test = qio_channel_test_new();\n\n    qio_channel_test_run_threads(test, false,\n\n                                 QIO_CHANNEL(clientChanTLS),\n\n                                 QIO_CHANNEL(serverChanTLS));\n\n    qio_channel_test_validate(test);\n\n\n\n    test = qio_channel_test_new();\n\n    qio_channel_test_run_threads(test, true,\n\n                                 QIO_CHANNEL(clientChanTLS),\n\n                                 QIO_CHANNEL(serverChanTLS));\n\n    qio_channel_test_validate(test);\n\n\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_KEY);\n\n\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_KEY);\n\n\n\n    rmdir(CLIENT_CERT_DIR);\n\n    rmdir(SERVER_CERT_DIR);\n\n\n\n    object_unparent(OBJECT(serverCreds));\n\n    object_unparent(OBJECT(clientCreds));\n\n\n\n    object_unref(OBJECT(serverChanTLS));\n\n    object_unref(OBJECT(clientChanTLS));\n\n\n\n    object_unref(OBJECT(serverChanSock));\n\n    object_unref(OBJECT(clientChanSock));\n\n\n\n    close(channel[0]);\n\n    close(channel[1]);\n\n}\n", "idx": 4152}
{"project": "qemu", "commit_id": "38f3adc34de83bf75d2023831dc520d32568a2d9", "target": 1, "func": "FWCfgState *fw_cfg_init_mem_wide(hwaddr ctl_addr,\n\n                                 hwaddr data_addr, uint32_t data_width,\n\n                                 hwaddr dma_addr, AddressSpace *dma_as)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *sbd;\n\n    FWCfgState *s;\n\n    bool dma_requested = dma_addr && dma_as;\n\n\n\n    dev = qdev_create(NULL, TYPE_FW_CFG_MEM);\n\n    qdev_prop_set_uint32(dev, \"data_width\", data_width);\n\n    if (!dma_requested) {\n\n        qdev_prop_set_bit(dev, \"dma_enabled\", false);\n\n    }\n\n\n\n    fw_cfg_init1(dev);\n\n\n\n    sbd = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(sbd, 0, ctl_addr);\n\n    sysbus_mmio_map(sbd, 1, data_addr);\n\n\n\n    s = FW_CFG(dev);\n\n\n\n    if (s->dma_enabled) {\n\n        s->dma_as = dma_as;\n\n        s->dma_addr = 0;\n\n        sysbus_mmio_map(sbd, 2, dma_addr);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 8734}
{"project": "qemu", "commit_id": "1b0952445522af73b0e78420a9078b3653923703", "target": 1, "func": "void hbitmap_iter_init(HBitmapIter *hbi, const HBitmap *hb, uint64_t first)\n\n{\n\n    unsigned i, bit;\n\n    uint64_t pos;\n\n\n\n    hbi->hb = hb;\n\n    pos = first >> hb->granularity;\n\n\n    hbi->pos = pos >> BITS_PER_LEVEL;\n\n    hbi->granularity = hb->granularity;\n\n\n\n    for (i = HBITMAP_LEVELS; i-- > 0; ) {\n\n        bit = pos & (BITS_PER_LONG - 1);\n\n        pos >>= BITS_PER_LEVEL;\n\n\n\n        /* Drop bits representing items before first.  */\n\n        hbi->cur[i] = hb->levels[i][pos] & ~((1UL << bit) - 1);\n\n\n\n        /* We have already added level i+1, so the lowest set bit has\n\n         * been processed.  Clear it.\n\n         */\n\n        if (i != HBITMAP_LEVELS - 1) {\n\n            hbi->cur[i] &= ~(1UL << bit);\n\n        }\n\n    }\n\n}", "idx": 5716}
{"project": "qemu", "commit_id": "4d1628e832dfc6ec02b0d196f6cc250aaa7bf3b3", "target": 1, "func": "uint64_t helper_sublv(CPUAlphaState *env, uint64_t op1, uint64_t op2)\n\n{\n\n    uint32_t res;\n\n    res = op1 - op2;\n\n    if (unlikely((op1 ^ op2) & (res ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return res;\n\n}\n", "idx": 10696}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static void m5206_mbar_writew(void *opaque, target_phys_addr_t offset,\n\n                              uint32_t value)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR write offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width > 2) {\n\n        uint32_t tmp;\n\n        tmp = m5206_mbar_readl(opaque, offset & ~3);\n\n        if (offset & 3) {\n\n            tmp = (tmp & 0xffff0000) | value;\n\n        } else {\n\n            tmp = (tmp & 0x0000ffff) | (value << 16);\n\n        }\n\n        m5206_mbar_writel(opaque, offset & ~3, tmp);\n\n        return;\n\n    } else if (width < 2) {\n\n        m5206_mbar_writeb(opaque, offset, value >> 8);\n\n        m5206_mbar_writeb(opaque, offset + 1, value & 0xff);\n\n        return;\n\n    }\n\n    m5206_mbar_write(s, offset, value, 2);\n\n}\n", "idx": 3951}
{"project": "qemu", "commit_id": "3cb0e25c4b417b7336816bd92de458f0770d49ff", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *value;\n\n    DriveInfo *dinfo = NULL;\n\n    QDict *bs_opts;\n\n    QemuOpts *legacy_opts;\n\n    DriveMediaType media = MEDIA_DISK;\n\n    BlockInterfaceType type;\n\n    int cyls, heads, secs, translation;\n\n    int max_devs, bus_id, unit_id, index;\n\n    const char *devaddr;\n\n    const char *werror, *rerror;\n\n    bool read_only = false;\n\n    bool copy_on_read;\n\n    const char *filename;\n\n    Error *local_err = NULL;\n\n\n\n    /* Change legacy command line options into QMP ones */\n\n    qemu_opt_rename(all_opts, \"iops\", \"throttling.iops-total\");\n\n    qemu_opt_rename(all_opts, \"iops_rd\", \"throttling.iops-read\");\n\n    qemu_opt_rename(all_opts, \"iops_wr\", \"throttling.iops-write\");\n\n\n\n    qemu_opt_rename(all_opts, \"bps\", \"throttling.bps-total\");\n\n    qemu_opt_rename(all_opts, \"bps_rd\", \"throttling.bps-read\");\n\n    qemu_opt_rename(all_opts, \"bps_wr\", \"throttling.bps-write\");\n\n\n\n    qemu_opt_rename(all_opts, \"iops_max\", \"throttling.iops-total-max\");\n\n    qemu_opt_rename(all_opts, \"iops_rd_max\", \"throttling.iops-read-max\");\n\n    qemu_opt_rename(all_opts, \"iops_wr_max\", \"throttling.iops-write-max\");\n\n\n\n    qemu_opt_rename(all_opts, \"bps_max\", \"throttling.bps-total-max\");\n\n    qemu_opt_rename(all_opts, \"bps_rd_max\", \"throttling.bps-read-max\");\n\n    qemu_opt_rename(all_opts, \"bps_wr_max\", \"throttling.bps-write-max\");\n\n\n\n    qemu_opt_rename(all_opts,\n\n                    \"iops_size\", \"throttling.iops-size\");\n\n\n\n    qemu_opt_rename(all_opts, \"readonly\", \"read-only\");\n\n\n\n    value = qemu_opt_get(all_opts, \"cache\");\n\n    if (value) {\n\n        int flags = 0;\n\n\n\n        if (bdrv_parse_cache_flags(value, &flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n\n\n        /* Specific options take precedence */\n\n        if (!qemu_opt_get(all_opts, \"cache.writeback\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.writeback\",\n\n                              !!(flags & BDRV_O_CACHE_WB));\n\n        }\n\n        if (!qemu_opt_get(all_opts, \"cache.direct\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.direct\",\n\n                              !!(flags & BDRV_O_NOCACHE));\n\n        }\n\n        if (!qemu_opt_get(all_opts, \"cache.no-flush\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.no-flush\",\n\n                              !!(flags & BDRV_O_NO_FLUSH));\n\n        }\n\n        qemu_opt_unset(all_opts, \"cache\");\n\n    }\n\n\n\n    /* Get a QDict for processing the options */\n\n    bs_opts = qdict_new();\n\n    qemu_opts_to_qdict(all_opts, bs_opts);\n\n\n\n    legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,\n\n                                   &error_abort);\n\n    qemu_opts_absorb_qdict(legacy_opts, bs_opts, &local_err);\n\n    if (local_err) {\n\n        error_report(\"%s\", error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Deprecated option boot=[on|off] */\n\n    if (qemu_opt_get(legacy_opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    /* Media type */\n\n    value = qemu_opt_get(legacy_opts, \"media\");\n\n    if (value) {\n\n        if (!strcmp(value, \"disk\")) {\n\n            media = MEDIA_DISK;\n\n        } else if (!strcmp(value, \"cdrom\")) {\n\n            media = MEDIA_CDROM;\n\n            read_only = true;\n\n        } else {\n\n            error_report(\"'%s' invalid media\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* copy-on-read is disabled with a warning for read-only devices */\n\n    read_only |= qemu_opt_get_bool(legacy_opts, \"read-only\", false);\n\n    copy_on_read = qemu_opt_get_bool(legacy_opts, \"copy-on-read\", false);\n\n\n\n    if (read_only && copy_on_read) {\n\n        error_report(\"warning: disabling copy-on-read on read-only drive\");\n\n        copy_on_read = false;\n\n    }\n\n\n\n    qdict_put(bs_opts, \"read-only\",\n\n              qstring_from_str(read_only ? \"on\" : \"off\"));\n\n    qdict_put(bs_opts, \"copy-on-read\",\n\n              qstring_from_str(copy_on_read ? \"on\" :\"off\"));\n\n\n\n    /* Controller type */\n\n    value = qemu_opt_get(legacy_opts, \"if\");\n\n    if (value) {\n\n        for (type = 0;\n\n             type < IF_COUNT && strcmp(value, if_name[type]);\n\n             type++) {\n\n        }\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", value);\n\n            goto fail;\n\n        }\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    /* Geometry */\n\n    cyls  = qemu_opt_get_number(legacy_opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(legacy_opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(legacy_opts, \"secs\", 0);\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n            goto fail;\n\n        }\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n            goto fail;\n\n        }\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    value = qemu_opt_get(legacy_opts, \"trans\");\n\n    if (value != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         value);\n\n            goto fail;\n\n        }\n\n        if (!strcmp(value, \"none\")) {\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        } else if (!strcmp(value, \"lba\")) {\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        } else if (!strcmp(value, \"large\")) {\n\n            translation = BIOS_ATA_TRANSLATION_LARGE;\n\n        } else if (!strcmp(value, \"rechs\")) {\n\n            translation = BIOS_ATA_TRANSLATION_RECHS;\n\n        } else if (!strcmp(value, \"auto\")) {\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n        } else {\n\n            error_report(\"'%s' invalid translation type\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        if (cyls || secs || heads) {\n\n            error_report(\"CHS can't be set with media=cdrom\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Device address specified by bus/unit or index.\n\n     * If none was specified, try to find the first free one. */\n\n    bus_id  = qemu_opt_get_number(legacy_opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(legacy_opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(legacy_opts, \"index\", -1);\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            goto fail;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\", unit_id, max_devs - 1);\n\n        goto fail;\n\n    }\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        goto fail;\n\n    }\n\n\n\n    /* no id supplied -> create one */\n\n    if (qemu_opts_id(all_opts) == NULL) {\n\n        char *new_id;\n\n        const char *mediastr = \"\";\n\n        if (type == IF_IDE || type == IF_SCSI) {\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        }\n\n        if (max_devs) {\n\n            new_id = g_strdup_printf(\"%s%i%s%i\", if_name[type], bus_id,\n\n                                     mediastr, unit_id);\n\n        } else {\n\n            new_id = g_strdup_printf(\"%s%s%i\", if_name[type],\n\n                                     mediastr, unit_id);\n\n        }\n\n        qdict_put(bs_opts, \"id\", qstring_from_str(new_id));\n\n        g_free(new_id);\n\n    }\n\n\n\n    /* Add virtio block device */\n\n    devaddr = qemu_opt_get(legacy_opts, \"addr\");\n\n    if (devaddr && type != IF_VIRTIO) {\n\n        error_report(\"addr is not supported by this bus type\");\n\n        goto fail;\n\n    }\n\n\n\n    if (type == IF_VIRTIO) {\n\n        QemuOpts *devopts;\n\n        devopts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n\n                                   &error_abort);\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(devopts, \"drive\", qdict_get_str(bs_opts, \"id\"));\n\n        if (devaddr) {\n\n            qemu_opt_set(devopts, \"addr\", devaddr);\n\n        }\n\n    }\n\n\n\n    filename = qemu_opt_get(legacy_opts, \"file\");\n\n\n\n    /* Check werror/rerror compatibility with if=... */\n\n    werror = qemu_opt_get(legacy_opts, \"werror\");\n\n    if (werror != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO &&\n\n            type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            goto fail;\n\n        }\n\n        qdict_put(bs_opts, \"werror\", qstring_from_str(werror));\n\n    }\n\n\n\n    rerror = qemu_opt_get(legacy_opts, \"rerror\");\n\n    if (rerror != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI &&\n\n            type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            goto fail;\n\n        }\n\n        qdict_put(bs_opts, \"rerror\", qstring_from_str(rerror));\n\n    }\n\n\n\n    /* Actual block device init: Functionality shared with blockdev-add */\n\n    dinfo = blockdev_init(filename, bs_opts, &local_err);\n\n\n    if (dinfo == NULL) {\n\n        if (local_err) {\n\n            error_report(\"%s\", error_get_pretty(local_err));\n\n            error_free(local_err);\n\n        }\n\n        goto fail;\n\n    } else {\n\n        assert(!local_err);\n\n    }\n\n\n\n    /* Set legacy DriveInfo fields */\n\n    dinfo->enable_auto_del = true;\n\n    dinfo->opts = all_opts;\n\n\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->devaddr = devaddr;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(legacy_opts);\n\n    QDECREF(bs_opts);\n\n    return dinfo;\n\n}", "idx": 6623}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_sextb(DisasContext *dc)\n\n{\n\n    LOG_DIS(\"sextb r%d, r%d\\n\", dc->r2, dc->r0);\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_SIGN_EXTEND)) {\n\n        cpu_abort(dc->env, \"hardware sign extender is not available\\n\");\n\n    }\n\n\n\n    tcg_gen_ext8s_tl(cpu_R[dc->r2], cpu_R[dc->r0]);\n\n}\n", "idx": 8508}
{"project": "qemu", "commit_id": "04920fc0faa4760f9c4fc0e73b992b768099be70", "target": 1, "func": "void do_info_roms(Monitor *mon, const QDict *qdict)\n\n{\n\n    Rom *rom;\n\n\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n\n        if (!rom->fw_file) {\n\n            monitor_printf(mon, \"addr=\" TARGET_FMT_plx\n\n                           \" size=0x%06zx mem=%s name=\\\"%s\\\"\\n\",\n\n                           rom->addr, rom->romsize,\n\n                           rom->isrom ? \"rom\" : \"ram\",\n\n                           rom->name);\n\n        } else {\n\n            monitor_printf(mon, \"fw=%s/%s\"\n\n                           \" size=0x%06zx name=\\\"%s\\\"\\n\",\n\n                           rom->fw_dir,\n\n                           rom->fw_file,\n\n                           rom->romsize,\n\n                           rom->name);\n\n        }\n\n    }\n\n}\n", "idx": 1143}
{"project": "qemu", "commit_id": "02c4f26b1517d9e403ec10d6f6ca3c0276d19e43", "target": 1, "func": "static int sd_snapshot_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab)\n\n{\n\n    Error *local_err = NULL;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    SheepdogReq req;\n\n    int fd, nr = 1024, ret, max = BITS_TO_LONGS(SD_NR_VDIS) * sizeof(long);\n\n    QEMUSnapshotInfo *sn_tab = NULL;\n\n    unsigned wlen, rlen;\n\n    int found = 0;\n\n    static SheepdogInode inode;\n\n    unsigned long *vdi_inuse;\n\n    unsigned int start_nr;\n\n    uint64_t hval;\n\n    uint32_t vid;\n\n\n\n    vdi_inuse = g_malloc(max);\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report(\"%s\", error_get_pretty(local_err));;\n\n        error_free(local_err);\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    rlen = max;\n\n    wlen = 0;\n\n\n\n    memset(&req, 0, sizeof(req));\n\n\n\n    req.opcode = SD_OP_READ_VDIS;\n\n    req.data_length = max;\n\n\n\n    ret = do_req(fd, s->aio_context, (SheepdogReq *)&req,\n\n                 vdi_inuse, &wlen, &rlen);\n\n\n\n    closesocket(fd);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    sn_tab = g_malloc0(nr * sizeof(*sn_tab));\n\n\n\n    /* calculate a vdi id with hash function */\n\n    hval = fnv_64a_buf(s->name, strlen(s->name), FNV1A_64_INIT);\n\n    start_nr = hval & (SD_NR_VDIS - 1);\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report(\"%s\", error_get_pretty(local_err));;\n\n        error_free(local_err);\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    for (vid = start_nr; found < nr; vid = (vid + 1) % SD_NR_VDIS) {\n\n        if (!test_bit(vid, vdi_inuse)) {\n\n            break;\n\n        }\n\n\n\n        /* we don't need to read entire object */\n\n        ret = read_object(fd, s->aio_context, (char *)&inode,\n\n                          vid_to_vdi_oid(vid),\n\n                          0, SD_INODE_SIZE - sizeof(inode.data_vdi_id), 0,\n\n                          s->cache_flags);\n\n\n\n        if (ret) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(inode.name, s->name) && is_snapshot(&inode)) {\n\n            sn_tab[found].date_sec = inode.snap_ctime >> 32;\n\n            sn_tab[found].date_nsec = inode.snap_ctime & 0xffffffff;\n\n            sn_tab[found].vm_state_size = inode.vm_state_size;\n\n            sn_tab[found].vm_clock_nsec = inode.vm_clock_nsec;\n\n\n\n            snprintf(sn_tab[found].id_str, sizeof(sn_tab[found].id_str),\n\n                     \"%\" PRIu32, inode.snap_id);\n\n            pstrcpy(sn_tab[found].name,\n\n                    MIN(sizeof(sn_tab[found].name), sizeof(inode.tag)),\n\n                    inode.tag);\n\n            found++;\n\n        }\n\n    }\n\n\n\n    closesocket(fd);\n\nout:\n\n    *psn_tab = sn_tab;\n\n\n\n    g_free(vdi_inuse);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return found;\n\n}\n", "idx": 1019}
{"project": "qemu", "commit_id": "eca1bdf415c454093dfc7eb983cd49287c043967", "target": 1, "func": "void cpu_reset (CPUMIPSState *env)\n{\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n    tlb_flush(env, 1);\n    /* Minimal init */\n#if defined(CONFIG_USER_ONLY)\n    env->hflags = MIPS_HFLAG_UM;\n#else\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n        /* If the exception was raised from a delay slot,\n           come back to the jump.  */\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n    } else {\n        env->CP0_ErrorEPC = env->active_tc.PC;\n    env->active_tc.PC = (int32_t)0xBFC00000;\n    env->CP0_Wired = 0;\n    /* SMP not implemented */\n    env->CP0_EBase = 0x80000000;\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n    /* vectored interrupts not implemented, timer on int 7,\n       no performance counters. */\n    env->CP0_IntCtl = 0xe0000000;\n    {\n        int i;\n        for (i = 0; i < 7; i++) {\n            env->CP0_WatchLo[i] = 0;\n            env->CP0_WatchHi[i] = 0x80000000;\n        env->CP0_WatchLo[7] = 0;\n        env->CP0_WatchHi[7] = 0;\n    /* Count register increments in debug mode, EJTAG version 1 */\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n    env->hflags = MIPS_HFLAG_CP0;\n#endif\n    env->exception_index = EXCP_NONE;\n    cpu_mips_register(env, env->cpu_model);", "idx": 8185}
{"project": "qemu", "commit_id": "6b4495401bdf442457b713b7e3994b465c55af35", "target": 1, "func": "pcie_cap_v1_fill(uint8_t *exp_cap, uint8_t port, uint8_t type, uint8_t version)\n\n{\n\n    /* capability register\n\n    interrupt message number defaults to 0 */\n\n    pci_set_word(exp_cap + PCI_EXP_FLAGS,\n\n                 ((type << PCI_EXP_FLAGS_TYPE_SHIFT) & PCI_EXP_FLAGS_TYPE) |\n\n                 version);\n\n\n\n    /* device capability register\n\n     * table 7-12:\n\n     * roll based error reporting bit must be set by all\n\n     * Functions conforming to the ECN, PCI Express Base\n\n     * Specification, Revision 1.1., or subsequent PCI Express Base\n\n     * Specification revisions.\n\n     */\n\n    pci_set_long(exp_cap + PCI_EXP_DEVCAP, PCI_EXP_DEVCAP_RBER);\n\n\n\n    pci_set_long(exp_cap + PCI_EXP_LNKCAP,\n\n                 (port << PCI_EXP_LNKCAP_PN_SHIFT) |\n\n                 PCI_EXP_LNKCAP_ASPMS_0S |\n\n                 PCI_EXP_LNK_MLW_1 |\n\n                 PCI_EXP_LNK_LS_25);\n\n\n\n    pci_set_word(exp_cap + PCI_EXP_LNKSTA,\n\n                 PCI_EXP_LNK_MLW_1 | PCI_EXP_LNK_LS_25 |PCI_EXP_LNKSTA_DLLLA);\n\n}\n", "idx": 4040}
{"project": "qemu", "commit_id": "91bea4e2bb1a5f7954a3b3a4f2e28e96bd25c458", "target": 1, "func": "iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n                 QEMUIOVector *qiov, int nb_sectors,\n                 BlockDriverCompletionFunc *cb,\n                 void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    IscsiAIOCB *acb;\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n    trace_iscsi_aio_writev(iscsilun->iscsi, sector_num, nb_sectors, opaque, acb);\n    acb->iscsilun    = iscsilun;\n    acb->qiov        = qiov;\n    acb->nb_sectors  = nb_sectors;\n    acb->sector_num  = sector_num;\n    acb->retries     = ISCSI_CMD_RETRIES;\n    if (iscsi_aio_writev_acb(acb) != 0) {\n        qemu_aio_release(acb);\n    iscsi_set_events(iscsilun);\n    return &acb->common;", "idx": 8579}
{"project": "qemu", "commit_id": "d8b2239bcd8872a5c5f7534d1658fc2365caab2d", "target": 1, "func": "bool cpu_restore_state(CPUState *cpu, uintptr_t retaddr)\n{\n    TranslationBlock *tb;\n    bool r = false;\n    tb_lock();\n    tb = tb_find_pc(retaddr);\n    if (tb) {\n        cpu_restore_state_from_tb(cpu, tb, retaddr);\n        if (tb->cflags & CF_NOCACHE) {\n            /* one-shot translation, invalidate it immediately */\n            tb_phys_invalidate(tb, -1);\n            tb_free(tb);\n        r = true;\n    tb_unlock();", "idx": 3964}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "func": "static int colo_packet_compare_udp(Packet *spkt, Packet *ppkt)\n\n{\n\n    int ret;\n\n    int network_header_length = ppkt->ip->ip_hl * 4;\n\n\n\n    trace_colo_compare_main(\"compare udp\");\n\n\n\n    /*\n\n     * Because of ppkt and spkt are both in the same connection,\n\n     * The ppkt's src ip, dst ip, src port, dst port, ip_proto all are\n\n     * same with spkt. In addition, IP header's Identification is a random\n\n     * field, we can handle it in IP fragmentation function later.\n\n     * COLO just concern the response net packet payload from primary guest\n\n     * and secondary guest are same or not, So we ignored all IP header include\n\n     * other field like TOS,TTL,IP Checksum. we only need to compare\n\n     * the ip payload here.\n\n     */\n\n    ret = colo_packet_compare_common(ppkt, spkt,\n\n                                     network_header_length + ETH_HLEN);\n\n\n\n    if (ret) {\n\n        trace_colo_compare_udp_miscompare(\"primary pkt size\", ppkt->size);\n\n        trace_colo_compare_udp_miscompare(\"Secondary pkt size\", spkt->size);\n\n        if (trace_event_get_state(TRACE_COLO_COMPARE_MISCOMPARE)) {\n\n            qemu_hexdump((char *)ppkt->data, stderr, \"colo-compare pri pkt\",\n\n                         ppkt->size);\n\n            qemu_hexdump((char *)spkt->data, stderr, \"colo-compare sec pkt\",\n\n                         spkt->size);\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 33}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static int vnc_client_io_error(VncState *vs, int ret, int last_errno)\n\n{\n\n    if (ret == 0 || ret == -1) {\n\n        if (ret == -1) {\n\n            switch (last_errno) {\n\n                case EINTR:\n\n                case EAGAIN:\n\n#ifdef _WIN32\n\n                case WSAEWOULDBLOCK:\n\n#endif\n\n                    return 0;\n\n                default:\n\n                    break;\n\n            }\n\n        }\n\n\n\n\tVNC_DEBUG(\"Closing down client sock %d %d\\n\", ret, ret < 0 ? last_errno : 0);\n\n\tqemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);\n\n\tclosesocket(vs->csock);\n\n        qemu_del_timer(vs->timer);\n\n        qemu_free_timer(vs->timer);\n\n        if (vs->input.buffer) qemu_free(vs->input.buffer);\n\n        if (vs->output.buffer) qemu_free(vs->output.buffer);\n\n#ifdef CONFIG_VNC_TLS\n\n\tvnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n        audio_del(vs);\n\n\n\n        VncState *p, *parent = NULL;\n\n        for (p = vs->vd->clients; p != NULL; p = p->next) {\n\n            if (p == vs) {\n\n                if (parent)\n\n                    parent->next = p->next;\n\n                else\n\n                    vs->vd->clients = p->next;\n\n                break;\n\n            }\n\n            parent = p;\n\n        }\n\n        if (!vs->vd->clients)\n\n            dcl->idle = 1;\n\n\n\n        qemu_free(vs->old_data);\n\n        qemu_free(vs);\n\n  \n\n\treturn 0;\n\n    }\n\n    return ret;\n\n}\n", "idx": 3963}
{"project": "qemu", "commit_id": "9ac228e02cf16202547e7025ef300369e0db7781", "target": 1, "func": "static int qcow_check(BlockDriverState *bs)\n\n{\n\n    return qcow2_check_refcounts(bs);\n\n}\n", "idx": 9597}
{"project": "qemu", "commit_id": "f6351288b65130deb8102b17143f5d84f817a02a", "target": 1, "func": "static void dp8393x_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n\n    dc->realize = dp8393x_realize;\n\n    dc->reset = dp8393x_reset;\n\n    dc->vmsd = &vmstate_dp8393x;\n\n    dc->props = dp8393x_properties;\n\n\n\n}", "idx": 9403}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "int kvm_arch_get_registers(CPUState *cs)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    struct kvm_regs regs;\n\n    struct kvm_sregs sregs;\n\n    uint32_t cr;\n\n    int i, ret;\n\n\n\n    ret = kvm_vcpu_ioctl(cs, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    cr = regs.cr;\n\n    for (i = 7; i >= 0; i--) {\n\n        env->crf[i] = cr & 15;\n\n        cr >>= 4;\n\n    }\n\n\n\n    env->ctr = regs.ctr;\n\n    env->lr = regs.lr;\n\n    cpu_write_xer(env, regs.xer);\n\n    env->msr = regs.msr;\n\n    env->nip = regs.pc;\n\n\n\n    env->spr[SPR_SRR0] = regs.srr0;\n\n    env->spr[SPR_SRR1] = regs.srr1;\n\n\n\n    env->spr[SPR_SPRG0] = regs.sprg0;\n\n    env->spr[SPR_SPRG1] = regs.sprg1;\n\n    env->spr[SPR_SPRG2] = regs.sprg2;\n\n    env->spr[SPR_SPRG3] = regs.sprg3;\n\n    env->spr[SPR_SPRG4] = regs.sprg4;\n\n    env->spr[SPR_SPRG5] = regs.sprg5;\n\n    env->spr[SPR_SPRG6] = regs.sprg6;\n\n    env->spr[SPR_SPRG7] = regs.sprg7;\n\n\n\n    env->spr[SPR_BOOKE_PID] = regs.pid;\n\n\n\n    for (i = 0;i < 32; i++)\n\n        env->gpr[i] = regs.gpr[i];\n\n\n\n    kvm_get_fp(cs);\n\n\n\n    if (cap_booke_sregs) {\n\n        ret = kvm_vcpu_ioctl(cs, KVM_GET_SREGS, &sregs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_BASE) {\n\n            env->spr[SPR_BOOKE_CSRR0] = sregs.u.e.csrr0;\n\n            env->spr[SPR_BOOKE_CSRR1] = sregs.u.e.csrr1;\n\n            env->spr[SPR_BOOKE_ESR] = sregs.u.e.esr;\n\n            env->spr[SPR_BOOKE_DEAR] = sregs.u.e.dear;\n\n            env->spr[SPR_BOOKE_MCSR] = sregs.u.e.mcsr;\n\n            env->spr[SPR_BOOKE_TSR] = sregs.u.e.tsr;\n\n            env->spr[SPR_BOOKE_TCR] = sregs.u.e.tcr;\n\n            env->spr[SPR_DECR] = sregs.u.e.dec;\n\n            env->spr[SPR_TBL] = sregs.u.e.tb & 0xffffffff;\n\n            env->spr[SPR_TBU] = sregs.u.e.tb >> 32;\n\n            env->spr[SPR_VRSAVE] = sregs.u.e.vrsave;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_ARCH206) {\n\n            env->spr[SPR_BOOKE_PIR] = sregs.u.e.pir;\n\n            env->spr[SPR_BOOKE_MCSRR0] = sregs.u.e.mcsrr0;\n\n            env->spr[SPR_BOOKE_MCSRR1] = sregs.u.e.mcsrr1;\n\n            env->spr[SPR_BOOKE_DECAR] = sregs.u.e.decar;\n\n            env->spr[SPR_BOOKE_IVPR] = sregs.u.e.ivpr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_64) {\n\n            env->spr[SPR_BOOKE_EPCR] = sregs.u.e.epcr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_SPRG8) {\n\n            env->spr[SPR_BOOKE_SPRG8] = sregs.u.e.sprg8;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_IVOR) {\n\n            env->spr[SPR_BOOKE_IVOR0] = sregs.u.e.ivor_low[0];\n\n            env->spr[SPR_BOOKE_IVOR1] = sregs.u.e.ivor_low[1];\n\n            env->spr[SPR_BOOKE_IVOR2] = sregs.u.e.ivor_low[2];\n\n            env->spr[SPR_BOOKE_IVOR3] = sregs.u.e.ivor_low[3];\n\n            env->spr[SPR_BOOKE_IVOR4] = sregs.u.e.ivor_low[4];\n\n            env->spr[SPR_BOOKE_IVOR5] = sregs.u.e.ivor_low[5];\n\n            env->spr[SPR_BOOKE_IVOR6] = sregs.u.e.ivor_low[6];\n\n            env->spr[SPR_BOOKE_IVOR7] = sregs.u.e.ivor_low[7];\n\n            env->spr[SPR_BOOKE_IVOR8] = sregs.u.e.ivor_low[8];\n\n            env->spr[SPR_BOOKE_IVOR9] = sregs.u.e.ivor_low[9];\n\n            env->spr[SPR_BOOKE_IVOR10] = sregs.u.e.ivor_low[10];\n\n            env->spr[SPR_BOOKE_IVOR11] = sregs.u.e.ivor_low[11];\n\n            env->spr[SPR_BOOKE_IVOR12] = sregs.u.e.ivor_low[12];\n\n            env->spr[SPR_BOOKE_IVOR13] = sregs.u.e.ivor_low[13];\n\n            env->spr[SPR_BOOKE_IVOR14] = sregs.u.e.ivor_low[14];\n\n            env->spr[SPR_BOOKE_IVOR15] = sregs.u.e.ivor_low[15];\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_SPE) {\n\n                env->spr[SPR_BOOKE_IVOR32] = sregs.u.e.ivor_high[0];\n\n                env->spr[SPR_BOOKE_IVOR33] = sregs.u.e.ivor_high[1];\n\n                env->spr[SPR_BOOKE_IVOR34] = sregs.u.e.ivor_high[2];\n\n            }\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_PM) {\n\n                env->spr[SPR_BOOKE_IVOR35] = sregs.u.e.ivor_high[3];\n\n            }\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_PC) {\n\n                env->spr[SPR_BOOKE_IVOR36] = sregs.u.e.ivor_high[4];\n\n                env->spr[SPR_BOOKE_IVOR37] = sregs.u.e.ivor_high[5];\n\n            }\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_ARCH206_MMU) {\n\n            env->spr[SPR_BOOKE_MAS0] = sregs.u.e.mas0;\n\n            env->spr[SPR_BOOKE_MAS1] = sregs.u.e.mas1;\n\n            env->spr[SPR_BOOKE_MAS2] = sregs.u.e.mas2;\n\n            env->spr[SPR_BOOKE_MAS3] = sregs.u.e.mas7_3 & 0xffffffff;\n\n            env->spr[SPR_BOOKE_MAS4] = sregs.u.e.mas4;\n\n            env->spr[SPR_BOOKE_MAS6] = sregs.u.e.mas6;\n\n            env->spr[SPR_BOOKE_MAS7] = sregs.u.e.mas7_3 >> 32;\n\n            env->spr[SPR_MMUCFG] = sregs.u.e.mmucfg;\n\n            env->spr[SPR_BOOKE_TLB0CFG] = sregs.u.e.tlbcfg[0];\n\n            env->spr[SPR_BOOKE_TLB1CFG] = sregs.u.e.tlbcfg[1];\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_EXP) {\n\n            env->spr[SPR_BOOKE_EPR] = sregs.u.e.epr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_PD) {\n\n            env->spr[SPR_BOOKE_EPLC] = sregs.u.e.eplc;\n\n            env->spr[SPR_BOOKE_EPSC] = sregs.u.e.epsc;\n\n        }\n\n\n\n        if (sregs.u.e.impl_id == KVM_SREGS_E_IMPL_FSL) {\n\n            env->spr[SPR_E500_SVR] = sregs.u.e.impl.fsl.svr;\n\n            env->spr[SPR_Exxx_MCAR] = sregs.u.e.impl.fsl.mcar;\n\n            env->spr[SPR_HID0] = sregs.u.e.impl.fsl.hid0;\n\n\n\n            if (sregs.u.e.impl.fsl.features & KVM_SREGS_E_FSL_PIDn) {\n\n                env->spr[SPR_BOOKE_PID1] = sregs.u.e.impl.fsl.pid1;\n\n                env->spr[SPR_BOOKE_PID2] = sregs.u.e.impl.fsl.pid2;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (cap_segstate) {\n\n        ret = kvm_vcpu_ioctl(cs, KVM_GET_SREGS, &sregs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n\n\n        /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n        /*\n\n         * The packed SLB array we get from KVM_GET_SREGS only contains\n\n         * information about valid entries. So we flush our internal\n\n         * copy to get rid of stale ones, then put all valid SLB entries\n\n         * back in.\n\n         */\n\n        memset(env->slb, 0, sizeof(env->slb));\n\n        for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n            target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n            target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n            /*\n\n             * Only restore valid entries\n\n             */\n\n            if (rb & SLB_ESID_V) {\n\n                ppc_store_slb(env, rb, rs);\n\n            }\n\n        }\n\n#endif\n\n\n\n        /* Sync SRs */\n\n        for (i = 0; i < 16; i++) {\n\n            env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n        }\n\n\n\n        /* Sync BATs */\n\n        for (i = 0; i < 8; i++) {\n\n            env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n            env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n            env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n            env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n        }\n\n    }\n\n\n\n    if (cap_hior) {\n\n        kvm_get_one_spr(cs, KVM_REG_PPC_HIOR, SPR_HIOR);\n\n    }\n\n\n\n    if (cap_one_reg) {\n\n        int i;\n\n\n\n        /* We deliberately ignore errors here, for kernels which have\n\n         * the ONE_REG calls, but don't support the specific\n\n         * registers, there's a reasonable chance things will still\n\n         * work, at least until we try to migrate. */\n\n        for (i = 0; i < 1024; i++) {\n\n            uint64_t id = env->spr_cb[i].one_reg_id;\n\n\n\n            if (id != 0) {\n\n                kvm_get_one_spr(cs, id, i);\n\n            }\n\n        }\n\n\n\n#ifdef TARGET_PPC64\n\n        if (cap_papr) {\n\n            if (kvm_get_vpa(cs) < 0) {\n\n                DPRINTF(\"Warning: Unable to get VPA information from KVM\\n\");\n\n            }\n\n        }\n\n#endif\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11194}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int virtio_ccw_rng_init(VirtioCcwDevice *ccw_dev)\n\n{\n\n    VirtIORNGCcw *dev = VIRTIO_RNG_CCW(ccw_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&ccw_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return virtio_ccw_device_init(ccw_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 10884}
{"project": "qemu", "commit_id": "365aa1131fa61815eb1d672df6ba451bfe7f2cea", "target": 1, "func": "static void kvm_apic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n\n\n    memory_region_init_io(&s->io_memory, NULL, &kvm_apic_io_ops, s, \"kvm-apic-msi\",\n\n                          APIC_SPACE_SIZE);\n\n\n\n    if (kvm_has_gsi_routing()) {\n\n        msi_nonbroken = true;\n\n    }\n\n}\n", "idx": 3149}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long host_to_target_timespec(abi_ulong target_addr,\n\n                                               struct timespec *host_ts)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_WRITE, target_ts, target_addr, 0))\n\n        return -TARGET_EFAULT;\n\n    target_ts->tv_sec = tswapal(host_ts->tv_sec);\n\n    target_ts->tv_nsec = tswapal(host_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 1);\n\n    return 0;\n\n}\n", "idx": 9919}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 7039}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 8903}
{"project": "qemu", "commit_id": "ac7e4cbbabae5a8e0d3948ddebf33351e61497c3", "target": 1, "func": "S390CPU *s390x_new_cpu(const char *typename, uint32_t core_id, Error **errp)\n\n{\n\n    S390CPU *cpu = S390_CPU(object_new(typename));\n\n    Error *err = NULL;\n\n\n\n    object_property_set_int(OBJECT(cpu), core_id, \"core-id\", &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n\n\nout:\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 9413}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void omap_gp_timer_clk_setup(struct omap_gp_timer_s *timer)\n\n{\n\n    omap_clk_adduser(timer->clk,\n\n                    qemu_allocate_irqs(omap_gp_timer_clk_update, timer, 1)[0]);\n\n    timer->rate = omap_clk_getrate(timer->clk);\n\n}\n", "idx": 6177}
{"project": "qemu", "commit_id": "5e39d89d20b17cf6fb7f09d181d34f17b2ae2160", "target": 1, "func": "static void spapr_numa_cpu(const void *data)\n\n{\n\n    char *cli;\n\n    QDict *resp;\n\n    QList *cpus;\n\n    const QObject *e;\n\n\n\n    cli = make_cli(data, \"-smp 4,cores=4 \"\n\n        \"-numa node,nodeid=0 -numa node,nodeid=1 \"\n\n        \"-numa cpu,node-id=0,core-id=0 \"\n\n        \"-numa cpu,node-id=0,core-id=1 \"\n\n        \"-numa cpu,node-id=0,core-id=2 \"\n\n        \"-numa cpu,node-id=1,core-id=3\");\n\n    qtest_start(cli);\n\n    cpus = get_cpus(&resp);\n\n    g_assert(cpus);\n\n\n\n    while ((e = qlist_pop(cpus))) {\n\n        QDict *cpu, *props;\n\n        int64_t core, node;\n\n\n\n        cpu = qobject_to_qdict(e);\n\n        g_assert(qdict_haskey(cpu, \"props\"));\n\n        props = qdict_get_qdict(cpu, \"props\");\n\n\n\n        g_assert(qdict_haskey(props, \"node-id\"));\n\n        node = qdict_get_int(props, \"node-id\");\n\n        g_assert(qdict_haskey(props, \"core-id\"));\n\n        core = qdict_get_int(props, \"core-id\");\n\n\n\n        if (core >= 0 && core < 3) {\n\n            g_assert_cmpint(node, ==, 0);\n\n        } else if (core == 3) {\n\n            g_assert_cmpint(node, ==, 1);\n\n        } else {\n\n            g_assert(false);\n\n        }\n\n    }\n\n\n\n    QDECREF(resp);\n\n    qtest_end();\n\n    g_free(cli);\n\n}\n", "idx": 1940}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750gx (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented (XXX: different from 750fx) */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented (XXX: different from 750fx) */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented (XXX: different from 750fx) */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 11234}
{"project": "qemu", "commit_id": "630530a6529bc3da9ab8aead7053dc753cb9ac77", "target": 1, "func": "static int vmdk_parent_open(BlockDriverState *bs, const char * filename)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    char *p_name; \n\n    char desc[DESC_SIZE];\n\n    char parent_img_name[1024];\n\n\n\n    /* the descriptor offset = 0x200 */\n\n    if (bdrv_pread(s->hd, 0x200, desc, DESC_SIZE) != DESC_SIZE)\n\n        return -1;\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != 0) {\n\n        char *end_name;\n\n        struct stat file_buf;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == 0)\n\n            return -1;\n\n                \n\n        strncpy(s->hd->backing_file, p_name, end_name - p_name);\n\n        if (stat(s->hd->backing_file, &file_buf) != 0) {\n\n            path_combine(parent_img_name, sizeof(parent_img_name),\n\n                         filename, s->hd->backing_file);\n\n        } else {\n\n            strcpy(parent_img_name, s->hd->backing_file);\n\n        }\n\n\n\n        s->hd->backing_hd = bdrv_new(\"\");\n\n        if (!s->hd->backing_hd) {\n\n            failure:\n\n            bdrv_close(s->hd);\n\n            return -1;\n\n        }\n\n        if (bdrv_open(s->hd->backing_hd, parent_img_name, 0) < 0)\n\n            goto failure;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10949}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "void bdrv_op_block(BlockDriverState *bs, BlockOpType op, Error *reason)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n\n\n    blocker = g_malloc0(sizeof(BdrvOpBlocker));\n\n    blocker->reason = reason;\n\n    QLIST_INSERT_HEAD(&bs->op_blockers[op], blocker, list);\n\n}\n", "idx": 2146}
{"project": "qemu", "commit_id": "301c7d38a0c359b91526391d13617386f3d9bb29", "target": 1, "func": "static int vmdk_add_extent(BlockDriverState *bs,\n\n                           BlockDriverState *file, bool flat, int64_t sectors,\n\n                           int64_t l1_offset, int64_t l1_backup_offset,\n\n                           uint32_t l1_size,\n\n                           int l2_size, uint64_t cluster_sectors,\n\n                           VmdkExtent **new_extent)\n\n{\n\n    VmdkExtent *extent;\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    if (cluster_sectors > 0x200000) {\n\n        /* 0x200000 * 512Bytes = 1GB for one cluster is unrealistic */\n\n        error_report(\"invalid granularity, image may be corrupt\");\n\n        return -EINVAL;\n\n    }\n\n    if (l1_size > 512 * 1024 * 1024) {\n\n        /* Although with big capacity and small l1_entry_sectors, we can get a\n\n         * big l1_size, we don't want unbounded value to allocate the table.\n\n         * Limit it to 512M, which is 16PB for default cluster and L2 table\n\n         * size */\n\n        error_report(\"L1 size too big\");\n\n        return -EFBIG;\n\n    }\n\n\n\n    s->extents = g_realloc(s->extents,\n\n                              (s->num_extents + 1) * sizeof(VmdkExtent));\n\n    extent = &s->extents[s->num_extents];\n\n    s->num_extents++;\n\n\n\n    memset(extent, 0, sizeof(VmdkExtent));\n\n    extent->file = file;\n\n    extent->flat = flat;\n\n    extent->sectors = sectors;\n\n    extent->l1_table_offset = l1_offset;\n\n    extent->l1_backup_table_offset = l1_backup_offset;\n\n    extent->l1_size = l1_size;\n\n    extent->l1_entry_sectors = l2_size * cluster_sectors;\n\n    extent->l2_size = l2_size;\n\n    extent->cluster_sectors = cluster_sectors;\n\n\n\n    if (s->num_extents > 1) {\n\n        extent->end_sector = (*(extent - 1)).end_sector + extent->sectors;\n\n    } else {\n\n        extent->end_sector = extent->sectors;\n\n    }\n\n    bs->total_sectors = extent->end_sector;\n\n    if (new_extent) {\n\n        *new_extent = extent;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10551}
{"project": "qemu", "commit_id": "87ca1f77b1c406137fe36ab73b2dc91fb75f8d0a", "target": 1, "func": "static void vfio_listener_region_add(MemoryListener *listener,\n\n                                     MemoryRegionSection *section)\n\n{\n\n    VFIOContainer *container = container_of(listener, VFIOContainer,\n\n                                            iommu_data.listener);\n\n    hwaddr iova, end;\n\n    void *vaddr;\n\n    int ret;\n\n\n\n    assert(!memory_region_is_iommu(section->mr));\n\n\n\n    if (vfio_listener_skipped_section(section)) {\n\n        DPRINTF(\"SKIPPING region_add %\"HWADDR_PRIx\" - %\"PRIx64\"\\n\",\n\n                section->offset_within_address_space,\n\n                section->offset_within_address_space +\n\n                int128_get64(int128_sub(section->size, int128_one())));\n\n        return;\n\n    }\n\n\n\n    if (unlikely((section->offset_within_address_space & ~TARGET_PAGE_MASK) !=\n\n                 (section->offset_within_region & ~TARGET_PAGE_MASK))) {\n\n        error_report(\"%s received unaligned region\", __func__);\n\n        return;\n\n    }\n\n\n\n    iova = TARGET_PAGE_ALIGN(section->offset_within_address_space);\n\n    end = (section->offset_within_address_space + int128_get64(section->size)) &\n\n          TARGET_PAGE_MASK;\n\n\n\n    if (iova >= end) {\n\n        return;\n\n    }\n\n\n\n    vaddr = memory_region_get_ram_ptr(section->mr) +\n\n            section->offset_within_region +\n\n            (iova - section->offset_within_address_space);\n\n\n\n    DPRINTF(\"region_add %\"HWADDR_PRIx\" - %\"HWADDR_PRIx\" [%p]\\n\",\n\n            iova, end - 1, vaddr);\n\n\n\n    memory_region_ref(section->mr);\n\n    ret = vfio_dma_map(container, iova, end - iova, vaddr, section->readonly);\n\n    if (ret) {\n\n        error_report(\"vfio_dma_map(%p, 0x%\"HWADDR_PRIx\", \"\n\n                     \"0x%\"HWADDR_PRIx\", %p) = %d (%m)\",\n\n                     container, iova, end - iova, vaddr, ret);\n\n    }\n\n}\n", "idx": 6094}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void spapr_vio_quiesce_one(VIOsPAPRDevice *dev)\n\n{\n\n    dev->flags &= ~VIO_PAPR_FLAG_DMA_BYPASS;\n\n\n\n    if (dev->rtce_table) {\n\n        size_t size = (dev->rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT)\n\n            * sizeof(VIOsPAPR_RTCE);\n\n        memset(dev->rtce_table, 0, size);\n\n    }\n\n\n\n    dev->crq.qladdr = 0;\n\n    dev->crq.qsize = 0;\n\n    dev->crq.qnext = 0;\n\n}\n", "idx": 4860}
{"project": "qemu", "commit_id": "6597c28d618a3d16d468770b7c30a0237a8c8ea9", "target": 1, "func": "static void dec_float(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 8);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x00:    /* lf.add.s */\n\n        LOG_DIS(\"lf.add.s r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        gen_helper_float_add_s(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x01:    /* lf.sub.s */\n\n        LOG_DIS(\"lf.sub.s r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        gen_helper_float_sub_s(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n\n\n    case 0x02:    /* lf.mul.s */\n\n        LOG_DIS(\"lf.mul.s r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        if (ra != 0 && rb != 0) {\n\n            gen_helper_float_mul_s(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        } else {\n\n            tcg_gen_ori_tl(fpcsr, fpcsr, FPCSR_ZF);\n\n            tcg_gen_movi_i32(cpu_R[rd], 0x0);\n\n        }\n\n        break;\n\n\n\n    case 0x03:    /* lf.div.s */\n\n        LOG_DIS(\"lf.div.s r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        gen_helper_float_div_s(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x04:    /* lf.itof.s */\n\n        LOG_DIS(\"lf.itof r%d, r%d\\n\", rd, ra);\n\n        gen_helper_itofs(cpu_R[rd], cpu_env, cpu_R[ra]);\n\n        break;\n\n\n\n    case 0x05:    /* lf.ftoi.s */\n\n        LOG_DIS(\"lf.ftoi r%d, r%d\\n\", rd, ra);\n\n        gen_helper_ftois(cpu_R[rd], cpu_env, cpu_R[ra]);\n\n        break;\n\n\n\n    case 0x06:    /* lf.rem.s */\n\n        LOG_DIS(\"lf.rem.s r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        gen_helper_float_rem_s(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x07:    /* lf.madd.s */\n\n        LOG_DIS(\"lf.madd.s r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        gen_helper_float_madd_s(cpu_R[rd], cpu_env, cpu_R[rd],\n\n                                cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x08:    /* lf.sfeq.s */\n\n        LOG_DIS(\"lf.sfeq.s r%d, r%d\\n\", ra, rb);\n\n        gen_helper_float_eq_s(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x09:    /* lf.sfne.s */\n\n        LOG_DIS(\"lf.sfne.s r%d, r%d\\n\", ra, rb);\n\n        gen_helper_float_ne_s(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x0a:    /* lf.sfgt.s */\n\n        LOG_DIS(\"lf.sfgt.s r%d, r%d\\n\", ra, rb);\n\n        gen_helper_float_gt_s(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x0b:    /* lf.sfge.s */\n\n        LOG_DIS(\"lf.sfge.s r%d, r%d\\n\", ra, rb);\n\n        gen_helper_float_ge_s(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x0c:    /* lf.sflt.s */\n\n        LOG_DIS(\"lf.sflt.s r%d, r%d\\n\", ra, rb);\n\n        gen_helper_float_lt_s(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x0d:    /* lf.sfle.s */\n\n        LOG_DIS(\"lf.sfle.s r%d, r%d\\n\", ra, rb);\n\n        gen_helper_float_le_s(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n/* not used yet, open it when we need or64.  */\n\n/*#ifdef TARGET_OPENRISC64\n\n    case 0x10:     lf.add.d\n\n        LOG_DIS(\"lf.add.d r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_add_d(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x11:     lf.sub.d\n\n        LOG_DIS(\"lf.sub.d r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_sub_d(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x12:     lf.mul.d\n\n        LOG_DIS(\"lf.mul.d r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        check_of64s(dc);\n\n        if (ra != 0 && rb != 0) {\n\n            gen_helper_float_mul_d(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        } else {\n\n            tcg_gen_ori_tl(fpcsr, fpcsr, FPCSR_ZF);\n\n            tcg_gen_movi_i64(cpu_R[rd], 0x0);\n\n        }\n\n        break;\n\n\n\n    case 0x13:     lf.div.d\n\n        LOG_DIS(\"lf.div.d r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_div_d(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x14:     lf.itof.d\n\n        LOG_DIS(\"lf.itof r%d, r%d\\n\", rd, ra);\n\n        check_of64s(dc);\n\n        gen_helper_itofd(cpu_R[rd], cpu_env, cpu_R[ra]);\n\n        break;\n\n\n\n    case 0x15:     lf.ftoi.d\n\n        LOG_DIS(\"lf.ftoi r%d, r%d\\n\", rd, ra);\n\n        check_of64s(dc);\n\n        gen_helper_ftoid(cpu_R[rd], cpu_env, cpu_R[ra]);\n\n        break;\n\n\n\n    case 0x16:     lf.rem.d\n\n        LOG_DIS(\"lf.rem.d r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_rem_d(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x17:     lf.madd.d\n\n        LOG_DIS(\"lf.madd.d r%d, r%d, r%d\\n\", rd, ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_madd_d(cpu_R[rd], cpu_env, cpu_R[rd],\n\n                                cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x18:     lf.sfeq.d\n\n        LOG_DIS(\"lf.sfeq.d r%d, r%d\\n\", ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_eq_d(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x1a:     lf.sfgt.d\n\n        LOG_DIS(\"lf.sfgt.d r%d, r%d\\n\", ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_gt_d(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x1b:     lf.sfge.d\n\n        LOG_DIS(\"lf.sfge.d r%d, r%d\\n\", ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_ge_d(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x19:     lf.sfne.d\n\n        LOG_DIS(\"lf.sfne.d r%d, r%d\\n\", ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_ne_d(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x1c:     lf.sflt.d\n\n        LOG_DIS(\"lf.sflt.d r%d, r%d\\n\", ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_lt_d(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n\n\n    case 0x1d:     lf.sfle.d\n\n        LOG_DIS(\"lf.sfle.d r%d, r%d\\n\", ra, rb);\n\n        check_of64s(dc);\n\n        gen_helper_float_le_d(cpu_sr_f, cpu_env, cpu_R[ra], cpu_R[rb]);\n\n        break;\n\n#endif*/\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 4134}
{"project": "qemu", "commit_id": "548f52ea06951c20f0b91cae6cde0512ec073c83", "target": 1, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n    int pending;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    pending = f->buf_size - f->buf_index;\n\n    if (pending > 0) {\n\n        memmove(f->buf, f->buf + f->buf_index, pending);\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = pending;\n\n\n\n    len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n\n                        IO_BUF_SIZE - pending);\n\n    if (len > 0) {\n\n        f->buf_size += len;\n\n        f->pos += len;\n\n    } else if (len == 0) {\n\n        qemu_file_set_error(f, -EIO);\n\n    } else if (len != -EAGAIN) {\n\n        qemu_file_set_error(f, len);\n\n    }\n\n}\n", "idx": 7676}
{"project": "qemu", "commit_id": "11748ba72ea4fc03e975aa5f5d876b5b0902e356", "target": 1, "func": "static int kvm_recommended_vcpus(KVMState *s)\n\n{\n\n    int ret = kvm_check_extension(s, KVM_CAP_NR_VCPUS);\n\n    return (ret) ? ret : 4;\n\n}\n", "idx": 422}
{"project": "qemu", "commit_id": "c919297379e9980c2bcc4d2053addbc1fd6d762b", "target": 1, "func": "static int img_compare(int argc, char **argv)\n\n{\n\n    const char *fmt1 = NULL, *fmt2 = NULL, *cache, *filename1, *filename2;\n\n    BlockBackend *blk1, *blk2;\n\n    BlockDriverState *bs1, *bs2;\n\n    int64_t total_sectors1, total_sectors2;\n\n    uint8_t *buf1 = NULL, *buf2 = NULL;\n\n    int pnum1, pnum2;\n\n    int allocated1, allocated2;\n\n    int ret = 0; /* return value - 0 Ident, 1 Different, >1 Error */\n\n    bool progress = false, quiet = false, strict = false;\n\n    int flags;\n\n    bool writethrough;\n\n    int64_t total_sectors;\n\n    int64_t sector_num = 0;\n\n    int64_t nb_sectors;\n\n    int c, pnum;\n\n    uint64_t progress_base;\n\n    bool image_opts = false;\n\n\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    for (;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"hf:F:T:pqs\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch (c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt1 = optarg;\n\n            break;\n\n        case 'F':\n\n            fmt2 = optarg;\n\n            break;\n\n        case 'T':\n\n            cache = optarg;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case 's':\n\n            strict = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                ret = 2;\n\n                goto out4;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Progress is not shown in Quiet mode */\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n\n\n    if (optind != argc - 2) {\n\n        error_exit(\"Expecting two image file names\");\n\n    }\n\n    filename1 = argv[optind++];\n\n    filename2 = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        ret = 2;\n\n        goto out4;\n\n    }\n\n\n\n    /* Initialize before goto out */\n\n    qemu_progress_init(progress, 2.0);\n\n\n\n    flags = 0;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid source cache option: %s\", cache);\n\n        ret = 2;\n\n        goto out3;\n\n    }\n\n\n\n    blk1 = img_open(image_opts, filename1, fmt1, flags, writethrough, quiet);\n\n    if (!blk1) {\n\n        ret = 2;\n\n        goto out3;\n\n    }\n\n\n\n    blk2 = img_open(image_opts, filename2, fmt2, flags, writethrough, quiet);\n\n    if (!blk2) {\n\n        ret = 2;\n\n        goto out2;\n\n    }\n\n    bs1 = blk_bs(blk1);\n\n    bs2 = blk_bs(blk2);\n\n\n\n    buf1 = blk_blockalign(blk1, IO_BUF_SIZE);\n\n    buf2 = blk_blockalign(blk2, IO_BUF_SIZE);\n\n    total_sectors1 = blk_nb_sectors(blk1);\n\n    if (total_sectors1 < 0) {\n\n        error_report(\"Can't get size of %s: %s\",\n\n                     filename1, strerror(-total_sectors1));\n\n        ret = 4;\n\n        goto out;\n\n    }\n\n    total_sectors2 = blk_nb_sectors(blk2);\n\n    if (total_sectors2 < 0) {\n\n        error_report(\"Can't get size of %s: %s\",\n\n                     filename2, strerror(-total_sectors2));\n\n        ret = 4;\n\n        goto out;\n\n    }\n\n    total_sectors = MIN(total_sectors1, total_sectors2);\n\n    progress_base = MAX(total_sectors1, total_sectors2);\n\n\n\n    qemu_progress_print(0, 100);\n\n\n\n    if (strict && total_sectors1 != total_sectors2) {\n\n        ret = 1;\n\n        qprintf(quiet, \"Strict mode: Image size mismatch!\\n\");\n\n        goto out;\n\n    }\n\n\n\n    for (;;) {\n\n        int64_t status1, status2;\n\n        BlockDriverState *file;\n\n\n\n        nb_sectors = sectors_to_process(total_sectors, sector_num);\n\n        if (nb_sectors <= 0) {\n\n            break;\n\n        }\n\n        status1 = bdrv_get_block_status_above(bs1, NULL, sector_num,\n\n                                              total_sectors1 - sector_num,\n\n                                              &pnum1, &file);\n\n        if (status1 < 0) {\n\n            ret = 3;\n\n            error_report(\"Sector allocation test failed for %s\", filename1);\n\n            goto out;\n\n        }\n\n        allocated1 = status1 & BDRV_BLOCK_ALLOCATED;\n\n\n\n        status2 = bdrv_get_block_status_above(bs2, NULL, sector_num,\n\n                                              total_sectors2 - sector_num,\n\n                                              &pnum2, &file);\n\n        if (status2 < 0) {\n\n            ret = 3;\n\n            error_report(\"Sector allocation test failed for %s\", filename2);\n\n            goto out;\n\n        }\n\n        allocated2 = status2 & BDRV_BLOCK_ALLOCATED;\n\n        if (pnum1) {\n\n            nb_sectors = MIN(nb_sectors, pnum1);\n\n        }\n\n        if (pnum2) {\n\n            nb_sectors = MIN(nb_sectors, pnum2);\n\n        }\n\n\n\n        if (strict) {\n\n            if ((status1 & ~BDRV_BLOCK_OFFSET_MASK) !=\n\n                (status2 & ~BDRV_BLOCK_OFFSET_MASK)) {\n\n                ret = 1;\n\n                qprintf(quiet, \"Strict mode: Offset %\" PRId64\n\n                        \" block status mismatch!\\n\",\n\n                        sectors_to_bytes(sector_num));\n\n                goto out;\n\n            }\n\n        }\n\n        if ((status1 & BDRV_BLOCK_ZERO) && (status2 & BDRV_BLOCK_ZERO)) {\n\n            nb_sectors = MIN(pnum1, pnum2);\n\n        } else if (allocated1 == allocated2) {\n\n            if (allocated1) {\n\n                ret = blk_pread(blk1, sector_num << BDRV_SECTOR_BITS, buf1,\n\n                                nb_sectors << BDRV_SECTOR_BITS);\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64 \" of %s:\"\n\n                                 \" %s\", sectors_to_bytes(sector_num), filename1,\n\n                                 strerror(-ret));\n\n                    ret = 4;\n\n                    goto out;\n\n                }\n\n                ret = blk_pread(blk2, sector_num << BDRV_SECTOR_BITS, buf2,\n\n                                nb_sectors << BDRV_SECTOR_BITS);\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64\n\n                                 \" of %s: %s\", sectors_to_bytes(sector_num),\n\n                                 filename2, strerror(-ret));\n\n                    ret = 4;\n\n                    goto out;\n\n                }\n\n                ret = compare_sectors(buf1, buf2, nb_sectors, &pnum);\n\n                if (ret || pnum != nb_sectors) {\n\n                    qprintf(quiet, \"Content mismatch at offset %\" PRId64 \"!\\n\",\n\n                            sectors_to_bytes(\n\n                                ret ? sector_num : sector_num + pnum));\n\n                    ret = 1;\n\n                    goto out;\n\n                }\n\n            }\n\n        } else {\n\n\n\n            if (allocated1) {\n\n                ret = check_empty_sectors(blk1, sector_num, nb_sectors,\n\n                                          filename1, buf1, quiet);\n\n            } else {\n\n                ret = check_empty_sectors(blk2, sector_num, nb_sectors,\n\n                                          filename2, buf1, quiet);\n\n            }\n\n            if (ret) {\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64 \": %s\",\n\n                                 sectors_to_bytes(sector_num), strerror(-ret));\n\n                    ret = 4;\n\n                }\n\n                goto out;\n\n            }\n\n        }\n\n        sector_num += nb_sectors;\n\n        qemu_progress_print(((float) nb_sectors / progress_base)*100, 100);\n\n    }\n\n\n\n    if (total_sectors1 != total_sectors2) {\n\n        BlockBackend *blk_over;\n\n        int64_t total_sectors_over;\n\n        const char *filename_over;\n\n\n\n        qprintf(quiet, \"Warning: Image size mismatch!\\n\");\n\n        if (total_sectors1 > total_sectors2) {\n\n            total_sectors_over = total_sectors1;\n\n            blk_over = blk1;\n\n            filename_over = filename1;\n\n        } else {\n\n            total_sectors_over = total_sectors2;\n\n            blk_over = blk2;\n\n            filename_over = filename2;\n\n        }\n\n\n\n        for (;;) {\n\n            nb_sectors = sectors_to_process(total_sectors_over, sector_num);\n\n            if (nb_sectors <= 0) {\n\n                break;\n\n            }\n\n            ret = bdrv_is_allocated_above(blk_bs(blk_over), NULL, sector_num,\n\n                                          nb_sectors, &pnum);\n\n            if (ret < 0) {\n\n                ret = 3;\n\n                error_report(\"Sector allocation test failed for %s\",\n\n                             filename_over);\n\n                goto out;\n\n\n\n            }\n\n            nb_sectors = pnum;\n\n            if (ret) {\n\n                ret = check_empty_sectors(blk_over, sector_num, nb_sectors,\n\n                                          filename_over, buf1, quiet);\n\n                if (ret) {\n\n                    if (ret < 0) {\n\n                        error_report(\"Error while reading offset %\" PRId64\n\n                                     \" of %s: %s\", sectors_to_bytes(sector_num),\n\n                                     filename_over, strerror(-ret));\n\n                        ret = 4;\n\n                    }\n\n                    goto out;\n\n                }\n\n            }\n\n            sector_num += nb_sectors;\n\n            qemu_progress_print(((float) nb_sectors / progress_base)*100, 100);\n\n        }\n\n    }\n\n\n\n    qprintf(quiet, \"Images are identical.\\n\");\n\n    ret = 0;\n\n\n\nout:\n\n    qemu_vfree(buf1);\n\n    qemu_vfree(buf2);\n\n    blk_unref(blk2);\n\nout2:\n\n    blk_unref(blk1);\n\nout3:\n\n    qemu_progress_end();\n\nout4:\n\n    return ret;\n\n}\n", "idx": 3665}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "uint64_t HELPER(get_cp_reg64)(CPUARMState *env, void *rip)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    return ri->readfn(env, ri);\n\n}\n", "idx": 1222}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static void coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen = 0;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    switch (aiocb_type) {\n\n    case AIOCB_FLUSH_CACHE:\n\n        hdr.opcode = SD_OP_FLUSH_VDI;\n\n        break;\n\n    case AIOCB_READ_UDATA:\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n        break;\n\n    case AIOCB_WRITE_UDATA:\n\n        if (create) {\n\n            hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        } else {\n\n            hdr.opcode = SD_OP_WRITE_OBJ;\n\n        }\n\n        wlen = datalen;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n        break;\n\n    case AIOCB_DISCARD_OBJ:\n\n        hdr.opcode = SD_OP_DISCARD_OBJ;\n\n        break;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    aio_set_fd_handler(s->aio_context, s->fd,\n\n                       co_read_response, co_write_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret != sizeof(hdr)) {\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret != wlen) {\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n        }\n\n    }\n\nout:\n\n    socket_set_cork(s->fd, 0);\n\n    aio_set_fd_handler(s->aio_context, s->fd, co_read_response, NULL, s);\n\n    s->co_send = NULL;\n\n    qemu_co_mutex_unlock(&s->lock);\n\n}\n", "idx": 2053}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_wait_io_event_common(CPUState *cpu)\n\n{\n\n    if (cpu->stop) {\n\n        cpu->stop = false;\n\n        cpu->stopped = true;\n\n        qemu_cond_broadcast(&qemu_pause_cond);\n\n    }\n\n    process_queued_cpu_work(cpu);\n\n    cpu->thread_kicked = false;\n\n}\n", "idx": 8067}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_gp_timer_s *omap_gp_timer_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_gp_timer_s *s = (struct omap_gp_timer_s *)\n\n            g_malloc0(sizeof(struct omap_gp_timer_s));\n\n\n\n    s->ta = ta;\n\n    s->irq = irq;\n\n    s->clk = fclk;\n\n    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, omap_gp_timer_tick, s);\n\n    s->match = timer_new_ns(QEMU_CLOCK_VIRTUAL, omap_gp_timer_match, s);\n\n    s->in = qemu_allocate_irq(omap_gp_timer_input, s, 0);\n\n    omap_gp_timer_reset(s);\n\n    omap_gp_timer_clk_setup(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_gp_timer_ops, s, \"omap.gptimer\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 11834}
{"project": "qemu", "commit_id": "3794d5482d74dc0031cee6d5be2c61c88ca723bd", "target": 1, "func": "int spapr_h_cas_compose_response(target_ulong addr, target_ulong size)\n\n{\n\n    void *fdt, *fdt_skel;\n\n    sPAPRDeviceTreeUpdateHeader hdr = { .version_id = 1 };\n\n\n\n    size -= sizeof(hdr);\n\n\n\n    /* Create sceleton */\n\n    fdt_skel = g_malloc0(size);\n\n    _FDT((fdt_create(fdt_skel, size)));\n\n    _FDT((fdt_begin_node(fdt_skel, \"\")));\n\n    _FDT((fdt_end_node(fdt_skel)));\n\n    _FDT((fdt_finish(fdt_skel)));\n\n    fdt = g_malloc0(size);\n\n    _FDT((fdt_open_into(fdt_skel, fdt, size)));\n\n    g_free(fdt_skel);\n\n\n\n    /* Place to make changes to the tree */\n\n\n\n    /* Pack resulting tree */\n\n    _FDT((fdt_pack(fdt)));\n\n\n\n    if (fdt_totalsize(fdt) + sizeof(hdr) > size) {\n\n        trace_spapr_cas_failed(size);\n\n        return -1;\n\n    }\n\n\n\n    cpu_physical_memory_write(addr, &hdr, sizeof(hdr));\n\n    cpu_physical_memory_write(addr + sizeof(hdr), fdt, fdt_totalsize(fdt));\n\n    trace_spapr_cas_continue(fdt_totalsize(fdt) + sizeof(hdr));\n\n    g_free(fdt);\n\n\n\n    return 0;\n\n}\n", "idx": 11083}
{"project": "qemu", "commit_id": "ba4906a9b64e165a958e12f6208ca834dc7a36dc", "target": 1, "func": "static int ds1338_send(I2CSlave *i2c, uint8_t data)\n\n{\n\n    DS1338State *s = FROM_I2C_SLAVE(DS1338State, i2c);\n\n    if (s->addr_byte) {\n\n        s->ptr = data;\n\n        s->addr_byte = 0;\n\n        return 0;\n\n    }\n\n    s->nvram[s->ptr - 8] = data;\n\n    if (data < 8) {\n\n        qemu_get_timedate(&s->now, s->offset);\n\n        switch(data) {\n\n        case 0:\n\n            /* TODO: Implement CH (stop) bit.  */\n\n            s->now.tm_sec = from_bcd(data & 0x7f);\n\n            break;\n\n        case 1:\n\n            s->now.tm_min = from_bcd(data & 0x7f);\n\n            break;\n\n        case 2:\n\n            if (data & 0x40) {\n\n                if (data & 0x20) {\n\n                    data = from_bcd(data & 0x4f) + 11;\n\n                } else {\n\n                    data = from_bcd(data & 0x1f) - 1;\n\n                }\n\n            } else {\n\n                data = from_bcd(data);\n\n            }\n\n            s->now.tm_hour = data;\n\n            break;\n\n        case 3:\n\n            s->now.tm_wday = from_bcd(data & 7) - 1;\n\n            break;\n\n        case 4:\n\n            s->now.tm_mday = from_bcd(data & 0x3f);\n\n            break;\n\n        case 5:\n\n            s->now.tm_mon = from_bcd(data & 0x1f) - 1;\n\n            break;\n\n        case 6:\n\n            s->now.tm_year = from_bcd(data) + 100;\n\n            break;\n\n        case 7:\n\n            /* Control register. Currently ignored.  */\n\n            break;\n\n        }\n\n        s->offset = qemu_timedate_diff(&s->now);\n\n    }\n\n    s->ptr = (s->ptr + 1) & 0xff;\n\n    return 0;\n\n}\n", "idx": 2523}
{"project": "qemu", "commit_id": "8f94a6e40e46cbc8e8014da825d25824b1803b34", "target": 1, "func": "int bdrv_open(BlockDriverState *bs, const char *filename, QDict *options,\n\n              int flags, BlockDriver *drv, Error **errp)\n\n{\n\n    int ret;\n\n    /* TODO: extra byte is a hack to ensure MAX_PATH space on Windows. */\n\n    char tmp_filename[PATH_MAX + 1];\n\n    BlockDriverState *file = NULL;\n\n    QDict *file_options = NULL;\n\n    const char *drvname;\n\n    Error *local_err = NULL;\n\n\n\n    /* NULL means an empty set of options */\n\n    if (options == NULL) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    bs->options = options;\n\n    options = qdict_clone_shallow(options);\n\n\n\n    /* For snapshot=on, create a temporary qcow2 overlay */\n\n    if (flags & BDRV_O_SNAPSHOT) {\n\n        BlockDriverState *bs1;\n\n        int64_t total_size;\n\n        BlockDriver *bdrv_qcow2;\n\n        QEMUOptionParameter *create_options;\n\n        char backing_filename[PATH_MAX];\n\n\n\n        if (qdict_size(options) != 0) {\n\n            error_setg(errp, \"Can't use snapshot=on with driver-specific options\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        assert(filename != NULL);\n\n\n\n        /* if snapshot, we create a temporary backing file and open it\n\n           instead of opening 'filename' directly */\n\n\n\n        /* if there is a backing file, use it */\n\n        bs1 = bdrv_new(\"\");\n\n        ret = bdrv_open(bs1, filename, NULL, 0, drv, &local_err);\n\n        if (ret < 0) {\n\n            bdrv_unref(bs1);\n\n            goto fail;\n\n        }\n\n        total_size = bdrv_getlength(bs1) & BDRV_SECTOR_MASK;\n\n\n\n        bdrv_unref(bs1);\n\n\n\n        ret = get_tmp_filename(tmp_filename, sizeof(tmp_filename));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not get temporary filename\");\n\n            goto fail;\n\n        }\n\n\n\n        /* Real path is meaningless for protocols */\n\n        if (path_has_protocol(filename)) {\n\n            snprintf(backing_filename, sizeof(backing_filename),\n\n                     \"%s\", filename);\n\n        } else if (!realpath(filename, backing_filename)) {\n\n            error_setg_errno(errp, errno, \"Could not resolve path '%s'\", filename);\n\n            ret = -errno;\n\n            goto fail;\n\n        }\n\n\n\n        bdrv_qcow2 = bdrv_find_format(\"qcow2\");\n\n        create_options = parse_option_parameters(\"\", bdrv_qcow2->create_options,\n\n                                                 NULL);\n\n\n\n        set_option_parameter_int(create_options, BLOCK_OPT_SIZE, total_size);\n\n        set_option_parameter(create_options, BLOCK_OPT_BACKING_FILE,\n\n                             backing_filename);\n\n        if (drv) {\n\n            set_option_parameter(create_options, BLOCK_OPT_BACKING_FMT,\n\n                drv->format_name);\n\n        }\n\n\n\n        ret = bdrv_create(bdrv_qcow2, tmp_filename, create_options, &local_err);\n\n        free_option_parameters(create_options);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not create temporary overlay \"\n\n                             \"'%s': %s\", tmp_filename,\n\n                             error_get_pretty(local_err));\n\n            error_free(local_err);\n\n            local_err = NULL;\n\n            goto fail;\n\n        }\n\n\n\n        filename = tmp_filename;\n\n        drv = bdrv_qcow2;\n\n        bs->is_temporary = 1;\n\n    }\n\n\n\n    /* Open image file without format layer */\n\n    if (flags & BDRV_O_RDWR) {\n\n        flags |= BDRV_O_ALLOW_RDWR;\n\n    }\n\n\n\n    qdict_extract_subqdict(options, &file_options, \"file.\");\n\n\n\n    ret = bdrv_file_open(&file, filename, file_options,\n\n                         bdrv_open_flags(bs, flags | BDRV_O_UNMAP), &local_err);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Find the right image format driver */\n\n    drvname = qdict_get_try_str(options, \"driver\");\n\n    if (drvname) {\n\n        drv = bdrv_find_whitelisted_format(drvname, !(flags & BDRV_O_RDWR));\n\n        qdict_del(options, \"driver\");\n\n    }\n\n\n\n    if (!drv) {\n\n        ret = find_image_format(file, filename, &drv, &local_err);\n\n    }\n\n\n\n    if (!drv) {\n\n        goto unlink_and_fail;\n\n    }\n\n\n\n    /* Open the image */\n\n    ret = bdrv_open_common(bs, file, options, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        goto unlink_and_fail;\n\n    }\n\n\n\n    if (bs->file != file) {\n\n        bdrv_unref(file);\n\n        file = NULL;\n\n    }\n\n\n\n    /* If there is a backing file, use it */\n\n    if ((flags & BDRV_O_NO_BACKING) == 0) {\n\n        QDict *backing_options;\n\n\n\n        qdict_extract_subqdict(options, &backing_options, \"backing.\");\n\n        ret = bdrv_open_backing_file(bs, backing_options, &local_err);\n\n        if (ret < 0) {\n\n            goto close_and_fail;\n\n        }\n\n    }\n\n\n\n    /* Check if any unknown options were used */\n\n    if (qdict_size(options) != 0) {\n\n        const QDictEntry *entry = qdict_first(options);\n\n        error_setg(errp, \"Block format '%s' used by device '%s' doesn't \"\n\n                   \"support the option '%s'\", drv->format_name, bs->device_name,\n\n                   entry->key);\n\n\n\n        ret = -EINVAL;\n\n        goto close_and_fail;\n\n    }\n\n    QDECREF(options);\n\n\n\n    if (!bdrv_key_required(bs)) {\n\n        bdrv_dev_change_media_cb(bs, true);\n\n    }\n\n\n\n    return 0;\n\n\n\nunlink_and_fail:\n\n    if (file != NULL) {\n\n        bdrv_unref(file);\n\n    }\n\n    if (bs->is_temporary) {\n\n        unlink(filename);\n\n    }\n\nfail:\n\n    QDECREF(bs->options);\n\n    QDECREF(options);\n\n    bs->options = NULL;\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    return ret;\n\n\n\nclose_and_fail:\n\n    bdrv_close(bs);\n\n    QDECREF(options);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    return ret;\n\n}\n", "idx": 5664}
{"project": "qemu", "commit_id": "ea15fb067212bb79291f9b76c5c76d45b62f58e1", "target": 1, "func": "static void tcg_target_qemu_prologue(TCGContext *s)\n\n{\n\n    int i, frame_size;\n\n\n\n    /* reserve some stack space */\n\n    frame_size = ARRAY_SIZE(tcg_target_callee_save_regs) * 4\n\n                 + TCG_STATIC_CALL_ARGS_SIZE;\n\n    frame_size = (frame_size + TCG_TARGET_STACK_ALIGN - 1) &\n\n                 ~(TCG_TARGET_STACK_ALIGN - 1);\n\n\n\n    /* TB prologue */\n\n    tcg_out_addi(s, TCG_REG_SP, -frame_size);\n\n    for(i = 0 ; i < ARRAY_SIZE(tcg_target_callee_save_regs) ; i++) {\n\n        tcg_out_st(s, TCG_TYPE_I32, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, TCG_STATIC_CALL_ARGS_SIZE + i * 4);\n\n    }\n\n\n\n    /* Call generated code */\n\n    tcg_out_opc_reg(s, OPC_JR, 0, tcg_target_call_iarg_regs[1]), 0);\n\n    tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[0]);\n\n    tb_ret_addr = s->code_ptr;\n\n\n\n    /* TB epilogue */\n\n    for(i = 0 ; i < ARRAY_SIZE(tcg_target_callee_save_regs) ; i++) {\n\n        tcg_out_ld(s, TCG_TYPE_I32, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, TCG_STATIC_CALL_ARGS_SIZE + i * 4);\n\n    }\n\n\n\n    tcg_out_opc_reg(s, OPC_JR, 0, TCG_REG_RA, 0);\n\n    tcg_out_addi(s, TCG_REG_SP, frame_size);\n\n}\n", "idx": 4556}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void vnc_colordepth(DisplayState *ds)\n\n{\n\n    int host_big_endian_flag;\n\n    struct VncState *vs = ds->opaque;\n\n\n\n#ifdef WORDS_BIGENDIAN\n\n    host_big_endian_flag = 1;\n\n#else\n\n    host_big_endian_flag = 0;\n\n#endif   \n\n    \n\n    switch (ds_get_bits_per_pixel(ds)) {\n\n        case 8:\n\n            vs->depth = 1;\n\n            vs->server_red_max = 7;\n\n            vs->server_green_max = 7;\n\n            vs->server_blue_max = 3;\n\n            vs->server_red_shift = 5;\n\n            vs->server_green_shift = 2;\n\n            vs->server_blue_shift = 0;\n\n            break;\n\n        case 16:\n\n            vs->depth = 2;\n\n            vs->server_red_max = 31;\n\n            vs->server_green_max = 63;\n\n            vs->server_blue_max = 31;\n\n            vs->server_red_shift = 11;\n\n            vs->server_green_shift = 5;\n\n            vs->server_blue_shift = 0;\n\n            break;\n\n        case 32:\n\n            vs->depth = 4;\n\n            vs->server_red_max = 255;\n\n            vs->server_green_max = 255;\n\n            vs->server_blue_max = 255;\n\n            vs->server_red_shift = 16;\n\n            vs->server_green_shift = 8;\n\n            vs->server_blue_shift = 0;\n\n            break;\n\n        default:\n\n            return;\n\n    }\n\n\n\n    if (vs->csock != -1 && vs->has_WMVi) {\n\n        /* Sending a WMVi message to notify the client*/\n\n        vnc_write_u8(vs, 0);  /* msg id */\n\n        vnc_write_u8(vs, 0);\n\n        vnc_write_u16(vs, 1); /* number of rects */\n\n        vnc_framebuffer_update(vs, 0, 0, ds_get_width(ds), ds_get_height(ds), 0x574D5669);\n\n        pixel_format_message(vs);\n\n        vnc_flush(vs);\n\n    } else {\n\n        if (vs->pix_bpp == 4 && vs->depth == 4 &&\n\n                host_big_endian_flag == vs->pix_big_endian &&\n\n                vs->client_red_max == 0xff && vs->client_green_max == 0xff && vs->client_blue_max == 0xff &&\n\n                vs->client_red_shift == 16 && vs->client_green_shift == 8 && vs->client_blue_shift == 0) {\n\n            vs->write_pixels = vnc_write_pixels_copy;\n\n            vs->send_hextile_tile = send_hextile_tile_32;\n\n        } else if (vs->pix_bpp == 2 && vs->depth == 2 &&\n\n                host_big_endian_flag == vs->pix_big_endian &&\n\n                vs->client_red_max == 31 && vs->client_green_max == 63 && vs->client_blue_max == 31 &&\n\n                vs->client_red_shift == 11 && vs->client_green_shift == 5 && vs->client_blue_shift == 0) {\n\n            vs->write_pixels = vnc_write_pixels_copy;\n\n            vs->send_hextile_tile = send_hextile_tile_16;\n\n        } else if (vs->pix_bpp == 1 && vs->depth == 1 &&\n\n                host_big_endian_flag == vs->pix_big_endian &&\n\n                vs->client_red_max == 7 && vs->client_green_max == 7 && vs->client_blue_max == 3 &&\n\n                vs->client_red_shift == 5 && vs->client_green_shift == 2 && vs->client_blue_shift == 0) {\n\n            vs->write_pixels = vnc_write_pixels_copy;\n\n            vs->send_hextile_tile = send_hextile_tile_8;\n\n        } else {\n\n            if (vs->depth == 4) {\n\n                vs->send_hextile_tile = send_hextile_tile_generic_32;\n\n            } else if (vs->depth == 2) {\n\n                vs->send_hextile_tile = send_hextile_tile_generic_16;\n\n            } else {\n\n                vs->send_hextile_tile = send_hextile_tile_generic_8;\n\n            }\n\n            vs->write_pixels = vnc_write_pixels_generic;\n\n        }\n\n    }\n\n}\n", "idx": 9551}
{"project": "qemu", "commit_id": "0f7bfd8198ffad58a5095ac5d7a46288ea7f5c6e", "target": 1, "func": "static void qxl_exit_vga_mode(PCIQXLDevice *d)\n\n{\n\n    if (d->mode != QXL_MODE_VGA) {\n\n        return;\n\n    }\n\n    trace_qxl_exit_vga_mode(d->id);\n\n\n    qxl_destroy_primary(d, QXL_SYNC);\n\n}", "idx": 1160}
{"project": "qemu", "commit_id": "2362a28ea11c145e1a13ae79342d76dc118a72a6", "target": 1, "func": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    rcu_register_thread();\n\n\n\n    my_iothread = iothread;\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!atomic_read(&iothread->stopping)) {\n\n        aio_poll(iothread->ctx, true);\n\n\n\n        if (atomic_read(&iothread->worker_context)) {\n\n            GMainLoop *loop;\n\n\n\n            g_main_context_push_thread_default(iothread->worker_context);\n\n            iothread->main_loop =\n\n                g_main_loop_new(iothread->worker_context, TRUE);\n\n            loop = iothread->main_loop;\n\n\n\n            g_main_loop_run(iothread->main_loop);\n\n            iothread->main_loop = NULL;\n\n            g_main_loop_unref(loop);\n\n\n\n            g_main_context_pop_thread_default(iothread->worker_context);\n\n        }\n\n    }\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 10217}
{"project": "qemu", "commit_id": "833c7174ce5145397d2b3405f6857ca607fed1f1", "target": 1, "func": "static int net_client_init(const char *str)\n\n{\n\n    const char *p;\n\n    char *q;\n\n    char device[64];\n\n    char buf[1024];\n\n    int vlan_id, ret;\n\n    VLANState *vlan;\n\n\n\n    p = str;\n\n    q = device;\n\n    while (*p != '\\0' && *p != ',') {\n\n        if ((q - device) < sizeof(device) - 1)\n\n            *q++ = *p;\n\n        p++;\n\n    }\n\n    *q = '\\0';\n\n    if (*p == ',')\n\n        p++;\n\n    vlan_id = 0;\n\n    if (get_param_value(buf, sizeof(buf), \"vlan\", p)) {\n\n        vlan_id = strtol(buf, NULL, 0);\n\n    }\n\n    vlan = qemu_find_vlan(vlan_id);\n\n    if (!vlan) {\n\n        fprintf(stderr, \"Could not create vlan %d\\n\", vlan_id);\n\n        return -1;\n\n    }\n\n    if (!strcmp(device, \"nic\")) {\n\n        NICInfo *nd;\n\n        uint8_t *macaddr;\n\n\n\n        if (nb_nics >= MAX_NICS) {\n\n            fprintf(stderr, \"Too Many NICs\\n\");\n\n            return -1;\n\n        }\n\n        nd = &nd_table[nb_nics];\n\n        macaddr = nd->macaddr;\n\n        macaddr[0] = 0x52;\n\n        macaddr[1] = 0x54;\n\n        macaddr[2] = 0x00;\n\n        macaddr[3] = 0x12;\n\n        macaddr[4] = 0x34;\n\n        macaddr[5] = 0x56 + nb_nics;\n\n\n\n        if (get_param_value(buf, sizeof(buf), \"macaddr\", p)) {\n\n            if (parse_macaddr(macaddr, buf) < 0) {\n\n                fprintf(stderr, \"invalid syntax for ethernet address\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n        if (get_param_value(buf, sizeof(buf), \"model\", p)) {\n\n            nd->model = strdup(buf);\n\n        }\n\n        nd->vlan = vlan;\n\n        nb_nics++;\n\n        vlan->nb_guest_devs++;\n\n        ret = 0;\n\n    } else\n\n    if (!strcmp(device, \"none\")) {\n\n        /* does nothing. It is needed to signal that no network cards\n\n           are wanted */\n\n        ret = 0;\n\n    } else\n\n#ifdef CONFIG_SLIRP\n\n    if (!strcmp(device, \"user\")) {\n\n        if (get_param_value(buf, sizeof(buf), \"hostname\", p)) {\n\n            pstrcpy(slirp_hostname, sizeof(slirp_hostname), buf);\n\n        }\n\n\n        ret = net_slirp_init(vlan);\n\n    } else\n\n#endif\n\n#ifdef _WIN32\n\n    if (!strcmp(device, \"tap\")) {\n\n        char ifname[64];\n\n        if (get_param_value(ifname, sizeof(ifname), \"ifname\", p) <= 0) {\n\n            fprintf(stderr, \"tap: no interface name\\n\");\n\n            return -1;\n\n        }\n\n\n        ret = tap_win32_init(vlan, ifname);\n\n    } else\n\n#else\n\n    if (!strcmp(device, \"tap\")) {\n\n        char ifname[64];\n\n        char setup_script[1024];\n\n        int fd;\n\n        if (get_param_value(buf, sizeof(buf), \"fd\", p) > 0) {\n\n            fd = strtol(buf, NULL, 0);\n\n            ret = -1;\n\n            if (net_tap_fd_init(vlan, fd))\n\n                ret = 0;\n\n        } else {\n\n            if (get_param_value(ifname, sizeof(ifname), \"ifname\", p) <= 0) {\n\n                ifname[0] = '\\0';\n\n            }\n\n            if (get_param_value(setup_script, sizeof(setup_script), \"script\", p) == 0) {\n\n                pstrcpy(setup_script, sizeof(setup_script), DEFAULT_NETWORK_SCRIPT);\n\n            }\n\n\n            ret = net_tap_init(vlan, ifname, setup_script);\n\n        }\n\n    } else\n\n#endif\n\n    if (!strcmp(device, \"socket\")) {\n\n        if (get_param_value(buf, sizeof(buf), \"fd\", p) > 0) {\n\n            int fd;\n\n            fd = strtol(buf, NULL, 0);\n\n            ret = -1;\n\n            if (net_socket_fd_init(vlan, fd, 1))\n\n                ret = 0;\n\n        } else if (get_param_value(buf, sizeof(buf), \"listen\", p) > 0) {\n\n            ret = net_socket_listen_init(vlan, buf);\n\n        } else if (get_param_value(buf, sizeof(buf), \"connect\", p) > 0) {\n\n            ret = net_socket_connect_init(vlan, buf);\n\n        } else if (get_param_value(buf, sizeof(buf), \"mcast\", p) > 0) {\n\n            ret = net_socket_mcast_init(vlan, buf);\n\n        } else {\n\n            fprintf(stderr, \"Unknown socket options: %s\\n\", p);\n\n            return -1;\n\n        }\n\n\n    } else\n\n    {\n\n        fprintf(stderr, \"Unknown network device: %s\\n\", device);\n\n        return -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Could not initialize device '%s'\\n\", device);\n\n    }\n\n    \n\n    return ret;\n\n}", "idx": 3663}
{"project": "qemu", "commit_id": "9a321e92343891e30f6fe8bfaad40454ae358bfb", "target": 1, "func": "static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */\n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    int ndev, irq, max_irqs = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Fins sPAPRPHBState */\n\n    phb = find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Releasing MSIs */\n\n    if (!req_num) {\n\n        ndev = spapr_msicfg_find(phb, config_addr, false);\n\n        if (ndev < 0) {\n\n            trace_spapr_pci_msi(\"MSI has not been enabled\", -1, config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n        trace_spapr_pci_msi(\"Released MSIs\", ndev, config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    /* Enabling MSI */\n\n\n\n    /* Find a device number in the map to add or reuse the existing one */\n\n    ndev = spapr_msicfg_find(phb, config_addr, true);\n\n    if (ndev >= SPAPR_MSIX_MAX_DEVS || ndev < 0) {\n\n        error_report(\"No free entry for a new MSI device\");\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n    trace_spapr_pci_msi(\"Configuring MSI\", ndev, config_addr);\n\n\n\n    /* Check if the device supports as many IRQs as requested */\n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device#%d\",\n\n                     ret_intr_type, ndev);\n\n        rtas_st(rets, 0, -1); /* Hardware error */\n\n        return;\n\n    }\n\n    /* Correct the number if the guest asked for too many */\n\n    if (req_num > max_irqs) {\n\n        req_num = max_irqs;\n\n    }\n\n\n\n    /* Check if there is an old config and MSI number has not changed */\n\n    if (phb->msi_table[ndev].nvec && (req_num != phb->msi_table[ndev].nvec)) {\n\n        /* Unexpected behaviour */\n\n        error_report(\"Cannot reuse MSI config for device#%d\", ndev);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* There is no cached config, allocate MSIs */\n\n    if (!phb->msi_table[ndev].nvec) {\n\n        irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                               ret_intr_type == RTAS_TYPE_MSI);\n\n        if (irq < 0) {\n\n            error_report(\"Cannot allocate MSIs for device#%d\", ndev);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n        phb->msi_table[ndev].irq = irq;\n\n        phb->msi_table[ndev].nvec = req_num;\n\n        phb->msi_table[ndev].config_addr = config_addr;\n\n    }\n\n\n\n    /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */\n\n    spapr_msi_setmsg(pdev, spapr->msi_win_addr, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     phb->msi_table[ndev].irq, req_num);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    rtas_st(rets, 3, ret_intr_type);\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(func, req_num);\n\n}\n", "idx": 6795}
{"project": "qemu", "commit_id": "59c9f437c59a4bf0594ed300d28fb24c645963a5", "target": 1, "func": "static bool run_poll_handlers_once(AioContext *ctx)\n\n{\n\n    bool progress = false;\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n            progress = true;\n\n        }\n\n\n\n        /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n    }\n\n\n\n    return progress;\n\n}\n", "idx": 8764}
{"project": "qemu", "commit_id": "f9a8b5530d438f836f9697639814f585aaec554d", "target": 1, "func": "int qdev_prop_check_globals(void)\n\n{\n\n    GlobalProperty *prop;\n\n    int ret = 0;\n\n\n\n    QTAILQ_FOREACH(prop, &global_props, next) {\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 1296}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static void buffer_reserve(Buffer *buffer, size_t len)\n\n{\n\n    if ((buffer->capacity - buffer->offset) < len) {\n\n\tbuffer->capacity += (len + 1024);\n\n\tbuffer->buffer = qemu_realloc(buffer->buffer, buffer->capacity);\n\n\tif (buffer->buffer == NULL) {\n\n\t    fprintf(stderr, \"vnc: out of memory\\n\");\n\n\t    exit(1);\n\n\t}\n\n    }\n\n}\n", "idx": 7113}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_read_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 1793}
{"project": "qemu", "commit_id": "66a08cbe6ad1aebec8eecf58b3ba042e19dd1649", "target": 1, "func": "static int uhci_handle_td(UHCIState *s, UHCIQueue *q,\n\n                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)\n\n{\n\n    UHCIAsync *async;\n\n    int len = 0, max_len;\n\n    bool spd;\n\n    bool queuing = (q != NULL);\n\n    uint8_t pid = td->token & 0xff;\n\n\n\n    /* Is active ? */\n\n    if (!(td->ctrl & TD_CTRL_ACTIVE)) {\n\n        /*\n\n         * ehci11d spec page 22: \"Even if the Active bit in the TD is already\n\n         * cleared when the TD is fetched ... an IOC interrupt is generated\"\n\n         */\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n                *int_mask |= 0x01;\n\n        }\n\n        return TD_RESULT_NEXT_QH;\n\n    }\n\n\n\n    async = uhci_async_find_td(s, td_addr, td);\n\n    if (async) {\n\n        /* Already submitted */\n\n        async->queue->valid = 32;\n\n\n\n        if (!async->done)\n\n            return TD_RESULT_ASYNC_CONT;\n\n        if (queuing) {\n\n            /* we are busy filling the queue, we are not prepared\n\n               to consume completed packages then, just leave them\n\n               in async state */\n\n            return TD_RESULT_ASYNC_CONT;\n\n        }\n\n\n\n        uhci_async_unlink(async);\n\n        goto done;\n\n    }\n\n\n\n    /* Allocate new packet */\n\n    if (q == NULL) {\n\n        USBDevice *dev = uhci_find_device(s, (td->token >> 8) & 0x7f);\n\n        USBEndpoint *ep = usb_ep_get(dev, pid, (td->token >> 15) & 0xf);\n\n        q = uhci_queue_get(s, td, ep);\n\n    }\n\n    async = uhci_async_alloc(q, td_addr);\n\n\n\n    /* valid needs to be large enough to handle 10 frame delay\n\n     * for initial isochronous requests\n\n     */\n\n    async->queue->valid = 32;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    spd = (pid == USB_TOKEN_IN && (td->ctrl & TD_CTRL_SPD) != 0);\n\n    usb_packet_setup(&async->packet, pid, q->ep, td_addr, spd,\n\n                     (td->ctrl & TD_CTRL_IOC) != 0);\n\n    qemu_sglist_add(&async->sgl, td->buffer, max_len);\n\n    usb_packet_map(&async->packet, &async->sgl);\n\n\n\n    switch(pid) {\n\n    case USB_TOKEN_OUT:\n\n    case USB_TOKEN_SETUP:\n\n        len = usb_handle_packet(q->ep->dev, &async->packet);\n\n        if (len >= 0)\n\n            len = max_len;\n\n        break;\n\n\n\n    case USB_TOKEN_IN:\n\n        len = usb_handle_packet(q->ep->dev, &async->packet);\n\n        break;\n\n\n\n    default:\n\n        /* invalid pid : frame interrupted */\n\n        usb_packet_unmap(&async->packet, &async->sgl);\n\n        uhci_async_free(async);\n\n        s->status |= UHCI_STS_HCPERR;\n\n        uhci_update_irq(s);\n\n        return TD_RESULT_STOP_FRAME;\n\n    }\n\n \n\n    if (len == USB_RET_ASYNC) {\n\n        uhci_async_link(async);\n\n        if (!queuing) {\n\n            uhci_queue_fill(q, td);\n\n        }\n\n        return TD_RESULT_ASYNC_START;\n\n    }\n\n\n\n    async->packet.result = len;\n\n\n\ndone:\n\n    len = uhci_complete_td(s, td, async, int_mask);\n\n    usb_packet_unmap(&async->packet, &async->sgl);\n\n    uhci_async_free(async);\n\n    return len;\n\n}\n", "idx": 11883}
{"project": "qemu", "commit_id": "6c3bc244d3cbdc5545504fda4fae0238ec36a3c0", "target": 1, "func": "static int vty_getchars(VIOsPAPRDevice *sdev, uint8_t *buf, int max)\n{\n    VIOsPAPRVTYDevice *dev = VIO_SPAPR_VTY_DEVICE(sdev);\n    int n = 0;\n    while ((n < max) && (dev->out != dev->in)) {\n        buf[n++] = dev->buf[dev->out++ % VTERM_BUFSIZE];\n    qemu_chr_fe_accept_input(&dev->chardev);\n    return n;", "idx": 4695}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv load_cpu_offset(int offset)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_ld_i32(tmp, cpu_env, offset);\n\n    return tmp;\n\n}\n", "idx": 3097}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_buffer(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_get_buffer(f, v, size);\n\n    return 0;\n\n}\n", "idx": 8401}
{"project": "qemu", "commit_id": "b2caa3b82edca29ccb5e7d6311ffcf841b9b7786", "target": 1, "func": "_eth_get_rss_ex_dst_addr(const struct iovec *pkt, int pkt_frags,\n\n                        size_t rthdr_offset,\n\n                        struct ip6_ext_hdr *ext_hdr,\n\n                        struct in6_address *dst_addr)\n\n{\n\n    struct ip6_ext_hdr_routing *rthdr = (struct ip6_ext_hdr_routing *) ext_hdr;\n\n\n\n    if ((rthdr->rtype == 2) &&\n\n        (rthdr->len == sizeof(struct in6_address) / 8) &&\n\n        (rthdr->segleft == 1)) {\n\n\n\n        size_t input_size = iov_size(pkt, pkt_frags);\n\n        size_t bytes_read;\n\n\n\n        if (input_size < rthdr_offset + sizeof(*ext_hdr)) {\n\n            return false;\n\n        }\n\n\n\n        bytes_read = iov_to_buf(pkt, pkt_frags,\n\n                                rthdr_offset + sizeof(*ext_hdr),\n\n                                dst_addr, sizeof(*dst_addr));\n\n\n\n        return bytes_read == sizeof(dst_addr);\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 8058}
{"project": "qemu", "commit_id": "56c119e52ca229869912b22a5bec283487b0cf9b", "target": 1, "func": "void xen_map_cache_init(void)\n\n{\n\n    unsigned long size;\n\n    struct rlimit rlimit_as;\n\n\n\n    mapcache = g_malloc0(sizeof (MapCache));\n\n\n\n    QTAILQ_INIT(&mapcache->locked_entries);\n\n    mapcache->last_address_index = -1;\n\n\n\n    getrlimit(RLIMIT_AS, &rlimit_as);\n\n    if (rlimit_as.rlim_max < MCACHE_MAX_SIZE) {\n\n        rlimit_as.rlim_cur = rlimit_as.rlim_max;\n\n    } else {\n\n        rlimit_as.rlim_cur = MCACHE_MAX_SIZE;\n\n    }\n\n\n\n    setrlimit(RLIMIT_AS, &rlimit_as);\n\n    mapcache->max_mcache_size = rlimit_as.rlim_cur;\n\n\n\n    mapcache->nr_buckets =\n\n        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +\n\n          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>\n\n         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));\n\n\n\n    size = mapcache->nr_buckets * sizeof (MapCacheEntry);\n\n    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);\n\n    DPRINTF(\"%s, nr_buckets = %lx size %lu\\n\", __func__,\n\n            mapcache->nr_buckets, size);\n\n    mapcache->entry = g_malloc0(size);\n\n}\n", "idx": 11165}
{"project": "qemu", "commit_id": "3178e2755ec5a7fb1afe583fb6ac2622c2c42184", "target": 1, "func": "static int sd_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid = 0;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    char vdi[SD_MAX_VDI_LEN], tag[SD_MAX_VDI_TAG_LEN];\n\n    uint32_t snapid;\n\n    char *buf = NULL;\n\n\n\n    strstart(filename, \"sheepdog:\", (const char **)&filename);\n\n\n\n    QLIST_INIT(&s->inflight_aio_head);\n\n    QLIST_INIT(&s->pending_aio_head);\n\n    s->fd = -1;\n\n\n\n    memset(vdi, 0, sizeof(vdi));\n\n    memset(tag, 0, sizeof(tag));\n\n    if (parse_vdiname(s, filename, vdi, &snapid, tag) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    s->fd = get_sheep_fd(s);\n\n    if (s->fd < 0) {\n\n        ret = s->fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = find_vdi_name(s, vdi, snapid, tag, &vid, 0);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    s->cache_enabled = 1;\n\n    s->flush_fd = connect_to_sdog(s->addr, s->port);\n\n    if (s->flush_fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = s->flush_fd;\n\n        goto out;\n\n    }\n\n\n\n    if (snapid || tag[0] != '\\0') {\n\n        dprintf(\"%\" PRIx32 \" snapshot inode was open.\\n\", vid);\n\n        s->is_snapshot = 1;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), 0, SD_INODE_SIZE, 0,\n\n                      s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n    s->min_dirty_data_idx = UINT32_MAX;\n\n    s->max_dirty_data_idx = 0;\n\n\n\n    bs->total_sectors = s->inode.vdi_size / SECTOR_SIZE;\n\n    strncpy(s->name, vdi, sizeof(s->name));\n\n    qemu_co_mutex_init(&s->lock);\n\n    g_free(buf);\n\n    return 0;\n\nout:\n\n    qemu_aio_set_fd_handler(s->fd, NULL, NULL, NULL, NULL);\n\n    if (s->fd >= 0) {\n\n        closesocket(s->fd);\n\n    }\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "idx": 6418}
{"project": "qemu", "commit_id": "3453f9a0dfa58578e6dadf0905ff4528b428ec73", "target": 1, "func": "static void usb_uas_command(UASDevice *uas, uas_ui *ui)\n{\n    UASRequest *req;\n    uint32_t len;\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n    if (uas_using_streams(uas) && tag > UAS_MAX_STREAMS) {\n        goto invalid_tag;\n    }\n    req = usb_uas_find_request(uas, tag);\n    if (req) {\n        goto overlapped_tag;\n    }\n    req = usb_uas_alloc_request(uas, ui);\n    if (req->dev == NULL) {\n        goto bad_target;\n    }\n    trace_usb_uas_command(uas->dev.addr, req->tag,\n                          usb_uas_get_lun(req->lun),\n                          req->lun >> 32, req->lun & 0xffffffff);\n    QTAILQ_INSERT_TAIL(&uas->requests, req, next);\n    if (uas_using_streams(uas) && uas->data3[req->tag] != NULL) {\n        req->data = uas->data3[req->tag];\n        req->data_async = true;\n        uas->data3[req->tag] = NULL;\n    }\n    req->req = scsi_req_new(req->dev, req->tag,\n                            usb_uas_get_lun(req->lun),\n                            ui->command.cdb, req);\n    if (uas->requestlog) {\n        scsi_req_print(req->req);\n    }\n    len = scsi_req_enqueue(req->req);\n    if (len) {\n        req->data_size = len;\n        scsi_req_continue(req->req);\n    }\noverlapped_tag:\n    usb_uas_queue_fake_sense(uas, tag, sense_code_OVERLAPPED_COMMANDS);\nbad_target:\n    usb_uas_queue_fake_sense(uas, tag, sense_code_LUN_NOT_SUPPORTED);\n    g_free(req);\n}", "idx": 598}
{"project": "qemu", "commit_id": "afcddefdbe75d0c20bf6e11b5512ba768ce0700c", "target": 1, "func": "static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque)\n\n{\n\n    RDMAControlHeader reg_resp = { .len = sizeof(RDMARegisterResult),\n\n                               .type = RDMA_CONTROL_REGISTER_RESULT,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader unreg_resp = { .len = 0,\n\n                               .type = RDMA_CONTROL_UNREGISTER_FINISHED,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader blocks = { .type = RDMA_CONTROL_RAM_BLOCKS_RESULT,\n\n                                 .repeat = 1 };\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMAControlHeader head;\n\n    RDMARegister *reg, *registers;\n\n    RDMACompress *comp;\n\n    RDMARegisterResult *reg_result;\n\n    static RDMARegisterResult results[RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE];\n\n    RDMALocalBlock *block;\n\n    void *host_addr;\n\n    int ret = 0;\n\n    int idx = 0;\n\n    int count = 0;\n\n    int i = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    do {\n\n        trace_qemu_rdma_registration_handle_wait();\n\n\n\n        ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);\n\n\n\n        if (ret < 0) {\n\n\n\n\n\n        if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {\n\n            error_report(\"rdma: Too many requests in this message (%d).\"\n\n                            \"Bailing.\", head.repeat);\n\n            ret = -EIO;\n\n\n\n\n\n        switch (head.type) {\n\n        case RDMA_CONTROL_COMPRESS:\n\n            comp = (RDMACompress *) rdma->wr_data[idx].control_curr;\n\n            network_to_compress(comp);\n\n\n\n            trace_qemu_rdma_registration_handle_compress(comp->length,\n\n                                                         comp->block_idx,\n\n                                                         comp->offset);\n\n            if (comp->block_idx >= rdma->local_ram_blocks.nb_blocks) {\n\n                error_report(\"rdma: 'compress' bad block index %u (vs %d)\",\n\n                             (unsigned int)comp->block_idx,\n\n                             rdma->local_ram_blocks.nb_blocks);\n\n                ret = -EIO;\n\n\n\n            block = &(rdma->local_ram_blocks.block[comp->block_idx]);\n\n\n\n            host_addr = block->local_host_addr +\n\n                            (comp->offset - block->offset);\n\n\n\n            ram_handle_compressed(host_addr, comp->value, comp->length);\n\n\n\n\n        case RDMA_CONTROL_REGISTER_FINISHED:\n\n            trace_qemu_rdma_registration_handle_finished();\n\n            goto out;\n\n\n\n        case RDMA_CONTROL_RAM_BLOCKS_REQUEST:\n\n            trace_qemu_rdma_registration_handle_ram_blocks();\n\n\n\n            /* Sort our local RAM Block list so it's the same as the source,\n\n             * we can do this since we've filled in a src_index in the list\n\n             * as we received the RAMBlock list earlier.\n\n             */\n\n            qsort(rdma->local_ram_blocks.block,\n\n                  rdma->local_ram_blocks.nb_blocks,\n\n                  sizeof(RDMALocalBlock), dest_ram_sort_func);\n\n            if (rdma->pin_all) {\n\n                ret = qemu_rdma_reg_whole_ram_blocks(rdma);\n\n                if (ret) {\n\n                    error_report(\"rdma migration: error dest \"\n\n                                    \"registering ram blocks\");\n\n                    goto out;\n\n\n\n\n\n            /*\n\n             * Dest uses this to prepare to transmit the RAMBlock descriptions\n\n             * to the source VM after connection setup.\n\n             * Both sides use the \"remote\" structure to communicate and update\n\n             * their \"local\" descriptions with what was sent.\n\n             */\n\n            for (i = 0; i < local->nb_blocks; i++) {\n\n                rdma->dest_blocks[i].remote_host_addr =\n\n                    (uintptr_t)(local->block[i].local_host_addr);\n\n\n\n                if (rdma->pin_all) {\n\n                    rdma->dest_blocks[i].remote_rkey = local->block[i].mr->rkey;\n\n\n\n\n                rdma->dest_blocks[i].offset = local->block[i].offset;\n\n                rdma->dest_blocks[i].length = local->block[i].length;\n\n\n\n                dest_block_to_network(&rdma->dest_blocks[i]);\n\n                trace_qemu_rdma_registration_handle_ram_blocks_loop(\n\n                    local->block[i].block_name,\n\n                    local->block[i].offset,\n\n                    local->block[i].length,\n\n                    local->block[i].local_host_addr,\n\n                    local->block[i].src_index);\n\n\n\n\n            blocks.len = rdma->local_ram_blocks.nb_blocks\n\n                                                * sizeof(RDMADestBlock);\n\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                                        (uint8_t *) rdma->dest_blocks, &blocks);\n\n\n\n            if (ret < 0) {\n\n                error_report(\"rdma migration: error sending remote info\");\n\n                goto out;\n\n\n\n\n\n        case RDMA_CONTROL_REGISTER_REQUEST:\n\n            trace_qemu_rdma_registration_handle_register(head.repeat);\n\n\n\n            reg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                uint64_t chunk;\n\n                uint8_t *chunk_start, *chunk_end;\n\n\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                reg_result = &results[count];\n\n\n\n                trace_qemu_rdma_registration_handle_register_loop(count,\n\n                         reg->current_index, reg->key.current_addr, reg->chunks);\n\n\n\n                if (reg->current_index >= rdma->local_ram_blocks.nb_blocks) {\n\n                    error_report(\"rdma: 'register' bad block index %u (vs %d)\",\n\n                                 (unsigned int)reg->current_index,\n\n                                 rdma->local_ram_blocks.nb_blocks);\n\n                    ret = -ENOENT;\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n                if (block->is_ram_block) {\n\n                    if (block->offset > reg->key.current_addr) {\n\n                        error_report(\"rdma: bad register address for block %s\"\n\n                            \" offset: %\" PRIx64 \" current_addr: %\" PRIx64,\n\n                            block->block_name, block->offset,\n\n                            reg->key.current_addr);\n\n\n\n\n                    host_addr = (block->local_host_addr +\n\n                                (reg->key.current_addr - block->offset));\n\n                    chunk = ram_chunk_index(block->local_host_addr,\n\n                                            (uint8_t *) host_addr);\n\n                } else {\n\n                    chunk = reg->key.chunk;\n\n                    host_addr = block->local_host_addr +\n\n                        (reg->key.chunk * (1UL << RDMA_REG_CHUNK_SHIFT));\n\n\n\n\n\n\n\n\n\n\n                chunk_start = ram_chunk_start(block, chunk);\n\n                chunk_end = ram_chunk_end(block, chunk + reg->chunks);\n\n                if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                            (uintptr_t)host_addr, NULL, &reg_result->rkey,\n\n                            chunk, chunk_start, chunk_end)) {\n\n                    error_report(\"cannot get rkey\");\n\n                    ret = -EINVAL;\n\n                    goto out;\n\n\n\n\n                reg_result->host_addr = (uintptr_t)block->local_host_addr;\n\n\n\n                trace_qemu_rdma_registration_handle_register_rkey(\n\n                                                           reg_result->rkey);\n\n\n\n                result_to_network(reg_result);\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                            (uint8_t *) results, &reg_resp);\n\n\n\n            if (ret < 0) {\n\n                error_report(\"Failed to send control buffer\");\n\n                goto out;\n\n\n\n        case RDMA_CONTROL_UNREGISTER_REQUEST:\n\n            trace_qemu_rdma_registration_handle_unregister(head.repeat);\n\n            unreg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                trace_qemu_rdma_registration_handle_unregister_loop(count,\n\n                           reg->current_index, reg->key.chunk);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n\n\n                ret = ibv_dereg_mr(block->pmr[reg->key.chunk]);\n\n                block->pmr[reg->key.chunk] = NULL;\n\n\n\n                if (ret != 0) {\n\n                    perror(\"rdma unregistration chunk failed\");\n\n                    ret = -ret;\n\n                    goto out;\n\n\n\n\n                rdma->total_registrations--;\n\n\n\n                trace_qemu_rdma_registration_handle_unregister_success(\n\n                                                       reg->key.chunk);\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma, NULL, &unreg_resp);\n\n\n\n            if (ret < 0) {\n\n                error_report(\"Failed to send control buffer\");\n\n                goto out;\n\n\n\n        case RDMA_CONTROL_REGISTER_RESULT:\n\n            error_report(\"Invalid RESULT message at dest.\");\n\n            ret = -EIO;\n\n            goto out;\n\n        default:\n\n            error_report(\"Unknown control message %s\", control_desc[head.type]);\n\n            ret = -EIO;\n\n            goto out;\n\n\n    } while (1);\n\nout:\n\n    if (ret < 0) {\n\n        rdma->error_state = ret;\n\n\n    return ret;\n", "idx": 1016}
{"project": "qemu", "commit_id": "16f4e8fa737b58b7b0461b33581e43ac06991110", "target": 1, "func": "static DWORD WINAPI do_suspend(LPVOID opaque)\n\n{\n\n    GuestSuspendMode *mode = opaque;\n\n    DWORD ret = 0;\n\n\n\n    if (!SetSuspendState(*mode == GUEST_SUSPEND_MODE_DISK, TRUE, TRUE)) {\n\n        slog(\"failed to suspend guest, %s\", GetLastError());\n\n        ret = -1;\n\n    }\n\n    g_free(mode);\n\n    return ret;\n\n}\n", "idx": 1288}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "qemu_irq qemu_irq_split(qemu_irq irq1, qemu_irq irq2)\n\n{\n\n    qemu_irq *s = g_malloc0(2 * sizeof(qemu_irq));\n\n    s[0] = irq1;\n\n    s[1] = irq2;\n\n    return qemu_allocate_irqs(qemu_splitirq, s, 1)[0];\n\n}\n", "idx": 4421}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n", "idx": 6849}
{"project": "qemu", "commit_id": "9814fed0afa73f5c37f04e02ec17c915a5d59303", "target": 1, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags, bool exc)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n        PTE_DPRINTF(\"%s: asc=primary\\n\", __func__);\n\n        r = mmu_translate_asce(env, vaddr, asc, env->cregs[1], raddr, flags,\n\n                               rw, exc);\n\n        break;\n\n    case PSW_ASC_HOME:\n\n        PTE_DPRINTF(\"%s: asc=home\\n\", __func__);\n\n        r = mmu_translate_asce(env, vaddr, asc, env->cregs[13], raddr, flags,\n\n                               rw, exc);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        PTE_DPRINTF(\"%s: asc=secondary\\n\", __func__);\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == MMU_INST_FETCH) {\n\n            r = mmu_translate_asce(env, vaddr, PSW_ASC_PRIMARY, env->cregs[1],\n\n                                   raddr, flags, rw, exc);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asce(env, vaddr, PSW_ASC_SECONDARY, env->cregs[7],\n\n                                   raddr, flags, rw, exc);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 1089}
{"project": "qemu", "commit_id": "4a1cba3802554a3b077d436002519ff1fb0c18bf", "target": 1, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i, ret;\n\n    bool progress;\n\n    int64_t timeout;\n\n\n\n    aio_context_acquire(ctx);\n\n    progress = false;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n", "idx": 8256}
{"project": "qemu", "commit_id": "3d3efba020da1de57a715e2087cf761ed0ad0904", "target": 1, "func": "void process_pending_signals(CPUArchState *cpu_env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    int sig;\n\n    TaskState *ts = cpu->opaque;\n\n\n\n    if (!ts->signal_pending)\n\n        return;\n\n\n\n    /* FIXME: This is not threadsafe.  */\n\n    for(sig = 1; sig <= TARGET_NSIG; sig++) {\n\n        if (ts->sigtab[sig - 1].pending) {\n\n            handle_pending_signal(cpu_env, sig);\n\n            return;\n\n        }\n\n    }\n\n    /* if no signal is pending, just return */\n\n    ts->signal_pending = 0;\n\n    return;\n\n}\n", "idx": 8472}
{"project": "qemu", "commit_id": "c13959c745a7e4965c94d19e3153d2c44459906d", "target": 1, "func": "static int vmdk_create(const char *filename, QEMUOptionParameter *options,\n\n                       Error **errp)\n\n{\n\n    int idx = 0;\n\n    BlockDriverState *new_bs = NULL;\n\n    Error *local_err;\n\n    char *desc = NULL;\n\n    int64_t total_size = 0, filesize;\n\n    const char *adapter_type = NULL;\n\n    const char *backing_file = NULL;\n\n    const char *fmt = NULL;\n\n    int flags = 0;\n\n    int ret = 0;\n\n    bool flat, split, compress;\n\n    GString *ext_desc_lines;\n\n    char path[PATH_MAX], prefix[PATH_MAX], postfix[PATH_MAX];\n\n    const int64_t split_size = 0x80000000;  /* VMDK has constant split size */\n\n    const char *desc_extent_line;\n\n    char parent_desc_line[BUF_SIZE] = \"\";\n\n    uint32_t parent_cid = 0xffffffff;\n\n    uint32_t number_heads = 16;\n\n    bool zeroed_grain = false;\n\n    uint32_t desc_offset = 0, desc_len;\n\n    const char desc_template[] =\n\n        \"# Disk DescriptorFile\\n\"\n\n        \"version=1\\n\"\n\n        \"CID=%\" PRIx32 \"\\n\"\n\n        \"parentCID=%\" PRIx32 \"\\n\"\n\n        \"createType=\\\"%s\\\"\\n\"\n\n        \"%s\"\n\n        \"\\n\"\n\n        \"# Extent description\\n\"\n\n        \"%s\"\n\n        \"\\n\"\n\n        \"# The Disk Data Base\\n\"\n\n        \"#DDB\\n\"\n\n        \"\\n\"\n\n        \"ddb.virtualHWVersion = \\\"%d\\\"\\n\"\n\n        \"ddb.geometry.cylinders = \\\"%\" PRId64 \"\\\"\\n\"\n\n        \"ddb.geometry.heads = \\\"%\" PRIu32 \"\\\"\\n\"\n\n        \"ddb.geometry.sectors = \\\"63\\\"\\n\"\n\n        \"ddb.adapterType = \\\"%s\\\"\\n\";\n\n\n\n    ext_desc_lines = g_string_new(NULL);\n\n\n\n    if (filename_decompose(filename, path, prefix, postfix, PATH_MAX, errp)) {\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            total_size = options->value.n;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_ADAPTER_TYPE)) {\n\n            adapter_type = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {\n\n            backing_file = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_COMPAT6)) {\n\n            flags |= options->value.n ? BLOCK_FLAG_COMPAT6 : 0;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_SUBFMT)) {\n\n            fmt = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_ZEROED_GRAIN)) {\n\n            zeroed_grain |= options->value.n;\n\n        }\n\n        options++;\n\n    }\n\n    if (!adapter_type) {\n\n        adapter_type = \"ide\";\n\n    } else if (strcmp(adapter_type, \"ide\") &&\n\n               strcmp(adapter_type, \"buslogic\") &&\n\n               strcmp(adapter_type, \"lsilogic\") &&\n\n               strcmp(adapter_type, \"legacyESX\")) {\n\n        error_setg(errp, \"Unknown adapter type: '%s'\", adapter_type);\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n    if (strcmp(adapter_type, \"ide\") != 0) {\n\n        /* that's the number of heads with which vmware operates when\n\n           creating, exporting, etc. vmdk files with a non-ide adapter type */\n\n        number_heads = 255;\n\n    }\n\n    if (!fmt) {\n\n        /* Default format to monolithicSparse */\n\n        fmt = \"monolithicSparse\";\n\n    } else if (strcmp(fmt, \"monolithicFlat\") &&\n\n               strcmp(fmt, \"monolithicSparse\") &&\n\n               strcmp(fmt, \"twoGbMaxExtentSparse\") &&\n\n               strcmp(fmt, \"twoGbMaxExtentFlat\") &&\n\n               strcmp(fmt, \"streamOptimized\")) {\n\n        error_setg(errp, \"Unknown subformat: '%s'\", fmt);\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n    split = !(strcmp(fmt, \"twoGbMaxExtentFlat\") &&\n\n              strcmp(fmt, \"twoGbMaxExtentSparse\"));\n\n    flat = !(strcmp(fmt, \"monolithicFlat\") &&\n\n             strcmp(fmt, \"twoGbMaxExtentFlat\"));\n\n    compress = !strcmp(fmt, \"streamOptimized\");\n\n    if (flat) {\n\n        desc_extent_line = \"RW %\" PRId64 \" FLAT \\\"%s\\\" 0\\n\";\n\n    } else {\n\n        desc_extent_line = \"RW %\" PRId64 \" SPARSE \\\"%s\\\"\\n\";\n\n    }\n\n    if (flat && backing_file) {\n\n        error_setg(errp, \"Flat image can't have backing file\");\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n    if (flat && zeroed_grain) {\n\n        error_setg(errp, \"Flat image can't enable zeroed grain\");\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n    if (backing_file) {\n\n        BlockDriverState *bs = NULL;\n\n        ret = bdrv_open(&bs, backing_file, NULL, NULL, BDRV_O_NO_BACKING, NULL,\n\n                        errp);\n\n        if (ret != 0) {\n\n            goto exit;\n\n        }\n\n        if (strcmp(bs->drv->format_name, \"vmdk\")) {\n\n            bdrv_unref(bs);\n\n            ret = -EINVAL;\n\n            goto exit;\n\n        }\n\n        parent_cid = vmdk_read_cid(bs, 0);\n\n        bdrv_unref(bs);\n\n        snprintf(parent_desc_line, sizeof(parent_desc_line),\n\n                \"parentFileNameHint=\\\"%s\\\"\", backing_file);\n\n    }\n\n\n\n    /* Create extents */\n\n    filesize = total_size;\n\n    while (filesize > 0) {\n\n        char desc_line[BUF_SIZE];\n\n        char ext_filename[PATH_MAX];\n\n        char desc_filename[PATH_MAX];\n\n        int64_t size = filesize;\n\n\n\n        if (split && size > split_size) {\n\n            size = split_size;\n\n        }\n\n        if (split) {\n\n            snprintf(desc_filename, sizeof(desc_filename), \"%s-%c%03d%s\",\n\n                    prefix, flat ? 'f' : 's', ++idx, postfix);\n\n        } else if (flat) {\n\n            snprintf(desc_filename, sizeof(desc_filename), \"%s-flat%s\",\n\n                    prefix, postfix);\n\n        } else {\n\n            snprintf(desc_filename, sizeof(desc_filename), \"%s%s\",\n\n                    prefix, postfix);\n\n        }\n\n        snprintf(ext_filename, sizeof(ext_filename), \"%s%s\",\n\n                path, desc_filename);\n\n\n\n        if (vmdk_create_extent(ext_filename, size,\n\n                               flat, compress, zeroed_grain, errp)) {\n\n            ret = -EINVAL;\n\n            goto exit;\n\n        }\n\n        filesize -= size;\n\n\n\n        /* Format description line */\n\n        snprintf(desc_line, sizeof(desc_line),\n\n                    desc_extent_line, size / BDRV_SECTOR_SIZE, desc_filename);\n\n        g_string_append(ext_desc_lines, desc_line);\n\n    }\n\n    /* generate descriptor file */\n\n    desc = g_strdup_printf(desc_template,\n\n                           (uint32_t)time(NULL),\n\n                           parent_cid,\n\n                           fmt,\n\n                           parent_desc_line,\n\n                           ext_desc_lines->str,\n\n                           (flags & BLOCK_FLAG_COMPAT6 ? 6 : 4),\n\n                           total_size /\n\n                               (int64_t)(63 * number_heads * BDRV_SECTOR_SIZE),\n\n                           number_heads,\n\n                           adapter_type);\n\n    desc_len = strlen(desc);\n\n    /* the descriptor offset = 0x200 */\n\n    if (!split && !flat) {\n\n        desc_offset = 0x200;\n\n    } else {\n\n        ret = bdrv_create_file(filename, options, &local_err);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not create image file\");\n\n            goto exit;\n\n        }\n\n    }\n\n    assert(new_bs == NULL);\n\n    ret = bdrv_open(&new_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not write description\");\n\n        goto exit;\n\n    }\n\n    ret = bdrv_pwrite(new_bs, desc_offset, desc, desc_len);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not write description\");\n\n        goto exit;\n\n    }\n\n    /* bdrv_pwrite write padding zeros to align to sector, we don't need that\n\n     * for description file */\n\n    if (desc_offset == 0) {\n\n        ret = bdrv_truncate(new_bs, desc_len);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not truncate file\");\n\n        }\n\n    }\n\nexit:\n\n    if (new_bs) {\n\n        bdrv_unref(new_bs);\n\n    }\n\n    g_free(desc);\n\n    g_string_free(ext_desc_lines, true);\n\n    return ret;\n\n}\n", "idx": 3868}
{"project": "qemu", "commit_id": "69c8944f17cb6c084567a16c080cfa7bc780e668", "target": 1, "func": "static int pci_ich9_ahci_init(PCIDevice *dev)\n\n{\n\n    struct AHCIPCIState *d;\n\n    d = DO_UPCAST(struct AHCIPCIState, card, dev);\n\n\n\n    pci_config_set_vendor_id(d->card.config, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(d->card.config, PCI_DEVICE_ID_INTEL_82801IR);\n\n\n\n    pci_config_set_class(d->card.config, PCI_CLASS_STORAGE_SATA);\n\n    pci_config_set_revision(d->card.config, 0x02);\n\n    pci_config_set_prog_interface(d->card.config, AHCI_PROGMODE_MAJOR_REV_1);\n\n\n\n    d->card.config[PCI_CACHE_LINE_SIZE] = 0x08;  /* Cache line size */\n\n    d->card.config[PCI_LATENCY_TIMER]   = 0x00;  /* Latency timer */\n\n    pci_config_set_interrupt_pin(d->card.config, 1);\n\n\n\n    /* XXX Software should program this register */\n\n    d->card.config[0x90]   = 1 << 6; /* Address Map Register - AHCI mode */\n\n\n\n    qemu_register_reset(ahci_reset, d);\n\n\n\n    /* XXX BAR size should be 1k, but that breaks, so bump it to 4k for now */\n\n    pci_register_bar_simple(&d->card, 5, 0x1000, 0, d->ahci.mem);\n\n\n\n    msi_init(dev, 0x50, 1, true, false);\n\n\n\n    ahci_init(&d->ahci, &dev->qdev, 6);\n\n    d->ahci.irq = d->card.irq[0];\n\n\n\n    return 0;\n\n}\n", "idx": 5253}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void vpb_sic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = vpb_sic_init;\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_vpb_sic;\n\n}\n", "idx": 5643}
{"project": "qemu", "commit_id": "3268a845f41253fb55852a8429c32b50f36f349a", "target": 1, "func": "void AUD_del_capture (CaptureVoiceOut *cap, void *cb_opaque)\n\n{\n\n    struct capture_callback *cb;\n\n\n\n    for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n        if (cb->opaque == cb_opaque) {\n\n            cb->ops.destroy (cb_opaque);\n\n            QLIST_REMOVE (cb, entries);\n\n            g_free (cb);\n\n\n\n            if (!cap->cb_head.lh_first) {\n\n                SWVoiceOut *sw = cap->hw.sw_head.lh_first, *sw1;\n\n\n\n                while (sw) {\n\n                    SWVoiceCap *sc = (SWVoiceCap *) sw;\n\n#ifdef DEBUG_CAPTURE\n\n                    dolog (\"freeing %s\\n\", sw->name);\n\n#endif\n\n\n\n                    sw1 = sw->entries.le_next;\n\n                    if (sw->rate) {\n\n                        st_rate_stop (sw->rate);\n\n                        sw->rate = NULL;\n\n                    }\n\n                    QLIST_REMOVE (sw, entries);\n\n                    QLIST_REMOVE (sc, entries);\n\n                    g_free (sc);\n\n                    sw = sw1;\n\n                }\n\n                QLIST_REMOVE (cap, entries);\n\n\n\n                g_free (cap);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}", "idx": 10750}
{"project": "qemu", "commit_id": "e49ab19fcaa617ad6cdfe1ac401327326b6a2552", "target": 1, "func": "static void iscsi_attach_aio_context(BlockDriverState *bs,\n\n                                     AioContext *new_context)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n\n\n    iscsilun->aio_context = new_context;\n\n    iscsi_set_events(iscsilun);\n\n\n\n#if defined(LIBISCSI_FEATURE_NOP_COUNTER)\n\n    /* Set up a timer for sending out iSCSI NOPs */\n\n    iscsilun->nop_timer = aio_timer_new(iscsilun->aio_context,\n\n                                        QEMU_CLOCK_REALTIME, SCALE_MS,\n\n                                        iscsi_nop_timed_event, iscsilun);\n\n    timer_mod(iscsilun->nop_timer,\n\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n#endif\n\n}\n", "idx": 10583}
{"project": "qemu", "commit_id": "5e39d89d20b17cf6fb7f09d181d34f17b2ae2160", "target": 1, "func": "static QList *get_cpus(QDict **resp)\n\n{\n\n    *resp = qmp(\"{ 'execute': 'query-cpus' }\");\n\n    g_assert(*resp);\n\n    g_assert(qdict_haskey(*resp, \"return\"));\n\n    return  qdict_get_qlist(*resp, \"return\");\n\n}\n", "idx": 10331}
{"project": "qemu", "commit_id": "13c91cb7e28b47f5c4227f7e88a1378570117704", "target": 1, "func": "static int iscsi_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int ret = 0;\n\n    int64_t total_size = 0;\n\n    BlockDriverState bs;\n\n    IscsiLun *iscsilun = NULL;\n\n    QDict *bs_options;\n\n\n\n    memset(&bs, 0, sizeof(BlockDriverState));\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, \"size\")) {\n\n            total_size = options->value.n / BDRV_SECTOR_SIZE;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    bs.opaque = g_malloc0(sizeof(struct IscsiLun));\n\n    iscsilun = bs.opaque;\n\n\n\n    bs_options = qdict_new();\n\n    qdict_put(bs_options, \"filename\", qstring_from_str(filename));\n\n    ret = iscsi_open(&bs, bs_options, 0);\n\n    QDECREF(bs_options);\n\n\n\n    if (ret != 0) {\n\n        goto out;\n\n    }\n\n    if (iscsilun->nop_timer) {\n\n        timer_del(iscsilun->nop_timer);\n\n        timer_free(iscsilun->nop_timer);\n\n    }\n\n    if (iscsilun->type != TYPE_DISK) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n    if (bs.total_sectors < total_size) {\n\n        ret = -ENOSPC;\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (iscsilun->iscsi != NULL) {\n\n        iscsi_destroy_context(iscsilun->iscsi);\n\n    }\n\n    g_free(bs.opaque);\n\n    return ret;\n\n}\n", "idx": 2174}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    ADBDeviceClass *adc = ADB_DEVICE_CLASS(oc);\n\n    ADBMouseClass *amc = ADB_MOUSE_CLASS(oc);\n\n\n\n    amc->parent_realize = dc->realize;\n\n    dc->realize = adb_mouse_realizefn;\n\n    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);\n\n\n\n    adc->devreq = adb_mouse_request;\n\n    dc->reset = adb_mouse_reset;\n\n    dc->vmsd = &vmstate_adb_mouse;\n\n}\n", "idx": 7621}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void mcf5208evb_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    M68kCPU *cpu;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    hwaddr entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"m5208\";\n\n    }\n\n    cpu = M68K_CPU(cpu_generic_init(TYPE_M68K_CPU, cpu_model));\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mcf5208.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, NULL, \"mcf5208.sram\", 16384, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, cpu);\n\n\n\n    mcf_uart_mm_init(0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used) {\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n    }\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        if (qtest_enabled()) {\n\n            return;\n\n        }\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, EM_68K, 0, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n\n                                  NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 11074}
{"project": "qemu", "commit_id": "b20909195745c34a819aed14ae996b60ab0f591f", "target": 1, "func": "iscsi_aio_read16_cb(struct iscsi_context *iscsi, int status,\n\n                    void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    trace_iscsi_aio_read16_cb(iscsi, status, acb, acb->canceled);\n\n\n\n    if (acb->canceled) {\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status != 0) {\n\n        error_report(\"Failed to read16 data from iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(iscsi_readv_writev_bh_cb, acb);\n\n}\n", "idx": 8620}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 10579}
{"project": "qemu", "commit_id": "5923f85fb82df7c8c60a89458a5ae856045e5ab1", "target": 1, "func": "static bool acpi_get_mcfg(AcpiMcfgInfo *mcfg)\n\n{\n\n    Object *pci_host;\n\n    QObject *o;\n\n\n\n    pci_host = acpi_get_i386_pci_host();\n\n    g_assert(pci_host);\n\n\n\n    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_BASE, NULL);\n\n    if (!o) {\n\n        return false;\n\n    }\n\n    mcfg->mcfg_base = qnum_get_int(qobject_to_qnum(o));\n\n    qobject_decref(o);\n\n\n\n    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_SIZE, NULL);\n\n    assert(o);\n\n    mcfg->mcfg_size = qnum_get_int(qobject_to_qnum(o));\n\n    qobject_decref(o);\n\n    return true;\n\n}\n", "idx": 1338}
{"project": "qemu", "commit_id": "f693fe6ef402bdcf89b3979bf004c4c5bf646724", "target": 1, "func": "GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)\n\n{\n\n    GuestMemoryBlockList *head, **link;\n\n    Error *local_err = NULL;\n\n    struct dirent *de;\n\n    DIR *dp;\n\n\n\n    head = NULL;\n\n    link = &head;\n\n\n\n    dp = opendir(\"/sys/devices/system/memory/\");\n\n    if (!dp) {\n\n        error_setg_errno(errp, errno, \"Can't open directory\"\n\n                         \"\\\"/sys/devices/system/memory/\\\"\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    /* Note: the phys_index of memory block may be discontinuous,\n\n     * this is because a memblk is the unit of the Sparse Memory design, which\n\n     * allows discontinuous memory ranges (ex. NUMA), so here we should\n\n     * traverse the memory block directory.\n\n     */\n\n    while ((de = readdir(dp)) != NULL) {\n\n        GuestMemoryBlock *mem_blk;\n\n        GuestMemoryBlockList *entry;\n\n\n\n        if ((strncmp(de->d_name, \"memory\", 6) != 0) ||\n\n            !(de->d_type & DT_DIR)) {\n\n            continue;\n\n        }\n\n\n\n        mem_blk = g_malloc0(sizeof *mem_blk);\n\n        /* The d_name is \"memoryXXX\",  phys_index is block id, same as XXX */\n\n        mem_blk->phys_index = strtoul(&de->d_name[6], NULL, 10);\n\n        mem_blk->has_can_offline = true; /* lolspeak ftw */\n\n        transfer_memory_block(mem_blk, true, NULL, &local_err);\n\n\n\n        entry = g_malloc0(sizeof *entry);\n\n        entry->value = mem_blk;\n\n\n\n        *link = entry;\n\n        link = &entry->next;\n\n    }\n\n\n\n    closedir(dp);\n\n    if (local_err == NULL) {\n\n        /* there's no guest with zero memory blocks */\n\n        if (head == NULL) {\n\n            error_setg(errp, \"guest reported zero memory blocks!\");\n\n        }\n\n        return head;\n\n    }\n\n\n\n    qapi_free_GuestMemoryBlockList(head);\n\n    error_propagate(errp, local_err);\n\n    return NULL;\n\n}\n", "idx": 8464}
{"project": "qemu", "commit_id": "c4237dfa635900e4d1cdc6038d5efe3507f45f0c", "target": 1, "func": "static int mig_save_device_dirty(QEMUFile *f, BlkMigDevState *bmds,\n\n                                 int is_async)\n\n{\n\n    BlkMigBlock *blk;\n\n    int64_t total_sectors = bmds->total_sectors;\n\n    int64_t sector;\n\n    int nr_sectors;\n\n    int ret = -EIO;\n\n\n\n    for (sector = bmds->cur_dirty; sector < bmds->total_sectors;) {\n\n        blk_mig_lock();\n\n        if (bmds_aio_inflight(bmds, sector)) {\n\n            blk_mig_unlock();\n\n            bdrv_drain_all();\n\n        } else {\n\n            blk_mig_unlock();\n\n        }\n\n        if (bdrv_get_dirty(bmds->bs, bmds->dirty_bitmap, sector)) {\n\n\n\n            if (total_sectors - sector < BDRV_SECTORS_PER_DIRTY_CHUNK) {\n\n                nr_sectors = total_sectors - sector;\n\n            } else {\n\n                nr_sectors = BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n            }\n\n            blk = g_new(BlkMigBlock, 1);\n\n            blk->buf = g_malloc(BLOCK_SIZE);\n\n            blk->bmds = bmds;\n\n            blk->sector = sector;\n\n            blk->nr_sectors = nr_sectors;\n\n\n\n            if (is_async) {\n\n                blk->iov.iov_base = blk->buf;\n\n                blk->iov.iov_len = nr_sectors * BDRV_SECTOR_SIZE;\n\n                qemu_iovec_init_external(&blk->qiov, &blk->iov, 1);\n\n\n\n                blk->aiocb = bdrv_aio_readv(bmds->bs, sector, &blk->qiov,\n\n                                            nr_sectors, blk_mig_read_cb, blk);\n\n\n\n                blk_mig_lock();\n\n                block_mig_state.submitted++;\n\n                bmds_set_aio_inflight(bmds, sector, nr_sectors, 1);\n\n                blk_mig_unlock();\n\n            } else {\n\n                ret = bdrv_read(bmds->bs, sector, blk->buf, nr_sectors);\n\n                if (ret < 0) {\n\n                    goto error;\n\n                }\n\n                blk_send(f, blk);\n\n\n\n                g_free(blk->buf);\n\n                g_free(blk);\n\n            }\n\n\n\n            bdrv_reset_dirty(bmds->bs, sector, nr_sectors);\n\n            break;\n\n        }\n\n        sector += BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n        bmds->cur_dirty = sector;\n\n    }\n\n\n\n    return (bmds->cur_dirty >= bmds->total_sectors);\n\n\n\nerror:\n\n    DPRINTF(\"Error reading sector %\" PRId64 \"\\n\", sector);\n\n    g_free(blk->buf);\n\n    g_free(blk);\n\n    return ret;\n\n}\n", "idx": 5170}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 1617}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 11549}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 4086}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void ich9_smb_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_ICH9_6;\n\n    k->revision = ICH9_A2_SMB_REVISION;\n\n    k->class_id = PCI_CLASS_SERIAL_SMBUS;\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_ich9_smbus;\n\n    dc->desc = \"ICH9 SMBUS Bridge\";\n\n    k->init = ich9_smbus_initfn;\n\n    k->config_write = ich9_smbus_write_config;\n\n}\n", "idx": 7483}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static void blkverify_verify_readv(BlkverifyAIOCB *acb)\n\n{\n\n    ssize_t offset = qemu_iovec_compare(acb->qiov, &acb->raw_qiov);\n\n    if (offset != -1) {\n\n        blkverify_err(acb, \"contents mismatch in sector %\" PRId64,\n\n                      acb->sector_num + (int64_t)(offset / BDRV_SECTOR_SIZE));\n\n    }\n\n}\n", "idx": 6318}
{"project": "qemu", "commit_id": "2ce68e4cf5be9b5176a3c3c372948d6340724d2d", "target": 1, "func": "static void vhost_set_memory(MemoryListener *listener,\n\n                             MemoryRegionSection *section,\n\n                             bool add)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         memory_listener);\n\n    hwaddr start_addr = section->offset_within_address_space;\n\n    ram_addr_t size = int128_get64(section->size);\n\n    bool log_dirty =\n\n        memory_region_get_dirty_log_mask(section->mr) & ~(1 << DIRTY_MEMORY_MIGRATION);\n\n    int s = offsetof(struct vhost_memory, regions) +\n\n        (dev->mem->nregions + 1) * sizeof dev->mem->regions[0];\n\n    void *ram;\n\n\n\n    dev->mem = g_realloc(dev->mem, s);\n\n\n\n    if (log_dirty) {\n\n        add = false;\n\n    }\n\n\n\n    assert(size);\n\n\n\n    /* Optimize no-change case. At least cirrus_vga does this a lot at this time. */\n\n    ram = memory_region_get_ram_ptr(section->mr) + section->offset_within_region;\n\n    if (add) {\n\n        if (!vhost_dev_cmp_memory(dev, start_addr, size, (uintptr_t)ram)) {\n\n            /* Region exists with same address. Nothing to do. */\n\n            return;\n\n        }\n\n    } else {\n\n        if (!vhost_dev_find_reg(dev, start_addr, size)) {\n\n            /* Removing region that we don't access. Nothing to do. */\n\n            return;\n\n        }\n\n    }\n\n\n\n    vhost_dev_unassign_memory(dev, start_addr, size);\n\n    if (add) {\n\n        /* Add given mapping, merging adjacent regions if any */\n\n        vhost_dev_assign_memory(dev, start_addr, size, (uintptr_t)ram);\n\n    } else {\n\n        /* Remove old mapping for this memory, if any. */\n\n        vhost_dev_unassign_memory(dev, start_addr, size);\n\n    }\n\n    dev->mem_changed_start_addr = MIN(dev->mem_changed_start_addr, start_addr);\n\n    dev->mem_changed_end_addr = MAX(dev->mem_changed_end_addr, start_addr + size - 1);\n\n    dev->memory_changed = true;\n\n\n}", "idx": 5631}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_exception(int excp)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_movi_i32(tmp, excp);\n\n    gen_helper_exception(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 6941}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static struct omap_eac_s *omap_eac_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, qemu_irq *drq, omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_eac_s *s = (struct omap_eac_s *)\n\n            g_malloc0(sizeof(struct omap_eac_s));\n\n\n\n    s->irq = irq;\n\n    s->codec.rxdrq = *drq ++;\n\n    s->codec.txdrq = *drq;\n\n    omap_eac_reset(s);\n\n\n\n    AUD_register_card(\"OMAP EAC\", &s->codec.card);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_eac_ops, s, \"omap.eac\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 12264}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 5431}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 939}
{"project": "qemu", "commit_id": "86d1bd70987cd11d85d01f52aa5824c63d910471", "target": 1, "func": "static int64_t allocate_clusters(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    uint32_t idx, to_allocate, i;\n\n    int64_t pos, space;\n\n\n\n    pos = block_status(s, sector_num, nb_sectors, pnum);\n\n    if (pos > 0) {\n\n        return pos;\n\n    }\n\n\n\n    idx = sector_num / s->tracks;\n\n    if (idx >= s->bat_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    to_allocate = DIV_ROUND_UP(sector_num + *pnum, s->tracks) - idx;\n\n    space = to_allocate * s->tracks;\n\n    if (s->data_end + space > bdrv_getlength(bs->file->bs) >> BDRV_SECTOR_BITS) {\n\n        int ret;\n\n        space += s->prealloc_size;\n\n        if (s->prealloc_mode == PRL_PREALLOC_MODE_FALLOCATE) {\n\n            ret = bdrv_pwrite_zeroes(bs->file,\n\n                                     s->data_end << BDRV_SECTOR_BITS,\n\n                                     space << BDRV_SECTOR_BITS, 0);\n\n        } else {\n\n            ret = bdrv_truncate(bs->file,\n\n                                (s->data_end + space) << BDRV_SECTOR_BITS);\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < to_allocate; i++) {\n\n        s->bat_bitmap[idx + i] = cpu_to_le32(s->data_end / s->off_multiplier);\n\n        s->data_end += s->tracks;\n\n        bitmap_set(s->bat_dirty_bmap,\n\n                   bat_entry_off(idx + i) / s->bat_dirty_block, 1);\n\n    }\n\n\n\n    return bat2sect(s, idx) + sector_num % s->tracks;\n\n}\n", "idx": 2445}
{"project": "qemu", "commit_id": "db431f6adc881a0758512cd765b3108209013512", "target": 1, "func": "int v9fs_co_st_gen(V9fsPDU *pdu, V9fsPath *path, mode_t st_mode,\n\n                   V9fsStatDotl *v9stat)\n\n{\n\n    int err = 0;\n\n    V9fsState *s = pdu->s;\n\n\n\n    if (v9fs_request_cancelled(pdu)) {\n\n        return -EINTR;\n\n\n    if (s->ctx.exops.get_st_gen) {\n\n        v9fs_path_read_lock(s);\n\n        v9fs_co_run_in_worker(\n\n            {\n\n                err = s->ctx.exops.get_st_gen(&s->ctx, path, st_mode,\n\n                                              &v9stat->st_gen);\n\n                if (err < 0) {\n\n                    err = -errno;\n\n\n            });\n\n        v9fs_path_unlock(s);\n\n\n\n\n\n\n    return err;\n", "idx": 9103}
{"project": "qemu", "commit_id": "9586fefefe383a9aa25ad99bde9a6b240309ca33", "target": 1, "func": "static void vga_screen_dump(void *opaque, const char *filename)\n\n{\n\n    VGAState *s = (VGAState *)opaque;\n\n\n\n    if (!(s->ar_index & 0x20))\n\n        vga_screen_dump_blank(s, filename);\n\n    else if (s->gr[6] & 1)\n\n        vga_screen_dump_graphic(s, filename);\n\n    else\n\n        vga_screen_dump_text(s, filename);\n\n}\n", "idx": 4619}
{"project": "qemu", "commit_id": "8804f57b531e4887ad9521c9abb9e0bbbcb1dd4e", "target": 1, "func": "static int vscsi_srp_direct_data(VSCSIState *s, vscsi_req *req,\n\n                                 uint8_t *buf, uint32_t len)\n\n{\n\n    struct srp_direct_buf *md = req->cur_desc;\n\n    uint32_t llen;\n\n    int rc;\n\n\n\n    dprintf(\"VSCSI: direct segment 0x%x bytes, va=0x%llx desc len=0x%x\\n\",\n\n            len, (unsigned long long)md->va, md->len);\n\n\n\n    llen = MIN(len, md->len);\n\n    if (llen) {\n\n        if (req->writing) { /* writing = to device = reading from memory */\n\n            rc = spapr_tce_dma_read(&s->vdev, md->va, buf, llen);\n\n        } else {\n\n            rc = spapr_tce_dma_write(&s->vdev, md->va, buf, llen);\n\n        }\n\n    }\n\n    md->len -= llen;\n\n    md->va += llen;\n\n\n\n    if (rc) {\n\n        return -1;\n\n    }\n\n    return llen;\n\n}\n", "idx": 10572}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n", "idx": 3670}
{"project": "qemu", "commit_id": "cba933b2257ef0ad241756a0ff86bc0acda685ca", "target": 1, "func": "static uint64_t icp_pit_read(void *opaque, hwaddr offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 2) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: Bad timer %d\\n\", __func__, n);\n\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}", "idx": 7}
{"project": "qemu", "commit_id": "5e52e5f903b2648c59030637e1610b32e965d615", "target": 1, "func": "static uint32_t get_features(VirtIODevice *vdev, uint32_t features)\n\n{\n\n    VirtIOSerial *vser;\n\n\n\n    vser = DO_UPCAST(VirtIOSerial, vdev, vdev);\n\n\n\n    if (vser->bus->max_nr_ports > 1) {\n\n        features |= (1 << VIRTIO_CONSOLE_F_MULTIPORT);\n\n    }\n\n    return features;\n\n}\n", "idx": 5201}
{"project": "qemu", "commit_id": "983bff3530782d51c46c8d7c0e17e2a9dfe5fb77", "target": 1, "func": "static void usb_mtp_object_readdir(MTPState *s, MTPObject *o)\n\n{\n\n    struct dirent *entry;\n\n    DIR *dir;\n\n\n\n    if (o->have_children) {\n\n        return;\n\n    }\n\n    o->have_children = true;\n\n\n\n    dir = opendir(o->path);\n\n    if (!dir) {\n\n        return;\n\n    }\n\n#ifdef __linux__\n\n    int watchfd = usb_mtp_add_watch(s->inotifyfd, o->path);\n\n    if (watchfd == -1) {\n\n        fprintf(stderr, \"usb-mtp: failed to add watch for %s\\n\", o->path);\n\n    } else {\n\n        trace_usb_mtp_inotify_event(s->dev.addr, o->path,\n\n                                    0, \"Watch Added\");\n\n        o->watchfd = watchfd;\n\n    }\n\n#endif\n\n    while ((entry = readdir(dir)) != NULL) {\n\n        usb_mtp_add_child(s, o, entry->d_name);\n\n    }\n\n    closedir(dir);\n\n}\n", "idx": 7057}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_mechname_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t mechlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client mechname len %d\\n\", mechlen);\n\n    if (mechlen > 100) {\n\n        VNC_DEBUG(\"Too long SASL mechname data %d\\n\", mechlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n    if (mechlen < 1) {\n\n        VNC_DEBUG(\"Too short SASL mechname %d\\n\", mechlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n    vnc_read_when(vs, protocol_client_auth_sasl_mechname,mechlen);\n\n    return 0;\n\n}\n", "idx": 1658}
{"project": "qemu", "commit_id": "5942a19040fed313b316ab7b6e3d2d8e7b1625bb", "target": 1, "func": "static void bus_set_realized(Object *obj, bool value, Error **errp)\n\n{\n\n    BusState *bus = BUS(obj);\n\n    BusClass *bc = BUS_GET_CLASS(bus);\n\n    Error *local_err = NULL;\n\n\n\n    if (value && !bus->realized) {\n\n        if (bc->realize) {\n\n            bc->realize(bus, &local_err);\n\n        }\n\n    } else if (!value && bus->realized) {\n\n        if (bc->unrealize) {\n\n            bc->unrealize(bus, &local_err);\n\n        }\n\n    }\n\n\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    bus->realized = value;\n\n}\n", "idx": 11157}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void xilinx_axidma_init(Object *obj)\n\n{\n\n    XilinxAXIDMA *s = XILINX_AXI_DMA(obj);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n\n\n    object_property_add_link(obj, \"axistream-connected\", TYPE_STREAM_SLAVE,\n\n                             (Object **)&s->tx_data_dev, &error_abort);\n\n    object_property_add_link(obj, \"axistream-control-connected\",\n\n                             TYPE_STREAM_SLAVE,\n\n                             (Object **)&s->tx_control_dev, &error_abort);\n\n\n\n    object_initialize(&s->rx_data_dev, sizeof(s->rx_data_dev),\n\n                      TYPE_XILINX_AXI_DMA_DATA_STREAM);\n\n    object_initialize(&s->rx_control_dev, sizeof(s->rx_control_dev),\n\n                      TYPE_XILINX_AXI_DMA_CONTROL_STREAM);\n\n    object_property_add_child(OBJECT(s), \"axistream-connected-target\",\n\n                              (Object *)&s->rx_data_dev, &error_abort);\n\n    object_property_add_child(OBJECT(s), \"axistream-control-connected-target\",\n\n                              (Object *)&s->rx_control_dev, &error_abort);\n\n\n\n    sysbus_init_irq(sbd, &s->streams[0].irq);\n\n    sysbus_init_irq(sbd, &s->streams[1].irq);\n\n\n\n    memory_region_init_io(&s->iomem, obj, &axidma_ops, s,\n\n                          \"xlnx.axi-dma\", R_MAX * 4 * 2);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n}\n", "idx": 1112}
{"project": "qemu", "commit_id": "315a1309defd8ddf910c6c17e28cbbd7faf92f2e", "target": 1, "func": "void coroutine_fn qemu_coroutine_yield(void)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n    Coroutine *to = self->caller;\n\n\n\n    trace_qemu_coroutine_yield(self, to);\n\n\n\n    if (!to) {\n\n        fprintf(stderr, \"Co-routine is yielding to no one\\n\");\n\n        abort();\n\n    }\n\n\n\n    self->caller = NULL;\n\n    coroutine_swap(self, to);\n\n}\n", "idx": 4900}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "void spapr_lmb_release(DeviceState *dev)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_hotplug_handler(dev));\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    sPAPRDIMMState *ds = spapr_pending_dimm_unplugs_find(spapr, PC_DIMM(dev));\n\n\n\n    /* This information will get lost if a migration occurs\n\n     * during the unplug process. In this case recover it. */\n\n    if (ds == NULL) {\n\n        ds = spapr_recover_pending_dimm_state(spapr, PC_DIMM(dev));\n\n        g_assert(ds);\n\n        /* The DRC being examined by the caller at least must be counted */\n\n        g_assert(ds->nr_lmbs);\n\n    }\n\n\n\n    if (--ds->nr_lmbs) {\n\n        return;\n\n    }\n\n\n\n    spapr_pending_dimm_unplugs_remove(spapr, ds);\n\n\n\n    /*\n\n     * Now that all the LMBs have been removed by the guest, call the\n\n     * pc-dimm unplug handler to cleanup up the pc-dimm device.\n\n     */\n\n    pc_dimm_memory_unplug(dev, &spapr->hotplug_memory, mr);\n\n    object_unparent(OBJECT(dev));\n\n}\n", "idx": 6044}
{"project": "qemu", "commit_id": "a083a89d7277f3268a251ce635d9aae5559242bd", "target": 1, "func": "void qemu_del_vlan_client(VLANClientState *vc)\n\n{\n\n    if (vc->vlan) {\n\n        QTAILQ_REMOVE(&vc->vlan->clients, vc, next);\n\n    } else {\n\n        if (vc->send_queue) {\n\n            qemu_del_net_queue(vc->send_queue);\n\n        }\n\n        QTAILQ_REMOVE(&non_vlan_clients, vc, next);\n\n        if (vc->peer) {\n\n            vc->peer->peer = NULL;\n\n        }\n\n    }\n\n\n\n    if (vc->info->cleanup) {\n\n        vc->info->cleanup(vc);\n\n    }\n\n\n\n    qemu_free(vc->name);\n\n    qemu_free(vc->model);\n\n    qemu_free(vc);\n\n}\n", "idx": 10932}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 5726}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void isabus_fdc_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = isabus_fdc_realize;\n\n    dc->fw_name = \"fdc\";\n\n    dc->no_user = 1;\n\n    dc->reset = fdctrl_external_reset_isa;\n\n    dc->vmsd = &vmstate_isa_fdc;\n\n    dc->props = isa_fdc_properties;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n}\n", "idx": 9718}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "static int qemu_loadvm_state(QEMUFile *f)\n\n{\n\n    SaveStateEntry *se;\n\n    int len, ret, instance_id, record_len, version_id;\n\n    int64_t total_len, end_pos, cur_pos;\n\n    unsigned int v;\n\n    char idstr[256];\n\n\n\n    v = qemu_get_be32(f);\n\n    if (v != QEMU_VM_FILE_MAGIC)\n\n        goto fail;\n\n    v = qemu_get_be32(f);\n\n    if (v != QEMU_VM_FILE_VERSION) {\n\n    fail:\n\n        ret = -1;\n\n        goto the_end;\n\n    }\n\n    total_len = qemu_get_be64(f);\n\n    end_pos = total_len + qemu_ftell(f);\n\n    for(;;) {\n\n        if (qemu_ftell(f) >= end_pos)\n\n            break;\n\n        len = qemu_get_byte(f);\n\n        qemu_get_buffer(f, (uint8_t *)idstr, len);\n\n        idstr[len] = '\\0';\n\n        instance_id = qemu_get_be32(f);\n\n        version_id = qemu_get_be32(f);\n\n        record_len = qemu_get_be32(f);\n\n#if 0\n\n        printf(\"idstr=%s instance=0x%x version=%d len=%d\\n\",\n\n               idstr, instance_id, version_id, record_len);\n\n#endif\n\n        cur_pos = qemu_ftell(f);\n\n        se = find_se(idstr, instance_id);\n\n        if (!se) {\n\n            fprintf(stderr, \"qemu: warning: instance 0x%x of device '%s' not present in current VM\\n\",\n\n                    instance_id, idstr);\n\n        } else {\n\n            ret = se->load_state(f, se->opaque, version_id);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"qemu: warning: error while loading state for instance 0x%x of device '%s'\\n\",\n\n                        instance_id, idstr);\n\n            }\n\n        }\n\n        /* always seek to exact end of record */\n\n        qemu_fseek(f, cur_pos + record_len, SEEK_SET);\n\n    }\n\n    ret = 0;\n\n the_end:\n\n    return ret;\n\n}\n", "idx": 5394}
{"project": "qemu", "commit_id": "fdcf6e65bce1f8972030fed7af5e8aa5f6ae92c6", "target": 1, "func": "static int read_password(char *buf, int buf_size)\n\n{\n\n    int c, i;\n\n    printf(\"Password: \");\n\n    fflush(stdout);\n\n    i = 0;\n\n    for(;;) {\n\n        c = getchar();\n\n        if (c == '\\n')\n\n            break;\n\n        if (i < (buf_size - 1))\n\n            buf[i++] = c;\n\n    }\n\n    buf[i] = '\\0';\n\n    return 0;\n\n}\n", "idx": 7424}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static gboolean register_signal_handlers(void)\n\n{\n\n    struct sigaction sigact, sigact_chld;\n\n    int ret;\n\n\n\n    memset(&sigact, 0, sizeof(struct sigaction));\n\n    sigact.sa_handler = quit_handler;\n\n\n\n    ret = sigaction(SIGINT, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n    ret = sigaction(SIGTERM, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n\n\n    memset(&sigact_chld, 0, sizeof(struct sigaction));\n\n    sigact_chld.sa_handler = child_handler;\n\n    sigact_chld.sa_flags = SA_NOCLDSTOP;\n\n    ret = sigaction(SIGCHLD, &sigact_chld, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 6131}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void vnc_write_pixels_generic(VncState *vs, void *pixels1, int size)\n\n{\n\n    uint8_t buf[4];\n\n\n\n    if (vs->depth == 4) {\n\n        uint32_t *pixels = pixels1;\n\n        int n, i;\n\n        n = size >> 2;\n\n        for(i = 0; i < n; i++) {\n\n            vnc_convert_pixel(vs, buf, pixels[i]);\n\n            vnc_write(vs, buf, vs->pix_bpp);\n\n        }\n\n    } else if (vs->depth == 2) {\n\n        uint16_t *pixels = pixels1;\n\n        int n, i;\n\n        n = size >> 1;\n\n        for(i = 0; i < n; i++) {\n\n            vnc_convert_pixel(vs, buf, pixels[i]);\n\n            vnc_write(vs, buf, vs->pix_bpp);\n\n        }\n\n    } else if (vs->depth == 1) {\n\n        uint8_t *pixels = pixels1;\n\n        int n, i;\n\n        n = size;\n\n        for(i = 0; i < n; i++) {\n\n            vnc_convert_pixel(vs, buf, pixels[i]);\n\n            vnc_write(vs, buf, vs->pix_bpp);\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"vnc_write_pixels_generic: VncState color depth not supported\\n\");\n\n    }\n\n}\n", "idx": 11224}
{"project": "qemu", "commit_id": "3bc36a401e0f33e63a4d2c58b646ddf78efb567c", "target": 1, "func": "static USBDevice *usb_bt_init(USBBus *bus, const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    struct USBBtState *s;\n\n    HCIInfo *hci;\n\n    const char *name = \"usb-bt-dongle\";\n\n\n\n    if (*cmdline) {\n\n        hci = hci_init(cmdline);\n\n    } else {\n\n        hci = bt_new_hci(qemu_find_bt_vlan(0));\n\n    }\n\n    if (!hci)\n\n        return NULL;\n\n\n\n    dev = usb_create(bus, name);\n\n    s = DO_UPCAST(struct USBBtState, dev, dev);\n\n    s->hci = hci;\n\n    if (qdev_init(&dev->qdev) < 0) {\n\n        error_report(\"Failed to initialize USB device '%s'\", name);\n\n        return NULL;\n\n    }\n\n\n\n    return dev;\n\n}\n", "idx": 9490}
{"project": "qemu", "commit_id": "4d73cd3b3f55fcff433ce64b125b7adb8aaece29", "target": 1, "func": "static int drive_init(struct drive_opt *arg, int snapshot,\n\n                      QEMUMachine *machine)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n        } else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_REPORT;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return 0;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return 0;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0 || qemu_key_check(bdrv, file)) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 11449}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "static void xscale_cpar_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                              uint64_t value)\n\n{\n\n    value &= 0x3fff;\n\n    if (env->cp15.c15_cpar != value) {\n\n        /* Changes cp0 to cp13 behavior, so needs a TB flush.  */\n\n        tb_flush(env);\n\n        env->cp15.c15_cpar = value;\n\n    }\n\n}\n", "idx": 6779}
{"project": "qemu", "commit_id": "8af42882a51c632a14d77277df0740f1aa8c958a", "target": 1, "func": "static void readline_hist_add(ReadLineState *rs, const char *cmdline)\n\n{\n\n    char *hist_entry, *new_entry;\n\n    int idx;\n\n\n\n    if (cmdline[0] == '\\0')\n\n\treturn;\n\n    new_entry = NULL;\n\n    if (rs->hist_entry != -1) {\n\n\t/* We were editing an existing history entry: replace it */\n\n\thist_entry = rs->history[rs->hist_entry];\n\n\tidx = rs->hist_entry;\n\n\tif (strcmp(hist_entry, cmdline) == 0) {\n\n\t    goto same_entry;\n\n\t}\n\n    }\n\n    /* Search cmdline in history buffers */\n\n    for (idx = 0; idx < READLINE_MAX_CMDS; idx++) {\n\n\thist_entry = rs->history[idx];\n\n\tif (hist_entry == NULL)\n\n\t    break;\n\n\tif (strcmp(hist_entry, cmdline) == 0) {\n\n\tsame_entry:\n\n\t    new_entry = hist_entry;\n\n\t    /* Put this entry at the end of history */\n\n\t    memmove(&rs->history[idx], &rs->history[idx + 1],\n\n\t\t    (READLINE_MAX_CMDS - idx + 1) * sizeof(char *));\n\n\t    rs->history[READLINE_MAX_CMDS - 1] = NULL;\n\n\t    for (; idx < READLINE_MAX_CMDS; idx++) {\n\n\t\tif (rs->history[idx] == NULL)\n\n\t\t    break;\n\n\t    }\n\n\t    break;\n\n\t}\n\n    }\n\n    if (idx == READLINE_MAX_CMDS) {\n\n\t/* Need to get one free slot */\n\n\tfree(rs->history[0]);\n\n\tmemcpy(rs->history, &rs->history[1],\n\n\t       (READLINE_MAX_CMDS - 1) * sizeof(char *));\n\n\trs->history[READLINE_MAX_CMDS - 1] = NULL;\n\n\tidx = READLINE_MAX_CMDS - 1;\n\n    }\n\n    if (new_entry == NULL)\n\n\tnew_entry = strdup(cmdline);\n\n    rs->history[idx] = new_entry;\n\n    rs->hist_entry = -1;\n\n}\n", "idx": 6848}
{"project": "qemu", "commit_id": "b6353bea572f8cc0f35fb7dc438ce74c08dda9e7", "target": 1, "func": "static int find_partition(BlockDriverState *bs, int partition,\n\n                          off_t *offset, off_t *size)\n\n{\n\n    struct partition_record mbr[4];\n\n    uint8_t data[512];\n\n    int i;\n\n    int ext_partnum = 4;\n\n\n\n    if (bdrv_read(bs, 0, data, 1))\n\n        errx(EINVAL, \"error while reading\");\n\n\n\n    if (data[510] != 0x55 || data[511] != 0xaa) {\n\n        errno = -EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        read_partition(&data[446 + 16 * i], &mbr[i]);\n\n\n\n        if (!mbr[i].nb_sectors_abs)\n\n            continue;\n\n\n\n        if (mbr[i].system == 0xF || mbr[i].system == 0x5) {\n\n            struct partition_record ext[4];\n\n            uint8_t data1[512];\n\n            int j;\n\n\n\n            if (bdrv_read(bs, mbr[i].start_sector_abs, data1, 1))\n\n                errx(EINVAL, \"error while reading\");\n\n\n\n            for (j = 0; j < 4; j++) {\n\n                read_partition(&data1[446 + 16 * j], &ext[j]);\n\n                if (!ext[j].nb_sectors_abs)\n\n                    continue;\n\n\n\n                if ((ext_partnum + j + 1) == partition) {\n\n                    *offset = (uint64_t)ext[j].start_sector_abs << 9;\n\n                    *size = (uint64_t)ext[j].nb_sectors_abs << 9;\n\n                    return 0;\n\n                }\n\n            }\n\n            ext_partnum += 4;\n\n        } else if ((i + 1) == partition) {\n\n            *offset = (uint64_t)mbr[i].start_sector_abs << 9;\n\n            *size = (uint64_t)mbr[i].nb_sectors_abs << 9;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    errno = -ENOENT;\n\n    return -1;\n\n}\n", "idx": 327}
{"project": "qemu", "commit_id": "24f3902b088cd4f2dbebfd90527b5d81d6a050e9", "target": 1, "func": "static int qemu_savevm_state(QEMUFile *f, Error **errp)\n\n{\n\n    int ret;\n\n    MigrationParams params = {\n\n        .blk = 0,\n\n        .shared = 0\n\n    };\n\n    MigrationState *ms = migrate_init(&params);\n\n    ms->to_dst_file = f;\n\n\n\n    if (qemu_savevm_state_blocked(errp)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    qemu_savevm_state_header(f);\n\n    qemu_savevm_state_begin(f, &params);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    while (qemu_file_get_error(f) == 0) {\n\n        if (qemu_savevm_state_iterate(f, false) > 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    ret = qemu_file_get_error(f);\n\n    if (ret == 0) {\n\n        qemu_savevm_state_complete_precopy(f, false);\n\n        ret = qemu_file_get_error(f);\n\n    }\n\n    qemu_savevm_state_cleanup();\n\n    if (ret != 0) {\n\n        error_setg_errno(errp, -ret, \"Error while writing VM state\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 3135}
{"project": "qemu", "commit_id": "398489018183d613306ab022653552247d93919f", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state,\n\n                    int *piix3_devfn,\n\n                    ISABus **isa_bus, qemu_irq *pic,\n\n                    MemoryRegion *address_space_mem,\n\n                    MemoryRegion *address_space_io,\n\n                    ram_addr_t ram_size,\n\n                    hwaddr pci_hole_start,\n\n                    hwaddr pci_hole_size,\n\n                    hwaddr pci_hole64_start,\n\n                    hwaddr pci_hole64_size,\n\n                    MemoryRegion *pci_address_space,\n\n                    MemoryRegion *ram_memory)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    PCIHostState *s;\n\n    PIIX3State *piix3;\n\n    PCII440FXState *f;\n\n    unsigned i;\n\n\n\n    dev = qdev_create(NULL, TYPE_I440FX_PCI_HOST_BRIDGE);\n\n    s = PCI_HOST_BRIDGE(dev);\n\n    b = pci_bus_new(dev, NULL, pci_address_space,\n\n                    address_space_io, 0, TYPE_PCI_BUS);\n\n    s->bus = b;\n\n    object_property_add_child(qdev_get_machine(), \"i440fx\", OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, TYPE_I440FX_PCI_DEVICE);\n\n    *pi440fx_state = I440FX_PCI_DEVICE(d);\n\n    f = *pi440fx_state;\n\n    f->system_memory = address_space_mem;\n\n    f->pci_address_space = pci_address_space;\n\n    f->ram_memory = ram_memory;\n\n    memory_region_init_alias(&f->pci_hole, OBJECT(d), \"pci-hole\", f->pci_address_space,\n\n                             pci_hole_start, pci_hole_size);\n\n    memory_region_add_subregion(f->system_memory, pci_hole_start, &f->pci_hole);\n\n    memory_region_init_alias(&f->pci_hole_64bit, OBJECT(d), \"pci-hole64\",\n\n                             f->pci_address_space,\n\n                             pci_hole64_start, pci_hole64_size);\n\n    if (pci_hole64_size) {\n\n        memory_region_add_subregion(f->system_memory, pci_hole64_start,\n\n                                    &f->pci_hole_64bit);\n\n    }\n\n    memory_region_init_alias(&f->smram_region, OBJECT(d), \"smram-region\",\n\n                             f->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(f->system_memory, 0xa0000,\n\n                                        &f->smram_region, 1);\n\n    memory_region_set_enabled(&f->smram_region, false);\n\n    init_pam(dev, f->ram_memory, f->system_memory, f->pci_address_space,\n\n             &f->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(dev, f->ram_memory, f->system_memory, f->pci_address_space,\n\n                 &f->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n\n\n    /* Xen supports additional interrupt routes from the PCI devices to\n\n     * the IOAPIC: the four pins of each PCI device on the bus are also\n\n     * connected to the IOAPIC directly.\n\n     * These additional routes can be discovered through ACPI. */\n\n    if (xen_enabled()) {\n\n        piix3 = DO_UPCAST(PIIX3State, dev,\n\n                pci_create_simple_multifunction(b, -1, true, \"PIIX3-xen\"));\n\n        pci_bus_irqs(b, xen_piix3_set_irq, xen_pci_slot_get_pirq,\n\n                piix3, XEN_PIIX_NUM_PIRQS);\n\n    } else {\n\n        piix3 = DO_UPCAST(PIIX3State, dev,\n\n                pci_create_simple_multifunction(b, -1, true, \"PIIX3\"));\n\n        pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3,\n\n                PIIX_NUM_PIRQS);\n\n        pci_bus_set_route_irq_fn(b, piix3_route_intx_pin_to_irq);\n\n    }\n\n    piix3->pic = pic;\n\n    *isa_bus = ISA_BUS(qdev_get_child_bus(DEVICE(piix3), \"isa.0\"));\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255) {\n\n        ram_size = 255;\n\n    }\n\n    d->config[0x57] = ram_size;\n\n\n\n    i440fx_update_memory_mappings(f);\n\n\n\n    return b;\n\n}\n", "idx": 9871}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "void OPPROTO op_405_check_ov (void)\n\n{\n\n    do_405_check_ov();\n\n    RETURN();\n\n}\n", "idx": 6}
{"project": "qemu", "commit_id": "fe1479aa251971abd3842dee4a783d4ebace8fb8", "target": 1, "func": "static int bamboo_load_device_tree(hwaddr addr,\n\n                                     uint32_t ramsize,\n\n                                     hwaddr initrd_base,\n\n                                     hwaddr initrd_size,\n\n                                     const char *kernel_cmdline)\n\n{\n\n    int ret = -1;\n\n    uint32_t mem_reg_property[] = { 0, 0, cpu_to_be32(ramsize) };\n\n    char *filename;\n\n    int fdt_size;\n\n    void *fdt;\n\n    uint32_t tb_freq = 400000000;\n\n    uint32_t clock_freq = 400000000;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);\n\n    if (!filename) {\n\n        goto out;\n\n    }\n\n    fdt = load_device_tree(filename, &fdt_size);\n\n    g_free(filename);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n\n\n    ret = qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                               sizeof(mem_reg_property));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    /* Copy data from the host device tree into the guest. Since the guest can\n\n     * directly access the timebase without host involvement, we must expose\n\n     * the correct frequencies. */\n\n    if (kvm_enabled()) {\n\n        tb_freq = kvmppc_get_tbfreq();\n\n        clock_freq = kvmppc_get_clockfreq();\n\n    }\n\n\n\n    qemu_devtree_setprop_cell(fdt, \"/cpus/cpu@0\", \"clock-frequency\",\n\n                              clock_freq);\n\n    qemu_devtree_setprop_cell(fdt, \"/cpus/cpu@0\", \"timebase-frequency\",\n\n                              tb_freq);\n\n\n\n    ret = rom_add_blob_fixed(BINARY_DEVICE_TREE_FILE, fdt, fdt_size, addr);\n\n    g_free(fdt);\n\n\n\nout:\n\n\n\n    return ret;\n\n}\n", "idx": 4687}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int virtio_rng_pci_init(VirtIOPCIProxy *vpci_dev)\n\n{\n\n    VirtIORngPCI *vrng = VIRTIO_RNG_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vrng->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(vrng),\n\n                             OBJECT(vrng->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return 0;\n\n}\n", "idx": 4156}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = 0x01,\n\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n\n    };\n\n    QemuConsole *con = vs->vd->dcl.con;\n\n    int width = surface_width(vs->vd->ds);\n\n    int height = surface_height(vs->vd->ds);\n\n\n\n    if (vs->last_bmask != button_mask) {\n\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n\n        vs->last_bmask = button_mask;\n\n    }\n\n\n\n    if (vs->absolute) {\n\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n\n    } else {\n\n        if (vs->last_x != -1) {\n\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n\n        }\n\n        vs->last_x = x;\n\n        vs->last_y = y;\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 160}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "static void kvm_mce_broadcast_rest(CPUState *env)\n\n{\n\n    CPUState *cenv;\n\n    int family, model, cpuver = env->cpuid_version;\n\n\n\n    family = (cpuver >> 8) & 0xf;\n\n    model = ((cpuver >> 12) & 0xf0) + ((cpuver >> 4) & 0xf);\n\n\n\n    /* Broadcast MCA signal for processor version 06H_EH and above */\n\n    if ((family == 6 && model >= 14) || family > 6) {\n\n        for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {\n\n            if (cenv == env) {\n\n                continue;\n\n            }\n\n            kvm_inject_x86_mce(cenv, 1, MCI_STATUS_VAL | MCI_STATUS_UC,\n\n                               MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0, 1);\n\n        }\n\n    }\n\n}\n", "idx": 3434}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n", "idx": 6351}
{"project": "qemu", "commit_id": "2a6391232fa58f32469fb61d55343eff32a91083", "target": 1, "func": "static uint32_t virtio_read_config(PCIDevice *pci_dev,\n\n                                   uint32_t address, int len)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    struct virtio_pci_cfg_cap *cfg;\n\n\n\n    if (proxy->config_cap &&\n\n        ranges_overlap(address, len, proxy->config_cap + offsetof(struct virtio_pci_cfg_cap,\n\n                                                                  pci_cfg_data),\n\n                       sizeof cfg->pci_cfg_data)) {\n\n        uint32_t off;\n\n        uint32_t len;\n\n\n\n        cfg = (void *)(proxy->pci_dev.config + proxy->config_cap);\n\n        off = le32_to_cpu(cfg->cap.offset);\n\n        len = le32_to_cpu(cfg->cap.length);\n\n\n\n        if (len <= sizeof cfg->pci_cfg_data) {\n\n            virtio_address_space_read(&proxy->modern_as, off,\n\n                                      cfg->pci_cfg_data, len);\n\n        }\n\n    }\n\n\n\n    return pci_default_read_config(pci_dev, address, len);\n\n}\n", "idx": 5361}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void block_migration_cancel(void *opaque)\n\n{\n\n    blk_mig_cleanup();\n\n}\n", "idx": 9074}
{"project": "qemu", "commit_id": "a8fb542705ac7e0dcf00908bc47bf49cdd058abe", "target": 1, "func": "static CharDriverState *qmp_chardev_open_socket(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    TCPCharDriver *s;\n\n    ChardevSocket *sock = backend->u.socket;\n\n    SocketAddress *addr = sock->addr;\n\n    bool do_nodelay     = sock->has_nodelay ? sock->nodelay : false;\n\n    bool is_listen      = sock->has_server  ? sock->server  : true;\n\n    bool is_telnet      = sock->has_telnet  ? sock->telnet  : false;\n\n    bool is_waitconnect = sock->has_wait    ? sock->wait    : false;\n\n    int64_t reconnect   = sock->has_reconnect ? sock->reconnect : 0;\n\n    ChardevCommon *common = qapi_ChardevSocket_base(backend->u.socket);\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    s = g_new0(TCPCharDriver, 1);\n\n\n\n    s->is_unix = addr->type == SOCKET_ADDRESS_KIND_UNIX;\n\n    s->is_listen = is_listen;\n\n    s->is_telnet = is_telnet;\n\n    s->do_nodelay = do_nodelay;\n\n    qapi_copy_SocketAddress(&s->addr, sock->addr);\n\n\n\n    chr->opaque = s;\n\n    chr->chr_write = tcp_chr_write;\n\n    chr->chr_sync_read = tcp_chr_sync_read;\n\n    chr->chr_close = tcp_chr_close;\n\n    chr->get_msgfds = tcp_get_msgfds;\n\n    chr->set_msgfds = tcp_set_msgfds;\n\n    chr->chr_add_client = tcp_chr_add_client;\n\n    chr->chr_add_watch = tcp_chr_add_watch;\n\n    chr->chr_update_read_handler = tcp_chr_update_read_handler;\n\n    /* be isn't opened until we get a connection */\n\n    chr->explicit_be_open = true;\n\n\n\n    chr->filename = SocketAddress_to_str(\"disconnected:\",\n\n                                         addr, is_listen, is_telnet);\n\n\n\n    if (is_listen) {\n\n        if (is_telnet) {\n\n            s->do_telnetopt = 1;\n\n        }\n\n    } else if (reconnect > 0) {\n\n        s->reconnect_time = reconnect;\n\n    }\n\n\n\n    if (s->reconnect_time) {\n\n        socket_try_connect(chr);\n\n    } else if (!qemu_chr_open_socket_fd(chr, errp)) {\n\n        g_free(s);\n\n        qemu_chr_free_common(chr);\n\n        return NULL;\n\n    }\n\n\n\n    if (is_listen && is_waitconnect) {\n\n        fprintf(stderr, \"QEMU waiting for connection on: %s\\n\",\n\n                chr->filename);\n\n        tcp_chr_accept(QIO_CHANNEL(s->listen_ioc), G_IO_IN, chr);\n\n        qio_channel_set_blocking(QIO_CHANNEL(s->listen_ioc), false, NULL);\n\n    }\n\n\n\n    return chr;\n\n}\n", "idx": 10138}
{"project": "qemu", "commit_id": "9c4bbee9e3b83544257e82566342c29e15a88637", "target": 1, "func": "static inline int handle_cpu_signal(uintptr_t pc, siginfo_t *info,\n\n                                    int is_write, sigset_t *old_set)\n\n{\n\n    CPUState *cpu = current_cpu;\n\n    CPUClass *cc;\n\n    int ret;\n\n    unsigned long address = (unsigned long)info->si_addr;\n\n\n\n    /* We must handle PC addresses from two different sources:\n\n     * a call return address and a signal frame address.\n\n     *\n\n     * Within cpu_restore_state_from_tb we assume the former and adjust\n\n     * the address by -GETPC_ADJ so that the address is within the call\n\n     * insn so that addr does not accidentally match the beginning of the\n\n     * next guest insn.\n\n     *\n\n     * However, when the PC comes from the signal frame, it points to\n\n     * the actual faulting host insn and not a call insn.  Subtracting\n\n     * GETPC_ADJ in that case may accidentally match the previous guest insn.\n\n     *\n\n     * So for the later case, adjust forward to compensate for what\n\n     * will be done later by cpu_restore_state_from_tb.\n\n     */\n\n    if (helper_retaddr) {\n\n        pc = helper_retaddr;\n\n    } else {\n\n        pc += GETPC_ADJ;\n\n    }\n\n\n\n    /* For synchronous signals we expect to be coming from the vCPU\n\n     * thread (so current_cpu should be valid) and either from running\n\n     * code or during translation which can fault as we cross pages.\n\n     *\n\n     * If neither is true then something has gone wrong and we should\n\n     * abort rather than try and restart the vCPU execution.\n\n     */\n\n    if (!cpu || !cpu->running) {\n\n        printf(\"qemu:%s received signal outside vCPU context @ pc=0x%\"\n\n               PRIxPTR \"\\n\",  __func__, pc);\n\n        abort();\n\n    }\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\",\n\n           pc, address, is_write, *(unsigned long *)old_set);\n\n#endif\n\n    /* XXX: locking issue */\n\n    if (is_write && h2g_valid(address)) {\n\n        switch (page_unprotect(h2g(address), pc)) {\n\n        case 0:\n\n            /* Fault not caused by a page marked unwritable to protect\n\n             * cached translations, must be the guest binary's problem.\n\n             */\n\n            break;\n\n        case 1:\n\n            /* Fault caused by protection of cached translation; TBs\n\n             * invalidated, so resume execution.  Retain helper_retaddr\n\n             * for a possible second fault.\n\n             */\n\n            return 1;\n\n        case 2:\n\n            /* Fault caused by protection of cached translation, and the\n\n             * currently executing TB was modified and must be exited\n\n             * immediately.  Clear helper_retaddr for next execution.\n\n             */\n\n            helper_retaddr = 0;\n\n            cpu_exit_tb_from_sighandler(cpu, old_set);\n\n            /* NORETURN */\n\n\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n    }\n\n\n\n    /* Convert forcefully to guest address space, invalid addresses\n\n       are still valid segv ones */\n\n    address = h2g_nocheck(address);\n\n\n\n    cc = CPU_GET_CLASS(cpu);\n\n    /* see if it is an MMU fault */\n\n    g_assert(cc->handle_mmu_fault);\n\n    ret = cc->handle_mmu_fault(cpu, address, is_write, MMU_USER_IDX);\n\n\n\n    if (ret == 0) {\n\n        /* The MMU fault was handled without causing real CPU fault.\n\n         *  Retain helper_retaddr for a possible second fault.\n\n         */\n\n        return 1;\n\n    }\n\n\n\n    /* All other paths lead to cpu_exit; clear helper_retaddr\n\n     * for next execution.\n\n     */\n\n    helper_retaddr = 0;\n\n\n\n    if (ret < 0) {\n\n        return 0; /* not an MMU fault */\n\n    }\n\n\n\n    /* Now we have a real cpu fault.  */\n\n    cpu_restore_state(cpu, pc);\n\n\n\n    sigprocmask(SIG_SETMASK, old_set, NULL);\n\n    cpu_loop_exit(cpu);\n\n\n\n    /* never comes here */\n\n    return 1;\n\n}\n", "idx": 8189}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_mig_unlock(void)\n\n{\n\n    qemu_mutex_unlock(&block_mig_state.lock);\n\n}\n", "idx": 233}
{"project": "qemu", "commit_id": "cca1af8c4d2ef6449fd61494ba2cb087b838011c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n\n                            int opc)\n\n{\n\n    int addr_regl, addr_reg1, addr_meml;\n\n    int data_regl, data_regh, data_reg1, data_reg2;\n\n    int mem_index, s_bits;\n\n#if defined(CONFIG_SOFTMMU)\n\n    void *label1_ptr, *label2_ptr;\n\n    int sp_args;\n\n#endif\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(CONFIG_SOFTMMU)\n\n    uint8_t *label3_ptr;\n\n# endif\n\n    int addr_regh, addr_reg2, addr_memh;\n\n#endif\n\n    data_regl = *args++;\n\n    if (opc == 3)\n\n        data_regh = *args++;\n\n    else\n\n        data_regh = 0;\n\n    addr_regl = *args++;\n\n#if TARGET_LONG_BITS == 64\n\n    addr_regh = *args++;\n\n#endif\n\n    mem_index = *args;\n\n    s_bits = opc & 3;\n\n\n\n    if (opc == 3) {\n\n#if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n        data_reg1 = data_regh;\n\n        data_reg2 = data_regl;\n\n#else\n\n        data_reg1 = data_regl;\n\n        data_reg2 = data_regh;\n\n#endif\n\n    } else {\n\n        data_reg1 = data_regl;\n\n        data_reg2 = 0;\n\n    }\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n    addr_reg1 = addr_regh;\n\n    addr_reg2 = addr_regl;\n\n    addr_memh = 0;\n\n    addr_meml = 4;\n\n# else\n\n    addr_reg1 = addr_regl;\n\n    addr_reg2 = addr_regh;\n\n    addr_memh = 4;\n\n    addr_meml = 0;\n\n# endif\n\n#else\n\n    addr_reg1 = addr_regl;\n\n    addr_meml = 0;\n\n#endif\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    tcg_out_opc_sa(s, OPC_SRL, TCG_REG_A0, addr_regl, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_imm(s, OPC_ANDI, TCG_REG_A0, TCG_REG_A0, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_A0, TCG_REG_A0, TCG_AREG0);\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_meml);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T0, TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n    tcg_out_opc_reg(s, OPC_AND, TCG_REG_T0, TCG_REG_T0, addr_regl);\n\n\n\n# if TARGET_LONG_BITS == 64\n\n    label3_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BNE, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_memh);\n\n\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, addr_regh, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    reloc_pc16(label3_ptr, (tcg_target_long) s->code_ptr);\n\n# else\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n# endif\n\n\n\n    /* slow path */\n\n    sp_args = TCG_REG_A0;\n\n    tcg_out_mov(s, sp_args++, addr_reg1);\n\n# if TARGET_LONG_BITS == 64\n\n    tcg_out_mov(s, sp_args++, addr_reg2);\n\n# endif\n\n    tcg_out_movi(s, TCG_TYPE_I32, sp_args++, mem_index);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T9, (tcg_target_long)qemu_ld_helpers[s_bits]);\n\n    tcg_out_opc_reg(s, OPC_JALR, TCG_REG_RA, TCG_REG_T9, 0);\n\n    tcg_out_nop(s);\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xff);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 24);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 24);\n\n        break;\n\n    case 1:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xffff);\n\n        break;\n\n    case 1 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 16);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 16);\n\n        break;\n\n    case 2:\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    case 3:\n\n        tcg_out_mov(s, data_reg2, TCG_REG_V1);\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    label2_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO, 0);\n\n    tcg_out_nop(s);\n\n\n\n    /* label1: fast path */\n\n    reloc_pc16(label1_ptr, (tcg_target_long) s->code_ptr);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_V0, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addend) + addr_meml);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_V0, TCG_REG_V0, addr_regl);\n\n\n\n    addr_reg1 = TCG_REG_V0;\n\n#endif\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_LBU, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_imm(s, OPC_LB, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 1:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LHU, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 1 | 4:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16s(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LH, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 2:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 3:\n\n#if !defined(CONFIG_SOFTMMU)\n\n        tcg_out_mov(s, TCG_REG_V0, addr_reg1);\n\n        addr_reg1 = TCG_REG_V0;\n\n#endif\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 4);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg2, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg2, addr_reg1, 4);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    reloc_pc16(label2_ptr, (tcg_target_long) s->code_ptr);\n\n#endif\n\n}\n", "idx": 6119}
{"project": "qemu", "commit_id": "32938e127f50a40844a0fb9c5abb8691aeeccf7e", "target": 1, "func": "static target_ulong disas_insn(DisasContext *s, target_ulong pc_start)\n\n{\n\n    int b, prefixes, aflag, dflag;\n\n    int shift, ot;\n\n    int modrm, reg, rm, mod, reg_addr, op, opreg, offset_addr, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n\n\n    if (unlikely(loglevel & CPU_LOG_TB_OP))\n\n        tcg_gen_debug_insn_start(pc_start);\n\n    s->pc = pc_start;\n\n    prefixes = 0;\n\n    aflag = s->code32;\n\n    dflag = s->code32;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n next_byte:\n\n    b = ldub_code(s->pc);\n\n    s->pc++;\n\n    /* check prefixes */\n\n#ifdef TARGET_X86_64\n\n    if (CODE64(s)) {\n\n        switch (b) {\n\n        case 0xf3:\n\n            prefixes |= PREFIX_REPZ;\n\n            goto next_byte;\n\n        case 0xf2:\n\n            prefixes |= PREFIX_REPNZ;\n\n            goto next_byte;\n\n        case 0xf0:\n\n            prefixes |= PREFIX_LOCK;\n\n            goto next_byte;\n\n        case 0x2e:\n\n            s->override = R_CS;\n\n            goto next_byte;\n\n        case 0x36:\n\n            s->override = R_SS;\n\n            goto next_byte;\n\n        case 0x3e:\n\n            s->override = R_DS;\n\n            goto next_byte;\n\n        case 0x26:\n\n            s->override = R_ES;\n\n            goto next_byte;\n\n        case 0x64:\n\n            s->override = R_FS;\n\n            goto next_byte;\n\n        case 0x65:\n\n            s->override = R_GS;\n\n            goto next_byte;\n\n        case 0x66:\n\n            prefixes |= PREFIX_DATA;\n\n            goto next_byte;\n\n        case 0x67:\n\n            prefixes |= PREFIX_ADR;\n\n            goto next_byte;\n\n        case 0x40 ... 0x4f:\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        if (rex_w == 1) {\n\n            /* 0x66 is ignored if rex.w is set */\n\n            dflag = 2;\n\n        } else {\n\n            if (prefixes & PREFIX_DATA)\n\n                dflag ^= 1;\n\n        }\n\n        if (!(prefixes & PREFIX_ADR))\n\n            aflag = 2;\n\n    } else\n\n#endif\n\n    {\n\n        switch (b) {\n\n        case 0xf3:\n\n            prefixes |= PREFIX_REPZ;\n\n            goto next_byte;\n\n        case 0xf2:\n\n            prefixes |= PREFIX_REPNZ;\n\n            goto next_byte;\n\n        case 0xf0:\n\n            prefixes |= PREFIX_LOCK;\n\n            goto next_byte;\n\n        case 0x2e:\n\n            s->override = R_CS;\n\n            goto next_byte;\n\n        case 0x36:\n\n            s->override = R_SS;\n\n            goto next_byte;\n\n        case 0x3e:\n\n            s->override = R_DS;\n\n            goto next_byte;\n\n        case 0x26:\n\n            s->override = R_ES;\n\n            goto next_byte;\n\n        case 0x64:\n\n            s->override = R_FS;\n\n            goto next_byte;\n\n        case 0x65:\n\n            s->override = R_GS;\n\n            goto next_byte;\n\n        case 0x66:\n\n            prefixes |= PREFIX_DATA;\n\n            goto next_byte;\n\n        case 0x67:\n\n            prefixes |= PREFIX_ADR;\n\n            goto next_byte;\n\n        }\n\n        if (prefixes & PREFIX_DATA)\n\n            dflag ^= 1;\n\n        if (prefixes & PREFIX_ADR)\n\n            aflag ^= 1;\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* lock generation */\n\n    if (prefixes & PREFIX_LOCK)\n\n        gen_helper_lock();\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = ldub_code(s->pc++) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = ldub_code(s->pc++);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    gen_op_movl_T0_0();\n\n                    s->cc_op = CC_OP_LOGICB + ot;\n\n                    gen_op_mov_reg_T0(ot, reg);\n\n                    gen_op_update1_cc();\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_TN_reg(ot, 1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = ldub_code(s->pc++);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                    gen_op_ld_T1_A0(ot + s->mem_index);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_TN_reg(ot, 1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(s, ot);\n\n                gen_op_movl_T1_im(val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n\n\n            modrm = ldub_code(s->pc++);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(s, OT_BYTE);\n\n                break;\n\n            }\n\n            gen_op_movl_T1_im(val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0)\n\n                s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(s, ot);\n\n            gen_op_movl_T1_im(val);\n\n            gen_op_testl_T0_T1_cc();\n\n            s->cc_op = CC_OP_LOGICB + ot;\n\n            break;\n\n        case 2: /* not */\n\n            tcg_gen_not_tl(cpu_T[0], cpu_T[0]);\n\n            if (mod != 3) {\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            } else {\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            tcg_gen_neg_tl(cpu_T[0], cpu_T[0]);\n\n            if (mod != 3) {\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            } else {\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            }\n\n            gen_op_update_neg_cc();\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext8u_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T[0], 0xff00);\n\n                s->cc_op = CC_OP_MULB;\n\n                break;\n\n            case OT_WORD:\n\n                gen_op_mov_TN_reg(OT_WORD, 1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext16u_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 16);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EDX);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n                s->cc_op = CC_OP_MULW;\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n#ifdef TARGET_X86_64\n\n                gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                tcg_gen_ext32u_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext32u_tl(cpu_T[1], cpu_T[1]);\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 32);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n#else\n\n                {\n\n                    TCGv_i64 t0, t1;\n\n                    t0 = tcg_temp_new_i64();\n\n                    t1 = tcg_temp_new_i64();\n\n                    gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                    tcg_gen_extu_i32_i64(t0, cpu_T[0]);\n\n                    tcg_gen_extu_i32_i64(t1, cpu_T[1]);\n\n                    tcg_gen_mul_i64(t0, t0, t1);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    tcg_gen_shri_i64(t0, t0, 32);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n                }\n\n#endif\n\n                s->cc_op = CC_OP_MULL;\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_helper_mulq_EAX_T0(cpu_T[0]);\n\n                s->cc_op = CC_OP_MULQ;\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext8s_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                s->cc_op = CC_OP_MULB;\n\n                break;\n\n            case OT_WORD:\n\n                gen_op_mov_TN_reg(OT_WORD, 1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext16s_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 16);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EDX);\n\n                s->cc_op = CC_OP_MULW;\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n#ifdef TARGET_X86_64\n\n                gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_T[1], cpu_T[1]);\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 32);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n#else\n\n                {\n\n                    TCGv_i64 t0, t1;\n\n                    t0 = tcg_temp_new_i64();\n\n                    t1 = tcg_temp_new_i64();\n\n                    gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                    tcg_gen_ext_i32_i64(t0, cpu_T[0]);\n\n                    tcg_gen_ext_i32_i64(t1, cpu_T[1]);\n\n                    tcg_gen_mul_i64(t0, t0, t1);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    tcg_gen_sari_tl(cpu_tmp0, cpu_T[0], 31);\n\n                    tcg_gen_shri_i64(t0, t0, 32);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n                    tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                }\n\n#endif\n\n                s->cc_op = CC_OP_MULL;\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_helper_imulq_EAX_T0(cpu_T[0]);\n\n                s->cc_op = CC_OP_MULQ;\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divb_AL(cpu_T[0]);\n\n                break;\n\n            case OT_WORD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divw_AX(cpu_T[0]);\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divl_EAX(cpu_T[0]);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divq_EAX(cpu_T[0]);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivb_AL(cpu_T[0]);\n\n                break;\n\n            case OT_WORD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivw_AX(cpu_T[0]);\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivl_EAX(cpu_T[0]);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivq_EAX(cpu_T[0]);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto illegal_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = OT_QUAD;\n\n            } else if (op == 3 || op == 5) {\n\n                /* for call calls, the operand is 16 or 32 bit, even\n\n                   in long mode */\n\n                ot = dflag ? OT_LONG : OT_WORD;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = dflag ? OT_QUAD : OT_WORD;\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (s->dflag == 0)\n\n                gen_op_andl_T0_ffff();\n\n            next_eip = s->pc - s->cs_base;\n\n            gen_movtl_T1_im(next_eip);\n\n            gen_push_T1(s);\n\n            gen_op_jmp_T0();\n\n            gen_eob(s);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n\n            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_lcall_protected(cpu_tmp2_i32, cpu_T[1],\n\n                                           tcg_const_i32(dflag), \n\n                                           tcg_const_i32(s->pc - pc_start));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_lcall_real(cpu_tmp2_i32, cpu_T[1],\n\n                                      tcg_const_i32(dflag), \n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            gen_eob(s);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (s->dflag == 0)\n\n                gen_op_andl_T0_ffff();\n\n            gen_op_jmp_T0();\n\n            gen_eob(s);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n\n            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_ljmp_protected(cpu_tmp2_i32, cpu_T[1],\n\n                                          tcg_const_i32(s->pc - pc_start));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_movl_T0_T1();\n\n                gen_op_jmp_T0();\n\n            }\n\n            gen_eob(s);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_T0(s);\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_TN_reg(ot, 1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        s->cc_op = CC_OP_LOGICB + ot;\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        val = insn_get(s, ot);\n\n\n\n        gen_op_mov_TN_reg(ot, 0, OR_EAX);\n\n        gen_op_movl_T1_im(val);\n\n        gen_op_testl_T0_T1_cc();\n\n        s->cc_op = CC_OP_LOGICB + ot;\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_QUAD, R_EAX);\n\n        } else\n\n#endif\n\n        if (dflag == 1) {\n\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n        } else {\n\n            gen_op_mov_TN_reg(OT_BYTE, 0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 63);\n\n            gen_op_mov_reg_T0(OT_QUAD, R_EDX);\n\n        } else\n\n#endif\n\n        if (dflag == 1) {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 31);\n\n            gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n        } else {\n\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 15);\n\n            gen_op_mov_reg_T0(OT_WORD, R_EDX);\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(s, ot);\n\n            gen_op_movl_T1_im(val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(s, OT_BYTE);\n\n            gen_op_movl_T1_im(val);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 1, reg);\n\n        }\n\n\n\n#ifdef TARGET_X86_64\n\n        if (ot == OT_QUAD) {\n\n            gen_helper_imulq_T0_T1(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n        } else\n\n#endif\n\n        if (ot == OT_LONG) {\n\n#ifdef TARGET_X86_64\n\n                tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_T[1], cpu_T[1]);\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n#else\n\n                {\n\n                    TCGv_i64 t0, t1;\n\n                    t0 = tcg_temp_new_i64();\n\n                    t1 = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(t0, cpu_T[0]);\n\n                    tcg_gen_ext_i32_i64(t1, cpu_T[1]);\n\n                    tcg_gen_mul_i64(t0, t0, t1);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    tcg_gen_sari_tl(cpu_tmp0, cpu_T[0], 31);\n\n                    tcg_gen_shri_i64(t0, t0, 32);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[1], t0);\n\n                    tcg_gen_sub_tl(cpu_cc_src, cpu_T[1], cpu_tmp0);\n\n                }\n\n#endif\n\n        } else {\n\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n            tcg_gen_ext16s_tl(cpu_T[1], cpu_T[1]);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T[0]);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n        }\n\n        gen_op_mov_reg_T0(ot, reg);\n\n        s->cc_op = CC_OP_MULB + ot;\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            gen_op_mov_TN_reg(ot, 1, rm);\n\n            gen_op_addl_T0_T1();\n\n            gen_op_mov_reg_T1(ot, reg);\n\n            gen_op_mov_reg_T0(ot, rm);\n\n        } else {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_op_addl_T0_T1();\n\n            gen_op_st_T0_A0(ot + s->mem_index);\n\n            gen_op_mov_reg_T1(ot, reg);\n\n        }\n\n        gen_op_update2_cc();\n\n        s->cc_op = CC_OP_ADDB + ot;\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            int label1, label2;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            a0 = tcg_temp_local_new();\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            if (mod == 3) {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n            } else {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                gen_op_ld_v(ot + s->mem_index, t0, a0);\n\n                rm = 0; /* avoid warning */\n\n            }\n\n            label1 = gen_new_label();\n\n            tcg_gen_ld_tl(t2, cpu_env, offsetof(CPUState, regs[R_EAX]));\n\n            tcg_gen_sub_tl(t2, t2, t0);\n\n            gen_extu(ot, t2);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, label1);\n\n            if (mod == 3) {\n\n                label2 = gen_new_label();\n\n                gen_op_mov_reg_v(ot, R_EAX, t0);\n\n                tcg_gen_br(label2);\n\n                gen_set_label(label1);\n\n                gen_op_mov_reg_v(ot, rm, t1);\n\n                gen_set_label(label2);\n\n            } else {\n\n                tcg_gen_mov_tl(t1, t0);\n\n                gen_op_mov_reg_v(ot, R_EAX, t0);\n\n                gen_set_label(label1);\n\n                /* always store */\n\n                gen_op_st_v(ot + s->mem_index, t1, a0);\n\n            }\n\n            tcg_gen_mov_tl(cpu_cc_src, t0);\n\n            tcg_gen_mov_tl(cpu_cc_dst, t2);\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n            tcg_temp_free(a0);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_helper_cmpxchg16b(cpu_A0);\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_helper_cmpxchg8b(cpu_A0);\n\n        }\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_TN_reg(OT_LONG, 0, (b & 7) | REX_B(s));\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s);\n\n        gen_op_mov_reg_T0(ot, (b & 7) | REX_B(s));\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        if (b == 0x68)\n\n            val = insn_get(s, ot);\n\n        else\n\n            val = (int8_t)insn_get(s, OT_BYTE);\n\n        gen_op_movl_T0_im(val);\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_T0(ot, rm);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = lduw_code(s->pc);\n\n            s->pc += 2;\n\n            level = ldub_code(s->pc++);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        /* XXX: exception not precise (ESP is updated before potential exception) */\n\n        if (CODE64(s)) {\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EBP);\n\n            gen_op_mov_reg_T0(OT_QUAD, R_ESP);\n\n        } else if (s->ss32) {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EBP);\n\n            gen_op_mov_reg_T0(OT_LONG, R_ESP);\n\n        } else {\n\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EBP);\n\n            gen_op_mov_reg_T0(OT_WORD, R_ESP);\n\n        }\n\n        gen_pop_T0(s);\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        gen_op_mov_reg_T0(ot, R_EBP);\n\n        gen_pop_update(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);\n\n        gen_pop_update(s);\n\n        if (reg == R_SS) {\n\n            /* if reg == SS, inhibit interrupts/trace. */\n\n            /* If several instructions disable interrupts, only the\n\n               _first_ does it */\n\n            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n\n                gen_helper_set_inhibit_irq();\n\n            s->tf = 0;\n\n        }\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7, pc_start - s->cs_base);\n\n        gen_pop_update(s);\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        }\n\n        val = insn_get(s, ot);\n\n        gen_op_movl_T0_im(val);\n\n        if (mod != 3)\n\n            gen_op_st_T0_A0(ot + s->mem_index);\n\n        else\n\n            gen_op_mov_reg_T0(ot, (modrm & 7) | REX_B(s));\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = OT_WORD + dflag;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_T0(ot, reg);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = ldub_code(s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);\n\n        if (reg == R_SS) {\n\n            /* if reg == SS, inhibit interrupts/trace */\n\n            /* If several instructions disable interrupts, only the\n\n               _first_ does it */\n\n            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n\n                gen_helper_set_inhibit_irq();\n\n            s->tf = 0;\n\n        }\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = ldub_code(s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        if (mod == 3)\n\n            ot = OT_WORD + dflag;\n\n        else\n\n            ot = OT_WORD;\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag + OT_WORD;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + OT_BYTE;\n\n            modrm = ldub_code(s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_TN_reg(ot, 0, rm);\n\n                switch(ot | (b & 8)) {\n\n                case OT_BYTE:\n\n                    tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                case OT_BYTE | 8:\n\n                    tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                case OT_WORD:\n\n                    tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                default:\n\n                case OT_WORD | 8:\n\n                    tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                }\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            } else {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                if (b & 8) {\n\n                    gen_op_lds_T0_A0(ot + s->mem_index);\n\n                } else {\n\n                    gen_op_ldu_T0_A0(ot + s->mem_index);\n\n                }\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* we must ensure that no segment is added */\n\n        s->override = -1;\n\n        val = s->addseg;\n\n        s->addseg = 0;\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        s->addseg = val;\n\n        gen_op_mov_reg_A0(ot - OT_WORD, reg);\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n#ifdef TARGET_X86_64\n\n            if (s->aflag == 2) {\n\n                offset_addr = ldq_code(s->pc);\n\n                s->pc += 8;\n\n                gen_op_movq_A0_im(offset_addr);\n\n            } else\n\n#endif\n\n            {\n\n                if (s->aflag) {\n\n                    offset_addr = insn_get(s, OT_LONG);\n\n                } else {\n\n                    offset_addr = insn_get(s, OT_WORD);\n\n                }\n\n                gen_op_movl_A0_im(offset_addr);\n\n            }\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_T0_A0(ot + s->mem_index);\n\n                gen_op_mov_reg_T0(ot, R_EAX);\n\n            } else {\n\n                gen_op_mov_TN_reg(ot, 0, R_EAX);\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n#ifdef TARGET_X86_64\n\n        if (s->aflag == 2) {\n\n            gen_op_movq_A0_reg(R_EBX);\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EAX);\n\n            tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xff);\n\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T[0]);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_movl_A0_reg(R_EBX);\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n\n            tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xff);\n\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T[0]);\n\n            if (s->aflag == 0)\n\n                gen_op_andl_A0_ffff();\n\n            else\n\n                tcg_gen_andi_tl(cpu_A0, cpu_A0, 0xffffffff);\n\n        }\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ldu_T0_A0(OT_BYTE + s->mem_index);\n\n        gen_op_mov_reg_T0(OT_BYTE, R_EAX);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(s, OT_BYTE);\n\n        gen_op_movl_T0_im(val);\n\n        gen_op_mov_reg_T0(OT_BYTE, (b & 7) | REX_B(s));\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = ldq_code(s->pc);\n\n            s->pc += 8;\n\n            reg = (b & 7) | REX_B(s);\n\n            gen_movtl_T0_im(tmp);\n\n            gen_op_mov_reg_T0(OT_QUAD, reg);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            val = insn_get(s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            gen_op_movl_T0_im(val);\n\n            gen_op_mov_reg_T0(ot, reg);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n        ot = dflag + OT_WORD;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            gen_op_mov_TN_reg(ot, 1, rm);\n\n            gen_op_mov_reg_T0(ot, rm);\n\n            gen_op_mov_reg_T1(ot, reg);\n\n        } else {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            /* for xchg, lock is implicit */\n\n            if (!(prefixes & PREFIX_LOCK))\n\n                gen_helper_lock();\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_op_st_T0_A0(ot + s->mem_index);\n\n            if (!(prefixes & PREFIX_LOCK))\n\n                gen_helper_unlock();\n\n            gen_op_mov_reg_T1(ot, reg);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        gen_op_ld_T1_A0(ot + s->mem_index);\n\n        gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n\n        gen_movl_seg_T0(s, op, pc_start - s->cs_base);\n\n        /* then put the data */\n\n        gen_op_mov_reg_T1(ot, reg);\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n\n\n            modrm = ldub_code(s->pc++);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = ldub_code(s->pc++);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_TN_reg(ot, 1, reg);\n\n\n\n        if (shift) {\n\n            val = ldub_code(s->pc++);\n\n            tcg_gen_movi_tl(cpu_T3, val);\n\n        } else {\n\n            tcg_gen_ld_tl(cpu_T3, cpu_env, offsetof(CPUState, regs[R_ECX]));\n\n        }\n\n        gen_shiftd_rm_T1_T3(s, ot, opreg, op);\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_flds_FT0(cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_FT0(cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        gen_helper_fldl_FT0(cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_op_lds_T0_A0(OT_WORD + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_FT0(cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop();\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_flds_ST0(cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_ST0(cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        gen_helper_fldl_ST0(cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_op_lds_T0_A0(OT_WORD + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_ST0(cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64);\n\n                        tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop();\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64);\n\n                        tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop();\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fldenv(\n\n                                   cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                gen_op_ld_T0_A0(OT_WORD + s->mem_index);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_fldcw(cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fstenv(cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fldt_ST0(cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fstt_ST0(cpu_A0);\n\n                gen_helper_fpop();\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_frstor(cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fsave(cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fbld_ST0(cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fbst_ST0(cpu_A0);\n\n                gen_helper_fpop();\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n\n                                  (s->mem_index >> 2) - 1);\n\n                gen_helper_fildll_ST0(cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64);\n\n                tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n\n                                  (s->mem_index >> 2) - 1);\n\n                gen_helper_fpop();\n\n                break;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush();\n\n                gen_helper_fmov_ST0_STN(tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    if (s->cc_op != CC_OP_DYNAMIC)\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n                    gen_helper_fwait();\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0();\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0();\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0();\n\n                    gen_helper_fcom_ST0_FT0();\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0();\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush();\n\n                        gen_helper_fld1_ST0();\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush();\n\n                        gen_helper_fldl2t_ST0();\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush();\n\n                        gen_helper_fldl2e_ST0();\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush();\n\n                        gen_helper_fldpi_ST0();\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush();\n\n                        gen_helper_fldlg2_ST0();\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush();\n\n                        gen_helper_fldln2_ST0();\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush();\n\n                        gen_helper_fldz_ST0();\n\n                        break;\n\n                    default:\n\n                        goto illegal_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1();\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x();\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan();\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan();\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract();\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1();\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp();\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp();\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem();\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1();\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt();\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos();\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale();\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint();\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin();\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos();\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop();\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0();\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0();\n\n                gen_helper_fpop();\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0();\n\n                    gen_helper_fpop();\n\n                    gen_helper_fpop();\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex();\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit();\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0();\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0();\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(tcg_const_i32(opreg));\n\n                gen_helper_fpop();\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0();\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0();\n\n                gen_helper_fpop();\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0();\n\n                    gen_helper_fpop();\n\n                    gen_helper_fpop();\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(tcg_const_i32(opreg));\n\n                gen_helper_fpop();\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32);\n\n                    tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                    gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0();\n\n                gen_helper_fpop();\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0();\n\n                gen_helper_fpop();\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1, l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1(s, s->cc_op, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (use_icount) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (use_icount) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        val = ldub_code(s->pc++);\n\n        gen_op_movl_T0_im(val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);\n\n        gen_op_mov_reg_T1(ot, R_EAX);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        val = ldub_code(s->pc++);\n\n        gen_op_movl_T0_im(val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_TN_reg(ot, 1, R_EAX);\n\n\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);\n\n        gen_op_mov_reg_T1(ot, R_EAX);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_TN_reg(ot, 1, R_EAX);\n\n\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = ldsw_code(s->pc);\n\n        s->pc += 2;\n\n        gen_pop_T0(s);\n\n        if (CODE64(s) && s->dflag)\n\n            s->dflag = 2;\n\n        gen_stack_update(s, val + (2 << s->dflag));\n\n        if (s->dflag == 0)\n\n            gen_op_andl_T0_ffff();\n\n        gen_op_jmp_T0();\n\n        gen_eob(s);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        gen_pop_T0(s);\n\n        gen_pop_update(s);\n\n        if (s->dflag == 0)\n\n            gen_op_andl_T0_ffff();\n\n        gen_op_jmp_T0();\n\n        gen_eob(s);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = ldsw_code(s->pc);\n\n        s->pc += 2;\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(tcg_const_i32(s->dflag),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);\n\n            if (s->dflag == 0)\n\n                gen_op_andl_T0_ffff();\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_T0();\n\n            /* pop selector */\n\n            gen_op_addl_A0_im(2 << s->dflag);\n\n            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (4 << s->dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(tcg_const_i32(s->dflag));\n\n            s->cc_op = CC_OP_EFLAGS;\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(tcg_const_i32(s->dflag));\n\n                s->cc_op = CC_OP_EFLAGS;\n\n            }\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_iret_protected(tcg_const_i32(s->dflag), \n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            s->cc_op = CC_OP_EFLAGS;\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag)\n\n                tval = (int32_t)insn_get(s, OT_LONG);\n\n            else\n\n                tval = (int16_t)insn_get(s, OT_WORD);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (s->dflag == 0)\n\n                tval &= 0xffff;\n\n            gen_movtl_T0_im(next_eip);\n\n            gen_push_T0(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            offset = insn_get(s, ot);\n\n            selector = insn_get(s, OT_WORD);\n\n\n\n            gen_op_movl_T0_im(selector);\n\n            gen_op_movl_T1_imu(offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag)\n\n            tval = (int32_t)insn_get(s, OT_LONG);\n\n        else\n\n            tval = (int16_t)insn_get(s, OT_WORD);\n\n        tval += s->pc - s->cs_base;\n\n        if (s->dflag == 0)\n\n            tval &= 0xffff;\n\n\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            offset = insn_get(s, ot);\n\n            selector = insn_get(s, OT_WORD);\n\n\n\n            gen_op_movl_T0_im(selector);\n\n            gen_op_movl_T1_imu(offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(s, OT_BYTE);\n\n        tval += s->pc - s->cs_base;\n\n        if (s->dflag == 0)\n\n            tval &= 0xffff;\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(s, OT_BYTE);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag) {\n\n            tval = (int32_t)insn_get(s, OT_LONG);\n\n        } else {\n\n            tval = (int16_t)insn_get(s, OT_WORD);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (s->dflag == 0)\n\n            tval &= 0xffff;\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = ldub_code(s->pc++);\n\n        gen_setcc(s, b);\n\n        gen_ldst_modrm(s, modrm, OT_BYTE, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        {\n\n            int l1;\n\n            TCGv t0;\n\n\n\n            ot = dflag + OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            t0 = tcg_temp_local_new();\n\n            if (mod != 3) {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                gen_op_ld_v(ot + s->mem_index, t0, cpu_A0);\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (ot == OT_LONG) {\n\n                /* XXX: specific Intel behaviour ? */\n\n                l1 = gen_new_label();\n\n                gen_jcc1(s, s->cc_op, b ^ 1, l1);\n\n                tcg_gen_st32_tl(t0, cpu_env, offsetof(CPUState, regs[reg]) + REG_L_OFFSET);\n\n                gen_set_label(l1);\n\n                tcg_gen_movi_tl(cpu_tmp0, 0);\n\n                tcg_gen_st32_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[reg]) + REG_LH_OFFSET);\n\n            } else\n\n#endif\n\n            {\n\n                l1 = gen_new_label();\n\n                gen_jcc1(s, s->cc_op, b ^ 1, l1);\n\n                gen_op_mov_reg_v(ot, reg, t0);\n\n                gen_set_label(l1);\n\n            }\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_helper_read_eflags(cpu_T[0]);\n\n            gen_push_T0(s);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (s->dflag) {\n\n                    gen_helper_write_eflags(cpu_T[0],\n\n                                       tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_T[0],\n\n                                       tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK) & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (s->dflag) {\n\n                        gen_helper_write_eflags(cpu_T[0],\n\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_T[0],\n\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK) & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (s->dflag) {\n\n                        gen_helper_write_eflags(cpu_T[0],\n\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_T[0],\n\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK) & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s);\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            /* abort translation because TF flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_TN_reg(OT_BYTE, 0, R_AH);\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T[0], cpu_T[0], CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T[0]);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_T[0]);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T[0], cpu_T[0], 0x02);\n\n        gen_op_mov_reg_T0(OT_BYTE, R_AH);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xf8: /* clc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xf9: /* stc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUState, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUState, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n        /* load shift */\n\n        val = ldub_code(s->pc++);\n\n        gen_op_movl_T1_im(val);\n\n        if (op < 4)\n\n            goto illegal_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_TN_reg(OT_LONG, 1, reg);\n\n        if (mod != 3) {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T[1]);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T[1], 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);\n\n            gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T[1], cpu_T[1], (1 << (3 + ot)) - 1);\n\n        switch(op) {\n\n        case 0:\n\n            tcg_gen_shr_tl(cpu_cc_src, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n\n            break;\n\n        case 1:\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n\n            tcg_gen_or_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n\n            break;\n\n        case 2:\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n\n            tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n            tcg_gen_and_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n\n            break;\n\n        default:\n\n        case 3:\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n\n            tcg_gen_xor_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n\n            break;\n\n        }\n\n        s->cc_op = CC_OP_SARB + ot;\n\n        if (op != 0) {\n\n            if (mod != 3)\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            else\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf */\n\n    case 0x1bd: /* bsr */\n\n        {\n\n            int label1;\n\n            TCGv t0;\n\n\n\n            ot = dflag + OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n            gen_extu(ot, cpu_T[0]);\n\n            label1 = gen_new_label();\n\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n\n            t0 = tcg_temp_local_new();\n\n            tcg_gen_mov_tl(t0, cpu_T[0]);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, label1);\n\n            if (b & 1) {\n\n                gen_helper_bsr(cpu_T[0], t0);\n\n            } else {\n\n                gen_helper_bsf(cpu_T[0], t0);\n\n            }\n\n            gen_op_mov_reg_T0(ot, reg);\n\n            tcg_gen_movi_tl(cpu_cc_dst, 1);\n\n            gen_set_label(label1);\n\n            tcg_gen_discard_tl(cpu_cc_src);\n\n            s->cc_op = CC_OP_LOGICB + ot;\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_daa();\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_das();\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_aaa();\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_aas();\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = ldub_code(s->pc++);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(tcg_const_i32(val));\n\n            s->cc_op = CC_OP_LOGICB;\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = ldub_code(s->pc++);\n\n        gen_helper_aad(tcg_const_i32(val));\n\n        s->cc_op = CC_OP_LOGICB;\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: xchg + rex handling */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK)\n\n            goto illegal_op;\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_PAUSE);\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_fwait();\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = ldub_code(s->pc++);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(cpu_single_env);\n\n        cpu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli();\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli();\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n            gen_sti:\n\n                gen_helper_sti();\n\n                /* interruptions are enabled only the first insn after sti */\n\n                /* If several instructions disable interrupts, only the\n\n                   _first_ does it */\n\n                if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n\n                    gen_helper_set_inhibit_irq();\n\n                /* give a chance to handle pending irqs */\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                goto gen_sti;\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_TN_reg(ot, 0, reg);\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        if (ot == OT_WORD)\n\n            gen_helper_boundw(cpu_A0, cpu_tmp2_i32);\n\n        else\n\n            gen_helper_boundl(cpu_A0, cpu_tmp2_i32);\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, reg);\n\n            tcg_gen_bswap_i64(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_QUAD, reg);\n\n        } else\n\n        {\n\n            TCGv_i32 tmp0;\n\n            gen_op_mov_TN_reg(OT_LONG, 0, reg);\n\n            \n\n            tmp0 = tcg_temp_new_i32();\n\n            tcg_gen_trunc_i64_i32(tmp0, cpu_T[0]);\n\n            tcg_gen_bswap_i32(tmp0, tmp0);\n\n            tcg_gen_extu_i32_i64(cpu_T[0], tmp0);\n\n            gen_op_mov_reg_T0(OT_LONG, reg);\n\n        }\n\n#else\n\n        {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, reg);\n\n            tcg_gen_bswap_i32(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_LONG, reg);\n\n        }\n\n#endif\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags_c(cpu_T[0]);\n\n        tcg_gen_neg_tl(cpu_T[0], cpu_T[0]);\n\n        gen_op_mov_reg_T0(OT_BYTE, R_EAX);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            int l1, l2, l3;\n\n\n\n            tval = (int8_t)insn_get(s, OT_BYTE);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (s->dflag == 0)\n\n                tval &= 0xffff;\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_compute_eflags(cpu_tmp0);\n\n                tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, CC_Z);\n\n                if (b == 0) {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, l1);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_tmp0, 0, l1);\n\n                }\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr();\n\n            } else {\n\n                gen_helper_wrmsr();\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (use_icount)\n\n            gen_io_start();\n\n        gen_helper_rdtsc();\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc();\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC) {\n\n                gen_op_set_cc_op(s->cc_op);\n\n                s->cc_op = CC_OP_DYNAMIC;\n\n            }\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_sysenter();\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC) {\n\n                gen_op_set_cc_op(s->cc_op);\n\n                s->cc_op = CC_OP_DYNAMIC;\n\n            }\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_sysexit(tcg_const_i32(dflag));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        if (s->cc_op != CC_OP_DYNAMIC) {\n\n            gen_op_set_cc_op(s->cc_op);\n\n            s->cc_op = CC_OP_DYNAMIC;\n\n        }\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(tcg_const_i32(s->pc - pc_start));\n\n        gen_eob(s);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC) {\n\n                gen_op_set_cc_op(s->cc_op);\n\n                s->cc_op = CC_OP_DYNAMIC;\n\n            }\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_sysret(tcg_const_i32(s->dflag));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma)\n\n                s->cc_op = CC_OP_EFLAGS;\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid();\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(tcg_const_i32(s->pc - pc_start));\n\n            s->is_jmp = 3;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,ldt.selector));\n\n            ot = OT_WORD;\n\n            if (mod == 3)\n\n                ot += s->dflag;\n\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_lldt(cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,tr.selector));\n\n            ot = OT_WORD;\n\n            if (mod == 3)\n\n                ot += s->dflag;\n\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_ltr(cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            if (op == 4)\n\n                gen_helper_verr(cpu_T[0]);\n\n            else\n\n                gen_helper_verw(cpu_T[0]);\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n    case 0x101:\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        rm = modrm & 7;\n\n        switch(op) {\n\n        case 0: /* sgdt */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (!s->dflag)\n\n                gen_op_andl_T0_im(0xffffff);\n\n            gen_op_st_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n\n            break;\n\n        case 1:\n\n            if (mod == 3) {\n\n                switch (rm) {\n\n                case 0: /* monitor */\n\n                    if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) ||\n\n                        s->cpl != 0)\n\n                        goto illegal_op;\n\n                    if (s->cc_op != CC_OP_DYNAMIC)\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n#ifdef TARGET_X86_64\n\n                    if (s->aflag == 2) {\n\n                        gen_op_movq_A0_reg(R_EAX);\n\n                    } else\n\n#endif\n\n                    {\n\n                        gen_op_movl_A0_reg(R_EAX);\n\n                        if (s->aflag == 0)\n\n                            gen_op_andl_A0_ffff();\n\n                    }\n\n                    gen_add_A0_ds_seg(s);\n\n                    gen_helper_monitor(cpu_A0);\n\n                    break;\n\n                case 1: /* mwait */\n\n                    if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) ||\n\n                        s->cpl != 0)\n\n                        goto illegal_op;\n\n                    if (s->cc_op != CC_OP_DYNAMIC) {\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                        s->cc_op = CC_OP_DYNAMIC;\n\n                    }\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n                    gen_helper_mwait(tcg_const_i32(s->pc - pc_start));\n\n                    gen_eob(s);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            } else { /* sidt */\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, idt.limit));\n\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                gen_add_A0_im(s, 2);\n\n                tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, idt.base));\n\n                if (!s->dflag)\n\n                    gen_op_andl_T0_im(0xffffff);\n\n                gen_op_st_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n\n            }\n\n            break;\n\n        case 2: /* lgdt */\n\n        case 3: /* lidt */\n\n            if (mod == 3) {\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                switch(rm) {\n\n                case 0: /* VMRUN */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_vmrun(tcg_const_i32(s->aflag),\n\n                                         tcg_const_i32(s->pc - pc_start));\n\n                        tcg_gen_exit_tb(0);\n\n                        s->is_jmp = 3;\n\n                    }\n\n                    break;\n\n                case 1: /* VMMCALL */\n\n                    if (!(s->flags & HF_SVME_MASK))\n\n                        goto illegal_op;\n\n                    gen_helper_vmmcall();\n\n                    break;\n\n                case 2: /* VMLOAD */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_vmload(tcg_const_i32(s->aflag));\n\n                    }\n\n                    break;\n\n                case 3: /* VMSAVE */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_vmsave(tcg_const_i32(s->aflag));\n\n                    }\n\n                    break;\n\n                case 4: /* STGI */\n\n                    if ((!(s->flags & HF_SVME_MASK) &&\n\n                         !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || \n\n                        !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_stgi();\n\n                    }\n\n                    break;\n\n                case 5: /* CLGI */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_clgi();\n\n                    }\n\n                    break;\n\n                case 6: /* SKINIT */\n\n                    if ((!(s->flags & HF_SVME_MASK) && \n\n                         !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || \n\n                        !s->pe)\n\n                        goto illegal_op;\n\n                    gen_helper_skinit();\n\n                    break;\n\n                case 7: /* INVLPGA */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_invlpga(tcg_const_i32(s->aflag));\n\n                    }\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            } else if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start,\n\n                                        op==2 ? SVM_EXIT_GDTR_WRITE : SVM_EXIT_IDTR_WRITE);\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                gen_op_ld_T1_A0(OT_WORD + s->mem_index);\n\n                gen_add_A0_im(s, 2);\n\n                gen_op_ld_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n\n                if (!s->dflag)\n\n                    gen_op_andl_T0_im(0xffffff);\n\n                if (op == 2) {\n\n                    tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,gdt.base));\n\n                    tcg_gen_st32_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,gdt.limit));\n\n                } else {\n\n                    tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,idt.base));\n\n                    tcg_gen_st32_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,idt.limit));\n\n                }\n\n            }\n\n            break;\n\n        case 4: /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,cr[0]));\n\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 1);\n\n            break;\n\n        case 6: /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n                gen_helper_lmsw(cpu_T[0]);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            }\n\n            break;\n\n        case 7: /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                if (mod == 3) {\n\n#ifdef TARGET_X86_64\n\n                    if (CODE64(s) && rm == 0) {\n\n                        /* swapgs */\n\n                        tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[R_GS].base));\n\n                        tcg_gen_ld_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,kernelgsbase));\n\n                        tcg_gen_st_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,segs[R_GS].base));\n\n                        tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,kernelgsbase));\n\n                    } else\n\n#endif\n\n                    {\n\n                        goto illegal_op;\n\n                    }\n\n                } else {\n\n                    if (s->cc_op != CC_OP_DYNAMIC)\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                    gen_helper_invlpg(cpu_A0);\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag + OT_WORD;\n\n\n\n            modrm = ldub_code(s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_TN_reg(OT_LONG, 0, rm);\n\n                /* sign extend */\n\n                if (d_ot == OT_QUAD)\n\n                    tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            } else {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                if (d_ot == OT_QUAD) {\n\n                    gen_op_lds_T0_A0(OT_LONG + s->mem_index);\n\n                } else {\n\n                    gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                }\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            int label1;\n\n            TCGv t0, t1, t2;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                gen_op_ld_v(ot + s->mem_index, t0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(ot + s->mem_index, t0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_compute_eflags(cpu_cc_src);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            int label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            if (b == 0x102)\n\n                gen_helper_lar(t0, cpu_T[0]);\n\n            else\n\n                gen_helper_lsl(t0, cpu_T[0]);\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x119 ... 0x11f: /* nop (multi byte) */\n\n        modrm = ldub_code(s->pc++);\n\n        gen_nop_modrm(s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = ldub_code(s->pc++);\n\n            if ((modrm & 0xc0) != 0xc0)\n\n                goto illegal_op;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = OT_QUAD;\n\n            else\n\n                ot = OT_LONG;\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    gen_op_mov_TN_reg(ot, 0, rm);\n\n                    gen_helper_write_crN(tcg_const_i32(reg), cpu_T[0]);\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    gen_helper_read_crN(cpu_T[0], tcg_const_i32(reg));\n\n                    gen_op_mov_reg_T0(ot, rm);\n\n                }\n\n                break;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = ldub_code(s->pc++);\n\n            if ((modrm & 0xc0) != 0xc0)\n\n                goto illegal_op;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = OT_QUAD;\n\n            else\n\n                ot = OT_LONG;\n\n            /* XXX: do it dynamically with CR4.DE bit */\n\n            if (reg == 4 || reg == 5 || reg >= 8)\n\n                goto illegal_op;\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_TN_reg(ot, 0, rm);\n\n                gen_helper_movl_drN_T0(tcg_const_i32(reg), cpu_T[0]);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,dr[reg]));\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts();\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = s->dflag == 2 ? OT_QUAD : OT_LONG;\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* fxsave */\n\n            if (mod == 3 || !(s->cpuid_features & CPUID_FXSR) ||\n\n                (s->flags & HF_EM_MASK))\n\n                goto illegal_op;\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_fxsave(cpu_A0, tcg_const_i32((s->dflag == 2)));\n\n            break;\n\n        case 1: /* fxrstor */\n\n            if (mod == 3 || !(s->cpuid_features & CPUID_FXSR) ||\n\n                (s->flags & HF_EM_MASK))\n\n                goto illegal_op;\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_fxrstor(cpu_A0, tcg_const_i32((s->dflag == 2)));\n\n            break;\n\n        case 2: /* ldmxcsr */\n\n        case 3: /* stmxcsr */\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK) ||\n\n                mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (op == 2) {\n\n                gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, mxcsr));\n\n            } else {\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, mxcsr));\n\n                gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n            }\n\n            break;\n\n        case 5: /* lfence */\n\n        case 6: /* mfence */\n\n            if ((modrm & 0xc7) != 0xc0 || !(s->cpuid_features & CPUID_SSE))\n\n                goto illegal_op;\n\n            break;\n\n        case 7: /* sfence / clflush */\n\n            if ((modrm & 0xc7) == 0xc0) {\n\n                /* sfence */\n\n                /* XXX: also check for cpuid_ext2_features & CPUID_EXT2_EMMX */\n\n                if (!(s->cpuid_features & CPUID_SSE))\n\n                    goto illegal_op;\n\n            } else {\n\n                /* clflush */\n\n                if (!(s->cpuid_features & CPUID_CLFLUSH))\n\n                    goto illegal_op;\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            }\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = ldub_code(s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        /* ignore for now */\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC) {\n\n            gen_op_set_cc_op(s->cc_op);\n\n            s->cc_op = CC_OP_DYNAMIC;\n\n        }\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm();\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = ldub_code(s->pc++);\n\n        reg = ((modrm >> 3) & 7);\n\n\n\n        if (s->prefix & PREFIX_DATA)\n\n            ot = OT_WORD;\n\n        else if (s->dflag != 2)\n\n            ot = OT_LONG;\n\n        else\n\n            ot = OT_QUAD;\n\n\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        gen_helper_popcnt(cpu_T[0], cpu_T[0], tcg_const_i32(ot));\n\n        gen_op_mov_reg_T0(ot, reg);\n\n\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x177:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto illegal_op;\n\n    }\n\n    /* lock generation */\n\n    if (s->prefix & PREFIX_LOCK)\n\n        gen_helper_unlock();\n\n    return s->pc;\n\n illegal_op:\n\n    if (s->prefix & PREFIX_LOCK)\n\n        gen_helper_unlock();\n\n    /* XXX: ensure that no lock was generated */\n\n    gen_exception(s, EXCP06_ILLOP, pc_start - s->cs_base);\n\n    return s->pc;\n\n}", "idx": 6100}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static inline void gen_ins(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_start();\n\n    }\n\n    gen_string_movl_A0_EDI(s);\n\n    /* Note: we must do this dummy write first to be restartable in\n\n       case of page fault. */\n\n    tcg_gen_movi_tl(cpu_T0, 0);\n\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    gen_helper_in_func(ot, cpu_T0, cpu_tmp2_i32);\n\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_EDI);\n\n    gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_end();\n\n    }\n\n}\n", "idx": 9973}
{"project": "qemu", "commit_id": "6c2934db949aa259ed47b126b5c6838ac57a3f6f", "target": 1, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    int l, io_index;\n\n    uint8_t *ptr;\n\n    uint32_t val;\n\n    target_phys_addr_t page;\n\n    unsigned long pd;\n\n    PhysPageDesc *p;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        p = phys_page_find(page >> TARGET_PAGE_BITS);\n\n        if (!p) {\n\n            pd = IO_MEM_UNASSIGNED;\n\n        } else {\n\n            pd = p->phys_offset;\n\n        }\n\n\n\n        if (is_write) {\n\n            if ((pd & ~TARGET_PAGE_MASK) != IO_MEM_RAM) {\n\n                io_index = (pd >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n                if (p)\n\n                    addr = (addr & ~TARGET_PAGE_MASK) + p->region_offset;\n\n                /* XXX: could force cpu_single_env to NULL to avoid\n\n                   potential bugs */\n\n                if (l >= 4 && ((addr & 3) == 0)) {\n\n                    /* 32 bit write access */\n\n                    val = ldl_p(buf);\n\n                    io_mem_write[io_index][2](io_mem_opaque[io_index], addr, val);\n\n                    l = 4;\n\n                } else if (l >= 2 && ((addr & 1) == 0)) {\n\n                    /* 16 bit write access */\n\n                    val = lduw_p(buf);\n\n                    io_mem_write[io_index][1](io_mem_opaque[io_index], addr, val);\n\n                    l = 2;\n\n                } else {\n\n                    /* 8 bit write access */\n\n                    val = ldub_p(buf);\n\n                    io_mem_write[io_index][0](io_mem_opaque[io_index], addr, val);\n\n                    l = 1;\n\n                }\n\n            } else {\n\n                unsigned long addr1;\n\n                addr1 = (pd & TARGET_PAGE_MASK) + (addr & ~TARGET_PAGE_MASK);\n\n                /* RAM case */\n\n                ptr = phys_ram_base + addr1;\n\n                memcpy(ptr, buf, l);\n\n                if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                    /* invalidate code */\n\n                    tb_invalidate_phys_page_range(addr1, addr1 + l, 0);\n\n                    /* set dirty bit */\n\n                    phys_ram_dirty[addr1 >> TARGET_PAGE_BITS] |=\n\n                        (0xff & ~CODE_DIRTY_FLAG);\n\n                }\n\n            }\n\n        } else {\n\n            if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM &&\n\n                !(pd & IO_MEM_ROMD)) {\n\n                /* I/O case */\n\n                io_index = (pd >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n                if (p)\n\n                    addr = (addr & ~TARGET_PAGE_MASK) + p->region_offset;\n\n                if (l >= 4 && ((addr & 3) == 0)) {\n\n                    /* 32 bit read access */\n\n                    val = io_mem_read[io_index][2](io_mem_opaque[io_index], addr);\n\n                    stl_p(buf, val);\n\n                    l = 4;\n\n                } else if (l >= 2 && ((addr & 1) == 0)) {\n\n                    /* 16 bit read access */\n\n                    val = io_mem_read[io_index][1](io_mem_opaque[io_index], addr);\n\n                    stw_p(buf, val);\n\n                    l = 2;\n\n                } else {\n\n                    /* 8 bit read access */\n\n                    val = io_mem_read[io_index][0](io_mem_opaque[io_index], addr);\n\n                    stb_p(buf, val);\n\n                    l = 1;\n\n                }\n\n            } else {\n\n                /* RAM case */\n\n                ptr = phys_ram_base + (pd & TARGET_PAGE_MASK) +\n\n                    (addr & ~TARGET_PAGE_MASK);\n\n                memcpy(buf, ptr, l);\n\n            }\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}\n", "idx": 2282}
{"project": "qemu", "commit_id": "8af00205445eb901f17ca5b632d976065187538e", "target": 1, "func": "ssize_t v9fs_get_xattr(FsContext *ctx, const char *path,\n\n                       const char *name, void *value, size_t size)\n\n{\n\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n\n    if (xops) {\n\n        return xops->getxattr(ctx, path, name, value, size);\n\n    }\n\n    errno = -EOPNOTSUPP;\n\n    return -1;\n\n}\n", "idx": 4608}
{"project": "qemu", "commit_id": "ce78d18ced118b03e821135e702ba1d513c8b2a7", "target": 1, "func": "void qemu_clock_warp(QEMUClockType type)\n\n{\n\n    int64_t deadline;\n\n\n\n    /*\n\n     * There are too many global variables to make the \"warp\" behavior\n\n     * applicable to other clocks.  But a clock argument removes the\n\n     * need for if statements all over the place.\n\n     */\n\n    if (type != QEMU_CLOCK_VIRTUAL || !use_icount) {\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * If the CPUs have been sleeping, advance QEMU_CLOCK_VIRTUAL timer now.\n\n     * This ensures that the deadline for the timer is computed correctly below.\n\n     * This also makes sure that the insn counter is synchronized before the\n\n     * CPU starts running, in case the CPU is woken by an event other than\n\n     * the earliest QEMU_CLOCK_VIRTUAL timer.\n\n     */\n\n    icount_warp_rt(NULL);\n\n    if (!all_cpu_threads_idle() || !qemu_clock_has_timers(QEMU_CLOCK_VIRTUAL)) {\n\n        timer_del(icount_warp_timer);\n\n        return;\n\n    }\n\n\n\n    if (qtest_enabled()) {\n\n        /* When testing, qtest commands advance icount.  */\n\n\treturn;\n\n    }\n\n\n\n    vm_clock_warp_start = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    /* We want to use the earliest deadline from ALL vm_clocks */\n\n    deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* Maintain prior (possibly buggy) behaviour where if no deadline\n\n     * was set (as there is no QEMU_CLOCK_VIRTUAL timer) or it is more than\n\n     * INT32_MAX nanoseconds ahead, we still use INT32_MAX\n\n     * nanoseconds.\n\n     */\n\n    if ((deadline < 0) || (deadline > INT32_MAX)) {\n\n        deadline = INT32_MAX;\n\n    }\n\n\n\n    if (deadline > 0) {\n\n        /*\n\n         * Ensure QEMU_CLOCK_VIRTUAL proceeds even when the virtual CPU goes to\n\n         * sleep.  Otherwise, the CPU might be waiting for a future timer\n\n         * interrupt to wake it up, but the interrupt never comes because\n\n         * the vCPU isn't running any insns and thus doesn't advance the\n\n         * QEMU_CLOCK_VIRTUAL.\n\n         *\n\n         * An extreme solution for this problem would be to never let VCPUs\n\n         * sleep in icount mode if there is a pending QEMU_CLOCK_VIRTUAL\n\n         * timer; rather time could just advance to the next QEMU_CLOCK_VIRTUAL\n\n         * event.  Instead, we do stop VCPUs and only advance QEMU_CLOCK_VIRTUAL\n\n         * after some e\"real\" time, (related to the time left until the next\n\n         * event) has passed. The QEMU_CLOCK_REALTIME timer will do this.\n\n         * This avoids that the warps are visible externally; for example,\n\n         * you will not be sending network packets continuously instead of\n\n         * every 100ms.\n\n         */\n\n        timer_mod(icount_warp_timer, vm_clock_warp_start + deadline);\n\n    } else if (deadline == 0) {\n\n        qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n\n    }\n\n}\n", "idx": 1133}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_pull(gnutls_transport_ptr_t transport,\n\n                            void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = qemu_recv(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 9354}
{"project": "qemu", "commit_id": "e17a87792d4886d2a508672c1639df3c1d40f1d1", "target": 1, "func": "char *spapr_get_cpu_core_type(const char *model)\n\n{\n\n    char *core_type;\n\n    gchar **model_pieces = g_strsplit(model, \",\", 2);\n\n\n\n    core_type = g_strdup_printf(\"%s-%s\", model_pieces[0], TYPE_SPAPR_CPU_CORE);\n\n    g_strfreev(model_pieces);\n\n\n\n    /* Check whether it exists or whether we have to look up an alias name */\n\n    if (!object_class_by_name(core_type)) {\n\n        const char *realmodel;\n\n\n\n        g_free(core_type);\n\n        realmodel = ppc_cpu_lookup_alias(model);\n\n        if (realmodel) {\n\n            return spapr_get_cpu_core_type(realmodel);\n\n        }\n\n        return NULL;\n\n    }\n\n\n\n    return core_type;\n\n}\n", "idx": 8822}
{"project": "qemu", "commit_id": "651060aba79dc9d0cc77ac3921948ea78dba7409", "target": 1, "func": "static uint32_t ppc_hash64_pte_size_decode(uint64_t pte1, uint32_t slb_pshift)\n\n{\n\n    switch (slb_pshift) {\n\n    case 12:\n\n        return 12;\n\n    case 16:\n\n        if ((pte1 & 0xf000) == 0x1000) {\n\n            return 16;\n\n        }\n\n        return 0;\n\n    case 24:\n\n        if ((pte1 & 0xff000) == 0) {\n\n            return 24;\n\n        }\n\n        return 0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6654}
{"project": "qemu", "commit_id": "3f66aa9c07d6392757f9d7b83849c7f791981725", "target": 1, "func": "ISADevice *isa_create(const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (!isabus) {\n\n        fprintf(stderr, \"Tried to create isa device %s with no isa bus present.\\n\", name);\n\n        return NULL;\n\n    }\n\n    dev = qdev_create(&isabus->qbus, name);\n\n    return DO_UPCAST(ISADevice, qdev, dev);\n\n}\n", "idx": 9118}
{"project": "qemu", "commit_id": "b835e919f022d768abdf00e8dc94f1a23fdcab15", "target": 1, "func": "static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 2461}
{"project": "qemu", "commit_id": "2634ab7fe29b3f75d0865b719caf8f310d634aae", "target": 1, "func": "static void pci_nic_uninit(PCIDevice *pci_dev)\n\n{\n\n    EEPRO100State *s = DO_UPCAST(EEPRO100State, dev, pci_dev);\n\n\n\n    vmstate_unregister(&pci_dev->qdev, s->vmstate, s);\n\n\n    eeprom93xx_free(&pci_dev->qdev, s->eeprom);\n\n    qemu_del_nic(s->nic);\n\n}", "idx": 10159}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "void helper_fxrstor(CPUX86State *env, target_ulong ptr, int data64)\n\n{\n\n    int i, fpus, fptag, nb_xmm_regs;\n\n    floatx80 tmp;\n\n    target_ulong addr;\n\n\n\n    /* The operand must be 16 byte aligned */\n\n    if (ptr & 0xf) {\n\n        raise_exception(env, EXCP0D_GPF);\n\n    }\n\n\n\n    env->fpuc = cpu_lduw_data(env, ptr);\n\n    fpus = cpu_lduw_data(env, ptr + 2);\n\n    fptag = cpu_lduw_data(env, ptr + 4);\n\n    env->fpstt = (fpus >> 11) & 7;\n\n    env->fpus = fpus & ~0x3800;\n\n    fptag ^= 0xff;\n\n    for (i = 0; i < 8; i++) {\n\n        env->fptags[i] = ((fptag >> i) & 1);\n\n    }\n\n\n\n    addr = ptr + 0x20;\n\n    for (i = 0; i < 8; i++) {\n\n        tmp = helper_fldt(env, addr);\n\n        ST(i) = tmp;\n\n        addr += 16;\n\n    }\n\n\n\n    if (env->cr[4] & CR4_OSFXSR_MASK) {\n\n        /* XXX: finish it */\n\n        env->mxcsr = cpu_ldl_data(env, ptr + 0x18);\n\n        /* cpu_ldl_data(env, ptr + 0x1c); */\n\n        if (env->hflags & HF_CS64_MASK) {\n\n            nb_xmm_regs = 16;\n\n        } else {\n\n            nb_xmm_regs = 8;\n\n        }\n\n        addr = ptr + 0xa0;\n\n        /* Fast FXRESTORE leaves out the XMM registers */\n\n        if (!(env->efer & MSR_EFER_FFXSR)\n\n            || (env->hflags & HF_CPL_MASK)\n\n            || !(env->hflags & HF_LMA_MASK)) {\n\n            for (i = 0; i < nb_xmm_regs; i++) {\n\n                env->xmm_regs[i].XMM_Q(0) = cpu_ldq_data(env, addr);\n\n                env->xmm_regs[i].XMM_Q(1) = cpu_ldq_data(env, addr + 8);\n\n                addr += 16;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 8877}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque,\n\n                                         uint64_t flags)\n\n{\n\n    RDMAControlHeader reg_resp = { .len = sizeof(RDMARegisterResult),\n\n                               .type = RDMA_CONTROL_REGISTER_RESULT,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader unreg_resp = { .len = 0,\n\n                               .type = RDMA_CONTROL_UNREGISTER_FINISHED,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader blocks = { .type = RDMA_CONTROL_RAM_BLOCKS_RESULT,\n\n                                 .repeat = 1 };\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMAControlHeader head;\n\n    RDMARegister *reg, *registers;\n\n    RDMACompress *comp;\n\n    RDMARegisterResult *reg_result;\n\n    static RDMARegisterResult results[RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE];\n\n    RDMALocalBlock *block;\n\n    void *host_addr;\n\n    int ret = 0;\n\n    int idx = 0;\n\n    int count = 0;\n\n    int i = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    do {\n\n        DDDPRINTF(\"Waiting for next request %\" PRIu64 \"...\\n\", flags);\n\n\n\n        ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);\n\n\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {\n\n            fprintf(stderr, \"rdma: Too many requests in this message (%d).\"\n\n                            \"Bailing.\\n\", head.repeat);\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n\n\n        switch (head.type) {\n\n        case RDMA_CONTROL_COMPRESS:\n\n            comp = (RDMACompress *) rdma->wr_data[idx].control_curr;\n\n            network_to_compress(comp);\n\n\n\n            DDPRINTF(\"Zapping zero chunk: %\" PRId64\n\n                    \" bytes, index %d, offset %\" PRId64 \"\\n\",\n\n                    comp->length, comp->block_idx, comp->offset);\n\n            block = &(rdma->local_ram_blocks.block[comp->block_idx]);\n\n\n\n            host_addr = block->local_host_addr +\n\n                            (comp->offset - block->offset);\n\n\n\n            ram_handle_compressed(host_addr, comp->value, comp->length);\n\n            break;\n\n\n\n        case RDMA_CONTROL_REGISTER_FINISHED:\n\n            DDDPRINTF(\"Current registrations complete.\\n\");\n\n            goto out;\n\n\n\n        case RDMA_CONTROL_RAM_BLOCKS_REQUEST:\n\n            DPRINTF(\"Initial setup info requested.\\n\");\n\n\n\n            if (rdma->pin_all) {\n\n                ret = qemu_rdma_reg_whole_ram_blocks(rdma);\n\n                if (ret) {\n\n                    fprintf(stderr, \"rdma migration: error dest \"\n\n                                    \"registering ram blocks!\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /*\n\n             * Dest uses this to prepare to transmit the RAMBlock descriptions\n\n             * to the source VM after connection setup.\n\n             * Both sides use the \"remote\" structure to communicate and update\n\n             * their \"local\" descriptions with what was sent.\n\n             */\n\n            for (i = 0; i < local->nb_blocks; i++) {\n\n                rdma->block[i].remote_host_addr =\n\n                    (uint64_t)(local->block[i].local_host_addr);\n\n\n\n                if (rdma->pin_all) {\n\n                    rdma->block[i].remote_rkey = local->block[i].mr->rkey;\n\n                }\n\n\n\n                rdma->block[i].offset = local->block[i].offset;\n\n                rdma->block[i].length = local->block[i].length;\n\n\n\n                remote_block_to_network(&rdma->block[i]);\n\n            }\n\n\n\n            blocks.len = rdma->local_ram_blocks.nb_blocks\n\n                                                * sizeof(RDMARemoteBlock);\n\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                                        (uint8_t *) rdma->block, &blocks);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"rdma migration: error sending remote info!\\n\");\n\n                goto out;\n\n            }\n\n\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d registration requests\\n\", head.repeat);\n\n\n\n            reg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                uint64_t chunk;\n\n                uint8_t *chunk_start, *chunk_end;\n\n\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                reg_result = &results[count];\n\n\n\n                DDPRINTF(\"Registration request (%d): index %d, current_addr %\"\n\n                         PRIu64 \" chunks: %\" PRIu64 \"\\n\", count,\n\n                         reg->current_index, reg->key.current_addr, reg->chunks);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n                if (block->is_ram_block) {\n\n                    host_addr = (block->local_host_addr +\n\n                                (reg->key.current_addr - block->offset));\n\n                    chunk = ram_chunk_index(block->local_host_addr,\n\n                                            (uint8_t *) host_addr);\n\n                } else {\n\n                    chunk = reg->key.chunk;\n\n                    host_addr = block->local_host_addr +\n\n                        (reg->key.chunk * (1UL << RDMA_REG_CHUNK_SHIFT));\n\n                }\n\n                chunk_start = ram_chunk_start(block, chunk);\n\n                chunk_end = ram_chunk_end(block, chunk + reg->chunks);\n\n                if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                            (uint8_t *)host_addr, NULL, &reg_result->rkey,\n\n                            chunk, chunk_start, chunk_end)) {\n\n                    fprintf(stderr, \"cannot get rkey!\\n\");\n\n                    ret = -EINVAL;\n\n                    goto out;\n\n                }\n\n\n\n                reg_result->host_addr = (uint64_t) block->local_host_addr;\n\n\n\n                DDPRINTF(\"Registered rkey for this request: %x\\n\",\n\n                                reg_result->rkey);\n\n\n\n                result_to_network(reg_result);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                            (uint8_t *) results, &reg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_UNREGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d unregistration requests\\n\", head.repeat);\n\n            unreg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                DDPRINTF(\"Unregistration request (%d): \"\n\n                         \" index %d, chunk %\" PRIu64 \"\\n\",\n\n                         count, reg->current_index, reg->key.chunk);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n\n\n                ret = ibv_dereg_mr(block->pmr[reg->key.chunk]);\n\n                block->pmr[reg->key.chunk] = NULL;\n\n\n\n                if (ret != 0) {\n\n                    perror(\"rdma unregistration chunk failed\");\n\n                    ret = -ret;\n\n                    goto out;\n\n                }\n\n\n\n                rdma->total_registrations--;\n\n\n\n                DDPRINTF(\"Unregistered chunk %\" PRIu64 \" successfully.\\n\",\n\n                            reg->key.chunk);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma, NULL, &unreg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_RESULT:\n\n            fprintf(stderr, \"Invalid RESULT message at dest.\\n\");\n\n            ret = -EIO;\n\n            goto out;\n\n        default:\n\n            fprintf(stderr, \"Unknown control message %s\\n\",\n\n                                control_desc[head.type]);\n\n            ret = -EIO;\n\n            goto out;\n\n        }\n\n    } while (1);\n\nout:\n\n    if (ret < 0) {\n\n        rdma->error_state = ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 8741}
{"project": "qemu", "commit_id": "8dea1dd406189dae6108104faf27f397835ae871", "target": 1, "func": "static void esp_mem_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    ESPState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr >> s->it_shift) & (ESP_REGS - 1);\n\n    DPRINTF(\"write reg[%d]: 0x%2.2x -> 0x%2.2x\\n\", saddr, s->wregs[saddr],\n\n            val);\n\n    switch (saddr) {\n\n    case ESP_TCLO:\n\n    case ESP_TCMID:\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        break;\n\n    case ESP_FIFO:\n\n        if (s->do_cmd) {\n\n            s->cmdbuf[s->cmdlen++] = val & 0xff;\n\n        } else if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n\n            uint8_t buf;\n\n            buf = val & 0xff;\n\n            s->ti_size--;\n\n            fprintf(stderr, \"esp: PIO data write not implemented\\n\");\n\n        } else {\n\n            s->ti_size++;\n\n            s->ti_buf[s->ti_wptr++] = val & 0xff;\n\n        }\n\n        break;\n\n    case ESP_CMD:\n\n        s->rregs[saddr] = val;\n\n        if (val & CMD_DMA) {\n\n            s->dma = 1;\n\n            /* Reload DMA counter.  */\n\n            s->rregs[ESP_TCLO] = s->wregs[ESP_TCLO];\n\n            s->rregs[ESP_TCMID] = s->wregs[ESP_TCMID];\n\n        } else {\n\n            s->dma = 0;\n\n        }\n\n        switch(val & CMD_CMD) {\n\n        case CMD_NOP:\n\n            DPRINTF(\"NOP (%2.2x)\\n\", val);\n\n            break;\n\n        case CMD_FLUSH:\n\n            DPRINTF(\"Flush FIFO (%2.2x)\\n\", val);\n\n            //s->ti_size = 0;\n\n            s->rregs[ESP_RINTR] = INTR_FC;\n\n            s->rregs[ESP_RSEQ] = 0;\n\n            s->rregs[ESP_RFLAGS] = 0;\n\n            break;\n\n        case CMD_RESET:\n\n            DPRINTF(\"Chip reset (%2.2x)\\n\", val);\n\n            esp_reset(s);\n\n            break;\n\n        case CMD_BUSRESET:\n\n            DPRINTF(\"Bus reset (%2.2x)\\n\", val);\n\n            s->rregs[ESP_RINTR] = INTR_RST;\n\n            if (!(s->wregs[ESP_CFG1] & CFG1_RESREPT)) {\n\n                esp_raise_irq(s);\n\n            }\n\n            break;\n\n        case CMD_TI:\n\n            handle_ti(s);\n\n            break;\n\n        case CMD_ICCS:\n\n            DPRINTF(\"Initiator Command Complete Sequence (%2.2x)\\n\", val);\n\n            write_response(s);\n\n            break;\n\n        case CMD_MSGACC:\n\n            DPRINTF(\"Message Accepted (%2.2x)\\n\", val);\n\n            write_response(s);\n\n            s->rregs[ESP_RINTR] = INTR_DC;\n\n            s->rregs[ESP_RSEQ] = 0;\n\n            break;\n\n        case CMD_SATN:\n\n            DPRINTF(\"Set ATN (%2.2x)\\n\", val);\n\n            break;\n\n        case CMD_SELATN:\n\n            DPRINTF(\"Set ATN (%2.2x)\\n\", val);\n\n            handle_satn(s);\n\n            break;\n\n        case CMD_SELATNS:\n\n            DPRINTF(\"Set ATN & stop (%2.2x)\\n\", val);\n\n            handle_satn_stop(s);\n\n            break;\n\n        case CMD_ENSEL:\n\n            DPRINTF(\"Enable selection (%2.2x)\\n\", val);\n\n            break;\n\n        default:\n\n            DPRINTF(\"Unhandled ESP command (%2.2x)\\n\", val);\n\n            break;\n\n        }\n\n        break;\n\n    case ESP_WBUSID ... ESP_WSYNO:\n\n        break;\n\n    case ESP_CFG1:\n\n        s->rregs[saddr] = val;\n\n        break;\n\n    case ESP_WCCF ... ESP_WTEST:\n\n        break;\n\n    case ESP_CFG2:\n\n        s->rregs[saddr] = val & CFG2_MASK;\n\n        break;\n\n    case ESP_CFG3 ... ESP_RES4:\n\n        s->rregs[saddr] = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    s->wregs[saddr] = val;\n\n}\n", "idx": 2533}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_update_rings(VirtIODevice *vdev, int n)\n\n{\n\n    VRing *vring = &vdev->vq[n].vring;\n\n\n\n    if (!vring->desc) {\n\n        /* not yet setup -> nothing to do */\n\n        return;\n\n    }\n\n    vring->avail = vring->desc + vring->num * sizeof(VRingDesc);\n\n    vring->used = vring_align(vring->avail +\n\n                              offsetof(VRingAvail, ring[vring->num]),\n\n                              vring->align);\n\n    virtio_init_region_cache(vdev, n);\n\n}\n", "idx": 4828}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static void mux_chr_read(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n    int m = chr->focus;\n\n    int i;\n\n\n\n    mux_chr_accept_input (opaque);\n\n\n\n    for(i = 0; i < size; i++)\n\n        if (mux_proc_byte(chr, d, buf[i])) {\n\n            if (d->prod == d->cons &&\n\n                d->chr_can_read[m] &&\n\n                d->chr_can_read[m](d->ext_opaque[m]))\n\n                d->chr_read[m](d->ext_opaque[m], &buf[i], 1);\n\n            else\n\n                d->buffer[d->prod++ & MUX_BUFFER_MASK] = buf[i];\n\n        }\n\n}\n", "idx": 1320}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int64_t get_remaining_dirty(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n    int64_t dirty = 0;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        dirty += bdrv_get_dirty_count(bmds->bs, bmds->dirty_bitmap);\n\n    }\n\n\n\n    return dirty << BDRV_SECTOR_BITS;\n\n}\n", "idx": 9089}
{"project": "qemu", "commit_id": "f2ad97ff81da51c064b9e87720ff48a0874f45d4", "target": 1, "func": "static int usb_xhci_post_load(void *opaque, int version_id)\n\n{\n\n    XHCIState *xhci = opaque;\n\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    dma_addr_t dcbaap, pctx;\n\n    uint32_t slot_ctx[4];\n\n    uint32_t ep_ctx[5];\n\n    int slotid, epid, state, intr;\n\n\n\n    dcbaap = xhci_addr64(xhci->dcbaap_low, xhci->dcbaap_high);\n\n\n\n    for (slotid = 1; slotid <= xhci->numslots; slotid++) {\n\n        slot = &xhci->slots[slotid-1];\n\n        if (!slot->addressed) {\n\n\n\n        slot->ctx =\n\n            xhci_mask64(ldq_le_pci_dma(pci_dev, dcbaap + 8 * slotid));\n\n        xhci_dma_read_u32s(xhci, slot->ctx, slot_ctx, sizeof(slot_ctx));\n\n        slot->uport = xhci_lookup_uport(xhci, slot_ctx);\n\n\n\n\n\n\n\n        assert(slot->uport && slot->uport->dev);\n\n\n\n        for (epid = 1; epid <= 31; epid++) {\n\n            pctx = slot->ctx + 32 * epid;\n\n            xhci_dma_read_u32s(xhci, pctx, ep_ctx, sizeof(ep_ctx));\n\n            state = ep_ctx[0] & EP_STATE_MASK;\n\n            if (state == EP_DISABLED) {\n\n\n\n            epctx = xhci_alloc_epctx(xhci, slotid, epid);\n\n            slot->eps[epid-1] = epctx;\n\n            xhci_init_epctx(epctx, pctx, ep_ctx);\n\n            epctx->state = state;\n\n            if (state == EP_RUNNING) {\n\n                /* kick endpoint after vmload is finished */\n\n                timer_mod(epctx->kick_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL));\n\n\n\n\n\n\n    for (intr = 0; intr < xhci->numintrs; intr++) {\n\n        if (xhci->intr[intr].msix_used) {\n\n            msix_vector_use(pci_dev, intr);\n\n        } else {\n\n            msix_vector_unuse(pci_dev, intr);\n\n\n\n\n\n    return 0;\n", "idx": 1987}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void vnc_display_close(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs)\n\n        return;\n\n    if (vs->display) {\n\n        g_free(vs->display);\n\n        vs->display = NULL;\n\n    }\n\n    if (vs->lsock != -1) {\n\n        qemu_set_fd_handler2(vs->lsock, NULL, NULL, NULL, NULL);\n\n        close(vs->lsock);\n\n        vs->lsock = -1;\n\n    }\n\n#ifdef CONFIG_VNC_WS\n\n    g_free(vs->ws_display);\n\n    vs->ws_display = NULL;\n\n    if (vs->lwebsock != -1) {\n\n        qemu_set_fd_handler2(vs->lwebsock, NULL, NULL, NULL, NULL);\n\n        close(vs->lwebsock);\n\n        vs->lwebsock = -1;\n\n    }\n\n#endif /* CONFIG_VNC_WS */\n\n    vs->auth = VNC_AUTH_INVALID;\n\n#ifdef CONFIG_VNC_TLS\n\n    vs->subauth = VNC_AUTH_INVALID;\n\n    vs->tls.x509verify = 0;\n\n#endif\n\n}\n", "idx": 1571}
{"project": "qemu", "commit_id": "7061a078984ba7d08b8b80686ad98c5162e56fbd", "target": 1, "func": "static int make_completely_empty(BlockDriverState *bs)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int ret, l1_clusters;\n\n    int64_t offset;\n\n    uint64_t *new_reftable = NULL;\n\n    uint64_t rt_entry, l1_size2;\n\n    struct {\n\n        uint64_t l1_offset;\n\n        uint64_t reftable_offset;\n\n        uint32_t reftable_clusters;\n\n    } QEMU_PACKED l1_ofs_rt_ofs_cls;\n\n\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = qcow2_cache_empty(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Refcounts will be broken utterly */\n\n    ret = qcow2_mark_dirty(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n\n\n    l1_clusters = DIV_ROUND_UP(s->l1_size, s->cluster_size / sizeof(uint64_t));\n\n    l1_size2 = (uint64_t)s->l1_size * sizeof(uint64_t);\n\n\n\n    /* After this call, neither the in-memory nor the on-disk refcount\n\n     * information accurately describe the actual references */\n\n\n\n    ret = bdrv_pwrite_zeroes(bs->file, s->l1_table_offset,\n\n                             l1_clusters * s->cluster_size, 0);\n\n    if (ret < 0) {\n\n        goto fail_broken_refcounts;\n\n    }\n\n    memset(s->l1_table, 0, l1_size2);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_EMPTY_IMAGE_PREPARE);\n\n\n\n    /* Overwrite enough clusters at the beginning of the sectors to place\n\n     * the refcount table, a refcount block and the L1 table in; this may\n\n     * overwrite parts of the existing refcount and L1 table, which is not\n\n     * an issue because the dirty flag is set, complete data loss is in fact\n\n     * desired and partial data loss is consequently fine as well */\n\n    ret = bdrv_pwrite_zeroes(bs->file, s->cluster_size,\n\n                             (2 + l1_clusters) * s->cluster_size, 0);\n\n    /* This call (even if it failed overall) may have overwritten on-disk\n\n     * refcount structures; in that case, the in-memory refcount information\n\n     * will probably differ from the on-disk information which makes the BDS\n\n     * unusable */\n\n    if (ret < 0) {\n\n        goto fail_broken_refcounts;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_UPDATE);\n\n\n\n    /* \"Create\" an empty reftable (one cluster) directly after the image\n\n     * header and an empty L1 table three clusters after the image header;\n\n     * the cluster between those two will be used as the first refblock */\n\n    l1_ofs_rt_ofs_cls.l1_offset = cpu_to_be64(3 * s->cluster_size);\n\n    l1_ofs_rt_ofs_cls.reftable_offset = cpu_to_be64(s->cluster_size);\n\n    l1_ofs_rt_ofs_cls.reftable_clusters = cpu_to_be32(1);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_table_offset),\n\n                           &l1_ofs_rt_ofs_cls, sizeof(l1_ofs_rt_ofs_cls));\n\n    if (ret < 0) {\n\n        goto fail_broken_refcounts;\n\n    }\n\n\n\n    s->l1_table_offset = 3 * s->cluster_size;\n\n\n\n    new_reftable = g_try_new0(uint64_t, s->cluster_size / sizeof(uint64_t));\n\n    if (!new_reftable) {\n\n        ret = -ENOMEM;\n\n        goto fail_broken_refcounts;\n\n    }\n\n\n\n    s->refcount_table_offset = s->cluster_size;\n\n    s->refcount_table_size   = s->cluster_size / sizeof(uint64_t);\n\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_reftable;\n\n    new_reftable = NULL;\n\n\n\n    /* Now the in-memory refcount information again corresponds to the on-disk\n\n     * information (reftable is empty and no refblocks (the refblock cache is\n\n     * empty)); however, this means some clusters (e.g. the image header) are\n\n     * referenced, but not refcounted, but the normal qcow2 code assumes that\n\n     * the in-memory information is always correct */\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Enter the first refblock into the reftable */\n\n    rt_entry = cpu_to_be64(2 * s->cluster_size);\n\n    ret = bdrv_pwrite_sync(bs->file, s->cluster_size,\n\n                           &rt_entry, sizeof(rt_entry));\n\n    if (ret < 0) {\n\n        goto fail_broken_refcounts;\n\n    }\n\n    s->refcount_table[0] = 2 * s->cluster_size;\n\n\n\n    s->free_cluster_index = 0;\n\n    assert(3 + l1_clusters <= s->refcount_block_size);\n\n    offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);\n\n    if (offset < 0) {\n\n        ret = offset;\n\n        goto fail_broken_refcounts;\n\n    } else if (offset > 0) {\n\n        error_report(\"First cluster in emptied image is in use\");\n\n        abort();\n\n    }\n\n\n\n    /* Now finally the in-memory information corresponds to the on-disk\n\n     * structures and is correct */\n\n    ret = qcow2_mark_clean(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = bdrv_truncate(bs->file->bs, (3 + l1_clusters) * s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail_broken_refcounts:\n\n    /* The BDS is unusable at this point. If we wanted to make it usable, we\n\n     * would have to call qcow2_refcount_close(), qcow2_refcount_init(),\n\n     * qcow2_check_refcounts(), qcow2_refcount_close() and qcow2_refcount_init()\n\n     * again. However, because the functions which could have caused this error\n\n     * path to be taken are used by those functions as well, it's very likely\n\n     * that that sequence will fail as well. Therefore, just eject the BDS. */\n\n    bs->drv = NULL;\n\n\n\nfail:\n\n    g_free(new_reftable);\n\n    return ret;\n\n}", "idx": 7989}
{"project": "qemu", "commit_id": "0bd8246bfec1dfb2eb959f52db535572c0260f4c", "target": 1, "func": "static void vga_invalidate_display(void *opaque)\n\n{\n\n    VGAState *s = (VGAState *)opaque;\n\n\n\n    s->last_width = -1;\n\n    s->last_height = -1;\n\n}\n", "idx": 9574}
{"project": "qemu", "commit_id": "b38ec5ee7a581776bbce0bdaecb397632c3c4791", "target": 1, "func": "static void pci_msix_write(void *opaque, hwaddr addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    XenPCIPassthroughState *s = opaque;\n\n    XenPTMSIX *msix = s->msix;\n\n    XenPTMSIXEntry *entry;\n\n    int entry_nr, offset;\n\n\n\n    entry_nr = addr / PCI_MSIX_ENTRY_SIZE;\n\n    if (entry_nr < 0 || entry_nr >= msix->total_entries) {\n\n        XEN_PT_ERR(&s->dev, \"asked MSI-X entry '%i' invalid!\\n\", entry_nr);\n\n        return;\n\n    }\n\n    entry = &msix->msix_entry[entry_nr];\n\n    offset = addr % PCI_MSIX_ENTRY_SIZE;\n\n\n\n    if (offset != PCI_MSIX_ENTRY_VECTOR_CTRL) {\n\n        const volatile uint32_t *vec_ctrl;\n\n\n\n        if (get_entry_value(entry, offset) == val\n\n            && entry->pirq != XEN_PT_UNASSIGNED_PIRQ) {\n\n            return;\n\n        }\n\n\n\n        /*\n\n         * If Xen intercepts the mask bit access, entry->vec_ctrl may not be\n\n         * up-to-date. Read from hardware directly.\n\n         */\n\n        vec_ctrl = s->msix->phys_iomem_base + entry_nr * PCI_MSIX_ENTRY_SIZE\n\n            + PCI_MSIX_ENTRY_VECTOR_CTRL;\n\n\n\n        if (msix->enabled && !(*vec_ctrl & PCI_MSIX_ENTRY_CTRL_MASKBIT)) {\n\n            XEN_PT_ERR(&s->dev, \"Can't update msix entry %d since MSI-X is\"\n\n                       \" already enabled.\\n\", entry_nr);\n\n            return;\n\n        }\n\n\n\n        entry->updated = true;\n\n    }\n\n\n\n    set_entry_value(entry, offset, val);\n\n\n\n    if (offset == PCI_MSIX_ENTRY_VECTOR_CTRL) {\n\n        if (msix->enabled && !(val & PCI_MSIX_ENTRY_CTRL_MASKBIT)) {\n\n            xen_pt_msix_update_one(s, entry_nr);\n\n        }\n\n    }\n\n}\n", "idx": 11347}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n", "idx": 7052}
{"project": "qemu", "commit_id": "9cf2bab2edca1e651eef49f2417f8f67bdfe49bb", "target": 1, "func": "static int qemu_rdma_connect(RDMAContext *rdma, Error **errp)\n\n{\n\n    RDMACapabilities cap = {\n\n                                .version = RDMA_CONTROL_VERSION_CURRENT,\n\n                                .flags = 0,\n\n                           };\n\n    struct rdma_conn_param conn_param = { .initiator_depth = 2,\n\n                                          .retry_count = 5,\n\n                                          .private_data = &cap,\n\n                                          .private_data_len = sizeof(cap),\n\n                                        };\n\n    struct rdma_cm_event *cm_event;\n\n    int ret;\n\n\n\n    /*\n\n     * Only negotiate the capability with destination if the user\n\n     * on the source first requested the capability.\n\n     */\n\n    if (rdma->pin_all) {\n\n        trace_qemu_rdma_connect_pin_all_requested();\n\n        cap.flags |= RDMA_CAPABILITY_PIN_ALL;\n\n    }\n\n\n\n    caps_to_network(&cap);\n\n\n\n    ret = rdma_connect(rdma->cm_id, &conn_param);\n\n    if (ret) {\n\n        perror(\"rdma_connect\");\n\n        ERROR(errp, \"connecting to destination!\");\n\n        goto err_rdma_source_connect;\n\n    }\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        perror(\"rdma_get_cm_event after rdma_connect\");\n\n        ERROR(errp, \"connecting to destination!\");\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_source_connect;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {\n\n        perror(\"rdma_get_cm_event != EVENT_ESTABLISHED after rdma_connect\");\n\n        ERROR(errp, \"connecting to destination!\");\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_source_connect;\n\n    }\n\n    rdma->connected = true;\n\n\n\n    memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));\n\n    network_to_caps(&cap);\n\n\n\n    /*\n\n     * Verify that the *requested* capabilities are supported by the destination\n\n     * and disable them otherwise.\n\n     */\n\n    if (rdma->pin_all && !(cap.flags & RDMA_CAPABILITY_PIN_ALL)) {\n\n        ERROR(errp, \"Server cannot support pinning all memory. \"\n\n                        \"Will register memory dynamically.\");\n\n        rdma->pin_all = false;\n\n    }\n\n\n\n    trace_qemu_rdma_connect_pin_all_outcome(rdma->pin_all);\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n\n\n    ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_READY);\n\n    if (ret) {\n\n        ERROR(errp, \"posting second control recv!\");\n\n        goto err_rdma_source_connect;\n\n    }\n\n\n\n    rdma->control_ready_expected = 1;\n\n    rdma->nb_sent = 0;\n\n    return 0;\n\n\n\nerr_rdma_source_connect:\n\n    qemu_rdma_cleanup(rdma);\n\n    return -1;\n\n}\n", "idx": 5836}
{"project": "qemu", "commit_id": "14fe292d86da90b79e2fb56a4986d27346339a00", "target": 1, "func": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n", "idx": 6641}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_get_bool(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    BoolProperty *prop = opaque;\n\n    bool value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_bool(v, &value, name, errp);\n\n}\n", "idx": 2112}
{"project": "qemu", "commit_id": "14cec170ea4724e6881ba2febb20e88a942e52d3", "target": 1, "func": "static int xen_pt_bar_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint32_t *value, uint32_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint32_t valid_emu_mask = 0;\n\n    uint32_t bar_emu_mask = 0;\n\n    int index;\n\n\n\n    /* get BAR index */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* use fixed-up value from kernel sysfs */\n\n    *value = base_address_with_flags(&s->real_device.io_regions[index]);\n\n\n\n    /* set emulate mask depend on BAR flag */\n\n    switch (s->bases[index].bar_flag) {\n\n    case XEN_PT_BAR_FLAG_MEM:\n\n        bar_emu_mask = XEN_PT_BAR_MEM_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_IO:\n\n        bar_emu_mask = XEN_PT_BAR_IO_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_UPPER:\n\n        bar_emu_mask = XEN_PT_BAR_ALLF;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* emulate BAR */\n\n    valid_emu_mask = bar_emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 4390}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void palmte_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    struct omap_mpu_state_s *mpu;\n\n    int flash_size = 0x00800000;\n\n    int sdram_size = palmte_binfo.ram_size;\n\n    static uint32_t cs0val = 0xffffffff;\n\n    static uint32_t cs1val = 0x0000e1a0;\n\n    static uint32_t cs2val = 0x0000e1a0;\n\n    static uint32_t cs3val = 0xe1a0e1a0;\n\n    int rom_size, rom_loaded = 0;\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *cs = g_new(MemoryRegion, 4);\n\n\n\n    mpu = omap310_mpu_init(address_space_mem, sdram_size, cpu_model);\n\n\n\n    /* External Flash (EMIFS) */\n\n    memory_region_init_ram(flash, NULL, \"palmte.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS0_BASE, flash);\n\n\n\n    memory_region_init_io(&cs[0], NULL, &static_ops, &cs0val, \"palmte-cs0\",\n\n                          OMAP_CS0_SIZE - flash_size);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS0_BASE + flash_size,\n\n                                &cs[0]);\n\n    memory_region_init_io(&cs[1], NULL, &static_ops, &cs1val, \"palmte-cs1\",\n\n                          OMAP_CS1_SIZE);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS1_BASE, &cs[1]);\n\n    memory_region_init_io(&cs[2], NULL, &static_ops, &cs2val, \"palmte-cs2\",\n\n                          OMAP_CS2_SIZE);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS2_BASE, &cs[2]);\n\n    memory_region_init_io(&cs[3], NULL, &static_ops, &cs3val, \"palmte-cs3\",\n\n                          OMAP_CS3_SIZE);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS3_BASE, &cs[3]);\n\n\n\n    palmte_microwire_setup(mpu);\n\n\n\n    qemu_add_kbd_event_handler(palmte_button_event, mpu);\n\n\n\n    palmte_gpio_setup(mpu);\n\n\n\n    /* Setup initial (reset) machine state */\n\n    if (nb_option_roms) {\n\n        rom_size = get_image_size(option_rom[0].name);\n\n        if (rom_size > flash_size) {\n\n            fprintf(stderr, \"%s: ROM image too big (%x > %x)\\n\",\n\n                            __FUNCTION__, rom_size, flash_size);\n\n            rom_size = 0;\n\n        }\n\n        if (rom_size > 0) {\n\n            rom_size = load_image_targphys(option_rom[0].name, OMAP_CS0_BASE,\n\n                                           flash_size);\n\n            rom_loaded = 1;\n\n        }\n\n        if (rom_size < 0) {\n\n            fprintf(stderr, \"%s: error loading '%s'\\n\",\n\n                            __FUNCTION__, option_rom[0].name);\n\n        }\n\n    }\n\n\n\n    if (!rom_loaded && !kernel_filename && !qtest_enabled()) {\n\n        fprintf(stderr, \"Kernel or ROM image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Load the kernel.  */\n\n    palmte_binfo.kernel_filename = kernel_filename;\n\n    palmte_binfo.kernel_cmdline = kernel_cmdline;\n\n    palmte_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(mpu->cpu, &palmte_binfo);\n\n}\n", "idx": 1498}
{"project": "qemu", "commit_id": "89cad9f3ec6b30d7550fb5704475fc9c3393a066", "target": 1, "func": "static void process_event(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    GAState *s = container_of(parser, GAState, parser);\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    g_assert(s && parser);\n\n\n\n    g_debug(\"process_event: called\");\n\n    obj = json_parser_parse_err(tokens, NULL, &err);\n\n    if (err || !obj || qobject_type(obj) != QTYPE_QDICT) {\n\n        qobject_decref(obj);\n\n        qdict = qdict_new();\n\n        if (!err) {\n\n            g_warning(\"failed to parse event: unknown error\");\n\n            error_setg(&err, QERR_JSON_PARSING);\n\n        } else {\n\n            g_warning(\"failed to parse event: %s\", error_get_pretty(err));\n\n        }\n\n        qdict_put_obj(qdict, \"error\", qmp_build_error_object(err));\n\n        error_free(err);\n\n    } else {\n\n        qdict = qobject_to_qdict(obj);\n\n    }\n\n\n\n    g_assert(qdict);\n\n\n\n    /* handle host->guest commands */\n\n    if (qdict_haskey(qdict, \"execute\")) {\n\n        process_command(s, qdict);\n\n    } else {\n\n        if (!qdict_haskey(qdict, \"error\")) {\n\n            QDECREF(qdict);\n\n            qdict = qdict_new();\n\n            g_warning(\"unrecognized payload format\");\n\n            error_setg(&err, QERR_UNSUPPORTED);\n\n            qdict_put_obj(qdict, \"error\", qmp_build_error_object(err));\n\n            error_free(err);\n\n        }\n\n        ret = send_response(s, QOBJECT(qdict));\n\n        if (ret < 0) {\n\n            g_warning(\"error sending error response: %s\", strerror(-ret));\n\n        }\n\n    }\n\n\n\n    QDECREF(qdict);\n\n}\n", "idx": 8842}
{"project": "qemu", "commit_id": "9814fed0afa73f5c37f04e02ec17c915a5d59303", "target": 1, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags, bool exc)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n        PTE_DPRINTF(\"%s: asc=primary\\n\", __func__);\n\n        r = mmu_translate_asce(env, vaddr, asc, env->cregs[1], raddr, flags,\n\n                               rw, exc);\n\n        break;\n\n    case PSW_ASC_HOME:\n\n        PTE_DPRINTF(\"%s: asc=home\\n\", __func__);\n\n        r = mmu_translate_asce(env, vaddr, asc, env->cregs[13], raddr, flags,\n\n                               rw, exc);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        PTE_DPRINTF(\"%s: asc=secondary\\n\", __func__);\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == MMU_INST_FETCH) {\n\n            r = mmu_translate_asce(env, vaddr, PSW_ASC_PRIMARY, env->cregs[1],\n\n                                   raddr, flags, rw, exc);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asce(env, vaddr, PSW_ASC_SECONDARY, env->cregs[7],\n\n                                   raddr, flags, rw, exc);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 1089}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "static void arm_cpu_reset(CPUState *s)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(s);\n\n    ARMCPUClass *acc = ARM_CPU_GET_CLASS(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n\n\n    acc->parent_reset(s);\n\n\n\n    memset(env, 0, offsetof(CPUARMState, end_reset_fields));\n\n\n\n    g_hash_table_foreach(cpu->cp_regs, cp_reg_reset, cpu);\n\n    g_hash_table_foreach(cpu->cp_regs, cp_reg_check_reset, cpu);\n\n\n\n    env->vfp.xregs[ARM_VFP_FPSID] = cpu->reset_fpsid;\n\n    env->vfp.xregs[ARM_VFP_MVFR0] = cpu->mvfr0;\n\n    env->vfp.xregs[ARM_VFP_MVFR1] = cpu->mvfr1;\n\n    env->vfp.xregs[ARM_VFP_MVFR2] = cpu->mvfr2;\n\n\n\n    cpu->powered_off = cpu->start_powered_off;\n\n    s->halted = cpu->start_powered_off;\n\n\n\n    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\n        env->iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_AARCH64)) {\n\n        /* 64 bit CPUs always start in 64 bit mode */\n\n        env->aarch64 = 1;\n\n#if defined(CONFIG_USER_ONLY)\n\n        env->pstate = PSTATE_MODE_EL0t;\n\n        /* Userspace expects access to DC ZVA, CTL_EL0 and the cache ops */\n\n        env->cp15.sctlr_el[1] |= SCTLR_UCT | SCTLR_UCI | SCTLR_DZE;\n\n        /* and to the FP/Neon instructions */\n\n        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 2, 3);\n\n#else\n\n        /* Reset into the highest available EL */\n\n        if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n            env->pstate = PSTATE_MODE_EL3h;\n\n        } else if (arm_feature(env, ARM_FEATURE_EL2)) {\n\n            env->pstate = PSTATE_MODE_EL2h;\n\n        } else {\n\n            env->pstate = PSTATE_MODE_EL1h;\n\n        }\n\n        env->pc = cpu->rvbar;\n\n#endif\n\n    } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n        /* Userspace expects access to cp10 and cp11 for FP/Neon */\n\n        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 4, 0xf);\n\n#endif\n\n    }\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->uncached_cpsr = ARM_CPU_MODE_USR;\n\n    /* For user mode we must enable access to coprocessors */\n\n    env->vfp.xregs[ARM_VFP_FPEXC] = 1 << 30;\n\n    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\n        env->cp15.c15_cpar = 3;\n\n    } else if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n        env->cp15.c15_cpar = 1;\n\n    }\n\n#else\n\n    /* SVC mode with interrupts disabled.  */\n\n    env->uncached_cpsr = ARM_CPU_MODE_SVC;\n\n    env->daif = PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F;\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t initial_msp; /* Loaded from 0x0 */\n\n        uint32_t initial_pc; /* Loaded from 0x4 */\n\n        uint8_t *rom;\n\n\n\n        /* For M profile we store FAULTMASK and PRIMASK in the\n\n         * PSTATE F and I bits; these are both clear at reset.\n\n         */\n\n        env->daif &= ~(PSTATE_I | PSTATE_F);\n\n\n\n        /* The reset value of this bit is IMPDEF, but ARM recommends\n\n         * that it resets to 1, so QEMU always does that rather than making\n\n         * it dependent on CPU model.\n\n         */\n\n        env->v7m.ccr = R_V7M_CCR_STKALIGN_MASK;\n\n\n\n        /* Unlike A/R profile, M profile defines the reset LR value */\n\n        env->regs[14] = 0xffffffff;\n\n\n\n        /* Load the initial SP and PC from the vector table at address 0 */\n\n        rom = rom_ptr(0);\n\n        if (rom) {\n\n            /* Address zero is covered by ROM which hasn't yet been\n\n             * copied into physical memory.\n\n             */\n\n            initial_msp = ldl_p(rom);\n\n            initial_pc = ldl_p(rom + 4);\n\n        } else {\n\n            /* Address zero not covered by a ROM blob, or the ROM blob\n\n             * is in non-modifiable memory and this is a second reset after\n\n             * it got copied into memory. In the latter case, rom_ptr\n\n             * will return a NULL pointer and we should use ldl_phys instead.\n\n             */\n\n            initial_msp = ldl_phys(s->as, 0);\n\n            initial_pc = ldl_phys(s->as, 4);\n\n        }\n\n\n\n        env->regs[13] = initial_msp & 0xFFFFFFFC;\n\n        env->regs[15] = initial_pc & ~1;\n\n        env->thumb = initial_pc & 1;\n\n    }\n\n\n\n    /* AArch32 has a hard highvec setting of 0xFFFF0000.  If we are currently\n\n     * executing as AArch32 then check if highvecs are enabled and\n\n     * adjust the PC accordingly.\n\n     */\n\n    if (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_V) {\n\n        env->regs[15] = 0xFFFF0000;\n\n    }\n\n\n\n    env->vfp.xregs[ARM_VFP_FPEXC] = 0;\n\n#endif\n\n    set_flush_to_zero(1, &env->vfp.standard_fp_status);\n\n    set_flush_inputs_to_zero(1, &env->vfp.standard_fp_status);\n\n    set_default_nan_mode(1, &env->vfp.standard_fp_status);\n\n    set_float_detect_tininess(float_tininess_before_rounding,\n\n                              &env->vfp.fp_status);\n\n    set_float_detect_tininess(float_tininess_before_rounding,\n\n                              &env->vfp.standard_fp_status);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (kvm_enabled()) {\n\n        kvm_arm_reset_vcpu(cpu);\n\n    }\n\n#endif\n\n\n\n    hw_breakpoint_update_all(cpu);\n\n    hw_watchpoint_update_all(cpu);\n\n}\n", "idx": 3761}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static void do_memory_save(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    FILE *f;\n\n    uint32_t size = qdict_get_int(qdict, \"size\");\n\n    const char *filename = qdict_get_str(qdict, \"filename\");\n\n    target_long addr = qdict_get_int(qdict, \"val\");\n\n    uint32_t l;\n\n    CPUState *env;\n\n    uint8_t buf[1024];\n\n\n\n    env = mon_get_cpu();\n\n    if (!env)\n\n        return;\n\n\n\n    f = fopen(filename, \"wb\");\n\n    if (!f) {\n\n        monitor_printf(mon, \"could not open '%s'\\n\", filename);\n\n        return;\n\n    }\n\n    while (size != 0) {\n\n        l = sizeof(buf);\n\n        if (l > size)\n\n            l = size;\n\n        cpu_memory_rw_debug(env, addr, buf, l, 0);\n\n        fwrite(buf, 1, l, f);\n\n        addr += l;\n\n        size -= l;\n\n    }\n\n    fclose(f);\n\n}\n", "idx": 11156}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                int32_t offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        prdt_tbl_entry_size(&tbl[off_idx]) - off_pos);\n\n\n\n        for (i = off_idx + 1; i < prdtl; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            prdt_tbl_entry_size(&tbl[i]));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\\n\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 6504}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static int console_init(SCLPEvent *event)\n\n{\n\n    static bool console_available;\n\n\n\n    SCLPConsole *scon = DO_UPCAST(SCLPConsole, event, event);\n\n\n\n    if (console_available) {\n\n        error_report(\"Multiple VT220 operator consoles are not supported\");\n\n        return -1;\n\n    }\n\n    console_available = true;\n\n    if (scon->chr) {\n\n        qemu_chr_add_handlers(scon->chr, chr_can_read,\n\n                              chr_read, NULL, scon);\n\n    }\n\n    scon->irq_read_vt220 = *qemu_allocate_irqs(trigger_ascii_console_data,\n\n                                               NULL, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 4162}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_i64(FWCfgState *s, uint16_t key, uint64_t value)\n\n{\n\n    uint64_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le64(value);\n\n    fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n", "idx": 10243}
{"project": "qemu", "commit_id": "ad5afd07b628cd0610ea322ad60b5ad03aa250c8", "target": 1, "func": "static void s390_cpu_model_initfn(Object *obj)\n{", "idx": 12214}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}", "idx": 11321}
{"project": "qemu", "commit_id": "f5790c3bc81702c98c7ddadedb274758cff8cbe7", "target": 1, "func": "uint64_t helper_cmpbge(uint64_t op1, uint64_t op2)\n\n{\n\n#if defined(__SSE2__)\n\n    uint64_t r;\n\n\n\n    /* The cmpbge instruction is heavily used in the implementation of\n\n       every string function on Alpha.  We can do much better than either\n\n       the default loop below, or even an unrolled version by using the\n\n       native vector support.  */\n\n    {\n\n        typedef uint64_t Q __attribute__((vector_size(16)));\n\n        typedef uint8_t B __attribute__((vector_size(16)));\n\n\n\n        Q q1 = (Q){ op1, 0 };\n\n        Q q2 = (Q){ op2, 0 };\n\n\n\n        q1 = (Q)((B)q1 >= (B)q2);\n\n\n\n        r = q1[0];\n\n    }\n\n\n\n    /* Select only one bit from each byte.  */\n\n    r &= 0x0101010101010101;\n\n\n\n    /* Collect the bits into the bottom byte.  */\n\n    /* .......A.......B.......C.......D.......E.......F.......G.......H */\n\n    r |= r >> (8 - 1);\n\n\n\n    /* .......A......AB......BC......CD......DE......EF......FG......GH */\n\n    r |= r >> (16 - 2);\n\n\n\n    /* .......A......AB.....ABC....ABCD....BCDE....CDEF....DEFG....EFGH */\n\n    r |= r >> (32 - 4);\n\n\n\n    /* .......A......AB.....ABC....ABCD...ABCDE..ABCDEF.ABCDEFGABCDEFGH */\n\n    /* Return only the low 8 bits.  */\n\n    return r & 0xff;\n\n#else\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 8; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb) {\n\n            res |= 1 << i;\n\n        }\n\n    }\n\n    return res;\n\n#endif\n\n}\n", "idx": 6846}
{"project": "qemu", "commit_id": "c3481247e58ff3f13337ce0a262b058799bd156c", "target": 1, "func": "void object_add(const char *type, const char *id, const QDict *qdict,\n\n                Visitor *v, Error **errp)\n\n{\n\n    Object *obj;\n\n    const QDictEntry *e;\n\n    Error *local_err = NULL;\n\n\n\n    if (!object_class_by_name(type)) {\n\n        error_setg(errp, \"invalid class name\");\n\n        return;\n\n    }\n\n\n\n    obj = object_new(type);\n\n    if (qdict) {\n\n        for (e = qdict_first(qdict); e; e = qdict_next(qdict, e)) {\n\n            object_property_set(obj, v, e->key, &local_err);\n\n            if (local_err) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!object_dynamic_cast(obj, TYPE_USER_CREATABLE)) {\n\n        error_setg(&local_err, \"object type '%s' isn't supported by object-add\",\n\n                   type);\n\n        goto out;\n\n    }\n\n\n\n    user_creatable_complete(obj, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    object_property_add_child(container_get(object_get_root(), \"/objects\"),\n\n                              id, obj, &local_err);\n\nout:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    object_unref(obj);\n\n}\n", "idx": 1773}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq *pl190_init(uint32_t base, qemu_irq irq, qemu_irq fiq)\n\n{\n\n    pl190_state *s;\n\n    qemu_irq *qi;\n\n    int iomemtype;\n\n\n\n    s = (pl190_state *)qemu_mallocz(sizeof(pl190_state));\n\n    iomemtype = cpu_register_io_memory(0, pl190_readfn,\n\n                                       pl190_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    qi = qemu_allocate_irqs(pl190_set_irq, s, 32);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->fiq = fiq;\n\n    pl190_reset(s);\n\n    /* ??? Save/restore.  */\n\n    return qi;\n\n}\n", "idx": 12162}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "void vnc_display_add_client(DisplayState *ds, int csock, int skipauth)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    vnc_connect(vs, csock, skipauth, 0);\n\n}\n", "idx": 5650}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static uint64_t alloc_cluster_offset(BlockDriverState *bs,\n\n                                     uint64_t offset,\n\n                                     int n_start, int n_end,\n\n                                     int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_available, nb_clusters, i = 0;\n\n    uint64_t start_sect;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    if (nb_clusters > s->l2_size - l2_index)\n\n            nb_clusters = s->l2_size - l2_index;\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0);\n\n\n\n        nb_available = nb_clusters << (s->cluster_bits - 9);\n\n        if (nb_available > n_end)\n\n            nb_available = n_end;\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        int j;\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n\n\n        j = count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index + i], 0);\n\n\n\n        if (j)\n\n            free_any_clusters(bs, cluster_offset, j);\n\n\n\n        i += j;\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* we must initialize the cluster content which won't be\n\n       written */\n\n\n\n    nb_available = nb_clusters << (s->cluster_bits - 9);\n\n    if (nb_available > n_end)\n\n        nb_available = n_end;\n\n\n\n    /* copy content of unmodified sectors */\n\n\n\n    start_sect = (offset & ~(s->cluster_size - 1)) >> 9;\n\n    if (n_start) {\n\n        ret = copy_sectors(bs, start_sect, cluster_offset, 0, n_start);\n\n        if (ret < 0)\n\n            return 0;\n\n    }\n\n\n\n    if (nb_available & (s->cluster_sectors - 1)) {\n\n        uint64_t end = nb_available & ~(uint64_t)(s->cluster_sectors - 1);\n\n        ret = copy_sectors(bs, start_sect + end,\n\n                           cluster_offset + (end << 9),\n\n                           nb_available - end,\n\n                           s->cluster_sectors);\n\n        if (ret < 0)\n\n            return 0;\n\n    }\n\n\n\n    /* update L2 table */\n\n\n\n    for (i = 0; i < nb_clusters; i++)\n\n        l2_table[l2_index + i] = cpu_to_be64((cluster_offset +\n\n                                             (i << s->cluster_bits)) |\n\n                                             QCOW_OFLAG_COPIED);\n\n\n\n    if (bdrv_pwrite(s->hd,\n\n                    l2_offset + l2_index * sizeof(uint64_t),\n\n                    l2_table + l2_index,\n\n                    nb_clusters * sizeof(uint64_t)) !=\n\n                    nb_clusters * sizeof(uint64_t))\n\n        return 0;\n\n\n\nout:\n\n    *num = nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 7304}
{"project": "qemu", "commit_id": "78e8fde26c032931ca2ae13bfc7c59e38afd17ee", "target": 1, "func": "int kvm_arch_handle_exit(CPUPPCState *env, struct kvm_run *run)\n\n{\n\n    int ret;\n\n\n\n    switch (run->exit_reason) {\n\n    case KVM_EXIT_DCR:\n\n        if (run->dcr.is_write) {\n\n            dprintf(\"handle dcr write\\n\");\n\n            ret = kvmppc_handle_dcr_write(env, run->dcr.dcrn, run->dcr.data);\n\n        } else {\n\n            dprintf(\"handle dcr read\\n\");\n\n            ret = kvmppc_handle_dcr_read(env, run->dcr.dcrn, &run->dcr.data);\n\n        }\n\n        break;\n\n    case KVM_EXIT_HLT:\n\n        dprintf(\"handle halt\\n\");\n\n        ret = kvmppc_handle_halt(env);\n\n        break;\n\n#ifdef CONFIG_PSERIES\n\n    case KVM_EXIT_PAPR_HCALL:\n\n        dprintf(\"handle PAPR hypercall\\n\");\n\n        run->papr_hcall.ret = spapr_hypercall(env, run->papr_hcall.nr,\n\n                                              run->papr_hcall.args);\n\n        ret = 1;\n\n        break;\n\n#endif\n\n    default:\n\n        fprintf(stderr, \"KVM: unknown exit reason %d\\n\", run->exit_reason);\n\n        ret = -1;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2296}
{"project": "qemu", "commit_id": "3b39d734141a71296d08af3d4c32f872fafd782e", "target": 1, "func": "static uint64_t arm_ldq_ptw(CPUState *cs, hwaddr addr, bool is_secure,\n\n                            ARMMMUIdx mmu_idx, ARMMMUFaultInfo *fi)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    MemTxAttrs attrs = {};\n\n    AddressSpace *as;\n\n\n\n    attrs.secure = is_secure;\n\n    as = arm_addressspace(cs, attrs);\n\n    addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fi);\n\n    if (fi->s1ptw) {\n\n        return 0;\n\n    }\n\n    if (regime_translation_big_endian(env, mmu_idx)) {\n\n        return address_space_ldq_be(as, addr, attrs, NULL);\n\n    } else {\n\n        return address_space_ldq_le(as, addr, attrs, NULL);\n\n    }\n\n}\n", "idx": 4629}
{"project": "qemu", "commit_id": "8160bfbc4d5d0abf78afa557f2d5832dc11cd690", "target": 1, "func": "static int unix_close(MigrationState *s)\n\n{\n\n    DPRINTF(\"unix_close\\n\");\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 497}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_hostfwd(SlirpState *s, Monitor *mon, const char *redir_str,\n\n                          int legacy_format)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    struct in_addr guest_addr = { .s_addr = 0 };\n\n    int host_port, guest_port;\n\n    const char *p;\n\n    char buf[256];\n\n    int is_udp;\n\n    char *end;\n\n\n\n    p = redir_str;\n\n    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (!legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    host_port = strtol(buf, &end, 0);\n\n    if (*end != '\\0' || host_port < 1 || host_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &guest_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    guest_port = strtol(p, &end, 0);\n\n    if (*end != '\\0' || guest_port < 1 || guest_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n\n                          guest_port) < 0) {\n\n        config_error(mon, \"could not set up host forwarding rule '%s'\\n\",\n\n                     redir_str);\n\n    }\n\n    return;\n\n\n\n fail_syntax:\n\n    config_error(mon, \"invalid host forwarding rule '%s'\\n\", redir_str);\n\n}\n", "idx": 5130}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static uint32_t sdhci_read_dataport(SDHCIState *s, unsigned size)\n\n{\n\n    uint32_t value = 0;\n\n    int i;\n\n\n\n    /* first check that a valid data exists in host controller input buffer */\n\n    if ((s->prnsts & SDHC_DATA_AVAILABLE) == 0) {\n\n        ERRPRINT(\"Trying to read from empty buffer\\n\");\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        value |= s->fifo_buffer[s->data_count] << i * 8;\n\n        s->data_count++;\n\n        /* check if we've read all valid data (blksize bytes) from buffer */\n\n        if ((s->data_count) >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"All %u bytes of data have been read from input buffer\\n\",\n\n                    s->data_count);\n\n            s->prnsts &= ~SDHC_DATA_AVAILABLE; /* no more data in a buffer */\n\n            s->data_count = 0;  /* next buff read must start at position [0] */\n\n\n\n            if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                s->blkcnt--;\n\n            }\n\n\n\n            /* if that was the last block of data */\n\n            if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n                ((s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0)) ||\n\n                 /* stop at gap request */\n\n                (s->stopped_state == sdhc_gap_read &&\n\n                 !(s->prnsts & SDHC_DAT_LINE_ACTIVE))) {\n\n                sdhci_end_transfer(s);\n\n            } else { /* if there are more data, read next block from card */\n\n                sdhci_read_block_from_card(s);\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return value;\n\n}\n", "idx": 1876}
{"project": "qemu", "commit_id": "08942ac17922d923a7cc5cf9854e9cc4b150b942", "target": 1, "func": "int spapr_tce_dma_write(VIOsPAPRDevice *dev, uint64_t taddr, const void *buf,\n                        uint32_t size)\n{\n#ifdef DEBUG_TCE\n    fprintf(stderr, \"spapr_tce_dma_write taddr=0x%llx size=0x%x\\n\",\n            (unsigned long long)taddr, size);\n#endif\n    while (size) {\n        uint64_t tce;\n        uint32_t lsize;\n        uint64_t txaddr;\n        /* Check if we are in bound */\n        if (taddr >= dev->rtce_window_size) {\n#ifdef DEBUG_TCE\n            fprintf(stderr, \"spapr_tce_dma_write out of bounds\\n\");\n#endif\n            return H_DEST_PARM;\n        tce = dev->rtce_table[taddr >> SPAPR_VIO_TCE_PAGE_SHIFT].tce;\n        /* How much til end of page ? */\n        lsize = MIN(size, ((~taddr) & SPAPR_VIO_TCE_PAGE_MASK) + 1);\n        /* Check TCE */\n        if (!(tce & 2)) {\n            return H_DEST_PARM;\n        /* Translate */\n        txaddr = (tce & ~SPAPR_VIO_TCE_PAGE_MASK) |\n            (taddr & SPAPR_VIO_TCE_PAGE_MASK);\n#ifdef DEBUG_TCE\n        fprintf(stderr, \" -> write to txaddr=0x%llx, size=0x%x\\n\",\n                (unsigned long long)txaddr, lsize);\n#endif\n        /* Do it */\n        cpu_physical_memory_write(txaddr, buf, lsize);\n        buf += lsize;\n        taddr += lsize;\n        size -= lsize;", "idx": 2250}
{"project": "qemu", "commit_id": "1d06cb7ab93f879ac25c9f5ef1d1ac8d97a42dfc", "target": 1, "func": "static sd_rsp_type_t sd_app_command(SDState *sd,\n\n                                    SDRequest req)\n\n{\n\n    DPRINTF(\"ACMD%d 0x%08x\\n\", req.cmd, req.arg);\n\n    switch (req.cmd) {\n\n    case 6:\t/* ACMD6:  SET_BUS_WIDTH */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->sd_status[0] &= 0x3f;\n\n            sd->sd_status[0] |= (req.arg & 0x03) << 6;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            *(uint32_t *) sd->data = sd->blk_written;\n\n\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 23:\t/* ACMD23: SET_WR_BLK_ERASE_COUNT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 41:\t/* ACMD41: SD_APP_OP_COND */\n\n        if (sd->spi) {\n\n            /* SEND_OP_CMD */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1;\n\n        }\n\n        switch (sd->state) {\n\n        case sd_idle_state:\n\n            /* We accept any voltage.  10000 V is nothing.  */\n\n            if (req.arg)\n\n                sd->state = sd_ready_state;\n\n\n\n            return sd_r3;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 42:\t/* ACMD42: SET_CLR_CARD_DETECT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Bringing in the 50KOhm pull-up resistor... Done.  */\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* Fall back to standard commands.  */\n\n        sd->card_status &= ~APP_CMD;\n\n        return sd_normal_command(sd, req);\n\n    }\n\n\n\n    fprintf(stderr, \"SD: ACMD%i in a wrong state\\n\", req.cmd);\n\n    return sd_illegal;\n\n}\n", "idx": 11814}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 10004}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pci_grackle_class_init(ObjectClass *klass, void *data)\n\n{\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = pci_grackle_init_device;\n\n    dc->no_user = 1;\n\n}\n", "idx": 9785}
{"project": "qemu", "commit_id": "806d102141b99d4f1e55a97d68b7ea8c8ba3129f", "target": 1, "func": "unsigned long init_guest_space(unsigned long host_start,\n\n                               unsigned long host_size,\n\n                               unsigned long guest_start,\n\n                               bool fixed)\n\n{\n\n    unsigned long current_start, real_start;\n\n    int flags;\n\n\n\n    assert(host_start || host_size);\n\n\n\n    /* If just a starting address is given, then just verify that\n\n     * address.  */\n\n    if (host_start && !host_size) {\n\n        if (guest_validate_base(host_start)) {\n\n            return host_start;\n\n        } else {\n\n            return (unsigned long)-1;\n\n        }\n\n    }\n\n\n\n    /* Setup the initial flags and start address.  */\n\n    current_start = host_start & qemu_host_page_mask;\n\n    flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE;\n\n    if (fixed) {\n\n        flags |= MAP_FIXED;\n\n    }\n\n\n\n    /* Otherwise, a non-zero size region of memory needs to be mapped\n\n     * and validated.  */\n\n    while (1) {\n\n        /* Do not use mmap_find_vma here because that is limited to the\n\n         * guest address space.  We are going to make the\n\n         * guest address space fit whatever we're given.\n\n         */\n\n        real_start = (unsigned long)\n\n            mmap((void *)current_start, host_size, PROT_NONE, flags, -1, 0);\n\n        if (real_start == (unsigned long)-1) {\n\n            return (unsigned long)-1;\n\n        }\n\n\n\n        if ((real_start == current_start)\n\n            && guest_validate_base(real_start - guest_start)) {\n\n            break;\n\n        }\n\n\n\n        /* That address didn't work.  Unmap and try a different one.\n\n         * The address the host picked because is typically right at\n\n         * the top of the host address space and leaves the guest with\n\n         * no usable address space.  Resort to a linear search.  We\n\n         * already compensated for mmap_min_addr, so this should not\n\n         * happen often.  Probably means we got unlucky and host\n\n         * address space randomization put a shared library somewhere\n\n         * inconvenient.\n\n         */\n\n        munmap((void *)real_start, host_size);\n\n        current_start += qemu_host_page_size;\n\n        if (host_start == current_start) {\n\n            /* Theoretically possible if host doesn't have any suitably\n\n             * aligned areas.  Normally the first mmap will fail.\n\n             */\n\n            return (unsigned long)-1;\n\n        }\n\n    }\n\n\n\n    return real_start;\n\n}\n", "idx": 9598}
{"project": "qemu", "commit_id": "1452686495922b81d6cf43edf025c1aef15965c0", "target": 1, "func": "void qmp_drive_mirror(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_granularity, uint32_t granularity,\n\n                      bool has_buf_size, int64_t buf_size,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *source, *target_bs;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n    if (!has_granularity) {\n\n        granularity = 0;\n\n    }\n\n    if (!has_buf_size) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    if (granularity != 0 && (granularity < 512 || granularity > 1048576 * 64)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, device);\n\n        return;\n\n    }\n\n    if (granularity & (granularity - 1)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, device);\n\n        return;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_in_use(bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, device);\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n    source = bs->backing_hd;\n\n    if (!source && sync == MIRROR_SYNC_MODE_TOP) {\n\n        sync = MIRROR_SYNC_MODE_FULL;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (sync == MIRROR_SYNC_MODE_FULL && mode != NEW_IMAGE_MODE_EXISTING) {\n\n        /* create new image w/o backing file */\n\n        assert(format && drv);\n\n        bdrv_img_create(target, format,\n\n                        NULL, NULL, NULL, size, flags, &local_err, false);\n\n    } else {\n\n        switch (mode) {\n\n        case NEW_IMAGE_MODE_EXISTING:\n\n            break;\n\n        case NEW_IMAGE_MODE_ABSOLUTE_PATHS:\n\n            /* create new image with backing file */\n\n            bdrv_img_create(target, format,\n\n                            source->filename,\n\n                            source->drv->format_name,\n\n                            NULL, size, flags, &local_err, false);\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Mirroring takes care of copy-on-write using the source's backing\n\n     * file.\n\n     */\n\n    target_bs = bdrv_new(\"\");\n\n    ret = bdrv_open(target_bs, target, NULL, flags | BDRV_O_NO_BACKING, drv,\n\n                    &local_err);\n\n    if (ret < 0) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    mirror_start(bs, target_bs, speed, granularity, buf_size, sync,\n\n                 on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 844}
{"project": "qemu", "commit_id": "acaa75507b34f7b588924a09c76c6848d209e08c", "target": 1, "func": "static void set_seg(struct kvm_segment *lhs, const SegmentCache *rhs)\n\n{\n\n    unsigned flags = rhs->flags;\n\n    lhs->selector = rhs->selector;\n\n    lhs->base = rhs->base;\n\n    lhs->limit = rhs->limit;\n\n    lhs->type = (flags >> DESC_TYPE_SHIFT) & 15;\n\n    lhs->present = (flags & DESC_P_MASK) != 0;\n\n    lhs->dpl = rhs->selector & 3;\n\n    lhs->db = (flags >> DESC_B_SHIFT) & 1;\n\n    lhs->s = (flags & DESC_S_MASK) != 0;\n\n    lhs->l = (flags >> DESC_L_SHIFT) & 1;\n\n    lhs->g = (flags & DESC_G_MASK) != 0;\n\n    lhs->avl = (flags & DESC_AVL_MASK) != 0;\n\n    lhs->unusable = 0;\n\n}\n", "idx": 3571}
{"project": "qemu", "commit_id": "d70724cec84ff99ffc7f70dd567466acf228b389", "target": 1, "func": "static void dump_op_count(void)\n\n{\n\n    int i;\n\n    FILE *f;\n\n    f = fopen(\"/tmp/op.log\", \"w\");\n\n    for(i = INDEX_op_end; i < NB_OPS; i++) {\n\n        fprintf(f, \"%s %\" PRId64 \"\\n\", tcg_op_defs[i].name, tcg_table_op_count[i]);\n\n    }\n\n    fclose(f);\n\n}\n", "idx": 9516}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "struct vhost_net *vhost_net_init(VhostNetOptions *options)\n\n{\n\n    int r;\n\n    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n\n\n    if (!options->net_backend) {\n\n        fprintf(stderr, \"vhost-net requires net backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (backend_kernel) {\n\n        r = vhost_net_get_fd(options->net_backend);\n\n        if (r < 0) {\n\n            goto fail;\n\n        }\n\n        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)\n\n            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);\n\n        net->backend = r;\n\n    } else {\n\n        net->dev.backend_features = 0;\n\n        net->backend = -1;\n\n    }\n\n    net->nc = options->net_backend;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = net->nc->queue_index;\n\n\n\n    r = vhost_dev_init(&net->dev, options->opaque,\n\n                       options->backend_type, options->force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (backend_kernel) {\n\n        if (!qemu_has_vnet_hdr_len(options->net_backend,\n\n                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);\n\n        }\n\n        if (~net->dev.features & net->dev.backend_features) {\n\n            fprintf(stderr, \"vhost lacks feature mask %\" PRIu64\n\n                   \" for backend\\n\",\n\n                   (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n            vhost_dev_cleanup(&net->dev);\n\n            goto fail;\n\n        }\n\n    }\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 11640}
{"project": "qemu", "commit_id": "36cf2a37132c7f01fa9adb5f95f5312b27742fd4", "target": 1, "func": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");", "idx": 4939}
{"project": "qemu", "commit_id": "66dc50f7057b9a0191f54e55764412202306858d", "target": 1, "func": "void ioinst_handle_ssch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    ORB orig_orb, orb;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 4);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &orig_orb, sizeof(orb))) {\n\n        return;\n\n    }\n\n    copy_orb_from_guest(&orb, &orig_orb);\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_orb_valid(&orb)) {\n\n        program_interrupt(env, PGM_OPERAND, 4);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"ssch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_ssch(sch, &orb);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case -EFAULT:\n\n        /*\n\n         * TODO:\n\n         * I'm wondering whether there is something better\n\n         * to do for us here (like setting some device or\n\n         * subchannel status).\n\n         */\n\n        program_interrupt(env, PGM_ADDRESSING, 4);\n\n        return;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 7578}
{"project": "qemu", "commit_id": "024e5bb664bda54b393e405f425f10fa9d3fbd1a", "target": 1, "func": "static void nic_cleanup(VLANClientState *nc)\n\n{\n\n    dp8393xState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    cpu_unregister_io_memory(s->mmio_index);\n\n\n\n    qemu_del_timer(s->watchdog);\n\n    qemu_free_timer(s->watchdog);\n\n\n\n    g_free(s);\n\n}\n", "idx": 718}
{"project": "qemu", "commit_id": "924e8a2bbc7cc62b3996efe9a2a460f541c04520", "target": 1, "func": "static coroutine_fn int quorum_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQuorumState *s = bs->opaque;\n\n    QuorumVoteVersion *winner = NULL;\n\n    QuorumVotes error_votes;\n\n    QuorumVoteValue result_value;\n\n    int i;\n\n    int result = 0;\n\n\n\n    QLIST_INIT(&error_votes.vote_list);\n\n    error_votes.compare = quorum_64bits_compare;\n\n\n\n    for (i = 0; i < s->num_children; i++) {\n\n        result = bdrv_co_flush(s->children[i]->bs);\n\n        result_value.l = result;\n\n        quorum_count_vote(&error_votes, &result_value, i);\n\n    }\n\n\n\n    winner = quorum_get_vote_winner(&error_votes);\n\n    result = winner->value.l;\n\n\n\n    quorum_free_vote_list(&error_votes);\n\n\n\n    return result;\n\n}\n", "idx": 1256}
{"project": "qemu", "commit_id": "315a1309defd8ddf910c6c17e28cbbd7faf92f2e", "target": 1, "func": "void coroutine_fn qemu_coroutine_yield(void)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n    Coroutine *to = self->caller;\n\n\n\n    trace_qemu_coroutine_yield(self, to);\n\n\n\n    if (!to) {\n\n        fprintf(stderr, \"Co-routine is yielding to no one\\n\");\n\n        abort();\n\n    }\n\n\n\n    self->caller = NULL;\n\n    coroutine_swap(self, to);\n\n}\n", "idx": 4900}
{"project": "qemu", "commit_id": "3a8f2a9ce51036ab2d25bcc31114b5cbb72ab44b", "target": 1, "func": "void pcie_host_mmcfg_init(PCIExpressHost *e, uint32_t size)\n\n{\n\n    assert(!(size & (size - 1)));       /* power of 2 */\n\n    assert(size >= PCIE_MMCFG_SIZE_MIN);\n\n    assert(size <= PCIE_MMCFG_SIZE_MAX);\n\n    e->size = size;\n\n    memory_region_init_io(&e->mmio, OBJECT(e), &pcie_mmcfg_ops, e,\n\n                          \"pcie-mmcfg\", e->size);\n\n}\n", "idx": 8803}
{"project": "qemu", "commit_id": "19ebd13ed45ad5d5f277f5914d55b83f13eb09eb", "target": 1, "func": "static void commit_complete(BlockJob *job, void *opaque)\n{\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n    CommitCompleteData *data = opaque;\n    BlockDriverState *active = s->active;\n    BlockDriverState *top = blk_bs(s->top);\n    BlockDriverState *base = blk_bs(s->base);\n    BlockDriverState *overlay_bs = bdrv_find_overlay(active, s->commit_top_bs);\n    int ret = data->ret;\n    bool remove_commit_top_bs = false;\n    /* Make sure overlay_bs and top stay around until bdrv_set_backing_hd() */\n    bdrv_ref(top);\n    bdrv_ref(overlay_bs);\n    /* Remove base node parent that still uses BLK_PERM_WRITE/RESIZE before\n     * the normal backing chain can be restored. */\n    blk_unref(s->base);\n    if (!block_job_is_cancelled(&s->common) && ret == 0) {\n        /* success */\n        ret = bdrv_drop_intermediate(active, s->commit_top_bs, base,\n                                     s->backing_file_str);\n    } else if (overlay_bs) {\n        /* XXX Can (or should) we somehow keep 'consistent read' blocked even\n         * after the failed/cancelled commit job is gone? If we already wrote\n         * something to base, the intermediate images aren't valid any more. */\n        remove_commit_top_bs = true;\n    }\n    /* restore base open flags here if appropriate (e.g., change the base back\n     * to r/o). These reopens do not need to be atomic, since we won't abort\n     * even on failure here */\n    if (s->base_flags != bdrv_get_flags(base)) {\n        bdrv_reopen(base, s->base_flags, NULL);\n    }\n    if (overlay_bs && s->orig_overlay_flags != bdrv_get_flags(overlay_bs)) {\n        bdrv_reopen(overlay_bs, s->orig_overlay_flags, NULL);\n    }\n    g_free(s->backing_file_str);\n    blk_unref(s->top);\n    block_job_completed(&s->common, ret);\n    g_free(data);\n    /* If bdrv_drop_intermediate() didn't already do that, remove the commit\n     * filter driver from the backing chain. Do this as the final step so that\n     * the 'consistent read' permission can be granted.  */\n    if (remove_commit_top_bs) {\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n    }\n}", "idx": 2482}
{"project": "qemu", "commit_id": "d5a8ee60a0fbc20a2c2d02f3bda1bb1bd365f1ee", "target": 1, "func": "BlockDeviceInfoList *bdrv_named_nodes_list(void)\n\n{\n\n    BlockDeviceInfoList *list, *entry;\n\n    BlockDriverState *bs;\n\n\n\n    list = NULL;\n\n    QTAILQ_FOREACH(bs, &graph_bdrv_states, node_list) {\n\n        entry = g_malloc0(sizeof(*entry));\n\n        entry->value = bdrv_block_device_info(bs);\n\n        entry->next = list;\n\n        list = entry;\n\n    }\n\n\n\n    return list;\n\n}\n", "idx": 5826}
{"project": "qemu", "commit_id": "f693fe6ef402bdcf89b3979bf004c4c5bf646724", "target": 1, "func": "GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)\n\n{\n\n    GuestMemoryBlockList *head, **link;\n\n    Error *local_err = NULL;\n\n    struct dirent *de;\n\n    DIR *dp;\n\n\n\n    head = NULL;\n\n    link = &head;\n\n\n\n    dp = opendir(\"/sys/devices/system/memory/\");\n\n    if (!dp) {\n\n        error_setg_errno(errp, errno, \"Can't open directory\"\n\n                         \"\\\"/sys/devices/system/memory/\\\"\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    /* Note: the phys_index of memory block may be discontinuous,\n\n     * this is because a memblk is the unit of the Sparse Memory design, which\n\n     * allows discontinuous memory ranges (ex. NUMA), so here we should\n\n     * traverse the memory block directory.\n\n     */\n\n    while ((de = readdir(dp)) != NULL) {\n\n        GuestMemoryBlock *mem_blk;\n\n        GuestMemoryBlockList *entry;\n\n\n\n        if ((strncmp(de->d_name, \"memory\", 6) != 0) ||\n\n            !(de->d_type & DT_DIR)) {\n\n            continue;\n\n        }\n\n\n\n        mem_blk = g_malloc0(sizeof *mem_blk);\n\n        /* The d_name is \"memoryXXX\",  phys_index is block id, same as XXX */\n\n        mem_blk->phys_index = strtoul(&de->d_name[6], NULL, 10);\n\n        mem_blk->has_can_offline = true; /* lolspeak ftw */\n\n        transfer_memory_block(mem_blk, true, NULL, &local_err);\n\n\n\n        entry = g_malloc0(sizeof *entry);\n\n        entry->value = mem_blk;\n\n\n\n        *link = entry;\n\n        link = &entry->next;\n\n    }\n\n\n\n    closedir(dp);\n\n    if (local_err == NULL) {\n\n        /* there's no guest with zero memory blocks */\n\n        if (head == NULL) {\n\n            error_setg(errp, \"guest reported zero memory blocks!\");\n\n        }\n\n        return head;\n\n    }\n\n\n\n    qapi_free_GuestMemoryBlockList(head);\n\n    error_propagate(errp, local_err);\n\n    return NULL;\n\n}\n", "idx": 8464}
{"project": "qemu", "commit_id": "e7c8526b2a1482a9b14319fda9f8ad4bfda5b958", "target": 1, "func": "void ahci_hba_enable(AHCIQState *ahci)\n\n{\n\n    /* Bits of interest in this section:\n\n     * GHC.AE     Global Host Control / AHCI Enable\n\n     * PxCMD.ST   Port Command: Start\n\n     * PxCMD.SUD  \"Spin Up Device\"\n\n     * PxCMD.POD  \"Power On Device\"\n\n     * PxCMD.FRE  \"FIS Receive Enable\"\n\n     * PxCMD.FR   \"FIS Receive Running\"\n\n     * PxCMD.CR   \"Command List Running\"\n\n     */\n\n    uint32_t reg, ports_impl;\n\n    uint16_t i;\n\n    uint8_t num_cmd_slots;\n\n\n\n    g_assert(ahci != NULL);\n\n\n\n    /* Set GHC.AE to 1 */\n\n    ahci_set(ahci, AHCI_GHC, AHCI_GHC_AE);\n\n    reg = ahci_rreg(ahci, AHCI_GHC);\n\n    ASSERT_BIT_SET(reg, AHCI_GHC_AE);\n\n\n\n    /* Cache CAP and CAP2. */\n\n    ahci->cap = ahci_rreg(ahci, AHCI_CAP);\n\n    ahci->cap2 = ahci_rreg(ahci, AHCI_CAP2);\n\n\n\n    /* Read CAP.NCS, how many command slots do we have? */\n\n    num_cmd_slots = ((ahci->cap & AHCI_CAP_NCS) >> ctzl(AHCI_CAP_NCS)) + 1;\n\n    g_test_message(\"Number of Command Slots: %u\", num_cmd_slots);\n\n\n\n    /* Determine which ports are implemented. */\n\n    ports_impl = ahci_rreg(ahci, AHCI_PI);\n\n\n\n    for (i = 0; ports_impl; ports_impl >>= 1, ++i) {\n\n        if (!(ports_impl & 0x01)) {\n\n            continue;\n\n        }\n\n\n\n        g_test_message(\"Initializing port %u\", i);\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n        if (BITCLR(reg, AHCI_PX_CMD_ST | AHCI_PX_CMD_CR |\n\n                   AHCI_PX_CMD_FRE | AHCI_PX_CMD_FR)) {\n\n            g_test_message(\"port is idle\");\n\n        } else {\n\n            g_test_message(\"port needs to be idled\");\n\n            ahci_px_clr(ahci, i, AHCI_PX_CMD,\n\n                        (AHCI_PX_CMD_ST | AHCI_PX_CMD_FRE));\n\n            /* The port has 500ms to disengage. */\n\n            usleep(500000);\n\n            reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n            ASSERT_BIT_CLEAR(reg, AHCI_PX_CMD_CR);\n\n            ASSERT_BIT_CLEAR(reg, AHCI_PX_CMD_FR);\n\n            g_test_message(\"port is now idle\");\n\n            /* The spec does allow for possibly needing a PORT RESET\n\n             * or HBA reset if we fail to idle the port. */\n\n        }\n\n\n\n        /* Allocate Memory for the Command List Buffer & FIS Buffer */\n\n        /* PxCLB space ... 0x20 per command, as in 4.2.2 p 36 */\n\n        ahci->port[i].clb = ahci_alloc(ahci, num_cmd_slots * 0x20);\n\n        qmemset(ahci->port[i].clb, 0x00, num_cmd_slots * 0x20);\n\n        g_test_message(\"CLB: 0x%08\" PRIx64, ahci->port[i].clb);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_CLB, ahci->port[i].clb);\n\n        g_assert_cmphex(ahci->port[i].clb, ==,\n\n                        ahci_px_rreg(ahci, i, AHCI_PX_CLB));\n\n\n\n        /* PxFB space ... 0x100, as in 4.2.1 p 35 */\n\n        ahci->port[i].fb = ahci_alloc(ahci, 0x100);\n\n        qmemset(ahci->port[i].fb, 0x00, 0x100);\n\n        g_test_message(\"FB: 0x%08\" PRIx64, ahci->port[i].fb);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_FB, ahci->port[i].fb);\n\n        g_assert_cmphex(ahci->port[i].fb, ==,\n\n                        ahci_px_rreg(ahci, i, AHCI_PX_FB));\n\n\n\n        /* Clear PxSERR, PxIS, then IS.IPS[x] by writing '1's. */\n\n        ahci_px_wreg(ahci, i, AHCI_PX_SERR, 0xFFFFFFFF);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_IS, 0xFFFFFFFF);\n\n        ahci_wreg(ahci, AHCI_IS, (1 << i));\n\n\n\n        /* Verify Interrupts Cleared */\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_SERR);\n\n        g_assert_cmphex(reg, ==, 0);\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_IS);\n\n        g_assert_cmphex(reg, ==, 0);\n\n\n\n        reg = ahci_rreg(ahci, AHCI_IS);\n\n        ASSERT_BIT_CLEAR(reg, (1 << i));\n\n\n\n        /* Enable All Interrupts: */\n\n        ahci_px_wreg(ahci, i, AHCI_PX_IE, 0xFFFFFFFF);\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_IE);\n\n        g_assert_cmphex(reg, ==, ~((uint32_t)AHCI_PX_IE_RESERVED));\n\n\n\n        /* Enable the FIS Receive Engine. */\n\n        ahci_px_set(ahci, i, AHCI_PX_CMD, AHCI_PX_CMD_FRE);\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n        ASSERT_BIT_SET(reg, AHCI_PX_CMD_FR);\n\n\n\n        /* AHCI 1.3 spec: if !STS.BSY, !STS.DRQ and PxSSTS.DET indicates\n\n         * physical presence, a device is present and may be started. However,\n\n         * PxSERR.DIAG.X /may/ need to be cleared a priori. */\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_SERR);\n\n        if (BITSET(reg, AHCI_PX_SERR_DIAG_X)) {\n\n            ahci_px_set(ahci, i, AHCI_PX_SERR, AHCI_PX_SERR_DIAG_X);\n\n        }\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_TFD);\n\n        if (BITCLR(reg, AHCI_PX_TFD_STS_BSY | AHCI_PX_TFD_STS_DRQ)) {\n\n            reg = ahci_px_rreg(ahci, i, AHCI_PX_SSTS);\n\n            if ((reg & AHCI_PX_SSTS_DET) == SSTS_DET_ESTABLISHED) {\n\n                /* Device Found: set PxCMD.ST := 1 */\n\n                ahci_px_set(ahci, i, AHCI_PX_CMD, AHCI_PX_CMD_ST);\n\n                ASSERT_BIT_SET(ahci_px_rreg(ahci, i, AHCI_PX_CMD),\n\n                               AHCI_PX_CMD_CR);\n\n                g_test_message(\"Started Device %u\", i);\n\n            } else if ((reg & AHCI_PX_SSTS_DET)) {\n\n                /* Device present, but in some unknown state. */\n\n                g_assert_not_reached();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* Enable GHC.IE */\n\n    ahci_set(ahci, AHCI_GHC, AHCI_GHC_IE);\n\n    reg = ahci_rreg(ahci, AHCI_GHC);\n\n    ASSERT_BIT_SET(reg, AHCI_GHC_IE);\n\n\n\n\n    /* TODO: The device should now be idling and waiting for commands.\n\n     * In the future, a small test-case to inspect the Register D2H FIS\n\n     * and clear the initial interrupts might be good. */\n\n}", "idx": 1172}
{"project": "qemu", "commit_id": "5f5a1318653c08e435cfa52f60b6a712815b659d", "target": 1, "func": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n\n{\n\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    uint8_t val;\n\n\n\n    k->get_config(vdev, vdev->config);\n\n\n\n    if (addr > (vdev->config_len - sizeof(val)))\n\n        return (uint32_t)-1;\n\n\n\n    val = ldub_p(vdev->config + addr);\n\n    return val;\n\n}\n", "idx": 8297}
{"project": "qemu", "commit_id": "de7b685c9e1cf606e37e7116e4c4f03a6ae2d14f", "target": 1, "func": "size_t ram_control_save_page(QEMUFile *f, ram_addr_t block_offset,\n\n                         ram_addr_t offset, size_t size, int *bytes_sent)\n\n{\n\n    if (f->ops->save_page) {\n\n        int ret = f->ops->save_page(f, f->opaque, block_offset,\n\n                                    offset, size, bytes_sent);\n\n\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (*bytes_sent > 0) {\n\n                qemu_update_position(f, *bytes_sent);\n\n            } else if (ret < 0) {\n\n                qemu_file_set_error(f, ret);\n\n            }\n\n        }\n\n\n\n        return ret;\n\n    }\n\n\n\n    return RAM_SAVE_CONTROL_NOT_SUPP;\n\n}\n", "idx": 11036}
{"project": "qemu", "commit_id": "2466119c9551d606a0f92f9832e0c865bc04b488", "target": 1, "func": "static inline int host_to_target_errno(int err)\n\n{\n\n    if(host_to_target_errno_table[err])\n\n        return host_to_target_errno_table[err];\n\n    return err;\n\n}\n", "idx": 4016}
{"project": "qemu", "commit_id": "ebfe27c593e5b222aa2a1fc545b447be3d995faa", "target": 1, "func": "static void disas_thumb_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t val, insn, op, rm, rn, rd, shift, cond;\n\n    int32_t offset;\n\n    int i;\n\n    TCGv_i32 tmp;\n\n    TCGv_i32 tmp2;\n\n    TCGv_i32 addr;\n\n\n\n    if (s->condexec_mask) {\n\n        cond = s->condexec_cond;\n\n        if (cond != 0x0e) {     /* Skip conditional when condition is AL. */\n\n          s->condlabel = gen_new_label();\n\n          arm_gen_test_cc(cond ^ 1, s->condlabel);\n\n          s->condjmp = 1;\n\n        }\n\n    }\n\n\n\n    insn = arm_lduw_code(env, s->pc, s->sctlr_b);\n\n    s->pc += 2;\n\n\n\n    switch (insn >> 12) {\n\n    case 0: case 1:\n\n\n\n        rd = insn & 7;\n\n        op = (insn >> 11) & 3;\n\n        if (op == 3) {\n\n            /* add/subtract */\n\n            rn = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rn);\n\n            if (insn & (1 << 10)) {\n\n                /* immediate */\n\n                tmp2 = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp2, (insn >> 6) & 7);\n\n            } else {\n\n                /* reg */\n\n                rm = (insn >> 6) & 7;\n\n                tmp2 = load_reg(s, rm);\n\n            }\n\n            if (insn & (1 << 9)) {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n            } else {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n            }\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* shift immediate */\n\n            rm = (insn >> 3) & 7;\n\n            shift = (insn >> 6) & 0x1f;\n\n            tmp = load_reg(s, rm);\n\n            gen_arm_shift_im(tmp, op, shift, s->condexec_mask == 0);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        }\n\n        break;\n\n    case 2: case 3:\n\n        /* arithmetic large immediate */\n\n        op = (insn >> 11) & 3;\n\n        rd = (insn >> 8) & 0x7;\n\n        if (op == 0) { /* mov */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, insn & 0xff);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tmp = load_reg(s, rd);\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, insn & 0xff);\n\n            switch (op) {\n\n            case 1: /* cmp */\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n                break;\n\n            case 2: /* add */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3: /* sub */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 4:\n\n        if (insn & (1 << 11)) {\n\n            rd = (insn >> 8) & 7;\n\n            /* load pc-relative.  Bit 1 of PC is ignored.  */\n\n            val = s->pc + 2 + ((insn & 0xff) * 4);\n\n            val &= ~(uint32_t)2;\n\n            addr = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(addr, val);\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s),\n\n                               rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(addr);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n        if (insn & (1 << 10)) {\n\n            /* data processing extended or blx */\n\n            rd = (insn & 7) | ((insn >> 4) & 8);\n\n            rm = (insn >> 3) & 0xf;\n\n            op = (insn >> 8) & 3;\n\n            switch (op) {\n\n            case 0: /* add */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 1: /* cmp */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                break;\n\n            case 2: /* mov/cpy */\n\n                tmp = load_reg(s, rm);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3:/* branch [and link] exchange thumb register */\n\n                tmp = load_reg(s, rm);\n\n                if (insn & (1 << 7)) {\n\n                    ARCH(5);\n\n                    val = (uint32_t)s->pc | 1;\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp2, val);\n\n                    store_reg(s, 14, tmp2);\n\n                    gen_bx(s, tmp);\n\n                } else {\n\n                    /* Only BX works as exception-return, not BLX */\n\n                    gen_bx_excret(s, tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n\n\n        /* data processing register */\n\n        rd = insn & 7;\n\n        rm = (insn >> 3) & 7;\n\n        op = (insn >> 6) & 0xf;\n\n        if (op == 2 || op == 3 || op == 4 || op == 7) {\n\n            /* the shift/rotate ops want the operands backwards */\n\n            val = rm;\n\n            rm = rd;\n\n            rd = val;\n\n            val = 1;\n\n        } else {\n\n            val = 0;\n\n        }\n\n\n\n        if (op == 9) { /* neg */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, 0);\n\n        } else if (op != 0xf) { /* mvn doesn't read its first operand */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            TCGV_UNUSED_I32(tmp);\n\n        }\n\n\n\n        tmp2 = load_reg(s, rm);\n\n        switch (op) {\n\n        case 0x0: /* and */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x1: /* eor */\n\n            tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x2: /* lsl */\n\n            if (s->condexec_mask) {\n\n                gen_shl(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shl_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x3: /* lsr */\n\n            if (s->condexec_mask) {\n\n                gen_shr(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shr_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x4: /* asr */\n\n            if (s->condexec_mask) {\n\n                gen_sar(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_sar_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x5: /* adc */\n\n            if (s->condexec_mask) {\n\n                gen_adc(tmp, tmp2);\n\n            } else {\n\n                gen_adc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x6: /* sbc */\n\n            if (s->condexec_mask) {\n\n                gen_sub_carry(tmp, tmp, tmp2);\n\n            } else {\n\n                gen_sbc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x7: /* ror */\n\n            if (s->condexec_mask) {\n\n                tcg_gen_andi_i32(tmp, tmp, 0x1f);\n\n                tcg_gen_rotr_i32(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_ror_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x8: /* tst */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            gen_logic_CC(tmp);\n\n            rd = 16;\n\n            break;\n\n        case 0x9: /* neg */\n\n            if (s->condexec_mask)\n\n                tcg_gen_neg_i32(tmp, tmp2);\n\n            else\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n            break;\n\n        case 0xa: /* cmp */\n\n            gen_sub_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xb: /* cmn */\n\n            gen_add_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xc: /* orr */\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xd: /* mul */\n\n            tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xe: /* bic */\n\n            tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xf: /* mvn */\n\n            tcg_gen_not_i32(tmp2, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp2);\n\n            val = 1;\n\n            rm = rd;\n\n            break;\n\n        }\n\n        if (rd != 16) {\n\n            if (val) {\n\n                store_reg(s, rm, tmp2);\n\n                if (op != 0xf)\n\n                    tcg_temp_free_i32(tmp);\n\n            } else {\n\n                store_reg(s, rd, tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n            }\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n            tcg_temp_free_i32(tmp2);\n\n        }\n\n        break;\n\n\n\n    case 5:\n\n        /* load/store register offset.  */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        rm = (insn >> 6) & 7;\n\n        op = (insn >> 9) & 7;\n\n        addr = load_reg(s, rn);\n\n        tmp = load_reg(s, rm);\n\n        tcg_gen_add_i32(addr, addr, tmp);\n\n        tcg_temp_free_i32(tmp);\n\n\n\n        if (op < 3) { /* store */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            tmp = tcg_temp_new_i32();\n\n        }\n\n\n\n        switch (op) {\n\n        case 0: /* str */\n\n            gen_aa32_st32_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 1: /* strh */\n\n            gen_aa32_st16_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 2: /* strb */\n\n            gen_aa32_st8_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 3: /* ldrsb */\n\n            gen_aa32_ld8s_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 4: /* ldr */\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 5: /* ldrh */\n\n            gen_aa32_ld16u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 6: /* ldrb */\n\n            gen_aa32_ld8u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 7: /* ldrsh */\n\n            gen_aa32_ld16s_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        }\n\n        if (op >= 3) { /* load */\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 6:\n\n        /* load/store word immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 4) & 0x7c;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 7:\n\n        /* load/store byte immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 6) & 0x1f;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld8u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st8_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 8:\n\n        /* load/store halfword immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 5) & 0x3e;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld16u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st16_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 9:\n\n        /* load/store from stack */\n\n        rd = (insn >> 8) & 7;\n\n        addr = load_reg(s, 13);\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 10:\n\n        /* add to high reg */\n\n        rd = (insn >> 8) & 7;\n\n        if (insn & (1 << 11)) {\n\n            /* SP */\n\n            tmp = load_reg(s, 13);\n\n        } else {\n\n            /* PC. bit 1 is ignored.  */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, (s->pc + 2) & ~(uint32_t)2);\n\n        }\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(tmp, tmp, val);\n\n        store_reg(s, rd, tmp);\n\n        break;\n\n\n\n    case 11:\n\n        /* misc */\n\n        op = (insn >> 8) & 0xf;\n\n        switch (op) {\n\n        case 0:\n\n            /* adjust stack pointer */\n\n            tmp = load_reg(s, 13);\n\n            val = (insn & 0x7f) * 4;\n\n            if (insn & (1 << 7))\n\n                val = -(int32_t)val;\n\n            tcg_gen_addi_i32(tmp, tmp, val);\n\n            store_reg(s, 13, tmp);\n\n            break;\n\n\n\n        case 2: /* sign/zero extend.  */\n\n            ARCH(6);\n\n            rd = insn & 7;\n\n            rm = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rm);\n\n            switch ((insn >> 6) & 3) {\n\n            case 0: gen_sxth(tmp); break;\n\n            case 1: gen_sxtb(tmp); break;\n\n            case 2: gen_uxth(tmp); break;\n\n            case 3: gen_uxtb(tmp); break;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 4: case 5: case 0xc: case 0xd:\n\n            /* push/pop */\n\n            addr = load_reg(s, 13);\n\n            if (insn & (1 << 8))\n\n                offset = 4;\n\n            else\n\n                offset = 0;\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i))\n\n                    offset += 4;\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i)) {\n\n                    if (insn & (1 << 11)) {\n\n                        /* pop */\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                        store_reg(s, i, tmp);\n\n                    } else {\n\n                        /* push */\n\n                        tmp = load_reg(s, i);\n\n                        gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                        tcg_temp_free_i32(tmp);\n\n                    }\n\n                    /* advance to the next address.  */\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                }\n\n            }\n\n            TCGV_UNUSED_I32(tmp);\n\n            if (insn & (1 << 8)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* pop pc */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                    /* don't set the pc until the rest of the instruction\n\n                       has completed */\n\n                } else {\n\n                    /* push lr */\n\n                    tmp = load_reg(s, 14);\n\n                    gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            /* write back the new stack pointer */\n\n            store_reg(s, 13, addr);\n\n            /* set the new PC value */\n\n            if ((insn & 0x0900) == 0x0900) {\n\n                store_reg_from_load(s, 15, tmp);\n\n            }\n\n            break;\n\n\n\n        case 1: case 3: case 9: case 11: /* czb */\n\n            rm = insn & 7;\n\n            tmp = load_reg(s, rm);\n\n            s->condlabel = gen_new_label();\n\n            s->condjmp = 1;\n\n            if (insn & (1 << 11))\n\n                tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, s->condlabel);\n\n            else\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, s->condlabel);\n\n            tcg_temp_free_i32(tmp);\n\n            offset = ((insn & 0xf8) >> 2) | (insn & 0x200) >> 3;\n\n            val = (uint32_t)s->pc + 2;\n\n            val += offset;\n\n            gen_jmp(s, val);\n\n            break;\n\n\n\n        case 15: /* IT, nop-hint.  */\n\n            if ((insn & 0xf) == 0) {\n\n                gen_nop_hint(s, (insn >> 4) & 0xf);\n\n                break;\n\n            }\n\n            /* If Then.  */\n\n            s->condexec_cond = (insn >> 4) & 0xe;\n\n            s->condexec_mask = insn & 0x1f;\n\n            /* No actual code generated for this insn, just setup state.  */\n\n            break;\n\n\n\n        case 0xe: /* bkpt */\n\n        {\n\n            int imm8 = extract32(insn, 0, 8);\n\n            ARCH(5);\n\n            gen_exception_insn(s, 2, EXCP_BKPT, syn_aa32_bkpt(imm8, true),\n\n                               default_exception_el(s));\n\n            break;\n\n        }\n\n\n\n        case 0xa: /* rev, and hlt */\n\n        {\n\n            int op1 = extract32(insn, 6, 2);\n\n\n\n            if (op1 == 2) {\n\n                /* HLT */\n\n                int imm6 = extract32(insn, 0, 6);\n\n\n\n                gen_hlt(s, imm6);\n\n                break;\n\n            }\n\n\n\n            /* Otherwise this is rev */\n\n            ARCH(6);\n\n            rn = (insn >> 3) & 0x7;\n\n            rd = insn & 0x7;\n\n            tmp = load_reg(s, rn);\n\n            switch (op1) {\n\n            case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n            case 1: gen_rev16(tmp); break;\n\n            case 3: gen_revsh(tmp); break;\n\n            default:\n\n                g_assert_not_reached();\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n\n\n        case 6:\n\n            switch ((insn >> 5) & 7) {\n\n            case 2:\n\n                /* setend */\n\n                ARCH(6);\n\n                if (((insn >> 3) & 1) != !!(s->be_data == MO_BE)) {\n\n                    gen_helper_setend(cpu_env);\n\n                    s->is_jmp = DISAS_UPDATE;\n\n                }\n\n                break;\n\n            case 3:\n\n                /* cps */\n\n                ARCH(6);\n\n                if (IS_USER(s)) {\n\n                    break;\n\n                }\n\n                if (arm_dc_feature(s, ARM_FEATURE_M)) {\n\n                    tmp = tcg_const_i32((insn & (1 << 4)) != 0);\n\n                    /* FAULTMASK */\n\n                    if (insn & 1) {\n\n                        addr = tcg_const_i32(19);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    /* PRIMASK */\n\n                    if (insn & 2) {\n\n                        addr = tcg_const_i32(16);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    tcg_temp_free_i32(tmp);\n\n                    gen_lookup_tb(s);\n\n                } else {\n\n                    if (insn & (1 << 4)) {\n\n                        shift = CPSR_A | CPSR_I | CPSR_F;\n\n                    } else {\n\n                        shift = 0;\n\n                    }\n\n                    gen_set_psr_im(s, ((insn & 7) << 6), 0, shift);\n\n                }\n\n                break;\n\n            default:\n\n                goto undef;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto undef;\n\n        }\n\n        break;\n\n\n\n    case 12:\n\n    {\n\n        /* load/store multiple */\n\n        TCGv_i32 loaded_var;\n\n        TCGV_UNUSED_I32(loaded_var);\n\n        rn = (insn >> 8) & 0x7;\n\n        addr = load_reg(s, rn);\n\n        for (i = 0; i < 8; i++) {\n\n            if (insn & (1 << i)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* load */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                    if (i == rn) {\n\n                        loaded_var = tmp;\n\n                    } else {\n\n                        store_reg(s, i, tmp);\n\n                    }\n\n                } else {\n\n                    /* store */\n\n                    tmp = load_reg(s, i);\n\n                    gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                /* advance to the next address */\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n        }\n\n        if ((insn & (1 << rn)) == 0) {\n\n            /* base reg not in list: base register writeback */\n\n            store_reg(s, rn, addr);\n\n        } else {\n\n            /* base reg in list: if load, complete it now */\n\n            if (insn & (1 << 11)) {\n\n                store_reg(s, rn, loaded_var);\n\n            }\n\n            tcg_temp_free_i32(addr);\n\n        }\n\n        break;\n\n    }\n\n    case 13:\n\n        /* conditional branch or swi */\n\n        cond = (insn >> 8) & 0xf;\n\n        if (cond == 0xe)\n\n            goto undef;\n\n\n\n        if (cond == 0xf) {\n\n            /* swi */\n\n            gen_set_pc_im(s, s->pc);\n\n            s->svc_imm = extract32(insn, 0, 8);\n\n            s->is_jmp = DISAS_SWI;\n\n            break;\n\n        }\n\n        /* generate a conditional jump to next instruction */\n\n        s->condlabel = gen_new_label();\n\n        arm_gen_test_cc(cond ^ 1, s->condlabel);\n\n        s->condjmp = 1;\n\n\n\n        /* jump to the offset */\n\n        val = (uint32_t)s->pc + 2;\n\n        offset = ((int32_t)insn << 24) >> 24;\n\n        val += offset << 1;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 14:\n\n        if (insn & (1 << 11)) {\n\n            if (disas_thumb2_insn(env, s, insn))\n\n              goto undef32;\n\n            break;\n\n        }\n\n        /* unconditional branch */\n\n        val = (uint32_t)s->pc;\n\n        offset = ((int32_t)insn << 21) >> 21;\n\n        val += (offset << 1) + 2;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 15:\n\n        if (disas_thumb2_insn(env, s, insn))\n\n            goto undef32;\n\n        break;\n\n    }\n\n    return;\n\nundef32:\n\n    gen_exception_insn(s, 4, EXCP_UDEF, syn_uncategorized(),\n\n                       default_exception_el(s));\n\n    return;\n\nillegal_op:\n\nundef:\n\n    gen_exception_insn(s, 2, EXCP_UDEF, syn_uncategorized(),\n\n                       default_exception_el(s));\n\n}\n", "idx": 2042}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 8903}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void ppc_heathrow_init (ram_addr_t ram_size,\n\n                               const char *boot_device,\n\n                               const char *kernel_filename,\n\n                               const char *kernel_cmdline,\n\n                               const char *initrd_filename,\n\n                               const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **heathrow_irqs;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, initrd_base;\n\n    int32_t kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, nvram_mem_index, dbdma_mem_index, cuda_mem_index;\n\n    int escc_mem_index, ide_mem_index[2];\n\n    uint16_t ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"G3\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 16.6 Mhz */\n\n        cpu_ppc_tb_init(env,  16600000UL);\n\n        env->osi_call = vga_osi_call;\n\n        qemu_register_reset(&cpu_ppc_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    if (ram_size > (2047 << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 2047 MB\\n\",\n\n                ((unsigned int)ram_size / (1 << 20)));\n\n        exit(1);\n\n    }\n\n\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, 0, NULL, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* Now we can load the kernel. The first step tries to load the kernel\n\n           supposing PhysAddr = 0x00000000. If that was wrong the kernel is\n\n           loaded again, the new PhysAddr being computed from lowaddr. */\n\n        kernel_size = load_elf(kernel_filename, kernel_base, NULL, &lowaddr, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        if (kernel_size > 0 && lowaddr != KERNEL_LOAD_ADDR) {\n\n            kernel_size = load_elf(kernel_filename, (2 * kernel_base) - lowaddr,\n\n                                   NULL, NULL, NULL, 1, ELF_MACHINE, 0);\n\n        }\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            /* TOFIX: for now, the second IDE channel is not properly\n\n             *        used by OHW. The Mac floppy disk are not emulated.\n\n             *        For now, OHW cannot boot from the network.\n\n             */\n\n#if 0\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#else\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'd') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#endif\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for G3 Beige machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 2 MB of ISA IO space */\n\n    isa_mmio_init(0xfe000000, 0x00200000);\n\n\n\n    /* XXX: we register only 1 output pin for heathrow PIC */\n\n    heathrow_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    heathrow_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * 1);\n\n    /* Connect the heathrow PIC outputs to the 6xx bus */\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            heathrow_irqs[i] = heathrow_irqs[0] + (i * 1);\n\n            heathrow_irqs[i][0] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            break;\n\n        default:\n\n            hw_error(\"Bus model not supported on OldWorld Mac machine\\n\");\n\n        }\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on heathrow machine\\n\");\n\n    }\n\n    pic = heathrow_pic_init(&pic_mem_index, 1, heathrow_irqs);\n\n    pci_bus = pci_grackle_init(0xfec00000, pic);\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x0f], pic[0x10], serial_hds[0],\n\n                               serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* First IDE channel is a MAC IDE on the MacIO bus */\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n    ide_mem_index[0] = -1;\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0D], dbdma, 0x16, pic[0x02]);\n\n\n\n    /* Second IDE channel is a CMD646 on the PCI bus */\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    hd[3] = hd[2] = NULL;\n\n    pci_cmd646_ide_init(pci_bus, hd, 0);\n\n\n\n    /* cuda also initialize ADB */\n\n    cuda_init(&cuda_mem_index, pic[0x12]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 4);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_343S1201, 1, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, nvr, 2, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, ARCH_HEATHROW);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 9552}
{"project": "qemu", "commit_id": "3e80bf9351f8fec9085c46df6da075efd5e71003", "target": 1, "func": "int qemu_sendv(int sockfd, struct iovec *iov, int len, int iov_offset)\n\n{\n\n    return do_sendv_recvv(sockfd, iov, len, iov_offset, 1);\n\n}\n", "idx": 1232}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static QVirtioPCIDevice *virtio_blk_pci_init(QPCIBus *bus, int slot)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_BLOCK);\n\n    g_assert(dev != NULL);\n\n    g_assert_cmphex(dev->vdev.device_type, ==, VIRTIO_ID_BLOCK);\n\n    g_assert_cmphex(dev->pdev->devfn, ==, ((slot << 3) | PCI_FN));\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    return dev;\n\n}\n", "idx": 8033}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void isabus_fdc_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = isabus_fdc_realize;\n\n    dc->fw_name = \"fdc\";\n\n    dc->no_user = 1;\n\n    dc->reset = fdctrl_external_reset_isa;\n\n    dc->vmsd = &vmstate_isa_fdc;\n\n    dc->props = isa_fdc_properties;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n}\n", "idx": 9718}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "void tcg_func_start(TCGContext *s)\n\n{\n\n    tcg_pool_reset(s);\n\n    s->nb_temps = s->nb_globals;\n\n\n\n    /* No temps have been previously allocated for size or locality.  */\n\n    memset(s->free_temps, 0, sizeof(s->free_temps));\n\n\n\n    s->nb_labels = 0;\n\n    s->current_frame_offset = s->frame_start;\n\n\n\n#ifdef CONFIG_DEBUG_TCG\n\n    s->goto_tb_issue_mask = 0;\n\n#endif\n\n\n\n    s->gen_op_buf[0].next = 1;\n\n    s->gen_op_buf[0].prev = 0;\n\n    s->gen_next_op_idx = 1;\n\n}\n", "idx": 2413}
{"project": "qemu", "commit_id": "d59ce6f34434bf47a9b26138c908650bf9a24be1", "target": 1, "func": "void hmp_info_migrate(Monitor *mon, const QDict *qdict)\n\n{\n\n    MigrationInfo *info;\n\n    MigrationCapabilityStatusList *caps, *cap;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    caps = qmp_query_migrate_capabilities(NULL);\n\n\n\n    /* do not display parameters during setup */\n\n    if (info->has_status && caps) {\n\n        monitor_printf(mon, \"capabilities: \");\n\n        for (cap = caps; cap; cap = cap->next) {\n\n            monitor_printf(mon, \"%s: %s \",\n\n                           MigrationCapability_lookup[cap->value->capability],\n\n                           cap->value->state ? \"on\" : \"off\");\n\n        }\n\n        monitor_printf(mon, \"\\n\");\n\n    }\n\n\n\n    if (info->has_status) {\n\n        monitor_printf(mon, \"Migration status: %s\\n\",\n\n                       MigrationStatus_lookup[info->status]);\n\n        monitor_printf(mon, \"total time: %\" PRIu64 \" milliseconds\\n\",\n\n                       info->total_time);\n\n        if (info->has_expected_downtime) {\n\n            monitor_printf(mon, \"expected downtime: %\" PRIu64 \" milliseconds\\n\",\n\n                           info->expected_downtime);\n\n        }\n\n        if (info->has_downtime) {\n\n            monitor_printf(mon, \"downtime: %\" PRIu64 \" milliseconds\\n\",\n\n                           info->downtime);\n\n        }\n\n        if (info->has_setup_time) {\n\n            monitor_printf(mon, \"setup: %\" PRIu64 \" milliseconds\\n\",\n\n                           info->setup_time);\n\n        }\n\n    }\n\n\n\n    if (info->has_ram) {\n\n        monitor_printf(mon, \"transferred ram: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->transferred >> 10);\n\n        monitor_printf(mon, \"throughput: %0.2f mbps\\n\",\n\n                       info->ram->mbps);\n\n        monitor_printf(mon, \"remaining ram: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->remaining >> 10);\n\n        monitor_printf(mon, \"total ram: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->total >> 10);\n\n        monitor_printf(mon, \"duplicate: %\" PRIu64 \" pages\\n\",\n\n                       info->ram->duplicate);\n\n        monitor_printf(mon, \"skipped: %\" PRIu64 \" pages\\n\",\n\n                       info->ram->skipped);\n\n        monitor_printf(mon, \"normal: %\" PRIu64 \" pages\\n\",\n\n                       info->ram->normal);\n\n        monitor_printf(mon, \"normal bytes: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->normal_bytes >> 10);\n\n        monitor_printf(mon, \"dirty sync count: %\" PRIu64 \"\\n\",\n\n                       info->ram->dirty_sync_count);\n\n        if (info->ram->dirty_pages_rate) {\n\n            monitor_printf(mon, \"dirty pages rate: %\" PRIu64 \" pages\\n\",\n\n                           info->ram->dirty_pages_rate);\n\n        }\n\n    }\n\n\n\n    if (info->has_disk) {\n\n        monitor_printf(mon, \"transferred disk: %\" PRIu64 \" kbytes\\n\",\n\n                       info->disk->transferred >> 10);\n\n        monitor_printf(mon, \"remaining disk: %\" PRIu64 \" kbytes\\n\",\n\n                       info->disk->remaining >> 10);\n\n        monitor_printf(mon, \"total disk: %\" PRIu64 \" kbytes\\n\",\n\n                       info->disk->total >> 10);\n\n    }\n\n\n\n    if (info->has_xbzrle_cache) {\n\n        monitor_printf(mon, \"cache size: %\" PRIu64 \" bytes\\n\",\n\n                       info->xbzrle_cache->cache_size);\n\n        monitor_printf(mon, \"xbzrle transferred: %\" PRIu64 \" kbytes\\n\",\n\n                       info->xbzrle_cache->bytes >> 10);\n\n        monitor_printf(mon, \"xbzrle pages: %\" PRIu64 \" pages\\n\",\n\n                       info->xbzrle_cache->pages);\n\n        monitor_printf(mon, \"xbzrle cache miss: %\" PRIu64 \"\\n\",\n\n                       info->xbzrle_cache->cache_miss);\n\n        monitor_printf(mon, \"xbzrle cache miss rate: %0.2f\\n\",\n\n                       info->xbzrle_cache->cache_miss_rate);\n\n        monitor_printf(mon, \"xbzrle overflow : %\" PRIu64 \"\\n\",\n\n                       info->xbzrle_cache->overflow);\n\n    }\n\n\n\n    if (info->has_cpu_throttle_percentage) {\n\n        monitor_printf(mon, \"cpu throttle percentage: %\" PRIu64 \"\\n\",\n\n                       info->cpu_throttle_percentage);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n    qapi_free_MigrationCapabilityStatusList(caps);\n\n}\n", "idx": 4195}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_s_without_atn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_s_without_atn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len) {\n\n        do_busid_cmd(s, buf, 0);\n\n    }\n\n}\n", "idx": 10887}
{"project": "qemu", "commit_id": "0f7bfd8198ffad58a5095ac5d7a46288ea7f5c6e", "target": 1, "func": "static void qxl_exit_vga_mode(PCIQXLDevice *d)\n\n{\n\n    if (d->mode != QXL_MODE_VGA) {\n\n        return;\n\n    }\n\n    trace_qxl_exit_vga_mode(d->id);\n\n\n    qxl_destroy_primary(d, QXL_SYNC);\n\n}", "idx": 1160}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    qemu_put_be16s(f, v);\n\n}\n", "idx": 6032}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_request(ADBDevice *d, uint8_t *obuf,\n\n                           const uint8_t *buf, int len)\n\n{\n\n    KBDState *s = ADB_KEYBOARD(d);\n\n    int cmd, reg, olen;\n\n\n\n    if ((buf[0] & 0x0f) == ADB_FLUSH) {\n\n        /* flush keyboard fifo */\n\n        s->wptr = s->rptr = s->count = 0;\n\n        return 0;\n\n    }\n\n\n\n    cmd = buf[0] & 0xc;\n\n    reg = buf[0] & 0x3;\n\n    olen = 0;\n\n    switch(cmd) {\n\n    case ADB_WRITEREG:\n\n        switch(reg) {\n\n        case 2:\n\n            /* LED status */\n\n            break;\n\n        case 3:\n\n            switch(buf[2]) {\n\n            case ADB_CMD_SELF_TEST:\n\n                break;\n\n            case ADB_CMD_CHANGE_ID:\n\n            case ADB_CMD_CHANGE_ID_AND_ACT:\n\n            case ADB_CMD_CHANGE_ID_AND_ENABLE:\n\n                d->devaddr = buf[1] & 0xf;\n\n                break;\n\n            default:\n\n                d->devaddr = buf[1] & 0xf;\n\n                /* we support handlers:\n\n                 * 1: Apple Standard Keyboard\n\n                 * 2: Apple Extended Keyboard (LShift = RShift)\n\n                 * 3: Apple Extended Keyboard (LShift != RShift)\n\n                 */\n\n                if (buf[2] == 1 || buf[2] == 2 || buf[2] == 3) {\n\n                    d->handler = buf[2];\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case ADB_READREG:\n\n        switch(reg) {\n\n        case 0:\n\n            olen = adb_kbd_poll(d, obuf);\n\n            break;\n\n        case 1:\n\n            break;\n\n        case 2:\n\n            obuf[0] = 0x00; /* XXX: check this */\n\n            obuf[1] = 0x07; /* led status */\n\n            olen = 2;\n\n            break;\n\n        case 3:\n\n            obuf[0] = d->handler;\n\n            obuf[1] = d->devaddr;\n\n            olen = 2;\n\n            break;\n\n        }\n\n        break;\n\n    }\n\n    return olen;\n\n}\n", "idx": 10898}
{"project": "qemu", "commit_id": "bc5008a832f95aae86efce844382e64d54da2146", "target": 1, "func": "static struct pathelem *add_entry(struct pathelem *root, const char *name,\n\n                                  unsigned type)\n\n{\n\n    struct pathelem **e;\n\n\n\n    root->num_entries++;\n\n\n\n    root = realloc(root, sizeof(*root)\n\n                   + sizeof(root->entries[0])*root->num_entries);\n\n    e = &root->entries[root->num_entries-1];\n\n\n\n    *e = new_entry(root->pathname, root, name);\n\n    if (is_dir_maybe(type)) {\n\n        *e = add_dir_maybe(*e);\n\n    }\n\n\n\n    return root;\n\n}\n", "idx": 11226}
{"project": "qemu", "commit_id": "80aa796bf38b7ef21daa42673b4711510c450d8a", "target": 1, "func": "static int pci_bridge_dev_initfn(PCIDevice *dev)\n\n{\n\n    PCIBridge *br = DO_UPCAST(PCIBridge, dev, dev);\n\n    PCIBridgeDev *bridge_dev = DO_UPCAST(PCIBridgeDev, bridge, br);\n\n    int err;\n\n    pci_bridge_map_irq(br, NULL, pci_bridge_dev_map_irq_fn);\n\n    err = pci_bridge_initfn(dev);\n\n    if (err) {\n\n        goto bridge_error;\n\n    }\n\n    memory_region_init(&bridge_dev->bar, \"shpc-bar\", shpc_bar_size(dev));\n\n    err = shpc_init(dev, &br->sec_bus, &bridge_dev->bar, 0);\n\n    if (err) {\n\n        goto shpc_error;\n\n    }\n\n    err = slotid_cap_init(dev, 0, bridge_dev->chassis_nr, 0);\n\n    if (err) {\n\n        goto slotid_error;\n\n    }\n\n    if ((bridge_dev->flags & (1 << PCI_BRIDGE_DEV_F_MSI_REQ)) &&\n\n        msi_supported) {\n\n        err = msi_init(dev, 0, 1, true, true);\n\n        if (err < 0) {\n\n            goto msi_error;\n\n        }\n\n    }\n\n    /* TODO: spec recommends using 64 bit prefetcheable BAR.\n\n     * Check whether that works well. */\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n\t\t     PCI_BASE_ADDRESS_MEM_TYPE_64, &bridge_dev->bar);\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x1;\n\n    return 0;\n\nmsi_error:\n\n    slotid_cap_cleanup(dev);\n\nslotid_error:\n\n    shpc_cleanup(dev, &bridge_dev->bar);\n\nshpc_error:\n\n    memory_region_destroy(&bridge_dev->bar);\n\nbridge_error:\n\n    return err;\n\n}\n", "idx": 1405}
{"project": "qemu", "commit_id": "2e1cf2c9685978193ef429cdb711bf50debea9d8", "target": 1, "func": "static void xilinx_spips_flush_txfifo(XilinxSPIPS *s)\n\n{\n\n    int debug_level = 0;\n\n    XilinxQSPIPS *q = (XilinxQSPIPS *) object_dynamic_cast(OBJECT(s),\n\n                                                           TYPE_XILINX_QSPIPS);\n\n\n\n    for (;;) {\n\n        int i;\n\n        uint8_t tx = 0;\n\n        uint8_t tx_rx[num_effective_busses(s)];\n\n        uint8_t dummy_cycles = 0;\n\n        uint8_t addr_length;\n\n\n\n        if (fifo8_is_empty(&s->tx_fifo)) {\n\n            if (!(s->regs[R_LQSPI_CFG] & LQSPI_CFG_LQ_MODE)) {\n\n                s->regs[R_INTR_STATUS] |= IXR_TX_FIFO_UNDERFLOW;\n\n            }\n\n            xilinx_spips_update_ixr(s);\n\n            return;\n\n        } else if (s->snoop_state == SNOOP_STRIPING) {\n\n            for (i = 0; i < num_effective_busses(s); ++i) {\n\n                tx_rx[i] = fifo8_pop(&s->tx_fifo);\n\n            }\n\n            stripe8(tx_rx, num_effective_busses(s), false);\n\n        } else if (s->snoop_state >= SNOOP_ADDR) {\n\n            tx = fifo8_pop(&s->tx_fifo);\n\n            for (i = 0; i < num_effective_busses(s); ++i) {\n\n                tx_rx[i] = tx;\n\n            }\n\n        } else {\n\n            /* Extract a dummy byte and generate dummy cycles according to the\n\n             * link state */\n\n            tx = fifo8_pop(&s->tx_fifo);\n\n            dummy_cycles = 8 / s->link_state;\n\n        }\n\n\n\n        for (i = 0; i < num_effective_busses(s); ++i) {\n\n            int bus = num_effective_busses(s) - 1 - i;\n\n            if (dummy_cycles) {\n\n                int d;\n\n                for (d = 0; d < dummy_cycles; ++d) {\n\n                    tx_rx[0] = ssi_transfer(s->spi[bus], (uint32_t)tx_rx[0]);\n\n                }\n\n            } else {\n\n                DB_PRINT_L(debug_level, \"tx = %02x\\n\", tx_rx[i]);\n\n                tx_rx[i] = ssi_transfer(s->spi[bus], (uint32_t)tx_rx[i]);\n\n                DB_PRINT_L(debug_level, \"rx = %02x\\n\", tx_rx[i]);\n\n            }\n\n        }\n\n\n\n        if (s->regs[R_CMND] & R_CMND_RXFIFO_DRAIN) {\n\n            DB_PRINT_L(debug_level, \"dircarding drained rx byte\\n\");\n\n            /* Do nothing */\n\n        } else if (s->rx_discard) {\n\n            DB_PRINT_L(debug_level, \"dircarding discarded rx byte\\n\");\n\n            s->rx_discard -= 8 / s->link_state;\n\n        } else if (fifo8_is_full(&s->rx_fifo)) {\n\n            s->regs[R_INTR_STATUS] |= IXR_RX_FIFO_OVERFLOW;\n\n            DB_PRINT_L(0, \"rx FIFO overflow\");\n\n        } else if (s->snoop_state == SNOOP_STRIPING) {\n\n            stripe8(tx_rx, num_effective_busses(s), true);\n\n            for (i = 0; i < num_effective_busses(s); ++i) {\n\n                fifo8_push(&s->rx_fifo, (uint8_t)tx_rx[i]);\n\n                DB_PRINT_L(debug_level, \"pushing striped rx byte\\n\");\n\n            }\n\n        } else {\n\n           DB_PRINT_L(debug_level, \"pushing unstriped rx byte\\n\");\n\n           fifo8_push(&s->rx_fifo, (uint8_t)tx_rx[0]);\n\n        }\n\n\n\n        if (s->link_state_next_when) {\n\n            s->link_state_next_when--;\n\n            if (!s->link_state_next_when) {\n\n                s->link_state = s->link_state_next;\n\n            }\n\n        }\n\n\n\n        DB_PRINT_L(debug_level, \"initial snoop state: %x\\n\",\n\n                   (unsigned)s->snoop_state);\n\n        switch (s->snoop_state) {\n\n        case (SNOOP_CHECKING):\n\n            /* Store the count of dummy bytes in the txfifo */\n\n            s->cmd_dummies = xilinx_spips_num_dummies(q, tx);\n\n            addr_length = get_addr_length(s, tx);\n\n            if (s->cmd_dummies < 0) {\n\n                s->snoop_state = SNOOP_NONE;\n\n            } else {\n\n                s->snoop_state = SNOOP_ADDR + addr_length - 1;\n\n            }\n\n            switch (tx) {\n\n            case DPP:\n\n            case DOR:\n\n            case DOR_4:\n\n                s->link_state_next = 2;\n\n                s->link_state_next_when = addr_length + s->cmd_dummies;\n\n                break;\n\n            case QPP:\n\n            case QPP_4:\n\n            case QOR:\n\n            case QOR_4:\n\n                s->link_state_next = 4;\n\n                s->link_state_next_when = addr_length + s->cmd_dummies;\n\n                break;\n\n            case DIOR:\n\n            case DIOR_4:\n\n                s->link_state = 2;\n\n                break;\n\n            case QIOR:\n\n            case QIOR_4:\n\n                s->link_state = 4;\n\n                break;\n\n            }\n\n            break;\n\n        case (SNOOP_ADDR):\n\n            /* Address has been transmitted, transmit dummy cycles now if\n\n             * needed */\n\n            if (s->cmd_dummies < 0) {\n\n                s->snoop_state = SNOOP_NONE;\n\n            } else {\n\n                s->snoop_state = s->cmd_dummies;\n\n            }\n\n            break;\n\n        case (SNOOP_STRIPING):\n\n        case (SNOOP_NONE):\n\n            /* Once we hit the boring stuff - squelch debug noise */\n\n            if (!debug_level) {\n\n                DB_PRINT_L(0, \"squelching debug info ....\\n\");\n\n                debug_level = 1;\n\n            }\n\n            break;\n\n        default:\n\n            s->snoop_state--;\n\n        }\n\n        DB_PRINT_L(debug_level, \"final snoop state: %x\\n\",\n\n                   (unsigned)s->snoop_state);\n\n    }\n\n}\n", "idx": 11035}
{"project": "qemu", "commit_id": "3e40ba0faf0822fa78336fe6cd9d677ea9b14f1b", "target": 1, "func": "static void vfio_disable_msix(VFIODevice *vdev)\n{\n    msix_unset_vector_notifiers(&vdev->pdev);\n    if (vdev->nr_vectors) {\n        vfio_disable_irqindex(vdev, VFIO_PCI_MSIX_IRQ_INDEX);\n    vfio_disable_msi_common(vdev);\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n            vdev->host.bus, vdev->host.slot, vdev->host.function);", "idx": 9467}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void migrate_fd_cleanup(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    qemu_bh_delete(s->cleanup_bh);\n\n    s->cleanup_bh = NULL;\n\n\n\n    if (s->file) {\n\n        trace_migrate_fd_cleanup();\n\n        qemu_mutex_unlock_iothread();\n\n        qemu_thread_join(&s->thread);\n\n        qemu_mutex_lock_iothread();\n\n\n\n        qemu_fclose(s->file);\n\n        s->file = NULL;\n\n    }\n\n\n\n    assert(s->state != MIG_STATE_ACTIVE);\n\n\n\n    if (s->state != MIG_STATE_COMPLETED) {\n\n        qemu_savevm_state_cancel();\n\n        if (s->state == MIG_STATE_CANCELLING) {\n\n            migrate_set_state(s, MIG_STATE_CANCELLING, MIG_STATE_CANCELLED);\n\n        }\n\n    }\n\n\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 3891}
{"project": "qemu", "commit_id": "8daea510951dd309a44cea8de415c685c43851cf", "target": 1, "func": "void qdev_prop_set_drive(DeviceState *dev, const char *name,\n\n                         BlockBackend *value, Error **errp)\n\n{\n\n    object_property_set_str(OBJECT(dev), value ? blk_name(value) : \"\",\n\n                            name, errp);\n\n}\n", "idx": 10943}
{"project": "qemu", "commit_id": "73698c30caaf16e990b8b2e6e7bc64928947e65e", "target": 1, "func": "static int mirror_do_read(MirrorBlockJob *s, int64_t sector_num,\n\n                          int nb_sectors)\n\n{\n\n    BlockBackend *source = s->common.blk;\n\n    int sectors_per_chunk, nb_chunks;\n\n    int ret = nb_sectors;\n\n    MirrorOp *op;\n\n\n\n    sectors_per_chunk = s->granularity >> BDRV_SECTOR_BITS;\n\n\n\n    /* We can only handle as much as buf_size at a time. */\n\n    nb_sectors = MIN(s->buf_size >> BDRV_SECTOR_BITS, nb_sectors);\n\n    assert(nb_sectors);\n\n\n\n    if (s->cow_bitmap) {\n\n        ret += mirror_cow_align(s, &sector_num, &nb_sectors);\n\n    }\n\n    assert(nb_sectors << BDRV_SECTOR_BITS <= s->buf_size);\n\n    /* The sector range must meet granularity because:\n\n     * 1) Caller passes in aligned values;\n\n     * 2) mirror_cow_align is used only when target cluster is larger. */\n\n    assert(!(sector_num % sectors_per_chunk));\n\n    nb_chunks = DIV_ROUND_UP(nb_sectors, sectors_per_chunk);\n\n\n\n    while (s->buf_free_count < nb_chunks) {\n\n        trace_mirror_yield_in_flight(s, sector_num, s->in_flight);\n\n        mirror_wait_for_io(s);\n\n    }\n\n\n\n    /* Allocate a MirrorOp that is used as an AIO callback.  */\n\n    op = g_new(MirrorOp, 1);\n\n    op->s = s;\n\n    op->sector_num = sector_num;\n\n    op->nb_sectors = nb_sectors;\n\n\n\n    /* Now make a QEMUIOVector taking enough granularity-sized chunks\n\n     * from s->buf_free.\n\n     */\n\n    qemu_iovec_init(&op->qiov, nb_chunks);\n\n    while (nb_chunks-- > 0) {\n\n        MirrorBuffer *buf = QSIMPLEQ_FIRST(&s->buf_free);\n\n        size_t remaining = nb_sectors * BDRV_SECTOR_SIZE - op->qiov.size;\n\n\n\n        QSIMPLEQ_REMOVE_HEAD(&s->buf_free, next);\n\n        s->buf_free_count--;\n\n        qemu_iovec_add(&op->qiov, buf, MIN(s->granularity, remaining));\n\n    }\n\n\n\n    /* Copy the dirty cluster.  */\n\n    s->in_flight++;\n\n    s->sectors_in_flight += nb_sectors;\n\n    trace_mirror_one_iteration(s, sector_num, nb_sectors);\n\n\n\n    blk_aio_preadv(source, sector_num * BDRV_SECTOR_SIZE, &op->qiov,\n\n                   nb_sectors * BDRV_SECTOR_SIZE,\n\n                   mirror_read_complete, op);\n\n    return ret;\n\n}\n", "idx": 7401}
{"project": "qemu", "commit_id": "97679527bf2f002225d08cfb93f840cef449ac0e", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    I440FXState *s;\n\n    PIIX3State *piix3;\n\n\n\n    dev = qdev_create(NULL, \"i440FX-pcihost\");\n\n    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));\n\n    b = pci_bus_new(&s->busdev.qdev, NULL, 0);\n\n    s->bus = b;\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, \"i440FX\");\n\n    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);\n\n\n\n    piix3 = DO_UPCAST(PIIX3State, dev,\n\n                                 pci_create_simple(b, -1, \"PIIX3\"));\n\n    piix3->pic = pic;\n\n    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);\n\n    (*pi440fx_state)->piix3 = piix3;\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255)\n\n        ram_size = 255;\n\n    (*pi440fx_state)->dev.config[0x57]=ram_size;\n\n\n\n    return b;\n\n}\n", "idx": 873}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "func": "int vnc_client_io_error(VncState *vs, int ret, int last_errno)\n\n{\n\n    if (ret == 0 || ret == -1) {\n\n        if (ret == -1) {\n\n            switch (last_errno) {\n\n                case EINTR:\n\n                case EAGAIN:\n\n#ifdef _WIN32\n\n                case WSAEWOULDBLOCK:\n\n#endif\n\n                    return 0;\n\n                default:\n\n                    break;\n\n            }\n\n        }\n\n\n\n        VNC_DEBUG(\"Closing down client sock %d %d\\n\", ret, ret < 0 ? last_errno : 0);\n\n        qemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);\n\n        closesocket(vs->csock);\n\n        qemu_del_timer(vs->timer);\n\n        qemu_free_timer(vs->timer);\n\n        if (vs->input.buffer) qemu_free(vs->input.buffer);\n\n        if (vs->output.buffer) qemu_free(vs->output.buffer);\n\n#ifdef CONFIG_VNC_TLS\n\n        vnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n        vnc_sasl_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n        audio_del(vs);\n\n\n\n        VncState *p, *parent = NULL;\n\n        for (p = vs->vd->clients; p != NULL; p = p->next) {\n\n            if (p == vs) {\n\n                if (parent)\n\n                    parent->next = p->next;\n\n                else\n\n                    vs->vd->clients = p->next;\n\n                break;\n\n            }\n\n            parent = p;\n\n        }\n\n        if (!vs->vd->clients)\n\n            dcl->idle = 1;\n\n\n\n        qemu_free(vs->server.ds->data);\n\n        qemu_free(vs->server.ds);\n\n        qemu_free(vs->guest.ds);\n\n        qemu_free(vs);\n\n\n\n        return 0;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6704}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *new_snapshot_list = NULL;\n\n    QCowSnapshot *old_snapshot_list = NULL;\n\n    QCowSnapshot sn1, *sn = &sn1;\n\n    int i, ret;\n\n    uint64_t *l1_table = NULL;\n\n    int64_t l1_table_offset;\n\n\n\n    memset(sn, 0, sizeof(*sn));\n\n\n\n    /* Generate an ID if it wasn't passed */\n\n    if (sn_info->id_str[0] == '\\0') {\n\n        find_new_snapshot_id(bs, sn_info->id_str, sizeof(sn_info->id_str));\n\n    }\n\n\n\n    /* Check that the ID is unique */\n\n    if (find_snapshot_by_id_and_name(bs, sn_info->id_str, NULL) >= 0) {\n\n        return -EEXIST;\n\n    }\n\n\n\n    /* Populate sn with passed data */\n\n    sn->id_str = g_strdup(sn_info->id_str);\n\n    sn->name = g_strdup(sn_info->name);\n\n\n\n    sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    sn->vm_state_size = sn_info->vm_state_size;\n\n    sn->date_sec = sn_info->date_sec;\n\n    sn->date_nsec = sn_info->date_nsec;\n\n    sn->vm_clock_nsec = sn_info->vm_clock_nsec;\n\n\n\n    /* Allocate the L1 table of the snapshot and copy the current one there. */\n\n    l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * sizeof(uint64_t));\n\n    if (l1_table_offset < 0) {\n\n        ret = l1_table_offset;\n\n        goto fail;\n\n    }\n\n\n\n    sn->l1_table_offset = l1_table_offset;\n\n    sn->l1_size = s->l1_size;\n\n\n\n    l1_table = g_malloc(s->l1_size * sizeof(uint64_t));\n\n    for(i = 0; i < s->l1_size; i++) {\n\n        l1_table[i] = cpu_to_be64(s->l1_table[i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_DEFAULT,\n\n            sn->l1_table_offset, s->l1_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = bdrv_pwrite(bs->file, sn->l1_table_offset, l1_table,\n\n                      s->l1_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    g_free(l1_table);\n\n    l1_table = NULL;\n\n\n\n    /*\n\n     * Increase the refcounts of all clusters and make sure everything is\n\n     * stable on disk before updating the snapshot table to contain a pointer\n\n     * to the new L1 table.\n\n     */\n\n    ret = qcow2_update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Append the new snapshot to the snapshot list */\n\n    new_snapshot_list = g_malloc((s->nb_snapshots + 1) * sizeof(QCowSnapshot));\n\n    if (s->snapshots) {\n\n        memcpy(new_snapshot_list, s->snapshots,\n\n               s->nb_snapshots * sizeof(QCowSnapshot));\n\n        old_snapshot_list = s->snapshots;\n\n    }\n\n    s->snapshots = new_snapshot_list;\n\n    s->snapshots[s->nb_snapshots++] = *sn;\n\n\n\n    ret = qcow2_write_snapshots(bs);\n\n    if (ret < 0) {\n\n        g_free(s->snapshots);\n\n        s->snapshots = old_snapshot_list;\n\n        s->nb_snapshots--;\n\n        goto fail;\n\n    }\n\n\n\n    g_free(old_snapshot_list);\n\n\n\n    /* The VM state isn't needed any more in the active L1 table; in fact, it\n\n     * hurts by causing expensive COW for the next snapshot. */\n\n    qcow2_discard_clusters(bs, qcow2_vm_state_offset(s),\n\n                           align_offset(sn->vm_state_size, s->cluster_size)\n\n                                >> BDRV_SECTOR_BITS,\n\n                           QCOW2_DISCARD_NEVER);\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n      BdrvCheckResult result = {0};\n\n      qcow2_check_refcounts(bs, &result, 0);\n\n    }\n\n#endif\n\n    return 0;\n\n\n\nfail:\n\n    g_free(sn->id_str);\n\n    g_free(sn->name);\n\n    g_free(l1_table);\n\n\n\n    return ret;\n\n}\n", "idx": 3562}
{"project": "qemu", "commit_id": "d1dbe37c1ee3f14cb64a9ae3c89f637fdd08fca1", "target": 1, "func": "static void ppc_hw_interrupt(CPUPPCState *env)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    int hdice;\n\n#if 0\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"%s: %p pending %08x req %08x me %d ee %d\\n\",\n\n                  __func__, env, env->pending_interrupts,\n\n                  cs->interrupt_request, (int)msr_me, (int)msr_ee);\n\n#endif\n\n    /* External reset */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n\n        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_RESET);\n\n        return;\n\n    }\n\n    /* Machine check exception */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n\n        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_MCHECK);\n\n        return;\n\n    }\n\n#if 0 /* TODO */\n\n    /* External debug exception */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DEBUG);\n\n        return;\n\n    }\n\n#endif\n\n    if (0) {\n\n        /* XXX: find a suitable condition to enable the hypervisor mode */\n\n        hdice = env->spr[SPR_LPCR] & 1;\n\n    } else {\n\n        hdice = 0;\n\n    }\n\n    if ((msr_ee != 0 || msr_hv == 0 || msr_pr != 0) && hdice != 0) {\n\n        /* Hypervisor decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_HDECR);\n\n            return;\n\n        }\n\n    }\n\n    if (msr_ce != 0) {\n\n        /* External critical interrupt */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CEXT)) {\n\n            /* Taking a critical external interrupt does not clear the external\n\n             * critical interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CEXT);\n\n#endif\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_CRITICAL);\n\n            return;\n\n        }\n\n    }\n\n    if (msr_ee != 0) {\n\n        /* Watchdog timer on embedded PowerPC */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_WDT);\n\n            return;\n\n        }\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CDOORBELL)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CDOORBELL);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORCI);\n\n            return;\n\n        }\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_FIT);\n\n            return;\n\n        }\n\n        /* Programmable interval timer on embedded PowerPC */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PIT);\n\n            return;\n\n        }\n\n        /* Decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n\n            if (ppc_decr_clear_on_delivery(env)) {\n\n                env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n\n            }\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DECR);\n\n            return;\n\n        }\n\n        /* External interrupt */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_EXTERNAL);\n\n            return;\n\n        }\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DOORBELL)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DOORBELL);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORI);\n\n            return;\n\n        }\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PERFM)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PERFM);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PERFM);\n\n            return;\n\n        }\n\n        /* Thermal interrupt */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_THERM);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 356}
{"project": "qemu", "commit_id": "72902672dc2ed6281cdb205259c1d52ecf01f6b2", "target": 1, "func": "static int disas_neon_data_insn(CPUState * env, DisasContext *s, uint32_t insn)\n\n{\n\n    int op;\n\n    int q;\n\n    int rd, rn, rm;\n\n    int size;\n\n    int shift;\n\n    int pass;\n\n    int count;\n\n    int pairwise;\n\n    int u;\n\n    int n;\n\n    uint32_t imm, mask;\n\n    TCGv tmp, tmp2, tmp3, tmp4, tmp5;\n\n    TCGv_i64 tmp64;\n\n\n\n    if (!s->vfp_enabled)\n\n      return 1;\n\n    q = (insn & (1 << 6)) != 0;\n\n    u = (insn >> 24) & 1;\n\n    VFP_DREG_D(rd, insn);\n\n    VFP_DREG_N(rn, insn);\n\n    VFP_DREG_M(rm, insn);\n\n    size = (insn >> 20) & 3;\n\n    if ((insn & (1 << 23)) == 0) {\n\n        /* Three register same length.  */\n\n        op = ((insn >> 7) & 0x1e) | ((insn >> 4) & 1);\n\n        if (size == 3 && (op == 1 || op == 5 || op == 8 || op == 9\n\n                          || op == 10 || op  == 11 || op == 16)) {\n\n            /* 64-bit element instructions.  */\n\n            for (pass = 0; pass < (q ? 2 : 1); pass++) {\n\n                neon_load_reg64(cpu_V0, rn + pass);\n\n                neon_load_reg64(cpu_V1, rm + pass);\n\n                switch (op) {\n\n                case 1: /* VQADD */\n\n                    if (u) {\n\n                        gen_helper_neon_add_saturate_u64(CPU_V001);\n\n                    } else {\n\n                        gen_helper_neon_add_saturate_s64(CPU_V001);\n\n                    }\n\n                    break;\n\n                case 5: /* VQSUB */\n\n                    if (u) {\n\n                        gen_helper_neon_sub_saturate_u64(CPU_V001);\n\n                    } else {\n\n                        gen_helper_neon_sub_saturate_s64(CPU_V001);\n\n                    }\n\n                    break;\n\n                case 8: /* VSHL */\n\n                    if (u) {\n\n                        gen_helper_neon_shl_u64(cpu_V0, cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_shl_s64(cpu_V0, cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case 9: /* VQSHL */\n\n                    if (u) {\n\n                        gen_helper_neon_qshl_u64(cpu_V0, cpu_env,\n\n                                                 cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_qshl_s64(cpu_V0, cpu_env,\n\n                                                 cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case 10: /* VRSHL */\n\n                    if (u) {\n\n                        gen_helper_neon_rshl_u64(cpu_V0, cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_rshl_s64(cpu_V0, cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case 11: /* VQRSHL */\n\n                    if (u) {\n\n                        gen_helper_neon_qrshl_u64(cpu_V0, cpu_env,\n\n                                                  cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_qrshl_s64(cpu_V0, cpu_env,\n\n                                                  cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case 16:\n\n                    if (u) {\n\n                        tcg_gen_sub_i64(CPU_V001);\n\n                    } else {\n\n                        tcg_gen_add_i64(CPU_V001);\n\n                    }\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n                neon_store_reg64(cpu_V0, rd + pass);\n\n            }\n\n            return 0;\n\n        }\n\n        switch (op) {\n\n        case 8: /* VSHL */\n\n        case 9: /* VQSHL */\n\n        case 10: /* VRSHL */\n\n        case 11: /* VQRSHL */\n\n            {\n\n                int rtmp;\n\n                /* Shift instruction operands are reversed.  */\n\n                rtmp = rn;\n\n                rn = rm;\n\n                rm = rtmp;\n\n                pairwise = 0;\n\n            }\n\n            break;\n\n        case 20: /* VPMAX */\n\n        case 21: /* VPMIN */\n\n        case 23: /* VPADD */\n\n            pairwise = 1;\n\n            break;\n\n        case 26: /* VPADD (float) */\n\n            pairwise = (u && size < 2);\n\n            break;\n\n        case 30: /* VPMIN/VPMAX (float) */\n\n            pairwise = u;\n\n            break;\n\n        default:\n\n            pairwise = 0;\n\n            break;\n\n        }\n\n\n\n        for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n\n\n        if (pairwise) {\n\n            /* Pairwise.  */\n\n            if (q)\n\n                n = (pass & 1) * 2;\n\n            else\n\n                n = 0;\n\n            if (pass < q + 1) {\n\n                tmp = neon_load_reg(rn, n);\n\n                tmp2 = neon_load_reg(rn, n + 1);\n\n            } else {\n\n                tmp = neon_load_reg(rm, n);\n\n                tmp2 = neon_load_reg(rm, n + 1);\n\n            }\n\n        } else {\n\n            /* Elementwise.  */\n\n            tmp = neon_load_reg(rn, pass);\n\n            tmp2 = neon_load_reg(rm, pass);\n\n        }\n\n        switch (op) {\n\n        case 0: /* VHADD */\n\n            GEN_NEON_INTEGER_OP(hadd);\n\n            break;\n\n        case 1: /* VQADD */\n\n            GEN_NEON_INTEGER_OP_ENV(qadd);\n\n            break;\n\n        case 2: /* VRHADD */\n\n            GEN_NEON_INTEGER_OP(rhadd);\n\n            break;\n\n        case 3: /* Logic ops.  */\n\n            switch ((u << 2) | size) {\n\n            case 0: /* VAND */\n\n                tcg_gen_and_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 1: /* BIC */\n\n                tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 2: /* VORR */\n\n                tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 3: /* VORN */\n\n                tcg_gen_orc_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 4: /* VEOR */\n\n                tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 5: /* VBSL */\n\n                tmp3 = neon_load_reg(rd, pass);\n\n                gen_neon_bsl(tmp, tmp, tmp2, tmp3);\n\n                dead_tmp(tmp3);\n\n                break;\n\n            case 6: /* VBIT */\n\n                tmp3 = neon_load_reg(rd, pass);\n\n                gen_neon_bsl(tmp, tmp, tmp3, tmp2);\n\n                dead_tmp(tmp3);\n\n                break;\n\n            case 7: /* VBIF */\n\n                tmp3 = neon_load_reg(rd, pass);\n\n                gen_neon_bsl(tmp, tmp3, tmp, tmp2);\n\n                dead_tmp(tmp3);\n\n                break;\n\n            }\n\n            break;\n\n        case 4: /* VHSUB */\n\n            GEN_NEON_INTEGER_OP(hsub);\n\n            break;\n\n        case 5: /* VQSUB */\n\n            GEN_NEON_INTEGER_OP_ENV(qsub);\n\n            break;\n\n        case 6: /* VCGT */\n\n            GEN_NEON_INTEGER_OP(cgt);\n\n            break;\n\n        case 7: /* VCGE */\n\n            GEN_NEON_INTEGER_OP(cge);\n\n            break;\n\n        case 8: /* VSHL */\n\n            GEN_NEON_INTEGER_OP(shl);\n\n            break;\n\n        case 9: /* VQSHL */\n\n            GEN_NEON_INTEGER_OP_ENV(qshl);\n\n            break;\n\n        case 10: /* VRSHL */\n\n            GEN_NEON_INTEGER_OP(rshl);\n\n            break;\n\n        case 11: /* VQRSHL */\n\n            GEN_NEON_INTEGER_OP_ENV(qrshl);\n\n            break;\n\n        case 12: /* VMAX */\n\n            GEN_NEON_INTEGER_OP(max);\n\n            break;\n\n        case 13: /* VMIN */\n\n            GEN_NEON_INTEGER_OP(min);\n\n            break;\n\n        case 14: /* VABD */\n\n            GEN_NEON_INTEGER_OP(abd);\n\n            break;\n\n        case 15: /* VABA */\n\n            GEN_NEON_INTEGER_OP(abd);\n\n            dead_tmp(tmp2);\n\n            tmp2 = neon_load_reg(rd, pass);\n\n            gen_neon_add(size, tmp, tmp2);\n\n            break;\n\n        case 16:\n\n            if (!u) { /* VADD */\n\n                if (gen_neon_add(size, tmp, tmp2))\n\n                    return 1;\n\n            } else { /* VSUB */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_sub_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_sub_u16(tmp, tmp, tmp2); break;\n\n                case 2: tcg_gen_sub_i32(tmp, tmp, tmp2); break;\n\n                default: return 1;\n\n                }\n\n            }\n\n            break;\n\n        case 17:\n\n            if (!u) { /* VTST */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_tst_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_tst_u16(tmp, tmp, tmp2); break;\n\n                case 2: gen_helper_neon_tst_u32(tmp, tmp, tmp2); break;\n\n                default: return 1;\n\n                }\n\n            } else { /* VCEQ */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_ceq_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_ceq_u16(tmp, tmp, tmp2); break;\n\n                case 2: gen_helper_neon_ceq_u32(tmp, tmp, tmp2); break;\n\n                default: return 1;\n\n                }\n\n            }\n\n            break;\n\n        case 18: /* Multiply.  */\n\n            switch (size) {\n\n            case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n\n            case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n\n            case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n\n            default: return 1;\n\n            }\n\n            dead_tmp(tmp2);\n\n            tmp2 = neon_load_reg(rd, pass);\n\n            if (u) { /* VMLS */\n\n                gen_neon_rsb(size, tmp, tmp2);\n\n            } else { /* VMLA */\n\n                gen_neon_add(size, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 19: /* VMUL */\n\n            if (u) { /* polynomial */\n\n                gen_helper_neon_mul_p8(tmp, tmp, tmp2);\n\n            } else { /* Integer */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n\n                case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n\n                default: return 1;\n\n                }\n\n            }\n\n            break;\n\n        case 20: /* VPMAX */\n\n            GEN_NEON_INTEGER_OP(pmax);\n\n            break;\n\n        case 21: /* VPMIN */\n\n            GEN_NEON_INTEGER_OP(pmin);\n\n            break;\n\n        case 22: /* Hultiply high.  */\n\n            if (!u) { /* VQDMULH */\n\n                switch (size) {\n\n                case 1: gen_helper_neon_qdmulh_s16(tmp, cpu_env, tmp, tmp2); break;\n\n                case 2: gen_helper_neon_qdmulh_s32(tmp, cpu_env, tmp, tmp2); break;\n\n                default: return 1;\n\n                }\n\n            } else { /* VQRDHMUL */\n\n                switch (size) {\n\n                case 1: gen_helper_neon_qrdmulh_s16(tmp, cpu_env, tmp, tmp2); break;\n\n                case 2: gen_helper_neon_qrdmulh_s32(tmp, cpu_env, tmp, tmp2); break;\n\n                default: return 1;\n\n                }\n\n            }\n\n            break;\n\n        case 23: /* VPADD */\n\n            if (u)\n\n                return 1;\n\n            switch (size) {\n\n            case 0: gen_helper_neon_padd_u8(tmp, tmp, tmp2); break;\n\n            case 1: gen_helper_neon_padd_u16(tmp, tmp, tmp2); break;\n\n            case 2: tcg_gen_add_i32(tmp, tmp, tmp2); break;\n\n            default: return 1;\n\n            }\n\n            break;\n\n        case 26: /* Floating point arithnetic.  */\n\n            switch ((u << 2) | size) {\n\n            case 0: /* VADD */\n\n                gen_helper_neon_add_f32(tmp, tmp, tmp2);\n\n                break;\n\n            case 2: /* VSUB */\n\n                gen_helper_neon_sub_f32(tmp, tmp, tmp2);\n\n                break;\n\n            case 4: /* VPADD */\n\n                gen_helper_neon_add_f32(tmp, tmp, tmp2);\n\n                break;\n\n            case 6: /* VABD */\n\n                gen_helper_neon_abd_f32(tmp, tmp, tmp2);\n\n                break;\n\n            default:\n\n                return 1;\n\n            }\n\n            break;\n\n        case 27: /* Float multiply.  */\n\n            gen_helper_neon_mul_f32(tmp, tmp, tmp2);\n\n            if (!u) {\n\n                dead_tmp(tmp2);\n\n                tmp2 = neon_load_reg(rd, pass);\n\n                if (size == 0) {\n\n                    gen_helper_neon_add_f32(tmp, tmp, tmp2);\n\n                } else {\n\n                    gen_helper_neon_sub_f32(tmp, tmp2, tmp);\n\n                }\n\n            }\n\n            break;\n\n        case 28: /* Float compare.  */\n\n            if (!u) {\n\n                gen_helper_neon_ceq_f32(tmp, tmp, tmp2);\n\n            } else {\n\n                if (size == 0)\n\n                    gen_helper_neon_cge_f32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_helper_neon_cgt_f32(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 29: /* Float compare absolute.  */\n\n            if (!u)\n\n                return 1;\n\n            if (size == 0)\n\n                gen_helper_neon_acge_f32(tmp, tmp, tmp2);\n\n            else\n\n                gen_helper_neon_acgt_f32(tmp, tmp, tmp2);\n\n            break;\n\n        case 30: /* Float min/max.  */\n\n            if (size == 0)\n\n                gen_helper_neon_max_f32(tmp, tmp, tmp2);\n\n            else\n\n                gen_helper_neon_min_f32(tmp, tmp, tmp2);\n\n            break;\n\n        case 31:\n\n            if (size == 0)\n\n                gen_helper_recps_f32(tmp, tmp, tmp2, cpu_env);\n\n            else\n\n                gen_helper_rsqrts_f32(tmp, tmp, tmp2, cpu_env);\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        dead_tmp(tmp2);\n\n\n\n        /* Save the result.  For elementwise operations we can put it\n\n           straight into the destination register.  For pairwise operations\n\n           we have to be careful to avoid clobbering the source operands.  */\n\n        if (pairwise && rd == rm) {\n\n            neon_store_scratch(pass, tmp);\n\n        } else {\n\n            neon_store_reg(rd, pass, tmp);\n\n        }\n\n\n\n        } /* for pass */\n\n        if (pairwise && rd == rm) {\n\n            for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                tmp = neon_load_scratch(pass);\n\n                neon_store_reg(rd, pass, tmp);\n\n            }\n\n        }\n\n        /* End of 3 register same size operations.  */\n\n    } else if (insn & (1 << 4)) {\n\n        if ((insn & 0x00380080) != 0) {\n\n            /* Two registers and shift.  */\n\n            op = (insn >> 8) & 0xf;\n\n            if (insn & (1 << 7)) {\n\n                /* 64-bit shift.   */\n\n                size = 3;\n\n            } else {\n\n                size = 2;\n\n                while ((insn & (1 << (size + 19))) == 0)\n\n                    size--;\n\n            }\n\n            shift = (insn >> 16) & ((1 << (3 + size)) - 1);\n\n            /* To avoid excessive dumplication of ops we implement shift\n\n               by immediate using the variable shift operations.  */\n\n            if (op < 8) {\n\n                /* Shift by immediate:\n\n                   VSHR, VSRA, VRSHR, VRSRA, VSRI, VSHL, VQSHL, VQSHLU.  */\n\n                /* Right shifts are encoded as N - shift, where N is the\n\n                   element size in bits.  */\n\n                if (op <= 4)\n\n                    shift = shift - (1 << (size + 3));\n\n                if (size == 3) {\n\n                    count = q + 1;\n\n                } else {\n\n                    count = q ? 4: 2;\n\n                }\n\n                switch (size) {\n\n                case 0:\n\n                    imm = (uint8_t) shift;\n\n                    imm |= imm << 8;\n\n                    imm |= imm << 16;\n\n                    break;\n\n                case 1:\n\n                    imm = (uint16_t) shift;\n\n                    imm |= imm << 16;\n\n                    break;\n\n                case 2:\n\n                case 3:\n\n                    imm = shift;\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n\n\n                for (pass = 0; pass < count; pass++) {\n\n                    if (size == 3) {\n\n                        neon_load_reg64(cpu_V0, rm + pass);\n\n                        tcg_gen_movi_i64(cpu_V1, imm);\n\n                        switch (op) {\n\n                        case 0:  /* VSHR */\n\n                        case 1:  /* VSRA */\n\n                            if (u)\n\n                                gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n\n                            else\n\n                                gen_helper_neon_shl_s64(cpu_V0, cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 2: /* VRSHR */\n\n                        case 3: /* VRSRA */\n\n                            if (u)\n\n                                gen_helper_neon_rshl_u64(cpu_V0, cpu_V0, cpu_V1);\n\n                            else\n\n                                gen_helper_neon_rshl_s64(cpu_V0, cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 4: /* VSRI */\n\n                            if (!u)\n\n                                return 1;\n\n                            gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 5: /* VSHL, VSLI */\n\n                            gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 6: /* VQSHLU */\n\n                            if (u) {\n\n                                gen_helper_neon_qshlu_s64(cpu_V0, cpu_env,\n\n                                                          cpu_V0, cpu_V1);\n\n                            } else {\n\n                                return 1;\n\n                            }\n\n                            break;\n\n                        case 7: /* VQSHL */\n\n                            if (u) {\n\n                                gen_helper_neon_qshl_u64(cpu_V0, cpu_env,\n\n                                                         cpu_V0, cpu_V1);\n\n                            } else {\n\n                                gen_helper_neon_qshl_s64(cpu_V0, cpu_env,\n\n                                                         cpu_V0, cpu_V1);\n\n                            }\n\n                            break;\n\n                        }\n\n                        if (op == 1 || op == 3) {\n\n                            /* Accumulate.  */\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                            tcg_gen_add_i64(cpu_V0, cpu_V0, cpu_V1);\n\n                        } else if (op == 4 || (op == 5 && u)) {\n\n                            /* Insert */\n\n                            cpu_abort(env, \"VS[LR]I.64 not implemented\");\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    } else { /* size < 3 */\n\n                        /* Operands in T0 and T1.  */\n\n                        tmp = neon_load_reg(rm, pass);\n\n                        tmp2 = new_tmp();\n\n                        tcg_gen_movi_i32(tmp2, imm);\n\n                        switch (op) {\n\n                        case 0:  /* VSHR */\n\n                        case 1:  /* VSRA */\n\n                            GEN_NEON_INTEGER_OP(shl);\n\n                            break;\n\n                        case 2: /* VRSHR */\n\n                        case 3: /* VRSRA */\n\n                            GEN_NEON_INTEGER_OP(rshl);\n\n                            break;\n\n                        case 4: /* VSRI */\n\n                            if (!u)\n\n                                return 1;\n\n                            GEN_NEON_INTEGER_OP(shl);\n\n                            break;\n\n                        case 5: /* VSHL, VSLI */\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_shl_u8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_shl_u16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_shl_u32(tmp, tmp, tmp2); break;\n\n                            default: return 1;\n\n                            }\n\n                            break;\n\n                        case 6: /* VQSHLU */\n\n                            if (!u) {\n\n                                return 1;\n\n                            }\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_qshlu_s8(tmp, cpu_env,\n\n                                                         tmp, tmp2);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_qshlu_s16(tmp, cpu_env,\n\n                                                          tmp, tmp2);\n\n                                break;\n\n                            case 2:\n\n                                gen_helper_neon_qshlu_s32(tmp, cpu_env,\n\n                                                          tmp, tmp2);\n\n                                break;\n\n                            default:\n\n                                return 1;\n\n                            }\n\n                            break;\n\n                        case 7: /* VQSHL */\n\n                            GEN_NEON_INTEGER_OP_ENV(qshl);\n\n                            break;\n\n                        }\n\n                        dead_tmp(tmp2);\n\n\n\n                        if (op == 1 || op == 3) {\n\n                            /* Accumulate.  */\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            gen_neon_add(size, tmp, tmp2);\n\n                            dead_tmp(tmp2);\n\n                        } else if (op == 4 || (op == 5 && u)) {\n\n                            /* Insert */\n\n                            switch (size) {\n\n                            case 0:\n\n                                if (op == 4)\n\n                                    mask = 0xff >> -shift;\n\n                                else\n\n                                    mask = (uint8_t)(0xff << shift);\n\n                                mask |= mask << 8;\n\n                                mask |= mask << 16;\n\n                                break;\n\n                            case 1:\n\n                                if (op == 4)\n\n                                    mask = 0xffff >> -shift;\n\n                                else\n\n                                    mask = (uint16_t)(0xffff << shift);\n\n                                mask |= mask << 16;\n\n                                break;\n\n                            case 2:\n\n                                if (shift < -31 || shift > 31) {\n\n                                    mask = 0;\n\n                                } else {\n\n                                    if (op == 4)\n\n                                        mask = 0xffffffffu >> -shift;\n\n                                    else\n\n                                        mask = 0xffffffffu << shift;\n\n                                }\n\n                                break;\n\n                            default:\n\n                                abort();\n\n                            }\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            tcg_gen_andi_i32(tmp, tmp, mask);\n\n                            tcg_gen_andi_i32(tmp2, tmp2, ~mask);\n\n                            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                            dead_tmp(tmp2);\n\n                        }\n\n                        neon_store_reg(rd, pass, tmp);\n\n                    }\n\n                } /* for pass */\n\n            } else if (op < 10) {\n\n                /* Shift by immediate and narrow:\n\n                   VSHRN, VRSHRN, VQSHRN, VQRSHRN.  */\n\n                shift = shift - (1 << (size + 3));\n\n                size++;\n\n                switch (size) {\n\n                case 1:\n\n                    imm = (uint16_t)shift;\n\n                    imm |= imm << 16;\n\n                    tmp2 = tcg_const_i32(imm);\n\n                    TCGV_UNUSED_I64(tmp64);\n\n                    break;\n\n                case 2:\n\n                    imm = (uint32_t)shift;\n\n                    tmp2 = tcg_const_i32(imm);\n\n                    TCGV_UNUSED_I64(tmp64);\n\n                    break;\n\n                case 3:\n\n                    tmp64 = tcg_const_i64(shift);\n\n                    TCGV_UNUSED(tmp2);\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (size == 3) {\n\n                        neon_load_reg64(cpu_V0, rm + pass);\n\n                        if (q) {\n\n                          if (u)\n\n                            gen_helper_neon_rshl_u64(cpu_V0, cpu_V0, tmp64);\n\n                          else\n\n                            gen_helper_neon_rshl_s64(cpu_V0, cpu_V0, tmp64);\n\n                        } else {\n\n                          if (u)\n\n                            gen_helper_neon_shl_u64(cpu_V0, cpu_V0, tmp64);\n\n                          else\n\n                            gen_helper_neon_shl_s64(cpu_V0, cpu_V0, tmp64);\n\n                        }\n\n                    } else {\n\n                        tmp = neon_load_reg(rm + pass, 0);\n\n                        gen_neon_shift_narrow(size, tmp, tmp2, q, u);\n\n                        tmp3 = neon_load_reg(rm + pass, 1);\n\n                        gen_neon_shift_narrow(size, tmp3, tmp2, q, u);\n\n                        tcg_gen_concat_i32_i64(cpu_V0, tmp, tmp3);\n\n                        dead_tmp(tmp);\n\n                        dead_tmp(tmp3);\n\n                    }\n\n                    tmp = new_tmp();\n\n                    if (op == 8 && !u) {\n\n                        gen_neon_narrow(size - 1, tmp, cpu_V0);\n\n                    } else {\n\n                        if (op == 8)\n\n                            gen_neon_narrow_sats(size - 1, tmp, cpu_V0);\n\n                        else\n\n                            gen_neon_narrow_satu(size - 1, tmp, cpu_V0);\n\n                    }\n\n                    neon_store_reg(rd, pass, tmp);\n\n                } /* for pass */\n\n                if (size == 3) {\n\n                    tcg_temp_free_i64(tmp64);\n\n                } else {\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n            } else if (op == 10) {\n\n                /* VSHLL */\n\n                if (q || size == 3)\n\n                    return 1;\n\n                tmp = neon_load_reg(rm, 0);\n\n                tmp2 = neon_load_reg(rm, 1);\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (pass == 1)\n\n                        tmp = tmp2;\n\n\n\n                    gen_neon_widen(cpu_V0, tmp, size, u);\n\n\n\n                    if (shift != 0) {\n\n                        /* The shift is less than the width of the source\n\n                           type, so we can just shift the whole register.  */\n\n                        tcg_gen_shli_i64(cpu_V0, cpu_V0, shift);\n\n                        if (size < 2 || !u) {\n\n                            uint64_t imm64;\n\n                            if (size == 0) {\n\n                                imm = (0xffu >> (8 - shift));\n\n                                imm |= imm << 16;\n\n                            } else {\n\n                                imm = 0xffff >> (16 - shift);\n\n                            }\n\n                            imm64 = imm | (((uint64_t)imm) << 32);\n\n                            tcg_gen_andi_i64(cpu_V0, cpu_V0, imm64);\n\n                        }\n\n                    }\n\n                    neon_store_reg64(cpu_V0, rd + pass);\n\n                }\n\n            } else if (op >= 14) {\n\n                /* VCVT fixed-point.  */\n\n                /* We have already masked out the must-be-1 top bit of imm6,\n\n                 * hence this 32-shift where the ARM ARM has 64-imm6.\n\n                 */\n\n                shift = 32 - shift;\n\n                for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, pass));\n\n                    if (!(op & 1)) {\n\n                        if (u)\n\n                            gen_vfp_ulto(0, shift);\n\n                        else\n\n                            gen_vfp_slto(0, shift);\n\n                    } else {\n\n                        if (u)\n\n                            gen_vfp_toul(0, shift);\n\n                        else\n\n                            gen_vfp_tosl(0, shift);\n\n                    }\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, pass));\n\n                }\n\n            } else {\n\n                return 1;\n\n            }\n\n        } else { /* (insn & 0x00380080) == 0 */\n\n            int invert;\n\n\n\n            op = (insn >> 8) & 0xf;\n\n            /* One register and immediate.  */\n\n            imm = (u << 7) | ((insn >> 12) & 0x70) | (insn & 0xf);\n\n            invert = (insn & (1 << 5)) != 0;\n\n            switch (op) {\n\n            case 0: case 1:\n\n                /* no-op */\n\n                break;\n\n            case 2: case 3:\n\n                imm <<= 8;\n\n                break;\n\n            case 4: case 5:\n\n                imm <<= 16;\n\n                break;\n\n            case 6: case 7:\n\n                imm <<= 24;\n\n                break;\n\n            case 8: case 9:\n\n                imm |= imm << 16;\n\n                break;\n\n            case 10: case 11:\n\n                imm = (imm << 8) | (imm << 24);\n\n                break;\n\n            case 12:\n\n                imm = (imm << 8) | 0xff;\n\n                break;\n\n            case 13:\n\n                imm = (imm << 16) | 0xffff;\n\n                break;\n\n            case 14:\n\n                imm |= (imm << 8) | (imm << 16) | (imm << 24);\n\n                if (invert)\n\n                    imm = ~imm;\n\n                break;\n\n            case 15:\n\n                imm = ((imm & 0x80) << 24) | ((imm & 0x3f) << 19)\n\n                      | ((imm & 0x40) ? (0x1f << 25) : (1 << 30));\n\n                break;\n\n            }\n\n            if (invert)\n\n                imm = ~imm;\n\n\n\n            for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                if (op & 1 && op < 12) {\n\n                    tmp = neon_load_reg(rd, pass);\n\n                    if (invert) {\n\n                        /* The immediate value has already been inverted, so\n\n                           BIC becomes AND.  */\n\n                        tcg_gen_andi_i32(tmp, tmp, imm);\n\n                    } else {\n\n                        tcg_gen_ori_i32(tmp, tmp, imm);\n\n                    }\n\n                } else {\n\n                    /* VMOV, VMVN.  */\n\n                    tmp = new_tmp();\n\n                    if (op == 14 && invert) {\n\n                        uint32_t val;\n\n                        val = 0;\n\n                        for (n = 0; n < 4; n++) {\n\n                            if (imm & (1 << (n + (pass & 1) * 4)))\n\n                                val |= 0xff << (n * 8);\n\n                        }\n\n                        tcg_gen_movi_i32(tmp, val);\n\n                    } else {\n\n                        tcg_gen_movi_i32(tmp, imm);\n\n                    }\n\n                }\n\n                neon_store_reg(rd, pass, tmp);\n\n            }\n\n        }\n\n    } else { /* (insn & 0x00800010 == 0x00800000) */\n\n        if (size != 3) {\n\n            op = (insn >> 8) & 0xf;\n\n            if ((insn & (1 << 6)) == 0) {\n\n                /* Three registers of different lengths.  */\n\n                int src1_wide;\n\n                int src2_wide;\n\n                int prewiden;\n\n                /* prewiden, src1_wide, src2_wide */\n\n                static const int neon_3reg_wide[16][3] = {\n\n                    {1, 0, 0}, /* VADDL */\n\n                    {1, 1, 0}, /* VADDW */\n\n                    {1, 0, 0}, /* VSUBL */\n\n                    {1, 1, 0}, /* VSUBW */\n\n                    {0, 1, 1}, /* VADDHN */\n\n                    {0, 0, 0}, /* VABAL */\n\n                    {0, 1, 1}, /* VSUBHN */\n\n                    {0, 0, 0}, /* VABDL */\n\n                    {0, 0, 0}, /* VMLAL */\n\n                    {0, 0, 0}, /* VQDMLAL */\n\n                    {0, 0, 0}, /* VMLSL */\n\n                    {0, 0, 0}, /* VQDMLSL */\n\n                    {0, 0, 0}, /* Integer VMULL */\n\n                    {0, 0, 0}, /* VQDMULL */\n\n                    {0, 0, 0}  /* Polynomial VMULL */\n\n                };\n\n\n\n                prewiden = neon_3reg_wide[op][0];\n\n                src1_wide = neon_3reg_wide[op][1];\n\n                src2_wide = neon_3reg_wide[op][2];\n\n\n\n                if (size == 0 && (op == 9 || op == 11 || op == 13))\n\n                    return 1;\n\n\n\n                /* Avoid overlapping operands.  Wide source operands are\n\n                   always aligned so will never overlap with wide\n\n                   destinations in problematic ways.  */\n\n                if (rd == rm && !src2_wide) {\n\n                    tmp = neon_load_reg(rm, 1);\n\n                    neon_store_scratch(2, tmp);\n\n                } else if (rd == rn && !src1_wide) {\n\n                    tmp = neon_load_reg(rn, 1);\n\n                    neon_store_scratch(2, tmp);\n\n                }\n\n                TCGV_UNUSED(tmp3);\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (src1_wide) {\n\n                        neon_load_reg64(cpu_V0, rn + pass);\n\n                        TCGV_UNUSED(tmp);\n\n                    } else {\n\n                        if (pass == 1 && rd == rn) {\n\n                            tmp = neon_load_scratch(2);\n\n                        } else {\n\n                            tmp = neon_load_reg(rn, pass);\n\n                        }\n\n                        if (prewiden) {\n\n                            gen_neon_widen(cpu_V0, tmp, size, u);\n\n                        }\n\n                    }\n\n                    if (src2_wide) {\n\n                        neon_load_reg64(cpu_V1, rm + pass);\n\n                        TCGV_UNUSED(tmp2);\n\n                    } else {\n\n                        if (pass == 1 && rd == rm) {\n\n                            tmp2 = neon_load_scratch(2);\n\n                        } else {\n\n                            tmp2 = neon_load_reg(rm, pass);\n\n                        }\n\n                        if (prewiden) {\n\n                            gen_neon_widen(cpu_V1, tmp2, size, u);\n\n                        }\n\n                    }\n\n                    switch (op) {\n\n                    case 0: case 1: case 4: /* VADDL, VADDW, VADDHN, VRADDHN */\n\n                        gen_neon_addl(size);\n\n                        break;\n\n                    case 2: case 3: case 6: /* VSUBL, VSUBW, VSUBHN, VRSUBHN */\n\n                        gen_neon_subl(size);\n\n                        break;\n\n                    case 5: case 7: /* VABAL, VABDL */\n\n                        switch ((size << 1) | u) {\n\n                        case 0:\n\n                            gen_helper_neon_abdl_s16(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 1:\n\n                            gen_helper_neon_abdl_u16(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 2:\n\n                            gen_helper_neon_abdl_s32(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 3:\n\n                            gen_helper_neon_abdl_u32(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 4:\n\n                            gen_helper_neon_abdl_s64(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 5:\n\n                            gen_helper_neon_abdl_u64(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        default: abort();\n\n                        }\n\n                        dead_tmp(tmp2);\n\n                        dead_tmp(tmp);\n\n                        break;\n\n                    case 8: case 9: case 10: case 11: case 12: case 13:\n\n                        /* VMLAL, VQDMLAL, VMLSL, VQDMLSL, VMULL, VQDMULL */\n\n                        gen_neon_mull(cpu_V0, tmp, tmp2, size, u);\n\n                        break;\n\n                    case 14: /* Polynomial VMULL */\n\n                        cpu_abort(env, \"Polynomial VMULL not implemented\");\n\n\n\n                    default: /* 15 is RESERVED.  */\n\n                        return 1;\n\n                    }\n\n                    if (op == 5 || op == 13 || (op >= 8 && op <= 11)) {\n\n                        /* Accumulate.  */\n\n                        if (op == 10 || op == 11) {\n\n                            gen_neon_negl(cpu_V0, size);\n\n                        }\n\n\n\n                        if (op != 13) {\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                        }\n\n\n\n                        switch (op) {\n\n                        case 5: case 8: case 10: /* VABAL, VMLAL, VMLSL */\n\n                            gen_neon_addl(size);\n\n                            break;\n\n                        case 9: case 11: /* VQDMLAL, VQDMLSL */\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V1, size);\n\n                            break;\n\n                            /* Fall through.  */\n\n                        case 13: /* VQDMULL */\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    } else if (op == 4 || op == 6) {\n\n                        /* Narrowing operation.  */\n\n                        tmp = new_tmp();\n\n                        if (!u) {\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_narrow_high_u8(tmp, cpu_V0);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_narrow_high_u16(tmp, cpu_V0);\n\n                                break;\n\n                            case 2:\n\n                                tcg_gen_shri_i64(cpu_V0, cpu_V0, 32);\n\n                                tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n                                break;\n\n                            default: abort();\n\n                            }\n\n                        } else {\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_narrow_round_high_u8(tmp, cpu_V0);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_narrow_round_high_u16(tmp, cpu_V0);\n\n                                break;\n\n                            case 2:\n\n                                tcg_gen_addi_i64(cpu_V0, cpu_V0, 1u << 31);\n\n                                tcg_gen_shri_i64(cpu_V0, cpu_V0, 32);\n\n                                tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n                                break;\n\n                            default: abort();\n\n                            }\n\n                        }\n\n                        if (pass == 0) {\n\n                            tmp3 = tmp;\n\n                        } else {\n\n                            neon_store_reg(rd, 0, tmp3);\n\n                            neon_store_reg(rd, 1, tmp);\n\n                        }\n\n                    } else {\n\n                        /* Write back the result.  */\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n                }\n\n            } else {\n\n                /* Two registers and a scalar.  */\n\n                switch (op) {\n\n                case 0: /* Integer VMLA scalar */\n\n                case 1: /* Float VMLA scalar */\n\n                case 4: /* Integer VMLS scalar */\n\n                case 5: /* Floating point VMLS scalar */\n\n                case 8: /* Integer VMUL scalar */\n\n                case 9: /* Floating point VMUL scalar */\n\n                case 12: /* VQDMULH scalar */\n\n                case 13: /* VQRDMULH scalar */\n\n                    tmp = neon_get_scalar(size, rm);\n\n                    neon_store_scratch(0, tmp);\n\n                    for (pass = 0; pass < (u ? 4 : 2); pass++) {\n\n                        tmp = neon_load_scratch(0);\n\n                        tmp2 = neon_load_reg(rn, pass);\n\n                        if (op == 12) {\n\n                            if (size == 1) {\n\n                                gen_helper_neon_qdmulh_s16(tmp, cpu_env, tmp, tmp2);\n\n                            } else {\n\n                                gen_helper_neon_qdmulh_s32(tmp, cpu_env, tmp, tmp2);\n\n                            }\n\n                        } else if (op == 13) {\n\n                            if (size == 1) {\n\n                                gen_helper_neon_qrdmulh_s16(tmp, cpu_env, tmp, tmp2);\n\n                            } else {\n\n                                gen_helper_neon_qrdmulh_s32(tmp, cpu_env, tmp, tmp2);\n\n                            }\n\n                        } else if (op & 1) {\n\n                            gen_helper_neon_mul_f32(tmp, tmp, tmp2);\n\n                        } else {\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n\n                            case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n\n                            default: return 1;\n\n                            }\n\n                        }\n\n                        dead_tmp(tmp2);\n\n                        if (op < 8) {\n\n                            /* Accumulate.  */\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            switch (op) {\n\n                            case 0:\n\n                                gen_neon_add(size, tmp, tmp2);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_add_f32(tmp, tmp, tmp2);\n\n                                break;\n\n                            case 4:\n\n                                gen_neon_rsb(size, tmp, tmp2);\n\n                                break;\n\n                            case 5:\n\n                                gen_helper_neon_sub_f32(tmp, tmp2, tmp);\n\n                                break;\n\n                            default:\n\n                                abort();\n\n                            }\n\n                            dead_tmp(tmp2);\n\n                        }\n\n                        neon_store_reg(rd, pass, tmp);\n\n                    }\n\n                    break;\n\n                case 2: /* VMLAL sclar */\n\n                case 3: /* VQDMLAL scalar */\n\n                case 6: /* VMLSL scalar */\n\n                case 7: /* VQDMLSL scalar */\n\n                case 10: /* VMULL scalar */\n\n                case 11: /* VQDMULL scalar */\n\n                    if (size == 0 && (op == 3 || op == 7 || op == 11))\n\n                        return 1;\n\n\n\n                    tmp2 = neon_get_scalar(size, rm);\n\n                    /* We need a copy of tmp2 because gen_neon_mull\n\n                     * deletes it during pass 0.  */\n\n                    tmp4 = new_tmp();\n\n                    tcg_gen_mov_i32(tmp4, tmp2);\n\n                    tmp3 = neon_load_reg(rn, 1);\n\n\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        if (pass == 0) {\n\n                            tmp = neon_load_reg(rn, 0);\n\n                        } else {\n\n                            tmp = tmp3;\n\n                            tmp2 = tmp4;\n\n                        }\n\n                        gen_neon_mull(cpu_V0, tmp, tmp2, size, u);\n\n                        if (op == 6 || op == 7) {\n\n                            gen_neon_negl(cpu_V0, size);\n\n                        }\n\n                        if (op != 11) {\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                        }\n\n                        switch (op) {\n\n                        case 2: case 6:\n\n                            gen_neon_addl(size);\n\n                            break;\n\n                        case 3: case 7:\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V1, size);\n\n                            break;\n\n                        case 10:\n\n                            /* no-op */\n\n                            break;\n\n                        case 11:\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n\n\n\n\n                    break;\n\n                default: /* 14 and 15 are RESERVED */\n\n                    return 1;\n\n                }\n\n            }\n\n        } else { /* size == 3 */\n\n            if (!u) {\n\n                /* Extract.  */\n\n                imm = (insn >> 8) & 0xf;\n\n\n\n                if (imm > 7 && !q)\n\n                    return 1;\n\n\n\n                if (imm == 0) {\n\n                    neon_load_reg64(cpu_V0, rn);\n\n                    if (q) {\n\n                        neon_load_reg64(cpu_V1, rn + 1);\n\n                    }\n\n                } else if (imm == 8) {\n\n                    neon_load_reg64(cpu_V0, rn + 1);\n\n                    if (q) {\n\n                        neon_load_reg64(cpu_V1, rm);\n\n                    }\n\n                } else if (q) {\n\n                    tmp64 = tcg_temp_new_i64();\n\n                    if (imm < 8) {\n\n                        neon_load_reg64(cpu_V0, rn);\n\n                        neon_load_reg64(tmp64, rn + 1);\n\n                    } else {\n\n                        neon_load_reg64(cpu_V0, rn + 1);\n\n                        neon_load_reg64(tmp64, rm);\n\n                    }\n\n                    tcg_gen_shri_i64(cpu_V0, cpu_V0, (imm & 7) * 8);\n\n                    tcg_gen_shli_i64(cpu_V1, tmp64, 64 - ((imm & 7) * 8));\n\n                    tcg_gen_or_i64(cpu_V0, cpu_V0, cpu_V1);\n\n                    if (imm < 8) {\n\n                        neon_load_reg64(cpu_V1, rm);\n\n                    } else {\n\n                        neon_load_reg64(cpu_V1, rm + 1);\n\n                        imm -= 8;\n\n                    }\n\n                    tcg_gen_shli_i64(cpu_V1, cpu_V1, 64 - (imm * 8));\n\n                    tcg_gen_shri_i64(tmp64, tmp64, imm * 8);\n\n                    tcg_gen_or_i64(cpu_V1, cpu_V1, tmp64);\n\n                    tcg_temp_free_i64(tmp64);\n\n                } else {\n\n                    /* BUGFIX */\n\n                    neon_load_reg64(cpu_V0, rn);\n\n                    tcg_gen_shri_i64(cpu_V0, cpu_V0, imm * 8);\n\n                    neon_load_reg64(cpu_V1, rm);\n\n                    tcg_gen_shli_i64(cpu_V1, cpu_V1, 64 - (imm * 8));\n\n                    tcg_gen_or_i64(cpu_V0, cpu_V0, cpu_V1);\n\n                }\n\n                neon_store_reg64(cpu_V0, rd);\n\n                if (q) {\n\n                    neon_store_reg64(cpu_V1, rd + 1);\n\n                }\n\n            } else if ((insn & (1 << 11)) == 0) {\n\n                /* Two register misc.  */\n\n                op = ((insn >> 12) & 0x30) | ((insn >> 7) & 0xf);\n\n                size = (insn >> 18) & 3;\n\n                switch (op) {\n\n                case 0: /* VREV64 */\n\n                    if (size == 3)\n\n                        return 1;\n\n                    for (pass = 0; pass < (q ? 2 : 1); pass++) {\n\n                        tmp = neon_load_reg(rm, pass * 2);\n\n                        tmp2 = neon_load_reg(rm, pass * 2 + 1);\n\n                        switch (size) {\n\n                        case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n                        case 1: gen_swap_half(tmp); break;\n\n                        case 2: /* no-op */ break;\n\n                        default: abort();\n\n                        }\n\n                        neon_store_reg(rd, pass * 2 + 1, tmp);\n\n                        if (size == 2) {\n\n                            neon_store_reg(rd, pass * 2, tmp2);\n\n                        } else {\n\n                            switch (size) {\n\n                            case 0: tcg_gen_bswap32_i32(tmp2, tmp2); break;\n\n                            case 1: gen_swap_half(tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                            neon_store_reg(rd, pass * 2, tmp2);\n\n                        }\n\n                    }\n\n                    break;\n\n                case 4: case 5: /* VPADDL */\n\n                case 12: case 13: /* VPADAL */\n\n                    if (size == 3)\n\n                        return 1;\n\n                    for (pass = 0; pass < q + 1; pass++) {\n\n                        tmp = neon_load_reg(rm, pass * 2);\n\n                        gen_neon_widen(cpu_V0, tmp, size, op & 1);\n\n                        tmp = neon_load_reg(rm, pass * 2 + 1);\n\n                        gen_neon_widen(cpu_V1, tmp, size, op & 1);\n\n                        switch (size) {\n\n                        case 0: gen_helper_neon_paddl_u16(CPU_V001); break;\n\n                        case 1: gen_helper_neon_paddl_u32(CPU_V001); break;\n\n                        case 2: tcg_gen_add_i64(CPU_V001); break;\n\n                        default: abort();\n\n                        }\n\n                        if (op >= 12) {\n\n                            /* Accumulate.  */\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                            gen_neon_addl(size);\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n                    break;\n\n                case 33: /* VTRN */\n\n                    if (size == 2) {\n\n                        for (n = 0; n < (q ? 4 : 2); n += 2) {\n\n                            tmp = neon_load_reg(rm, n);\n\n                            tmp2 = neon_load_reg(rd, n + 1);\n\n                            neon_store_reg(rm, n, tmp2);\n\n                            neon_store_reg(rd, n + 1, tmp);\n\n                        }\n\n                    } else {\n\n                        goto elementwise;\n\n                    }\n\n                    break;\n\n                case 34: /* VUZP */\n\n                    /* Reg  Before       After\n\n                       Rd   A3 A2 A1 A0  B2 B0 A2 A0\n\n                       Rm   B3 B2 B1 B0  B3 B1 A3 A1\n\n                     */\n\n                    if (size == 3)\n\n                        return 1;\n\n                    gen_neon_unzip(rd, q, 0, size);\n\n                    gen_neon_unzip(rm, q, 4, size);\n\n                    if (q) {\n\n                        static int unzip_order_q[8] =\n\n                            {0, 2, 4, 6, 1, 3, 5, 7};\n\n                        for (n = 0; n < 8; n++) {\n\n                            int reg = (n < 4) ? rd : rm;\n\n                            tmp = neon_load_scratch(unzip_order_q[n]);\n\n                            neon_store_reg(reg, n % 4, tmp);\n\n                        }\n\n                    } else {\n\n                        static int unzip_order[4] =\n\n                            {0, 4, 1, 5};\n\n                        for (n = 0; n < 4; n++) {\n\n                            int reg = (n < 2) ? rd : rm;\n\n                            tmp = neon_load_scratch(unzip_order[n]);\n\n                            neon_store_reg(reg, n % 2, tmp);\n\n                        }\n\n                    }\n\n                    break;\n\n                case 35: /* VZIP */\n\n                    /* Reg  Before       After\n\n                       Rd   A3 A2 A1 A0  B1 A1 B0 A0\n\n                       Rm   B3 B2 B1 B0  B3 A3 B2 A2\n\n                     */\n\n                    if (size == 3)\n\n                        return 1;\n\n                    count = (q ? 4 : 2);\n\n                    for (n = 0; n < count; n++) {\n\n                        tmp = neon_load_reg(rd, n);\n\n                        tmp2 = neon_load_reg(rd, n);\n\n                        switch (size) {\n\n                        case 0: gen_neon_zip_u8(tmp, tmp2); break;\n\n                        case 1: gen_neon_zip_u16(tmp, tmp2); break;\n\n                        case 2: /* no-op */; break;\n\n                        default: abort();\n\n                        }\n\n                        neon_store_scratch(n * 2, tmp);\n\n                        neon_store_scratch(n * 2 + 1, tmp2);\n\n                    }\n\n                    for (n = 0; n < count * 2; n++) {\n\n                        int reg = (n < count) ? rd : rm;\n\n                        tmp = neon_load_scratch(n);\n\n                        neon_store_reg(reg, n % count, tmp);\n\n                    }\n\n                    break;\n\n                case 36: case 37: /* VMOVN, VQMOVUN, VQMOVN */\n\n                    if (size == 3)\n\n                        return 1;\n\n                    TCGV_UNUSED(tmp2);\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        neon_load_reg64(cpu_V0, rm + pass);\n\n                        tmp = new_tmp();\n\n                        if (op == 36 && q == 0) {\n\n                            gen_neon_narrow(size, tmp, cpu_V0);\n\n                        } else if (q) {\n\n                            gen_neon_narrow_satu(size, tmp, cpu_V0);\n\n                        } else {\n\n                            gen_neon_narrow_sats(size, tmp, cpu_V0);\n\n                        }\n\n                        if (pass == 0) {\n\n                            tmp2 = tmp;\n\n                        } else {\n\n                            neon_store_reg(rd, 0, tmp2);\n\n                            neon_store_reg(rd, 1, tmp);\n\n                        }\n\n                    }\n\n                    break;\n\n                case 38: /* VSHLL */\n\n                    if (q || size == 3)\n\n                        return 1;\n\n                    tmp = neon_load_reg(rm, 0);\n\n                    tmp2 = neon_load_reg(rm, 1);\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        if (pass == 1)\n\n                            tmp = tmp2;\n\n                        gen_neon_widen(cpu_V0, tmp, size, 1);\n\n                        tcg_gen_shli_i64(cpu_V0, cpu_V0, 8 << size);\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n                    break;\n\n                case 44: /* VCVT.F16.F32 */\n\n                    if (!arm_feature(env, ARM_FEATURE_VFP_FP16))\n\n                      return 1;\n\n                    tmp = new_tmp();\n\n                    tmp2 = new_tmp();\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 0));\n\n                    gen_helper_vfp_fcvt_f32_to_f16(tmp, cpu_F0s, cpu_env);\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 1));\n\n                    gen_helper_vfp_fcvt_f32_to_f16(tmp2, cpu_F0s, cpu_env);\n\n                    tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n                    tcg_gen_or_i32(tmp2, tmp2, tmp);\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 2));\n\n                    gen_helper_vfp_fcvt_f32_to_f16(tmp, cpu_F0s, cpu_env);\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 3));\n\n                    neon_store_reg(rd, 0, tmp2);\n\n                    tmp2 = new_tmp();\n\n                    gen_helper_vfp_fcvt_f32_to_f16(tmp2, cpu_F0s, cpu_env);\n\n                    tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n                    tcg_gen_or_i32(tmp2, tmp2, tmp);\n\n                    neon_store_reg(rd, 1, tmp2);\n\n                    dead_tmp(tmp);\n\n                    break;\n\n                case 46: /* VCVT.F32.F16 */\n\n                    if (!arm_feature(env, ARM_FEATURE_VFP_FP16))\n\n                      return 1;\n\n                    tmp3 = new_tmp();\n\n                    tmp = neon_load_reg(rm, 0);\n\n                    tmp2 = neon_load_reg(rm, 1);\n\n                    tcg_gen_ext16u_i32(tmp3, tmp);\n\n                    gen_helper_vfp_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 0));\n\n                    tcg_gen_shri_i32(tmp3, tmp, 16);\n\n                    gen_helper_vfp_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 1));\n\n                    dead_tmp(tmp);\n\n                    tcg_gen_ext16u_i32(tmp3, tmp2);\n\n                    gen_helper_vfp_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 2));\n\n                    tcg_gen_shri_i32(tmp3, tmp2, 16);\n\n                    gen_helper_vfp_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 3));\n\n                    dead_tmp(tmp2);\n\n                    dead_tmp(tmp3);\n\n                    break;\n\n                default:\n\n                elementwise:\n\n                    for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                        if (op == 30 || op == 31 || op >= 58) {\n\n                            tcg_gen_ld_f32(cpu_F0s, cpu_env,\n\n                                           neon_reg_offset(rm, pass));\n\n                            TCGV_UNUSED(tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rm, pass);\n\n                        }\n\n                        switch (op) {\n\n                        case 1: /* VREV32 */\n\n                            switch (size) {\n\n                            case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n                            case 1: gen_swap_half(tmp); break;\n\n                            default: return 1;\n\n                            }\n\n                            break;\n\n                        case 2: /* VREV16 */\n\n                            if (size != 0)\n\n                                return 1;\n\n                            gen_rev16(tmp);\n\n                            break;\n\n                        case 8: /* CLS */\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_cls_s8(tmp, tmp); break;\n\n                            case 1: gen_helper_neon_cls_s16(tmp, tmp); break;\n\n                            case 2: gen_helper_neon_cls_s32(tmp, tmp); break;\n\n                            default: return 1;\n\n                            }\n\n                            break;\n\n                        case 9: /* CLZ */\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_clz_u8(tmp, tmp); break;\n\n                            case 1: gen_helper_neon_clz_u16(tmp, tmp); break;\n\n                            case 2: gen_helper_clz(tmp, tmp); break;\n\n                            default: return 1;\n\n                            }\n\n                            break;\n\n                        case 10: /* CNT */\n\n                            if (size != 0)\n\n                                return 1;\n\n                            gen_helper_neon_cnt_u8(tmp, tmp);\n\n                            break;\n\n                        case 11: /* VNOT */\n\n                            if (size != 0)\n\n                                return 1;\n\n                            tcg_gen_not_i32(tmp, tmp);\n\n                            break;\n\n                        case 14: /* VQABS */\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_qabs_s8(tmp, cpu_env, tmp); break;\n\n                            case 1: gen_helper_neon_qabs_s16(tmp, cpu_env, tmp); break;\n\n                            case 2: gen_helper_neon_qabs_s32(tmp, cpu_env, tmp); break;\n\n                            default: return 1;\n\n                            }\n\n                            break;\n\n                        case 15: /* VQNEG */\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_qneg_s8(tmp, cpu_env, tmp); break;\n\n                            case 1: gen_helper_neon_qneg_s16(tmp, cpu_env, tmp); break;\n\n                            case 2: gen_helper_neon_qneg_s32(tmp, cpu_env, tmp); break;\n\n                            default: return 1;\n\n                            }\n\n                            break;\n\n                        case 16: case 19: /* VCGT #0, VCLE #0 */\n\n                            tmp2 = tcg_const_i32(0);\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_cgt_s8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_cgt_s16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_cgt_s32(tmp, tmp, tmp2); break;\n\n                            default: return 1;\n\n                            }\n\n                            tcg_temp_free(tmp2);\n\n                            if (op == 19)\n\n                                tcg_gen_not_i32(tmp, tmp);\n\n                            break;\n\n                        case 17: case 20: /* VCGE #0, VCLT #0 */\n\n                            tmp2 = tcg_const_i32(0);\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_cge_s8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_cge_s16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_cge_s32(tmp, tmp, tmp2); break;\n\n                            default: return 1;\n\n                            }\n\n                            tcg_temp_free(tmp2);\n\n                            if (op == 20)\n\n                                tcg_gen_not_i32(tmp, tmp);\n\n                            break;\n\n                        case 18: /* VCEQ #0 */\n\n                            tmp2 = tcg_const_i32(0);\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_ceq_u8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_ceq_u16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_ceq_u32(tmp, tmp, tmp2); break;\n\n                            default: return 1;\n\n                            }\n\n                            tcg_temp_free(tmp2);\n\n                            break;\n\n                        case 22: /* VABS */\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_abs_s8(tmp, tmp); break;\n\n                            case 1: gen_helper_neon_abs_s16(tmp, tmp); break;\n\n                            case 2: tcg_gen_abs_i32(tmp, tmp); break;\n\n                            default: return 1;\n\n                            }\n\n                            break;\n\n                        case 23: /* VNEG */\n\n                            if (size == 3)\n\n                                return 1;\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_neon_rsb(size, tmp, tmp2);\n\n                            tcg_temp_free(tmp2);\n\n                            break;\n\n                        case 24: case 27: /* Float VCGT #0, Float VCLE #0 */\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_cgt_f32(tmp, tmp, tmp2);\n\n                            tcg_temp_free(tmp2);\n\n                            if (op == 27)\n\n                                tcg_gen_not_i32(tmp, tmp);\n\n                            break;\n\n                        case 25: case 28: /* Float VCGE #0, Float VCLT #0 */\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_cge_f32(tmp, tmp, tmp2);\n\n                            tcg_temp_free(tmp2);\n\n                            if (op == 28)\n\n                                tcg_gen_not_i32(tmp, tmp);\n\n                            break;\n\n                        case 26: /* Float VCEQ #0 */\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_ceq_f32(tmp, tmp, tmp2);\n\n                            tcg_temp_free(tmp2);\n\n                            break;\n\n                        case 30: /* Float VABS */\n\n                            gen_vfp_abs(0);\n\n                            break;\n\n                        case 31: /* Float VNEG */\n\n                            gen_vfp_neg(0);\n\n                            break;\n\n                        case 32: /* VSWP */\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            neon_store_reg(rm, pass, tmp2);\n\n                            break;\n\n                        case 33: /* VTRN */\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            switch (size) {\n\n                            case 0: gen_neon_trn_u8(tmp, tmp2); break;\n\n                            case 1: gen_neon_trn_u16(tmp, tmp2); break;\n\n                            case 2: abort();\n\n                            default: return 1;\n\n                            }\n\n                            neon_store_reg(rm, pass, tmp2);\n\n                            break;\n\n                        case 56: /* Integer VRECPE */\n\n                            gen_helper_recpe_u32(tmp, tmp, cpu_env);\n\n                            break;\n\n                        case 57: /* Integer VRSQRTE */\n\n                            gen_helper_rsqrte_u32(tmp, tmp, cpu_env);\n\n                            break;\n\n                        case 58: /* Float VRECPE */\n\n                            gen_helper_recpe_f32(cpu_F0s, cpu_F0s, cpu_env);\n\n                            break;\n\n                        case 59: /* Float VRSQRTE */\n\n                            gen_helper_rsqrte_f32(cpu_F0s, cpu_F0s, cpu_env);\n\n                            break;\n\n                        case 60: /* VCVT.F32.S32 */\n\n                            gen_vfp_sito(0);\n\n                            break;\n\n                        case 61: /* VCVT.F32.U32 */\n\n                            gen_vfp_uito(0);\n\n                            break;\n\n                        case 62: /* VCVT.S32.F32 */\n\n                            gen_vfp_tosiz(0);\n\n                            break;\n\n                        case 63: /* VCVT.U32.F32 */\n\n                            gen_vfp_touiz(0);\n\n                            break;\n\n                        default:\n\n                            /* Reserved: 21, 29, 39-56 */\n\n                            return 1;\n\n                        }\n\n                        if (op == 30 || op == 31 || op >= 58) {\n\n                            tcg_gen_st_f32(cpu_F0s, cpu_env,\n\n                                           neon_reg_offset(rd, pass));\n\n                        } else {\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            } else if ((insn & (1 << 10)) == 0) {\n\n                /* VTBL, VTBX.  */\n\n                n = ((insn >> 5) & 0x18) + 8;\n\n                if (insn & (1 << 6)) {\n\n                    tmp = neon_load_reg(rd, 0);\n\n                } else {\n\n                    tmp = new_tmp();\n\n                    tcg_gen_movi_i32(tmp, 0);\n\n                }\n\n                tmp2 = neon_load_reg(rm, 0);\n\n                tmp4 = tcg_const_i32(rn);\n\n                tmp5 = tcg_const_i32(n);\n\n                gen_helper_neon_tbl(tmp2, tmp2, tmp, tmp4, tmp5);\n\n                dead_tmp(tmp);\n\n                if (insn & (1 << 6)) {\n\n                    tmp = neon_load_reg(rd, 1);\n\n                } else {\n\n                    tmp = new_tmp();\n\n                    tcg_gen_movi_i32(tmp, 0);\n\n                }\n\n                tmp3 = neon_load_reg(rm, 1);\n\n                gen_helper_neon_tbl(tmp3, tmp3, tmp, tmp4, tmp5);\n\n                tcg_temp_free_i32(tmp5);\n\n                tcg_temp_free_i32(tmp4);\n\n                neon_store_reg(rd, 0, tmp2);\n\n                neon_store_reg(rd, 1, tmp3);\n\n                dead_tmp(tmp);\n\n            } else if ((insn & 0x380) == 0) {\n\n                /* VDUP */\n\n                if (insn & (1 << 19)) {\n\n                    tmp = neon_load_reg(rm, 1);\n\n                } else {\n\n                    tmp = neon_load_reg(rm, 0);\n\n                }\n\n                if (insn & (1 << 16)) {\n\n                    gen_neon_dup_u8(tmp, ((insn >> 17) & 3) * 8);\n\n                } else if (insn & (1 << 17)) {\n\n                    if ((insn >> 18) & 1)\n\n                        gen_neon_dup_high16(tmp);\n\n                    else\n\n                        gen_neon_dup_low16(tmp);\n\n                }\n\n                for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                    tmp2 = new_tmp();\n\n                    tcg_gen_mov_i32(tmp2, tmp);\n\n                    neon_store_reg(rd, pass, tmp2);\n\n                }\n\n                dead_tmp(tmp);\n\n            } else {\n\n                return 1;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1385}
{"project": "qemu", "commit_id": "f80872e21c07edd06eb343eeeefc8af404b518a6", "target": 1, "func": "static void init_proc_POWER7 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Processor identification */\n\n    spr_register(env, SPR_PIR, \"PIR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_pir,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* PURR & SPURR: Hack - treat these as aliases for the TB for now */\n\n    spr_register_kvm(env, SPR_PURR,   \"PURR\",\n\n                     &spr_read_purr, SPR_NOACCESS,\n\n                     &spr_read_purr, SPR_NOACCESS,\n\n                     KVM_REG_PPC_PURR, 0x00000000);\n\n    spr_register_kvm(env, SPR_SPURR,   \"SPURR\",\n\n                     &spr_read_purr, SPR_NOACCESS,\n\n                     &spr_read_purr, SPR_NOACCESS,\n\n                     KVM_REG_PPC_SPURR, 0x00000000);\n\n    spr_register(env, SPR_CFAR, \"SPR_CFAR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_cfar, &spr_write_cfar,\n\n                 0x00000000);\n\n    spr_register_kvm(env, SPR_DSCR, \"SPR_DSCR\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_generic,\n\n                     KVM_REG_PPC_DSCR, 0x00000000);\n\n#endif /* !CONFIG_USER_ONLY */\n\n    /* Memory management */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRLT\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x80800000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_CTRLF\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x80800000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 32;\n\n#endif\n\n    init_excp_POWER7(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppcPOWER7_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}", "idx": 2720}
{"project": "qemu", "commit_id": "bd16430777cc3d25930e479fdbe290d92cec0888", "target": 1, "func": "static void sysbus_ahci_realize(DeviceState *dev, Error **errp)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    SysbusAHCIState *s = SYSBUS_AHCI(dev);\n\n\n\n    ahci_init(&s->ahci, dev, NULL, s->num_ports);\n\n\n\n    sysbus_init_mmio(sbd, &s->ahci.mem);\n\n    sysbus_init_irq(sbd, &s->ahci.irq);\n\n}\n", "idx": 5674}
{"project": "qemu", "commit_id": "ff4b91c2f7e51dab148aba4bf43c2f39f219e495", "target": 1, "func": "static uint64_t get_cluster_offset(BlockDriverState *bs,\n\n                                   uint64_t offset, int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int l1_bits, c;\n\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n\n\n\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n\n    nb_needed = *num + index_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the offset and\n\n     * the end of the l1 entry\n\n     */\n\n\n\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n", "idx": 10293}
{"project": "qemu", "commit_id": "8ce1ee4618f4a557959f5a5731f6726b30416df5", "target": 1, "func": "GuestMemoryBlockInfo *qmp_guest_get_memory_block_info(Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    char *dirpath;\n\n    int dirfd;\n\n    char *buf;\n\n    GuestMemoryBlockInfo *info;\n\n\n\n    dirpath = g_strdup_printf(\"/sys/devices/system/memory/\");\n\n    dirfd = open(dirpath, O_RDONLY | O_DIRECTORY);\n\n    if (dirfd == -1) {\n\n        error_setg_errno(errp, errno, \"open(\\\"%s\\\")\", dirpath);\n\n        g_free(dirpath);\n\n        return NULL;\n\n    }\n\n    g_free(dirpath);\n\n\n\n    buf = g_malloc0(20);\n\n    ga_read_sysfs_file(dirfd, \"block_size_bytes\", buf, 20, &local_err);\n\n\n    if (local_err) {\n\n        g_free(buf);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n\n\n    info = g_new0(GuestMemoryBlockInfo, 1);\n\n    info->size = strtol(buf, NULL, 16); /* the unit is bytes */\n\n\n\n    g_free(buf);\n\n\n\n    return info;\n\n}", "idx": 10280}
{"project": "qemu", "commit_id": "4118a97030aa9bd1d520d1d06bbe0655d829df04", "target": 1, "func": "long target_mmap(target_ulong start, target_ulong len, int prot,\n\n                 int flags, int fd, target_ulong offset)\n\n{\n\n    target_ulong ret, end, real_start, real_end, retaddr, host_offset, host_len;\n\n    long host_start;\n\n#if defined(__alpha__) || defined(__sparc__) || defined(__x86_64__) || \\\n\n        defined(__ia64) || defined(__mips__)\n\n    static target_ulong last_start = 0x40000000;\n\n#elif defined(__CYGWIN__)\n\n    /* Cygwin doesn't have a whole lot of address space.  */\n\n    static target_ulong last_start = 0x18000000;\n\n#endif\n\n\n\n#ifdef DEBUG_MMAP\n\n    {\n\n        printf(\"mmap: start=0x%lx len=0x%lx prot=%c%c%c flags=\",\n\n               start, len,\n\n               prot & PROT_READ ? 'r' : '-',\n\n               prot & PROT_WRITE ? 'w' : '-',\n\n               prot & PROT_EXEC ? 'x' : '-');\n\n        if (flags & MAP_FIXED)\n\n            printf(\"MAP_FIXED \");\n\n        if (flags & MAP_ANONYMOUS)\n\n            printf(\"MAP_ANON \");\n\n        switch(flags & MAP_TYPE) {\n\n        case MAP_PRIVATE:\n\n            printf(\"MAP_PRIVATE \");\n\n            break;\n\n        case MAP_SHARED:\n\n            printf(\"MAP_SHARED \");\n\n            break;\n\n        default:\n\n            printf(\"[MAP_TYPE=0x%x] \", flags & MAP_TYPE);\n\n            break;\n\n        }\n\n        printf(\"fd=%d offset=%lx\\n\", fd, offset);\n\n    }\n\n#endif\n\n\n\n    if (offset & ~TARGET_PAGE_MASK) {\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    len = TARGET_PAGE_ALIGN(len);\n\n    if (len == 0)\n\n        return start;\n\n    real_start = start & qemu_host_page_mask;\n\n\n\n    if (!(flags & MAP_FIXED)) {\n\n#if defined(__alpha__) || defined(__sparc__) || defined(__x86_64__) || \\\n\n    defined(__ia64) || defined(__mips__) || defined(__CYGWIN__)\n\n        /* tell the kernel to search at the same place as i386 */\n\n        if (real_start == 0) {\n\n            real_start = last_start;\n\n            last_start += HOST_PAGE_ALIGN(len);\n\n        }\n\n#endif\n\n        if (0 && qemu_host_page_size != qemu_real_host_page_size) {\n\n            /* NOTE: this code is only for debugging with '-p' option */\n\n            /* ??? Can also occur when TARGET_PAGE_SIZE > host page size.  */\n\n            /* reserve a memory area */\n\n            /* ??? This needs fixing for remapping.  */\n\nabort();\n\n            host_len = HOST_PAGE_ALIGN(len) + qemu_host_page_size - TARGET_PAGE_SIZE;\n\n            real_start = (long)mmap(g2h(real_start), host_len, PROT_NONE,\n\n                                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n            if (real_start == -1)\n\n                return real_start;\n\n            real_end = real_start + host_len;\n\n            start = HOST_PAGE_ALIGN(real_start);\n\n            end = start + HOST_PAGE_ALIGN(len);\n\n            if (start > real_start)\n\n                munmap((void *)real_start, start - real_start);\n\n            if (end < real_end)\n\n                munmap((void *)end, real_end - end);\n\n            /* use it as a fixed mapping */\n\n            flags |= MAP_FIXED;\n\n        } else {\n\n            /* if not fixed, no need to do anything */\n\n            host_offset = offset & qemu_host_page_mask;\n\n            host_len = len + offset - host_offset;\n\n            host_start = (long)mmap(real_start ? g2h(real_start) : NULL,\n\n                                    host_len, prot, flags, fd, host_offset);\n\n            if (host_start == -1)\n\n                return host_start;\n\n            /* update start so that it points to the file position at 'offset' */\n\n            if (!(flags & MAP_ANONYMOUS))\n\n                host_start += offset - host_offset;\n\n            start = h2g(host_start);\n\n            goto the_end1;\n\n        }\n\n    }\n\n\n\n    if (start & ~TARGET_PAGE_MASK) {\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    end = start + len;\n\n    real_end = HOST_PAGE_ALIGN(end);\n\n\n\n    /* worst case: we cannot map the file because the offset is not\n\n       aligned, so we read it */\n\n    if (!(flags & MAP_ANONYMOUS) &&\n\n        (offset & ~qemu_host_page_mask) != (start & ~qemu_host_page_mask)) {\n\n        /* msync() won't work here, so we return an error if write is\n\n           possible while it is a shared mapping */\n\n        if ((flags & MAP_TYPE) == MAP_SHARED &&\n\n            (prot & PROT_WRITE)) {\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        retaddr = target_mmap(start, len, prot | PROT_WRITE,\n\n                              MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,\n\n                              -1, 0);\n\n        if (retaddr == -1)\n\n            return retaddr;\n\n        pread(fd, g2h(start), len, offset);\n\n        if (!(prot & PROT_WRITE)) {\n\n            ret = target_mprotect(start, len, prot);\n\n            if (ret != 0)\n\n                return ret;\n\n        }\n\n        goto the_end;\n\n    }\n\n\n\n    /* handle the start of the mapping */\n\n    if (start > real_start) {\n\n        if (real_end == real_start + qemu_host_page_size) {\n\n            /* one single host page */\n\n            ret = mmap_frag(real_start, start, end,\n\n                            prot, flags, fd, offset);\n\n            if (ret == -1)\n\n                return ret;\n\n            goto the_end1;\n\n        }\n\n        ret = mmap_frag(real_start, start, real_start + qemu_host_page_size,\n\n                        prot, flags, fd, offset);\n\n        if (ret == -1)\n\n            return ret;\n\n        real_start += qemu_host_page_size;\n\n    }\n\n    /* handle the end of the mapping */\n\n    if (end < real_end) {\n\n        ret = mmap_frag(real_end - qemu_host_page_size,\n\n                        real_end - qemu_host_page_size, real_end,\n\n                        prot, flags, fd,\n\n                        offset + real_end - qemu_host_page_size - start);\n\n        if (ret == -1)\n\n            return ret;\n\n        real_end -= qemu_host_page_size;\n\n    }\n\n\n\n    /* map the middle (easier) */\n\n    if (real_start < real_end) {\n\n        unsigned long offset1;\n\n\tif (flags & MAP_ANONYMOUS)\n\n\t  offset1 = 0;\n\n\telse\n\n\t  offset1 = offset + real_start - start;\n\n        ret = (long)mmap(g2h(real_start), real_end - real_start,\n\n                         prot, flags, fd, offset1);\n\n        if (ret == -1)\n\n            return ret;\n\n    }\n\n the_end1:\n\n    page_set_flags(start, start + len, prot | PAGE_VALID);\n\n the_end:\n\n#ifdef DEBUG_MMAP\n\n    printf(\"ret=0x%lx\\n\", (long)start);\n\n    page_dump(stdout);\n\n    printf(\"\\n\");\n\n#endif\n\n    return start;\n\n}\n", "idx": 9007}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n", "idx": 9593}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_flush(void *opaque)\n\n{\n\n    int16_t tag;\n\n    size_t offset = 7;\n\n    V9fsPDU *cancel_pdu;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"w\", &tag);\n\n\n\n\n    QLIST_FOREACH(cancel_pdu, &s->active_list, next) {\n\n        if (cancel_pdu->tag == tag) {\n\n            break;\n\n        }\n\n    }\n\n    if (cancel_pdu) {\n\n        cancel_pdu->cancelled = 1;\n\n        /*\n\n         * Wait for pdu to complete.\n\n         */\n\n        qemu_co_queue_wait(&cancel_pdu->complete);\n\n        cancel_pdu->cancelled = 0;\n\n        free_pdu(pdu->s, cancel_pdu);\n\n    }\n\n    complete_pdu(s, pdu, 7);\n\n    return;\n\n}", "idx": 11363}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static uint32_t qvirtio_pci_get_guest_features(QVirtioDevice *d)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    return qpci_io_readl(dev->pdev, dev->addr + VIRTIO_PCI_GUEST_FEATURES);\n\n}\n", "idx": 9171}
{"project": "qemu", "commit_id": "33243031dad02d161225ba99d782616da133f689", "target": 1, "func": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n\n                                          struct virtio_gpu_ctrl_command *cmd)\n\n{\n\n    struct virtio_gpu_resource_attach_backing att_rb;\n\n    struct iovec *res_iovs;\n\n    int ret;\n\n\n\n    VIRTIO_GPU_FILL_CMD(att_rb);\n\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n\n\n\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n\n    if (ret != 0) {\n\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n\n        return;\n\n    }\n\n\n\n    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n\n                                       res_iovs, att_rb.nr_entries);\n\n}\n", "idx": 5690}
{"project": "qemu", "commit_id": "0ccb9c1d8128a020720d5c6abf99a470742a1b94", "target": 1, "func": "DISAS_INSN(divw)\n\n{\n\n    TCGv reg;\n\n    TCGv tmp;\n\n    TCGv src;\n\n    int sign;\n\n\n\n    sign = (insn & 0x100) != 0;\n\n    reg = DREG(insn, 9);\n\n    if (sign) {\n\n        tcg_gen_ext16s_i32(QREG_DIV1, reg);\n\n    } else {\n\n        tcg_gen_ext16u_i32(QREG_DIV1, reg);\n\n    }\n\n    SRC_EA(env, src, OS_WORD, sign, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, src);\n\n    if (sign) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(1));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(1));\n\n    }\n\n\n\n    tmp = tcg_temp_new();\n\n    src = tcg_temp_new();\n\n    tcg_gen_ext16u_i32(tmp, QREG_DIV1);\n\n    tcg_gen_shli_i32(src, QREG_DIV2, 16);\n\n    tcg_gen_or_i32(reg, tmp, src);\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n", "idx": 8358}
{"project": "qemu", "commit_id": "56c4bfb3f07f3107894c00281276aea4f5e8834d", "target": 1, "func": "static void get_offset_range(hwaddr phys_addr,\n\n                             ram_addr_t mapping_length,\n\n                             DumpState *s,\n\n                             hwaddr *p_offset,\n\n                             hwaddr *p_filesz)\n\n{\n\n    RAMBlock *block;\n\n    hwaddr offset = s->memory_offset;\n\n    int64_t size_in_block, start;\n\n\n\n    /* When the memory is not stored into vmcore, offset will be -1 */\n\n    *p_offset = -1;\n\n    *p_filesz = 0;\n\n\n\n    if (s->has_filter) {\n\n        if (phys_addr < s->begin || phys_addr >= s->begin + s->length) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (s->has_filter) {\n\n            if (block->offset >= s->begin + s->length ||\n\n                block->offset + block->length <= s->begin) {\n\n                /* This block is out of the range */\n\n                continue;\n\n            }\n\n\n\n            if (s->begin <= block->offset) {\n\n                start = block->offset;\n\n            } else {\n\n                start = s->begin;\n\n            }\n\n\n\n            size_in_block = block->length - (start - block->offset);\n\n            if (s->begin + s->length < block->offset + block->length) {\n\n                size_in_block -= block->offset + block->length -\n\n                                 (s->begin + s->length);\n\n            }\n\n        } else {\n\n            start = block->offset;\n\n            size_in_block = block->length;\n\n        }\n\n\n\n        if (phys_addr >= start && phys_addr < start + size_in_block) {\n\n            *p_offset = phys_addr - start + offset;\n\n\n\n            /* The offset range mapped from the vmcore file must not spill over\n\n             * the RAMBlock, clamp it. The rest of the mapping will be\n\n             * zero-filled in memory at load time; see\n\n             * <http://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html>.\n\n             */\n\n            *p_filesz = phys_addr + mapping_length <= start + size_in_block ?\n\n                        mapping_length :\n\n                        size_in_block - (phys_addr - start);\n\n            return;\n\n        }\n\n\n\n        offset += size_in_block;\n\n    }\n\n}\n", "idx": 1043}
{"project": "qemu", "commit_id": "4a94fc9bf2dac5965acb8e264d55a356737a2aa6", "target": 1, "func": "static void zynq_xadc_write(void *opaque, hwaddr offset, uint64_t val,\n\n                            unsigned size)\n\n{\n\n    ZynqXADCState *s = (ZynqXADCState *)opaque;\n\n    int reg = offset / 4;\n\n    int xadc_reg;\n\n    int xadc_cmd;\n\n    int xadc_data;\n\n\n\n    if (!zynq_xadc_check_offset(reg, false)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"zynq_xadc: Invalid write access \"\n\n                      \"to addr %\" HWADDR_PRIx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case CFG:\n\n        s->regs[CFG] = val;\n\n        break;\n\n    case INT_STS:\n\n        s->regs[INT_STS] &= ~val;\n\n        break;\n\n    case INT_MASK:\n\n        s->regs[INT_MASK] = val & INT_ALL;\n\n        break;\n\n    case CMDFIFO:\n\n        xadc_cmd  = extract32(val, 26,  4);\n\n        xadc_reg  = extract32(val, 16, 10);\n\n        xadc_data = extract32(val,  0, 16);\n\n\n\n        if (s->regs[MCTL] & MCTL_RESET) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"zynq_xadc: Sending command \"\n\n                          \"while comm channel held in reset: %\" PRIx32 \"\\n\",\n\n                          (uint32_t) val);\n\n            break;\n\n        }\n\n\n\n        if (xadc_reg > ZYNQ_XADC_NUM_ADC_REGS && xadc_cmd != CMD_NOP) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"read/write op to invalid xadc \"\n\n                          \"reg 0x%x\\n\", xadc_reg);\n\n            break;\n\n        }\n\n\n\n        switch (xadc_cmd) {\n\n        case CMD_READ:\n\n            xadc_push_dfifo(s, s->xadc_regs[xadc_reg]);\n\n            break;\n\n        case CMD_WRITE:\n\n            s->xadc_regs[xadc_reg] = xadc_data;\n\n            /* fallthrough */\n\n        case CMD_NOP:\n\n            xadc_push_dfifo(s, 0);\n\n            break;\n\n        }\n\n        break;\n\n    case MCTL:\n\n        s->regs[MCTL] = val & 0x00fffeff;\n\n        break;\n\n    }\n\n    zynq_xadc_update_ints(s);\n\n}\n", "idx": 8923}
{"project": "qemu", "commit_id": "5f8632d3c3d7bc5ef24166ba7cf90fcfb2adbf7d", "target": 1, "func": "static void pc_init_isa(MachineState *machine)\n\n{\n\n    has_pci_info = false;\n\n    has_acpi_build = false;\n\n    smbios_defaults = false;\n\n\n\n\n\n\n    if (!machine->cpu_model) {\n\n        machine->cpu_model = \"486\";\n\n    }\n\n    x86_cpu_compat_disable_kvm_features(FEAT_KVM, KVM_FEATURE_PV_EOI);\n\n    enable_compat_apic_id_mode();\n\n    pc_init1(machine, 0, 1);\n\n}", "idx": 3791}
{"project": "qemu", "commit_id": "c4237dfa635900e4d1cdc6038d5efe3507f45f0c", "target": 1, "func": "static void mirror_read_complete(void *opaque, int ret)\n\n{\n\n    MirrorOp *op = opaque;\n\n    MirrorBlockJob *s = op->s;\n\n    if (ret < 0) {\n\n        BlockDriverState *source = s->common.bs;\n\n        BlockErrorAction action;\n\n\n\n        bdrv_set_dirty(source, op->sector_num, op->nb_sectors);\n\n        action = mirror_error_action(s, true, -ret);\n\n        if (action == BLOCK_ERROR_ACTION_REPORT && s->ret >= 0) {\n\n            s->ret = ret;\n\n        }\n\n\n\n        mirror_iteration_done(op, ret);\n\n        return;\n\n    }\n\n    bdrv_aio_writev(s->target, op->sector_num, &op->qiov, op->nb_sectors,\n\n                    mirror_write_complete, op);\n\n}\n", "idx": 818}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static void term_exit(void)\n\n{\n\n    tcsetattr(0, TCSANOW, &oldtty);\n\n}\n", "idx": 1756}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "vnc_display_setup_auth(VncDisplay *vs,\n\n                       bool password,\n\n                       bool sasl,\n\n                       bool tls,\n\n                       bool x509,\n\n                       bool websocket)\n\n{\n\n    /*\n\n     * We have a choice of 3 authentication options\n\n     *\n\n     *   1. none\n\n     *   2. vnc\n\n     *   3. sasl\n\n     *\n\n     * The channel can be run in 2 modes\n\n     *\n\n     *   1. clear\n\n     *   2. tls\n\n     *\n\n     * And TLS can use 2 types of credentials\n\n     *\n\n     *   1. anon\n\n     *   2. x509\n\n     *\n\n     * We thus have 9 possible logical combinations\n\n     *\n\n     *   1. clear + none\n\n     *   2. clear + vnc\n\n     *   3. clear + sasl\n\n     *   4. tls + anon + none\n\n     *   5. tls + anon + vnc\n\n     *   6. tls + anon + sasl\n\n     *   7. tls + x509 + none\n\n     *   8. tls + x509 + vnc\n\n     *   9. tls + x509 + sasl\n\n     *\n\n     * These need to be mapped into the VNC auth schemes\n\n     * in an appropriate manner. In regular VNC, all the\n\n     * TLS options get mapped into VNC_AUTH_VENCRYPT\n\n     * sub-auth types.\n\n     *\n\n     * In websockets, the https:// protocol already provides\n\n     * TLS support, so there is no need to make use of the\n\n     * VeNCrypt extension. Furthermore, websockets browser\n\n     * clients could not use VeNCrypt even if they wanted to,\n\n     * as they cannot control when the TLS handshake takes\n\n     * place. Thus there is no option but to rely on https://,\n\n     * meaning combinations 4->6 and 7->9 will be mapped to\n\n     * VNC auth schemes in the same way as combos 1->3.\n\n     *\n\n     * Regardless of fact that we have a different mapping to\n\n     * VNC auth mechs for plain VNC vs websockets VNC, the end\n\n     * result has the same security characteristics.\n\n     */\n\n    if (password) {\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (websocket) {\n\n                vs->ws_tls = true;\n\n            }\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n\n            vs->auth = VNC_AUTH_VNC;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vs->ws_auth = VNC_AUTH_VNC;\n\n        } else {\n\n            vs->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    } else if (sasl) {\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (websocket) {\n\n                vs->ws_tls = true;\n\n            }\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n\n            vs->auth = VNC_AUTH_SASL;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vs->ws_auth = VNC_AUTH_SASL;\n\n        } else {\n\n            vs->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    } else {\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (websocket) {\n\n                vs->ws_tls = true;\n\n            }\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n\n            vs->auth = VNC_AUTH_NONE;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vs->ws_auth = VNC_AUTH_NONE;\n\n        } else {\n\n            vs->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    }\n\n}\n", "idx": 954}
{"project": "qemu", "commit_id": "baa61b9870dd7e0bb07e0ae61c6ec805db13f699", "target": 1, "func": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_balloon_device_exit;\n\n    dc->props = virtio_balloon_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->init = virtio_balloon_device_init;\n\n    vdc->get_config = virtio_balloon_get_config;\n\n    vdc->set_config = virtio_balloon_set_config;\n\n    vdc->get_features = virtio_balloon_get_features;\n\n}\n", "idx": 282}
{"project": "qemu", "commit_id": "7f763a5d994bbddb50705d2e50decdf52937521f", "target": 1, "func": "static void ppc_spapr_reset(void)\n\n{\n\n    /* flush out the hash table */\n\n    memset(spapr->htab, 0, spapr->htab_size);\n\n\n\n    qemu_devices_reset();\n\n\n\n    /* Load the fdt */\n\n    spapr_finalize_fdt(spapr, spapr->fdt_addr, spapr->rtas_addr,\n\n                       spapr->rtas_size);\n\n\n\n    /* Set up the entry state */\n\n    first_cpu->gpr[3] = spapr->fdt_addr;\n\n    first_cpu->gpr[5] = 0;\n\n    first_cpu->halted = 0;\n\n    first_cpu->nip = spapr->entry_point;\n\n\n\n}\n", "idx": 5773}
{"project": "qemu", "commit_id": "b196d969efa3987148994f0f8da79a10ebda7641", "target": 1, "func": "static void superio_ioport_writeb(void *opaque, hwaddr addr, uint64_t data,\n\n                                  unsigned size)\n\n{\n\n    int can_write;\n\n    SuperIOConfig *superio_conf = opaque;\n\n\n\n    DPRINTF(\"superio_ioport_writeb  address 0x%x  val 0x%x\\n\", addr, data);\n\n    if (addr == 0x3f0) {\n\n        superio_conf->index = data & 0xff;\n\n    } else {\n\n        /* 0x3f1 */\n\n        switch (superio_conf->index) {\n\n        case 0x00 ... 0xdf:\n\n        case 0xe4:\n\n        case 0xe5:\n\n        case 0xe9 ... 0xed:\n\n        case 0xf3:\n\n        case 0xf5:\n\n        case 0xf7:\n\n        case 0xf9 ... 0xfb:\n\n        case 0xfd ... 0xff:\n\n            can_write = 0;\n\n            break;\n\n        default:\n\n            can_write = 1;\n\n\n\n            if (can_write) {\n\n                switch (superio_conf->index) {\n\n                case 0xe7:\n\n                    if ((data & 0xff) != 0xfe) {\n\n                        DPRINTF(\"chage uart 1 base. unsupported yet\\n\");\n\n                    }\n\n                    break;\n\n                case 0xe8:\n\n                    if ((data & 0xff) != 0xbe) {\n\n                        DPRINTF(\"chage uart 2 base. unsupported yet\\n\");\n\n                    }\n\n                    break;\n\n\n\n                default:\n\n                    superio_conf->config[superio_conf->index] = data & 0xff;\n\n                }\n\n            }\n\n        }\n\n        superio_conf->config[superio_conf->index] = data & 0xff;\n\n    }\n\n}\n", "idx": 176}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void init_pipe_signaling(PCIQXLDevice *d)\n\n{\n\n   if (pipe(d->pipe) < 0) {\n\n       dprint(d, 1, \"%s: pipe creation failed\\n\", __FUNCTION__);\n\n       return;\n\n   }\n\n#ifdef CONFIG_IOTHREAD\n\n   fcntl(d->pipe[0], F_SETFL, O_NONBLOCK);\n\n#else\n\n   fcntl(d->pipe[0], F_SETFL, O_NONBLOCK /* | O_ASYNC */);\n\n#endif\n\n   fcntl(d->pipe[1], F_SETFL, O_NONBLOCK);\n\n   fcntl(d->pipe[0], F_SETOWN, getpid());\n\n\n\n   d->main = pthread_self();\n\n   qemu_set_fd_handler(d->pipe[0], pipe_read, NULL, d);\n\n}\n", "idx": 1354}
{"project": "qemu", "commit_id": "b35278f75450e57c134a153e6da9744c1db8382f", "target": 1, "func": "static int qcow2_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, ret = 0;\n\n    QCowHeader header;\n\n    uint64_t ext_end;\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version < 2 || header.version > 3) {\n\n        report_unsupported(bs, \"QCOW version %d\", header.version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    s->qcow_version = header.version;\n\n\n\n    /* Initialise version 3 header fields */\n\n    if (header.version == 2) {\n\n        header.incompatible_features    = 0;\n\n        header.compatible_features      = 0;\n\n        header.autoclear_features       = 0;\n\n        header.refcount_order           = 4;\n\n        header.header_length            = 72;\n\n    } else {\n\n        be64_to_cpus(&header.incompatible_features);\n\n        be64_to_cpus(&header.compatible_features);\n\n        be64_to_cpus(&header.autoclear_features);\n\n        be32_to_cpus(&header.refcount_order);\n\n        be32_to_cpus(&header.header_length);\n\n    }\n\n\n\n    if (header.header_length > sizeof(header)) {\n\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n\n                         s->unknown_header_fields_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (header.backing_file_offset) {\n\n        ext_end = header.backing_file_offset;\n\n    } else {\n\n        ext_end = 1 << header.cluster_bits;\n\n    }\n\n\n\n    /* Handle feature bits */\n\n    s->incompatible_features    = header.incompatible_features;\n\n    s->compatible_features      = header.compatible_features;\n\n    s->autoclear_features       = header.autoclear_features;\n\n\n\n    if (s->incompatible_features != 0) {\n\n        void *feature_table = NULL;\n\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n\n                              &feature_table);\n\n        report_unsupported_feature(bs, feature_table,\n\n                                   s->incompatible_features);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    /* Check support for various header values */\n\n    if (header.refcount_order != 4) {\n\n        report_unsupported(bs, \"%d bit reference counts\",\n\n                           1 << header.refcount_order);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        bs->encrypted = 1;\n\n    }\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    /* read the level 1 table */\n\n    s->l1_size = header.l1_size;\n\n    s->l1_vm_state_index = size_to_l1(s, header.size);\n\n    /* the L1 table must contain at least enough entries to put\n\n       header.size bytes */\n\n    if (s->l1_size < s->l1_vm_state_index) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    if (s->l1_size > 0) {\n\n        s->l1_table = g_malloc0(\n\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n                         s->l1_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < s->l1_size; i++) {\n\n            be64_to_cpus(&s->l1_table[i]);\n\n        }\n\n    }\n\n\n\n    /* alloc L2 table/refcount block cache */\n\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    /* one more sector for decompressed data alignment */\n\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n\n                                  + 512);\n\n    s->cluster_cache_offset = -1;\n\n    s->flags = flags;\n\n\n\n    ret = qcow2_refcount_init(bs);\n\n    if (ret != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    QLIST_INIT(&s->cluster_allocs);\n\n\n\n    /* read qcow2 extensions */\n\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL)) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023) {\n\n            len = 1023;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                         bs->backing_file, len);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n\n\n    ret = qcow2_read_snapshots(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Clear unknown autoclear feature bits */\n\n    if (!bs->read_only && s->autoclear_features != 0) {\n\n        s->autoclear_features = 0;\n\n        ret = qcow2_update_header(bs);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Initialise locks */\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n        BdrvCheckResult result = {0};\n\n        qcow2_check_refcounts(bs, &result);\n\n    }\n\n#endif\n\n    return ret;\n\n\n\n fail:\n\n    g_free(s->unknown_header_fields);\n\n    cleanup_unknown_header_ext(bs);\n\n    qcow2_free_snapshots(bs);\n\n    qcow2_refcount_close(bs);\n\n    g_free(s->l1_table);\n\n    if (s->l2_table_cache) {\n\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n\n    }\n\n    g_free(s->cluster_cache);\n\n    qemu_vfree(s->cluster_data);\n\n    return ret;\n\n}\n", "idx": 5492}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "static void monitor_qmp_event(void *opaque, int event)\n\n{\n\n    QObject *data;\n\n    Monitor *mon = opaque;\n\n\n\n    switch (event) {\n\n    case CHR_EVENT_OPENED:\n\n        mon->qmp.in_command_mode = false;\n\n        data = get_qmp_greeting();\n\n        monitor_json_emitter(mon, data);\n\n        qobject_decref(data);\n\n        mon_refcount++;\n\n        break;\n\n    case CHR_EVENT_CLOSED:\n\n        json_message_parser_destroy(&mon->qmp.parser);\n\n        json_message_parser_init(&mon->qmp.parser, handle_qmp_command);\n\n        mon_refcount--;\n\n        monitor_fdsets_cleanup();\n\n        break;\n\n    }\n\n}\n", "idx": 755}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int unused, int size)\n\n{\n\n    if (is_exec)\n\n        helper_raise_exception(EXCP_IBE);\n\n    else\n\n        helper_raise_exception(EXCP_DBE);\n\n}\n", "idx": 11777}
{"project": "qemu", "commit_id": "1d06cb7ab93f879ac25c9f5ef1d1ac8d97a42dfc", "target": 1, "func": "static sd_rsp_type_t sd_app_command(SDState *sd,\n\n                                    SDRequest req)\n\n{\n\n    DPRINTF(\"ACMD%d 0x%08x\\n\", req.cmd, req.arg);\n\n    switch (req.cmd) {\n\n    case 6:\t/* ACMD6:  SET_BUS_WIDTH */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->sd_status[0] &= 0x3f;\n\n            sd->sd_status[0] |= (req.arg & 0x03) << 6;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            *(uint32_t *) sd->data = sd->blk_written;\n\n\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 23:\t/* ACMD23: SET_WR_BLK_ERASE_COUNT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 41:\t/* ACMD41: SD_APP_OP_COND */\n\n        if (sd->spi) {\n\n            /* SEND_OP_CMD */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1;\n\n        }\n\n        switch (sd->state) {\n\n        case sd_idle_state:\n\n            /* We accept any voltage.  10000 V is nothing.  */\n\n            if (req.arg)\n\n                sd->state = sd_ready_state;\n\n\n\n            return sd_r3;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 42:\t/* ACMD42: SET_CLR_CARD_DETECT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Bringing in the 50KOhm pull-up resistor... Done.  */\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* Fall back to standard commands.  */\n\n        sd->card_status &= ~APP_CMD;\n\n        return sd_normal_command(sd, req);\n\n    }\n\n\n\n    fprintf(stderr, \"SD: ACMD%i in a wrong state\\n\", req.cmd);\n\n    return sd_illegal;\n\n}\n", "idx": 11814}
{"project": "qemu", "commit_id": "76e050c2e62995f1d6905e28674dea3a7fcff1a5", "target": 1, "func": "void op_subo (void)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = T0;\n\n    T0 = (int32_t)T0 - (int32_t)T1;\n\n    if (!((T0 >> 31) ^ (T1 >> 31) ^ (tmp >> 31))) {\n\n        CALL_FROM_TB1(do_raise_exception_direct, EXCP_OVERFLOW);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 3555}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_cpu_kick_self(void)\n\n{\n\n#ifndef _WIN32\n\n    assert(cpu_single_env);\n\n\n\n    raise(SIG_IPI);\n\n#else\n\n    abort();\n\n#endif\n\n}\n", "idx": 10915}
{"project": "qemu", "commit_id": "d5a8ee60a0fbc20a2c2d02f3bda1bb1bd365f1ee", "target": 1, "func": "BlockDeviceInfo *bdrv_block_device_info(BlockDriverState *bs)\n\n{\n\n    BlockDeviceInfo *info = g_malloc0(sizeof(*info));\n\n\n\n    info->file                   = g_strdup(bs->filename);\n\n    info->ro                     = bs->read_only;\n\n    info->drv                    = g_strdup(bs->drv->format_name);\n\n    info->encrypted              = bs->encrypted;\n\n    info->encryption_key_missing = bdrv_key_required(bs);\n\n\n\n    info->cache = g_new(BlockdevCacheInfo, 1);\n\n    *info->cache = (BlockdevCacheInfo) {\n\n        .writeback      = bdrv_enable_write_cache(bs),\n\n        .direct         = !!(bs->open_flags & BDRV_O_NOCACHE),\n\n        .no_flush       = !!(bs->open_flags & BDRV_O_NO_FLUSH),\n\n    };\n\n\n\n    if (bs->node_name[0]) {\n\n        info->has_node_name = true;\n\n        info->node_name = g_strdup(bs->node_name);\n\n    }\n\n\n\n    if (bs->backing_file[0]) {\n\n        info->has_backing_file = true;\n\n        info->backing_file = g_strdup(bs->backing_file);\n\n    }\n\n\n\n    info->backing_file_depth = bdrv_get_backing_file_depth(bs);\n\n    info->detect_zeroes = bs->detect_zeroes;\n\n\n\n    if (bs->io_limits_enabled) {\n\n        ThrottleConfig cfg;\n\n        throttle_get_config(&bs->throttle_state, &cfg);\n\n        info->bps     = cfg.buckets[THROTTLE_BPS_TOTAL].avg;\n\n        info->bps_rd  = cfg.buckets[THROTTLE_BPS_READ].avg;\n\n        info->bps_wr  = cfg.buckets[THROTTLE_BPS_WRITE].avg;\n\n\n\n        info->iops    = cfg.buckets[THROTTLE_OPS_TOTAL].avg;\n\n        info->iops_rd = cfg.buckets[THROTTLE_OPS_READ].avg;\n\n        info->iops_wr = cfg.buckets[THROTTLE_OPS_WRITE].avg;\n\n\n\n        info->has_bps_max     = cfg.buckets[THROTTLE_BPS_TOTAL].max;\n\n        info->bps_max         = cfg.buckets[THROTTLE_BPS_TOTAL].max;\n\n        info->has_bps_rd_max  = cfg.buckets[THROTTLE_BPS_READ].max;\n\n        info->bps_rd_max      = cfg.buckets[THROTTLE_BPS_READ].max;\n\n        info->has_bps_wr_max  = cfg.buckets[THROTTLE_BPS_WRITE].max;\n\n        info->bps_wr_max      = cfg.buckets[THROTTLE_BPS_WRITE].max;\n\n\n\n        info->has_iops_max    = cfg.buckets[THROTTLE_OPS_TOTAL].max;\n\n        info->iops_max        = cfg.buckets[THROTTLE_OPS_TOTAL].max;\n\n        info->has_iops_rd_max = cfg.buckets[THROTTLE_OPS_READ].max;\n\n        info->iops_rd_max     = cfg.buckets[THROTTLE_OPS_READ].max;\n\n        info->has_iops_wr_max = cfg.buckets[THROTTLE_OPS_WRITE].max;\n\n        info->iops_wr_max     = cfg.buckets[THROTTLE_OPS_WRITE].max;\n\n\n\n        info->has_iops_size = cfg.op_size;\n\n        info->iops_size = cfg.op_size;\n\n    }\n\n\n\n    info->write_threshold = bdrv_write_threshold_get(bs);\n\n\n\n    return info;\n\n}\n", "idx": 2322}
{"project": "qemu", "commit_id": "630530a6529bc3da9ab8aead7053dc753cb9ac77", "target": 1, "func": "static int get_whole_cluster(BlockDriverState *bs, uint64_t cluster_offset,\n\n                             uint64_t offset, int allocate)\n\n{\n\n    uint64_t parent_cluster_offset;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    uint8_t  whole_grain[s->cluster_sectors*512];        // 128 sectors * 512 bytes each = grain size 64KB\n\n\n\n    // we will be here if it's first write on non-exist grain(cluster).\n\n    // try to read from parent image, if exist\n\n    if (s->hd->backing_hd) {\n\n        BDRVVmdkState *ps = s->hd->backing_hd->opaque;\n\n\n\n        if (!vmdk_is_cid_valid(bs))\n\n            return -1;\n\n        parent_cluster_offset = get_cluster_offset(s->hd->backing_hd, offset, allocate);\n\n        if (bdrv_pread(ps->hd, parent_cluster_offset, whole_grain, ps->cluster_sectors*512) != \n\n                                                                            ps->cluster_sectors*512)\n\n            return -1;\n\n\n\n        if (bdrv_pwrite(s->hd, cluster_offset << 9, whole_grain, sizeof(whole_grain)) != \n\n                                                                            sizeof(whole_grain))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6912}
{"project": "qemu", "commit_id": "76e050c2e62995f1d6905e28674dea3a7fcff1a5", "target": 1, "func": "void op_subo (void)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = T0;\n\n    T0 = (int32_t)T0 - (int32_t)T1;\n\n    if (!((T0 >> 31) ^ (T1 >> 31) ^ (tmp >> 31))) {\n\n        CALL_FROM_TB1(do_raise_exception_direct, EXCP_OVERFLOW);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 3555}
{"project": "qemu", "commit_id": "6787d27b04a79524c547c60701400eb0418e3533", "target": 1, "func": "static target_ulong h_client_architecture_support(PowerPCCPU *cpu_,\n\n                                                  sPAPRMachineState *spapr,\n\n                                                  target_ulong opcode,\n\n                                                  target_ulong *args)\n\n{\n\n    target_ulong list = ppc64_phys_to_real(args[0]);\n\n    target_ulong ov_table;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu_);\n\n    CPUState *cs;\n\n    bool cpu_match = false, cpu_update = true;\n\n    unsigned old_cpu_version = cpu_->cpu_version;\n\n    unsigned compat_lvl = 0, cpu_version = 0;\n\n    unsigned max_lvl = get_compat_level(cpu_->max_compat);\n\n    int counter;\n\n    sPAPROptionVector *ov5_guest;\n\n\n\n    /* Parse PVR list */\n\n    for (counter = 0; counter < 512; ++counter) {\n\n        uint32_t pvr, pvr_mask;\n\n\n\n        pvr_mask = ldl_be_phys(&address_space_memory, list);\n\n        list += 4;\n\n        pvr = ldl_be_phys(&address_space_memory, list);\n\n        list += 4;\n\n\n\n        trace_spapr_cas_pvr_try(pvr);\n\n        if (!max_lvl &&\n\n            ((cpu_->env.spr[SPR_PVR] & pvr_mask) == (pvr & pvr_mask))) {\n\n            cpu_match = true;\n\n            cpu_version = 0;\n\n        } else if (pvr == cpu_->cpu_version) {\n\n            cpu_match = true;\n\n            cpu_version = cpu_->cpu_version;\n\n        } else if (!cpu_match) {\n\n            cas_handle_compat_cpu(pcc, pvr, max_lvl, &compat_lvl, &cpu_version);\n\n        }\n\n        /* Terminator record */\n\n        if (~pvr_mask & pvr) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Parsing finished */\n\n    trace_spapr_cas_pvr(cpu_->cpu_version, cpu_match,\n\n                        cpu_version, pcc->pcr_mask);\n\n\n\n    /* Update CPUs */\n\n    if (old_cpu_version != cpu_version) {\n\n        CPU_FOREACH(cs) {\n\n            SetCompatState s = {\n\n                .cpu_version = cpu_version,\n\n                .err = NULL,\n\n            };\n\n\n\n            run_on_cpu(cs, do_set_compat, &s);\n\n\n\n            if (s.err) {\n\n                error_report_err(s.err);\n\n                return H_HARDWARE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!cpu_version) {\n\n        cpu_update = false;\n\n    }\n\n\n\n    /* For the future use: here @ov_table points to the first option vector */\n\n    ov_table = list;\n\n\n\n    ov5_guest = spapr_ovec_parse_vector(ov_table, 5);\n\n\n\n    /* NOTE: there are actually a number of ov5 bits where input from the\n\n     * guest is always zero, and the platform/QEMU enables them independently\n\n     * of guest input. To model these properly we'd want some sort of mask,\n\n     * but since they only currently apply to memory migration as defined\n\n     * by LoPAPR 1.1, 14.5.4.8, which QEMU doesn't implement, we don't need\n\n     * to worry about this.\n\n     */\n\n    spapr_ovec_intersect(spapr->ov5_cas, spapr->ov5, ov5_guest);\n\n    spapr_ovec_cleanup(ov5_guest);\n\n\n\n    if (spapr_h_cas_compose_response(spapr, args[1], args[2],\n\n                                     cpu_update)) {\n\n        qemu_system_reset_request();\n\n    }\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 2261}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "int arm_set_cpu_off(uint64_t cpuid)\n\n{\n\n    CPUState *target_cpu_state;\n\n    ARMCPU *target_cpu;\n\n\n\n    DPRINTF(\"cpu %\" PRId64 \"\\n\", cpuid);\n\n\n\n    /* change to the cpu we are powering up */\n\n    target_cpu_state = arm_get_cpu_by_id(cpuid);\n\n    if (!target_cpu_state) {\n\n        return QEMU_ARM_POWERCTL_INVALID_PARAM;\n\n    }\n\n    target_cpu = ARM_CPU(target_cpu_state);\n\n    if (target_cpu->powered_off) {\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"[ARM]%s: CPU %\" PRId64 \" is already off\\n\",\n\n                      __func__, cpuid);\n\n        return QEMU_ARM_POWERCTL_IS_OFF;\n\n    }\n\n\n\n    target_cpu->powered_off = true;\n\n    target_cpu_state->halted = 1;\n\n    target_cpu_state->exception_index = EXCP_HLT;\n\n    cpu_loop_exit(target_cpu_state);\n\n    /* notreached */\n\n\n\n    return QEMU_ARM_POWERCTL_RET_SUCCESS;\n\n}\n", "idx": 1672}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void coroutine_fn nest(void *opaque)\n\n{\n\n    NestData *nd = opaque;\n\n\n\n    nd->n_enter++;\n\n\n\n    if (nd->n_enter < nd->max) {\n\n        Coroutine *child;\n\n\n\n        child = qemu_coroutine_create(nest);\n\n        qemu_coroutine_enter(child, nd);\n\n    }\n\n\n\n    nd->n_return++;\n\n}\n", "idx": 54}
{"project": "qemu", "commit_id": "702dbcc274e2ca43be20ba64c758c0ca57dab91d", "target": 1, "func": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n\n\n\n    g_free(s->tag);\n\n    g_free(s->ctx.fs_root);\n", "idx": 1828}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 12130}
{"project": "qemu", "commit_id": "81b23ef82cd1be29ca3d69ab7e98b5b5e55926ce", "target": 1, "func": "static int xen_pt_cmd_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint16_t *value, uint16_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint16_t valid_emu_mask = 0;\n\n    uint16_t emu_mask = reg->emu_mask;\n\n\n\n    if (s->is_virtfn) {\n\n        emu_mask |= PCI_COMMAND_MEMORY;\n\n    }\n\n\n\n    /* emulate word register */\n\n    valid_emu_mask = emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 5425}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 7684}
{"project": "qemu", "commit_id": "491d68d9382dbb588f2ff5132ee3d87ce2f1b230", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n\n                               unsigned int epid)\n\n{\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_disable(slotid, epid);\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    assert(epid >= 1 && epid <= 31);\n\n\n\n    slot = &xhci->slots[slotid-1];\n\n\n\n    if (!slot->eps[epid-1]) {\n\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n\n        return CC_SUCCESS;\n\n    }\n\n\n\n    xhci_ep_nuke_xfers(xhci, slotid, epid, 0);\n\n\n\n    epctx = slot->eps[epid-1];\n\n\n\n    if (epctx->nr_pstreams) {\n\n        xhci_free_streams(epctx);\n\n    }\n\n\n\n    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) {\n\n        usb_packet_cleanup(&epctx->transfers[i].packet);\n\n    }\n\n\n\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n\n\n\n    timer_free(epctx->kick_timer);\n\n    g_free(epctx);\n\n    slot->eps[epid-1] = NULL;\n\n\n\n    return CC_SUCCESS;\n\n}\n", "idx": 2748}
{"project": "qemu", "commit_id": "a5f533909e746ca6e534b232fb42c9c6fd81b468", "target": 1, "func": "static void gen_branch(DisasContext *ctx, int insn_bytes)\n\n{\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;\n\n        /* Branches completion */\n\n        ctx->hflags &= ~MIPS_HFLAG_BMASK;\n\n        ctx->bstate = BS_BRANCH;\n\n        save_cpu_state(ctx, 0);\n\n        /* FIXME: Need to clear can_do_io.  */\n\n        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {\n\n        case MIPS_HFLAG_FBNSLOT:\n\n            MIPS_DEBUG(\"forbidden slot\");\n\n            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);\n\n            break;\n\n        case MIPS_HFLAG_B:\n\n            /* unconditional branch */\n\n            MIPS_DEBUG(\"unconditional branch\");\n\n            if (proc_hflags & MIPS_HFLAG_BX) {\n\n                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);\n\n            }\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BL:\n\n            /* blikely taken case */\n\n            MIPS_DEBUG(\"blikely branch taken\");\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                TCGLabel *l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 10476}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void sysbus_ahci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = sysbus_ahci_realize;\n\n    dc->vmsd = &vmstate_sysbus_ahci;\n\n    dc->props = sysbus_ahci_properties;\n\n    dc->reset = sysbus_ahci_reset;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n\n\n\n\n\n}", "idx": 3924}
{"project": "qemu", "commit_id": "b027a538c6790bcfc93ef7f4819fe3e581445959", "target": 1, "func": "static int oss_ctl_out (HWVoiceOut *hw, int cmd, ...)\n\n{\n\n    int trig;\n\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n\n\n\n    switch (cmd) {\n\n    case VOICE_ENABLE:\n\n        {\n\n            va_list ap;\n\n            int poll_mode;\n\n\n\n            va_start (ap, cmd);\n\n            poll_mode = va_arg (ap, int);\n\n            va_end (ap);\n\n\n\n            ldebug (\"enabling voice\\n\");\n\n            if (poll_mode && oss_poll_out (hw)) {\n\n                poll_mode = 0;\n\n            }\n\n            hw->poll_mode = poll_mode;\n\n\n\n            if (!oss->mmapped) {\n\n                return 0;\n\n            }\n\n\n\n            audio_pcm_info_clear_buf (&hw->info, oss->pcm_buf, hw->samples);\n\n            trig = PCM_ENABLE_OUTPUT;\n\n            if (ioctl (oss->fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                oss_logerr (\n\n                    errno,\n\n                    \"SNDCTL_DSP_SETTRIGGER PCM_ENABLE_OUTPUT failed\\n\"\n\n                    );\n\n                return -1;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case VOICE_DISABLE:\n\n        if (hw->poll_mode) {\n\n            qemu_set_fd_handler (oss->fd, NULL, NULL, NULL);\n\n            hw->poll_mode = 0;\n\n        }\n\n\n\n        if (!oss->mmapped) {\n\n            return 0;\n\n        }\n\n\n\n        ldebug (\"disabling voice\\n\");\n\n        trig = 0;\n\n        if (ioctl (oss->fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n            oss_logerr (errno, \"SNDCTL_DSP_SETTRIGGER 0 failed\\n\");\n\n            return -1;\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6062}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void qmp_memchar_write(const char *device, int64_t size,\n\n                       const char *data, bool has_format,\n\n                       enum DataFormat format,\n\n                       Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    guchar *write_data;\n\n    int ret;\n\n    gsize write_count;\n\n\n\n    chr = qemu_chr_find(device);\n\n    if (!chr) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (qemu_is_chr(chr, \"memory\")) {\n\n        error_setg(errp,\"%s is not memory char device\", device);\n\n        return;\n\n    }\n\n\n\n    write_count = (gsize)size;\n\n\n\n    if (has_format && (format == DATA_FORMAT_BASE64)) {\n\n        write_data = g_base64_decode(data, &write_count);\n\n    } else {\n\n        write_data = (uint8_t *)data;\n\n    }\n\n\n\n    ret = cirmem_chr_write(chr, write_data, write_count);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to write to device %s\", device);\n\n        return;\n\n    }\n\n}\n", "idx": 5809}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "int vnc_tls_set_x509_creds_dir(VncDisplay *vd,\n\n                               const char *certdir)\n\n{\n\n    if (vnc_set_x509_credential(vd, certdir, X509_CA_CERT_FILE, &vd->tls.x509cacert, 0) < 0)\n\n        goto cleanup;\n\n    if (vnc_set_x509_credential(vd, certdir, X509_CA_CRL_FILE, &vd->tls.x509cacrl, 1) < 0)\n\n        goto cleanup;\n\n    if (vnc_set_x509_credential(vd, certdir, X509_SERVER_CERT_FILE, &vd->tls.x509cert, 0) < 0)\n\n        goto cleanup;\n\n    if (vnc_set_x509_credential(vd, certdir, X509_SERVER_KEY_FILE, &vd->tls.x509key, 0) < 0)\n\n        goto cleanup;\n\n\n\n    return 0;\n\n\n\n cleanup:\n\n    g_free(vd->tls.x509cacert);\n\n    g_free(vd->tls.x509cacrl);\n\n    g_free(vd->tls.x509cert);\n\n    g_free(vd->tls.x509key);\n\n    vd->tls.x509cacert = vd->tls.x509cacrl = vd->tls.x509cert = vd->tls.x509key = NULL;\n\n    return -1;\n\n}\n", "idx": 3600}
{"project": "qemu", "commit_id": "876d516311c1538a7d29f2abec48b7cda0645eea", "target": 1, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl)\n\n{\n\n    /* vga mode framebuffer / primary surface (bar 0, first part) */\n\n    if (qxl->vgamem_size_mb < 8) {\n\n        qxl->vgamem_size_mb = 8;\n\n\n\n\n\n\n\n\n    qxl->vgamem_size = qxl->vgamem_size_mb * 1024 * 1024;\n\n\n\n    /* vga ram (bar 0, total) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n\n    if (qxl->vga.vram_size < qxl->vgamem_size * 2) {\n\n        qxl->vga.vram_size = qxl->vgamem_size * 2;\n\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n\n    qxl->vgamem_size = msb_mask(qxl->vgamem_size * 2 - 1);\n\n    qxl->vga.vram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n    qxl->vram32_size = msb_mask(qxl->vram32_size * 2 - 1);\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n", "idx": 4850}
{"project": "qemu", "commit_id": "1104d83c726d2b20f9cec7b99ab3570a2fdbd46d", "target": 1, "func": "int nbd_client_co_pwritev(BlockDriverState *bs, uint64_t offset,\n\n                          uint64_t bytes, QEMUIOVector *qiov, int flags)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_WRITE,\n\n        .from = offset,\n\n        .len = bytes,\n\n    };\n\n\n\n\n    if (flags & BDRV_REQ_FUA) {\n\n        assert(client->info.flags & NBD_FLAG_SEND_FUA);\n\n        request.flags |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    assert(bytes <= NBD_MAX_BUFFER_SIZE);\n\n\n\n    return nbd_co_request(bs, &request, qiov);\n\n}", "idx": 3021}
{"project": "qemu", "commit_id": "ed78cda3de92056737364ab3cb748b16f5f17dea", "target": 1, "func": "int bdrv_flush_all(void)\n\n{\n\n    BlockDriverState *bs;\n\n    int result = 0;\n\n\n\n    QTAILQ_FOREACH(bs, &bdrv_states, device_list) {\n\n        int ret = bdrv_flush(bs);\n\n        if (ret < 0 && !result) {\n\n            result = ret;\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 1191}
{"project": "qemu", "commit_id": "9a94ee5bb15793ef69692998ef57794a33074134", "target": 1, "func": "static void rtas_stop_self(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n\n    cs->halted = 1;\n\n    qemu_cpu_kick(cs);\n\n    /*\n\n     * While stopping a CPU, the guest calls H_CPPR which\n\n     * effectively disables interrupts on XICS level.\n\n     * However decrementer interrupts in TCG can still\n\n     * wake the CPU up so here we disable interrupts in MSR\n\n     * as well.\n\n     * As rtas_start_cpu() resets the whole MSR anyway, there is\n\n     * no need to bother with specific bits, we just clear it.\n\n     */\n\n    env->msr = 0;\n\n\n\n    /* Disable Power-saving mode Exit Cause exceptions for the CPU.\n\n     * This could deliver an interrupt on a dying CPU and crash the\n\n     * guest */\n\n    env->spr[SPR_LPCR] &= ~pcc->lpcr_pm;\n\n}", "idx": 11033}
{"project": "qemu", "commit_id": "d8fd2954996255ba6ad610917e7849832d0120b7", "target": 1, "func": "static void do_interrupt_v7m(CPUARMState *env)\n\n{\n\n    uint32_t xpsr = xpsr_read(env);\n\n    uint32_t lr;\n\n    uint32_t addr;\n\n\n\n    lr = 0xfffffff1;\n\n    if (env->v7m.current_sp)\n\n        lr |= 4;\n\n    if (env->v7m.exception == 0)\n\n        lr |= 8;\n\n\n\n    /* For exceptions we just mark as pending on the NVIC, and let that\n\n       handle it.  */\n\n    /* TODO: Need to escalate if the current priority is higher than the\n\n       one we're raising.  */\n\n    switch (env->exception_index) {\n\n    case EXCP_UDEF:\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE);\n\n        return;\n\n    case EXCP_SWI:\n\n        env->regs[15] += 2;\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SVC);\n\n        return;\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_MEM);\n\n        return;\n\n    case EXCP_BKPT:\n\n        if (semihosting_enabled) {\n\n            int nr;\n\n            nr = lduw_code(env->regs[15]) & 0xff;\n\n            if (nr == 0xab) {\n\n                env->regs[15] += 2;\n\n                env->regs[0] = do_arm_semihosting(env);\n\n                return;\n\n            }\n\n        }\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_DEBUG);\n\n        return;\n\n    case EXCP_IRQ:\n\n        env->v7m.exception = armv7m_nvic_acknowledge_irq(env->nvic);\n\n        break;\n\n    case EXCP_EXCEPTION_EXIT:\n\n        do_v7m_exception_exit(env);\n\n        return;\n\n    default:\n\n        cpu_abort(env, \"Unhandled exception 0x%x\\n\", env->exception_index);\n\n        return; /* Never happens.  Keep compiler happy.  */\n\n    }\n\n\n\n    /* Align stack pointer.  */\n\n    /* ??? Should only do this if Configuration Control Register\n\n       STACKALIGN bit is set.  */\n\n    if (env->regs[13] & 4) {\n\n        env->regs[13] -= 4;\n\n        xpsr |= 0x200;\n\n    }\n\n    /* Switch to the handler mode.  */\n\n    v7m_push(env, xpsr);\n\n    v7m_push(env, env->regs[15]);\n\n    v7m_push(env, env->regs[14]);\n\n    v7m_push(env, env->regs[12]);\n\n    v7m_push(env, env->regs[3]);\n\n    v7m_push(env, env->regs[2]);\n\n    v7m_push(env, env->regs[1]);\n\n    v7m_push(env, env->regs[0]);\n\n    switch_v7m_sp(env, 0);\n\n    /* Clear IT bits */\n\n    env->condexec_bits = 0;\n\n    env->regs[14] = lr;\n\n    addr = ldl_phys(env->v7m.vecbase + env->v7m.exception * 4);\n\n    env->regs[15] = addr & 0xfffffffe;\n\n    env->thumb = addr & 1;\n\n}\n", "idx": 11182}
{"project": "qemu", "commit_id": "d09acb9b5ef0bb4fa94d3d459919a6ebaf8804bc", "target": 1, "func": "static char *read_splashfile(char *filename, int *file_sizep, int *file_typep)\n\n{\n\n    GError *err = NULL;\n\n    gboolean res;\n\n    gchar *content;\n\n    int file_type = -1;\n\n    unsigned int filehead = 0;\n\n    int bmp_bpp;\n\n\n\n    res = g_file_get_contents(filename, &content, (gsize *)file_sizep, &err);\n\n    if (res == FALSE) {\n\n        error_report(\"failed to read splash file '%s'\", filename);\n\n        g_error_free(err);\n\n        return NULL;\n\n    }\n\n\n\n    /* check file size */\n\n    if (*file_sizep < 30) {\n\n        goto error;\n\n    }\n\n\n\n    /* check magic ID */\n\n    filehead = ((content[0] & 0xff) + (content[1] << 8)) & 0xffff;\n\n    if (filehead == 0xd8ff) {\n\n        file_type = JPG_FILE;\n\n    } else if (filehead == 0x4d42) {\n\n        file_type = BMP_FILE;\n\n    } else {\n\n        goto error;\n\n    }\n\n\n\n    /* check BMP bpp */\n\n    if (file_type == BMP_FILE) {\n\n        bmp_bpp = (content[28] + (content[29] << 8)) & 0xffff;\n\n        if (bmp_bpp != 24) {\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    /* return values */\n\n    *file_typep = file_type;\n\n\n\n    return content;\n\n\n\nerror:\n\n    error_report(\"splash file '%s' format not recognized; must be JPEG \"\n\n                 \"or 24 bit BMP\", filename);\n\n    g_free(content);\n\n    return NULL;\n\n}\n", "idx": 1783}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUSizedBuffer *qsb_clone(const QEMUSizedBuffer *qsb)\n\n{\n\n    QEMUSizedBuffer *out = qsb_create(NULL, qsb_get_length(qsb));\n\n    size_t i;\n\n    ssize_t res;\n\n    off_t pos = 0;\n\n\n\n    if (!out) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < qsb->n_iov; i++) {\n\n        res =  qsb_write_at(out, qsb->iov[i].iov_base,\n\n                            pos, qsb->iov[i].iov_len);\n\n        if (res < 0) {\n\n            qsb_free(out);\n\n            return NULL;\n\n        }\n\n        pos += res;\n\n    }\n\n\n\n    return out;\n\n}\n", "idx": 2128}
{"project": "qemu", "commit_id": "b41d320fef705289d2b73f4949731eb2e189161d", "target": 1, "func": "static void spapr_reset_htab(sPAPRMachineState *spapr)\n\n{\n\n    long shift;\n\n    int index;\n\n\n\n    shift = kvmppc_reset_htab(spapr->htab_shift);\n\n    if (shift > 0) {\n\n        if (shift != spapr->htab_shift) {\n\n            error_setg(&error_abort, \"Requested HTAB allocation failed during reset\");\n\n        }\n\n\n\n        /* Tell readers to update their file descriptor */\n\n        if (spapr->htab_fd >= 0) {\n\n            spapr->htab_fd_stale = true;\n\n        }\n\n    } else {\n\n        memset(spapr->htab, 0, HTAB_SIZE(spapr));\n\n\n\n        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n\n            DIRTY_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n    }\n\n\n\n    /* Update the RMA size if necessary */\n\n    if (spapr->vrma_adjust) {\n\n        spapr->rma_size = kvmppc_rma_size(spapr_node0_size(),\n\n                                          spapr->htab_shift);\n\n    }\n\n}\n", "idx": 10703}
{"project": "qemu", "commit_id": "b0b1d69079fcb9453f45aade9e9f6b71422147b0", "target": 1, "func": "int kvm_arch_debug(struct kvm_debug_exit_arch *arch_info)\n\n{\n\n    int handle = 0;\n\n    int n;\n\n\n\n    if (arch_info->exception == 1) {\n\n        if (arch_info->dr6 & (1 << 14)) {\n\n            if (cpu_single_env->singlestep_enabled)\n\n                handle = 1;\n\n        } else {\n\n            for (n = 0; n < 4; n++)\n\n                if (arch_info->dr6 & (1 << n))\n\n                    switch ((arch_info->dr7 >> (16 + n*4)) & 0x3) {\n\n                    case 0x0:\n\n                        handle = 1;\n\n                        break;\n\n                    case 0x1:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_WRITE;\n\n                        break;\n\n                    case 0x3:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_ACCESS;\n\n                        break;\n\n                    }\n\n        }\n\n    } else if (kvm_find_sw_breakpoint(cpu_single_env, arch_info->pc))\n\n        handle = 1;\n\n\n\n    if (!handle)\n\n        kvm_update_guest_debug(cpu_single_env,\n\n                        (arch_info->exception == 1) ?\n\n                        KVM_GUESTDBG_INJECT_DB : KVM_GUESTDBG_INJECT_BP);\n\n\n\n    return handle;\n\n}\n", "idx": 6280}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_buffer_async(QEMUFile *f, const uint8_t *buf, int size)\n\n{\n\n    if (!f->ops->writev_buffer) {\n\n        qemu_put_buffer(f, buf, size);\n\n        return;\n\n    }\n\n\n\n    if (f->last_error) {\n\n        return;\n\n    }\n\n\n\n    f->bytes_xfer += size;\n\n    add_to_iovec(f, buf, size);\n\n}\n", "idx": 9797}
{"project": "qemu", "commit_id": "b7fcff01790d25f48d81ef6c8c3399577096a555", "target": 1, "func": "static void test_identify(void)\n\n{\n\n    uint8_t data;\n\n    uint16_t buf[256];\n\n    int i;\n\n    int ret;\n\n\n\n    ide_test_start(\n\n        \"-vnc none \"\n\n        \"-drive file=%s,if=ide,serial=%s,cache=writeback \"\n\n        \"-global ide-hd.ver=%s\",\n\n        tmp_path, \"testdisk\", \"version\");\n\n\n\n    /* IDENTIFY command on device 0*/\n\n    outb(IDE_BASE + reg_device, 0);\n\n    outb(IDE_BASE + reg_command, CMD_IDENTIFY);\n\n\n\n    /* Read in the IDENTIFY buffer and check registers */\n\n    data = inb(IDE_BASE + reg_device);\n\n    g_assert_cmpint(data & DEV, ==, 0);\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        data = inb(IDE_BASE + reg_status);\n\n        assert_bit_set(data, DRDY | DRQ);\n\n        assert_bit_clear(data, BSY | DF | ERR);\n\n\n\n        ((uint16_t*) buf)[i] = inw(IDE_BASE + reg_data);\n\n    }\n\n\n\n    data = inb(IDE_BASE + reg_status);\n\n    assert_bit_set(data, DRDY);\n\n    assert_bit_clear(data, BSY | DF | ERR | DRQ);\n\n\n\n    /* Check serial number/version in the buffer */\n\n    string_cpu_to_be16(&buf[10], 20);\n\n    ret = memcmp(&buf[10], \"testdisk            \", 20);\n\n    g_assert(ret == 0);\n\n\n\n    string_cpu_to_be16(&buf[23], 8);\n\n    ret = memcmp(&buf[23], \"version \", 8);\n\n    g_assert(ret == 0);\n\n\n\n    /* Write cache enabled bit */\n\n    assert_bit_set(buf[85], 0x20);\n\n\n\n    ide_test_quit();\n\n}\n", "idx": 4491}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_test_cc(int cc, int label)\n\n{\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n    int inv;\n\n\n\n    switch (cc) {\n\n    case 0: /* eq: Z */\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        break;\n\n    case 1: /* ne: !Z */\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, label);\n\n        break;\n\n    case 2: /* cs: C */\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, label);\n\n        break;\n\n    case 3: /* cc: !C */\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        break;\n\n    case 4: /* mi: N */\n\n        tmp = load_cpu_field(NF);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    case 5: /* pl: !N */\n\n        tmp = load_cpu_field(NF);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        break;\n\n    case 6: /* vs: V */\n\n        tmp = load_cpu_field(VF);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    case 7: /* vc: !V */\n\n        tmp = load_cpu_field(VF);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        break;\n\n    case 8: /* hi: C && !Z */\n\n        inv = gen_new_label();\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, inv);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, label);\n\n        gen_set_label(inv);\n\n        break;\n\n    case 9: /* ls: !C || Z */\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        break;\n\n    case 10: /* ge: N == V -> N ^ V == 0 */\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        break;\n\n    case 11: /* lt: N != V -> N ^ V != 0 */\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    case 12: /* gt: !Z && N == V */\n\n        inv = gen_new_label();\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, inv);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        gen_set_label(inv);\n\n        break;\n\n    case 13: /* le: Z || N != V */\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"Bad condition code 0x%x\\n\", cc);\n\n        abort();\n\n    }\n\n    dead_tmp(tmp);\n\n}\n", "idx": 3900}
{"project": "qemu", "commit_id": "ee25595f0126de0f83da86cc29ba2365be7a50d2", "target": 1, "func": "static void check_cmd(AHCIState *s, int port)\n\n{\n\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n\n    int slot;\n\n\n\n    if ((pr->cmd & PORT_CMD_START) && pr->cmd_issue) {\n\n        for (slot = 0; (slot < 32) && pr->cmd_issue; slot++) {\n\n            if ((pr->cmd_issue & (1 << slot)) &&\n\n                !handle_cmd(s, port, slot)) {\n\n                pr->cmd_issue &= ~(1 << slot);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7952}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "g_malloc0(size_t n_bytes)\n\n{\n\n    void *mem;\n\n    __coverity_negative_sink__(n_bytes);\n\n    mem = calloc(1, n_bytes == 0 ? 1 : n_bytes);\n\n    if (!mem) __coverity_panic__();\n\n    return mem;\n\n}\n", "idx": 8233}
{"project": "qemu", "commit_id": "c0532a76b407af4b276dc5a62d8178db59857ea6", "target": 1, "func": "void cpu_inject_x86_mce(CPUState *cenv, int bank, uint64_t status,\n\n                        uint64_t mcg_status, uint64_t addr, uint64_t misc)\n\n{\n\n    uint64_t mcg_cap = cenv->mcg_cap;\n\n    unsigned bank_num = mcg_cap & 0xff;\n\n    uint64_t *banks = cenv->mce_banks;\n\n\n\n    if (bank >= bank_num || !(status & MCI_STATUS_VAL))\n\n        return;\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_inject_x86_mce(cenv, bank, status, mcg_status, addr, misc);\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * if MSR_MCG_CTL is not all 1s, the uncorrected error\n\n     * reporting is disabled\n\n     */\n\n    if ((status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\n        cenv->mcg_ctl != ~(uint64_t)0)\n\n        return;\n\n    banks += 4 * bank;\n\n    /*\n\n     * if MSR_MCi_CTL is not all 1s, the uncorrected error\n\n     * reporting is disabled for the bank\n\n     */\n\n    if ((status & MCI_STATUS_UC) && banks[0] != ~(uint64_t)0)\n\n        return;\n\n    if (status & MCI_STATUS_UC) {\n\n        if ((cenv->mcg_status & MCG_STATUS_MCIP) ||\n\n            !(cenv->cr[4] & CR4_MCE_MASK)) {\n\n            fprintf(stderr, \"injects mce exception while previous \"\n\n                    \"one is in progress!\\n\");\n\n            qemu_log_mask(CPU_LOG_RESET, \"Triple fault\\n\");\n\n            qemu_system_reset_request();\n\n            return;\n\n        }\n\n        if (banks[1] & MCI_STATUS_VAL)\n\n            status |= MCI_STATUS_OVER;\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        cenv->mcg_status = mcg_status;\n\n        banks[1] = status;\n\n        cpu_interrupt(cenv, CPU_INTERRUPT_MCE);\n\n    } else if (!(banks[1] & MCI_STATUS_VAL)\n\n               || !(banks[1] & MCI_STATUS_UC)) {\n\n        if (banks[1] & MCI_STATUS_VAL)\n\n            status |= MCI_STATUS_OVER;\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        banks[1] = status;\n\n    } else\n\n        banks[1] |= MCI_STATUS_OVER;\n\n}\n", "idx": 11290}
{"project": "qemu", "commit_id": "cc1e13913916f755fd2dc5041b8d4bf25d3ea88e", "target": 1, "func": "static QIOChannelSocket *nbd_establish_connection(SocketAddress *saddr,\n\n                                                  Error **errp)\n\n{\n\n    QIOChannelSocket *sioc;\n\n    Error *local_err = NULL;\n\n\n\n    sioc = qio_channel_socket_new();\n\n    qio_channel_set_name(QIO_CHANNEL(sioc), \"nbd-client\");\n\n\n\n    qio_channel_socket_connect_sync(sioc,\n\n                                    saddr,\n\n                                    &local_err);\n\n    if (local_err) {\n\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n\n\n    qio_channel_set_delay(QIO_CHANNEL(sioc), false);\n\n\n\n    return sioc;\n\n}", "idx": 3842}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static void machine_set_loadparm(Object *obj, const char *val, Error **errp)\n\n{\n\n    S390CcwMachineState *ms = S390_CCW_MACHINE(obj);\n\n    int i;\n\n\n\n    for (i = 0; i < sizeof(ms->loadparm) && val[i]; i++) {\n\n        uint8_t c = toupper(val[i]); /* mimic HMC */\n\n\n\n        if (('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || (c == '.') ||\n\n            (c == ' ')) {\n\n            ms->loadparm[i] = c;\n\n        } else {\n\n            error_setg(errp, \"LOADPARM: invalid character '%c' (ASCII 0x%02x)\",\n\n                       c, c);\n\n            return;\n\n        }\n\n    }\n\n\n\n    for (; i < sizeof(ms->loadparm); i++) {\n\n        ms->loadparm[i] = ' '; /* pad right with spaces */\n\n    }\n\n}\n", "idx": 28}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_addco (void)\n\n{\n\n    do_addco();\n\n    RETURN();\n\n}\n", "idx": 6952}
{"project": "qemu", "commit_id": "3750dabc69d76f0938cc726a64a70e4ae2fe21df", "target": 1, "func": "static uint64_t virtio_pci_common_read(void *opaque, hwaddr addr,\n\n                                       unsigned size)\n\n{\n\n    VirtIOPCIProxy *proxy = opaque;\n\n    VirtIODevice *vdev = virtio_bus_get_device(&proxy->bus);\n\n    uint32_t val = 0;\n\n    int i;\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_COMMON_DFSELECT:\n\n        val = proxy->dfselect;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_DF:\n\n        if (proxy->dfselect <= 1) {\n\n            val = vdev->host_features >> (32 * proxy->dfselect);\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GFSELECT:\n\n        val = proxy->gfselect;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GF:\n\n        if (proxy->gfselect <= ARRAY_SIZE(proxy->guest_features)) {\n\n            val = proxy->guest_features[proxy->gfselect];\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_MSIX:\n\n        val = vdev->config_vector;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_NUMQ:\n\n        for (i = 0; i < VIRTIO_QUEUE_MAX; ++i) {\n\n            if (virtio_queue_get_num(vdev, i)) {\n\n                val = i + 1;\n\n            }\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_STATUS:\n\n        val = vdev->status;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_CFGGENERATION:\n\n        val = vdev->generation;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SELECT:\n\n        val = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SIZE:\n\n        val = virtio_queue_get_num(vdev, vdev->queue_sel);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_MSIX:\n\n        val = virtio_queue_vector(vdev, vdev->queue_sel);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_ENABLE:\n\n        val = proxy->vqs[vdev->queue_sel].enabled;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_NOFF:\n\n        /* Simply map queues in order */\n\n        val = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCLO:\n\n        val = proxy->vqs[vdev->queue_sel].desc[0];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCHI:\n\n        val = proxy->vqs[vdev->queue_sel].desc[1];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILLO:\n\n        val = proxy->vqs[vdev->queue_sel].avail[0];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILHI:\n\n        val = proxy->vqs[vdev->queue_sel].avail[1];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDLO:\n\n        val = proxy->vqs[vdev->queue_sel].used[0];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDHI:\n\n        val = proxy->vqs[vdev->queue_sel].used[1];\n\n        break;\n\n    default:\n\n        val = 0;\n\n    }\n\n\n\n    return val;\n\n}\n", "idx": 2202}
{"project": "qemu", "commit_id": "3d100d0fa9ee4826425ea1c2a120a0f661d8e739", "target": 1, "func": "static void i82801b11_bridge_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->is_bridge = 1;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82801BA_11;\n\n    k->revision = ICH9_D2P_A2_REVISION;\n\n    k->init = i82801b11_bridge_initfn;\n\n    k->config_write = pci_bridge_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n}", "idx": 8303}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static void buffer_reset(Buffer *buffer)\n\n{\n\n\tbuffer->offset = 0;\n\n}\n", "idx": 5839}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "int bdrv_get_dirty(BlockDriverState *bs, int64_t sector)\n\n{\n\n    int64_t chunk = sector / (int64_t)BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    if (bs->dirty_bitmap != NULL &&\n\n        (sector << BDRV_SECTOR_BITS) <= bdrv_getlength(bs)) {\n\n        return bs->dirty_bitmap[chunk];\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 8729}
{"project": "qemu", "commit_id": "cecd8504b80148b66cdc1ce32046429bc3549090", "target": 1, "func": "void HELPER(vfp_set_fpscr)(CPUState *env, uint32_t val)\n\n{\n\n    int i;\n\n    uint32_t changed;\n\n\n\n    changed = env->vfp.xregs[ARM_VFP_FPSCR];\n\n    env->vfp.xregs[ARM_VFP_FPSCR] = (val & 0xffc8ffff);\n\n    env->vfp.vec_len = (val >> 16) & 7;\n\n    env->vfp.vec_stride = (val >> 20) & 3;\n\n\n\n    changed ^= val;\n\n    if (changed & (3 << 22)) {\n\n        i = (val >> 22) & 3;\n\n        switch (i) {\n\n        case 0:\n\n            i = float_round_nearest_even;\n\n            break;\n\n        case 1:\n\n            i = float_round_up;\n\n            break;\n\n        case 2:\n\n            i = float_round_down;\n\n            break;\n\n        case 3:\n\n            i = float_round_to_zero;\n\n            break;\n\n        }\n\n        set_float_rounding_mode(i, &env->vfp.fp_status);\n\n    }\n\n    if (changed & (1 << 24))\n\n        set_flush_to_zero((val & (1 << 24)) != 0, &env->vfp.fp_status);\n\n    if (changed & (1 << 25))\n\n        set_default_nan_mode((val & (1 << 25)) != 0, &env->vfp.fp_status);\n\n\n\n    i = vfp_exceptbits_to_host(val);\n\n    set_float_exception_flags(i, &env->vfp.fp_status);\n\n}\n", "idx": 12209}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "void helper_stsw(CPUPPCState *env, target_ulong addr, uint32_t nb,\n\n                 uint32_t reg)\n\n{\n\n    int sh;\n\n\n\n    for (; nb > 3; nb -= 4) {\n\n        cpu_stl_data(env, addr, env->gpr[reg]);\n\n        reg = (reg + 1) % 32;\n\n        addr = addr_add(env, addr, 4);\n\n    }\n\n    if (unlikely(nb > 0)) {\n\n        for (sh = 24; nb > 0; nb--, sh -= 8) {\n\n            cpu_stb_data(env, addr, (env->gpr[reg] >> sh) & 0xFF);\n\n            addr = addr_add(env, addr, 1);\n\n        }\n\n    }\n\n}\n", "idx": 10056}
{"project": "qemu", "commit_id": "e829b0bb054ed3389e5b22dad61875e51674e629", "target": 1, "func": "iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,\n\n                        void *command_data, void *opaque)\n\n{\n\n    struct IscsiTask *itask = opaque;\n\n    struct scsi_readcapacity16 *rc16;\n\n    struct scsi_task *task = command_data;\n\n\n\n    if (status != 0) {\n\n        error_report(\"iSCSI: Failed to read capacity of iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    rc16 = scsi_datain_unmarshall(task);\n\n    if (rc16 == NULL) {\n\n        error_report(\"iSCSI: Failed to unmarshall readcapacity16 data.\");\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    itask->iscsilun->block_size = rc16->block_length;\n\n    itask->iscsilun->num_blocks = rc16->returned_lba + 1;\n\n    itask->bs->total_sectors    = itask->iscsilun->num_blocks *\n\n                               itask->iscsilun->block_size / BDRV_SECTOR_SIZE ;\n\n\n\n    itask->status   = 0;\n\n    itask->complete = 1;\n\n    scsi_free_scsi_task(task);\n\n}\n", "idx": 3045}
{"project": "qemu", "commit_id": "857d4f46c31d2f4d57d2f0fad9dfb584262bf9b9", "target": 1, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_sector_num;\n\n    int cluster_nb_sectors;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, sector_num, nb_sectors,\n\n                           &cluster_sector_num, &cluster_nb_sectors);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, sector_num, nb_sectors,\n\n                                   cluster_sector_num, cluster_nb_sectors);\n\n\n\n    iov.iov_len = cluster_nb_sectors * BDRV_SECTOR_SIZE;\n\n    iov.iov_base = bounce_buffer = qemu_blockalign(bs, iov.iov_len);\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = drv->bdrv_co_readv(bs, cluster_sector_num, cluster_nb_sectors,\n\n                             &bounce_qiov);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    if (drv->bdrv_co_write_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        ret = bdrv_co_do_write_zeroes(bs, cluster_sector_num,\n\n                                      cluster_nb_sectors, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = drv->bdrv_co_writev(bs, cluster_sector_num, cluster_nb_sectors,\n\n                                  &bounce_qiov);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = (sector_num - cluster_sector_num) * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes,\n\n                        nb_sectors * BDRV_SECTOR_SIZE);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 9610}
{"project": "qemu", "commit_id": "69179fe2fc0b91f68699012ba72d329e74ff629e", "target": 1, "func": "static void test_reconnect(void)\n\n{\n\n    gchar *path = g_strdup_printf(\"/%s/vhost-user/reconnect/subprocess\",\n\n                                  qtest_get_arch());\n\n    g_test_trap_subprocess(path, 0, 0);\n\n    g_test_trap_assert_passed();\n\n\n}", "idx": 130}
{"project": "qemu", "commit_id": "60ff4e63e2ea4738f114cbaf1f17e6e0184fc09c", "target": 1, "func": "static void calxeda_init(MachineState *machine, enum cxmachines machine_id)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    DeviceState *dev = NULL;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[128];\n\n    int n;\n\n    qemu_irq cpu_irq[4];\n\n    MemoryRegion *sysram;\n\n    MemoryRegion *dram;\n\n    MemoryRegion *sysmem;\n\n    char *sysboot_filename;\n\n\n\n    if (!cpu_model) {\n\n        switch (machine_id) {\n\n        case CALXEDA_HIGHBANK:\n\n            cpu_model = \"cortex-a9\";\n\n            break;\n\n        case CALXEDA_MIDWAY:\n\n            cpu_model = \"cortex-a15\";\n\n            break;\n\n        }\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n        Object *cpuobj;\n\n        ARMCPU *cpu;\n\n        Error *err = NULL;\n\n\n\n        if (!oc) {\n\n            error_report(\"Unable to find CPU definition\");\n\n            exit(1);\n\n        }\n\n\n\n        cpuobj = object_new(object_class_get_name(oc));\n\n        cpu = ARM_CPU(cpuobj);\n\n\n\n        /* By default A9 and A15 CPUs have EL3 enabled.  This board does not\n\n         * currently support EL3 so the CPU EL3 property is disabled before\n\n         * realization.\n\n         */\n\n        if (object_property_find(cpuobj, \"has_el3\", NULL)) {\n\n            object_property_set_bool(cpuobj, false, \"has_el3\", &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        if (object_property_find(cpuobj, \"reset-cbar\", NULL)) {\n\n            object_property_set_int(cpuobj, MPCORE_PERIPHBASE,\n\n                                    \"reset-cbar\", &error_abort);\n\n        }\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ);\n\n    }\n\n\n\n    sysmem = get_system_memory();\n\n    dram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(dram, NULL, \"highbank.dram\", ram_size, &error_abort);\n\n    /* SDRAM at address zero.  */\n\n    memory_region_add_subregion(sysmem, 0, dram);\n\n\n\n    sysram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\n\n                           &error_abort);\n\n    memory_region_add_subregion(sysmem, 0xfff88000, sysram);\n\n    if (bios_name != NULL) {\n\n        sysboot_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (sysboot_filename != NULL) {\n\n            uint32_t filesize = get_image_size(sysboot_filename);\n\n            if (load_image_targphys(\"sysram.bin\", 0xfff88000, filesize) < 0) {\n\n                hw_error(\"Unable to load %s\\n\", bios_name);\n\n            }\n\n            g_free(sysboot_filename);\n\n        } else {\n\n           hw_error(\"Unable to find %s\\n\", bios_name);\n\n        }\n\n    }\n\n\n\n    switch (machine_id) {\n\n    case CALXEDA_HIGHBANK:\n\n        dev = qdev_create(NULL, \"l2x0\");\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, 0xfff12000);\n\n\n\n        dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n        break;\n\n    case CALXEDA_MIDWAY:\n\n        dev = qdev_create(NULL, \"a15mpcore_priv\");\n\n        break;\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"num-irq\", NIRQ_GIC);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n    }\n\n\n\n    for (n = 0; n < 128; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"sp804\");\n\n    qdev_prop_set_uint32(dev, \"freq0\", 150000000);\n\n    qdev_prop_set_uint32(dev, \"freq1\", 150000000);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff34000);\n\n    sysbus_connect_irq(busdev, 0, pic[18]);\n\n    sysbus_create_simple(\"pl011\", 0xfff36000, pic[20]);\n\n\n\n    dev = qdev_create(NULL, \"highbank-regs\");\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff3c000);\n\n\n\n    sysbus_create_simple(\"pl061\", 0xfff30000, pic[14]);\n\n    sysbus_create_simple(\"pl061\", 0xfff31000, pic[15]);\n\n    sysbus_create_simple(\"pl061\", 0xfff32000, pic[16]);\n\n    sysbus_create_simple(\"pl061\", 0xfff33000, pic[17]);\n\n    sysbus_create_simple(\"pl031\", 0xfff35000, pic[19]);\n\n    sysbus_create_simple(\"pl022\", 0xfff39000, pic[23]);\n\n\n\n    sysbus_create_simple(\"sysbus-ahci\", 0xffe08000, pic[83]);\n\n\n\n    if (nd_table[0].used) {\n\n        qemu_check_nic_model(&nd_table[0], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[0]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]);\n\n\n\n        qemu_check_nic_model(&nd_table[1], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[1]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]);\n\n    }\n\n\n\n    highbank_binfo.ram_size = ram_size;\n\n    highbank_binfo.kernel_filename = kernel_filename;\n\n    highbank_binfo.kernel_cmdline = kernel_cmdline;\n\n    highbank_binfo.initrd_filename = initrd_filename;\n\n    /* highbank requires a dtb in order to boot, and the dtb will override\n\n     * the board ID. The following value is ignored, so set it to -1 to be\n\n     * clear that the value is meaningless.\n\n     */\n\n    highbank_binfo.board_id = -1;\n\n    highbank_binfo.nb_cpus = smp_cpus;\n\n    highbank_binfo.loader_start = 0;\n\n    highbank_binfo.write_secondary_boot = hb_write_secondary;\n\n    highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo);\n\n}\n", "idx": 6088}
{"project": "qemu", "commit_id": "9ada575bbafaf6d3724a7f59df9da89776817cac", "target": 1, "func": "static void create_header64(DumpState *s, Error **errp)\n{\n    DiskDumpHeader64 *dh = NULL;\n    KdumpSubHeader64 *kh = NULL;\n    size_t size;\n    uint32_t block_size;\n    uint32_t sub_hdr_size;\n    uint32_t bitmap_blocks;\n    uint32_t status = 0;\n    uint64_t offset_note;\n    Error *local_err = NULL;\n    /* write common header, the version of kdump-compressed format is 6th */\n    size = sizeof(DiskDumpHeader64);\n    dh = g_malloc0(size);\n    strncpy(dh->signature, KDUMP_SIGNATURE, strlen(KDUMP_SIGNATURE));\n    dh->header_version = cpu_to_dump32(s, 6);\n    block_size = s->dump_info.page_size;\n    dh->block_size = cpu_to_dump32(s, block_size);\n    sub_hdr_size = sizeof(struct KdumpSubHeader64) + s->note_size;\n    sub_hdr_size = DIV_ROUND_UP(sub_hdr_size, block_size);\n    dh->sub_hdr_size = cpu_to_dump32(s, sub_hdr_size);\n    /* dh->max_mapnr may be truncated, full 64bit is in kh.max_mapnr_64 */\n    dh->max_mapnr = cpu_to_dump32(s, MIN(s->max_mapnr, UINT_MAX));\n    dh->nr_cpus = cpu_to_dump32(s, s->nr_cpus);\n    bitmap_blocks = DIV_ROUND_UP(s->len_dump_bitmap, block_size) * 2;\n    dh->bitmap_blocks = cpu_to_dump32(s, bitmap_blocks);\n    strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine));\n    if (s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) {\n        status |= DUMP_DH_COMPRESSED_ZLIB;\n#ifdef CONFIG_LZO\n    if (s->flag_compress & DUMP_DH_COMPRESSED_LZO) {\n        status |= DUMP_DH_COMPRESSED_LZO;\n#endif\n#ifdef CONFIG_SNAPPY\n    if (s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) {\n        status |= DUMP_DH_COMPRESSED_SNAPPY;\n#endif\n    dh->status = cpu_to_dump32(s, status);\n    if (write_buffer(s->fd, 0, dh, size) < 0) {\n        error_setg(errp, \"dump: failed to write disk dump header\");\n        goto out;\n    /* write sub header */\n    size = sizeof(KdumpSubHeader64);\n    kh = g_malloc0(size);\n    /* 64bit max_mapnr_64 */\n    kh->max_mapnr_64 = cpu_to_dump64(s, s->max_mapnr);\n    kh->phys_base = cpu_to_dump64(s, s->dump_info.phys_base);\n    kh->dump_level = cpu_to_dump32(s, DUMP_LEVEL);\n    offset_note = DISKDUMP_HEADER_BLOCKS * block_size + size;\n    kh->offset_note = cpu_to_dump64(s, offset_note);\n    kh->note_size = cpu_to_dump64(s, s->note_size);\n    if (write_buffer(s->fd, DISKDUMP_HEADER_BLOCKS *\n                     block_size, kh, size) < 0) {\n        error_setg(errp, \"dump: failed to write kdump sub header\");\n        goto out;\n    /* write note */\n    s->note_buf = g_malloc0(s->note_size);\n    s->note_buf_offset = 0;\n    /* use s->note_buf to store notes temporarily */\n    write_elf64_notes(buf_write_note, s, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    if (write_buffer(s->fd, offset_note, s->note_buf,\n                     s->note_size) < 0) {\n        error_setg(errp, \"dump: failed to write notes\");\n        goto out;\n    /* get offset of dump_bitmap */\n    s->offset_dump_bitmap = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size) *\n                             block_size;\n    /* get offset of page */\n    s->offset_page = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size + bitmap_blocks) *\n                     block_size;\nout:\n    g_free(dh);\n    g_free(kh);\n    g_free(s->note_buf);", "idx": 534}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static target_ulong h_enter(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                            target_ulong opcode, target_ulong *args)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong pteh = args[2];\n\n    target_ulong ptel = args[3];\n\n    target_ulong page_shift = 12;\n\n    target_ulong raddr;\n\n    target_ulong i;\n\n    hwaddr hpte;\n\n\n\n    /* only handle 4k and 16M pages for now */\n\n    if (pteh & HPTE64_V_LARGE) {\n\n#if 0 /* We don't support 64k pages yet */\n\n        if ((ptel & 0xf000) == 0x1000) {\n\n            /* 64k page */\n\n        } else\n\n#endif\n\n        if ((ptel & 0xff000) == 0) {\n\n            /* 16M page */\n\n            page_shift = 24;\n\n            /* lowest AVA bit must be 0 for 16M pages */\n\n            if (pteh & 0x80) {\n\n                return H_PARAMETER;\n\n            }\n\n        } else {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    raddr = (ptel & HPTE64_R_RPN) & ~((1ULL << page_shift) - 1);\n\n\n\n    if (raddr < spapr->ram_limit) {\n\n        /* Regular RAM - should have WIMG=0010 */\n\n        if ((ptel & HPTE64_R_WIMG) != HPTE64_R_M) {\n\n            return H_PARAMETER;\n\n        }\n\n    } else {\n\n        /* Looks like an IO address */\n\n        /* FIXME: What WIMG combinations could be sensible for IO?\n\n         * For now we allow WIMG=010x, but are there others? */\n\n        /* FIXME: Should we check against registered IO addresses? */\n\n        if ((ptel & (HPTE64_R_W | HPTE64_R_I | HPTE64_R_M)) != HPTE64_R_I) {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    pteh &= ~0x60ULL;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n    if (likely((flags & H_EXACT) == 0)) {\n\n        pte_index &= ~7ULL;\n\n        hpte = pte_index * HASH_PTE_SIZE_64;\n\n        for (i = 0; ; ++i) {\n\n            if (i == 8) {\n\n                return H_PTEG_FULL;\n\n            }\n\n            if ((ppc_hash64_load_hpte0(env, hpte) & HPTE64_V_VALID) == 0) {\n\n                break;\n\n            }\n\n            hpte += HASH_PTE_SIZE_64;\n\n        }\n\n    } else {\n\n        i = 0;\n\n        hpte = pte_index * HASH_PTE_SIZE_64;\n\n        if (ppc_hash64_load_hpte0(env, hpte) & HPTE64_V_VALID) {\n\n            return H_PTEG_FULL;\n\n        }\n\n    }\n\n    ppc_hash64_store_hpte1(env, hpte, ptel);\n\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n\n    ppc_hash64_store_hpte0(env, hpte, pteh | HPTE64_V_HPTE_DIRTY);\n\n\n\n    args[0] = pte_index + i;\n\n    return H_SUCCESS;\n\n}\n", "idx": 7891}
{"project": "qemu", "commit_id": "decb471488dd9e7e7ab9957f120cb501c4489f63", "target": 1, "func": "static inline int get_segment(CPUState *env, mmu_ctx_t *ctx,\n\n                              target_ulong eaddr, int rw, int type)\n\n{\n\n    target_phys_addr_t hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n#if defined(TARGET_PPC64)\n\n    if (env->mmu_model & POWERPC_MMU_64) {\n\n        ppc_slb_t *slb;\n\n        target_ulong pageaddr;\n\n        int segment_bits;\n\n\n\n        LOG_MMU(\"Check SLBs\\n\");\n\n        slb = slb_lookup(env, eaddr);\n\n        if (!slb) {\n\n            return -5;\n\n        }\n\n\n\n        if (slb->vsid & SLB_VSID_B) {\n\n            vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n            segment_bits = 40;\n\n        } else {\n\n            vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n            segment_bits = 28;\n\n        }\n\n\n\n        target_page_bits = (slb->vsid & SLB_VSID_L)\n\n            ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n        ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                      : (slb->vsid & SLB_VSID_KS));\n\n        ds = 0;\n\n        ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n        pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n        if (slb->vsid & SLB_VSID_B) {\n\n            hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n        } else {\n\n            hash = vsid ^ (pageaddr >> target_page_bits);\n\n        }\n\n        /* Only 5 bits of the page index are used in the AVPN */\n\n        ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n            ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n    } else\n\n#endif /* defined(TARGET_PPC64) */\n\n    {\n\n        target_ulong sr, pgidx;\n\n\n\n        sr = env->sr[eaddr >> 28];\n\n        ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                    ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n        ds = sr & 0x80000000 ? 1 : 0;\n\n        ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n        vsid = sr & 0x00FFFFFF;\n\n        target_page_bits = TARGET_PAGE_BITS;\n\n        LOG_MMU(\"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx \" nip=\"\n\n                TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n                \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n                eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n                (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n        pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n        hash = vsid ^ pgidx;\n\n        ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n    }\n\n    LOG_MMU(\"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (target_phys_addr_t)-1ULL;\n\n            if (unlikely(env->mmu_model == POWERPC_MMU_SOFT_6xx ||\n\n                         env->mmu_model == POWERPC_MMU_SOFT_74xx)) {\n\n                /* Software TLB search */\n\n                ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n            } else {\n\n                LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                        \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                        \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                        env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                        ctx->hash[0]);\n\n                /* Primary table lookup */\n\n                ret = find_pte(env, ctx, 0, rw, type, target_page_bits);\n\n                if (ret < 0) {\n\n                    /* Secondary table lookup */\n\n                    if (eaddr != 0xEFFFFFFF)\n\n                        LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                                \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                                \" hash=\" TARGET_FMT_plx \" pg_addr=\"\n\n                                TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                                env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n                    ret2 = find_pte(env, ctx, 1, rw, type,\n\n                                    target_page_bits);\n\n                    if (ret2 != -1)\n\n                        ret = ret2;\n\n                }\n\n            }\n\n#if defined (DUMP_PAGE_TABLES)\n\n            if (qemu_log_enabled()) {\n\n                target_phys_addr_t curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", sdr, mask + 0x80);\n\n                for (curaddr = sdr; curaddr < (sdr + mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(curaddr);\n\n                    a1 = ldl_phys(curaddr + 4);\n\n                    a2 = ldl_phys(curaddr + 8);\n\n                    a3 = ldl_phys(curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            LOG_MMU(\"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        LOG_MMU(\"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log(\"ERROR: instruction should not need \"\n\n                        \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2739}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_reset(DeviceState *qdev)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(qdev);\n\n    pci_bridge_reset(qdev);\n\n    msi_reset(d);\n\n    shpc_reset(d);\n\n}\n", "idx": 6222}
{"project": "qemu", "commit_id": "d72915c60bff51495529449750e051d01b03c62f", "target": 1, "func": "void throttle_get_config(ThrottleState *ts, ThrottleConfig *cfg)\n{\n    *cfg = ts->cfg;", "idx": 8858}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "size_t qsb_get_length(const QEMUSizedBuffer *qsb)\n\n{\n\n    return qsb->used;\n\n}\n", "idx": 10421}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationInfo *qmp_query_migrate(Error **errp)\n\n{\n\n    MigrationInfo *info = g_malloc0(sizeof(*info));\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    switch (s->state) {\n\n    case MIG_STATE_NONE:\n\n        /* no migration has happened ever */\n\n        break;\n\n    case MIG_STATE_SETUP:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"setup\");\n\n        info->has_total_time = false;\n\n        break;\n\n    case MIG_STATE_ACTIVE:\n\n    case MIG_STATE_CANCELLING:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"active\");\n\n        info->has_total_time = true;\n\n        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)\n\n            - s->total_time;\n\n        info->has_expected_downtime = true;\n\n        info->expected_downtime = s->expected_downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = ram_bytes_remaining();\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->dirty_pages_rate = s->dirty_pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 5907}
{"project": "qemu", "commit_id": "848696bf353750899832c51005f1bd3540da5c29", "target": 1, "func": "static void adlib_realizefn (DeviceState *dev, Error **errp)\n\n{\n\n    AdlibState *s = ADLIB(dev);\n\n    PortioList *port_list = g_new(PortioList, 1);\n\n    struct audsettings as;\n\n\n\n    if (glob_adlib) {\n\n        error_setg (errp, \"Cannot create more than 1 adlib device\");\n\n        return;\n\n    }\n\n    glob_adlib = s;\n\n\n\n#ifdef HAS_YMF262\n\n    if (YMF262Init (1, 14318180, s->freq)) {\n\n        error_setg (errp, \"YMF262Init %d failed\", s->freq);\n\n        return;\n\n    }\n\n    else {\n\n        YMF262SetTimerHandler (0, timer_handler, 0);\n\n        s->enabled = 1;\n\n    }\n\n#else\n\n    s->opl = OPLCreate (OPL_TYPE_YM3812, 3579545, s->freq);\n\n    if (!s->opl) {\n\n        error_setg (errp, \"OPLCreate %d failed\", s->freq);\n\n        return;\n\n    }\n\n    else {\n\n        OPLSetTimerHandler (s->opl, timer_handler, 0);\n\n        s->enabled = 1;\n\n    }\n\n#endif\n\n\n\n    as.freq = s->freq;\n\n    as.nchannels = SHIFT;\n\n    as.fmt = AUD_FMT_S16;\n\n    as.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    AUD_register_card (\"adlib\", &s->card);\n\n\n\n    s->voice = AUD_open_out (\n\n        &s->card,\n\n        s->voice,\n\n        \"adlib\",\n\n        s,\n\n        adlib_callback,\n\n        &as\n\n        );\n\n    if (!s->voice) {\n\n        Adlib_fini (s);\n\n        error_setg (errp, \"Initializing audio voice failed\");\n\n        return;\n\n    }\n\n\n\n    s->samples = AUD_get_buffer_size_out (s->voice) >> SHIFT;\n\n    s->mixbuf = g_malloc0 (s->samples << SHIFT);\n\n\n\n    adlib_portio_list[0].offset = s->port;\n\n    adlib_portio_list[1].offset = s->port + 8;\n\n    portio_list_init (port_list, OBJECT(s), adlib_portio_list, s, \"adlib\");\n\n    portio_list_add (port_list, isa_address_space_io(&s->parent_obj), 0);\n\n}\n", "idx": 2500}
{"project": "qemu", "commit_id": "7843c0d60db694b6d97e14ec5538fb97424016c1", "target": 1, "func": "static void powerpc_get_compat(Object *obj, Visitor *v, const char *name,\n\n                               void *opaque, Error **errp)\n\n{\n\n    char *value = (char *)\"\";\n\n    Property *prop = opaque;\n\n    uint32_t *max_compat = qdev_get_prop_ptr(DEVICE(obj), prop);\n\n\n\n    switch (*max_compat) {\n\n    case CPU_POWERPC_LOGICAL_2_05:\n\n        value = (char *)\"power6\";\n\n        break;\n\n    case CPU_POWERPC_LOGICAL_2_06:\n\n        value = (char *)\"power7\";\n\n        break;\n\n    case CPU_POWERPC_LOGICAL_2_07:\n\n        value = (char *)\"power8\";\n\n        break;\n\n    case 0:\n\n        break;\n\n    default:\n\n        error_report(\"Internal error: compat is set to %x\", *max_compat);\n\n        abort();\n\n        break;\n\n    }\n\n\n\n    visit_type_str(v, name, &value, errp);\n\n}\n", "idx": 10780}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 129}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n", "idx": 269}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static gboolean register_signal_handlers(void)\n\n{\n\n    struct sigaction sigact, sigact_chld;\n\n    int ret;\n\n\n\n    memset(&sigact, 0, sizeof(struct sigaction));\n\n    sigact.sa_handler = quit_handler;\n\n\n\n    ret = sigaction(SIGINT, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n    ret = sigaction(SIGTERM, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n\n\n    memset(&sigact_chld, 0, sizeof(struct sigaction));\n\n    sigact_chld.sa_handler = child_handler;\n\n    sigact_chld.sa_flags = SA_NOCLDSTOP;\n\n    ret = sigaction(SIGCHLD, &sigact_chld, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 6131}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}", "idx": 1163}
{"project": "qemu", "commit_id": "eeae2e7b52255dae0976a027b6e11274990c708d", "target": 1, "func": "static uint32_t pci_reg_read4(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PPCE500PCIState *pci = opaque;\n\n    unsigned long win;\n\n    uint32_t value = 0;\n\n\n\n    win = addr & 0xfe0;\n\n\n\n    switch (win) {\n\n    case PPCE500_PCI_OW1:\n\n    case PPCE500_PCI_OW2:\n\n    case PPCE500_PCI_OW3:\n\n    case PPCE500_PCI_OW4:\n\n        switch (addr & 0xC) {\n\n        case PCI_POTAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].potar;\n\n            break;\n\n        case PCI_POTEAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].potear;\n\n            break;\n\n        case PCI_POWBAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].powbar;\n\n            break;\n\n        case PCI_POWAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].powar;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case PPCE500_PCI_IW3:\n\n    case PPCE500_PCI_IW2:\n\n    case PPCE500_PCI_IW1:\n\n        switch (addr & 0xC) {\n\n        case PCI_PITAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].pitar;\n\n            break;\n\n        case PCI_PIWBAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].piwbar;\n\n            break;\n\n        case PCI_PIWBEAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].piwbear;\n\n            break;\n\n        case PCI_PIWAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].piwar;\n\n            break;\n\n        default:\n\n            break;\n\n        };\n\n        break;\n\n\n\n    case PPCE500_PCI_GASKET_TIMR:\n\n        value = pci->gasket_time;\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    pci_debug(\"%s: win:%lx(addr:\" TARGET_FMT_plx \") -> value:%x\\n\", __func__,\n\n              win, addr, value);\n\n    return value;\n\n}\n", "idx": 1574}
{"project": "qemu", "commit_id": "c1d4096b0f033d0a52c542f0948403783c3682e9", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    struct scsi_inquiry_supported_pages *inq_vpd;\n    char *initiator_name = NULL;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    const char *filename;\n    int i, ret;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_setg(errp, \"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                   \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                   \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    filename = qemu_opt_get(opts, \"filename\");\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\n        error_setg(errp, \"Failed to parse URL : %s\", filename);\n        ret = -EINVAL;\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\n        error_setg(errp, \"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n        error_setg(errp, \"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\n        if (ret != 0) {\n            error_setg(errp, \"Failed to set initiator username and password\");\n            ret = -EINVAL;\n    /* check if we got CHAP username/password via the options */\n    parse_chap(iscsi, iscsi_url->target, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n        error_setg(errp, \"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    if (iscsi_full_connect_sync(iscsi, iscsi_url->portal, iscsi_url->lun) != 0) {\n        error_setg(errp, \"iSCSI: Failed to connect to LUN : %s\",\n            iscsi_get_error(iscsi));\n        ret = -EINVAL;\n    iscsilun->iscsi = iscsi;\n    iscsilun->aio_context = bdrv_get_aio_context(bs);\n    iscsilun->lun   = iscsi_url->lun;\n    iscsilun->has_write_same = true;\n    task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 0, 0,\n                            (void **) &inq, errp);\n    if (task == NULL) {\n        ret = -EINVAL;\n    iscsilun->type = inq->periperal_device_type;\n    scsi_free_scsi_task(task);\n    task = NULL;\n    iscsi_readcapacity_sync(iscsilun, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    bs->total_sectors = sector_lun2qemu(iscsilun->num_blocks, iscsilun);\n    bs->request_alignment = iscsilun->block_size;\n    /* We don't have any emulation for devices other than disks and CD-ROMs, so\n     * this must be sg ioctl compatible. We force it to be sg, otherwise qemu\n     * will try to read from the device to guess the image format.\n     */\n    if (iscsilun->type != TYPE_DISK && iscsilun->type != TYPE_ROM) {\n        bs->sg = 1;\n    task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                            SCSI_INQUIRY_PAGECODE_SUPPORTED_VPD_PAGES,\n                            (void **) &inq_vpd, errp);\n    if (task == NULL) {\n        ret = -EINVAL;\n    for (i = 0; i < inq_vpd->num_pages; i++) {\n        struct scsi_task *inq_task;\n        struct scsi_inquiry_logical_block_provisioning *inq_lbp;\n        struct scsi_inquiry_block_limits *inq_bl;\n        switch (inq_vpd->pages[i]) {\n        case SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING:\n            inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                                        SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING,\n                                        (void **) &inq_lbp, errp);\n            if (inq_task == NULL) {\n                ret = -EINVAL;\n            memcpy(&iscsilun->lbp, inq_lbp,\n                   sizeof(struct scsi_inquiry_logical_block_provisioning));\n            scsi_free_scsi_task(inq_task);\n            break;\n        case SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS:\n            inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                                    SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS,\n                                    (void **) &inq_bl, errp);\n            if (inq_task == NULL) {\n                ret = -EINVAL;\n            memcpy(&iscsilun->bl, inq_bl,\n                   sizeof(struct scsi_inquiry_block_limits));\n            scsi_free_scsi_task(inq_task);\n            break;\n        default:\n            break;\n    scsi_free_scsi_task(task);\n    task = NULL;\n    iscsi_attach_aio_context(bs, iscsilun->aio_context);\n    /* Guess the internal cluster (page) size of the iscsi target by the means\n     * of opt_unmap_gran. Transfer the unmap granularity only if it has a\n     * reasonable size */\n    if (iscsilun->bl.opt_unmap_gran * iscsilun->block_size >= 4 * 1024 &&\n        iscsilun->bl.opt_unmap_gran * iscsilun->block_size <= 16 * 1024 * 1024) {\n        iscsilun->cluster_sectors = (iscsilun->bl.opt_unmap_gran *\n                                     iscsilun->block_size) >> BDRV_SECTOR_BITS;\n        if (iscsilun->lbprz && !(bs->open_flags & BDRV_O_NOCACHE)) {\n            iscsilun->allocationmap = iscsi_allocationmap_init(iscsilun);\n            if (iscsilun->allocationmap == NULL) {\n                ret = -ENOMEM;\nout:\n    qemu_opts_del(opts);\n    g_free(initiator_name);\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    if (task != NULL) {\n        scsi_free_scsi_task(task);\n    if (ret) {\n        if (iscsi != NULL) {\n            iscsi_destroy_context(iscsi);\n        memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;", "idx": 2760}
{"project": "qemu", "commit_id": "864699227911909ef1e33ecf91bf3c900715a9b1", "target": 1, "func": "static void loadvm_postcopy_handle_run_bh(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    MigrationIncomingState *mis = opaque;\n\n\n\n    /* TODO we should move all of this lot into postcopy_ram.c or a shared code\n\n     * in migration.c\n\n     */\n\n    cpu_synchronize_all_post_init();\n\n\n\n    qemu_announce_self();\n\n\n\n    /* Make sure all file formats flush their mutable metadata */\n\n    bdrv_invalidate_cache_all(&local_err);\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n    }\n\n\n\n    trace_loadvm_postcopy_handle_run_cpu_sync();\n\n    cpu_synchronize_all_post_init();\n\n\n\n    trace_loadvm_postcopy_handle_run_vmstart();\n\n\n\n    if (autostart) {\n\n        /* Hold onto your hats, starting the CPU */\n\n        vm_start();\n\n    } else {\n\n        /* leave it paused and let management decide when to start the CPU */\n\n        runstate_set(RUN_STATE_PAUSED);\n\n    }\n\n\n\n    qemu_bh_delete(mis->bh);\n\n}\n", "idx": 8623}
{"project": "qemu", "commit_id": "c4c0e236beabb9de5ff472f77aeb811ec5484615", "target": 1, "func": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n\n{\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret, value, index;\n\n\n\n    /* \n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n    value = le16_to_cpu(s->ctrl.req.wValue);\n\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n\n        s->ctrl.len);\n\n\n\n    if (s->ctrl.req.bRequestType == 0) {\n\n        switch (s->ctrl.req.bRequest) {\n\n        case USB_REQ_SET_ADDRESS:\n\n            return usb_host_set_address(s, value);\n\n\n\n        case USB_REQ_SET_CONFIGURATION:\n\n            return usb_host_set_config(s, value & 0xff);\n\n        }\n\n    }\n\n\n\n    if (s->ctrl.req.bRequestType == 1 &&\n\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n\n        return usb_host_set_interface(s, index, value);\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    aurb = async_alloc();\n\n    aurb->hdev   = s;\n\n    aurb->packet = p;\n\n\n\n    /* \n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is layed out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */ \n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &s->ctrl.req;\n\n    urb->buffer_length = 8 + s->ctrl.len;\n\n\n\n    urb->usercontext = s;\n\n\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    usb_defer_packet(p, async_cancel, aurb);\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 8353}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void spapr_phb_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    HotplugHandlerClass *hp = HOTPLUG_HANDLER_CLASS(klass);\n\n\n\n    hc->root_bus_path = spapr_phb_root_bus_path;\n\n    dc->realize = spapr_phb_realize;\n\n    dc->props = spapr_phb_properties;\n\n    dc->reset = spapr_phb_reset;\n\n    dc->vmsd = &vmstate_spapr_pci;\n\n\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    hp->plug = spapr_phb_hot_plug_child;\n\n    hp->unplug = spapr_phb_hot_unplug_child;\n\n}", "idx": 11361}
{"project": "qemu", "commit_id": "e7bd708ec85e40fd51569bb90c52d6613ffd8f45", "target": 1, "func": "void ide_atapi_cmd(IDEState *s)\n\n{\n\n    uint8_t *buf = s->io_buffer;\n\n    const struct AtapiCmd *cmd = &atapi_cmd_table[s->io_buffer[0]];\n\n\n\n#ifdef DEBUG_IDE_ATAPI\n\n    {\n\n        int i;\n\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n\n            printf(\" %02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    /*\n\n     * If there's a UNIT_ATTENTION condition pending, only command flagged with\n\n     * ALLOW_UA are allowed to complete. with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION && !(cmd->flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(cmd->flags & ALLOW_UA) &&\n\n        !s->tray_open && blk_is_inserted(s->blk) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((cmd->flags & CHECK_READY) &&\n\n        (!media_present(s) || !blk_is_inserted(s->blk)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Nondata commands permit the byte_count_limit to be 0.\n\n     * If this is a data-transferring PIO command and BCL is 0,\n\n     * we abort at the /ATA/ level, not the ATAPI level.\n\n     * See ATA8 ACS3 section 7.17.6.49 and 7.21.5 */\n\n    if (cmd->handler && !(cmd->flags & NONDATA)) {\n\n        /* TODO: Check IDENTIFY data word 125 for default BCL (currently 0) */\n\n        if (!(atapi_byte_count_limit(s) || s->atapi_dma)) {\n\n            /* TODO: Move abort back into core.c and make static inline again */\n\n            ide_abort_command(s);\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (cmd->handler) {\n\n        cmd->handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n", "idx": 5463}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd)\n\n{\n\n    struct kvm_create_spapr_tce args = {\n\n        .liobn = liobn,\n\n        .window_size = window_size,\n\n    };\n\n    long len;\n\n    int fd;\n\n    void *table;\n\n\n\n    /* Must set fd to -1 so we don't try to munmap when called for\n\n     * destroying the table, which the upper layers -will- do\n\n     */\n\n    *pfd = -1;\n\n    if (!cap_spapr_tce) {\n\n        return NULL;\n\n    }\n\n\n\n    fd = kvm_vm_ioctl(kvm_state, KVM_CREATE_SPAPR_TCE, &args);\n\n    if (fd < 0) {\n\n        fprintf(stderr, \"KVM: Failed to create TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        return NULL;\n\n    }\n\n\n\n    len = (window_size / SPAPR_VIO_TCE_PAGE_SIZE) * sizeof(VIOsPAPR_RTCE);\n\n    /* FIXME: round this up to page size */\n\n\n\n    table = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\n    if (table == MAP_FAILED) {\n\n        fprintf(stderr, \"KVM: Failed to map TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    *pfd = fd;\n\n    return table;\n\n}\n", "idx": 847}
{"project": "qemu", "commit_id": "3de31797825e94fd67ee7c2e877127acc3d2edbd", "target": 1, "func": "static inline void gen_intermediate_code_internal(PowerPCCPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = POWERPC_EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n    ctx.mem_idx = env->mmu_idx;\n\n    ctx.insns_flags = env->insns_flags;\n\n    ctx.insns_flags2 = env->insns_flags2;\n\n    ctx.access_type = -1;\n\n    ctx.le_mode = env->hflags & (1 << MSR_LE) ? 1 : 0;\n\n#if defined(TARGET_PPC64)\n\n    ctx.sf_mode = msr_is_64bit(env, env->msr);\n\n    ctx.has_cfar = !!(env->flags & POWERPC_FLAG_CFAR);\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    if ((env->flags & POWERPC_FLAG_SPE) && msr_spe)\n\n        ctx.spe_enabled = msr_spe;\n\n    else\n\n        ctx.spe_enabled = 0;\n\n    if ((env->flags & POWERPC_FLAG_VRE) && msr_vr)\n\n        ctx.altivec_enabled = msr_vr;\n\n    else\n\n        ctx.altivec_enabled = 0;\n\n    if ((env->flags & POWERPC_FLAG_VSX) && msr_vsx) {\n\n        ctx.vsx_enabled = msr_vsx;\n\n    } else {\n\n        ctx.vsx_enabled = 0;\n\n\n    if ((env->flags & POWERPC_FLAG_SE) && msr_se)\n\n        ctx.singlestep_enabled = CPU_SINGLE_STEP;\n\n    else\n\n        ctx.singlestep_enabled = 0;\n\n    if ((env->flags & POWERPC_FLAG_BE) && msr_be)\n\n        ctx.singlestep_enabled |= CPU_BRANCH_STEP;\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        ctx.singlestep_enabled |= GDBSTUB_SINGLE_STEP;\n\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_tb_start();\n\n    tcg_clear_temp_count();\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == POWERPC_EXCP_NONE\n\n            && tcg_ctx.gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == ctx.nip) {\n\n                    gen_debug_exception(ctxp);\n\n                    break;\n\n\n\n\n        if (unlikely(search_pc)) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n\n            tcg_ctx.gen_opc_pc[lj] = ctx.nip;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n\n        LOG_DISAS(\"----------------\\n\");\n\n        LOG_DISAS(\"nip=\" TARGET_FMT_lx \" super=%d ir=%d\\n\",\n\n                  ctx.nip, ctx.mem_idx, (int)msr_ir);\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n        if (unlikely(ctx.le_mode)) {\n\n            ctx.opcode = bswap32(cpu_ldl_code(env, ctx.nip));\n\n        } else {\n\n            ctx.opcode = cpu_ldl_code(env, ctx.nip);\n\n\n        LOG_DISAS(\"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), ctx.le_mode ? \"little\" : \"big\");\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(ctx.nip);\n\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        num_insns++;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (qemu_log_enabled()) {\n\n                qemu_log(\"invalid/unsupported opcode: \"\n\n                         \"%02x - %02x - %02x (%08x) \" TARGET_FMT_lx \" %d\\n\",\n\n                         opc1(ctx.opcode), opc2(ctx.opcode),\n\n                         opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, (int)msr_ir);\n\n\n        } else {\n\n            uint32_t inval;\n\n\n\n            if (unlikely(handler->type & (PPC_SPE | PPC_SPE_SINGLE | PPC_SPE_DOUBLE) && Rc(ctx.opcode))) {\n\n                inval = handler->inval2;\n\n            } else {\n\n                inval = handler->inval1;\n\n\n\n\n            if (unlikely((ctx.opcode & inval) != 0)) {\n\n                if (qemu_log_enabled()) {\n\n                    qemu_log(\"invalid bits: %08x for opcode: \"\n\n                             \"%02x - %02x - %02x (%08x) \" TARGET_FMT_lx \"\\n\",\n\n                             ctx.opcode & inval, opc1(ctx.opcode),\n\n                             opc2(ctx.opcode), opc3(ctx.opcode),\n\n                             ctx.opcode, ctx.nip - 4);\n\n\n                gen_inval_exception(ctxp, POWERPC_EXCP_INVAL_INVAL);\n\n                break;\n\n\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely(ctx.singlestep_enabled & CPU_SINGLE_STEP &&\n\n                     (ctx.nip <= 0x100 || ctx.nip > 0xF00) &&\n\n                     ctx.exception != POWERPC_SYSCALL &&\n\n                     ctx.exception != POWERPC_EXCP_TRAP &&\n\n                     ctx.exception != POWERPC_EXCP_BRANCH)) {\n\n            gen_exception(ctxp, POWERPC_EXCP_TRACE);\n\n        } else if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                            (cs->singlestep_enabled) ||\n\n                            singlestep ||\n\n                            num_insns >= max_insns)) {\n\n            /* if we reach a page boundary or are single stepping, stop\n\n             * generation\n\n             */\n\n            break;\n\n\n\n\n\n\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    if (ctx.exception == POWERPC_EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != POWERPC_EXCP_BRANCH) {\n\n        if (unlikely(cs->singlestep_enabled)) {\n\n            gen_debug_exception(ctxp);\n\n\n        /* Generate the return instruction */\n\n        tcg_gen_exit_tb(0);\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n        tb->icount = num_insns;\n\n\n#if defined(DEBUG_DISAS)\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        int flags;\n\n        flags = env->bfd_mach;\n\n        flags |= ctx.le_mode << 16;\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, ctx.nip - pc_start, flags);\n\n        qemu_log(\"\\n\");\n\n\n#endif\n", "idx": 9887}
{"project": "qemu", "commit_id": "b41d320fef705289d2b73f4949731eb2e189161d", "target": 1, "func": "static void spapr_alloc_htab(sPAPRMachineState *spapr)\n\n{\n\n    long shift;\n\n    int index;\n\n\n\n    /* allocate hash page table.  For now we always make this 16mb,\n\n     * later we should probably make it scale to the size of guest\n\n     * RAM */\n\n\n\n    shift = kvmppc_reset_htab(spapr->htab_shift);\n\n\n\n    if (shift > 0) {\n\n        /* Kernel handles htab, we don't need to allocate one */\n\n        if (shift != spapr->htab_shift) {\n\n            error_setg(&error_abort, \"Failed to allocate HTAB of requested size, try with smaller maxmem\");\n\n        }\n\n\n\n        spapr->htab_shift = shift;\n\n        kvmppc_kern_htab = true;\n\n    } else {\n\n        /* Allocate htab */\n\n        spapr->htab = qemu_memalign(HTAB_SIZE(spapr), HTAB_SIZE(spapr));\n\n\n\n        /* And clear it */\n\n        memset(spapr->htab, 0, HTAB_SIZE(spapr));\n\n\n\n        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n\n            DIRTY_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n    }\n\n}\n", "idx": 10865}
{"project": "qemu", "commit_id": "0a852417564bc59441dc09509beacf7b49bc1e57", "target": 1, "func": "bool trace_init_backends(void)\n{\n#ifdef CONFIG_TRACE_SIMPLE\n    if (!st_init()) {\n        fprintf(stderr, \"failed to initialize simple tracing backend.\\n\");\n        return false;\n    }\n#ifdef CONFIG_TRACE_FTRACE\n    if (!ftrace_init()) {\n        fprintf(stderr, \"failed to initialize ftrace backend.\\n\");\n        return false;\n    }\n    return true;\n}", "idx": 11273}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void qbus_initfn(Object *obj)\n\n{\n\n    BusState *bus = BUS(obj);\n\n\n\n    QTAILQ_INIT(&bus->children);\n\n    object_property_add_link(obj, QDEV_HOTPLUG_HANDLER_PROPERTY,\n\n                             TYPE_HOTPLUG_HANDLER,\n\n                             (Object **)&bus->hotplug_handler, NULL);\n\n    object_property_add_bool(obj, \"realized\",\n\n                             bus_get_realized, bus_set_realized, NULL);\n\n}\n", "idx": 4957}
{"project": "qemu", "commit_id": "0e8b3cdfbc167f4bb7790ef744eaa1ac0e6959f9", "target": 1, "func": "void *postcopy_get_tmp_page(MigrationIncomingState *mis)\n\n{\n\n    if (!mis->postcopy_tmp_page) {\n\n        mis->postcopy_tmp_page = mmap(NULL, getpagesize(),\n\n                             PROT_READ | PROT_WRITE, MAP_PRIVATE |\n\n                             MAP_ANONYMOUS, -1, 0);\n\n        if (!mis->postcopy_tmp_page) {\n\n            error_report(\"%s: %s\", __func__, strerror(errno));\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    return mis->postcopy_tmp_page;\n\n}\n", "idx": 8922}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void arm_cpu_class_init(ObjectClass *oc, void *data)\n{\n    ARMCPUClass *acc = ARM_CPU_CLASS(oc);\n    CPUClass *cc = CPU_CLASS(acc);\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    acc->parent_realize = dc->realize;\n    dc->realize = arm_cpu_realizefn;\n    dc->props = arm_cpu_properties;\n    acc->parent_reset = cc->reset;\n    cc->reset = arm_cpu_reset;\n    cc->class_by_name = arm_cpu_class_by_name;\n    cc->has_work = arm_cpu_has_work;\n    cc->cpu_exec_interrupt = arm_cpu_exec_interrupt;\n    cc->dump_state = arm_cpu_dump_state;\n    cc->set_pc = arm_cpu_set_pc;\n    cc->gdb_read_register = arm_cpu_gdb_read_register;\n    cc->gdb_write_register = arm_cpu_gdb_write_register;\n#ifdef CONFIG_USER_ONLY\n    cc->handle_mmu_fault = arm_cpu_handle_mmu_fault;\n#else\n    cc->do_interrupt = arm_cpu_do_interrupt;\n    cc->get_phys_page_debug = arm_cpu_get_phys_page_debug;\n    cc->vmsd = &vmstate_arm_cpu;\n    cc->virtio_is_big_endian = arm_cpu_is_big_endian;\n#endif\n    cc->gdb_num_core_regs = 26;\n    cc->gdb_core_xml_file = \"arm-core.xml\";\n    cc->gdb_stop_before_watchpoint = true;\n    cc->debug_excp_handler = arm_debug_excp_handler;\n    cc->disas_set_info = arm_disas_set_info;\n}", "idx": 9016}
{"project": "qemu", "commit_id": "b0e90181e4d7244a9466447703acdb2cdd7abdaa", "target": 1, "func": "static int query_memdev(Object *obj, void *opaque)\n\n{\n\n    MemdevList **list = opaque;\n\n    Error *err = NULL;\n\n\n\n    if (object_dynamic_cast(obj, TYPE_MEMORY_BACKEND)) {\n\n        MemdevList *m = g_malloc0(sizeof(*m));\n\n\n\n        m->value = g_malloc0(sizeof(*m->value));\n\n\n\n        m->value->size = object_property_get_int(obj, \"size\",\n\n                                                 &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->merge = object_property_get_bool(obj, \"merge\",\n\n                                                   &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->dump = object_property_get_bool(obj, \"dump\",\n\n                                                  &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->prealloc = object_property_get_bool(obj,\n\n                                                      \"prealloc\", &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->policy = object_property_get_enum(obj,\n\n                                                    \"policy\",\n\n                                                    HostMemPolicy_lookup,\n\n                                                    &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        object_property_get_uint16List(obj, \"host-nodes\",\n\n                                       &m->value->host_nodes, &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->next = *list;\n\n        *list = m;\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    return -1;\n\n}\n", "idx": 12094}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int set_dirty_tracking(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n    int ret;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        bmds->dirty_bitmap = bdrv_create_dirty_bitmap(bmds->bs, BLOCK_SIZE,\n\n                                                      NULL);\n\n        if (!bmds->dirty_bitmap) {\n\n            ret = -errno;\n\n            goto fail;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nfail:\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        if (bmds->dirty_bitmap) {\n\n            bdrv_release_dirty_bitmap(bmds->bs, bmds->dirty_bitmap);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 11726}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 3228}
{"project": "qemu", "commit_id": "7c38ecd09763107513bacc791856fdbb582a107c", "target": 1, "func": "static int acpi_pcihp_get_bsel(PCIBus *bus)\n\n{\n\n    QObject *o = object_property_get_qobject(OBJECT(bus),\n\n                                             ACPI_PCIHP_PROP_BSEL, NULL);\n\n    int64_t bsel = -1;\n\n    if (o) {\n\n        bsel = qint_get_int(qobject_to_qint(o));\n\n    }\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n    return bsel;\n\n}\n", "idx": 10027}
{"project": "qemu", "commit_id": "3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8", "target": 1, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        if (qemu_ram_addr_from_host(addr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n\n        kvm_mce_inject(first_cpu, paddr, code);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 2481}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void qga_vss_fsfreeze(int *nr_volume, Error **errp, bool freeze)\n\n{\n\n    const char *func_name = freeze ? \"requester_freeze\" : \"requester_thaw\";\n\n    QGAVSSRequesterFunc func;\n\n    ErrorSet errset = {\n\n        .error_setg_win32 = error_setg_win32,\n\n        .errp = errp,\n\n    };\n\n\n\n    g_assert(errp);             /* requester.cpp requires it */\n\n    func = (QGAVSSRequesterFunc)GetProcAddress(provider_lib, func_name);\n\n    if (!func) {\n\n        error_setg_win32(errp, GetLastError(), \"failed to load %s from %s\",\n\n                         func_name, QGA_VSS_DLL);\n\n        return;\n\n    }\n\n\n\n    func(nr_volume, &errset);\n\n}\n", "idx": 2415}
{"project": "qemu", "commit_id": "18c9a9c3c2698d71575d49c308db88f295ddffed", "target": 1, "func": "print_execve(const struct syscallname *name,\n\n             abi_long arg1, abi_long arg2, abi_long arg3,\n\n             abi_long arg4, abi_long arg5, abi_long arg6)\n\n{\n\n    abi_ulong arg_ptr_addr;\n\n    char *s;\n\n\n\n    if (!(s = lock_user_string(arg1)))\n\n        return;\n\n    gemu_log(\"%s(\\\"%s\\\",{\", name->name, s);\n\n    unlock_user(s, arg1, 0);\n\n\n\n    for (arg_ptr_addr = arg2; ; arg_ptr_addr += sizeof(abi_ulong)) {\n\n        abi_ulong *arg_ptr, arg_addr, s_addr;\n\n\n\n        arg_ptr = lock_user(VERIFY_READ, arg_ptr_addr, sizeof(abi_ulong), 1);\n\n        if (!arg_ptr)\n\n            return;\n\n        arg_addr = tswapl(*arg_ptr);\n\n        unlock_user(arg_ptr, arg_ptr_addr, 0);\n\n        if (!arg_addr)\n\n            break;\n\n        if ((s = lock_user_string(arg_addr))) {\n\n            gemu_log(\"\\\"%s\\\",\", s);\n\n            unlock_user(s, s_addr, 0);\n\n        }\n\n    }\n\n\n\n    gemu_log(\"NULL})\");\n\n}\n", "idx": 8783}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_rt_sigreturn(CPUS390XState *env)\n\n{\n\n    rt_sigframe *frame;\n\n    abi_ulong frame_addr = env->regs[15];\n\n    sigset_t set;\n\n\n\n    trace_user_do_rt_sigreturn(env, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);\n\n\n\n    set_sigmask(&set); /* ~_BLOCKABLE? */\n\n\n\n    if (restore_sigregs(env, &frame->uc.tuc_mcontext)) {\n\n        goto badframe;\n\n    }\n\n\n\n    if (do_sigaltstack(frame_addr + offsetof(rt_sigframe, uc.tuc_stack), 0,\n\n                       get_sp_from_cpustate(env)) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 1322}
{"project": "qemu", "commit_id": "378df4b23753a11be650af7664ca76bc75cb9f01", "target": 1, "func": "static void tcg_handle_interrupt(CPUArchState *env, int mask)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    int old_mask;\n\n\n\n    old_mask = env->interrupt_request;\n\n    env->interrupt_request |= mask;\n\n\n\n    /*\n\n     * If called from iothread context, wake the target cpu in\n\n     * case its halted.\n\n     */\n\n    if (!qemu_cpu_is_self(cpu)) {\n\n        qemu_cpu_kick(cpu);\n\n        return;\n\n    }\n\n\n\n    if (use_icount) {\n\n        env->icount_decr.u16.high = 0xffff;\n\n        if (!can_do_io(env)\n\n            && (mask & ~old_mask) != 0) {\n\n            cpu_abort(env, \"Raised interrupt while not in I/O function\");\n\n        }\n\n    } else {\n\n        cpu_unlink_tb(cpu);\n\n    }\n\n}\n", "idx": 7028}
{"project": "qemu", "commit_id": "84593a0807004d852132eaa56edf24d55793d480", "target": 1, "func": "static void ram_save_cleanup(void *opaque)\n\n{\n\n    RAMState **rsp = opaque;\n\n    RAMBlock *block;\n\n\n\n    /* caller have hold iothread lock or is in a bh, so there is\n\n     * no writing race against this migration_bitmap\n\n     */\n\n    memory_global_dirty_log_stop();\n\n\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n        g_free(block->bmap);\n\n        block->bmap = NULL;\n\n        g_free(block->unsentmap);\n\n        block->unsentmap = NULL;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n    if (XBZRLE.cache) {\n\n        cache_fini(XBZRLE.cache);\n\n        g_free(XBZRLE.encoded_buf);\n\n        g_free(XBZRLE.current_buf);\n\n        g_free(XBZRLE.zero_target_page);\n\n        XBZRLE.cache = NULL;\n\n        XBZRLE.encoded_buf = NULL;\n\n        XBZRLE.current_buf = NULL;\n\n        XBZRLE.zero_target_page = NULL;\n\n    }\n\n    XBZRLE_cache_unlock();\n\n    compress_threads_save_cleanup();\n\n    ram_state_cleanup(rsp);\n\n}\n", "idx": 1868}
{"project": "qemu", "commit_id": "c4c0e236beabb9de5ff472f77aeb811ec5484615", "target": 1, "func": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n\n{\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret, value, index;\n\n\n\n    /* \n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n    value = le16_to_cpu(s->ctrl.req.wValue);\n\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n\n        s->ctrl.len);\n\n\n\n    if (s->ctrl.req.bRequestType == 0) {\n\n        switch (s->ctrl.req.bRequest) {\n\n        case USB_REQ_SET_ADDRESS:\n\n            return usb_host_set_address(s, value);\n\n\n\n        case USB_REQ_SET_CONFIGURATION:\n\n            return usb_host_set_config(s, value & 0xff);\n\n        }\n\n    }\n\n\n\n    if (s->ctrl.req.bRequestType == 1 &&\n\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n\n        return usb_host_set_interface(s, index, value);\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    aurb = async_alloc();\n\n    aurb->hdev   = s;\n\n    aurb->packet = p;\n\n\n\n    /* \n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is layed out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */ \n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &s->ctrl.req;\n\n    urb->buffer_length = 8 + s->ctrl.len;\n\n\n\n    urb->usercontext = s;\n\n\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    usb_defer_packet(p, async_cancel, aurb);\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 8353}
{"project": "qemu", "commit_id": "96bc97ebf350ec480b69082819cedb8850f46a0f", "target": 1, "func": "QemuOpts *qemu_opts_find(QemuOptsList *list, const char *id)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    QTAILQ_FOREACH(opts, &list->head, next) {\n\n        if (!opts->id) {\n\n            if (!id) {\n\n                return opts;\n\n            }\n\n            continue;\n\n        }\n\n        if (strcmp(opts->id, id) != 0) {\n\n            continue;\n\n        }\n\n        return opts;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 6943}
{"project": "qemu", "commit_id": "0a852417564bc59441dc09509beacf7b49bc1e57", "target": 1, "func": "bool trace_init_backends(void)\n{\n#ifdef CONFIG_TRACE_SIMPLE\n    if (!st_init()) {\n        fprintf(stderr, \"failed to initialize simple tracing backend.\\n\");\n        return false;\n    }\n#ifdef CONFIG_TRACE_FTRACE\n    if (!ftrace_init()) {\n        fprintf(stderr, \"failed to initialize ftrace backend.\\n\");\n        return false;\n    }\n    return true;\n}", "idx": 11273}
{"project": "qemu", "commit_id": "760794f784f66e262a9ca32821ba202cdf3a3e4b", "target": 1, "func": "static int chr_can_read(void *opaque)\n\n{\n\n    int can_read;\n\n    SCLPConsole *scon = opaque;\n\n\n\n    can_read = SIZE_BUFFER_VT220 - scon->iov_data_len;\n\n\n\n    return can_read;\n\n}\n", "idx": 6069}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static void blkverify_aio_cb(void *opaque, int ret)\n\n{\n\n    BlkverifyAIOCB *acb = opaque;\n\n\n\n    switch (++acb->done) {\n\n    case 1:\n\n        acb->ret = ret;\n\n        break;\n\n\n\n    case 2:\n\n        if (acb->ret != ret) {\n\n            blkverify_err(acb, \"return value mismatch %d != %d\", acb->ret, ret);\n\n        }\n\n\n\n        if (acb->verify) {\n\n            acb->verify(acb);\n\n        }\n\n\n\n        aio_bh_schedule_oneshot(bdrv_get_aio_context(acb->common.bs),\n\n                                blkverify_aio_bh, acb);\n\n        break;\n\n    }\n\n}\n", "idx": 5140}
{"project": "qemu", "commit_id": "1f9296b51a26650916a2c4191268bb64057bdc5f", "target": 1, "func": "static void balloon_stats_change_timer(VirtIOBalloon *s, int secs)\n\n{\n\n    timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);\n\n}\n", "idx": 8746}
{"project": "qemu", "commit_id": "fd28aa132362320f9f3a30b23f634bb14dee528e", "target": 1, "func": "void qemu_ram_free(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr == block->offset) {\n\n            QLIST_REMOVE(block, next);\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (mem_path) {\n\n#if defined (__linux__) && !defined(TARGET_S390X)\n\n                if (block->fd) {\n\n                    munmap(block->host, block->length);\n\n                    close(block->fd);\n\n                } else {\n\n                    qemu_vfree(block->host);\n\n                }\n\n\n\n#endif\n\n            } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                munmap(block->host, block->length);\n\n\n                qemu_vfree(block->host);\n\n#endif\n\n            }\n\n            qemu_free(block);\n\n            return;\n\n        }\n\n    }\n\n\n\n}", "idx": 1275}
{"project": "qemu", "commit_id": "f575f145f4fa97fdbb9bbb4df62dfeada3f15dc4", "target": 1, "func": "static bool is_zero_cluster(BlockDriverState *bs, int64_t start)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int nr;\n\n    BlockDriverState *file;\n\n    int64_t res = bdrv_get_block_status_above(bs, NULL, start,\n\n                                              s->cluster_sectors, &nr, &file);\n\n    return res >= 0 && ((res & BDRV_BLOCK_ZERO) || !(res & BDRV_BLOCK_DATA));\n\n}\n", "idx": 9121}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "static void test_parse_invalid_path(void)\n\n{\n\n    g_test_trap_subprocess (\"/logging/parse_invalid_path/subprocess\", 0, 0);\n\n    g_test_trap_assert_passed();\n\n    g_test_trap_assert_stdout(\"\");\n\n    g_test_trap_assert_stderr(\"Bad logfile format: /tmp/qemu-%d%d.log\\n\");\n\n}\n", "idx": 940}
{"project": "qemu", "commit_id": "f6ec953ca329d4509e5a1a1ff051365fccdbb6b7", "target": 1, "func": "static int ioreq_runio_qemu_sync(struct ioreq *ioreq)\n\n{\n\n    struct XenBlkDev *blkdev = ioreq->blkdev;\n\n    int i, rc, len = 0;\n\n    off_t pos;\n\n\n\n    if (ioreq->req.nr_segments && ioreq_map(ioreq) == -1)\n\n\tgoto err;\n\n    if (ioreq->presync)\n\n\tbdrv_flush(blkdev->bs);\n\n\n\n    switch (ioreq->req.operation) {\n\n    case BLKIF_OP_READ:\n\n\tpos = ioreq->start;\n\n\tfor (i = 0; i < ioreq->v.niov; i++) {\n\n\t    rc = bdrv_read(blkdev->bs, pos / BLOCK_SIZE,\n\n\t\t\t   ioreq->v.iov[i].iov_base,\n\n\t\t\t   ioreq->v.iov[i].iov_len / BLOCK_SIZE);\n\n\t    if (rc != 0) {\n\n\t\txen_be_printf(&blkdev->xendev, 0, \"rd I/O error (%p, len %zd)\\n\",\n\n\t\t\t      ioreq->v.iov[i].iov_base,\n\n\t\t\t      ioreq->v.iov[i].iov_len);\n\n\t\tgoto err;\n\n\t    }\n\n\t    len += ioreq->v.iov[i].iov_len;\n\n\t    pos += ioreq->v.iov[i].iov_len;\n\n\t}\n\n\tbreak;\n\n    case BLKIF_OP_WRITE:\n\n    case BLKIF_OP_WRITE_BARRIER:\n\n        if (!ioreq->req.nr_segments)\n\n            break;\n\n\tpos = ioreq->start;\n\n\tfor (i = 0; i < ioreq->v.niov; i++) {\n\n\t    rc = bdrv_write(blkdev->bs, pos / BLOCK_SIZE,\n\n\t\t\t    ioreq->v.iov[i].iov_base,\n\n\t\t\t    ioreq->v.iov[i].iov_len / BLOCK_SIZE);\n\n\t    if (rc != 0) {\n\n\t\txen_be_printf(&blkdev->xendev, 0, \"wr I/O error (%p, len %zd)\\n\",\n\n\t\t\t      ioreq->v.iov[i].iov_base,\n\n\t\t\t      ioreq->v.iov[i].iov_len);\n\n\t\tgoto err;\n\n\t    }\n\n\t    len += ioreq->v.iov[i].iov_len;\n\n\t    pos += ioreq->v.iov[i].iov_len;\n\n\t}\n\n\tbreak;\n\n    default:\n\n\t/* unknown operation (shouldn't happen -- parse catches this) */\n\n\tgoto err;\n\n    }\n\n\n\n    if (ioreq->postsync)\n\n\tbdrv_flush(blkdev->bs);\n\n    ioreq->status = BLKIF_RSP_OKAY;\n\n\n\n    ioreq_unmap(ioreq);\n\n    ioreq_finish(ioreq);\n\n    return 0;\n\n\n\nerr:\n\n    ioreq->status = BLKIF_RSP_ERROR;\n\n    return -1;\n\n}\n", "idx": 1601}
{"project": "qemu", "commit_id": "a973001797221b0fd7be55cb6513c72a01f4b639", "target": 1, "func": "static always_inline void gen_op_arith_compute_ca(DisasContext *ctx, TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    int l1 = gen_new_label();\n\n\n\n#if defined(TARGET_PPC64)\n\n    if (!(ctx->sf_mode)) {\n\n        TCGv t0, t1;\n\n        t0 = tcg_temp_new(TCG_TYPE_TL);\n\n        t1 = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n        tcg_gen_ext32u_tl(t0, arg1);\n\n        tcg_gen_ext32u_tl(t1, arg2);\n\n        if (sub) {\n\n            tcg_gen_brcond_tl(TCG_COND_GTU, t0, t1, l1);\n\n        } else {\n\n            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);\n\n        }\n\n    } else\n\n#endif\n\n    if (sub) {\n\n        tcg_gen_brcond_tl(TCG_COND_GTU, arg1, arg2, l1);\n\n    } else {\n\n        tcg_gen_brcond_tl(TCG_COND_GEU, arg1, arg2, l1);\n\n    }\n\n    tcg_gen_ori_tl(cpu_xer, cpu_xer, 1 << XER_CA);\n\n    gen_set_label(l1);\n\n}\n", "idx": 4354}
{"project": "qemu", "commit_id": "bd88c780e6a17188f7fd676f3a056e5db21500e0", "target": 1, "func": "static void *clone_func(void *arg)\n\n{\n\n    new_thread_info *info = arg;\n\n    CPUArchState *env;\n\n    CPUState *cpu;\n\n    TaskState *ts;\n\n\n\n    rcu_register_thread();\n\n    env = info->env;\n\n    cpu = ENV_GET_CPU(env);\n\n    thread_cpu = cpu;\n\n    ts = (TaskState *)cpu->opaque;\n\n    info->tid = gettid();\n\n    cpu->host_tid = info->tid;\n\n    task_settid(ts);\n\n    if (info->child_tidptr)\n\n        put_user_u32(info->tid, info->child_tidptr);\n\n    if (info->parent_tidptr)\n\n        put_user_u32(info->tid, info->parent_tidptr);\n\n    /* Enable signals.  */\n\n    sigprocmask(SIG_SETMASK, &info->sigmask, NULL);\n\n    /* Signal to the parent that we're ready.  */\n\n    pthread_mutex_lock(&info->mutex);\n\n    pthread_cond_broadcast(&info->cond);\n\n    pthread_mutex_unlock(&info->mutex);\n\n    /* Wait until the parent has finshed initializing the tls state.  */\n\n    pthread_mutex_lock(&clone_lock);\n\n    pthread_mutex_unlock(&clone_lock);\n\n    cpu_loop(env);\n\n    /* never exits */\n\n    return NULL;\n\n}\n", "idx": 367}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static int stellaris_enet_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n\n                          \"stellaris_enet\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->mmio);\n\n    sysbus_init_irq(sbd, &s->irq);\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n\n\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n\n\n    stellaris_enet_reset(s);\n\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n\n                    stellaris_enet_save, stellaris_enet_load, s);\n\n    return 0;\n\n}\n", "idx": 11984}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void send_ext_audio_ack(VncState *vs)\n\n{\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n    vnc_write_u8(vs, 0);\n\n    vnc_write_u16(vs, 1);\n\n    vnc_framebuffer_update(vs, 0, 0,\n\n                           surface_width(vs->vd->ds),\n\n                           surface_height(vs->vd->ds),\n\n                           VNC_ENCODING_AUDIO);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 5150}
{"project": "qemu", "commit_id": "23802b4fe0cf5821b72aa5bc682e38c8c91bb168", "target": 1, "func": "void qtest_init(const char *qtest_chrdev, const char *qtest_log)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    chr = qemu_chr_new(\"qtest\", qtest_chrdev, NULL);\n\n\n\n    qemu_chr_add_handlers(chr, qtest_can_read, qtest_read, qtest_event, chr);\n\n    qemu_chr_fe_set_echo(chr, true);\n\n\n\n    inbuf = g_string_new(\"\");\n\n\n\n    if (qtest_log) {\n\n        if (strcmp(qtest_log, \"none\") != 0) {\n\n            qtest_log_fp = fopen(qtest_log, \"w+\");\n\n        }\n\n    } else {\n\n        qtest_log_fp = stderr;\n\n    }\n\n\n\n    qtest_chr = chr;\n\n}\n", "idx": 1192}
{"project": "qemu", "commit_id": "89cad9f3ec6b30d7550fb5704475fc9c3393a066", "target": 1, "func": "static void process_event(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    GAState *s = container_of(parser, GAState, parser);\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    g_assert(s && parser);\n\n\n\n    g_debug(\"process_event: called\");\n\n    obj = json_parser_parse_err(tokens, NULL, &err);\n\n    if (err || !obj || qobject_type(obj) != QTYPE_QDICT) {\n\n        qobject_decref(obj);\n\n        qdict = qdict_new();\n\n        if (!err) {\n\n            g_warning(\"failed to parse event: unknown error\");\n\n            error_setg(&err, QERR_JSON_PARSING);\n\n        } else {\n\n            g_warning(\"failed to parse event: %s\", error_get_pretty(err));\n\n        }\n\n        qdict_put_obj(qdict, \"error\", qmp_build_error_object(err));\n\n        error_free(err);\n\n    } else {\n\n        qdict = qobject_to_qdict(obj);\n\n    }\n\n\n\n    g_assert(qdict);\n\n\n\n    /* handle host->guest commands */\n\n    if (qdict_haskey(qdict, \"execute\")) {\n\n        process_command(s, qdict);\n\n    } else {\n\n        if (!qdict_haskey(qdict, \"error\")) {\n\n            QDECREF(qdict);\n\n            qdict = qdict_new();\n\n            g_warning(\"unrecognized payload format\");\n\n            error_setg(&err, QERR_UNSUPPORTED);\n\n            qdict_put_obj(qdict, \"error\", qmp_build_error_object(err));\n\n            error_free(err);\n\n        }\n\n        ret = send_response(s, QOBJECT(qdict));\n\n        if (ret < 0) {\n\n            g_warning(\"error sending error response: %s\", strerror(-ret));\n\n        }\n\n    }\n\n\n\n    QDECREF(qdict);\n\n}\n", "idx": 8842}
{"project": "qemu", "commit_id": "78a52ad5acca7053b774fcc80290e7b7e224c80a", "target": 1, "func": "static int count_contiguous_clusters(uint64_t nb_clusters, int cluster_size,\n\n        uint64_t *l2_table, uint64_t stop_flags)\n\n{\n\n    int i;\n\n    uint64_t mask = stop_flags | L2E_OFFSET_MASK | QCOW2_CLUSTER_COMPRESSED;\n\n    uint64_t first_entry = be64_to_cpu(l2_table[0]);\n\n    uint64_t offset = first_entry & mask;\n\n\n\n    if (!offset)\n\n        return 0;\n\n\n\n    assert(qcow2_get_cluster_type(first_entry) != QCOW2_CLUSTER_COMPRESSED);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t l2_entry = be64_to_cpu(l2_table[i]) & mask;\n\n        if (offset + (uint64_t) i * cluster_size != l2_entry) {\n\n            break;\n\n        }\n\n    }\n\n\n\n\treturn i;\n\n}\n", "idx": 9221}
{"project": "qemu", "commit_id": "ae392c416c69a020226c768d9c3af08b29dd6d96", "target": 1, "func": "static int msix_is_masked(PCIDevice *dev, int vector)\n\n{\n\n    unsigned offset =\n\n        vector * PCI_MSIX_ENTRY_SIZE + PCI_MSIX_ENTRY_VECTOR_CTRL;\n\n    return dev->msix_function_masked ||\n\n\t   dev->msix_table_page[offset] & PCI_MSIX_ENTRY_CTRL_MASKBIT;\n\n}\n", "idx": 1738}
{"project": "qemu", "commit_id": "84cab1e2f5be3ea6eaa65c9fc0422fb992946ce0", "target": 1, "func": "static void gen_std(DisasContext *ctx)\n\n{\n\n    int rs;\n\n    TCGv EA;\n\n\n\n    rs = rS(ctx->opcode);\n\n    if ((ctx->opcode & 0x3) == 0x2) {\n\n#if defined(CONFIG_USER_ONLY)\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n        /* stq */\n\n        if (unlikely(ctx->mem_idx == 0)) {\n\n            gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n            return;\n\n        }\n\n        if (unlikely(rs & 1)) {\n\n            gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n            return;\n\n        }\n\n        if (unlikely(ctx->le_mode)) {\n\n            /* Little-endian mode is not handled */\n\n            gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n            return;\n\n        }\n\n        gen_set_access_type(ctx, ACCESS_INT);\n\n        EA = tcg_temp_new();\n\n        gen_addr_imm_index(ctx, EA, 0x03);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs], EA);\n\n        gen_addr_add(ctx, EA, EA, 8);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs+1], EA);\n\n        tcg_temp_free(EA);\n\n#endif\n\n    } else {\n\n        /* std / stdu */\n\n        if (Rc(ctx->opcode)) {\n\n            if (unlikely(rA(ctx->opcode) == 0)) {\n\n                gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n                return;\n\n            }\n\n        }\n\n        gen_set_access_type(ctx, ACCESS_INT);\n\n        EA = tcg_temp_new();\n\n        gen_addr_imm_index(ctx, EA, 0x03);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs], EA);\n\n        if (Rc(ctx->opcode))\n\n            tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], EA);\n\n        tcg_temp_free(EA);\n\n    }\n\n}\n", "idx": 9199}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void ram_control_after_iterate(QEMUFile *f, uint64_t flags)\n\n{\n\n    int ret = 0;\n\n\n\n    if (f->ops->after_ram_iterate) {\n\n        ret = f->ops->after_ram_iterate(f, f->opaque, flags);\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n    }\n\n}\n", "idx": 2206}
{"project": "qemu", "commit_id": "0d07fe47d4986271a21ed4ff5237275ff55dd93f", "target": 1, "func": "static inline abi_long do_msgrcv(int msqid, abi_long msgp,\n\n                                 unsigned int msgsz, abi_long msgtyp,\n\n                                 int msgflg)\n\n{\n\n    struct target_msgbuf *target_mb;\n\n    char *target_mtext;\n\n    struct msgbuf *host_mb;\n\n    abi_long ret = 0;\n\n\n\n    if (!lock_user_struct(VERIFY_WRITE, target_mb, msgp, 0))\n\n        return -TARGET_EFAULT;\n\n\n\n    host_mb = malloc(msgsz+sizeof(long));\n\n    ret = get_errno(msgrcv(msqid, host_mb, msgsz, tswapal(msgtyp), msgflg));\n\n\n\n    if (ret > 0) {\n\n        abi_ulong target_mtext_addr = msgp + sizeof(abi_ulong);\n\n        target_mtext = lock_user(VERIFY_WRITE, target_mtext_addr, ret, 0);\n\n        if (!target_mtext) {\n\n            ret = -TARGET_EFAULT;\n\n            goto end;\n\n        }\n\n        memcpy(target_mb->mtext, host_mb->mtext, ret);\n\n        unlock_user(target_mtext, target_mtext_addr, ret);\n\n    }\n\n\n\n    target_mb->mtype = tswapal(host_mb->mtype);\n\n    free(host_mb);\n\n\n\nend:\n\n    if (target_mb)\n\n        unlock_user_struct(target_mb, msgp, 1);\n\n    return ret;\n\n}\n", "idx": 9517}
{"project": "qemu", "commit_id": "e7bab9a256d653948760ef9f3d04f14eb2a81731", "target": 1, "func": "static int cpu_post_load(void *opaque, int version_id)\n\n{\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    target_ulong msr;\n\n\n\n    /*\n\n     * If we're operating in compat mode, we should be ok as long as\n\n     * the destination supports the same compatiblity mode.\n\n     *\n\n     * Otherwise, however, we require that the destination has exactly\n\n     * the same CPU model as the source.\n\n     */\n\n\n\n#if defined(TARGET_PPC64)\n\n    if (cpu->compat_pvr) {\n\n        Error *local_err = NULL;\n\n\n\n        ppc_set_compat(cpu, cpu->compat_pvr, &local_err);\n\n        if (local_err) {\n\n            error_report_err(local_err);\n\n            error_free(local_err);\n\n            return -1;\n\n        }\n\n    } else\n\n#endif\n\n    {\n\n        if (!pvr_match(cpu, env->spr[SPR_PVR])) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    env->lr = env->spr[SPR_LR];\n\n    env->ctr = env->spr[SPR_CTR];\n\n    cpu_write_xer(env, env->spr[SPR_XER]);\n\n#if defined(TARGET_PPC64)\n\n    env->cfar = env->spr[SPR_CFAR];\n\n#endif\n\n    env->spe_fscr = env->spr[SPR_BOOKE_SPEFSCR];\n\n\n\n    for (i = 0; (i < 4) && (i < env->nb_BATs); i++) {\n\n        env->DBAT[0][i] = env->spr[SPR_DBAT0U + 2*i];\n\n        env->DBAT[1][i] = env->spr[SPR_DBAT0U + 2*i + 1];\n\n        env->IBAT[0][i] = env->spr[SPR_IBAT0U + 2*i];\n\n        env->IBAT[1][i] = env->spr[SPR_IBAT0U + 2*i + 1];\n\n    }\n\n    for (i = 0; (i < 4) && ((i+4) < env->nb_BATs); i++) {\n\n        env->DBAT[0][i+4] = env->spr[SPR_DBAT4U + 2*i];\n\n        env->DBAT[1][i+4] = env->spr[SPR_DBAT4U + 2*i + 1];\n\n        env->IBAT[0][i+4] = env->spr[SPR_IBAT4U + 2*i];\n\n        env->IBAT[1][i+4] = env->spr[SPR_IBAT4U + 2*i + 1];\n\n    }\n\n\n\n    if (!cpu->vhyp) {\n\n        ppc_store_sdr1(env, env->spr[SPR_SDR1]);\n\n    }\n\n\n\n    /* Invalidate all msr bits except MSR_TGPR/MSR_HVB before restoring */\n\n    msr = env->msr;\n\n    env->msr ^= ~((1ULL << MSR_TGPR) | MSR_HVB);\n\n    ppc_store_msr(env, msr);\n\n\n\n    hreg_compute_mem_idx(env);\n\n\n\n    return 0;\n\n}\n", "idx": 4759}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void arm_sysctl_init(uint32_t base, uint32_t sys_id)\n\n{\n\n    arm_sysctl_state *s;\n\n    int iomemtype;\n\n\n\n    s = (arm_sysctl_state *)qemu_mallocz(sizeof(arm_sysctl_state));\n\n    if (!s)\n\n        return;\n\n    s->base = base;\n\n    s->sys_id = sys_id;\n\n    iomemtype = cpu_register_io_memory(0, arm_sysctl_readfn,\n\n                                       arm_sysctl_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 8695}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 2928}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 3956}
{"project": "qemu", "commit_id": "8c0a6dc96cd14c48da4a61fe35431f36d6e6e467", "target": 1, "func": "static void test_hmac_speed(const void *opaque)\n\n{\n\n    size_t chunk_size = (size_t)opaque;\n\n    QCryptoHmac *hmac = NULL;\n\n    uint8_t *in = NULL, *out = NULL;\n\n    size_t out_len = 0;\n\n    double total = 0.0;\n\n    struct iovec iov;\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    if (!qcrypto_hmac_supports(QCRYPTO_HASH_ALG_SHA256)) {\n\n        return;\n\n    }\n\n\n\n    in = g_new0(uint8_t, chunk_size);\n\n    memset(in, g_test_rand_int(), chunk_size);\n\n\n\n    iov.iov_base = (char *)in;\n\n    iov.iov_len = chunk_size;\n\n\n\n    g_test_timer_start();\n\n    do {\n\n        hmac = qcrypto_hmac_new(QCRYPTO_HASH_ALG_SHA256,\n\n                                (const uint8_t *)KEY, strlen(KEY), &err);\n\n        g_assert(err == NULL);\n\n        g_assert(hmac != NULL);\n\n\n\n        ret = qcrypto_hmac_bytesv(hmac, &iov, 1, &out, &out_len, &err);\n\n        g_assert(ret == 0);\n\n        g_assert(err == NULL);\n\n\n\n        qcrypto_hmac_free(hmac);\n\n\n\n        total += chunk_size;\n\n    } while (g_test_timer_elapsed() < 5.0);\n\n\n\n    total /= 1024 * 1024; /* to MB */\n\n\n\n    g_print(\"hmac(sha256): \");\n\n    g_print(\"Testing chunk_size %ld bytes \", chunk_size);\n\n    g_print(\"done: %.2f MB in %.2f secs: \", total, g_test_timer_last());\n\n    g_print(\"%.2f MB/sec\\n\", total / g_test_timer_last());\n\n\n\n    g_free(out);\n\n    g_free(in);\n\n}\n", "idx": 4105}
{"project": "qemu", "commit_id": "51c1ebb1bc2642296379a8db1ba9dfb4f78a2f80", "target": 1, "func": "int32_t scsi_send_command(SCSIDevice *s, uint32_t tag, uint8_t *buf, int lun)\n\n{\n\n    int64_t nb_sectors;\n\n    uint32_t lba;\n\n    uint32_t len;\n\n    int cmdlen;\n\n    int is_write;\n\n\n\n    s->command = buf[0];\n\n    s->tag = tag;\n\n    s->sector_count = 0;\n\n    s->buf_pos = 0;\n\n    s->buf_len = 0;\n\n    is_write = 0;\n\n    DPRINTF(\"Command: 0x%02x\", buf[0]);\n\n    switch (s->command >> 5) {\n\n    case 0:\n\n        lba = buf[3] | (buf[2] << 8) | ((buf[1] & 0x1f) << 16);\n\n        len = buf[4];\n\n        cmdlen = 6;\n\n        break;\n\n    case 1:\n\n    case 2:\n\n        lba = buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24);\n\n        len = buf[8] | (buf[7] << 8);\n\n        cmdlen = 10;\n\n        break;\n\n    case 4:\n\n        lba = buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24);\n\n        len = buf[13] | (buf[12] << 8) | (buf[11] << 16) | (buf[10] << 24);\n\n        cmdlen = 16;\n\n        break;\n\n    case 5:\n\n        lba = buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24);\n\n        len = buf[9] | (buf[8] << 8) | (buf[7] << 16) | (buf[6] << 24);\n\n        cmdlen = 12;\n\n        break;\n\n    default:\n\n        BADF(\"Unsupported command length, command %x\\n\", s->command);\n\n        goto fail;\n\n    }\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < cmdlen; i++) {\n\n            printf(\" 0x%02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n    if (lun || buf[1] >> 5) {\n\n        /* Only LUN 0 supported.  */\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", lun ? lun : buf[1] >> 5);\n\n        goto fail;\n\n    }\n\n    switch (s->command) {\n\n    case 0x0:\n\n\tDPRINTF(\"Test Unit Ready\\n\");\n\n\tbreak;\n\n    case 0x03:\n\n        DPRINTF(\"Request Sense (len %d)\\n\", len);\n\n        if (len < 4)\n\n            goto fail;\n\n        memset(buf, 0, 4);\n\n        s->buf[0] = 0xf0;\n\n        s->buf[1] = 0;\n\n        s->buf[2] = s->sense;\n\n        s->buf_len = 4;\n\n        break;\n\n    case 0x12:\n\n        DPRINTF(\"Inquiry (len %d)\\n\", len);\n\n        if (len < 36) {\n\n            BADF(\"Inquiry buffer too small (%d)\\n\", len);\n\n        }\n\n\tmemset(s->buf, 0, 36);\n\n\tif (bdrv_get_type_hint(s->bdrv) == BDRV_TYPE_CDROM) {\n\n\t    s->buf[0] = 5;\n\n            s->buf[1] = 0x80;\n\n\t    memcpy(&s->buf[16], \"QEMU CD-ROM    \", 16);\n\n\t} else {\n\n\t    s->buf[0] = 0;\n\n\t    memcpy(&s->buf[16], \"QEMU HARDDISK  \", 16);\n\n\t}\n\n\tmemcpy(&s->buf[8], \"QEMU   \", 8);\n\n        memcpy(&s->buf[32], QEMU_VERSION, 4);\n\n        /* Identify device as SCSI-3 rev 1.\n\n           Some later commands are also implemented. */\n\n\ts->buf[2] = 3;\n\n\ts->buf[3] = 2; /* Format 2 */\n\n\ts->buf[4] = 32;\n\n\ts->buf_len = 36;\n\n\tbreak;\n\n    case 0x16:\n\n        DPRINTF(\"Reserve(6)\\n\");\n\n        if (buf[1] & 1)\n\n            goto fail;\n\n        break;\n\n    case 0x17:\n\n        DPRINTF(\"Release(6)\\n\");\n\n        if (buf[1] & 1)\n\n            goto fail;\n\n        break;\n\n    case 0x1a:\n\n    case 0x5a:\n\n        {\n\n            char *p;\n\n            int page;\n\n\n\n            page = buf[2] & 0x3f;\n\n            DPRINTF(\"Mode Sense (page %d, len %d)\\n\", page, len);\n\n            p = s->buf;\n\n            memset(p, 0, 4);\n\n            s->buf[1] = 0; /* Default media type.  */\n\n            s->buf[3] = 0; /* Block descriptor length.  */\n\n            if (bdrv_get_type_hint(s->bdrv) == BDRV_TYPE_CDROM) {\n\n                s->buf[2] = 0x80; /* Readonly.  */\n\n            }\n\n            p += 4;\n\n            if ((page == 8 || page == 0x3f)) {\n\n                /* Caching page.  */\n\n                p[0] = 8;\n\n                p[1] = 0x12;\n\n                p[2] = 4; /* WCE */\n\n                p += 19;\n\n            }\n\n            if ((page == 0x3f || page == 0x2a)\n\n                    && (bdrv_get_type_hint(s->bdrv) == BDRV_TYPE_CDROM)) {\n\n                /* CD Capabilities and Mechanical Status page. */\n\n                p[0] = 0x2a;\n\n                p[1] = 0x14;\n\n                p[2] = 3; // CD-R & CD-RW read\n\n                p[3] = 0; // Writing not supported\n\n                p[4] = 0x7f; /* Audio, composite, digital out,\n\n                                         mode 2 form 1&2, multi session */\n\n                p[5] = 0xff; /* CD DA, DA accurate, RW supported,\n\n                                         RW corrected, C2 errors, ISRC,\n\n                                         UPC, Bar code */\n\n                p[6] = 0x2d | (bdrv_is_locked(s->bdrv)? 2 : 0);\n\n                /* Locking supported, jumper present, eject, tray */\n\n                p[7] = 0; /* no volume & mute control, no\n\n                                      changer */\n\n                p[8] = (50 * 176) >> 8; // 50x read speed\n\n                p[9] = (50 * 176) & 0xff;\n\n                p[10] = 0 >> 8; // No volume\n\n                p[11] = 0 & 0xff;\n\n                p[12] = 2048 >> 8; // 2M buffer\n\n                p[13] = 2048 & 0xff;\n\n                p[14] = (16 * 176) >> 8; // 16x read speed current\n\n                p[15] = (16 * 176) & 0xff;\n\n                p[18] = (16 * 176) >> 8; // 16x write speed\n\n                p[19] = (16 * 176) & 0xff;\n\n                p[20] = (16 * 176) >> 8; // 16x write speed current\n\n                p[21] = (16 * 176) & 0xff;\n\n                p += 21;\n\n            }\n\n            s->buf_len = p - s->buf;\n\n            s->buf[0] = s->buf_len - 4;\n\n            if (s->buf_len > len)\n\n                s->buf_len = len;\n\n        }\n\n        break;\n\n    case 0x1b:\n\n        DPRINTF(\"Start Stop Unit\\n\");\n\n\tbreak;\n\n    case 0x1e:\n\n        DPRINTF(\"Prevent Allow Medium Removal (prevent = %d)\\n\", buf[4] & 3);\n\n        bdrv_set_locked(s->bdrv, buf[4] & 1);\n\n\tbreak;\n\n    case 0x25:\n\n\tDPRINTF(\"Read Capacity\\n\");\n\n        /* The normal LEN field for this command is zero.  */\n\n\tmemset(s->buf, 0, 8);\n\n\tbdrv_get_geometry(s->bdrv, &nb_sectors);\n\n\ts->buf[0] = (nb_sectors >> 24) & 0xff;\n\n\ts->buf[1] = (nb_sectors >> 16) & 0xff;\n\n\ts->buf[2] = (nb_sectors >> 8) & 0xff;\n\n\ts->buf[3] = nb_sectors & 0xff;\n\n\ts->buf[4] = 0;\n\n\ts->buf[5] = 0;\n\n        s->buf[6] = s->cluster_size * 2;\n\n\ts->buf[7] = 0;\n\n\ts->buf_len = 8;\n\n\tbreak;\n\n    case 0x08:\n\n    case 0x28:\n\n        DPRINTF(\"Read (sector %d, count %d)\\n\", lba, len);\n\n        s->sector = lba * s->cluster_size;\n\n        s->sector_count = len * s->cluster_size;\n\n        break;\n\n    case 0x0a:\n\n    case 0x2a:\n\n        DPRINTF(\"Write (sector %d, count %d)\\n\", lba, len);\n\n        s->sector = lba * s->cluster_size;\n\n        s->sector_count = len * s->cluster_size;\n\n        is_write = 1;\n\n        break;\n\n    case 0x35:\n\n        DPRINTF(\"Syncronise cache (sector %d, count %d)\\n\", lba, len);\n\n        bdrv_flush(s->bdrv);\n\n        break;\n\n    case 0x43:\n\n        {\n\n            int start_track, format, msf, toclen;\n\n\n\n            msf = buf[1] & 2;\n\n            format = buf[2] & 0xf;\n\n            start_track = buf[6];\n\n            bdrv_get_geometry(s->bdrv, &nb_sectors);\n\n            DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n            switch(format) {\n\n            case 0:\n\n                toclen = cdrom_read_toc(nb_sectors, s->buf, msf, start_track);\n\n                break;\n\n            case 1:\n\n                /* multi session : only a single session defined */\n\n                toclen = 12;\n\n                memset(s->buf, 0, 12);\n\n                s->buf[1] = 0x0a;\n\n                s->buf[2] = 0x01;\n\n                s->buf[3] = 0x01;\n\n                break;\n\n            case 2:\n\n                toclen = cdrom_read_toc_raw(nb_sectors, s->buf, msf, start_track);\n\n                break;\n\n            default:\n\n                goto error_cmd;\n\n            }\n\n            if (toclen > 0) {\n\n                if (len > toclen)\n\n                  len = toclen;\n\n                s->buf_len = len;\n\n                break;\n\n            }\n\n        error_cmd:\n\n            DPRINTF(\"Read TOC error\\n\");\n\n            goto fail;\n\n        }\n\n    case 0x46:\n\n        DPRINTF(\"Get Configuration (rt %d, maxlen %d)\\n\", buf[1] & 3, len);\n\n        memset(s->buf, 0, 8);\n\n        /* ??? This shoud probably return much more information.  For now\n\n           just return the basic header indicating the CD-ROM profile.  */\n\n        s->buf[7] = 8; // CD-ROM\n\n        s->buf_len = 8;\n\n        break;\n\n    case 0x56:\n\n        DPRINTF(\"Reserve(10)\\n\");\n\n        if (buf[1] & 3)\n\n            goto fail;\n\n        break;\n\n    case 0x57:\n\n        DPRINTF(\"Release(10)\\n\");\n\n        if (buf[1] & 3)\n\n            goto fail;\n\n        break;\n\n    case 0xa0:\n\n        DPRINTF(\"Report LUNs (len %d)\\n\", len);\n\n        if (len < 16)\n\n            goto fail;\n\n        memset(s->buf, 0, 16);\n\n        s->buf[3] = 8;\n\n        s->buf_len = 16;\n\n        break;\n\n    default:\n\n\tDPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n\n    fail:\n\n        scsi_command_complete(s, SENSE_ILLEGAL_REQUEST);\n\n\treturn 0;\n\n    }\n\n    if (s->sector_count == 0 && s->buf_len == 0) {\n\n        scsi_command_complete(s, SENSE_NO_SENSE);\n\n    }\n\n    len = s->sector_count * 512 + s->buf_len;\n\n    return is_write ? -len : len;\n\n}\n", "idx": 1569}
{"project": "qemu", "commit_id": "72f0d0bf51362011c4d841a89fb8f5cfb16e0bf3", "target": 1, "func": "static int mp_dacl_removexattr(FsContext *ctx,\n\n                               const char *path, const char *name)\n\n{\n\n    int ret;\n\n    char *buffer;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret  = lremovexattr(buffer, MAP_ACL_DEFAULT);\n\n    if (ret == -1 && errno == ENODATA) {\n\n        /*\n\n         * We don't get ENODATA error when trying to remove a\n\n         * posix acl that is not present. So don't throw the error\n\n         * even in case of mapped security model\n\n         */\n\n        errno = 0;\n\n        ret = 0;\n\n    }\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 10641}
{"project": "qemu", "commit_id": "027d9a7d2911e993cdcbd21c7c35d1dd058f05bb", "target": 1, "func": "void cpu_exit(CPUState *cpu)\n\n{\n\n    cpu->exit_request = 1;\n\n    /* Ensure cpu_exec will see the exit request after TCG has exited.  */\n\n    smp_wmb();\n\n    cpu->tcg_exit_req = 1;\n\n}\n", "idx": 3}
{"project": "qemu", "commit_id": "5cb9b56acfc0b50acf7ccd2d044ab4991c47fdde", "target": 1, "func": "static int parse_vlan(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    VLANState **ptr = qdev_get_prop_ptr(dev, prop);\n\n    int id;\n\n\n\n    if (sscanf(str, \"%d\", &id) != 1)\n\n        return -EINVAL;\n\n    *ptr = qemu_find_vlan(id, 1);\n\n    if (*ptr == NULL)\n\n        return -ENOENT;\n\n    return 0;\n\n}\n", "idx": 6639}
{"project": "qemu", "commit_id": "25f2895e0e437a3548f9794846001fb5d5ab853d", "target": 1, "func": "void kvm_arm_reset_vcpu(ARMCPU *cpu)\n\n{\n\n    /* Re-init VCPU so that all registers are set to\n\n     * their respective reset values.\n\n     */\n\n    kvm_arm_vcpu_init(CPU(cpu));\n\n    write_kvmstate_to_list(cpu);\n\n}\n", "idx": 9359}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void host_x86_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    X86CPUClass *xcc = X86_CPU_CLASS(oc);\n\n    uint32_t eax = 0, ebx = 0, ecx = 0, edx = 0;\n\n\n\n    xcc->kvm_required = true;\n\n\n\n    host_cpuid(0x0, 0, &eax, &ebx, &ecx, &edx);\n\n    x86_cpu_vendor_words2str(host_cpudef.vendor, ebx, edx, ecx);\n\n\n\n    host_cpuid(0x1, 0, &eax, &ebx, &ecx, &edx);\n\n    host_cpudef.family = ((eax >> 8) & 0x0F) + ((eax >> 20) & 0xFF);\n\n    host_cpudef.model = ((eax >> 4) & 0x0F) | ((eax & 0xF0000) >> 12);\n\n    host_cpudef.stepping = eax & 0x0F;\n\n\n\n    cpu_x86_fill_model_id(host_cpudef.model_id);\n\n\n\n    xcc->cpu_def = &host_cpudef;\n\n    host_cpudef.cache_info_passthrough = true;\n\n\n\n    /* level, xlevel, xlevel2, and the feature words are initialized on\n\n     * instance_init, because they require KVM to be initialized.\n\n     */\n\n\n\n    dc->props = host_x86_cpu_properties;\n\n\n\n}", "idx": 10602}
{"project": "qemu", "commit_id": "b31f84126215e3fd4b8acbc3083ae30d407329e8", "target": 1, "func": "static void mtree_print_mr(fprintf_function mon_printf, void *f,\n\n                           const MemoryRegion *mr, unsigned int level,\n\n                           hwaddr base,\n\n                           MemoryRegionListHead *alias_print_queue)\n\n{\n\n    MemoryRegionList *new_ml, *ml, *next_ml;\n\n    MemoryRegionListHead submr_print_queue;\n\n    const MemoryRegion *submr;\n\n    unsigned int i;\n\n\n\n    if (!mr) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < level; i++) {\n\n        mon_printf(f, MTREE_INDENT);\n\n    }\n\n\n\n    if (mr->alias) {\n\n        MemoryRegionList *ml;\n\n        bool found = false;\n\n\n\n        /* check if the alias is already in the queue */\n\n        QTAILQ_FOREACH(ml, alias_print_queue, queue) {\n\n            if (ml->mr == mr->alias) {\n\n                found = true;\n\n            }\n\n        }\n\n\n\n        if (!found) {\n\n            ml = g_new(MemoryRegionList, 1);\n\n            ml->mr = mr->alias;\n\n            QTAILQ_INSERT_TAIL(alias_print_queue, ml, queue);\n\n        }\n\n        mon_printf(f, TARGET_FMT_plx \"-\" TARGET_FMT_plx\n\n                   \" (prio %d, %s): alias %s @%s \" TARGET_FMT_plx\n\n                   \"-\" TARGET_FMT_plx \"%s\\n\",\n\n                   base + mr->addr,\n\n                   base + mr->addr + MR_SIZE(mr->size),\n\n                   mr->priority,\n\n                   memory_region_type((MemoryRegion *)mr),\n\n                   memory_region_name(mr),\n\n                   memory_region_name(mr->alias),\n\n                   mr->alias_offset,\n\n                   mr->alias_offset + MR_SIZE(mr->size),\n\n                   mr->enabled ? \"\" : \" [disabled]\");\n\n    } else {\n\n        mon_printf(f,\n\n                   TARGET_FMT_plx \"-\" TARGET_FMT_plx \" (prio %d, %s): %s%s\\n\",\n\n                   base + mr->addr,\n\n                   base + mr->addr + MR_SIZE(mr->size),\n\n                   mr->priority,\n\n                   memory_region_type((MemoryRegion *)mr),\n\n                   memory_region_name(mr),\n\n                   mr->enabled ? \"\" : \" [disabled]\");\n\n    }\n\n\n\n    QTAILQ_INIT(&submr_print_queue);\n\n\n\n    QTAILQ_FOREACH(submr, &mr->subregions, subregions_link) {\n\n        new_ml = g_new(MemoryRegionList, 1);\n\n        new_ml->mr = submr;\n\n        QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n\n            if (new_ml->mr->addr < ml->mr->addr ||\n\n                (new_ml->mr->addr == ml->mr->addr &&\n\n                 new_ml->mr->priority > ml->mr->priority)) {\n\n                QTAILQ_INSERT_BEFORE(ml, new_ml, queue);\n\n                new_ml = NULL;\n\n                break;\n\n            }\n\n        }\n\n        if (new_ml) {\n\n            QTAILQ_INSERT_TAIL(&submr_print_queue, new_ml, queue);\n\n        }\n\n    }\n\n\n\n    QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n\n        mtree_print_mr(mon_printf, f, ml->mr, level + 1, base + mr->addr,\n\n                       alias_print_queue);\n\n    }\n\n\n\n    QTAILQ_FOREACH_SAFE(ml, &submr_print_queue, queue, next_ml) {\n\n        g_free(ml);\n\n    }\n\n}\n", "idx": 1792}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "void vnc_init_state(VncState *vs)\n\n{\n\n    vs->initialized = true;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    vs->last_x = -1;\n\n    vs->last_y = -1;\n\n\n\n    vs->as.freq = 44100;\n\n    vs->as.nchannels = 2;\n\n    vs->as.fmt = AUD_FMT_S16;\n\n    vs->as.endianness = 0;\n\n\n\n    qemu_mutex_init(&vs->output_mutex);\n\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n\n\n    QTAILQ_INSERT_HEAD(&vd->clients, vs, next);\n\n\n\n    graphic_hw_update(vd->dcl.con);\n\n\n\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_version, 12);\n\n    reset_keys(vs);\n\n    if (vs->vd->lock_key_sync)\n\n        vs->led = qemu_add_led_event_handler(kbd_leds, vs);\n\n\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n\n\n    /* vs might be free()ed here */\n\n}\n", "idx": 1861}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 939}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static void htab_save_first_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                 int64_t max_ns)\n\n{\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart;\n\n\n\n        /* Consume invalid HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n\n\n        /* Consume valid HPTEs */\n\n        chunkstart = index;\n\n        while ((index < htabslots)\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = index - chunkstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, 0);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n\n\n            if ((qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n    } while ((index < htabslots) && !qemu_file_rate_limit(f));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n        spapr->htab_first_pass = false;\n\n    }\n\n    spapr->htab_save_index = index;\n\n}\n", "idx": 4430}
{"project": "qemu", "commit_id": "0fbc20740342713f282b118b4a446c4c43df3f4a", "target": 1, "func": "void kvm_irqchip_add_irq_route(KVMState *s, int irq, int irqchip, int pin)\n\n{\n\n    struct kvm_irq_routing_entry e;\n\n\n\n    assert(pin < s->gsi_count);\n\n\n\n    e.gsi = irq;\n\n    e.type = KVM_IRQ_ROUTING_IRQCHIP;\n\n    e.flags = 0;\n\n    e.u.irqchip.irqchip = irqchip;\n\n    e.u.irqchip.pin = pin;\n\n    kvm_add_routing_entry(s, &e);\n\n}\n", "idx": 6979}
{"project": "qemu", "commit_id": "b308c82cbda44e138ef990af64d44a5613c16092", "target": 1, "func": "static void pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIBus *parent = br->dev.bus;\n\n    uint16_t cmd = pci_get_word(br->dev.config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &br->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &br->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &br->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n   /* TODO: optinal VGA and VGA palette snooping support. */\n\n}\n", "idx": 5970}
{"project": "qemu", "commit_id": "7f87af39dc786a979e7ebba338d0781e366060ed", "target": 1, "func": "static void pc_isa_bios_init(MemoryRegion *rom_memory,\n\n                             MemoryRegion *flash_mem,\n\n                             int ram_size)\n\n{\n\n    int isa_bios_size;\n\n    MemoryRegion *isa_bios;\n\n    uint64_t flash_size;\n\n    void *flash_ptr, *isa_bios_ptr;\n\n\n\n    flash_size = memory_region_size(flash_mem);\n\n\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = flash_size;\n\n    if (isa_bios_size > (128 * 1024)) {\n\n        isa_bios_size = 128 * 1024;\n\n    }\n\n    isa_bios = g_malloc(sizeof(*isa_bios));\n\n    memory_region_init_ram(isa_bios, NULL, \"isa-bios\", isa_bios_size);\n\n    vmstate_register_ram_global(isa_bios);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        0x100000 - isa_bios_size,\n\n                                        isa_bios,\n\n                                        1);\n\n\n\n    /* copy ISA rom image from top of flash memory */\n\n    flash_ptr = memory_region_get_ram_ptr(flash_mem);\n\n    isa_bios_ptr = memory_region_get_ram_ptr(isa_bios);\n\n    memcpy(isa_bios_ptr,\n\n           ((uint8_t*)flash_ptr) + (flash_size - isa_bios_size),\n\n           isa_bios_size);\n\n\n\n    memory_region_set_readonly(isa_bios, true);\n\n}\n", "idx": 7649}
{"project": "qemu", "commit_id": "58a0067aa8bf1e3ccad4fc354b080502e63f9fb1", "target": 1, "func": "void replay_bh_schedule_event(QEMUBH *bh)\n\n{\n\n    if (replay_mode != REPLAY_MODE_NONE) {\n\n        uint64_t id = replay_get_current_step();\n\n        replay_add_event(REPLAY_ASYNC_EVENT_BH, bh, NULL, id);\n\n    } else {\n\n        qemu_bh_schedule(bh);\n\n    }\n\n}\n", "idx": 7680}
{"project": "qemu", "commit_id": "ed4f86e8b6eff8e600c69adee68c7cd34dd2cccb", "target": 1, "func": "int load_multiboot(FWCfgState *fw_cfg,\n                   FILE *f,\n                   const char *kernel_filename,\n                   const char *initrd_filename,\n                   const char *kernel_cmdline,\n                   int kernel_file_size,\n                   uint8_t *header)\n{\n    int i, is_multiboot = 0;\n    uint32_t flags = 0;\n    uint32_t mh_entry_addr;\n    uint32_t mh_load_addr;\n    uint32_t mb_kernel_size;\n    MultibootState mbs;\n    uint8_t bootinfo[MBI_SIZE];\n    uint8_t *mb_bootinfo_data;\n    uint32_t cmdline_len;\n    /* Ok, let's see if it is a multiboot image.\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n    for (i = 0; i < (8192 - 48); i += 4) {\n        if (ldl_p(header+i) == 0x1BADB002) {\n            uint32_t checksum = ldl_p(header+i+8);\n            flags = ldl_p(header+i+4);\n            checksum += flags;\n            checksum += (uint32_t)0x1BADB002;\n            if (!checksum) {\n                is_multiboot = 1;\n                break;\n    if (!is_multiboot)\n        return 0; /* no multiboot */\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n    memset(bootinfo, 0, sizeof(bootinfo));\n    memset(&mbs, 0, sizeof(mbs));\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n        uint64_t elf_entry;\n        uint64_t elf_low, elf_high;\n        int kernel_size;\n        fclose(f);\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n                               &elf_low, &elf_high, 0, I386_ELF_MACHINE,\n                               0, 0);\n        if (kernel_size < 0) {\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n        mh_load_addr = elf_low;\n        mb_kernel_size = elf_high - elf_low;\n        mh_entry_addr = elf_entry;\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n                  mb_kernel_size, (size_t)mh_entry_addr);\n    } else {\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n        mh_load_addr = ldl_p(header+i+16);\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n        uint32_t mb_load_size = 0;\n        mh_entry_addr = ldl_p(header+i+28);\n        if (mh_load_end_addr) {\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n        } else {\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n            mb_load_size = mb_kernel_size;\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n        uint32_t mh_width = ldl_p(header+i+36);\n        uint32_t mh_height = ldl_p(header+i+40);\n        uint32_t mh_depth = ldl_p(header+i+44); */\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n                 mb_load_size, mh_load_addr);\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n            fprintf(stderr, \"fread() failed\\n\");\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n        fclose(f);\n    mbs.mb_buf_phys = mh_load_addr;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n    /* Calculate space for cmdlines, bootloader name, and mb_mods */\n    cmdline_len = strlen(kernel_filename) + 1;\n    cmdline_len += strlen(kernel_cmdline) + 1;\n    if (initrd_filename) {\n        const char *r = initrd_filename;\n        cmdline_len += strlen(r) + 1;\n        mbs.mb_mods_avail = 1;\n        while (*(r = get_opt_value(NULL, 0, r))) {\n           mbs.mb_mods_avail++;\n           r++;\n    mbs.mb_buf_size += cmdline_len;\n    mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n    mbs.mb_buf_size += strlen(bootloader_name) + 1;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n    /* enlarge mb_buf to hold cmdlines, bootloader, mb-info structs */\n    mbs.mb_buf            = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n    mbs.offset_cmdlines   = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n    mbs.offset_bootloader = mbs.offset_cmdlines + cmdline_len;\n    if (initrd_filename) {\n        const char *next_initrd;\n        char not_last, tmpbuf[strlen(initrd_filename) + 1];\n        mbs.offset_mods = mbs.mb_buf_size;\n        do {\n            char *next_space;\n            int mb_mod_length;\n            uint32_t offs = mbs.mb_buf_size;\n            next_initrd = get_opt_value(tmpbuf, sizeof(tmpbuf), initrd_filename);\n            not_last = *next_initrd;\n            /* if a space comes after the module filename, treat everything\n               after that as parameters */\n            hwaddr c = mb_add_cmdline(&mbs, tmpbuf);\n            if ((next_space = strchr(tmpbuf, ' ')))\n                *next_space = '\\0';\n            mb_debug(\"multiboot loading module: %s\\n\", tmpbuf);\n            mb_mod_length = get_image_size(tmpbuf);\n            if (mb_mod_length < 0) {\n                fprintf(stderr, \"Failed to open file '%s'\\n\", tmpbuf);\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n            load_image(tmpbuf, (unsigned char *)mbs.mb_buf + offs);\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n                     (char *)mbs.mb_buf + offs,\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n            initrd_filename = next_initrd+1;\n        } while (not_last);\n    /* Commandline support */\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n             kernel_filename, kernel_cmdline);\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n    stl_p(bootinfo + MBI_BOOTLOADER, mb_add_bootloader(&mbs, bootloader_name));\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n    /* the kernel is where we want it to be now */\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n                                | MULTIBOOT_FLAGS_CMDLINE\n                                | MULTIBOOT_FLAGS_MODULES\n                                | MULTIBOOT_FLAGS_MMAP\n                                | MULTIBOOT_FLAGS_BOOTLOADER);\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n    /* save bootinfo off the stack */\n    mb_bootinfo_data = g_memdup(bootinfo, sizeof(bootinfo));\n    /* Pass variables to option rom */\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n                     mbs.mb_buf, mbs.mb_buf_size);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n                     sizeof(bootinfo));\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n    option_rom[nb_option_roms].bootindex = 0;\n    nb_option_roms++;\n    return 1; /* yes, we are multiboot */", "idx": 9215}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void spitz_i2c_setup(PXA2xxState *cpu)\n\n{\n\n    /* Attach the CPU on one end of our I2C bus.  */\n\n    I2CBus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);\n\n\n\n    DeviceState *wm;\n\n\n\n    /* Attach a WM8750 to the bus */\n\n    wm = i2c_create_slave(bus, \"wm8750\", 0);\n\n\n\n    spitz_wm8750_addr(wm, 0, 0);\n\n    qdev_connect_gpio_out(cpu->gpio, SPITZ_GPIO_WM,\n\n                    qemu_allocate_irqs(spitz_wm8750_addr, wm, 1)[0]);\n\n    /* .. and to the sound interface.  */\n\n    cpu->i2s->opaque = wm;\n\n    cpu->i2s->codec_out = wm8750_dac_dat;\n\n    cpu->i2s->codec_in = wm8750_adc_dat;\n\n    wm8750_data_req_set(wm, cpu->i2s->data_req, cpu->i2s);\n\n}\n", "idx": 2478}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "int kvm_has_sync_mmu(void)\n\n{\n\n#ifdef KVM_CAP_SYNC_MMU\n\n    KVMState *s = kvm_state;\n\n\n\n    return kvm_check_extension(s, KVM_CAP_SYNC_MMU);\n\n#else\n\n    return 0;\n\n#endif\n\n}\n", "idx": 229}
{"project": "qemu", "commit_id": "aa5cb7f5e8bf2e6737d0cb36c118332ca26e7797", "target": 1, "func": "static void register_types(void)\n\n{\n\n    register_char_driver(\"null\", CHARDEV_BACKEND_KIND_NULL, NULL,\n\n                         qemu_chr_open_null);\n\n    register_char_driver(\"socket\", CHARDEV_BACKEND_KIND_SOCKET,\n\n                         qemu_chr_parse_socket, qmp_chardev_open_socket);\n\n    register_char_driver(\"udp\", CHARDEV_BACKEND_KIND_UDP, qemu_chr_parse_udp,\n\n                         qmp_chardev_open_udp);\n\n    register_char_driver(\"ringbuf\", CHARDEV_BACKEND_KIND_RINGBUF,\n\n                         qemu_chr_parse_ringbuf, qemu_chr_open_ringbuf);\n\n    register_char_driver(\"file\", CHARDEV_BACKEND_KIND_FILE,\n\n                         qemu_chr_parse_file_out, qmp_chardev_open_file);\n\n    register_char_driver(\"stdio\", CHARDEV_BACKEND_KIND_STDIO,\n\n                         qemu_chr_parse_stdio, qemu_chr_open_stdio);\n\n#if defined HAVE_CHARDEV_SERIAL\n\n    register_char_driver(\"serial\", CHARDEV_BACKEND_KIND_SERIAL,\n\n                         qemu_chr_parse_serial, qmp_chardev_open_serial);\n\n    register_char_driver(\"tty\", CHARDEV_BACKEND_KIND_SERIAL,\n\n                         qemu_chr_parse_serial, qmp_chardev_open_serial);\n\n#endif\n\n#ifdef HAVE_CHARDEV_PARPORT\n\n    register_char_driver(\"parallel\", CHARDEV_BACKEND_KIND_PARALLEL,\n\n                         qemu_chr_parse_parallel, qmp_chardev_open_parallel);\n\n    register_char_driver(\"parport\", CHARDEV_BACKEND_KIND_PARALLEL,\n\n                         qemu_chr_parse_parallel, qmp_chardev_open_parallel);\n\n#endif\n\n#ifdef HAVE_CHARDEV_PTY\n\n    register_char_driver(\"pty\", CHARDEV_BACKEND_KIND_PTY, NULL,\n\n                         qemu_chr_open_pty);\n\n#endif\n\n#ifdef _WIN32\n\n    register_char_driver(\"console\", CHARDEV_BACKEND_KIND_CONSOLE, NULL,\n\n                         qemu_chr_open_win_con);\n\n#endif\n\n    register_char_driver(\"pipe\", CHARDEV_BACKEND_KIND_PIPE,\n\n                         qemu_chr_parse_pipe, qemu_chr_open_pipe);\n\n    register_char_driver(\"mux\", CHARDEV_BACKEND_KIND_MUX, qemu_chr_parse_mux,\n\n                         qemu_chr_open_mux);\n\n    /* Bug-compatibility: */\n\n    register_char_driver(\"memory\", CHARDEV_BACKEND_KIND_MEMORY,\n\n                         qemu_chr_parse_ringbuf, qemu_chr_open_ringbuf);\n\n    /* this must be done after machine init, since we register FEs with muxes\n\n     * as part of realize functions like serial_isa_realizefn when -nographic\n\n     * is specified\n\n     */\n\n    qemu_add_machine_init_done_notifier(&muxes_realize_notify);\n\n\n\n    atexit(qemu_chr_cleanup);\n\n}\n", "idx": 52}
{"project": "qemu", "commit_id": "ed78cda3de92056737364ab3cb748b16f5f17dea", "target": 1, "func": "int bdrv_flush_all(void)\n\n{\n\n    BlockDriverState *bs;\n\n    int result = 0;\n\n\n\n    QTAILQ_FOREACH(bs, &bdrv_states, device_list) {\n\n        int ret = bdrv_flush(bs);\n\n        if (ret < 0 && !result) {\n\n            result = ret;\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 1191}
{"project": "qemu", "commit_id": "65a8e1f6413a0f6f79894da710b5d6d43361d27d", "target": 1, "func": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n\n{\n\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n\n\n\n    return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n\n                              \"*l*lwwb*b*b*blww\",\n\n                              pcic->vendor_id, pcic->device_id, pcic->revision,\n\n                              pcic->subsystem_vendor_id,\n\n                              pcic->subsystem_id);\n\n}\n", "idx": 9477}
{"project": "qemu", "commit_id": "525989a50a70ea0ffa2b1cdf56279765bb2b7de0", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    BlockDriverState *iter;\n\n    int orig_bs_flags;\n\n\n\n    /* Make sure that the image is opened in read-write mode */\n\n    orig_bs_flags = bdrv_get_flags(bs);\n\n    if (!(orig_bs_flags & BDRV_O_RDWR)) {\n\n        if (bdrv_reopen(bs, orig_bs_flags | BDRV_O_RDWR, errp) != 0) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* Prevent concurrent jobs trying to modify the graph structure here, we\n\n     * already have our own plans. Also don't allow resize as the image size is\n\n     * queried only at the job start and then cached. */\n\n    s = block_job_create(job_id, &stream_job_driver, bs,\n\n                         BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED |\n\n                         BLK_PERM_GRAPH_MOD,\n\n                         BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED |\n\n                         BLK_PERM_WRITE,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Block all intermediate nodes between bs and base, because they will\n\n     * disappear from the chain after this operation. The streaming job reads\n\n     * every block only once, assuming that it doesn't change, so block writes\n\n     * and resizes. */\n\n    for (iter = backing_bs(bs); iter && iter != base; iter = backing_bs(iter)) {\n\n        block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED,\n\n                           &error_abort);\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n    s->bs_flags = orig_bs_flags;\n\n\n\n    s->on_error = on_error;\n\n    trace_stream_start(bs, base, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (orig_bs_flags != bdrv_get_flags(bs)) {\n\n        bdrv_reopen(bs, s->bs_flags, NULL);\n\n    }\n\n}\n", "idx": 2269}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void command_loop(void)\n\n{\n\n    int c, i, j = 0, done = 0, fetchable = 0, prompted = 0;\n\n    char *input;\n\n    char **v;\n\n    const cmdinfo_t *ct;\n\n\n\n    for (i = 0; !done && i < ncmdline; i++) {\n\n        input = strdup(cmdline[i]);\n\n        if (!input) {\n\n            fprintf(stderr, _(\"cannot strdup command '%s': %s\\n\"),\n\n                    cmdline[i], strerror(errno));\n\n            exit(1);\n\n        }\n\n        v = breakline(input, &c);\n\n        if (c) {\n\n            ct = find_command(v[0]);\n\n            if (ct) {\n\n                if (ct->flags & CMD_FLAG_GLOBAL) {\n\n                    done = command(ct, c, v);\n\n                } else {\n\n                    j = 0;\n\n                    while (!done && (j = args_command(j))) {\n\n                        done = command(ct, c, v);\n\n                    }\n\n                }\n\n            } else {\n\n                fprintf(stderr, _(\"command \\\"%s\\\" not found\\n\"), v[0]);\n\n            }\n\n\t}\n\n        doneline(input, v);\n\n    }\n\n    if (cmdline) {\n\n        free(cmdline);\n\n        return;\n\n    }\n\n\n\n    while (!done) {\n\n        if (!prompted) {\n\n            printf(\"%s\", get_prompt());\n\n            fflush(stdout);\n\n            qemu_aio_set_fd_handler(STDIN_FILENO, prep_fetchline, NULL, NULL,\n\n                                    NULL, &fetchable);\n\n            prompted = 1;\n\n        }\n\n\n\n        qemu_aio_wait();\n\n\n\n        if (!fetchable) {\n\n            continue;\n\n        }\n\n        input = fetchline();\n\n        if (input == NULL) {\n\n            break;\n\n        }\n\n        v = breakline(input, &c);\n\n        if (c) {\n\n            ct = find_command(v[0]);\n\n            if (ct) {\n\n                done = command(ct, c, v);\n\n            } else {\n\n                fprintf(stderr, _(\"command \\\"%s\\\" not found\\n\"), v[0]);\n\n            }\n\n        }\n\n        doneline(input, v);\n\n\n\n        prompted = 0;\n\n        fetchable = 0;\n\n    }\n\n    qemu_aio_set_fd_handler(STDIN_FILENO, NULL, NULL, NULL, NULL, NULL);\n\n}\n", "idx": 9270}
{"project": "qemu", "commit_id": "848696bf353750899832c51005f1bd3540da5c29", "target": 1, "func": "static int qxl_init_primary(PCIDevice *dev)\n\n{\n\n    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);\n\n    VGACommonState *vga = &qxl->vga;\n\n    PortioList *qxl_vga_port_list = g_new(PortioList, 1);\n\n    int rc;\n\n\n\n    qxl->id = 0;\n\n    qxl_init_ramsize(qxl);\n\n    vga->vram_size_mb = qxl->vga.vram_size >> 20;\n\n    vga_common_init(vga, OBJECT(dev), true);\n\n    vga_init(vga, OBJECT(dev),\n\n             pci_address_space(dev), pci_address_space_io(dev), false);\n\n    portio_list_init(qxl_vga_port_list, OBJECT(dev), qxl_vga_portio_list,\n\n                     vga, \"vga\");\n\n    portio_list_set_flush_coalesced(qxl_vga_port_list);\n\n    portio_list_add(qxl_vga_port_list, pci_address_space_io(dev), 0x3b0);\n\n\n\n    vga->con = graphic_console_init(DEVICE(dev), 0, &qxl_ops, qxl);\n\n    qemu_spice_display_init_common(&qxl->ssd);\n\n\n\n    rc = qxl_init_common(qxl);\n\n    if (rc != 0) {\n\n        return rc;\n\n    }\n\n\n\n    qxl->ssd.dcl.ops = &display_listener_ops;\n\n    qxl->ssd.dcl.con = vga->con;\n\n    register_displaychangelistener(&qxl->ssd.dcl);\n\n    return rc;\n\n}\n", "idx": 8248}
{"project": "qemu", "commit_id": "2ba1eeb62c29d23238b95dc7e9ade3444b49f0a1", "target": 1, "func": "int dyngen_code(TCGContext *s, uint8_t *gen_code_buf)\n\n{\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        extern int64_t dyngen_op_count;\n\n        extern int dyngen_op_count_max;\n\n        int n;\n\n        n = (gen_opc_ptr - gen_opc_buf);\n\n        dyngen_op_count += n;\n\n        if (n > dyngen_op_count_max)\n\n            dyngen_op_count_max = n;\n\n    }\n\n#endif\n\n\n\n    tcg_gen_code_common(s, gen_code_buf, 0, NULL);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((unsigned long)gen_code_buf, \n\n                       (unsigned long)s->code_ptr);\n\n    return s->code_ptr -  gen_code_buf;\n\n}\n", "idx": 3214}
{"project": "qemu", "commit_id": "88affa1c77c9019f3450f851495997897bd14e40", "target": 1, "func": "static void do_info_trace(Monitor *mon)\n\n{\n\n    st_print_trace((FILE *)mon, &monitor_fprintf);\n\n}\n", "idx": 10593}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_alt_setting_status(void *priv, uint32_t id,\n\n    struct usb_redir_alt_setting_status_header *alt_setting_status)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    AsyncURB *aurb;\n\n    int len = 0;\n\n\n\n    DPRINTF(\"alt status %d intf %d alt %d id: %u\\n\",\n\n            alt_setting_status->status,\n\n            alt_setting_status->interface,\n\n            alt_setting_status->alt, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        return;\n\n    }\n\n    if (aurb->packet) {\n\n        if (aurb->get) {\n\n            dev->dev.data_buf[0] = alt_setting_status->alt;\n\n            len = 1;\n\n        }\n\n        aurb->packet->len =\n\n            usbredir_handle_status(dev, alt_setting_status->status, len);\n\n        usb_generic_async_ctrl_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n}\n", "idx": 11618}
{"project": "qemu", "commit_id": "e7b921c2d9efc249f99b9feb0e7dca82c96aa5c4", "target": 1, "func": "static inline int get_a32_user_mem_index(DisasContext *s)\n\n{\n\n    /* Return the core mmu_idx to use for A32/T32 \"unprivileged load/store\"\n\n     * insns:\n\n     *  if PL2, UNPREDICTABLE (we choose to implement as if PL0)\n\n     *  otherwise, access as if at PL0.\n\n     */\n\n    switch (s->mmu_idx) {\n\n    case ARMMMUIdx_S1E2:        /* this one is UNPREDICTABLE */\n\n    case ARMMMUIdx_S12NSE0:\n\n    case ARMMMUIdx_S12NSE1:\n\n        return arm_to_core_mmu_idx(ARMMMUIdx_S12NSE0);\n\n    case ARMMMUIdx_S1E3:\n\n    case ARMMMUIdx_S1SE0:\n\n    case ARMMMUIdx_S1SE1:\n\n        return arm_to_core_mmu_idx(ARMMMUIdx_S1SE0);\n\n\n\n\n    case ARMMMUIdx_S2NS:\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}", "idx": 11295}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void add_migration_state_change_notifier(Notifier *notify)\n\n{\n\n    notifier_list_add(&migration_state_notifiers, notify);\n\n}\n", "idx": 7157}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static void mv88w8618_eth_init(NICInfo *nd, uint32_t base, qemu_irq irq)\n\n{\n\n    mv88w8618_eth_state *s;\n\n    int iomemtype;\n\n\n\n    qemu_check_nic_model(nd, \"mv88w8618\");\n\n\n\n    s = qemu_mallocz(sizeof(mv88w8618_eth_state));\n\n    s->irq = irq;\n\n    s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                 eth_receive, eth_can_receive, s);\n\n    iomemtype = cpu_register_io_memory(0, mv88w8618_eth_readfn,\n\n                                       mv88w8618_eth_writefn, s);\n\n    cpu_register_physical_memory(base, MP_ETH_SIZE, iomemtype);\n\n}\n", "idx": 3399}
{"project": "qemu", "commit_id": "d9d3aaea0b3fbb5028e20316bdb93359487cd01f", "target": 1, "func": "void replay_configure(QemuOpts *opts)\n\n{\n\n    const char *fname;\n\n    const char *rr;\n\n    ReplayMode mode = REPLAY_MODE_NONE;\n\n    Location loc;\n\n\n\n    if (!opts) {\n\n        return;\n\n    }\n\n\n\n    loc_push_none(&loc);\n\n    qemu_opts_loc_restore(opts);\n\n\n\n    rr = qemu_opt_get(opts, \"rr\");\n\n    if (!rr) {\n\n        /* Just enabling icount */\n\n        return;\n\n    } else if (!strcmp(rr, \"record\")) {\n\n        mode = REPLAY_MODE_RECORD;\n\n    } else if (!strcmp(rr, \"replay\")) {\n\n        mode = REPLAY_MODE_PLAY;\n\n    } else {\n\n        error_report(\"Invalid icount rr option: %s\", rr);\n\n        exit(1);\n\n    }\n\n\n\n    fname = qemu_opt_get(opts, \"rrfile\");\n\n    if (!fname) {\n\n        error_report(\"File name not specified for replay\");\n\n        exit(1);\n\n    }\n\n\n\n    replay_enable(fname, mode);\n\n\n\n    loc_pop(&loc);\n\n}\n", "idx": 8396}
{"project": "qemu", "commit_id": "134a03e0b3d34b01b68107104c525c3bff1211d4", "target": 1, "func": "static int os_host_main_loop_wait(uint32_t timeout)\n\n{\n\n    GMainContext *context = g_main_context_default();\n\n    int select_ret, g_poll_ret, ret, i;\n\n    PollingEntry *pe;\n\n    WaitObjects *w = &wait_objects;\n\n    gint poll_timeout;\n\n    static struct timeval tv0;\n\n\n\n    /* XXX: need to suppress polling by better using win32 events */\n\n    ret = 0;\n\n    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {\n\n        ret |= pe->func(pe->opaque);\n\n    }\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n\n\n    g_main_context_prepare(context, &max_priority);\n\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n\n\n\n    for (i = 0; i < w->num; i++) {\n\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n\n    }\n\n\n\n    if (poll_timeout < 0 || timeout < poll_timeout) {\n\n        poll_timeout = timeout;\n\n    }\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    g_poll_ret = g_poll(poll_fds, n_poll_fds + w->num, poll_timeout);\n\n    qemu_mutex_lock_iothread();\n\n    if (g_poll_ret > 0) {\n\n        for (i = 0; i < w->num; i++) {\n\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n\n        }\n\n        for (i = 0; i < w->num; i++) {\n\n            if (w->revents[i] && w->func[i]) {\n\n                w->func[i](w->opaque[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n\n        g_main_context_dispatch(context);\n\n    }\n\n\n\n    /* Call select after g_poll to avoid a useless iteration and therefore\n\n     * improve socket latency.\n\n     */\n\n\n\n    if (nfds >= 0) {\n\n        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);\n\n        if (select_ret != 0) {\n\n            timeout = 0;\n\n        }\n\n    }\n\n\n\n    return select_ret || g_poll_ret;\n\n}\n", "idx": 6757}
{"project": "qemu", "commit_id": "d66e5cee002c471b78139228a4e7012736b375f9", "target": 1, "func": "static int qcow_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, shift, ret;\n\n    QCowHeader header;\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be32_to_cpus(&header.mtime);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        error_setg(errp, \"Image not in qcow format\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version != QCOW_VERSION) {\n\n        char version[64];\n\n        snprintf(version, sizeof(version), \"QCOW version %\" PRIu32,\n\n                 header.version);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                  bs->device_name, \"qcow\", version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.size <= 1) {\n\n        error_setg(errp, \"Image size is too small (must be at least 2 bytes)\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.cluster_bits < 9 || header.cluster_bits > 16) {\n\n        error_setg(errp, \"Cluster size must be between 512 and 64k\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* l2_bits specifies number of entries; storing a uint64_t in each entry,\n\n     * so bytes = num_entries << 3. */\n\n    if (header.l2_bits < 9 - 3 || header.l2_bits > 16 - 3) {\n\n        error_setg(errp, \"L2 table size must be between 512 and 64k\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        error_setg(errp, \"invalid encryption method in qcow header\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        bs->encrypted = 1;\n\n    }\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = header.l2_bits;\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->cluster_offset_mask = (1LL << (63 - s->cluster_bits)) - 1;\n\n\n\n    /* read the level 1 table */\n\n    shift = s->cluster_bits + s->l2_bits;\n\n    if (header.size > UINT64_MAX - (1LL << shift)) {\n\n        error_setg(errp, \"Image too large\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else {\n\n        uint64_t l1_size = (header.size + (1LL << shift) - 1) >> shift;\n\n        if (l1_size > INT_MAX / sizeof(uint64_t)) {\n\n            error_setg(errp, \"Image too large\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        s->l1_size = l1_size;\n\n    }\n\n\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    s->l1_table = g_malloc(s->l1_size * sizeof(uint64_t));\n\n\n\n    ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n               s->l1_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for(i = 0;i < s->l1_size; i++) {\n\n        be64_to_cpus(&s->l1_table[i]);\n\n    }\n\n    /* alloc L2 cache */\n\n    s->l2_cache = g_malloc(s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    s->cluster_data = g_malloc(s->cluster_size);\n\n    s->cluster_cache_offset = -1;\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023) {\n\n            len = 1023;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                   bs->backing_file, len);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n\n\n    /* Disable migration when qcow images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"qcow\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\n\n\n fail:\n\n    g_free(s->l1_table);\n\n    g_free(s->l2_cache);\n\n    g_free(s->cluster_cache);\n\n    g_free(s->cluster_data);\n\n    return ret;\n\n}\n", "idx": 7600}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void uc32_cpu_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    CPUClass *cc = CPU_CLASS(oc);\n    UniCore32CPUClass *ucc = UNICORE32_CPU_CLASS(oc);\n    ucc->parent_realize = dc->realize;\n    dc->realize = uc32_cpu_realizefn;\n    cc->class_by_name = uc32_cpu_class_by_name;\n    cc->has_work = uc32_cpu_has_work;\n    cc->do_interrupt = uc32_cpu_do_interrupt;\n    cc->cpu_exec_interrupt = uc32_cpu_exec_interrupt;\n    cc->dump_state = uc32_cpu_dump_state;\n    cc->set_pc = uc32_cpu_set_pc;\n#ifdef CONFIG_USER_ONLY\n    cc->handle_mmu_fault = uc32_cpu_handle_mmu_fault;\n#else\n    cc->get_phys_page_debug = uc32_cpu_get_phys_page_debug;\n#endif\n    dc->vmsd = &vmstate_uc32_cpu;\n}", "idx": 3818}
{"project": "qemu", "commit_id": "cfba8e6f92d45a2374622c3dc57499e42a1c07e1", "target": 1, "func": "static void vncws_send_handshake_response(VncState *vs, const char* key)\n\n{\n\n    char combined_key[WS_CLIENT_KEY_LEN + WS_GUID_LEN + 1];\n\n    char hash[SHA1_DIGEST_LEN];\n\n    size_t hash_size = SHA1_DIGEST_LEN;\n\n    char *accept = NULL, *response = NULL;\n\n    gnutls_datum_t in;\n\n\n\n    g_strlcpy(combined_key, key, WS_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, WS_GUID, WS_CLIENT_KEY_LEN + WS_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    in.data = (void *)combined_key;\n\n    in.size = WS_CLIENT_KEY_LEN + WS_GUID_LEN;\n\n    if (gnutls_fingerprint(GNUTLS_DIG_SHA1, &in, hash, &hash_size)\n\n            == GNUTLS_E_SUCCESS) {\n\n        accept = g_base64_encode((guchar *)hash, SHA1_DIGEST_LEN);\n\n    }\n\n    if (accept == NULL) {\n\n        VNC_DEBUG(\"Hashing Websocket combined key failed\\n\");\n\n        vnc_client_error(vs);\n\n        return;\n\n    }\n\n\n\n    response = g_strdup_printf(WS_HANDSHAKE, accept);\n\n    vnc_write(vs, response, strlen(response));\n\n    vnc_flush(vs);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    vs->encode_ws = 1;\n\n    vnc_init_state(vs);\n\n}\n", "idx": 6949}
{"project": "qemu", "commit_id": "c5633d998a27502ad8cc10c2d46f91b02555ae7a", "target": 1, "func": "static int xen_pt_config_reg_init(XenPCIPassthroughState *s,\n\n                                  XenPTRegGroup *reg_grp, XenPTRegInfo *reg)\n\n{\n\n    XenPTReg *reg_entry;\n\n    uint32_t data = 0;\n\n    int rc = 0;\n\n\n\n    reg_entry = g_new0(XenPTReg, 1);\n\n    reg_entry->reg = reg;\n\n\n\n    if (reg->init) {\n\n        /* initialize emulate register */\n\n        rc = reg->init(s, reg_entry->reg,\n\n                       reg_grp->base_offset + reg->offset, &data);\n\n        if (rc < 0) {\n\n            free(reg_entry);\n\n            return rc;\n\n        }\n\n        if (data == XEN_PT_INVALID_REG) {\n\n            /* free unused BAR register entry */\n\n            free(reg_entry);\n\n            return 0;\n\n        }\n\n        /* set register value */\n\n        reg_entry->data = data;\n\n    }\n\n    /* list add register entry */\n\n    QLIST_INSERT_HEAD(&reg_grp->reg_tbl_list, reg_entry, entries);\n\n\n\n    return 0;\n\n}\n", "idx": 2786}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "void cpu_exec_init(CPUState *cpu, Error **errp)\n\n{\n\n    CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);\n\n\n\n    cpu_list_add(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);\n\n    }\n\n    if (cc->vmsd != NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, cc->vmsd, cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 7077}
{"project": "qemu", "commit_id": "43c696a298f6bef81818b1d8e64d41a160782101", "target": 1, "func": "static void virtio_scsi_hotplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if (s->ctx && !s->dataplane_disabled) {\n\n        VirtIOSCSIBlkChangeNotifier *insert_notifier, *remove_notifier;\n\n\n\n        if (blk_op_is_blocked(sd->conf.blk, BLOCK_OP_TYPE_DATAPLANE, errp)) {\n\n            return;\n\n        }\n\n        blk_op_block_all(sd->conf.blk, s->blocker);\n\n        aio_context_acquire(s->ctx);\n\n        blk_set_aio_context(sd->conf.blk, s->ctx);\n\n        aio_context_release(s->ctx);\n\n\n\n        insert_notifier = g_new0(VirtIOSCSIBlkChangeNotifier, 1);\n\n        insert_notifier->n.notify = virtio_scsi_blk_insert_notifier;\n\n        insert_notifier->s = s;\n\n        insert_notifier->sd = sd;\n\n        blk_add_insert_bs_notifier(sd->conf.blk, &insert_notifier->n);\n\n        QTAILQ_INSERT_TAIL(&s->insert_notifiers, insert_notifier, next);\n\n\n\n        remove_notifier = g_new0(VirtIOSCSIBlkChangeNotifier, 1);\n\n        remove_notifier->n.notify = virtio_scsi_blk_remove_notifier;\n\n        remove_notifier->s = s;\n\n        remove_notifier->sd = sd;\n\n        blk_add_remove_bs_notifier(sd->conf.blk, &remove_notifier->n);\n\n        QTAILQ_INSERT_TAIL(&s->remove_notifiers, remove_notifier, next);\n\n    }\n\n\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG)) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_RESCAN);\n\n    }\n\n}\n", "idx": 10681}
{"project": "qemu", "commit_id": "50d4a858e62b1d864227d13f07d2c79c118d046a", "target": 1, "func": "static ssize_t handle_aiocb_rw(RawPosixAIOData *aiocb)\n\n{\n\n    ssize_t nbytes;\n\n    char *buf;\n\n\n\n    if (!(aiocb->aio_type & QEMU_AIO_MISALIGNED)) {\n\n        /*\n\n         * If there is just a single buffer, and it is properly aligned\n\n         * we can just use plain pread/pwrite without any problems.\n\n         */\n\n        if (aiocb->aio_niov == 1) {\n\n             return handle_aiocb_rw_linear(aiocb, aiocb->aio_iov->iov_base);\n\n        }\n\n        /*\n\n         * We have more than one iovec, and all are properly aligned.\n\n         *\n\n         * Try preadv/pwritev first and fall back to linearizing the\n\n         * buffer if it's not supported.\n\n         */\n\n        if (preadv_present) {\n\n            nbytes = handle_aiocb_rw_vector(aiocb);\n\n            if (nbytes == aiocb->aio_nbytes ||\n\n                (nbytes < 0 && nbytes != -ENOSYS)) {\n\n                return nbytes;\n\n            }\n\n            preadv_present = false;\n\n        }\n\n\n\n        /*\n\n         * XXX(hch): short read/write.  no easy way to handle the reminder\n\n         * using these interfaces.  For now retry using plain\n\n         * pread/pwrite?\n\n         */\n\n    }\n\n\n\n    /*\n\n     * Ok, we have to do it the hard way, copy all segments into\n\n     * a single aligned buffer.\n\n     */\n\n    buf = qemu_blockalign(aiocb->bs, aiocb->aio_nbytes);\n\n    if (aiocb->aio_type & QEMU_AIO_WRITE) {\n\n        char *p = buf;\n\n        int i;\n\n\n\n        for (i = 0; i < aiocb->aio_niov; ++i) {\n\n            memcpy(p, aiocb->aio_iov[i].iov_base, aiocb->aio_iov[i].iov_len);\n\n            p += aiocb->aio_iov[i].iov_len;\n\n        }\n\n        assert(p - buf == aiocb->aio_nbytes);\n\n    }\n\n\n\n    nbytes = handle_aiocb_rw_linear(aiocb, buf);\n\n    if (!(aiocb->aio_type & QEMU_AIO_WRITE)) {\n\n        char *p = buf;\n\n        size_t count = aiocb->aio_nbytes, copy;\n\n        int i;\n\n\n\n        for (i = 0; i < aiocb->aio_niov && count; ++i) {\n\n            copy = count;\n\n            if (copy > aiocb->aio_iov[i].iov_len) {\n\n                copy = aiocb->aio_iov[i].iov_len;\n\n            }\n\n            memcpy(aiocb->aio_iov[i].iov_base, p, copy);\n\n            assert(count >= copy);\n\n            p     += copy;\n\n            count -= copy;\n\n        }\n\n        assert(count == 0);\n\n    }\n\n    qemu_vfree(buf);\n\n\n\n    return nbytes;\n\n}\n", "idx": 9008}
{"project": "qemu", "commit_id": "38c4d0aea3e1264c86e282d99560330adf2b6e25", "target": 1, "func": "static int64_t try_fiemap(BlockDriverState *bs, off_t start, off_t *data,\n\n                          off_t *hole, int nb_sectors, int *pnum)\n\n{\n\n#ifdef CONFIG_FIEMAP\n\n    BDRVRawState *s = bs->opaque;\n\n    int64_t ret = BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID | start;\n\n    struct {\n\n        struct fiemap fm;\n\n        struct fiemap_extent fe;\n\n    } f;\n\n\n\n    if (s->skip_fiemap) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    f.fm.fm_start = start;\n\n    f.fm.fm_length = (int64_t)nb_sectors * BDRV_SECTOR_SIZE;\n\n    f.fm.fm_flags = 0;\n\n    f.fm.fm_extent_count = 1;\n\n    f.fm.fm_reserved = 0;\n\n    if (ioctl(s->fd, FS_IOC_FIEMAP, &f) == -1) {\n\n        s->skip_fiemap = true;\n\n        return -errno;\n\n    }\n\n\n\n    if (f.fm.fm_mapped_extents == 0) {\n\n        /* No extents found, data is beyond f.fm.fm_start + f.fm.fm_length.\n\n         * f.fm.fm_start + f.fm.fm_length must be clamped to the file size!\n\n         */\n\n        off_t length = lseek(s->fd, 0, SEEK_END);\n\n        *hole = f.fm.fm_start;\n\n        *data = MIN(f.fm.fm_start + f.fm.fm_length, length);\n\n    } else {\n\n        *data = f.fe.fe_logical;\n\n        *hole = f.fe.fe_logical + f.fe.fe_length;\n\n        if (f.fe.fe_flags & FIEMAP_EXTENT_UNWRITTEN) {\n\n            ret |= BDRV_BLOCK_ZERO;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 1497}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void unset_dirty_tracking(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        bdrv_release_dirty_bitmap(bmds->bs, bmds->dirty_bitmap);\n\n    }\n\n}\n", "idx": 7191}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "Coroutine *qemu_coroutine_create(CoroutineEntry *entry)\n\n{\n\n    Coroutine *co = NULL;\n\n\n\n    if (CONFIG_COROUTINE_POOL) {\n\n        co = QSLIST_FIRST(&alloc_pool);\n\n        if (!co) {\n\n            if (release_pool_size > POOL_BATCH_SIZE) {\n\n                /* Slow path; a good place to register the destructor, too.  */\n\n                if (!coroutine_pool_cleanup_notifier.notify) {\n\n                    coroutine_pool_cleanup_notifier.notify = coroutine_pool_cleanup;\n\n                    qemu_thread_atexit_add(&coroutine_pool_cleanup_notifier);\n\n                }\n\n\n\n                /* This is not exact; there could be a little skew between\n\n                 * release_pool_size and the actual size of release_pool.  But\n\n                 * it is just a heuristic, it does not need to be perfect.\n\n                 */\n\n                alloc_pool_size = atomic_xchg(&release_pool_size, 0);\n\n                QSLIST_MOVE_ATOMIC(&alloc_pool, &release_pool);\n\n                co = QSLIST_FIRST(&alloc_pool);\n\n            }\n\n        }\n\n        if (co) {\n\n            QSLIST_REMOVE_HEAD(&alloc_pool, pool_next);\n\n            alloc_pool_size--;\n\n        }\n\n    }\n\n\n\n    if (!co) {\n\n        co = qemu_coroutine_new();\n\n    }\n\n\n\n    co->entry = entry;\n\n    QSIMPLEQ_INIT(&co->co_queue_wakeup);\n\n    return co;\n\n}\n", "idx": 11146}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_set(Error **errp, ErrorClass err_class, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, err_class, fmt, ap);\n\n    va_end(ap);\n\n}\n", "idx": 3866}
{"project": "qemu", "commit_id": "ed1dda53d073acdb52889aa30f9d251061b053bd", "target": 1, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n#if defined ALPHA_DEBUG_DISAS\n\n    static int insn_count;\n\n#endif\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    target_ulong pc_start;\n\n    uint32_t insn;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int ret;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.amask = env->amask;\n\n#if defined (CONFIG_USER_ONLY)\n\n    ctx.mem_idx = 0;\n\n#else\n\n    ctx.mem_idx = ((env->ps >> 3) & 3);\n\n    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    for (ret = 0; ret == 0;) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    gen_excp(&ctx, EXCP_DEBUG, 0);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.pc;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"pc \" TARGET_FMT_lx \" mem_idx %d\\n\",\n\n                  ctx.pc, ctx.mem_idx);\n\n#endif\n\n        insn = ldl_code(ctx.pc);\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"opcode %08x %d\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 675}
{"project": "qemu", "commit_id": "dac23a6c05e543590508b48b8ed31d89b0c99c61", "target": 1, "func": "static bool load_asl(GArray *sdts, AcpiSdtTable *sdt)\n\n{\n\n    AcpiSdtTable *temp;\n\n    GError *error = NULL;\n\n    GString *command_line = g_string_new(iasl);\n\n    gint fd;\n\n    gchar *out, *out_err;\n\n    gboolean ret;\n\n    int i;\n\n\n\n    fd = g_file_open_tmp(\"asl-XXXXXX.dsl\", &sdt->asl_file, &error);\n\n    g_assert_no_error(error);\n\n    close(fd);\n\n\n\n    /* build command line */\n\n    g_string_append_printf(command_line, \" -p %s \", sdt->asl_file);\n\n    if (compare_signature(sdt, \"DSDT\") ||\n\n        compare_signature(sdt, \"SSDT\")) {\n\n        for (i = 0; i < sdts->len; ++i) {\n\n            temp = &g_array_index(sdts, AcpiSdtTable, i);\n\n            if (compare_signature(temp, \"DSDT\") ||\n\n                compare_signature(temp, \"SSDT\")) {\n\n                g_string_append_printf(command_line, \"-e %s \", temp->aml_file);\n\n            }\n\n        }\n\n    }\n\n    g_string_append_printf(command_line, \"-d %s\", sdt->aml_file);\n\n\n\n    /* pass 'out' and 'out_err' in order to be redirected */\n\n    ret = g_spawn_command_line_sync(command_line->str, &out, &out_err, NULL, &error);\n\n    g_assert_no_error(error);\n\n\n\n    if (ret) {\n\n        ret = g_file_get_contents(sdt->asl_file, (gchar **)&sdt->asl,\n\n                                  &sdt->asl_len, &error);\n\n        g_assert(ret);\n\n        g_assert_no_error(error);\n\n        g_assert(sdt->asl_len);\n\n    }\n\n\n\n    g_free(out);\n\n    g_free(out_err);\n\n    g_string_free(command_line, true);\n\n\n\n    return !ret;\n\n}\n", "idx": 6155}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int migrate_use_xbzrle(void)\n\n{\n\n    MigrationState *s;\n\n\n\n    s = migrate_get_current();\n\n\n\n    return s->enabled_capabilities[MIGRATION_CAPABILITY_XBZRLE];\n\n}\n", "idx": 4610}
{"project": "qemu", "commit_id": "de1c90cf8b73992b4197561850d2da1075fb82eb", "target": 1, "func": "static void qemu_event_increment(void)\n\n{\n\n    SetEvent(qemu_event_handle);\n\n}\n", "idx": 6710}
{"project": "qemu", "commit_id": "771b64daf9c73be98d223d3ab101a61f02cac277", "target": 1, "func": "static void laio_cancel(BlockDriverAIOCB *blockacb)\n\n{\n\n    struct qemu_laiocb *laiocb = (struct qemu_laiocb *)blockacb;\n\n    struct io_event event;\n\n    int ret;\n\n\n\n    if (laiocb->ret != -EINPROGRESS)\n\n        return;\n\n\n\n    /*\n\n     * Note that as of Linux 2.6.31 neither the block device code nor any\n\n     * filesystem implements cancellation of AIO request.\n\n     * Thus the polling loop below is the normal code path.\n\n     */\n\n    ret = io_cancel(laiocb->ctx->ctx, &laiocb->iocb, &event);\n\n    if (ret == 0) {\n\n        laiocb->ret = -ECANCELED;\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * We have to wait for the iocb to finish.\n\n     *\n\n     * The only way to get the iocb status update is by polling the io context.\n\n     * We might be able to do this slightly more optimal by removing the\n\n     * O_NONBLOCK flag.\n\n     */\n\n    while (laiocb->ret == -EINPROGRESS) {\n\n        qemu_laio_completion_cb(&laiocb->ctx->e);\n\n    }\n\n}\n", "idx": 5135}
{"project": "qemu", "commit_id": "9ed5726c043958359b0f1fa44ab3e4f25f9d9a47", "target": 1, "func": "target_ulong helper_dmt(target_ulong arg1)\n\n{\n\n    // TODO\n\n    arg1 = 0;\n\n    // rt = arg1\n\n\n\n    return arg1;\n\n}\n", "idx": 214}
{"project": "qemu", "commit_id": "8bb93c6f99a42c2e0943bc904b283cd622d302c5", "target": 1, "func": "static void dpy_refresh(DisplayState *s)\n\n{\n\n    DisplayChangeListener *dcl;\n\n\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (dcl->ops->dpy_refresh) {\n\n            dcl->ops->dpy_refresh(dcl);\n\n        }\n\n    }\n\n}\n", "idx": 3164}
{"project": "qemu", "commit_id": "0e1dac6c41f337f997814344a847162968c20c64", "target": 1, "func": "int kvm_init(MachineClass *mc)\n\n{\n\n    static const char upgrade_note[] =\n\n        \"Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\\n\"\n\n        \"(see http://sourceforge.net/projects/kvm).\\n\";\n\n    struct {\n\n        const char *name;\n\n        int num;\n\n    } num_cpus[] = {\n\n        { \"SMP\",          smp_cpus },\n\n        { \"hotpluggable\", max_cpus },\n\n        { NULL, }\n\n    }, *nc = num_cpus;\n\n    int soft_vcpus_limit, hard_vcpus_limit;\n\n    KVMState *s;\n\n    const KVMCapabilityInfo *missing_cap;\n\n    int ret;\n\n    int i, type = 0;\n\n    const char *kvm_type;\n\n\n\n    s = g_malloc0(sizeof(KVMState));\n\n\n\n    /*\n\n     * On systems where the kernel can support different base page\n\n     * sizes, host page size may be different from TARGET_PAGE_SIZE,\n\n     * even with KVM.  TARGET_PAGE_SIZE is assumed to be the minimum\n\n     * page size for the system though.\n\n     */\n\n    assert(TARGET_PAGE_SIZE <= getpagesize());\n\n    page_size_init();\n\n\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n\n    QTAILQ_INIT(&s->kvm_sw_breakpoints);\n\n#endif\n\n    s->vmfd = -1;\n\n    s->fd = qemu_open(\"/dev/kvm\", O_RDWR);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n\n        ret = -errno;\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n\n    if (ret < KVM_API_VERSION) {\n\n        if (ret > 0) {\n\n            ret = -EINVAL;\n\n        }\n\n        fprintf(stderr, \"kvm version too old\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (ret > KVM_API_VERSION) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm version not supported\\n\");\n\n        goto err;\n\n    }\n\n\n\n    s->nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);\n\n\n\n    /* If unspecified, use the default value */\n\n    if (!s->nr_slots) {\n\n        s->nr_slots = 32;\n\n    }\n\n\n\n    s->slots = g_malloc0(s->nr_slots * sizeof(KVMSlot));\n\n\n\n    for (i = 0; i < s->nr_slots; i++) {\n\n        s->slots[i].slot = i;\n\n    }\n\n\n\n    /* check the vcpu limits */\n\n    soft_vcpus_limit = kvm_recommended_vcpus(s);\n\n    hard_vcpus_limit = kvm_max_vcpus(s);\n\n\n\n    while (nc->name) {\n\n        if (nc->num > soft_vcpus_limit) {\n\n            fprintf(stderr,\n\n                    \"Warning: Number of %s cpus requested (%d) exceeds \"\n\n                    \"the recommended cpus supported by KVM (%d)\\n\",\n\n                    nc->name, nc->num, soft_vcpus_limit);\n\n\n\n            if (nc->num > hard_vcpus_limit) {\n\n                fprintf(stderr, \"Number of %s cpus requested (%d) exceeds \"\n\n                        \"the maximum cpus supported by KVM (%d)\\n\",\n\n                        nc->name, nc->num, hard_vcpus_limit);\n\n                exit(1);\n\n            }\n\n        }\n\n        nc++;\n\n    }\n\n\n\n    kvm_type = qemu_opt_get(qemu_get_machine_opts(), \"kvm-type\");\n\n    if (mc->kvm_type) {\n\n        type = mc->kvm_type(kvm_type);\n\n    } else if (kvm_type) {\n\n        fprintf(stderr, \"Invalid argument kvm-type=%s\\n\", kvm_type);\n\n        goto err;\n\n    }\n\n\n\n    do {\n\n        ret = kvm_ioctl(s, KVM_CREATE_VM, type);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ioctl(KVM_CREATE_VM) failed: %d %s\\n\", -ret,\n\n                strerror(-ret));\n\n\n\n#ifdef TARGET_S390X\n\n        fprintf(stderr, \"Please add the 'switch_amode' kernel parameter to \"\n\n                        \"your host kernel command line\\n\");\n\n#endif\n\n        goto err;\n\n    }\n\n\n\n    s->vmfd = ret;\n\n    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);\n\n    if (!missing_cap) {\n\n        missing_cap =\n\n            kvm_check_extension_list(s, kvm_arch_required_capabilities);\n\n    }\n\n    if (missing_cap) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm does not support %s\\n%s\",\n\n                missing_cap->name, upgrade_note);\n\n        goto err;\n\n    }\n\n\n\n    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n\n\n\n    s->broken_set_mem_region = 1;\n\n    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n\n    if (ret > 0) {\n\n        s->broken_set_mem_region = 0;\n\n    }\n\n\n\n#ifdef KVM_CAP_VCPU_EVENTS\n\n    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);\n\n#endif\n\n\n\n    s->robust_singlestep =\n\n        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);\n\n\n\n#ifdef KVM_CAP_DEBUGREGS\n\n    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XSAVE\n\n    s->xsave = kvm_check_extension(s, KVM_CAP_XSAVE);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XCRS\n\n    s->xcrs = kvm_check_extension(s, KVM_CAP_XCRS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_PIT_STATE2\n\n    s->pit_state2 = kvm_check_extension(s, KVM_CAP_PIT_STATE2);\n\n#endif\n\n\n\n#ifdef KVM_CAP_IRQ_ROUTING\n\n    s->direct_msi = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) > 0);\n\n#endif\n\n\n\n    s->intx_set_mask = kvm_check_extension(s, KVM_CAP_PCI_2_3);\n\n\n\n    s->irq_set_ioctl = KVM_IRQ_LINE;\n\n    if (kvm_check_extension(s, KVM_CAP_IRQ_INJECT_STATUS)) {\n\n        s->irq_set_ioctl = KVM_IRQ_LINE_STATUS;\n\n    }\n\n\n\n#ifdef KVM_CAP_READONLY_MEM\n\n    kvm_readonly_mem_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_READONLY_MEM) > 0);\n\n#endif\n\n\n\n    ret = kvm_arch_init(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_irqchip_create(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    kvm_state = s;\n\n    memory_listener_register(&kvm_memory_listener, &address_space_memory);\n\n    memory_listener_register(&kvm_io_listener, &address_space_io);\n\n\n\n    s->many_ioeventfds = kvm_check_many_ioeventfds();\n\n\n\n    cpu_interrupt_handler = kvm_handle_interrupt;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    if (s->vmfd >= 0) {\n\n        close(s->vmfd);\n\n    }\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n    }\n\n    g_free(s->slots);\n\n    g_free(s);\n\n\n\n    return ret;\n\n}\n", "idx": 3584}
{"project": "qemu", "commit_id": "ee640c625e190a0c0e6b8966adc0e4720fb75200", "target": 1, "func": "e1000e_init_msix(E1000EState *s)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    int res = msix_init(PCI_DEVICE(s), E1000E_MSIX_VEC_NUM,\n\n                        &s->msix,\n\n                        E1000E_MSIX_IDX, E1000E_MSIX_TABLE,\n\n                        &s->msix,\n\n                        E1000E_MSIX_IDX, E1000E_MSIX_PBA,\n\n                        0xA0);\n\n\n\n    if (res < 0) {\n\n        trace_e1000e_msix_init_fail(res);\n\n    } else {\n\n        if (!e1000e_use_msix_vectors(s, E1000E_MSIX_VEC_NUM)) {\n\n            msix_uninit(d, &s->msix, &s->msix);\n\n        }\n\n    }\n\n}\n", "idx": 4364}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 6394}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "struct pxa2xx_state_s *pxa270_init(unsigned int sdram_size,\n\n                DisplayState *ds, const char *revision)\n\n{\n\n    struct pxa2xx_state_s *s;\n\n    struct pxa2xx_ssp_s *ssp;\n\n    int iomemtype, i;\n\n    s = (struct pxa2xx_state_s *) qemu_mallocz(sizeof(struct pxa2xx_state_s));\n\n\n\n    if (revision && strncmp(revision, \"pxa27\", 5)) {\n\n        fprintf(stderr, \"Machine requires a PXA27x processor.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    s->env = cpu_init();\n\n    cpu_arm_set_model(s->env, revision ?: \"pxa270\");\n\n    register_savevm(\"cpu\", 0, 0, cpu_save, cpu_load, s->env);\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE,\n\n                    sdram_size, qemu_ram_alloc(sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE,\n\n                    0x40000, qemu_ram_alloc(0x40000) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa27x_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa27x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0],\n\n                    s->pic[PXA27X_PIC_OST_4_11]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 121);\n\n\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa270_serial[i].io_base; i ++)\n\n        if (serial_hds[i])\n\n            serial_mm_init(pxa270_serial[i].io_base, 2,\n\n                            s->pic[pxa270_serial[i].irqn], serial_hds[i], 1);\n\n        else\n\n            break;\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    if (ds)\n\n        s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD], ds);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 4] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s);\n\n    cpu_register_physical_memory(s->cm_base, 0xfff, iomemtype);\n\n    register_savevm(\"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s);\n\n    cpu_register_physical_memory(s->mm_base, 0xfff, iomemtype);\n\n    register_savevm(\"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s);\n\n    cpu_register_physical_memory(s->pm_base, 0xff, iomemtype);\n\n    register_savevm(\"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++);\n\n    s->ssp = (struct pxa2xx_ssp_s **)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s *) * i);\n\n    ssp = (struct pxa2xx_ssp_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s) * i);\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++) {\n\n        s->ssp[i] = &ssp[i];\n\n        ssp[i].base = pxa27x_ssp[i].io_base;\n\n        ssp[i].irq = s->pic[pxa27x_ssp[i].irqn];\n\n\n\n        iomemtype = cpu_register_io_memory(0, pxa2xx_ssp_readfn,\n\n                        pxa2xx_ssp_writefn, &ssp[i]);\n\n        cpu_register_physical_memory(ssp[i].base, 0xfff, iomemtype);\n\n        register_savevm(\"pxa2xx_ssp\", i, 0,\n\n                        pxa2xx_ssp_save, pxa2xx_ssp_load, s);\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pxa(0x4c000000, 3, -1, s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s);\n\n    cpu_register_physical_memory(s->rtc_base, 0xfff, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(\"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overriden by board-specific code */\n\n    pxa2xx_gpio_handler_set(s->gpio, 1, pxa2xx_reset, s);\n\n    return s;\n\n}\n", "idx": 8521}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze(Error **err)\n\n{\n\n    int ret = 0, i = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n", "idx": 4441}
{"project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "target": 1, "func": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\n\t\t\t\t\t     unsigned mode,\n\n\t\t\t\t\t     unsigned offset,\n\n\t\t\t\t\t     uint32_t mem_value)\n\n{\n\n    int x;\n\n    unsigned val = mem_value;\n\n    uint8_t *dst;\n\n\n\n    dst = s->vram_ptr + offset;\n\n    for (x = 0; x < 8; x++) {\n\n\tif (val & 0x80) {\n\n\t    *dst = s->cirrus_shadow_gr1;\n\n\t} else if (mode == 5) {\n\n\t    *dst = s->cirrus_shadow_gr0;\n\n\t}\n\n\tval <<= 1;\n\n\tdst++;\n\n    }\n\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);\n\n}\n", "idx": 2091}
{"project": "qemu", "commit_id": "5cb9b56acfc0b50acf7ccd2d044ab4991c47fdde", "target": 1, "func": "static int print_uint8(DeviceState *dev, Property *prop, char *dest, size_t len)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    return snprintf(dest, len, \"%\" PRIu8, *ptr);\n\n}\n", "idx": 4388}
{"project": "qemu", "commit_id": "783e7706937fe15523b609b545587a028a2bdd03", "target": 1, "func": "static void virtio_net_handle_tx_bh(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIONet *n = to_virtio_net(vdev);\n\n\n\n    if (unlikely(n->tx_waiting)) {\n\n        return;\n\n    }\n\n    virtio_queue_set_notification(vq, 0);\n\n    qemu_bh_schedule(n->tx_bh);\n\n    n->tx_waiting = 1;\n\n}\n", "idx": 5511}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int set_dirty_tracking(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n    int ret;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        bmds->dirty_bitmap = bdrv_create_dirty_bitmap(bmds->bs, BLOCK_SIZE,\n\n                                                      NULL);\n\n        if (!bmds->dirty_bitmap) {\n\n            ret = -errno;\n\n            goto fail;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nfail:\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        if (bmds->dirty_bitmap) {\n\n            bdrv_release_dirty_bitmap(bmds->bs, bmds->dirty_bitmap);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 11726}
{"project": "qemu", "commit_id": "4b236b621bf090509c4a0be372edfd31d13b289a", "target": 1, "func": "static void gen_spr_power5p_lpar(CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Logical partitionning */\n\n    spr_register_kvm(env, SPR_LPCR, \"LPCR\",\n\n\n                     &spr_read_generic, &spr_write_lpcr,\n\n                     KVM_REG_PPC_LPCR, LPCR_LPES0 | LPCR_LPES1);\n\n\n\n\n\n#endif\n\n}", "idx": 10122}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n", "idx": 205}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n", "idx": 11510}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    /* We only advertise 1 auth scheme at a time, so client\n\n     * must pick the one we sent. Verify this */\n\n    if (data[0] != vs->auth) { /* Reject auth */\n\n       VNC_DEBUG(\"Reject auth %d because it didn't match advertized\\n\", (int)data[0]);\n\n       vnc_write_u32(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Authentication failed\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    } else { /* Accept requested auth */\n\n       VNC_DEBUG(\"Client requested auth %d\\n\", (int)data[0]);\n\n       switch (vs->auth) {\n\n       case VNC_AUTH_NONE:\n\n           VNC_DEBUG(\"Accept auth none\\n\");\n\n           if (vs->minor >= 8) {\n\n               vnc_write_u32(vs, 0); /* Accept auth completion */\n\n               vnc_flush(vs);\n\n           }\n\n           start_client_init(vs);\n\n           break;\n\n\n\n       case VNC_AUTH_VNC:\n\n           VNC_DEBUG(\"Start VNC auth\\n\");\n\n           start_auth_vnc(vs);\n\n           break;\n\n\n\n       case VNC_AUTH_VENCRYPT:\n\n           VNC_DEBUG(\"Accept VeNCrypt auth\\n\");\n\n           start_auth_vencrypt(vs);\n\n           break;\n\n\n\n#ifdef CONFIG_VNC_SASL\n\n       case VNC_AUTH_SASL:\n\n           VNC_DEBUG(\"Accept SASL auth\\n\");\n\n           start_auth_sasl(vs);\n\n           break;\n\n#endif /* CONFIG_VNC_SASL */\n\n\n\n       default: /* Should not be possible, but just in case */\n\n           VNC_DEBUG(\"Reject auth %d server code bug\\n\", vs->auth);\n\n           vnc_write_u8(vs, 1);\n\n           if (vs->minor >= 8) {\n\n               static const char err[] = \"Authentication failed\";\n\n               vnc_write_u32(vs, sizeof(err));\n\n               vnc_write(vs, err, sizeof(err));\n\n           }\n\n           vnc_client_error(vs);\n\n       }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1524}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_pop_next_tx_descr(VMXNET3State *s,\n\n                          int qidx,\n\n                          struct Vmxnet3_TxDesc *txd,\n\n                          uint32_t *descr_idx)\n\n{\n\n    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {\n\n        /* Only read after generation field verification */\n\n        smp_rmb();\n\n        /* Re-read to be sure we got the latest version */\n\n        vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n        VMXNET3_RING_DUMP(VMW_RIPRN, \"TX\", qidx, ring);\n\n        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);\n\n        vmxnet3_inc_tx_consumption_counter(s, qidx);\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 2453}
{"project": "qemu", "commit_id": "43849424cff82803011fad21074531a1101e514e", "target": 1, "func": "static void tap_cleanup(VLANClientState *nc)\n\n{\n\n    TAPState *s = DO_UPCAST(TAPState, nc, nc);\n\n\n\n    if (s->vhost_net) {\n\n        vhost_net_cleanup(s->vhost_net);\n\n\n    }\n\n\n\n    qemu_purge_queued_packets(nc);\n\n\n\n    if (s->down_script[0])\n\n        launch_script(s->down_script, s->down_script_arg, s->fd);\n\n\n\n    tap_read_poll(s, 0);\n\n    tap_write_poll(s, 0);\n\n    close(s->fd);\n\n}", "idx": 1216}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_configuration_status(void *priv, uint32_t id,\n\n    struct usb_redir_configuration_status_header *config_status)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    AsyncURB *aurb;\n\n    int len = 0;\n\n\n\n    DPRINTF(\"set config status %d config %d id %u\\n\", config_status->status,\n\n            config_status->configuration, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        return;\n\n    }\n\n    if (aurb->packet) {\n\n        if (aurb->get) {\n\n            dev->dev.data_buf[0] = config_status->configuration;\n\n            len = 1;\n\n        }\n\n        aurb->packet->len =\n\n            usbredir_handle_status(dev, config_status->status, len);\n\n        usb_generic_async_ctrl_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n}\n", "idx": 4704}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 7265}
{"project": "qemu", "commit_id": "6d0b908a628a7086fa855c68b217cc1e2a5c4c19", "target": 1, "func": "dispatcher_wait(Dispatcher *dispr, uint32_t timeout)\n\n{\n\n    struct timeval tv;\n\n    tv.tv_sec = timeout / 1000000;\n\n    tv.tv_usec = timeout % 1000000;\n\n\n\n    fd_set fdset = dispr->fdset;\n\n\n\n    /* wait until some of sockets become readable. */\n\n    int rc = select(dispr->max_sock + 1, &fdset, 0, 0, &tv);\n\n\n\n    if (rc == -1) {\n\n        vubr_die(\"select\");\n\n    }\n\n\n\n    /* Timeout */\n\n    if (rc == 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* Now call callback for every ready socket. */\n\n\n\n    int sock;\n\n    for (sock = 0; sock < dispr->max_sock + 1; sock++)\n\n        if (FD_ISSET(sock, &fdset)) {\n\n            Event *e = &dispr->events[sock];\n\n            e->callback(sock, e->ctx);\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 5951}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "static void liveness_pass_1(TCGContext *s)\n\n{\n\n    int nb_globals = s->nb_globals;\n\n    int oi, oi_prev;\n\n\n\n    tcg_la_func_end(s);\n\n\n\n    for (oi = s->gen_op_buf[0].prev; oi != 0; oi = oi_prev) {\n\n        int i, nb_iargs, nb_oargs;\n\n        TCGOpcode opc_new, opc_new2;\n\n        bool have_opc_new2;\n\n        TCGLifeData arg_life = 0;\n\n        TCGTemp *arg_ts;\n\n\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n\n\n        oi_prev = op->prev;\n\n\n\n        switch (opc) {\n\n        case INDEX_op_call:\n\n            {\n\n                int call_flags;\n\n\n\n                nb_oargs = op->callo;\n\n                nb_iargs = op->calli;\n\n                call_flags = op->args[nb_oargs + nb_iargs + 1];\n\n\n\n                /* pure functions can be removed if their result is unused */\n\n                if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) {\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg_ts = arg_temp(op->args[i]);\n\n                        if (arg_ts->state != TS_DEAD) {\n\n                            goto do_not_remove_call;\n\n                        }\n\n                    }\n\n                    goto do_remove;\n\n                } else {\n\n                do_not_remove_call:\n\n\n\n                    /* output args are dead */\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg_ts = arg_temp(op->args[i]);\n\n                        if (arg_ts->state & TS_DEAD) {\n\n                            arg_life |= DEAD_ARG << i;\n\n                        }\n\n                        if (arg_ts->state & TS_MEM) {\n\n                            arg_life |= SYNC_ARG << i;\n\n                        }\n\n                        arg_ts->state = TS_DEAD;\n\n                    }\n\n\n\n                    if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS |\n\n                                        TCG_CALL_NO_READ_GLOBALS))) {\n\n                        /* globals should go back to memory */\n\n                        for (i = 0; i < nb_globals; i++) {\n\n                            s->temps[i].state = TS_DEAD | TS_MEM;\n\n                        }\n\n                    } else if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) {\n\n                        /* globals should be synced to memory */\n\n                        for (i = 0; i < nb_globals; i++) {\n\n                            s->temps[i].state |= TS_MEM;\n\n                        }\n\n                    }\n\n\n\n                    /* record arguments that die in this helper */\n\n                    for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n                        arg_ts = arg_temp(op->args[i]);\n\n                        if (arg_ts && arg_ts->state & TS_DEAD) {\n\n                            arg_life |= DEAD_ARG << i;\n\n                        }\n\n                    }\n\n                    /* input arguments are live for preceding opcodes */\n\n                    for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n                        arg_ts = arg_temp(op->args[i]);\n\n                        if (arg_ts) {\n\n                            arg_ts->state &= ~TS_DEAD;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case INDEX_op_insn_start:\n\n            break;\n\n        case INDEX_op_discard:\n\n            /* mark the temporary as dead */\n\n            arg_temp(op->args[0])->state = TS_DEAD;\n\n            break;\n\n\n\n        case INDEX_op_add2_i32:\n\n            opc_new = INDEX_op_add_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i32:\n\n            opc_new = INDEX_op_sub_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_add2_i64:\n\n            opc_new = INDEX_op_add_i64;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i64:\n\n            opc_new = INDEX_op_sub_i64;\n\n        do_addsub2:\n\n            nb_iargs = 4;\n\n            nb_oargs = 2;\n\n            /* Test if the high part of the operation is dead, but not\n\n               the low part.  The result can be optimized to a simple\n\n               add or sub.  This happens often for x86_64 guest when the\n\n               cpu mode is set to 32 bit.  */\n\n            if (arg_temp(op->args[1])->state == TS_DEAD) {\n\n                if (arg_temp(op->args[0])->state == TS_DEAD) {\n\n                    goto do_remove;\n\n                }\n\n                /* Replace the opcode and adjust the args in place,\n\n                   leaving 3 unused args at the end.  */\n\n                op->opc = opc = opc_new;\n\n                op->args[1] = op->args[2];\n\n                op->args[2] = op->args[4];\n\n                /* Fall through and mark the single-word operation live.  */\n\n                nb_iargs = 2;\n\n                nb_oargs = 1;\n\n            }\n\n            goto do_not_remove;\n\n\n\n        case INDEX_op_mulu2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_muluh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_mulsh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_mulu2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_muluh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i64;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_mulsh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i64;\n\n            goto do_mul2;\n\n        do_mul2:\n\n            nb_iargs = 2;\n\n            nb_oargs = 2;\n\n            if (arg_temp(op->args[1])->state == TS_DEAD) {\n\n                if (arg_temp(op->args[0])->state == TS_DEAD) {\n\n                    /* Both parts of the operation are dead.  */\n\n                    goto do_remove;\n\n                }\n\n                /* The high part of the operation is dead; generate the low. */\n\n                op->opc = opc = opc_new;\n\n                op->args[1] = op->args[2];\n\n                op->args[2] = op->args[3];\n\n            } else if (arg_temp(op->args[0])->state == TS_DEAD && have_opc_new2) {\n\n                /* The low part of the operation is dead; generate the high. */\n\n                op->opc = opc = opc_new2;\n\n                op->args[0] = op->args[1];\n\n                op->args[1] = op->args[2];\n\n                op->args[2] = op->args[3];\n\n            } else {\n\n                goto do_not_remove;\n\n            }\n\n            /* Mark the single-word operation live.  */\n\n            nb_oargs = 1;\n\n            goto do_not_remove;\n\n\n\n        default:\n\n            /* XXX: optimize by hardcoding common cases (e.g. triadic ops) */\n\n            nb_iargs = def->nb_iargs;\n\n            nb_oargs = def->nb_oargs;\n\n\n\n            /* Test if the operation can be removed because all\n\n               its outputs are dead. We assume that nb_oargs == 0\n\n               implies side effects */\n\n            if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) {\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    if (arg_temp(op->args[i])->state != TS_DEAD) {\n\n                        goto do_not_remove;\n\n                    }\n\n                }\n\n            do_remove:\n\n                tcg_op_remove(s, op);\n\n            } else {\n\n            do_not_remove:\n\n                /* output args are dead */\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg_ts = arg_temp(op->args[i]);\n\n                    if (arg_ts->state & TS_DEAD) {\n\n                        arg_life |= DEAD_ARG << i;\n\n                    }\n\n                    if (arg_ts->state & TS_MEM) {\n\n                        arg_life |= SYNC_ARG << i;\n\n                    }\n\n                    arg_ts->state = TS_DEAD;\n\n                }\n\n\n\n                /* if end of basic block, update */\n\n                if (def->flags & TCG_OPF_BB_END) {\n\n                    tcg_la_bb_end(s);\n\n                } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n\n                    /* globals should be synced to memory */\n\n                    for (i = 0; i < nb_globals; i++) {\n\n                        s->temps[i].state |= TS_MEM;\n\n                    }\n\n                }\n\n\n\n                /* record arguments that die in this opcode */\n\n                for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n                    arg_ts = arg_temp(op->args[i]);\n\n                    if (arg_ts->state & TS_DEAD) {\n\n                        arg_life |= DEAD_ARG << i;\n\n                    }\n\n                }\n\n                /* input arguments are live for preceding opcodes */\n\n                for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n                    arg_temp(op->args[i])->state &= ~TS_DEAD;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n        op->life = arg_life;\n\n    }\n\n}\n", "idx": 7285}
{"project": "qemu", "commit_id": "a760715095e9cda6eb97486c040aa35f82297945", "target": 1, "func": "QemuOptsList *qemu_opts_append(QemuOptsList *dst,\n\n                               QemuOptsList *list)\n\n{\n\n    size_t num_opts, num_dst_opts;\n\n    QemuOptDesc *desc;\n\n    bool need_init = false;\n\n\n\n    if (!list) {\n\n        return dst;\n\n    }\n\n\n\n    /* If dst is NULL, after realloc, some area of dst should be initialized\n\n     * before adding options to it.\n\n     */\n\n    if (!dst) {\n\n        need_init = true;\n\n    }\n\n\n\n    num_opts = count_opts_list(dst);\n\n    num_dst_opts = num_opts;\n\n    num_opts += count_opts_list(list);\n\n    dst = g_realloc(dst, sizeof(QemuOptsList) +\n\n                    (num_opts + 1) * sizeof(QemuOptDesc));\n\n    if (need_init) {\n\n        dst->name = NULL;\n\n        dst->implied_opt_name = NULL;\n\n        QTAILQ_INIT(&dst->head);\n\n        dst->merge_lists = false;\n\n    }\n\n    dst->desc[num_dst_opts].name = NULL;\n\n\n\n    /* append list->desc to dst->desc */\n\n    if (list) {\n\n        desc = list->desc;\n\n        while (desc && desc->name) {\n\n            if (find_desc_by_name(dst->desc, desc->name) == NULL) {\n\n                dst->desc[num_dst_opts++] = *desc;\n\n                dst->desc[num_dst_opts].name = NULL;\n\n            }\n\n            desc++;\n\n        }\n\n    }\n\n\n\n    return dst;\n\n}\n", "idx": 1743}
{"project": "qemu", "commit_id": "3e4f910c8d490a1490409a7e381dbbb229f9d272", "target": 1, "func": "static int ehci_register_companion(USBBus *bus, USBPort *ports[],\n\n                                   uint32_t portcount, uint32_t firstport)\n\n{\n\n    EHCIState *s = container_of(bus, EHCIState, bus);\n\n    uint32_t i;\n\n\n\n    if (firstport + portcount > NB_PORTS) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"firstport\",\n\n                      \"firstport on masterbus\");\n\n        error_printf_unless_qmp(\n\n            \"firstport value of %u makes companion take ports %u - %u, which \"\n\n            \"is outside of the valid range of 0 - %u\\n\", firstport, firstport,\n\n            firstport + portcount - 1, NB_PORTS - 1);\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < portcount; i++) {\n\n        if (s->companion_ports[firstport + i]) {\n\n            qerror_report(QERR_INVALID_PARAMETER_VALUE, \"masterbus\",\n\n                          \"an USB masterbus\");\n\n            error_printf_unless_qmp(\n\n                \"port %u on masterbus %s already has a companion assigned\\n\",\n\n                firstport + i, bus->qbus.name);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < portcount; i++) {\n\n        s->companion_ports[firstport + i] = ports[i];\n\n        s->ports[firstport + i].speedmask |=\n\n            USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL;\n\n        /* Ensure devs attached before the initial reset go to the companion */\n\n        s->portsc[firstport + i] = PORTSC_POWNER;\n\n    }\n\n\n\n    s->companion_count++;\n\n    s->mmio[0x05] = (s->companion_count << 4) | portcount;\n\n\n\n    return 0;\n\n}\n", "idx": 6840}
{"project": "qemu", "commit_id": "882b3b97697affb36ca3d174f42f846232008979", "target": 1, "func": "int css_create_css_image(uint8_t cssid, bool default_image)\n\n{\n\n    trace_css_new_image(cssid, default_image ? \"(default)\" : \"\");\n\n    if (cssid > MAX_CSSID) {\n\n        return -EINVAL;\n\n    }\n\n    if (channel_subsys.css[cssid]) {\n\n        return -EBUSY;\n\n    }\n\n    channel_subsys.css[cssid] = g_malloc0(sizeof(CssImage));\n\n    if (default_image) {\n\n        channel_subsys.default_cssid = cssid;\n\n    }\n\n    return 0;\n\n}\n", "idx": 11762}
{"project": "qemu", "commit_id": "0c53d7342b4e8412f3b81eed67f053304813dc5d", "target": 1, "func": "static void gen_ove_ov(DisasContext *dc, TCGv ov)\n\n{\n\n    gen_helper_ove(cpu_env, ov);\n\n}\n", "idx": 11971}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void vmsvga_init(DeviceState *dev, struct vmsvga_state_s *s,\n\n                        MemoryRegion *address_space, MemoryRegion *io)\n\n{\n\n    s->scratch_size = SVGA_SCRATCH_SIZE;\n\n    s->scratch = g_malloc(s->scratch_size * 4);\n\n\n\n    s->vga.con = graphic_console_init(dev, 0, &vmsvga_ops, s);\n\n\n\n    s->fifo_size = SVGA_FIFO_SIZE;\n\n    memory_region_init_ram(&s->fifo_ram, NULL, \"vmsvga.fifo\", s->fifo_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->fifo_ram);\n\n    s->fifo_ptr = memory_region_get_ram_ptr(&s->fifo_ram);\n\n\n\n    vga_common_init(&s->vga, OBJECT(dev), true);\n\n    vga_init(&s->vga, OBJECT(dev), address_space, io, true);\n\n    vmstate_register(NULL, 0, &vmstate_vga_common, &s->vga);\n\n    s->new_depth = 32;\n\n}\n", "idx": 5064}
{"project": "qemu", "commit_id": "089305ac0a273e64c9a5655d26da7fe19ecee66f", "target": 1, "func": "static void gen_rot_rm_T1(DisasContext *s, int ot, int op1, int is_right)\n\n{\n\n    target_ulong mask = (ot == OT_QUAD ? 0x3f : 0x1f);\n\n    TCGv_i32 t0, t1;\n\n\n\n    /* load */\n\n    if (op1 == OR_TMP0) {\n\n        gen_op_ld_T0_A0(ot + s->mem_index);\n\n    } else {\n\n        gen_op_mov_TN_reg(ot, 0, op1);\n\n    }\n\n\n\n    tcg_gen_andi_tl(cpu_T[1], cpu_T[1], mask);\n\n\n\n    switch (ot) {\n\n    case OT_BYTE:\n\n        /* Replicate the 8-bit input so that a 32-bit rotate works.  */\n\n        tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);\n\n        tcg_gen_muli_tl(cpu_T[0], cpu_T[0], 0x01010101);\n\n        goto do_long;\n\n    case OT_WORD:\n\n        /* Replicate the 16-bit input so that a 32-bit rotate works.  */\n\n        tcg_gen_deposit_tl(cpu_T[0], cpu_T[0], cpu_T[0], 16, 16);\n\n        goto do_long;\n\n    do_long:\n\n#ifdef TARGET_X86_64\n\n    case OT_LONG:\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);\n\n        if (is_right) {\n\n            tcg_gen_rotr_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        } else {\n\n            tcg_gen_rotl_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        }\n\n        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n        break;\n\n#endif\n\n    default:\n\n        if (is_right) {\n\n            tcg_gen_rotr_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n        } else {\n\n            tcg_gen_rotl_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n        }\n\n        break;\n\n    }\n\n\n\n    /* store */\n\n    if (op1 == OR_TMP0) {\n\n        gen_op_st_T0_A0(ot + s->mem_index);\n\n    } else {\n\n        gen_op_mov_reg_T0(ot, op1);\n\n    }\n\n\n\n    /* We'll need the flags computed into CC_SRC.  */\n\n    gen_compute_eflags(s);\n\n\n\n    /* The value that was \"rotated out\" is now present at the other end\n\n       of the word.  Compute C into CC_DST and O into CC_SRC2.  Note that\n\n       since we've computed the flags into CC_SRC, these variables are\n\n       currently dead.  */\n\n    if (is_right) {\n\n        tcg_gen_shri_tl(cpu_cc_src2, cpu_T[0], mask - 1);\n\n        tcg_gen_shri_tl(cpu_cc_dst, cpu_T[0], mask);\n\n\n    } else {\n\n        tcg_gen_shri_tl(cpu_cc_src2, cpu_T[0], mask);\n\n        tcg_gen_andi_tl(cpu_cc_dst, cpu_T[0], 1);\n\n    }\n\n    tcg_gen_andi_tl(cpu_cc_src2, cpu_cc_src2, 1);\n\n    tcg_gen_xor_tl(cpu_cc_src2, cpu_cc_src2, cpu_cc_dst);\n\n\n\n    /* Now conditionally store the new CC_OP value.  If the shift count\n\n       is 0 we keep the CC_OP_EFLAGS setting so that only CC_SRC is live.\n\n       Otherwise reuse CC_OP_ADCOX which have the C and O flags split out\n\n       exactly as we computed above.  */\n\n    t0 = tcg_const_i32(0);\n\n    t1 = tcg_temp_new_i32();\n\n    tcg_gen_trunc_tl_i32(t1, cpu_T[1]);\n\n    tcg_gen_movi_i32(cpu_tmp2_i32, CC_OP_ADCOX); \n\n    tcg_gen_movi_i32(cpu_tmp3_i32, CC_OP_EFLAGS);\n\n    tcg_gen_movcond_i32(TCG_COND_NE, cpu_cc_op, t1, t0,\n\n                        cpu_tmp2_i32, cpu_tmp3_i32);\n\n    tcg_temp_free_i32(t0);\n\n    tcg_temp_free_i32(t1);\n\n\n\n    /* The CC_OP value is no longer predictable.  */ \n\n    set_cc_op(s, CC_OP_DYNAMIC);\n\n}", "idx": 3864}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static uint16_t vring_used_idx(VirtQueue *vq)\n\n{\n\n    VRingMemoryRegionCaches *caches = atomic_rcu_read(&vq->vring.caches);\n\n    hwaddr pa = offsetof(VRingUsed, idx);\n\n    return virtio_lduw_phys_cached(vq->vdev, &caches->used, pa);\n\n}\n", "idx": 857}
{"project": "qemu", "commit_id": "5ad4a2b75f85dd854a781a6e03b90320cb3441d3", "target": 1, "func": "bool address_space_access_valid(AddressSpace *as, hwaddr addr, int len, bool is_write)\n\n{\n\n    MemoryRegion *mr;\n\n    hwaddr l, xlat;\n\n\n\n    rcu_read_lock();\n\n    while (len > 0) {\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &xlat, &l, is_write);\n\n        if (!memory_access_is_direct(mr, is_write)) {\n\n            l = memory_access_size(mr, l, addr);\n\n            if (!memory_region_access_valid(mr, xlat, l, is_write)) {\n\n\n                return false;\n\n            }\n\n        }\n\n\n\n        len -= l;\n\n        addr += l;\n\n    }\n\n\n    return true;\n\n}", "idx": 538}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writew(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xfe;\n\n\n\n    switch (addr)\n\n    {\n\n        case IntrMask:\n\n            rtl8139_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case IntrStatus:\n\n            rtl8139_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case MultiIntr:\n\n            rtl8139_MultiIntr_write(s, val);\n\n            break;\n\n\n\n        case RxBufPtr:\n\n            rtl8139_RxBufPtr_write(s, val);\n\n            break;\n\n\n\n        case BasicModeCtrl:\n\n            rtl8139_BasicModeCtrl_write(s, val);\n\n            break;\n\n        case BasicModeStatus:\n\n            rtl8139_BasicModeStatus_write(s, val);\n\n            break;\n\n        case NWayAdvert:\n\n            DPRINTF(\"NWayAdvert write(w) val=0x%04x\\n\", val);\n\n            s->NWayAdvert = val;\n\n            break;\n\n        case NWayLPAR:\n\n            DPRINTF(\"forbidden NWayLPAR write(w) val=0x%04x\\n\", val);\n\n            break;\n\n        case NWayExpansion:\n\n            DPRINTF(\"NWayExpansion write(w) val=0x%04x\\n\", val);\n\n            s->NWayExpansion = val;\n\n            break;\n\n\n\n        case CpCmd:\n\n            rtl8139_CpCmd_write(s, val);\n\n            break;\n\n\n\n        case IntrMitigate:\n\n            rtl8139_IntrMitigate_write(s, val);\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"ioport write(w) addr=0x%x val=0x%04x via write(b)\\n\",\n\n                addr, val);\n\n\n\n            rtl8139_io_writeb(opaque, addr, val & 0xff);\n\n            rtl8139_io_writeb(opaque, addr + 1, (val >> 8) & 0xff);\n\n            break;\n\n    }\n\n}\n", "idx": 11434}
{"project": "qemu", "commit_id": "544a3731591f5d53e15f22de00ce5ac758d490b3", "target": 1, "func": "static void test_visitor_out_alternate(TestOutputVisitorData *data,\n\n                                       const void *unused)\n\n{\n\n    QObject *arg;\n\n    UserDefAlternate *tmp;\n\n    QDict *qdict;\n\n\n\n    tmp = g_new0(UserDefAlternate, 1);\n\n    tmp->type = QTYPE_QINT;\n\n    tmp->u.i = 42;\n\n\n\n    visit_type_UserDefAlternate(data->ov, NULL, &tmp, &error_abort);\n\n    arg = qmp_output_get_qobject(data->qov);\n\n\n\n    g_assert(qobject_type(arg) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(arg)), ==, 42);\n\n\n\n    qapi_free_UserDefAlternate(tmp);\n\n    qobject_decref(arg);\n\n\n\n    tmp = g_new0(UserDefAlternate, 1);\n\n    tmp->type = QTYPE_QSTRING;\n\n    tmp->u.s = g_strdup(\"hello\");\n\n\n\n    visit_type_UserDefAlternate(data->ov, NULL, &tmp, &error_abort);\n\n    arg = qmp_output_get_qobject(data->qov);\n\n\n\n    g_assert(qobject_type(arg) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(arg)), ==, \"hello\");\n\n\n\n    qapi_free_UserDefAlternate(tmp);\n\n    qobject_decref(arg);\n\n\n\n    tmp = g_new0(UserDefAlternate, 1);\n\n    tmp->type = QTYPE_QDICT;\n\n    tmp->u.udfu.integer = 1;\n\n    tmp->u.udfu.string = g_strdup(\"str\");\n\n    tmp->u.udfu.enum1 = ENUM_ONE_VALUE1;\n\n    tmp->u.udfu.u.value1 = g_new0(UserDefA, 1);\n\n    tmp->u.udfu.u.value1->boolean = true;\n\n\n\n    visit_type_UserDefAlternate(data->ov, NULL, &tmp, &error_abort);\n\n    arg = qmp_output_get_qobject(data->qov);\n\n\n\n    g_assert_cmpint(qobject_type(arg), ==, QTYPE_QDICT);\n\n    qdict = qobject_to_qdict(arg);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 4);\n\n    g_assert_cmpint(qdict_get_int(qdict, \"integer\"), ==, 1);\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"string\"), ==, \"str\");\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"enum1\"), ==, \"value1\");\n\n    g_assert_cmpint(qdict_get_bool(qdict, \"boolean\"), ==, true);\n\n\n\n    qapi_free_UserDefAlternate(tmp);\n\n    qobject_decref(arg);\n\n}\n", "idx": 3345}
{"project": "qemu", "commit_id": "21174c34b6b9ace9ad82e0deb13be752d28a5907", "target": 1, "func": "static int get_unused_buffer(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    qemu_fseek(f, size, SEEK_CUR);\n\n    return 0;\n\n}\n", "idx": 3622}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 6394}
{"project": "qemu", "commit_id": "787aaf5703a702094f395db6795e74230282cd62", "target": 1, "func": "static void cpu_x86_register(X86CPU *cpu, const char *name, Error **errp)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    x86_def_t def1, *def = &def1;\n\n\n\n    memset(def, 0, sizeof(*def));\n\n\n\n    if (cpu_x86_find_by_name(cpu, def, name) < 0) {\n\n        error_setg(errp, \"Unable to find CPU definition: %s\", name);\n\n        return;\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        def->features[FEAT_KVM] |= kvm_default_features;\n\n    }\n\n    def->features[FEAT_1_ECX] |= CPUID_EXT_HYPERVISOR;\n\n\n\n    object_property_set_str(OBJECT(cpu), def->vendor, \"vendor\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->level, \"level\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->family, \"family\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->model, \"model\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->stepping, \"stepping\", errp);\n\n    env->features[FEAT_1_EDX] = def->features[FEAT_1_EDX];\n\n    env->features[FEAT_1_ECX] = def->features[FEAT_1_ECX];\n\n    env->features[FEAT_8000_0001_EDX] = def->features[FEAT_8000_0001_EDX];\n\n    env->features[FEAT_8000_0001_ECX] = def->features[FEAT_8000_0001_ECX];\n\n    object_property_set_int(OBJECT(cpu), def->xlevel, \"xlevel\", errp);\n\n    env->features[FEAT_KVM] = def->features[FEAT_KVM];\n\n    env->features[FEAT_SVM] = def->features[FEAT_SVM];\n\n    env->features[FEAT_C000_0001_EDX] = def->features[FEAT_C000_0001_EDX];\n\n    env->features[FEAT_7_0_EBX] = def->features[FEAT_7_0_EBX];\n\n    env->cpuid_xlevel2 = def->xlevel2;\n\n\n\n\n    object_property_set_str(OBJECT(cpu), def->model_id, \"model-id\", errp);\n\n}", "idx": 7700}
{"project": "qemu", "commit_id": "d6309c170eb99950c9f1d881a5ff7163ae28d353", "target": 1, "func": "static void test_acpi_piix4_tcg_cphp(void)\n\n{\n\n    test_data data;\n\n\n\n    memset(&data, 0, sizeof(data));\n\n    data.machine = MACHINE_PC;\n\n    data.variant = \".cphp\";\n\n    test_acpi_one(\"-smp 2,cores=3,sockets=2,maxcpus=6\",\n\n                  &data);\n\n    free_test_data(&data);\n\n}\n", "idx": 5310}
{"project": "qemu", "commit_id": "7797a73947d5c0e63dd5552b348cf66c384b4555", "target": 1, "func": "static void pxa2xx_pcmcia_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    dc->realize = pxa2xx_pcmcia_realize;\n\n}\n", "idx": 8299}
{"project": "qemu", "commit_id": "2caa9e9d2e0f356cc244bc41ce1d3e81663f6782", "target": 1, "func": "static int vnc_zlib_stop(VncState *vs)\n\n{\n\n    z_streamp zstream = &vs->zlib.stream;\n\n    int previous_out;\n\n\n\n    // switch back to normal output/zlib buffers\n\n    vs->zlib.zlib = vs->output;\n\n    vs->output = vs->zlib.tmp;\n\n\n\n    // compress the zlib buffer\n\n\n\n    // initialize the stream\n\n    // XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream\\n\");\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = vnc_zlib_zalloc;\n\n        zstream->zfree = vnc_zlib_zfree;\n\n\n\n        err = deflateInit2(zstream, vs->tight.compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        vs->zlib.level = vs->tight.compression;\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    if (vs->tight.compression != vs->zlib.level) {\n\n        if (deflateParams(zstream, vs->tight.compression,\n\n                          Z_DEFAULT_STRATEGY) != Z_OK) {\n\n            return -1;\n\n        }\n\n        vs->zlib.level = vs->tight.compression;\n\n    }\n\n\n\n    // reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.zlib.offset + 64);\n\n\n\n    // set pointers\n\n    zstream->next_in = vs->zlib.zlib.buffer;\n\n    zstream->avail_in = vs->zlib.zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    // start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n", "idx": 9943}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static bool gen_wsr_ccompare(DisasContext *dc, uint32_t sr, TCGv_i32 v)\n\n{\n\n    uint32_t id = sr - CCOMPARE;\n\n    bool ret = false;\n\n\n\n    if (id < dc->config->nccompare) {\n\n        uint32_t int_bit = 1 << dc->config->timerint[id];\n\n        TCGv_i32 tmp = tcg_const_i32(id);\n\n\n\n        tcg_gen_mov_i32(cpu_SR[sr], v);\n\n        tcg_gen_andi_i32(cpu_SR[INTSET], cpu_SR[INTSET], ~int_bit);\n\n        if (dc->tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n        }\n\n        gen_helper_update_ccompare(cpu_env, tmp);\n\n        if (dc->tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jumpi_check_loop_end(dc, 0);\n\n            ret = true;\n\n        }\n\n        tcg_temp_free(tmp);\n\n    }\n\n    return ret;\n\n}\n", "idx": 8539}
{"project": "qemu", "commit_id": "58117c9bb429cd9552d998687aa99088eb1d8528", "target": 1, "func": "uint32_t HELPER(v7m_mrs)(CPUARMState *env, uint32_t reg)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n\n\n    switch (reg) {\n\n    case 0: /* APSR */\n\n        return xpsr_read(env) & 0xf8000000;\n\n    case 1: /* IAPSR */\n\n        return xpsr_read(env) & 0xf80001ff;\n\n    case 2: /* EAPSR */\n\n        return xpsr_read(env) & 0xff00fc00;\n\n    case 3: /* xPSR */\n\n        return xpsr_read(env) & 0xff00fdff;\n\n    case 5: /* IPSR */\n\n        return xpsr_read(env) & 0x000001ff;\n\n    case 6: /* EPSR */\n\n        return xpsr_read(env) & 0x0700fc00;\n\n    case 7: /* IEPSR */\n\n        return xpsr_read(env) & 0x0700edff;\n\n    case 8: /* MSP */\n\n        return env->v7m.current_sp ? env->v7m.other_sp : env->regs[13];\n\n    case 9: /* PSP */\n\n        return env->v7m.current_sp ? env->regs[13] : env->v7m.other_sp;\n\n    case 16: /* PRIMASK */\n\n        return (env->daif & PSTATE_I) != 0;\n\n    case 17: /* BASEPRI */\n\n    case 18: /* BASEPRI_MAX */\n\n        return env->v7m.basepri;\n\n    case 19: /* FAULTMASK */\n\n        return (env->daif & PSTATE_F) != 0;\n\n    case 20: /* CONTROL */\n\n        return env->v7m.control;\n\n    default:\n\n        /* ??? For debugging only.  */\n\n        cpu_abort(CPU(cpu), \"Unimplemented system register read (%d)\\n\", reg);\n\n        return 0;\n\n    }\n\n}\n", "idx": 3467}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "static void xics_kvm_realize(DeviceState *dev, Error **errp)\n\n{\n\n    KVMXICSState *icpkvm = KVM_XICS(dev);\n\n    XICSState *icp = XICS_COMMON(dev);\n\n    int i, rc;\n\n    Error *error = NULL;\n\n    struct kvm_create_device xics_create_device = {\n\n        .type = KVM_DEV_TYPE_XICS,\n\n        .flags = 0,\n\n    };\n\n\n\n    if (!kvm_enabled() || !kvm_check_extension(kvm_state, KVM_CAP_IRQ_XICS)) {\n\n        error_setg(errp,\n\n                   \"KVM and IRQ_XICS capability must be present for in-kernel XICS\");\n\n        goto fail;\n\n    }\n\n\n\n    icpkvm->set_xive_token = spapr_rtas_register(\"ibm,set-xive\", rtas_dummy);\n\n    icpkvm->get_xive_token = spapr_rtas_register(\"ibm,get-xive\", rtas_dummy);\n\n    icpkvm->int_off_token = spapr_rtas_register(\"ibm,int-off\", rtas_dummy);\n\n    icpkvm->int_on_token = spapr_rtas_register(\"ibm,int-on\", rtas_dummy);\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(icpkvm->set_xive_token,\n\n                                         \"ibm,set-xive\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,set-xive\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(icpkvm->get_xive_token,\n\n                                         \"ibm,get-xive\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,get-xive\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(icpkvm->int_on_token, \"ibm,int-on\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,int-on\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(icpkvm->int_off_token, \"ibm,int-off\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,int-off\");\n\n        goto fail;\n\n    }\n\n\n\n    /* Create the kernel ICP */\n\n    rc = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &xics_create_device);\n\n    if (rc < 0) {\n\n        error_setg_errno(errp, -rc, \"Error on KVM_CREATE_DEVICE for XICS\");\n\n        goto fail;\n\n    }\n\n\n\n    icpkvm->kernel_xics_fd = xics_create_device.fd;\n\n\n\n    object_property_set_bool(OBJECT(icp->ics), true, \"realized\", &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto fail;\n\n    }\n\n\n\n    assert(icp->nr_servers);\n\n    for (i = 0; i < icp->nr_servers; i++) {\n\n        object_property_set_bool(OBJECT(&icp->ss[i]), true, \"realized\", &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    kvm_kernel_irqchip = true;\n\n    kvm_irqfds_allowed = true;\n\n    kvm_msi_via_irqfd_allowed = true;\n\n    kvm_gsi_direct_mapping = true;\n\n\n\n    return;\n\n\n\nfail:\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,set-xive\");\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,get-xive\");\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,int-on\");\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,int-off\");\n\n}\n", "idx": 3297}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void kvmclock_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = kvmclock_realize;\n\n    dc->vmsd = &kvmclock_vmsd;\n\n    dc->props = kvmclock_properties;\n\n\n\n\n\n\n}", "idx": 7024}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static int32_t scsi_target_send_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSITargetReq *r = DO_UPCAST(SCSITargetReq, req, req);\n\n\n\n    switch (buf[0]) {\n\n    case REPORT_LUNS:\n\n        if (!scsi_target_emulate_report_luns(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n        if (!scsi_target_emulate_inquiry(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case REQUEST_SENSE:\n\n        r->len = scsi_device_get_sense(r->req.dev, r->buf,\n\n                                       MIN(req->cmd.xfer, sizeof r->buf),\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        if (r->req.dev->sense_is_ua) {\n\n            scsi_device_unit_attention_reported(req->dev);\n\n            r->req.dev->sense_len = 0;\n\n            r->req.dev->sense_is_ua = false;\n\n        }\n\n        break;\n\n    default:\n\n        scsi_req_build_sense(req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    illegal_request:\n\n        scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (!r->len) {\n\n        scsi_req_complete(req, GOOD);\n\n    }\n\n    return r->len;\n\n}\n", "idx": 6168}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "void ahci_init(AHCIState *s, DeviceState *qdev, AddressSpace *as, int ports)\n\n{\n\n    qemu_irq *irqs;\n\n    int i;\n\n\n\n    s->as = as;\n\n    s->ports = ports;\n\n    s->dev = g_malloc0(sizeof(AHCIDevice) * ports);\n\n    ahci_reg_init(s);\n\n    /* XXX BAR size should be 1k, but that breaks, so bump it to 4k for now */\n\n    memory_region_init_io(&s->mem, OBJECT(qdev), &ahci_mem_ops, s,\n\n                          \"ahci\", AHCI_MEM_BAR_SIZE);\n\n    memory_region_init_io(&s->idp, OBJECT(qdev), &ahci_idp_ops, s,\n\n                          \"ahci-idp\", 32);\n\n\n\n    irqs = qemu_allocate_irqs(ahci_irq_set, s, s->ports);\n\n\n\n    for (i = 0; i < s->ports; i++) {\n\n        AHCIDevice *ad = &s->dev[i];\n\n\n\n        ide_bus_new(&ad->port, sizeof(ad->port), qdev, i, 1);\n\n        ide_init2(&ad->port, irqs[i]);\n\n\n\n        ad->hba = s;\n\n        ad->port_no = i;\n\n        ad->port.dma = &ad->dma;\n\n        ad->port.dma->ops = &ahci_dma_ops;\n\n    }\n\n}\n", "idx": 445}
{"project": "qemu", "commit_id": "cb72cba83021fa42719e73a5249c12096a4d1cfc", "target": 1, "func": "uint32_t ide_data_readw(void *opaque, uint32_t addr)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n    int ret;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set. The result of a read\n\n     * during PIO in is indeterminate, return 0 and don't move forward. */\n\n    if (!(s->status & DRQ_STAT) || !ide_is_pio_out(s)) {\n\n        return 0;\n\n    }\n\n\n\n    p = s->data_ptr;\n\n    if (p + 2 > s->data_end) {\n\n        return 0;\n\n    }\n\n\n\n    ret = cpu_to_le16(*(uint16_t *)p);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n    return ret;\n\n}\n", "idx": 3935}
{"project": "qemu", "commit_id": "b93f995081cc32e56071fef179161d2907d0491e", "target": 1, "func": "int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n                        bool exact_size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int new_l1_size2, ret, i;\n    uint64_t *new_l1_table;\n    int64_t old_l1_table_offset, old_l1_size;\n    int64_t new_l1_table_offset, new_l1_size;\n    uint8_t data[12];\n    if (min_size <= s->l1_size)\n        return 0;\n    if (exact_size) {\n        new_l1_size = min_size;\n    } else {\n        /* Bump size up to reduce the number of times we have to grow */\n        new_l1_size = s->l1_size;\n        if (new_l1_size == 0) {\n            new_l1_size = 1;\n        while (min_size > new_l1_size) {\n            new_l1_size = (new_l1_size * 3 + 1) / 2;\n    if (new_l1_size > INT_MAX / sizeof(uint64_t)) {\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"grow l1_table from %d to %\" PRId64 \"\\n\",\n            s->l1_size, new_l1_size);\n#endif\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n    new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n    /* write new table (align to cluster) */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n    if (new_l1_table_offset < 0) {\n        g_free(new_l1_table);\n        return new_l1_table_offset;\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail;\n    /* the L1 position has not yet been updated, so these clusters must\n     * indeed be completely free */\n    ret = qcow2_pre_write_overlap_check(bs, 0, new_l1_table_offset,\n                                        new_l1_size2);\n    if (ret < 0) {\n        goto fail;\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n    ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n    if (ret < 0)\n        goto fail;\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n    /* set new table */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n    stq_be_p(data + 4, new_l1_table_offset);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n    if (ret < 0) {\n        goto fail;\n    g_free(s->l1_table);\n    old_l1_table_offset = s->l1_table_offset;\n    s->l1_table_offset = new_l1_table_offset;\n    s->l1_table = new_l1_table;\n    old_l1_size = s->l1_size;\n    s->l1_size = new_l1_size;\n    qcow2_free_clusters(bs, old_l1_table_offset, old_l1_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    return 0;\n fail:\n    g_free(new_l1_table);\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,\n                        QCOW2_DISCARD_OTHER);\n    return ret;", "idx": 3338}
{"project": "qemu", "commit_id": "69d34a360dfe773e17e72c76d15931c9b9d190f6", "target": 1, "func": "static off_t read_uint32(BlockDriverState *bs, int64_t offset)\n\n{\n\n\tuint32_t buffer;\n\n\tif (bdrv_pread(bs->file, offset, &buffer, 4) < 4)\n\n\t\treturn 0;\n\n\treturn be32_to_cpu(buffer);\n\n}\n", "idx": 11724}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static int do_co_pwrite_zeroes(BlockBackend *blk, int64_t offset,\n\n                               int64_t count, int flags, int64_t *total)\n\n{\n\n    Coroutine *co;\n\n    CoWriteZeroes data = {\n\n        .blk    = blk,\n\n        .offset = offset,\n\n        .count  = count,\n\n        .total  = total,\n\n        .flags  = flags,\n\n        .done   = false,\n\n    };\n\n\n\n    if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        return -ERANGE;\n\n    }\n\n\n\n    co = qemu_coroutine_create(co_pwrite_zeroes_entry);\n\n    qemu_coroutine_enter(co, &data);\n\n    while (!data.done) {\n\n        aio_poll(blk_get_aio_context(blk), true);\n\n    }\n\n    if (data.ret < 0) {\n\n        return data.ret;\n\n    } else {\n\n        return 1;\n\n    }\n\n}\n", "idx": 8099}
{"project": "qemu", "commit_id": "b2cd5b925c529d91fae5fe8373490714e1a8fe6c", "target": 1, "func": "static void test_keyval_parse_list(void)\n\n{\n\n    Error *err = NULL;\n\n    QDict *qdict, *sub_qdict;\n\n\n\n    /* Root can't be a list */\n\n    qdict = keyval_parse(\"0=1\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n\n\n    /* List elements need not be in order */\n\n    qdict = keyval_parse(\"list.0=null,list.2=zwei,list.1=eins\",\n\n                         NULL, &error_abort);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 1);\n\n    check_list012(qdict_get_qlist(qdict, \"list\"));\n\n    QDECREF(qdict);\n\n\n\n    /* Multiple indexes, last one wins */\n\n    qdict = keyval_parse(\"list.1=goner,list.0=null,list.1=eins,list.2=zwei\",\n\n                         NULL, &error_abort);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 1);\n\n    check_list012(qdict_get_qlist(qdict, \"list\"));\n\n    QDECREF(qdict);\n\n\n\n    /* List at deeper nesting */\n\n    qdict = keyval_parse(\"a.list.1=eins,a.list.0=null,a.list.2=zwei\",\n\n                         NULL, &error_abort);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 1);\n\n    sub_qdict = qdict_get_qdict(qdict, \"a\");\n\n    g_assert_cmpint(qdict_size(sub_qdict), ==, 1);\n\n    check_list012(qdict_get_qlist(sub_qdict, \"list\"));\n\n    QDECREF(qdict);\n\n\n\n    /* Inconsistent dotted keys: both list and dictionary */\n\n    qdict = keyval_parse(\"a.b.c=1,a.b.0=2\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n    qdict = keyval_parse(\"a.0.c=1,a.b.c=2\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n\n\n    /* Missing list indexes */\n\n    qdict = keyval_parse(\"list.2=lonely\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n    qdict = keyval_parse(\"list.0=null,list.2=eins,list.02=zwei\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n}\n", "idx": 1518}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_downtime(double value, Error **errp)\n\n{\n\n    value *= 1e9;\n\n    value = MAX(0, MIN(UINT64_MAX, value));\n\n    max_downtime = (uint64_t)value;\n\n}\n", "idx": 8477}
{"project": "qemu", "commit_id": "94fb0909645de18481cc726ee0ec9b5afa861394", "target": 1, "func": "static void ram_decompress_close(RamDecompressState *s)\n\n{\n\n    inflateEnd(&s->zstream);\n\n}\n", "idx": 5775}
{"project": "qemu", "commit_id": "9c75e168bc388094c04aabb6fc59c91abe06e81c", "target": 1, "func": "void qmp_block_resize(bool has_device, const char *device,\n                      bool has_node_name, const char *node_name,\n                      int64_t size, Error **errp)\n{\n    Error *local_err = NULL;\n    BlockDriverState *bs;\n    int ret;\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n                        has_node_name ? node_name : NULL,\n                        &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n    if (!bdrv_is_first_non_filter(bs)) {\n        error_set(errp, QERR_FEATURE_DISABLED, \"resize\");\n    if (size < 0) {\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"size\", \"a >0 size\");\n    /* complete all in-flight operations before resizing the device */\n    bdrv_drain_all();\n    ret = bdrv_truncate(bs, size);\n    switch (ret) {\n    case 0:\n        break;\n    case -ENOMEDIUM:\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n        break;\n    case -ENOTSUP:\n        error_set(errp, QERR_UNSUPPORTED);\n        break;\n    case -EACCES:\n        error_set(errp, QERR_DEVICE_IS_READ_ONLY, device);\n        break;\n    case -EBUSY:\n        break;\n    default:\n        error_setg_errno(errp, -ret, \"Could not resize\");\n        break;", "idx": 10207}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void arm_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n    static bool inited;\n\n    uint32_t Aff1, Aff0;\n\n\n\n    cs->env_ptr = &cpu->env;\n\n    cpu_exec_init(cs, &error_abort);\n\n    cpu->cp_regs = g_hash_table_new_full(g_int_hash, g_int_equal,\n\n                                         g_free, g_free);\n\n\n\n    /* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.\n\n     * We don't support setting cluster ID ([16..23]) (known as Aff2\n\n     * in later ARM ARM versions), or any of the higher affinity level fields,\n\n     * so these bits always RAZ.\n\n     */\n\n    Aff1 = cs->cpu_index / ARM_CPUS_PER_CLUSTER;\n\n    Aff0 = cs->cpu_index % ARM_CPUS_PER_CLUSTER;\n\n    cpu->mp_affinity = (Aff1 << ARM_AFF1_SHIFT) | Aff0;\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    /* Our inbound IRQ and FIQ lines */\n\n    if (kvm_enabled()) {\n\n        /* VIRQ and VFIQ are unused with KVM but we add them to maintain\n\n         * the same interface as non-KVM CPUs.\n\n         */\n\n        qdev_init_gpio_in(DEVICE(cpu), arm_cpu_kvm_set_irq, 4);\n\n    } else {\n\n        qdev_init_gpio_in(DEVICE(cpu), arm_cpu_set_irq, 4);\n\n    }\n\n\n\n    cpu->gt_timer[GTIMER_PHYS] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_ptimer_cb, cpu);\n\n    cpu->gt_timer[GTIMER_VIRT] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_vtimer_cb, cpu);\n\n    cpu->gt_timer[GTIMER_HYP] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_htimer_cb, cpu);\n\n    cpu->gt_timer[GTIMER_SEC] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_stimer_cb, cpu);\n\n    qdev_init_gpio_out(DEVICE(cpu), cpu->gt_timer_outputs,\n\n                       ARRAY_SIZE(cpu->gt_timer_outputs));\n\n#endif\n\n\n\n    /* DTB consumers generally don't in fact care what the 'compatible'\n\n     * string is, so always provide some string and trust that a hypothetical\n\n     * picky DTB consumer will also provide a helpful error message.\n\n     */\n\n    cpu->dtb_compatible = \"qemu,unknown\";\n\n    cpu->psci_version = 1; /* By default assume PSCI v0.1 */\n\n    cpu->kvm_target = QEMU_KVM_ARM_TARGET_NONE;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu->psci_version = 2; /* TCG implements PSCI 0.2 */\n\n        if (!inited) {\n\n            inited = true;\n\n            arm_translate_init();\n\n        }\n\n    }\n\n}\n", "idx": 9339}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "qemu_irq qemu_irq_split(qemu_irq irq1, qemu_irq irq2)\n\n{\n\n    qemu_irq *s = g_malloc0(2 * sizeof(qemu_irq));\n\n    s[0] = irq1;\n\n    s[1] = irq2;\n\n    return qemu_allocate_irqs(qemu_splitirq, s, 1)[0];\n\n}\n", "idx": 4421}
{"project": "qemu", "commit_id": "21174c34b6b9ace9ad82e0deb13be752d28a5907", "target": 1, "func": "static int get_unused_buffer(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    qemu_fseek(f, size, SEEK_CUR);\n\n    return 0;\n\n}\n", "idx": 3622}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void x86_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    CPUState *cs = CPU(dev);\n\n    X86CPU *cpu = X86_CPU(dev);\n\n    X86CPUClass *xcc = X86_CPU_GET_CLASS(dev);\n\n    CPUX86State *env = &cpu->env;\n\n    Error *local_err = NULL;\n\n    static bool ht_warned;\n\n\n\n    if (xcc->kvm_required && !kvm_enabled()) {\n\n        char *name = x86_cpu_class_get_model_name(xcc);\n\n        error_setg(&local_err, \"CPU model '%s' requires KVM\", name);\n\n        g_free(name);\n\n        goto out;\n\n    }\n\n\n\n    if (cpu->apic_id == UNASSIGNED_APIC_ID) {\n\n        error_setg(errp, \"apic-id property was not initialized properly\");\n\n        return;\n\n    }\n\n\n\n    x86_cpu_load_features(cpu, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    if (x86_cpu_filter_features(cpu) &&\n\n        (cpu->check_cpuid || cpu->enforce_cpuid)) {\n\n        x86_cpu_report_filtered_features(cpu);\n\n        if (cpu->enforce_cpuid) {\n\n            error_setg(&local_err,\n\n                       kvm_enabled() ?\n\n                           \"Host doesn't support requested features\" :\n\n                           \"TCG doesn't support requested features\");\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* On AMD CPUs, some CPUID[8000_0001].EDX bits must match the bits on\n\n     * CPUID[1].EDX.\n\n     */\n\n    if (IS_AMD_CPU(env)) {\n\n        env->features[FEAT_8000_0001_EDX] &= ~CPUID_EXT2_AMD_ALIASES;\n\n        env->features[FEAT_8000_0001_EDX] |= (env->features[FEAT_1_EDX]\n\n           & CPUID_EXT2_AMD_ALIASES);\n\n    }\n\n\n\n    /* For 64bit systems think about the number of physical bits to present.\n\n     * ideally this should be the same as the host; anything other than matching\n\n     * the host can cause incorrect guest behaviour.\n\n     * QEMU used to pick the magic value of 40 bits that corresponds to\n\n     * consumer AMD devices but nothing else.\n\n     */\n\n    if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {\n\n        if (kvm_enabled()) {\n\n            uint32_t host_phys_bits = x86_host_phys_bits();\n\n            static bool warned;\n\n\n\n            if (cpu->host_phys_bits) {\n\n                /* The user asked for us to use the host physical bits */\n\n                cpu->phys_bits = host_phys_bits;\n\n            }\n\n\n\n            /* Print a warning if the user set it to a value that's not the\n\n             * host value.\n\n             */\n\n            if (cpu->phys_bits != host_phys_bits && cpu->phys_bits != 0 &&\n\n                !warned) {\n\n                error_report(\"Warning: Host physical bits (%u)\"\n\n                                 \" does not match phys-bits property (%u)\",\n\n                                 host_phys_bits, cpu->phys_bits);\n\n                warned = true;\n\n            }\n\n\n\n            if (cpu->phys_bits &&\n\n                (cpu->phys_bits > TARGET_PHYS_ADDR_SPACE_BITS ||\n\n                cpu->phys_bits < 32)) {\n\n                error_setg(errp, \"phys-bits should be between 32 and %u \"\n\n                                 \" (but is %u)\",\n\n                                 TARGET_PHYS_ADDR_SPACE_BITS, cpu->phys_bits);\n\n                return;\n\n            }\n\n        } else {\n\n            if (cpu->phys_bits && cpu->phys_bits != TCG_PHYS_ADDR_BITS) {\n\n                error_setg(errp, \"TCG only supports phys-bits=%u\",\n\n                                  TCG_PHYS_ADDR_BITS);\n\n                return;\n\n            }\n\n        }\n\n        /* 0 means it was not explicitly set by the user (or by machine\n\n         * compat_props or by the host code above). In this case, the default\n\n         * is the value used by TCG (40).\n\n         */\n\n        if (cpu->phys_bits == 0) {\n\n            cpu->phys_bits = TCG_PHYS_ADDR_BITS;\n\n        }\n\n    } else {\n\n        /* For 32 bit systems don't use the user set value, but keep\n\n         * phys_bits consistent with what we tell the guest.\n\n         */\n\n        if (cpu->phys_bits != 0) {\n\n            error_setg(errp, \"phys-bits is not user-configurable in 32 bit\");\n\n            return;\n\n        }\n\n\n\n        if (env->features[FEAT_1_EDX] & CPUID_PSE36) {\n\n            cpu->phys_bits = 36;\n\n        } else {\n\n            cpu->phys_bits = 32;\n\n        }\n\n    }\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        tcg_x86_init();\n\n    }\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    qemu_register_reset(x86_cpu_machine_reset_cb, cpu);\n\n\n\n    if (cpu->env.features[FEAT_1_EDX] & CPUID_APIC || smp_cpus > 1) {\n\n        x86_cpu_apic_create(cpu, &local_err);\n\n        if (local_err != NULL) {\n\n            goto out;\n\n        }\n\n    }\n\n#endif\n\n\n\n    mce_init(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (tcg_enabled()) {\n\n        AddressSpace *newas = g_new(AddressSpace, 1);\n\n\n\n        cpu->cpu_as_mem = g_new(MemoryRegion, 1);\n\n        cpu->cpu_as_root = g_new(MemoryRegion, 1);\n\n\n\n        /* Outer container... */\n\n        memory_region_init(cpu->cpu_as_root, OBJECT(cpu), \"memory\", ~0ull);\n\n        memory_region_set_enabled(cpu->cpu_as_root, true);\n\n\n\n        /* ... with two regions inside: normal system memory with low\n\n         * priority, and...\n\n         */\n\n        memory_region_init_alias(cpu->cpu_as_mem, OBJECT(cpu), \"memory\",\n\n                                 get_system_memory(), 0, ~0ull);\n\n        memory_region_add_subregion_overlap(cpu->cpu_as_root, 0, cpu->cpu_as_mem, 0);\n\n        memory_region_set_enabled(cpu->cpu_as_mem, true);\n\n        address_space_init(newas, cpu->cpu_as_root, \"CPU\");\n\n        cs->num_ases = 1;\n\n        cpu_address_space_init(cs, newas, 0);\n\n\n\n        /* ... SMRAM with higher priority, linked from /machine/smram.  */\n\n        cpu->machine_done.notify = x86_cpu_machine_done;\n\n        qemu_add_machine_init_done_notifier(&cpu->machine_done);\n\n    }\n\n#endif\n\n\n\n    qemu_init_vcpu(cs);\n\n\n\n    /* Only Intel CPUs support hyperthreading. Even though QEMU fixes this\n\n     * issue by adjusting CPUID_0000_0001_EBX and CPUID_8000_0008_ECX\n\n     * based on inputs (sockets,cores,threads), it is still better to gives\n\n     * users a warning.\n\n     *\n\n     * NOTE: the following code has to follow qemu_init_vcpu(). Otherwise\n\n     * cs->nr_threads hasn't be populated yet and the checking is incorrect.\n\n     */\n\n    if (!IS_INTEL_CPU(env) && cs->nr_threads > 1 && !ht_warned) {\n\n        error_report(\"AMD CPU doesn't support hyperthreading. Please configure\"\n\n                     \" -smp options properly.\");\n\n        ht_warned = true;\n\n    }\n\n\n\n    x86_cpu_apic_realize(cpu, &local_err);\n\n    if (local_err != NULL) {\n\n        goto out;\n\n    }\n\n    cpu_reset(cs);\n\n\n\n    xcc->parent_realize(dev, &local_err);\n\n\n\nout:\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 9776}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "int inet_connect(const char *str, bool block, Error **errp)\n\n{\n\n    QemuOpts *opts;\n\n    int sock = -1;\n\n\n\n    opts = qemu_opts_create(&dummy_opts, NULL, 0);\n\n    if (inet_parse(opts, str) == 0) {\n\n        if (block) {\n\n            qemu_opt_set(opts, \"block\", \"on\");\n\n        }\n\n        sock = inet_connect_opts(opts, errp);\n\n    } else {\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return sock;\n\n}\n", "idx": 10377}
{"project": "qemu", "commit_id": "2fd5d864099dd38b43b595e9e3375dad2f76049b", "target": 1, "func": "int add_exec(struct ex_list **ex_ptr, int do_pty, char *exec,\n\n             struct in_addr addr, int port)\n\n{\n\n\tstruct ex_list *tmp_ptr;\n\n\n\n\t/* First, check if the port is \"bound\" */\n\n\tfor (tmp_ptr = *ex_ptr; tmp_ptr; tmp_ptr = tmp_ptr->ex_next) {\n\n\t\tif (port == tmp_ptr->ex_fport &&\n\n\t\t    addr.s_addr == tmp_ptr->ex_addr.s_addr)\n\n\t\t\treturn -1;\n\n\t}\n\n\n\n\ttmp_ptr = *ex_ptr;\n\n\t*ex_ptr = (struct ex_list *)malloc(sizeof(struct ex_list));\n\n\t(*ex_ptr)->ex_fport = port;\n\n\t(*ex_ptr)->ex_addr = addr;\n\n\t(*ex_ptr)->ex_pty = do_pty;\n\n\t(*ex_ptr)->ex_exec = (do_pty == 3) ? exec : strdup(exec);\n\n\t(*ex_ptr)->ex_next = tmp_ptr;\n\n\treturn 0;\n\n}\n", "idx": 5501}
{"project": "qemu", "commit_id": "ded67782e6d06069873adce7f9074d273ae75760", "target": 1, "func": "static int acpi_load_old(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    PIIX4PMState *s = opaque;\n\n    int ret, i;\n\n    uint16_t temp;\n\n\n\n    ret = pci_device_load(&s->dev, f);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_get_be16s(f, &s->ar.pm1.evt.sts);\n\n    qemu_get_be16s(f, &s->ar.pm1.evt.en);\n\n    qemu_get_be16s(f, &s->ar.pm1.cnt.cnt);\n\n\n\n    ret = vmstate_load_state(f, &vmstate_apm, opaque, 1);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_get_timer(f, s->ar.tmr.timer);\n\n    qemu_get_sbe64s(f, &s->ar.tmr.overflow_time);\n\n\n\n    qemu_get_be16s(f, (uint16_t *)s->ar.gpe.sts);\n\n    for (i = 0; i < 3; i++) {\n\n        qemu_get_be16s(f, &temp);\n\n    }\n\n\n\n    qemu_get_be16s(f, (uint16_t *)s->ar.gpe.en);\n\n    for (i = 0; i < 3; i++) {\n\n        qemu_get_be16s(f, &temp);\n\n    }\n\n\n\n    ret = vmstate_load_state(f, &vmstate_pci_status, opaque, 1);\n\n    return ret;\n\n}\n", "idx": 1652}
{"project": "qemu", "commit_id": "ec9c10d29c6bb5613a680af62f5825d3bb2d31d4", "target": 1, "func": "static DriveInfo *blockdev_init(QDict *bs_opts,\n\n                                BlockInterfaceType type,\n\n                                Error **errp)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    DriveInfo *dinfo;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockDriver *drv = NULL;\n\n\n\n    /* Check common options by copying from bs_opts to opts, all other options\n\n     * stay in bs_opts for processing by bdrv_open(). */\n\n    id = qdict_get_try_str(bs_opts, \"id\");\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"read-only\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_setg(errp, \"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"cache.writeback\", true)) {\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.direct\", false)) {\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.no-flush\", false)) {\n\n        bdrv_flags |= BDRV_O_NO_FLUSH;\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_setg(errp, \"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            error_setg(errp, \"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    memset(&cfg, 0, sizeof(cfg));\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].avg  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].max  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n    cfg.op_size = qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n    if (!check_throttle_config(&cfg, &error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_setg(errp, \"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* init */\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    dinfo->id = g_strdup(qemu_opts_id(opts));\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->type = type;\n\n    dinfo->refcount = 1;\n\n    if (serial != NULL) {\n\n        dinfo->serial = g_strdup(serial);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    if (throttle_enabled(&cfg)) {\n\n        bdrv_io_limits_enable(dinfo->bdrv);\n\n        bdrv_set_io_limits(dinfo->bdrv, &cfg);\n\n    }\n\n\n\n    if (!file || !*file) {\n\n        if (has_driver_specific_opts) {\n\n            file = NULL;\n\n        } else {\n\n            return dinfo;\n\n        }\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    QINCREF(bs_opts);\n\n    ret = bdrv_open(dinfo->bdrv, file, bs_opts, bdrv_flags, drv, &error);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"could not open disk image %s: %s\",\n\n                   file ?: dinfo->id, error_get_pretty(error));\n\n        error_free(error);\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n\n\n    return dinfo;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    QDECREF(bs_opts);\n\n    bdrv_unref(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 8258}
{"project": "qemu", "commit_id": "96bc97ebf350ec480b69082819cedb8850f46a0f", "target": 1, "func": "QemuOpts *qemu_opts_find(QemuOptsList *list, const char *id)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    QTAILQ_FOREACH(opts, &list->head, next) {\n\n        if (!opts->id) {\n\n            if (!id) {\n\n                return opts;\n\n            }\n\n            continue;\n\n        }\n\n        if (strcmp(opts->id, id) != 0) {\n\n            continue;\n\n        }\n\n        return opts;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 6943}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 addFloat64Sigs( float64 a, float64 b, flag zSign STATUS_PARAM )\n\n{\n\n    int16 aExp, bExp, zExp;\n\n    uint64_t aSig, bSig, zSig;\n\n    int16 expDiff;\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    bSig = extractFloat64Frac( b );\n\n    bExp = extractFloat64Exp( b );\n\n    expDiff = aExp - bExp;\n\n    aSig <<= 9;\n\n    bSig <<= 9;\n\n    if ( 0 < expDiff ) {\n\n        if ( aExp == 0x7FF ) {\n\n            if ( aSig ) return propagateFloat64NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( bExp == 0 ) {\n\n            --expDiff;\n\n        }\n\n        else {\n\n            bSig |= LIT64( 0x2000000000000000 );\n\n        }\n\n        shift64RightJamming( bSig, expDiff, &bSig );\n\n        zExp = aExp;\n\n    }\n\n    else if ( expDiff < 0 ) {\n\n        if ( bExp == 0x7FF ) {\n\n            if ( bSig ) return propagateFloat64NaN( a, b STATUS_VAR );\n\n            return packFloat64( zSign, 0x7FF, 0 );\n\n        }\n\n        if ( aExp == 0 ) {\n\n            ++expDiff;\n\n        }\n\n        else {\n\n            aSig |= LIT64( 0x2000000000000000 );\n\n        }\n\n        shift64RightJamming( aSig, - expDiff, &aSig );\n\n        zExp = bExp;\n\n    }\n\n    else {\n\n        if ( aExp == 0x7FF ) {\n\n            if ( aSig | bSig ) return propagateFloat64NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( aExp == 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            return packFloat64( zSign, 0, ( aSig + bSig )>>9 );\n\n        }\n\n        zSig = LIT64( 0x4000000000000000 ) + aSig + bSig;\n\n        zExp = aExp;\n\n        goto roundAndPack;\n\n    }\n\n    aSig |= LIT64( 0x2000000000000000 );\n\n    zSig = ( aSig + bSig )<<1;\n\n    --zExp;\n\n    if ( (int64_t) zSig < 0 ) {\n\n        zSig = aSig + bSig;\n\n        ++zExp;\n\n    }\n\n roundAndPack:\n\n    return roundAndPackFloat64( zSign, zExp, zSig STATUS_VAR );\n\n\n\n}\n", "idx": 8643}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_wew_0c(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned ra = extract32(insn, 21, 5);\n\n    return do_fop_wew(ctx, rt, ra, di->f_wew);\n\n}\n", "idx": 992}
{"project": "qemu", "commit_id": "b31f84126215e3fd4b8acbc3083ae30d407329e8", "target": 1, "func": "static void mtree_print_mr(fprintf_function mon_printf, void *f,\n\n                           const MemoryRegion *mr, unsigned int level,\n\n                           hwaddr base,\n\n                           MemoryRegionListHead *alias_print_queue)\n\n{\n\n    MemoryRegionList *new_ml, *ml, *next_ml;\n\n    MemoryRegionListHead submr_print_queue;\n\n    const MemoryRegion *submr;\n\n    unsigned int i;\n\n\n\n    if (!mr) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < level; i++) {\n\n        mon_printf(f, MTREE_INDENT);\n\n    }\n\n\n\n    if (mr->alias) {\n\n        MemoryRegionList *ml;\n\n        bool found = false;\n\n\n\n        /* check if the alias is already in the queue */\n\n        QTAILQ_FOREACH(ml, alias_print_queue, queue) {\n\n            if (ml->mr == mr->alias) {\n\n                found = true;\n\n            }\n\n        }\n\n\n\n        if (!found) {\n\n            ml = g_new(MemoryRegionList, 1);\n\n            ml->mr = mr->alias;\n\n            QTAILQ_INSERT_TAIL(alias_print_queue, ml, queue);\n\n        }\n\n        mon_printf(f, TARGET_FMT_plx \"-\" TARGET_FMT_plx\n\n                   \" (prio %d, %s): alias %s @%s \" TARGET_FMT_plx\n\n                   \"-\" TARGET_FMT_plx \"%s\\n\",\n\n                   base + mr->addr,\n\n                   base + mr->addr + MR_SIZE(mr->size),\n\n                   mr->priority,\n\n                   memory_region_type((MemoryRegion *)mr),\n\n                   memory_region_name(mr),\n\n                   memory_region_name(mr->alias),\n\n                   mr->alias_offset,\n\n                   mr->alias_offset + MR_SIZE(mr->size),\n\n                   mr->enabled ? \"\" : \" [disabled]\");\n\n    } else {\n\n        mon_printf(f,\n\n                   TARGET_FMT_plx \"-\" TARGET_FMT_plx \" (prio %d, %s): %s%s\\n\",\n\n                   base + mr->addr,\n\n                   base + mr->addr + MR_SIZE(mr->size),\n\n                   mr->priority,\n\n                   memory_region_type((MemoryRegion *)mr),\n\n                   memory_region_name(mr),\n\n                   mr->enabled ? \"\" : \" [disabled]\");\n\n    }\n\n\n\n    QTAILQ_INIT(&submr_print_queue);\n\n\n\n    QTAILQ_FOREACH(submr, &mr->subregions, subregions_link) {\n\n        new_ml = g_new(MemoryRegionList, 1);\n\n        new_ml->mr = submr;\n\n        QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n\n            if (new_ml->mr->addr < ml->mr->addr ||\n\n                (new_ml->mr->addr == ml->mr->addr &&\n\n                 new_ml->mr->priority > ml->mr->priority)) {\n\n                QTAILQ_INSERT_BEFORE(ml, new_ml, queue);\n\n                new_ml = NULL;\n\n                break;\n\n            }\n\n        }\n\n        if (new_ml) {\n\n            QTAILQ_INSERT_TAIL(&submr_print_queue, new_ml, queue);\n\n        }\n\n    }\n\n\n\n    QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n\n        mtree_print_mr(mon_printf, f, ml->mr, level + 1, base + mr->addr,\n\n                       alias_print_queue);\n\n    }\n\n\n\n    QTAILQ_FOREACH_SAFE(ml, &submr_print_queue, queue, next_ml) {\n\n        g_free(ml);\n\n    }\n\n}\n", "idx": 1792}
{"project": "qemu", "commit_id": "66a08cbe6ad1aebec8eecf58b3ba042e19dd1649", "target": 1, "func": "static void uhci_process_frame(UHCIState *s)\n\n{\n\n    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;\n\n    uint32_t curr_qh, td_count = 0;\n\n    int cnt, ret;\n\n    UHCI_TD td;\n\n    UHCI_QH qh;\n\n    QhDb qhdb;\n\n\n\n    frame_addr = s->fl_base_addr + ((s->frnum & 0x3ff) << 2);\n\n\n\n    pci_dma_read(&s->dev, frame_addr, &link, 4);\n\n    le32_to_cpus(&link);\n\n\n\n    int_mask = 0;\n\n    curr_qh  = 0;\n\n\n\n    qhdb_reset(&qhdb);\n\n\n\n    for (cnt = FRAME_MAX_LOOPS; is_valid(link) && cnt; cnt--) {\n\n        if (s->frame_bytes >= s->frame_bandwidth) {\n\n            /* We've reached the usb 1.1 bandwidth, which is\n\n               1280 bytes/frame, stop processing */\n\n            trace_usb_uhci_frame_stop_bandwidth();\n\n            break;\n\n        }\n\n        if (is_qh(link)) {\n\n            /* QH */\n\n            trace_usb_uhci_qh_load(link & ~0xf);\n\n\n\n            if (qhdb_insert(&qhdb, link)) {\n\n                /*\n\n                 * We're going in circles. Which is not a bug because\n\n                 * HCD is allowed to do that as part of the BW management.\n\n                 *\n\n                 * Stop processing here if no transaction has been done\n\n                 * since we've been here last time.\n\n                 */\n\n                if (td_count == 0) {\n\n                    trace_usb_uhci_frame_loop_stop_idle();\n\n                    break;\n\n                } else {\n\n                    trace_usb_uhci_frame_loop_continue();\n\n                    td_count = 0;\n\n                    qhdb_reset(&qhdb);\n\n                    qhdb_insert(&qhdb, link);\n\n                }\n\n            }\n\n\n\n            pci_dma_read(&s->dev, link & ~0xf, &qh, sizeof(qh));\n\n            le32_to_cpus(&qh.link);\n\n            le32_to_cpus(&qh.el_link);\n\n\n\n            if (!is_valid(qh.el_link)) {\n\n                /* QH w/o elements */\n\n                curr_qh = 0;\n\n                link = qh.link;\n\n            } else {\n\n                /* QH with elements */\n\n            \tcurr_qh = link;\n\n            \tlink = qh.el_link;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        /* TD */\n\n        uhci_read_td(s, &td, link);\n\n        trace_usb_uhci_td_load(curr_qh & ~0xf, link & ~0xf, td.ctrl, td.token);\n\n\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, NULL, &td, link, &int_mask);\n\n        if (old_td_ctrl != td.ctrl) {\n\n            /* update the status bits of the TD */\n\n            val = cpu_to_le32(td.ctrl);\n\n            pci_dma_write(&s->dev, (link & ~0xf) + 4, &val, sizeof(val));\n\n        }\n\n\n\n        switch (ret) {\n\n        case TD_RESULT_STOP_FRAME: /* interrupted frame */\n\n            goto out;\n\n\n\n        case TD_RESULT_NEXT_QH:\n\n        case TD_RESULT_ASYNC_CONT:\n\n            trace_usb_uhci_td_nextqh(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_ASYNC_START:\n\n            trace_usb_uhci_td_async(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_COMPLETE:\n\n            trace_usb_uhci_td_complete(curr_qh & ~0xf, link & ~0xf);\n\n            link = td.link;\n\n            td_count++;\n\n            s->frame_bytes += (td.ctrl & 0x7ff) + 1;\n\n\n\n            if (curr_qh) {\n\n                /* update QH element link */\n\n                qh.el_link = link;\n\n                val = cpu_to_le32(qh.el_link);\n\n                pci_dma_write(&s->dev, (curr_qh & ~0xf) + 4, &val, sizeof(val));\n\n\n\n                if (!depth_first(link)) {\n\n                    /* done with this QH */\n\n                    curr_qh = 0;\n\n                    link    = qh.link;\n\n                }\n\n            }\n\n            break;\n\n\n\n        default:\n\n            assert(!\"unknown return code\");\n\n        }\n\n\n\n        /* go to the next entry */\n\n    }\n\n\n\nout:\n\n    s->pending_int_mask |= int_mask;\n\n}\n", "idx": 2065}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void common_unbind(struct common *c)\n\n{\n\n    xen_be_unbind_evtchn(&c->xendev);\n\n    if (c->page) {\n\n\tmunmap(c->page, XC_PAGE_SIZE);\n\n\tc->page = NULL;\n\n    }\n\n}\n", "idx": 10113}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void packet_id_queue_add(struct PacketIdQueue *q, uint64_t id)\n\n{\n\n    USBRedirDevice *dev = q->dev;\n\n    struct PacketIdQueueEntry *e;\n\n\n\n    DPRINTF(\"adding packet id %\"PRIu64\" to %s queue\\n\", id, q->name);\n\n\n\n    e = g_malloc0(sizeof(struct PacketIdQueueEntry));\n\n    e->id = id;\n\n    QTAILQ_INSERT_TAIL(&q->head, e, next);\n\n    q->size++;\n\n}\n", "idx": 8817}
{"project": "qemu", "commit_id": "5ad4a2b75f85dd854a781a6e03b90320cb3441d3", "target": 1, "func": "bool address_space_access_valid(AddressSpace *as, hwaddr addr, int len, bool is_write)\n\n{\n\n    MemoryRegion *mr;\n\n    hwaddr l, xlat;\n\n\n\n    rcu_read_lock();\n\n    while (len > 0) {\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &xlat, &l, is_write);\n\n        if (!memory_access_is_direct(mr, is_write)) {\n\n            l = memory_access_size(mr, l, addr);\n\n            if (!memory_region_access_valid(mr, xlat, l, is_write)) {\n\n\n                return false;\n\n            }\n\n        }\n\n\n\n        len -= l;\n\n        addr += l;\n\n    }\n\n\n    return true;\n\n}", "idx": 538}
{"project": "qemu", "commit_id": "61ed73cff427206b3a959b18a4877952f566279b", "target": 1, "func": "static ssize_t handle_aiocb_rw_linear(RawPosixAIOData *aiocb, char *buf)\n\n{\n\n    ssize_t offset = 0;\n\n    ssize_t len;\n\n\n\n    while (offset < aiocb->aio_nbytes) {\n\n        if (aiocb->aio_type & QEMU_AIO_WRITE) {\n\n            len = pwrite(aiocb->aio_fildes,\n\n                         (const char *)buf + offset,\n\n                         aiocb->aio_nbytes - offset,\n\n                         aiocb->aio_offset + offset);\n\n        } else {\n\n            len = pread(aiocb->aio_fildes,\n\n                        buf + offset,\n\n                        aiocb->aio_nbytes - offset,\n\n                        aiocb->aio_offset + offset);\n\n        }\n\n        if (len == -1 && errno == EINTR) {\n\n            continue;\n\n\n\n\n\n\n\n\n\n\n        } else if (len == -1) {\n\n            offset = -errno;\n\n\n        } else if (len == 0) {\n\n\n        }\n\n        offset += len;\n\n    }\n\n\n\n    return offset;\n\n}", "idx": 39}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "static void kvm_mce_broadcast_rest(CPUState *env)\n\n{\n\n    CPUState *cenv;\n\n    int family, model, cpuver = env->cpuid_version;\n\n\n\n    family = (cpuver >> 8) & 0xf;\n\n    model = ((cpuver >> 12) & 0xf0) + ((cpuver >> 4) & 0xf);\n\n\n\n    /* Broadcast MCA signal for processor version 06H_EH and above */\n\n    if ((family == 6 && model >= 14) || family > 6) {\n\n        for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {\n\n            if (cenv == env) {\n\n                continue;\n\n            }\n\n            kvm_inject_x86_mce(cenv, 1, MCI_STATUS_VAL | MCI_STATUS_UC,\n\n                               MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0, 1);\n\n        }\n\n    }\n\n}\n", "idx": 3434}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 10579}
{"project": "qemu", "commit_id": "4bc02e230d1e0fd41d2a892d81dcad56e3b3702d", "target": 1, "func": "target_ulong helper_srad(CPUPPCState *env, target_ulong value,\n\n                         target_ulong shift)\n\n{\n\n    int64_t ret;\n\n\n\n    if (likely(!(shift & 0x40))) {\n\n        if (likely((uint64_t)shift != 0)) {\n\n            shift &= 0x3f;\n\n            ret = (int64_t)value >> shift;\n\n            if (likely(ret >= 0 || (value & ((1 << shift) - 1)) == 0)) {\n\n                env->ca = 0;\n\n            } else {\n\n                env->ca = 1;\n\n            }\n\n        } else {\n\n            ret = (int64_t)value;\n\n            env->ca = 0;\n\n        }\n\n    } else {\n\n        ret = (int64_t)value >> 63;\n\n        env->ca = (ret != 0);\n\n    }\n\n    return ret;\n\n}\n", "idx": 596}
{"project": "qemu", "commit_id": "3e80bf9351f8fec9085c46df6da075efd5e71003", "target": 1, "func": "int coroutine_fn qemu_co_recvv(int sockfd, struct iovec *iov,\n\n                               int len, int iov_offset)\n\n{\n\n    int total = 0;\n\n    int ret;\n\n    while (len) {\n\n        ret = qemu_recvv(sockfd, iov, len, iov_offset + total);\n\n        if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n                continue;\n\n            }\n\n            if (total == 0) {\n\n                total = -1;\n\n            }\n\n            break;\n\n        }\n\n        if (ret == 0) {\n\n            break;\n\n        }\n\n        total += ret, len -= ret;\n\n    }\n\n\n\n    return total;\n\n}\n", "idx": 9312}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "void axisdev88_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    CRISCPU *cpu;\n\n    CPUCRISState *env;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    DriveInfo *nand;\n\n    qemu_irq irq[30], nmi[2];\n\n    void *etraxfs_dmac;\n\n    struct etraxfs_dma_client *dma_eth;\n\n    int i;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *phys_intmem = g_new(MemoryRegion, 1);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"crisv32\";\n\n    }\n\n    cpu = cpu_cris_init(cpu_model);\n\n    env = &cpu->env;\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(phys_ram, NULL, \"axisdev88.ram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, phys_ram);\n\n\n\n    /* The ETRAX-FS has 128Kb on chip ram, the docs refer to it as the \n\n       internal memory.  */\n\n    memory_region_init_ram(phys_intmem, NULL, \"axisdev88.chipram\", INTMEM_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(phys_intmem);\n\n    memory_region_add_subregion(address_space_mem, 0x38000000, phys_intmem);\n\n\n\n      /* Attach a NAND flash to CS1.  */\n\n    nand = drive_get(IF_MTD, 0, 0);\n\n    nand_state.nand = nand_init(nand ? blk_by_legacy_dinfo(nand) : NULL,\n\n                                NAND_MFR_STMICRO, 0x39);\n\n    memory_region_init_io(&nand_state.iomem, NULL, &nand_ops, &nand_state,\n\n                          \"nand\", 0x05000000);\n\n    memory_region_add_subregion(address_space_mem, 0x10000000,\n\n                                &nand_state.iomem);\n\n\n\n    gpio_state.nand = &nand_state;\n\n    memory_region_init_io(&gpio_state.iomem, NULL, &gpio_ops, &gpio_state,\n\n                          \"gpio\", 0x5c);\n\n    memory_region_add_subregion(address_space_mem, 0x3001a000,\n\n                                &gpio_state.iomem);\n\n\n\n\n\n    dev = qdev_create(NULL, \"etraxfs,pic\");\n\n    /* FIXME: Is there a proper way to signal vectors to the CPU core?  */\n\n    qdev_prop_set_ptr(dev, \"interrupt_vector\", &env->interrupt_vector);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(s, 0, 0x3001c000);\n\n    sysbus_connect_irq(s, 0, qdev_get_gpio_in(DEVICE(cpu), CRIS_CPU_IRQ));\n\n    sysbus_connect_irq(s, 1, qdev_get_gpio_in(DEVICE(cpu), CRIS_CPU_NMI));\n\n    for (i = 0; i < 30; i++) {\n\n        irq[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    nmi[0] = qdev_get_gpio_in(dev, 30);\n\n    nmi[1] = qdev_get_gpio_in(dev, 31);\n\n\n\n    etraxfs_dmac = etraxfs_dmac_init(0x30000000, 10);\n\n    for (i = 0; i < 10; i++) {\n\n        /* On ETRAX, odd numbered channels are inputs.  */\n\n        etraxfs_dmac_connect(etraxfs_dmac, i, irq + 7 + i, i & 1);\n\n    }\n\n\n\n    /* Add the two ethernet blocks.  */\n\n    dma_eth = g_malloc0(sizeof dma_eth[0] * 4); /* Allocate 4 channels.  */\n\n    etraxfs_eth_init(&nd_table[0], 0x30034000, 1, &dma_eth[0], &dma_eth[1]);\n\n    if (nb_nics > 1) {\n\n        etraxfs_eth_init(&nd_table[1], 0x30036000, 2, &dma_eth[2], &dma_eth[3]);\n\n    }\n\n\n\n    /* The DMA Connector block is missing, hardwire things for now.  */\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 0, &dma_eth[0]);\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 1, &dma_eth[1]);\n\n    if (nb_nics > 1) {\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 6, &dma_eth[2]);\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 7, &dma_eth[3]);\n\n    }\n\n\n\n    /* 2 timers.  */\n\n    sysbus_create_varargs(\"etraxfs,timer\", 0x3001e000, irq[0x1b], nmi[1], NULL);\n\n    sysbus_create_varargs(\"etraxfs,timer\", 0x3005e000, irq[0x1b], nmi[1], NULL);\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_create_simple(\"etraxfs,serial\", 0x30026000 + i * 0x2000,\n\n                             irq[0x14 + i]);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        li.image_filename = kernel_filename;\n\n        li.cmdline = kernel_cmdline;\n\n        cris_load_image(cpu, &li);\n\n    } else if (!qtest_enabled()) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n}\n", "idx": 8152}
{"project": "qemu", "commit_id": "a8a21be9855e0bb0947a7325d0d1741a8814f21e", "target": 1, "func": "int net_init_bridge(const NetClientOptions *opts, const char *name,\n\n                    NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    const NetdevBridgeOptions *bridge;\n\n    const char *helper, *br;\n\n    TAPState *s;\n\n    int fd, vnet_hdr;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_BRIDGE);\n\n    bridge = opts->bridge;\n\n\n\n    helper = bridge->has_helper ? bridge->helper : DEFAULT_BRIDGE_HELPER;\n\n    br     = bridge->has_br     ? bridge->br     : DEFAULT_BRIDGE_INTERFACE;\n\n\n\n    fd = net_bridge_run_helper(helper, br);\n\n    if (fd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n    vnet_hdr = tap_probe_vnet_hdr(fd);\n\n    s = net_tap_fd_init(peer, \"bridge\", name, fd, vnet_hdr);\n\n\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s,br=%s\", helper,\n\n             br);\n\n\n\n    return 0;\n\n}\n", "idx": 3976}
{"project": "qemu", "commit_id": "b027a538c6790bcfc93ef7f4819fe3e581445959", "target": 1, "func": "static int oss_ctl_in (HWVoiceIn *hw, int cmd, ...)\n\n{\n\n    OSSVoiceIn *oss = (OSSVoiceIn *) hw;\n\n\n\n    switch (cmd) {\n\n    case VOICE_ENABLE:\n\n        {\n\n            va_list ap;\n\n            int poll_mode;\n\n\n\n            va_start (ap, cmd);\n\n            poll_mode = va_arg (ap, int);\n\n            va_end (ap);\n\n\n\n            if (poll_mode && oss_poll_in (hw)) {\n\n                poll_mode = 0;\n\n            }\n\n            hw->poll_mode = poll_mode;\n\n        }\n\n        break;\n\n\n\n    case VOICE_DISABLE:\n\n        if (hw->poll_mode) {\n\n            hw->poll_mode = 0;\n\n            qemu_set_fd_handler (oss->fd, NULL, NULL, NULL);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 286}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static void audio_capture(void *opaque, void *buf, int size)\n\n{\n\n    VncState *vs = opaque;\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 4984}
{"project": "qemu", "commit_id": "06b1297017415ae6a07a0e97ad7d8e90b2d95823", "target": 1, "func": "static int virtio_net_has_buffers(VirtIONet *n, int bufsize)\n\n{\n\n    if (virtio_queue_empty(n->rx_vq) ||\n\n        (n->mergeable_rx_bufs &&\n\n         !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) {\n\n        virtio_queue_set_notification(n->rx_vq, 1);\n\n        return 0;\n\n    }\n\n\n\n    virtio_queue_set_notification(n->rx_vq, 0);\n\n    return 1;\n\n}\n", "idx": 6707}
{"project": "qemu", "commit_id": "86a8623692b1b559a419a92eb8b6897c221bca74", "target": 1, "func": "static void mem_add(MemoryListener *listener, MemoryRegionSection *section)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n    MemoryRegionSection now = *section, remain = *section;\n\n\n\n    if ((now.offset_within_address_space & ~TARGET_PAGE_MASK)\n\n        || (now.size < TARGET_PAGE_SIZE)) {\n\n        now.size = MIN(TARGET_PAGE_ALIGN(now.offset_within_address_space)\n\n                       - now.offset_within_address_space,\n\n                       now.size);\n\n        register_subpage(d, &now);\n\n        remain.size -= now.size;\n\n        remain.offset_within_address_space += now.size;\n\n        remain.offset_within_region += now.size;\n\n    }\n\n    while (remain.size >= TARGET_PAGE_SIZE) {\n\n        now = remain;\n\n        if (remain.offset_within_region & ~TARGET_PAGE_MASK) {\n\n            now.size = TARGET_PAGE_SIZE;\n\n            register_subpage(d, &now);\n\n        } else {\n\n            now.size &= TARGET_PAGE_MASK;\n\n            register_multipage(d, &now);\n\n        }\n\n        remain.size -= now.size;\n\n        remain.offset_within_address_space += now.size;\n\n        remain.offset_within_region += now.size;\n\n    }\n\n    now = remain;\n\n    if (now.size) {\n\n        register_subpage(d, &now);\n\n    }\n\n}\n", "idx": 914}
{"project": "qemu", "commit_id": "08d49df0dbaacc220a099dbfb644e1dc0eda57be", "target": 1, "func": "static void handle_windowevent(SDL_Event *ev)\n{\n    struct sdl2_console *scon = get_scon_from_window(ev->window.windowID);\n    switch (ev->window.event) {\n    case SDL_WINDOWEVENT_RESIZED:\n        {\n            QemuUIInfo info;\n            memset(&info, 0, sizeof(info));\n            info.width = ev->window.data1;\n            info.height = ev->window.data2;\n            dpy_set_ui_info(scon->dcl.con, &info);\n        sdl2_redraw(scon);\n        break;\n    case SDL_WINDOWEVENT_EXPOSED:\n        sdl2_redraw(scon);\n        break;\n    case SDL_WINDOWEVENT_FOCUS_GAINED:\n    case SDL_WINDOWEVENT_ENTER:\n        if (!gui_grab && (qemu_input_is_absolute() || absolute_enabled)) {\n            absolute_mouse_grab(scon);\n        break;\n    case SDL_WINDOWEVENT_FOCUS_LOST:\n        if (gui_grab && !gui_fullscreen) {\n            sdl_grab_end(scon);\n        break;\n    case SDL_WINDOWEVENT_RESTORED:\n        update_displaychangelistener(&scon->dcl, GUI_REFRESH_INTERVAL_DEFAULT);\n        break;\n    case SDL_WINDOWEVENT_MINIMIZED:\n        update_displaychangelistener(&scon->dcl, 500);\n        break;\n    case SDL_WINDOWEVENT_CLOSE:\n        if (!no_quit) {\n            no_shutdown = 0;\n            qemu_system_shutdown_request();\n        break;\n    case SDL_WINDOWEVENT_SHOWN:\n        if (scon->hidden) {\n            SDL_HideWindow(scon->real_window);\n        break;\n    case SDL_WINDOWEVENT_HIDDEN:\n        if (!scon->hidden) {\n            SDL_ShowWindow(scon->real_window);\n        break;", "idx": 3144}
{"project": "qemu", "commit_id": "737d2b3c41d59eb8f94ab7eb419b957938f24943", "target": 1, "func": "ssize_t ne2000_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n\n{\n\n    NE2000State *s = qemu_get_nic_opaque(nc);\n\n    int size = size_;\n\n    uint8_t *p;\n\n    unsigned int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] =\n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (s->cmd & E8390_STOP || ne2000_buffer_full(s))\n\n        return -1;\n\n\n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return size;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return size;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return size;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&\n\n                   s->mem[4] == buf[2] &&\n\n                   s->mem[6] == buf[3] &&\n\n                   s->mem[8] == buf[4] &&\n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return size;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    if (index >= NE2000_PMEM_END) {\n\n        index = s->start;\n\n    }\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        if (index <= s->stop)\n\n            avail = s->stop - index;\n\n        else\n\n            avail = 0;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have received something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n\n\n    return size_;\n\n}\n", "idx": 4813}
{"project": "qemu", "commit_id": "e83980455c8c7eb066405de512be7c4bace3ac4d", "target": 1, "func": "static void virtio_ccw_device_plugged(DeviceState *d)\n\n{\n\n    VirtioCcwDevice *dev = VIRTIO_CCW_DEVICE(d);\n\n    SubchDev *sch = dev->sch;\n\n\n\n    sch->id.cu_model = virtio_bus_get_vdev_id(&dev->bus);\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          d->hotplugged, 1);\n\n}\n", "idx": 359}
{"project": "qemu", "commit_id": "645c9496f7083c105ecd32f32532496af6aadf62", "target": 1, "func": "void qmp_netdev_del(const char *id, Error **errp)\n\n{\n\n    NetClientState *nc;\n\n\n\n    nc = qemu_find_netdev(id);\n\n    if (!nc) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, id);\n\n        return;\n\n    }\n\n\n\n    qemu_del_net_client(nc);\n\n    qemu_opts_del(qemu_opts_find(qemu_find_opts_err(\"netdev\", errp), id));\n\n}\n", "idx": 11922}
{"project": "qemu", "commit_id": "b196d969efa3987148994f0f8da79a10ebda7641", "target": 1, "func": "static void superio_ioport_writeb(void *opaque, hwaddr addr, uint64_t data,\n\n                                  unsigned size)\n\n{\n\n    int can_write;\n\n    SuperIOConfig *superio_conf = opaque;\n\n\n\n    DPRINTF(\"superio_ioport_writeb  address 0x%x  val 0x%x\\n\", addr, data);\n\n    if (addr == 0x3f0) {\n\n        superio_conf->index = data & 0xff;\n\n    } else {\n\n        /* 0x3f1 */\n\n        switch (superio_conf->index) {\n\n        case 0x00 ... 0xdf:\n\n        case 0xe4:\n\n        case 0xe5:\n\n        case 0xe9 ... 0xed:\n\n        case 0xf3:\n\n        case 0xf5:\n\n        case 0xf7:\n\n        case 0xf9 ... 0xfb:\n\n        case 0xfd ... 0xff:\n\n            can_write = 0;\n\n            break;\n\n        default:\n\n            can_write = 1;\n\n\n\n            if (can_write) {\n\n                switch (superio_conf->index) {\n\n                case 0xe7:\n\n                    if ((data & 0xff) != 0xfe) {\n\n                        DPRINTF(\"chage uart 1 base. unsupported yet\\n\");\n\n                    }\n\n                    break;\n\n                case 0xe8:\n\n                    if ((data & 0xff) != 0xbe) {\n\n                        DPRINTF(\"chage uart 2 base. unsupported yet\\n\");\n\n                    }\n\n                    break;\n\n\n\n                default:\n\n                    superio_conf->config[superio_conf->index] = data & 0xff;\n\n                }\n\n            }\n\n        }\n\n        superio_conf->config[superio_conf->index] = data & 0xff;\n\n    }\n\n}\n", "idx": 176}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void vty_putchars(VIOsPAPRDevice *sdev, uint8_t *buf, int len)\n\n{\n\n    VIOsPAPRVTYDevice *dev = VIO_SPAPR_VTY_DEVICE(sdev);\n\n\n\n    /* FIXME: should check the qemu_chr_fe_write() return value */\n\n    qemu_chr_fe_write(dev->chardev, buf, len);\n\n}\n", "idx": 3946}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_rt_sigreturn(CPUMIPSState *env)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n\n\n    frame_addr = env->active_tc.gpr[29];\n\n    trace_user_do_rt_sigreturn(env, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset(&blocked, &frame->rs_uc.tuc_sigmask);\n\n    set_sigmask(&blocked);\n\n\n\n    restore_sigcontext(env, &frame->rs_uc.tuc_mcontext);\n\n\n\n    if (do_sigaltstack(frame_addr +\n\n                       offsetof(struct target_rt_sigframe, rs_uc.tuc_stack),\n\n                       0, get_sp_from_cpustate(env)) == -EFAULT)\n\n        goto badframe;\n\n\n\n    env->active_tc.PC = env->CP0_EPC;\n\n    mips_set_hflags_isa_mode_from_pc(env);\n\n    /* I am not sure this is right, but it seems to work\n\n    * maybe a problem with nested signals ? */\n\n    env->CP0_EPC = 0;\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nbadframe:\n\n    force_sig(TARGET_SIGSEGV/*, current*/);\n\n    return 0;\n\n}\n", "idx": 10627}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl, uint32_t ram_min_mb)\n\n{\n\n    /* vga ram (bar 0) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vga.vram_size < ram_min_mb * 1024 * 1024) {\n\n        qxl->vga.vram_size = ram_min_mb * 1024 * 1024;\n\n    }\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n    }\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n    }\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vga.vram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n    qxl->vram32_size = msb_mask(qxl->vram32_size * 2 - 1);\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n\n}\n", "idx": 1115}
{"project": "qemu", "commit_id": "6c8d56a2e95712a6206a2671d2b04b2e59cabc0b", "target": 1, "func": "static uint64_t fw_cfg_comb_read(void *opaque, hwaddr addr,\n\n                                 unsigned size)\n\n{\n\n    return fw_cfg_read(opaque);\n\n}\n", "idx": 3915}
{"project": "qemu", "commit_id": "9e92f6d46233171898fc7d0487a04e5b78e44234", "target": 1, "func": "void ga_unset_frozen(GAState *s)\n\n{\n\n    if (!ga_is_frozen(s)) {\n\n        return;\n\n    }\n\n\n\n    /* if we delayed creation/opening of pid/log files due to being\n\n     * in a frozen state at start up, do it now\n\n     */\n\n    if (s->deferred_options.log_filepath) {\n\n        s->log_file = fopen(s->deferred_options.log_filepath, \"a\");\n\n        if (!s->log_file) {\n\n            s->log_file = stderr;\n\n        }\n\n        s->deferred_options.log_filepath = NULL;\n\n    }\n\n    ga_enable_logging(s);\n\n    g_warning(\"logging re-enabled due to filesystem unfreeze\");\n\n    if (s->deferred_options.pid_filepath) {\n\n        if (!ga_open_pidfile(s->deferred_options.pid_filepath)) {\n\n            g_warning(\"failed to create/open pid file\");\n\n        }\n\n        s->deferred_options.pid_filepath = NULL;\n\n    }\n\n\n\n    /* enable all disabled, non-blacklisted commands */\n\n    ga_enable_non_blacklisted(s->blacklist);\n\n    s->frozen = false;\n\n    if (!ga_delete_file(s->state_filepath_isfrozen)) {\n\n        g_warning(\"unable to delete %s, fsfreeze may not function properly\",\n\n                  s->state_filepath_isfrozen);\n\n    }\n\n}\n", "idx": 4572}
{"project": "qemu", "commit_id": "dc2c4eca89ec5ee7b7a4c2563c991a14a7c5ee84", "target": 1, "func": "CharDriverState *qemu_chr_new_from_opts(QemuOpts *opts,\n\n                                    void (*init)(struct CharDriverState *s),\n\n                                    Error **errp)\n\n{\n\n    CharDriver *cd;\n\n    CharDriverState *chr;\n\n    GSList *i;\n\n\n\n    if (qemu_opts_id(opts) == NULL) {\n\n        error_setg(errp, \"chardev: no id specified\");\n\n        goto err;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"backend\") == NULL) {\n\n        error_setg(errp, \"chardev: \\\"%s\\\" missing backend\",\n\n                   qemu_opts_id(opts));\n\n        goto err;\n\n    }\n\n    for (i = backends; i; i = i->next) {\n\n        cd = i->data;\n\n\n\n        if (strcmp(cd->name, qemu_opt_get(opts, \"backend\")) == 0) {\n\n            break;\n\n        }\n\n    }\n\n    if (i == NULL) {\n\n        error_setg(errp, \"chardev: backend \\\"%s\\\" not found\",\n\n                   qemu_opt_get(opts, \"backend\"));\n\n        goto err;\n\n    }\n\n\n\n    if (!cd->open) {\n\n        /* using new, qapi init */\n\n        ChardevBackend *backend = g_new0(ChardevBackend, 1);\n\n        ChardevReturn *ret = NULL;\n\n        const char *id = qemu_opts_id(opts);\n\n        const char *bid = NULL;\n\n\n\n        if (qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n            bid = g_strdup_printf(\"%s-base\", id);\n\n        }\n\n\n\n        chr = NULL;\n\n        backend->kind = cd->kind;\n\n        if (cd->parse) {\n\n            cd->parse(opts, backend, errp);\n\n            if (error_is_set(errp)) {\n\n                goto qapi_out;\n\n            }\n\n        }\n\n        ret = qmp_chardev_add(bid ? bid : id, backend, errp);\n\n        if (error_is_set(errp)) {\n\n            goto qapi_out;\n\n        }\n\n\n\n        if (bid) {\n\n            qapi_free_ChardevBackend(backend);\n\n            qapi_free_ChardevReturn(ret);\n\n            backend = g_new0(ChardevBackend, 1);\n\n            backend->mux = g_new0(ChardevMux, 1);\n\n            backend->kind = CHARDEV_BACKEND_KIND_MUX;\n\n            backend->mux->chardev = g_strdup(bid);\n\n            ret = qmp_chardev_add(id, backend, errp);\n\n            if (error_is_set(errp)) {\n\n                goto qapi_out;\n\n            }\n\n        }\n\n\n\n        chr = qemu_chr_find(id);\n\n\n\n    qapi_out:\n\n        qapi_free_ChardevBackend(backend);\n\n        qapi_free_ChardevReturn(ret);\n\n        return chr;\n\n    }\n\n\n\n    chr = cd->open(opts);\n\n    if (!chr) {\n\n        error_setg(errp, \"chardev: opening backend \\\"%s\\\" failed\",\n\n                   qemu_opt_get(opts, \"backend\"));\n\n        goto err;\n\n    }\n\n\n\n    if (!chr->filename)\n\n        chr->filename = g_strdup(qemu_opt_get(opts, \"backend\"));\n\n    chr->init = init;\n\n    /* if we didn't create the chardev via qmp_chardev_add, we\n\n     * need to send the OPENED event here\n\n     */\n\n    if (!chr->explicit_be_open) {\n\n        qemu_chr_be_event(chr, CHR_EVENT_OPENED);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&chardevs, chr, next);\n\n\n\n    if (qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        CharDriverState *base = chr;\n\n        int len = strlen(qemu_opts_id(opts)) + 6;\n\n        base->label = g_malloc(len);\n\n        snprintf(base->label, len, \"%s-base\", qemu_opts_id(opts));\n\n        chr = qemu_chr_open_mux(base);\n\n        chr->filename = base->filename;\n\n        chr->avail_connections = MAX_MUX;\n\n        QTAILQ_INSERT_TAIL(&chardevs, chr, next);\n\n    } else {\n\n        chr->avail_connections = 1;\n\n    }\n\n    chr->label = g_strdup(qemu_opts_id(opts));\n\n    chr->opts = opts;\n\n    return chr;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 4532}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int qcow_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, shift, ret;\n\n    QCowHeader header;\n\n\n\n    ret = bdrv_file_open(&s->hd, filename, flags | BDRV_O_AUTOGROW);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (bdrv_pread(s->hd, 0, &header, sizeof(header)) != sizeof(header))\n\n        goto fail;\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC || header.version != QCOW_VERSION)\n\n        goto fail;\n\n    if (header.size <= 1 ||\n\n        header.cluster_bits < 9 ||\n\n        header.cluster_bits > 16)\n\n        goto fail;\n\n    if (header.crypt_method > QCOW_CRYPT_AES)\n\n        goto fail;\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header)\n\n        bs->encrypted = 1;\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    /* read the level 1 table */\n\n    s->l1_size = header.l1_size;\n\n    shift = s->cluster_bits + s->l2_bits;\n\n    s->l1_vm_state_index = (header.size + (1LL << shift) - 1) >> shift;\n\n    /* the L1 table must contain at least enough entries to put\n\n       header.size bytes */\n\n    if (s->l1_size < s->l1_vm_state_index)\n\n        goto fail;\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    s->l1_table = qemu_malloc(s->l1_size * sizeof(uint64_t));\n\n    if (!s->l1_table)\n\n        goto fail;\n\n    if (bdrv_pread(s->hd, s->l1_table_offset, s->l1_table, s->l1_size * sizeof(uint64_t)) !=\n\n        s->l1_size * sizeof(uint64_t))\n\n        goto fail;\n\n    for(i = 0;i < s->l1_size; i++) {\n\n        be64_to_cpus(&s->l1_table[i]);\n\n    }\n\n    /* alloc L2 cache */\n\n    s->l2_cache = qemu_malloc(s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n\n    if (!s->l2_cache)\n\n        goto fail;\n\n    s->cluster_cache = qemu_malloc(s->cluster_size);\n\n    if (!s->cluster_cache)\n\n        goto fail;\n\n    /* one more sector for decompressed data alignment */\n\n    s->cluster_data = qemu_malloc(s->cluster_size + 512);\n\n    if (!s->cluster_data)\n\n        goto fail;\n\n    s->cluster_cache_offset = -1;\n\n\n\n    if (refcount_init(bs) < 0)\n\n        goto fail;\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023)\n\n            len = 1023;\n\n        if (bdrv_pread(s->hd, header.backing_file_offset, bs->backing_file, len) != len)\n\n            goto fail;\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n    if (qcow_read_snapshots(bs) < 0)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ALLOC\n\n    check_refcounts(bs);\n\n#endif\n\n    return 0;\n\n\n\n fail:\n\n    qcow_free_snapshots(bs);\n\n    refcount_close(bs);\n\n    qemu_free(s->l1_table);\n\n    qemu_free(s->l2_cache);\n\n    qemu_free(s->cluster_cache);\n\n    qemu_free(s->cluster_data);\n\n    bdrv_delete(s->hd);\n\n    return -1;\n\n}\n", "idx": 12158}
{"project": "qemu", "commit_id": "0ca4f94195cce77b624edc6d9abcf14a3bf01f06", "target": 1, "func": "static uint64_t bonito_readl(void *opaque, hwaddr addr,\n\n                             unsigned size)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"\\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 10707}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_proc_601 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_601(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID15, \"HID15\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->nb_tlb = 64;\n\n    env->nb_ways = 2;\n\n    env->id_tlbs = 0;\n\n#endif\n\n    init_excp_601(env);\n\n    env->dcache_line_size = 64;\n\n    env->icache_line_size = 64;\n\n    /* XXX: TODO: allocate internal IRQ controller */\n\n}\n", "idx": 9184}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "RTCState *rtc_init(int base_year)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"mc146818rtc\");\n\n    qdev_prop_set_int32(&dev->qdev, \"base_year\", base_year);\n\n    qdev_init(&dev->qdev);\n\n    return DO_UPCAST(RTCState, dev, dev);\n\n}\n", "idx": 8112}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void moxiesim_init(MachineState *machine)\n\n{\n\n    MoxieCPU *cpu = NULL;\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUMoxieState *env;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    hwaddr ram_base = 0x200000;\n\n    LoaderParams loader_params;\n\n\n\n    /* Init CPUs. */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"MoxieLite-moxie-cpu\";\n\n    }\n\n    cpu = MOXIE_CPU(cpu_generic_init(TYPE_MOXIE_CPU, cpu_model));\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n\n\n    /* Allocate RAM. */\n\n    memory_region_init_ram(ram, NULL, \"moxiesim.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, ram_base, ram);\n\n\n\n    memory_region_init_ram(rom, NULL, \"moxie.rom\", 128 * 0x1000, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0x1000, rom);\n\n\n\n    if (kernel_filename) {\n\n        loader_params.ram_size = ram_size;\n\n        loader_params.kernel_filename = kernel_filename;\n\n        loader_params.kernel_cmdline = kernel_cmdline;\n\n        loader_params.initrd_filename = initrd_filename;\n\n        load_kernel(cpu, &loader_params);\n\n    }\n\n\n\n    /* A single 16450 sits at offset 0x3f8.  */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(address_space_mem, 0x3f8, 0, env->irq[4],\n\n                       8000000/16, serial_hds[0], DEVICE_LITTLE_ENDIAN);\n\n    }\n\n}\n", "idx": 3899}
{"project": "qemu", "commit_id": "9a93b61730e3b46ef1c01ca522c6abe80ec13832", "target": 1, "func": "static void msix_mmio_write(void *opaque, target_phys_addr_t addr,\n                            uint64_t val, unsigned size)\n{\n    PCIDevice *dev = opaque;\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;\n    int vector = offset / PCI_MSIX_ENTRY_SIZE;\n    pci_set_long(dev->msix_table_page + offset, val);\n    msix_handle_mask_update(dev, vector);", "idx": 7016}
{"project": "qemu", "commit_id": "760794f784f66e262a9ca32821ba202cdf3a3e4b", "target": 1, "func": "static int chr_can_read(void *opaque)\n\n{\n\n    int can_read;\n\n    SCLPConsole *scon = opaque;\n\n\n\n    can_read = SIZE_BUFFER_VT220 - scon->iov_data_len;\n\n\n\n    return can_read;\n\n}\n", "idx": 6069}
{"project": "qemu", "commit_id": "689ed13e73bdb5a5ca3366524475e3065fae854a", "target": 1, "func": "static void test_io_channel_tls(const void *opaque)\n\n{\n\n    struct QIOChannelTLSTestData *data =\n\n        (struct QIOChannelTLSTestData *)opaque;\n\n    QCryptoTLSCreds *clientCreds;\n\n    QCryptoTLSCreds *serverCreds;\n\n    QIOChannelTLS *clientChanTLS;\n\n    QIOChannelTLS *serverChanTLS;\n\n    QIOChannelSocket *clientChanSock;\n\n    QIOChannelSocket *serverChanSock;\n\n    qemu_acl *acl;\n\n    const char * const *wildcards;\n\n    int channel[2];\n\n    struct QIOChannelTLSHandshakeData clientHandshake = { false, false };\n\n    struct QIOChannelTLSHandshakeData serverHandshake = { false, false };\n\n    Error *err = NULL;\n\n    QIOChannelTest *test;\n\n    GMainContext *mainloop;\n\n\n\n    /* We'll use this for our fake client-server connection */\n\n    g_assert(socketpair(AF_UNIX, SOCK_STREAM, 0, channel) == 0);\n\n\n\n#define CLIENT_CERT_DIR \"tests/test-io-channel-tls-client/\"\n\n#define SERVER_CERT_DIR \"tests/test-io-channel-tls-server/\"\n\n    mkdir(CLIENT_CERT_DIR, 0700);\n\n    mkdir(SERVER_CERT_DIR, 0700);\n\n\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_KEY);\n\n\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_KEY);\n\n\n\n    g_assert(link(data->servercacrt,\n\n                  SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT) == 0);\n\n    g_assert(link(data->servercrt,\n\n                  SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_CERT) == 0);\n\n    g_assert(link(KEYFILE,\n\n                  SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_KEY) == 0);\n\n\n\n    g_assert(link(data->clientcacrt,\n\n                  CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT) == 0);\n\n    g_assert(link(data->clientcrt,\n\n                  CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_CERT) == 0);\n\n    g_assert(link(KEYFILE,\n\n                  CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_KEY) == 0);\n\n\n\n    clientCreds = test_tls_creds_create(\n\n        QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT,\n\n        CLIENT_CERT_DIR,\n\n        &err);\n\n    g_assert(clientCreds != NULL);\n\n\n\n    serverCreds = test_tls_creds_create(\n\n        QCRYPTO_TLS_CREDS_ENDPOINT_SERVER,\n\n        SERVER_CERT_DIR,\n\n        &err);\n\n    g_assert(serverCreds != NULL);\n\n\n\n    acl = qemu_acl_init(\"channeltlsacl\");\n\n    qemu_acl_reset(acl);\n\n    wildcards = data->wildcards;\n\n    while (wildcards && *wildcards) {\n\n        qemu_acl_append(acl, 0, *wildcards);\n\n        wildcards++;\n\n    }\n\n\n\n    clientChanSock = qio_channel_socket_new_fd(\n\n        channel[0], &err);\n\n    g_assert(clientChanSock != NULL);\n\n    serverChanSock = qio_channel_socket_new_fd(\n\n        channel[1], &err);\n\n    g_assert(serverChanSock != NULL);\n\n\n\n    /*\n\n     * We have an evil loop to do the handshake in a single\n\n     * thread, so we need these non-blocking to avoid deadlock\n\n     * of ourselves\n\n     */\n\n    qio_channel_set_blocking(QIO_CHANNEL(clientChanSock), false, NULL);\n\n    qio_channel_set_blocking(QIO_CHANNEL(serverChanSock), false, NULL);\n\n\n\n    /* Now the real part of the test, setup the sessions */\n\n    clientChanTLS = qio_channel_tls_new_client(\n\n        QIO_CHANNEL(clientChanSock), clientCreds,\n\n        data->hostname, &err);\n\n    g_assert(clientChanTLS != NULL);\n\n\n\n    serverChanTLS = qio_channel_tls_new_server(\n\n        QIO_CHANNEL(serverChanSock), serverCreds,\n\n        \"channeltlsacl\", &err);\n\n    g_assert(serverChanTLS != NULL);\n\n\n\n    qio_channel_tls_handshake(clientChanTLS,\n\n                              test_tls_handshake_done,\n\n                              &clientHandshake,\n\n                              NULL);\n\n    qio_channel_tls_handshake(serverChanTLS,\n\n                              test_tls_handshake_done,\n\n                              &serverHandshake,\n\n                              NULL);\n\n\n\n    /*\n\n     * Finally we loop around & around doing handshake on each\n\n     * session until we get an error, or the handshake completes.\n\n     * This relies on the socketpair being nonblocking to avoid\n\n     * deadlocking ourselves upon handshake\n\n     */\n\n    mainloop = g_main_context_default();\n\n    do {\n\n        g_main_context_iteration(mainloop, TRUE);\n\n    } while (!clientHandshake.finished &&\n\n             !serverHandshake.finished);\n\n\n\n    g_assert(clientHandshake.failed == data->expectClientFail);\n\n    g_assert(serverHandshake.failed == data->expectServerFail);\n\n\n\n    test = qio_channel_test_new();\n\n    qio_channel_test_run_threads(test, false,\n\n                                 QIO_CHANNEL(clientChanTLS),\n\n                                 QIO_CHANNEL(serverChanTLS));\n\n    qio_channel_test_validate(test);\n\n\n\n    test = qio_channel_test_new();\n\n    qio_channel_test_run_threads(test, true,\n\n                                 QIO_CHANNEL(clientChanTLS),\n\n                                 QIO_CHANNEL(serverChanTLS));\n\n    qio_channel_test_validate(test);\n\n\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_CERT);\n\n    unlink(SERVER_CERT_DIR QCRYPTO_TLS_CREDS_X509_SERVER_KEY);\n\n\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CA_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_CERT);\n\n    unlink(CLIENT_CERT_DIR QCRYPTO_TLS_CREDS_X509_CLIENT_KEY);\n\n\n\n    rmdir(CLIENT_CERT_DIR);\n\n    rmdir(SERVER_CERT_DIR);\n\n\n\n    object_unparent(OBJECT(serverCreds));\n\n    object_unparent(OBJECT(clientCreds));\n\n\n\n    object_unref(OBJECT(serverChanTLS));\n\n    object_unref(OBJECT(clientChanTLS));\n\n\n\n    object_unref(OBJECT(serverChanSock));\n\n    object_unref(OBJECT(clientChanSock));\n\n\n\n    close(channel[0]);\n\n    close(channel[1]);\n\n}\n", "idx": 4152}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void *pl110_init(DisplayState *ds, uint32_t base, qemu_irq irq,\n\n                 int versatile)\n\n{\n\n    pl110_state *s;\n\n    int iomemtype;\n\n\n\n    s = (pl110_state *)qemu_mallocz(sizeof(pl110_state));\n\n    iomemtype = cpu_register_io_memory(0, pl110_readfn,\n\n                                       pl110_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->ds = ds;\n\n    s->versatile = versatile;\n\n    s->irq = irq;\n\n    graphic_console_init(ds, pl110_update_display, pl110_invalidate_display,\n\n                         NULL, s);\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n", "idx": 3517}
{"project": "qemu", "commit_id": "c7085da7266120a8594f8fddcbf3b6839a8eda58", "target": 1, "func": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOBlock *s = to_virtio_blk(vdev);\n\n    struct virtio_blk_config blkcfg;\n\n    uint64_t capacity;\n\n    int cylinders, heads, secs;\n\n\n\n    bdrv_get_geometry(s->bs, &capacity);\n\n    bdrv_get_geometry_hint(s->bs, &cylinders, &heads, &secs);\n\n    stq_raw(&blkcfg.capacity, capacity);\n\n    stl_raw(&blkcfg.seg_max, 128 - 2);\n\n    stw_raw(&blkcfg.cylinders, cylinders);\n\n    blkcfg.heads = heads;\n\n    blkcfg.sectors = secs;\n\n\n    memcpy(config, &blkcfg, sizeof(blkcfg));\n\n}", "idx": 9314}
{"project": "qemu", "commit_id": "6687b79d636cd60ed9adb1177d0d946b58fa7717", "target": 1, "func": "static int net_init_nic(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    int idx;\n\n    NICInfo *nd;\n\n    const char *netdev;\n\n\n\n    idx = nic_get_free_idx();\n\n    if (idx == -1 || nb_nics >= MAX_NICS) {\n\n        error_report(\"Too Many NICs\");\n\n        return -1;\n\n    }\n\n\n\n    nd = &nd_table[idx];\n\n\n\n    memset(nd, 0, sizeof(*nd));\n\n\n\n    if ((netdev = qemu_opt_get(opts, \"netdev\"))) {\n\n        nd->netdev = qemu_find_netdev(netdev);\n\n        if (!nd->netdev) {\n\n            error_report(\"netdev '%s' not found\", netdev);\n\n            return -1;\n\n        }\n\n    } else {\n\n        assert(vlan);\n\n        nd->vlan = vlan;\n\n    }\n\n    if (name) {\n\n        nd->name = g_strdup(name);\n\n    }\n\n    if (qemu_opt_get(opts, \"model\")) {\n\n        nd->model = g_strdup(qemu_opt_get(opts, \"model\"));\n\n    }\n\n    if (qemu_opt_get(opts, \"addr\")) {\n\n        nd->devaddr = g_strdup(qemu_opt_get(opts, \"addr\"));\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"macaddr\") &&\n\n        net_parse_macaddr(nd->macaddr.a, qemu_opt_get(opts, \"macaddr\")) < 0) {\n\n        error_report(\"invalid syntax for ethernet address\");\n\n        return -1;\n\n    }\n\n    qemu_macaddr_default_if_unset(&nd->macaddr);\n\n\n\n    nd->nvectors = qemu_opt_get_number(opts, \"vectors\",\n\n                                       DEV_NVECTORS_UNSPECIFIED);\n\n    if (nd->nvectors != DEV_NVECTORS_UNSPECIFIED &&\n\n        (nd->nvectors < 0 || nd->nvectors > 0x7ffffff)) {\n\n        error_report(\"invalid # of vectors: %d\", nd->nvectors);\n\n        return -1;\n\n    }\n\n\n\n    nd->used = 1;\n\n    nb_nics++;\n\n\n\n    return idx;\n\n}\n", "idx": 3999}
{"project": "qemu", "commit_id": "010ec6293409f10b88631c36145944b9c3277ce1", "target": 1, "func": "static void nic_reset(void *opaque)\n\n{\n\n    EEPRO100State *s = opaque;\n\n    TRACE(OTHER, logout(\"%p\\n\", s));\n\n    /* TODO: Clearing of multicast table for selective reset, too? */\n\n    memset(&s->mult[0], 0, sizeof(s->mult));\n\n    nic_selective_reset(s);\n\n}\n", "idx": 8550}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void rtas_set_tce_bypass(sPAPREnvironment *spapr, uint32_t token,\n\n                                uint32_t nargs, target_ulong args,\n\n                                uint32_t nret, target_ulong rets)\n\n{\n\n    VIOsPAPRBus *bus = spapr->vio_bus;\n\n    VIOsPAPRDevice *dev;\n\n    uint32_t unit, enable;\n\n\n\n    if (nargs != 2) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n    unit = rtas_ld(args, 0);\n\n    enable = rtas_ld(args, 1);\n\n    dev = spapr_vio_find_by_reg(bus, unit);\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n    if (enable) {\n\n        dev->flags |= VIO_PAPR_FLAG_DMA_BYPASS;\n\n    } else {\n\n        dev->flags &= ~VIO_PAPR_FLAG_DMA_BYPASS;\n\n    }\n\n\n\n    rtas_st(rets, 0, 0);\n\n}\n", "idx": 12176}
{"project": "qemu", "commit_id": "d3532a0db02296e687711b8cdc7791924efccea0", "target": 1, "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (BLTUNSAFE(s))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n", "idx": 6463}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int unused, int size)\n\n{\n\n    if (is_exec)\n\n        helper_raise_exception(EXCP_IBE);\n\n    else\n\n        helper_raise_exception(EXCP_DBE);\n\n}\n", "idx": 11777}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_realize(DeviceState *dev, Error **errp)\n{\n    PnvChip *chip = PNV_CHIP(dev);\n    Error *error = NULL;\n    PnvChipClass *pcc = PNV_CHIP_GET_CLASS(chip);\n    char *typename = pnv_core_typename(pcc->cpu_model);\n    size_t typesize = object_type_get_instance_size(typename);\n    int i, core_hwid;\n    if (!object_class_by_name(typename)) {\n        error_setg(errp, \"Unable to find PowerNV CPU Core '%s'\", typename);\n    /* Cores */\n    pnv_chip_core_sanitize(chip, &error);\n    chip->cores = g_malloc0(typesize * chip->nr_cores);\n    for (i = 0, core_hwid = 0; (core_hwid < sizeof(chip->cores_mask) * 8)\n             && (i < chip->nr_cores); core_hwid++) {\n        char core_name[32];\n        void *pnv_core = chip->cores + i * typesize;\n        if (!(chip->cores_mask & (1ull << core_hwid))) {\n            continue;\n        object_initialize(pnv_core, typesize, typename);\n        snprintf(core_name, sizeof(core_name), \"core[%d]\", core_hwid);\n        object_property_add_child(OBJECT(chip), core_name, OBJECT(pnv_core),\n                                  &error_fatal);\n        object_property_set_int(OBJECT(pnv_core), smp_threads, \"nr-threads\",\n                                &error_fatal);\n        object_property_set_int(OBJECT(pnv_core), core_hwid,\n                                CPU_CORE_PROP_CORE_ID, &error_fatal);\n        object_property_set_int(OBJECT(pnv_core),\n                                pcc->core_pir(chip, core_hwid),\n                                \"pir\", &error_fatal);\n        object_property_set_bool(OBJECT(pnv_core), true, \"realized\",\n                                 &error_fatal);\n        object_unref(OBJECT(pnv_core));\n        i++;\n    g_free(typename);", "idx": 1414}
{"project": "qemu", "commit_id": "75cb298d905030fca897ea1d80e409c7f7e3e5ea", "target": 1, "func": "sowrite(struct socket *so)\n\n{\n\n\tint  n,nn;\n\n\tstruct sbuf *sb = &so->so_rcv;\n\n\tint len = sb->sb_cc;\n\n\tstruct iovec iov[2];\n\n\n\n\tDEBUG_CALL(\"sowrite\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\n\n\tif (so->so_urgc) {\n\n\t\tsosendoob(so);\n\n\t\tif (sb->sb_cc == 0)\n\n\t\t\treturn 0;\n\n\t}\n\n\n\n\t/*\n\n\t * No need to check if there's something to write,\n\n\t * sowrite wouldn't have been called otherwise\n\n\t */\n\n\n\n\tiov[0].iov_base = sb->sb_rptr;\n\n        iov[1].iov_base = NULL;\n\n        iov[1].iov_len = 0;\n\n\tif (sb->sb_rptr < sb->sb_wptr) {\n\n\t\tiov[0].iov_len = sb->sb_wptr - sb->sb_rptr;\n\n\t\t/* Should never succeed, but... */\n\n\t\tif (iov[0].iov_len > len) iov[0].iov_len = len;\n\n\t\tn = 1;\n\n\t} else {\n\n\t\tiov[0].iov_len = (sb->sb_data + sb->sb_datalen) - sb->sb_rptr;\n\n\t\tif (iov[0].iov_len > len) iov[0].iov_len = len;\n\n\t\tlen -= iov[0].iov_len;\n\n\t\tif (len) {\n\n\t\t\tiov[1].iov_base = sb->sb_data;\n\n\t\t\tiov[1].iov_len = sb->sb_wptr - sb->sb_data;\n\n\t\t\tif (iov[1].iov_len > len) iov[1].iov_len = len;\n\n\t\t\tn = 2;\n\n\t\t} else\n\n\t\t\tn = 1;\n\n\t}\n\n\t/* Check if there's urgent data to send, and if so, send it */\n\n\n\n#ifdef HAVE_READV\n\n\tnn = writev(so->s, (const struct iovec *)iov, n);\n\n\n\n\tDEBUG_MISC((dfd, \"  ... wrote nn = %d bytes\\n\", nn));\n\n#else\n\n\tnn = slirp_send(so, iov[0].iov_base, iov[0].iov_len,0);\n\n#endif\n\n\t/* This should never happen, but people tell me it does *shrug* */\n\n\tif (nn < 0 && (errno == EAGAIN || errno == EINTR))\n\n\t\treturn 0;\n\n\n\n\tif (nn <= 0) {\n\n\t\tDEBUG_MISC((dfd, \" --- sowrite disconnected, so->so_state = %x, errno = %d\\n\",\n\n\t\t\tso->so_state, errno));\n\n\t\tsofcantsendmore(so);\n\n\t\ttcp_sockclosed(sototcpcb(so));\n\n\t\treturn -1;\n\n\t}\n\n\n\n#ifndef HAVE_READV\n\n\tif (n == 2 && nn == iov[0].iov_len) {\n\n            int ret;\n\n            ret = slirp_send(so, iov[1].iov_base, iov[1].iov_len,0);\n\n            if (ret > 0)\n\n                nn += ret;\n\n        }\n\n        DEBUG_MISC((dfd, \"  ... wrote nn = %d bytes\\n\", nn));\n\n#endif\n\n\n\n\t/* Update sbuf */\n\n\tsb->sb_cc -= nn;\n\n\tsb->sb_rptr += nn;\n\n\tif (sb->sb_rptr >= (sb->sb_data + sb->sb_datalen))\n\n\t\tsb->sb_rptr -= sb->sb_datalen;\n\n\n\n\t/*\n\n\t * If in DRAIN mode, and there's no more data, set\n\n\t * it CANTSENDMORE\n\n\t */\n\n\tif ((so->so_state & SS_FWDRAIN) && sb->sb_cc == 0)\n\n\t\tsofcantsendmore(so);\n\n\n\n\treturn nn;\n\n}\n", "idx": 411}
{"project": "qemu", "commit_id": "797d780b1375b1af1d7713685589bfdec9908dc3", "target": 1, "func": "static void gen_wsr_ps(DisasContext *dc, uint32_t sr, TCGv_i32 v)\n\n{\n\n    uint32_t mask = PS_WOE | PS_CALLINC | PS_OWB |\n\n        PS_UM | PS_EXCM | PS_INTLEVEL;\n\n\n\n    if (option_enabled(dc, XTENSA_OPTION_MMU)) {\n\n        mask |= PS_RING;\n\n    }\n\n    tcg_gen_andi_i32(cpu_SR[sr], v, mask);\n\n    /* This can change mmu index, so exit tb */\n\n    gen_jumpi(dc, dc->next_pc, -1);\n\n}\n", "idx": 4664}
{"project": "qemu", "commit_id": "2ba1eeb62c29d23238b95dc7e9ade3444b49f0a1", "target": 1, "func": "int dyngen_code(TCGContext *s, uint8_t *gen_code_buf)\n\n{\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        extern int64_t dyngen_op_count;\n\n        extern int dyngen_op_count_max;\n\n        int n;\n\n        n = (gen_opc_ptr - gen_opc_buf);\n\n        dyngen_op_count += n;\n\n        if (n > dyngen_op_count_max)\n\n            dyngen_op_count_max = n;\n\n    }\n\n#endif\n\n\n\n    tcg_gen_code_common(s, gen_code_buf, 0, NULL);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((unsigned long)gen_code_buf, \n\n                       (unsigned long)s->code_ptr);\n\n    return s->code_ptr -  gen_code_buf;\n\n}\n", "idx": 3214}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void vnc_dpy_switch(DisplayChangeListener *dcl,\n\n                           DisplaySurface *surface)\n\n{\n\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n\n    VncState *vs;\n\n\n\n    vnc_abort_display_jobs(vd);\n\n\n\n    /* server surface */\n\n    qemu_pixman_image_unref(vd->server);\n\n    vd->ds = surface;\n\n    vd->server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,\n\n                                          surface_width(vd->ds),\n\n                                          surface_height(vd->ds),\n\n                                          NULL, 0);\n\n\n\n    /* guest surface */\n\n#if 0 /* FIXME */\n\n    if (ds_get_bytes_per_pixel(ds) != vd->guest.ds->pf.bytes_per_pixel)\n\n        console_color_init(ds);\n\n#endif\n\n    qemu_pixman_image_unref(vd->guest.fb);\n\n    vd->guest.fb = pixman_image_ref(surface->image);\n\n    vd->guest.format = surface->format;\n\n    VNC_SET_VISIBLE_PIXELS_DIRTY(vd->guest.dirty,\n\n                                 surface_width(vd->ds),\n\n                                 surface_height(vd->ds));\n\n\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n        vnc_colordepth(vs);\n\n        vnc_desktop_resize(vs);\n\n        if (vs->vd->cursor) {\n\n            vnc_cursor_define(vs);\n\n        }\n\n        VNC_SET_VISIBLE_PIXELS_DIRTY(vs->dirty,\n\n                                     surface_width(vd->ds),\n\n                                     surface_height(vd->ds));\n\n    }\n\n}\n", "idx": 8850}
{"project": "qemu", "commit_id": "548f52ea06951c20f0b91cae6cde0512ec073c83", "target": 1, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n    int pending;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    pending = f->buf_size - f->buf_index;\n\n    if (pending > 0) {\n\n        memmove(f->buf, f->buf + f->buf_index, pending);\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = pending;\n\n\n\n    len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n\n                        IO_BUF_SIZE - pending);\n\n    if (len > 0) {\n\n        f->buf_size += len;\n\n        f->pos += len;\n\n    } else if (len == 0) {\n\n        qemu_file_set_error(f, -EIO);\n\n    } else if (len != -EAGAIN) {\n\n        qemu_file_set_error(f, len);\n\n    }\n\n}\n", "idx": 7676}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)\n{\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n    if (k->notify) {\n        k->notify(qbus->parent, vector);", "idx": 4269}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "void *g_try_realloc(void *mem, size_t n_bytes)\n\n{\n\n    __coverity_negative_sink__(n_bytes);\n\n    return realloc(mem, n_bytes == 0 ? 1 : n_bytes);\n\n}\n", "idx": 8120}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfi(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    /* FIXME: This instruction doesn't exist anymore on 64-bit server\n\n     * processors compliant with arch 2.x, we should remove it there,\n\n     * but we need to fix OpenBIOS not to use it on 970 first\n\n     */\n\n    /* Restore CPU state */\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_update_cfar(ctx, ctx->nip);\n\n    gen_helper_rfi(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 11408}
{"project": "qemu", "commit_id": "4d1de87c75007ee7e29dd271ebb4afdcf01ad7aa", "target": 1, "func": "abi_long do_brk(abi_ulong new_brk)\n\n{\n\n    abi_ulong brk_page;\n\n    abi_long mapped_addr;\n\n    int\tnew_alloc_size;\n\n\n\n    if (!new_brk)\n\n        return target_brk;\n\n    if (new_brk < target_original_brk)\n\n        return target_brk;\n\n\n\n    brk_page = HOST_PAGE_ALIGN(target_brk);\n\n\n\n    /* If the new brk is less than this, set it and we're done... */\n\n    if (new_brk < brk_page) {\n\n\ttarget_brk = new_brk;\n\n    \treturn target_brk;\n\n    }\n\n\n\n    /* We need to allocate more memory after the brk... Note that\n\n     * we don't use MAP_FIXED because that will map over the top of\n\n     * any existing mapping (like the one with the host libc or qemu\n\n     * itself); instead we treat \"mapped but at wrong address\" as\n\n     * a failure and unmap again.\n\n     */\n\n    new_alloc_size = HOST_PAGE_ALIGN(new_brk - brk_page + 1);\n\n    mapped_addr = get_errno(target_mmap(brk_page, new_alloc_size,\n\n                                        PROT_READ|PROT_WRITE,\n\n                                        MAP_ANON|MAP_PRIVATE, 0, 0));\n\n\n\n    if (mapped_addr == brk_page) {\n\n        target_brk = new_brk;\n\n        return target_brk;\n\n    } else if (mapped_addr != -1) {\n\n        /* Mapped but at wrong address, meaning there wasn't actually\n\n         * enough space for this brk.\n\n         */\n\n        target_munmap(mapped_addr, new_alloc_size);\n\n        mapped_addr = -1;\n\n    }\n\n\n\n#if defined(TARGET_ALPHA)\n\n    /* We (partially) emulate OSF/1 on Alpha, which requires we\n\n       return a proper errno, not an unchanged brk value.  */\n\n    return -TARGET_ENOMEM;\n\n#endif\n\n    /* For everything else, return the previous break. */\n\n    return target_brk;\n\n}\n", "idx": 10910}
{"project": "qemu", "commit_id": "9fbf0fa81fca8f527669dd4fa72662d66e7d6329", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)\n\n{\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 7923}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "static void aarch64_tr_insn_start(DisasContextBase *dcbase, CPUState *cpu)\n\n{\n\n    DisasContext *dc = container_of(dcbase, DisasContext, base);\n\n\n\n    dc->insn_start_idx = tcg_op_buf_count();\n\n    tcg_gen_insn_start(dc->pc, 0, 0);\n\n}\n", "idx": 2499}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 838}
{"project": "qemu", "commit_id": "e8199e4895d34136735dea7e628d0de1a5afb630", "target": 1, "func": "static void process_incoming_migration_co(void *opaque)\n\n{\n\n    QEMUFile *f = opaque;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n    PostcopyState ps;\n\n    int ret;\n\n\n\n    mis->from_src_file = f;\n\n    mis->largest_page_size = qemu_ram_pagesize_largest();\n\n    postcopy_state_set(POSTCOPY_INCOMING_NONE);\n\n    migrate_set_state(&mis->state, MIGRATION_STATUS_NONE,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n    ret = qemu_loadvm_state(f);\n\n\n\n    ps = postcopy_state_get();\n\n    trace_process_incoming_migration_co_end(ret, ps);\n\n    if (ps != POSTCOPY_INCOMING_NONE) {\n\n        if (ps == POSTCOPY_INCOMING_ADVISE) {\n\n            /*\n\n             * Where a migration had postcopy enabled (and thus went to advise)\n\n             * but managed to complete within the precopy period, we can use\n\n             * the normal exit.\n\n             */\n\n            postcopy_ram_incoming_cleanup(mis);\n\n        } else if (ret >= 0) {\n\n            /*\n\n             * Postcopy was started, cleanup should happen at the end of the\n\n             * postcopy thread.\n\n             */\n\n            trace_process_incoming_migration_co_postcopy_end_main();\n\n            return;\n\n        }\n\n        /* Else if something went wrong then just fall out of the normal exit */\n\n    }\n\n\n\n    /* we get COLO info, and know if we are in COLO mode */\n\n    if (!ret && migration_incoming_enable_colo()) {\n\n        mis->migration_incoming_co = qemu_coroutine_self();\n\n        qemu_thread_create(&mis->colo_incoming_thread, \"COLO incoming\",\n\n             colo_process_incoming_thread, mis, QEMU_THREAD_JOINABLE);\n\n        mis->have_colo_incoming_thread = true;\n\n        qemu_coroutine_yield();\n\n\n\n        /* Wait checkpoint incoming thread exit before free resource */\n\n        qemu_thread_join(&mis->colo_incoming_thread);\n\n    }\n\n\n\n    qemu_fclose(f);\n\n    free_xbzrle_decoded_buf();\n\n\n\n    if (ret < 0) {\n\n        migrate_set_state(&mis->state, MIGRATION_STATUS_ACTIVE,\n\n                          MIGRATION_STATUS_FAILED);\n\n        error_report(\"load of migration failed: %s\", strerror(-ret));\n\n        migrate_decompress_threads_join();\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    mis->bh = qemu_bh_new(process_incoming_migration_bh, mis);\n\n    qemu_bh_schedule(mis->bh);\n\n}\n", "idx": 7532}
{"project": "qemu", "commit_id": "3ce21445387c64032a21ae73c995195307a28a36", "target": 1, "func": "void usb_host_info(Monitor *mon, const QDict *qdict)\n\n{\n\n    libusb_device **devs;\n\n    struct libusb_device_descriptor ddesc;\n\n    char port[16];\n\n    int i, n;\n\n\n\n    if (usb_host_init() != 0) {\n\n        return;\n\n    }\n\n\n\n    n = libusb_get_device_list(ctx, &devs);\n\n    for (i = 0; i < n; i++) {\n\n        if (libusb_get_device_descriptor(devs[i], &ddesc) != 0) {\n\n            continue;\n\n        }\n\n        if (ddesc.bDeviceClass == LIBUSB_CLASS_HUB) {\n\n            continue;\n\n        }\n\n        usb_host_get_port(devs[i], port, sizeof(port));\n\n        monitor_printf(mon, \"  Bus %d, Addr %d, Port %s, Speed %s Mb/s\\n\",\n\n                       libusb_get_bus_number(devs[i]),\n\n                       libusb_get_device_address(devs[i]),\n\n                       port,\n\n                       speed_name[libusb_get_device_speed(devs[i])]);\n\n        monitor_printf(mon, \"    Class %02x:\", ddesc.bDeviceClass);\n\n        monitor_printf(mon, \" USB device %04x:%04x\",\n\n                       ddesc.idVendor, ddesc.idProduct);\n\n        if (ddesc.iProduct) {\n\n            libusb_device_handle *handle;\n\n            if (libusb_open(devs[i], &handle) == 0) {\n\n                unsigned char name[64] = \"\";\n\n                libusb_get_string_descriptor_ascii(handle,\n\n                                                   ddesc.iProduct,\n\n                                                   name, sizeof(name));\n\n                libusb_close(handle);\n\n                monitor_printf(mon, \", %s\", name);\n\n            }\n\n        }\n\n        monitor_printf(mon, \"\\n\");\n\n    }\n\n    libusb_free_device_list(devs, 1);\n\n}\n", "idx": 8494}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_signal(QemuCond *cond)\n\n{\n\n    DWORD result;\n\n\n\n    /*\n\n     * Signal only when there are waiters.  cond->waiters is\n\n     * incremented by pthread_cond_wait under the external lock,\n\n     * so we are safe about that.\n\n     */\n\n    if (cond->waiters == 0) {\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * Waiting threads decrement it outside the external lock, but\n\n     * only if another thread is executing pthread_cond_broadcast and\n\n     * has the mutex.  So, it also cannot be decremented concurrently\n\n     * with this particular access.\n\n     */\n\n    cond->target = cond->waiters - 1;\n\n    result = SignalObjectAndWait(cond->sema, cond->continue_event,\n\n                                 INFINITE, FALSE);\n\n    if (result == WAIT_ABANDONED || result == WAIT_FAILED) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n}\n", "idx": 2470}
{"project": "qemu", "commit_id": "6b728b31163bbd0788fe7d537931c4624cd24215", "target": 1, "func": "static int assign_intx(AssignedDevice *dev, Error **errp)\n\n{\n\n    AssignedIRQType new_type;\n\n    PCIINTxRoute intx_route;\n\n    bool intx_host_msi;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    /* Interrupt PIN 0 means don't use INTx */\n\n    if (assigned_dev_pci_read_byte(&dev->dev, PCI_INTERRUPT_PIN) == 0) {\n\n        pci_device_set_intx_routing_notifier(&dev->dev, NULL);\n\n        return 0;\n\n    }\n\n\n\n    verify_irqchip_in_kernel(&local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    pci_device_set_intx_routing_notifier(&dev->dev,\n\n                                         assigned_dev_update_irq_routing);\n\n\n\n    intx_route = pci_device_route_intx_to_irq(&dev->dev, dev->intpin);\n\n    assert(intx_route.mode != PCI_INTX_INVERTED);\n\n\n\n    if (!pci_intx_route_changed(&dev->intx_route, &intx_route)) {\n\n        return 0;\n\n    }\n\n\n\n    switch (dev->assigned_irq_type) {\n\n    case ASSIGNED_IRQ_INTX_HOST_INTX:\n\n    case ASSIGNED_IRQ_INTX_HOST_MSI:\n\n        intx_host_msi = dev->assigned_irq_type == ASSIGNED_IRQ_INTX_HOST_MSI;\n\n        r = kvm_device_intx_deassign(kvm_state, dev->dev_id, intx_host_msi);\n\n        break;\n\n    case ASSIGNED_IRQ_MSI:\n\n        r = kvm_device_msi_deassign(kvm_state, dev->dev_id);\n\n        break;\n\n    case ASSIGNED_IRQ_MSIX:\n\n        r = kvm_device_msix_deassign(kvm_state, dev->dev_id);\n\n        break;\n\n    default:\n\n        r = 0;\n\n        break;\n\n    }\n\n    if (r) {\n\n        perror(\"assign_intx: deassignment of previous interrupt failed\");\n\n    }\n\n    dev->assigned_irq_type = ASSIGNED_IRQ_NONE;\n\n\n\n    if (intx_route.mode == PCI_INTX_DISABLED) {\n\n        dev->intx_route = intx_route;\n\n        return 0;\n\n    }\n\n\n\nretry:\n\n    if (dev->features & ASSIGNED_DEVICE_PREFER_MSI_MASK &&\n\n        dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {\n\n        intx_host_msi = true;\n\n        new_type = ASSIGNED_IRQ_INTX_HOST_MSI;\n\n    } else {\n\n        intx_host_msi = false;\n\n        new_type = ASSIGNED_IRQ_INTX_HOST_INTX;\n\n    }\n\n\n\n    r = kvm_device_intx_assign(kvm_state, dev->dev_id, intx_host_msi,\n\n                               intx_route.irq);\n\n    if (r < 0) {\n\n        if (r == -EIO && !(dev->features & ASSIGNED_DEVICE_PREFER_MSI_MASK) &&\n\n            dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {\n\n            /* Retry with host-side MSI. There might be an IRQ conflict and\n\n             * either the kernel or the device doesn't support sharing. */\n\n            error_report(\"Host-side INTx sharing not supported, \"\n\n                         \"using MSI instead\");\n\n            error_printf(\"Some devices do not work properly in this mode.\\n\");\n\n            dev->features |= ASSIGNED_DEVICE_PREFER_MSI_MASK;\n\n            goto retry;\n\n        }\n\n        error_setg_errno(errp, -r, \"Failed to assign irq for \\\"%s\\\"\",\n\n                         dev->dev.qdev.id);\n\n        error_append_hint(errp, \"Perhaps you are assigning a device \"\n\n                          \"that shares an IRQ with another device?\\n\");\n\n        return r;\n\n    }\n\n\n\n    dev->intx_route = intx_route;\n\n    dev->assigned_irq_type = new_type;\n\n    return r;\n\n}\n", "idx": 2404}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                          BdrvCheckMode fix)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size, i, highest_cluster, nb_clusters;\n\n    int refcount1, refcount2;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n    int ret;\n\n\n\n    size = bdrv_getlength(bs->file);\n\n    if (size < 0) {\n\n        res->check_errors++;\n\n        return size;\n\n    }\n\n\n\n    nb_clusters = size_to_clusters(s, size);\n\n    if (nb_clusters > INT_MAX) {\n\n        res->check_errors++;\n\n        return -EFBIG;\n\n    }\n\n\n\n    refcount_table = g_malloc0(nb_clusters * sizeof(uint16_t));\n\n\n\n    res->bfi.total_clusters =\n\n        size_to_clusters(s, bs->total_sectors * BDRV_SECTOR_SIZE);\n\n\n\n    /* header */\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        0, s->cluster_size);\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n            sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->refcount_table_offset,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= nb_clusters) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                    \" is outside image\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                offset, s->cluster_size);\n\n            if (refcount_table[cluster] != 1) {\n\n                fprintf(stderr, \"%s refcount block %\" PRId64\n\n                    \" refcount=%d\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                            \"ERROR\",\n\n                    i, refcount_table[cluster]);\n\n\n\n                if (fix & BDRV_FIX_ERRORS) {\n\n                    int64_t new_offset;\n\n\n\n                    new_offset = realloc_refcount_block(bs, i, offset);\n\n                    if (new_offset < 0) {\n\n                        res->corruptions++;\n\n                        continue;\n\n                    }\n\n\n\n                    /* update refcounts */\n\n                    if ((new_offset >> s->cluster_bits) >= nb_clusters) {\n\n                        /* increase refcount_table size if necessary */\n\n                        int old_nb_clusters = nb_clusters;\n\n                        nb_clusters = (new_offset >> s->cluster_bits) + 1;\n\n                        refcount_table = g_realloc(refcount_table,\n\n                                nb_clusters * sizeof(uint16_t));\n\n                        memset(&refcount_table[old_nb_clusters], 0, (nb_clusters\n\n                                - old_nb_clusters) * sizeof(uint16_t));\n\n                    }\n\n                    refcount_table[cluster]--;\n\n                    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            new_offset, s->cluster_size);\n\n\n\n                    res->corruptions_fixed++;\n\n                } else {\n\n                    res->corruptions++;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for (i = 0, highest_cluster = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        if (refcount1 < 0) {\n\n            fprintf(stderr, \"Can't get refcount for cluster %\" PRId64 \": %s\\n\",\n\n                i, strerror(-refcount1));\n\n            res->check_errors++;\n\n            continue;\n\n        }\n\n\n\n        refcount2 = refcount_table[i];\n\n\n\n        if (refcount1 > 0 || refcount2 > 0) {\n\n            highest_cluster = i;\n\n        }\n\n\n\n        if (refcount1 != refcount2) {\n\n\n\n            /* Check if we're allowed to fix the mismatch */\n\n            int *num_fixed = NULL;\n\n            if (refcount1 > refcount2 && (fix & BDRV_FIX_LEAKS)) {\n\n                num_fixed = &res->leaks_fixed;\n\n            } else if (refcount1 < refcount2 && (fix & BDRV_FIX_ERRORS)) {\n\n                num_fixed = &res->corruptions_fixed;\n\n            }\n\n\n\n            fprintf(stderr, \"%s cluster %\" PRId64 \" refcount=%d reference=%d\\n\",\n\n                   num_fixed != NULL     ? \"Repairing\" :\n\n                   refcount1 < refcount2 ? \"ERROR\" :\n\n                                           \"Leaked\",\n\n                   i, refcount1, refcount2);\n\n\n\n            if (num_fixed) {\n\n                ret = update_refcount(bs, i << s->cluster_bits, 1,\n\n                                      refcount2 - refcount1,\n\n                                      QCOW2_DISCARD_ALWAYS);\n\n                if (ret >= 0) {\n\n                    (*num_fixed)++;\n\n                    continue;\n\n                }\n\n            }\n\n\n\n            /* And if we couldn't, print an error */\n\n            if (refcount1 < refcount2) {\n\n                res->corruptions++;\n\n            } else {\n\n                res->leaks++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* check OFLAG_COPIED */\n\n    ret = check_oflag_copied(bs, res, fix);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    res->image_end_offset = (highest_cluster + 1) * s->cluster_size;\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(refcount_table);\n\n\n\n    return ret;\n\n}\n", "idx": 11803}
{"project": "qemu", "commit_id": "0560b0e97df3da43651158c799c6d889f27529c3", "target": 1, "func": "static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);\n\n\n\n    /*\n\n     * virtio pci bar layout used by default.\n\n     * subclasses can re-arrange things if needed.\n\n     *\n\n     *   region 0   --  virtio legacy io bar\n\n     *   region 1   --  msi-x bar\n\n     *   region 4+5 --  virtio modern memory (64bit) bar\n\n     *\n\n     */\n\n    proxy->legacy_io_bar  = 0;\n\n    proxy->msix_bar       = 1;\n\n    proxy->modern_io_bar  = 2;\n\n    proxy->modern_mem_bar = 4;\n\n\n\n    proxy->common.offset = 0x0;\n\n    proxy->common.size = 0x1000;\n\n    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;\n\n\n\n    proxy->isr.offset = 0x1000;\n\n    proxy->isr.size = 0x1000;\n\n    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;\n\n\n\n    proxy->device.offset = 0x2000;\n\n    proxy->device.size = 0x1000;\n\n    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;\n\n\n\n    proxy->notify.offset = 0x3000;\n\n    proxy->notify.size =\n\n        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;\n\n    proxy->notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    proxy->notify_pio.offset = 0x0;\n\n    proxy->notify_pio.size = 0x4;\n\n    proxy->notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    /* subclasses can enforce modern, so do this unconditionally */\n\n    memory_region_init(&proxy->modern_bar, OBJECT(proxy), \"virtio-pci\",\n\n                       2 * QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *\n\n                       VIRTIO_QUEUE_MAX);\n\n\n\n    memory_region_init_alias(&proxy->modern_cfg,\n\n                             OBJECT(proxy),\n\n                             \"virtio-pci-cfg\",\n\n                             &proxy->modern_bar,\n\n                             0,\n\n                             memory_region_size(&proxy->modern_bar));\n\n\n\n    address_space_init(&proxy->modern_as, &proxy->modern_cfg, \"virtio-pci-cfg-as\");\n\n\n\n    if (!(proxy->flags & VIRTIO_PCI_FLAG_DISABLE_PCIE)\n\n        && !(proxy->flags & VIRTIO_PCI_FLAG_DISABLE_MODERN)\n\n        && pci_bus_is_express(pci_dev->bus)\n\n        && !pci_bus_is_root(pci_dev->bus)) {\n\n        int pos;\n\n\n\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n\n        pos = pcie_endpoint_cap_init(pci_dev, 0);\n\n        assert(pos > 0);\n\n\n\n        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);\n\n        assert(pos > 0);\n\n\n\n        /*\n\n         * Indicates that this function complies with revision 1.2 of the\n\n         * PCI Power Management Interface Specification.\n\n         */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_PMC, 0x3);\n\n    }\n\n\n\n    virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);\n\n    if (k->realize) {\n\n        k->realize(proxy, errp);\n\n    }\n\n}\n", "idx": 3904}
{"project": "qemu", "commit_id": "07d4e69147b4957e617812206a62a86f03294ad3", "target": 1, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n    int ret = 0;\n\n\n\n    trace_vmstate_load_state(vmsd->name, version_id);\n\n    if (version_id > vmsd->version_id) {\n\n        error_report(\"%s: incoming version_id %d is too new \"\n\n                     \"for local version_id %d\",\n\n                     vmsd->name, version_id, vmsd->version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too new\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        if (vmsd->load_state_old &&\n\n            version_id >= vmsd->minimum_version_id_old) {\n\n            ret = vmsd->load_state_old(f, opaque, version_id);\n\n            trace_vmstate_load_state_end(vmsd->name, \"old path\", ret);\n\n            return ret;\n\n        }\n\n        error_report(\"%s: incoming version_id %d is too old \"\n\n                     \"for local minimum version_id  %d\",\n\n                     vmsd->name, version_id, vmsd->minimum_version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too old\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if (vmsd->pre_load) {\n\n        int ret = vmsd->pre_load(opaque);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n    while (field->name) {\n\n        trace_vmstate_load_state_field(vmsd->name, field->name);\n\n        if ((field->field_exists &&\n\n             field->field_exists(opaque, version_id)) ||\n\n            (!field->field_exists &&\n\n             field->version_id <= version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            vmstate_handle_alloc(first_elem, field, opaque);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n\n                                             field->vmsd->version_id);\n\n                } else {\n\n                    ret = field->info->get(f, curr_elem, size, field);\n\n                }\n\n                if (ret >= 0) {\n\n                    ret = qemu_file_get_error(f);\n\n                }\n\n                if (ret < 0) {\n\n                    qemu_file_set_error(f, ret);\n\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n\n                                 field->name);\n\n                    trace_vmstate_load_field_error(field->name, ret);\n\n                    return ret;\n\n                }\n\n            }\n\n        } else if (field->flags & VMS_MUST_EXIST) {\n\n            error_report(\"Input validation failed: %s/%s\",\n\n                         vmsd->name, field->name);\n\n            return -1;\n\n        }\n\n        field++;\n\n    }\n\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n    if (vmsd->post_load) {\n\n        ret = vmsd->post_load(opaque, version_id);\n\n    }\n\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n\n    return ret;\n\n}\n", "idx": 2318}
{"project": "qemu", "commit_id": "b53ccc30c40df52d192e469a86c188a8649c6df3", "target": 1, "func": "void qmp_dump_guest_memory(bool paging, const char *file, bool has_begin,\n\n                           int64_t begin, bool has_length, int64_t length,\n\n                           Error **errp)\n\n{\n\n    const char *p;\n\n    int fd = -1;\n\n    DumpState *s;\n\n    int ret;\n\n\n\n    if (has_begin && !has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"length\");\n\n        return;\n\n    }\n\n    if (!has_begin && has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"begin\");\n\n        return;\n\n    }\n\n\n\n#if !defined(WIN32)\n\n    if (strstart(file, \"fd:\", &p)) {\n\n        fd = monitor_get_fd(cur_mon, p, errp);\n\n        if (fd == -1) {\n\n            return;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if  (strstart(file, \"file:\", &p)) {\n\n        fd = qemu_open(p, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR);\n\n        if (fd < 0) {\n\n            error_setg_file_open(errp, errno, p);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"protocol\");\n\n        return;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(DumpState));\n\n\n\n    ret = dump_init(s, fd, paging, has_begin, begin, length, errp);\n\n    if (ret < 0) {\n\n        g_free(s);\n\n        return;\n\n    }\n\n\n\n    if (create_vmcore(s) < 0 && !error_is_set(s->errp)) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n    g_free(s);\n\n}\n", "idx": 455}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void musicpal_init(ram_addr_t ram_size,\n\n               const char *boot_device,\n\n               const char *kernel_filename, const char *kernel_cmdline,\n\n               const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *cpu_pic;\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    DeviceState *i2c_dev;\n\n    DeviceState *lcd_dev;\n\n    DeviceState *key_dev;\n\n#ifdef HAS_AUDIO\n\n    DeviceState *wm8750_dev;\n\n    SysBusDevice *s;\n\n#endif\n\n    i2c_bus *i2c;\n\n    int i;\n\n    unsigned long flash_size;\n\n    DriveInfo *dinfo;\n\n    ram_addr_t sram_off;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n\n\n    /* For now we use a fixed - the original - RAM size */\n\n    cpu_register_physical_memory(0, MP_RAM_DEFAULT_SIZE,\n\n                                 qemu_ram_alloc(MP_RAM_DEFAULT_SIZE));\n\n\n\n    sram_off = qemu_ram_alloc(MP_SRAM_SIZE);\n\n    cpu_register_physical_memory(MP_SRAM_BASE, MP_SRAM_SIZE, sram_off);\n\n\n\n    dev = sysbus_create_simple(\"mv88w8618_pic\", MP_PIC_BASE,\n\n                               cpu_pic[ARM_PIC_CPU_IRQ]);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_varargs(\"mv88w8618_pit\", MP_PIT_BASE, pic[MP_TIMER1_IRQ],\n\n                          pic[MP_TIMER2_IRQ], pic[MP_TIMER3_IRQ],\n\n                          pic[MP_TIMER4_IRQ], NULL);\n\n\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(MP_UART1_BASE, 2, pic[MP_UART1_IRQ], 1825000,\n\n                   serial_hds[0], 1);\n\n    }\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(MP_UART2_BASE, 2, pic[MP_UART2_IRQ], 1825000,\n\n                   serial_hds[1], 1);\n\n    }\n\n\n\n    /* Register flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (dinfo) {\n\n        flash_size = bdrv_getlength(dinfo->bdrv);\n\n        if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n\n            flash_size != 32*1024*1024) {\n\n            fprintf(stderr, \"Invalid flash image size\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /*\n\n         * The original U-Boot accesses the flash at 0xFE000000 instead of\n\n         * 0xFF800000 (if there is 8 MB flash). So remap flash access if the\n\n         * image is smaller than 32 MB.\n\n         */\n\n        pflash_cfi02_register(0-MP_FLASH_SIZE_MAX, qemu_ram_alloc(flash_size),\n\n                              dinfo->bdrv, 0x10000,\n\n                              (flash_size + 0xffff) >> 16,\n\n                              MP_FLASH_SIZE_MAX / flash_size,\n\n                              2, 0x00BF, 0x236D, 0x0000, 0x0000,\n\n                              0x5555, 0x2AAA);\n\n    }\n\n    sysbus_create_simple(\"mv88w8618_flashcfg\", MP_FLASHCFG_BASE, NULL);\n\n\n\n    qemu_check_nic_model(&nd_table[0], \"mv88w8618\");\n\n    dev = qdev_create(NULL, \"mv88w8618_eth\");\n\n    dev->nd = &nd_table[0];\n\n    qdev_init(dev);\n\n    sysbus_mmio_map(sysbus_from_qdev(dev), 0, MP_ETH_BASE);\n\n    sysbus_connect_irq(sysbus_from_qdev(dev), 0, pic[MP_ETH_IRQ]);\n\n\n\n    sysbus_create_simple(\"mv88w8618_wlan\", MP_WLAN_BASE, NULL);\n\n\n\n    musicpal_misc_init();\n\n\n\n    dev = sysbus_create_simple(\"musicpal_gpio\", MP_GPIO_BASE, pic[MP_GPIO_IRQ]);\n\n    i2c_dev = sysbus_create_simple(\"bitbang_i2c\", 0, NULL);\n\n    i2c = (i2c_bus *)qdev_get_child_bus(i2c_dev, \"i2c\");\n\n\n\n    lcd_dev = sysbus_create_simple(\"musicpal_lcd\", MP_LCD_BASE, NULL);\n\n    key_dev = sysbus_create_simple(\"musicpal_key\", 0, NULL);\n\n\n\n    /* I2C read data */\n\n    qdev_connect_gpio_out(i2c_dev, 0,\n\n                          qdev_get_gpio_in(dev, MP_GPIO_I2C_DATA_BIT));\n\n    /* I2C data */\n\n    qdev_connect_gpio_out(dev, 3, qdev_get_gpio_in(i2c_dev, 0));\n\n    /* I2C clock */\n\n    qdev_connect_gpio_out(dev, 4, qdev_get_gpio_in(i2c_dev, 1));\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        qdev_connect_gpio_out(dev, i, qdev_get_gpio_in(lcd_dev, i));\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        qdev_connect_gpio_out(key_dev, i, qdev_get_gpio_in(dev, i + 8));\n\n    }\n\n    for (i = 4; i < 8; i++) {\n\n        qdev_connect_gpio_out(key_dev, i, qdev_get_gpio_in(dev, i + 15));\n\n    }\n\n\n\n#ifdef HAS_AUDIO\n\n    wm8750_dev = i2c_create_slave(i2c, \"wm8750\", MP_WM_ADDR);\n\n    dev = qdev_create(NULL, \"mv88w8618_audio\");\n\n    s = sysbus_from_qdev(dev);\n\n    qdev_prop_set_ptr(dev, \"wm8750\", wm8750_dev);\n\n    qdev_init(dev);\n\n    sysbus_mmio_map(s, 0, MP_AUDIO_BASE);\n\n    sysbus_connect_irq(s, 0, pic[MP_AUDIO_IRQ]);\n\n#endif\n\n\n\n    musicpal_binfo.ram_size = MP_RAM_DEFAULT_SIZE;\n\n    musicpal_binfo.kernel_filename = kernel_filename;\n\n    musicpal_binfo.kernel_cmdline = kernel_cmdline;\n\n    musicpal_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &musicpal_binfo);\n\n}\n", "idx": 6048}
{"project": "qemu", "commit_id": "34e1c27bc3094ffe484d9855e07ad104bddf579f", "target": 1, "func": "uint32 float32_to_uint32( float32 a STATUS_PARAM )\n\n{\n\n    int64_t v;\n\n    uint32 res;\n\n\n\n    v = float32_to_int64(a STATUS_VAR);\n\n    if (v < 0) {\n\n        res = 0;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else if (v > 0xffffffff) {\n\n        res = 0xffffffff;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else {\n\n        res = v;\n\n    }\n\n    return res;\n\n}\n", "idx": 7624}
{"project": "qemu", "commit_id": "3c0c47e3464f3c54bd3f1cc6d4da2cbf7465e295", "target": 1, "func": "static void spapr_machine_device_unplug(HotplugHandler *hotplug_dev,\n\n                                      DeviceState *dev, Error **errp)\n\n{\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(qdev_get_machine());\n\n\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM)) {\n\n        error_setg(errp, \"Memory hot unplug not supported by sPAPR\");\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_SPAPR_CPU_CORE)) {\n\n        if (!smc->dr_cpu_enabled) {\n\n            error_setg(errp, \"CPU hot unplug not supported on this machine\");\n\n            return;\n\n        }\n\n        spapr_core_unplug(hotplug_dev, dev, errp);\n\n    }\n\n}\n", "idx": 1397}
{"project": "qemu", "commit_id": "f24582d6ad8a080e008974c000bf0ae635d036ac", "target": 1, "func": "void qmp_output_visitor_cleanup(QmpOutputVisitor *v)\n\n{\n\n    QStackEntry *e, *tmp;\n\n\n\n    QTAILQ_FOREACH_SAFE(e, &v->stack, node, tmp) {\n\n        QTAILQ_REMOVE(&v->stack, e, node);\n\n        if (e->value) {\n\n            qobject_decref(e->value);\n\n        }\n\n        g_free(e);\n\n    }\n\n\n\n    g_free(v);\n\n}\n", "idx": 650}
{"project": "qemu", "commit_id": "79482e5ab38a05ca8869040b0d8b8f451f16ff62", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, bool add_ca, bool compute_ca,\n\n                                    bool compute_ov, bool compute_rc0)\n\n{\n\n    TCGv t0 = ret;\n\n\n\n    if (((compute_ca && add_ca) || compute_ov)\n\n        && (TCGV_EQUAL(ret, arg1) || TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = tcg_temp_new();\n\n    }\n\n\n\n    if (compute_ca) {\n\n        TCGv zero = tcg_const_tl(0);\n\n        if (add_ca) {\n\n            tcg_gen_add2_tl(t0, cpu_ca, arg1, zero, cpu_ca, zero);\n\n            tcg_gen_add2_tl(t0, cpu_ca, t0, cpu_ca, arg2, zero);\n\n        } else {\n\n            tcg_gen_add2_tl(t0, cpu_ca, arg1, zero, arg2, zero);\n\n        }\n\n        tcg_temp_free(zero);\n\n    } else {\n\n        tcg_gen_add_tl(t0, arg1, arg2);\n\n        if (add_ca) {\n\n            tcg_gen_add_tl(t0, t0, cpu_ca);\n\n        }\n\n    }\n\n\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n    if (unlikely(compute_rc0)) {\n\n        gen_set_Rc0(ctx, t0);\n\n    }\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 7245}
{"project": "qemu", "commit_id": "bb16172c52ac18742f3df156912c169904e92147", "target": 1, "func": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}", "idx": 9300}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n", "idx": 261}
{"project": "qemu", "commit_id": "b307446e04232b3a87e9da04886895a8e5a4a407", "target": 1, "func": "void mips_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                         int flags)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx\n\n                \" LO=0x\" TARGET_FMT_lx \" ds %04x \"\n\n                TARGET_FMT_lx \" \" TARGET_FMT_ld \"\\n\",\n\n                env->active_tc.PC, env->active_tc.HI[0], env->active_tc.LO[0],\n\n                env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->active_tc.gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x%016\"\n\n                PRIx64 \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->lladdr);\n\n    cpu_fprintf(f, \"    Config2 0x%08x Config3 0x%08x\\n\",\n\n                env->CP0_Config2, env->CP0_Config3);\n\n    cpu_fprintf(f, \"    Config4 0x%08x Config5 0x%08x\\n\",\n\n                env->CP0_Config4, env->CP0_Config5);\n\n    if (env->hflags & MIPS_HFLAG_FPU)\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 5351}
{"project": "qemu", "commit_id": "e8d3b1a25f284cdf9705b7cf0412281cc9ee3a36", "target": 1, "func": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    if (bh->scheduled)\n\n        return;\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* Make sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    smp_mb();\n\n    bh->scheduled = 1;\n\n    aio_notify(ctx);\n\n}\n", "idx": 1433}
{"project": "qemu", "commit_id": "def74c0cf05722b2e502d4b4f1219966c5b0cbd3", "target": 1, "func": "int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,\n\n                              int mmu_idx)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    hwaddr physical;\n\n    int prot;\n\n    int access_type;\n\n#endif\n\n    int ret = 0;\n\n\n\n#if 0\n\n    log_cpu_state(cs, 0);\n\n#endif\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n              \"%s pc \" TARGET_FMT_lx \" ad %\" VADDR_PRIx \" rw %d mmu_idx %d\\n\",\n\n              __func__, env->active_tc.PC, address, rw, mmu_idx);\n\n\n\n    /* data access */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* XXX: put correct access by using cpu_restore_state()\n\n       correctly */\n\n    access_type = ACCESS_INT;\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n             \"%s address=%\" VADDR_PRIx \" ret %d physical \" TARGET_FMT_plx\n\n             \" prot %d\\n\",\n\n             __func__, address, ret, physical, prot);\n\n    if (ret == TLBRET_MATCH) {\n\n        tlb_set_page(cs, address & TARGET_PAGE_MASK,\n\n                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0)\n\n#endif\n\n    {\n\n        raise_mmu_exception(env, address, rw, ret);\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2007}
{"project": "qemu", "commit_id": "302fa283789a2f9b1199c327047cfad2258a23a2", "target": 1, "func": "const char *memory_region_name(const MemoryRegion *mr)\n\n{\n\n    return object_get_canonical_path_component(OBJECT(mr));\n\n}\n", "idx": 9685}
{"project": "qemu", "commit_id": "ae392c416c69a020226c768d9c3af08b29dd6d96", "target": 1, "func": "static void msix_mmio_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    PCIDevice *dev = opaque;\n\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;\n\n    int vector = offset / PCI_MSIX_ENTRY_SIZE;\n\n\n\n    /* MSI-X page includes a read-only PBA and a writeable Vector Control. */\n\n    if (vector >= dev->msix_entries_nr) {\n\n        return;\n\n    }\n\n\n\n    pci_set_long(dev->msix_table_page + offset, val);\n\n    msix_handle_mask_update(dev, vector);\n\n}\n", "idx": 2201}
{"project": "qemu", "commit_id": "3b39d734141a71296d08af3d4c32f872fafd782e", "target": 1, "func": "static uint32_t arm_ldl_ptw(CPUState *cs, hwaddr addr, bool is_secure,\n\n                            ARMMMUIdx mmu_idx, ARMMMUFaultInfo *fi)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    MemTxAttrs attrs = {};\n\n    AddressSpace *as;\n\n\n\n    attrs.secure = is_secure;\n\n    as = arm_addressspace(cs, attrs);\n\n    addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fi);\n\n    if (fi->s1ptw) {\n\n        return 0;\n\n    }\n\n    if (regime_translation_big_endian(env, mmu_idx)) {\n\n        return address_space_ldl_be(as, addr, attrs, NULL);\n\n    } else {\n\n        return address_space_ldl_le(as, addr, attrs, NULL);\n\n    }\n\n}\n", "idx": 11844}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void send_ext_key_event_ack(VncState *vs)\n\n{\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n    vnc_write_u8(vs, 0);\n\n    vnc_write_u16(vs, 1);\n\n    vnc_framebuffer_update(vs, 0, 0,\n\n                           surface_width(vs->vd->ds),\n\n                           surface_height(vs->vd->ds),\n\n                           VNC_ENCODING_EXT_KEY_EVENT);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 917}
{"project": "qemu", "commit_id": "0c544d73bbb4c8612b7754a8e1c8b0c8af1617ff", "target": 1, "func": "static void *nbd_client_thread(void *arg)\n\n{\n\n    char *device = arg;\n\n    off_t size;\n\n    size_t blocksize;\n\n    uint32_t nbdflags;\n\n    int fd, sock;\n\n    int ret;\n\n    pthread_t show_parts_thread;\n\n\n\n    sock = unix_socket_outgoing(sockpath);\n\n    if (sock < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = nbd_receive_negotiate(sock, NULL, &nbdflags,\n\n                                &size, &blocksize);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    fd = open(device, O_RDWR);\n\n    if (fd < 0) {\n\n        /* Linux-only, we can use %m in printf.  */\n\n        fprintf(stderr, \"Failed to open %s: %m\", device);\n\n        goto out;\n\n    }\n\n\n\n    ret = nbd_init(fd, sock, nbdflags, size, blocksize);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* update partition table */\n\n    pthread_create(&show_parts_thread, NULL, show_parts, device);\n\n\n\n    if (verbose) {\n\n        fprintf(stderr, \"NBD device %s is now connected to %s\\n\",\n\n                device, srcpath);\n\n    } else {\n\n        /* Close stderr so that the qemu-nbd process exits.  */\n\n        dup2(STDOUT_FILENO, STDERR_FILENO);\n\n    }\n\n\n\n    ret = nbd_client(fd);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n    close(fd);\n\n    kill(getpid(), SIGTERM);\n\n    return (void *) EXIT_SUCCESS;\n\n\n\nout:\n\n    kill(getpid(), SIGTERM);\n\n    return (void *) EXIT_FAILURE;\n\n}\n", "idx": 8203}
{"project": "qemu", "commit_id": "3d90c6254863693a6b13d918d2b8682e08bbc681", "target": 1, "func": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, bwidth, bits;\n\n    ram_addr_t page0, page1;\n\n    DirtyBitmapSnapshot *snap = NULL;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line = NULL;\n\n    bool share_surface;\n\n    pixman_format_code_t format;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    bool byteswap = !s->big_endian_fb;\n\n#else\n\n    bool byteswap = s->big_endian_fb;\n\n#endif\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n\n            - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    } else if (shift_control == 1) {\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    }\n\n\n\n    depth = s->get_bpp(s);\n\n\n\n    /*\n\n     * Check whether we can share the surface with the backend\n\n     * or whether we need a shadow surface. We share native\n\n     * endian surfaces for 15bpp and above and byteswapped\n\n     * surfaces for 24bpp and above.\n\n     */\n\n    format = qemu_default_pixman_format(depth, !byteswap);\n\n    if (format) {\n\n        share_surface = dpy_gfx_check_format(s->con, format)\n\n            && !s->force_shadow;\n\n    } else {\n\n        share_surface = false;\n\n    }\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth ||\n\n        s->last_byteswap != byteswap ||\n\n        share_surface != is_buffer_shared(surface)) {\n\n        if (share_surface) {\n\n            surface = qemu_create_displaysurface_from(disp_width,\n\n                    height, format, s->line_offset,\n\n                    s->vram_ptr + (s->start_addr * 4));\n\n            dpy_gfx_replace_surface(s->con, surface);\n\n        } else {\n\n            qemu_console_resize(s->con, disp_width, height);\n\n            surface = qemu_console_surface(s->con);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        s->last_byteswap = byteswap;\n\n        full_update = 1;\n\n    } else if (is_buffer_shared(surface) &&\n\n               (full_update || surface_data(surface) != s->vram_ptr\n\n                + (s->start_addr * 4))) {\n\n        pixman_format_code_t format =\n\n            qemu_default_pixman_format(depth, !byteswap);\n\n        surface = qemu_create_displaysurface_from(disp_width,\n\n                height, format, s->line_offset,\n\n                s->vram_ptr + (s->start_addr * 4));\n\n        dpy_gfx_replace_surface(s->con, surface);\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE15_BE : VGA_DRAW_LINE15_LE;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE16_BE : VGA_DRAW_LINE16_LE;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE24_BE : VGA_DRAW_LINE24_LE;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE32_BE : VGA_DRAW_LINE32_LE;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v];\n\n\n\n    if (!is_buffer_shared(surface) && s->cursor_invalidate) {\n\n        s->cursor_invalidate(s);\n\n    }\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n\n           s->line_compare, sr(s, VGA_SEQ_CLOCK_MODE));\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = DIV_ROUND_UP(width * bits, 8);\n\n    y_start = -1;\n\n    d = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    y1 = 0;\n\n\n\n    if (!full_update) {\n\n        ram_addr_t region_start = addr1;\n\n        ram_addr_t region_end = addr1 + line_offset * height;\n\n        vga_sync_dirty_bitmap(s);\n\n        if (s->line_compare < height) {\n\n            /* split screen mode */\n\n            region_start = 0;\n\n        }\n\n        snap = memory_region_snapshot_and_clear_dirty(&s->vram, region_start,\n\n                                                      region_end - region_start,\n\n                                                      DIRTY_MEMORY_VGA);\n\n    }\n\n\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        update = full_update;\n\n        page0 = addr;\n\n        page1 = addr + bwidth - 1;\n\n        if (full_update) {\n\n            update = 1;\n\n        } else {\n\n            update = memory_region_snapshot_get_dirty(&s->vram, snap,\n\n                                                      page0, page1 - page0);\n\n        }\n\n        /* explicit invalidation for the hardware cursor (cirrus only) */\n\n        update |= vga_scanline_invalidated(s, y);\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (!(is_buffer_shared(surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_gfx_update(s->con, 0, y_start,\n\n                               disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_gfx_update(s->con, 0, y_start,\n\n                       disp_width, y - y_start);\n\n    }\n\n    g_free(snap);\n\n    memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));\n\n}\n", "idx": 3977}
{"project": "qemu", "commit_id": "3494d650273e619606c6cb2c38aa9b8b7bed98e2", "target": 1, "func": "static int curl_open(BlockDriverState *bs, QDict *options, int flags)\n\n{\n\n    BDRVCURLState *s = bs->opaque;\n\n    CURLState *state = NULL;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *file;\n\n    double d;\n\n\n\n    static int inited = 0;\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"curl block device does not support writes\");\n\n        return -EROFS;\n\n    }\n\n\n\n    opts = qemu_opts_create_nofail(&runtime_opts);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out_noclean;\n\n    }\n\n\n\n    s->readahead_size = qemu_opt_get_size(opts, \"readahead\", READ_AHEAD_SIZE);\n\n    if ((s->readahead_size & 0x1ff) != 0) {\n\n        fprintf(stderr, \"HTTP_READAHEAD_SIZE %zd is not a multiple of 512\\n\",\n\n                s->readahead_size);\n\n        goto out_noclean;\n\n    }\n\n\n\n    file = qemu_opt_get(opts, \"url\");\n\n    if (file == NULL) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR, \"curl block driver requires \"\n\n                      \"an 'url' option\");\n\n        goto out_noclean;\n\n    }\n\n\n\n    if (!inited) {\n\n        curl_global_init(CURL_GLOBAL_ALL);\n\n        inited = 1;\n\n    }\n\n\n\n    DPRINTF(\"CURL: Opening %s\\n\", file);\n\n    s->url = g_strdup(file);\n\n    state = curl_init_state(s);\n\n    if (!state)\n\n        goto out_noclean;\n\n\n\n    // Get file size\n\n\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_size_cb);\n\n    if (curl_easy_perform(state->curl))\n\n        goto out;\n\n    curl_easy_getinfo(state->curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d);\n\n    if (d)\n\n        s->len = (size_t)d;\n\n    else if(!s->len)\n\n        goto out;\n\n    DPRINTF(\"CURL: Size = %zd\\n\", s->len);\n\n\n\n    curl_clean_state(state);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\n\n\n    // Now we know the file exists and its size, so let's\n\n    // initialize the multi interface!\n\n\n\n    s->multi = curl_multi_init();\n\n    curl_multi_setopt(s->multi, CURLMOPT_SOCKETDATA, s);\n\n    curl_multi_setopt(s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb);\n\n    curl_multi_do(s);\n\n\n\n    qemu_opts_del(opts);\n\n    return 0;\n\n\n\nout:\n\n    fprintf(stderr, \"CURL: Error opening file: %s\\n\", state->errmsg);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\nout_noclean:\n\n    g_free(s->url);\n\n    qemu_opts_del(opts);\n\n    return -EINVAL;\n\n}\n", "idx": 5724}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "func": "int net_slirp_parse_legacy(QemuOptsList *opts_list, const char *optarg, int *ret)\n\n{\n\n    if (strcmp(opts_list->name, \"net\") != 0 ||\n\n        strncmp(optarg, \"channel,\", strlen(\"channel,\")) != 0) {\n\n        return 0;\n\n    }\n\n\n\n    error_report(\"The '-net channel' option is deprecated. \"\n\n                 \"Please use '-netdev user,guestfwd=...' instead.\");\n\n\n\n    /* handle legacy -net channel,port:chr */\n\n    optarg += strlen(\"channel,\");\n\n\n\n    if (QTAILQ_EMPTY(&slirp_stacks)) {\n\n        struct slirp_config_str *config;\n\n\n\n        config = g_malloc(sizeof(*config));\n\n        pstrcpy(config->str, sizeof(config->str), optarg);\n\n        config->flags = SLIRP_CFG_LEGACY;\n\n        config->next = slirp_configs;\n\n        slirp_configs = config;\n\n        *ret = 0;\n\n    } else {\n\n        *ret = slirp_guestfwd(QTAILQ_FIRST(&slirp_stacks), optarg, 1);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 3527}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "bool desc_ring_set_size(DescRing *ring, uint32_t size)\n\n{\n\n    int i;\n\n\n\n    if (size < 2 || size > 0x10000 || (size & (size - 1))) {\n\n        DPRINTF(\"ERROR: ring[%d] size (%d) not a power of 2 \"\n\n                \"or in range [2, 64K]\\n\", ring->index, size);\n\n        return false;\n\n    }\n\n\n\n    for (i = 0; i < ring->size; i++) {\n\n        g_free(ring->info[i].buf);\n\n    }\n\n\n\n    ring->size = size;\n\n    ring->head = ring->tail = 0;\n\n\n\n    ring->info = g_realloc(ring->info, size * sizeof(DescInfo));\n\n    if (!ring->info) {\n\n        return false;\n\n    }\n\n\n\n    memset(ring->info, 0, size * sizeof(DescInfo));\n\n\n\n    for (i = 0; i < size; i++) {\n\n        ring->info[i].ring = ring;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 8222}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void test_in_coroutine(void)\n\n{\n\n    Coroutine *coroutine;\n\n\n\n    g_assert(!qemu_in_coroutine());\n\n\n\n    coroutine = qemu_coroutine_create(verify_in_coroutine);\n\n    qemu_coroutine_enter(coroutine, NULL);\n\n}\n", "idx": 9701}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "void ppc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    int i;\n\n\n\n    for (i = 0; ; i++) {\n\n        (*cpu_fprintf)(f, \"PowerPC %-16s PVR %08x\\n\",\n\n                       ppc_defs[i].name, ppc_defs[i].pvr);\n\n        if (strcmp(ppc_defs[i].name, \"default\") == 0)\n\n            break;\n\n    }\n\n}\n", "idx": 2570}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "void bdrv_set_dirty_tracking(BlockDriverState *bs, int enable)\n\n{\n\n    int64_t bitmap_size;\n\n\n\n    if (enable) {\n\n        if (bs->dirty_tracking == 0) {\n\n            int64_t i;\n\n            uint8_t test;\n\n\n\n            bitmap_size = (bdrv_getlength(bs) >> BDRV_SECTOR_BITS);\n\n            bitmap_size /= BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n            bitmap_size++;\n\n\n\n            bs->dirty_bitmap = qemu_mallocz(bitmap_size);\n\n\n\n            bs->dirty_tracking = enable;\n\n            for(i = 0; i < bitmap_size; i++) test = bs->dirty_bitmap[i]; \n\n        }\n\n    } else {\n\n        if (bs->dirty_tracking != 0) {\n\n            qemu_free(bs->dirty_bitmap);\n\n            bs->dirty_tracking = enable;\n\n        }\n\n    }\n\n}\n", "idx": 10275}
{"project": "qemu", "commit_id": "5b185639c5740998de403415c749ac98e13418fd", "target": 1, "func": "void HELPER(cksm)(uint32_t r1, uint32_t r2)\n\n{\n\n    uint64_t src = get_address_31fix(r2);\n\n    uint64_t src_len = env->regs[(r2 + 1) & 15];\n\n    uint64_t cksm = 0;\n\n\n\n    while (src_len >= 4) {\n\n        cksm += ldl(src);\n\n        cksm = cksm_overflow(cksm);\n\n\n\n        /* move to next word */\n\n        src_len -= 4;\n\n        src += 4;\n\n    }\n\n\n\n    switch (src_len) {\n\n    case 0:\n\n        break;\n\n    case 1:\n\n        cksm += ldub(src);\n\n        cksm = cksm_overflow(cksm);\n\n        break;\n\n    case 2:\n\n        cksm += lduw(src);\n\n        cksm = cksm_overflow(cksm);\n\n        break;\n\n    case 3:\n\n        /* XXX check if this really is correct */\n\n        cksm += lduw(src) << 8;\n\n        cksm += ldub(src + 2);\n\n        cksm = cksm_overflow(cksm);\n\n        break;\n\n    }\n\n\n\n    /* indicate we've processed everything */\n\n    env->regs[(r2 + 1) & 15] = 0;\n\n\n\n    /* store result */\n\n    env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) | (uint32_t)cksm;\n\n}\n", "idx": 10035}
{"project": "qemu", "commit_id": "ca96ac44dcd290566090b2435bc828fded356ad9", "target": 1, "func": "static void aio_rfifolock_cb(void *opaque)\n\n{\n\n    /* Kick owner thread in case they are blocked in aio_poll() */\n\n    aio_notify(opaque);\n\n}\n", "idx": 4907}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "void ppc_store_sdr1(CPUPPCState *env, target_ulong value)\n\n{\n\n    LOG_MMU(\"%s: \" TARGET_FMT_lx \"\\n\", __func__, value);\n\n    if (env->spr[SPR_SDR1] != value) {\n\n        env->spr[SPR_SDR1] = value;\n\n#if defined(TARGET_PPC64)\n\n        if (env->mmu_model & POWERPC_MMU_64) {\n\n            target_ulong htabsize = value & SDR_64_HTABSIZE;\n\n\n\n            if (htabsize > 28) {\n\n                fprintf(stderr, \"Invalid HTABSIZE 0x\" TARGET_FMT_lx\n\n                        \" stored in SDR1\\n\", htabsize);\n\n                htabsize = 28;\n\n            }\n\n            env->htab_mask = (1ULL << (htabsize + 18)) - 1;\n\n            env->htab_base = value & SDR_64_HTABORG;\n\n        } else\n\n#endif /* defined(TARGET_PPC64) */\n\n        {\n\n            /* FIXME: Should check for valid HTABMASK values */\n\n            env->htab_mask = ((value & SDR_32_HTABMASK) << 16) | 0xFFFF;\n\n            env->htab_base = value & SDR_32_HTABORG;\n\n        }\n\n        tlb_flush(env, 1);\n\n    }\n\n}\n", "idx": 5837}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpsr(CPUSPARCState *env, target_ulong new_psr)\n\n{\n\n    if ((new_psr & PSR_CWP) >= env->nwindows) {\n\n        cpu_raise_exception_ra(env, TT_ILL_INSN, GETPC());\n\n    } else {\n\n\n\n        cpu_put_psr(env, new_psr);\n\n\n    }\n\n}", "idx": 10483}
{"project": "qemu", "commit_id": "e7d81004e486b0e80a674d164d8aec0e83fa812f", "target": 1, "func": "gdb_handlesig (CPUState *env, int sig)\n\n{\n\n  GDBState *s;\n\n  char buf[256];\n\n  int n;\n\n\n\n  s = gdbserver_state;\n\n  if (gdbserver_fd < 0 || s->fd < 0)\n\n    return sig;\n\n\n\n  /* disable single step if it was enabled */\n\n  cpu_single_step(env, 0);\n\n  tb_flush(env);\n\n\n\n  if (sig != 0)\n\n    {\n\n      snprintf(buf, sizeof(buf), \"S%02x\", target_signal_to_gdb (sig));\n\n      put_packet(s, buf);\n\n    }\n\n  /* put_packet() might have detected that the peer terminated the \n\n     connection.  */\n\n  if (s->fd < 0)\n\n      return sig;\n\n\n\n  sig = 0;\n\n  s->state = RS_IDLE;\n\n  s->running_state = 0;\n\n  while (s->running_state == 0) {\n\n      n = read (s->fd, buf, 256);\n\n      if (n > 0)\n\n        {\n\n          int i;\n\n\n\n          for (i = 0; i < n; i++)\n\n            gdb_read_byte (s, buf[i]);\n\n        }\n\n      else if (n == 0 || errno != EAGAIN)\n\n        {\n\n          /* XXX: Connection closed.  Should probably wait for annother\n\n             connection before continuing.  */\n\n          return sig;\n\n        }\n\n  }\n\n  sig = s->signal;\n\n  s->signal = 0;\n\n  return sig;\n\n}\n", "idx": 5814}
{"project": "qemu", "commit_id": "b3af1bc9d21e6bec7dfd283d91b465c9f815b6d6", "target": 1, "func": "int qemu_loadvm_state(QEMUFile *f)\n\n{\n\n    QLIST_HEAD(, LoadStateEntry) loadvm_handlers =\n\n        QLIST_HEAD_INITIALIZER(loadvm_handlers);\n\n    LoadStateEntry *le, *new_le;\n\n    Error *local_err = NULL;\n\n    uint8_t section_type;\n\n    unsigned int v;\n\n    int ret;\n\n    int file_error_after_eof = -1;\n\n\n\n    if (qemu_savevm_state_blocked(&local_err)) {\n\n        error_report_err(local_err);\n\n        return -EINVAL;\n\n    }\n\n\n\n    v = qemu_get_be32(f);\n\n    if (v != QEMU_VM_FILE_MAGIC) {\n\n        error_report(\"Not a migration stream\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    v = qemu_get_be32(f);\n\n    if (v == QEMU_VM_FILE_VERSION_COMPAT) {\n\n        error_report(\"SaveVM v2 format is obsolete and don't work anymore\");\n\n        return -ENOTSUP;\n\n    }\n\n    if (v != QEMU_VM_FILE_VERSION) {\n\n        error_report(\"Unsupported migration stream version\");\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    while ((section_type = qemu_get_byte(f)) != QEMU_VM_EOF) {\n\n        uint32_t instance_id, version_id, section_id;\n\n        SaveStateEntry *se;\n\n        char idstr[257];\n\n        int len;\n\n\n\n        trace_qemu_loadvm_state_section(section_type);\n\n        switch (section_type) {\n\n        case QEMU_VM_SECTION_START:\n\n        case QEMU_VM_SECTION_FULL:\n\n            /* Read section start */\n\n            section_id = qemu_get_be32(f);\n\n            len = qemu_get_byte(f);\n\n            qemu_get_buffer(f, (uint8_t *)idstr, len);\n\n            idstr[len] = 0;\n\n            instance_id = qemu_get_be32(f);\n\n            version_id = qemu_get_be32(f);\n\n\n\n            trace_qemu_loadvm_state_section_startfull(section_id, idstr,\n\n                                                      instance_id, version_id);\n\n            /* Find savevm section */\n\n            se = find_se(idstr, instance_id);\n\n            if (se == NULL) {\n\n                error_report(\"Unknown savevm section or instance '%s' %d\",\n\n                             idstr, instance_id);\n\n                ret = -EINVAL;\n\n                goto out;\n\n            }\n\n\n\n            /* Validate version */\n\n            if (version_id > se->version_id) {\n\n                error_report(\"savevm: unsupported version %d for '%s' v%d\",\n\n                             version_id, idstr, se->version_id);\n\n                ret = -EINVAL;\n\n                goto out;\n\n            }\n\n\n\n            /* Add entry */\n\n            le = g_malloc0(sizeof(*le));\n\n\n\n            le->se = se;\n\n            le->section_id = section_id;\n\n            le->version_id = version_id;\n\n            QLIST_INSERT_HEAD(&loadvm_handlers, le, entry);\n\n\n\n            ret = vmstate_load(f, le->se, le->version_id);\n\n            if (ret < 0) {\n\n                error_report(\"error while loading state for instance 0x%x of\"\n\n                             \" device '%s'\", instance_id, idstr);\n\n                goto out;\n\n            }\n\n            break;\n\n        case QEMU_VM_SECTION_PART:\n\n        case QEMU_VM_SECTION_END:\n\n            section_id = qemu_get_be32(f);\n\n\n\n            trace_qemu_loadvm_state_section_partend(section_id);\n\n            QLIST_FOREACH(le, &loadvm_handlers, entry) {\n\n                if (le->section_id == section_id) {\n\n                    break;\n\n                }\n\n            }\n\n            if (le == NULL) {\n\n                error_report(\"Unknown savevm section %d\", section_id);\n\n                ret = -EINVAL;\n\n                goto out;\n\n            }\n\n\n\n            ret = vmstate_load(f, le->se, le->version_id);\n\n            if (ret < 0) {\n\n                error_report(\"error while loading state section id %d(%s)\",\n\n                             section_id, le->se->idstr);\n\n                goto out;\n\n            }\n\n            break;\n\n        default:\n\n            error_report(\"Unknown savevm section type %d\", section_type);\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    file_error_after_eof = qemu_file_get_error(f);\n\n\n\n    /*\n\n     * Try to read in the VMDESC section as well, so that dumping tools that\n\n     * intercept our migration stream have the chance to see it.\n\n     */\n\n    if (qemu_get_byte(f) == QEMU_VM_VMDESCRIPTION) {\n\n        uint32_t size = qemu_get_be32(f);\n\n        uint8_t *buf = g_malloc(0x1000);\n\n\n\n        while (size > 0) {\n\n            uint32_t read_chunk = MIN(size, 0x1000);\n\n            qemu_get_buffer(f, buf, read_chunk);\n\n            size -= read_chunk;\n\n        }\n\n        g_free(buf);\n\n    }\n\n\n\n    cpu_synchronize_all_post_init();\n\n\n\n    ret = 0;\n\n\n\nout:\n\n    QLIST_FOREACH_SAFE(le, &loadvm_handlers, entry, new_le) {\n\n        QLIST_REMOVE(le, entry);\n\n        g_free(le);\n\n    }\n\n\n\n    if (ret == 0) {\n\n        /* We may not have a VMDESC section, so ignore relative errors */\n\n        ret = file_error_after_eof;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10571}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "uint64_t cpu_tick_get_count(CPUTimer *timer)\n\n{\n\n    uint64_t real_count = timer_to_cpu_ticks(\n\n                    qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - timer->clock_offset,\n\n                    timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s get_count count=0x%016lx (%s) p=%p\\n\",\n\n           timer->name, real_count,\n\n           timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    if (timer->disabled)\n\n        real_count |= timer->disabled_mask;\n\n\n\n    return real_count;\n\n}\n", "idx": 8296}
{"project": "qemu", "commit_id": "ff2b68aa70d10b7eae813b04e9a23723dbd89ebd", "target": 1, "func": "static void nbd_client_close(NBDClient *client)\n\n{\n\n    qemu_set_fd_handler2(client->sock, NULL, NULL, NULL, NULL);\n\n    close(client->sock);\n\n    client->sock = -1;\n\n    if (client->close) {\n\n        client->close(client);\n\n    }\n\n    nbd_client_put(client);\n\n}\n", "idx": 3827}
{"project": "qemu", "commit_id": "17eb587aeb492fe68f8130b027154ff0921fc0b4", "target": 1, "func": "static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n\n                                 struct tftp_t *tp)\n\n{\n\n  struct tftp_session *spt;\n\n  int k;\n\n\n\n  for (k = 0; k < TFTP_SESSIONS_MAX; k++) {\n\n    spt = &slirp->tftp_sessions[k];\n\n\n\n    if (!tftp_session_in_use(spt))\n\n        goto found;\n\n\n\n    /* sessions time out after 5 inactive seconds */\n\n    if ((int)(curtime - spt->timestamp) > 5000) {\n\n        tftp_session_terminate(spt);\n\n        goto found;\n\n    }\n\n  }\n\n\n\n  return -1;\n\n\n\n found:\n\n  memset(spt, 0, sizeof(*spt));\n\n  spt->client_addr = *srcsas;\n\n  spt->fd = -1;\n\n  spt->block_size = 512;\n\n  spt->client_port = tp->udp.uh_sport;\n\n  spt->slirp = slirp;\n\n\n\n  tftp_session_update(spt);\n\n\n\n  return k;\n\n}\n", "idx": 8689}
{"project": "qemu", "commit_id": "c36ad13fe9ece9a21a8c1dd082473a2b182298ee", "target": 1, "func": "static void hpet_ram_write(void *opaque, hwaddr addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    int i;\n\n    HPETState *s = opaque;\n\n    uint64_t old_val, new_val, val, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_writel at %\" PRIx64 \" = %#x\\n\", addr, value);\n\n    index = addr;\n\n    old_val = hpet_ram_read(opaque, addr, 4);\n\n    new_val = value;\n\n\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        DPRINTF(\"qemu: hpet_ram_writel timer_id = %#x\\n\", timer_id);\n\n        if (timer_id > s->num_timers) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return;\n\n        }\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CFG\\n\");\n\n            if (activating_bit(old_val, new_val, HPET_TN_FSB_ENABLE)) {\n\n                update_irq(timer, 0);\n\n            }\n\n            val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);\n\n            timer->config = (timer->config & 0xffffffff00000000ULL) | val;\n\n            if (new_val & HPET_TN_32BIT) {\n\n                timer->cmp = (uint32_t)timer->cmp;\n\n                timer->period = (uint32_t)timer->period;\n\n            }\n\n            if (activating_bit(old_val, new_val, HPET_TN_ENABLE)) {\n\n                hpet_set_timer(timer);\n\n            } else if (deactivating_bit(old_val, new_val, HPET_TN_ENABLE)) {\n\n                hpet_del_timer(timer);\n\n            }\n\n            break;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            DPRINTF(\"qemu: invalid HPET_TN_CFG+4 write\\n\");\n\n            break;\n\n        case HPET_TN_CMP: // comparator register\n\n            DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP\\n\");\n\n            if (timer->config & HPET_TN_32BIT) {\n\n                new_val = (uint32_t)new_val;\n\n            }\n\n            if (!timer_is_periodic(timer)\n\n                || (timer->config & HPET_TN_SETVAL)) {\n\n                timer->cmp = (timer->cmp & 0xffffffff00000000ULL) | new_val;\n\n            }\n\n            if (timer_is_periodic(timer)) {\n\n                /*\n\n                 * FIXME: Clamp period to reasonable min value?\n\n                 * Clamp period to reasonable max value\n\n                 */\n\n                new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                timer->period =\n\n                    (timer->period & 0xffffffff00000000ULL) | new_val;\n\n            }\n\n            timer->config &= ~HPET_TN_SETVAL;\n\n            if (hpet_enabled(s)) {\n\n                hpet_set_timer(timer);\n\n            }\n\n            break;\n\n        case HPET_TN_CMP + 4: // comparator register high order\n\n            DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP + 4\\n\");\n\n            if (!timer_is_periodic(timer)\n\n                || (timer->config & HPET_TN_SETVAL)) {\n\n                timer->cmp = (timer->cmp & 0xffffffffULL) | new_val << 32;\n\n            } else {\n\n                /*\n\n                 * FIXME: Clamp period to reasonable min value?\n\n                 * Clamp period to reasonable max value\n\n                 */\n\n                new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                timer->period =\n\n                    (timer->period & 0xffffffffULL) | new_val << 32;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled(s)) {\n\n                    hpet_set_timer(timer);\n\n                }\n\n                break;\n\n        case HPET_TN_ROUTE:\n\n            timer->fsb = (timer->fsb & 0xffffffff00000000ULL) | new_val;\n\n            break;\n\n        case HPET_TN_ROUTE + 4:\n\n            timer->fsb = (new_val << 32) | (timer->fsb & 0xffffffff);\n\n            break;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n            break;\n\n        }\n\n        return;\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return;\n\n        case HPET_CFG:\n\n            val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);\n\n            s->config = (s->config & 0xffffffff00000000ULL) | val;\n\n            if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                /* Enable main counter and interrupt generation. */\n\n                s->hpet_offset =\n\n                    ticks_to_ns(s->hpet_counter) - qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n                for (i = 0; i < s->num_timers; i++) {\n\n                    if ((&s->timer[i])->cmp != ~0ULL) {\n\n                        hpet_set_timer(&s->timer[i]);\n\n                    }\n\n                }\n\n            } else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                /* Halt main counter and disable interrupt generation. */\n\n                s->hpet_counter = hpet_get_ticks(s);\n\n                for (i = 0; i < s->num_timers; i++) {\n\n                    hpet_del_timer(&s->timer[i]);\n\n                }\n\n            }\n\n            /* i8254 and RTC output pins are disabled\n\n             * when HPET is in legacy mode */\n\n            if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                qemu_set_irq(s->pit_enabled, 0);\n\n                qemu_irq_lower(s->irqs[0]);\n\n                qemu_irq_lower(s->irqs[RTC_ISA_IRQ]);\n\n            } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                qemu_irq_lower(s->irqs[0]);\n\n                qemu_set_irq(s->pit_enabled, 1);\n\n                qemu_set_irq(s->irqs[RTC_ISA_IRQ], s->rtc_irq_level);\n\n            }\n\n            break;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG+4 write\\n\");\n\n            break;\n\n        case HPET_STATUS:\n\n            val = new_val & s->isr;\n\n            for (i = 0; i < s->num_timers; i++) {\n\n                if (val & (1 << i)) {\n\n                    update_irq(&s->timer[i], 0);\n\n                }\n\n            }\n\n            break;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                DPRINTF(\"qemu: Writing counter while HPET enabled!\\n\");\n\n            }\n\n            s->hpet_counter =\n\n                (s->hpet_counter & 0xffffffff00000000ULL) | value;\n\n            DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                    value, s->hpet_counter);\n\n            break;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                DPRINTF(\"qemu: Writing counter while HPET enabled!\\n\");\n\n            }\n\n            s->hpet_counter =\n\n                (s->hpet_counter & 0xffffffffULL) | (((uint64_t)value) << 32);\n\n            DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                    value, s->hpet_counter);\n\n            break;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 6102}
{"project": "qemu", "commit_id": "53111180946a56d314a9c1d07d09b9ef91e847b9", "target": 1, "func": "static void arm_gic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *sbc = SYS_BUS_DEVICE_CLASS(klass);\n\n    ARMGICClass *agc = ARM_GIC_CLASS(klass);\n\n    agc->parent_init = sbc->init;\n\n    sbc->init = arm_gic_init;\n\n    dc->no_user = 1;\n\n}\n", "idx": 9618}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int posix_aio_init(void)\n\n{\n\n    sigset_t mask;\n\n    PosixAioState *s;\n\n  \n\n    if (posix_aio_state)\n\n        return 0;\n\n\n\n    s = qemu_malloc(sizeof(PosixAioState));\n\n    if (s == NULL)\n\n        return -ENOMEM;\n\n\n\n    /* Make sure to block AIO signal */\n\n    sigemptyset(&mask);\n\n    sigaddset(&mask, SIGUSR2);\n\n    sigprocmask(SIG_BLOCK, &mask, NULL);\n\n    \n\n    s->first_aio = NULL;\n\n    s->fd = qemu_signalfd(&mask);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"failed to create signalfd\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    fcntl(s->fd, F_SETFL, O_NONBLOCK);\n\n\n\n    qemu_aio_set_fd_handler(s->fd, posix_aio_read, NULL, posix_aio_flush, s);\n\n\n\n#if defined(__linux__)\n\n    {\n\n        struct aioinit ai;\n\n\n\n        memset(&ai, 0, sizeof(ai));\n\n#if defined(__GLIBC_PREREQ) && __GLIBC_PREREQ(2, 4)\n\n        ai.aio_threads = 64;\n\n        ai.aio_num = 64;\n\n#else\n\n        /* XXX: aio thread exit seems to hang on RedHat 9 and this init\n\n           seems to fix the problem. */\n\n        ai.aio_threads = 1;\n\n        ai.aio_num = 1;\n\n        ai.aio_idle_time = 365 * 100000;\n\n#endif\n\n        aio_init(&ai);\n\n    }\n\n#endif\n\n    posix_aio_state = s;\n\n\n\n    return 0;\n\n}\n", "idx": 3974}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "int kvm_arch_init(MachineState *ms, KVMState *s)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"host\");\n\n    cap_sync_regs = kvm_check_extension(s, KVM_CAP_SYNC_REGS);\n\n    cap_async_pf = kvm_check_extension(s, KVM_CAP_ASYNC_PF);\n\n    cap_mem_op = kvm_check_extension(s, KVM_CAP_S390_MEM_OP);\n\n    cap_s390_irq = kvm_check_extension(s, KVM_CAP_S390_INJECT_IRQ);\n\n\n\n    if (!kvm_check_extension(s, KVM_CAP_S390_GMAP)\n\n        || !kvm_check_extension(s, KVM_CAP_S390_COW)) {\n\n        phys_mem_set_alloc(legacy_s390_alloc);\n\n    }\n\n\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_USER_SIGP, 0);\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_VECTOR_REGISTERS, 0);\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_USER_STSI, 0);\n\n    if (ri_allowed()) {\n\n        if (kvm_vm_enable_cap(s, KVM_CAP_S390_RI, 0) == 0) {\n\n            cap_ri = 1;\n\n        }\n\n    }\n\n    if (gs_allowed()) {\n\n        if (kvm_vm_enable_cap(s, KVM_CAP_S390_GS, 0) == 0) {\n\n            cap_gs = 1;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * The migration interface for ais was introduced with kernel 4.13\n\n     * but the capability itself had been active since 4.12. As migration\n\n     * support is considered necessary let's disable ais in the 2.10\n\n     * machine.\n\n     */\n\n    /* kvm_vm_enable_cap(s, KVM_CAP_S390_AIS, 0); */\n\n\n\n    return 0;\n\n}\n", "idx": 990}
{"project": "qemu", "commit_id": "a1bb73849fbd7d992b6ac2cf30c034244fb2299d", "target": 1, "func": "void helper_rfdi(CPUPPCState *env)\n\n{\n\n    do_rfi(env, env->spr[SPR_BOOKE_DSRR0], SPR_BOOKE_DSRR1,\n\n           ~((target_ulong)0x3FFF0000), 0);\n\n}\n", "idx": 9398}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n", "idx": 10220}
{"project": "qemu", "commit_id": "e03c902cb617414dae49d77a810f6957ff7affac", "target": 1, "func": "static uint32_t icp_accept(struct icp_server_state *ss)\n\n{\n\n    uint32_t xirr = ss->xirr;\n\n\n\n    qemu_irq_lower(ss->output);\n\n    ss->xirr = ss->pending_priority << 24;\n\n\n\n\n    trace_xics_icp_accept(xirr, ss->xirr);\n\n\n\n    return xirr;\n\n}", "idx": 9307}
{"project": "qemu", "commit_id": "5cb9b56acfc0b50acf7ccd2d044ab4991c47fdde", "target": 1, "func": "static int print_uint32(DeviceState *dev, Property *prop, char *dest, size_t len)\n\n{\n\n    uint32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    return snprintf(dest, len, \"%\" PRIu32, *ptr);\n\n}\n", "idx": 9480}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    ADBDeviceClass *adc = ADB_DEVICE_CLASS(oc);\n\n    ADBMouseClass *amc = ADB_MOUSE_CLASS(oc);\n\n\n\n    amc->parent_realize = dc->realize;\n\n    dc->realize = adb_mouse_realizefn;\n\n    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);\n\n\n\n    adc->devreq = adb_mouse_request;\n\n    dc->reset = adb_mouse_reset;\n\n    dc->vmsd = &vmstate_adb_mouse;\n\n}\n", "idx": 7621}
{"project": "qemu", "commit_id": "d20051856cd2fa8f10fed2d2a0b2751de5f7b20d", "target": 1, "func": "static int ide_dev_initfn(IDEDevice *dev, IDEDriveKind kind)\n{\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, dev->qdev.parent_bus);\n    IDEState *s = bus->ifs + dev->unit;\n    Error *err = NULL;\n    if (dev->conf.discard_granularity == -1) {\n        dev->conf.discard_granularity = 512;\n    } else if (dev->conf.discard_granularity &&\n               dev->conf.discard_granularity != 512) {\n        error_report(\"discard_granularity must be 512 for ide\");\n    blkconf_serial(&dev->conf, &dev->serial);\n    if (kind != IDE_CD) {\n        blkconf_geometry(&dev->conf, &dev->chs_trans, 65536, 16, 255, &err);\n        if (err) {\n            error_report(\"%s\", error_get_pretty(err));\n            error_free(err);\n    if (ide_init_drive(s, dev->conf.blk, kind,\n                       dev->version, dev->serial, dev->model, dev->wwn,\n                       dev->conf.cyls, dev->conf.heads, dev->conf.secs,\n                       dev->chs_trans) < 0) {\n    if (!dev->version) {\n        dev->version = g_strdup(s->version);\n    if (!dev->serial) {\n        dev->serial = g_strdup(s->drive_serial_str);\n    add_boot_device_path(dev->conf.bootindex, &dev->qdev,\n                         dev->unit ? \"/disk@1\" : \"/disk@0\");\n    return 0;", "idx": 5217}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void iscsi_retry_timer_expired(void *opaque)\n\n{\n\n    struct IscsiTask *iTask = opaque;\n\n    iTask->complete = 1;\n\n    if (iTask->co) {\n\n        qemu_coroutine_enter(iTask->co, NULL);\n\n    }\n\n}\n", "idx": 2371}
{"project": "qemu", "commit_id": "d8f94e1bb275ab6a14a15220fd6afd0d04324aeb", "target": 1, "func": "static void mips_fulong2e_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios = g_new(MemoryRegion, 1);\n\n    long bios_size;\n\n    int64_t kernel_entry;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cpu_exit_irq;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    I2CBus *smbus;\n\n    int i;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    MIPSCPU *cpu;\n\n    CPUMIPSState *env;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"Loongson-2E\";\n\n    }\n\n    cpu = cpu_mips_init(cpu_model);\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n\n\n    /* fulong 2e has 256M ram. */\n\n    ram_size = 256 * 1024 * 1024;\n\n\n\n    /* fulong 2e has a 1M flash.Winbond W39L040AP70Z */\n\n    bios_size = 1024 * 1024;\n\n\n\n    /* allocate RAM */\n\n    memory_region_init_ram(ram, NULL, \"fulong2e.ram\", ram_size, &error_abort);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_init_ram(bios, NULL, \"fulong2e.bios\", bios_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(bios);\n\n    memory_region_set_readonly(bios, true);\n\n\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n    memory_region_add_subregion(address_space_mem, 0x1fc00000LL, bios);\n\n\n\n    /* We do not support flash operation, just loading pmon.bin as raw BIOS.\n\n     * Please use -L to set the BIOS path and -bios to set bios name. */\n\n\n\n    if (kernel_filename) {\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel (env);\n\n        write_bootloader(env, memory_region_get_ram_ptr(bios), kernel_entry);\n\n    } else {\n\n        if (bios_name == NULL) {\n\n                bios_name = FULONG_BIOSNAME;\n\n        }\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image_targphys(filename, 0x1fc00000LL,\n\n                                            BIOS_SIZE);\n\n            g_free(filename);\n\n        } else {\n\n            bios_size = -1;\n\n        }\n\n\n\n        if ((bios_size < 0 || bios_size > BIOS_SIZE) &&\n\n            !kernel_filename && !qtest_enabled()) {\n\n            error_report(\"Could not load MIPS bios '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Init internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* North bridge, Bonito --> IP2 */\n\n    pci_bus = bonito_init((qemu_irq *)&(env->irq[2]));\n\n\n\n    /* South bridge */\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n\n\n    isa_bus = vt82c686b_init(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 0));\n\n    if (!isa_bus) {\n\n        fprintf(stderr, \"vt82c686b_init error\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt controller */\n\n    /* The 8259 -> IP5  */\n\n    i8259 = i8259_init(isa_bus, env->irq[5]);\n\n    isa_bus_irqs(isa_bus, i8259);\n\n\n\n    vt82c686b_ide_init(pci_bus, hd, PCI_DEVFN(FULONG2E_VIA_SLOT, 1));\n\n    pci_create_simple(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 2),\n\n                      \"vt82c686b-usb-uhci\");\n\n    pci_create_simple(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 3),\n\n                      \"vt82c686b-usb-uhci\");\n\n\n\n    smbus = vt82c686b_pm_init(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 4),\n\n                              0xeee1, NULL);\n\n    /* TODO: Populate SPD eeprom data.  */\n\n    smbus_eeprom_init(smbus, 1, eeprom_spd, sizeof(eeprom_spd));\n\n\n\n    /* init other devices */\n\n    pit = pit_init(isa_bus, 0x40, 0, NULL);\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(0, cpu_exit_irq);\n\n\n\n    /* Super I/O */\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    rtc_init(isa_bus, 2000, NULL);\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_isa_init(isa_bus, i, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    if (parallel_hds[0]) {\n\n        parallel_init(isa_bus, 0, parallel_hds[0]);\n\n    }\n\n\n\n    /* Sound card */\n\n    audio_init(pci_bus);\n\n    /* Network card */\n\n    network_init(pci_bus);\n\n}\n", "idx": 4309}
{"project": "qemu", "commit_id": "2a633c461e96cb9a856292c46917653bd43959c8", "target": 1, "func": "static int virtio_blk_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n\n\n    if (version_id != 2)\n\n        return -EINVAL;\n\n\n\n    virtio_load(&s->vdev, f);\n\n    while (qemu_get_sbyte(f)) {\n\n        VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n        qemu_get_buffer(f, (unsigned char*)&req->elem, sizeof(req->elem));\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n\n\n        virtqueue_map_sg(req->elem.in_sg, req->elem.in_addr,\n\n            req->elem.in_num, 1);\n\n        virtqueue_map_sg(req->elem.out_sg, req->elem.out_addr,\n\n            req->elem.out_num, 0);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 8342}
{"project": "qemu", "commit_id": "4d8d5467cd6e324fb49ae97b9d5dcee3973d9a19", "target": 1, "func": "static uint32_t regtype_to_ss(uint8_t type)\n\n{\n\n    if (type & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\n        return 3;\n\n    }\n\n    if (type == PCI_BASE_ADDRESS_SPACE_IO) {\n\n        return 1;\n\n    }\n\n    return 2;\n\n}\n", "idx": 6687}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_er_reset(XHCIState *xhci, int v)\n\n{\n\n    XHCIInterrupter *intr = &xhci->intr[v];\n\n    XHCIEvRingSeg seg;\n\n\n\n    if (intr->erstsz == 0) {\n\n        /* disabled */\n\n        intr->er_start = 0;\n\n        intr->er_size = 0;\n\n        return;\n\n    }\n\n    /* cache the (sole) event ring segment location */\n\n    if (intr->erstsz != 1) {\n\n        DPRINTF(\"xhci: invalid value for ERSTSZ: %d\\n\", intr->erstsz);\n\n        xhci_die(xhci);\n\n        return;\n\n    }\n\n    dma_addr_t erstba = xhci_addr64(intr->erstba_low, intr->erstba_high);\n\n    pci_dma_read(PCI_DEVICE(xhci), erstba, &seg, sizeof(seg));\n\n    le32_to_cpus(&seg.addr_low);\n\n    le32_to_cpus(&seg.addr_high);\n\n    le32_to_cpus(&seg.size);\n\n    if (seg.size < 16 || seg.size > 4096) {\n\n        DPRINTF(\"xhci: invalid value for segment size: %d\\n\", seg.size);\n\n        xhci_die(xhci);\n\n        return;\n\n    }\n\n    intr->er_start = xhci_addr64(seg.addr_low, seg.addr_high);\n\n    intr->er_size = seg.size;\n\n\n\n    intr->er_ep_idx = 0;\n\n    intr->er_pcs = 1;\n\n    intr->er_full = 0;\n\n\n\n    DPRINTF(\"xhci: event ring[%d]:\" DMA_ADDR_FMT \" [%d]\\n\",\n\n            v, intr->er_start, intr->er_size);\n\n}\n", "idx": 8626}
{"project": "qemu", "commit_id": "80cba1b71eb9a75404d1effddec8ffa9f0d6d6fb", "target": 1, "func": "static int proxy_init(FsContext *ctx)\n\n{\n\n    V9fsProxy *proxy = g_malloc(sizeof(V9fsProxy));\n\n    int sock_id;\n\n\n\n    if (ctx->export_flags & V9FS_PROXY_SOCK_NAME) {\n\n        sock_id = connect_namedsocket(ctx->fs_root);\n\n    } else {\n\n        sock_id = atoi(ctx->fs_root);\n\n        if (sock_id < 0) {\n\n            fprintf(stderr, \"socket descriptor not initialized\\n\");\n\n\n            return -1;\n\n        }\n\n    }\n\n    g_free(ctx->fs_root);\n\n\n\n\n    proxy->in_iovec.iov_base  = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n\n    proxy->in_iovec.iov_len   = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n\n    proxy->out_iovec.iov_base = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n\n    proxy->out_iovec.iov_len  = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n\n\n\n    ctx->private = proxy;\n\n    proxy->sockfd = sock_id;\n\n    qemu_mutex_init(&proxy->mutex);\n\n\n\n    ctx->export_flags |= V9FS_PATHNAME_FSCONTEXT;\n\n    ctx->exops.get_st_gen = proxy_ioc_getversion;\n\n    return 0;\n\n}", "idx": 10713}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void musicpal_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    ARMCPU *cpu;\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    DeviceState *i2c_dev;\n\n    DeviceState *lcd_dev;\n\n    DeviceState *key_dev;\n\n    DeviceState *wm8750_dev;\n\n    SysBusDevice *s;\n\n    I2CBus *i2c;\n\n    int i;\n\n    unsigned long flash_size;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = ARM_CPU(cpu_generic_init(TYPE_ARM_CPU, cpu_model));\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* For now we use a fixed - the original - RAM size */\n\n    memory_region_allocate_system_memory(ram, NULL, \"musicpal.ram\",\n\n                                         MP_RAM_DEFAULT_SIZE);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    memory_region_init_ram(sram, NULL, \"musicpal.sram\", MP_SRAM_SIZE,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, MP_SRAM_BASE, sram);\n\n\n\n    dev = sysbus_create_simple(TYPE_MV88W8618_PIC, MP_PIC_BASE,\n\n                               qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ));\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_varargs(TYPE_MV88W8618_PIT, MP_PIT_BASE, pic[MP_TIMER1_IRQ],\n\n                          pic[MP_TIMER2_IRQ], pic[MP_TIMER3_IRQ],\n\n                          pic[MP_TIMER4_IRQ], NULL);\n\n\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(address_space_mem, MP_UART1_BASE, 2, pic[MP_UART1_IRQ],\n\n                       1825000, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n    }\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(address_space_mem, MP_UART2_BASE, 2, pic[MP_UART2_IRQ],\n\n                       1825000, serial_hds[1], DEVICE_NATIVE_ENDIAN);\n\n    }\n\n\n\n    /* Register flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (dinfo) {\n\n        BlockBackend *blk = blk_by_legacy_dinfo(dinfo);\n\n\n\n        flash_size = blk_getlength(blk);\n\n        if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n\n            flash_size != 32*1024*1024) {\n\n            fprintf(stderr, \"Invalid flash image size\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /*\n\n         * The original U-Boot accesses the flash at 0xFE000000 instead of\n\n         * 0xFF800000 (if there is 8 MB flash). So remap flash access if the\n\n         * image is smaller than 32 MB.\n\n         */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        pflash_cfi02_register(0x100000000ULL-MP_FLASH_SIZE_MAX, NULL,\n\n                              \"musicpal.flash\", flash_size,\n\n                              blk, 0x10000, (flash_size + 0xffff) >> 16,\n\n                              MP_FLASH_SIZE_MAX / flash_size,\n\n                              2, 0x00BF, 0x236D, 0x0000, 0x0000,\n\n                              0x5555, 0x2AAA, 1);\n\n#else\n\n        pflash_cfi02_register(0x100000000ULL-MP_FLASH_SIZE_MAX, NULL,\n\n                              \"musicpal.flash\", flash_size,\n\n                              blk, 0x10000, (flash_size + 0xffff) >> 16,\n\n                              MP_FLASH_SIZE_MAX / flash_size,\n\n                              2, 0x00BF, 0x236D, 0x0000, 0x0000,\n\n                              0x5555, 0x2AAA, 0);\n\n#endif\n\n\n\n    }\n\n    sysbus_create_simple(TYPE_MV88W8618_FLASHCFG, MP_FLASHCFG_BASE, NULL);\n\n\n\n    qemu_check_nic_model(&nd_table[0], \"mv88w8618\");\n\n    dev = qdev_create(NULL, TYPE_MV88W8618_ETH);\n\n    qdev_set_nic_properties(dev, &nd_table[0]);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, MP_ETH_BASE);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[MP_ETH_IRQ]);\n\n\n\n    sysbus_create_simple(\"mv88w8618_wlan\", MP_WLAN_BASE, NULL);\n\n\n\n    sysbus_create_simple(TYPE_MUSICPAL_MISC, MP_MISC_BASE, NULL);\n\n\n\n    dev = sysbus_create_simple(TYPE_MUSICPAL_GPIO, MP_GPIO_BASE,\n\n                               pic[MP_GPIO_IRQ]);\n\n    i2c_dev = sysbus_create_simple(\"gpio_i2c\", -1, NULL);\n\n    i2c = (I2CBus *)qdev_get_child_bus(i2c_dev, \"i2c\");\n\n\n\n    lcd_dev = sysbus_create_simple(TYPE_MUSICPAL_LCD, MP_LCD_BASE, NULL);\n\n    key_dev = sysbus_create_simple(TYPE_MUSICPAL_KEY, -1, NULL);\n\n\n\n    /* I2C read data */\n\n    qdev_connect_gpio_out(i2c_dev, 0,\n\n                          qdev_get_gpio_in(dev, MP_GPIO_I2C_DATA_BIT));\n\n    /* I2C data */\n\n    qdev_connect_gpio_out(dev, 3, qdev_get_gpio_in(i2c_dev, 0));\n\n    /* I2C clock */\n\n    qdev_connect_gpio_out(dev, 4, qdev_get_gpio_in(i2c_dev, 1));\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        qdev_connect_gpio_out(dev, i, qdev_get_gpio_in(lcd_dev, i));\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        qdev_connect_gpio_out(key_dev, i, qdev_get_gpio_in(dev, i + 8));\n\n    }\n\n    for (i = 4; i < 8; i++) {\n\n        qdev_connect_gpio_out(key_dev, i, qdev_get_gpio_in(dev, i + 15));\n\n    }\n\n\n\n    wm8750_dev = i2c_create_slave(i2c, \"wm8750\", MP_WM_ADDR);\n\n    dev = qdev_create(NULL, \"mv88w8618_audio\");\n\n    s = SYS_BUS_DEVICE(dev);\n\n    qdev_prop_set_ptr(dev, \"wm8750\", wm8750_dev);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(s, 0, MP_AUDIO_BASE);\n\n    sysbus_connect_irq(s, 0, pic[MP_AUDIO_IRQ]);\n\n\n\n    musicpal_binfo.ram_size = MP_RAM_DEFAULT_SIZE;\n\n    musicpal_binfo.kernel_filename = kernel_filename;\n\n    musicpal_binfo.kernel_cmdline = kernel_cmdline;\n\n    musicpal_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &musicpal_binfo);\n\n}\n", "idx": 5413}
{"project": "qemu", "commit_id": "aef4acb6616ab7fb5c105660aa8a2cee4e250e75", "target": 1, "func": "static int copy_sectors(BlockDriverState *bs, uint64_t start_sect,\n\n                        uint64_t cluster_offset, int n_start, int n_end)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int n, ret;\n\n    void *buf;\n\n\n\n    /*\n\n     * If this is the last cluster and it is only partially used, we must only\n\n     * copy until the end of the image, or bdrv_check_request will fail for the\n\n     * bdrv_read/write calls below.\n\n     */\n\n    if (start_sect + n_end > bs->total_sectors) {\n\n        n_end = bs->total_sectors - start_sect;\n\n    }\n\n\n\n    n = n_end - n_start;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, n * BDRV_SECTOR_SIZE);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_READ);\n\n    ret = bdrv_read(bs, start_sect + n_start, buf, n);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (s->crypt_method) {\n\n        qcow2_encrypt_sectors(s, start_sect + n_start,\n\n                        buf, buf, n, 1,\n\n                        &s->aes_encrypt_key);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_WRITE);\n\n    ret = bdrv_write(bs->file, (cluster_offset >> 9) + n_start, buf, n);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    qemu_vfree(buf);\n\n    return ret;\n\n}\n", "idx": 2712}
{"project": "qemu", "commit_id": "9a321e92343891e30f6fe8bfaad40454ae358bfb", "target": 1, "func": "static int spapr_msicfg_find(sPAPRPHBState *phb, uint32_t config_addr,\n\n                             bool alloc_new)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < SPAPR_MSIX_MAX_DEVS; ++i) {\n\n        if (!phb->msi_table[i].nvec) {\n\n            break;\n\n        }\n\n        if (phb->msi_table[i].config_addr == config_addr) {\n\n            return i;\n\n        }\n\n    }\n\n    if ((i < SPAPR_MSIX_MAX_DEVS) && alloc_new) {\n\n        trace_spapr_pci_msi(\"Allocating new MSI config\", i, config_addr);\n\n        return i;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 12028}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void memory_region_transaction_commit(void)\n{\n    AddressSpace *as;\n    assert(memory_region_transaction_depth);\n    --memory_region_transaction_depth;\n    if (!memory_region_transaction_depth) {\n        if (memory_region_update_pending) {\n            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_topology(as);\n            }\n            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);\n        } else if (ioeventfd_update_pending) {\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_ioeventfds(as);\n            }\n        }\n        memory_region_clear_pending();\n   }\n}", "idx": 60}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    if (p->devep != 0)\n\n        return s->info->handle_data(s, p);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = s->info->handle_control(s, p, request, value, index,\n\n                                          s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->len)\n\n                len = p->len;\n\n            memcpy(p->data, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 10779}
{"project": "qemu", "commit_id": "04097f7c5957273c578f72b9bd603ba6b1d69e33", "target": 1, "func": "static inline void vhost_dev_log_resize(struct vhost_dev* dev, uint64_t size)\n\n{\n\n    vhost_log_chunk_t *log;\n\n    uint64_t log_base;\n\n    int r;\n\n    if (size) {\n\n        log = g_malloc0(size * sizeof *log);\n\n    } else {\n\n        log = NULL;\n\n    }\n\n    log_base = (uint64_t)(unsigned long)log;\n\n    r = ioctl(dev->control, VHOST_SET_LOG_BASE, &log_base);\n\n    assert(r >= 0);\n\n    vhost_client_sync_dirty_bitmap(&dev->client, 0,\n\n                                   (target_phys_addr_t)~0x0ull);\n\n    if (dev->log) {\n\n        g_free(dev->log);\n\n    }\n\n    dev->log = log;\n\n    dev->log_size = size;\n\n}\n", "idx": 273}
{"project": "qemu", "commit_id": "b5469b1104a4b0c870dd805d9fb9d844b56d987e", "target": 1, "func": "void vnc_tight_clear(VncState *vs)\n\n{\n\n    int i;\n\n    for (i=0; i<ARRAY_SIZE(vs->tight.stream); i++) {\n\n        if (vs->tight.stream[i].opaque) {\n\n            deflateEnd(&vs->tight.stream[i]);\n\n        }\n\n    }\n\n\n\n    buffer_free(&vs->tight.tight);\n\n    buffer_free(&vs->tight.zlib);\n\n    buffer_free(&vs->tight.gradient);\n\n#ifdef CONFIG_VNC_JPEG\n\n    buffer_free(&vs->tight.jpeg);\n\n\n\n\n\n}", "idx": 11903}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_sdrc_s *omap_sdrc_init(MemoryRegion *sysmem,\n\n                                   hwaddr base)\n\n{\n\n    struct omap_sdrc_s *s = (struct omap_sdrc_s *)\n\n            g_malloc0(sizeof(struct omap_sdrc_s));\n\n\n\n    omap_sdrc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_sdrc_ops, s, \"omap.sdrc\", 0x1000);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 415}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 3437}
{"project": "qemu", "commit_id": "e122636562218b3d442cd2cd18fbc188dd9ce709", "target": 1, "func": "void migration_set_incoming_channel(MigrationState *s,\n\n                                    QIOChannel *ioc)\n\n{\n\n    QEMUFile *f = qemu_fopen_channel_input(ioc);\n\n\n\n    process_incoming_migration(f);\n\n}\n", "idx": 12227}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_update_rings(VirtIODevice *vdev, int n)\n\n{\n\n    VRing *vring = &vdev->vq[n].vring;\n\n\n\n    if (!vring->desc) {\n\n        /* not yet setup -> nothing to do */\n\n        return;\n\n    }\n\n    vring->avail = vring->desc + vring->num * sizeof(VRingDesc);\n\n    vring->used = vring_align(vring->avail +\n\n                              offsetof(VRingAvail, ring[vring->num]),\n\n                              vring->align);\n\n    virtio_init_region_cache(vdev, n);\n\n}\n", "idx": 4828}
{"project": "qemu", "commit_id": "4333979e3d8c129953bba36ed87ce543d33cbea1", "target": 1, "func": "static void bochs_bios_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    static const char shutdown_str[8] = \"Shutdown\";\n\n    static int shutdown_index = 0;\n\n\n\n    switch(addr) {\n\n        /* Bochs BIOS messages */\n\n    case 0x400:\n\n    case 0x401:\n\n        /* used to be panic, now unused */\n\n        break;\n\n    case 0x402:\n\n    case 0x403:\n\n#ifdef DEBUG_BIOS\n\n        fprintf(stderr, \"%c\", val);\n\n#endif\n\n        break;\n\n    case 0x8900:\n\n        /* same as Bochs power off */\n\n        if (val == shutdown_str[shutdown_index]) {\n\n            shutdown_index++;\n\n            if (shutdown_index == 8) {\n\n                shutdown_index = 0;\n\n                qemu_system_shutdown_request();\n\n            }\n\n        } else {\n\n            shutdown_index = 0;\n\n        }\n\n        break;\n\n\n\n        /* LGPL'ed VGA BIOS messages */\n\n    case 0x501:\n\n    case 0x502:\n\n        fprintf(stderr, \"VGA BIOS panic, line %d\\n\", val);\n\n        exit(1);\n\n    case 0x500:\n\n    case 0x503:\n\n#ifdef DEBUG_BIOS\n\n        fprintf(stderr, \"%c\", val);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 591}
{"project": "qemu", "commit_id": "5070570c9089b905dd9efae30ee4318033c6ccd6", "target": 1, "func": "static int find_debugfs(char *debugfs)\n\n{\n\n    char type[100];\n\n    FILE *fp;\n\n\n\n    fp = fopen(\"/proc/mounts\", \"r\");\n\n    if (fp == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    while (fscanf(fp, \"%*s %\" STR(PATH_MAX) \"s %99s %*s %*d %*d\\n\",\n\n                  debugfs, type) == 2) {\n\n        if (strcmp(type, \"debugfs\") == 0) {\n\n            break;\n\n        }\n\n    }\n\n    fclose(fp);\n\n\n\n    if (strcmp(type, \"debugfs\") != 0) {\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 12088}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int alsa_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceOut *alsa = (ALSAVoiceOut *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_out;\n\n    req.buffer_size = conf.buffer_size_out;\n\n    req.size_in_usec = conf.size_in_usec_out;\n\n    req.override_mask =\n\n        (conf.period_size_out_overridden ? 1 : 0) |\n\n        (conf.buffer_size_out_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (0, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, obt.samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "idx": 4530}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n\n                      struct in_addr vserver_addr)\n\n{\n\n    static int instance;\n\n    char smb_conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n", "idx": 4726}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "void bdrv_op_block(BlockDriverState *bs, BlockOpType op, Error *reason)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n\n\n    blocker = g_malloc0(sizeof(BdrvOpBlocker));\n\n    blocker->reason = reason;\n\n    QLIST_INSERT_HEAD(&bs->op_blockers[op], blocker, list);\n\n}\n", "idx": 2146}
{"project": "qemu", "commit_id": "854e67fea6a6f181163a5467fc9ba04de8d181bb", "target": 1, "func": "void hmp_info_tlb(Monitor *mon, const QDict *qdict)\n\n{\n\n    CPUArchState *env1 = mon_get_cpu_env();\n\n\n\n\n\n\n\n    dump_mmu((FILE*)mon, (fprintf_function)monitor_printf, env1);\n", "idx": 1999}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static int ram_find_and_save_block(RAMState *rs, bool last_stage)\n\n{\n\n    PageSearchStatus pss;\n\n    int pages = 0;\n\n    bool again, found;\n\n    ram_addr_t dirty_ram_abs; /* Address of the start of the dirty page in\n\n                                 ram_addr_t space */\n\n\n\n    /* No dirty page as there is zero RAM */\n\n    if (!ram_bytes_total()) {\n\n        return pages;\n\n    }\n\n\n\n    pss.block = rs->last_seen_block;\n\n    pss.offset = rs->last_offset;\n\n    pss.complete_round = false;\n\n\n\n    if (!pss.block) {\n\n        pss.block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n    }\n\n\n\n    do {\n\n        again = true;\n\n        found = get_queued_page(rs, &pss, &dirty_ram_abs);\n\n\n\n        if (!found) {\n\n            /* priority queue empty, so just search for something dirty */\n\n            found = find_dirty_block(rs, &pss, &again, &dirty_ram_abs);\n\n        }\n\n\n\n        if (found) {\n\n            pages = ram_save_host_page(rs, &pss, last_stage, dirty_ram_abs);\n\n        }\n\n    } while (!pages && again);\n\n\n\n    rs->last_seen_block = pss.block;\n\n    rs->last_offset = pss.offset;\n\n\n\n    return pages;\n\n}\n", "idx": 2149}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,\n\n                             hwaddr paddr, MemTxAttrs attrs, int prot,\n\n                             int mmu_idx, target_ulong size)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    hwaddr iotlb, xlat, sz;\n\n    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;\n\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n\n\n\n    assert_cpu_is_self(cpu);\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n\n\n    sz = size;\n\n    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);\n\n    assert(sz >= TARGET_PAGE_SIZE);\n\n\n\n    tlb_debug(\"vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n              \" prot=%x idx=%d\\n\",\n\n              vaddr, paddr, prot, mmu_idx);\n\n\n\n    address = vaddr;\n\n    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {\n\n        /* IO memory case */\n\n        address |= TLB_MMIO;\n\n        addend = 0;\n\n    } else {\n\n        /* TLB_MMIO for rom/romd handled below */\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n\n                                            prot, &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    te = &env->tlb_table[mmu_idx][index];\n\n\n\n    /* do not discard the translation in te, evict it into a victim tlb */\n\n    env->tlb_v_table[mmu_idx][vidx] = *te;\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n\n\n    /* refill the tlb */\n\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && cpu_physical_memory_is_clean(\n\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 1572}
{"project": "qemu", "commit_id": "67c4c2bd958b0074ffbcde12cb434cd064adab12", "target": 1, "func": "static void vnc_display_close(VncDisplay *vs)\n\n{\n\n    if (!vs)\n\n        return;\n\n    vs->enabled = false;\n\n    vs->is_unix = false;\n\n    if (vs->lsock != NULL) {\n\n        if (vs->lsock_tag) {\n\n            g_source_remove(vs->lsock_tag);\n\n        }\n\n        object_unref(OBJECT(vs->lsock));\n\n        vs->lsock = NULL;\n\n    }\n\n    vs->ws_enabled = false;\n\n    if (vs->lwebsock != NULL) {\n\n        if (vs->lwebsock_tag) {\n\n            g_source_remove(vs->lwebsock_tag);\n\n        }\n\n        object_unref(OBJECT(vs->lwebsock));\n\n        vs->lwebsock = NULL;\n\n    }\n\n    vs->auth = VNC_AUTH_INVALID;\n\n    vs->subauth = VNC_AUTH_INVALID;\n\n    if (vs->tlscreds) {\n\n        object_unparent(OBJECT(vs->tlscreds));\n\n\n    }\n\n    g_free(vs->tlsaclname);\n\n    vs->tlsaclname = NULL;\n\n}", "idx": 7540}
{"project": "qemu", "commit_id": "2a633c461e96cb9a856292c46917653bd43959c8", "target": 1, "func": "static int virtio_blk_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n\n\n    if (version_id != 2)\n\n        return -EINVAL;\n\n\n\n    virtio_load(&s->vdev, f);\n\n    while (qemu_get_sbyte(f)) {\n\n        VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n        qemu_get_buffer(f, (unsigned char*)&req->elem, sizeof(req->elem));\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n\n\n        virtqueue_map_sg(req->elem.in_sg, req->elem.in_addr,\n\n            req->elem.in_num, 1);\n\n        virtqueue_map_sg(req->elem.out_sg, req->elem.out_addr,\n\n            req->elem.out_num, 0);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 8342}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_kbd_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    ADBDeviceClass *adc = ADB_DEVICE_CLASS(oc);\n\n    ADBKeyboardClass *akc = ADB_KEYBOARD_CLASS(oc);\n\n\n\n    akc->parent_realize = dc->realize;\n\n    dc->realize = adb_kbd_realizefn;\n\n    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);\n\n\n\n    adc->devreq = adb_kbd_request;\n\n    dc->reset = adb_kbd_reset;\n\n    dc->vmsd = &vmstate_adb_kbd;\n\n}\n", "idx": 10242}
{"project": "qemu", "commit_id": "1d5bf692e55ae22b59083741d521e27db704846d", "target": 1, "func": "static void vfio_listener_region_del(MemoryListener *listener,\n\n                                     MemoryRegionSection *section)\n\n{\n\n    VFIOContainer *container = container_of(listener, VFIOContainer,\n\n                                            iommu_data.listener);\n\n    hwaddr iova, end;\n\n    int ret;\n\n\n\n    if (vfio_listener_skipped_section(section)) {\n\n        DPRINTF(\"SKIPPING region_del %\"HWADDR_PRIx\" - %\"PRIx64\"\\n\",\n\n                section->offset_within_address_space,\n\n                section->offset_within_address_space + section->size - 1);\n\n        return;\n\n    }\n\n\n\n    if (unlikely((section->offset_within_address_space & ~TARGET_PAGE_MASK) !=\n\n                 (section->offset_within_region & ~TARGET_PAGE_MASK))) {\n\n        error_report(\"%s received unaligned region\", __func__);\n\n        return;\n\n    }\n\n\n\n    iova = TARGET_PAGE_ALIGN(section->offset_within_address_space);\n\n    end = (section->offset_within_address_space + int128_get64(section->size)) &\n\n          TARGET_PAGE_MASK;\n\n\n\n    if (iova >= end) {\n\n        return;\n\n    }\n\n\n\n    DPRINTF(\"region_del %\"HWADDR_PRIx\" - %\"HWADDR_PRIx\"\\n\",\n\n            iova, end - 1);\n\n\n\n    ret = vfio_dma_unmap(container, iova, end - iova);\n\n    memory_region_unref(section->mr);\n\n    if (ret) {\n\n        error_report(\"vfio_dma_unmap(%p, 0x%\"HWADDR_PRIx\", \"\n\n                     \"0x%\"HWADDR_PRIx\") = %d (%m)\",\n\n                     container, iova, end - iova, ret);\n\n    }\n\n}\n", "idx": 4321}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7941}
{"project": "qemu", "commit_id": "e2dd21e510ed66daeb4c5d58638450c1fb8c6fea", "target": 1, "func": "static void wait_for_serial(const char *side)\n\n{\n\n    char *serialpath = g_strdup_printf(\"%s/%s\", tmpfs, side);\n\n    FILE *serialfile = fopen(serialpath, \"r\");\n\n    const char *arch = qtest_get_arch();\n\n    int started = (strcmp(side, \"src_serial\") == 0 &&\n\n                   strcmp(arch, \"ppc64\") == 0) ? 0 : 1;\n\n\n\n    do {\n\n        int readvalue = fgetc(serialfile);\n\n\n\n        if (!started) {\n\n            /* SLOF prints its banner before starting test,\n\n             * to ignore it, mark the start of the test with '_',\n\n             * ignore all characters until this marker\n\n             */\n\n            switch (readvalue) {\n\n            case '_':\n\n                started = 1;\n\n                break;\n\n            case EOF:\n\n                fseek(serialfile, 0, SEEK_SET);\n\n                usleep(1000);\n\n                break;\n\n            }\n\n            continue;\n\n        }\n\n        switch (readvalue) {\n\n        case 'A':\n\n            /* Fine */\n\n            break;\n\n\n\n        case 'B':\n\n            /* It's alive! */\n\n            fclose(serialfile);\n\n            g_free(serialpath);\n\n            return;\n\n\n\n        case EOF:\n\n            started = (strcmp(side, \"src_serial\") == 0 &&\n\n                       strcmp(arch, \"ppc64\") == 0) ? 0 : 1;\n\n            fseek(serialfile, 0, SEEK_SET);\n\n            usleep(1000);\n\n            break;\n\n\n\n        default:\n\n            fprintf(stderr, \"Unexpected %d on %s serial\\n\", readvalue, side);\n\n            g_assert_not_reached();\n\n        }\n\n    } while (true);\n\n}\n", "idx": 4830}
{"project": "qemu", "commit_id": "69ef1f36b0f882fc5ba9491fb272fa5f83ac1d3d", "target": 1, "func": "void qmp_migrate_set_parameters(bool has_compress_level,\n\n                                int64_t compress_level,\n\n                                bool has_compress_threads,\n\n                                int64_t compress_threads,\n\n                                bool has_decompress_threads,\n\n                                int64_t decompress_threads,\n\n                                bool has_cpu_throttle_initial,\n\n                                int64_t cpu_throttle_initial,\n\n                                bool has_cpu_throttle_increment,\n\n                                int64_t cpu_throttle_increment,\n\n\n\n\n\n                                Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    if (has_compress_level && (compress_level < 0 || compress_level > 9)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"compress_level\",\n\n                   \"is invalid, it should be in the range of 0 to 9\");\n\n        return;\n\n    }\n\n    if (has_compress_threads &&\n\n            (compress_threads < 1 || compress_threads > 255)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"compress_threads\",\n\n                   \"is invalid, it should be in the range of 1 to 255\");\n\n        return;\n\n    }\n\n    if (has_decompress_threads &&\n\n            (decompress_threads < 1 || decompress_threads > 255)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"decompress_threads\",\n\n                   \"is invalid, it should be in the range of 1 to 255\");\n\n        return;\n\n    }\n\n    if (has_cpu_throttle_initial &&\n\n            (cpu_throttle_initial < 1 || cpu_throttle_initial > 99)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"cpu_throttle_initial\",\n\n                   \"an integer in the range of 1 to 99\");\n\n    }\n\n    if (has_cpu_throttle_increment &&\n\n            (cpu_throttle_increment < 1 || cpu_throttle_increment > 99)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"cpu_throttle_increment\",\n\n                   \"an integer in the range of 1 to 99\");\n\n    }\n\n\n\n    if (has_compress_level) {\n\n        s->parameters.compress_level = compress_level;\n\n    }\n\n    if (has_compress_threads) {\n\n        s->parameters.compress_threads = compress_threads;\n\n    }\n\n    if (has_decompress_threads) {\n\n        s->parameters.decompress_threads = decompress_threads;\n\n    }\n\n    if (has_cpu_throttle_initial) {\n\n        s->parameters.cpu_throttle_initial = cpu_throttle_initial;\n\n    }\n\n    if (has_cpu_throttle_increment) {\n\n        s->parameters.cpu_throttle_increment = cpu_throttle_increment;\n\n    }\n\n    if (has_tls_creds) {\n\n        g_free(s->parameters.tls_creds);\n\n        s->parameters.tls_creds = g_strdup(tls_creds);\n\n    }\n\n    if (has_tls_hostname) {\n\n        g_free(s->parameters.tls_hostname);\n\n        s->parameters.tls_hostname = g_strdup(tls_hostname);\n\n    }\n\n}", "idx": 5959}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_flash_write(void *opaque, hwaddr addr,\n\n                               uint64_t val, unsigned size)\n\n{\n\n}\n", "idx": 5940}
{"project": "qemu", "commit_id": "244381ec19ce1412b474f41b5f30fe1da846451b", "target": 1, "func": "static ssize_t gem_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    CadenceGEMState *s;\n\n    unsigned   rxbufsize, bytes_to_copy;\n\n    unsigned   rxbuf_offset;\n\n    uint8_t    rxbuf[2048];\n\n    uint8_t   *rxbuf_ptr;\n\n    bool first_desc = true;\n\n    int maf;\n\n\n\n    s = qemu_get_nic_opaque(nc);\n\n\n\n    /* Is this destination MAC address \"for us\" ? */\n\n    maf = gem_mac_address_filter(s, buf);\n\n    if (maf == GEM_RX_REJECT) {\n\n        return -1;\n\n\n\n\n    /* Discard packets with receive length error enabled ? */\n\n    if (s->regs[GEM_NWCFG] & GEM_NWCFG_LERR_DISC) {\n\n        unsigned type_len;\n\n\n\n        /* Fish the ethertype / length field out of the RX packet */\n\n        type_len = buf[12] << 8 | buf[13];\n\n        /* It is a length field, not an ethertype */\n\n        if (type_len < 0x600) {\n\n            if (size < type_len) {\n\n                /* discard */\n\n                return -1;\n\n\n\n\n\n\n    /*\n\n     * Determine configured receive buffer offset (probably 0)\n\n     */\n\n    rxbuf_offset = (s->regs[GEM_NWCFG] & GEM_NWCFG_BUFF_OFST_M) >>\n\n                   GEM_NWCFG_BUFF_OFST_S;\n\n\n\n    /* The configure size of each receive buffer.  Determines how many\n\n     * buffers needed to hold this packet.\n\n     */\n\n    rxbufsize = ((s->regs[GEM_DMACFG] & GEM_DMACFG_RBUFSZ_M) >>\n\n                 GEM_DMACFG_RBUFSZ_S) * GEM_DMACFG_RBUFSZ_MUL;\n\n\n\n\n    /* Pad to minimum length. Assume FCS field is stripped, logic\n\n     * below will increment it to the real minimum of 64 when\n\n     * not FCS stripping\n\n     */\n\n    if (size < 60) {\n\n        size = 60;\n\n\n\n\n    /* Strip of FCS field ? (usually yes) */\n\n    if (s->regs[GEM_NWCFG] & GEM_NWCFG_STRIP_FCS) {\n\n        rxbuf_ptr = (void *)buf;\n\n    } else {\n\n        unsigned crc_val;\n\n\n\n\n\n\n\n        /* The application wants the FCS field, which QEMU does not provide.\n\n         * We must try and calculate one.\n\n         */\n\n\n\n        memcpy(rxbuf, buf, size);\n\n        memset(rxbuf + size, 0, sizeof(rxbuf) - size);\n\n        rxbuf_ptr = rxbuf;\n\n        crc_val = cpu_to_le32(crc32(0, rxbuf, MAX(size, 60)));\n\n        memcpy(rxbuf + size, &crc_val, sizeof(crc_val));\n\n\n\n        bytes_to_copy += 4;\n\n        size += 4;\n\n\n\n\n    DB_PRINT(\"config bufsize: %d packet size: %ld\\n\", rxbufsize, size);\n\n\n\n    while (bytes_to_copy) {\n\n        /* Do nothing if receive is not enabled. */\n\n        if (!gem_can_receive(nc)) {\n\n            assert(!first_desc);\n\n            return -1;\n\n\n\n\n        DB_PRINT(\"copy %d bytes to 0x%x\\n\", MIN(bytes_to_copy, rxbufsize),\n\n                rx_desc_get_buffer(s->rx_desc));\n\n\n\n        /* Copy packet data to emulated DMA buffer */\n\n        cpu_physical_memory_write(rx_desc_get_buffer(s->rx_desc) + rxbuf_offset,\n\n                                  rxbuf_ptr, MIN(bytes_to_copy, rxbufsize));\n\n        rxbuf_ptr += MIN(bytes_to_copy, rxbufsize);\n\n        bytes_to_copy -= MIN(bytes_to_copy, rxbufsize);\n\n\n\n        /* Update the descriptor.  */\n\n        if (first_desc) {\n\n            rx_desc_set_sof(s->rx_desc);\n\n            first_desc = false;\n\n\n        if (bytes_to_copy == 0) {\n\n            rx_desc_set_eof(s->rx_desc);\n\n            rx_desc_set_length(s->rx_desc, size);\n\n\n        rx_desc_set_ownership(s->rx_desc);\n\n\n\n        switch (maf) {\n\n        case GEM_RX_PROMISCUOUS_ACCEPT:\n\n            break;\n\n        case GEM_RX_BROADCAST_ACCEPT:\n\n            rx_desc_set_broadcast(s->rx_desc);\n\n            break;\n\n        case GEM_RX_UNICAST_HASH_ACCEPT:\n\n            rx_desc_set_unicast_hash(s->rx_desc);\n\n            break;\n\n        case GEM_RX_MULTICAST_HASH_ACCEPT:\n\n            rx_desc_set_multicast_hash(s->rx_desc);\n\n            break;\n\n        case GEM_RX_REJECT:\n\n            abort();\n\n        default: /* SAR */\n\n            rx_desc_set_sar(s->rx_desc, maf);\n\n\n\n\n        /* Descriptor write-back.  */\n\n        cpu_physical_memory_write(s->rx_desc_addr,\n\n                                  (uint8_t *)s->rx_desc, sizeof(s->rx_desc));\n\n\n\n        /* Next descriptor */\n\n        if (rx_desc_get_wrap(s->rx_desc)) {\n\n            DB_PRINT(\"wrapping RX descriptor list\\n\");\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        } else {\n\n            DB_PRINT(\"incrementing RX descriptor list\\n\");\n\n            s->rx_desc_addr += 8;\n\n\n        gem_get_rx_desc(s);\n\n\n\n\n    /* Count it */\n\n    gem_receive_updatestats(s, buf, size);\n\n\n\n    s->regs[GEM_RXSTATUS] |= GEM_RXSTATUS_FRMRCVD;\n\n    s->regs[GEM_ISR] |= GEM_INT_RXCMPL & ~(s->regs[GEM_IMR]);\n\n\n\n    /* Handle interrupt consequences */\n\n    gem_update_int_status(s);\n\n\n\n    return size;\n", "idx": 3166}
{"project": "qemu", "commit_id": "75b0713e189a981e5bfd087d5f35705446bbb12a", "target": 1, "func": "static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets,\n\n                              GArray *table_data, BIOSLinker *linker)\n\n{\n\n    GArray *structures = nvdimm_build_device_structure(device_list);\n\n    unsigned int header;\n\n\n\n    acpi_add_table(table_offsets, table_data);\n\n\n\n    /* NFIT header. */\n\n    header = table_data->len;\n\n    acpi_data_push(table_data, sizeof(NvdimmNfitHeader));\n\n    /* NVDIMM device structures. */\n\n    g_array_append_vals(table_data, structures->data, structures->len);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + header), \"NFIT\",\n\n                 sizeof(NvdimmNfitHeader) + structures->len, 1, NULL, NULL);\n\n    g_array_free(structures, true);\n\n}\n", "idx": 9900}
{"project": "qemu", "commit_id": "630530a6529bc3da9ab8aead7053dc753cb9ac77", "target": 1, "func": "static int vmdk_write(BlockDriverState *bs, int64_t sector_num, \n\n                     const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    int index_in_cluster, n;\n\n    uint64_t cluster_offset;\n\n    static int cid_update = 0;\n\n\n\n    while (nb_sectors > 0) {\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors)\n\n            n = nb_sectors;\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9, 1);\n\n        if (!cluster_offset)\n\n            return -1;\n\n        if (bdrv_pwrite(s->hd, cluster_offset + index_in_cluster * 512, buf, n * 512) != n * 512)\n\n            return -1;\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n\n\n        // update CID on the first write every time the virtual disk is opened\n\n        if (!cid_update) {\n\n            vmdk_write_cid(bs, time(NULL));\n\n            cid_update++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6309}
{"project": "qemu", "commit_id": "366d4f7e0007a5540897fbac6e377c57d8c79a73", "target": 1, "func": "static uint64_t cg3_reg_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n    CG3State *s = opaque;\n\n    int val;\n\n\n\n    switch (addr) {\n\n    case CG3_REG_BT458_ADDR:\n\n    case CG3_REG_BT458_COLMAP:\n\n        val = 0;\n\n        break;\n\n    case CG3_REG_FBC_CTRL:\n\n        val = s->regs[0];\n\n        break;\n\n    case CG3_REG_FBC_STATUS:\n\n        /* monitor ID 6, board type = 1 (color) */\n\n        val = s->regs[1] | CG3_SR_1152_900_76_B | CG3_SR_ID_COLOR;\n\n        break;\n\n    case CG3_REG_FBC_CURSTART ... CG3_REG_SIZE:\n\n        val = s->regs[addr - 0x10];\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP,\n\n                  \"cg3: Unimplemented register read \"\n\n                  \"reg 0x%\" HWADDR_PRIx \" size 0x%x\\n\",\n\n                  addr, size);\n\n        val = 0;\n\n        break;\n\n    }\n\n    DPRINTF(\"read %02x from reg %\" HWADDR_PRIx \"\\n\", val, addr);\n\n    return val;\n\n}\n", "idx": 84}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void object_get_link_property(Object *obj, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Object **child = opaque;\n\n    gchar *path;\n\n\n\n    if (*child) {\n\n        path = object_get_canonical_path(*child);\n\n        visit_type_str(v, &path, name, errp);\n\n        g_free(path);\n\n    } else {\n\n        path = (gchar *)\"\";\n\n        visit_type_str(v, &path, name, errp);\n\n    }\n\n}\n", "idx": 5967}
{"project": "qemu", "commit_id": "9877860e7bd1e26ee70ab9bb5ebc34c92bf23bf5", "target": 1, "func": "static int vmdk_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    char *buf;\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    uint32_t magic;\n\n    Error *local_err = NULL;\n\n\n\n    bs->file = bdrv_open_child(NULL, options, \"file\", bs, &child_file,\n\n                               false, errp);\n\n    if (!bs->file) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf = vmdk_read_desc(bs->file, 0, errp);\n\n    if (!buf) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    magic = ldl_be_p(buf);\n\n    switch (magic) {\n\n        case VMDK3_MAGIC:\n\n        case VMDK4_MAGIC:\n\n            ret = vmdk_open_sparse(bs, bs->file, flags, buf, options,\n\n                                   errp);\n\n            s->desc_offset = 0x200;\n\n            break;\n\n        default:\n\n            ret = vmdk_open_desc_file(bs, flags, buf, options, errp);\n\n            break;\n\n    }\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* try to open parent images, if exist */\n\n    ret = vmdk_parent_open(bs);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n    s->cid = vmdk_read_cid(bs, 0);\n\n    s->parent_cid = vmdk_read_cid(bs, 1);\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n    /* Disable migration when VMDK images are used */\n\n    error_setg(&s->migration_blocker, \"The vmdk format used by node '%s' \"\n\n               \"does not support live migration\",\n\n               bdrv_get_device_or_node_name(bs));\n\n    ret = migrate_add_blocker(s->migration_blocker, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        error_free(s->migration_blocker);\n\n        goto fail;\n\n    }\n\n\n\n    g_free(buf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(buf);\n\n    g_free(s->create_type);\n\n    s->create_type = NULL;\n\n    vmdk_free_extents(bs);\n\n    return ret;\n\n}\n", "idx": 11055}
{"project": "qemu", "commit_id": "57ee366ce9cf8d9f7a52b7b654b9db78fe887349", "target": 1, "func": "static void qemu_aio_complete(void *opaque, int ret)\n\n{\n\n    struct ioreq *ioreq = opaque;\n\n\n\n    if (ret != 0) {\n\n        xen_be_printf(&ioreq->blkdev->xendev, 0, \"%s I/O error\\n\",\n\n                      ioreq->req.operation == BLKIF_OP_READ ? \"read\" : \"write\");\n\n        ioreq->aio_errors++;\n\n    }\n\n\n\n    ioreq->aio_inflight--;\n\n    if (ioreq->presync) {\n\n        ioreq->presync = 0;\n\n        ioreq_runio_qemu_aio(ioreq);\n\n        return;\n\n    }\n\n    if (ioreq->aio_inflight > 0) {\n\n        return;\n\n    }\n\n    if (ioreq->postsync) {\n\n        ioreq->postsync = 0;\n\n        ioreq->aio_inflight++;\n\n        blk_aio_flush(ioreq->blkdev->blk, qemu_aio_complete, ioreq);\n\n        return;\n\n    }\n\n\n\n    ioreq->status = ioreq->aio_errors ? BLKIF_RSP_ERROR : BLKIF_RSP_OKAY;\n\n    ioreq_unmap(ioreq);\n\n    ioreq_finish(ioreq);\n\n    switch (ioreq->req.operation) {\n\n    case BLKIF_OP_WRITE:\n\n    case BLKIF_OP_FLUSH_DISKCACHE:\n\n        if (!ioreq->req.nr_segments) {\n\n            break;\n\n        }\n\n    case BLKIF_OP_READ:\n\n        block_acct_done(blk_get_stats(ioreq->blkdev->blk), &ioreq->acct);\n\n        break;\n\n    case BLKIF_OP_DISCARD:\n\n    default:\n\n        break;\n\n    }\n\n    qemu_bh_schedule(ioreq->blkdev->bh);\n\n}\n", "idx": 11959}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void mcf5208evb_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    M68kCPU *cpu;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    hwaddr entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"m5208\";\n\n    }\n\n    cpu = M68K_CPU(cpu_generic_init(TYPE_M68K_CPU, cpu_model));\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mcf5208.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, NULL, \"mcf5208.sram\", 16384, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, cpu);\n\n\n\n    mcf_uart_mm_init(0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used) {\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n    }\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        if (qtest_enabled()) {\n\n            return;\n\n        }\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, EM_68K, 0, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n\n                                  NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 11074}
{"project": "qemu", "commit_id": "2aaa1940684a3bf2b381fd2a8ff26c287a05109d", "target": 1, "func": "static uint32_t cc_calc_abs_64(int64_t dst)\n\n{\n\n    if ((uint64_t)dst == 0x8000000000000000ULL) {\n\n        return 3;\n\n    } else if (dst) {\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 5255}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_test_cc(int cc, int label)\n\n{\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n    int inv;\n\n\n\n    switch (cc) {\n\n    case 0: /* eq: Z */\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        break;\n\n    case 1: /* ne: !Z */\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, label);\n\n        break;\n\n    case 2: /* cs: C */\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, label);\n\n        break;\n\n    case 3: /* cc: !C */\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        break;\n\n    case 4: /* mi: N */\n\n        tmp = load_cpu_field(NF);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    case 5: /* pl: !N */\n\n        tmp = load_cpu_field(NF);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        break;\n\n    case 6: /* vs: V */\n\n        tmp = load_cpu_field(VF);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    case 7: /* vc: !V */\n\n        tmp = load_cpu_field(VF);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        break;\n\n    case 8: /* hi: C && !Z */\n\n        inv = gen_new_label();\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, inv);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, label);\n\n        gen_set_label(inv);\n\n        break;\n\n    case 9: /* ls: !C || Z */\n\n        tmp = load_cpu_field(CF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        break;\n\n    case 10: /* ge: N == V -> N ^ V == 0 */\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        break;\n\n    case 11: /* lt: N != V -> N ^ V != 0 */\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    case 12: /* gt: !Z && N == V */\n\n        inv = gen_new_label();\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, inv);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_GE, tmp, 0, label);\n\n        gen_set_label(inv);\n\n        break;\n\n    case 13: /* le: Z || N != V */\n\n        tmp = load_cpu_field(ZF);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, label);\n\n        dead_tmp(tmp);\n\n        tmp = load_cpu_field(VF);\n\n        tmp2 = load_cpu_field(NF);\n\n        tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcondi_i32(TCG_COND_LT, tmp, 0, label);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"Bad condition code 0x%x\\n\", cc);\n\n        abort();\n\n    }\n\n    dead_tmp(tmp);\n\n}\n", "idx": 3900}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static ssize_t socket_writev_buffer(void *opaque, struct iovec *iov, int iovcnt,\n\n                                    int64_t pos)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n    ssize_t size = iov_size(iov, iovcnt);\n\n\n\n    len = iov_send(s->fd, iov, iovcnt, 0, size);\n\n    if (len < size) {\n\n        len = -socket_error();\n\n    }\n\n    return len;\n\n}\n", "idx": 5126}
{"project": "qemu", "commit_id": "3debbb5af5f63440b170b71bf3aecc0e778f5691", "target": 1, "func": "target_ulong helper_msub32_suov(CPUTriCoreState *env, target_ulong r1,\n\n                                target_ulong r2, target_ulong r3)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t t3 = extract64(r3, 0, 32);\n\n    int64_t result;\n\n\n\n    result = t2 - (t1 * t3);\n\n    return suov32_neg(env, result);\n\n}\n", "idx": 10236}
{"project": "qemu", "commit_id": "2f78e491d7b46542158ce0b8132ee4e05bc0ade4", "target": 1, "func": "AioContext *aio_context_new(void)\n\n{\n\n    AioContext *ctx;\n\n    ctx = (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n    ctx->pollfds = g_array_new(FALSE, FALSE, sizeof(GPollFD));\n\n    ctx->thread_pool = NULL;\n\n    qemu_mutex_init(&ctx->bh_lock);\n\n    rfifolock_init(&ctx->lock, aio_rfifolock_cb, ctx);\n\n    event_notifier_init(&ctx->notifier, false);\n\n    aio_set_event_notifier(ctx, &ctx->notifier, \n\n                           (EventNotifierHandler *)\n\n                           event_notifier_test_and_clear);\n\n    timerlistgroup_init(&ctx->tlg, aio_timerlist_notify, ctx);\n\n\n\n    return ctx;\n\n}\n", "idx": 1271}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 1049}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void fd_start_outgoing_migration(MigrationState *s, const char *fdname, Error **errp)\n\n{\n\n    int fd = monitor_get_fd(cur_mon, fdname, errp);\n\n    if (fd == -1) {\n\n        return;\n\n    }\n\n    s->file = qemu_fdopen(fd, \"wb\");\n\n\n\n    migrate_fd_connect(s);\n\n}\n", "idx": 10723}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 5114}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static void spr_write_hdecr(DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_hdecr(cpu_env, cpu_gpr[gprn]);\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 9910}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 10579}
{"project": "qemu", "commit_id": "aef4acb6616ab7fb5c105660aa8a2cee4e250e75", "target": 1, "func": "static int copy_sectors(BlockDriverState *bs, uint64_t start_sect,\n\n                        uint64_t cluster_offset, int n_start, int n_end)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int n, ret;\n\n    void *buf;\n\n\n\n    /*\n\n     * If this is the last cluster and it is only partially used, we must only\n\n     * copy until the end of the image, or bdrv_check_request will fail for the\n\n     * bdrv_read/write calls below.\n\n     */\n\n    if (start_sect + n_end > bs->total_sectors) {\n\n        n_end = bs->total_sectors - start_sect;\n\n    }\n\n\n\n    n = n_end - n_start;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, n * BDRV_SECTOR_SIZE);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_READ);\n\n    ret = bdrv_read(bs, start_sect + n_start, buf, n);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (s->crypt_method) {\n\n        qcow2_encrypt_sectors(s, start_sect + n_start,\n\n                        buf, buf, n, 1,\n\n                        &s->aes_encrypt_key);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_WRITE);\n\n    ret = bdrv_write(bs->file, (cluster_offset >> 9) + n_start, buf, n);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    qemu_vfree(buf);\n\n    return ret;\n\n}\n", "idx": 2712}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "int bdrv_all_find_snapshot(const char *name, BlockDriverState **first_bad_bs)\n\n{\n\n    QEMUSnapshotInfo sn;\n\n    int err = 0;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while (err == 0 && (it = bdrv_next(it, &bs))) {\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            err = bdrv_snapshot_find(bs, &sn, name);\n\n        }\n\n        aio_context_release(ctx);\n\n    }\n\n\n\n    *first_bad_bs = bs;\n\n    return err;\n\n}\n", "idx": 4027}
{"project": "qemu", "commit_id": "2f6f826e03e09eb3b65b3a764580d66b857e3a23", "target": 1, "func": "MemdevList *qmp_query_memdev(Error **errp)\n\n{\n\n    Object *obj;\n\n    MemdevList *list = NULL;\n\n\n\n    obj = object_get_objects_root();\n\n    if (obj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_child_foreach(obj, query_memdev, &list) != 0) {\n\n        goto error;\n\n    }\n\n\n\n    return list;\n\n\n\nerror:\n\n    qapi_free_MemdevList(list);\n\n    return NULL;\n\n}\n", "idx": 10408}
{"project": "qemu", "commit_id": "d71cdbfd540d91a6ae0005e59abfd782c424b07a", "target": 1, "func": "static void leon3_generic_hw_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState   *env;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *prom = g_new(MemoryRegion, 1);\n\n    int         ret;\n\n    char       *filename;\n\n    qemu_irq   *cpu_irqs = NULL;\n\n    int         bios_size;\n\n    int         prom_size;\n\n    ResetData  *reset_info;\n\n\n\n    /* Init CPU */\n\n    if (!cpu_model) {\n\n        cpu_model = \"LEON3\";\n\n    }\n\n\n\n    cpu = cpu_sparc_init(cpu_model);\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, 0);\n\n\n\n    /* Reset data */\n\n    reset_info        = g_malloc0(sizeof(ResetData));\n\n    reset_info->cpu   = cpu;\n\n    reset_info->sp    = 0x40000000 + ram_size;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n\n\n    /* Allocate IRQ manager */\n\n    grlib_irqmp_create(0x80000200, env, &cpu_irqs, MAX_PILS, &leon3_set_pil_in);\n\n\n\n    env->qemu_irq_ack = leon3_irq_manager;\n\n\n\n    /* Allocate RAM */\n\n    if ((uint64_t)ram_size > (1UL << 30)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum 1G\\n\",\n\n                (unsigned int)(ram_size / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(ram, NULL, \"leon3.ram\", ram_size, &error_abort);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Allocate BIOS */\n\n    prom_size = 8 * 1024 * 1024; /* 8Mb */\n\n    memory_region_init_ram(prom, NULL, \"Leon3.bios\", prom_size, &error_abort);\n\n    vmstate_register_ram_global(prom);\n\n    memory_region_set_readonly(prom, true);\n\n    memory_region_add_subregion(address_space_mem, 0x00000000, prom);\n\n\n\n    /* Load boot prom */\n\n    if (bios_name == NULL) {\n\n        bios_name = PROM_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    bios_size = get_image_size(filename);\n\n\n\n    if (bios_size > prom_size) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s': file too big\\n\",\n\n                filename);\n\n        exit(1);\n\n    }\n\n\n\n    if (bios_size > 0) {\n\n        ret = load_image_targphys(filename, 0x00000000, bios_size);\n\n        if (ret < 0 || ret > prom_size) {\n\n            fprintf(stderr, \"qemu: could not load prom '%s'\\n\", filename);\n\n            exit(1);\n\n        }\n\n    } else if (kernel_filename == NULL && !qtest_enabled()) {\n\n        fprintf(stderr, \"Can't read bios image %s\\n\", filename);\n\n        exit(1);\n\n    }\n\n\n\n\n    /* Can directly load an application. */\n\n    if (kernel_filename != NULL) {\n\n        long     kernel_size;\n\n        uint64_t entry;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1 /* big endian */, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        if (bios_size <= 0) {\n\n            /* If there is no bios/monitor, start the application.  */\n\n            env->pc = entry;\n\n            env->npc = entry + 4;\n\n            reset_info->entry = entry;\n\n        }\n\n    }\n\n\n\n    /* Allocate timers */\n\n    grlib_gptimer_create(0x80000300, 2, CPU_CLK, cpu_irqs, 6);\n\n\n\n    /* Allocate uart */\n\n    if (serial_hds[0]) {\n\n        grlib_apbuart_create(0x80000100, serial_hds[0], cpu_irqs[3]);\n\n    }\n\n}", "idx": 2435}
{"project": "qemu", "commit_id": "4118a97030aa9bd1d520d1d06bbe0655d829df04", "target": 1, "func": "long target_mmap(target_ulong start, target_ulong len, int prot,\n\n                 int flags, int fd, target_ulong offset)\n\n{\n\n    target_ulong ret, end, real_start, real_end, retaddr, host_offset, host_len;\n\n    long host_start;\n\n#if defined(__alpha__) || defined(__sparc__) || defined(__x86_64__) || \\\n\n        defined(__ia64) || defined(__mips__)\n\n    static target_ulong last_start = 0x40000000;\n\n#elif defined(__CYGWIN__)\n\n    /* Cygwin doesn't have a whole lot of address space.  */\n\n    static target_ulong last_start = 0x18000000;\n\n#endif\n\n\n\n#ifdef DEBUG_MMAP\n\n    {\n\n        printf(\"mmap: start=0x%lx len=0x%lx prot=%c%c%c flags=\",\n\n               start, len,\n\n               prot & PROT_READ ? 'r' : '-',\n\n               prot & PROT_WRITE ? 'w' : '-',\n\n               prot & PROT_EXEC ? 'x' : '-');\n\n        if (flags & MAP_FIXED)\n\n            printf(\"MAP_FIXED \");\n\n        if (flags & MAP_ANONYMOUS)\n\n            printf(\"MAP_ANON \");\n\n        switch(flags & MAP_TYPE) {\n\n        case MAP_PRIVATE:\n\n            printf(\"MAP_PRIVATE \");\n\n            break;\n\n        case MAP_SHARED:\n\n            printf(\"MAP_SHARED \");\n\n            break;\n\n        default:\n\n            printf(\"[MAP_TYPE=0x%x] \", flags & MAP_TYPE);\n\n            break;\n\n        }\n\n        printf(\"fd=%d offset=%lx\\n\", fd, offset);\n\n    }\n\n#endif\n\n\n\n    if (offset & ~TARGET_PAGE_MASK) {\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    len = TARGET_PAGE_ALIGN(len);\n\n    if (len == 0)\n\n        return start;\n\n    real_start = start & qemu_host_page_mask;\n\n\n\n    if (!(flags & MAP_FIXED)) {\n\n#if defined(__alpha__) || defined(__sparc__) || defined(__x86_64__) || \\\n\n    defined(__ia64) || defined(__mips__) || defined(__CYGWIN__)\n\n        /* tell the kernel to search at the same place as i386 */\n\n        if (real_start == 0) {\n\n            real_start = last_start;\n\n            last_start += HOST_PAGE_ALIGN(len);\n\n        }\n\n#endif\n\n        if (0 && qemu_host_page_size != qemu_real_host_page_size) {\n\n            /* NOTE: this code is only for debugging with '-p' option */\n\n            /* ??? Can also occur when TARGET_PAGE_SIZE > host page size.  */\n\n            /* reserve a memory area */\n\n            /* ??? This needs fixing for remapping.  */\n\nabort();\n\n            host_len = HOST_PAGE_ALIGN(len) + qemu_host_page_size - TARGET_PAGE_SIZE;\n\n            real_start = (long)mmap(g2h(real_start), host_len, PROT_NONE,\n\n                                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n            if (real_start == -1)\n\n                return real_start;\n\n            real_end = real_start + host_len;\n\n            start = HOST_PAGE_ALIGN(real_start);\n\n            end = start + HOST_PAGE_ALIGN(len);\n\n            if (start > real_start)\n\n                munmap((void *)real_start, start - real_start);\n\n            if (end < real_end)\n\n                munmap((void *)end, real_end - end);\n\n            /* use it as a fixed mapping */\n\n            flags |= MAP_FIXED;\n\n        } else {\n\n            /* if not fixed, no need to do anything */\n\n            host_offset = offset & qemu_host_page_mask;\n\n            host_len = len + offset - host_offset;\n\n            host_start = (long)mmap(real_start ? g2h(real_start) : NULL,\n\n                                    host_len, prot, flags, fd, host_offset);\n\n            if (host_start == -1)\n\n                return host_start;\n\n            /* update start so that it points to the file position at 'offset' */\n\n            if (!(flags & MAP_ANONYMOUS))\n\n                host_start += offset - host_offset;\n\n            start = h2g(host_start);\n\n            goto the_end1;\n\n        }\n\n    }\n\n\n\n    if (start & ~TARGET_PAGE_MASK) {\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    end = start + len;\n\n    real_end = HOST_PAGE_ALIGN(end);\n\n\n\n    /* worst case: we cannot map the file because the offset is not\n\n       aligned, so we read it */\n\n    if (!(flags & MAP_ANONYMOUS) &&\n\n        (offset & ~qemu_host_page_mask) != (start & ~qemu_host_page_mask)) {\n\n        /* msync() won't work here, so we return an error if write is\n\n           possible while it is a shared mapping */\n\n        if ((flags & MAP_TYPE) == MAP_SHARED &&\n\n            (prot & PROT_WRITE)) {\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        retaddr = target_mmap(start, len, prot | PROT_WRITE,\n\n                              MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,\n\n                              -1, 0);\n\n        if (retaddr == -1)\n\n            return retaddr;\n\n        pread(fd, g2h(start), len, offset);\n\n        if (!(prot & PROT_WRITE)) {\n\n            ret = target_mprotect(start, len, prot);\n\n            if (ret != 0)\n\n                return ret;\n\n        }\n\n        goto the_end;\n\n    }\n\n\n\n    /* handle the start of the mapping */\n\n    if (start > real_start) {\n\n        if (real_end == real_start + qemu_host_page_size) {\n\n            /* one single host page */\n\n            ret = mmap_frag(real_start, start, end,\n\n                            prot, flags, fd, offset);\n\n            if (ret == -1)\n\n                return ret;\n\n            goto the_end1;\n\n        }\n\n        ret = mmap_frag(real_start, start, real_start + qemu_host_page_size,\n\n                        prot, flags, fd, offset);\n\n        if (ret == -1)\n\n            return ret;\n\n        real_start += qemu_host_page_size;\n\n    }\n\n    /* handle the end of the mapping */\n\n    if (end < real_end) {\n\n        ret = mmap_frag(real_end - qemu_host_page_size,\n\n                        real_end - qemu_host_page_size, real_end,\n\n                        prot, flags, fd,\n\n                        offset + real_end - qemu_host_page_size - start);\n\n        if (ret == -1)\n\n            return ret;\n\n        real_end -= qemu_host_page_size;\n\n    }\n\n\n\n    /* map the middle (easier) */\n\n    if (real_start < real_end) {\n\n        unsigned long offset1;\n\n\tif (flags & MAP_ANONYMOUS)\n\n\t  offset1 = 0;\n\n\telse\n\n\t  offset1 = offset + real_start - start;\n\n        ret = (long)mmap(g2h(real_start), real_end - real_start,\n\n                         prot, flags, fd, offset1);\n\n        if (ret == -1)\n\n            return ret;\n\n    }\n\n the_end1:\n\n    page_set_flags(start, start + len, prot | PAGE_VALID);\n\n the_end:\n\n#ifdef DEBUG_MMAP\n\n    printf(\"ret=0x%lx\\n\", (long)start);\n\n    page_dump(stdout);\n\n    printf(\"\\n\");\n\n#endif\n\n    return start;\n\n}\n", "idx": 9007}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 12130}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_control_packet(void *priv, uint32_t id,\n\n    struct usb_redir_control_packet_header *control_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    int len = control_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"ctrl-in status %d len %d id %u\\n\", control_packet->status,\n\n            len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    aurb->control_packet.status = control_packet->status;\n\n    aurb->control_packet.length = control_packet->length;\n\n    if (memcmp(&aurb->control_packet, control_packet,\n\n               sizeof(*control_packet))) {\n\n        ERROR(\"return control packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, control_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"ctrl data in:\", data, data_len);\n\n            if (data_len <= sizeof(dev->dev.data_buf)) {\n\n                memcpy(dev->dev.data_buf, data, data_len);\n\n            } else {\n\n                ERROR(\"ctrl buffer too small (%d > %zu)\\n\",\n\n                      data_len, sizeof(dev->dev.data_buf));\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_generic_async_ctrl_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 425}
{"project": "qemu", "commit_id": "ab443475c9235822e329e1bfde89be6c71e2c21e", "target": 1, "func": "int kvm_arch_process_async_events(CPUState *env)\n{\n    if (kvm_irqchip_in_kernel()) {\n    if (env->interrupt_request & (CPU_INTERRUPT_HARD | CPU_INTERRUPT_NMI)) {\n    if (env->interrupt_request & CPU_INTERRUPT_INIT) {\n        do_cpu_init(env);\n    if (env->interrupt_request & CPU_INTERRUPT_SIPI) {\n        do_cpu_sipi(env);\n    return env->halted;", "idx": 1620}
{"project": "qemu", "commit_id": "b2b012afdd9c03ba8a1619f45301d34f358d367b", "target": 1, "func": "static void imx_eth_write(void *opaque, hwaddr offset, uint64_t value,\n\n                           unsigned size)\n\n{\n\n    IMXFECState *s = IMX_FEC(opaque);\n\n    uint32_t index = offset >> 2;\n\n\n\n    FEC_PRINTF(\"reg[%s] <= 0x%\" PRIx32 \"\\n\", imx_eth_reg_name(s, index),\n\n                (uint32_t)value);\n\n\n\n    switch (index) {\n\n    case ENET_EIR:\n\n        s->regs[index] &= ~value;\n\n        break;\n\n    case ENET_EIMR:\n\n        s->regs[index] = value;\n\n        break;\n\n    case ENET_RDAR:\n\n        if (s->regs[ENET_ECR] & ENET_ECR_ETHEREN) {\n\n            if (!s->regs[index]) {\n\n                s->regs[index] = ENET_RDAR_RDAR;\n\n                imx_eth_enable_rx(s);\n\n            }\n\n        } else {\n\n            s->regs[index] = 0;\n\n        }\n\n        break;\n\n    case ENET_TDAR:\n\n        if (s->regs[ENET_ECR] & ENET_ECR_ETHEREN) {\n\n            s->regs[index] = ENET_TDAR_TDAR;\n\n            imx_eth_do_tx(s);\n\n        }\n\n        s->regs[index] = 0;\n\n        break;\n\n    case ENET_ECR:\n\n        if (value & ENET_ECR_RESET) {\n\n            return imx_eth_reset(DEVICE(s));\n\n        }\n\n        s->regs[index] = value;\n\n        if ((s->regs[index] & ENET_ECR_ETHEREN) == 0) {\n\n            s->regs[ENET_RDAR] = 0;\n\n            s->rx_descriptor = s->regs[ENET_RDSR];\n\n            s->regs[ENET_TDAR] = 0;\n\n            s->tx_descriptor = s->regs[ENET_TDSR];\n\n        }\n\n        break;\n\n    case ENET_MMFR:\n\n        s->regs[index] = value;\n\n        if (extract32(value, 29, 1)) {\n\n            /* This is a read operation */\n\n            s->regs[ENET_MMFR] = deposit32(s->regs[ENET_MMFR], 0, 16,\n\n                                           do_phy_read(s,\n\n                                                       extract32(value,\n\n                                                                 18, 10)));\n\n        } else {\n\n            /* This a write operation */\n\n            do_phy_write(s, extract32(value, 18, 10), extract32(value, 0, 16));\n\n        }\n\n        /* raise the interrupt as the PHY operation is done */\n\n        s->regs[ENET_EIR] |= ENET_INT_MII;\n\n        break;\n\n    case ENET_MSCR:\n\n        s->regs[index] = value & 0xfe;\n\n        break;\n\n    case ENET_MIBC:\n\n        /* TODO: Implement MIB.  */\n\n        s->regs[index] = (value & 0x80000000) ? 0xc0000000 : 0;\n\n        break;\n\n    case ENET_RCR:\n\n        s->regs[index] = value & 0x07ff003f;\n\n        /* TODO: Implement LOOP mode.  */\n\n        break;\n\n    case ENET_TCR:\n\n        /* We transmit immediately, so raise GRA immediately.  */\n\n        s->regs[index] = value;\n\n        if (value & 1) {\n\n            s->regs[ENET_EIR] |= ENET_INT_GRA;\n\n        }\n\n        break;\n\n    case ENET_PALR:\n\n        s->regs[index] = value;\n\n        s->conf.macaddr.a[0] = value >> 24;\n\n        s->conf.macaddr.a[1] = value >> 16;\n\n        s->conf.macaddr.a[2] = value >> 8;\n\n        s->conf.macaddr.a[3] = value;\n\n        break;\n\n    case ENET_PAUR:\n\n        s->regs[index] = (value | 0x0000ffff) & 0xffff8808;\n\n        s->conf.macaddr.a[4] = value >> 24;\n\n        s->conf.macaddr.a[5] = value >> 16;\n\n        break;\n\n    case ENET_OPD:\n\n        s->regs[index] = (value & 0x0000ffff) | 0x00010000;\n\n        break;\n\n    case ENET_IAUR:\n\n    case ENET_IALR:\n\n    case ENET_GAUR:\n\n    case ENET_GALR:\n\n        /* TODO: implement MAC hash filtering.  */\n\n        break;\n\n    case ENET_TFWR:\n\n        if (s->is_fec) {\n\n            s->regs[index] = value & 0x3;\n\n        } else {\n\n            s->regs[index] = value & 0x13f;\n\n        }\n\n        break;\n\n    case ENET_RDSR:\n\n        if (s->is_fec) {\n\n            s->regs[index] = value & ~3;\n\n        } else {\n\n            s->regs[index] = value & ~7;\n\n        }\n\n        s->rx_descriptor = s->regs[index];\n\n        break;\n\n    case ENET_TDSR:\n\n        if (s->is_fec) {\n\n            s->regs[index] = value & ~3;\n\n        } else {\n\n            s->regs[index] = value & ~7;\n\n        }\n\n        s->tx_descriptor = s->regs[index];\n\n        break;\n\n    case ENET_MRBR:\n\n        s->regs[index] = value & 0x00003ff0;\n\n        break;\n\n    default:\n\n        if (s->is_fec) {\n\n            imx_fec_write(s, index, value);\n\n        } else {\n\n            imx_enet_write(s, index, value);\n\n        }\n\n        return;\n\n    }\n\n\n\n    imx_eth_update(s);\n\n}\n", "idx": 4290}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 2223}
{"project": "qemu", "commit_id": "6c2d1c32d084320081b0cd047f8cacd6e722d03a", "target": 1, "func": "static void xhci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->vmsd    = &vmstate_xhci;\n\n    dc->props   = xhci_properties;\n\n    dc->reset   = xhci_reset;\n\n    k->init         = usb_xhci_initfn;\n\n    k->vendor_id    = PCI_VENDOR_ID_NEC;\n\n    k->device_id    = PCI_DEVICE_ID_NEC_UPD720200;\n\n    k->class_id     = PCI_CLASS_SERIAL_USB;\n\n    k->revision     = 0x03;\n\n    k->is_express   = 1;\n\n\n}", "idx": 5331}
{"project": "qemu", "commit_id": "de1c90cf8b73992b4197561850d2da1075fb82eb", "target": 1, "func": "static void qemu_event_increment(void)\n\n{\n\n    SetEvent(qemu_event_handle);\n\n}\n", "idx": 6710}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 3353}
{"project": "qemu", "commit_id": "b7fcff01790d25f48d81ef6c8c3399577096a555", "target": 1, "func": "static void test_identify(void)\n\n{\n\n    uint8_t data;\n\n    uint16_t buf[256];\n\n    int i;\n\n    int ret;\n\n\n\n    ide_test_start(\n\n        \"-vnc none \"\n\n        \"-drive file=%s,if=ide,serial=%s,cache=writeback \"\n\n        \"-global ide-hd.ver=%s\",\n\n        tmp_path, \"testdisk\", \"version\");\n\n\n\n    /* IDENTIFY command on device 0*/\n\n    outb(IDE_BASE + reg_device, 0);\n\n    outb(IDE_BASE + reg_command, CMD_IDENTIFY);\n\n\n\n    /* Read in the IDENTIFY buffer and check registers */\n\n    data = inb(IDE_BASE + reg_device);\n\n    g_assert_cmpint(data & DEV, ==, 0);\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        data = inb(IDE_BASE + reg_status);\n\n        assert_bit_set(data, DRDY | DRQ);\n\n        assert_bit_clear(data, BSY | DF | ERR);\n\n\n\n        ((uint16_t*) buf)[i] = inw(IDE_BASE + reg_data);\n\n    }\n\n\n\n    data = inb(IDE_BASE + reg_status);\n\n    assert_bit_set(data, DRDY);\n\n    assert_bit_clear(data, BSY | DF | ERR | DRQ);\n\n\n\n    /* Check serial number/version in the buffer */\n\n    string_cpu_to_be16(&buf[10], 20);\n\n    ret = memcmp(&buf[10], \"testdisk            \", 20);\n\n    g_assert(ret == 0);\n\n\n\n    string_cpu_to_be16(&buf[23], 8);\n\n    ret = memcmp(&buf[23], \"version \", 8);\n\n    g_assert(ret == 0);\n\n\n\n    /* Write cache enabled bit */\n\n    assert_bit_set(buf[85], 0x20);\n\n\n\n    ide_test_quit();\n\n}\n", "idx": 4491}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbivax_booke206(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n\n\n    gen_helper_booke206_tlbivax(cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 10202}
{"project": "qemu", "commit_id": "75cb298d905030fca897ea1d80e409c7f7e3e5ea", "target": 1, "func": "sowrite(struct socket *so)\n\n{\n\n\tint  n,nn;\n\n\tstruct sbuf *sb = &so->so_rcv;\n\n\tint len = sb->sb_cc;\n\n\tstruct iovec iov[2];\n\n\n\n\tDEBUG_CALL(\"sowrite\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\n\n\tif (so->so_urgc) {\n\n\t\tsosendoob(so);\n\n\t\tif (sb->sb_cc == 0)\n\n\t\t\treturn 0;\n\n\t}\n\n\n\n\t/*\n\n\t * No need to check if there's something to write,\n\n\t * sowrite wouldn't have been called otherwise\n\n\t */\n\n\n\n\tiov[0].iov_base = sb->sb_rptr;\n\n        iov[1].iov_base = NULL;\n\n        iov[1].iov_len = 0;\n\n\tif (sb->sb_rptr < sb->sb_wptr) {\n\n\t\tiov[0].iov_len = sb->sb_wptr - sb->sb_rptr;\n\n\t\t/* Should never succeed, but... */\n\n\t\tif (iov[0].iov_len > len) iov[0].iov_len = len;\n\n\t\tn = 1;\n\n\t} else {\n\n\t\tiov[0].iov_len = (sb->sb_data + sb->sb_datalen) - sb->sb_rptr;\n\n\t\tif (iov[0].iov_len > len) iov[0].iov_len = len;\n\n\t\tlen -= iov[0].iov_len;\n\n\t\tif (len) {\n\n\t\t\tiov[1].iov_base = sb->sb_data;\n\n\t\t\tiov[1].iov_len = sb->sb_wptr - sb->sb_data;\n\n\t\t\tif (iov[1].iov_len > len) iov[1].iov_len = len;\n\n\t\t\tn = 2;\n\n\t\t} else\n\n\t\t\tn = 1;\n\n\t}\n\n\t/* Check if there's urgent data to send, and if so, send it */\n\n\n\n#ifdef HAVE_READV\n\n\tnn = writev(so->s, (const struct iovec *)iov, n);\n\n\n\n\tDEBUG_MISC((dfd, \"  ... wrote nn = %d bytes\\n\", nn));\n\n#else\n\n\tnn = slirp_send(so, iov[0].iov_base, iov[0].iov_len,0);\n\n#endif\n\n\t/* This should never happen, but people tell me it does *shrug* */\n\n\tif (nn < 0 && (errno == EAGAIN || errno == EINTR))\n\n\t\treturn 0;\n\n\n\n\tif (nn <= 0) {\n\n\t\tDEBUG_MISC((dfd, \" --- sowrite disconnected, so->so_state = %x, errno = %d\\n\",\n\n\t\t\tso->so_state, errno));\n\n\t\tsofcantsendmore(so);\n\n\t\ttcp_sockclosed(sototcpcb(so));\n\n\t\treturn -1;\n\n\t}\n\n\n\n#ifndef HAVE_READV\n\n\tif (n == 2 && nn == iov[0].iov_len) {\n\n            int ret;\n\n            ret = slirp_send(so, iov[1].iov_base, iov[1].iov_len,0);\n\n            if (ret > 0)\n\n                nn += ret;\n\n        }\n\n        DEBUG_MISC((dfd, \"  ... wrote nn = %d bytes\\n\", nn));\n\n#endif\n\n\n\n\t/* Update sbuf */\n\n\tsb->sb_cc -= nn;\n\n\tsb->sb_rptr += nn;\n\n\tif (sb->sb_rptr >= (sb->sb_data + sb->sb_datalen))\n\n\t\tsb->sb_rptr -= sb->sb_datalen;\n\n\n\n\t/*\n\n\t * If in DRAIN mode, and there's no more data, set\n\n\t * it CANTSENDMORE\n\n\t */\n\n\tif ((so->so_state & SS_FWDRAIN) && sb->sb_cc == 0)\n\n\t\tsofcantsendmore(so);\n\n\n\n\treturn nn;\n\n}\n", "idx": 411}
{"project": "qemu", "commit_id": "7e5f90fa3ff32ea31548666d57a78005555ecf34", "target": 1, "func": "int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,\n\n                int *is_linux)\n\n{\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    /* TODO: Implement Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto out;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 8632}
{"project": "qemu", "commit_id": "e61da14d60ba1cceacad8396adcb9662c7f690af", "target": 1, "func": "static void control_out(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtIOSerial *vser;\n\n\n\n    vser = DO_UPCAST(VirtIOSerial, vdev, vdev);\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        handle_control_message(vser, elem.out_sg[0].iov_base);\n\n        virtqueue_push(vq, &elem, elem.out_sg[0].iov_len);\n\n    }\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 5304}
{"project": "qemu", "commit_id": "72902672dc2ed6281cdb205259c1d52ecf01f6b2", "target": 1, "func": "uint64_t HELPER(neon_add_saturate_u64)(uint64_t src1, uint64_t src2)\n\n{\n\n    uint64_t res;\n\n\n\n    res = src1 + src2;\n\n    if (res < src1) {\n\n        env->QF = 1;\n\n        res = ~(uint64_t)0;\n\n    }\n\n    return res;\n\n}\n", "idx": 10946}
{"project": "qemu", "commit_id": "38f3adc34de83bf75d2023831dc520d32568a2d9", "target": 1, "func": "static void fw_cfg_init1(DeviceState *dev)\n\n{\n\n    FWCfgState *s = FW_CFG(dev);\n\n    MachineState *machine = MACHINE(qdev_get_machine());\n\n    uint32_t version = FW_CFG_VERSION;\n\n\n\n    assert(!object_resolve_path(FW_CFG_PATH, NULL));\n\n\n\n    object_property_add_child(OBJECT(machine), FW_CFG_NAME, OBJECT(s), NULL);\n\n\n\n    qdev_init_nofail(dev);\n\n\n\n    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)\"QEMU\", 4);\n\n    fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);\n\n    fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);\n\n    fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)boot_menu);\n\n    fw_cfg_bootsplash(s);\n\n    fw_cfg_reboot(s);\n\n\n\n    if (s->dma_enabled) {\n\n        version |= FW_CFG_VERSION_DMA;\n\n    }\n\n\n\n    fw_cfg_add_i32(s, FW_CFG_ID, version);\n\n\n\n    s->machine_ready.notify = fw_cfg_machine_ready;\n\n    qemu_add_machine_init_done_notifier(&s->machine_ready);\n\n}\n", "idx": 8675}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(subfze)\n\n{\n\n    T1 = ~T0;\n\n    T0 = T1 + xer_ca;\n\n    if (T0 < T1) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 10798}
{"project": "qemu", "commit_id": "924e8a2bbc7cc62b3996efe9a2a460f541c04520", "target": 1, "func": "static coroutine_fn int quorum_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQuorumState *s = bs->opaque;\n\n    QuorumVoteVersion *winner = NULL;\n\n    QuorumVotes error_votes;\n\n    QuorumVoteValue result_value;\n\n    int i;\n\n    int result = 0;\n\n\n\n    QLIST_INIT(&error_votes.vote_list);\n\n    error_votes.compare = quorum_64bits_compare;\n\n\n\n    for (i = 0; i < s->num_children; i++) {\n\n        result = bdrv_co_flush(s->children[i]->bs);\n\n        result_value.l = result;\n\n        quorum_count_vote(&error_votes, &result_value, i);\n\n    }\n\n\n\n    winner = quorum_get_vote_winner(&error_votes);\n\n    result = winner->value.l;\n\n\n\n    quorum_free_vote_list(&error_votes);\n\n\n\n    return result;\n\n}\n", "idx": 1256}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "bool migrate_auto_converge(void)\n\n{\n\n    MigrationState *s;\n\n\n\n    s = migrate_get_current();\n\n\n\n    return s->enabled_capabilities[MIGRATION_CAPABILITY_AUTO_CONVERGE];\n\n}\n", "idx": 1632}
{"project": "qemu", "commit_id": "e3442099a2794925dfbe83711cd204caf80eae60", "target": 1, "func": "void qmp_block_passwd(bool has_device, const char *device,\n\n                      bool has_node_name, const char *node_name,\n\n                      const char *password, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    BlockDriverState *bs;\n\n    int err;\n\n\n\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n\n                        has_node_name ? node_name : NULL,\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    err = bdrv_set_key(bs, password);\n\n    if (err == -EINVAL) {\n\n        error_set(errp, QERR_DEVICE_NOT_ENCRYPTED, bdrv_get_device_name(bs));\n\n        return;\n\n    } else if (err < 0) {\n\n        error_set(errp, QERR_INVALID_PASSWORD);\n\n        return;\n\n    }\n\n}\n", "idx": 4264}
{"project": "qemu", "commit_id": "89da90b1b4acf24a9a3f2fd197b1bdf69ab24e72", "target": 1, "func": "static void gt64120_pci_mapping(GT64120State *s)\n\n{\n\n    /* Update IO mapping */\n\n    if ((s->regs[GT_PCI0IOLD] & 0x7f) <= s->regs[GT_PCI0IOHD])\n\n    {\n\n      /* Unmap old IO address */\n\n      if (s->PCI0IO_length)\n\n      {\n\n          memory_region_del_subregion(get_system_memory(), &s->PCI0IO_mem);\n\n          memory_region_destroy(&s->PCI0IO_mem);\n\n      }\n\n      /* Map new IO address */\n\n      s->PCI0IO_start = s->regs[GT_PCI0IOLD] << 21;\n\n      s->PCI0IO_length = ((s->regs[GT_PCI0IOHD] + 1) - (s->regs[GT_PCI0IOLD] & 0x7f)) << 21;\n\n      isa_mem_base = s->PCI0IO_start;\n\n      isa_mmio_init(s->PCI0IO_start, s->PCI0IO_length);\n\n    }\n\n}\n", "idx": 283}
{"project": "qemu", "commit_id": "cb72cba83021fa42719e73a5249c12096a4d1cfc", "target": 1, "func": "uint32_t ide_data_readw(void *opaque, uint32_t addr)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n    int ret;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set. The result of a read\n\n     * during PIO in is indeterminate, return 0 and don't move forward. */\n\n    if (!(s->status & DRQ_STAT) || !ide_is_pio_out(s)) {\n\n        return 0;\n\n    }\n\n\n\n    p = s->data_ptr;\n\n    if (p + 2 > s->data_end) {\n\n        return 0;\n\n    }\n\n\n\n    ret = cpu_to_le16(*(uint16_t *)p);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n    return ret;\n\n}\n", "idx": 3935}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "static int net_vhost_chardev_opts(void *opaque,\n\n                                  const char *name, const char *value,\n\n                                  Error **errp)\n\n{\n\n    VhostUserChardevProps *props = opaque;\n\n\n\n    if (strcmp(name, \"backend\") == 0 && strcmp(value, \"socket\") == 0) {\n\n        props->is_socket = true;\n\n    } else if (strcmp(name, \"path\") == 0) {\n\n        props->is_unix = true;\n\n    } else if (strcmp(name, \"server\") == 0) {\n\n    } else {\n\n        error_setg(errp,\n\n                   \"vhost-user does not support a chardev with option %s=%s\",\n\n                   name, value);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 3706}
{"project": "qemu", "commit_id": "d9654a58576dae982458bdb1eb565c9876c24c22", "target": 1, "func": "read_help(void)\n\n{\n\n\tprintf(\n\n\"\\n\"\n\n\" reads a range of bytes from the given offset\\n\"\n\n\"\\n\"\n\n\" Example:\\n\"\n\n\" 'read -v 512 1k' - dumps 1 kilobyte read from 512 bytes into the file\\n\"\n\n\"\\n\"\n\n\" Reads a segment of the currently open file, optionally dumping it to the\\n\"\n\n\" standard output stream (with -v option) for subsequent inspection.\\n\"\n\n\" -p, -- use bdrv_pread to read the file\\n\"\n\n\" -P, -- use a pattern to verify read data\\n\"\n\n\" -C, -- report statistics in a machine parsable format\\n\"\n\n\" -v, -- dump buffer to standard output\\n\"\n\n\" -q, -- quite mode, do not show I/O statistics\\n\"\n\n\"\\n\");\n\n}\n", "idx": 2291}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static AddrRange addrrange_make(uint64_t start, uint64_t size)\n\n{\n\n    return (AddrRange) { start, size };\n\n}\n", "idx": 10262}
{"project": "qemu", "commit_id": "4172a00373b2c81374293becc02b16b7f8c76659", "target": 1, "func": "static void run_block_job(BlockJob *job, Error **errp)\n\n{\n\n    AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n    /* FIXME In error cases, the job simply goes away and we access a dangling\n\n     * pointer below. */\n\n    aio_context_acquire(aio_context);\n\n    do {\n\n        aio_poll(aio_context, true);\n\n        qemu_progress_print(job->len ?\n\n                            ((float)job->offset / job->len * 100.f) : 0.0f, 0);\n\n    } while (!job->ready);\n\n\n\n    block_job_complete_sync(job, errp);\n\n    aio_context_release(aio_context);\n\n\n\n    /* A block job may finish instantaneously without publishing any progress,\n\n     * so just signal completion here */\n\n    qemu_progress_print(100.f, 0);\n\n}\n", "idx": 759}
{"project": "qemu", "commit_id": "36b62ae6a58f9a588fd33be9386e18a2b90103f5", "target": 1, "func": "static void fw_cfg_data_mem_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    FWCfgState *s = opaque;\n\n    uint8_t buf[8];\n\n    unsigned i;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf[0] = value;\n\n        break;\n\n    case 2:\n\n        stw_he_p(buf, value);\n\n        break;\n\n    case 4:\n\n        stl_he_p(buf, value);\n\n        break;\n\n    case 8:\n\n        stq_he_p(buf, value);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    for (i = 0; i < size; ++i) {\n\n        fw_cfg_write(s, buf[i]);\n\n    }\n\n}\n", "idx": 4344}
{"project": "qemu", "commit_id": "71200fb9664c2967a1cdd22b68b0da3a8b2b3eb7", "target": 1, "func": "static CharDriverState *qemu_chr_open_stdio(const char *id,\n\n                                            ChardevBackend *backend,\n\n                                            ChardevReturn *ret,\n\n                                            Error **errp)\n\n{\n\n    ChardevStdio *opts = backend->u.stdio.data;\n\n    CharDriverState *chr;\n\n    struct sigaction act;\n\n    ChardevCommon *common = qapi_ChardevStdio_base(opts);\n\n\n\n    if (is_daemonized()) {\n\n        error_setg(errp, \"cannot use stdio with -daemonize\");\n\n\n\n\n\n    if (stdio_in_use) {\n\n        error_setg(errp, \"cannot use stdio by multiple character devices\");\n\n\n\n\n\n    stdio_in_use = true;\n\n    old_fd0_flags = fcntl(0, F_GETFL);\n\n    tcgetattr(0, &oldtty);\n\n    qemu_set_nonblock(0);\n\n    atexit(term_exit);\n\n\n\n    memset(&act, 0, sizeof(act));\n\n    act.sa_handler = term_stdio_handler;\n\n    sigaction(SIGCONT, &act, NULL);\n\n\n\n    chr = qemu_chr_open_fd(0, 1, common, errp);\n\n\n\n\n    chr->chr_close = qemu_chr_close_stdio;\n\n    chr->chr_set_echo = qemu_chr_set_echo_stdio;\n\n    if (opts->has_signal) {\n\n        stdio_allow_signal = opts->signal;\n\n\n    qemu_chr_fe_set_echo(chr, false);\n\n\n\n    return chr;\n", "idx": 8173}
{"project": "qemu", "commit_id": "8904e5a75005fe579c28806003892d8ae4a27dfa", "target": 1, "func": "static void spapr_set_vsmt_mode(sPAPRMachineState *spapr, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    bool vsmt_user = !!spapr->vsmt;\n\n    int kvm_smt = kvmppc_smt_threads();\n\n    int ret;\n\n\n\n    if (!kvm_enabled() && (smp_threads > 1)) {\n\n        error_setg(&local_err, \"TCG cannot support more than 1 thread/core \"\n\n                     \"on a pseries machine\");\n\n        goto out;\n\n    }\n\n    if (!is_power_of_2(smp_threads)) {\n\n        error_setg(&local_err, \"Cannot support %d threads/core on a pseries \"\n\n                     \"machine because it must be a power of 2\", smp_threads);\n\n        goto out;\n\n    }\n\n\n\n    /* Detemine the VSMT mode to use: */\n\n    if (vsmt_user) {\n\n        if (spapr->vsmt < smp_threads) {\n\n            error_setg(&local_err, \"Cannot support VSMT mode %d\"\n\n                         \" because it must be >= threads/core (%d)\",\n\n                         spapr->vsmt, smp_threads);\n\n            goto out;\n\n        }\n\n        /* In this case, spapr->vsmt has been set by the command line */\n\n    } else {\n\n        /* Choose a VSMT mode that may be higher than necessary but is\n\n         * likely to be compatible with hosts that don't have VSMT. */\n\n        spapr->vsmt = MAX(kvm_smt, smp_threads);\n\n    }\n\n\n\n    /* KVM: If necessary, set the SMT mode: */\n\n    if (kvm_enabled() && (spapr->vsmt != kvm_smt)) {\n\n        ret = kvmppc_set_smt_threads(spapr->vsmt);\n\n        if (ret) {\n\n            /* Looks like KVM isn't able to change VSMT mode */\n\n            error_setg(&local_err,\n\n                       \"Failed to set KVM's VSMT mode to %d (errno %d)\",\n\n                       spapr->vsmt, ret);\n\n            /* We can live with that if the default one is big enough\n\n             * for the number of threads, and a submultiple of the one\n\n             * we want.  In this case we'll waste some vcpu ids, but\n\n             * behaviour will be correct */\n\n            if ((kvm_smt >= smp_threads) && ((spapr->vsmt % kvm_smt) == 0)) {\n\n                warn_report_err(local_err);\n\n                local_err = NULL;\n\n                goto out;\n\n            } else {\n\n                if (!vsmt_user) {\n\n                    error_append_hint(&local_err,\n\n                                      \"On PPC, a VM with %d threads/core\"\n\n                                      \" on a host with %d threads/core\"\n\n                                      \" requires the use of VSMT mode %d.\\n\",\n\n                                      smp_threads, kvm_smt, spapr->vsmt);\n\n                }\n\n                kvmppc_hint_smt_possible(&local_err);\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n    /* else TCG: nothing to do currently */\n\nout:\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 2639}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void cpu_stop_current(void)\n\n{\n\n}\n", "idx": 4014}
{"project": "qemu", "commit_id": "3ff91d7e85176f8b4b131163d7fd801757a2c949", "target": 1, "func": "void tcg_gen_ld8s_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)\n\n{\n\n    tcg_gen_ld8s_i32(TCGV_LOW(ret), arg2, offset);\n\n    tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_HIGH(ret), 31);\n\n}\n", "idx": 8171}
{"project": "qemu", "commit_id": "b027a538c6790bcfc93ef7f4819fe3e581445959", "target": 1, "func": "static int oss_ctl_out (HWVoiceOut *hw, int cmd, ...)\n\n{\n\n    int trig;\n\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n\n\n\n    switch (cmd) {\n\n    case VOICE_ENABLE:\n\n        {\n\n            va_list ap;\n\n            int poll_mode;\n\n\n\n            va_start (ap, cmd);\n\n            poll_mode = va_arg (ap, int);\n\n            va_end (ap);\n\n\n\n            ldebug (\"enabling voice\\n\");\n\n            if (poll_mode && oss_poll_out (hw)) {\n\n                poll_mode = 0;\n\n            }\n\n            hw->poll_mode = poll_mode;\n\n\n\n            if (!oss->mmapped) {\n\n                return 0;\n\n            }\n\n\n\n            audio_pcm_info_clear_buf (&hw->info, oss->pcm_buf, hw->samples);\n\n            trig = PCM_ENABLE_OUTPUT;\n\n            if (ioctl (oss->fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                oss_logerr (\n\n                    errno,\n\n                    \"SNDCTL_DSP_SETTRIGGER PCM_ENABLE_OUTPUT failed\\n\"\n\n                    );\n\n                return -1;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case VOICE_DISABLE:\n\n        if (hw->poll_mode) {\n\n            qemu_set_fd_handler (oss->fd, NULL, NULL, NULL);\n\n            hw->poll_mode = 0;\n\n        }\n\n\n\n        if (!oss->mmapped) {\n\n            return 0;\n\n        }\n\n\n\n        ldebug (\"disabling voice\\n\");\n\n        trig = 0;\n\n        if (ioctl (oss->fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n            oss_logerr (errno, \"SNDCTL_DSP_SETTRIGGER 0 failed\\n\");\n\n            return -1;\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6062}
{"project": "qemu", "commit_id": "df39076850958b842ac9e414dc3ab2895f1877bf", "target": 1, "func": "bool runstate_needs_reset(void)\n\n{\n\n    return runstate_check(RUN_STATE_INTERNAL_ERROR) ||\n\n        runstate_check(RUN_STATE_SHUTDOWN) ||\n\n        runstate_check(RUN_STATE_GUEST_PANICKED);\n\n}\n", "idx": 10963}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_migration_done(struct vhost_dev *dev, char* mac_addr)\n\n{\n\n    VhostUserMsg msg = { 0 };\n\n    int err;\n\n\n\n    assert(dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER);\n\n\n\n    /* If guest supports GUEST_ANNOUNCE do nothing */\n\n    if (virtio_has_feature(dev->acked_features, VIRTIO_NET_F_GUEST_ANNOUNCE)) {\n\n        return 0;\n\n    }\n\n\n\n    /* if backend supports VHOST_USER_PROTOCOL_F_RARP ask it to send the RARP */\n\n    if (virtio_has_feature(dev->protocol_features,\n\n                           VHOST_USER_PROTOCOL_F_RARP)) {\n\n        msg.request = VHOST_USER_SEND_RARP;\n\n        msg.flags = VHOST_USER_VERSION;\n\n        memcpy((char *)&msg.u64, mac_addr, 6);\n\n        msg.size = sizeof(m.u64);\n\n\n\n        err = vhost_user_write(dev, &msg, NULL, 0);\n\n        return err;\n\n    }\n\n    return -1;\n\n}\n", "idx": 2195}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "void vnc_display_open(DisplayState *ds, const char *display, Error **errp)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n    const char *options;\n\n    int password = 0;\n\n    int reverse = 0;\n\n#ifdef CONFIG_VNC_TLS\n\n    int tls = 0, x509 = 0;\n\n#endif\n\n#ifdef CONFIG_VNC_SASL\n\n    int sasl = 0;\n\n    int saslErr;\n\n#endif\n\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n\n    int acl = 0;\n\n#endif\n\n    int lock_key_sync = 1;\n\n\n\n    if (!vnc_display) {\n\n        error_setg(errp, \"VNC display not active\");\n\n        return;\n\n    }\n\n    vnc_display_close(ds);\n\n    if (strcmp(display, \"none\") == 0)\n\n        return;\n\n\n\n    vs->display = g_strdup(display);\n\n    vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n\n\n\n    options = display;\n\n    while ((options = strchr(options, ','))) {\n\n        options++;\n\n        if (strncmp(options, \"password\", 8) == 0) {\n\n            if (fips_get_state()) {\n\n                error_setg(errp,\n\n                           \"VNC password auth disabled due to FIPS mode, \"\n\n                           \"consider using the VeNCrypt or SASL authentication \"\n\n                           \"methods as an alternative\");\n\n                goto fail;\n\n            }\n\n            password = 1; /* Require password auth */\n\n        } else if (strncmp(options, \"reverse\", 7) == 0) {\n\n            reverse = 1;\n\n        } else if (strncmp(options, \"no-lock-key-sync\", 16) == 0) {\n\n            lock_key_sync = 0;\n\n#ifdef CONFIG_VNC_SASL\n\n        } else if (strncmp(options, \"sasl\", 4) == 0) {\n\n            sasl = 1; /* Require SASL auth */\n\n#endif\n\n#ifdef CONFIG_VNC_WS\n\n        } else if (strncmp(options, \"websocket\", 9) == 0) {\n\n            char *start, *end;\n\n            vs->websocket = 1;\n\n\n\n            /* Check for 'websocket=<port>' */\n\n            start = strchr(options, '=');\n\n            end = strchr(options, ',');\n\n            if (start && (!end || (start < end))) {\n\n                int len = end ? end-(start+1) : strlen(start+1);\n\n                if (len < 6) {\n\n                    /* extract the host specification from display */\n\n                    char  *host = NULL, *port = NULL, *host_end = NULL;\n\n                    port = g_strndup(start + 1, len);\n\n\n\n                    /* ipv6 hosts have colons */\n\n                    end = strchr(display, ',');\n\n                    host_end = g_strrstr_len(display, end - display, \":\");\n\n\n\n                    if (host_end) {\n\n                        host = g_strndup(display, host_end - display + 1);\n\n                    } else {\n\n                        host = g_strndup(\":\", 1);\n\n                    }\n\n                    vs->ws_display = g_strconcat(host, port, NULL);\n\n                    g_free(host);\n\n                    g_free(port);\n\n                }\n\n            }\n\n#endif /* CONFIG_VNC_WS */\n\n#ifdef CONFIG_VNC_TLS\n\n        } else if (strncmp(options, \"tls\", 3) == 0) {\n\n            tls = 1; /* Require TLS */\n\n        } else if (strncmp(options, \"x509\", 4) == 0) {\n\n            char *start, *end;\n\n            x509 = 1; /* Require x509 certificates */\n\n            if (strncmp(options, \"x509verify\", 10) == 0)\n\n                vs->tls.x509verify = 1; /* ...and verify client certs */\n\n\n\n            /* Now check for 'x509=/some/path' postfix\n\n             * and use that to setup x509 certificate/key paths */\n\n            start = strchr(options, '=');\n\n            end = strchr(options, ',');\n\n            if (start && (!end || (start < end))) {\n\n                int len = end ? end-(start+1) : strlen(start+1);\n\n                char *path = g_strndup(start + 1, len);\n\n\n\n                VNC_DEBUG(\"Trying certificate path '%s'\\n\", path);\n\n                if (vnc_tls_set_x509_creds_dir(vs, path) < 0) {\n\n                    error_setg(errp, \"Failed to find x509 certificates/keys in %s\", path);\n\n                    g_free(path);\n\n                    goto fail;\n\n                }\n\n                g_free(path);\n\n            } else {\n\n                error_setg(errp, \"No certificate path provided\");\n\n                goto fail;\n\n            }\n\n#endif\n\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n\n        } else if (strncmp(options, \"acl\", 3) == 0) {\n\n            acl = 1;\n\n#endif\n\n        } else if (strncmp(options, \"lossy\", 5) == 0) {\n\n            vs->lossy = true;\n\n        } else if (strncmp(options, \"non-adaptive\", 12) == 0) {\n\n            vs->non_adaptive = true;\n\n        } else if (strncmp(options, \"share=\", 6) == 0) {\n\n            if (strncmp(options+6, \"ignore\", 6) == 0) {\n\n                vs->share_policy = VNC_SHARE_POLICY_IGNORE;\n\n            } else if (strncmp(options+6, \"allow-exclusive\", 15) == 0) {\n\n                vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n\n            } else if (strncmp(options+6, \"force-shared\", 12) == 0) {\n\n                vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n\n            } else {\n\n                error_setg(errp, \"unknown vnc share= option\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (acl && x509 && vs->tls.x509verify) {\n\n        if (!(vs->tls.acl = qemu_acl_init(\"vnc.x509dname\"))) {\n\n            fprintf(stderr, \"Failed to create x509 dname ACL\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n#endif\n\n#ifdef CONFIG_VNC_SASL\n\n    if (acl && sasl) {\n\n        if (!(vs->sasl.acl = qemu_acl_init(\"vnc.username\"))) {\n\n            fprintf(stderr, \"Failed to create username ACL\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /*\n\n     * Combinations we support here:\n\n     *\n\n     *  - no-auth                (clear text, no auth)\n\n     *  - password               (clear text, weak auth)\n\n     *  - sasl                   (encrypt, good auth *IF* using Kerberos via GSSAPI)\n\n     *  - tls                    (encrypt, weak anonymous creds, no auth)\n\n     *  - tls + password         (encrypt, weak anonymous creds, weak auth)\n\n     *  - tls + sasl             (encrypt, weak anonymous creds, good auth)\n\n     *  - tls + x509             (encrypt, good x509 creds, no auth)\n\n     *  - tls + x509 + password  (encrypt, good x509 creds, weak auth)\n\n     *  - tls + x509 + sasl      (encrypt, good x509 creds, good auth)\n\n     *\n\n     * NB1. TLS is a stackable auth scheme.\n\n     * NB2. the x509 schemes have option to validate a client cert dname\n\n     */\n\n    if (password) {\n\n#ifdef CONFIG_VNC_TLS\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n\n            }\n\n        } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n\n            vs->auth = VNC_AUTH_VNC;\n\n#ifdef CONFIG_VNC_TLS\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    } else if (sasl) {\n\n#ifdef CONFIG_VNC_TLS\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n\n            }\n\n        } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n\n            vs->auth = VNC_AUTH_SASL;\n\n#ifdef CONFIG_VNC_TLS\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n#endif /* CONFIG_VNC_TLS */\n\n#endif /* CONFIG_VNC_SASL */\n\n    } else {\n\n#ifdef CONFIG_VNC_TLS\n\n        if (tls) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (x509) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n\n            } else {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n\n            }\n\n        } else {\n\n#endif\n\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n\n            vs->auth = VNC_AUTH_NONE;\n\n#ifdef CONFIG_VNC_TLS\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n#endif\n\n    }\n\n\n\n#ifdef CONFIG_VNC_SASL\n\n    if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {\n\n        error_setg(errp, \"Failed to initialize SASL auth: %s\",\n\n                   sasl_errstring(saslErr, NULL, NULL));\n\n        goto fail;\n\n    }\n\n#endif\n\n    vs->lock_key_sync = lock_key_sync;\n\n\n\n    if (reverse) {\n\n        /* connect to viewer */\n\n        int csock;\n\n        vs->lsock = -1;\n\n#ifdef CONFIG_VNC_WS\n\n        vs->lwebsock = -1;\n\n#endif\n\n        if (strncmp(display, \"unix:\", 5) == 0) {\n\n            csock = unix_connect(display+5, errp);\n\n        } else {\n\n            csock = inet_connect(display, errp);\n\n        }\n\n        if (csock < 0) {\n\n            goto fail;\n\n        }\n\n        vnc_connect(vs, csock, 0, 0);\n\n    } else {\n\n        /* listen for connects */\n\n        char *dpy;\n\n        dpy = g_malloc(256);\n\n        if (strncmp(display, \"unix:\", 5) == 0) {\n\n            pstrcpy(dpy, 256, \"unix:\");\n\n            vs->lsock = unix_listen(display+5, dpy+5, 256-5, errp);\n\n        } else {\n\n            vs->lsock = inet_listen(display, dpy, 256,\n\n                                    SOCK_STREAM, 5900, errp);\n\n            if (vs->lsock < 0) {\n\n                g_free(dpy);\n\n                goto fail;\n\n            }\n\n#ifdef CONFIG_VNC_WS\n\n            if (vs->websocket) {\n\n                if (vs->ws_display) {\n\n                    vs->lwebsock = inet_listen(vs->ws_display, NULL, 256,\n\n                        SOCK_STREAM, 0, errp);\n\n                } else {\n\n                    vs->lwebsock = inet_listen(vs->display, NULL, 256,\n\n                        SOCK_STREAM, 5700, errp);\n\n                }\n\n\n\n                if (vs->lwebsock < 0) {\n\n                    if (vs->lsock) {\n\n                        close(vs->lsock);\n\n                        vs->lsock = -1;\n\n                    }\n\n                    g_free(dpy);\n\n                    goto fail;\n\n                }\n\n            }\n\n#endif /* CONFIG_VNC_WS */\n\n        }\n\n        g_free(vs->display);\n\n        vs->display = dpy;\n\n        qemu_set_fd_handler2(vs->lsock, NULL,\n\n                vnc_listen_regular_read, NULL, vs);\n\n#ifdef CONFIG_VNC_WS\n\n        if (vs->websocket) {\n\n            qemu_set_fd_handler2(vs->lwebsock, NULL,\n\n                    vnc_listen_websocket_read, NULL, vs);\n\n        }\n\n#endif /* CONFIG_VNC_WS */\n\n    }\n\n    return;\n\n\n\nfail:\n\n    g_free(vs->display);\n\n    vs->display = NULL;\n\n#ifdef CONFIG_VNC_WS\n\n    g_free(vs->ws_display);\n\n    vs->ws_display = NULL;\n\n#endif /* CONFIG_VNC_WS */\n\n}\n", "idx": 1068}
{"project": "qemu", "commit_id": "fe121b9d3c4258e41f7efa4976bf79151b2d5dbb", "target": 1, "func": "static void qemu_laio_process_completion(struct qemu_laiocb *laiocb)\n\n{\n\n    int ret;\n\n\n\n    ret = laiocb->ret;\n\n    if (ret != -ECANCELED) {\n\n        if (ret == laiocb->nbytes) {\n\n            ret = 0;\n\n        } else if (ret >= 0) {\n\n            /* Short reads mean EOF, pad with zeros. */\n\n            if (laiocb->is_read) {\n\n                qemu_iovec_memset(laiocb->qiov, ret, 0,\n\n                    laiocb->qiov->size - ret);\n\n            } else {\n\n                ret = -ENOSPC;\n\n            }\n\n        }\n\n    }\n\n\n\n    laiocb->ret = ret;\n\n    if (laiocb->co) {\n\n        /* Jump and continue completion for foreign requests, don't do\n\n         * anything for current request, it will be completed shortly. */\n\n        if (laiocb->co != qemu_coroutine_self()) {\n\n            qemu_coroutine_enter(laiocb->co);\n\n        }\n\n    } else {\n\n        laiocb->common.cb(laiocb->common.opaque, ret);\n\n        qemu_aio_unref(laiocb);\n\n    }\n\n}\n", "idx": 2452}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_in (HWVoiceIn *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 2285}
{"project": "qemu", "commit_id": "2aaa1940684a3bf2b381fd2a8ff26c287a05109d", "target": 1, "func": "static uint32_t cc_calc_abs_32(int32_t dst)\n\n{\n\n    if ((uint32_t)dst == 0x80000000UL) {\n\n        return 3;\n\n    } else if (dst) {\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 1199}
{"project": "qemu", "commit_id": "0696ae2c9236a3589f5eaf5b00c12868b6f30a17", "target": 1, "func": "static int qcow_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    int header_size, backing_filename_len, l1_size, shift, i;\n\n    QCowHeader header;\n\n    uint8_t *tmp;\n\n    int64_t total_size = 0;\n\n    char *backing_file = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    BlockBackend *qcow_blk;\n\n    const char *encryptfmt = NULL;\n\n    QDict *options;\n\n    QDict *encryptopts = NULL;\n\n    QCryptoBlockCreateOptions *crypto_opts = NULL;\n\n    QCryptoBlock *crypto = NULL;\n\n\n\n    /* Read out options */\n\n    total_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                          BDRV_SECTOR_SIZE);\n\n    if (total_size == 0) {\n\n        error_setg(errp, \"Image size is too small, cannot be zero length\");\n\n        ret = -EINVAL;\n\n        goto cleanup;\n\n    }\n\n\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    encryptfmt = qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT_FORMAT);\n\n    if (encryptfmt) {\n\n        if (qemu_opt_get(opts, BLOCK_OPT_ENCRYPT)) {\n\n            error_setg(errp, \"Options \" BLOCK_OPT_ENCRYPT \" and \"\n\n                       BLOCK_OPT_ENCRYPT_FORMAT \" are mutually exclusive\");\n\n            ret = -EINVAL;\n\n            goto cleanup;\n\n        }\n\n    } else if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {\n\n        encryptfmt = \"aes\";\n\n    }\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto cleanup;\n\n    }\n\n\n\n    qcow_blk = blk_new_open(filename, NULL, NULL,\n\n                            BDRV_O_RDWR | BDRV_O_RESIZE | BDRV_O_PROTOCOL,\n\n                            &local_err);\n\n    if (qcow_blk == NULL) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EIO;\n\n        goto cleanup;\n\n    }\n\n\n\n    blk_set_allow_write_beyond_eof(qcow_blk, true);\n\n\n\n    ret = blk_truncate(qcow_blk, 0, PREALLOC_MODE_OFF, errp);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    memset(&header, 0, sizeof(header));\n\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n\n    header.version = cpu_to_be32(QCOW_VERSION);\n\n    header.size = cpu_to_be64(total_size);\n\n    header_size = sizeof(header);\n\n    backing_filename_len = 0;\n\n    if (backing_file) {\n\n        if (strcmp(backing_file, \"fat:\")) {\n\n            header.backing_file_offset = cpu_to_be64(header_size);\n\n            backing_filename_len = strlen(backing_file);\n\n            header.backing_file_size = cpu_to_be32(backing_filename_len);\n\n            header_size += backing_filename_len;\n\n        } else {\n\n            /* special backing file for vvfat */\n\n            g_free(backing_file);\n\n            backing_file = NULL;\n\n        }\n\n        header.cluster_bits = 9; /* 512 byte cluster to avoid copying\n\n                                    unmodified sectors */\n\n        header.l2_bits = 12; /* 32 KB L2 tables */\n\n    } else {\n\n        header.cluster_bits = 12; /* 4 KB clusters */\n\n        header.l2_bits = 9; /* 4 KB L2 tables */\n\n    }\n\n    header_size = (header_size + 7) & ~7;\n\n    shift = header.cluster_bits + header.l2_bits;\n\n    l1_size = (total_size + (1LL << shift) - 1) >> shift;\n\n\n\n    header.l1_table_offset = cpu_to_be64(header_size);\n\n\n\n    options = qemu_opts_to_qdict(opts, NULL);\n\n    qdict_extract_subqdict(options, &encryptopts, \"encrypt.\");\n\n    QDECREF(options);\n\n    if (encryptfmt) {\n\n        if (!g_str_equal(encryptfmt, \"aes\")) {\n\n            error_setg(errp, \"Unknown encryption format '%s', expected 'aes'\",\n\n                       encryptfmt);\n\n            ret = -EINVAL;\n\n            goto exit;\n\n        }\n\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n\n\n\n        crypto_opts = block_crypto_create_opts_init(\n\n            Q_CRYPTO_BLOCK_FORMAT_QCOW, encryptopts, errp);\n\n        if (!crypto_opts) {\n\n            ret = -EINVAL;\n\n            goto exit;\n\n        }\n\n\n\n        crypto = qcrypto_block_create(crypto_opts, \"encrypt.\",\n\n                                      NULL, NULL, NULL, errp);\n\n        if (!crypto) {\n\n            ret = -EINVAL;\n\n            goto exit;\n\n        }\n\n    } else {\n\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n\n    }\n\n\n\n    /* write all the data */\n\n    ret = blk_pwrite(qcow_blk, 0, &header, sizeof(header), 0);\n\n    if (ret != sizeof(header)) {\n\n        goto exit;\n\n    }\n\n\n\n    if (backing_file) {\n\n        ret = blk_pwrite(qcow_blk, sizeof(header),\n\n                         backing_file, backing_filename_len, 0);\n\n        if (ret != backing_filename_len) {\n\n            goto exit;\n\n        }\n\n    }\n\n\n\n    tmp = g_malloc0(BDRV_SECTOR_SIZE);\n\n    for (i = 0; i < DIV_ROUND_UP(sizeof(uint64_t) * l1_size, BDRV_SECTOR_SIZE);\n\n         i++) {\n\n        ret = blk_pwrite(qcow_blk, header_size + BDRV_SECTOR_SIZE * i,\n\n                         tmp, BDRV_SECTOR_SIZE, 0);\n\n        if (ret != BDRV_SECTOR_SIZE) {\n\n            g_free(tmp);\n\n            goto exit;\n\n        }\n\n    }\n\n\n\n    g_free(tmp);\n\n    ret = 0;\n\nexit:\n\n    blk_unref(qcow_blk);\n\ncleanup:\n\n    QDECREF(encryptopts);\n\n    qcrypto_block_free(crypto);\n\n    qapi_free_QCryptoBlockCreateOptions(crypto_opts);\n\n    g_free(backing_file);\n\n    return ret;\n\n}\n", "idx": 5506}
{"project": "qemu", "commit_id": "d07bde88a52bf293c3f8846cfd162e0a57e1557c", "target": 1, "func": "static TranslationBlock *tb_find_slow(target_ulong pc,\n\n                                      target_ulong cs_base,\n\n                                      uint64_t flags)\n\n{\n\n    TranslationBlock *tb, **ptb1;\n\n    int code_gen_size;\n\n    unsigned int h;\n\n    target_ulong phys_pc, phys_page1, phys_page2, virt_page2;\n\n    uint8_t *tc_ptr;\n\n\n\n    spin_lock(&tb_lock);\n\n\n\n    tb_invalidated_flag = 0;\n\n\n\n    regs_to_env(); /* XXX: do it just before cpu_gen_code() */\n\n\n\n    /* find translated block using physical mappings */\n\n    phys_pc = get_phys_addr_code(env, pc);\n\n    phys_page1 = phys_pc & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    h = tb_phys_hash_func(phys_pc);\n\n    ptb1 = &tb_phys_hash[h];\n\n    for(;;) {\n\n        tb = *ptb1;\n\n        if (!tb)\n\n            goto not_found;\n\n        if (tb->pc == pc &&\n\n            tb->page_addr[0] == phys_page1 &&\n\n            tb->cs_base == cs_base &&\n\n            tb->flags == flags) {\n\n            /* check next page if needed */\n\n            if (tb->page_addr[1] != -1) {\n\n                virt_page2 = (pc & TARGET_PAGE_MASK) +\n\n                    TARGET_PAGE_SIZE;\n\n                phys_page2 = get_phys_addr_code(env, virt_page2);\n\n                if (tb->page_addr[1] == phys_page2)\n\n                    goto found;\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        ptb1 = &tb->phys_hash_next;\n\n    }\n\n not_found:\n\n    /* if no translated code available, then translate it now */\n\n    tb = tb_alloc(pc);\n\n    if (!tb) {\n\n        /* flush must be done */\n\n        tb_flush(env);\n\n        /* cannot fail at this point */\n\n        tb = tb_alloc(pc);\n\n        /* don't forget to invalidate previous TB info */\n\n        tb_invalidated_flag = 1;\n\n    }\n\n    tc_ptr = code_gen_ptr;\n\n    tb->tc_ptr = tc_ptr;\n\n    tb->cs_base = cs_base;\n\n    tb->flags = flags;\n\n    cpu_gen_code(env, tb, CODE_GEN_MAX_SIZE, &code_gen_size);\n\n    code_gen_ptr = (void *)(((unsigned long)code_gen_ptr + code_gen_size + CODE_GEN_ALIGN - 1) & ~(CODE_GEN_ALIGN - 1));\n\n\n\n    /* check next page if needed */\n\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n\n        phys_page2 = get_phys_addr_code(env, virt_page2);\n\n    }\n\n    tb_link_phys(tb, phys_pc, phys_page2);\n\n\n\n found:\n\n    /* we add the TB in the virtual pc hash table */\n\n    env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb;\n\n    spin_unlock(&tb_lock);\n\n    return tb;\n\n}\n", "idx": 3479}
{"project": "qemu", "commit_id": "773de5c786a6050bbf3b33c0e29d1bd519a40b4b", "target": 1, "func": "static uint16_t handle_write_event_buf(SCLPEventFacility *ef,\n\n                                       EventBufferHeader *event_buf, SCCB *sccb)\n\n{\n\n    uint16_t rc;\n\n    BusChild *kid;\n\n    SCLPEvent *event;\n\n    SCLPEventClass *ec;\n\n\n\n    QTAILQ_FOREACH(kid, &ef->sbus.qbus.children, sibling) {\n\n        DeviceState *qdev = kid->child;\n\n        event = (SCLPEvent *) qdev;\n\n        ec = SCLP_EVENT_GET_CLASS(event);\n\n\n\n        rc = SCLP_RC_INVALID_FUNCTION;\n\n        if (ec->write_event_data &&\n\n            ec->event_type() == event_buf->type) {\n\n            rc = ec->write_event_data(event, event_buf);\n\n            break;\n\n        }\n\n    }\n\n    return rc;\n\n}\n", "idx": 3782}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_command_complete(void *opaque, int ret)\n\n{\n\n    SCSIGenericReq *r = (SCSIGenericReq *)opaque;\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, r->req.dev);\n\n\n\n    r->req.aiocb = NULL;\n\n    s->driver_status = r->io_header.driver_status;\n\n    if (s->driver_status & SG_ERR_DRIVER_SENSE)\n\n        s->senselen = r->io_header.sb_len_wr;\n\n\n\n    if (ret != 0)\n\n        r->req.status = BUSY;\n\n    else {\n\n        if (s->driver_status & SG_ERR_DRIVER_TIMEOUT) {\n\n            r->req.status = BUSY;\n\n            BADF(\"Driver Timeout\\n\");\n\n        } else if (r->io_header.status)\n\n            r->req.status = r->io_header.status;\n\n        else if (s->driver_status & SG_ERR_DRIVER_SENSE)\n\n            r->req.status = CHECK_CONDITION;\n\n        else\n\n            r->req.status = GOOD;\n\n    }\n\n    DPRINTF(\"Command complete 0x%p tag=0x%x status=%d\\n\",\n\n            r, r->req.tag, r->req.status);\n\n\n\n    scsi_req_complete(&r->req);\n\n}\n", "idx": 999}
{"project": "qemu", "commit_id": "77a10d04d033484a913a5ee76eed31a9acc57bae", "target": 1, "func": "void vfio_put_group(VFIOGroup *group)\n\n{\n\n    if (!QLIST_EMPTY(&group->device_list)) {\n\n        return;\n\n    }\n\n\n\n    vfio_kvm_device_del_group(group);\n\n    vfio_disconnect_container(group);\n\n    QLIST_REMOVE(group, next);\n\n    trace_vfio_put_group(group->fd);\n\n    close(group->fd);\n\n    g_free(group);\n\n\n\n    if (QLIST_EMPTY(&vfio_group_list)) {\n\n        qemu_unregister_reset(vfio_reset_handler, NULL);\n\n    }\n\n}\n", "idx": 3854}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static void icp_control_init(uint32_t base)\n\n{\n\n    int iomemtype;\n\n    icp_control_state *s;\n\n\n\n    s = (icp_control_state *)qemu_mallocz(sizeof(icp_control_state));\n\n    iomemtype = cpu_register_io_memory(0, icp_control_readfn,\n\n                                       icp_control_writefn, s);\n\n    cpu_register_physical_memory(base, 0x007fffff, iomemtype);\n\n    s->base = base;\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 9253}
{"project": "qemu", "commit_id": "47025a0193f1f910300adfa443305ccf8482ef87", "target": 1, "func": "static void qxl_realize_primary(PCIDevice *dev, Error **errp)\n\n{\n\n    PCIQXLDevice *qxl = PCI_QXL(dev);\n\n    VGACommonState *vga = &qxl->vga;\n\n    Error *local_err = NULL;\n\n\n\n    qxl->id = 0;\n\n    qxl_init_ramsize(qxl);\n\n    vga->vbe_size = qxl->vgamem_size;\n\n    vga->vram_size_mb = qxl->vga.vram_size >> 20;\n\n    vga_common_init(vga, OBJECT(dev), true);\n\n    vga_init(vga, OBJECT(dev),\n\n             pci_address_space(dev), pci_address_space_io(dev), false);\n\n    portio_list_init(&qxl->vga_port_list, OBJECT(dev), qxl_vga_portio_list,\n\n                     vga, \"vga\");\n\n    portio_list_set_flush_coalesced(&qxl->vga_port_list);\n\n    portio_list_add(&qxl->vga_port_list, pci_address_space_io(dev), 0x3b0);\n\n\n\n    vga->con = graphic_console_init(DEVICE(dev), 0, &qxl_ops, qxl);\n\n    qemu_spice_display_init_common(&qxl->ssd);\n\n\n\n    qxl_realize_common(qxl, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    qxl->ssd.dcl.ops = &display_listener_ops;\n\n    qxl->ssd.dcl.con = vga->con;\n\n    register_displaychangelistener(&qxl->ssd.dcl);\n\n}\n", "idx": 10628}
{"project": "qemu", "commit_id": "3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8", "target": 1, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        if (qemu_ram_addr_from_host(addr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n\n        kvm_mce_inject(first_cpu, paddr, code);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 2481}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static int xen_init(MachineState *ms)\n\n{\n\n    xen_xc = xen_xc_interface_open(0, 0, 0);\n\n    if (xen_xc == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open xen interface\\n\");\n\n\n\n\n\n\n\n\n\n    qemu_add_vm_change_state_handler(xen_change_state_handler, NULL);\n\n\n\n    global_state_set_optional();\n\n    savevm_skip_configuration();\n\n    savevm_skip_section_footers();\n\n\n\n    return 0;\n", "idx": 11813}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_events_init(sPAPREnvironment *spapr)\n\n{\n\n    spapr->epow_irq = spapr_allocate_msi(0);\n\n    spapr->epow_notifier.notify = spapr_powerdown_req;\n\n    qemu_register_powerdown_notifier(&spapr->epow_notifier);\n\n    spapr_rtas_register(\"check-exception\", check_exception);\n\n}\n", "idx": 11931}
{"project": "qemu", "commit_id": "791230d8bbd5c09d80845755a54074cd2d8b5a22", "target": 1, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n                          BdrvCheckMode fix)\n{\n    BDRVQcowState *s = bs->opaque;\n    BdrvCheckResult pre_compare_res;\n    int64_t size, highest_cluster, nb_clusters;\n    uint16_t *refcount_table = NULL;\n    bool rebuild = false;\n    int ret;\n    size = bdrv_getlength(bs->file);\n    if (size < 0) {\n        res->check_errors++;\n        return size;\n    nb_clusters = size_to_clusters(s, size);\n    if (nb_clusters > INT_MAX) {\n        res->check_errors++;\n        return -EFBIG;\n    res->bfi.total_clusters =\n        size_to_clusters(s, bs->total_sectors * BDRV_SECTOR_SIZE);\n    ret = calculate_refcounts(bs, res, fix, &rebuild, &refcount_table,\n    /* In case we don't need to rebuild the refcount structure (but want to fix\n     * something), this function is immediately called again, in which case the\n     * result should be ignored */\n    pre_compare_res = *res;\n    compare_refcounts(bs, res, 0, &rebuild, &highest_cluster, refcount_table,\n                      nb_clusters);\n    if (rebuild && (fix & BDRV_FIX_ERRORS)) {\n        fprintf(stderr, \"Rebuilding refcount structure\\n\");\n        ret = rebuild_refcount_structure(bs, res, &refcount_table,\n    } else if (fix) {\n            fprintf(stderr, \"ERROR need to rebuild refcount structures\\n\");\n            res->check_errors++;\n            ret = -EIO;\n        if (res->leaks || res->corruptions) {\n            *res = pre_compare_res;\n            compare_refcounts(bs, res, fix, &rebuild, &highest_cluster,\n                              refcount_table, nb_clusters);\n    /* check OFLAG_COPIED */\n    ret = check_oflag_copied(bs, res, fix);\n    res->image_end_offset = (highest_cluster + 1) * s->cluster_size;\n    ret = 0;\nfail:\n    g_free(refcount_table);\n    return ret;", "idx": 6708}
{"project": "qemu", "commit_id": "e3697092228770c3b23d0bf524e18b508b109932", "target": 1, "func": "static void vga_draw_graphic(VGAState *s, int full_update)\n\n{\n\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[0x05] >> 5) & 3;\n\n    double_scan = (s->cr[0x09] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n        if (depth == 16 || depth == 32) {\n\n            if (is_graphic_console()) {\n\n                qemu_free_displaysurface(s->ds->surface);\n\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                                                               s->line_offset,\n\n                                                               s->vram_ptr + (s->start_addr * 4));\n\n                dpy_resize(s->ds);\n\n            } else {\n\n                qemu_console_resize(s->ds, disp_width, height);\n\n            }\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n\n        dpy_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = 0x7fffffff;\n\n    page_max = -1;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[0x17] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[0x17] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n\n        update = full_update |\n\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n\n            /* if wide line, can use another page */\n\n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 2937}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "int qemu_strtoul(const char *nptr, const char **endptr, int base,\n\n                 unsigned long *result)\n\n{\n\n    char *p;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        *result = strtoul(nptr, &p, base);\n\n        err = check_strtox_error(endptr, p, errno);\n\n    }\n\n    return err;\n\n}\n", "idx": 10414}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check where the kernel has been linked */\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}", "idx": 5323}
{"project": "qemu", "commit_id": "c0532a76b407af4b276dc5a62d8178db59857ea6", "target": 1, "func": "void cpu_inject_x86_mce(CPUState *cenv, int bank, uint64_t status,\n\n                        uint64_t mcg_status, uint64_t addr, uint64_t misc)\n\n{\n\n    uint64_t mcg_cap = cenv->mcg_cap;\n\n    unsigned bank_num = mcg_cap & 0xff;\n\n    uint64_t *banks = cenv->mce_banks;\n\n\n\n    if (bank >= bank_num || !(status & MCI_STATUS_VAL))\n\n        return;\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_inject_x86_mce(cenv, bank, status, mcg_status, addr, misc);\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * if MSR_MCG_CTL is not all 1s, the uncorrected error\n\n     * reporting is disabled\n\n     */\n\n    if ((status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\n        cenv->mcg_ctl != ~(uint64_t)0)\n\n        return;\n\n    banks += 4 * bank;\n\n    /*\n\n     * if MSR_MCi_CTL is not all 1s, the uncorrected error\n\n     * reporting is disabled for the bank\n\n     */\n\n    if ((status & MCI_STATUS_UC) && banks[0] != ~(uint64_t)0)\n\n        return;\n\n    if (status & MCI_STATUS_UC) {\n\n        if ((cenv->mcg_status & MCG_STATUS_MCIP) ||\n\n            !(cenv->cr[4] & CR4_MCE_MASK)) {\n\n            fprintf(stderr, \"injects mce exception while previous \"\n\n                    \"one is in progress!\\n\");\n\n            qemu_log_mask(CPU_LOG_RESET, \"Triple fault\\n\");\n\n            qemu_system_reset_request();\n\n            return;\n\n        }\n\n        if (banks[1] & MCI_STATUS_VAL)\n\n            status |= MCI_STATUS_OVER;\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        cenv->mcg_status = mcg_status;\n\n        banks[1] = status;\n\n        cpu_interrupt(cenv, CPU_INTERRUPT_MCE);\n\n    } else if (!(banks[1] & MCI_STATUS_VAL)\n\n               || !(banks[1] & MCI_STATUS_UC)) {\n\n        if (banks[1] & MCI_STATUS_VAL)\n\n            status |= MCI_STATUS_OVER;\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        banks[1] = status;\n\n    } else\n\n        banks[1] |= MCI_STATUS_OVER;\n\n}\n", "idx": 11290}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_970FX (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    /* XXX: not correct */\n\n    gen_low_BATs(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); /* TOFIX */\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc970_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 3239}
{"project": "qemu", "commit_id": "b53ccc30c40df52d192e469a86c188a8649c6df3", "target": 1, "func": "void hmp_dump_guest_memory(Monitor *mon, const QDict *qdict)\n\n{\n\n    Error *errp = NULL;\n\n    int paging = qdict_get_try_bool(qdict, \"paging\", 0);\n\n    const char *file = qdict_get_str(qdict, \"filename\");\n\n    bool has_begin = qdict_haskey(qdict, \"begin\");\n\n    bool has_length = qdict_haskey(qdict, \"length\");\n\n    int64_t begin = 0;\n\n    int64_t length = 0;\n\n    char *prot;\n\n\n\n    if (has_begin) {\n\n        begin = qdict_get_int(qdict, \"begin\");\n\n    }\n\n    if (has_length) {\n\n        length = qdict_get_int(qdict, \"length\");\n\n    }\n\n\n\n    prot = g_strconcat(\"file:\", file, NULL);\n\n\n\n    qmp_dump_guest_memory(paging, prot, has_begin, begin, has_length, length,\n\n                          &errp);\n\n    hmp_handle_error(mon, &errp);\n\n    g_free(prot);\n\n}\n", "idx": 8839}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 340}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power8e_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER8E\";\n\n    k->chip_type = PNV_CHIP_POWER8E;\n\n    k->chip_cfam_id = 0x221ef04980000000ull;  /* P8 Murano DD2.1 */\n\n    k->cores_mask = POWER8E_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p8;\n\n\n    dc->desc = \"PowerNV Chip POWER8E\";\n\n}", "idx": 601}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void omap_gp_timer_clk_setup(struct omap_gp_timer_s *timer)\n\n{\n\n    omap_clk_adduser(timer->clk,\n\n                    qemu_allocate_irqs(omap_gp_timer_clk_update, timer, 1)[0]);\n\n    timer->rate = omap_clk_getrate(timer->clk);\n\n}\n", "idx": 6177}
{"project": "qemu", "commit_id": "cf5f7937b05c84d5565134f058c00cd48304a117", "target": 1, "func": "static void nvic_writel(NVICState *s, uint32_t offset, uint32_t value,\n\n                        MemTxAttrs attrs)\n\n{\n\n    ARMCPU *cpu = s->cpu;\n\n\n\n    switch (offset) {\n\n    case 0x380 ... 0x3bf: /* NVIC_ITNS<n> */\n\n    {\n\n        int startvec = 32 * (offset - 0x380) + NVIC_FIRST_IRQ;\n\n        int i;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            break;\n\n        }\n\n        for (i = 0; i < 32 && startvec + i < s->num_irq; i++) {\n\n            s->itns[startvec + i] = (value >> i) & 1;\n\n        }\n\n        nvic_irq_update(s);\n\n        break;\n\n    }\n\n    case 0xd04: /* Interrupt Control State (ICSR) */\n\n        if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {\n\n            if (value & (1 << 31)) {\n\n                armv7m_nvic_set_pending(s, ARMV7M_EXCP_NMI, false);\n\n            } else if (value & (1 << 30) &&\n\n                       arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n                /* PENDNMICLR didn't exist in v7M */\n\n                armv7m_nvic_clear_pending(s, ARMV7M_EXCP_NMI, false);\n\n            }\n\n        }\n\n        if (value & (1 << 28)) {\n\n            armv7m_nvic_set_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);\n\n        } else if (value & (1 << 27)) {\n\n            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);\n\n        }\n\n        if (value & (1 << 26)) {\n\n            armv7m_nvic_set_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);\n\n        } else if (value & (1 << 25)) {\n\n            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);\n\n        }\n\n        break;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu->env.v7m.vecbase[attrs.secure] = value & 0xffffff80;\n\n        break;\n\n    case 0xd0c: /* Application Interrupt/Reset Control (AIRCR) */\n\n        if ((value >> R_V7M_AIRCR_VECTKEY_SHIFT) == 0x05fa) {\n\n            if (value & R_V7M_AIRCR_SYSRESETREQ_MASK) {\n\n                if (attrs.secure ||\n\n                    !(cpu->env.v7m.aircr & R_V7M_AIRCR_SYSRESETREQS_MASK)) {\n\n                    qemu_irq_pulse(s->sysresetreq);\n\n                }\n\n            }\n\n            if (value & R_V7M_AIRCR_VECTCLRACTIVE_MASK) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Setting VECTCLRACTIVE when not in DEBUG mode \"\n\n                              \"is UNPREDICTABLE\\n\");\n\n            }\n\n            if (value & R_V7M_AIRCR_VECTRESET_MASK) {\n\n                /* NB: this bit is RES0 in v8M */\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Setting VECTRESET when not in DEBUG mode \"\n\n                              \"is UNPREDICTABLE\\n\");\n\n            }\n\n            s->prigroup[attrs.secure] = extract32(value,\n\n                                                  R_V7M_AIRCR_PRIGROUP_SHIFT,\n\n                                                  R_V7M_AIRCR_PRIGROUP_LENGTH);\n\n            if (attrs.secure) {\n\n                /* These bits are only writable by secure */\n\n                cpu->env.v7m.aircr = value &\n\n                    (R_V7M_AIRCR_SYSRESETREQS_MASK |\n\n                     R_V7M_AIRCR_BFHFNMINS_MASK |\n\n                     R_V7M_AIRCR_PRIS_MASK);\n\n                /* BFHFNMINS changes the priority of Secure HardFault, and\n\n                 * allows a pending Non-secure HardFault to preempt (which\n\n                 * we implement by marking it enabled).\n\n                 */\n\n                if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {\n\n                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -3;\n\n                    s->vectors[ARMV7M_EXCP_HARD].enabled = 1;\n\n                } else {\n\n                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -1;\n\n                    s->vectors[ARMV7M_EXCP_HARD].enabled = 0;\n\n                }\n\n            }\n\n            nvic_irq_update(s);\n\n        }\n\n        break;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement control registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"NVIC: SCR unimplemented\\n\");\n\n        break;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* Enforce RAZ/WI on reserved and must-RAZ/WI bits */\n\n        value &= (R_V7M_CCR_STKALIGN_MASK |\n\n                  R_V7M_CCR_BFHFNMIGN_MASK |\n\n                  R_V7M_CCR_DIV_0_TRP_MASK |\n\n                  R_V7M_CCR_UNALIGN_TRP_MASK |\n\n                  R_V7M_CCR_USERSETMPEND_MASK |\n\n                  R_V7M_CCR_NONBASETHRDENA_MASK);\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* v8M makes NONBASETHRDENA and STKALIGN be RES1 */\n\n            value |= R_V7M_CCR_NONBASETHRDENA_MASK\n\n                | R_V7M_CCR_STKALIGN_MASK;\n\n        }\n\n        if (attrs.secure) {\n\n            /* the BFHFNMIGN bit is not banked; keep that in the NS copy */\n\n            cpu->env.v7m.ccr[M_REG_NS] =\n\n                (cpu->env.v7m.ccr[M_REG_NS] & ~R_V7M_CCR_BFHFNMIGN_MASK)\n\n                | (value & R_V7M_CCR_BFHFNMIGN_MASK);\n\n            value &= ~R_V7M_CCR_BFHFNMIGN_MASK;\n\n        }\n\n\n\n        cpu->env.v7m.ccr[attrs.secure] = value;\n\n        break;\n\n    case 0xd24: /* System Handler Control and State (SHCSR) */\n\n        if (attrs.secure) {\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;\n\n            /* Secure HardFault active bit cannot be written */\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_PENDSV].active =\n\n                (value & (1 << 10)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SYSTICK].active =\n\n                (value & (1 << 11)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].pending =\n\n                (value & (1 << 12)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].enabled =\n\n                (value & (1 << 18)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;\n\n            /* SecureFault not banked, but RAZ/WI to NS */\n\n            s->vectors[ARMV7M_EXCP_SECURE].active = (value & (1 << 4)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SECURE].enabled = (value & (1 << 19)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SECURE].pending = (value & (1 << 20)) != 0;\n\n        } else {\n\n            s->vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;\n\n            if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n                /* HARDFAULTPENDED is not present in v7M */\n\n                s->vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;\n\n            }\n\n            s->vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;\n\n            s->vectors[ARMV7M_EXCP_PENDSV].active = (value & (1 << 10)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SYSTICK].active = (value & (1 << 11)) != 0;\n\n            s->vectors[ARMV7M_EXCP_USAGE].pending = (value & (1 << 12)) != 0;\n\n            s->vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;\n\n            s->vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;\n\n            s->vectors[ARMV7M_EXCP_USAGE].enabled = (value & (1 << 18)) != 0;\n\n        }\n\n        if (attrs.secure || (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK)) {\n\n            s->vectors[ARMV7M_EXCP_BUS].active = (value & (1 << 1)) != 0;\n\n            s->vectors[ARMV7M_EXCP_BUS].pending = (value & (1 << 14)) != 0;\n\n            s->vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;\n\n        }\n\n        /* NMIACT can only be written if the write is of a zero, with\n\n         * BFHFNMINS 1, and by the CPU in secure state via the NS alias.\n\n         */\n\n        if (!attrs.secure && cpu->env.v7m.secure &&\n\n            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&\n\n            (value & (1 << 5)) == 0) {\n\n            s->vectors[ARMV7M_EXCP_NMI].active = 0;\n\n        }\n\n        /* HARDFAULTACT can only be written if the write is of a zero\n\n         * to the non-secure HardFault state by the CPU in secure state.\n\n         * The only case where we can be targeting the non-secure HF state\n\n         * when in secure state is if this is a write via the NS alias\n\n         * and BFHFNMINS is 1.\n\n         */\n\n        if (!attrs.secure && cpu->env.v7m.secure &&\n\n            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&\n\n            (value & (1 << 2)) == 0) {\n\n            s->vectors[ARMV7M_EXCP_HARD].active = 0;\n\n        }\n\n\n\n        /* TODO: this is RAZ/WI from NS if DEMCR.SDME is set */\n\n        s->vectors[ARMV7M_EXCP_DEBUG].active = (value & (1 << 8)) != 0;\n\n        nvic_irq_update(s);\n\n        break;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        cpu->env.v7m.cfsr[attrs.secure] &= ~value; /* W1C */\n\n        if (attrs.secure) {\n\n            /* The BFSR bits [15:8] are shared between security states\n\n             * and we store them in the NS copy.\n\n             */\n\n            cpu->env.v7m.cfsr[M_REG_NS] &= ~(value & R_V7M_CFSR_BFSR_MASK);\n\n        }\n\n        break;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n        cpu->env.v7m.hfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xd30: /* Debug Fault Status.  */\n\n        cpu->env.v7m.dfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xd34: /* Mem Manage Address.  */\n\n        cpu->env.v7m.mmfar[attrs.secure] = value;\n\n        return;\n\n    case 0xd38: /* Bus Fault Address.  */\n\n        cpu->env.v7m.bfar = value;\n\n        return;\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"NVIC: Aux fault status registers unimplemented\\n\");\n\n        break;\n\n    case 0xd90: /* MPU_TYPE */\n\n        return; /* RO */\n\n    case 0xd94: /* MPU_CTRL */\n\n        if ((value &\n\n             (R_V7M_MPU_CTRL_HFNMIENA_MASK | R_V7M_MPU_CTRL_ENABLE_MASK))\n\n            == R_V7M_MPU_CTRL_HFNMIENA_MASK) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"MPU_CTRL: HFNMIENA and !ENABLE is \"\n\n                          \"UNPREDICTABLE\\n\");\n\n        }\n\n        cpu->env.v7m.mpu_ctrl[attrs.secure]\n\n            = value & (R_V7M_MPU_CTRL_ENABLE_MASK |\n\n                       R_V7M_MPU_CTRL_HFNMIENA_MASK |\n\n                       R_V7M_MPU_CTRL_PRIVDEFENA_MASK);\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    case 0xd98: /* MPU_RNR */\n\n        if (value >= cpu->pmsav7_dregion) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"MPU region out of range %\"\n\n                          PRIu32 \"/%\" PRIu32 \"\\n\",\n\n                          value, cpu->pmsav7_dregion);\n\n        } else {\n\n            cpu->env.pmsav7.rnr[attrs.secure] = value;\n\n        }\n\n        break;\n\n    case 0xd9c: /* MPU_RBAR */\n\n    case 0xda4: /* MPU_RBAR_A1 */\n\n    case 0xdac: /* MPU_RBAR_A2 */\n\n    case 0xdb4: /* MPU_RBAR_A3 */\n\n    {\n\n        int region;\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR, and there is no 'region' field in the\n\n             * RBAR register.\n\n             */\n\n            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */\n\n\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return;\n\n            }\n\n            cpu->env.pmsav8.rbar[attrs.secure][region] = value;\n\n            tlb_flush(CPU(cpu));\n\n            return;\n\n        }\n\n\n\n        if (value & (1 << 4)) {\n\n            /* VALID bit means use the region number specified in this\n\n             * value and also update MPU_RNR.REGION with that value.\n\n             */\n\n            region = extract32(value, 0, 4);\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"MPU region out of range %u/%\" PRIu32 \"\\n\",\n\n                              region, cpu->pmsav7_dregion);\n\n                return;\n\n            }\n\n            cpu->env.pmsav7.rnr[attrs.secure] = region;\n\n        } else {\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return;\n\n        }\n\n\n\n        cpu->env.pmsav7.drbar[region] = value & ~0x1f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xda0: /* MPU_RASR (v7M), MPU_RLAR (v8M) */\n\n    case 0xda8: /* MPU_RASR_A1 (v7M), MPU_RLAR_A1 (v8M) */\n\n    case 0xdb0: /* MPU_RASR_A2 (v7M), MPU_RLAR_A2 (v8M) */\n\n    case 0xdb8: /* MPU_RASR_A3 (v7M), MPU_RLAR_A3 (v8M) */\n\n    {\n\n        int region = cpu->env.pmsav7.rnr[attrs.secure];\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR.\n\n             */\n\n            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */\n\n\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return;\n\n            }\n\n            cpu->env.pmsav8.rlar[attrs.secure][region] = value;\n\n            tlb_flush(CPU(cpu));\n\n            return;\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return;\n\n        }\n\n\n\n        cpu->env.pmsav7.drsr[region] = value & 0xff3f;\n\n        cpu->env.pmsav7.dracr[region] = (value >> 16) & 0x173f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xdc0: /* MPU_MAIR0 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (cpu->pmsav7_dregion) {\n\n            /* Register is RES0 if no MPU regions are implemented */\n\n            cpu->env.pmsav8.mair0[attrs.secure] = value;\n\n        }\n\n        /* We don't need to do anything else because memory attributes\n\n         * only affect cacheability, and we don't implement caching.\n\n         */\n\n        break;\n\n    case 0xdc4: /* MPU_MAIR1 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (cpu->pmsav7_dregion) {\n\n            /* Register is RES0 if no MPU regions are implemented */\n\n            cpu->env.pmsav8.mair1[attrs.secure] = value;\n\n        }\n\n        /* We don't need to do anything else because memory attributes\n\n         * only affect cacheability, and we don't implement caching.\n\n         */\n\n        break;\n\n    case 0xdd0: /* SAU_CTRL */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.sau.ctrl = value & 3;\n\n        break;\n\n    case 0xdd4: /* SAU_TYPE */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        break;\n\n    case 0xdd8: /* SAU_RNR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (value >= cpu->sau_sregion) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"SAU region out of range %\"\n\n                          PRIu32 \"/%\" PRIu32 \"\\n\",\n\n                          value, cpu->sau_sregion);\n\n        } else {\n\n            cpu->env.sau.rnr = value;\n\n        }\n\n        break;\n\n    case 0xddc: /* SAU_RBAR */\n\n    {\n\n        int region = cpu->env.sau.rnr;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (region >= cpu->sau_sregion) {\n\n            return;\n\n        }\n\n        cpu->env.sau.rbar[region] = value & ~0x1f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xde0: /* SAU_RLAR */\n\n    {\n\n        int region = cpu->env.sau.rnr;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (region >= cpu->sau_sregion) {\n\n            return;\n\n        }\n\n        cpu->env.sau.rlar[region] = value & ~0x1c;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xde4: /* SFSR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.v7m.sfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xde8: /* SFAR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.v7m.sfsr = value;\n\n        break;\n\n    case 0xf00: /* Software Triggered Interrupt Register */\n\n    {\n\n        int excnum = (value & 0x1ff) + NVIC_FIRST_IRQ;\n\n        if (excnum < s->num_irq) {\n\n            armv7m_nvic_set_pending(s, excnum, false);\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n    bad_offset:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"NVIC: Bad write offset 0x%x\\n\", offset);\n\n    }\n\n}\n", "idx": 2143}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n", "idx": 8714}
{"project": "qemu", "commit_id": "94e7340b5db8bce7866e44e700ffa8fd26585c7e", "target": 1, "func": "int nbd_send_request(int csock, struct nbd_request *request)\n\n{\n\n    uint8_t buf[4 + 4 + 8 + 8 + 4];\n\n\n\n    cpu_to_be32w((uint32_t*)buf, NBD_REQUEST_MAGIC);\n\n    cpu_to_be32w((uint32_t*)(buf + 4), request->type);\n\n    cpu_to_be64w((uint64_t*)(buf + 8), request->handle);\n\n    cpu_to_be64w((uint64_t*)(buf + 16), request->from);\n\n    cpu_to_be32w((uint32_t*)(buf + 24), request->len);\n\n\n\n    TRACE(\"Sending request to client: \"\n\n          \"{ .from = %\" PRIu64\", .len = %u, .handle = %\" PRIu64\", .type=%i}\",\n\n          request->from, request->len, request->handle, request->type);\n\n\n\n    if (write_sync(csock, buf, sizeof(buf)) != sizeof(buf)) {\n\n        LOG(\"writing to socket failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8686}
{"project": "qemu", "commit_id": "c804c2a71752dd1e150cde768d8c54b02fa8bad9", "target": 1, "func": "static void event_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->bus_type = TYPE_SCLP_EVENTS_BUS;\n\n    dc->unplug = qdev_simple_unplug_cb;\n\n    dc->init = event_qdev_init;\n\n    dc->exit = event_qdev_exit;\n\n}\n", "idx": 5115}
{"project": "qemu", "commit_id": "e8d3b1a25f284cdf9705b7cf0412281cc9ee3a36", "target": 1, "func": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    if (bh->scheduled)\n\n        return;\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* Make sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    smp_mb();\n\n    bh->scheduled = 1;\n\n    aio_notify(ctx);\n\n}\n", "idx": 1433}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 1617}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "int kvm_arm_sync_mpstate_to_qemu(ARMCPU *cpu)\n\n{\n\n    if (cap_has_mp_state) {\n\n        struct kvm_mp_state mp_state;\n\n        int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MP_STATE, &mp_state);\n\n        if (ret) {\n\n            fprintf(stderr, \"%s: failed to get MP_STATE %d/%s\\n\",\n\n                    __func__, ret, strerror(-ret));\n\n            abort();\n\n        }\n\n        cpu->powered_off = (mp_state.mp_state == KVM_MP_STATE_STOPPED);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11833}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void old_pc_system_rom_init(MemoryRegion *rom_memory, bool isapc_ram_fw)\n\n{\n\n    char *filename;\n\n    MemoryRegion *bios, *isa_bios;\n\n    int bios_size, isa_bios_size;\n\n    int ret;\n\n\n\n    /* BIOS load */\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size <= 0 ||\n\n        (bios_size % 65536) != 0) {\n\n        goto bios_error;\n\n    }\n\n    bios = g_malloc(sizeof(*bios));\n\n    memory_region_init_ram(bios, NULL, \"pc.bios\", bios_size, &error_abort);\n\n    vmstate_register_ram_global(bios);\n\n    if (!isapc_ram_fw) {\n\n        memory_region_set_readonly(bios, true);\n\n    }\n\n    ret = rom_add_file_fixed(bios_name, (uint32_t)(-bios_size), -1);\n\n    if (ret != 0) {\n\n    bios_error:\n\n        fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = bios_size;\n\n    if (isa_bios_size > (128 * 1024)) {\n\n        isa_bios_size = 128 * 1024;\n\n    }\n\n    isa_bios = g_malloc(sizeof(*isa_bios));\n\n    memory_region_init_alias(isa_bios, NULL, \"isa-bios\", bios,\n\n                             bios_size - isa_bios_size, isa_bios_size);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        0x100000 - isa_bios_size,\n\n                                        isa_bios,\n\n                                        1);\n\n    if (!isapc_ram_fw) {\n\n        memory_region_set_readonly(isa_bios, true);\n\n    }\n\n\n\n    /* map all the bios at the top of memory */\n\n    memory_region_add_subregion(rom_memory,\n\n                                (uint32_t)(-bios_size),\n\n                                bios);\n\n}\n", "idx": 7473}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static int tty_serial_ioctl(CharDriverState *chr, int cmd, void *arg)\n\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    switch(cmd) {\n\n    case CHR_IOCTL_SERIAL_SET_PARAMS:\n\n\n            QEMUSerialSetParams *ssp = arg;\n\n            tty_serial_init(s->fd_in, ssp->speed, ssp->parity,\n\n                            ssp->data_bits, ssp->stop_bits);\n\n\n\n    case CHR_IOCTL_SERIAL_SET_BREAK:\n\n\n            int enable = *(int *)arg;\n\n            if (enable)\n\n                tcsendbreak(s->fd_in, 1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    default:\n\n        return -ENOTSUP;\n\n\n    return 0;\n", "idx": 6517}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_DIVIDE)) {\n\n        cpu_abort(dc->env, \"hardware divider is not available\\n\");\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n", "idx": 868}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static void qht_bucket_reset__locked(struct qht_bucket *head)\n\n{\n\n    struct qht_bucket *b = head;\n\n    int i;\n\n\n\n    seqlock_write_begin(&head->sequence);\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i] == NULL) {\n\n                goto done;\n\n            }\n\n            b->hashes[i] = 0;\n\n            atomic_set(&b->pointers[i], NULL);\n\n        }\n\n        b = b->next;\n\n    } while (b);\n\n done:\n\n    seqlock_write_end(&head->sequence);\n\n}\n", "idx": 1856}
{"project": "qemu", "commit_id": "1dd3a44753f10970ded50950d28353c00bfcaf91", "target": 1, "func": "static int bdrv_check_byte_request(BlockDriverState *bs, int64_t offset,\n                                   size_t size)\n{\n    int64_t len;\n    if (!bdrv_is_inserted(bs))\n        return -ENOMEDIUM;\n    if (bs->growable)\n        return 0;\n    len = bdrv_getlength(bs);\n    if (offset < 0)\n    if ((offset > len) || (len - offset < size))\n    return 0;", "idx": 7291}
{"project": "qemu", "commit_id": "5f5a1318653c08e435cfa52f60b6a712815b659d", "target": 1, "func": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n\n{\n\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    uint8_t val = data;\n\n\n\n    if (addr > (vdev->config_len - sizeof(val)))\n\n        return;\n\n\n\n    stb_p(vdev->config + addr, val);\n\n\n\n    if (k->set_config) {\n\n        k->set_config(vdev, vdev->config);\n\n    }\n\n}\n", "idx": 10092}
{"project": "qemu", "commit_id": "988e0f06621fde11ec0d319a6fd0ab3ccef0602f", "target": 1, "func": "int monitor_read_bdrv_key_start(Monitor *mon, BlockDriverState *bs,\n\n                                BlockCompletionFunc *completion_cb,\n\n                                void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    int err;\n\n\n\n    bdrv_add_key(bs, NULL, &local_err);\n\n    if (!local_err) {\n\n        if (completion_cb)\n\n            completion_cb(opaque, 0);\n\n        return 0;\n\n    }\n\n\n\n    /* Need a key for @bs */\n\n\n\n    if (monitor_ctrl_mode(mon)) {\n\n        qerror_report_err(local_err);\n\n\n        return -1;\n\n    }\n\n\n\n\n    monitor_printf(mon, \"%s (%s) is encrypted.\\n\", bdrv_get_device_name(bs),\n\n                   bdrv_get_encrypted_filename(bs));\n\n\n\n    mon->password_completion_cb = completion_cb;\n\n    mon->password_opaque = opaque;\n\n\n\n    err = monitor_read_password(mon, bdrv_password_cb, bs);\n\n\n\n    if (err && completion_cb)\n\n        completion_cb(opaque, err);\n\n\n\n    return err;\n\n}", "idx": 5890}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_write_flush(QEMUFile *f, RDMAContext *rdma)\n\n{\n\n    int ret;\n\n\n\n    if (!rdma->current_length) {\n\n        return 0;\n\n    }\n\n\n\n    ret = qemu_rdma_write_one(f, rdma,\n\n            rdma->current_index, rdma->current_addr, rdma->current_length);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        rdma->nb_sent++;\n\n        DDDPRINTF(\"sent total: %d\\n\", rdma->nb_sent);\n\n    }\n\n\n\n    rdma->current_length = 0;\n\n    rdma->current_addr = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 1214}
{"project": "qemu", "commit_id": "206ae74aea5593f5f5bad769a6b4f101f17bc6fd", "target": 1, "func": "uint32_t do_arm_semihosting(CPUState *env)\n\n{\n\n    target_ulong args;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = env->opaque;\n\n#else\n\n    CPUState *ts = env;\n\n#endif\n\n\n\n    nr = env->regs[0];\n\n    args = env->regs[1];\n\n    switch (nr) {\n\n    case SYS_OPEN:\n\n        if (!(s = lock_user_string(ARG(0))))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        if (ARG(1) >= 12)\n\n            return (uint32_t)-1;\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            if (ARG(1) < 4)\n\n                return STDIN_FILENO;\n\n            else\n\n                return STDOUT_FILENO;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"open,%s,%x,1a4\", ARG(0),\n\n\t\t\t   (int)ARG(2)+1, gdb_open_modeflags[ARG(1)]);\n\n            return env->regs[0];\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[ARG(1)], 0644));\n\n        }\n\n        unlock_user(s, ARG(0), 0);\n\n        return ret;\n\n    case SYS_CLOSE:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"close,%x\", ARG(0));\n\n            return env->regs[0];\n\n        } else {\n\n            return set_swi_errno(ts, close(ARG(0)));\n\n        }\n\n    case SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                gdb_do_syscall(arm_semi_cb, \"write,2,%x,1\", args);\n\n                return env->regs[0];\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"write,2,%x,%x\\n\", args, len);\n\n            ret = env->regs[0];\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case SYS_WRITE:\n\n        len = ARG(2);\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            gdb_do_syscall(arm_semi_cb, \"write,%x,%x,%x\", ARG(0), ARG(1), len);\n\n            return env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user(VERIFY_READ, ARG(1), len, 1)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ret = set_swi_errno(ts, write(ARG(0), s, len));\n\n            unlock_user(s, ARG(1), 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case SYS_READ:\n\n        len = ARG(2);\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            gdb_do_syscall(arm_semi_cb, \"read,%x,%x,%x\", ARG(0), ARG(1), len);\n\n            return env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user(VERIFY_WRITE, ARG(1), len, 0)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            do\n\n              ret = set_swi_errno(ts, read(ARG(0), s, len));\n\n            while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, ARG(1), len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case SYS_READC:\n\n       /* XXX: Read from debug cosole. Not implemented.  */\n\n        return 0;\n\n    case SYS_ISTTY:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"isatty,%x\", ARG(0));\n\n            return env->regs[0];\n\n        } else {\n\n            return isatty(ARG(0));\n\n        }\n\n    case SYS_SEEK:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"lseek,%x,%x,0\", ARG(0), ARG(1));\n\n            return env->regs[0];\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(ARG(0), ARG(1), SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case SYS_FLEN:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_flen_cb, \"fstat,%x,%x\",\n\n\t\t\t   ARG(0), env->regs[13]-64);\n\n            return env->regs[0];\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(ARG(0), &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case SYS_REMOVE:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"unlink,%s\", ARG(0), (int)ARG(1)+1);\n\n            ret = env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user_string(ARG(0))))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, ARG(0), 0);\n\n        }\n\n        return ret;\n\n    case SYS_RENAME:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"rename,%s,%s\",\n\n                           ARG(0), (int)ARG(1)+1, ARG(2), (int)ARG(3)+1);\n\n            return env->regs[0];\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(ARG(0));\n\n            s2 = lock_user_string(ARG(2));\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, ARG(2), 0);\n\n            if (s)\n\n                unlock_user(s, ARG(0), 0);\n\n            return ret;\n\n        }\n\n    case SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case SYS_SYSTEM:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"system,%s\", ARG(0), (int)ARG(1)+1);\n\n            return env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user_string(ARG(0))))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, ARG(0), 0);\n\n            return ret;\n\n        }\n\n    case SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case SYS_GET_CMDLINE:\n\n#ifdef CONFIG_USER_ONLY\n\n        /* Build a commandline from the original argv.  */\n\n        {\n\n            char *arm_cmdline_buffer;\n\n            const char *host_cmdline_buffer;\n\n\n\n            unsigned int i;\n\n            unsigned int arm_cmdline_len = ARG(1);\n\n            unsigned int host_cmdline_len =\n\n                ts->info->arg_end-ts->info->arg_start;\n\n\n\n            if (!arm_cmdline_len || host_cmdline_len > arm_cmdline_len) {\n\n                return -1; /* not enough space to store command line */\n\n            }\n\n\n\n            if (!host_cmdline_len) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                arm_cmdline_buffer = lock_user(VERIFY_WRITE, ARG(0), 1, 0);\n\n                arm_cmdline_buffer[0] = 0;\n\n                unlock_user(arm_cmdline_buffer, ARG(0), 1);\n\n\n\n                /* Adjust the commandline length argument. */\n\n                SET_ARG(1, 0);\n\n                return 0;\n\n            }\n\n\n\n            /* lock the buffers on the ARM side */\n\n            arm_cmdline_buffer =\n\n                lock_user(VERIFY_WRITE, ARG(0), host_cmdline_len, 0);\n\n            host_cmdline_buffer =\n\n                lock_user(VERIFY_READ, ts->info->arg_start,\n\n                                       host_cmdline_len, 1);\n\n\n\n            if (arm_cmdline_buffer && host_cmdline_buffer)\n\n            {\n\n                /* the last argument is zero-terminated;\n\n                   no need for additional termination */\n\n                memcpy(arm_cmdline_buffer, host_cmdline_buffer,\n\n                       host_cmdline_len);\n\n\n\n                /* separate arguments by white spaces */\n\n                for (i = 0; i < host_cmdline_len-1; i++) {\n\n                    if (arm_cmdline_buffer[i] == 0) {\n\n                        arm_cmdline_buffer[i] = ' ';\n\n                    }\n\n                }\n\n\n\n                /* Adjust the commandline length argument. */\n\n                SET_ARG(1, host_cmdline_len-1);\n\n            }\n\n\n\n            /* Unlock the buffers on the ARM side.  */\n\n            unlock_user(arm_cmdline_buffer, ARG(0), host_cmdline_len);\n\n            unlock_user((void*)host_cmdline_buffer, ts->info->arg_start, 0);\n\n\n\n            /* Return success if we could return a commandline.  */\n\n            return (arm_cmdline_buffer && host_cmdline_buffer) ? 0 : -1;\n\n        }\n\n#else\n\n        return -1;\n\n#endif\n\n    case SYS_HEAPINFO:\n\n        {\n\n            uint32_t *ptr;\n\n            uint32_t limit;\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                long ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret != -1)\n\n                        break;\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            if (!(ptr = lock_user(VERIFY_WRITE, ARG(0), 16, 0)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ptr[0] = tswap32(ts->heap_base);\n\n            ptr[1] = tswap32(ts->heap_limit);\n\n            ptr[2] = tswap32(ts->stack_base);\n\n            ptr[3] = tswap32(0); /* Stack limit.  */\n\n            unlock_user(ptr, ARG(0), 16);\n\n#else\n\n            limit = ram_size;\n\n            if (!(ptr = lock_user(VERIFY_WRITE, ARG(0), 16, 0)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            ptr[0] = tswap32(limit / 2);\n\n            ptr[1] = tswap32(limit);\n\n            ptr[2] = tswap32(limit); /* Stack base */\n\n            ptr[3] = tswap32(0); /* Stack limit.  */\n\n            unlock_user(ptr, ARG(0), 16);\n\n#endif\n\n            return 0;\n\n        }\n\n    case SYS_EXIT:\n\n        gdb_exit(env, 0);\n\n        exit(0);\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(env, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 2992}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_check(GSource *source)\n\n{\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return cond & wsource->condition;\n\n}\n", "idx": 7187}
{"project": "qemu", "commit_id": "d2e9fd8f703203c2eeeed120b1ef6c3a6574e0ab", "target": 1, "func": "static always_inline void gen_op_arith_subf(DisasContext *ctx, TCGv ret, TCGv arg1, TCGv arg2,\n\n                                            int add_ca, int compute_ca, int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret, arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_andi_tl(t1, cpu_xer, (1 << XER_CA));\n\n        tcg_gen_shri_tl(t1, t1, XER_CA);\n\n\n\n    }\n\n\n\n    if (compute_ca && compute_ov) {\n\n        /* Start with XER CA and OV disabled, the most likely case */\n\n        tcg_gen_andi_tl(cpu_xer, cpu_xer, ~((1 << XER_CA) | (1 << XER_OV)));\n\n    } else if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_andi_tl(cpu_xer, cpu_xer, ~(1 << XER_CA));\n\n    } else if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_andi_tl(cpu_xer, cpu_xer, ~(1 << XER_OV));\n\n    }\n\n\n\n    if (add_ca) {\n\n        tcg_gen_not_tl(t0, arg1);\n\n        tcg_gen_add_tl(t0, t0, arg2);\n\n        gen_op_arith_compute_ca(ctx, t0, arg2, 0);\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n\n        tcg_gen_sub_tl(t0, arg2, arg1);\n\n        if (compute_ca) {\n\n            gen_op_arith_compute_ca(ctx, t0, arg2, 1);\n\n        }\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 1);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}", "idx": 9031}
{"project": "qemu", "commit_id": "27ef9cb0e77eda46618ea084adffa63ebde5be80", "target": 1, "func": "static CharDriverState *qemu_chr_open_pp_fd(int fd,\n\n                                            ChardevCommon *backend,\n\n                                            Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ParallelCharDriver *drv;\n\n\n\n    if (ioctl(fd, PPCLAIM) < 0) {\n\n        error_setg_errno(errp, errno, \"not a parallel port\");\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    drv = g_new0(ParallelCharDriver, 1);\n\n    drv->fd = fd;\n\n    drv->mode = IEEE1284_MODE_COMPAT;\n\n\n\n    chr = qemu_chr_alloc(backend, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    chr->chr_close = pp_close;\n\n    chr->opaque = drv;\n\n\n\n    return chr;\n\n}\n", "idx": 4401}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void framebuffer_update_request(VncState *vs, int incremental,\n\n                                       int x_position, int y_position,\n\n                                       int w, int h)\n\n{\n\n    int i;\n\n    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;\n\n    const size_t height = surface_height(vs->vd->ds);\n\n\n\n    if (y_position > height) {\n\n        y_position = height;\n\n    }\n\n    if (y_position + h >= height) {\n\n        h = height - y_position;\n\n    }\n\n\n\n    vs->need_update = 1;\n\n    if (!incremental) {\n\n        vs->force_update = 1;\n\n        for (i = 0; i < h; i++) {\n\n            bitmap_set(vs->dirty[y_position + i], 0, width);\n\n            bitmap_clear(vs->dirty[y_position + i], width,\n\n                         VNC_DIRTY_BITS - width);\n\n        }\n\n    }\n\n}\n", "idx": 3163}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 10612}
{"project": "qemu", "commit_id": "63fa06dc978f3669dbfd9443b33cde9e2a7f4b41", "target": 1, "func": "static int vdi_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    VdiHeader header;\n\n    size_t bmap_size;\n\n    int ret;\n\n\n\n    logout(\"\\n\");\n\n\n\n    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    vdi_header_to_cpu(&header);\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n\n\n    if (header.disk_size % SECTOR_SIZE != 0) {\n\n        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.\n\n           We accept them but round the disk size to the next multiple of\n\n           SECTOR_SIZE. */\n\n        logout(\"odd disk size %\" PRIu64 \" B, round up\\n\", header.disk_size);\n\n        header.disk_size += SECTOR_SIZE - 1;\n\n        header.disk_size &= ~(SECTOR_SIZE - 1);\n\n    }\n\n\n\n    if (header.signature != VDI_SIGNATURE) {\n\n        error_setg(errp, \"Image not in VDI format (bad signature %08x)\", header.signature);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else if (header.version != VDI_VERSION_1_1) {\n\n        error_setg(errp, \"unsupported VDI image (version %u.%u)\",\n\n                   header.version >> 16, header.version & 0xffff);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_bmap % SECTOR_SIZE != 0) {\n\n        /* We only support block maps which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned block map offset \"\n\n                   \"0x%x)\", header.offset_bmap);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_data % SECTOR_SIZE != 0) {\n\n        /* We only support data blocks which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned data offset 0x%x)\",\n\n                   header.offset_data);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.sector_size != SECTOR_SIZE) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.sector_size, SECTOR_SIZE);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.block_size != 1 * MiB) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.block_size, 1 * MiB);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.disk_size >\n\n               (uint64_t)header.blocks_in_image * header.block_size) {\n\n        error_setg(errp, \"unsupported VDI image (disk size %\" PRIu64 \", \"\n\n                   \"image bitmap has room for %\" PRIu64 \")\",\n\n                   header.disk_size,\n\n                   (uint64_t)header.blocks_in_image * header.block_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_link)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL link UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_parent)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL parent UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    bs->total_sectors = header.disk_size / SECTOR_SIZE;\n\n\n\n    s->block_size = header.block_size;\n\n    s->block_sectors = header.block_size / SECTOR_SIZE;\n\n    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;\n\n    s->header = header;\n\n\n\n    bmap_size = header.blocks_in_image * sizeof(uint32_t);\n\n    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    s->bmap = g_malloc(bmap_size * SECTOR_SIZE);\n\n    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);\n\n    if (ret < 0) {\n\n        goto fail_free_bmap;\n\n    }\n\n\n\n    /* Disable migration when vdi images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vdi\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\n fail_free_bmap:\n\n    g_free(s->bmap);\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 1381}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static hwaddr ppc_hash64_htab_lookup(CPUPPCState *env,\n\n                                     ppc_slb_t *slb, target_ulong eaddr,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    hwaddr pteg_off, pte_offset;\n\n    hwaddr hash;\n\n    uint64_t vsid, epnshift, epnmask, epn, ptem;\n\n\n\n    /* Page size according to the SLB, which we use to generate the\n\n     * EPN for hash table lookup..  When we implement more recent MMU\n\n     * extensions this might be different from the actual page size\n\n     * encoded in the PTE */\n\n    epnshift = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    epnmask = ~((1ULL << epnshift) - 1);\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        /* 1TB segment */\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        epn = (eaddr & ~SEGMENT_MASK_1T) & epnmask;\n\n        hash = vsid ^ (vsid << 25) ^ (epn >> epnshift);\n\n    } else {\n\n        /* 256M segment */\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        epn = (eaddr & ~SEGMENT_MASK_256M) & epnmask;\n\n        hash = vsid ^ (epn >> epnshift);\n\n    }\n\n    ptem = (slb->vsid & SLB_VSID_PTEM) | ((epn >> 16) & HPTE64_V_AVPN);\n\n\n\n    /* Page address translation */\n\n    LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n            \" hash \" TARGET_FMT_plx \"\\n\",\n\n            env->htab_base, env->htab_mask, hash);\n\n\n\n    /* Primary PTEG lookup */\n\n    LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n            \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n            \" hash=\" TARGET_FMT_plx \"\\n\",\n\n            env->htab_base, env->htab_mask, vsid, ptem,  hash);\n\n    pteg_off = (hash * HASH_PTEG_SIZE_64) & env->htab_mask;\n\n    pte_offset = ppc_hash64_pteg_search(env, pteg_off, 0, ptem, pte);\n\n\n\n    if (pte_offset == -1) {\n\n        /* Secondary PTEG lookup */\n\n        LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                env->htab_mask, vsid, ptem, ~hash);\n\n\n\n        pteg_off = (~hash * HASH_PTEG_SIZE_64) & env->htab_mask;\n\n        pte_offset = ppc_hash64_pteg_search(env, pteg_off, 1, ptem, pte);\n\n    }\n\n\n\n    return pte_offset;\n\n}\n", "idx": 6362}
{"project": "qemu", "commit_id": "398489018183d613306ab022653552247d93919f", "target": 1, "func": "PcGuestInfo *pc_guest_info_init(ram_addr_t below_4g_mem_size,\n\n                                ram_addr_t above_4g_mem_size)\n\n{\n\n    PcGuestInfoState *guest_info_state = g_malloc0(sizeof *guest_info_state);\n\n    PcGuestInfo *guest_info = &guest_info_state->info;\n\n\n\n    guest_info->pci_info.w32.end = IO_APIC_DEFAULT_ADDRESS;\n\n    if (sizeof(hwaddr) == 4) {\n\n        guest_info->pci_info.w64.begin = 0;\n\n        guest_info->pci_info.w64.end = 0;\n\n    } else {\n\n        /*\n\n         * BIOS does not set MTRR entries for the 64 bit window, so no need to\n\n         * align address to power of two.  Align address at 1G, this makes sure\n\n         * it can be exactly covered with a PAT entry even when using huge\n\n         * pages.\n\n         */\n\n        guest_info->pci_info.w64.begin =\n\n            ROUND_UP((0x1ULL << 32) + above_4g_mem_size, 0x1ULL << 30);\n\n        guest_info->pci_info.w64.end = guest_info->pci_info.w64.begin +\n\n            (0x1ULL << 62);\n\n        assert(guest_info->pci_info.w64.begin <= guest_info->pci_info.w64.end);\n\n    }\n\n\n\n    guest_info_state->machine_done.notify = pc_guest_info_machine_done;\n\n    qemu_add_machine_init_done_notifier(&guest_info_state->machine_done);\n\n    return guest_info;\n\n}\n", "idx": 7329}
{"project": "qemu", "commit_id": "34e1c27bc3094ffe484d9855e07ad104bddf579f", "target": 1, "func": "uint32 float32_to_uint32( float32 a STATUS_PARAM )\n\n{\n\n    int64_t v;\n\n    uint32 res;\n\n\n\n    v = float32_to_int64(a STATUS_VAR);\n\n    if (v < 0) {\n\n        res = 0;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else if (v > 0xffffffff) {\n\n        res = 0xffffffff;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else {\n\n        res = v;\n\n    }\n\n    return res;\n\n}\n", "idx": 7624}
{"project": "qemu", "commit_id": "16f4e8fa737b58b7b0461b33581e43ac06991110", "target": 1, "func": "void qmp_guest_shutdown(bool has_mode, const char *mode, Error **err)\n\n{\n\n    UINT shutdown_flag = EWX_FORCE;\n\n\n\n    slog(\"guest-shutdown called, mode: %s\", mode);\n\n\n\n    if (!has_mode || strcmp(mode, \"powerdown\") == 0) {\n\n        shutdown_flag |= EWX_POWEROFF;\n\n    } else if (strcmp(mode, \"halt\") == 0) {\n\n        shutdown_flag |= EWX_SHUTDOWN;\n\n    } else if (strcmp(mode, \"reboot\") == 0) {\n\n        shutdown_flag |= EWX_REBOOT;\n\n    } else {\n\n        error_set(err, QERR_INVALID_PARAMETER_VALUE, \"mode\",\n\n                  \"halt|powerdown|reboot\");\n\n        return;\n\n    }\n\n\n\n    /* Request a shutdown privilege, but try to shut down the system\n\n       anyway. */\n\n    acquire_privilege(SE_SHUTDOWN_NAME, err);\n\n    if (error_is_set(err)) {\n\n        return;\n\n    }\n\n\n\n    if (!ExitWindowsEx(shutdown_flag, SHTDN_REASON_FLAG_PLANNED)) {\n\n        slog(\"guest-shutdown failed: %d\", GetLastError());\n\n        error_set(err, QERR_UNDEFINED_ERROR);\n\n    }\n\n}\n", "idx": 906}
{"project": "qemu", "commit_id": "01979a98d75b49c2acbbbb71521c285f8d8f9fb7", "target": 1, "func": "static int bdrv_qed_check(BlockDriverState *bs, BdrvCheckResult *result)\n\n{\n\n    return -ENOTSUP;\n\n}\n", "idx": 309}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 10050}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "iscsi_set_events(IscsiLun *iscsilun)\n\n{\n\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    int ev = iscsi_which_events(iscsi);\n\n\n\n    if (ev != iscsilun->events) {\n\n        aio_set_fd_handler(iscsilun->aio_context,\n\n                           iscsi_get_fd(iscsi),\n\n                           (ev & POLLIN) ? iscsi_process_read : NULL,\n\n                           (ev & POLLOUT) ? iscsi_process_write : NULL,\n\n                           iscsilun);\n\n        iscsilun->events = ev;\n\n    }\n\n\n\n    /* newer versions of libiscsi may return zero events. In this\n\n     * case start a timer to ensure we are able to return to service\n\n     * once this situation changes. */\n\n    if (!ev) {\n\n        timer_mod(iscsilun->event_timer,\n\n                  qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);\n\n    }\n\n}\n", "idx": 5034}
{"project": "qemu", "commit_id": "0ead93120eb7bd770b32adc00b5ec1ee721626dc", "target": 1, "func": "static bool is_sector_request_lun_aligned(int64_t sector_num, int nb_sectors,\n\n                                          IscsiLun *iscsilun)\n\n{\n\n    assert(nb_sectors < BDRV_REQUEST_MAX_SECTORS);\n\n    return is_byte_request_lun_aligned(sector_num << BDRV_SECTOR_BITS,\n\n                                       nb_sectors << BDRV_SECTOR_BITS,\n\n                                       iscsilun);\n\n}\n", "idx": 9696}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint32_t *v = pv;\n\n    qemu_get_be32s(f, v);\n\n    return 0;\n\n}\n", "idx": 6438}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_set(Error **errp, ErrorClass err_class, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, err_class, fmt, ap);\n\n    va_end(ap);\n\n}\n", "idx": 3866}
{"project": "qemu", "commit_id": "073de86aa934d46d596a2367e7501da5500e5b86", "target": 1, "func": "static hwaddr ppc_hash64_htab_lookup(PowerPCCPU *cpu,\n\n                                     ppc_slb_t *slb, target_ulong eaddr,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    hwaddr pte_offset;\n\n    hwaddr hash;\n\n    uint64_t vsid, epnmask, epn, ptem;\n\n\n\n    /* The SLB store path should prevent any bad page size encodings\n\n     * getting in there, so: */\n\n    assert(slb->sps);\n\n\n\n    epnmask = ~((1ULL << slb->sps->page_shift) - 1);\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        /* 1TB segment */\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        epn = (eaddr & ~SEGMENT_MASK_1T) & epnmask;\n\n        hash = vsid ^ (vsid << 25) ^ (epn >> slb->sps->page_shift);\n\n    } else {\n\n        /* 256M segment */\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        epn = (eaddr & ~SEGMENT_MASK_256M) & epnmask;\n\n        hash = vsid ^ (epn >> slb->sps->page_shift);\n\n    }\n\n    ptem = (slb->vsid & SLB_VSID_PTEM) | ((epn >> 16) & HPTE64_V_AVPN);\n\n\n\n    /* Page address translation */\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n            \" hash \" TARGET_FMT_plx \"\\n\",\n\n            env->htab_base, env->htab_mask, hash);\n\n\n\n    /* Primary PTEG lookup */\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n            \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n            \" hash=\" TARGET_FMT_plx \"\\n\",\n\n            env->htab_base, env->htab_mask, vsid, ptem,  hash);\n\n    pte_offset = ppc_hash64_pteg_search(cpu, hash, slb, 0, ptem, pte);\n\n\n\n    if (pte_offset == -1) {\n\n        /* Secondary PTEG lookup */\n\n        qemu_log_mask(CPU_LOG_MMU,\n\n                \"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                env->htab_mask, vsid, ptem, ~hash);\n\n\n\n        pte_offset = ppc_hash64_pteg_search(cpu, ~hash, slb, 1, ptem, pte);\n\n    }\n\n\n\n    return pte_offset;\n\n}\n", "idx": 3424}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "static int scsi_qdev_init(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n    SCSIBus *bus = DO_UPCAST(SCSIBus, qbus, dev->qdev.parent_bus);\n\n    SCSIDevice *d;\n\n    int rc = -1;\n\n\n\n    if (dev->channel > bus->info->max_channel) {\n\n        error_report(\"bad scsi channel id: %d\", dev->channel);\n\n        goto err;\n\n    }\n\n    if (dev->id != -1 && dev->id > bus->info->max_target) {\n\n        error_report(\"bad scsi device id: %d\", dev->id);\n\n        goto err;\n\n    }\n\n\n\n    if (dev->id == -1) {\n\n        int id = -1;\n\n        if (dev->lun == -1) {\n\n            dev->lun = 0;\n\n        }\n\n        do {\n\n            d = scsi_device_find(bus, dev->channel, ++id, dev->lun);\n\n        } while (d && d->lun == dev->lun && id <= bus->info->max_target);\n\n        if (id > bus->info->max_target) {\n\n            error_report(\"no free target\");\n\n            goto err;\n\n        }\n\n        dev->id = id;\n\n    } else if (dev->lun == -1) {\n\n        int lun = -1;\n\n        do {\n\n            d = scsi_device_find(bus, dev->channel, dev->id, ++lun);\n\n        } while (d && d->lun == lun && lun < bus->info->max_lun);\n\n        if (lun > bus->info->max_lun) {\n\n            error_report(\"no free lun\");\n\n            goto err;\n\n        }\n\n        dev->lun = lun;\n\n    } else {\n\n        d = scsi_device_find(bus, dev->channel, dev->id, dev->lun);\n\n        if (dev->lun == d->lun && dev != d) {\n\n            qdev_free(&d->qdev);\n\n        }\n\n    }\n\n\n\n    QTAILQ_INIT(&dev->requests);\n\n    rc = scsi_device_init(dev);\n\n    if (rc == 0) {\n\n        dev->vmsentry = qemu_add_vm_change_state_handler(scsi_dma_restart_cb,\n\n                                                         dev);\n\n    }\n\n\n\nerr:\n\n    return rc;\n\n}\n", "idx": 2531}
{"project": "qemu", "commit_id": "8c6c0478996e8f77374e69b6df68655b0b4ba689", "target": 1, "func": "vmxnet3_init_msi(VMXNET3State *s)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    int res;\n\n\n\n    res = msi_init(d, VMXNET3_MSI_OFFSET, VMXNET3_MSI_NUM_VECTORS,\n\n                   VMXNET3_USE_64BIT, VMXNET3_PER_VECTOR_MASK);\n\n    if (0 > res) {\n\n        VMW_WRPRN(\"Failed to initialize MSI, error %d\", res);\n\n        s->msi_used = false;\n\n    } else {\n\n        s->msi_used = true;\n\n    }\n\n\n\n    return s->msi_used;\n\n}\n", "idx": 6988}
{"project": "qemu", "commit_id": "e167adc9d9f5df4f8109aecd4552c407fdce094a", "target": 1, "func": "static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,\n\n                                   unsigned int imms, unsigned int immr)\n\n{\n\n    uint64_t mask;\n\n    unsigned e, levels, s, r;\n\n    int len;\n\n\n\n    assert(immn < 2 && imms < 64 && immr < 64);\n\n\n\n    /* The bit patterns we create here are 64 bit patterns which\n\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n\n     * 64 bits each. Each element contains the same value: a run\n\n     * of between 1 and e-1 non-zero bits, rotated within the\n\n     * element by between 0 and e-1 bits.\n\n     *\n\n     * The element size and run length are encoded into immn (1 bit)\n\n     * and imms (6 bits) as follows:\n\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n", "idx": 4341}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static uint32_t m5206_mbar_readb(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    if (m5206_mbar_width[offset >> 2] > 1) {\n\n        uint16_t val;\n\n        val = m5206_mbar_readw(opaque, offset & ~1);\n\n        if ((offset & 1) == 0) {\n\n            val >>= 8;\n\n        }\n\n        return val & 0xff;\n\n    }\n\n    return m5206_mbar_read(s, offset, 1);\n\n}\n", "idx": 6698}
{"project": "qemu", "commit_id": "f2d089425d43735b5369f70f3a36b712440578e5", "target": 1, "func": "static MemTxResult  memory_region_read_accessor(MemoryRegion *mr,\n\n                                                hwaddr addr,\n\n                                                uint64_t *value,\n\n                                                unsigned size,\n\n                                                unsigned shift,\n\n                                                uint64_t mask,\n\n                                                MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = mr->ops->read(mr->opaque, addr, size);\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    *value |= (tmp & mask) << shift;\n\n    return MEMTX_OK;\n\n}", "idx": 2704}
{"project": "qemu", "commit_id": "e9db8ff38e539260a2cb5a7918d1155b7d92a264", "target": 1, "func": "static struct glfs *qemu_gluster_init(BlockdevOptionsGluster *gconf,\n\n                                      const char *filename,\n\n                                      QDict *options, Error **errp)\n\n{\n\n    int ret;\n\n    if (filename) {\n\n        ret = qemu_gluster_parse_uri(gconf, filename);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"invalid URI\");\n\n            error_append_hint(errp, \"Usage: file=gluster[+transport]://\"\n\n                                    \"[host[:port]]/volume/path[?socket=...]\\n\");\n\n            errno = -ret;\n\n            return NULL;\n\n        }\n\n    } else {\n\n        ret = qemu_gluster_parse_json(gconf, options, errp);\n\n        if (ret < 0) {\n\n            error_append_hint(errp, \"Usage: \"\n\n                             \"-drive driver=qcow2,file.driver=gluster,\"\n\n                             \"file.volume=testvol,file.path=/path/a.qcow2\"\n\n                             \"[,file.debug=9],file.server.0.type=tcp,\"\n\n                             \"file.server.0.host=1.2.3.4,\"\n\n                             \"file.server.0.port=24007,\"\n\n                             \"file.server.1.transport=unix,\"\n\n                             \"file.server.1.socket=/var/run/glusterd.socket ...\"\n\n                             \"\\n\");\n\n            errno = -ret;\n\n            return NULL;\n\n        }\n\n\n\n    }\n\n\n\n    return qemu_gluster_glfs_init(gconf, errp);\n\n}\n", "idx": 3305}
{"project": "qemu", "commit_id": "b56d417b8d7548e913d928809ce6bb1d6c2563e2", "target": 1, "func": "static unsigned hpte_page_shift(const struct ppc_one_seg_page_size *sps,\n\n    uint64_t pte0, uint64_t pte1)\n\n{\n\n    int i;\n\n\n\n    if (!(pte0 & HPTE64_V_LARGE)) {\n\n        if (sps->page_shift != 12) {\n\n            /* 4kiB page in a non 4kiB segment */\n\n            return 0;\n\n        }\n\n        /* Normal 4kiB page */\n\n        return 12;\n\n    }\n\n\n\n    for (i = 0; i < PPC_PAGE_SIZES_MAX_SZ; i++) {\n\n        const struct ppc_one_page_size *ps = &sps->enc[i];\n\n        uint64_t mask;\n\n\n\n        if (!ps->page_shift) {\n\n            break;\n\n        }\n\n\n\n        if (ps->page_shift == 12) {\n\n            /* L bit is set so this can't be a 4kiB page */\n\n            continue;\n\n        }\n\n\n\n        mask = ((1ULL << ps->page_shift) - 1) & HPTE64_R_RPN;\n\n\n\n        if ((pte1 & mask) == (ps->pte_enc << HPTE64_R_RPN_SHIFT)) {\n\n            return ps->page_shift;\n\n        }\n\n    }\n\n\n\n    return 0; /* Bad page size encoding */\n\n}\n", "idx": 6381}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void network_init(void)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n        const char *default_devaddr = NULL;\n\n\n\n        if (i == 0 && (!nd->model || strcmp(nd->model, \"pcnet\") == 0))\n\n            /* The malta board has a PCNet card using PCI SLOT 11 */\n\n            default_devaddr = \"0b\";\n\n\n\n        pci_nic_init(nd, \"pcnet\", default_devaddr);\n\n    }\n\n}\n", "idx": 5013}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void omap_timer_clk_setup(struct omap_mpu_timer_s *timer)\n\n{\n\n    omap_clk_adduser(timer->clk,\n\n                    qemu_allocate_irqs(omap_timer_clk_update, timer, 1)[0]);\n\n    timer->rate = omap_clk_getrate(timer->clk);\n\n}\n", "idx": 11314}
{"project": "qemu", "commit_id": "908bcd540f489f7adf2d804347905b0025d808d3", "target": 1, "func": "int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)\n\n{\n\n\n\n\n    if (bs->drv->bdrv_check == NULL) {\n\n        return -ENOTSUP;\n\n\n\n\n    memset(res, 0, sizeof(*res));\n\n    return bs->drv->bdrv_check(bs, res, fix);\n", "idx": 5001}
{"project": "qemu", "commit_id": "e05ca8200216149008fa1b1d1d847bf16691f6b4", "target": 1, "func": "int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev)\n\n{\n\n    int i, r;\n\n\n\n    hdev->started = true;\n\n\n\n    r = vhost_dev_set_features(hdev, hdev->log_enabled);\n\n    if (r < 0) {\n\n        goto fail_features;\n\n    }\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_MEM_TABLE, hdev->mem);\n\n    if (r < 0) {\n\n        r = -errno;\n\n        goto fail_mem;\n\n    }\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_start(hdev,\n\n                                  vdev,\n\n                                  hdev->vqs + i,\n\n                                  hdev->vq_index + i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n\n\n    if (hdev->log_enabled) {\n\n        hdev->log_size = vhost_get_log_size(hdev);\n\n        hdev->log = hdev->log_size ?\n\n            g_malloc0(hdev->log_size * sizeof *hdev->log) : NULL;\n\n        r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_LOG_BASE, hdev->log);\n\n        if (r < 0) {\n\n            r = -errno;\n\n            goto fail_log;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nfail_log:\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_stop(hdev,\n\n                             vdev,\n\n                             hdev->vqs + i,\n\n                             hdev->vq_index + i);\n\n    }\n\n    i = hdev->nvqs;\n\nfail_mem:\n\nfail_features:\n\n\n\n    hdev->started = false;\n\n    return r;\n\n}\n", "idx": 10517}
{"project": "qemu", "commit_id": "8af00205445eb901f17ca5b632d976065187538e", "target": 1, "func": "ssize_t v9fs_get_xattr(FsContext *ctx, const char *path,\n\n                       const char *name, void *value, size_t size)\n\n{\n\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n\n    if (xops) {\n\n        return xops->getxattr(ctx, path, name, value, size);\n\n    }\n\n    errno = -EOPNOTSUPP;\n\n    return -1;\n\n}\n", "idx": 4608}
{"project": "qemu", "commit_id": "e612a1f7256bb3546cf3e9ae6cad3997c4153663", "target": 1, "func": "target_read_memory (bfd_vma memaddr,\n\n                    bfd_byte *myaddr,\n\n                    int length,\n\n                    struct disassemble_info *info)\n\n{\n\n    int i;\n\n    for(i = 0; i < length; i++) {\n\n        myaddr[i] = ldub_code(memaddr + i);\n\n    }\n\n    return 0;\n\n}\n", "idx": 1026}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "static int spapr_nvram_init(VIOsPAPRDevice *dev)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n\n\n    if (nvram->drive) {\n\n        nvram->size = bdrv_getlength(nvram->drive);\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n        nvram->buf = g_malloc0(nvram->size);\n\n    }\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        fprintf(stderr, \"spapr-nvram must be between %d and %d bytes in size\\n\",\n\n                MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    spapr_rtas_register(\"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(\"nvram-store\", rtas_nvram_store);\n\n\n\n    return 0;\n\n}\n", "idx": 7192}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "void vnc_init_state(VncState *vs)\n\n{\n\n    vs->initialized = true;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    vs->last_x = -1;\n\n    vs->last_y = -1;\n\n\n\n    vs->as.freq = 44100;\n\n    vs->as.nchannels = 2;\n\n    vs->as.fmt = AUD_FMT_S16;\n\n    vs->as.endianness = 0;\n\n\n\n    qemu_mutex_init(&vs->output_mutex);\n\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n\n\n    QTAILQ_INSERT_HEAD(&vd->clients, vs, next);\n\n\n\n    graphic_hw_update(vd->dcl.con);\n\n\n\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_version, 12);\n\n    reset_keys(vs);\n\n    if (vs->vd->lock_key_sync)\n\n        vs->led = qemu_add_led_event_handler(kbd_leds, vs);\n\n\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n\n\n    /* vs might be free()ed here */\n\n}\n", "idx": 1861}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 6394}
{"project": "qemu", "commit_id": "b981289c493c7ddabc1cdf7de99daa24642c7739", "target": 1, "func": "static void ppc_heathrow_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    const char *boot_device = machine->boot_order;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    PowerPCCPU *cpu = NULL;\n\n    CPUPPCState *env = NULL;\n\n    char *filename;\n\n    qemu_irq *pic, **heathrow_irqs;\n\n    int linux_boot, i;\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios = g_new(MemoryRegion, 1);\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    uint32_t kernel_base, initrd_base, cmdline_base = 0;\n\n    int32_t kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    PCIDevice *macio;\n\n    MACIOIDEState *macio_ide;\n\n    DeviceState *dev;\n\n    BusState *adb_bus;\n\n    int bios_size;\n\n    MemoryRegion *pic_mem;\n\n    MemoryRegion *escc_mem, *escc_bar = g_new(MemoryRegion, 1);\n\n    uint16_t ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    uint64_t tbfreq;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"G3\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        /* Set time-base frequency to 16.6 Mhz */\n\n        cpu_ppc_tb_init(env,  TBFREQ);\n\n        qemu_register_reset(ppc_heathrow_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    if (ram_size > (2047 << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 2047 MB\\n\",\n\n                ((unsigned int)ram_size / (1 << 20)));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_heathrow.ram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    /* allocate and load BIOS */\n\n    memory_region_init_ram(bios, NULL, \"ppc_heathrow.bios\", BIOS_SIZE);\n\n    vmstate_register_ram_global(bios);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    memory_region_set_readonly(bios, true);\n\n    memory_region_add_subregion(sysmem, PROM_ADDR, bios);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, 0, NULL, NULL, NULL, NULL,\n\n                             1, ELF_MACHINE, 0);\n\n        g_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n            cmdline_base = round_page(initrd_base + initrd_size);\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n            cmdline_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            /* TOFIX: for now, the second IDE channel is not properly\n\n             *        used by OHW. The Mac floppy disk are not emulated.\n\n             *        For now, OHW cannot boot from the network.\n\n             */\n\n#if 0\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#else\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'd') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#endif\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for G3 Beige machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Register 2 MB of ISA IO space */\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, 0x00200000);\n\n    memory_region_add_subregion(sysmem, 0xfe000000, isa);\n\n\n\n    /* XXX: we register only 1 output pin for heathrow PIC */\n\n    heathrow_irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    heathrow_irqs[0] =\n\n        g_malloc0(smp_cpus * sizeof(qemu_irq) * 1);\n\n    /* Connect the heathrow PIC outputs to the 6xx bus */\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            heathrow_irqs[i] = heathrow_irqs[0] + (i * 1);\n\n            heathrow_irqs[i][0] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            break;\n\n        default:\n\n            hw_error(\"Bus model not supported on OldWorld Mac machine\\n\");\n\n        }\n\n    }\n\n\n\n    /* Timebase Frequency */\n\n    if (kvm_enabled()) {\n\n        tbfreq = kvmppc_get_tbfreq();\n\n    } else {\n\n        tbfreq = TBFREQ;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on heathrow machine\\n\");\n\n    }\n\n    pic = heathrow_pic_init(&pic_mem, 1, heathrow_irqs);\n\n    pci_bus = pci_grackle_init(0xfec00000, pic,\n\n                               get_system_memory(),\n\n                               get_system_io());\n\n    pci_vga_init(pci_bus);\n\n\n\n    escc_mem = escc_init(0, pic[0x0f], pic[0x10], serial_hds[0],\n\n                               serial_hds[1], ESCC_CLOCK, 4);\n\n    memory_region_init_alias(escc_bar, NULL, \"escc-bar\",\n\n                             escc_mem, 0, memory_region_size(escc_mem));\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n\n\n    macio = pci_create(pci_bus, -1, TYPE_OLDWORLD_MACIO);\n\n    dev = DEVICE(macio);\n\n    qdev_connect_gpio_out(dev, 0, pic[0x12]); /* CUDA */\n\n    qdev_connect_gpio_out(dev, 1, pic[0x0D]); /* IDE-0 */\n\n    qdev_connect_gpio_out(dev, 2, pic[0x02]); /* IDE-0 DMA */\n\n    qdev_connect_gpio_out(dev, 3, pic[0x0E]); /* IDE-1 */\n\n    qdev_connect_gpio_out(dev, 4, pic[0x03]); /* IDE-1 DMA */\n\n\n    macio_init(macio, pic_mem, escc_bar);\n\n\n\n    macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),\n\n                                                        \"ide[0]\"));\n\n    macio_ide_init_drives(macio_ide, hd);\n\n\n\n    macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),\n\n                                                        \"ide[1]\"));\n\n    macio_ide_init_drives(macio_ide, &hd[MAX_IDE_DEVS]);\n\n\n\n    dev = DEVICE(object_resolve_path_component(OBJECT(macio), \"cuda\"));\n\n    adb_bus = qdev_get_child_bus(dev, \"adb.0\");\n\n    dev = qdev_create(adb_bus, TYPE_ADB_KEYBOARD);\n\n    qdev_init_nofail(dev);\n\n    dev = qdev_create(adb_bus, TYPE_ADB_MOUSE);\n\n    qdev_init_nofail(dev);\n\n\n\n    if (usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, ARCH_HEATHROW);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, cmdline_base);\n\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        hypercall = g_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, tbfreq);\n\n    /* Mac OS X requires a \"known good\" clock-frequency value; pass it one. */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_CLOCKFREQ, CLOCKFREQ);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_BUSFREQ, BUSFREQ);\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}", "idx": 2674}
{"project": "qemu", "commit_id": "d35ff5e6b3aa3a706b0aa3bcf11400fac945b67a", "target": 1, "func": "static void process_incoming_migration_bh(void *opaque)\n{\n    Error *local_err = NULL;\n    MigrationIncomingState *mis = opaque;\n    /* Make sure all file formats flush their mutable metadata */\n    bdrv_invalidate_cache_all(&local_err);\n        migrate_set_state(&mis->state, MIGRATION_STATUS_ACTIVE,\n                          MIGRATION_STATUS_FAILED);\n        error_report_err(local_err);\n        migrate_decompress_threads_join();\n        exit(EXIT_FAILURE);\n    /*\n     * This must happen after all error conditions are dealt with and\n     * we're sure the VM is going to be running on this host.\n     */\n    qemu_announce_self();\n    /* If global state section was not received or we are in running\n       state, we need to obey autostart. Any other state is set with\n       runstate_set. */\n    if (!global_state_received() ||\n        global_state_get_runstate() == RUN_STATE_RUNNING) {\n        if (autostart) {\n            vm_start();\n        } else {\n            runstate_set(RUN_STATE_PAUSED);\n    } else {\n        runstate_set(global_state_get_runstate());\n    migrate_decompress_threads_join();\n    /*\n     * This must happen after any state changes since as soon as an external\n     * observer sees this event they might start to prod at the VM assuming\n     * it's ready to use.\n     */\n    migrate_set_state(&mis->state, MIGRATION_STATUS_ACTIVE,\n                      MIGRATION_STATUS_COMPLETED);\n    qemu_bh_delete(mis->bh);\n    migration_incoming_state_destroy();", "idx": 8444}
{"project": "qemu", "commit_id": "98448f58c10033a0f7fcd0673cce4626506403fa", "target": 1, "func": "static int main_loop(void)\n\n{\n\n    int ret, timeout;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    CPUState *env;\n\n\n\n    cur_cpu = first_cpu;\n\n    next_cpu = cur_cpu->next_cpu ?: first_cpu;\n\n    for(;;) {\n\n        if (vm_running) {\n\n\n\n            for(;;) {\n\n                /* get next cpu */\n\n                env = next_cpu;\n\n#ifdef CONFIG_PROFILER\n\n                ti = profile_getclock();\n\n#endif\n\n                if (use_icount) {\n\n                    int64_t count;\n\n                    int decr;\n\n                    qemu_icount -= (env->icount_decr.u16.low + env->icount_extra);\n\n                    env->icount_decr.u16.low = 0;\n\n                    env->icount_extra = 0;\n\n                    count = qemu_next_deadline();\n\n                    count = (count + (1 << icount_time_shift) - 1)\n\n                            >> icount_time_shift;\n\n                    qemu_icount += count;\n\n                    decr = (count > 0xffff) ? 0xffff : count;\n\n                    count -= decr;\n\n                    env->icount_decr.u16.low = decr;\n\n                    env->icount_extra = count;\n\n                }\n\n                ret = cpu_exec(env);\n\n#ifdef CONFIG_PROFILER\n\n                qemu_time += profile_getclock() - ti;\n\n#endif\n\n                if (use_icount) {\n\n                    /* Fold pending instructions back into the\n\n                       instruction counter, and clear the interrupt flag.  */\n\n                    qemu_icount -= (env->icount_decr.u16.low\n\n                                    + env->icount_extra);\n\n                    env->icount_decr.u32 = 0;\n\n                    env->icount_extra = 0;\n\n                }\n\n                next_cpu = env->next_cpu ?: first_cpu;\n\n                if (event_pending && likely(ret != EXCP_DEBUG)) {\n\n                    ret = EXCP_INTERRUPT;\n\n                    event_pending = 0;\n\n                    break;\n\n                }\n\n                if (ret == EXCP_HLT) {\n\n                    /* Give the next CPU a chance to run.  */\n\n                    cur_cpu = env;\n\n                    continue;\n\n                }\n\n                if (ret != EXCP_HALTED)\n\n                    break;\n\n                /* all CPUs are halted ? */\n\n                if (env == cur_cpu)\n\n                    break;\n\n            }\n\n            cur_cpu = env;\n\n\n\n            if (shutdown_requested) {\n\n                ret = EXCP_INTERRUPT;\n\n                if (no_shutdown) {\n\n                    vm_stop(0);\n\n                    no_shutdown = 0;\n\n                }\n\n                else\n\n                    break;\n\n            }\n\n            if (reset_requested) {\n\n                reset_requested = 0;\n\n                qemu_system_reset();\n\n                ret = EXCP_INTERRUPT;\n\n            }\n\n            if (powerdown_requested) {\n\n                powerdown_requested = 0;\n\n\t\tqemu_system_powerdown();\n\n                ret = EXCP_INTERRUPT;\n\n            }\n\n            if (unlikely(ret == EXCP_DEBUG)) {\n\n                vm_stop(EXCP_DEBUG);\n\n            }\n\n            /* If all cpus are halted then wait until the next IRQ */\n\n            /* XXX: use timeout computed from timers */\n\n            if (ret == EXCP_HALTED) {\n\n                if (use_icount) {\n\n                    int64_t add;\n\n                    int64_t delta;\n\n                    /* Advance virtual time to the next event.  */\n\n                    if (use_icount == 1) {\n\n                        /* When not using an adaptive execution frequency\n\n                           we tend to get badly out of sync with real time,\n\n                           so just delay for a reasonable amount of time.  */\n\n                        delta = 0;\n\n                    } else {\n\n                        delta = cpu_get_icount() - cpu_get_clock();\n\n                    }\n\n                    if (delta > 0) {\n\n                        /* If virtual time is ahead of real time then just\n\n                           wait for IO.  */\n\n                        timeout = (delta / 1000000) + 1;\n\n                    } else {\n\n                        /* Wait for either IO to occur or the next\n\n                           timer event.  */\n\n                        add = qemu_next_deadline();\n\n                        /* We advance the timer before checking for IO.\n\n                           Limit the amount we advance so that early IO\n\n                           activity won't get the guest too far ahead.  */\n\n                        if (add > 10000000)\n\n                            add = 10000000;\n\n                        delta += add;\n\n                        add = (add + (1 << icount_time_shift) - 1)\n\n                              >> icount_time_shift;\n\n                        qemu_icount += add;\n\n                        timeout = delta / 1000000;\n\n                        if (timeout < 0)\n\n                            timeout = 0;\n\n                    }\n\n                } else {\n\n                    timeout = 10;\n\n                }\n\n            } else {\n\n                timeout = 0;\n\n            }\n\n        } else {\n\n            if (shutdown_requested)\n\n                break;\n\n            timeout = 10;\n\n        }\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        main_loop_wait(timeout);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n    }\n\n    cpu_disable_ticks();\n\n    return ret;\n\n}\n", "idx": 4026}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static void type_initialize(TypeImpl *ti)\n\n{\n\n    TypeImpl *parent;\n\n\n\n    if (ti->class) {\n\n        return;\n\n    }\n\n\n\n    ti->class_size = type_class_get_size(ti);\n\n    ti->instance_size = type_object_get_size(ti);\n\n\n\n    ti->class = g_malloc0(ti->class_size);\n\n\n\n    parent = type_get_parent(ti);\n\n    if (parent) {\n\n        type_initialize(parent);\n\n        GSList *e;\n\n        int i;\n\n\n\n        g_assert(parent->class_size <= ti->class_size);\n\n        memcpy(ti->class, parent->class, parent->class_size);\n\n        ti->class->interfaces = NULL;\n\n\n\n        for (e = parent->class->interfaces; e; e = e->next) {\n\n            ObjectClass *iface = e->data;\n\n            type_initialize_interface(ti, object_class_get_name(iface));\n\n        }\n\n\n\n        for (i = 0; i < ti->num_interfaces; i++) {\n\n            TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);\n\n            for (e = ti->class->interfaces; e; e = e->next) {\n\n                TypeImpl *target_type = OBJECT_CLASS(e->data)->type;\n\n\n\n                if (type_is_ancestor(target_type, t)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (e) {\n\n                continue;\n\n            }\n\n\n\n            type_initialize_interface(ti, ti->interfaces[i].typename);\n\n        }\n\n    }\n\n\n\n    ti->class->type = ti;\n\n\n\n    while (parent) {\n\n        if (parent->class_base_init) {\n\n            parent->class_base_init(ti->class, ti->class_data);\n\n        }\n\n        parent = type_get_parent(parent);\n\n    }\n\n\n\n    if (ti->class_init) {\n\n        ti->class_init(ti->class, ti->class_data);\n\n    }\n\n\n\n\n\n}\n", "idx": 8928}
{"project": "qemu", "commit_id": "983bff3530782d51c46c8d7c0e17e2a9dfe5fb77", "target": 1, "func": "static void usb_mtp_handle_reset(USBDevice *dev)\n\n{\n\n    MTPState *s = USB_MTP(dev);\n\n\n\n    trace_usb_mtp_reset(s->dev.addr);\n\n\n\n#ifdef __linux__\n\n    usb_mtp_inotify_cleanup(s);\n\n#endif\n\n    usb_mtp_object_free(s, QTAILQ_FIRST(&s->objects));\n\n    s->session = 0;\n\n    usb_mtp_data_free(s->data_in);\n\n    s->data_in = NULL;\n\n    usb_mtp_data_free(s->data_out);\n\n    s->data_out = NULL;\n\n    g_free(s->result);\n\n    s->result = NULL;\n\n}\n", "idx": 11481}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n                               BdrvCheckMode fix, bool *rebuild,\n                               void **refcount_table, int64_t *nb_clusters)\n{\n    BDRVQcow2State *s = bs->opaque;\n    int64_t i;\n    QCowSnapshot *sn;\n    int ret;\n    if (!*refcount_table) {\n        int64_t old_size = 0;\n        ret = realloc_refcount_array(s, refcount_table,\n                                     &old_size, *nb_clusters);\n            res->check_errors++;\n    /* header */\n                        0, s->cluster_size);\n    /* current L1 table */\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n    /* snapshots */\n    for (i = 0; i < s->nb_snapshots; i++) {\n        sn = s->snapshots + i;\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n                                 sn->l1_table_offset, sn->l1_size, 0);\n                        s->snapshots_offset, s->snapshots_size);\n    /* refcount data */\n                        s->refcount_table_offset,\n                        s->refcount_table_size * sizeof(uint64_t));\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);", "idx": 7461}
{"project": "qemu", "commit_id": "9103f1ceb46614b150bcbc3c9a4fbc72b47fedcc", "target": 1, "func": "static void raw_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    struct stat st;\n\n\n\n    if (!fstat(s->fd, &st)) {\n\n        if (S_ISBLK(st.st_mode) || S_ISCHR(st.st_mode)) {\n\n            int ret = hdev_get_max_transfer_length(bs, s->fd);\n\n            if (ret > 0 && ret <= BDRV_REQUEST_MAX_BYTES) {\n\n                bs->bl.max_transfer = pow2floor(ret);\n\n\n\n\n\n\n\n\n\n\n\n    raw_probe_alignment(bs, s->fd, errp);\n\n    bs->bl.min_mem_alignment = s->buf_align;\n\n    bs->bl.opt_mem_alignment = MAX(s->buf_align, getpagesize());\n", "idx": 5362}
{"project": "qemu", "commit_id": "dafe31fc2a8653b535d58f8c7b250c0827b14420", "target": 1, "func": "static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)\n\n{\n\n    EHCIPacket *p;\n\n    uint32_t entry, devaddr;\n\n    EHCIQueue *q;\n\n\n\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    q = ehci_find_queue_by_qh(ehci, entry, async);\n\n    if (NULL == q) {\n\n        q = ehci_alloc_queue(ehci, entry, async);\n\n    }\n\n    p = QTAILQ_FIRST(&q->packets);\n\n\n\n    q->seen++;\n\n    if (q->seen > 1) {\n\n        /* we are going in circles -- stop processing */\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        q = NULL;\n\n        goto out;\n\n    }\n\n\n\n    get_dwords(ehci, NLPTR_GET(q->qhaddr),\n\n               (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n    ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh);\n\n\n\n    devaddr = get_field(q->qh.epchar, QH_EPCHAR_DEVADDR);\n\n    if (q->dev != NULL && q->dev->addr != devaddr) {\n\n        if (!QTAILQ_EMPTY(&q->packets)) {\n\n            /* should not happen (guest bug) */\n\n            ehci_cancel_queue(q);\n\n        }\n\n        q->dev = NULL;\n\n    }\n\n    if (q->dev == NULL) {\n\n        q->dev = ehci_find_device(q->ehci, devaddr);\n\n    }\n\n\n\n    if (p && p->async == EHCI_ASYNC_FINISHED) {\n\n        /* I/O finished -- continue processing queue */\n\n        trace_usb_ehci_packet_action(p->queue, p, \"complete\");\n\n        ehci_set_state(ehci, async, EST_EXECUTING);\n\n        goto out;\n\n    }\n\n\n\n    if (async && (q->qh.epchar & QH_EPCHAR_H)) {\n\n\n\n        /*  EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */\n\n        if (ehci->usbsts & USBSTS_REC) {\n\n            ehci_clear_usbsts(ehci, USBSTS_REC);\n\n        } else {\n\n            DPRINTF(\"FETCHQH:  QH 0x%08x. H-bit set, reclamation status reset\"\n\n                       \" - done processing\\n\", q->qhaddr);\n\n            ehci_set_state(ehci, async, EST_ACTIVE);\n\n            q = NULL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n#if EHCI_DEBUG\n\n    if (q->qhaddr != q->qh.next) {\n\n    DPRINTF(\"FETCHQH:  QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\",\n\n               q->qhaddr,\n\n               q->qh.epchar & QH_EPCHAR_H,\n\n               q->qh.token & QTD_TOKEN_HALT,\n\n               q->qh.token & QTD_TOKEN_ACTIVE,\n\n               q->qh.next);\n\n    }\n\n#endif\n\n\n\n    if (q->qh.token & QTD_TOKEN_HALT) {\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n\n\n    } else if ((q->qh.token & QTD_TOKEN_ACTIVE) &&\n\n               (NLPTR_TBIT(q->qh.current_qtd) == 0)) {\n\n        q->qtdaddr = q->qh.current_qtd;\n\n        ehci_set_state(ehci, async, EST_FETCHQTD);\n\n\n\n    } else {\n\n        /*  EHCI spec version 1.0 Section 4.10.2 */\n\n        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);\n\n    }\n\n\n\nout:\n\n    return q;\n\n}\n", "idx": 5379}
{"project": "qemu", "commit_id": "a97fed52e57385fc749e6f6ef95be7ebdb81ba9b", "target": 1, "func": "void OPPROTO op_store_msr_32 (void)\n\n{\n\n    ppc_store_msr_32(env, T0);\n\n    RETURN();\n\n}\n", "idx": 2913}
{"project": "qemu", "commit_id": "d0ebd78890fba2ab458ec34763dae8566ccb1b72", "target": 1, "func": "static uint32_t parse_enumeration(char *str,\n    EnumTable *table, uint32_t not_found_value)\n{\n    uint32_t ret = not_found_value;\n    while (table->name != NULL) {\n        if (strcmp(table->name, str) == 0) {\n            ret = table->value;\n            break;\n        }\n        table++;\n    }\n    return ret;\n}", "idx": 8219}
{"project": "qemu", "commit_id": "dac23a6c05e543590508b48b8ed31d89b0c99c61", "target": 1, "func": "static bool load_asl(GArray *sdts, AcpiSdtTable *sdt)\n\n{\n\n    AcpiSdtTable *temp;\n\n    GError *error = NULL;\n\n    GString *command_line = g_string_new(iasl);\n\n    gint fd;\n\n    gchar *out, *out_err;\n\n    gboolean ret;\n\n    int i;\n\n\n\n    fd = g_file_open_tmp(\"asl-XXXXXX.dsl\", &sdt->asl_file, &error);\n\n    g_assert_no_error(error);\n\n    close(fd);\n\n\n\n    /* build command line */\n\n    g_string_append_printf(command_line, \" -p %s \", sdt->asl_file);\n\n    if (compare_signature(sdt, \"DSDT\") ||\n\n        compare_signature(sdt, \"SSDT\")) {\n\n        for (i = 0; i < sdts->len; ++i) {\n\n            temp = &g_array_index(sdts, AcpiSdtTable, i);\n\n            if (compare_signature(temp, \"DSDT\") ||\n\n                compare_signature(temp, \"SSDT\")) {\n\n                g_string_append_printf(command_line, \"-e %s \", temp->aml_file);\n\n            }\n\n        }\n\n    }\n\n    g_string_append_printf(command_line, \"-d %s\", sdt->aml_file);\n\n\n\n    /* pass 'out' and 'out_err' in order to be redirected */\n\n    ret = g_spawn_command_line_sync(command_line->str, &out, &out_err, NULL, &error);\n\n    g_assert_no_error(error);\n\n\n\n    if (ret) {\n\n        ret = g_file_get_contents(sdt->asl_file, (gchar **)&sdt->asl,\n\n                                  &sdt->asl_len, &error);\n\n        g_assert(ret);\n\n        g_assert_no_error(error);\n\n        g_assert(sdt->asl_len);\n\n    }\n\n\n\n    g_free(out);\n\n    g_free(out_err);\n\n    g_string_free(command_line, true);\n\n\n\n    return !ret;\n\n}\n", "idx": 6155}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                    QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_pwritev(bs->file, offset, bytes, qiov, flags);", "idx": 7283}
{"project": "qemu", "commit_id": "f1f9e6c5961ffb36fd4a81cd7edcded7bfad2ab2", "target": 1, "func": "static int vhost_virtqueue_start(struct vhost_dev *dev,\n\n                                struct VirtIODevice *vdev,\n\n                                struct vhost_virtqueue *vq,\n\n                                unsigned idx)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusState *vbus = VIRTIO_BUS(qbus);\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(vbus);\n\n    hwaddr s, l, a;\n\n    int r;\n\n    int vhost_vq_index = dev->vhost_ops->vhost_get_vq_index(dev, idx);\n\n    struct vhost_vring_file file = {\n\n        .index = vhost_vq_index\n\n    };\n\n    struct vhost_vring_state state = {\n\n        .index = vhost_vq_index\n\n    };\n\n    struct VirtQueue *vvq = virtio_get_queue(vdev, idx);\n\n\n\n\n\n    vq->num = state.num = virtio_queue_get_num(vdev, idx);\n\n    r = dev->vhost_ops->vhost_set_vring_num(dev, &state);\n\n    if (r) {\n\n        VHOST_OPS_DEBUG(\"vhost_set_vring_num failed\");\n\n        return -errno;\n\n    }\n\n\n\n    state.num = virtio_queue_get_last_avail_idx(vdev, idx);\n\n    r = dev->vhost_ops->vhost_set_vring_base(dev, &state);\n\n    if (r) {\n\n        VHOST_OPS_DEBUG(\"vhost_set_vring_base failed\");\n\n        return -errno;\n\n    }\n\n\n\n    if (vhost_needs_vring_endian(vdev)) {\n\n        r = vhost_virtqueue_set_vring_endian_legacy(dev,\n\n                                                    virtio_is_big_endian(vdev),\n\n                                                    vhost_vq_index);\n\n        if (r) {\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    s = l = virtio_queue_get_desc_size(vdev, idx);\n\n    a = virtio_queue_get_desc_addr(vdev, idx);\n\n    vq->desc = cpu_physical_memory_map(a, &l, 0);\n\n    if (!vq->desc || l != s) {\n\n        r = -ENOMEM;\n\n        goto fail_alloc_desc;\n\n    }\n\n    s = l = virtio_queue_get_avail_size(vdev, idx);\n\n    a = virtio_queue_get_avail_addr(vdev, idx);\n\n    vq->avail = cpu_physical_memory_map(a, &l, 0);\n\n    if (!vq->avail || l != s) {\n\n        r = -ENOMEM;\n\n        goto fail_alloc_avail;\n\n    }\n\n    vq->used_size = s = l = virtio_queue_get_used_size(vdev, idx);\n\n    vq->used_phys = a = virtio_queue_get_used_addr(vdev, idx);\n\n    vq->used = cpu_physical_memory_map(a, &l, 1);\n\n    if (!vq->used || l != s) {\n\n        r = -ENOMEM;\n\n        goto fail_alloc_used;\n\n    }\n\n\n\n    vq->ring_size = s = l = virtio_queue_get_ring_size(vdev, idx);\n\n    vq->ring_phys = a = virtio_queue_get_ring_addr(vdev, idx);\n\n    vq->ring = cpu_physical_memory_map(a, &l, 1);\n\n    if (!vq->ring || l != s) {\n\n        r = -ENOMEM;\n\n        goto fail_alloc_ring;\n\n    }\n\n\n\n    r = vhost_virtqueue_set_addr(dev, vq, vhost_vq_index, dev->log_enabled);\n\n    if (r < 0) {\n\n        r = -errno;\n\n        goto fail_alloc;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(virtio_queue_get_host_notifier(vvq));\n\n    r = dev->vhost_ops->vhost_set_vring_kick(dev, &file);\n\n    if (r) {\n\n        VHOST_OPS_DEBUG(\"vhost_set_vring_kick failed\");\n\n        r = -errno;\n\n        goto fail_kick;\n\n    }\n\n\n\n    /* Clear and discard previous events if any. */\n\n    event_notifier_test_and_clear(&vq->masked_notifier);\n\n\n\n    /* Init vring in unmasked state, unless guest_notifier_mask\n\n     * will do it later.\n\n     */\n\n    if (!vdev->use_guest_notifier_mask) {\n\n        /* TODO: check and handle errors. */\n\n        vhost_virtqueue_mask(dev, vdev, idx, false);\n\n    }\n\n\n\n    if (k->query_guest_notifiers &&\n\n        k->query_guest_notifiers(qbus->parent) &&\n\n        virtio_queue_vector(vdev, idx) == VIRTIO_NO_VECTOR) {\n\n        file.fd = -1;\n\n        r = dev->vhost_ops->vhost_set_vring_call(dev, &file);\n\n        if (r) {\n\n            goto fail_vector;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nfail_vector:\n\nfail_kick:\n\nfail_alloc:\n\n    cpu_physical_memory_unmap(vq->ring, virtio_queue_get_ring_size(vdev, idx),\n\n                              0, 0);\n\nfail_alloc_ring:\n\n    cpu_physical_memory_unmap(vq->used, virtio_queue_get_used_size(vdev, idx),\n\n                              0, 0);\n\nfail_alloc_used:\n\n    cpu_physical_memory_unmap(vq->avail, virtio_queue_get_avail_size(vdev, idx),\n\n                              0, 0);\n\nfail_alloc_avail:\n\n    cpu_physical_memory_unmap(vq->desc, virtio_queue_get_desc_size(vdev, idx),\n\n                              0, 0);\n\nfail_alloc_desc:\n\n    return r;\n\n}\n", "idx": 3717}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 8918}
{"project": "qemu", "commit_id": "45fe15c25a5c9feea6e0f78434f5e9f632de9d94", "target": 1, "func": "static int intel_hda_exit(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n\n\n    if (d->msi) {\n\n        msi_uninit(&d->pci);\n\n    }\n\n    cpu_unregister_io_memory(d->mmio_addr);\n\n    return 0;\n\n}\n", "idx": 5345}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "static void vga_mm_init(VGAState *s, target_phys_addr_t vram_base,\n\n                        target_phys_addr_t ctrl_base, int it_shift)\n\n{\n\n    int s_ioport_ctrl, vga_io_memory;\n\n\n\n    s->it_shift = it_shift;\n\n    s_ioport_ctrl = cpu_register_io_memory(0, vga_mm_read_ctrl, vga_mm_write_ctrl, s);\n\n    vga_io_memory = cpu_register_io_memory(0, vga_mem_read, vga_mem_write, s);\n\n\n\n    register_savevm(\"vga\", 0, 2, vga_save, vga_load, s);\n\n\n\n    cpu_register_physical_memory(ctrl_base, 0x100000, s_ioport_ctrl);\n\n    s->bank_offset = 0;\n\n    cpu_register_physical_memory(vram_base + 0x000a0000, 0x20000, vga_io_memory);\n\n\n}", "idx": 9169}
{"project": "qemu", "commit_id": "4172a00373b2c81374293becc02b16b7f8c76659", "target": 1, "func": "static void block_job_unref(BlockJob *job)\n\n{\n\n    if (--job->refcnt == 0) {\n\n        BlockDriverState *bs = blk_bs(job->blk);\n\n        bs->job = NULL;\n\n        block_job_remove_all_bdrv(job);\n\n        blk_remove_aio_context_notifier(job->blk,\n\n                                        block_job_attached_aio_context,\n\n                                        block_job_detach_aio_context, job);\n\n        blk_unref(job->blk);\n\n        error_free(job->blocker);\n\n        g_free(job->id);\n\n        QLIST_REMOVE(job, job_list);\n\n        g_free(job);\n\n    }\n\n}\n", "idx": 5183}
{"project": "qemu", "commit_id": "6546d0dba6c211c1a3eac1252a4f50a0c151a08a", "target": 1, "func": "static bool object_create_initial(const char *type)\n{\n    if (g_str_equal(type, \"rng-egd\")) {\n    /*\n     * return false for concrete netfilters since\n     * they depend on netdevs already existing\n    if (g_str_equal(type, \"filter-buffer\") ||\n        g_str_equal(type, \"filter-dump\") ||\n        g_str_equal(type, \"filter-mirror\") ||\n        g_str_equal(type, \"filter-redirector\")) {\n    return true;", "idx": 2320}
{"project": "qemu", "commit_id": "14a10fc39923b3af07c8c46d22cb20843bee3a72", "target": 1, "func": "static void xtensa_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    XtensaCPUClass *xcc = XTENSA_CPU_GET_CLASS(dev);\n    cs->gdb_num_regs = xcc->config->gdb_regmap.num_regs;\n    xcc->parent_realize(dev, errp);\n}", "idx": 3493}
{"project": "qemu", "commit_id": "a9c380db3b8c6af19546a68145c8d1438a09c92b", "target": 1, "func": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    SSISlave *ss = SSI_SLAVE(opaque);\n\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n\n    int i;\n\n\n\n    if (version_id != 1)\n\n\n\n\n    s->mode = qemu_get_be32(f);\n\n    s->cmd = qemu_get_be32(f);\n\n    for (i = 0; i < 4; i++)\n\n        s->cmdarg[i] = qemu_get_be32(f);\n\n    for (i = 0; i < 5; i++)\n\n        s->response[i] = qemu_get_be32(f);\n\n    s->arglen = qemu_get_be32(f);\n\n\n\n\n\n    s->response_pos = qemu_get_be32(f);\n\n    s->stopping = qemu_get_be32(f);\n\n\n\n\n\n\n\n\n    ss->cs = qemu_get_be32(f);\n\n\n\n    return 0;\n", "idx": 6274}
{"project": "qemu", "commit_id": "94fb0909645de18481cc726ee0ec9b5afa861394", "target": 1, "func": "static int ram_load_dead(QEMUFile *f, void *opaque)\n\n{\n\n    RamDecompressState s1, *s = &s1;\n\n    uint8_t buf[10];\n\n    ram_addr_t i;\n\n\n\n    if (ram_decompress_open(s, f) < 0)\n\n        return -EINVAL;\n\n    for(i = 0; i < last_ram_offset; i+= BDRV_HASH_BLOCK_SIZE) {\n\n        if (ram_decompress_buf(s, buf, 1) < 0) {\n\n            fprintf(stderr, \"Error while reading ram block header\\n\");\n\n            goto error;\n\n        }\n\n        if (buf[0] == 0) {\n\n            if (ram_decompress_buf(s, qemu_get_ram_ptr(i),\n\n                                   BDRV_HASH_BLOCK_SIZE) < 0) {\n\n                fprintf(stderr, \"Error while reading ram block address=0x%08\" PRIx64, (uint64_t)i);\n\n                goto error;\n\n            }\n\n        } else {\n\n        error:\n\n            printf(\"Error block header\\n\");\n\n            return -EINVAL;\n\n        }\n\n    }\n\n    ram_decompress_close(s);\n\n\n\n    return 0;\n\n}\n", "idx": 7765}
{"project": "qemu", "commit_id": "9b4e38fe6a35890bb1d995316d7be08de0b30ee5", "target": 1, "func": "static void test_visitor_in_errors(TestInputVisitorData *data,\n                                   const void *unused)\n{\n    TestStruct *p = NULL;\n    Error *err = NULL;\n    Visitor *v;\n    strList *q = NULL;\n    UserDefTwo *r = NULL;\n    WrapAlternate *s = NULL;\n    v = visitor_input_test_init(data, \"{ 'integer': false, 'boolean': 'foo', \"\n                                \"'string': -42 }\");\n    visit_type_TestStruct(v, NULL, &p, &err);\n    g_assert(!p);\n    v = visitor_input_test_init(data, \"[ '1', '2', false, '3' ]\");\n    visit_type_strList(v, NULL, &q, &err);\n    assert(!q);\n}", "idx": 8574}
{"project": "qemu", "commit_id": "ab33fcda9f96b9195dfb3fcf5bd9bb5383caeaea", "target": 1, "func": "static bool all_cpu_threads_idle(void)\n\n{\n\n    CPUState *env;\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        if (!cpu_thread_is_idle(env)) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n", "idx": 8379}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "SCSIRequest *scsi_req_find(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIRequest *req;\n\n\n\n    QTAILQ_FOREACH(req, &d->requests, next) {\n\n        if (req->tag == tag) {\n\n            return req;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 11488}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "gen_intermediate_code_internal(MIPSCPU *cpu, TranslationBlock *tb,\n\n                               bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUMIPSState *env = &cpu->env;\n\n    DisasContext ctx;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int num_insns;\n\n    int max_insns;\n\n    int insn_bytes;\n\n    int is_branch;\n\n\n\n    if (search_pc)\n\n        qemu_log(\"search pc %d\\n\", search_pc);\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.saved_pc = -1;\n\n    ctx.singlestep_enabled = cs->singlestep_enabled;\n\n    ctx.insn_flags = env->insn_flags;\n\n    ctx.tb = tb;\n\n    ctx.bstate = BS_NONE;\n\n    /* Restore delay slot state from the tb context.  */\n\n    ctx.hflags = (uint32_t)tb->flags; /* FIXME: maybe use 64 bits here? */\n\n    restore_cpu_state(env, &ctx);\n\n#ifdef CONFIG_USER_ONLY\n\n        ctx.mem_idx = MIPS_HFLAG_UM;\n\n#else\n\n        ctx.mem_idx = ctx.hflags & MIPS_HFLAG_KSU;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n    LOG_DISAS(\"\\ntb %p idx %d hflags %04x\\n\", tb, ctx.mem_idx, ctx.hflags);\n\n    gen_tb_start();\n\n    while (ctx.bstate == BS_NONE) {\n\n        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    save_cpu_state(&ctx, 1);\n\n                    ctx.bstate = BS_BRANCH;\n\n                    gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n                    /* Include the breakpoint location or the tb won't\n\n                     * be flushed when it must be.  */\n\n                    ctx.pc += 4;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = ctx.pc;\n\n            gen_opc_hflags[lj] = ctx.hflags & MIPS_HFLAG_BMASK;\n\n            gen_opc_btarget[lj] = ctx.btarget;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        is_branch = 0;\n\n        if (!(ctx.hflags & MIPS_HFLAG_M16)) {\n\n            ctx.opcode = cpu_ldl_code(env, ctx.pc);\n\n            insn_bytes = 4;\n\n            decode_opc(env, &ctx, &is_branch);\n\n        } else if (ctx.insn_flags & ASE_MICROMIPS) {\n\n            ctx.opcode = cpu_lduw_code(env, ctx.pc);\n\n            insn_bytes = decode_micromips_opc(env, &ctx, &is_branch);\n\n        } else if (ctx.insn_flags & ASE_MIPS16) {\n\n            ctx.opcode = cpu_lduw_code(env, ctx.pc);\n\n            insn_bytes = decode_mips16_opc(env, &ctx, &is_branch);\n\n        } else {\n\n            generate_exception(&ctx, EXCP_RI);\n\n            ctx.bstate = BS_STOP;\n\n            break;\n\n        }\n\n        if (!is_branch) {\n\n            handle_delay_slot(&ctx, insn_bytes);\n\n        }\n\n        ctx.pc += insn_bytes;\n\n\n\n        num_insns++;\n\n\n\n        /* Execute a branch and its delay slot as a single instruction.\n\n           This is what GDB expects and is consistent with what the\n\n           hardware does (e.g. if a delay slot instruction faults, the\n\n           reported PC is the PC of the branch).  */\n\n        if (cs->singlestep_enabled && (ctx.hflags & MIPS_HFLAG_BMASK) == 0) {\n\n            break;\n\n        }\n\n\n\n        if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0)\n\n            break;\n\n\n\n        if (tcg_ctx.gen_opc_ptr >= gen_opc_end) {\n\n            break;\n\n        }\n\n\n\n        if (num_insns >= max_insns)\n\n            break;\n\n\n\n        if (singlestep)\n\n            break;\n\n    }\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (cs->singlestep_enabled && ctx.bstate != BS_BRANCH) {\n\n        save_cpu_state(&ctx, ctx.bstate == BS_NONE);\n\n        gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n    } else {\n\n        switch (ctx.bstate) {\n\n        case BS_STOP:\n\n            gen_goto_tb(&ctx, 0, ctx.pc);\n\n            break;\n\n        case BS_NONE:\n\n            save_cpu_state(&ctx, 0);\n\n            gen_goto_tb(&ctx, 0, ctx.pc);\n\n            break;\n\n        case BS_EXCP:\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case BS_BRANCH:\n\n        default:\n\n            break;\n\n        }\n\n    }\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    LOG_DISAS(\"\\n\");\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, ctx.pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 9622}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 7438}
{"project": "qemu", "commit_id": "630530a6529bc3da9ab8aead7053dc753cb9ac77", "target": 1, "func": "static int get_whole_cluster(BlockDriverState *bs, uint64_t cluster_offset,\n\n                             uint64_t offset, int allocate)\n\n{\n\n    uint64_t parent_cluster_offset;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    uint8_t  whole_grain[s->cluster_sectors*512];        // 128 sectors * 512 bytes each = grain size 64KB\n\n\n\n    // we will be here if it's first write on non-exist grain(cluster).\n\n    // try to read from parent image, if exist\n\n    if (s->hd->backing_hd) {\n\n        BDRVVmdkState *ps = s->hd->backing_hd->opaque;\n\n\n\n        if (!vmdk_is_cid_valid(bs))\n\n            return -1;\n\n        parent_cluster_offset = get_cluster_offset(s->hd->backing_hd, offset, allocate);\n\n        if (bdrv_pread(ps->hd, parent_cluster_offset, whole_grain, ps->cluster_sectors*512) != \n\n                                                                            ps->cluster_sectors*512)\n\n            return -1;\n\n\n\n        if (bdrv_pwrite(s->hd, cluster_offset << 9, whole_grain, sizeof(whole_grain)) != \n\n                                                                            sizeof(whole_grain))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6912}
{"project": "qemu", "commit_id": "0188fadb7fe460d8c4c743372b1f7b25773e183e", "target": 1, "func": "static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUS390XState *env)\n\n{\n\n    sigframe *frame;\n\n    abi_ulong frame_addr;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    qemu_log(\"%s: frame_addr 0x%llx\\n\", __FUNCTION__,\n\n             (unsigned long long)frame_addr);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n            goto give_sigsegv;\n\n    }\n\n\n\n    qemu_log(\"%s: 1\\n\", __FUNCTION__);\n\n    if (__put_user(set->sig[0], &frame->sc.oldmask[0])) {\n\n              goto give_sigsegv;\n\n    }\n\n\n\n    save_sigregs(env, &frame->sregs);\n\n\n\n    __put_user((abi_ulong)(unsigned long)&frame->sregs,\n\n               (abi_ulong *)&frame->sc.sregs);\n\n\n\n    /* Set up to return from userspace.  If provided, use a stub\n\n       already in userspace.  */\n\n    if (ka->sa_flags & TARGET_SA_RESTORER) {\n\n            env->regs[14] = (unsigned long)\n\n                    ka->sa_restorer | PSW_ADDR_AMODE;\n\n    } else {\n\n            env->regs[14] = (unsigned long)\n\n                    frame->retcode | PSW_ADDR_AMODE;\n\n            if (__put_user(S390_SYSCALL_OPCODE | TARGET_NR_sigreturn,\n\n                           (uint16_t *)(frame->retcode)))\n\n                    goto give_sigsegv;\n\n    }\n\n\n\n    /* Set up backchain. */\n\n    if (__put_user(env->regs[15], (abi_ulong *) frame)) {\n\n            goto give_sigsegv;\n\n    }\n\n\n\n    /* Set up registers for signal handler */\n\n    env->regs[15] = frame_addr;\n\n    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;\n\n\n\n    env->regs[2] = sig; //map_signal(sig);\n\n    env->regs[3] = frame_addr += offsetof(typeof(*frame), sc);\n\n\n\n    /* We forgot to include these in the sigcontext.\n\n       To avoid breaking binary compatibility, they are passed as args. */\n\n    env->regs[4] = 0; // FIXME: no clue... current->thread.trap_no;\n\n    env->regs[5] = 0; // FIXME: no clue... current->thread.prot_addr;\n\n\n\n    /* Place signal number on stack to allow backtrace from handler.  */\n\n    if (__put_user(env->regs[2], (int *) &frame->signo)) {\n\n            goto give_sigsegv;\n\n    }\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    qemu_log(\"%s: give_sigsegv\\n\", __FUNCTION__);\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 6430}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile *qemu_fdopen(int fd, const char *mode)\n\n{\n\n    QEMUFileSocket *s;\n\n\n\n    if (mode == NULL ||\n\n        (mode[0] != 'r' && mode[0] != 'w') ||\n\n        mode[1] != 'b' || mode[2] != 0) {\n\n        fprintf(stderr, \"qemu_fdopen: Argument validity check failed\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(QEMUFileSocket));\n\n    s->fd = fd;\n\n\n\n    if (mode[0] == 'r') {\n\n        s->file = qemu_fopen_ops(s, &unix_read_ops);\n\n    } else {\n\n        s->file = qemu_fopen_ops(s, &unix_write_ops);\n\n    }\n\n    return s->file;\n\n}\n", "idx": 700}
{"project": "qemu", "commit_id": "8db165b36ef893ac69af0452f20eeb78e7b26b5a", "target": 1, "func": "static void pollfds_poll(GArray *pollfds, int nfds, fd_set *rfds,\n\n                         fd_set *wfds, fd_set *xfds)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < pollfds->len; i++) {\n\n        GPollFD *pfd = &g_array_index(pollfds, GPollFD, i);\n\n        int fd = pfd->fd;\n\n        int revents = 0;\n\n\n\n        if (FD_ISSET(fd, rfds)) {\n\n            revents |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, wfds)) {\n\n            revents |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, xfds)) {\n\n            revents |= G_IO_PRI;\n\n        }\n\n        pfd->revents = revents & pfd->events;\n\n    }\n\n}\n", "idx": 5746}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static QDict *qmp_check_input_obj(QObject *input_obj)\n\n{\n\n    const QDictEntry *ent;\n\n    int has_exec_key = 0;\n\n    QDict *input_dict;\n\n\n\n    if (qobject_type(input_obj) != QTYPE_QDICT) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        return NULL;\n\n    }\n\n\n\n    input_dict = qobject_to_qdict(input_obj);\n\n\n\n    for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n\n        const char *arg_name = qdict_entry_key(ent);\n\n        const QObject *arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                              \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = 1;\n\n        } else if (!strcmp(arg_name, \"arguments\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QDICT) {\n\n                qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"arguments\",\n\n                              \"object\");\n\n                return NULL;\n\n            }\n\n        } else if (!strcmp(arg_name, \"id\")) {\n\n            /* FIXME: check duplicated IDs for async commands */\n\n        } else {\n\n            qerror_report(QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return input_dict;\n\n}\n", "idx": 5169}
{"project": "qemu", "commit_id": "11b7b07f8a15879134a54e73fade98d5e11e04f8", "target": 1, "func": "char *qdist_pr(const struct qdist *dist, size_t n_bins, uint32_t opt)\n\n{\n\n    const char *border = opt & QDIST_PR_BORDER ? \"|\" : \"\";\n\n    char *llabel, *rlabel;\n\n    char *hgram;\n\n    GString *s;\n\n\n\n    if (dist->n == 0) {\n\n        return NULL;\n\n    }\n\n\n\n    s = g_string_new(\"\");\n\n\n\n    llabel = qdist_pr_label(dist, n_bins, opt, true);\n\n    rlabel = qdist_pr_label(dist, n_bins, opt, false);\n\n    hgram = qdist_pr_plain(dist, n_bins);\n\n    g_string_append_printf(s, \"%s%s%s%s%s\",\n\n                           llabel, border, hgram, border, rlabel);\n\n    g_free(llabel);\n\n    g_free(rlabel);\n\n    g_free(hgram);\n\n\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 10663}
{"project": "qemu", "commit_id": "9bc9732faeff09828fe38c0ebe2401ee131a6fca", "target": 1, "func": "static void nbd_coroutine_start(NbdClientSession *s,\n\n   struct nbd_request *request)\n\n{\n\n    /* Poor man semaphore.  The free_sema is locked when no other request\n\n     * can be accepted, and unlocked after receiving one reply.  */\n\n    if (s->in_flight >= MAX_NBD_REQUESTS - 1) {\n\n        qemu_co_mutex_lock(&s->free_sema);\n\n        assert(s->in_flight < MAX_NBD_REQUESTS);\n\n    }\n\n    s->in_flight++;\n\n\n\n    /* s->recv_coroutine[i] is set as soon as we get the send_lock.  */\n\n}\n", "idx": 4651}
{"project": "qemu", "commit_id": "344dc16fae0cb6a011aa5befffc8e7d520b11d5d", "target": 1, "func": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n\n{\n\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n\n    if (event_notifier_test_and_clear(n)) {\n\n        virtio_queue_notify_vq(vq);\n\n    }\n\n}\n", "idx": 4631}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 907}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_mig_unlock(void)\n\n{\n\n    qemu_mutex_unlock(&block_mig_state.lock);\n\n}\n", "idx": 233}
{"project": "qemu", "commit_id": "ca96ac44dcd290566090b2435bc828fded356ad9", "target": 1, "func": "int aio_bh_poll(AioContext *ctx)\n\n{\n\n    QEMUBH *bh, **bhp, *next;\n\n    int ret;\n\n\n\n    ctx->walking_bh++;\n\n\n\n    ret = 0;\n\n    for (bh = ctx->first_bh; bh; bh = next) {\n\n        /* Make sure that fetching bh happens before accessing its members */\n\n        smp_read_barrier_depends();\n\n        next = bh->next;\n\n        /* The atomic_xchg is paired with the one in qemu_bh_schedule.  The\n\n         * implicit memory barrier ensures that the callback sees all writes\n\n         * done by the scheduling thread.  It also ensures that the scheduling\n\n         * thread sees the zero before bh->cb has run, and thus will call\n\n         * aio_notify again if necessary.\n\n         */\n\n        if (!bh->deleted && atomic_xchg(&bh->scheduled, 0)) {\n\n            if (!bh->idle)\n\n                ret = 1;\n\n            bh->idle = 0;\n\n            bh->cb(bh->opaque);\n\n        }\n\n    }\n\n\n\n    ctx->walking_bh--;\n\n\n\n    /* remove deleted bhs */\n\n    if (!ctx->walking_bh) {\n\n        qemu_mutex_lock(&ctx->bh_lock);\n\n        bhp = &ctx->first_bh;\n\n        while (*bhp) {\n\n            bh = *bhp;\n\n            if (bh->deleted) {\n\n                *bhp = bh->next;\n\n                g_free(bh);\n\n            } else {\n\n                bhp = &bh->next;\n\n            }\n\n        }\n\n        qemu_mutex_unlock(&ctx->bh_lock);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11569}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "void qmp_qmp_capabilities(Error **errp)\n\n{\n\n    cur_mon->qmp.in_command_mode = true;\n\n}\n", "idx": 3688}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_src_opc(CPUTriCoreState *env, DisasContext *ctx, int op1)\n\n{\n\n    int r1;\n\n    int32_t const4;\n\n    TCGv temp, temp2;\n\n\n\n    r1 = MASK_OP_SRC_S1D(ctx->opcode);\n\n    const4 = MASK_OP_SRC_CONST4_SEXT(ctx->opcode);\n\n\n\n    switch (op1) {\n\n    case OPC1_16_SRC_ADD:\n\n        gen_addi_d(cpu_gpr_d[r1], cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_ADD_A15:\n\n        gen_addi_d(cpu_gpr_d[r1], cpu_gpr_d[15], const4);\n\n        break;\n\n    case OPC1_16_SRC_ADD_15A:\n\n        gen_addi_d(cpu_gpr_d[15], cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_ADD_A:\n\n        tcg_gen_addi_tl(cpu_gpr_a[r1], cpu_gpr_a[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_CADD:\n\n        gen_condi_add(TCG_COND_NE, cpu_gpr_d[r1], const4, cpu_gpr_d[r1],\n\n                      cpu_gpr_d[15]);\n\n        break;\n\n    case OPC1_16_SRC_CADDN:\n\n        gen_condi_add(TCG_COND_EQ, cpu_gpr_d[r1], const4, cpu_gpr_d[r1],\n\n                      cpu_gpr_d[15]);\n\n        break;\n\n    case OPC1_16_SRC_CMOV:\n\n        temp = tcg_const_tl(0);\n\n        temp2 = tcg_const_tl(const4);\n\n        tcg_gen_movcond_tl(TCG_COND_NE, cpu_gpr_d[r1], cpu_gpr_d[15], temp,\n\n                           temp2, cpu_gpr_d[r1]);\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        break;\n\n    case OPC1_16_SRC_CMOVN:\n\n        temp = tcg_const_tl(0);\n\n        temp2 = tcg_const_tl(const4);\n\n        tcg_gen_movcond_tl(TCG_COND_EQ, cpu_gpr_d[r1], cpu_gpr_d[15], temp,\n\n                           temp2, cpu_gpr_d[r1]);\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        break;\n\n    case OPC1_16_SRC_EQ:\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, cpu_gpr_d[15], cpu_gpr_d[r1],\n\n                            const4);\n\n        break;\n\n    case OPC1_16_SRC_LT:\n\n        tcg_gen_setcondi_tl(TCG_COND_LT, cpu_gpr_d[15], cpu_gpr_d[r1],\n\n                            const4);\n\n        break;\n\n    case OPC1_16_SRC_MOV:\n\n        tcg_gen_movi_tl(cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_MOV_A:\n\n        const4 = MASK_OP_SRC_CONST4(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_a[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_MOV_E:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            tcg_gen_movi_tl(cpu_gpr_d[r1], const4);\n\n            tcg_gen_sari_tl(cpu_gpr_d[r1+1], cpu_gpr_d[r1], 31);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC1_16_SRC_SH:\n\n        gen_shi(cpu_gpr_d[r1], cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_SHA:\n\n        gen_shaci(cpu_gpr_d[r1], cpu_gpr_d[r1], const4);\n\n        break;\n\n    }\n\n}\n", "idx": 3489}
{"project": "qemu", "commit_id": "c919297379e9980c2bcc4d2053addbc1fd6d762b", "target": 1, "func": "static int img_compare(int argc, char **argv)\n\n{\n\n    const char *fmt1 = NULL, *fmt2 = NULL, *cache, *filename1, *filename2;\n\n    BlockBackend *blk1, *blk2;\n\n    BlockDriverState *bs1, *bs2;\n\n    int64_t total_sectors1, total_sectors2;\n\n    uint8_t *buf1 = NULL, *buf2 = NULL;\n\n    int pnum1, pnum2;\n\n    int allocated1, allocated2;\n\n    int ret = 0; /* return value - 0 Ident, 1 Different, >1 Error */\n\n    bool progress = false, quiet = false, strict = false;\n\n    int flags;\n\n    bool writethrough;\n\n    int64_t total_sectors;\n\n    int64_t sector_num = 0;\n\n    int64_t nb_sectors;\n\n    int c, pnum;\n\n    uint64_t progress_base;\n\n    bool image_opts = false;\n\n\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    for (;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"hf:F:T:pqs\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch (c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt1 = optarg;\n\n            break;\n\n        case 'F':\n\n            fmt2 = optarg;\n\n            break;\n\n        case 'T':\n\n            cache = optarg;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case 's':\n\n            strict = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                ret = 2;\n\n                goto out4;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Progress is not shown in Quiet mode */\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n\n\n    if (optind != argc - 2) {\n\n        error_exit(\"Expecting two image file names\");\n\n    }\n\n    filename1 = argv[optind++];\n\n    filename2 = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        ret = 2;\n\n        goto out4;\n\n    }\n\n\n\n    /* Initialize before goto out */\n\n    qemu_progress_init(progress, 2.0);\n\n\n\n    flags = 0;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid source cache option: %s\", cache);\n\n        ret = 2;\n\n        goto out3;\n\n    }\n\n\n\n    blk1 = img_open(image_opts, filename1, fmt1, flags, writethrough, quiet);\n\n    if (!blk1) {\n\n        ret = 2;\n\n        goto out3;\n\n    }\n\n\n\n    blk2 = img_open(image_opts, filename2, fmt2, flags, writethrough, quiet);\n\n    if (!blk2) {\n\n        ret = 2;\n\n        goto out2;\n\n    }\n\n    bs1 = blk_bs(blk1);\n\n    bs2 = blk_bs(blk2);\n\n\n\n    buf1 = blk_blockalign(blk1, IO_BUF_SIZE);\n\n    buf2 = blk_blockalign(blk2, IO_BUF_SIZE);\n\n    total_sectors1 = blk_nb_sectors(blk1);\n\n    if (total_sectors1 < 0) {\n\n        error_report(\"Can't get size of %s: %s\",\n\n                     filename1, strerror(-total_sectors1));\n\n        ret = 4;\n\n        goto out;\n\n    }\n\n    total_sectors2 = blk_nb_sectors(blk2);\n\n    if (total_sectors2 < 0) {\n\n        error_report(\"Can't get size of %s: %s\",\n\n                     filename2, strerror(-total_sectors2));\n\n        ret = 4;\n\n        goto out;\n\n    }\n\n    total_sectors = MIN(total_sectors1, total_sectors2);\n\n    progress_base = MAX(total_sectors1, total_sectors2);\n\n\n\n    qemu_progress_print(0, 100);\n\n\n\n    if (strict && total_sectors1 != total_sectors2) {\n\n        ret = 1;\n\n        qprintf(quiet, \"Strict mode: Image size mismatch!\\n\");\n\n        goto out;\n\n    }\n\n\n\n    for (;;) {\n\n        int64_t status1, status2;\n\n        BlockDriverState *file;\n\n\n\n        nb_sectors = sectors_to_process(total_sectors, sector_num);\n\n        if (nb_sectors <= 0) {\n\n            break;\n\n        }\n\n        status1 = bdrv_get_block_status_above(bs1, NULL, sector_num,\n\n                                              total_sectors1 - sector_num,\n\n                                              &pnum1, &file);\n\n        if (status1 < 0) {\n\n            ret = 3;\n\n            error_report(\"Sector allocation test failed for %s\", filename1);\n\n            goto out;\n\n        }\n\n        allocated1 = status1 & BDRV_BLOCK_ALLOCATED;\n\n\n\n        status2 = bdrv_get_block_status_above(bs2, NULL, sector_num,\n\n                                              total_sectors2 - sector_num,\n\n                                              &pnum2, &file);\n\n        if (status2 < 0) {\n\n            ret = 3;\n\n            error_report(\"Sector allocation test failed for %s\", filename2);\n\n            goto out;\n\n        }\n\n        allocated2 = status2 & BDRV_BLOCK_ALLOCATED;\n\n        if (pnum1) {\n\n            nb_sectors = MIN(nb_sectors, pnum1);\n\n        }\n\n        if (pnum2) {\n\n            nb_sectors = MIN(nb_sectors, pnum2);\n\n        }\n\n\n\n        if (strict) {\n\n            if ((status1 & ~BDRV_BLOCK_OFFSET_MASK) !=\n\n                (status2 & ~BDRV_BLOCK_OFFSET_MASK)) {\n\n                ret = 1;\n\n                qprintf(quiet, \"Strict mode: Offset %\" PRId64\n\n                        \" block status mismatch!\\n\",\n\n                        sectors_to_bytes(sector_num));\n\n                goto out;\n\n            }\n\n        }\n\n        if ((status1 & BDRV_BLOCK_ZERO) && (status2 & BDRV_BLOCK_ZERO)) {\n\n            nb_sectors = MIN(pnum1, pnum2);\n\n        } else if (allocated1 == allocated2) {\n\n            if (allocated1) {\n\n                ret = blk_pread(blk1, sector_num << BDRV_SECTOR_BITS, buf1,\n\n                                nb_sectors << BDRV_SECTOR_BITS);\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64 \" of %s:\"\n\n                                 \" %s\", sectors_to_bytes(sector_num), filename1,\n\n                                 strerror(-ret));\n\n                    ret = 4;\n\n                    goto out;\n\n                }\n\n                ret = blk_pread(blk2, sector_num << BDRV_SECTOR_BITS, buf2,\n\n                                nb_sectors << BDRV_SECTOR_BITS);\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64\n\n                                 \" of %s: %s\", sectors_to_bytes(sector_num),\n\n                                 filename2, strerror(-ret));\n\n                    ret = 4;\n\n                    goto out;\n\n                }\n\n                ret = compare_sectors(buf1, buf2, nb_sectors, &pnum);\n\n                if (ret || pnum != nb_sectors) {\n\n                    qprintf(quiet, \"Content mismatch at offset %\" PRId64 \"!\\n\",\n\n                            sectors_to_bytes(\n\n                                ret ? sector_num : sector_num + pnum));\n\n                    ret = 1;\n\n                    goto out;\n\n                }\n\n            }\n\n        } else {\n\n\n\n            if (allocated1) {\n\n                ret = check_empty_sectors(blk1, sector_num, nb_sectors,\n\n                                          filename1, buf1, quiet);\n\n            } else {\n\n                ret = check_empty_sectors(blk2, sector_num, nb_sectors,\n\n                                          filename2, buf1, quiet);\n\n            }\n\n            if (ret) {\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64 \": %s\",\n\n                                 sectors_to_bytes(sector_num), strerror(-ret));\n\n                    ret = 4;\n\n                }\n\n                goto out;\n\n            }\n\n        }\n\n        sector_num += nb_sectors;\n\n        qemu_progress_print(((float) nb_sectors / progress_base)*100, 100);\n\n    }\n\n\n\n    if (total_sectors1 != total_sectors2) {\n\n        BlockBackend *blk_over;\n\n        int64_t total_sectors_over;\n\n        const char *filename_over;\n\n\n\n        qprintf(quiet, \"Warning: Image size mismatch!\\n\");\n\n        if (total_sectors1 > total_sectors2) {\n\n            total_sectors_over = total_sectors1;\n\n            blk_over = blk1;\n\n            filename_over = filename1;\n\n        } else {\n\n            total_sectors_over = total_sectors2;\n\n            blk_over = blk2;\n\n            filename_over = filename2;\n\n        }\n\n\n\n        for (;;) {\n\n            nb_sectors = sectors_to_process(total_sectors_over, sector_num);\n\n            if (nb_sectors <= 0) {\n\n                break;\n\n            }\n\n            ret = bdrv_is_allocated_above(blk_bs(blk_over), NULL, sector_num,\n\n                                          nb_sectors, &pnum);\n\n            if (ret < 0) {\n\n                ret = 3;\n\n                error_report(\"Sector allocation test failed for %s\",\n\n                             filename_over);\n\n                goto out;\n\n\n\n            }\n\n            nb_sectors = pnum;\n\n            if (ret) {\n\n                ret = check_empty_sectors(blk_over, sector_num, nb_sectors,\n\n                                          filename_over, buf1, quiet);\n\n                if (ret) {\n\n                    if (ret < 0) {\n\n                        error_report(\"Error while reading offset %\" PRId64\n\n                                     \" of %s: %s\", sectors_to_bytes(sector_num),\n\n                                     filename_over, strerror(-ret));\n\n                        ret = 4;\n\n                    }\n\n                    goto out;\n\n                }\n\n            }\n\n            sector_num += nb_sectors;\n\n            qemu_progress_print(((float) nb_sectors / progress_base)*100, 100);\n\n        }\n\n    }\n\n\n\n    qprintf(quiet, \"Images are identical.\\n\");\n\n    ret = 0;\n\n\n\nout:\n\n    qemu_vfree(buf1);\n\n    qemu_vfree(buf2);\n\n    blk_unref(blk2);\n\nout2:\n\n    blk_unref(blk1);\n\nout3:\n\n    qemu_progress_end();\n\nout4:\n\n    return ret;\n\n}\n", "idx": 3665}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 9254}
{"project": "qemu", "commit_id": "6265eb26a375179f193f792e4f0d49036d2cf052", "target": 1, "func": "int parse_host_src_port(struct sockaddr_in *haddr,\n\n                        struct sockaddr_in *saddr,\n\n                        const char *input_str)\n\n{\n\n    char *str = strdup(input_str);\n\n    char *host_str = str;\n\n    char *src_str;\n\n    const char *src_str2;\n\n    char *ptr;\n\n\n\n    /*\n\n     * Chop off any extra arguments at the end of the string which\n\n     * would start with a comma, then fill in the src port information\n\n     * if it was provided else use the \"any address\" and \"any port\".\n\n     */\n\n    if ((ptr = strchr(str,',')))\n\n        *ptr = '\\0';\n\n\n\n    if ((src_str = strchr(input_str,'@'))) {\n\n        *src_str = '\\0';\n\n        src_str++;\n\n    }\n\n\n\n    if (parse_host_port(haddr, host_str) < 0)\n\n        goto fail;\n\n\n\n    src_str2 = src_str;\n\n    if (!src_str || *src_str == '\\0')\n\n        src_str2 = \":0\";\n\n\n\n    if (parse_host_port(saddr, src_str2) < 0)\n\n        goto fail;\n\n\n\n    free(str);\n\n    return(0);\n\n\n\nfail:\n\n    free(str);\n\n    return -1;\n\n}\n", "idx": 5538}
{"project": "qemu", "commit_id": "b1b1dad31f3a092e046b09795f4476705c4e564e", "target": 1, "func": "static int aio_write_f(int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n    BlockDriverAIOCB *acb;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n\n            return command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n\n\n\n    gettimeofday(&ctx->t1, NULL);\n\n    acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n                          ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    if (!acb) {\n\n        free(ctx->buf);\n\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 1955}
{"project": "qemu", "commit_id": "42ed3727536ccf80c87942b3f04e7378fe90f107", "target": 1, "func": "bool trace_backend_init(const char *events, const char *file)\n\n{\n\n    GThread *thread;\n\n\n\n    if (!g_thread_supported()) {\n\n\n        g_thread_init(NULL);\n\n\n\n\n\n    }\n\n\n\n    trace_available_cond = g_cond_new();\n\n    trace_empty_cond = g_cond_new();\n\n\n\n    thread = trace_thread_create(writeout_thread);\n\n    if (!thread) {\n\n        fprintf(stderr, \"warning: unable to initialize simple trace backend\\n\");\n\n        return false;\n\n    }\n\n\n\n    atexit(st_flush_trace_buffer);\n\n    trace_backend_init_events(events);\n\n    st_set_trace_file(file);\n\n    return true;\n\n}", "idx": 187}
{"project": "qemu", "commit_id": "c27ff60871aff588a35e51d1a90faed410993e55", "target": 1, "func": "ssize_t qemu_sendv_packet(VLANClientState *vc1, const struct iovec *iov,\n\n                          int iovcnt)\n\n{\n\n    VLANState *vlan = vc1->vlan;\n\n    VLANClientState *vc;\n\n    ssize_t max_len = 0;\n\n\n\n    if (vc1->link_down)\n\n        return calc_iov_length(iov, iovcnt);\n\n\n\n    for (vc = vlan->first_client; vc != NULL; vc = vc->next) {\n\n        ssize_t len = 0;\n\n\n\n        if (vc == vc1)\n\n            continue;\n\n\n\n        if (vc->link_down)\n\n            len = calc_iov_length(iov, iovcnt);\n\n        else if (vc->fd_readv)\n\n            len = vc->fd_readv(vc->opaque, iov, iovcnt);\n\n        else if (vc->fd_read)\n\n            len = vc_sendv_compat(vc, iov, iovcnt);\n\n\n\n        max_len = MAX(max_len, len);\n\n    }\n\n\n\n    return max_len;\n\n}\n", "idx": 3534}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t *refcount_table,\n\n                              int refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n        l1_table_offset, l1_size2);\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 == 0) {\n\n        l1_table = NULL;\n\n    } else {\n\n        l1_table = g_malloc(l1_size2);\n\n        if (bdrv_pread(bs->file, l1_table_offset,\n\n                       l1_table, l1_size2) != l1_size2)\n\n            goto fail;\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                l2_offset, s->cluster_size);\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n    res->check_errors++;\n\n    g_free(l1_table);\n\n    return -EIO;\n\n}\n", "idx": 11616}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void fsl_imx25_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    dc->realize = fsl_imx25_realize;\n}", "idx": 6348}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static void vtd_handle_gcmd_qie(IntelIOMMUState *s, bool en)\n\n{\n\n    uint64_t iqa_val = vtd_get_quad_raw(s, DMAR_IQA_REG);\n\n\n\n    trace_vtd_inv_qi_enable(en);\n\n\n\n    if (en) {\n\n        if (vtd_queued_inv_enable_check(s)) {\n\n            s->iq = iqa_val & VTD_IQA_IQA_MASK;\n\n            /* 2^(x+8) entries */\n\n            s->iq_size = 1UL << ((iqa_val & VTD_IQA_QS) + 8);\n\n            s->qi_enabled = true;\n\n            trace_vtd_inv_qi_setup(s->iq, s->iq_size);\n\n            /* Ok - report back to driver */\n\n            vtd_set_clear_mask_long(s, DMAR_GSTS_REG, 0, VTD_GSTS_QIES);\n\n        } else {\n\n            trace_vtd_err_qi_enable(s->iq_tail);\n\n        }\n\n    } else {\n\n        if (vtd_queued_inv_disable_check(s)) {\n\n            /* disable Queued Invalidation */\n\n            vtd_set_quad_raw(s, DMAR_IQH_REG, 0);\n\n            s->iq_head = 0;\n\n            s->qi_enabled = false;\n\n            /* Ok - report back to driver */\n\n            vtd_set_clear_mask_long(s, DMAR_GSTS_REG, VTD_GSTS_QIES, 0);\n\n        } else {\n\n            trace_vtd_err_qi_disable(s->iq_head, s->iq_tail, s->iq_last_desc_type);\n\n        }\n\n    }\n\n}\n", "idx": 8603}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 9703}
{"project": "qemu", "commit_id": "b1ab03af890b2b6c5bafc9344b7fe05b392180a5", "target": 1, "func": "static void realview_init(MachineState *machine,\n\n                          enum realview_board_type board_type)\n\n{\n\n    ARMCPU *cpu = NULL;\n\n    CPUARMState *env;\n\n    ObjectClass *cpu_oc;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram_lo = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_hi = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_hack = g_new(MemoryRegion, 1);\n\n    DeviceState *dev, *sysctl, *gpio2, *pl041;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[64];\n\n    qemu_irq mmc_irq[2];\n\n    PCIBus *pci_bus = NULL;\n\n    NICInfo *nd;\n\n    I2CBus *i2c;\n\n    int n;\n\n    int done_nic = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int is_mpcore = 0;\n\n    int is_pb = 0;\n\n    uint32_t proc_id = 0;\n\n    uint32_t sys_id;\n\n    ram_addr_t low_ram_size;\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    hwaddr periphbase = 0;\n\n\n\n    switch (board_type) {\n\n    case BOARD_EB:\n\n        break;\n\n    case BOARD_EB_MPCORE:\n\n        is_mpcore = 1;\n\n        periphbase = 0x10100000;\n\n        break;\n\n    case BOARD_PB_A8:\n\n        is_pb = 1;\n\n        break;\n\n    case BOARD_PBX_A9:\n\n        is_mpcore = 1;\n\n        is_pb = 1;\n\n        periphbase = 0x1f000000;\n\n        break;\n\n    }\n\n\n\n    cpu_oc = cpu_class_by_name(TYPE_ARM_CPU, machine->cpu_model);\n\n    if (!cpu_oc) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        Object *cpuobj = object_new(object_class_get_name(cpu_oc));\n\n        Error *err = NULL;\n\n\n\n        if (is_pb && is_mpcore) {\n\n            object_property_set_int(cpuobj, periphbase, \"reset-cbar\", &err);\n\n            if (err) {\n\n                error_report(\"%s\", error_get_pretty(err));\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            exit(1);\n\n        }\n\n\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpuobj), ARM_CPU_IRQ);\n\n    }\n\n    cpu = ARM_CPU(first_cpu);\n\n    env = &cpu->env;\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        if (is_mpcore) {\n\n            proc_id = 0x0c000000;\n\n        } else {\n\n            proc_id = 0x0e000000;\n\n        }\n\n    } else if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        proc_id = 0x06000000;\n\n    } else if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        proc_id = 0x04000000;\n\n    } else {\n\n        proc_id = 0x02000000;\n\n    }\n\n\n\n    if (is_pb && ram_size > 0x20000000) {\n\n        /* Core tile RAM.  */\n\n        low_ram_size = ram_size - 0x20000000;\n\n        ram_size = 0x20000000;\n\n        memory_region_init_ram(ram_lo, NULL, \"realview.lowmem\", low_ram_size,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(ram_lo);\n\n        memory_region_add_subregion(sysmem, 0x20000000, ram_lo);\n\n    }\n\n\n\n    memory_region_init_ram(ram_hi, NULL, \"realview.highmem\", ram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ram_hi);\n\n    low_ram_size = ram_size;\n\n    if (low_ram_size > 0x10000000)\n\n      low_ram_size = 0x10000000;\n\n    /* SDRAM at address zero.  */\n\n    memory_region_init_alias(ram_alias, NULL, \"realview.alias\",\n\n                             ram_hi, 0, low_ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram_alias);\n\n    if (is_pb) {\n\n        /* And again at a high address.  */\n\n        memory_region_add_subregion(sysmem, 0x70000000, ram_hi);\n\n    } else {\n\n        ram_size = low_ram_size;\n\n    }\n\n\n\n    sys_id = is_pb ? 0x01780500 : 0xc1400400;\n\n    sysctl = qdev_create(NULL, \"realview_sysctl\");\n\n    qdev_prop_set_uint32(sysctl, \"sys_id\", sys_id);\n\n    qdev_prop_set_uint32(sysctl, \"proc_id\", proc_id);\n\n    qdev_init_nofail(sysctl);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(sysctl), 0, 0x10000000);\n\n\n\n    if (is_mpcore) {\n\n        dev = qdev_create(NULL, is_pb ? \"a9mpcore_priv\": \"realview_mpcore\");\n\n        qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, periphbase);\n\n        for (n = 0; n < smp_cpus; n++) {\n\n            sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        }\n\n        sysbus_create_varargs(\"l2x0\", periphbase + 0x2000, NULL);\n\n        /* Both A9 and 11MPCore put the GIC CPU i/f at base + 0x100 */\n\n        realview_binfo.gic_cpu_if_addr = periphbase + 0x100;\n\n    } else {\n\n        uint32_t gic_addr = is_pb ? 0x1e000000 : 0x10040000;\n\n        /* For now just create the nIRQ GIC, and ignore the others.  */\n\n        dev = sysbus_create_simple(\"realview_gic\", gic_addr, cpu_irq[0]);\n\n    }\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    pl041 = qdev_create(NULL, \"pl041\");\n\n    qdev_prop_set_uint32(pl041, \"nc_fifo_depth\", 512);\n\n    qdev_init_nofail(pl041);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(pl041), 0, 0x10004000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(pl041), 0, pic[19]);\n\n\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, pic[20]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x10007000, pic[21]);\n\n\n\n    sysbus_create_simple(\"pl011\", 0x10009000, pic[12]);\n\n    sysbus_create_simple(\"pl011\", 0x1000a000, pic[13]);\n\n    sysbus_create_simple(\"pl011\", 0x1000b000, pic[14]);\n\n    sysbus_create_simple(\"pl011\", 0x1000c000, pic[15]);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    sysbus_create_simple(\"pl081\", 0x10030000, pic[24]);\n\n\n\n    sysbus_create_simple(\"sp804\", 0x10011000, pic[4]);\n\n    sysbus_create_simple(\"sp804\", 0x10012000, pic[5]);\n\n\n\n    sysbus_create_simple(\"pl061\", 0x10013000, pic[6]);\n\n    sysbus_create_simple(\"pl061\", 0x10014000, pic[7]);\n\n    gpio2 = sysbus_create_simple(\"pl061\", 0x10015000, pic[8]);\n\n\n\n    sysbus_create_simple(\"pl111\", 0x10020000, pic[23]);\n\n\n\n    dev = sysbus_create_varargs(\"pl181\", 0x10005000, pic[17], pic[18], NULL);\n\n    /* Wire up MMC card detect and read-only signals. These have\n\n     * to go to both the PL061 GPIO and the sysctl register.\n\n     * Note that the PL181 orders these lines (readonly,inserted)\n\n     * and the PL061 has them the other way about. Also the card\n\n     * detect line is inverted.\n\n     */\n\n    mmc_irq[0] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_WPROT),\n\n        qdev_get_gpio_in(gpio2, 1));\n\n    mmc_irq[1] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_CARDIN),\n\n        qemu_irq_invert(qdev_get_gpio_in(gpio2, 0)));\n\n    qdev_connect_gpio_out(dev, 0, mmc_irq[0]);\n\n    qdev_connect_gpio_out(dev, 1, mmc_irq[1]);\n\n\n\n    sysbus_create_simple(\"pl031\", 0x10017000, pic[10]);\n\n\n\n    if (!is_pb) {\n\n        dev = qdev_create(NULL, \"realview_pci\");\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(busdev, 0, 0x10019000); /* PCI controller registers */\n\n        sysbus_mmio_map(busdev, 1, 0x60000000); /* PCI self-config */\n\n        sysbus_mmio_map(busdev, 2, 0x61000000); /* PCI config */\n\n        sysbus_mmio_map(busdev, 3, 0x62000000); /* PCI I/O */\n\n        sysbus_mmio_map(busdev, 4, 0x63000000); /* PCI memory window 1 */\n\n        sysbus_mmio_map(busdev, 5, 0x64000000); /* PCI memory window 2 */\n\n        sysbus_mmio_map(busdev, 6, 0x68000000); /* PCI memory window 3 */\n\n        sysbus_connect_irq(busdev, 0, pic[48]);\n\n        sysbus_connect_irq(busdev, 1, pic[49]);\n\n        sysbus_connect_irq(busdev, 2, pic[50]);\n\n        sysbus_connect_irq(busdev, 3, pic[51]);\n\n        pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");\n\n        if (usb_enabled(false)) {\n\n            pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n        }\n\n        n = drive_get_max_bus(IF_SCSI);\n\n        while (n >= 0) {\n\n            pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n            n--;\n\n        }\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n\n\n        if (!done_nic && (!nd->model ||\n\n                    strcmp(nd->model, is_pb ? \"lan9118\" : \"smc91c111\") == 0)) {\n\n            if (is_pb) {\n\n                lan9118_init(nd, 0x4e000000, pic[28]);\n\n            } else {\n\n                smc91c111_init(nd, 0x4e000000, pic[28]);\n\n            }\n\n            done_nic = 1;\n\n        } else {\n\n            if (pci_bus) {\n\n                pci_nic_init_nofail(nd, pci_bus, \"rtl8139\", NULL);\n\n            }\n\n        }\n\n    }\n\n\n\n    dev = sysbus_create_simple(\"versatile_i2c\", 0x10002000, NULL);\n\n    i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n    i2c_create_slave(i2c, \"ds1338\", 0x68);\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /* 0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD. (EB) */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /*  0x10002000 Two-Wire Serial Bus - DVI. (PB) */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1. (EB) */\n\n    /*  0x10050000 GIC2. (EB) */\n\n    /*  0x10060000 GIC3. (EB) */\n\n    /*  0x10070000 GIC4. (EB) */\n\n    /*  0x10080000 SMC.  */\n\n    /* 0x1e000000 GIC1. (PB) */\n\n    /*  0x1e001000 GIC2. (PB) */\n\n    /*  0x1e002000 GIC3. (PB) */\n\n    /*  0x1e003000 GIC4. (PB) */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x60000000 PCI Self Config.  */\n\n    /* 0x61000000 PCI Config.  */\n\n    /* 0x62000000 PCI IO.  */\n\n    /* 0x63000000 PCI mem 0.  */\n\n    /* 0x64000000 PCI mem 1.  */\n\n    /* 0x68000000 PCI mem 2.  */\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    memory_region_init_ram(ram_hack, NULL, \"realview.hack\", 0x1000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ram_hack);\n\n    memory_region_add_subregion(sysmem, SMP_BOOT_ADDR, ram_hack);\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = machine->kernel_filename;\n\n    realview_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    realview_binfo.initrd_filename = machine->initrd_filename;\n\n    realview_binfo.nb_cpus = smp_cpus;\n\n    realview_binfo.board_id = realview_board_id[board_type];\n\n    realview_binfo.loader_start = (board_type == BOARD_PB_A8 ? 0x70000000 : 0);\n\n    arm_load_kernel(ARM_CPU(first_cpu), &realview_binfo);\n\n}\n", "idx": 871}
{"project": "qemu", "commit_id": "92196b2f5664d5defa778b1b24df56e2239b5e93", "target": 1, "func": "int bdrv_pwrite_sync(BlockDriverState *bs, int64_t offset,\n\n    const void *buf, int count)\n\n{\n\n    int ret;\n\n\n\n    ret = bdrv_pwrite(bs, offset, buf, count);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* No flush needed for cache=writethrough, it uses O_DSYNC */\n\n    if ((bs->open_flags & BDRV_O_CACHE_MASK) != 0) {\n\n        bdrv_flush(bs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2381}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl110_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl110_initfn;\n\n    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_pl110;\n\n}\n", "idx": 350}
{"project": "qemu", "commit_id": "93b665693dd4afd32c89b0d5ee2b407b26a7a3bc", "target": 1, "func": "static void rtc_periodic_timer(void *opaque)\n\n{\n\n    RTCState *s = opaque;\n\n\n\n    rtc_timer_update(s, s->next_periodic_time);\n\n#ifdef TARGET_I386\n\n    if ((s->cmos_data[RTC_REG_C] & 0xc0) && rtc_td_hack) {\n\n        s->irq_coalesced++;\n\n        return;\n\n    }\n\n#endif\n\n    if (s->cmos_data[RTC_REG_B] & REG_B_PIE) {\n\n        s->cmos_data[RTC_REG_C] |= 0xc0;\n\n        rtc_irq_raise(s->irq);\n\n    }\n\n    if (s->cmos_data[RTC_REG_B] & REG_B_SQWE) {\n\n        /* Not square wave at all but we don't want 2048Hz interrupts!\n\n           Must be seen as a pulse.  */\n\n        qemu_irq_raise(s->sqw_irq);\n\n    }\n\n}\n", "idx": 5594}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 3437}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static void imx_serial_write(void *opaque, hwaddr offset,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    IMXSerialState *s = (IMXSerialState *)opaque;\n\n    unsigned char ch;\n\n\n\n    DPRINTF(\"write(offset=0x%\" HWADDR_PRIx \", value = 0x%x) to %s\\n\",\n\n            offset, (unsigned int)value, s->chr ? s->chr->label : \"NODEV\");\n\n\n\n    switch (offset >> 2) {\n\n    case 0x10: /* UTXD */\n\n        ch = value;\n\n        if (s->ucr2 & UCR2_TXEN) {\n\n            if (s->chr) {\n\n                qemu_chr_fe_write(s->chr, &ch, 1);\n\n            }\n\n            s->usr1 &= ~USR1_TRDY;\n\n            imx_update(s);\n\n            s->usr1 |= USR1_TRDY;\n\n            imx_update(s);\n\n        }\n\n        break;\n\n\n\n    case 0x20: /* UCR1 */\n\n        s->ucr1 = value & 0xffff;\n\n\n\n        DPRINTF(\"write(ucr1=%x)\\n\", (unsigned int)value);\n\n\n\n        imx_update(s);\n\n        break;\n\n\n\n    case 0x21: /* UCR2 */\n\n        /*\n\n         * Only a few bits in control register 2 are implemented as yet.\n\n         * If it's intended to use a real serial device as a back-end, this\n\n         * register will have to be implemented more fully.\n\n         */\n\n        if (!(value & UCR2_SRST)) {\n\n            imx_serial_reset(s);\n\n            imx_update(s);\n\n            value |= UCR2_SRST;\n\n        }\n\n        if (value & UCR2_RXEN) {\n\n            if (!(s->ucr2 & UCR2_RXEN)) {\n\n                if (s->chr) {\n\n                    qemu_chr_accept_input(s->chr);\n\n                }\n\n            }\n\n        }\n\n        s->ucr2 = value & 0xffff;\n\n        break;\n\n\n\n    case 0x25: /* USR1 */\n\n        value &= USR1_AWAKE | USR1_AIRINT | USR1_DTRD | USR1_AGTIM |\n\n                 USR1_FRAMERR | USR1_ESCF | USR1_RTSD | USR1_PARTYER;\n\n        s->usr1 &= ~value;\n\n        break;\n\n\n\n    case 0x26: /* USR2 */\n\n        /*\n\n         * Writing 1 to some bits clears them; all other\n\n         * values are ignored\n\n         */\n\n        value &= USR2_ADET | USR2_DTRF | USR2_IDLE | USR2_ACST |\n\n                 USR2_RIDELT | USR2_IRINT | USR2_WAKE |\n\n                 USR2_DCDDELT | USR2_RTSF | USR2_BRCD | USR2_ORE;\n\n        s->usr2 &= ~value;\n\n        break;\n\n\n\n    /*\n\n     * Linux expects to see what it writes to these registers\n\n     * We don't currently alter the baud rate\n\n     */\n\n    case 0x29: /* UBIR */\n\n        s->ubrc = value & 0xffff;\n\n        break;\n\n\n\n    case 0x2a: /* UBMR */\n\n        s->ubmr = value & 0xffff;\n\n        break;\n\n\n\n    case 0x2c: /* One ms reg */\n\n        s->onems = value & 0xffff;\n\n        break;\n\n\n\n    case 0x24: /* FIFO control register */\n\n        s->ufcr = value & 0xffff;\n\n        break;\n\n\n\n    case 0x22: /* UCR3 */\n\n        s->ucr3 = value & 0xffff;\n\n        break;\n\n\n\n    case 0x2d: /* UTS1 */\n\n    case 0x23: /* UCR4 */\n\n        qemu_log_mask(LOG_UNIMP, \"[%s]%s: Unimplemented reg 0x%\"\n\n                      HWADDR_PRIx \"\\n\", TYPE_IMX_SERIAL, __func__, offset);\n\n        /* TODO */\n\n        break;\n\n\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Bad register at offset 0x%\"\n\n                      HWADDR_PRIx \"\\n\", TYPE_IMX_SERIAL, __func__, offset);\n\n    }\n\n}\n", "idx": 2795}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int posix_aio_init(void)\n\n{\n\n    sigset_t mask;\n\n    PosixAioState *s;\n\n  \n\n    if (posix_aio_state)\n\n        return 0;\n\n\n\n    s = qemu_malloc(sizeof(PosixAioState));\n\n    if (s == NULL)\n\n        return -ENOMEM;\n\n\n\n    /* Make sure to block AIO signal */\n\n    sigemptyset(&mask);\n\n    sigaddset(&mask, SIGUSR2);\n\n    sigprocmask(SIG_BLOCK, &mask, NULL);\n\n    \n\n    s->first_aio = NULL;\n\n    s->fd = qemu_signalfd(&mask);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"failed to create signalfd\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    fcntl(s->fd, F_SETFL, O_NONBLOCK);\n\n\n\n    qemu_aio_set_fd_handler(s->fd, posix_aio_read, NULL, posix_aio_flush, s);\n\n\n\n#if defined(__linux__)\n\n    {\n\n        struct aioinit ai;\n\n\n\n        memset(&ai, 0, sizeof(ai));\n\n#if defined(__GLIBC_PREREQ) && __GLIBC_PREREQ(2, 4)\n\n        ai.aio_threads = 64;\n\n        ai.aio_num = 64;\n\n#else\n\n        /* XXX: aio thread exit seems to hang on RedHat 9 and this init\n\n           seems to fix the problem. */\n\n        ai.aio_threads = 1;\n\n        ai.aio_num = 1;\n\n        ai.aio_idle_time = 365 * 100000;\n\n#endif\n\n        aio_init(&ai);\n\n    }\n\n#endif\n\n    posix_aio_state = s;\n\n\n\n    return 0;\n\n}\n", "idx": 3974}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "static void *bochs_bios_init(void)\n\n{\n\n    void *fw_cfg;\n\n    uint8_t *smbios_table;\n\n    size_t smbios_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES, (uint8_t *)acpi_tables,\n\n                     acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_table = smbios_get_table(&smbios_len);\n\n    if (smbios_table)\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_table, smbios_len);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE, (uint8_t *)&e820_table,\n\n                     sizeof(e820_table));\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, (uint8_t *)&hpet_cfg,\n\n                     sizeof(struct hpet_fw_config));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + max_cpus + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, node_cpumask[j])) {\n\n                numa_fw_cfg[i + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[max_cpus + 1 + i] = cpu_to_le64(node_mem[i]);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, (uint8_t *)numa_fw_cfg,\n\n                     (1 + max_cpus + nb_numa_nodes) * sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 526}
{"project": "qemu", "commit_id": "a2689242b10a7bbc9a952659a2a5cc04a86d10e1", "target": 1, "func": "static int handle_intercept(S390CPU *cpu)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    struct kvm_run *run = cs->kvm_run;\n\n    int icpt_code = run->s390_sieic.icptcode;\n\n    int r = 0;\n\n\n\n    DPRINTF(\"intercept: 0x%x (at 0x%lx)\\n\", icpt_code,\n\n            (long)cs->kvm_run->psw_addr);\n\n    switch (icpt_code) {\n\n        case ICPT_INSTRUCTION:\n\n            r = handle_instruction(cpu, run);\n\n            break;\n\n        case ICPT_WAITPSW:\n\n            /* disabled wait, since enabled wait is handled in kernel */\n\n            if (s390_del_running_cpu(cpu) == 0) {\n\n                if (is_special_wait_psw(cs)) {\n\n                    qemu_system_shutdown_request();\n\n                } else {\n\n                    QObject *data;\n\n\n\n                    data = qobject_from_jsonf(\"{ 'action': %s }\", \"pause\");\n\n                    monitor_protocol_event(QEVENT_GUEST_PANICKED, data);\n\n                    qobject_decref(data);\n\n                    vm_stop(RUN_STATE_GUEST_PANICKED);\n\n                }\n\n            }\n\n            r = EXCP_HALTED;\n\n            break;\n\n        case ICPT_CPU_STOP:\n\n            if (s390_del_running_cpu(cpu) == 0) {\n\n                qemu_system_shutdown_request();\n\n            }\n\n            r = EXCP_HALTED;\n\n            break;\n\n        case ICPT_SOFT_INTERCEPT:\n\n            fprintf(stderr, \"KVM unimplemented icpt SOFT\\n\");\n\n            exit(1);\n\n            break;\n\n        case ICPT_IO:\n\n            fprintf(stderr, \"KVM unimplemented icpt IO\\n\");\n\n            exit(1);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown intercept code: %d\\n\", icpt_code);\n\n            exit(1);\n\n            break;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 5675}
{"project": "qemu", "commit_id": "91bea4e2bb1a5f7954a3b3a4f2e28e96bd25c458", "target": 1, "func": "iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n                 QEMUIOVector *qiov, int nb_sectors,\n                 BlockDriverCompletionFunc *cb,\n                 void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    IscsiAIOCB *acb;\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n    trace_iscsi_aio_writev(iscsilun->iscsi, sector_num, nb_sectors, opaque, acb);\n    acb->iscsilun    = iscsilun;\n    acb->qiov        = qiov;\n    acb->nb_sectors  = nb_sectors;\n    acb->sector_num  = sector_num;\n    acb->retries     = ISCSI_CMD_RETRIES;\n    if (iscsi_aio_writev_acb(acb) != 0) {\n        qemu_aio_release(acb);\n    iscsi_set_events(iscsilun);\n    return &acb->common;", "idx": 8579}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "void OPPROTO op_check_subfo_64 (void)\n\n{\n\n    if (likely(!(((uint64_t)(~T2) ^ (uint64_t)T1 ^ UINT64_MAX) &\n\n                 ((uint64_t)(~T2) ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 10465}
{"project": "qemu", "commit_id": "94fb0909645de18481cc726ee0ec9b5afa861394", "target": 1, "func": "static int ram_decompress_open(RamDecompressState *s, QEMUFile *f)\n\n{\n\n    int ret;\n\n    memset(s, 0, sizeof(*s));\n\n    s->f = f;\n\n    ret = inflateInit(&s->zstream);\n\n    if (ret != Z_OK)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 1282}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int vdi_check(BlockDriverState *bs, BdrvCheckResult *res,\n\n                     BdrvCheckMode fix)\n\n{\n\n    /* TODO: additional checks possible. */\n\n    BDRVVdiState *s = (BDRVVdiState *)bs->opaque;\n\n    uint32_t blocks_allocated = 0;\n\n    uint32_t block;\n\n    uint32_t *bmap;\n\n    logout(\"\\n\");\n\n\n\n    if (fix) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    bmap = g_try_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n\n    if (s->header.blocks_in_image && bmap == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n\n\n\n    /* Check block map and value of blocks_allocated. */\n\n    for (block = 0; block < s->header.blocks_in_image; block++) {\n\n        uint32_t bmap_entry = le32_to_cpu(s->bmap[block]);\n\n        if (VDI_IS_ALLOCATED(bmap_entry)) {\n\n            if (bmap_entry < s->header.blocks_in_image) {\n\n                blocks_allocated++;\n\n                if (!VDI_IS_ALLOCATED(bmap[bmap_entry])) {\n\n                    bmap[bmap_entry] = bmap_entry;\n\n                } else {\n\n                    fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                            \" also used by %\" PRIu32 \"\\n\", bmap[bmap_entry], bmap_entry);\n\n                    res->corruptions++;\n\n                }\n\n            } else {\n\n                fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                        \" too large, is %\" PRIu32 \"\\n\", block, bmap_entry);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n    if (blocks_allocated != s->header.blocks_allocated) {\n\n        fprintf(stderr, \"ERROR: allocated blocks mismatch, is %\" PRIu32\n\n               \", should be %\" PRIu32 \"\\n\",\n\n               blocks_allocated, s->header.blocks_allocated);\n\n        res->corruptions++;\n\n    }\n\n\n\n    g_free(bmap);\n\n\n\n    return 0;\n\n}\n", "idx": 10955}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void large_dict(void)\n\n{\n\n    GString *gstr = g_string_new(\"\");\n\n    QObject *obj;\n\n\n\n    gen_test_json(gstr, 10, 100);\n\n    obj = qobject_from_json(gstr->str, NULL);\n\n    g_assert(obj != NULL);\n\n\n\n    qobject_decref(obj);\n\n    g_string_free(gstr, true);\n\n}\n", "idx": 7513}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static struct omap_rtc_s *omap_rtc_init(MemoryRegion *system_memory,\n\n                                        hwaddr base,\n\n                                        qemu_irq timerirq, qemu_irq alarmirq,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_rtc_s *s = (struct omap_rtc_s *)\n\n            g_malloc0(sizeof(struct omap_rtc_s));\n\n\n\n    s->irq = timerirq;\n\n    s->alarm = alarmirq;\n\n    s->clk = timer_new_ms(rtc_clock, omap_rtc_tick, s);\n\n\n\n    omap_rtc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_rtc_ops, s,\n\n                          \"omap-rtc\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 10556}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_bool(Visitor *v, const char *name, bool *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (siv->string) {\n\n        if (!strcasecmp(siv->string, \"on\") ||\n\n            !strcasecmp(siv->string, \"yes\") ||\n\n            !strcasecmp(siv->string, \"true\")) {\n\n            *obj = true;\n\n            return;\n\n        }\n\n        if (!strcasecmp(siv->string, \"off\") ||\n\n            !strcasecmp(siv->string, \"no\") ||\n\n            !strcasecmp(siv->string, \"false\")) {\n\n            *obj = false;\n\n            return;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"boolean\");\n\n}\n", "idx": 2855}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "static void xlnx_dp_set_dpdma(Object *obj, const char *name, Object *val,\n\n                              Error **errp)\n\n{\n\n    XlnxDPState *s = XLNX_DP(obj);\n\n    if (s->console) {\n\n        DisplaySurface *surface = qemu_console_surface(s->console);\n\n        XlnxDPDMAState *dma = XLNX_DPDMA(val);\n\n        xlnx_dpdma_set_host_data_location(dma, DP_GRAPHIC_DMA_CHANNEL,\n\n                                          surface_data(surface));\n\n    }\n\n}\n", "idx": 9861}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static OfDpaGroup *of_dpa_group_alloc(uint32_t id)\n\n{\n\n    OfDpaGroup *group = g_malloc0(sizeof(OfDpaGroup));\n\n\n\n    if (!group) {\n\n        return NULL;\n\n    }\n\n\n\n    group->id = id;\n\n\n\n    return group;\n\n}\n", "idx": 10284}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void limits_nesting(void)\n\n{\n\n    enum { max_nesting = 1024 }; /* see qobject/json-streamer.c */\n\n    char buf[2 * (max_nesting + 1) + 1];\n\n    QObject *obj;\n\n\n\n    obj = qobject_from_json(make_nest(buf, max_nesting), NULL);\n\n    g_assert(obj != NULL);\n\n    qobject_decref(obj);\n\n\n\n    obj = qobject_from_json(make_nest(buf, max_nesting + 1), NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 9331}
{"project": "qemu", "commit_id": "e9a07334fb6ee08ddd61787c102d36e7e781efef", "target": 1, "func": "static void g364fb_update_display(void *opaque)\n{\n    G364State *s = opaque;\n    if (s->width == 0 || s->height == 0)\n        return;\n    if (s->width != ds_get_width(s->ds) || s->height != ds_get_height(s->ds)) {\n        qemu_console_resize(s->ds, s->width, s->height);\n    }\n    if (s->ctla & CTLA_FORCE_BLANK) {\n        g364fb_draw_blank(s);\n    } else if (s->depth == 8) {\n        g364fb_draw_graphic8(s);\n    } else {\n        error_report(\"g364: unknown guest depth %d\", s->depth);\n    }\n    qemu_irq_raise(s->irq);\n}", "idx": 1289}
{"project": "qemu", "commit_id": "cec56a733dd2c3fa81dbedbecf03922258747f7d", "target": 1, "func": "void cpu_state_reset(CPUMIPSState *env)\n{\n    MIPSCPU *cpu = mips_env_get_cpu(env);\n    CPUState *cs = CPU(cpu);\n    /* Reset registers to their default values */\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n#ifdef TARGET_WORDS_BIGENDIAN\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n#endif\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n    env->CP0_Config4 = env->cpu_model->CP0_Config4;\n    env->CP0_Config4_rw_bitmask = env->cpu_model->CP0_Config4_rw_bitmask;\n    env->CP0_Config5 = env->cpu_model->CP0_Config5;\n    env->CP0_Config5_rw_bitmask = env->cpu_model->CP0_Config5_rw_bitmask;\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n                                 << env->cpu_model->CP0_LLAddr_shift;\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n    env->CCRes = env->cpu_model->CCRes;\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n    env->current_tc = 0;\n    env->SEGBITS = env->cpu_model->SEGBITS;\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n#if defined(TARGET_MIPS64)\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n        env->SEGMask |= 3ULL << 62;\n    }\n#endif\n    env->PABITS = env->cpu_model->PABITS;\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n    env->CP0_PageGrain_rw_bitmask = env->cpu_model->CP0_PageGrain_rw_bitmask;\n    env->CP0_PageGrain = env->cpu_model->CP0_PageGrain;\n    env->CP0_EBaseWG_rw_bitmask = env->cpu_model->CP0_EBaseWG_rw_bitmask;\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n    env->active_fpu.fcr31_rw_bitmask = env->cpu_model->CP1_fcr31_rw_bitmask;\n    env->active_fpu.fcr31 = env->cpu_model->CP1_fcr31;\n    env->msair = env->cpu_model->MSAIR;\n    env->insn_flags = env->cpu_model->insn_flags;\n#if defined(CONFIG_USER_ONLY)\n    env->CP0_Status = (MIPS_HFLAG_UM << CP0St_KSU);\n# ifdef TARGET_MIPS64\n    /* Enable 64-bit register mode.  */\n    env->CP0_Status |= (1 << CP0St_PX);\n# endif\n# ifdef TARGET_ABI_MIPSN64\n    /* Enable 64-bit address mode.  */\n    env->CP0_Status |= (1 << CP0St_UX);\n# endif\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n       hardware registers.  */\n    env->CP0_HWREna |= 0x0000000F;\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n        env->CP0_Status |= (1 << CP0St_CU1);\n    }\n    if (env->CP0_Config3 & (1 << CP0C3_DSPP)) {\n        env->CP0_Status |= (1 << CP0St_MX);\n    }\n# if defined(TARGET_MIPS64)\n    /* For MIPS64, init FR bit to 1 if FPU unit is there and bit is writable. */\n    if ((env->CP0_Config1 & (1 << CP0C1_FP)) &&\n        (env->CP0_Status_rw_bitmask & (1 << CP0St_FR))) {\n        env->CP0_Status |= (1 << CP0St_FR);\n    }\n# endif\n#else\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n        /* If the exception was raised from a delay slot,\n           come back to the jump.  */\n        env->CP0_ErrorEPC = (env->active_tc.PC\n                             - (env->hflags & MIPS_HFLAG_B16 ? 2 : 4));\n    } else {\n        env->CP0_ErrorEPC = env->active_tc.PC;\n    }\n    env->active_tc.PC = env->exception_base;\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n    env->CP0_Wired = 0;\n    env->CP0_GlobalNumber = (cs->cpu_index & 0xFF) << CP0GN_VPId;\n    env->CP0_EBase = (cs->cpu_index & 0x3FF);\n    if (kvm_enabled()) {\n        env->CP0_EBase |= 0x40000000;\n    } else {\n        env->CP0_EBase |= (int32_t)0x80000000;\n    }\n    if (env->CP0_Config3 & (1 << CP0C3_CMGCR)) {\n        env->CP0_CMGCRBase = 0x1fbf8000 >> 4;\n    }\n    env->CP0_EntryHi_ASID_mask = (env->CP0_Config4 & (1 << CP0C4_AE)) ?\n                                 0x3ff : 0xff;\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n    /* vectored interrupts not implemented, timer on int 7,\n       no performance counters. */\n    env->CP0_IntCtl = 0xe0000000;\n    {\n        int i;\n        for (i = 0; i < 7; i++) {\n            env->CP0_WatchLo[i] = 0;\n            env->CP0_WatchHi[i] = 0x80000000;\n        }\n        env->CP0_WatchLo[7] = 0;\n        env->CP0_WatchHi[7] = 0;\n    }\n    /* Count register increments in debug mode, EJTAG version 1 */\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n    cpu_mips_store_count(env, 1);\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n        int i;\n        /* Only TC0 on VPE 0 starts as active.  */\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n            env->tcs[i].CP0_TCBind = cs->cpu_index << CP0TCBd_CurVPE;\n            env->tcs[i].CP0_TCHalt = 1;\n        }\n        env->active_tc.CP0_TCHalt = 1;\n        cs->halted = 1;\n        if (cs->cpu_index == 0) {\n            /* VPE0 starts up enabled.  */\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n            /* TC0 starts up unhalted.  */\n            cs->halted = 0;\n            env->active_tc.CP0_TCHalt = 0;\n            env->tcs[0].CP0_TCHalt = 0;\n            /* With thread 0 active.  */\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n        }\n    }\n#endif\n    if ((env->insn_flags & ISA_MIPS32R6) &&\n        (env->active_fpu.fcr0 & (1 << FCR0_F64))) {\n        /* Status.FR = 0 mode in 64-bit FPU not allowed in R6 */\n        env->CP0_Status |= (1 << CP0St_FR);\n    }\n    /* MSA */\n    if (env->CP0_Config3 & (1 << CP0C3_MSAP)) {\n        msa_reset(env);\n    }\n    compute_hflags(env);\n    restore_fp_status(env);\n    restore_pamask(env);\n    cs->exception_index = EXCP_NONE;\n    if (semihosting_get_argc()) {\n        /* UHI interface can be used to obtain argc and argv */\n        env->active_tc.gpr[4] = -1;\n    }\n}", "idx": 9805}
{"project": "qemu", "commit_id": "4d9ad7f793605abd9806fc932b3e04e028894565", "target": 1, "func": "uint64_t HELPER(neon_abdl_u64)(uint32_t a, uint32_t b)\n\n{\n\n    uint64_t result;\n\n    DO_ABD(result, a, b, uint32_t);\n\n    return result;\n\n}\n", "idx": 5593}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static int coroutine_fn sd_co_flush_to_disk(BlockDriverState *bs)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    SheepdogAIOCB *acb;\n\n    AIOReq *aio_req;\n\n\n\n    if (s->cache_flags != SD_FLAG_CMD_CACHE) {\n\n        return 0;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, NULL, 0, 0);\n\n    acb->aiocb_type = AIOCB_FLUSH_CACHE;\n\n    acb->aio_done_func = sd_finish_aiocb;\n\n\n\n    aio_req = alloc_aio_req(s, acb, vid_to_vdi_oid(s->inode.vdi_id),\n\n                            0, 0, 0, 0, 0);\n\n    QLIST_INSERT_HEAD(&s->inflight_aio_head, aio_req, aio_siblings);\n\n    add_aio_request(s, aio_req, NULL, 0, false, acb->aiocb_type);\n\n\n\n    qemu_coroutine_yield();\n\n    return acb->ret;\n\n}\n", "idx": 2494}
{"project": "qemu", "commit_id": "02c4f26b1517d9e403ec10d6f6ca3c0276d19e43", "target": 1, "func": "int qed_check(BDRVQEDState *s, BdrvCheckResult *result, bool fix)\n\n{\n\n    QEDCheck check = {\n\n        .s = s,\n\n        .result = result,\n\n        .nclusters = qed_bytes_to_clusters(s, s->file_size),\n\n        .request = { .l2_table = NULL },\n\n        .fix = fix,\n\n    };\n\n    int ret;\n\n\n\n    check.used_clusters = g_try_malloc0(((check.nclusters + 31) / 32) *\n\n                                        sizeof(check.used_clusters[0]));\n\n    if (check.nclusters && check.used_clusters == NULL) {\n\n        return -ENOMEM;\n\n    }\n\n\n\n    check.result->bfi.total_clusters =\n\n        (s->header.image_size + s->header.cluster_size - 1) /\n\n            s->header.cluster_size;\n\n    ret = qed_check_l1_table(&check, s->l1_table);\n\n    if (ret == 0) {\n\n        /* Only check for leaks if entire image was scanned successfully */\n\n        qed_check_for_leaks(&check);\n\n\n\n        if (fix) {\n\n            qed_check_mark_clean(s, result);\n\n        }\n\n    }\n\n\n\n    g_free(check.used_clusters);\n\n    return ret;\n\n}\n", "idx": 5700}
{"project": "qemu", "commit_id": "1e2713384c58037ad44f716c31c08daca18862c5", "target": 1, "func": "static void test_qga_config(gconstpointer data)\n\n{\n\n    GError *error = NULL;\n\n    char *cwd, *cmd, *out, *err, *str, **strv, **argv = NULL;\n\n    char *env[2];\n\n    int status;\n\n    gsize n;\n\n    GKeyFile *kf;\n\n\n\n    cwd = g_get_current_dir();\n\n    cmd = g_strdup_printf(\"%s%cqemu-ga -D\",\n\n                          cwd, G_DIR_SEPARATOR);\n\n\n    g_shell_parse_argv(cmd, NULL, &argv, &error);\n\n\n    g_assert_no_error(error);\n\n\n\n    env[0] = g_strdup_printf(\"QGA_CONF=tests%cdata%ctest-qga-config\",\n\n                             G_DIR_SEPARATOR, G_DIR_SEPARATOR);\n\n    env[1] = NULL;\n\n    g_spawn_sync(NULL, argv, env, 0,\n\n                 NULL, NULL, &out, &err, &status, &error);\n\n    g_strfreev(argv);\n\n\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(err, ==, \"\");\n\n    g_assert_cmpint(status, ==, 0);\n\n\n\n    kf = g_key_file_new();\n\n    g_key_file_load_from_data(kf, out, -1, G_KEY_FILE_NONE, &error);\n\n    g_assert_no_error(error);\n\n\n\n    str = g_key_file_get_start_group(kf);\n\n    g_assert_cmpstr(str, ==, \"general\");\n\n    g_free(str);\n\n\n\n    g_assert_false(g_key_file_get_boolean(kf, \"general\", \"daemon\", &error));\n\n    g_assert_no_error(error);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"method\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"virtio-serial\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"path\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/path/to/org.qemu.guest_agent.0\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"pidfile\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/var/foo/qemu-ga.pid\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"statedir\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/var/state\");\n\n    g_free(str);\n\n\n\n    g_assert_true(g_key_file_get_boolean(kf, \"general\", \"verbose\", &error));\n\n    g_assert_no_error(error);\n\n\n\n    strv = g_key_file_get_string_list(kf, \"general\", \"blacklist\", &n, &error);\n\n    g_assert_cmpint(n, ==, 2);\n\n#if GLIB_CHECK_VERSION(2, 44, 0)\n\n    g_assert_true(g_strv_contains((const char * const *)strv,\n\n                                  \"guest-ping\"));\n\n    g_assert_true(g_strv_contains((const char * const *)strv,\n\n                                  \"guest-get-time\"));\n\n#endif\n\n    g_assert_no_error(error);\n\n    g_strfreev(strv);\n\n\n\n    g_free(out);\n\n    g_free(err);\n\n    g_free(env[0]);\n\n    g_key_file_free(kf);\n\n}", "idx": 5841}
{"project": "qemu", "commit_id": "9ff7f5bddbe5814bafe5e798d2cf1087b58dc7b6", "target": 1, "func": "void exynos4210_init_board_irqs(Exynos4210Irq *s)\n\n{\n\n    uint32_t grp, bit, irq_id, n;\n\n\n\n    for (n = 0; n < EXYNOS4210_MAX_EXT_COMBINER_IN_IRQ; n++) {\n\n        s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n],\n\n                s->ext_combiner_irq[n]);\n\n\n\n        irq_id = 0;\n\n        if (n == EXYNOS4210_COMBINER_GET_IRQ_NUM(1, 4) ||\n\n                n == EXYNOS4210_COMBINER_GET_IRQ_NUM(12, 4)) {\n\n            /* MCT_G0 is passed to External GIC */\n\n            irq_id = EXT_GIC_ID_MCT_G0;\n\n        }\n\n        if (n == EXYNOS4210_COMBINER_GET_IRQ_NUM(1, 5) ||\n\n                n == EXYNOS4210_COMBINER_GET_IRQ_NUM(12, 5)) {\n\n            /* MCT_G1 is passed to External and GIC */\n\n            irq_id = EXT_GIC_ID_MCT_G1;\n\n        }\n\n        if (irq_id) {\n\n            s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n],\n\n                    s->ext_gic_irq[irq_id-32]);\n\n        }\n\n\n\n    }\n\n    for (; n < EXYNOS4210_MAX_INT_COMBINER_IN_IRQ; n++) {\n\n        /* these IDs are passed to Internal Combiner and External GIC */\n\n        grp = EXYNOS4210_COMBINER_GET_GRP_NUM(n);\n\n        bit = EXYNOS4210_COMBINER_GET_BIT_NUM(n);\n\n        irq_id = combiner_grp_to_gic_id[grp -\n\n                     EXYNOS4210_MAX_EXT_COMBINER_OUT_IRQ][bit];\n\n\n\n        if (irq_id) {\n\n            s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n],\n\n                    s->ext_gic_irq[irq_id-32]);\n\n        }\n\n    }\n\n}\n", "idx": 12040}
{"project": "qemu", "commit_id": "a8a21be9855e0bb0947a7325d0d1741a8814f21e", "target": 1, "func": "static int net_bridge_run_helper(const char *helper, const char *bridge)\n\n{\n\n    sigset_t oldmask, mask;\n\n    int pid, status;\n\n    char *args[5];\n\n    char **parg;\n\n    int sv[2];\n\n\n\n    sigemptyset(&mask);\n\n    sigaddset(&mask, SIGCHLD);\n\n    sigprocmask(SIG_BLOCK, &mask, &oldmask);\n\n\n\n    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sv) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    /* try to launch bridge helper */\n\n    pid = fork();\n\n    if (pid == 0) {\n\n        int open_max = sysconf(_SC_OPEN_MAX), i;\n\n        char fd_buf[6+10];\n\n        char br_buf[6+IFNAMSIZ] = {0};\n\n        char helper_cmd[PATH_MAX + sizeof(fd_buf) + sizeof(br_buf) + 15];\n\n\n\n        for (i = 3; i < open_max; i++) {\n\n            if (i != sv[1]) {\n\n                close(i);\n\n            }\n\n        }\n\n\n\n        snprintf(fd_buf, sizeof(fd_buf), \"%s%d\", \"--fd=\", sv[1]);\n\n\n\n        if (strrchr(helper, ' ') || strrchr(helper, '\\t')) {\n\n            /* assume helper is a command */\n\n\n\n            if (strstr(helper, \"--br=\") == NULL) {\n\n                snprintf(br_buf, sizeof(br_buf), \"%s%s\", \"--br=\", bridge);\n\n            }\n\n\n\n            snprintf(helper_cmd, sizeof(helper_cmd), \"%s %s %s %s\",\n\n                     helper, \"--use-vnet\", fd_buf, br_buf);\n\n\n\n            parg = args;\n\n            *parg++ = (char *)\"sh\";\n\n            *parg++ = (char *)\"-c\";\n\n            *parg++ = helper_cmd;\n\n            *parg++ = NULL;\n\n\n\n            execv(\"/bin/sh\", args);\n\n        } else {\n\n            /* assume helper is just the executable path name */\n\n\n\n            snprintf(br_buf, sizeof(br_buf), \"%s%s\", \"--br=\", bridge);\n\n\n\n            parg = args;\n\n            *parg++ = (char *)helper;\n\n            *parg++ = (char *)\"--use-vnet\";\n\n            *parg++ = fd_buf;\n\n            *parg++ = br_buf;\n\n            *parg++ = NULL;\n\n\n\n            execv(helper, args);\n\n        }\n\n        _exit(1);\n\n\n\n    } else if (pid > 0) {\n\n        int fd;\n\n\n\n        close(sv[1]);\n\n\n\n        do {\n\n            fd = recv_fd(sv[0]);\n\n        } while (fd == -1 && errno == EINTR);\n\n\n\n        close(sv[0]);\n\n\n\n        while (waitpid(pid, &status, 0) != pid) {\n\n            /* loop */\n\n        }\n\n        sigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n        if (fd < 0) {\n\n            fprintf(stderr, \"failed to recv file descriptor\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\n            return fd;\n\n        }\n\n    }\n\n    fprintf(stderr, \"failed to launch bridge helper\\n\");\n\n    return -1;\n\n}\n", "idx": 2682}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void nbd_read(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n\n\n    if (client->recv_coroutine) {\n\n        qemu_coroutine_enter(client->recv_coroutine, NULL);\n\n    } else {\n\n        qemu_coroutine_enter(qemu_coroutine_create(nbd_trip), client);\n\n    }\n\n}\n", "idx": 12193}
{"project": "qemu", "commit_id": "f6bb84d53110398f4899c19dab4e0fe9908ec060", "target": 1, "func": "void *HELPER(lookup_tb_ptr)(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    TranslationBlock *tb;\n\n    target_ulong cs_base, pc;\n\n    uint32_t flags, hash;\n\n\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    hash = tb_jmp_cache_hash_func(pc);\n\n    tb = atomic_rcu_read(&cpu->tb_jmp_cache[hash]);\n\n\n\n    if (unlikely(!(tb\n\n                   && tb->pc == pc\n\n                   && tb->cs_base == cs_base\n\n                   && tb->flags == flags\n\n                   && tb->trace_vcpu_dstate == *cpu->trace_dstate))) {\n\n        tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n\n        if (!tb) {\n\n            return tcg_ctx.code_gen_epilogue;\n\n        }\n\n        atomic_set(&cpu->tb_jmp_cache[hash], tb);\n\n    }\n\n\n\n    qemu_log_mask_and_addr(CPU_LOG_EXEC, pc,\n\n                           \"Chain %p [%d: \" TARGET_FMT_lx \"] %s\\n\",\n\n                           tb->tc_ptr, cpu->cpu_index, pc,\n\n                           lookup_symbol(pc));\n\n    return tb->tc_ptr;\n\n}\n", "idx": 4714}
{"project": "qemu", "commit_id": "345ce423dd58b3ddc3cfbcbb1ca2eee25546e8be", "target": 1, "func": "print_insn_sparc (bfd_vma memaddr, disassemble_info *info)\n\n{\n\n  FILE *stream = info->stream;\n\n  bfd_byte buffer[4];\n\n  unsigned long insn;\n\n  sparc_opcode_hash *op;\n\n  /* Nonzero of opcode table has been initialized.  */\n\n  static int opcodes_initialized = 0;\n\n  /* bfd mach number of last call.  */\n\n  static unsigned long current_mach = 0;\n\n  bfd_vma (*getword) (const unsigned char *);\n\n\n\n  if (!opcodes_initialized\n\n      || info->mach != current_mach)\n\n    {\n\n      int i;\n\n\n\n      current_arch_mask = compute_arch_mask (info->mach);\n\n\n\n      if (!opcodes_initialized)\n\n        sorted_opcodes =\n\n          malloc (sparc_num_opcodes * sizeof (sparc_opcode *));\n\n      /* Reset the sorted table so we can resort it.  */\n\n      for (i = 0; i < sparc_num_opcodes; ++i)\n\n        sorted_opcodes[i] = &sparc_opcodes[i];\n\n      qsort ((char *) sorted_opcodes, sparc_num_opcodes,\n\n             sizeof (sorted_opcodes[0]), compare_opcodes);\n\n\n\n      build_hash_table (sorted_opcodes, opcode_hash_table, sparc_num_opcodes);\n\n      current_mach = info->mach;\n\n      opcodes_initialized = 1;\n\n    }\n\n\n\n  {\n\n    int status =\n\n      (*info->read_memory_func) (memaddr, buffer, sizeof (buffer), info);\n\n\n\n    if (status != 0)\n\n      {\n\n        (*info->memory_error_func) (status, memaddr, info);\n\n        return -1;\n\n      }\n\n  }\n\n\n\n  /* On SPARClite variants such as DANlite (sparc86x), instructions\n\n     are always big-endian even when the machine is in little-endian mode.  */\n\n  if (info->endian == BFD_ENDIAN_BIG || info->mach == bfd_mach_sparc_sparclite)\n\n    getword = bfd_getb32;\n\n  else\n\n    getword = bfd_getl32;\n\n\n\n  insn = getword (buffer);\n\n\n\n  info->insn_info_valid = 1;                    /* We do return this info.  */\n\n  info->insn_type = dis_nonbranch;              /* Assume non branch insn.  */\n\n  info->branch_delay_insns = 0;                 /* Assume no delay.  */\n\n  info->target = 0;                             /* Assume no target known.  */\n\n\n\n  for (op = opcode_hash_table[HASH_INSN (insn)]; op; op = op->next)\n\n    {\n\n      const sparc_opcode *opcode = op->opcode;\n\n\n\n      /* If the insn isn't supported by the current architecture, skip it.  */\n\n      if (! (opcode->architecture & current_arch_mask))\n\n        continue;\n\n\n\n      if ((opcode->match & insn) == opcode->match\n\n          && (opcode->lose & insn) == 0)\n\n        {\n\n          /* Nonzero means that we have found an instruction which has\n\n             the effect of adding or or'ing the imm13 field to rs1.  */\n\n          int imm_added_to_rs1 = 0;\n\n          int imm_ored_to_rs1 = 0;\n\n\n\n          /* Nonzero means that we have found a plus sign in the args\n\n             field of the opcode table.  */\n\n          int found_plus = 0;\n\n\n\n          /* Nonzero means we have an annulled branch.  */\n\n          /* int is_annulled = 0; */ /* see FIXME below */\n\n\n\n          /* Do we have an `add' or `or' instruction combining an\n\n             immediate with rs1?  */\n\n          if (opcode->match == 0x80102000) /* or */\n\n            imm_ored_to_rs1 = 1;\n\n          if (opcode->match == 0x80002000) /* add */\n\n            imm_added_to_rs1 = 1;\n\n\n\n          if (X_RS1 (insn) != X_RD (insn)\n\n              && strchr (opcode->args, 'r') != NULL)\n\n              /* Can't do simple format if source and dest are different.  */\n\n              continue;\n\n          if (X_RS2 (insn) != X_RD (insn)\n\n              && strchr (opcode->args, 'O') != NULL)\n\n              /* Can't do simple format if source and dest are different.  */\n\n              continue;\n\n\n\n          (*info->fprintf_func) (stream, \"%s\", opcode->name);\n\n\n\n          {\n\n            const char *s;\n\n\n\n            if (opcode->args[0] != ',')\n\n              (*info->fprintf_func) (stream, \" \");\n\n\n\n            for (s = opcode->args; *s != '\\0'; ++s)\n\n              {\n\n                while (*s == ',')\n\n                  {\n\n                    (*info->fprintf_func) (stream, \",\");\n\n                    ++s;\n\n                    switch (*s)\n\n                      {\n\n                      case 'a':\n\n                        (*info->fprintf_func) (stream, \"a\");\n\n                        /* is_annulled = 1; */ /* see FIXME below */\n\n                        ++s;\n\n                        continue;\n\n                      case 'N':\n\n                        (*info->fprintf_func) (stream, \"pn\");\n\n                        ++s;\n\n                        continue;\n\n\n\n                      case 'T':\n\n                        (*info->fprintf_func) (stream, \"pt\");\n\n                        ++s;\n\n                        continue;\n\n\n\n                      default:\n\n                        break;\n\n                      }\n\n                  }\n\n\n\n                (*info->fprintf_func) (stream, \" \");\n\n\n\n                switch (*s)\n\n                  {\n\n                  case '+':\n\n                    found_plus = 1;\n\n                    /* Fall through.  */\n\n\n\n                  default:\n\n                    (*info->fprintf_func) (stream, \"%c\", *s);\n\n                    break;\n\n\n\n                  case '#':\n\n                    (*info->fprintf_func) (stream, \"0\");\n\n                    break;\n\n\n\n#define reg(n)  (*info->fprintf_func) (stream, \"%%%s\", reg_names[n])\n\n                  case '1':\n\n                  case 'r':\n\n                    reg (X_RS1 (insn));\n\n                    break;\n\n\n\n                  case '2':\n\n                  case 'O':\n\n                    reg (X_RS2 (insn));\n\n                    break;\n\n\n\n                  case 'd':\n\n                    reg (X_RD (insn));\n\n                    break;\n\n#undef  reg\n\n\n\n#define freg(n)         (*info->fprintf_func) (stream, \"%%%s\", freg_names[n])\n\n#define fregx(n)        (*info->fprintf_func) (stream, \"%%%s\", freg_names[((n) & ~1) | (((n) & 1) << 5)])\n\n                  case 'e':\n\n                    freg (X_RS1 (insn));\n\n                    break;\n\n                  case 'v':     /* Double/even.  */\n\n                  case 'V':     /* Quad/multiple of 4.  */\n\n                    fregx (X_RS1 (insn));\n\n                    break;\n\n\n\n                  case 'f':\n\n                    freg (X_RS2 (insn));\n\n                    break;\n\n                  case 'B':     /* Double/even.  */\n\n                  case 'R':     /* Quad/multiple of 4.  */\n\n                    fregx (X_RS2 (insn));\n\n                    break;\n\n\n\n                  case 'g':\n\n                    freg (X_RD (insn));\n\n                    break;\n\n                  case 'H':     /* Double/even.  */\n\n                  case 'J':     /* Quad/multiple of 4.  */\n\n                    fregx (X_RD (insn));\n\n                    break;\n\n#undef  freg\n\n#undef  fregx\n\n\n\n#define creg(n) (*info->fprintf_func) (stream, \"%%c%u\", (unsigned int) (n))\n\n                  case 'b':\n\n                    creg (X_RS1 (insn));\n\n                    break;\n\n\n\n                  case 'c':\n\n                    creg (X_RS2 (insn));\n\n                    break;\n\n\n\n                  case 'D':\n\n                    creg (X_RD (insn));\n\n                    break;\n\n#undef  creg\n\n\n\n                  case 'h':\n\n                    (*info->fprintf_func) (stream, \"%%hi(%#x)\",\n\n                                           ((unsigned) 0xFFFFFFFF\n\n                                            & ((int) X_IMM22 (insn) << 10)));\n\n                    break;\n\n\n\n                  case 'i':     /* 13 bit immediate.  */\n\n                  case 'I':     /* 11 bit immediate.  */\n\n                  case 'j':     /* 10 bit immediate.  */\n\n                    {\n\n                      int imm;\n\n\n\n                      if (*s == 'i')\n\n                        imm = X_SIMM (insn, 13);\n\n                      else if (*s == 'I')\n\n                        imm = X_SIMM (insn, 11);\n\n                      else\n\n                        imm = X_SIMM (insn, 10);\n\n\n\n                      /* Check to see whether we have a 1+i, and take\n\n                         note of that fact.\n\n\n\n                         Note: because of the way we sort the table,\n\n                         we will be matching 1+i rather than i+1,\n\n                         so it is OK to assume that i is after +,\n\n                         not before it.  */\n\n                      if (found_plus)\n\n                        imm_added_to_rs1 = 1;\n\n\n\n                      if (imm <= 9)\n\n                        (*info->fprintf_func) (stream, \"%d\", imm);\n\n                      else\n\n                        (*info->fprintf_func) (stream, \"%#x\", imm);\n\n                    }\n\n                    break;\n\n\n\n                  case 'X':     /* 5 bit unsigned immediate.  */\n\n                  case 'Y':     /* 6 bit unsigned immediate.  */\n\n                    {\n\n                      int imm = X_IMM (insn, *s == 'X' ? 5 : 6);\n\n\n\n                      if (imm <= 9)\n\n                        (info->fprintf_func) (stream, \"%d\", imm);\n\n                      else\n\n                        (info->fprintf_func) (stream, \"%#x\", (unsigned) imm);\n\n                    }\n\n                    break;\n\n\n\n                  case '3':\n\n                    (info->fprintf_func) (stream, \"%ld\", X_IMM (insn, 3));\n\n                    break;\n\n\n\n                  case 'K':\n\n                    {\n\n                      int mask = X_MEMBAR (insn);\n\n                      int bit = 0x40, printed_one = 0;\n\n                      const char *name;\n\n\n\n                      if (mask == 0)\n\n                        (info->fprintf_func) (stream, \"0\");\n\n                      else\n\n                        while (bit)\n\n                          {\n\n                            if (mask & bit)\n\n                              {\n\n                                if (printed_one)\n\n                                  (info->fprintf_func) (stream, \"|\");\n\n                                name = sparc_decode_membar (bit);\n\n                                (info->fprintf_func) (stream, \"%s\", name);\n\n                                printed_one = 1;\n\n                              }\n\n                            bit >>= 1;\n\n                          }\n\n                      break;\n\n                    }\n\n\n\n                  case 'k':\n\n                    info->target = memaddr + SEX (X_DISP16 (insn), 16) * 4;\n\n                    (*info->print_address_func) (info->target, info);\n\n                    break;\n\n\n\n                  case 'G':\n\n                    info->target = memaddr + SEX (X_DISP19 (insn), 19) * 4;\n\n                    (*info->print_address_func) (info->target, info);\n\n                    break;\n\n\n\n                  case '6':\n\n                  case '7':\n\n                  case '8':\n\n                  case '9':\n\n                    (*info->fprintf_func) (stream, \"%%fcc%c\", *s - '6' + '0');\n\n                    break;\n\n\n\n                  case 'z':\n\n                    (*info->fprintf_func) (stream, \"%%icc\");\n\n                    break;\n\n\n\n                  case 'Z':\n\n                    (*info->fprintf_func) (stream, \"%%xcc\");\n\n                    break;\n\n\n\n                  case 'E':\n\n                    (*info->fprintf_func) (stream, \"%%ccr\");\n\n                    break;\n\n\n\n                  case 's':\n\n                    (*info->fprintf_func) (stream, \"%%fprs\");\n\n                    break;\n\n\n\n                  case 'o':\n\n                    (*info->fprintf_func) (stream, \"%%asi\");\n\n                    break;\n\n\n\n                  case 'W':\n\n                    (*info->fprintf_func) (stream, \"%%tick\");\n\n                    break;\n\n\n\n                  case 'P':\n\n                    (*info->fprintf_func) (stream, \"%%pc\");\n\n                    break;\n\n\n\n                  case '?':\n\n                    if (X_RS1 (insn) == 31)\n\n                      (*info->fprintf_func) (stream, \"%%ver\");\n\n                    else if ((unsigned) X_RS1 (insn) < 17)\n\n                      (*info->fprintf_func) (stream, \"%%%s\",\n\n                                             v9_priv_reg_names[X_RS1 (insn)]);\n\n                    else\n\n                      (*info->fprintf_func) (stream, \"%%reserved\");\n\n                    break;\n\n\n\n                  case '!':\n\n                    if ((unsigned) X_RD (insn) < 17)\n\n                      (*info->fprintf_func) (stream, \"%%%s\",\n\n                                             v9_priv_reg_names[X_RD (insn)]);\n\n                    else\n\n                      (*info->fprintf_func) (stream, \"%%reserved\");\n\n                    break;\n\n\n\n                  case '$':\n\n                    if ((unsigned) X_RS1 (insn) < 32)\n\n                      (*info->fprintf_func) (stream, \"%%%s\",\n\n                                             v9_hpriv_reg_names[X_RS1 (insn)]);\n\n                    else\n\n                      (*info->fprintf_func) (stream, \"%%reserved\");\n\n                    break;\n\n\n\n                  case '%':\n\n                    if ((unsigned) X_RD (insn) < 32)\n\n                      (*info->fprintf_func) (stream, \"%%%s\",\n\n                                             v9_hpriv_reg_names[X_RD (insn)]);\n\n                    else\n\n                      (*info->fprintf_func) (stream, \"%%reserved\");\n\n                    break;\n\n\n\n                  case '/':\n\n                    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 25)\n\n                      (*info->fprintf_func) (stream, \"%%reserved\");\n\n                    else\n\n                      (*info->fprintf_func) (stream, \"%%%s\",\n\n                                             v9a_asr_reg_names[X_RS1 (insn)-16]);\n\n                    break;\n\n\n\n                  case '_':\n\n                    if (X_RD (insn) < 16 || X_RD (insn) > 25)\n\n                      (*info->fprintf_func) (stream, \"%%reserved\");\n\n                    else\n\n                      (*info->fprintf_func) (stream, \"%%%s\",\n\n                                             v9a_asr_reg_names[X_RD (insn)-16]);\n\n                    break;\n\n\n\n                  case '*':\n\n                    {\n\n                      const char *name = sparc_decode_prefetch (X_RD (insn));\n\n\n\n                      if (name)\n\n                        (*info->fprintf_func) (stream, \"%s\", name);\n\n                      else\n\n                        (*info->fprintf_func) (stream, \"%ld\", X_RD (insn));\n\n                      break;\n\n                    }\n\n\n\n                  case 'M':\n\n                    (*info->fprintf_func) (stream, \"%%asr%ld\", X_RS1 (insn));\n\n                    break;\n\n\n\n                  case 'm':\n\n                    (*info->fprintf_func) (stream, \"%%asr%ld\", X_RD (insn));\n\n                    break;\n\n\n\n                  case 'L':\n\n                    info->target = memaddr + SEX (X_DISP30 (insn), 30) * 4;\n\n                    (*info->print_address_func) (info->target, info);\n\n                    break;\n\n\n\n                  case 'n':\n\n                    (*info->fprintf_func)\n\n                      (stream, \"%#x\", SEX (X_DISP22 (insn), 22));\n\n                    break;\n\n\n\n                  case 'l':\n\n                    info->target = memaddr + SEX (X_DISP22 (insn), 22) * 4;\n\n                    (*info->print_address_func) (info->target, info);\n\n                    break;\n\n\n\n                  case 'A':\n\n                    {\n\n                      const char *name;\n\n\n\n                      if ((info->mach == bfd_mach_sparc_v8plusa) ||\n\n                          ((info->mach >= bfd_mach_sparc_v9) &&\n\n                           (info->mach <= bfd_mach_sparc_v9b)))\n\n                        name = sparc_decode_asi_v9 (X_ASI (insn));\n\n                      else\n\n                        name = sparc_decode_asi_v8 (X_ASI (insn));\n\n\n\n                      if (name)\n\n                        (*info->fprintf_func) (stream, \"%s\", name);\n\n                      else\n\n                        (*info->fprintf_func) (stream, \"(%ld)\", X_ASI (insn));\n\n                      break;\n\n                    }\n\n\n\n                  case 'C':\n\n                    (*info->fprintf_func) (stream, \"%%csr\");\n\n                    break;\n\n\n\n                  case 'F':\n\n                    (*info->fprintf_func) (stream, \"%%fsr\");\n\n                    break;\n\n\n\n                  case 'p':\n\n                    (*info->fprintf_func) (stream, \"%%psr\");\n\n                    break;\n\n\n\n                  case 'q':\n\n                    (*info->fprintf_func) (stream, \"%%fq\");\n\n                    break;\n\n\n\n                  case 'Q':\n\n                    (*info->fprintf_func) (stream, \"%%cq\");\n\n                    break;\n\n\n\n                  case 't':\n\n                    (*info->fprintf_func) (stream, \"%%tbr\");\n\n                    break;\n\n\n\n                  case 'w':\n\n                    (*info->fprintf_func) (stream, \"%%wim\");\n\n                    break;\n\n\n\n                  case 'x':\n\n                    (*info->fprintf_func) (stream, \"%ld\",\n\n                                           ((X_LDST_I (insn) << 8)\n\n                                            + X_ASI (insn)));\n\n                    break;\n\n\n\n                  case 'y':\n\n                    (*info->fprintf_func) (stream, \"%%y\");\n\n                    break;\n\n\n\n                  case 'u':\n\n                  case 'U':\n\n                    {\n\n                      int val = *s == 'U' ? X_RS1 (insn) : X_RD (insn);\n\n                      const char *name = sparc_decode_sparclet_cpreg (val);\n\n\n\n                      if (name)\n\n                        (*info->fprintf_func) (stream, \"%s\", name);\n\n                      else\n\n                        (*info->fprintf_func) (stream, \"%%cpreg(%d)\", val);\n\n                      break;\n\n                    }\n\n                  }\n\n              }\n\n          }\n\n\n\n          /* If we are adding or or'ing something to rs1, then\n\n             check to see whether the previous instruction was\n\n             a sethi to the same register as in the sethi.\n\n             If so, attempt to print the result of the add or\n\n             or (in this context add and or do the same thing)\n\n             and its symbolic value.  */\n\n          if (imm_ored_to_rs1 || imm_added_to_rs1)\n\n            {\n\n              unsigned long prev_insn;\n\n              int errcode;\n\n\n\n              if (memaddr >= 4)\n\n                errcode =\n\n                  (*info->read_memory_func)\n\n                  (memaddr - 4, buffer, sizeof (buffer), info);\n\n              else\n\n                errcode = 1;\n\n\n\n              prev_insn = getword (buffer);\n\n\n\n              if (errcode == 0)\n\n                {\n\n                  /* If it is a delayed branch, we need to look at the\n\n                     instruction before the delayed branch.  This handles\n\n                     sequences such as:\n\n\n\n                     sethi %o1, %hi(_foo), %o1\n\n                     call _printf\n\n                     or %o1, %lo(_foo), %o1  */\n\n\n\n                  if (is_delayed_branch (prev_insn))\n\n                    {\n\n                      if (memaddr >= 8)\n\n                        errcode = (*info->read_memory_func)\n\n                          (memaddr - 8, buffer, sizeof (buffer), info);\n\n                      else\n\n                        errcode = 1;\n\n\n\n                      prev_insn = getword (buffer);\n\n                    }\n\n                }\n\n\n\n              /* If there was a problem reading memory, then assume\n\n                 the previous instruction was not sethi.  */\n\n              if (errcode == 0)\n\n                {\n\n                  /* Is it sethi to the same register?  */\n\n                  if ((prev_insn & 0xc1c00000) == 0x01000000\n\n                      && X_RD (prev_insn) == X_RS1 (insn))\n\n                    {\n\n                      (*info->fprintf_func) (stream, \"\\t! \");\n\n                      info->target =\n\n                        ((unsigned) 0xFFFFFFFF\n\n                         & ((int) X_IMM22 (prev_insn) << 10));\n\n                      if (imm_added_to_rs1)\n\n                        info->target += X_SIMM (insn, 13);\n\n                      else\n\n                        info->target |= X_SIMM (insn, 13);\n\n                      (*info->print_address_func) (info->target, info);\n\n                      info->insn_type = dis_dref;\n\n                      info->data_size = 4;  /* FIXME!!! */\n\n                    }\n\n                }\n\n            }\n\n\n\n          if (opcode->flags & (F_UNBR|F_CONDBR|F_JSR))\n\n            {\n\n                /* FIXME -- check is_annulled flag.  */\n\n              if (opcode->flags & F_UNBR)\n\n                info->insn_type = dis_branch;\n\n              if (opcode->flags & F_CONDBR)\n\n                info->insn_type = dis_condbranch;\n\n              if (opcode->flags & F_JSR)\n\n                info->insn_type = dis_jsr;\n\n              if (opcode->flags & F_DELAYED)\n\n                info->branch_delay_insns = 1;\n\n            }\n\n\n\n          return sizeof (buffer);\n\n        }\n\n    }\n\n\n\n  info->insn_type = dis_noninsn;        /* Mark as non-valid instruction.  */\n\n  (*info->fprintf_func) (stream, _(\"unknown\"));\n\n  return sizeof (buffer);\n\n}\n", "idx": 5050}
{"project": "qemu", "commit_id": "053965c7ff5b260672719884e644ce4117d01995", "target": 1, "func": "static int raw_pread(BlockDriverState *bs, int64_t offset,\n\n                     uint8_t *buf, int count)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int size, ret, shift, sum;\n\n\n\n    sum = 0;\n\n\n\n    if (s->aligned_buf != NULL)  {\n\n\n\n        if (offset & 0x1ff) {\n\n            /* align offset on a 512 bytes boundary */\n\n\n\n            shift = offset & 0x1ff;\n\n            size = (shift + count + 0x1ff) & ~0x1ff;\n\n            if (size > ALIGNED_BUFFER_SIZE)\n\n                size = ALIGNED_BUFFER_SIZE;\n\n            ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, size);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            size = 512 - shift;\n\n            if (size > count)\n\n                size = count;\n\n            memcpy(buf, s->aligned_buf + shift, size);\n\n\n\n            buf += size;\n\n            offset += size;\n\n            count -= size;\n\n            sum += size;\n\n\n\n            if (count == 0)\n\n                return sum;\n\n        }\n\n        if (count & 0x1ff || (uintptr_t) buf & 0x1ff) {\n\n\n\n            /* read on aligned buffer */\n\n\n\n            while (count) {\n\n\n\n                size = (count + 0x1ff) & ~0x1ff;\n\n                if (size > ALIGNED_BUFFER_SIZE)\n\n                    size = ALIGNED_BUFFER_SIZE;\n\n\n\n                ret = raw_pread_aligned(bs, offset, s->aligned_buf, size);\n\n                if (ret < 0)\n\n                    return ret;\n\n\n\n                size = ret;\n\n                if (size > count)\n\n                    size = count;\n\n\n\n                memcpy(buf, s->aligned_buf, size);\n\n\n\n                buf += size;\n\n                offset += size;\n\n                count -= size;\n\n                sum += size;\n\n            }\n\n\n\n            return sum;\n\n        }\n\n    }\n\n\n\n    return raw_pread_aligned(bs, offset, buf, count) + sum;\n\n}\n", "idx": 4967}
{"project": "qemu", "commit_id": "66dc50f7057b9a0191f54e55764412202306858d", "target": 1, "func": "int css_do_ssch(SubchDev *sch, ORB *orb)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (~(p->flags) & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA)) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {\n\n        ret = -EINPROGRESS;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & (SCSW_FCTL_START_FUNC |\n\n                   SCSW_FCTL_HALT_FUNC |\n\n                   SCSW_FCTL_CLEAR_FUNC)) {\n\n        ret = -EBUSY;\n\n        goto out;\n\n    }\n\n\n\n    /* If monitoring is active, update counter. */\n\n    if (channel_subsys.chnmon_active) {\n\n        css_update_chnmon(sch);\n\n    }\n\n    sch->orb = *orb;\n\n    sch->channel_prog = orb->cpa;\n\n    /* Trigger the start function. */\n\n    s->ctrl |= (SCSW_FCTL_START_FUNC | SCSW_ACTL_START_PEND);\n\n    s->flags &= ~SCSW_FLAGS_MASK_PNO;\n\n\n\n    ret = do_subchannel_work(sch);\n\n\n\nout:\n\n    return ret;\n\n}\n", "idx": 936}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 10600}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_reset(DeviceState *dev)\n\n{\n\n    rc4030State *s = RC4030(dev);\n\n    int i;\n\n\n\n    s->config = 0x410; /* some boards seem to accept 0x104 too */\n\n    s->revision = 1;\n\n    s->invalid_address_register = 0;\n\n\n\n    memset(s->dma_regs, 0, sizeof(s->dma_regs));\n\n    rc4030_dma_tt_update(s, 0, 0);\n\n\n\n    s->remote_failed_address = s->memory_failed_address = 0;\n\n    s->cache_maint = 0;\n\n    s->cache_ptag = s->cache_ltag = 0;\n\n    s->cache_bmask = 0;\n\n\n\n    s->memory_refresh_rate = 0x18186;\n\n    s->nvram_protect = 7;\n\n    for (i = 0; i < 15; i++)\n\n        s->rem_speed[i] = 7;\n\n    s->imr_jazz = 0x10; /* XXX: required by firmware, but why? */\n\n    s->isr_jazz = 0;\n\n\n\n    s->itr = 0;\n\n\n\n    qemu_irq_lower(s->timer_irq);\n\n    qemu_irq_lower(s->jazz_bus_irq);\n\n}\n", "idx": 5306}
{"project": "qemu", "commit_id": "73221b12ea55ae916b550e56d70743221ca3c886", "target": 1, "func": "static void ohci_reset(OHCIState *ohci)\n\n{\n\n    OHCIPort *port;\n\n    int i;\n\n\n\n    ohci->ctl = 0;\n\n    ohci->old_ctl = 0;\n\n    ohci->status = 0;\n\n    ohci->intr_status = 0;\n\n    ohci->intr = OHCI_INTR_MIE;\n\n\n\n    ohci->hcca = 0;\n\n    ohci->ctrl_head = ohci->ctrl_cur = 0;\n\n    ohci->bulk_head = ohci->bulk_cur = 0;\n\n    ohci->per_cur = 0;\n\n    ohci->done = 0;\n\n    ohci->done_count = 7;\n\n\n\n    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?\n\n     * I took the value linux sets ...\n\n     */\n\n    ohci->fsmps = 0x2778;\n\n    ohci->fi = 0x2edf;\n\n    ohci->fit = 0;\n\n    ohci->frt = 0;\n\n    ohci->frame_number = 0;\n\n    ohci->pstart = 0;\n\n    ohci->lst = OHCI_LS_THRESH;\n\n\n\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n\n    ohci->rhstatus = 0;\n\n\n\n    for (i = 0; i < ohci->num_ports; i++)\n\n      {\n\n        port = &ohci->rhport[i];\n\n        port->ctrl = 0;\n\n        if (port->port.dev)\n\n            ohci_attach(&port->port, port->port.dev);\n\n      }\n\n    if (ohci->async_td) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n    dprintf(\"usb-ohci: Reset %s\\n\", ohci->name);\n\n}\n", "idx": 12127}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 878}
{"project": "qemu", "commit_id": "f702e62a193e9ddb41cef95068717e5582b39a64", "target": 1, "func": "static void serial_ioport_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                unsigned size)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    addr &= 7;\n\n    DPRINTF(\"write addr=0x%\" HWADDR_PRIx \" val=0x%\" PRIx64 \"\\n\", addr, val);\n\n    switch(addr) {\n\n    default:\n\n    case 0:\n\n        if (s->lcr & UART_LCR_DLAB) {\n\n            s->divider = (s->divider & 0xff00) | val;\n\n            serial_update_parameters(s);\n\n        } else {\n\n            s->thr = (uint8_t) val;\n\n            if(s->fcr & UART_FCR_FE) {\n\n                /* xmit overruns overwrite data, so make space if needed */\n\n                if (fifo8_is_full(&s->xmit_fifo)) {\n\n                    fifo8_pop(&s->xmit_fifo);\n\n                }\n\n                fifo8_push(&s->xmit_fifo, s->thr);\n\n                s->lsr &= ~UART_LSR_TEMT;\n\n            }\n\n            s->thr_ipending = 0;\n\n            s->lsr &= ~UART_LSR_THRE;\n\n            serial_update_irq(s);\n\n            serial_xmit(NULL, G_IO_OUT, s);\n\n        }\n\n        break;\n\n    case 1:\n\n        if (s->lcr & UART_LCR_DLAB) {\n\n            s->divider = (s->divider & 0x00ff) | (val << 8);\n\n            serial_update_parameters(s);\n\n        } else {\n\n            s->ier = val & 0x0f;\n\n            /* If the backend device is a real serial port, turn polling of the modem\n\n               status lines on physical port on or off depending on UART_IER_MSI state */\n\n            if (s->poll_msl >= 0) {\n\n                if (s->ier & UART_IER_MSI) {\n\n                     s->poll_msl = 1;\n\n                     serial_update_msl(s);\n\n                } else {\n\n                     timer_del(s->modem_status_poll);\n\n                     s->poll_msl = 0;\n\n                }\n\n            }\n\n            if (s->lsr & UART_LSR_THRE) {\n\n                s->thr_ipending = 1;\n\n                serial_update_irq(s);\n\n            }\n\n        }\n\n        break;\n\n    case 2:\n\n        val = val & 0xFF;\n\n\n\n        if (s->fcr == val)\n\n            break;\n\n\n\n        /* Did the enable/disable flag change? If so, make sure FIFOs get flushed */\n\n        if ((val ^ s->fcr) & UART_FCR_FE)\n\n            val |= UART_FCR_XFR | UART_FCR_RFR;\n\n\n\n        /* FIFO clear */\n\n\n\n        if (val & UART_FCR_RFR) {\n\n            timer_del(s->fifo_timeout_timer);\n\n            s->timeout_ipending=0;\n\n            fifo8_reset(&s->recv_fifo);\n\n        }\n\n\n\n        if (val & UART_FCR_XFR) {\n\n            fifo8_reset(&s->xmit_fifo);\n\n        }\n\n\n\n        if (val & UART_FCR_FE) {\n\n            s->iir |= UART_IIR_FE;\n\n            /* Set recv_fifo trigger Level */\n\n            switch (val & 0xC0) {\n\n            case UART_FCR_ITL_1:\n\n                s->recv_fifo_itl = 1;\n\n                break;\n\n            case UART_FCR_ITL_2:\n\n                s->recv_fifo_itl = 4;\n\n                break;\n\n            case UART_FCR_ITL_3:\n\n                s->recv_fifo_itl = 8;\n\n                break;\n\n            case UART_FCR_ITL_4:\n\n                s->recv_fifo_itl = 14;\n\n                break;\n\n            }\n\n        } else\n\n            s->iir &= ~UART_IIR_FE;\n\n\n\n        /* Set fcr - or at least the bits in it that are supposed to \"stick\" */\n\n        s->fcr = val & 0xC9;\n\n        serial_update_irq(s);\n\n        break;\n\n    case 3:\n\n        {\n\n            int break_enable;\n\n            s->lcr = val;\n\n            serial_update_parameters(s);\n\n            break_enable = (val >> 6) & 1;\n\n            if (break_enable != s->last_break_enable) {\n\n                s->last_break_enable = break_enable;\n\n                qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_BREAK,\n\n                               &break_enable);\n\n            }\n\n        }\n\n        break;\n\n    case 4:\n\n        {\n\n            int flags;\n\n            int old_mcr = s->mcr;\n\n            s->mcr = val & 0x1f;\n\n            if (val & UART_MCR_LOOP)\n\n                break;\n\n\n\n            if (s->poll_msl >= 0 && old_mcr != s->mcr) {\n\n\n\n                qemu_chr_fe_ioctl(s->chr,CHR_IOCTL_SERIAL_GET_TIOCM, &flags);\n\n\n\n                flags &= ~(CHR_TIOCM_RTS | CHR_TIOCM_DTR);\n\n\n\n                if (val & UART_MCR_RTS)\n\n                    flags |= CHR_TIOCM_RTS;\n\n                if (val & UART_MCR_DTR)\n\n                    flags |= CHR_TIOCM_DTR;\n\n\n\n                qemu_chr_fe_ioctl(s->chr,CHR_IOCTL_SERIAL_SET_TIOCM, &flags);\n\n                /* Update the modem status after a one-character-send wait-time, since there may be a response\n\n                   from the device/computer at the other end of the serial line */\n\n                timer_mod(s->modem_status_poll, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + s->char_transmit_time);\n\n            }\n\n        }\n\n        break;\n\n    case 5:\n\n        break;\n\n    case 6:\n\n        break;\n\n    case 7:\n\n        s->scr = val;\n\n        break;\n\n    }\n\n}\n", "idx": 7718}
{"project": "qemu", "commit_id": "a076972a4d36381d610a854f0c336507650a1d34", "target": 1, "func": "aio_ctx_finalize(GSource     *source)\n{\n    AioContext *ctx = (AioContext *) source;\n    thread_pool_free(ctx->thread_pool);\n    aio_set_event_notifier(ctx, &ctx->notifier, NULL);\n    event_notifier_cleanup(&ctx->notifier);\n    rfifolock_destroy(&ctx->lock);\n    qemu_mutex_destroy(&ctx->bh_lock);\n    timerlistgroup_deinit(&ctx->tlg);", "idx": 5367}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void packet_id_queue_add(struct PacketIdQueue *q, uint64_t id)\n\n{\n\n    USBRedirDevice *dev = q->dev;\n\n    struct PacketIdQueueEntry *e;\n\n\n\n    DPRINTF(\"adding packet id %\"PRIu64\" to %s queue\\n\", id, q->name);\n\n\n\n    e = g_malloc0(sizeof(struct PacketIdQueueEntry));\n\n    e->id = id;\n\n    QTAILQ_INSERT_TAIL(&q->head, e, next);\n\n    q->size++;\n\n}\n", "idx": 8817}
{"project": "qemu", "commit_id": "302a0d3ed721e4c30c6a2a37f64c60b50ffd33b9", "target": 1, "func": "static int pdu_copy_sg(V9fsPDU *pdu, size_t offset, int rx, struct iovec *sg)\n\n{\n\n    size_t pos = 0;\n\n    int i, j;\n\n    struct iovec *src_sg;\n\n    unsigned int num;\n\n\n\n    if (rx) {\n\n        src_sg = pdu->elem.in_sg;\n\n        num = pdu->elem.in_num;\n\n    } else {\n\n        src_sg = pdu->elem.out_sg;\n\n        num = pdu->elem.out_num;\n\n    }\n\n\n\n    j = 0;\n\n    for (i = 0; i < num; i++) {\n\n        if (offset <= pos) {\n\n            sg[j].iov_base = src_sg[i].iov_base;\n\n            sg[j].iov_len = src_sg[i].iov_len;\n\n            j++;\n\n        } else if (offset < (src_sg[i].iov_len + pos)) {\n\n            sg[j].iov_base = src_sg[i].iov_base;\n\n            sg[j].iov_len = src_sg[i].iov_len;\n\n            sg[j].iov_base += (offset - pos);\n\n            sg[j].iov_len -= (offset - pos);\n\n            j++;\n\n        }\n\n        pos += src_sg[i].iov_len;\n\n    }\n\n\n\n    return j;\n\n}\n", "idx": 10942}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "static bool write_header(FILE *fp)\n\n{\n\n    static const TraceRecord header = {\n\n        .event = HEADER_EVENT_ID,\n\n        .timestamp_ns = HEADER_MAGIC,\n\n        .x1 = HEADER_VERSION,\n\n    };\n\n\n\n    return fwrite(&header, sizeof header, 1, fp) == 1;\n\n}\n", "idx": 5049}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int vhdx_create_new_headers(BlockDriverState *bs, uint64_t image_size,\n\n                                   uint32_t log_size)\n\n{\n\n    int ret = 0;\n\n    VHDXHeader *hdr = NULL;\n\n\n\n    hdr = g_malloc0(sizeof(VHDXHeader));\n\n\n\n    hdr->signature       = VHDX_HEADER_SIGNATURE;\n\n    hdr->sequence_number = g_random_int();\n\n    hdr->log_version     = 0;\n\n    hdr->version         = 1;\n\n    hdr->log_length      = log_size;\n\n    hdr->log_offset      = VHDX_HEADER_SECTION_END;\n\n    vhdx_guid_generate(&hdr->file_write_guid);\n\n    vhdx_guid_generate(&hdr->data_write_guid);\n\n\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER1_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n    hdr->sequence_number++;\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER2_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(hdr);\n\n    return ret;\n\n}\n", "idx": 7210}
{"project": "qemu", "commit_id": "ebee92b4fef9defa19a8c348ec8b2716732ad4df", "target": 1, "func": "static int print_block_option_help(const char *filename, const char *fmt)\n\n{\n\n    BlockDriver *drv, *proto_drv;\n\n    QEMUOptionParameter *create_options = NULL;\n\n\n\n    /* Find driver and parse its options */\n\n    drv = bdrv_find_format(fmt);\n\n    if (!drv) {\n\n        error_report(\"Unknown file format '%s'\", fmt);\n\n        return 1;\n\n    }\n\n\n\n    create_options = append_option_parameters(create_options,\n\n                                              drv->create_options);\n\n\n\n    if (filename) {\n\n        proto_drv = bdrv_find_protocol(filename, true);\n\n        if (!proto_drv) {\n\n            error_report(\"Unknown protocol '%s'\", filename);\n\n\n            return 1;\n\n        }\n\n        create_options = append_option_parameters(create_options,\n\n                                                  proto_drv->create_options);\n\n    }\n\n\n\n    print_option_help(create_options);\n\n\n    return 0;\n\n}", "idx": 4730}
{"project": "qemu", "commit_id": "f6351288b65130deb8102b17143f5d84f817a02a", "target": 1, "func": "static void dp8393x_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n\n    dc->realize = dp8393x_realize;\n\n    dc->reset = dp8393x_reset;\n\n    dc->vmsd = &vmstate_dp8393x;\n\n    dc->props = dp8393x_properties;\n\n\n\n}", "idx": 9403}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n\n    size_t i, pwlen;\n\n    unsigned char key[8];\n\n    time_t now = time(NULL);\n\n    QCryptoCipher *cipher = NULL;\n\n    Error *err = NULL;\n\n\n\n    if (!vs->vd->password) {\n\n        VNC_DEBUG(\"No password configured on server\");\n\n        goto reject;\n\n    }\n\n    if (vs->vd->expires < now) {\n\n        VNC_DEBUG(\"Password is expired\");\n\n        goto reject;\n\n    }\n\n\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n\n\n    /* Calculate the expected challenge response */\n\n    pwlen = strlen(vs->vd->password);\n\n    for (i=0; i<sizeof(key); i++)\n\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n\n\n\n    cipher = qcrypto_cipher_new(\n\n        QCRYPTO_CIPHER_ALG_DES_RFB,\n\n        QCRYPTO_CIPHER_MODE_ECB,\n\n        key, G_N_ELEMENTS(key),\n\n        &err);\n\n    if (!cipher) {\n\n        VNC_DEBUG(\"Cannot initialize cipher %s\",\n\n                  error_get_pretty(err));\n\n        error_free(err);\n\n        goto reject;\n\n    }\n\n\n\n    if (qcrypto_cipher_encrypt(cipher,\n\n                               vs->challenge,\n\n                               response,\n\n                               VNC_AUTH_CHALLENGE_SIZE,\n\n                               &err) < 0) {\n\n        VNC_DEBUG(\"Cannot encrypt challenge %s\",\n\n                  error_get_pretty(err));\n\n        error_free(err);\n\n        goto reject;\n\n    }\n\n\n\n    /* Compare expected vs actual challenge response */\n\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n\n        VNC_DEBUG(\"Client challenge response did not match\\n\");\n\n        goto reject;\n\n    } else {\n\n        VNC_DEBUG(\"Accepting VNC challenge response\\n\");\n\n        vnc_write_u32(vs, 0); /* Accept auth */\n\n        vnc_flush(vs);\n\n\n\n        start_client_init(vs);\n\n    }\n\n\n\n    qcrypto_cipher_free(cipher);\n\n    return 0;\n\n\n\nreject:\n\n    vnc_write_u32(vs, 1); /* Reject auth */\n\n    if (vs->minor >= 8) {\n\n        static const char err[] = \"Authentication failed\";\n\n        vnc_write_u32(vs, sizeof(err));\n\n        vnc_write(vs, err, sizeof(err));\n\n    }\n\n    vnc_flush(vs);\n\n    vnc_client_error(vs);\n\n    qcrypto_cipher_free(cipher);\n\n    return 0;\n\n}\n", "idx": 3788}
{"project": "qemu", "commit_id": "6687b79d636cd60ed9adb1177d0d946b58fa7717", "target": 1, "func": "static int net_init_nic(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    int idx;\n\n    NICInfo *nd;\n\n    const char *netdev;\n\n\n\n    idx = nic_get_free_idx();\n\n    if (idx == -1 || nb_nics >= MAX_NICS) {\n\n        error_report(\"Too Many NICs\");\n\n        return -1;\n\n    }\n\n\n\n    nd = &nd_table[idx];\n\n\n\n    memset(nd, 0, sizeof(*nd));\n\n\n\n    if ((netdev = qemu_opt_get(opts, \"netdev\"))) {\n\n        nd->netdev = qemu_find_netdev(netdev);\n\n        if (!nd->netdev) {\n\n            error_report(\"netdev '%s' not found\", netdev);\n\n            return -1;\n\n        }\n\n    } else {\n\n        assert(vlan);\n\n        nd->vlan = vlan;\n\n    }\n\n    if (name) {\n\n        nd->name = g_strdup(name);\n\n    }\n\n    if (qemu_opt_get(opts, \"model\")) {\n\n        nd->model = g_strdup(qemu_opt_get(opts, \"model\"));\n\n    }\n\n    if (qemu_opt_get(opts, \"addr\")) {\n\n        nd->devaddr = g_strdup(qemu_opt_get(opts, \"addr\"));\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"macaddr\") &&\n\n        net_parse_macaddr(nd->macaddr.a, qemu_opt_get(opts, \"macaddr\")) < 0) {\n\n        error_report(\"invalid syntax for ethernet address\");\n\n        return -1;\n\n    }\n\n    qemu_macaddr_default_if_unset(&nd->macaddr);\n\n\n\n    nd->nvectors = qemu_opt_get_number(opts, \"vectors\",\n\n                                       DEV_NVECTORS_UNSPECIFIED);\n\n    if (nd->nvectors != DEV_NVECTORS_UNSPECIFIED &&\n\n        (nd->nvectors < 0 || nd->nvectors > 0x7ffffff)) {\n\n        error_report(\"invalid # of vectors: %d\", nd->nvectors);\n\n        return -1;\n\n    }\n\n\n\n    nd->used = 1;\n\n    nb_nics++;\n\n\n\n    return idx;\n\n}\n", "idx": 3999}
{"project": "qemu", "commit_id": "bd9ccd8517e83b7c33a9167815dbfffb30d70b13", "target": 1, "func": "static inline void vmsvga_fill_rect(struct vmsvga_state_s *s,\n\n                uint32_t c, int x, int y, int w, int h)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n\n    int bypl = surface_stride(surface);\n\n    int width = surface_bytes_per_pixel(surface) * w;\n\n    int line = h;\n\n    int column;\n\n    uint8_t *fst;\n\n    uint8_t *dst;\n\n    uint8_t *src;\n\n    uint8_t col[4];\n\n\n\n    col[0] = c;\n\n    col[1] = c >> 8;\n\n    col[2] = c >> 16;\n\n    col[3] = c >> 24;\n\n\n\n    fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;\n\n\n\n    if (line--) {\n\n        dst = fst;\n\n        src = col;\n\n        for (column = width; column > 0; column--) {\n\n            *(dst++) = *(src++);\n\n            if (src - col == surface_bytes_per_pixel(surface)) {\n\n                src = col;\n\n            }\n\n        }\n\n        dst = fst;\n\n        for (; line > 0; line--) {\n\n            dst += bypl;\n\n            memcpy(dst, fst, width);\n\n        }\n\n    }\n\n\n\n    vmsvga_update_rect_delayed(s, x, y, w, h);\n\n}\n", "idx": 1582}
{"project": "qemu", "commit_id": "bdf211f884113426e1f8226b69731593efa003ea", "target": 1, "func": "static abi_long do_ioctl_rt(const IOCTLEntry *ie, uint8_t *buf_temp,\n\n                                int fd, int cmd, abi_long arg)\n\n{\n\n    const argtype *arg_type = ie->arg_type;\n\n    const StructEntry *se;\n\n    const argtype *field_types;\n\n    const int *dst_offsets, *src_offsets;\n\n    int target_size;\n\n    void *argptr;\n\n    abi_ulong *target_rt_dev_ptr;\n\n    unsigned long *host_rt_dev_ptr;\n\n    abi_long ret;\n\n    int i;\n\n\n\n    assert(ie->access == IOC_W);\n\n    assert(*arg_type == TYPE_PTR);\n\n    arg_type++;\n\n    assert(*arg_type == TYPE_STRUCT);\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        return -TARGET_EFAULT;\n\n    }\n\n    arg_type++;\n\n    assert(*arg_type == (int)STRUCT_rtentry);\n\n    se = struct_entries + *arg_type++;\n\n    assert(se->convert[0] == NULL);\n\n    /* convert struct here to be able to catch rt_dev string */\n\n    field_types = se->field_types;\n\n    dst_offsets = se->field_offsets[THUNK_HOST];\n\n    src_offsets = se->field_offsets[THUNK_TARGET];\n\n    for (i = 0; i < se->nb_fields; i++) {\n\n        if (dst_offsets[i] == offsetof(struct rtentry, rt_dev)) {\n\n            assert(*field_types == TYPE_PTRVOID);\n\n            target_rt_dev_ptr = (abi_ulong *)(argptr + src_offsets[i]);\n\n            host_rt_dev_ptr = (unsigned long *)(buf_temp + dst_offsets[i]);\n\n            if (*target_rt_dev_ptr != 0) {\n\n                *host_rt_dev_ptr = (unsigned long)lock_user_string(\n\n                                                  tswapal(*target_rt_dev_ptr));\n\n                if (!*host_rt_dev_ptr) {\n\n                    unlock_user(argptr, arg, 0);\n\n                    return -TARGET_EFAULT;\n\n                }\n\n            } else {\n\n                *host_rt_dev_ptr = 0;\n\n            }\n\n            field_types++;\n\n            continue;\n\n        }\n\n        field_types = thunk_convert(buf_temp + dst_offsets[i],\n\n                                    argptr + src_offsets[i],\n\n                                    field_types, THUNK_HOST);\n\n    }\n\n    unlock_user(argptr, arg, 0);\n\n    assert(host_rt_dev_ptr);\n\n\n\n    ret = get_errno(safe_ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (*host_rt_dev_ptr != 0) {\n\n        unlock_user((void *)*host_rt_dev_ptr,\n\n                    *target_rt_dev_ptr, 0);\n\n    }\n\n    return ret;\n\n}\n", "idx": 2342}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_configuration_status(void *priv, uint32_t id,\n\n    struct usb_redir_configuration_status_header *config_status)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    AsyncURB *aurb;\n\n    int len = 0;\n\n\n\n    DPRINTF(\"set config status %d config %d id %u\\n\", config_status->status,\n\n            config_status->configuration, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        return;\n\n    }\n\n    if (aurb->packet) {\n\n        if (aurb->get) {\n\n            dev->dev.data_buf[0] = config_status->configuration;\n\n            len = 1;\n\n        }\n\n        aurb->packet->len =\n\n            usbredir_handle_status(dev, config_status->status, len);\n\n        usb_generic_async_ctrl_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n}\n", "idx": 4704}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_realize(DeviceState *dev, Error **errp)\n{\n    PnvChip *chip = PNV_CHIP(dev);\n    Error *error = NULL;\n    PnvChipClass *pcc = PNV_CHIP_GET_CLASS(chip);\n    char *typename = pnv_core_typename(pcc->cpu_model);\n    size_t typesize = object_type_get_instance_size(typename);\n    int i, core_hwid;\n    if (!object_class_by_name(typename)) {\n        error_setg(errp, \"Unable to find PowerNV CPU Core '%s'\", typename);\n    /* Cores */\n    pnv_chip_core_sanitize(chip, &error);\n    chip->cores = g_malloc0(typesize * chip->nr_cores);\n    for (i = 0, core_hwid = 0; (core_hwid < sizeof(chip->cores_mask) * 8)\n             && (i < chip->nr_cores); core_hwid++) {\n        char core_name[32];\n        void *pnv_core = chip->cores + i * typesize;\n        if (!(chip->cores_mask & (1ull << core_hwid))) {\n            continue;\n        object_initialize(pnv_core, typesize, typename);\n        snprintf(core_name, sizeof(core_name), \"core[%d]\", core_hwid);\n        object_property_add_child(OBJECT(chip), core_name, OBJECT(pnv_core),\n                                  &error_fatal);\n        object_property_set_int(OBJECT(pnv_core), smp_threads, \"nr-threads\",\n                                &error_fatal);\n        object_property_set_int(OBJECT(pnv_core), core_hwid,\n                                CPU_CORE_PROP_CORE_ID, &error_fatal);\n        object_property_set_int(OBJECT(pnv_core),\n                                pcc->core_pir(chip, core_hwid),\n                                \"pir\", &error_fatal);\n        object_property_set_bool(OBJECT(pnv_core), true, \"realized\",\n                                 &error_fatal);\n        object_unref(OBJECT(pnv_core));\n        i++;\n    g_free(typename);", "idx": 1414}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_tt_write(void *opaque, hwaddr addr, uint64_t data,\n\n                                unsigned int size)\n\n{\n\n    rc4030State *s = opaque;\n\n\n\n    /* write memory */\n\n    memcpy(memory_region_get_ram_ptr(&s->dma_tt) + addr, &data, size);\n\n\n\n    /* update dma address space (only if frame field has been written) */\n\n    if (addr % sizeof(dma_pagetable_entry) == 0) {\n\n        int index = addr / sizeof(dma_pagetable_entry);\n\n        memory_region_transaction_begin();\n\n        rc4030_dma_as_update_one(s, index, (uint32_t)data);\n\n        memory_region_transaction_commit();\n\n    }\n\n}\n", "idx": 7479}
{"project": "qemu", "commit_id": "864699227911909ef1e33ecf91bf3c900715a9b1", "target": 1, "func": "static int loadvm_postcopy_handle_run(MigrationIncomingState *mis)\n\n{\n\n    PostcopyState ps = postcopy_state_set(POSTCOPY_INCOMING_RUNNING);\n\n\n\n    trace_loadvm_postcopy_handle_run();\n\n    if (ps != POSTCOPY_INCOMING_LISTENING) {\n\n        error_report(\"CMD_POSTCOPY_RUN in wrong postcopy state (%d)\", ps);\n\n        return -1;\n\n    }\n\n\n\n    mis->bh = qemu_bh_new(loadvm_postcopy_handle_run_bh, NULL);\n\n    qemu_bh_schedule(mis->bh);\n\n\n\n    /* We need to finish reading the stream from the package\n\n     * and also stop reading anything more from the stream that loaded the\n\n     * package (since it's now being read by the listener thread).\n\n     * LOADVM_QUIT will quit all the layers of nested loadvm loops.\n\n     */\n\n    return LOADVM_QUIT;\n\n}\n", "idx": 10795}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n\n                              int is_user, int is_softmmu)\n\n{\n\n    mmu_ctx_t ctx;\n\n    int exception = 0, error_code = 0;\n\n    int access_type;\n\n    int ret = 0;\n\n    \n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        /* XXX: put correct access by using cpu_restore_state()\n\n           correctly */\n\n        access_type = ACCESS_INT;\n\n        //        access_type = env->access_type;\n\n    }\n\n    ret = get_physical_address(env, &ctx, address, rw, access_type, 1);\n\n    if (ret == 0) {\n\n        ret = tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                           ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                           is_user, is_softmmu);\n\n    } else if (ret < 0) {\n\n#if defined (DEBUG_MMU)\n\n        if (loglevel > 0)\n\n            cpu_dump_state(env, logfile, fprintf, 0);\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            exception = EXCP_ISI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                if (unlikely(PPC_MMU(env) == PPC_FLAGS_MMU_SOFT_6xx)) {\n\n                    exception = EXCP_I_TLBMISS;\n\n                    env->spr[SPR_IMISS] = address;\n\n                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;\n\n                    error_code = 1 << 18;\n\n                    goto tlb_miss;\n\n                } else if (unlikely(PPC_MMU(env) == PPC_FLAGS_MMU_SOFT_4xx)) {\n\n                    /* XXX: TODO */\n\n                } else {\n\n                    error_code = 0x40000000;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = 0x10000000;\n\n                break;\n\n            case -5:\n\n                /* No match in segment table */\n\n                exception = EXCP_ISEG;\n\n                error_code = 0;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                if (unlikely(PPC_MMU(env) == PPC_FLAGS_MMU_SOFT_6xx)) {\n\n                    if (rw == 1) {\n\n                        exception = EXCP_DS_TLBMISS;\n\n                        error_code = 1 << 16;\n\n                    } else {\n\n                        exception = EXCP_DL_TLBMISS;\n\n                        error_code = 0;\n\n                    }\n\n                    env->spr[SPR_DMISS] = address;\n\n                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;\n\n                tlb_miss:\n\n                    error_code |= ctx.key << 19;\n\n                    env->spr[SPR_HASH1] = ctx.pg_addr[0];\n\n                    env->spr[SPR_HASH2] = ctx.pg_addr[1];\n\n                    /* Do not alter DAR nor DSISR */\n\n                    goto out;\n\n                } else if (unlikely(PPC_MMU(env) == PPC_FLAGS_MMU_SOFT_4xx)) {\n\n                    /* XXX: TODO */\n\n                } else {\n\n                    error_code = 0x40000000;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = 0x08000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    error_code = 0x04000000;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    error_code = 0x04100000;\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n                break;\n\n            case -5:\n\n                /* No match in segment table */\n\n                exception = EXCP_DSEG;\n\n                error_code = 0;\n\n                break;\n\n            }\n\n            if (exception == EXCP_DSI && rw == 1)\n\n                error_code |= 0x02000000;\n\n            /* Store fault address */\n\n            env->spr[SPR_DAR] = address;\n\n            env->spr[SPR_DSISR] = error_code;\n\n        }\n\n    out:\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 5347}
{"project": "qemu", "commit_id": "546a7dc40e8b8b6440a052e2b5cdfe9aadcaccf6", "target": 1, "func": "int qcow2_backing_read1(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                        int64_t offset, int bytes)\n\n{\n\n    uint64_t bs_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    int n1;\n\n\n\n    if ((offset + bytes) <= bs_size) {\n\n        return bytes;\n\n    }\n\n\n\n    if (offset >= bs_size) {\n\n        n1 = 0;\n\n    } else {\n\n        n1 = bs_size - offset;\n\n    }\n\n\n\n    qemu_iovec_memset(qiov, n1, 0, bytes - n1);\n\n\n\n    return n1;\n\n}\n", "idx": 6831}
{"project": "qemu", "commit_id": "edc243851279e3393000b28b6b69454cae1190ef", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 6830}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_user(DisasContext *dc)\n\n{\n\n    LOG_DIS(\"user\");\n\n\n\n    cpu_abort(dc->env, \"user insn undefined\\n\");\n\n}\n", "idx": 11548}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void usb_msd_cancel_io(USBPacket *p, void *opaque)\n\n{\n\n    MSDState *s = opaque;\n\n    s->scsi_dev->info->cancel_io(s->scsi_dev, s->tag);\n\n    s->packet = NULL;\n\n    s->scsi_len = 0;\n\n}\n", "idx": 9965}
{"project": "qemu", "commit_id": "2ad645d2854746b55ddfd1d8e951f689cca5d78f", "target": 1, "func": "static int setup_common(char *argv[], int argv_sz)\n\n{\n\n    memset(cur_ide, 0, sizeof(cur_ide));\n\n    return append_arg(0, argv, argv_sz,\n\n                      g_strdup(\"-nodefaults -display none\"));\n\n}\n", "idx": 10237}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_byte(QEMUFile *f, int v)\n\n{\n\n    if (f->last_error) {\n\n        return;\n\n    }\n\n\n\n    f->buf[f->buf_index] = v;\n\n    f->bytes_xfer++;\n\n    if (f->ops->writev_buffer) {\n\n        add_to_iovec(f, f->buf + f->buf_index, 1);\n\n    }\n\n    f->buf_index++;\n\n    if (f->buf_index == IO_BUF_SIZE) {\n\n        qemu_fflush(f);\n\n    }\n\n}\n", "idx": 10557}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_msi_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint64_t r = 0;\n\n    int i, srs;\n\n\n\n    DPRINTF(\"%s: addr \" TARGET_FMT_plx \"\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        return -1;\n\n    }\n\n\n\n    srs = addr >> 4;\n\n\n\n    switch (addr) {\n\n    case 0x00:\n\n    case 0x10:\n\n    case 0x20:\n\n    case 0x30:\n\n    case 0x40:\n\n    case 0x50:\n\n    case 0x60:\n\n    case 0x70: /* MSIRs */\n\n        r = opp->msi[srs].msir;\n\n        /* Clear on read */\n\n        opp->msi[srs].msir = 0;\n\n        break;\n\n    case 0x120: /* MSISR */\n\n        for (i = 0; i < MAX_MSI; i++) {\n\n            r |= (opp->msi[i].msir ? 1 : 0) << i;\n\n        }\n\n        break;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 659}
{"project": "qemu", "commit_id": "66a08cbe6ad1aebec8eecf58b3ba042e19dd1649", "target": 1, "func": "static void uhci_process_frame(UHCIState *s)\n\n{\n\n    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;\n\n    uint32_t curr_qh, td_count = 0;\n\n    int cnt, ret;\n\n    UHCI_TD td;\n\n    UHCI_QH qh;\n\n    QhDb qhdb;\n\n\n\n    frame_addr = s->fl_base_addr + ((s->frnum & 0x3ff) << 2);\n\n\n\n    pci_dma_read(&s->dev, frame_addr, &link, 4);\n\n    le32_to_cpus(&link);\n\n\n\n    int_mask = 0;\n\n    curr_qh  = 0;\n\n\n\n    qhdb_reset(&qhdb);\n\n\n\n    for (cnt = FRAME_MAX_LOOPS; is_valid(link) && cnt; cnt--) {\n\n        if (s->frame_bytes >= s->frame_bandwidth) {\n\n            /* We've reached the usb 1.1 bandwidth, which is\n\n               1280 bytes/frame, stop processing */\n\n            trace_usb_uhci_frame_stop_bandwidth();\n\n            break;\n\n        }\n\n        if (is_qh(link)) {\n\n            /* QH */\n\n            trace_usb_uhci_qh_load(link & ~0xf);\n\n\n\n            if (qhdb_insert(&qhdb, link)) {\n\n                /*\n\n                 * We're going in circles. Which is not a bug because\n\n                 * HCD is allowed to do that as part of the BW management.\n\n                 *\n\n                 * Stop processing here if no transaction has been done\n\n                 * since we've been here last time.\n\n                 */\n\n                if (td_count == 0) {\n\n                    trace_usb_uhci_frame_loop_stop_idle();\n\n                    break;\n\n                } else {\n\n                    trace_usb_uhci_frame_loop_continue();\n\n                    td_count = 0;\n\n                    qhdb_reset(&qhdb);\n\n                    qhdb_insert(&qhdb, link);\n\n                }\n\n            }\n\n\n\n            pci_dma_read(&s->dev, link & ~0xf, &qh, sizeof(qh));\n\n            le32_to_cpus(&qh.link);\n\n            le32_to_cpus(&qh.el_link);\n\n\n\n            if (!is_valid(qh.el_link)) {\n\n                /* QH w/o elements */\n\n                curr_qh = 0;\n\n                link = qh.link;\n\n            } else {\n\n                /* QH with elements */\n\n            \tcurr_qh = link;\n\n            \tlink = qh.el_link;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        /* TD */\n\n        uhci_read_td(s, &td, link);\n\n        trace_usb_uhci_td_load(curr_qh & ~0xf, link & ~0xf, td.ctrl, td.token);\n\n\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, NULL, &td, link, &int_mask);\n\n        if (old_td_ctrl != td.ctrl) {\n\n            /* update the status bits of the TD */\n\n            val = cpu_to_le32(td.ctrl);\n\n            pci_dma_write(&s->dev, (link & ~0xf) + 4, &val, sizeof(val));\n\n        }\n\n\n\n        switch (ret) {\n\n        case TD_RESULT_STOP_FRAME: /* interrupted frame */\n\n            goto out;\n\n\n\n        case TD_RESULT_NEXT_QH:\n\n        case TD_RESULT_ASYNC_CONT:\n\n            trace_usb_uhci_td_nextqh(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_ASYNC_START:\n\n            trace_usb_uhci_td_async(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_COMPLETE:\n\n            trace_usb_uhci_td_complete(curr_qh & ~0xf, link & ~0xf);\n\n            link = td.link;\n\n            td_count++;\n\n            s->frame_bytes += (td.ctrl & 0x7ff) + 1;\n\n\n\n            if (curr_qh) {\n\n                /* update QH element link */\n\n                qh.el_link = link;\n\n                val = cpu_to_le32(qh.el_link);\n\n                pci_dma_write(&s->dev, (curr_qh & ~0xf) + 4, &val, sizeof(val));\n\n\n\n                if (!depth_first(link)) {\n\n                    /* done with this QH */\n\n                    curr_qh = 0;\n\n                    link    = qh.link;\n\n                }\n\n            }\n\n            break;\n\n\n\n        default:\n\n            assert(!\"unknown return code\");\n\n        }\n\n\n\n        /* go to the next entry */\n\n    }\n\n\n\nout:\n\n    s->pending_int_mask |= int_mask;\n\n}\n", "idx": 2065}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_accept(RDMAContext *rdma)\n\n{\n\n    RDMACapabilities cap;\n\n    struct rdma_conn_param conn_param = {\n\n                                            .responder_resources = 2,\n\n                                            .private_data = &cap,\n\n                                            .private_data_len = sizeof(cap),\n\n                                         };\n\n    struct rdma_cm_event *cm_event;\n\n    struct ibv_context *verbs;\n\n    int ret = -EINVAL;\n\n    int idx;\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_CONNECT_REQUEST) {\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));\n\n\n\n    network_to_caps(&cap);\n\n\n\n    if (cap.version < 1 || cap.version > RDMA_CONTROL_VERSION_CURRENT) {\n\n            fprintf(stderr, \"Unknown source RDMA version: %d, bailing...\\n\",\n\n                            cap.version);\n\n            rdma_ack_cm_event(cm_event);\n\n            goto err_rdma_dest_wait;\n\n    }\n\n\n\n    /*\n\n     * Respond with only the capabilities this version of QEMU knows about.\n\n     */\n\n    cap.flags &= known_capabilities;\n\n\n\n    /*\n\n     * Enable the ones that we do know about.\n\n     * Add other checks here as new ones are introduced.\n\n     */\n\n    if (cap.flags & RDMA_CAPABILITY_PIN_ALL) {\n\n        rdma->pin_all = true;\n\n    }\n\n\n\n    rdma->cm_id = cm_event->id;\n\n    verbs = cm_event->id->verbs;\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n\n\n    DPRINTF(\"Memory pin all: %s\\n\", rdma->pin_all ? \"enabled\" : \"disabled\");\n\n\n\n    caps_to_network(&cap);\n\n\n\n    DPRINTF(\"verbs context after listen: %p\\n\", verbs);\n\n\n\n    if (!rdma->verbs) {\n\n        rdma->verbs = verbs;\n\n    } else if (rdma->verbs != verbs) {\n\n            fprintf(stderr, \"ibv context not matching %p, %p!\\n\",\n\n                    rdma->verbs, verbs);\n\n            goto err_rdma_dest_wait;\n\n    }\n\n\n\n    qemu_rdma_dump_id(\"dest_init\", verbs);\n\n\n\n    ret = qemu_rdma_alloc_pd_cq(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error allocating pd and cq!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = qemu_rdma_alloc_qp(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error allocating qp!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = qemu_rdma_init_ram_blocks(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error initializing ram blocks!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        ret = qemu_rdma_reg_control(rdma, idx);\n\n        if (ret) {\n\n            fprintf(stderr, \"rdma: error registering %d control!\\n\", idx);\n\n            goto err_rdma_dest_wait;\n\n        }\n\n    }\n\n\n\n    qemu_set_fd_handler2(rdma->channel->fd, NULL, NULL, NULL, NULL);\n\n\n\n    ret = rdma_accept(rdma->cm_id, &conn_param);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma_accept returns %d!\\n\", ret);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma_accept get_cm_event failed %d!\\n\", ret);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {\n\n        fprintf(stderr, \"rdma_accept not event established!\\n\");\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n    rdma->connected = true;\n\n\n\n    ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_READY);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error posting second control recv!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    qemu_rdma_dump_gid(\"dest_connect\", rdma->cm_id);\n\n\n\n    return 0;\n\n\n\nerr_rdma_dest_wait:\n\n    rdma->error_state = ret;\n\n    qemu_rdma_cleanup(rdma);\n\n    return ret;\n\n}\n", "idx": 10529}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 2759}
{"project": "qemu", "commit_id": "c8a9fd80719e63615dac12e3625223fb54aa8430", "target": 1, "func": "static void bdrv_ioctl_bh_cb(void *opaque)\n\n{\n\n    BdrvIoctlCompletionData *data = opaque;\n\n\n\n    bdrv_co_io_em_complete(data->co, -ENOTSUP);\n\n    qemu_bh_delete(data->bh);\n\n}\n", "idx": 2955}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_rfe(DisasContext *s, TCGv_i32 pc, TCGv_i32 cpsr)\n\n{\n\n    gen_set_cpsr(cpsr, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(cpsr);\n\n    store_reg(s, 15, pc);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 7500}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static int ram_find_and_save_block(RAMState *rs, bool last_stage)\n\n{\n\n    PageSearchStatus pss;\n\n    int pages = 0;\n\n    bool again, found;\n\n    ram_addr_t dirty_ram_abs; /* Address of the start of the dirty page in\n\n                                 ram_addr_t space */\n\n\n\n    /* No dirty page as there is zero RAM */\n\n    if (!ram_bytes_total()) {\n\n        return pages;\n\n    }\n\n\n\n    pss.block = rs->last_seen_block;\n\n    pss.offset = rs->last_offset;\n\n    pss.complete_round = false;\n\n\n\n    if (!pss.block) {\n\n        pss.block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n    }\n\n\n\n    do {\n\n        again = true;\n\n        found = get_queued_page(rs, &pss, &dirty_ram_abs);\n\n\n\n        if (!found) {\n\n            /* priority queue empty, so just search for something dirty */\n\n            found = find_dirty_block(rs, &pss, &again, &dirty_ram_abs);\n\n        }\n\n\n\n        if (found) {\n\n            pages = ram_save_host_page(rs, &pss, last_stage, dirty_ram_abs);\n\n        }\n\n    } while (!pages && again);\n\n\n\n    rs->last_seen_block = pss.block;\n\n    rs->last_offset = pss.offset;\n\n\n\n    return pages;\n\n}\n", "idx": 2149}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_getlock(void *opaque)\n{\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsGetlock *glock;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    glock = g_malloc(sizeof(*glock));\n    pdu_unmarshal(pdu, offset, \"dbqqds\", &fid, &glock->type,\n                  &glock->start, &glock->length, &glock->proc_id,\n                  &glock->client_id);\n    trace_v9fs_getlock(pdu->tag, pdu->id, fid,\n                       glock->type, glock->start, glock->length);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp->fs.fd, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    glock->type = P9_LOCK_TYPE_UNLCK;\n    offset += pdu_marshal(pdu, offset, \"bqqds\", glock->type,\n                          glock->start, glock->length, glock->proc_id,\n                          &glock->client_id);\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    complete_pdu(s, pdu, err);\n    v9fs_string_free(&glock->client_id);\n    g_free(glock);\n}", "idx": 3570}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "CBus *cbus_init(qemu_irq dat)\n\n{\n\n    CBusPriv *s = (CBusPriv *) g_malloc0(sizeof(*s));\n\n\n\n    s->dat_out = dat;\n\n    s->cbus.clk = qemu_allocate_irqs(cbus_clk, s, 1)[0];\n\n    s->cbus.dat = qemu_allocate_irqs(cbus_dat, s, 1)[0];\n\n    s->cbus.sel = qemu_allocate_irqs(cbus_sel, s, 1)[0];\n\n\n\n    s->sel = 1;\n\n    s->clk = 0;\n\n    s->dat = 0;\n\n\n\n    return &s->cbus;\n\n}\n", "idx": 8293}
{"project": "qemu", "commit_id": "ab7a0f0b6dbe8836d490c736803abef6e3695e1f", "target": 1, "func": "static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,\n\n                                 unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    uint32_t ret;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return 0;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        return s->dir[bank];\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        printf(\"%s: Read from a write-only register \" REG_FMT \"\\n\",\n\n                        __FUNCTION__, offset);\n\n        return s->gpsr[bank];\t/* Return last written value.  */\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        printf(\"%s: Read from a write-only register \" REG_FMT \"\\n\",\n\n                        __FUNCTION__, offset);\n\n        return 31337;\t\t/* Specified as unpredictable in the docs.  */\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising[bank];\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling[bank];\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2];\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2 + 1];\n\n\n\n    case GPLR:\t\t/* GPIO Pin-Level registers */\n\n        ret = (s->olevel[bank] & s->dir[bank]) |\n\n                (s->ilevel[bank] & ~s->dir[bank]);\n\n        qemu_irq_raise(s->read_notify);\n\n        return ret;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        return s->status[bank];\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9304}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                int32_t offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        prdt_tbl_entry_size(&tbl[off_idx]) - off_pos);\n\n\n\n        for (i = off_idx + 1; i < prdtl; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            prdt_tbl_entry_size(&tbl[i]));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\\n\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 6504}
{"project": "qemu", "commit_id": "bec1e9546e03b9e7f5152cf3e8c95cf8acff5e12", "target": 1, "func": "static ssize_t local_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n\n                              char *buf, size_t bufsz)\n\n{\n\n    ssize_t tsize = -1;\n\n    char *buffer;\n\n    char *path = fs_path->data;\n\n\n\n    if ((fs_ctx->export_flags & V9FS_SM_MAPPED) ||\n\n        (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE)) {\n\n        int fd;\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, O_RDONLY | O_NOFOLLOW);\n\n        g_free(buffer);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n        do {\n\n            tsize = read(fd, (void *)buf, bufsz);\n\n        } while (tsize == -1 && errno == EINTR);\n\n        close(fd);\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        tsize = readlink(buffer, buf, bufsz);\n\n        g_free(buffer);\n\n    }\n\n    return tsize;\n\n}\n", "idx": 6243}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "static void vm_completion(ReadLineState *rs, const char *str)\n\n{\n\n    size_t len;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    len = strlen(str);\n\n    readline_set_completion_index(rs, len);\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        SnapshotInfoList *snapshots, *snapshot;\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        bool ok = false;\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;\n\n        }\n\n        aio_context_release(ctx);\n\n        if (!ok) {\n\n            continue;\n\n        }\n\n\n\n        snapshot = snapshots;\n\n        while (snapshot) {\n\n            char *completion = snapshot->value->name;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            completion = snapshot->value->id;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            snapshot = snapshot->next;\n\n        }\n\n        qapi_free_SnapshotInfoList(snapshots);\n\n    }\n\n\n\n}\n", "idx": 7078}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_register_types(void)\n\n{\n\n    type_register_static(&boston_device);\n\n}\n", "idx": 1404}
{"project": "qemu", "commit_id": "4cad3867b6df2c0826ae508a9fe15dd0b9d8936a", "target": 1, "func": "int fw_cfg_add_bytes(FWCfgState *s, uint16_t key, uint8_t *data, uint32_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n\n\n    return 1;\n\n}\n", "idx": 7023}
{"project": "qemu", "commit_id": "a6109ff1b5d7184a9d490c4ff94f175940232ebd", "target": 1, "func": "static void vmsvga_init(struct vmsvga_state_s *s, int vga_ram_size)\n\n{\n\n    s->scratch_size = SVGA_SCRATCH_SIZE;\n\n    s->scratch = qemu_malloc(s->scratch_size * 4);\n\n\n\n    vmsvga_reset(s);\n\n\n\n    s->fifo_size = SVGA_FIFO_SIZE;\n\n    s->fifo_offset = qemu_ram_alloc(s->fifo_size);\n\n    s->fifo_ptr = qemu_get_ram_ptr(s->fifo_offset);\n\n\n\n    vga_common_init(&s->vga, vga_ram_size);\n\n    vga_init(&s->vga);\n\n    vmstate_register(0, &vmstate_vga_common, &s->vga);\n\n\n\n    s->vga.ds = graphic_console_init(vmsvga_update_display,\n\n                                     vmsvga_invalidate_display,\n\n                                     vmsvga_screen_dump,\n\n                                     vmsvga_text_update, s);\n\n\n\n    vga_init_vbe(&s->vga);\n\n    rom_add_vga(VGABIOS_FILENAME);\n\n}\n", "idx": 9793}
{"project": "qemu", "commit_id": "5d6c599fe1d69a1bf8c5c4d3c58be2b31cd625ad", "target": 1, "func": "void qmp_xen_save_devices_state(const char *filename, Error **errp)\n\n{\n\n    QEMUFile *f;\n\n    QIOChannelFile *ioc;\n\n    int saved_vm_running;\n\n    int ret;\n\n\n\n    saved_vm_running = runstate_is_running();\n\n    vm_stop(RUN_STATE_SAVE_VM);\n\n    global_state_store_running();\n\n\n\n    ioc = qio_channel_file_new_path(filename, O_WRONLY | O_CREAT, 0660, errp);\n\n    if (!ioc) {\n\n        goto the_end;\n\n    }\n\n    qio_channel_set_name(QIO_CHANNEL(ioc), \"migration-xen-save-state\");\n\n    f = qemu_fopen_channel_output(QIO_CHANNEL(ioc));\n\n    ret = qemu_save_device_state(f);\n\n    qemu_fclose(f);\n\n    if (ret < 0) {\n\n        error_setg(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n the_end:\n\n    if (saved_vm_running) {\n\n        vm_start();\n\n    }\n\n}\n", "idx": 8213}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static USBDevice *usb_msd_init(USBBus *bus, const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(qemu_find_opts(\"drive\"), id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n            return NULL;\n\n        }\n\n        filename = p1;\n\n    }\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n        return NULL;\n\n    }\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, 0);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    /* create guest device */\n\n    dev = usb_create(bus, \"usb-storage\");\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n    if (qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo->bdrv) < 0) {\n\n        qdev_free(&dev->qdev);\n\n        return NULL;\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n\n\n    return dev;\n\n}\n", "idx": 5082}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_psr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return GET_PSR(env);\n\n}\n", "idx": 314}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "static int find_snapshot_by_id(BlockDriverState *bs, const char *id_str)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i;\n\n\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        if (!strcmp(s->snapshots[i].id_str, id_str))\n\n            return i;\n\n    }\n\n    return -1;\n\n}\n", "idx": 4515}
{"project": "qemu", "commit_id": "962b289ef35087fcd8764e4e29808d8ac90157f7", "target": 1, "func": "char *target_strerror(int err)\n\n{\n\n\n\n\n    return strerror(target_to_host_errno(err));\n", "idx": 9576}
{"project": "qemu", "commit_id": "78dbbbe4dff95369c63bf77ee0df23371e1d6602", "target": 1, "func": "static inline bool extended_addresses_enabled(CPUARMState *env)\n\n{\n\n    return arm_feature(env, ARM_FEATURE_LPAE)\n\n        && (env->cp15.c2_control & (1 << 31));\n\n}\n", "idx": 10601}
{"project": "qemu", "commit_id": "2a8e7499093cd33a607ebd7c1cd591169aa68a3e", "target": 1, "func": "static void error_mem_write(void *opaque, hwaddr addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    abort();\n\n}\n", "idx": 1540}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_broadcast(QemuCond *cond)\n\n{\n\n    BOOLEAN result;\n\n    /*\n\n     * As in pthread_cond_signal, access to cond->waiters and\n\n     * cond->target is locked via the external mutex.\n\n     */\n\n    if (cond->waiters == 0) {\n\n        return;\n\n    }\n\n\n\n    cond->target = 0;\n\n    result = ReleaseSemaphore(cond->sema, cond->waiters, NULL);\n\n    if (!result) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n\n\n    /*\n\n     * At this point all waiters continue. Each one takes its\n\n     * slice of the semaphore. Now it's our turn to wait: Since\n\n     * the external mutex is held, no thread can leave cond_wait,\n\n     * yet. For this reason, we can be sure that no thread gets\n\n     * a chance to eat *more* than one slice. OTOH, it means\n\n     * that the last waiter must send us a wake-up.\n\n     */\n\n    WaitForSingleObject(cond->continue_event, INFINITE);\n\n}\n", "idx": 7378}
{"project": "qemu", "commit_id": "11c89769dc3e638ef72915d97058411ddf79b64b", "target": 1, "func": "int qcow2_alloc_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int *num, uint64_t *host_offset, QCowL2Meta **m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, remaining;\n\n    uint64_t cluster_offset;\n\n    uint64_t cur_bytes;\n\n    int ret;\n\n\n\n    trace_qcow2_alloc_clusters_offset(qemu_coroutine_self(), offset, *num);\n\n\n\n    assert((offset & ~BDRV_SECTOR_MASK) == 0);\n\n\n\nagain:\n\n    start = offset;\n\n    remaining = *num << BDRV_SECTOR_BITS;\n\n    cluster_offset = 0;\n\n    *host_offset = 0;\n\n    cur_bytes = 0;\n\n    *m = NULL;\n\n\n\n    while (true) {\n\n\n\n        if (!*host_offset) {\n\n            *host_offset = start_of_cluster(s, cluster_offset);\n\n        }\n\n\n\n        assert(remaining >= cur_bytes);\n\n\n\n        start           += cur_bytes;\n\n        remaining       -= cur_bytes;\n\n        cluster_offset  += cur_bytes;\n\n\n\n        if (remaining == 0) {\n\n            break;\n\n        }\n\n\n\n        cur_bytes = remaining;\n\n\n\n        /*\n\n         * Now start gathering as many contiguous clusters as possible:\n\n         *\n\n         * 1. Check for overlaps with in-flight allocations\n\n         *\n\n         *      a) Overlap not in the first cluster -> shorten this request and\n\n         *         let the caller handle the rest in its next loop iteration.\n\n         *\n\n         *      b) Real overlaps of two requests. Yield and restart the search\n\n         *         for contiguous clusters (the situation could have changed\n\n         *         while we were sleeping)\n\n         *\n\n         *      c) TODO: Request starts in the same cluster as the in-flight\n\n         *         allocation ends. Shorten the COW of the in-fight allocation,\n\n         *         set cluster_offset to write to the same cluster and set up\n\n         *         the right synchronisation between the in-flight request and\n\n         *         the new one.\n\n         */\n\n        ret = handle_dependencies(bs, start, &cur_bytes, m);\n\n        if (ret == -EAGAIN) {\n\n            /* Currently handle_dependencies() doesn't yield if we already had\n\n             * an allocation. If it did, we would have to clean up the L2Meta\n\n             * structs before starting over. */\n\n            assert(*m == NULL);\n\n            goto again;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        } else if (cur_bytes == 0) {\n\n            break;\n\n        } else {\n\n            /* handle_dependencies() may have decreased cur_bytes (shortened\n\n             * the allocations below) so that the next dependency is processed\n\n             * correctly during the next loop iteration. */\n\n        }\n\n\n\n        /*\n\n         * 2. Count contiguous COPIED clusters.\n\n         */\n\n        ret = handle_copied(bs, start, &cluster_offset, &cur_bytes, m);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            continue;\n\n        } else if (cur_bytes == 0) {\n\n            break;\n\n        }\n\n\n\n        /*\n\n         * 3. If the request still hasn't completed, allocate new clusters,\n\n         *    considering any cluster_offset of steps 1c or 2.\n\n         */\n\n        ret = handle_alloc(bs, start, &cluster_offset, &cur_bytes, m);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            continue;\n\n        } else {\n\n            assert(cur_bytes == 0);\n\n            break;\n\n        }\n\n    }\n\n\n\n    *num -= remaining >> BDRV_SECTOR_BITS;\n\n    assert(*num > 0);\n\n    assert(*host_offset != 0);\n\n\n\n    return 0;\n\n}\n", "idx": 9525}
{"project": "qemu", "commit_id": "056f49ff2cf645dc484956b00b65a3aa18a1a9a3", "target": 1, "func": "void monitor_flush(Monitor *mon)\n\n{\n\n    int rc;\n\n    size_t len;\n\n    const char *buf;\n\n\n\n    if (mon->skip_flush) {\n\n        return;\n\n    }\n\n\n\n    buf = qstring_get_str(mon->outbuf);\n\n    len = qstring_get_length(mon->outbuf);\n\n\n\n    if (len && !mon->mux_out) {\n\n        rc = qemu_chr_fe_write(mon->chr, (const uint8_t *) buf, len);\n\n        if (rc == len) {\n\n            /* all flushed */\n\n            QDECREF(mon->outbuf);\n\n            mon->outbuf = qstring_new();\n\n            return;\n\n        }\n\n        if (rc > 0) {\n\n            /* partinal write */\n\n            QString *tmp = qstring_from_str(buf + rc);\n\n            QDECREF(mon->outbuf);\n\n            mon->outbuf = tmp;\n\n        }\n\n        if (mon->watch == 0) {\n\n            mon->watch = qemu_chr_fe_add_watch(mon->chr, G_IO_OUT,\n\n                                               monitor_unblocked, mon);\n\n        }\n\n    }\n\n}\n", "idx": 2377}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int oss_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n\n    struct oss_params req, obt;\n\n    int endianness;\n\n    int err;\n\n    int fd;\n\n    audfmt_e effective_fmt;\n\n    struct audsettings obt_as;\n\n\n\n    oss->fd = -1;\n\n\n\n    req.fmt = aud_to_ossfmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.fragsize = conf.fragsize;\n\n    req.nfrags = conf.nfrags;\n\n\n\n    if (oss_open (0, &req, &obt, &fd)) {\n\n        return -1;\n\n    }\n\n\n\n    err = oss_to_audfmt (obt.fmt, &effective_fmt, &endianness);\n\n    if (err) {\n\n        oss_anal_close (&fd);\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = effective_fmt;\n\n    obt_as.endianness = endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    oss->nfrags = obt.nfrags;\n\n    oss->fragsize = obt.fragsize;\n\n\n\n    if (obt.nfrags * obt.fragsize & hw->info.align) {\n\n        dolog (\"warning: Misaligned DAC buffer, size %d, alignment %d\\n\",\n\n               obt.nfrags * obt.fragsize, hw->info.align + 1);\n\n    }\n\n\n\n    hw->samples = (obt.nfrags * obt.fragsize) >> hw->info.shift;\n\n\n\n    oss->mmapped = 0;\n\n    if (conf.try_mmap) {\n\n        oss->pcm_buf = mmap (\n\n            NULL,\n\n            hw->samples << hw->info.shift,\n\n            PROT_READ | PROT_WRITE,\n\n            MAP_SHARED,\n\n            fd,\n\n            0\n\n            );\n\n        if (oss->pcm_buf == MAP_FAILED) {\n\n            oss_logerr (errno, \"Failed to map %d bytes of DAC\\n\",\n\n                        hw->samples << hw->info.shift);\n\n        }\n\n        else {\n\n            int err;\n\n            int trig = 0;\n\n            if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                oss_logerr (errno, \"SNDCTL_DSP_SETTRIGGER 0 failed\\n\");\n\n            }\n\n            else {\n\n                trig = PCM_ENABLE_OUTPUT;\n\n                if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                    oss_logerr (\n\n                        errno,\n\n                        \"SNDCTL_DSP_SETTRIGGER PCM_ENABLE_OUTPUT failed\\n\"\n\n                        );\n\n                }\n\n                else {\n\n                    oss->mmapped = 1;\n\n                }\n\n            }\n\n\n\n            if (!oss->mmapped) {\n\n                err = munmap (oss->pcm_buf, hw->samples << hw->info.shift);\n\n                if (err) {\n\n                    oss_logerr (errno, \"Failed to unmap buffer %p size %d\\n\",\n\n                                oss->pcm_buf, hw->samples << hw->info.shift);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!oss->mmapped) {\n\n        oss->pcm_buf = audio_calloc (\n\n            AUDIO_FUNC,\n\n            hw->samples,\n\n            1 << hw->info.shift\n\n            );\n\n        if (!oss->pcm_buf) {\n\n            dolog (\n\n                \"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n                hw->samples,\n\n                1 << hw->info.shift\n\n                );\n\n            oss_anal_close (&fd);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    oss->fd = fd;\n\n    return 0;\n\n}\n", "idx": 2180}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "int bdrv_create(BlockDriver *drv, const char* filename,\n\n                QemuOpts *opts, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    Coroutine *co;\n\n    CreateCo cco = {\n\n        .drv = drv,\n\n        .filename = g_strdup(filename),\n\n        .opts = opts,\n\n        .ret = NOT_DONE,\n\n        .err = NULL,\n\n    };\n\n\n\n    if (!drv->bdrv_create) {\n\n        error_setg(errp, \"Driver '%s' does not support image creation\", drv->format_name);\n\n        ret = -ENOTSUP;\n\n        goto out;\n\n    }\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_create_co_entry(&cco);\n\n    } else {\n\n        co = qemu_coroutine_create(bdrv_create_co_entry);\n\n        qemu_coroutine_enter(co, &cco);\n\n        while (cco.ret == NOT_DONE) {\n\n            aio_poll(qemu_get_aio_context(), true);\n\n        }\n\n    }\n\n\n\n    ret = cco.ret;\n\n    if (ret < 0) {\n\n        if (cco.err) {\n\n            error_propagate(errp, cco.err);\n\n        } else {\n\n            error_setg_errno(errp, -ret, \"Could not create image\");\n\n        }\n\n    }\n\n\n\nout:\n\n    g_free(cco.filename);\n\n    return ret;\n\n}\n", "idx": 438}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void gicv3_cpuif_update(GICv3CPUState *cs)\n{\n    /* Tell the CPU about its highest priority pending interrupt */\n    int irqlevel = 0;\n    int fiqlevel = 0;\n    ARMCPU *cpu = ARM_CPU(cs->cpu);\n    CPUARMState *env = &cpu->env;\n    trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq,\n                             cs->hppi.grp, cs->hppi.prio);\n    if (cs->hppi.grp == GICV3_G1 && !arm_feature(env, ARM_FEATURE_EL3)) {\n        /* If a Security-enabled GIC sends a G1S interrupt to a\n         * Security-disabled CPU, we must treat it as if it were G0.\n         */\n        cs->hppi.grp = GICV3_G0;\n    }\n    if (icc_hppi_can_preempt(cs)) {\n        /* We have an interrupt: should we signal it as IRQ or FIQ?\n         * This is described in the GICv3 spec section 4.6.2.\n         */\n        bool isfiq;\n        switch (cs->hppi.grp) {\n        case GICV3_G0:\n            isfiq = true;\n            break;\n        case GICV3_G1:\n            isfiq = (!arm_is_secure(env) ||\n                     (arm_current_el(env) == 3 && arm_el_is_aa64(env, 3)));\n            break;\n        case GICV3_G1NS:\n            isfiq = arm_is_secure(env);\n            break;\n        default:\n            g_assert_not_reached();\n        }\n        if (isfiq) {\n            fiqlevel = 1;\n        } else {\n            irqlevel = 1;\n        }\n    }\n    trace_gicv3_cpuif_set_irqs(gicv3_redist_affid(cs), fiqlevel, irqlevel);\n    qemu_set_irq(cs->parent_fiq, fiqlevel);\n    qemu_set_irq(cs->parent_irq, irqlevel);\n}", "idx": 7460}
{"project": "qemu", "commit_id": "dd63169766abd2b8dc33f4451dac5e778458a47c", "target": 1, "func": "static ram_addr_t ram_block_add(RAMBlock *new_block, Error **errp)\n\n{\n\n    RAMBlock *block;\n\n    RAMBlock *last_block = NULL;\n\n    ram_addr_t old_ram_size, new_ram_size;\n\n\n\n    old_ram_size = last_ram_offset() >> TARGET_PAGE_BITS;\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    new_block->offset = find_ram_offset(new_block->max_length);\n\n\n\n    if (!new_block->host) {\n\n        if (xen_enabled()) {\n\n            xen_ram_alloc(new_block->offset, new_block->max_length,\n\n                          new_block->mr);\n\n        } else {\n\n            new_block->host = phys_mem_alloc(new_block->max_length,\n\n                                             &new_block->mr->align);\n\n            if (!new_block->host) {\n\n                error_setg_errno(errp, errno,\n\n                                 \"cannot set up guest memory '%s'\",\n\n                                 memory_region_name(new_block->mr));\n\n                qemu_mutex_unlock_ramlist();\n\n                return -1;\n\n\n            memory_try_enable_merging(new_block->host, new_block->max_length);\n\n\n\n\n\n\n\n\n\n\n    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,\n\n     * QLIST (which has an RCU-friendly variant) does not have insertion at\n\n     * tail, so save the last element in last_block.\n\n     */\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n        last_block = block;\n\n        if (block->max_length < new_block->max_length) {\n\n            break;\n\n\n\n    if (block) {\n\n        QLIST_INSERT_BEFORE_RCU(block, new_block, next);\n\n    } else if (last_block) {\n\n        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);\n\n    } else { /* list is empty */\n\n        QLIST_INSERT_HEAD_RCU(&ram_list.blocks, new_block, next);\n\n\n    ram_list.mru_block = NULL;\n\n\n\n    /* Write list before version */\n\n    smp_wmb();\n\n    ram_list.version++;\n\n    qemu_mutex_unlock_ramlist();\n\n\n\n    new_ram_size = last_ram_offset() >> TARGET_PAGE_BITS;\n\n\n\n\n        int i;\n\n\n\n        /* ram_list.dirty_memory[] is protected by the iothread lock.  */\n\n        for (i = 0; i < DIRTY_MEMORY_NUM; i++) {\n\n            ram_list.dirty_memory[i] =\n\n                bitmap_zero_extend(ram_list.dirty_memory[i],\n\n                                   old_ram_size, new_ram_size);\n\n\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n\n                                        new_block->used_length,\n\n                                        DIRTY_CLIENTS_ALL);\n\n\n\n    if (new_block->host) {\n\n        qemu_ram_setup_dump(new_block->host, new_block->max_length);\n\n        qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_HUGEPAGE);\n\n        qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_DONTFORK);\n\n        if (kvm_enabled()) {\n\n            kvm_setup_guest_memory(new_block->host, new_block->max_length);\n\n\n\n\n\n    return new_block->offset;\n", "idx": 1680}
{"project": "qemu", "commit_id": "aab99135b63522267c6fdae04712cb2f02c8c7de", "target": 1, "func": "static uint32_t set_allocation_state(sPAPRDRConnector *drc,\n\n                                     sPAPRDRAllocationState state)\n\n{\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    DPRINTFN(\"drc: %x, set_allocation_state: %x\", get_index(drc), state);\n\n\n\n    if (state == SPAPR_DR_ALLOCATION_STATE_USABLE) {\n\n        /* if there's no resource/device associated with the DRC, there's\n\n         * no way for us to put it in an allocation state consistent with\n\n         * being 'USABLE'. PAPR 2.7, 13.5.3.4 documents that this should\n\n         * result in an RTAS return code of -3 / \"no such indicator\"\n\n         */\n\n        if (!drc->dev) {\n\n            return RTAS_OUT_NO_SUCH_INDICATOR;\n\n        }\n\n    }\n\n\n\n    if (drc->type != SPAPR_DR_CONNECTOR_TYPE_PCI) {\n\n        drc->allocation_state = state;\n\n        if (drc->awaiting_release &&\n\n            drc->allocation_state == SPAPR_DR_ALLOCATION_STATE_UNUSABLE) {\n\n            DPRINTFN(\"finalizing device removal\");\n\n            drck->detach(drc, DEVICE(drc->dev), drc->detach_cb,\n\n                         drc->detach_cb_opaque, NULL);\n\n\n\n        }\n\n    }\n\n    return RTAS_OUT_SUCCESS;\n\n}", "idx": 10640}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n\n                               Error **errp)\n\n{\n\n    int size;\n\n    char *path;\n\n    void *ptr;\n\n    char name[32];\n\n    const VMStateDescription *vmsd;\n\n\n\n    if (!pdev->romfile)\n\n        return;\n\n    if (strlen(pdev->romfile) == 0)\n\n        return;\n\n\n\n    if (!pdev->rom_bar) {\n\n        /*\n\n         * Load rom via fw_cfg instead of creating a rom bar,\n\n         * for 0.11 compatibility.\n\n         */\n\n        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);\n\n\n\n        /*\n\n         * Hot-plugged devices can't use the option ROM\n\n         * if the rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n", "idx": 5264}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "static void monitor_qmp_event(void *opaque, int event)\n\n{\n\n    QObject *data;\n\n    Monitor *mon = opaque;\n\n\n\n    switch (event) {\n\n    case CHR_EVENT_OPENED:\n\n        mon->qmp.in_command_mode = false;\n\n        data = get_qmp_greeting();\n\n        monitor_json_emitter(mon, data);\n\n        qobject_decref(data);\n\n        mon_refcount++;\n\n        break;\n\n    case CHR_EVENT_CLOSED:\n\n        json_message_parser_destroy(&mon->qmp.parser);\n\n        json_message_parser_init(&mon->qmp.parser, handle_qmp_command);\n\n        mon_refcount--;\n\n        monitor_fdsets_cleanup();\n\n        break;\n\n    }\n\n}\n", "idx": 755}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_remove_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n    uint8_t t[sizeof(diag_501)];\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, t, sizeof(diag_501), 0)) {\n\n        return -EINVAL;\n\n    } else if (memcmp(t, diag_501, sizeof(diag_501))) {\n\n        return -EINVAL;\n\n    } else if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                                   sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10020}
{"project": "qemu", "commit_id": "4d1628e832dfc6ec02b0d196f6cc250aaa7bf3b3", "target": 1, "func": "uint64_t helper_mullv(CPUAlphaState *env, uint64_t op1, uint64_t op2)\n\n{\n\n    int64_t res = (int64_t)op1 * (int64_t)op2;\n\n\n\n    if (unlikely((int32_t)res != res)) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return (int64_t)((int32_t)res);\n\n}\n", "idx": 1076}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_exception(int excp)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_movi_i32(tmp, excp);\n\n    gen_helper_exception(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 6941}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(test_ctr_false)\n\n{\n\n    T0 = (regs->ctr != 0 && (T0 & PARAM(1)) == 0);\n\n    RETURN();\n\n}\n", "idx": 3522}
{"project": "qemu", "commit_id": "e98ccb3fbba94d0b2165caabf7aeee370d4ce900", "target": 1, "func": "static void taihu_405ep_init(ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    char *filename;\n\n    qemu_irq *pic;\n\n    ram_addr_t bios_offset;\n\n    target_phys_addr_t ram_bases[2], ram_sizes[2];\n\n    long bios_size;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors;\n\n    DriveInfo *dinfo;\n\n\n\n    /* RAM is soldered to the board so the size cannot be changed */\n\n    ram_bases[0] = qemu_ram_alloc(NULL, \"taihu_405ep.ram-0\", 0x04000000);\n\n    ram_sizes[0] = 0x04000000;\n\n    ram_bases[1] = qemu_ram_alloc(NULL, \"taihu_405ep.ram-1\", 0x04000000);\n\n    ram_sizes[1] = 0x04000000;\n\n    ram_size = 0x08000000;\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    ppc405ep_init(ram_bases, ram_sizes, 33333333, &pic,\n\n                  kernel_filename == NULL ? 0 : 1);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#if defined(USE_FLASH_BIOS)\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        bios_size = bdrv_getlength(dinfo->bdrv);\n\n        /* XXX: should check that size is 2MB */\n\n        //        bios_size = 2 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n        bios_offset = qemu_ram_alloc(NULL, \"taihu_405ep.bios\", bios_size);\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at offset %08lx addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, bios_offset, -bios_size,\n\n               bdrv_get_device_name(dinfo->bdrv), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size), bios_offset,\n\n                              dinfo->bdrv, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        bios_offset = qemu_ram_alloc(NULL, \"taihu_405ep.bios\", BIOS_SIZE);\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, qemu_get_ram_ptr(bios_offset));\n\n\n        } else {\n\n            bios_size = -1;\n\n        }\n\n        if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n            fprintf(stderr, \"qemu: could not load PowerPC bios '%s'\\n\",\n\n                    bios_name);\n\n            exit(1);\n\n        }\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                     bios_size, bios_offset | IO_MEM_ROM);\n\n    }\n\n    /* Register Linux flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        bios_size = bdrv_getlength(dinfo->bdrv);\n\n        /* XXX: should check that size is 32MB */\n\n        bios_size = 32 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at offset %08lx  addr \" TARGET_FMT_lx \" '%s'\\n\",\n\n               fl_idx, bios_size, bios_offset, (target_ulong)0xfc000000,\n\n               bdrv_get_device_name(dinfo->bdrv));\n\n#endif\n\n        bios_offset = qemu_ram_alloc(NULL, \"taihu_405ep.flash\", bios_size);\n\n        pflash_cfi02_register(0xfc000000, bios_offset,\n\n                              dinfo->bdrv, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    }\n\n    /* Register CLPD & LCD display */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register CPLD\\n\", __func__);\n\n#endif\n\n    taihu_cpld_init(0x50100000);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr,\n\n                        \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}", "idx": 2943}
{"project": "qemu", "commit_id": "bfe8043e9214d2fc6572cc72b5f2218308747acd", "target": 1, "func": "static coroutine_fn int qcow2_co_flush_to_os(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        return ret;\n\n    }\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return 0;\n\n}\n", "idx": 9495}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 1857}
{"project": "qemu", "commit_id": "832390a5ed11e6c516db0986bf302d098e3ae36c", "target": 1, "func": "static int img_check(int argc, char **argv)\n\n{\n\n    int c, ret;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output, *cache;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n    int fix = 0;\n\n    int flags = BDRV_O_FLAGS | BDRV_O_CHECK;\n\n    ImageCheck *check;\n\n    bool quiet = false;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"repair\", required_argument, 0, 'r'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"hf:r:T:q\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 'r':\n\n            flags |= BDRV_O_RDWR;\n\n\n\n            if (!strcmp(optarg, \"leaks\")) {\n\n                fix = BDRV_FIX_LEAKS;\n\n            } else if (!strcmp(optarg, \"all\")) {\n\n                fix = BDRV_FIX_LEAKS | BDRV_FIX_ERRORS;\n\n            } else {\n\n                error_exit(\"Unknown option value for -r \"\n\n                           \"(expecting 'leaks' or 'all'): %s\", optarg);\n\n            }\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        case 'T':\n\n            cache = optarg;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        }\n\n    }\n\n    if (optind != argc - 1) {\n\n        error_exit(\"Expecting one image file name\");\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    ret = bdrv_parse_cache_flags(cache, &flags);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid source cache option: %s\", cache);\n\n        return 1;\n\n    }\n\n\n\n    blk = img_open(\"image\", filename, fmt, flags, true, quiet);\n\n    if (!blk) {\n\n        return 1;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    check = g_new0(ImageCheck, 1);\n\n    ret = collect_image_check(bs, check, filename, fmt, fix);\n\n\n\n    if (ret == -ENOTSUP) {\n\n        error_report(\"This image format does not support checks\");\n\n        ret = 63;\n\n        goto fail;\n\n    }\n\n\n\n    if (check->corruptions_fixed || check->leaks_fixed) {\n\n        int corruptions_fixed, leaks_fixed;\n\n\n\n        leaks_fixed         = check->leaks_fixed;\n\n        corruptions_fixed   = check->corruptions_fixed;\n\n\n\n        if (output_format == OFORMAT_HUMAN) {\n\n            qprintf(quiet,\n\n                    \"The following inconsistencies were found and repaired:\\n\\n\"\n\n                    \"    %\" PRId64 \" leaked clusters\\n\"\n\n                    \"    %\" PRId64 \" corruptions\\n\\n\"\n\n                    \"Double checking the fixed image now...\\n\",\n\n                    check->leaks_fixed,\n\n                    check->corruptions_fixed);\n\n        }\n\n\n\n        ret = collect_image_check(bs, check, filename, fmt, 0);\n\n\n\n        check->leaks_fixed          = leaks_fixed;\n\n        check->corruptions_fixed    = corruptions_fixed;\n\n    }\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_check(check, quiet);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        dump_json_image_check(check, quiet);\n\n        break;\n\n    }\n\n\n\n    if (ret || check->check_errors) {\n\n        ret = 1;\n\n        goto fail;\n\n    }\n\n\n\n    if (check->corruptions) {\n\n        ret = 2;\n\n    } else if (check->leaks) {\n\n        ret = 3;\n\n    } else {\n\n        ret = 0;\n\n    }\n\n\n\nfail:\n\n    qapi_free_ImageCheck(check);\n\n    blk_unref(blk);\n\n    return ret;\n\n}\n", "idx": 9653}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 4735}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static int qpa_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    static pa_buffer_attr ba;\n\n    struct audsettings obt_as = *as;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    /*\n\n     * qemu audio tick runs at 250 Hz (by default), so processing\n\n     * data chunks worth 4 ms of sound should be a good fit.\n\n     */\n\n    ba.tlength = pa_usec_to_bytes (4 * 1000, &ss);\n\n    ba.minreq = pa_usec_to_bytes (2 * 1000, &ss);\n\n    ba.maxlength = -1;\n\n    ba.prebuf = -1;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_PLAYBACK,\n\n        conf.sink,\n\n        \"pcm.playback\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        &ba,                    /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for playback failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    pa->rpos = hw->rpos;\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_out, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 5091}
{"project": "qemu", "commit_id": "66dc50f7057b9a0191f54e55764412202306858d", "target": 1, "func": "int s390_ccw_cmd_request(ORB *orb, SCSW *scsw, void *data)\n\n{\n\n    S390CCWDeviceClass *cdc = S390_CCW_DEVICE_GET_CLASS(data);\n\n\n\n    if (cdc->handle_request) {\n\n        return cdc->handle_request(orb, scsw, data);\n\n    } else {\n\n        return -ENOSYS;\n\n    }\n\n}\n", "idx": 705}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t **refcount_table,\n\n                              int64_t *refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                        l1_table_offset, l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 1832}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int get_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[10];\n\n    uint8_t buf[8];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = READ_CAPACITY;\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0)\n\n        return -1;\n\n\n\n    return (buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7];\n\n}\n", "idx": 224}
{"project": "qemu", "commit_id": "bf25983345ca44aec3dd92c57142be45452bd38a", "target": 1, "func": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    /* should be the case, see cirrus_bitblt_start */\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n    return false;", "idx": 7290}
{"project": "qemu", "commit_id": "e8ce12d9eaeedeb7f8d9debcd4c9b993903f1abb", "target": 1, "func": "static void usbredir_buffered_bulk_packet(void *priv, uint64_t id,\n\n    struct usb_redir_buffered_bulk_packet_header *buffered_bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t status, ep = buffered_bulk_packet->endpoint;\n\n    void *free_on_destroy;\n\n    int i, len;\n\n\n\n    DPRINTF(\"buffered-bulk-in status %d ep %02X len %d id %\"PRIu64\"\\n\",\n\n            buffered_bulk_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_BULK) {\n\n        ERROR(\"received buffered-bulk packet for non bulk ep %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (dev->endpoint[EP2I(ep)].bulk_receiving_started == 0) {\n\n        DPRINTF(\"received buffered-bulk packet on not started ep %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    /* Data must be in maxp chunks for buffered_bulk_add_*_data_to_packet */\n\n    len = dev->endpoint[EP2I(ep)].max_packet_size;\n\n    status = usb_redir_success;\n\n    free_on_destroy = NULL;\n\n    for (i = 0; i < data_len; i += len) {\n\n        if (len >= (data_len - i)) {\n\n            len = data_len - i;\n\n            status = buffered_bulk_packet->status;\n\n            free_on_destroy = data;\n\n        }\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data + i, len, status, ep, free_on_destroy);\n\n    }\n\n\n\n    if (dev->endpoint[EP2I(ep)].pending_async_packet) {\n\n        USBPacket *p = dev->endpoint[EP2I(ep)].pending_async_packet;\n\n        dev->endpoint[EP2I(ep)].pending_async_packet = NULL;\n\n        usbredir_buffered_bulk_in_complete(dev, p, ep);\n\n        usb_packet_complete(&dev->dev, p);\n\n    }\n\n}\n", "idx": 4192}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_update(DisplayChangeListener *dcl,\n\n                      DisplayState *ds, int x, int y, int w, int h)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    int x1, x2, y1, y2;\n\n    int mx, my;\n\n    int fbw, fbh;\n\n    int ww, wh;\n\n\n\n    DPRINTF(\"update(x=%d, y=%d, w=%d, h=%d)\\n\", x, y, w, h);\n\n\n\n    x1 = floor(x * s->scale_x);\n\n    y1 = floor(y * s->scale_y);\n\n\n\n    x2 = ceil(x * s->scale_x + w * s->scale_x);\n\n    y2 = ceil(y * s->scale_y + h * s->scale_y);\n\n\n\n    fbw = ds_get_width(s->ds) * s->scale_x;\n\n    fbh = ds_get_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    gtk_widget_queue_draw_area(s->drawing_area, mx + x1, my + y1, (x2 - x1), (y2 - y1));\n\n}\n", "idx": 9013}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct NetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!net_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = net_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    net_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%zu < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  pkt_len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 529}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "static bool aio_dispatch(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool progress = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case qemu_aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    node = QLIST_FIRST(&ctx->aio_handlers);\n\n    while (node) {\n\n        AioHandler *tmp;\n\n        int revents;\n\n\n\n        ctx->walking_handlers++;\n\n\n\n        revents = node->pfd.revents & node->pfd.events;\n\n        node->pfd.revents = 0;\n\n\n\n        if (!node->deleted &&\n\n            (revents & (G_IO_IN | G_IO_HUP | G_IO_ERR)) &&\n\n            node->io_read) {\n\n            node->io_read(node->opaque);\n\n            progress = true;\n\n        }\n\n        if (!node->deleted &&\n\n            (revents & (G_IO_OUT | G_IO_ERR)) &&\n\n            node->io_write) {\n\n            node->io_write(node->opaque);\n\n            progress = true;\n\n        }\n\n\n\n        tmp = node;\n\n        node = QLIST_NEXT(node, node);\n\n\n\n        ctx->walking_handlers--;\n\n\n\n        if (!ctx->walking_handlers && tmp->deleted) {\n\n            QLIST_REMOVE(tmp, node);\n\n            g_free(tmp);\n\n        }\n\n    }\n\n    return progress;\n\n}\n", "idx": 9087}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_one_sector_short_prdt(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n\n\n    /* Read 2 sectors but only give 1 sector in PRDT */\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = 0,\n\n            .size = cpu_to_le32(0x200 | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    /* Normal request */\n\n    status = send_dma_request(CMD_READ_DMA, 0, 2,\n\n                              prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, 0);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Abort the request before it completes */\n\n    status = send_dma_request(CMD_READ_DMA | CMDF_ABORT, 0, 2,\n\n                              prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, 0);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n}\n", "idx": 10907}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static int net_socket_mcast_create(struct sockaddr_in *mcastaddr)\n\n{\n\n    struct ip_mreq imr;\n\n    int fd;\n\n    int val, ret;\n\n    if (!IN_MULTICAST(ntohl(mcastaddr->sin_addr.s_addr))) {\n\n\tfprintf(stderr, \"qemu: error: specified mcastaddr \\\"%s\\\" (0x%08x) does not contain a multicast address\\n\",\n\n\t\tinet_ntoa(mcastaddr->sin_addr),\n\n                (int)ntohl(mcastaddr->sin_addr.s_addr));\n\n\treturn -1;\n\n\n\n    }\n\n    fd = socket(PF_INET, SOCK_DGRAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket(PF_INET, SOCK_DGRAM)\");\n\n        return -1;\n\n    }\n\n\n\n    val = 1;\n\n    ret=setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,\n\n                   (const char *)&val, sizeof(val));\n\n    if (ret < 0) {\n\n\tperror(\"setsockopt(SOL_SOCKET, SO_REUSEADDR)\");\n\n\tgoto fail;\n\n    }\n\n\n\n    ret = bind(fd, (struct sockaddr *)mcastaddr, sizeof(*mcastaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n        goto fail;\n\n    }\n\n\n\n    /* Add host to multicast group */\n\n    imr.imr_multiaddr = mcastaddr->sin_addr;\n\n    imr.imr_interface.s_addr = htonl(INADDR_ANY);\n\n\n\n    ret = setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\n                     (const char *)&imr, sizeof(struct ip_mreq));\n\n    if (ret < 0) {\n\n\tperror(\"setsockopt(IP_ADD_MEMBERSHIP)\");\n\n\tgoto fail;\n\n    }\n\n\n\n    /* Force mcast msgs to loopback (eg. several QEMUs in same host */\n\n    val = 1;\n\n    ret=setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,\n\n                   (const char *)&val, sizeof(val));\n\n    if (ret < 0) {\n\n\tperror(\"setsockopt(SOL_IP, IP_MULTICAST_LOOP)\");\n\n\tgoto fail;\n\n    }\n\n\n\n    socket_set_nonblock(fd);\n\n    return fd;\n\nfail:\n\n    if (fd >= 0)\n\n        closesocket(fd);\n\n    return -1;\n\n}\n", "idx": 8073}
{"project": "qemu", "commit_id": "87c258cd1e1c10faaeee8016ab6c67de97d6b996", "target": 1, "func": "static void do_test_equality(bool expected, int _, ...)\n{\n    va_list ap_count, ap_extract;\n    QObject **args;\n    int arg_count = 0;\n    int i, j;\n    va_start(ap_count, _);\n    va_copy(ap_extract, ap_count);\n    while (va_arg(ap_count, QObject *) != &test_equality_end_of_arguments) {\n        arg_count++;\n    }\n    va_end(ap_count);\n    args = g_new(QObject *, arg_count);\n    for (i = 0; i < arg_count; i++) {\n        args[i] = va_arg(ap_extract, QObject *);\n    }\n    va_end(ap_extract);\n    for (i = 0; i < arg_count; i++) {\n        g_assert(qobject_is_equal(args[i], args[i]) == true);\n        for (j = i + 1; j < arg_count; j++) {\n            g_assert(qobject_is_equal(args[i], args[j]) == expected);\n        }\n    }\n}", "idx": 384}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "void translator_loop(const TranslatorOps *ops, DisasContextBase *db,\n\n                     CPUState *cpu, TranslationBlock *tb)\n\n{\n\n    int max_insns;\n\n\n\n    /* Initialize DisasContext */\n\n    db->tb = tb;\n\n    db->pc_first = tb->pc;\n\n    db->pc_next = db->pc_first;\n\n    db->is_jmp = DISAS_NEXT;\n\n    db->num_insns = 0;\n\n    db->singlestep_enabled = cpu->singlestep_enabled;\n\n\n\n    /* Instruction counting */\n\n    max_insns = db->tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n    if (db->singlestep_enabled || singlestep) {\n\n        max_insns = 1;\n\n    }\n\n\n\n    max_insns = ops->init_disas_context(db, cpu, max_insns);\n\n    tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */\n\n\n\n    /* Reset the temp count so that we can identify leaks */\n\n    tcg_clear_temp_count();\n\n\n\n    /* Start translating.  */\n\n    gen_tb_start(db->tb);\n\n    ops->tb_start(db, cpu);\n\n    tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */\n\n\n\n    while (true) {\n\n        db->num_insns++;\n\n        ops->insn_start(db, cpu);\n\n        tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */\n\n\n\n        /* Pass breakpoint hits to target for further processing */\n\n        if (unlikely(!QTAILQ_EMPTY(&cpu->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n                if (bp->pc == db->pc_next) {\n\n                    if (ops->breakpoint_check(db, cpu, bp)) {\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            /* The breakpoint_check hook may use DISAS_TOO_MANY to indicate\n\n               that only one more instruction is to be executed.  Otherwise\n\n               it should use DISAS_NORETURN when generating an exception,\n\n               but may use a DISAS_TARGET_* value for Something Else.  */\n\n            if (db->is_jmp > DISAS_TOO_MANY) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* Disassemble one instruction.  The translate_insn hook should\n\n           update db->pc_next and db->is_jmp to indicate what should be\n\n           done next -- either exiting this loop or locate the start of\n\n           the next instruction.  */\n\n        if (db->num_insns == max_insns && (db->tb->cflags & CF_LAST_IO)) {\n\n            /* Accept I/O on the last instruction.  */\n\n            gen_io_start();\n\n            ops->translate_insn(db, cpu);\n\n            gen_io_end();\n\n        } else {\n\n            ops->translate_insn(db, cpu);\n\n        }\n\n\n\n        /* Stop translation if translate_insn so indicated.  */\n\n        if (db->is_jmp != DISAS_NEXT) {\n\n            break;\n\n        }\n\n\n\n        /* Stop translation if the output buffer is full,\n\n           or we have executed all of the allowed instructions.  */\n\n        if (tcg_op_buf_full() || db->num_insns >= max_insns) {\n\n            db->is_jmp = DISAS_TOO_MANY;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Emit code to exit the TB, as indicated by db->is_jmp.  */\n\n    ops->tb_stop(db, cpu);\n\n    gen_tb_end(db->tb, db->num_insns);\n\n\n\n    /* The disas_log hook may use these values rather than recompute.  */\n\n    db->tb->size = db->pc_next - db->pc_first;\n\n    db->tb->icount = db->num_insns;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)\n\n        && qemu_log_in_addr_range(db->pc_first)) {\n\n        qemu_log_lock();\n\n        qemu_log(\"----------------\\n\");\n\n        ops->disas_log(db, cpu);\n\n        qemu_log(\"\\n\");\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n}\n", "idx": 1985}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_add_logical_lan_buffer(CPUPPCState *env,\n\n                                             sPAPREnvironment *spapr,\n\n                                             target_ulong opcode,\n\n                                             target_ulong *args)\n\n{\n\n    target_ulong reg = args[0];\n\n    target_ulong buf = args[1];\n\n    VIOsPAPRDevice *sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n\n    VIOsPAPRVLANDevice *dev = (VIOsPAPRVLANDevice *)sdev;\n\n    vlan_bd_t bd;\n\n\n\n    dprintf(\"H_ADD_LOGICAL_LAN_BUFFER(0x\" TARGET_FMT_lx\n\n            \", 0x\" TARGET_FMT_lx \")\\n\", reg, buf);\n\n\n\n    if (!sdev) {\n\n        hcall_dprintf(\"Bad device\\n\");\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if ((check_bd(dev, buf, 4) < 0)\n\n        || (VLAN_BD_LEN(buf) < 16)) {\n\n        hcall_dprintf(\"Bad buffer enqueued\\n\");\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if (!dev->isopen || dev->rx_bufs >= VLAN_MAX_BUFS) {\n\n        return H_RESOURCE;\n\n    }\n\n\n\n    do {\n\n        dev->add_buf_ptr += 8;\n\n        if (dev->add_buf_ptr >= SPAPR_VIO_TCE_PAGE_SIZE) {\n\n            dev->add_buf_ptr = VLAN_RX_BDS_OFF;\n\n        }\n\n\n\n        bd = ldq_tce(sdev, dev->buf_list + dev->add_buf_ptr);\n\n    } while (bd & VLAN_BD_VALID);\n\n\n\n    stq_tce(sdev, dev->buf_list + dev->add_buf_ptr, buf);\n\n\n\n    dev->rx_bufs++;\n\n\n\n    dprintf(\"h_add_logical_lan_buffer():  Added buf  ptr=%d  rx_bufs=%d\"\n\n            \" bd=0x%016llx\\n\", dev->add_buf_ptr, dev->rx_bufs,\n\n            (unsigned long long)buf);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 1355}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "static void xlnx_dp_set_dpdma(Object *obj, const char *name, Object *val,\n\n                              Error **errp)\n\n{\n\n    XlnxDPState *s = XLNX_DP(obj);\n\n    if (s->console) {\n\n        DisplaySurface *surface = qemu_console_surface(s->console);\n\n        XlnxDPDMAState *dma = XLNX_DPDMA(val);\n\n        xlnx_dpdma_set_host_data_location(dma, DP_GRAPHIC_DMA_CHANNEL,\n\n                                          surface_data(surface));\n\n    }\n\n}\n", "idx": 9861}
{"project": "qemu", "commit_id": "731d5856cbb9c160fe02b90cd3cf354ea4f52f34", "target": 1, "func": "static ssize_t dump_receive(VLANClientState *vc, const uint8_t *buf, size_t size)\n\n{\n\n    DumpState *s = vc->opaque;\n\n    struct pcap_sf_pkthdr hdr;\n\n    int64_t ts;\n\n    int caplen;\n\n\n\n    /* Early return in case of previous error. */\n\n    if (s->fd < 0) {\n\n        return size;\n\n    }\n\n\n\n    ts = muldiv64(qemu_get_clock(vm_clock), 1000000, get_ticks_per_sec());\n\n    caplen = size > s->pcap_caplen ? s->pcap_caplen : size;\n\n\n\n    hdr.ts.tv_sec = ts / 1000000;\n\n    hdr.ts.tv_usec = ts % 1000000;\n\n    hdr.caplen = caplen;\n\n    hdr.len = size;\n\n    if (write(s->fd, &hdr, sizeof(hdr)) != sizeof(hdr) ||\n\n        write(s->fd, buf, caplen) != caplen) {\n\n        qemu_log(\"-net dump write error - stop dump\\n\");\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n\n\n    return size;\n\n}\n", "idx": 2341}
{"project": "qemu", "commit_id": "244381ec19ce1412b474f41b5f30fe1da846451b", "target": 1, "func": "static ssize_t gem_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    CadenceGEMState *s;\n\n    unsigned   rxbufsize, bytes_to_copy;\n\n    unsigned   rxbuf_offset;\n\n    uint8_t    rxbuf[2048];\n\n    uint8_t   *rxbuf_ptr;\n\n    bool first_desc = true;\n\n    int maf;\n\n\n\n    s = qemu_get_nic_opaque(nc);\n\n\n\n    /* Is this destination MAC address \"for us\" ? */\n\n    maf = gem_mac_address_filter(s, buf);\n\n    if (maf == GEM_RX_REJECT) {\n\n        return -1;\n\n\n\n\n    /* Discard packets with receive length error enabled ? */\n\n    if (s->regs[GEM_NWCFG] & GEM_NWCFG_LERR_DISC) {\n\n        unsigned type_len;\n\n\n\n        /* Fish the ethertype / length field out of the RX packet */\n\n        type_len = buf[12] << 8 | buf[13];\n\n        /* It is a length field, not an ethertype */\n\n        if (type_len < 0x600) {\n\n            if (size < type_len) {\n\n                /* discard */\n\n                return -1;\n\n\n\n\n\n\n    /*\n\n     * Determine configured receive buffer offset (probably 0)\n\n     */\n\n    rxbuf_offset = (s->regs[GEM_NWCFG] & GEM_NWCFG_BUFF_OFST_M) >>\n\n                   GEM_NWCFG_BUFF_OFST_S;\n\n\n\n    /* The configure size of each receive buffer.  Determines how many\n\n     * buffers needed to hold this packet.\n\n     */\n\n    rxbufsize = ((s->regs[GEM_DMACFG] & GEM_DMACFG_RBUFSZ_M) >>\n\n                 GEM_DMACFG_RBUFSZ_S) * GEM_DMACFG_RBUFSZ_MUL;\n\n\n\n\n    /* Pad to minimum length. Assume FCS field is stripped, logic\n\n     * below will increment it to the real minimum of 64 when\n\n     * not FCS stripping\n\n     */\n\n    if (size < 60) {\n\n        size = 60;\n\n\n\n\n    /* Strip of FCS field ? (usually yes) */\n\n    if (s->regs[GEM_NWCFG] & GEM_NWCFG_STRIP_FCS) {\n\n        rxbuf_ptr = (void *)buf;\n\n    } else {\n\n        unsigned crc_val;\n\n\n\n\n\n\n\n        /* The application wants the FCS field, which QEMU does not provide.\n\n         * We must try and calculate one.\n\n         */\n\n\n\n        memcpy(rxbuf, buf, size);\n\n        memset(rxbuf + size, 0, sizeof(rxbuf) - size);\n\n        rxbuf_ptr = rxbuf;\n\n        crc_val = cpu_to_le32(crc32(0, rxbuf, MAX(size, 60)));\n\n        memcpy(rxbuf + size, &crc_val, sizeof(crc_val));\n\n\n\n        bytes_to_copy += 4;\n\n        size += 4;\n\n\n\n\n    DB_PRINT(\"config bufsize: %d packet size: %ld\\n\", rxbufsize, size);\n\n\n\n    while (bytes_to_copy) {\n\n        /* Do nothing if receive is not enabled. */\n\n        if (!gem_can_receive(nc)) {\n\n            assert(!first_desc);\n\n            return -1;\n\n\n\n\n        DB_PRINT(\"copy %d bytes to 0x%x\\n\", MIN(bytes_to_copy, rxbufsize),\n\n                rx_desc_get_buffer(s->rx_desc));\n\n\n\n        /* Copy packet data to emulated DMA buffer */\n\n        cpu_physical_memory_write(rx_desc_get_buffer(s->rx_desc) + rxbuf_offset,\n\n                                  rxbuf_ptr, MIN(bytes_to_copy, rxbufsize));\n\n        rxbuf_ptr += MIN(bytes_to_copy, rxbufsize);\n\n        bytes_to_copy -= MIN(bytes_to_copy, rxbufsize);\n\n\n\n        /* Update the descriptor.  */\n\n        if (first_desc) {\n\n            rx_desc_set_sof(s->rx_desc);\n\n            first_desc = false;\n\n\n        if (bytes_to_copy == 0) {\n\n            rx_desc_set_eof(s->rx_desc);\n\n            rx_desc_set_length(s->rx_desc, size);\n\n\n        rx_desc_set_ownership(s->rx_desc);\n\n\n\n        switch (maf) {\n\n        case GEM_RX_PROMISCUOUS_ACCEPT:\n\n            break;\n\n        case GEM_RX_BROADCAST_ACCEPT:\n\n            rx_desc_set_broadcast(s->rx_desc);\n\n            break;\n\n        case GEM_RX_UNICAST_HASH_ACCEPT:\n\n            rx_desc_set_unicast_hash(s->rx_desc);\n\n            break;\n\n        case GEM_RX_MULTICAST_HASH_ACCEPT:\n\n            rx_desc_set_multicast_hash(s->rx_desc);\n\n            break;\n\n        case GEM_RX_REJECT:\n\n            abort();\n\n        default: /* SAR */\n\n            rx_desc_set_sar(s->rx_desc, maf);\n\n\n\n\n        /* Descriptor write-back.  */\n\n        cpu_physical_memory_write(s->rx_desc_addr,\n\n                                  (uint8_t *)s->rx_desc, sizeof(s->rx_desc));\n\n\n\n        /* Next descriptor */\n\n        if (rx_desc_get_wrap(s->rx_desc)) {\n\n            DB_PRINT(\"wrapping RX descriptor list\\n\");\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        } else {\n\n            DB_PRINT(\"incrementing RX descriptor list\\n\");\n\n            s->rx_desc_addr += 8;\n\n\n        gem_get_rx_desc(s);\n\n\n\n\n    /* Count it */\n\n    gem_receive_updatestats(s, buf, size);\n\n\n\n    s->regs[GEM_RXSTATUS] |= GEM_RXSTATUS_FRMRCVD;\n\n    s->regs[GEM_ISR] |= GEM_INT_RXCMPL & ~(s->regs[GEM_IMR]);\n\n\n\n    /* Handle interrupt consequences */\n\n    gem_update_int_status(s);\n\n\n\n    return size;\n", "idx": 3166}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static int console_init(SCLPEvent *event)\n\n{\n\n    static bool console_available;\n\n\n\n    SCLPConsole *scon = DO_UPCAST(SCLPConsole, event, event);\n\n\n\n    if (console_available) {\n\n        error_report(\"Multiple VT220 operator consoles are not supported\");\n\n        return -1;\n\n    }\n\n    console_available = true;\n\n    if (scon->chr) {\n\n        qemu_chr_add_handlers(scon->chr, chr_can_read,\n\n                              chr_read, NULL, scon);\n\n    }\n\n    scon->irq_read_vt220 = *qemu_allocate_irqs(trigger_ascii_console_data,\n\n                                               NULL, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 4162}
{"project": "qemu", "commit_id": "0cf33fb6b49a19de32859e2cdc6021334f448fb3", "target": 1, "func": "static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n\n    unsigned mhdr_cnt = 0;\n\n    size_t offset, i, guest_offset;\n\n\n\n    if (!virtio_net_can_receive(nc)) {\n\n        return -1;\n\n    }\n\n\n\n    /* hdr_len refers to the header we supply to the guest */\n\n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!receive_filter(n, buf, size))\n\n        return size;\n\n\n\n    offset = i = 0;\n\n\n\n    while (offset < size) {\n\n        VirtQueueElement elem;\n\n        int len, total;\n\n        const struct iovec *sg = elem.in_sg;\n\n\n\n        total = 0;\n\n\n\n        if (virtqueue_pop(q->rx_vq, &elem) == 0) {\n\n            if (i == 0)\n\n                return -1;\n\n            error_report(\"virtio-net unexpected empty queue: \"\n\n                         \"i %zd mergeable %d offset %zd, size %zd, \"\n\n                         \"guest hdr len %zd, host hdr len %zd \"\n\n                         \"guest features 0x%\" PRIx64,\n\n                         i, n->mergeable_rx_bufs, offset, size,\n\n                         n->guest_hdr_len, n->host_hdr_len,\n\n                         vdev->guest_features);\n\n            exit(1);\n\n        }\n\n\n\n        if (elem.in_num < 1) {\n\n            error_report(\"virtio-net receive queue contains no in buffers\");\n\n            exit(1);\n\n        }\n\n\n\n        if (i == 0) {\n\n            assert(offset == 0);\n\n            if (n->mergeable_rx_bufs) {\n\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n\n                                    sg, elem.in_num,\n\n                                    offsetof(typeof(mhdr), num_buffers),\n\n                                    sizeof(mhdr.num_buffers));\n\n            }\n\n\n\n            receive_header(n, sg, elem.in_num, buf, size);\n\n            offset = n->host_hdr_len;\n\n            total += n->guest_hdr_len;\n\n            guest_offset = n->guest_hdr_len;\n\n        } else {\n\n            guest_offset = 0;\n\n        }\n\n\n\n        /* copy in packet.  ugh */\n\n        len = iov_from_buf(sg, elem.in_num, guest_offset,\n\n                           buf + offset, size - offset);\n\n        total += len;\n\n        offset += len;\n\n        /* If buffers can't be merged, at this point we\n\n         * must have consumed the complete packet.\n\n         * Otherwise, drop it. */\n\n        if (!n->mergeable_rx_bufs && offset < size) {\n\n#if 0\n\n            error_report(\"virtio-net truncated non-mergeable packet: \"\n\n                         \"i %zd mergeable %d offset %zd, size %zd, \"\n\n                         \"guest hdr len %zd, host hdr len %zd\",\n\n                         i, n->mergeable_rx_bufs,\n\n                         offset, size, n->guest_hdr_len, n->host_hdr_len);\n\n#endif\n\n            return size;\n\n        }\n\n\n\n        /* signal other side */\n\n        virtqueue_fill(q->rx_vq, &elem, total, i++);\n\n    }\n\n\n\n    if (mhdr_cnt) {\n\n        virtio_stw_p(vdev, &mhdr.num_buffers, i);\n\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n\n                     0,\n\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n\n    }\n\n\n\n    virtqueue_flush(q->rx_vq, i);\n\n    virtio_notify(vdev, q->rx_vq);\n\n\n\n    return size;\n\n}\n", "idx": 1344}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check where the kernel has been linked */\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}", "idx": 5323}
{"project": "qemu", "commit_id": "ee640c625e190a0c0e6b8966adc0e4720fb75200", "target": 1, "func": "static void virtio_pci_device_plugged(DeviceState *d, Error **errp)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);\n\n    VirtioBusState *bus = &proxy->bus;\n\n    bool legacy = virtio_pci_legacy(proxy);\n\n    bool modern;\n\n    bool modern_pio = proxy->flags & VIRTIO_PCI_FLAG_MODERN_PIO_NOTIFY;\n\n    uint8_t *config;\n\n    uint32_t size;\n\n    VirtIODevice *vdev = virtio_bus_get_device(&proxy->bus);\n\n\n\n    /*\n\n     * Virtio capabilities present without\n\n     * VIRTIO_F_VERSION_1 confuses guests\n\n     */\n\n    if (!proxy->ignore_backend_features &&\n\n            !virtio_has_feature(vdev->host_features, VIRTIO_F_VERSION_1)) {\n\n        virtio_pci_disable_modern(proxy);\n\n\n\n        if (!legacy) {\n\n            error_setg(errp, \"Device doesn't support modern mode, and legacy\"\n\n                             \" mode is disabled\");\n\n            error_append_hint(errp, \"Set disable-legacy to off\\n\");\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    modern = virtio_pci_modern(proxy);\n\n\n\n    config = proxy->pci_dev.config;\n\n    if (proxy->class_code) {\n\n        pci_config_set_class(config, proxy->class_code);\n\n    }\n\n\n\n    if (legacy) {\n\n        if (virtio_host_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM)) {\n\n            error_setg(errp, \"VIRTIO_F_IOMMU_PLATFORM was supported by\"\n\n                       \"neither legacy nor transitional device.\");\n\n            return ;\n\n        }\n\n        /* legacy and transitional */\n\n        pci_set_word(config + PCI_SUBSYSTEM_VENDOR_ID,\n\n                     pci_get_word(config + PCI_VENDOR_ID));\n\n        pci_set_word(config + PCI_SUBSYSTEM_ID, virtio_bus_get_vdev_id(bus));\n\n    } else {\n\n        /* pure virtio-1.0 */\n\n        pci_set_word(config + PCI_VENDOR_ID,\n\n                     PCI_VENDOR_ID_REDHAT_QUMRANET);\n\n        pci_set_word(config + PCI_DEVICE_ID,\n\n                     0x1040 + virtio_bus_get_vdev_id(bus));\n\n        pci_config_set_revision(config, 1);\n\n    }\n\n    config[PCI_INTERRUPT_PIN] = 1;\n\n\n\n\n\n    if (modern) {\n\n        struct virtio_pci_cap cap = {\n\n            .cap_len = sizeof cap,\n\n        };\n\n        struct virtio_pci_notify_cap notify = {\n\n            .cap.cap_len = sizeof notify,\n\n            .notify_off_multiplier =\n\n                cpu_to_le32(virtio_pci_queue_mem_mult(proxy)),\n\n        };\n\n        struct virtio_pci_cfg_cap cfg = {\n\n            .cap.cap_len = sizeof cfg,\n\n            .cap.cfg_type = VIRTIO_PCI_CAP_PCI_CFG,\n\n        };\n\n        struct virtio_pci_notify_cap notify_pio = {\n\n            .cap.cap_len = sizeof notify,\n\n            .notify_off_multiplier = cpu_to_le32(0x0),\n\n        };\n\n\n\n        struct virtio_pci_cfg_cap *cfg_mask;\n\n\n\n        virtio_pci_modern_regions_init(proxy);\n\n\n\n        virtio_pci_modern_mem_region_map(proxy, &proxy->common, &cap);\n\n        virtio_pci_modern_mem_region_map(proxy, &proxy->isr, &cap);\n\n        virtio_pci_modern_mem_region_map(proxy, &proxy->device, &cap);\n\n        virtio_pci_modern_mem_region_map(proxy, &proxy->notify, &notify.cap);\n\n\n\n        if (modern_pio) {\n\n            memory_region_init(&proxy->io_bar, OBJECT(proxy),\n\n                               \"virtio-pci-io\", 0x4);\n\n\n\n            pci_register_bar(&proxy->pci_dev, proxy->modern_io_bar_idx,\n\n                             PCI_BASE_ADDRESS_SPACE_IO, &proxy->io_bar);\n\n\n\n            virtio_pci_modern_io_region_map(proxy, &proxy->notify_pio,\n\n                                            &notify_pio.cap);\n\n        }\n\n\n\n        pci_register_bar(&proxy->pci_dev, proxy->modern_mem_bar_idx,\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64,\n\n                         &proxy->modern_bar);\n\n\n\n        proxy->config_cap = virtio_pci_add_mem_cap(proxy, &cfg.cap);\n\n        cfg_mask = (void *)(proxy->pci_dev.wmask + proxy->config_cap);\n\n        pci_set_byte(&cfg_mask->cap.bar, ~0x0);\n\n        pci_set_long((uint8_t *)&cfg_mask->cap.offset, ~0x0);\n\n        pci_set_long((uint8_t *)&cfg_mask->cap.length, ~0x0);\n\n        pci_set_long(cfg_mask->pci_cfg_data, ~0x0);\n\n    }\n\n\n\n    if (proxy->nvectors) {\n\n        int err = msix_init_exclusive_bar(&proxy->pci_dev, proxy->nvectors,\n\n                                          proxy->msix_bar_idx);\n\n        if (err) {\n\n            /* Notice when a system that supports MSIx can't initialize it.  */\n\n            if (err != -ENOTSUP) {\n\n                error_report(\"unable to init msix vectors to %\" PRIu32,\n\n                             proxy->nvectors);\n\n            }\n\n            proxy->nvectors = 0;\n\n        }\n\n    }\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n    proxy->pci_dev.config_read = virtio_read_config;\n\n\n\n    if (legacy) {\n\n        size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev)\n\n            + virtio_bus_get_vdev_config_len(bus);\n\n        size = pow2ceil(size);\n\n\n\n        memory_region_init_io(&proxy->bar, OBJECT(proxy),\n\n                              &virtio_pci_config_ops,\n\n                              proxy, \"virtio-pci\", size);\n\n\n\n        pci_register_bar(&proxy->pci_dev, proxy->legacy_io_bar_idx,\n\n                         PCI_BASE_ADDRESS_SPACE_IO, &proxy->bar);\n\n    }\n\n}\n", "idx": 8860}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xfc;\n\n\n\n    switch (addr)\n\n    {\n\n        case RxMissed:\n\n            DPRINTF(\"RxMissed clearing on write\\n\");\n\n            s->RxMissed = 0;\n\n            break;\n\n\n\n        case TxConfig:\n\n            rtl8139_TxConfig_write(s, val);\n\n            break;\n\n\n\n        case RxConfig:\n\n            rtl8139_RxConfig_write(s, val);\n\n            break;\n\n\n\n        case TxStatus0 ... TxStatus0+4*4-1:\n\n            rtl8139_TxStatus_write(s, addr-TxStatus0, val);\n\n            break;\n\n\n\n        case TxAddr0 ... TxAddr0+4*4-1:\n\n            rtl8139_TxAddr_write(s, addr-TxAddr0, val);\n\n            break;\n\n\n\n        case RxBuf:\n\n            rtl8139_RxBuf_write(s, val);\n\n            break;\n\n\n\n        case RxRingAddrLO:\n\n            DPRINTF(\"C+ RxRing low bits write val=0x%08x\\n\", val);\n\n            s->RxRingAddrLO = val;\n\n            break;\n\n\n\n        case RxRingAddrHI:\n\n            DPRINTF(\"C+ RxRing high bits write val=0x%08x\\n\", val);\n\n            s->RxRingAddrHI = val;\n\n            break;\n\n\n\n        case Timer:\n\n            DPRINTF(\"TCTR Timer reset on write\\n\");\n\n            s->TCTR_base = qemu_get_clock_ns(vm_clock);\n\n            rtl8139_set_next_tctr_time(s, s->TCTR_base);\n\n            break;\n\n\n\n        case FlashReg:\n\n            DPRINTF(\"FlashReg TimerInt write val=0x%08x\\n\", val);\n\n            if (s->TimerInt != val) {\n\n                s->TimerInt = val;\n\n                rtl8139_set_next_tctr_time(s, qemu_get_clock_ns(vm_clock));\n\n            }\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"ioport write(l) addr=0x%x val=0x%08x via write(b)\\n\",\n\n                addr, val);\n\n            rtl8139_io_writeb(opaque, addr, val & 0xff);\n\n            rtl8139_io_writeb(opaque, addr + 1, (val >> 8) & 0xff);\n\n            rtl8139_io_writeb(opaque, addr + 2, (val >> 16) & 0xff);\n\n            rtl8139_io_writeb(opaque, addr + 3, (val >> 24) & 0xff);\n\n            break;\n\n    }\n\n}\n", "idx": 3347}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_lcd_read(void *opaque, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint64_t val = 0;\n\n\n\n    switch (size) {\n\n    case 8:\n\n        val |= (uint64_t)s->lcd_content[(addr + 7) & 0x7] << 56;\n\n        val |= (uint64_t)s->lcd_content[(addr + 6) & 0x7] << 48;\n\n        val |= (uint64_t)s->lcd_content[(addr + 5) & 0x7] << 40;\n\n        val |= (uint64_t)s->lcd_content[(addr + 4) & 0x7] << 32;\n\n        /* fall through */\n\n    case 4:\n\n        val |= (uint64_t)s->lcd_content[(addr + 3) & 0x7] << 24;\n\n        val |= (uint64_t)s->lcd_content[(addr + 2) & 0x7] << 16;\n\n        /* fall through */\n\n    case 2:\n\n        val |= (uint64_t)s->lcd_content[(addr + 1) & 0x7] << 8;\n\n        /* fall through */\n\n    case 1:\n\n        val |= (uint64_t)s->lcd_content[(addr + 0) & 0x7];\n\n        break;\n\n    }\n\n\n\n    return val;\n\n}\n", "idx": 6203}
{"project": "qemu", "commit_id": "073de86aa934d46d596a2367e7501da5500e5b86", "target": 1, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     ppc_slb_t *slb, bool secondary,\n\n                                     target_ulong ptem, ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            unsigned pshift = hpte_page_shift(slb->sps, pte0, pte1);\n\n            /*\n\n             * If there is no match, ignore the PTE, it could simply\n\n             * be for a different segment size encoding and the\n\n             * architecture specifies we should not match. Linux will\n\n             * potentially leave behind PTEs for the wrong base page\n\n             * size when demoting segments.\n\n             */\n\n            if (pshift == 0) {\n\n                continue;\n\n            }\n\n            /* We don't do anything with pshift yet as qemu TLB only deals\n\n             * with 4K pages anyway\n\n             */\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(cpu, token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(cpu, token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 8205}
{"project": "qemu", "commit_id": "344dc16fae0cb6a011aa5befffc8e7d520b11d5d", "target": 1, "func": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n\n{\n\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n\n    if (event_notifier_test_and_clear(n)) {\n\n        virtio_queue_notify_vq(vq);\n\n    }\n\n}\n", "idx": 4631}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "int bdrv_all_goto_snapshot(const char *name, BlockDriverState **first_bad_bs)\n\n{\n\n    int err = 0;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while (err == 0 && (it = bdrv_next(it, &bs))) {\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            err = bdrv_snapshot_goto(bs, name);\n\n        }\n\n        aio_context_release(ctx);\n\n    }\n\n\n\n    *first_bad_bs = bs;\n\n    return err;\n\n}\n", "idx": 6116}
{"project": "qemu", "commit_id": "c84f0f25db2eaab101665ddb60c1ddf1decce76a", "target": 1, "func": "static int virtio_gpu_load(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    VirtIOGPU *g = opaque;\n\n    struct virtio_gpu_simple_resource *res;\n\n    struct virtio_gpu_scanout *scanout;\n\n    uint32_t resource_id, pformat;\n\n    int i;\n\n\n\n    g->hostmem = 0;\n\n\n\n    resource_id = qemu_get_be32(f);\n\n    while (resource_id != 0) {\n\n        res = g_new0(struct virtio_gpu_simple_resource, 1);\n\n        res->resource_id = resource_id;\n\n        res->width = qemu_get_be32(f);\n\n        res->height = qemu_get_be32(f);\n\n        res->format = qemu_get_be32(f);\n\n        res->iov_cnt = qemu_get_be32(f);\n\n\n\n        /* allocate */\n\n        pformat = get_pixman_format(res->format);\n\n        if (!pformat) {\n\n\n            return -EINVAL;\n\n\n        res->image = pixman_image_create_bits(pformat,\n\n                                              res->width, res->height,\n\n                                              NULL, 0);\n\n        if (!res->image) {\n\n\n            return -EINVAL;\n\n\n\n\n        res->hostmem = PIXMAN_FORMAT_BPP(pformat) * res->width * res->height;\n\n\n\n        res->addrs = g_new(uint64_t, res->iov_cnt);\n\n        res->iov = g_new(struct iovec, res->iov_cnt);\n\n\n\n        /* read data */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            res->addrs[i] = qemu_get_be64(f);\n\n            res->iov[i].iov_len = qemu_get_be32(f);\n\n\n        qemu_get_buffer(f, (void *)pixman_image_get_data(res->image),\n\n                        pixman_image_get_stride(res->image) * res->height);\n\n\n\n        /* restore mapping */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            hwaddr len = res->iov[i].iov_len;\n\n            res->iov[i].iov_base =\n\n                cpu_physical_memory_map(res->addrs[i], &len, 1);\n\n            if (!res->iov[i].iov_base || len != res->iov[i].iov_len) {\n\n\n\n\n\n\n\n\n\n\n\n                return -EINVAL;\n\n\n\n\n\n        QTAILQ_INSERT_HEAD(&g->reslist, res, next);\n\n        g->hostmem += res->hostmem;\n\n\n\n        resource_id = qemu_get_be32(f);\n\n\n\n\n    /* load & apply scanout state */\n\n    vmstate_load_state(f, &vmstate_virtio_gpu_scanouts, g, 1);\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n\n        scanout = &g->scanout[i];\n\n        if (!scanout->resource_id) {\n\n            continue;\n\n\n        res = virtio_gpu_find_resource(g, scanout->resource_id);\n\n        if (!res) {\n\n            return -EINVAL;\n\n\n        scanout->ds = qemu_create_displaysurface_pixman(res->image);\n\n        if (!scanout->ds) {\n\n            return -EINVAL;\n\n\n\n\n        dpy_gfx_replace_surface(scanout->con, scanout->ds);\n\n        dpy_gfx_update(scanout->con, 0, 0, scanout->width, scanout->height);\n\n        update_cursor(g, &scanout->cursor);\n\n        res->scanout_bitmask |= (1 << i);\n\n\n\n\n    return 0;\n", "idx": 11266}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n\n                      struct in_addr vserver_addr)\n\n{\n\n    static int instance;\n\n    char smb_conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n", "idx": 4726}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void memory_region_transaction_commit(void)\n{\n    AddressSpace *as;\n    assert(memory_region_transaction_depth);\n    --memory_region_transaction_depth;\n    if (!memory_region_transaction_depth) {\n        if (memory_region_update_pending) {\n            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_topology(as);\n            }\n            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);\n        } else if (ioeventfd_update_pending) {\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_ioeventfds(as);\n            }\n        }\n        memory_region_clear_pending();\n   }\n}", "idx": 60}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 5818}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "static void *acpi_add_rom_blob(AcpiBuildState *build_state, GArray *blob,\n\n                               const char *name)\n\n{\n\n    return rom_add_blob(name, blob->data, acpi_data_len(blob), -1, name,\n\n                        acpi_build_update, build_state);\n\n}\n", "idx": 3402}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static void hpet_reset(void *opaque) {\n\n    HPETState *s = opaque;\n\n    int i;\n\n    static int count = 0;\n\n\n\n    for (i=0; i<HPET_NUM_TIMERS; i++) {\n\n        HPETTimer *timer = &s->timer[i];\n\n        hpet_del_timer(timer);\n\n        timer->tn = i;\n\n        timer->cmp = ~0ULL;\n\n        timer->config =  HPET_TN_PERIODIC_CAP | HPET_TN_SIZE_CAP;\n\n        /* advertise availability of ioapic inti2 */\n\n        timer->config |=  0x00000004ULL << 32;\n\n        timer->state = s;\n\n        timer->period = 0ULL;\n\n        timer->wrap_flag = 0;\n\n    }\n\n\n\n    s->hpet_counter = 0ULL;\n\n    s->hpet_offset = 0ULL;\n\n    /* 64-bit main counter; 3 timers supported; LegacyReplacementRoute. */\n\n    s->capability = 0x8086a201ULL;\n\n    s->capability |= ((HPET_CLK_PERIOD) << 32);\n\n    s->config = 0ULL;\n\n    if (count > 0)\n\n        /* we don't enable pit when hpet_reset is first called (by hpet_init)\n\n         * because hpet is taking over for pit here. On subsequent invocations,\n\n         * hpet_reset is called due to system reset. At this point control must\n\n         * be returned to pit until SW reenables hpet.\n\n         */\n\n        hpet_pit_enable();\n\n    count = 1;\n\n}\n", "idx": 10817}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfi(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    /* FIXME: This instruction doesn't exist anymore on 64-bit server\n\n     * processors compliant with arch 2.x, we should remove it there,\n\n     * but we need to fix OpenBIOS not to use it on 970 first\n\n     */\n\n    /* Restore CPU state */\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_update_cfar(ctx, ctx->nip);\n\n    gen_helper_rfi(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 11408}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 8202}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "void qemu_system_reset(bool report)\n\n{\n\n    MachineClass *mc;\n\n\n\n    mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    if (mc && mc->reset) {\n\n        mc->reset();\n\n    } else {\n\n        qemu_devices_reset();\n\n    }\n\n    if (report) {\n\n        qapi_event_send_reset(&error_abort);\n\n    }\n\n    cpu_synchronize_all_post_reset();\n\n}\n", "idx": 9535}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_slave_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *k = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_MISC, k->categories);\n\n    k->bus_type = TYPE_AUX_BUS;\n\n}\n", "idx": 466}
{"project": "qemu", "commit_id": "c8389550dedc65892fba9c3df29423efd802f544", "target": 1, "func": "static void vmgenid_device_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->vmsd = &vmstate_vmgenid;\n\n    dc->realize = vmgenid_realize;\n\n    dc->hotpluggable = false;\n\n    dc->props = vmgenid_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n\n\n    object_class_property_add_str(klass, VMGENID_GUID, NULL,\n\n                                  vmgenid_set_guid, NULL);\n\n    object_class_property_set_description(klass, VMGENID_GUID,\n\n                                    \"Set Global Unique Identifier \"\n\n                                    \"(big-endian) or auto for random value\",\n\n                                    NULL);\n\n}\n", "idx": 10711}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "mips_mipssim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios = g_new(MemoryRegion, 1);\n\n    MIPSCPU *cpu;\n\n    CPUMIPSState *env;\n\n    ResetData *reset_info;\n\n    int bios_size;\n\n\n\n    /* Init CPUs. */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"5Kf\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n    cpu = cpu_mips_init(cpu_model);\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetData));\n\n    reset_info->cpu = cpu;\n\n    reset_info->vector = env->active_tc.PC;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n\n\n    /* Allocate RAM. */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mips_mipssim.ram\",\n\n                                         ram_size);\n\n    memory_region_init_ram(bios, NULL, \"mips_mipssim.bios\", BIOS_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(bios);\n\n    memory_region_set_readonly(bios, true);\n\n\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    /* Map the BIOS / boot exception handler. */\n\n    memory_region_add_subregion(address_space_mem, 0x1fc00000LL, bios);\n\n    /* Load a BIOS / boot exception handler image. */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = load_image_targphys(filename, 0x1fc00000LL, BIOS_SIZE);\n\n        g_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if ((bios_size < 0 || bios_size > BIOS_SIZE) &&\n\n        !kernel_filename && !qtest_enabled()) {\n\n        /* Bail out if we have neither a kernel image nor boot vector code. */\n\n        error_report(\"Could not load MIPS bios '%s', and no \"\n\n                     \"-kernel argument was specified\", bios_name);\n\n        exit(1);\n\n    } else {\n\n        /* We have a boot vector start address. */\n\n        env->active_tc.PC = (target_long)(int32_t)0xbfc00000;\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        reset_info->vector = load_kernel();\n\n    }\n\n\n\n    /* Init CPU internal devices. */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* Register 64 KB of ISA IO space at 0x1fd00000. */\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, 0x00010000);\n\n    memory_region_add_subregion(get_system_memory(), 0x1fd00000, isa);\n\n\n\n    /* A single 16450 sits at offset 0x3f8. It is attached to\n\n       MIPS CPU INT2, which is interrupt 4. */\n\n    if (serial_hds[0])\n\n        serial_init(0x3f8, env->irq[4], 115200, serial_hds[0],\n\n                    get_system_io());\n\n\n\n    if (nd_table[0].used)\n\n        /* MIPSnet uses the MIPS CPU INT0, which is interrupt 2. */\n\n        mipsnet_init(0x4200, env->irq[2], &nd_table[0]);\n\n}\n", "idx": 7861}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 10936}
{"project": "qemu", "commit_id": "e8199e4895d34136735dea7e628d0de1a5afb630", "target": 1, "func": "static void process_incoming_migration_co(void *opaque)\n\n{\n\n    QEMUFile *f = opaque;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n    PostcopyState ps;\n\n    int ret;\n\n\n\n    mis->from_src_file = f;\n\n    mis->largest_page_size = qemu_ram_pagesize_largest();\n\n    postcopy_state_set(POSTCOPY_INCOMING_NONE);\n\n    migrate_set_state(&mis->state, MIGRATION_STATUS_NONE,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n    ret = qemu_loadvm_state(f);\n\n\n\n    ps = postcopy_state_get();\n\n    trace_process_incoming_migration_co_end(ret, ps);\n\n    if (ps != POSTCOPY_INCOMING_NONE) {\n\n        if (ps == POSTCOPY_INCOMING_ADVISE) {\n\n            /*\n\n             * Where a migration had postcopy enabled (and thus went to advise)\n\n             * but managed to complete within the precopy period, we can use\n\n             * the normal exit.\n\n             */\n\n            postcopy_ram_incoming_cleanup(mis);\n\n        } else if (ret >= 0) {\n\n            /*\n\n             * Postcopy was started, cleanup should happen at the end of the\n\n             * postcopy thread.\n\n             */\n\n            trace_process_incoming_migration_co_postcopy_end_main();\n\n            return;\n\n        }\n\n        /* Else if something went wrong then just fall out of the normal exit */\n\n    }\n\n\n\n    /* we get COLO info, and know if we are in COLO mode */\n\n    if (!ret && migration_incoming_enable_colo()) {\n\n        mis->migration_incoming_co = qemu_coroutine_self();\n\n        qemu_thread_create(&mis->colo_incoming_thread, \"COLO incoming\",\n\n             colo_process_incoming_thread, mis, QEMU_THREAD_JOINABLE);\n\n        mis->have_colo_incoming_thread = true;\n\n        qemu_coroutine_yield();\n\n\n\n        /* Wait checkpoint incoming thread exit before free resource */\n\n        qemu_thread_join(&mis->colo_incoming_thread);\n\n    }\n\n\n\n    qemu_fclose(f);\n\n    free_xbzrle_decoded_buf();\n\n\n\n    if (ret < 0) {\n\n        migrate_set_state(&mis->state, MIGRATION_STATUS_ACTIVE,\n\n                          MIGRATION_STATUS_FAILED);\n\n        error_report(\"load of migration failed: %s\", strerror(-ret));\n\n        migrate_decompress_threads_join();\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    mis->bh = qemu_bh_new(process_incoming_migration_bh, mis);\n\n    qemu_bh_schedule(mis->bh);\n\n}\n", "idx": 7532}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_migration_done(struct vhost_dev *dev, char* mac_addr)\n\n{\n\n    VhostUserMsg msg = { 0 };\n\n    int err;\n\n\n\n    assert(dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER);\n\n\n\n    /* If guest supports GUEST_ANNOUNCE do nothing */\n\n    if (virtio_has_feature(dev->acked_features, VIRTIO_NET_F_GUEST_ANNOUNCE)) {\n\n        return 0;\n\n    }\n\n\n\n    /* if backend supports VHOST_USER_PROTOCOL_F_RARP ask it to send the RARP */\n\n    if (virtio_has_feature(dev->protocol_features,\n\n                           VHOST_USER_PROTOCOL_F_RARP)) {\n\n        msg.request = VHOST_USER_SEND_RARP;\n\n        msg.flags = VHOST_USER_VERSION;\n\n        memcpy((char *)&msg.u64, mac_addr, 6);\n\n        msg.size = sizeof(m.u64);\n\n\n\n        err = vhost_user_write(dev, &msg, NULL, 0);\n\n        return err;\n\n    }\n\n    return -1;\n\n}\n", "idx": 2195}
{"project": "qemu", "commit_id": "01762e03222154fef6d98087ce391aed8a157be5", "target": 1, "func": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = blk_get_error_action(req->dev->blk,\n\n                                                   is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(blk_get_stats(s->blk), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    blk_error_action(s->blk, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n", "idx": 8415}
{"project": "qemu", "commit_id": "792773b2255d25c6f5fe9dfa0ae200debab92de4", "target": 1, "func": "static void init_blk_migration(Monitor *mon, QEMUFile *f)\n\n{\n\n    BlkMigDevState *bmds;\n\n    BlockDriverState *bs;\n\n\n\n    block_mig_state.submitted = 0;\n\n    block_mig_state.read_done = 0;\n\n    block_mig_state.transferred = 0;\n\n    block_mig_state.total_sector_sum = 0;\n\n    block_mig_state.prev_progress = -1;\n\n\n\n    for (bs = bdrv_first; bs != NULL; bs = bs->next) {\n\n        if (bs->type == BDRV_TYPE_HD) {\n\n            bmds = qemu_mallocz(sizeof(BlkMigDevState));\n\n            bmds->bs = bs;\n\n            bmds->bulk_completed = 0;\n\n            bmds->total_sectors = bdrv_getlength(bs) >> BDRV_SECTOR_BITS;\n\n            bmds->completed_sectors = 0;\n\n            bmds->shared_base = block_mig_state.shared_base;\n\n\n\n            block_mig_state.total_sector_sum += bmds->total_sectors;\n\n\n\n            if (bmds->shared_base) {\n\n                monitor_printf(mon, \"Start migration for %s with shared base \"\n\n                                    \"image\\n\",\n\n                               bs->device_name);\n\n            } else {\n\n                monitor_printf(mon, \"Start full migration for %s\\n\",\n\n                               bs->device_name);\n\n            }\n\n\n\n            QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n        }\n\n    }\n\n}\n", "idx": 8385}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static TAPState *net_tap_fd_init(VLANState *vlan, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = qemu_mallocz(sizeof(TAPState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n    s->vc = qemu_new_vlan_client(vlan, tap_receive, s);\n\n    qemu_set_fd_handler(s->fd, tap_send, NULL, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str), \"tap: fd=%d\", fd);\n\n    return s;\n\n}\n", "idx": 2890}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int16_t *v = pv;\n\n    qemu_get_sbe16s(f, v);\n\n    return 0;\n\n}\n", "idx": 4703}
{"project": "qemu", "commit_id": "548f52ea06951c20f0b91cae6cde0512ec073c83", "target": 1, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n    int pending;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    pending = f->buf_size - f->buf_index;\n\n    if (pending > 0) {\n\n        memmove(f->buf, f->buf + f->buf_index, pending);\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = pending;\n\n\n\n    len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n\n                        IO_BUF_SIZE - pending);\n\n    if (len > 0) {\n\n        f->buf_size += len;\n\n        f->pos += len;\n\n    } else if (len == 0) {\n\n        qemu_file_set_error(f, -EIO);\n\n    } else if (len != -EAGAIN) {\n\n        qemu_file_set_error(f, len);\n\n    }\n\n}\n", "idx": 7676}
{"project": "qemu", "commit_id": "c6d34865fa02463cf34634f45369ebcc725b101b", "target": 1, "func": "static int dmg_read_mish_block(BDRVDMGState *s, DmgHeaderState *ds,\n\n                               uint8_t *buffer, uint32_t count)\n\n{\n\n    uint32_t type, i;\n\n    int ret;\n\n    size_t new_size;\n\n    uint32_t chunk_count;\n\n    int64_t offset = 0;\n\n\n\n    type = buff_read_uint32(buffer, offset);\n\n    /* skip data that is not a valid MISH block (invalid magic or too small) */\n\n    if (type != 0x6d697368 || count < 244) {\n\n        /* assume success for now */\n\n        return 0;\n\n    }\n\n\n\n    offset += 4;\n\n    offset += 200;\n\n\n\n    chunk_count = (count - 204) / 40;\n\n    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n    s->types = g_realloc(s->types, new_size / 2);\n\n    s->offsets = g_realloc(s->offsets, new_size);\n\n    s->lengths = g_realloc(s->lengths, new_size);\n\n    s->sectors = g_realloc(s->sectors, new_size);\n\n    s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n\n\n\n    for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) {\n\n        s->types[i] = buff_read_uint32(buffer, offset);\n\n        offset += 4;\n\n        if (s->types[i] != 0x80000005 && s->types[i] != 1 &&\n\n            s->types[i] != 2) {\n\n            if (s->types[i] == 0xffffffff && i > 0) {\n\n                ds->last_in_offset = s->offsets[i - 1] + s->lengths[i - 1];\n\n                ds->last_out_offset = s->sectors[i - 1] +\n\n                                      s->sectorcounts[i - 1];\n\n            }\n\n            chunk_count--;\n\n            i--;\n\n            offset += 36;\n\n            continue;\n\n        }\n\n        offset += 4;\n\n\n\n        s->sectors[i] = buff_read_uint64(buffer, offset);\n\n        s->sectors[i] += ds->last_out_offset;\n\n        offset += 8;\n\n\n\n        s->sectorcounts[i] = buff_read_uint64(buffer, offset);\n\n        offset += 8;\n\n\n\n        if (s->sectorcounts[i] > DMG_SECTORCOUNTS_MAX) {\n\n            error_report(\"sector count %\" PRIu64 \" for chunk %\" PRIu32\n\n                         \" is larger than max (%u)\",\n\n                         s->sectorcounts[i], i, DMG_SECTORCOUNTS_MAX);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n\n\n        s->offsets[i] = buff_read_uint64(buffer, offset);\n\n        s->offsets[i] += ds->last_in_offset;\n\n        offset += 8;\n\n\n\n        s->lengths[i] = buff_read_uint64(buffer, offset);\n\n        offset += 8;\n\n\n\n        if (s->lengths[i] > DMG_LENGTHS_MAX) {\n\n            error_report(\"length %\" PRIu64 \" for chunk %\" PRIu32\n\n                         \" is larger than max (%u)\",\n\n                         s->lengths[i], i, DMG_LENGTHS_MAX);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n\n\n        update_max_chunk_size(s, i, &ds->max_compressed_size,\n\n                              &ds->max_sectors_per_chunk);\n\n    }\n\n    s->n_chunks += chunk_count;\n\n    return 0;\n\n\n\nfail:\n\n    return ret;\n\n}\n", "idx": 7556}
{"project": "qemu", "commit_id": "fac7aa7fc2ebc26803b0a7b44b010f47ce3e1dd8", "target": 1, "func": "static uint32_t  ahci_port_read(AHCIState *s, int port, int offset)\n\n{\n\n    uint32_t val;\n\n    AHCIPortRegs *pr;\n\n    pr = &s->dev[port].port_regs;\n\n\n\n    switch (offset) {\n\n    case PORT_LST_ADDR:\n\n        val = pr->lst_addr;\n\n        break;\n\n    case PORT_LST_ADDR_HI:\n\n        val = pr->lst_addr_hi;\n\n        break;\n\n    case PORT_FIS_ADDR:\n\n        val = pr->fis_addr;\n\n        break;\n\n    case PORT_FIS_ADDR_HI:\n\n        val = pr->fis_addr_hi;\n\n        break;\n\n    case PORT_IRQ_STAT:\n\n        val = pr->irq_stat;\n\n        break;\n\n    case PORT_IRQ_MASK:\n\n        val = pr->irq_mask;\n\n        break;\n\n    case PORT_CMD:\n\n        val = pr->cmd;\n\n        break;\n\n    case PORT_TFDATA:\n\n        val = ((uint16_t)s->dev[port].port.ifs[0].error << 8) |\n\n              s->dev[port].port.ifs[0].status;\n\n        break;\n\n    case PORT_SIG:\n\n        val = pr->sig;\n\n        break;\n\n    case PORT_SCR_STAT:\n\n        if (s->dev[port].port.ifs[0].bs) {\n\n            val = SATA_SCR_SSTATUS_DET_DEV_PRESENT_PHY_UP |\n\n                  SATA_SCR_SSTATUS_SPD_GEN1 | SATA_SCR_SSTATUS_IPM_ACTIVE;\n\n        } else {\n\n            val = SATA_SCR_SSTATUS_DET_NODEV;\n\n        }\n\n        break;\n\n    case PORT_SCR_CTL:\n\n        val = pr->scr_ctl;\n\n        break;\n\n    case PORT_SCR_ERR:\n\n        val = pr->scr_err;\n\n        break;\n\n    case PORT_SCR_ACT:\n\n        pr->scr_act &= ~s->dev[port].finished;\n\n        s->dev[port].finished = 0;\n\n        val = pr->scr_act;\n\n        break;\n\n    case PORT_CMD_ISSUE:\n\n        val = pr->cmd_issue;\n\n        break;\n\n    case PORT_RESERVED:\n\n    default:\n\n        val = 0;\n\n    }\n\n    DPRINTF(port, \"offset: 0x%x val: 0x%x\\n\", offset, val);\n\n    return val;\n\n\n\n}\n", "idx": 1362}
{"project": "qemu", "commit_id": "57d84cf35302fe51789c18354bf09a521bb603df", "target": 1, "func": "static void remove_port(VirtIOSerial *vser, uint32_t port_id)\n\n{\n\n    VirtIOSerialPort *port;\n\n    unsigned int i;\n\n\n\n    i = port_id / 32;\n\n    vser->ports_map[i] &= ~(1U << (port_id % 32));\n\n\n\n    port = find_port_by_id(vser, port_id);\n\n    /*\n\n     * This function is only called from qdev's unplug callback; if we\n\n     * get a NULL port here, we're in trouble.\n\n     */\n\n    assert(port);\n\n\n\n    /* Flush out any unconsumed buffers first */\n\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n\n\n    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);\n\n}\n", "idx": 1006}
{"project": "qemu", "commit_id": "f2e933d20d5fd6c38bda227359b79bcc81654f99", "target": 1, "func": "uint_fast16_t float64_to_uint16_round_to_zero(float64 a STATUS_PARAM)\n\n{\n\n    int64_t v;\n\n    uint_fast16_t res;\n\n\n\n    v = float64_to_int64_round_to_zero(a STATUS_VAR);\n\n    if (v < 0) {\n\n        res = 0;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else if (v > 0xffff) {\n\n        res = 0xffff;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else {\n\n        res = v;\n\n    }\n\n    return res;\n\n}\n", "idx": 5016}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static uint64_t openpic_gbl_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval;\n\n\n\n    DPRINTF(\"%s: addr \" TARGET_FMT_plx \"\\n\", __func__, addr);\n\n    retval = 0xFFFFFFFF;\n\n    if (addr & 0xF)\n\n        return retval;\n\n    switch (addr) {\n\n    case 0x1000: /* FREP */\n\n        retval = opp->frep;\n\n        break;\n\n    case 0x1020: /* GLBC */\n\n        retval = opp->glbc;\n\n        break;\n\n    case 0x1080: /* VENI */\n\n        retval = opp->veni;\n\n        break;\n\n    case 0x1090: /* PINT */\n\n        retval = 0x00000000;\n\n        break;\n\n    case 0x00: /* Block Revision Register1 (BRR1) */\n\n        retval = opp->brr1;\n\n        break;\n\n    case 0x40:\n\n    case 0x50:\n\n    case 0x60:\n\n    case 0x70:\n\n    case 0x80:\n\n    case 0x90:\n\n    case 0xA0:\n\n    case 0xB0:\n\n        retval = openpic_cpu_read_internal(opp, addr, get_current_cpu());\n\n        break;\n\n    case 0x10A0: /* IPI_IPVP */\n\n    case 0x10B0:\n\n    case 0x10C0:\n\n    case 0x10D0:\n\n        {\n\n            int idx;\n\n            idx = (addr - 0x10A0) >> 4;\n\n            retval = read_IRQreg_ipvp(opp, opp->irq_ipi0 + idx);\n\n        }\n\n        break;\n\n    case 0x10E0: /* SPVE */\n\n        retval = opp->spve;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 9248}
{"project": "qemu", "commit_id": "b11e20fb6c658bc13b2e4dfc1b86c2eb8731e374", "target": 1, "func": "static void cleanup_infolist(CommandLineParameterInfoList *head)\n\n{\n\n    CommandLineParameterInfoList *pre_entry, *cur, *del_entry;\n\n\n\n    cur = head;\n\n    while (cur->next) {\n\n        pre_entry = head;\n\n        while (pre_entry != cur->next) {\n\n            if (!strcmp(pre_entry->value->name, cur->next->value->name)) {\n\n                del_entry = cur->next;\n\n                cur->next = cur->next->next;\n\n                g_free(del_entry);\n\n                break;\n\n            }\n\n            pre_entry = pre_entry->next;\n\n        }\n\n        cur = cur->next;\n\n    }\n\n}\n", "idx": 5656}
{"project": "qemu", "commit_id": "6c2d1c32d084320081b0cd047f8cacd6e722d03a", "target": 1, "func": "static void ohci_pci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = usb_ohci_initfn_pci;\n\n    k->vendor_id = PCI_VENDOR_ID_APPLE;\n\n    k->device_id = PCI_DEVICE_ID_APPLE_IPID_USB;\n\n    k->class_id = PCI_CLASS_SERIAL_USB;\n\n\n    dc->desc = \"Apple USB Controller\";\n\n    dc->props = ohci_pci_properties;\n\n}", "idx": 9233}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n", "idx": 4617}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "void smc91c111_init(NICInfo *nd, uint32_t base, qemu_irq irq)\n\n{\n\n    smc91c111_state *s;\n\n    int iomemtype;\n\n\n\n    qemu_check_nic_model(nd, \"smc91c111\");\n\n\n\n    s = (smc91c111_state *)qemu_mallocz(sizeof(smc91c111_state));\n\n    iomemtype = cpu_register_io_memory(0, smc91c111_readfn,\n\n                                       smc91c111_writefn, s);\n\n    cpu_register_physical_memory(base, 16, iomemtype);\n\n    s->irq = irq;\n\n    memcpy(s->macaddr, nd->macaddr, 6);\n\n\n\n    smc91c111_reset(s);\n\n\n\n    s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                 smc91c111_receive, smc91c111_can_receive, s);\n\n    qemu_format_nic_info_str(s->vc, s->macaddr);\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 544}
{"project": "qemu", "commit_id": "19dbcbf7cc1892f5130b4edd5a4bb4ca800ef7d8", "target": 1, "func": "static int preallocate(BlockDriverState *bs)\n\n{\n\n    uint64_t nb_sectors;\n\n    uint64_t offset;\n\n    int num;\n\n    int ret;\n\n    QCowL2Meta meta;\n\n\n\n    nb_sectors = bdrv_getlength(bs) >> 9;\n\n    offset = 0;\n\n    QLIST_INIT(&meta.dependent_requests);\n\n    meta.cluster_offset = 0;\n\n\n\n    while (nb_sectors) {\n\n        num = MIN(nb_sectors, INT_MAX >> 9);\n\n        ret = qcow2_alloc_cluster_offset(bs, offset, 0, num, &num, &meta);\n\n\n\n        if (ret < 0) {\n\n            return -1;\n\n        }\n\n\n\n        if (qcow2_alloc_cluster_link_l2(bs, &meta) < 0) {\n\n            qcow2_free_any_clusters(bs, meta.cluster_offset, meta.nb_clusters);\n\n            return -1;\n\n        }\n\n\n\n        /* There are no dependent requests, but we need to remove our request\n\n         * from the list of in-flight requests */\n\n        run_dependent_requests(&meta);\n\n\n\n        /* TODO Preallocate data if requested */\n\n\n\n        nb_sectors -= num;\n\n        offset += num << 9;\n\n    }\n\n\n\n    /*\n\n     * It is expected that the image file is large enough to actually contain\n\n     * all of the allocated clusters (otherwise we get failing reads after\n\n     * EOF). Extend the image to the last allocated sector.\n\n     */\n\n    if (meta.cluster_offset != 0) {\n\n        uint8_t buf[512];\n\n        memset(buf, 0, 512);\n\n        bdrv_write(bs->file, (meta.cluster_offset >> 9) + num - 1, buf, 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4517}
{"project": "qemu", "commit_id": "c46a3ea025b147d58e4c7a222307ccba1e9e376f", "target": 1, "func": "static void lan9118_writel(void *opaque, target_phys_addr_t offset,\n\n                           uint32_t val)\n\n{\n\n    lan9118_state *s = (lan9118_state *)opaque;\n\n    offset &= 0xff;\n\n    \n\n    //DPRINTF(\"Write reg 0x%02x = 0x%08x\\n\", (int)offset, val);\n\n    if (offset >= 0x20 && offset < 0x40) {\n\n        /* TX FIFO */\n\n        tx_fifo_push(s, val);\n\n        return;\n\n    }\n\n    switch (offset) {\n\n    case CSR_IRQ_CFG:\n\n        /* TODO: Implement interrupt deassertion intervals.  */\n\n        s->irq_cfg = (s->irq_cfg & IRQ_INT) | (val & IRQ_EN);\n\n        break;\n\n    case CSR_INT_STS:\n\n        s->int_sts &= ~val;\n\n        break;\n\n    case CSR_INT_EN:\n\n        s->int_en = val & ~RESERVED_INT;\n\n        s->int_sts |= val & SW_INT;\n\n        break;\n\n    case CSR_FIFO_INT:\n\n        DPRINTF(\"FIFO INT levels %08x\\n\", val);\n\n        s->fifo_int = val;\n\n        break;\n\n    case CSR_RX_CFG:\n\n        if (val & 0x8000) {\n\n            /* RX_DUMP */\n\n            s->rx_fifo_used = 0;\n\n            s->rx_status_fifo_used = 0;\n\n            s->rx_packet_size_tail = s->rx_packet_size_head;\n\n            s->rx_packet_size[s->rx_packet_size_head] = 0;\n\n        }\n\n        s->rx_cfg = val & 0xcfff1ff0;\n\n        break;\n\n    case CSR_TX_CFG:\n\n        if (val & 0x8000) {\n\n            s->tx_status_fifo_used = 0;\n\n        }\n\n        if (val & 0x4000) {\n\n            s->txp->state = TX_IDLE;\n\n            s->txp->fifo_used = 0;\n\n            s->txp->cmd_a = 0xffffffff;\n\n        }\n\n        s->tx_cfg = val & 6;\n\n        break;\n\n    case CSR_HW_CFG:\n\n        if (val & 1) {\n\n            /* SRST */\n\n            lan9118_reset(&s->busdev.qdev);\n\n        } else {\n\n            s->hw_cfg = val & 0x003f300;\n\n        }\n\n        break;\n\n    case CSR_RX_DP_CTRL:\n\n        if (val & 0x80000000) {\n\n            /* Skip forward to next packet.  */\n\n            s->rxp_pad = 0;\n\n            s->rxp_offset = 0;\n\n            if (s->rxp_size == 0) {\n\n                /* Pop a word to start the next packet.  */\n\n                rx_fifo_pop(s);\n\n                s->rxp_pad = 0;\n\n                s->rxp_offset = 0;\n\n            }\n\n            s->rx_fifo_head += s->rxp_size;\n\n            if (s->rx_fifo_head >= s->rx_fifo_size) {\n\n                s->rx_fifo_head -= s->rx_fifo_size;\n\n            }\n\n        }\n\n        break;\n\n    case CSR_PMT_CTRL:\n\n        if (val & 0x400) {\n\n            phy_reset(s);\n\n        }\n\n        s->pmt_ctrl &= ~0x34e;\n\n        s->pmt_ctrl |= (val & 0x34e);\n\n        break;\n\n    case CSR_GPIO_CFG:\n\n        /* Probably just enabling LEDs.  */\n\n        s->gpio_cfg = val & 0x7777071f;\n\n        break;\n\n    case CSR_GPT_CFG:\n\n        if ((s->gpt_cfg ^ val) & GPT_TIMER_EN) {\n\n            if (val & GPT_TIMER_EN) {\n\n                ptimer_set_count(s->timer, val & 0xffff);\n\n                ptimer_run(s->timer, 0);\n\n            } else {\n\n                ptimer_stop(s->timer);\n\n                ptimer_set_count(s->timer, 0xffff);\n\n            }\n\n        }\n\n        s->gpt_cfg = val & (GPT_TIMER_EN | 0xffff);\n\n        break;\n\n    case CSR_WORD_SWAP:\n\n        /* Ignored because we're in 32-bit mode.  */\n\n        s->word_swap = val;\n\n        break;\n\n    case CSR_MAC_CSR_CMD:\n\n        s->mac_cmd = val & 0x4000000f;\n\n        if (val & 0x80000000) {\n\n            if (val & 0x40000000) {\n\n                s->mac_data = do_mac_read(s, val & 0xf);\n\n                DPRINTF(\"MAC read %d = 0x%08x\\n\", val & 0xf, s->mac_data);\n\n            } else {\n\n                DPRINTF(\"MAC write %d = 0x%08x\\n\", val & 0xf, s->mac_data);\n\n                do_mac_write(s, val & 0xf, s->mac_data);\n\n            }\n\n        }\n\n        break;\n\n    case CSR_MAC_CSR_DATA:\n\n        s->mac_data = val;\n\n        break;\n\n    case CSR_AFC_CFG:\n\n        s->afc_cfg = val & 0x00ffffff;\n\n        break;\n\n    case CSR_E2P_CMD:\n\n        lan9118_eeprom_cmd(s, (val >> 28) & 7, val & 0xff);\n\n        break;\n\n    case CSR_E2P_DATA:\n\n        s->e2p_data = val & 0xff;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"lan9118_write: Bad reg 0x%x = %x\\n\", (int)offset, val);\n\n        break;\n\n    }\n\n    lan9118_update(s);\n\n}\n", "idx": 10261}
{"project": "qemu", "commit_id": "d5a8ee60a0fbc20a2c2d02f3bda1bb1bd365f1ee", "target": 1, "func": "BlockDeviceInfoList *qmp_query_named_block_nodes(Error **errp)\n\n{\n\n    return bdrv_named_nodes_list();\n\n}\n", "idx": 7508}
{"project": "qemu", "commit_id": "8c0a6dc96cd14c48da4a61fe35431f36d6e6e467", "target": 1, "func": "static void test_hash_speed(const void *opaque)\n\n{\n\n    size_t chunk_size = (size_t)opaque;\n\n    uint8_t *in = NULL, *out = NULL;\n\n    size_t out_len = 0;\n\n    double total = 0.0;\n\n    struct iovec iov;\n\n    int ret;\n\n\n\n    in = g_new0(uint8_t, chunk_size);\n\n    memset(in, g_test_rand_int(), chunk_size);\n\n\n\n    iov.iov_base = (char *)in;\n\n    iov.iov_len = chunk_size;\n\n\n\n    g_test_timer_start();\n\n    do {\n\n        ret = qcrypto_hash_bytesv(QCRYPTO_HASH_ALG_SHA256,\n\n                                  &iov, 1, &out, &out_len,\n\n                                  NULL);\n\n        g_assert(ret == 0);\n\n\n\n        total += chunk_size;\n\n    } while (g_test_timer_elapsed() < 5.0);\n\n\n\n    total /= 1024 * 1024; /* to MB */\n\n    g_print(\"sha256: \");\n\n    g_print(\"Testing chunk_size %ld bytes \", chunk_size);\n\n    g_print(\"done: %.2f MB in %.2f secs: \", total, g_test_timer_last());\n\n    g_print(\"%.2f MB/sec\\n\", total / g_test_timer_last());\n\n\n\n    g_free(out);\n\n    g_free(in);\n\n}\n", "idx": 11451}
{"project": "qemu", "commit_id": "53111180946a56d314a9c1d07d09b9ef91e847b9", "target": 1, "func": "static void armv7m_nvic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    NVICClass *nc = NVIC_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    nc->parent_reset = dc->reset;\n\n    nc->parent_init = sdc->init;\n\n    sdc->init = armv7m_nvic_init;\n\n    dc->vmsd  = &vmstate_nvic;\n\n    dc->reset = armv7m_nvic_reset;\n\n}\n", "idx": 2899}
{"project": "qemu", "commit_id": "302fa283789a2f9b1199c327047cfad2258a23a2", "target": 1, "func": "const char *memory_region_name(const MemoryRegion *mr)\n\n{\n\n    return object_get_canonical_path_component(OBJECT(mr));\n\n}\n", "idx": 9685}
{"project": "qemu", "commit_id": "8b81bb3b069d4007bc44c8d5888d630b7f0b42ff", "target": 1, "func": "static void virtio_pci_device_unplugged(DeviceState *d)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(d);\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);\n\n\n\n    virtio_pci_stop_ioeventfd(proxy);\n\n    msix_uninit_exclusive_bar(pci_dev);\n\n}\n", "idx": 10873}
{"project": "qemu", "commit_id": "97a3ea57198b39b8366cd2a7514707abdcd0a7bc", "target": 1, "func": "static int curl_open(BlockDriverState *bs, QDict *options, int flags,\n                     Error **errp)\n{\n    BDRVCURLState *s = bs->opaque;\n    CURLState *state = NULL;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    const char *file;\n    double d;\n    static int inited = 0;\n    if (flags & BDRV_O_RDWR) {\n        error_setg(errp, \"curl block device does not support writes\");\n        return -EROFS;\n    }\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out_noclean;\n    }\n    s->readahead_size = qemu_opt_get_size(opts, CURL_BLOCK_OPT_READAHEAD,\n                                          READ_AHEAD_DEFAULT);\n    if ((s->readahead_size & 0x1ff) != 0) {\n        error_setg(errp, \"HTTP_READAHEAD_SIZE %zd is not a multiple of 512\",\n                   s->readahead_size);\n        goto out_noclean;\n    }\n    file = qemu_opt_get(opts, CURL_BLOCK_OPT_URL);\n    if (file == NULL) {\n        error_setg(errp, \"curl block driver requires an 'url' option\");\n        goto out_noclean;\n    }\n    if (!inited) {\n        curl_global_init(CURL_GLOBAL_ALL);\n        inited = 1;\n    }\n    DPRINTF(\"CURL: Opening %s\\n\", file);\n    s->url = g_strdup(file);\n    state = curl_init_state(s);\n    if (!state)\n        goto out_noclean;\n    // Get file size\n    s->accept_range = false;\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);\n    curl_easy_setopt(state->curl, CURLOPT_HEADERFUNCTION,\n                     curl_header_cb);\n    curl_easy_setopt(state->curl, CURLOPT_HEADERDATA, s);\n    if (curl_easy_perform(state->curl))\n        goto out;\n    curl_easy_getinfo(state->curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d);\n    if (d)\n        s->len = (size_t)d;\n    else if(!s->len)\n        goto out;\n    if ((!strncasecmp(s->url, \"http://\", strlen(\"http://\"))\n        || !strncasecmp(s->url, \"https://\", strlen(\"https://\")))\n        && !s->accept_range) {\n        pstrcpy(state->errmsg, CURL_ERROR_SIZE,\n                \"Server does not support 'range' (byte ranges).\");\n        goto out;\n    }\n    DPRINTF(\"CURL: Size = %zd\\n\", s->len);\n    curl_clean_state(state);\n    curl_easy_cleanup(state->curl);\n    state->curl = NULL;\n    aio_timer_init(bdrv_get_aio_context(bs), &s->timer,\n                   QEMU_CLOCK_REALTIME, SCALE_NS,\n                   curl_multi_timeout_do, s);\n    // Now we know the file exists and its size, so let's\n    // initialize the multi interface!\n    s->multi = curl_multi_init();\n    curl_multi_setopt(s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb);\n#ifdef NEED_CURL_TIMER_CALLBACK\n    curl_multi_setopt(s->multi, CURLMOPT_TIMERDATA, s);\n    curl_multi_setopt(s->multi, CURLMOPT_TIMERFUNCTION, curl_timer_cb);\n#endif\n    qemu_opts_del(opts);\n    return 0;\nout:\n    error_setg(errp, \"CURL: Error opening file: %s\", state->errmsg);\n    curl_easy_cleanup(state->curl);\n    state->curl = NULL;\nout_noclean:\n    g_free(s->url);\n    qemu_opts_del(opts);\n    return -EINVAL;\n}", "idx": 8052}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_dgram_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai, *peer = NULL, *local = NULL;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock = -1, rc;\n\n\n\n    /* lookup peer addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = \"localhost\";\n\n    }\n\n    if (port == NULL || strlen(port) == 0) {\n\n        fprintf(stderr, \"inet_dgram: port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: peer (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, peer);\n\n    }\n\n\n\n    /* lookup local addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    ai.ai_family = peer->ai_family;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"localaddr\");\n\n    port = qemu_opt_get(opts, \"localport\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = NULL;\n\n    }\n\n    if (!port || strlen(port) == 0)\n\n        port = \"0\";\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: local (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, local);\n\n    }\n\n\n\n    /* create socket */\n\n    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n", "idx": 7908}
{"project": "qemu", "commit_id": "cdd346371e09709be8e46398bb097dc690a746f2", "target": 1, "func": "static uint16_t nvme_get_feature(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    uint32_t dw10 = le32_to_cpu(cmd->cdw10);\n\n    uint32_t result;\n\n\n\n    switch (dw10) {\n\n    case NVME_VOLATILE_WRITE_CACHE:\n\n        result = blk_enable_write_cache(n->conf.blk);\n\n        break;\n\n    case NVME_NUMBER_OF_QUEUES:\n\n        result = cpu_to_le32((n->num_queues - 1) | ((n->num_queues - 1) << 16));\n\n        break;\n\n    default:\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n\n\n    req->cqe.result = result;\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 8958}
{"project": "qemu", "commit_id": "2ce68e4cf5be9b5176a3c3c372948d6340724d2d", "target": 1, "func": "static void vhost_set_memory(MemoryListener *listener,\n\n                             MemoryRegionSection *section,\n\n                             bool add)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         memory_listener);\n\n    hwaddr start_addr = section->offset_within_address_space;\n\n    ram_addr_t size = int128_get64(section->size);\n\n    bool log_dirty =\n\n        memory_region_get_dirty_log_mask(section->mr) & ~(1 << DIRTY_MEMORY_MIGRATION);\n\n    int s = offsetof(struct vhost_memory, regions) +\n\n        (dev->mem->nregions + 1) * sizeof dev->mem->regions[0];\n\n    void *ram;\n\n\n\n    dev->mem = g_realloc(dev->mem, s);\n\n\n\n    if (log_dirty) {\n\n        add = false;\n\n    }\n\n\n\n    assert(size);\n\n\n\n    /* Optimize no-change case. At least cirrus_vga does this a lot at this time. */\n\n    ram = memory_region_get_ram_ptr(section->mr) + section->offset_within_region;\n\n    if (add) {\n\n        if (!vhost_dev_cmp_memory(dev, start_addr, size, (uintptr_t)ram)) {\n\n            /* Region exists with same address. Nothing to do. */\n\n            return;\n\n        }\n\n    } else {\n\n        if (!vhost_dev_find_reg(dev, start_addr, size)) {\n\n            /* Removing region that we don't access. Nothing to do. */\n\n            return;\n\n        }\n\n    }\n\n\n\n    vhost_dev_unassign_memory(dev, start_addr, size);\n\n    if (add) {\n\n        /* Add given mapping, merging adjacent regions if any */\n\n        vhost_dev_assign_memory(dev, start_addr, size, (uintptr_t)ram);\n\n    } else {\n\n        /* Remove old mapping for this memory, if any. */\n\n        vhost_dev_unassign_memory(dev, start_addr, size);\n\n    }\n\n    dev->mem_changed_start_addr = MIN(dev->mem_changed_start_addr, start_addr);\n\n    dev->mem_changed_end_addr = MAX(dev->mem_changed_end_addr, start_addr + size - 1);\n\n    dev->memory_changed = true;\n\n\n}", "idx": 5631}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_s_without_atn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_s_without_atn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len) {\n\n        do_busid_cmd(s, buf, 0);\n\n    }\n\n}\n", "idx": 10887}
{"project": "qemu", "commit_id": "d5a8ee60a0fbc20a2c2d02f3bda1bb1bd365f1ee", "target": 1, "func": "BlockDeviceInfo *bdrv_block_device_info(BlockDriverState *bs)\n\n{\n\n    BlockDeviceInfo *info = g_malloc0(sizeof(*info));\n\n\n\n    info->file                   = g_strdup(bs->filename);\n\n    info->ro                     = bs->read_only;\n\n    info->drv                    = g_strdup(bs->drv->format_name);\n\n    info->encrypted              = bs->encrypted;\n\n    info->encryption_key_missing = bdrv_key_required(bs);\n\n\n\n    info->cache = g_new(BlockdevCacheInfo, 1);\n\n    *info->cache = (BlockdevCacheInfo) {\n\n        .writeback      = bdrv_enable_write_cache(bs),\n\n        .direct         = !!(bs->open_flags & BDRV_O_NOCACHE),\n\n        .no_flush       = !!(bs->open_flags & BDRV_O_NO_FLUSH),\n\n    };\n\n\n\n    if (bs->node_name[0]) {\n\n        info->has_node_name = true;\n\n        info->node_name = g_strdup(bs->node_name);\n\n    }\n\n\n\n    if (bs->backing_file[0]) {\n\n        info->has_backing_file = true;\n\n        info->backing_file = g_strdup(bs->backing_file);\n\n    }\n\n\n\n    info->backing_file_depth = bdrv_get_backing_file_depth(bs);\n\n    info->detect_zeroes = bs->detect_zeroes;\n\n\n\n    if (bs->io_limits_enabled) {\n\n        ThrottleConfig cfg;\n\n        throttle_get_config(&bs->throttle_state, &cfg);\n\n        info->bps     = cfg.buckets[THROTTLE_BPS_TOTAL].avg;\n\n        info->bps_rd  = cfg.buckets[THROTTLE_BPS_READ].avg;\n\n        info->bps_wr  = cfg.buckets[THROTTLE_BPS_WRITE].avg;\n\n\n\n        info->iops    = cfg.buckets[THROTTLE_OPS_TOTAL].avg;\n\n        info->iops_rd = cfg.buckets[THROTTLE_OPS_READ].avg;\n\n        info->iops_wr = cfg.buckets[THROTTLE_OPS_WRITE].avg;\n\n\n\n        info->has_bps_max     = cfg.buckets[THROTTLE_BPS_TOTAL].max;\n\n        info->bps_max         = cfg.buckets[THROTTLE_BPS_TOTAL].max;\n\n        info->has_bps_rd_max  = cfg.buckets[THROTTLE_BPS_READ].max;\n\n        info->bps_rd_max      = cfg.buckets[THROTTLE_BPS_READ].max;\n\n        info->has_bps_wr_max  = cfg.buckets[THROTTLE_BPS_WRITE].max;\n\n        info->bps_wr_max      = cfg.buckets[THROTTLE_BPS_WRITE].max;\n\n\n\n        info->has_iops_max    = cfg.buckets[THROTTLE_OPS_TOTAL].max;\n\n        info->iops_max        = cfg.buckets[THROTTLE_OPS_TOTAL].max;\n\n        info->has_iops_rd_max = cfg.buckets[THROTTLE_OPS_READ].max;\n\n        info->iops_rd_max     = cfg.buckets[THROTTLE_OPS_READ].max;\n\n        info->has_iops_wr_max = cfg.buckets[THROTTLE_OPS_WRITE].max;\n\n        info->iops_wr_max     = cfg.buckets[THROTTLE_OPS_WRITE].max;\n\n\n\n        info->has_iops_size = cfg.op_size;\n\n        info->iops_size = cfg.op_size;\n\n    }\n\n\n\n    info->write_threshold = bdrv_write_threshold_get(bs);\n\n\n\n    return info;\n\n}\n", "idx": 2322}
{"project": "qemu", "commit_id": "b2d1fe67d09d2b6c7da647fbcea6ca0148c206d3", "target": 1, "func": "static void usbredir_interface_info(void *priv,\n\n    struct usb_redir_interface_info_header *interface_info)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n\n\n    dev->interface_info = *interface_info;\n\n\n\n    /*\n\n     * If we receive interface info after the device has already been\n\n     * connected (ie on a set_config), re-check the filter.\n\n     */\n\n    if (qemu_timer_pending(dev->attach_timer) || dev->dev.attached) {\n\n        if (usbredir_check_filter(dev)) {\n\n            ERROR(\"Device no longer matches filter after interface info \"\n\n                  \"change, disconnecting!\\n\");\n\n        }\n\n    }\n\n}\n", "idx": 10516}
{"project": "qemu", "commit_id": "8a0548f94edecb96acb9b7fb9106ccc821c4996f", "target": 1, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *cpu, struct kvm_sw_breakpoint *bp)\n\n{\n\n    return -EINVAL;\n\n}\n", "idx": 1467}
{"project": "qemu", "commit_id": "8dea1dd406189dae6108104faf27f397835ae871", "target": 1, "func": "static uint32_t get_cmd(ESPState *s, uint8_t *buf)\n\n{\n\n    uint32_t dmalen;\n\n    int target;\n\n\n\n    dmalen = s->rregs[ESP_TCLO] | (s->rregs[ESP_TCMID] << 8);\n\n    target = s->wregs[ESP_WBUSID] & 7;\n\n    DPRINTF(\"get_cmd: len %d target %d\\n\", dmalen, target);\n\n    if (s->dma) {\n\n        s->dma_memory_read(s->dma_opaque, buf, dmalen);\n\n    } else {\n\n        buf[0] = 0;\n\n        memcpy(&buf[1], s->ti_buf, dmalen);\n\n        dmalen++;\n\n    }\n\n\n\n    s->ti_size = 0;\n\n    s->ti_rptr = 0;\n\n    s->ti_wptr = 0;\n\n\n\n    if (s->current_dev) {\n\n        /* Started a new command before the old one finished.  Cancel it.  */\n\n        s->current_dev->cancel_io(s->current_dev, 0);\n\n        s->async_len = 0;\n\n    }\n\n\n\n    if (target >= ESP_MAX_DEVS || !s->scsi_dev[target]) {\n\n        // No such drive\n\n        s->rregs[ESP_RSTAT] = 0;\n\n        s->rregs[ESP_RINTR] = INTR_DC;\n\n        s->rregs[ESP_RSEQ] = SEQ_0;\n\n        esp_raise_irq(s);\n\n        return 0;\n\n    }\n\n    s->current_dev = s->scsi_dev[target];\n\n    return dmalen;\n\n}\n", "idx": 8438}
{"project": "qemu", "commit_id": "8190483196148f765c65785876f7b893d64b6cdd", "target": 1, "func": "static int net_vhost_check_net(void *opaque, QemuOpts *opts, Error **errp)\n\n{\n\n    const char *name = opaque;\n\n    const char *driver, *netdev;\n\n    const char virtio_name[] = \"virtio-net-\";\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    netdev = qemu_opt_get(opts, \"netdev\");\n\n\n\n    if (!driver || !netdev) {\n\n        return 0;\n\n    }\n\n\n\n    if (strcmp(netdev, name) == 0 &&\n\n        strncmp(driver, virtio_name, strlen(virtio_name)) != 0) {\n\n        error_report(\"vhost-user requires frontend driver virtio-net-*\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2573}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 2543}
{"project": "qemu", "commit_id": "0c53d7342b4e8412f3b81eed67f053304813dc5d", "target": 1, "func": "static void gen_ove_ov(DisasContext *dc, TCGv ov)\n\n{\n\n    gen_helper_ove(cpu_env, ov);\n\n}\n", "idx": 11971}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_fsync(void *opaque)\n{\n    int err;\n    int32_t fid;\n    int datasync;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    pdu_unmarshal(pdu, offset, \"dd\", &fid, &datasync);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fsync(pdu, fidp, datasync);\n    if (!err) {\n        err = offset;\n    }\n    put_fid(pdu, fidp);\nout_nofid:\n    complete_pdu(s, pdu, err);\n}", "idx": 99}
{"project": "qemu", "commit_id": "b1b1dad31f3a092e046b09795f4476705c4e564e", "target": 1, "func": "static int aio_write_f(int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n    BlockDriverAIOCB *acb;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n\n            return command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n\n\n\n    gettimeofday(&ctx->t1, NULL);\n\n    acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n                          ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    if (!acb) {\n\n        free(ctx->buf);\n\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 1955}
{"project": "qemu", "commit_id": "c165f7758009a4f793c1fc19ebb69cf55313450b", "target": 1, "func": "static int dmg_open(BlockDriverState *bs, QDict *options, int flags,\n                    Error **errp)\n{\n    BDRVDMGState *s = bs->opaque;\n    uint64_t info_begin, info_end, last_in_offset, last_out_offset;\n    uint32_t count, tmp;\n    uint32_t max_compressed_size = 1, max_sectors_per_chunk = 1, i;\n    int64_t offset;\n    int ret;\n    bs->read_only = 1;\n    s->n_chunks = 0;\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n    /* read offset of info blocks */\n    offset = bdrv_getlength(bs->file);\n    if (offset < 0) {\n        ret = offset;\n    offset -= 0x1d8;\n    ret = read_uint64(bs, offset, &info_begin);\n    if (ret < 0) {\n    } else if (info_begin == 0) {\n    ret = read_uint32(bs, info_begin, &tmp);\n    if (ret < 0) {\n    } else if (tmp != 0x100) {\n    ret = read_uint32(bs, info_begin + 4, &count);\n    if (ret < 0) {\n    } else if (count == 0) {\n    info_end = info_begin + count;\n    offset = info_begin + 0x100;\n    /* read offsets */\n    last_in_offset = last_out_offset = 0;\n    while (offset < info_end) {\n        uint32_t type;\n        ret = read_uint32(bs, offset, &count);\n        if (ret < 0) {\n        } else if (count == 0) {\n        offset += 4;\n        ret = read_uint32(bs, offset, &type);\n        if (ret < 0) {\n        if (type == 0x6d697368 && count >= 244) {\n            size_t new_size;\n            uint32_t chunk_count;\n            offset += 4;\n            offset += 200;\n            chunk_count = (count - 204) / 40;\n            new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n            s->types = g_realloc(s->types, new_size / 2);\n            s->offsets = g_realloc(s->offsets, new_size);\n            s->lengths = g_realloc(s->lengths, new_size);\n            s->sectors = g_realloc(s->sectors, new_size);\n            s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n            for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) {\n                ret = read_uint32(bs, offset, &s->types[i]);\n                if (ret < 0) {\n                offset += 4;\n                if (s->types[i] != 0x80000005 && s->types[i] != 1 &&\n                    s->types[i] != 2) {\n                    if (s->types[i] == 0xffffffff && i > 0) {\n                        last_in_offset = s->offsets[i - 1] + s->lengths[i - 1];\n                        last_out_offset = s->sectors[i - 1] +\n                                          s->sectorcounts[i - 1];\n                    chunk_count--;\n                    i--;\n                    offset += 36;\n                    continue;\n                offset += 4;\n                ret = read_uint64(bs, offset, &s->sectors[i]);\n                if (ret < 0) {\n                s->sectors[i] += last_out_offset;\n                offset += 8;\n                ret = read_uint64(bs, offset, &s->sectorcounts[i]);\n                if (ret < 0) {\n                offset += 8;\n                if (s->sectorcounts[i] > DMG_SECTORCOUNTS_MAX) {\n                    error_report(\"sector count %\" PRIu64 \" for chunk %u is \"\n                                 \"larger than max (%u)\",\n                                 s->sectorcounts[i], i, DMG_SECTORCOUNTS_MAX);\n                ret = read_uint64(bs, offset, &s->offsets[i]);\n                if (ret < 0) {\n                s->offsets[i] += last_in_offset;\n                offset += 8;\n                ret = read_uint64(bs, offset, &s->lengths[i]);\n                if (ret < 0) {\n                offset += 8;\n                if (s->lengths[i] > max_compressed_size) {\n                    max_compressed_size = s->lengths[i];\n                if (s->sectorcounts[i] > max_sectors_per_chunk) {\n                    max_sectors_per_chunk = s->sectorcounts[i];\n            s->n_chunks += chunk_count;\n    /* initialize zlib engine */\n    s->compressed_chunk = g_malloc(max_compressed_size + 1);\n    s->uncompressed_chunk = g_malloc(512 * max_sectors_per_chunk);\n    if (inflateInit(&s->zstream) != Z_OK) {\n    s->current_chunk = s->n_chunks;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->types);\n    g_free(s->offsets);\n    g_free(s->lengths);\n    g_free(s->sectors);\n    g_free(s->sectorcounts);\n    g_free(s->compressed_chunk);\n    g_free(s->uncompressed_chunk);\n    return ret;", "idx": 4632}
{"project": "qemu", "commit_id": "a8f2e5c8fffbaf7fbd4f0efc8efbeebade78008f", "target": 1, "func": "void virtio_scsi_handle_ctrl_req(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    VirtIODevice *vdev = (VirtIODevice *)s;\n\n    uint32_t type;\n\n    int r = 0;\n\n\n\n    if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,\n\n                &type, sizeof(type)) < sizeof(type)) {\n\n        virtio_scsi_bad_req();\n\n        return;\n\n    }\n\n\n\n    virtio_tswap32s(vdev, &type);\n\n    if (type == VIRTIO_SCSI_T_TMF) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlTMFReq),\n\n                    sizeof(VirtIOSCSICtrlTMFResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            r = virtio_scsi_do_tmf(s, req);\n\n        }\n\n\n\n    } else if (type == VIRTIO_SCSI_T_AN_QUERY ||\n\n               type == VIRTIO_SCSI_T_AN_SUBSCRIBE) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlANReq),\n\n                    sizeof(VirtIOSCSICtrlANResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            req->resp.an.event_actual = 0;\n\n            req->resp.an.response = VIRTIO_SCSI_S_OK;\n\n        }\n\n    }\n\n    if (r == 0) {\n\n        virtio_scsi_complete_req(req);\n\n    } else {\n\n        assert(r == -EINPROGRESS);\n\n    }\n\n}\n", "idx": 388}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static int vnc_set_x509_credential(VncDisplay *vd,\n\n                                   const char *certdir,\n\n                                   const char *filename,\n\n                                   char **cred,\n\n                                   int ignoreMissing)\n\n{\n\n    struct stat sb;\n\n\n\n    g_free(*cred);\n\n    *cred = g_malloc(strlen(certdir) + strlen(filename) + 2);\n\n\n\n    strcpy(*cred, certdir);\n\n    strcat(*cred, \"/\");\n\n    strcat(*cred, filename);\n\n\n\n    VNC_DEBUG(\"Check %s\\n\", *cred);\n\n    if (stat(*cred, &sb) < 0) {\n\n        g_free(*cred);\n\n        *cred = NULL;\n\n        if (ignoreMissing && errno == ENOENT)\n\n            return 0;\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7317}
{"project": "qemu", "commit_id": "4d1628e832dfc6ec02b0d196f6cc250aaa7bf3b3", "target": 1, "func": "static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)\n\n{\n\n    int32_t disp21, disp16, disp12 __attribute__((unused));\n\n    uint16_t fn11;\n\n    uint8_t opc, ra, rb, rc, fpfn, fn7, lit;\n\n    bool islit;\n\n    TCGv va, vb, vc, tmp;\n\n    TCGv_i32 t32;\n\n    ExitStatus ret;\n\n\n\n    /* Decode all instruction fields */\n\n    opc = extract32(insn, 26, 6);\n\n    ra = extract32(insn, 21, 5);\n\n    rb = extract32(insn, 16, 5);\n\n    rc = extract32(insn, 0, 5);\n\n    islit = extract32(insn, 12, 1);\n\n    lit = extract32(insn, 13, 8);\n\n\n\n    disp21 = sextract32(insn, 0, 21);\n\n    disp16 = sextract32(insn, 0, 16);\n\n    disp12 = sextract32(insn, 0, 12);\n\n\n\n    fn11 = extract32(insn, 5, 11);\n\n    fpfn = extract32(insn, 5, 6);\n\n    fn7 = extract32(insn, 5, 7);\n\n\n\n    if (rb == 31 && !islit) {\n\n        islit = true;\n\n        lit = 0;\n\n    }\n\n\n\n    ret = NO_EXIT;\n\n    switch (opc) {\n\n    case 0x00:\n\n        /* CALL_PAL */\n\n        ret = gen_call_pal(ctx, insn & 0x03ffffff);\n\n        break;\n\n    case 0x01:\n\n        /* OPC01 */\n\n        goto invalid_opc;\n\n    case 0x02:\n\n        /* OPC02 */\n\n        goto invalid_opc;\n\n    case 0x03:\n\n        /* OPC03 */\n\n        goto invalid_opc;\n\n    case 0x04:\n\n        /* OPC04 */\n\n        goto invalid_opc;\n\n    case 0x05:\n\n        /* OPC05 */\n\n        goto invalid_opc;\n\n    case 0x06:\n\n        /* OPC06 */\n\n        goto invalid_opc;\n\n    case 0x07:\n\n        /* OPC07 */\n\n        goto invalid_opc;\n\n\n\n    case 0x09:\n\n        /* LDAH */\n\n        disp16 = (uint32_t)disp16 << 16;\n\n        /* fall through */\n\n    case 0x08:\n\n        /* LDA */\n\n        va = dest_gpr(ctx, ra);\n\n        /* It's worth special-casing immediate loads.  */\n\n        if (rb == 31) {\n\n            tcg_gen_movi_i64(va, disp16);\n\n        } else {\n\n            tcg_gen_addi_i64(va, load_gpr(ctx, rb), disp16);\n\n        }\n\n        break;\n\n\n\n    case 0x0A:\n\n        /* LDBU */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0B:\n\n        /* LDQ_U */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x0C:\n\n        /* LDWU */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0D:\n\n        /* STW */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0E:\n\n        /* STB */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0F:\n\n        /* STQ_U */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1);\n\n        break;\n\n\n\n    case 0x10:\n\n        vc = dest_gpr(ctx, rc);\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n\n\n        if (ra == 31) {\n\n            if (fn7 == 0x00) {\n\n                /* Special case ADDL as SEXTL.  */\n\n                tcg_gen_ext32s_i64(vc, vb);\n\n                break;\n\n            }\n\n            if (fn7 == 0x29) {\n\n                /* Special case SUBQ as NEGQ.  */\n\n                tcg_gen_neg_i64(vc, vb);\n\n                break;\n\n            }\n\n        }\n\n\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* ADDL */\n\n            tcg_gen_add_i64(vc, va, vb);\n\n            tcg_gen_ext32s_i64(vc, vc);\n\n            break;\n\n        case 0x02:\n\n            /* S4ADDL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_add_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x09:\n\n            /* SUBL */\n\n            tcg_gen_sub_i64(vc, va, vb);\n\n            tcg_gen_ext32s_i64(vc, vc);\n\n            break;\n\n        case 0x0B:\n\n            /* S4SUBL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_sub_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x0F:\n\n            /* CMPBGE */\n\n            gen_helper_cmpbge(vc, va, vb);\n\n            break;\n\n        case 0x12:\n\n            /* S8ADDL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_add_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x1B:\n\n            /* S8SUBL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_sub_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x1D:\n\n            /* CMPULT */\n\n            tcg_gen_setcond_i64(TCG_COND_LTU, vc, va, vb);\n\n            break;\n\n        case 0x20:\n\n            /* ADDQ */\n\n            tcg_gen_add_i64(vc, va, vb);\n\n            break;\n\n        case 0x22:\n\n            /* S4ADDQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_add_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x29:\n\n            /* SUBQ */\n\n            tcg_gen_sub_i64(vc, va, vb);\n\n            break;\n\n        case 0x2B:\n\n            /* S4SUBQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_sub_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x2D:\n\n            /* CMPEQ */\n\n            tcg_gen_setcond_i64(TCG_COND_EQ, vc, va, vb);\n\n            break;\n\n        case 0x32:\n\n            /* S8ADDQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_add_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x3B:\n\n            /* S8SUBQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_sub_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x3D:\n\n            /* CMPULE */\n\n            tcg_gen_setcond_i64(TCG_COND_LEU, vc, va, vb);\n\n            break;\n\n        case 0x40:\n\n            /* ADDL/V */\n\n            gen_helper_addlv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x49:\n\n            /* SUBL/V */\n\n            gen_helper_sublv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x4D:\n\n            /* CMPLT */\n\n            tcg_gen_setcond_i64(TCG_COND_LT, vc, va, vb);\n\n            break;\n\n        case 0x60:\n\n            /* ADDQ/V */\n\n            gen_helper_addqv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x69:\n\n            /* SUBQ/V */\n\n            gen_helper_subqv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x6D:\n\n            /* CMPLE */\n\n            tcg_gen_setcond_i64(TCG_COND_LE, vc, va, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x11:\n\n        if (fn7 == 0x20) {\n\n            if (rc == 31) {\n\n                /* Special case BIS as NOP.  */\n\n                break;\n\n            }\n\n            if (ra == 31) {\n\n                /* Special case BIS as MOV.  */\n\n                vc = dest_gpr(ctx, rc);\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(vc, lit);\n\n                } else {\n\n                    tcg_gen_mov_i64(vc, load_gpr(ctx, rb));\n\n                }\n\n                break;\n\n            }\n\n        }\n\n\n\n        vc = dest_gpr(ctx, rc);\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n\n\n        if (fn7 == 0x28 && ra == 31) {\n\n            /* Special case ORNOT as NOT.  */\n\n            tcg_gen_not_i64(vc, vb);\n\n            break;\n\n        }\n\n\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* AND */\n\n            tcg_gen_and_i64(vc, va, vb);\n\n            break;\n\n        case 0x08:\n\n            /* BIC */\n\n            tcg_gen_andc_i64(vc, va, vb);\n\n            break;\n\n        case 0x14:\n\n            /* CMOVLBS */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_andi_i64(tmp, va, 1);\n\n            tcg_gen_movcond_i64(TCG_COND_NE, vc, tmp, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x16:\n\n            /* CMOVLBC */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_andi_i64(tmp, va, 1);\n\n            tcg_gen_movcond_i64(TCG_COND_EQ, vc, tmp, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x20:\n\n            /* BIS */\n\n            tcg_gen_or_i64(vc, va, vb);\n\n            break;\n\n        case 0x24:\n\n            /* CMOVEQ */\n\n            tcg_gen_movcond_i64(TCG_COND_EQ, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x26:\n\n            /* CMOVNE */\n\n            tcg_gen_movcond_i64(TCG_COND_NE, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x28:\n\n            /* ORNOT */\n\n            tcg_gen_orc_i64(vc, va, vb);\n\n            break;\n\n        case 0x40:\n\n            /* XOR */\n\n            tcg_gen_xor_i64(vc, va, vb);\n\n            break;\n\n        case 0x44:\n\n            /* CMOVLT */\n\n            tcg_gen_movcond_i64(TCG_COND_LT, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x46:\n\n            /* CMOVGE */\n\n            tcg_gen_movcond_i64(TCG_COND_GE, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x48:\n\n            /* EQV */\n\n            tcg_gen_eqv_i64(vc, va, vb);\n\n            break;\n\n        case 0x61:\n\n            /* AMASK */\n\n            REQUIRE_REG_31(ra);\n\n            {\n\n                uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT;\n\n                tcg_gen_andi_i64(vc, vb, ~amask);\n\n            }\n\n            break;\n\n        case 0x64:\n\n            /* CMOVLE */\n\n            tcg_gen_movcond_i64(TCG_COND_LE, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x66:\n\n            /* CMOVGT */\n\n            tcg_gen_movcond_i64(TCG_COND_GT, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x6C:\n\n            /* IMPLVER */\n\n            REQUIRE_REG_31(ra);\n\n            tcg_gen_movi_i64(vc, ctx->implver);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x12:\n\n        vc = dest_gpr(ctx, rc);\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x02:\n\n            /* MSKBL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0x01);\n\n            break;\n\n        case 0x06:\n\n            /* EXTBL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0x01);\n\n            break;\n\n        case 0x0B:\n\n            /* INSBL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0x01);\n\n            break;\n\n        case 0x12:\n\n            /* MSKWL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x16:\n\n            /* EXTWL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x1B:\n\n            /* INSWL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x22:\n\n            /* MSKLL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x26:\n\n            /* EXTLL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x2B:\n\n            /* INSLL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x30:\n\n            /* ZAP */\n\n            if (islit) {\n\n                gen_zapnoti(vc, va, ~lit);\n\n            } else {\n\n                gen_helper_zap(vc, va, load_gpr(ctx, rb));\n\n            }\n\n            break;\n\n        case 0x31:\n\n            /* ZAPNOT */\n\n            if (islit) {\n\n                gen_zapnoti(vc, va, lit);\n\n            } else {\n\n                gen_helper_zapnot(vc, va, load_gpr(ctx, rb));\n\n            }\n\n            break;\n\n        case 0x32:\n\n            /* MSKQL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x34:\n\n            /* SRL */\n\n            if (islit) {\n\n                tcg_gen_shri_i64(vc, va, lit & 0x3f);\n\n            } else {\n\n                tmp = tcg_temp_new();\n\n                vb = load_gpr(ctx, rb);\n\n                tcg_gen_andi_i64(tmp, vb, 0x3f);\n\n                tcg_gen_shr_i64(vc, va, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x36:\n\n            /* EXTQL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x39:\n\n            /* SLL */\n\n            if (islit) {\n\n                tcg_gen_shli_i64(vc, va, lit & 0x3f);\n\n            } else {\n\n                tmp = tcg_temp_new();\n\n                vb = load_gpr(ctx, rb);\n\n                tcg_gen_andi_i64(tmp, vb, 0x3f);\n\n                tcg_gen_shl_i64(vc, va, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* INSQL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x3C:\n\n            /* SRA */\n\n            if (islit) {\n\n                tcg_gen_sari_i64(vc, va, lit & 0x3f);\n\n            } else {\n\n                tmp = tcg_temp_new();\n\n                vb = load_gpr(ctx, rb);\n\n                tcg_gen_andi_i64(tmp, vb, 0x3f);\n\n                tcg_gen_sar_i64(vc, va, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x52:\n\n            /* MSKWH */\n\n            gen_msk_h(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x57:\n\n            /* INSWH */\n\n            gen_ins_h(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x5A:\n\n            /* EXTWH */\n\n            gen_ext_h(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x62:\n\n            /* MSKLH */\n\n            gen_msk_h(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x67:\n\n            /* INSLH */\n\n            gen_ins_h(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x6A:\n\n            /* EXTLH */\n\n            gen_ext_h(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x72:\n\n            /* MSKQH */\n\n            gen_msk_h(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x77:\n\n            /* INSQH */\n\n            gen_ins_h(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x7A:\n\n            /* EXTQH */\n\n            gen_ext_h(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x13:\n\n        vc = dest_gpr(ctx, rc);\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* MULL */\n\n            tcg_gen_mul_i64(vc, va, vb);\n\n            tcg_gen_ext32s_i64(vc, vc);\n\n            break;\n\n        case 0x20:\n\n            /* MULQ */\n\n            tcg_gen_mul_i64(vc, va, vb);\n\n            break;\n\n        case 0x30:\n\n            /* UMULH */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_mulu2_i64(tmp, vc, va, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x40:\n\n            /* MULL/V */\n\n            gen_helper_mullv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x60:\n\n            /* MULQ/V */\n\n            gen_helper_mulqv(vc, cpu_env, va, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x14:\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_FIX);\n\n        vc = dest_fpr(ctx, rc);\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x04:\n\n            /* ITOFS */\n\n            REQUIRE_REG_31(rb);\n\n            t32 = tcg_temp_new_i32();\n\n            va = load_gpr(ctx, ra);\n\n            tcg_gen_trunc_i64_i32(t32, va);\n\n            gen_helper_memory_to_s(vc, t32);\n\n            tcg_temp_free_i32(t32);\n\n            break;\n\n        case 0x0A:\n\n            /* SQRTF */\n\n            REQUIRE_REG_31(ra);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_helper_sqrtf(vc, cpu_env, vb);\n\n            break;\n\n        case 0x0B:\n\n            /* SQRTS */\n\n            REQUIRE_REG_31(ra);\n\n            gen_sqrts(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x14:\n\n            /* ITOFF */\n\n            REQUIRE_REG_31(rb);\n\n            t32 = tcg_temp_new_i32();\n\n            va = load_gpr(ctx, ra);\n\n            tcg_gen_trunc_i64_i32(t32, va);\n\n            gen_helper_memory_to_f(vc, t32);\n\n            tcg_temp_free_i32(t32);\n\n            break;\n\n        case 0x24:\n\n            /* ITOFT */\n\n            REQUIRE_REG_31(rb);\n\n            va = load_gpr(ctx, ra);\n\n            tcg_gen_mov_i64(vc, va);\n\n            break;\n\n        case 0x2A:\n\n            /* SQRTG */\n\n            REQUIRE_REG_31(ra);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_helper_sqrtg(vc, cpu_env, vb);\n\n            break;\n\n        case 0x02B:\n\n            /* SQRTT */\n\n            REQUIRE_REG_31(ra);\n\n            gen_sqrtt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x15:\n\n        /* VAX floating point */\n\n        /* XXX: rounding mode and trap are ignored (!) */\n\n        vc = dest_fpr(ctx, rc);\n\n        vb = load_fpr(ctx, rb);\n\n        va = load_fpr(ctx, ra);\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDF */\n\n            gen_helper_addf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x01:\n\n            /* SUBF */\n\n            gen_helper_subf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x02:\n\n            /* MULF */\n\n            gen_helper_mulf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x03:\n\n            /* DIVF */\n\n            gen_helper_divf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x1E:\n\n            /* CVTDG -- TODO */\n\n            REQUIRE_REG_31(ra);\n\n            goto invalid_opc;\n\n        case 0x20:\n\n            /* ADDG */\n\n            gen_helper_addg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x21:\n\n            /* SUBG */\n\n            gen_helper_subg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x22:\n\n            /* MULG */\n\n            gen_helper_mulg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x23:\n\n            /* DIVG */\n\n            gen_helper_divg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x25:\n\n            /* CMPGEQ */\n\n            gen_helper_cmpgeq(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x26:\n\n            /* CMPGLT */\n\n            gen_helper_cmpglt(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x27:\n\n            /* CMPGLE */\n\n            gen_helper_cmpgle(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x2C:\n\n            /* CVTGF */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtgf(vc, cpu_env, vb);\n\n            break;\n\n        case 0x2D:\n\n            /* CVTGD -- TODO */\n\n            REQUIRE_REG_31(ra);\n\n            goto invalid_opc;\n\n        case 0x2F:\n\n            /* CVTGQ */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtgq(vc, cpu_env, vb);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQF */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtqf(vc, cpu_env, vb);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQG */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtqg(vc, cpu_env, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x16:\n\n        /* IEEE floating-point */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDS */\n\n            gen_adds(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x01:\n\n            /* SUBS */\n\n            gen_subs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x02:\n\n            /* MULS */\n\n            gen_muls(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x03:\n\n            /* DIVS */\n\n            gen_divs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x20:\n\n            /* ADDT */\n\n            gen_addt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x21:\n\n            /* SUBT */\n\n            gen_subt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x22:\n\n            /* MULT */\n\n            gen_mult(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x23:\n\n            /* DIVT */\n\n            gen_divt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x24:\n\n            /* CMPTUN */\n\n            gen_cmptun(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x25:\n\n            /* CMPTEQ */\n\n            gen_cmpteq(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x26:\n\n            /* CMPTLT */\n\n            gen_cmptlt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x27:\n\n            /* CMPTLE */\n\n            gen_cmptle(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x2C:\n\n            REQUIRE_REG_31(ra);\n\n            if (fn11 == 0x2AC || fn11 == 0x6AC) {\n\n                /* CVTST */\n\n                gen_cvtst(ctx, rb, rc, fn11);\n\n            } else {\n\n                /* CVTTS */\n\n                gen_cvtts(ctx, rb, rc, fn11);\n\n            }\n\n            break;\n\n        case 0x2F:\n\n            /* CVTTQ */\n\n            REQUIRE_REG_31(ra);\n\n            gen_cvttq(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQS */\n\n            REQUIRE_REG_31(ra);\n\n            gen_cvtqs(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQT */\n\n            REQUIRE_REG_31(ra);\n\n            gen_cvtqt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x17:\n\n        switch (fn11) {\n\n        case 0x010:\n\n            /* CVTLQ */\n\n            REQUIRE_REG_31(ra);\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_cvtlq(vc, vb);\n\n            break;\n\n        case 0x020:\n\n            /* CPYS */\n\n            if (rc == 31) {\n\n                /* Special case CPYS as FNOP.  */\n\n            } else {\n\n                vc = dest_fpr(ctx, rc);\n\n                va = load_fpr(ctx, ra);\n\n                if (ra == rb) {\n\n                    /* Special case CPYS as FMOV.  */\n\n                    tcg_gen_mov_i64(vc, va);\n\n                } else {\n\n                    vb = load_fpr(ctx, rb);\n\n                    gen_cpy_mask(vc, va, vb, 0, 0x8000000000000000ULL);\n\n                }\n\n            }\n\n            break;\n\n        case 0x021:\n\n            /* CPYSN */\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            va = load_fpr(ctx, ra);\n\n            gen_cpy_mask(vc, va, vb, 1, 0x8000000000000000ULL);\n\n            break;\n\n        case 0x022:\n\n            /* CPYSE */\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            va = load_fpr(ctx, ra);\n\n            gen_cpy_mask(vc, va, vb, 0, 0xFFF0000000000000ULL);\n\n            break;\n\n        case 0x024:\n\n            /* MT_FPCR */\n\n            va = load_fpr(ctx, ra);\n\n            gen_helper_store_fpcr(cpu_env, va);\n\n            if (ctx->tb_rm == QUAL_RM_D) {\n\n                /* Re-do the copy of the rounding mode to fp_status\n\n                   the next time we use dynamic rounding.  */\n\n                ctx->tb_rm = -1;\n\n            }\n\n            break;\n\n        case 0x025:\n\n            /* MF_FPCR */\n\n            va = dest_fpr(ctx, ra);\n\n            gen_helper_load_fpcr(va, cpu_env);\n\n            break;\n\n        case 0x02A:\n\n            /* FCMOVEQ */\n\n            gen_fcmov(ctx, TCG_COND_EQ, ra, rb, rc);\n\n            break;\n\n        case 0x02B:\n\n            /* FCMOVNE */\n\n            gen_fcmov(ctx, TCG_COND_NE, ra, rb, rc);\n\n            break;\n\n        case 0x02C:\n\n            /* FCMOVLT */\n\n            gen_fcmov(ctx, TCG_COND_LT, ra, rb, rc);\n\n            break;\n\n        case 0x02D:\n\n            /* FCMOVGE */\n\n            gen_fcmov(ctx, TCG_COND_GE, ra, rb, rc);\n\n            break;\n\n        case 0x02E:\n\n            /* FCMOVLE */\n\n            gen_fcmov(ctx, TCG_COND_LE, ra, rb, rc);\n\n            break;\n\n        case 0x02F:\n\n            /* FCMOVGT */\n\n            gen_fcmov(ctx, TCG_COND_GT, ra, rb, rc);\n\n            break;\n\n        case 0x030:\n\n            /* CVTQL */\n\n            REQUIRE_REG_31(ra);\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_cvtql(vc, vb);\n\n            break;\n\n        case 0x130:\n\n            /* CVTQL/V */\n\n        case 0x530:\n\n            /* CVTQL/SV */\n\n            REQUIRE_REG_31(ra);\n\n            /* ??? I'm pretty sure there's nothing that /sv needs to do that\n\n               /v doesn't do.  The only thing I can think is that /sv is a\n\n               valid instruction merely for completeness in the ISA.  */\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_helper_cvtql_v_input(cpu_env, vb);\n\n            gen_cvtql(vc, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x18:\n\n        switch ((uint16_t)disp16) {\n\n        case 0x0000:\n\n            /* TRAPB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x0400:\n\n            /* EXCB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x4000:\n\n            /* MB */\n\n            /* No-op */\n\n            break;\n\n        case 0x4400:\n\n            /* WMB */\n\n            /* No-op */\n\n            break;\n\n        case 0x8000:\n\n            /* FETCH */\n\n            /* No-op */\n\n            break;\n\n        case 0xA000:\n\n            /* FETCH_M */\n\n            /* No-op */\n\n            break;\n\n        case 0xC000:\n\n            /* RPCC */\n\n            va = dest_gpr(ctx, ra);\n\n            if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n                gen_helper_load_pcc(va, cpu_env);\n\n                gen_io_end();\n\n                ret = EXIT_PC_STALE;\n\n            } else {\n\n                gen_helper_load_pcc(va, cpu_env);\n\n            }\n\n            break;\n\n        case 0xE000:\n\n            /* RC */\n\n            gen_rx(ra, 0);\n\n            break;\n\n        case 0xE800:\n\n            /* ECB */\n\n            break;\n\n        case 0xF000:\n\n            /* RS */\n\n            gen_rx(ra, 1);\n\n            break;\n\n        case 0xF800:\n\n            /* WH64 */\n\n            /* No-op */\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x19:\n\n        /* HW_MFPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        va = dest_gpr(ctx, ra);\n\n        ret = gen_mfpr(ctx, va, insn & 0xffff);\n\n        break;\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1A:\n\n        /* JMP, JSR, RET, JSR_COROUTINE.  These only differ by the branch\n\n           prediction stack action, which of course we don't implement.  */\n\n        vb = load_gpr(ctx, rb);\n\n        tcg_gen_andi_i64(cpu_pc, vb, ~3);\n\n        if (ra != 31) {\n\n            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc);\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n\n\n    case 0x1B:\n\n        /* HW_LD (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        {\n\n            TCGv addr = tcg_temp_new();\n\n            vb = load_gpr(ctx, rb);\n\n            va = dest_gpr(ctx, ra);\n\n\n\n            tcg_gen_addi_i64(addr, vb, disp12);\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access (hw_ldl/p) */\n\n                gen_helper_ldl_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access (hw_ldq/p) */\n\n                gen_helper_ldq_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock (hw_ldl_l/p) */\n\n                gen_helper_ldl_l_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock (hw_ldq_l/p) */\n\n                gen_helper_ldq_l_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual PTE fetch (hw_ldl/v) */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual PTE fetch (hw_ldq/v) */\n\n                goto invalid_opc;\n\n                break;\n\n            case 0x6:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Longword virtual access (hw_ldl) */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Quadword virtual access (hw_ldq) */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Longword virtual access with protection check (hw_ldl/w) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_KERNEL_IDX, MO_LESL);\n\n                break;\n\n            case 0xB:\n\n                /* Quadword virtual access with protection check (hw_ldq/w) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_KERNEL_IDX, MO_LEQ);\n\n                break;\n\n            case 0xC:\n\n                /* Longword virtual access with alt access mode (hw_ldl/a)*/\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alt access mode (hw_ldq/a) */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Longword virtual access with alternate access mode and\n\n                   protection checks (hw_ldl/wa) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_USER_IDX, MO_LESL);\n\n                break;\n\n            case 0xF:\n\n                /* Quadword virtual access with alternate access mode and\n\n                   protection checks (hw_ldq/wa) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_USER_IDX, MO_LEQ);\n\n                break;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1C:\n\n        vc = dest_gpr(ctx, rc);\n\n        if (fn7 == 0x70) {\n\n            /* FTOIT */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_FIX);\n\n            REQUIRE_REG_31(rb);\n\n            va = load_fpr(ctx, ra);\n\n            tcg_gen_mov_i64(vc, va);\n\n            break;\n\n        } else if (fn7 == 0x78) {\n\n            /* FTOIS */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_FIX);\n\n            REQUIRE_REG_31(rb);\n\n            t32 = tcg_temp_new_i32();\n\n            va = load_fpr(ctx, ra);\n\n            gen_helper_s_to_memory(t32, va);\n\n            tcg_gen_ext_i32_i64(vc, t32);\n\n            tcg_temp_free_i32(t32);\n\n            break;\n\n        }\n\n\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* SEXTB */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n            REQUIRE_REG_31(ra);\n\n            tcg_gen_ext8s_i64(vc, vb);\n\n            break;\n\n        case 0x01:\n\n            /* SEXTW */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n            REQUIRE_REG_31(ra);\n\n            tcg_gen_ext16s_i64(vc, vb);\n\n            break;\n\n        case 0x30:\n\n            /* CTPOP */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_CIX);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_ctpop(vc, vb);\n\n            break;\n\n        case 0x31:\n\n            /* PERR */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_perr(vc, va, vb);\n\n            break;\n\n        case 0x32:\n\n            /* CTLZ */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_CIX);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_ctlz(vc, vb);\n\n            break;\n\n        case 0x33:\n\n            /* CTTZ */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_CIX);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cttz(vc, vb);\n\n            break;\n\n        case 0x34:\n\n            /* UNPKBW */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_unpkbw(vc, vb);\n\n            break;\n\n        case 0x35:\n\n            /* UNPKBL */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_unpkbl(vc, vb);\n\n            break;\n\n        case 0x36:\n\n            /* PKWB */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_pkwb(vc, vb);\n\n            break;\n\n        case 0x37:\n\n            /* PKLB */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_pklb(vc, vb);\n\n            break;\n\n        case 0x38:\n\n            /* MINSB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minsb8(vc, va, vb);\n\n            break;\n\n        case 0x39:\n\n            /* MINSW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minsw4(vc, va, vb);\n\n            break;\n\n        case 0x3A:\n\n            /* MINUB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minub8(vc, va, vb);\n\n            break;\n\n        case 0x3B:\n\n            /* MINUW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minuw4(vc, va, vb);\n\n            break;\n\n        case 0x3C:\n\n            /* MAXUB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxub8(vc, va, vb);\n\n            break;\n\n        case 0x3D:\n\n            /* MAXUW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxuw4(vc, va, vb);\n\n            break;\n\n        case 0x3E:\n\n            /* MAXSB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxsb8(vc, va, vb);\n\n            break;\n\n        case 0x3F:\n\n            /* MAXSW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxsw4(vc, va, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x1D:\n\n        /* HW_MTPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        vb = load_gpr(ctx, rb);\n\n        ret = gen_mtpr(ctx, vb, insn & 0xffff);\n\n        break;\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1E:\n\n        /* HW_RET (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        if (rb == 31) {\n\n            /* Pre-EV6 CPUs interpreted this as HW_REI, loading the return\n\n               address from EXC_ADDR.  This turns out to be useful for our\n\n               emulation PALcode, so continue to accept it.  */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr));\n\n            gen_helper_hw_ret(cpu_env, tmp);\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            gen_helper_hw_ret(cpu_env, load_gpr(ctx, rb));\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1F:\n\n        /* HW_ST (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        {\n\n            TCGv addr = tcg_temp_new();\n\n            va = load_gpr(ctx, ra);\n\n            vb = load_gpr(ctx, rb);\n\n\n\n            tcg_gen_addi_i64(addr, vb, disp12);\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access */\n\n                gen_helper_stl_phys(cpu_env, addr, va);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access */\n\n                gen_helper_stq_phys(cpu_env, addr, va);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock */\n\n                gen_helper_stl_c_phys(dest_gpr(ctx, ra), cpu_env, addr, va);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock */\n\n                gen_helper_stq_c_phys(dest_gpr(ctx, ra), cpu_env, addr, va);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual access */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual access */\n\n                goto invalid_opc;\n\n            case 0x6:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xB:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xC:\n\n                /* Longword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xF:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n    case 0x20:\n\n        /* LDF */\n\n        gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x21:\n\n        /* LDG */\n\n        gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x22:\n\n        /* LDS */\n\n        gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x23:\n\n        /* LDT */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x24:\n\n        /* STF */\n\n        gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x25:\n\n        /* STG */\n\n        gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x26:\n\n        /* STS */\n\n        gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x27:\n\n        /* STT */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x28:\n\n        /* LDL */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x29:\n\n        /* LDQ */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2A:\n\n        /* LDL_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2B:\n\n        /* LDQ_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2C:\n\n        /* STL */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2D:\n\n        /* STQ */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2E:\n\n        /* STL_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 0);\n\n        break;\n\n    case 0x2F:\n\n        /* STQ_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 1);\n\n        break;\n\n    case 0x30:\n\n        /* BR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x31: /* FBEQ */\n\n        ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21);\n\n        break;\n\n    case 0x32: /* FBLT */\n\n        ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21);\n\n        break;\n\n    case 0x33: /* FBLE */\n\n        ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21);\n\n        break;\n\n    case 0x34:\n\n        /* BSR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11342}
{"project": "qemu", "commit_id": "7f0317cfc8da620cdb38cb5cfec5f82b8dd05403", "target": 1, "func": "void *block_job_create(const BlockJobDriver *driver, BlockDriverState *bs,\n\n                       int64_t speed, BlockCompletionFunc *cb,\n\n                       void *opaque, Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockJob *job;\n\n\n\n    assert(cb);\n\n    if (bs->job) {\n\n        error_setg(errp, QERR_DEVICE_IN_USE, bdrv_get_device_name(bs));\n\n        return NULL;\n\n    }\n\n\n\n    blk = blk_new();\n\n    blk_insert_bs(blk, bs);\n\n\n\n    job = g_malloc0(driver->instance_size);\n\n    error_setg(&job->blocker, \"block device is in use by block job: %s\",\n\n               BlockJobType_lookup[driver->job_type]);\n\n    bdrv_op_block_all(bs, job->blocker);\n\n    bdrv_op_unblock(bs, BLOCK_OP_TYPE_DATAPLANE, job->blocker);\n\n\n\n    job->driver        = driver;\n\n    job->id            = g_strdup(bdrv_get_device_name(bs));\n\n    job->blk           = blk;\n\n    job->cb            = cb;\n\n    job->opaque        = opaque;\n\n    job->busy          = true;\n\n    job->refcnt        = 1;\n\n    bs->job = job;\n\n\n\n    QLIST_INSERT_HEAD(&block_jobs, job, job_list);\n\n\n\n    blk_add_aio_context_notifier(blk, block_job_attached_aio_context,\n\n                                 block_job_detach_aio_context, job);\n\n\n\n    /* Only set speed when necessary to avoid NotSupported error */\n\n    if (speed != 0) {\n\n        Error *local_err = NULL;\n\n\n\n        block_job_set_speed(job, speed, &local_err);\n\n        if (local_err) {\n\n            block_job_unref(job);\n\n            error_propagate(errp, local_err);\n\n            return NULL;\n\n        }\n\n    }\n\n    return job;\n\n}\n", "idx": 10664}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "static void iscsi_timed_set_events(void *opaque)\n\n{\n\n    IscsiLun *iscsilun = opaque;\n\n    iscsi_set_events(iscsilun);\n\n}\n", "idx": 6749}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id, int fail_if_exists)\n\n{\n\n    QemuOpts *opts = NULL;\n\n\n\n    if (id) {\n\n        if (!id_wellformed(id)) {\n\n            qerror_report(QERR_INVALID_PARAMETER_VALUE, \"id\", \"an identifier\");\n\n            error_printf_unless_qmp(\"Identifiers consist of letters, digits, '-', '.', '_', starting with a letter.\\n\");\n\n            return NULL;\n\n        }\n\n        opts = qemu_opts_find(list, id);\n\n        if (opts != NULL) {\n\n            if (fail_if_exists && !list->merge_lists) {\n\n                qerror_report(QERR_DUPLICATE_ID, id, list->name);\n\n                return NULL;\n\n            } else {\n\n                return opts;\n\n            }\n\n        }\n\n    } else if (list->merge_lists) {\n\n        opts = qemu_opts_find(list, NULL);\n\n        if (opts) {\n\n            return opts;\n\n        }\n\n    }\n\n    opts = g_malloc0(sizeof(*opts));\n\n    if (id) {\n\n        opts->id = g_strdup(id);\n\n    }\n\n    opts->list = list;\n\n    loc_save(&opts->loc);\n\n    QTAILQ_INIT(&opts->head);\n\n    QTAILQ_INSERT_TAIL(&list->head, opts, next);\n\n    return opts;\n\n}\n", "idx": 1918}
{"project": "qemu", "commit_id": "d8fd2954996255ba6ad610917e7849832d0120b7", "target": 1, "func": "static void do_interrupt_v7m(CPUARMState *env)\n\n{\n\n    uint32_t xpsr = xpsr_read(env);\n\n    uint32_t lr;\n\n    uint32_t addr;\n\n\n\n    lr = 0xfffffff1;\n\n    if (env->v7m.current_sp)\n\n        lr |= 4;\n\n    if (env->v7m.exception == 0)\n\n        lr |= 8;\n\n\n\n    /* For exceptions we just mark as pending on the NVIC, and let that\n\n       handle it.  */\n\n    /* TODO: Need to escalate if the current priority is higher than the\n\n       one we're raising.  */\n\n    switch (env->exception_index) {\n\n    case EXCP_UDEF:\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE);\n\n        return;\n\n    case EXCP_SWI:\n\n        env->regs[15] += 2;\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SVC);\n\n        return;\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_MEM);\n\n        return;\n\n    case EXCP_BKPT:\n\n        if (semihosting_enabled) {\n\n            int nr;\n\n            nr = lduw_code(env->regs[15]) & 0xff;\n\n            if (nr == 0xab) {\n\n                env->regs[15] += 2;\n\n                env->regs[0] = do_arm_semihosting(env);\n\n                return;\n\n            }\n\n        }\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_DEBUG);\n\n        return;\n\n    case EXCP_IRQ:\n\n        env->v7m.exception = armv7m_nvic_acknowledge_irq(env->nvic);\n\n        break;\n\n    case EXCP_EXCEPTION_EXIT:\n\n        do_v7m_exception_exit(env);\n\n        return;\n\n    default:\n\n        cpu_abort(env, \"Unhandled exception 0x%x\\n\", env->exception_index);\n\n        return; /* Never happens.  Keep compiler happy.  */\n\n    }\n\n\n\n    /* Align stack pointer.  */\n\n    /* ??? Should only do this if Configuration Control Register\n\n       STACKALIGN bit is set.  */\n\n    if (env->regs[13] & 4) {\n\n        env->regs[13] -= 4;\n\n        xpsr |= 0x200;\n\n    }\n\n    /* Switch to the handler mode.  */\n\n    v7m_push(env, xpsr);\n\n    v7m_push(env, env->regs[15]);\n\n    v7m_push(env, env->regs[14]);\n\n    v7m_push(env, env->regs[12]);\n\n    v7m_push(env, env->regs[3]);\n\n    v7m_push(env, env->regs[2]);\n\n    v7m_push(env, env->regs[1]);\n\n    v7m_push(env, env->regs[0]);\n\n    switch_v7m_sp(env, 0);\n\n    /* Clear IT bits */\n\n    env->condexec_bits = 0;\n\n    env->regs[14] = lr;\n\n    addr = ldl_phys(env->v7m.vecbase + env->v7m.exception * 4);\n\n    env->regs[15] = addr & 0xfffffffe;\n\n    env->thumb = addr & 1;\n\n}\n", "idx": 11182}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_listen_opts(QemuOpts *opts, int port_offset)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    const char *addr;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten,rc,to,try_next;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (qemu_opt_get(opts, \"port\") == NULL) {\n\n        fprintf(stderr, \"%s: host and/or port not specified\\n\", __FUNCTION__);\n\n        return -1;\n\n    }\n\n    pstrcpy(port, sizeof(port), qemu_opt_get(opts, \"port\"));\n\n    addr = qemu_opt_get(opts, \"host\");\n\n\n\n    to = qemu_opt_get_number(opts, \"to\", 0);\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    /* lookup */\n\n    if (port_offset)\n\n        snprintf(port, sizeof(port), \"%d\", atoi(port) + port_offset);\n\n    rc = getaddrinfo(strlen(addr) ? addr : NULL, port, &ai, &res);\n\n    if (rc != 0) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug)\n\n        inet_print_addrinfo(__FUNCTION__, res);\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                    inet_strfamily(e->ai_family), strerror(errno));\n\n            continue;\n\n        }\n\n\n\n        setsockopt(slisten,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n#ifdef IPV6_V6ONLY\n\n        if (e->ai_family == PF_INET6) {\n\n            /* listen on both ipv4 and ipv6 */\n\n            setsockopt(slisten,IPPROTO_IPV6,IPV6_V6ONLY,(void*)&off,\n\n                sizeof(off));\n\n        }\n\n#endif\n\n\n\n        for (;;) {\n\n            if (bind(slisten, e->ai_addr, e->ai_addrlen) == 0) {\n\n                if (sockets_debug)\n\n                    fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                        inet_strfamily(e->ai_family), uaddr, inet_getport(e));\n\n                goto listen;\n\n            }\n\n            try_next = to && (inet_getport(e) <= to + port_offset);\n\n            if (!try_next || sockets_debug)\n\n                fprintf(stderr,\"%s: bind(%s,%s,%d): %s\\n\", __FUNCTION__,\n\n                        inet_strfamily(e->ai_family), uaddr, inet_getport(e),\n\n                        strerror(errno));\n\n            if (try_next) {\n\n                inet_setport(e, inet_getport(e) + 1);\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    fprintf(stderr, \"%s: FAILED\\n\", __FUNCTION__);\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        perror(\"listen\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    snprintf(uport, sizeof(uport), \"%d\", inet_getport(e) - port_offset);\n\n    qemu_opt_set(opts, \"host\", uaddr);\n\n    qemu_opt_set(opts, \"port\", uport);\n\n    qemu_opt_set(opts, \"ipv6\", (e->ai_family == PF_INET6) ? \"on\" : \"off\");\n\n    qemu_opt_set(opts, \"ipv4\", (e->ai_family != PF_INET6) ? \"on\" : \"off\");\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 1506}
{"project": "qemu", "commit_id": "5bfb723f07fde2caafa90cb40c102a4e36dfea9e", "target": 1, "func": "static void mm_rearm_timer(struct qemu_alarm_timer *t, int64_t delta)\n\n{\n\n    int nearest_delta_ms = (delta + 999999) / 1000000;\n\n    if (nearest_delta_ms < 1) {\n\n        nearest_delta_ms = 1;\n\n    }\n\n\n\n    timeKillEvent(mm_timer);\n\n    mm_timer = timeSetEvent(nearest_delta_ms,\n\n                            mm_period,\n\n                            mm_alarm_handler,\n\n                            (DWORD_PTR)t,\n\n                            TIME_ONESHOT | TIME_CALLBACK_FUNCTION);\n\n\n\n    if (!mm_timer) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(mm_period);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 8801}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "void usb_cancel_packet(USBPacket * p)\n\n{\n\n    assert(p->owner != NULL);\n\n    usb_device_cancel_packet(p->owner->dev, p);\n\n    p->owner = NULL;\n\n}\n", "idx": 5768}
{"project": "qemu", "commit_id": "490309fcfbed9fa1ed357541f609975016a34628", "target": 1, "func": "int qemu_poll_ns(GPollFD *fds, guint nfds, int64_t timeout)\n\n{\n\n#ifdef CONFIG_PPOLL\n\n    if (timeout < 0) {\n\n        return ppoll((struct pollfd *)fds, nfds, NULL, NULL);\n\n    } else {\n\n        struct timespec ts;\n\n        ts.tv_sec = timeout / 1000000000LL;\n\n        ts.tv_nsec = timeout % 1000000000LL;\n\n        return ppoll((struct pollfd *)fds, nfds, &ts, NULL);\n\n    }\n\n#else\n\n    return g_poll(fds, nfds, qemu_timeout_ns_to_ms(timeout));\n\n#endif\n\n}\n", "idx": 12244}
{"project": "qemu", "commit_id": "46daff13c854769bfa8c51e77719325ea0f47b1b", "target": 1, "func": "static void qemu_tcg_wait_io_event(void)\n\n{\n\n    CPUState *env;\n\n\n\n    while (all_cpu_threads_idle()) {\n\n       /* Start accounting real time to the virtual clock if the CPUs\n\n          are idle.  */\n\n        qemu_clock_warp(vm_clock);\n\n        qemu_cond_wait(tcg_halt_cond, &qemu_global_mutex);\n\n    }\n\n\n\n    qemu_mutex_unlock(&qemu_global_mutex);\n\n\n\n    /*\n\n     * Users of qemu_global_mutex can be starved, having no chance\n\n     * to acquire it since this path will get to it first.\n\n     * So use another lock to provide fairness.\n\n     */\n\n    qemu_mutex_lock(&qemu_fair_mutex);\n\n    qemu_mutex_unlock(&qemu_fair_mutex);\n\n\n\n    qemu_mutex_lock(&qemu_global_mutex);\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        qemu_wait_io_event_common(env);\n\n    }\n\n}\n", "idx": 2402}
{"project": "qemu", "commit_id": "17cce735780f0ff6a2ef173c34614bd47acd56e5", "target": 1, "func": "static void vdi_close(BlockDriverState *bs)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n\n\n    g_free(s->bmap);\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 549}
{"project": "qemu", "commit_id": "8f68760561abf90156456fec6ad55c3b2a066d46", "target": 1, "func": "static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n", "idx": 5986}
{"project": "qemu", "commit_id": "f575f145f4fa97fdbb9bbb4df62dfeada3f15dc4", "target": 1, "func": "static bool is_zero_cluster(BlockDriverState *bs, int64_t start)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int nr;\n\n    BlockDriverState *file;\n\n    int64_t res = bdrv_get_block_status_above(bs, NULL, start,\n\n                                              s->cluster_sectors, &nr, &file);\n\n    return res >= 0 && ((res & BDRV_BLOCK_ZERO) || !(res & BDRV_BLOCK_DATA));\n\n}\n", "idx": 9121}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_decr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return cpu_ppc_load_decr(env);\n\n}\n", "idx": 9843}
{"project": "qemu", "commit_id": "7717f248eebdcfe6de400404d0cf65dcb3633308", "target": 1, "func": "static void openrisc_pic_cpu_handler(void *opaque, int irq, int level)\n\n{\n\n    OpenRISCCPU *cpu = (OpenRISCCPU *)opaque;\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t irq_bit = 1 << irq;\n\n\n\n    if (irq > 31 || irq < 0) {\n\n        return;\n\n    }\n\n\n\n    if (level) {\n\n        cpu->env.picsr |= irq_bit;\n\n    } else {\n\n        cpu->env.picsr &= ~irq_bit;\n\n    }\n\n\n\n    if (cpu->env.picsr & cpu->env.picmr) {\n\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n\n    } else {\n\n        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n\n        cpu->env.picsr = 0;\n\n    }\n\n}\n", "idx": 3196}
{"project": "qemu", "commit_id": "1e0228fd20aa46ac1f02cffee946cdd4ffaf8b96", "target": 1, "func": "Exynos4210State *exynos4210_init(MemoryRegion *system_mem,\n        unsigned long ram_size)\n{\n    int i, n;\n    Exynos4210State *s = g_new(Exynos4210State, 1);\n    qemu_irq gate_irq[EXYNOS4210_NCPUS][EXYNOS4210_IRQ_GATE_NINPUTS];\n    unsigned long mem_size;\n    DeviceState *dev;\n    SysBusDevice *busdev;\n    ObjectClass *cpu_oc;\n    cpu_oc = cpu_class_by_name(TYPE_ARM_CPU, \"cortex-a9\");\n    assert(cpu_oc);\n    for (n = 0; n < EXYNOS4210_NCPUS; n++) {\n        Object *cpuobj = object_new(object_class_get_name(cpu_oc));\n        /* By default A9 CPUs have EL3 enabled.  This board does not currently\n         * support EL3 so the CPU EL3 property is disabled before realization.\n         */\n        if (object_property_find(cpuobj, \"has_el3\", NULL)) {\n            object_property_set_bool(cpuobj, false, \"has_el3\", &error_fatal);\n        }\n        s->cpu[n] = ARM_CPU(cpuobj);\n        object_property_set_int(cpuobj, EXYNOS4210_SMP_PRIVATE_BASE_ADDR,\n                                \"reset-cbar\", &error_abort);\n        object_property_set_bool(cpuobj, true, \"realized\", &error_fatal);\n    }\n    /*** IRQs ***/\n    s->irq_table = exynos4210_init_irq(&s->irqs);\n    /* IRQ Gate */\n    for (i = 0; i < EXYNOS4210_NCPUS; i++) {\n        dev = qdev_create(NULL, \"exynos4210.irq_gate\");\n        qdev_prop_set_uint32(dev, \"n_in\", EXYNOS4210_IRQ_GATE_NINPUTS);\n        qdev_init_nofail(dev);\n        /* Get IRQ Gate input in gate_irq */\n        for (n = 0; n < EXYNOS4210_IRQ_GATE_NINPUTS; n++) {\n            gate_irq[i][n] = qdev_get_gpio_in(dev, n);\n        }\n        busdev = SYS_BUS_DEVICE(dev);\n        /* Connect IRQ Gate output to CPU's IRQ line */\n        sysbus_connect_irq(busdev, 0,\n                           qdev_get_gpio_in(DEVICE(s->cpu[i]), ARM_CPU_IRQ));\n    }\n    /* Private memory region and Internal GIC */\n    dev = qdev_create(NULL, \"a9mpcore_priv\");\n    qdev_prop_set_uint32(dev, \"num-cpu\", EXYNOS4210_NCPUS);\n    qdev_init_nofail(dev);\n    busdev = SYS_BUS_DEVICE(dev);\n    sysbus_mmio_map(busdev, 0, EXYNOS4210_SMP_PRIVATE_BASE_ADDR);\n    for (n = 0; n < EXYNOS4210_NCPUS; n++) {\n        sysbus_connect_irq(busdev, n, gate_irq[n][0]);\n    }\n    for (n = 0; n < EXYNOS4210_INT_GIC_NIRQ; n++) {\n        s->irqs.int_gic_irq[n] = qdev_get_gpio_in(dev, n);\n    }\n    /* Cache controller */\n    sysbus_create_simple(\"l2x0\", EXYNOS4210_L2X0_BASE_ADDR, NULL);\n    /* External GIC */\n    dev = qdev_create(NULL, \"exynos4210.gic\");\n    qdev_prop_set_uint32(dev, \"num-cpu\", EXYNOS4210_NCPUS);\n    qdev_init_nofail(dev);\n    busdev = SYS_BUS_DEVICE(dev);\n    /* Map CPU interface */\n    sysbus_mmio_map(busdev, 0, EXYNOS4210_EXT_GIC_CPU_BASE_ADDR);\n    /* Map Distributer interface */\n    sysbus_mmio_map(busdev, 1, EXYNOS4210_EXT_GIC_DIST_BASE_ADDR);\n    for (n = 0; n < EXYNOS4210_NCPUS; n++) {\n        sysbus_connect_irq(busdev, n, gate_irq[n][1]);\n    }\n    for (n = 0; n < EXYNOS4210_EXT_GIC_NIRQ; n++) {\n        s->irqs.ext_gic_irq[n] = qdev_get_gpio_in(dev, n);\n    }\n    /* Internal Interrupt Combiner */\n    dev = qdev_create(NULL, \"exynos4210.combiner\");\n    qdev_init_nofail(dev);\n    busdev = SYS_BUS_DEVICE(dev);\n    for (n = 0; n < EXYNOS4210_MAX_INT_COMBINER_OUT_IRQ; n++) {\n        sysbus_connect_irq(busdev, n, s->irqs.int_gic_irq[n]);\n    }\n    exynos4210_combiner_get_gpioin(&s->irqs, dev, 0);\n    sysbus_mmio_map(busdev, 0, EXYNOS4210_INT_COMBINER_BASE_ADDR);\n    /* External Interrupt Combiner */\n    dev = qdev_create(NULL, \"exynos4210.combiner\");\n    qdev_prop_set_uint32(dev, \"external\", 1);\n    qdev_init_nofail(dev);\n    busdev = SYS_BUS_DEVICE(dev);\n    for (n = 0; n < EXYNOS4210_MAX_INT_COMBINER_OUT_IRQ; n++) {\n        sysbus_connect_irq(busdev, n, s->irqs.ext_gic_irq[n]);\n    }\n    exynos4210_combiner_get_gpioin(&s->irqs, dev, 1);\n    sysbus_mmio_map(busdev, 0, EXYNOS4210_EXT_COMBINER_BASE_ADDR);\n    /* Initialize board IRQs. */\n    exynos4210_init_board_irqs(&s->irqs);\n    /*** Memory ***/\n    /* Chip-ID and OMR */\n    memory_region_init_io(&s->chipid_mem, NULL, &exynos4210_chipid_and_omr_ops,\n        NULL, \"exynos4210.chipid\", sizeof(chipid_and_omr));\n    memory_region_add_subregion(system_mem, EXYNOS4210_CHIPID_ADDR,\n                                &s->chipid_mem);\n    /* Internal ROM */\n    memory_region_init_ram(&s->irom_mem, NULL, \"exynos4210.irom\",\n                           EXYNOS4210_IROM_SIZE, &error_fatal);\n    vmstate_register_ram_global(&s->irom_mem);\n    memory_region_set_readonly(&s->irom_mem, true);\n    memory_region_add_subregion(system_mem, EXYNOS4210_IROM_BASE_ADDR,\n                                &s->irom_mem);\n    /* mirror of iROM */\n    memory_region_init_alias(&s->irom_alias_mem, NULL, \"exynos4210.irom_alias\",\n                             &s->irom_mem,\n                             0,\n                             EXYNOS4210_IROM_SIZE);\n    memory_region_set_readonly(&s->irom_alias_mem, true);\n    memory_region_add_subregion(system_mem, EXYNOS4210_IROM_MIRROR_BASE_ADDR,\n                                &s->irom_alias_mem);\n    /* Internal RAM */\n    memory_region_init_ram(&s->iram_mem, NULL, \"exynos4210.iram\",\n                           EXYNOS4210_IRAM_SIZE, &error_fatal);\n    vmstate_register_ram_global(&s->iram_mem);\n    memory_region_add_subregion(system_mem, EXYNOS4210_IRAM_BASE_ADDR,\n                                &s->iram_mem);\n    /* DRAM */\n    mem_size = ram_size;\n    if (mem_size > EXYNOS4210_DRAM_MAX_SIZE) {\n        memory_region_init_ram(&s->dram1_mem, NULL, \"exynos4210.dram1\",\n                mem_size - EXYNOS4210_DRAM_MAX_SIZE, &error_fatal);\n        vmstate_register_ram_global(&s->dram1_mem);\n        memory_region_add_subregion(system_mem, EXYNOS4210_DRAM1_BASE_ADDR,\n                &s->dram1_mem);\n        mem_size = EXYNOS4210_DRAM_MAX_SIZE;\n    }\n    memory_region_init_ram(&s->dram0_mem, NULL, \"exynos4210.dram0\", mem_size,\n                           &error_fatal);\n    vmstate_register_ram_global(&s->dram0_mem);\n    memory_region_add_subregion(system_mem, EXYNOS4210_DRAM0_BASE_ADDR,\n            &s->dram0_mem);\n   /* PMU.\n    * The only reason of existence at the moment is that secondary CPU boot\n    * loader uses PMU INFORM5 register as a holding pen.\n    */\n    sysbus_create_simple(\"exynos4210.pmu\", EXYNOS4210_PMU_BASE_ADDR, NULL);\n    /* PWM */\n    sysbus_create_varargs(\"exynos4210.pwm\", EXYNOS4210_PWM_BASE_ADDR,\n                          s->irq_table[exynos4210_get_irq(22, 0)],\n                          s->irq_table[exynos4210_get_irq(22, 1)],\n                          s->irq_table[exynos4210_get_irq(22, 2)],\n                          s->irq_table[exynos4210_get_irq(22, 3)],\n                          s->irq_table[exynos4210_get_irq(22, 4)],\n                          NULL);\n    /* RTC */\n    sysbus_create_varargs(\"exynos4210.rtc\", EXYNOS4210_RTC_BASE_ADDR,\n                          s->irq_table[exynos4210_get_irq(23, 0)],\n                          s->irq_table[exynos4210_get_irq(23, 1)],\n                          NULL);\n    /* Multi Core Timer */\n    dev = qdev_create(NULL, \"exynos4210.mct\");\n    qdev_init_nofail(dev);\n    busdev = SYS_BUS_DEVICE(dev);\n    for (n = 0; n < 4; n++) {\n        /* Connect global timer interrupts to Combiner gpio_in */\n        sysbus_connect_irq(busdev, n,\n                s->irq_table[exynos4210_get_irq(1, 4 + n)]);\n    }\n    /* Connect local timer interrupts to Combiner gpio_in */\n    sysbus_connect_irq(busdev, 4,\n            s->irq_table[exynos4210_get_irq(51, 0)]);\n    sysbus_connect_irq(busdev, 5,\n            s->irq_table[exynos4210_get_irq(35, 3)]);\n    sysbus_mmio_map(busdev, 0, EXYNOS4210_MCT_BASE_ADDR);\n    /*** I2C ***/\n    for (n = 0; n < EXYNOS4210_I2C_NUMBER; n++) {\n        uint32_t addr = EXYNOS4210_I2C_BASE_ADDR + EXYNOS4210_I2C_SHIFT * n;\n        qemu_irq i2c_irq;\n        if (n < 8) {\n            i2c_irq = s->irq_table[exynos4210_get_irq(EXYNOS4210_I2C_INTG, n)];\n        } else {\n            i2c_irq = s->irq_table[exynos4210_get_irq(EXYNOS4210_HDMI_INTG, 1)];\n        }\n        dev = qdev_create(NULL, \"exynos4210.i2c\");\n        qdev_init_nofail(dev);\n        busdev = SYS_BUS_DEVICE(dev);\n        sysbus_connect_irq(busdev, 0, i2c_irq);\n        sysbus_mmio_map(busdev, 0, addr);\n        s->i2c_if[n] = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n    }\n    /*** UARTs ***/\n    exynos4210_uart_create(EXYNOS4210_UART0_BASE_ADDR,\n                           EXYNOS4210_UART0_FIFO_SIZE, 0, NULL,\n                  s->irq_table[exynos4210_get_irq(EXYNOS4210_UART_INT_GRP, 0)]);\n    exynos4210_uart_create(EXYNOS4210_UART1_BASE_ADDR,\n                           EXYNOS4210_UART1_FIFO_SIZE, 1, NULL,\n                  s->irq_table[exynos4210_get_irq(EXYNOS4210_UART_INT_GRP, 1)]);\n    exynos4210_uart_create(EXYNOS4210_UART2_BASE_ADDR,\n                           EXYNOS4210_UART2_FIFO_SIZE, 2, NULL,\n                  s->irq_table[exynos4210_get_irq(EXYNOS4210_UART_INT_GRP, 2)]);\n    exynos4210_uart_create(EXYNOS4210_UART3_BASE_ADDR,\n                           EXYNOS4210_UART3_FIFO_SIZE, 3, NULL,\n                  s->irq_table[exynos4210_get_irq(EXYNOS4210_UART_INT_GRP, 3)]);\n    /*** Display controller (FIMD) ***/\n    sysbus_create_varargs(\"exynos4210.fimd\", EXYNOS4210_FIMD0_BASE_ADDR,\n            s->irq_table[exynos4210_get_irq(11, 0)],\n            s->irq_table[exynos4210_get_irq(11, 1)],\n            s->irq_table[exynos4210_get_irq(11, 2)],\n            NULL);\n    sysbus_create_simple(TYPE_EXYNOS4210_EHCI, EXYNOS4210_EHCI_BASE_ADDR,\n            s->irq_table[exynos4210_get_irq(28, 3)]);\n    return s;\n}", "idx": 1050}
{"project": "qemu", "commit_id": "4efb1f7c612ff35badc8f8cbda78ac891fabf20a", "target": 1, "func": "static int qcow2_cache_do_get(BlockDriverState *bs, Qcow2Cache *c,\n    uint64_t offset, void **table, bool read_from_disk)\n{\n    BDRVQcow2State *s = bs->opaque;\n    int i;\n    int ret;\n    int lookup_index;\n    uint64_t min_lru_counter = UINT64_MAX;\n    int min_lru_index = -1;\n    trace_qcow2_cache_get(qemu_coroutine_self(), c == s->l2_table_cache,\n                          offset, read_from_disk);\n    /* Check if the table is already cached */\n    i = lookup_index = (offset / s->cluster_size * 4) % c->size;\n    do {\n        const Qcow2CachedTable *t = &c->entries[i];\n        if (t->offset == offset) {\n            goto found;\n        if (t->ref == 0 && t->lru_counter < min_lru_counter) {\n            min_lru_counter = t->lru_counter;\n            min_lru_index = i;\n        if (++i == c->size) {\n            i = 0;\n    } while (i != lookup_index);\n    if (min_lru_index == -1) {\n        /* This can't happen in current synchronous code, but leave the check\n         * here as a reminder for whoever starts using AIO with the cache */\n        abort();\n    /* Cache miss: write a table back and replace it */\n    i = min_lru_index;\n    trace_qcow2_cache_get_replace_entry(qemu_coroutine_self(),\n                                        c == s->l2_table_cache, i);\n    ret = qcow2_cache_entry_flush(bs, c, i);\n    if (ret < 0) {\n        return ret;\n    trace_qcow2_cache_get_read(qemu_coroutine_self(),\n                               c == s->l2_table_cache, i);\n    c->entries[i].offset = 0;\n    if (read_from_disk) {\n        if (c == s->l2_table_cache) {\n            BLKDBG_EVENT(bs->file, BLKDBG_L2_LOAD);\n        ret = bdrv_pread(bs->file, offset,\n                         qcow2_cache_get_table_addr(bs, c, i),\n                         s->cluster_size);\n        if (ret < 0) {\n            return ret;\n    c->entries[i].offset = offset;\n    /* And return the right table */\nfound:\n    c->entries[i].ref++;\n    *table = qcow2_cache_get_table_addr(bs, c, i);\n    trace_qcow2_cache_get_done(qemu_coroutine_self(),\n                               c == s->l2_table_cache, i);\n    return 0;", "idx": 7608}
{"project": "qemu", "commit_id": "f307b2558f61e068ce514f2dde2cad74c62036d6", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, uint16_t **refcount_table,\n\n                               int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        *refcount_table = g_try_new0(uint16_t, *nb_clusters);\n\n        if (*nb_clusters && *refcount_table == NULL) {\n\n            res->check_errors++;\n\n            return -ENOMEM;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n\n}\n", "idx": 1696}
{"project": "qemu", "commit_id": "0aecede6121e56ccc5d6a82243f2ccccdfabe6d5", "target": 1, "func": "TranslationBlock *tb_gen_code(CPUState *cpu,\n\n                              target_ulong pc, target_ulong cs_base,\n\n                              uint32_t flags, int cflags)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    TranslationBlock *tb;\n\n    tb_page_addr_t phys_pc, phys_page2;\n\n    target_ulong virt_page2;\n\n    tcg_insn_unit *gen_code_buf;\n\n    int gen_code_size, search_size;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    assert_memory_lock();\n\n\n\n    phys_pc = get_page_addr_code(env, pc);\n\n    if (use_icount && !(cflags & CF_IGNORE_ICOUNT)) {\n\n        cflags |= CF_USE_ICOUNT;\n\n    }\n\n\n\n    tb = tb_alloc(pc);\n\n    if (unlikely(!tb)) {\n\n buffer_overflow:\n\n        /* flush must be done */\n\n        tb_flush(cpu);\n\n        mmap_unlock();\n\n        /* Make the execution loop process the flush as soon as possible.  */\n\n        cpu->exception_index = EXCP_INTERRUPT;\n\n        cpu_loop_exit(cpu);\n\n    }\n\n\n\n    gen_code_buf = tcg_ctx.code_gen_ptr;\n\n    tb->tc_ptr = gen_code_buf;\n\n    tb->pc = pc;\n\n    tb->cs_base = cs_base;\n\n    tb->flags = flags;\n\n    tb->cflags = cflags;\n\n    tb->trace_vcpu_dstate = *cpu->trace_dstate;\n\n    tb->invalid = false;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    tcg_ctx.tb_count1++; /* includes aborted translations because of\n\n                       exceptions */\n\n    ti = profile_getclock();\n\n#endif\n\n\n\n    tcg_func_start(&tcg_ctx);\n\n\n\n    tcg_ctx.cpu = ENV_GET_CPU(env);\n\n    gen_intermediate_code(cpu, tb);\n\n    tcg_ctx.cpu = NULL;\n\n\n\n    trace_translate_block(tb, tb->pc, tb->tc_ptr);\n\n\n\n    /* generate machine code */\n\n    tb->jmp_reset_offset[0] = TB_JMP_RESET_OFFSET_INVALID;\n\n    tb->jmp_reset_offset[1] = TB_JMP_RESET_OFFSET_INVALID;\n\n    tcg_ctx.tb_jmp_reset_offset = tb->jmp_reset_offset;\n\n    if (TCG_TARGET_HAS_direct_jump) {\n\n        tcg_ctx.tb_jmp_insn_offset = tb->jmp_target_arg;\n\n        tcg_ctx.tb_jmp_target_addr = NULL;\n\n    } else {\n\n        tcg_ctx.tb_jmp_insn_offset = NULL;\n\n        tcg_ctx.tb_jmp_target_addr = tb->jmp_target_arg;\n\n    }\n\n\n\n#ifdef CONFIG_PROFILER\n\n    tcg_ctx.tb_count++;\n\n    tcg_ctx.interm_time += profile_getclock() - ti;\n\n    tcg_ctx.code_time -= profile_getclock();\n\n#endif\n\n\n\n    /* ??? Overflow could be handled better here.  In particular, we\n\n       don't need to re-do gen_intermediate_code, nor should we re-do\n\n       the tcg optimization currently hidden inside tcg_gen_code.  All\n\n       that should be required is to flush the TBs, allocate a new TB,\n\n       re-initialize it per above, and re-do the actual code generation.  */\n\n    gen_code_size = tcg_gen_code(&tcg_ctx, tb);\n\n    if (unlikely(gen_code_size < 0)) {\n\n        goto buffer_overflow;\n\n    }\n\n    search_size = encode_search(tb, (void *)gen_code_buf + gen_code_size);\n\n    if (unlikely(search_size < 0)) {\n\n        goto buffer_overflow;\n\n    }\n\n\n\n#ifdef CONFIG_PROFILER\n\n    tcg_ctx.code_time += profile_getclock();\n\n    tcg_ctx.code_in_len += tb->size;\n\n    tcg_ctx.code_out_len += gen_code_size;\n\n    tcg_ctx.search_out_len += search_size;\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_OUT_ASM) &&\n\n        qemu_log_in_addr_range(tb->pc)) {\n\n        qemu_log_lock();\n\n        qemu_log(\"OUT: [size=%d]\\n\", gen_code_size);\n\n        if (tcg_ctx.data_gen_ptr) {\n\n            size_t code_size = tcg_ctx.data_gen_ptr - tb->tc_ptr;\n\n            size_t data_size = gen_code_size - code_size;\n\n            size_t i;\n\n\n\n            log_disas(tb->tc_ptr, code_size);\n\n\n\n            for (i = 0; i < data_size; i += sizeof(tcg_target_ulong)) {\n\n                if (sizeof(tcg_target_ulong) == 8) {\n\n                    qemu_log(\"0x%08\" PRIxPTR \":  .quad  0x%016\" PRIx64 \"\\n\",\n\n                             (uintptr_t)tcg_ctx.data_gen_ptr + i,\n\n                             *(uint64_t *)(tcg_ctx.data_gen_ptr + i));\n\n                } else {\n\n                    qemu_log(\"0x%08\" PRIxPTR \":  .long  0x%08x\\n\",\n\n                             (uintptr_t)tcg_ctx.data_gen_ptr + i,\n\n                             *(uint32_t *)(tcg_ctx.data_gen_ptr + i));\n\n                }\n\n            }\n\n        } else {\n\n            log_disas(tb->tc_ptr, gen_code_size);\n\n        }\n\n        qemu_log(\"\\n\");\n\n        qemu_log_flush();\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n\n\n    tcg_ctx.code_gen_ptr = (void *)\n\n        ROUND_UP((uintptr_t)gen_code_buf + gen_code_size + search_size,\n\n                 CODE_GEN_ALIGN);\n\n\n\n    /* init jump list */\n\n    assert(((uintptr_t)tb & 3) == 0);\n\n    tb->jmp_list_first = (uintptr_t)tb | 2;\n\n    tb->jmp_list_next[0] = (uintptr_t)NULL;\n\n    tb->jmp_list_next[1] = (uintptr_t)NULL;\n\n\n\n    /* init original jump addresses wich has been set during tcg_gen_code() */\n\n    if (tb->jmp_reset_offset[0] != TB_JMP_RESET_OFFSET_INVALID) {\n\n        tb_reset_jump(tb, 0);\n\n    }\n\n    if (tb->jmp_reset_offset[1] != TB_JMP_RESET_OFFSET_INVALID) {\n\n        tb_reset_jump(tb, 1);\n\n    }\n\n\n\n    /* check next page if needed */\n\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n\n        phys_page2 = get_page_addr_code(env, virt_page2);\n\n    }\n\n    /* As long as consistency of the TB stuff is provided by tb_lock in user\n\n     * mode and is implicit in single-threaded softmmu emulation, no explicit\n\n     * memory barrier is required before tb_link_page() makes the TB visible\n\n     * through the physical hash table and physical page list.\n\n     */\n\n    tb_link_page(tb, phys_pc, phys_page2);\n\n    return tb;\n\n}\n", "idx": 6870}
{"project": "qemu", "commit_id": "9586fefefe383a9aa25ad99bde9a6b240309ca33", "target": 1, "func": "static int cirrus_vga_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    int ret;\n\n\n\n    if (version_id > 2)\n\n        return -EINVAL;\n\n\n\n    if (s->pci_dev && version_id >= 2) {\n\n        ret = pci_device_load(s->pci_dev, f);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    qemu_get_be32s(f, &s->latch);\n\n    qemu_get_8s(f, &s->sr_index);\n\n    qemu_get_buffer(f, s->sr, 256);\n\n    qemu_get_8s(f, &s->gr_index);\n\n    qemu_get_8s(f, &s->cirrus_shadow_gr0);\n\n    qemu_get_8s(f, &s->cirrus_shadow_gr1);\n\n    s->gr[0x00] = s->cirrus_shadow_gr0 & 0x0f;\n\n    s->gr[0x01] = s->cirrus_shadow_gr1 & 0x0f;\n\n    qemu_get_buffer(f, s->gr + 2, 254);\n\n    qemu_get_8s(f, &s->ar_index);\n\n    qemu_get_buffer(f, s->ar, 21);\n\n    s->ar_flip_flop=qemu_get_be32(f);\n\n    qemu_get_8s(f, &s->cr_index);\n\n    qemu_get_buffer(f, s->cr, 256);\n\n    qemu_get_8s(f, &s->msr);\n\n    qemu_get_8s(f, &s->fcr);\n\n    qemu_get_8s(f, &s->st00);\n\n    qemu_get_8s(f, &s->st01);\n\n\n\n    qemu_get_8s(f, &s->dac_state);\n\n    qemu_get_8s(f, &s->dac_sub_index);\n\n    qemu_get_8s(f, &s->dac_read_index);\n\n    qemu_get_8s(f, &s->dac_write_index);\n\n    qemu_get_buffer(f, s->dac_cache, 3);\n\n    qemu_get_buffer(f, s->palette, 768);\n\n\n\n    s->bank_offset=qemu_get_be32(f);\n\n\n\n    qemu_get_8s(f, &s->cirrus_hidden_dac_lockindex);\n\n    qemu_get_8s(f, &s->cirrus_hidden_dac_data);\n\n\n\n    qemu_get_be32s(f, &s->hw_cursor_x);\n\n    qemu_get_be32s(f, &s->hw_cursor_y);\n\n\n\n    cirrus_update_memory_access(s);\n\n    /* force refresh */\n\n    s->graphic_mode = -1;\n\n    cirrus_update_bank_ptr(s, 0);\n\n    cirrus_update_bank_ptr(s, 1);\n\n    return 0;\n\n}\n", "idx": 4200}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void text_console_resize(QemuConsole *s)\n\n{\n\n    TextCell *cells, *c, *c1;\n\n    int w1, x, y, last_width;\n\n\n\n    last_width = s->width;\n\n    s->width = surface_width(s->surface) / FONT_WIDTH;\n\n    s->height = surface_height(s->surface) / FONT_HEIGHT;\n\n\n\n    w1 = last_width;\n\n    if (s->width < w1)\n\n        w1 = s->width;\n\n\n\n    cells = g_malloc(s->width * s->total_height * sizeof(TextCell));\n\n    for(y = 0; y < s->total_height; y++) {\n\n        c = &cells[y * s->width];\n\n        if (w1 > 0) {\n\n            c1 = &s->cells[y * last_width];\n\n            for(x = 0; x < w1; x++) {\n\n                *c++ = *c1++;\n\n            }\n\n        }\n\n        for(x = w1; x < s->width; x++) {\n\n            c->ch = ' ';\n\n            c->t_attrib = s->t_attrib_default;\n\n            c++;\n\n        }\n\n    }\n\n    g_free(s->cells);\n\n    s->cells = cells;\n\n}\n", "idx": 10644}
{"project": "qemu", "commit_id": "f8762027a33e2f5d0915c56a904962b1481f75c1", "target": 1, "func": "static int socket_accept(int sock)\n\n{\n\n    struct sockaddr_un addr;\n\n    socklen_t addrlen;\n\n    int ret;\n\n\n\n    addrlen = sizeof(addr);\n\n    do {\n\n        ret = accept(sock, (struct sockaddr *)&addr, &addrlen);\n\n    } while (ret == -1 && errno == EINTR);\n\n    g_assert_no_errno(ret);\n\n    close(sock);\n\n\n\n    return ret;\n\n}\n", "idx": 3700}
{"project": "qemu", "commit_id": "66dc50f7057b9a0191f54e55764412202306858d", "target": 1, "func": "int do_subchannel_work_virtual(SubchDev *sch)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func_virtual(sch);\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n    return 0;\n\n}\n", "idx": 11700}
{"project": "qemu", "commit_id": "a6109ff1b5d7184a9d490c4ff94f175940232ebd", "target": 1, "func": "static void vmsvga_reset(struct vmsvga_state_s *s)\n\n{\n\n    s->index = 0;\n\n    s->enable = 0;\n\n    s->config = 0;\n\n    s->width = -1;\n\n    s->height = -1;\n\n    s->svgaid = SVGA_ID;\n\n    s->depth = 24;\n\n    s->bypp = (s->depth + 7) >> 3;\n\n    s->cursor.on = 0;\n\n    s->redraw_fifo_first = 0;\n\n    s->redraw_fifo_last = 0;\n\n    switch (s->depth) {\n\n    case 8:\n\n        s->wred   = 0x00000007;\n\n        s->wgreen = 0x00000038;\n\n        s->wblue  = 0x000000c0;\n\n        break;\n\n    case 15:\n\n        s->wred   = 0x0000001f;\n\n        s->wgreen = 0x000003e0;\n\n        s->wblue  = 0x00007c00;\n\n        break;\n\n    case 16:\n\n        s->wred   = 0x0000001f;\n\n        s->wgreen = 0x000007e0;\n\n        s->wblue  = 0x0000f800;\n\n        break;\n\n    case 24:\n\n        s->wred   = 0x00ff0000;\n\n        s->wgreen = 0x0000ff00;\n\n        s->wblue  = 0x000000ff;\n\n        break;\n\n    case 32:\n\n        s->wred   = 0x00ff0000;\n\n        s->wgreen = 0x0000ff00;\n\n        s->wblue  = 0x000000ff;\n\n        break;\n\n    }\n\n    s->syncing = 0;\n\n}\n", "idx": 4626}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 907}
{"project": "qemu", "commit_id": "b308c82cbda44e138ef990af64d44a5613c16092", "target": 1, "func": "static void pci_bridge_update_mappings(PCIBridge *br)\n\n{\n\n    /* Make updates atomic to: handle the case of one VCPU updating the bridge\n\n     * while another accesses an unaffected region. */\n\n    memory_region_transaction_begin();\n\n    pci_bridge_region_cleanup(br);\n\n    pci_bridge_region_init(br);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 3211}
{"project": "qemu", "commit_id": "599d64f6dc10f267a45e7abebfcafd8e7626585b", "target": 1, "func": "static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n", "idx": 3783}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7941}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "static int qemu_rbd_snap_remove(BlockDriverState *bs,\n\n                                const char *snapshot_name)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    int r;\n\n\n\n    r = rbd_snap_remove(s->image, snapshot_name);\n\n    return r;\n\n}\n", "idx": 9458}
{"project": "qemu", "commit_id": "9a94ee5bb15793ef69692998ef57794a33074134", "target": 1, "func": "static void rtas_start_cpu(PowerPCCPU *cpu_, sPAPRMachineState *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    PowerPCCPU *cpu;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cpu = spapr_find_cpu(id);\n\n    if (cpu != NULL) {\n\n        CPUState *cs = CPU(cpu);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n\n\n        /* Enable Power-saving mode Exit Cause exceptions for the new CPU */\n\n        env->spr[SPR_LPCR] |= pcc->lpcr_pm;\n\n\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n        spapr_cpu_set_endianness(cpu);\n\n        spapr_cpu_update_tb_offset(cpu);\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}", "idx": 1250}
{"project": "qemu", "commit_id": "687db4ed2ecd5fd74c94fbb420482823cca4ab7e", "target": 1, "func": "static void blkverify_err(BlkverifyAIOCB *acb, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    fprintf(stderr, \"blkverify: %s sector_num=%ld nb_sectors=%d \",\n\n            acb->is_write ? \"write\" : \"read\", acb->sector_num,\n\n            acb->nb_sectors);\n\n    vfprintf(stderr, fmt, ap);\n\n    fprintf(stderr, \"\\n\");\n\n    va_end(ap);\n\n    exit(1);\n\n}\n", "idx": 5372}
{"project": "qemu", "commit_id": "ab8131afee34d6aa427bd56ac18c4d3b6df80728", "target": 1, "func": "static void booke_update_fixed_timer(CPUPPCState         *env,\n\n                                     uint8_t           target_bit,\n\n                                     uint64_t          *next,\n\n                                     struct QEMUTimer *timer)\n\n{\n\n    ppc_tb_t *tb_env = env->tb_env;\n\n    uint64_t lapse;\n\n    uint64_t tb;\n\n    uint64_t period = 1 << (target_bit + 1);\n\n    uint64_t now;\n\n\n\n    now = qemu_get_clock_ns(vm_clock);\n\n    tb  = cpu_ppc_get_tb(tb_env, now, tb_env->tb_offset);\n\n\n\n    lapse = period - ((tb - (1 << target_bit)) & (period - 1));\n\n\n\n    *next = now + muldiv64(lapse, get_ticks_per_sec(), tb_env->tb_freq);\n\n\n\n    /* XXX: If expire time is now. We can't run the callback because we don't\n\n     * have access to it. So we just set the timer one nanosecond later.\n\n     */\n\n\n\n    if (*next == now) {\n\n        (*next)++;\n\n    }\n\n\n\n    qemu_mod_timer(timer, *next);\n\n}\n", "idx": 1915}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "static always_inline void gen_op_subfo (void)\n\n{\n\n    gen_op_move_T2_T0();\n\n    gen_op_subf();\n\n    gen_op_check_subfo();\n\n}\n", "idx": 7200}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static BlockAIOCB *blkverify_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    BlkverifyAIOCB *acb = blkverify_aio_get(bs, true, sector_num, qiov,\n\n                                            nb_sectors, cb, opaque);\n\n\n\n    bdrv_aio_writev(s->test_file, sector_num, qiov, nb_sectors,\n\n                    blkverify_aio_cb, acb);\n\n    bdrv_aio_writev(bs->file, sector_num, qiov, nb_sectors,\n\n                    blkverify_aio_cb, acb);\n\n    return &acb->common;\n\n}\n", "idx": 2198}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_net_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBNetState *s = (USBNetState *) dev;\n\n    int ret = 0;\n\n\n\n    switch(p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep) {\n\n        case 1:\n\n            ret = usb_net_handle_statusin(s, p);\n\n            break;\n\n\n\n        case 2:\n\n            ret = usb_net_handle_datain(s, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep) {\n\n        case 2:\n\n            ret = usb_net_handle_dataout(s, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    if (ret == USB_RET_STALL)\n\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n\n                        \"pid 0x%x ep 0x%x len 0x%x\\n\",\n\n                        p->pid, p->devep, p->len);\n\n    return ret;\n\n}\n", "idx": 11634}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "DISAS_INSN(shift_im)\n\n{\n\n    TCGv reg;\n\n    int tmp;\n\n    TCGv shift;\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n\n\n    reg = DREG(insn, 0);\n\n    tmp = (insn >> 9) & 7;\n\n    if (tmp == 0)\n\n        tmp = 8;\n\n    shift = tcg_const_i32(tmp);\n\n    /* No need to flush flags becuse we know we will set C flag.  */\n\n    if (insn & 0x100) {\n\n        gen_helper_shl_cc(reg, cpu_env, reg, shift);\n\n    } else {\n\n        if (insn & 8) {\n\n            gen_helper_shr_cc(reg, cpu_env, reg, shift);\n\n        } else {\n\n            gen_helper_sar_cc(reg, cpu_env, reg, shift);\n\n        }\n\n    }\n\n}\n", "idx": 10444}
{"project": "qemu", "commit_id": "0522604b09b8cff54ba2450a7478da2a4d084817", "target": 1, "func": "static void x86_cpu_reset(CPUState *s)\n{\n    X86CPU *cpu = X86_CPU(s);\n    X86CPUClass *xcc = X86_CPU_GET_CLASS(cpu);\n    CPUX86State *env = &cpu->env;\n    int i;\n    xcc->parent_reset(s);\n    memset(env, 0, offsetof(CPUX86State, breakpoints));\n    tlb_flush(env, 1);\n    env->old_exception = -1;\n    /* init to reset state */\n#ifdef CONFIG_SOFTMMU\n    env->hflags |= HF_SOFTMMU_MASK;\n#endif\n    env->hflags2 |= HF2_GIF_MASK;\n    cpu_x86_update_cr0(env, 0x60000010);\n    env->a20_mask = ~0x0;\n    env->smbase = 0x30000;\n    env->idt.limit = 0xffff;\n    env->gdt.limit = 0xffff;\n    env->ldt.limit = 0xffff;\n    env->ldt.flags = DESC_P_MASK | (2 << DESC_TYPE_SHIFT);\n    env->tr.limit = 0xffff;\n    env->tr.flags = DESC_P_MASK | (11 << DESC_TYPE_SHIFT);\n    cpu_x86_load_seg_cache(env, R_CS, 0xf000, 0xffff0000, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_CS_MASK |\n                           DESC_R_MASK | DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    env->eip = 0xfff0;\n    env->regs[R_EDX] = env->cpuid_version;\n    env->eflags = 0x2;\n    /* FPU init */\n    for (i = 0; i < 8; i++) {\n        env->fptags[i] = 1;\n    }\n    env->fpuc = 0x37f;\n    env->mxcsr = 0x1f80;\n    env->xstate_bv = XSTATE_FP | XSTATE_SSE;\n    env->pat = 0x0007040600070406ULL;\n    env->msr_ia32_misc_enable = MSR_IA32_MISC_ENABLE_DEFAULT;\n    memset(env->dr, 0, sizeof(env->dr));\n    env->dr[6] = DR6_FIXED_1;\n    env->dr[7] = DR7_FIXED_1;\n    cpu_breakpoint_remove_all(env, BP_CPU);\n    cpu_watchpoint_remove_all(env, BP_CPU);\n#if !defined(CONFIG_USER_ONLY)\n    /* We hard-wire the BSP to the first CPU. */\n    if (s->cpu_index == 0) {\n        apic_designate_bsp(env->apic_state);\n    }\n    s->halted = !cpu_is_bsp(cpu);\n#endif\n}", "idx": 7647}
{"project": "qemu", "commit_id": "0b368a10c71af96f6cf93b0ba5c2ee3bdbd50e96", "target": 1, "func": "static int kvm_put_msrs(X86CPU *cpu, int level)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n    int ret;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, env->sysenter_cs);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, env->sysenter_esp);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, env->sysenter_eip);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, env->pat);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, env->star);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, env->vm_hsave);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, env->tsc_aux);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, env->tsc_adjust);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE,\n\n                          env->msr_ia32_misc_enable);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, env->smbase);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, env->msr_bndcfgs);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, env->xss);\n\n    }\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, env->cstar);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, env->kernelgsbase);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, env->fmask);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, env->lstar);\n\n    }\n\n#endif\n\n    /*\n\n     * The following MSRs have side effects on the guest or are too heavy\n\n     * for normal writeback. Limit them to reset or full state updates.\n\n     */\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, env->wall_clock_msr);\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_ASYNC_PF)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, env->async_pf_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_PV_EOI)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, env->pv_eoi_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_STEAL_TIME)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, env->steal_time_msr);\n\n        }\n\n        if (has_msr_architectural_pmu) {\n\n            /* Stop the counter.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\n\n            /* Set the counter values.  */\n\n            for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,\n\n                                  env->msr_fixed_counters[i]);\n\n            }\n\n            for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,\n\n                                  env->msr_gp_counters[i]);\n\n                kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,\n\n                                  env->msr_gp_evtsel[i]);\n\n            }\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,\n\n                              env->msr_global_status);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL,\n\n                              env->msr_global_ovf_ctrl);\n\n\n\n            /* Now start the PMU.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL,\n\n                              env->msr_fixed_ctr_ctrl);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL,\n\n                              env->msr_global_ctrl);\n\n        }\n\n        /*\n\n         * Hyper-V partition-wide MSRs: to avoid clearing them on cpu hot-add,\n\n         * only sync them to KVM on the first cpu\n\n         */\n\n        if (current_cpu == first_cpu) {\n\n            if (has_msr_hv_hypercall) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID,\n\n                                  env->msr_hv_guest_os_id);\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL,\n\n                                  env->msr_hv_hypercall);\n\n            }\n\n            if (cpu->hyperv_time) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC,\n\n                                  env->msr_hv_tsc);\n\n            }\n\n        }\n\n        if (cpu->hyperv_vapic) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE,\n\n                              env->msr_hv_vapic);\n\n        }\n\n        if (has_msr_hv_crash) {\n\n            int j;\n\n\n\n            for (j = 0; j < HV_CRASH_PARAMS; j++)\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j,\n\n                                  env->msr_hv_crash_params[j]);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_NOTIFY);\n\n        }\n\n        if (has_msr_hv_runtime) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, env->msr_hv_runtime);\n\n        }\n\n        if (cpu->hyperv_synic) {\n\n            int j;\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, HV_SYNIC_VERSION);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL,\n\n                              env->msr_hv_synic_control);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP,\n\n                              env->msr_hv_synic_evt_page);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP,\n\n                              env->msr_hv_synic_msg_page);\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_synic_sint); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_SINT0 + j,\n\n                                  env->msr_hv_synic_sint[j]);\n\n            }\n\n        }\n\n        if (has_msr_hv_stimer) {\n\n            int j;\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_config); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_CONFIG + j * 2,\n\n                                env->msr_hv_stimer_config[j]);\n\n            }\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_count); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_COUNT + j * 2,\n\n                                env->msr_hv_stimer_count[j]);\n\n            }\n\n        }\n\n        if (env->features[FEAT_1_EDX] & CPUID_MTRR) {\n\n            uint64_t phys_mask = MAKE_64BIT_MASK(0, cpu->phys_bits);\n\n\n\n            kvm_msr_entry_add(cpu, MSR_MTRRdefType, env->mtrr_deftype);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, env->mtrr_fixed[0]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, env->mtrr_fixed[1]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, env->mtrr_fixed[2]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, env->mtrr_fixed[3]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, env->mtrr_fixed[4]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, env->mtrr_fixed[5]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, env->mtrr_fixed[6]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, env->mtrr_fixed[7]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, env->mtrr_fixed[8]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, env->mtrr_fixed[9]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, env->mtrr_fixed[10]);\n\n            for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n                /* The CPU GPs if we write to a bit above the physical limit of\n\n                 * the host CPU (and KVM emulates that)\n\n                 */\n\n                uint64_t mask = env->mtrr_var[i].mask;\n\n                mask &= phys_mask;\n\n\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i),\n\n                                  env->mtrr_var[i].base);\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), mask);\n\n            }\n\n        }\n\n\n\n        /* Note: MSR_IA32_FEATURE_CONTROL is written separately, see\n\n         *       kvm_put_msr_feature_control. */\n\n    }\n\n    if (env->mcg_cap) {\n\n        int i;\n\n\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, env->mcg_status);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, env->mcg_ctl);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, env->mcg_ext_ctl);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, env->mce_banks[i]);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret < cpu->kvm_msr_buf->nmsrs) {\n\n        struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];\n\n        error_report(\"error: failed to set MSR 0x%\" PRIx32 \" to 0x%\" PRIx64,\n\n                     (uint32_t)e->index, (uint64_t)e->data);\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    return 0;\n\n}\n", "idx": 9908}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n", "idx": 10837}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_vfp_msr(TCGv tmp)\n\n{\n\n    tcg_gen_mov_i32(cpu_F0s, tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1786}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "CBus *cbus_init(qemu_irq dat)\n\n{\n\n    CBusPriv *s = (CBusPriv *) g_malloc0(sizeof(*s));\n\n\n\n    s->dat_out = dat;\n\n    s->cbus.clk = qemu_allocate_irqs(cbus_clk, s, 1)[0];\n\n    s->cbus.dat = qemu_allocate_irqs(cbus_dat, s, 1)[0];\n\n    s->cbus.sel = qemu_allocate_irqs(cbus_sel, s, 1)[0];\n\n\n\n    s->sel = 1;\n\n    s->clk = 0;\n\n    s->dat = 0;\n\n\n\n    return &s->cbus;\n\n}\n", "idx": 8293}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbilx_booke206(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n\n\n    switch((ctx->opcode >> 21) & 0x3) {\n\n    case 0:\n\n        gen_helper_booke206_tlbilx0(cpu_env, t0);\n\n        break;\n\n    case 1:\n\n        gen_helper_booke206_tlbilx1(cpu_env, t0);\n\n        break;\n\n    case 3:\n\n        gen_helper_booke206_tlbilx3(cpu_env, t0);\n\n        break;\n\n    default:\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        break;\n\n    }\n\n\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 5571}
{"project": "qemu", "commit_id": "6630886863d4a9b3b7bcb3b0e2895d83eb269c75", "target": 1, "func": "static int net_init_nic(const NetClientOptions *opts, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    int idx;\n\n    NICInfo *nd;\n\n    const NetLegacyNicOptions *nic;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_NIC);\n\n    nic = opts->nic;\n\n\n\n    idx = nic_get_free_idx();\n\n    if (idx == -1 || nb_nics >= MAX_NICS) {\n\n        error_report(\"Too Many NICs\");\n\n        return -1;\n\n    }\n\n\n\n    nd = &nd_table[idx];\n\n\n\n    memset(nd, 0, sizeof(*nd));\n\n\n\n    if (nic->has_netdev) {\n\n        nd->netdev = qemu_find_netdev(nic->netdev);\n\n        if (!nd->netdev) {\n\n            error_report(\"netdev '%s' not found\", nic->netdev);\n\n            return -1;\n\n        }\n\n    } else {\n\n        assert(peer);\n\n        nd->netdev = peer;\n\n    }\n\n    nd->name = g_strdup(name);\n\n    if (nic->has_model) {\n\n        nd->model = g_strdup(nic->model);\n\n    }\n\n    if (nic->has_addr) {\n\n        nd->devaddr = g_strdup(nic->addr);\n\n    }\n\n\n\n    if (nic->has_macaddr &&\n\n        net_parse_macaddr(nd->macaddr.a, nic->macaddr) < 0) {\n\n        error_report(\"invalid syntax for ethernet address\");\n\n        return -1;\n\n    }\n\n    if (nic->has_macaddr &&\n\n        is_multicast_ether_addr(nd->macaddr.a)) {\n\n        error_report(\"NIC cannot have multicast MAC address (odd 1st byte)\");\n\n        return -1;\n\n    }\n\n    qemu_macaddr_default_if_unset(&nd->macaddr);\n\n\n\n    if (nic->has_vectors) {\n\n        if (nic->vectors > 0x7ffffff) {\n\n            error_report(\"invalid # of vectors: %\"PRIu32, nic->vectors);\n\n            return -1;\n\n        }\n\n        nd->nvectors = nic->vectors;\n\n    } else {\n\n        nd->nvectors = DEV_NVECTORS_UNSPECIFIED;\n\n    }\n\n\n\n    nd->used = 1;\n\n    nb_nics++;\n\n\n\n    return idx;\n\n}\n", "idx": 6670}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "void *cpu_register_map_client(void *opaque, void (*callback)(void *opaque))\n\n{\n\n    MapClient *client = g_malloc(sizeof(*client));\n\n\n\n    qemu_mutex_lock(&map_client_list_lock);\n\n    client->opaque = opaque;\n\n    client->callback = callback;\n\n    QLIST_INSERT_HEAD(&map_client_list, client, link);\n\n    if (!atomic_read(&bounce.in_use)) {\n\n        cpu_notify_map_clients_locked();\n\n    }\n\n    qemu_mutex_unlock(&map_client_list_lock);\n\n    return client;\n\n}\n", "idx": 1182}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float128 addFloat128Sigs( float128 a, float128 b, flag zSign STATUS_PARAM)\n\n{\n\n    int32 aExp, bExp, zExp;\n\n    uint64_t aSig0, aSig1, bSig0, bSig1, zSig0, zSig1, zSig2;\n\n    int32 expDiff;\n\n\n\n    aSig1 = extractFloat128Frac1( a );\n\n    aSig0 = extractFloat128Frac0( a );\n\n    aExp = extractFloat128Exp( a );\n\n    bSig1 = extractFloat128Frac1( b );\n\n    bSig0 = extractFloat128Frac0( b );\n\n    bExp = extractFloat128Exp( b );\n\n    expDiff = aExp - bExp;\n\n    if ( 0 < expDiff ) {\n\n        if ( aExp == 0x7FFF ) {\n\n            if ( aSig0 | aSig1 ) return propagateFloat128NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( bExp == 0 ) {\n\n            --expDiff;\n\n        }\n\n        else {\n\n            bSig0 |= LIT64( 0x0001000000000000 );\n\n        }\n\n        shift128ExtraRightJamming(\n\n            bSig0, bSig1, 0, expDiff, &bSig0, &bSig1, &zSig2 );\n\n        zExp = aExp;\n\n    }\n\n    else if ( expDiff < 0 ) {\n\n        if ( bExp == 0x7FFF ) {\n\n            if ( bSig0 | bSig1 ) return propagateFloat128NaN( a, b STATUS_VAR );\n\n            return packFloat128( zSign, 0x7FFF, 0, 0 );\n\n        }\n\n        if ( aExp == 0 ) {\n\n            ++expDiff;\n\n        }\n\n        else {\n\n            aSig0 |= LIT64( 0x0001000000000000 );\n\n        }\n\n        shift128ExtraRightJamming(\n\n            aSig0, aSig1, 0, - expDiff, &aSig0, &aSig1, &zSig2 );\n\n        zExp = bExp;\n\n    }\n\n    else {\n\n        if ( aExp == 0x7FFF ) {\n\n            if ( aSig0 | aSig1 | bSig0 | bSig1 ) {\n\n                return propagateFloat128NaN( a, b STATUS_VAR );\n\n            }\n\n            return a;\n\n        }\n\n        add128( aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1 );\n\n        if ( aExp == 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat128( zSign, 0, 0, 0 );\n\n            return packFloat128( zSign, 0, zSig0, zSig1 );\n\n        }\n\n        zSig2 = 0;\n\n        zSig0 |= LIT64( 0x0002000000000000 );\n\n        zExp = aExp;\n\n        goto shiftRight1;\n\n    }\n\n    aSig0 |= LIT64( 0x0001000000000000 );\n\n    add128( aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1 );\n\n    --zExp;\n\n    if ( zSig0 < LIT64( 0x0002000000000000 ) ) goto roundAndPack;\n\n    ++zExp;\n\n shiftRight1:\n\n    shift128ExtraRightJamming(\n\n        zSig0, zSig1, zSig2, 1, &zSig0, &zSig1, &zSig2 );\n\n roundAndPack:\n\n    return roundAndPackFloat128( zSign, zExp, zSig0, zSig1, zSig2 STATUS_VAR );\n\n\n\n}\n", "idx": 6984}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "bool virtio_scsi_handle_ctrl_vq(VirtIOSCSI *s, VirtQueue *vq)\n\n{\n\n    VirtIOSCSIReq *req;\n\n    bool progress = false;\n\n\n\n    virtio_scsi_acquire(s);\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        progress = true;\n\n        virtio_scsi_handle_ctrl_req(s, req);\n\n    }\n\n    virtio_scsi_release(s);\n\n    return progress;\n\n}\n", "idx": 7911}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_msr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->msr;\n\n}\n", "idx": 3510}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n", "idx": 1197}
{"project": "qemu", "commit_id": "b49ae9138d5cadb47fb868297fbcdac8292fb666", "target": 1, "func": "void vhost_net_ack_features(struct vhost_net *net, unsigned features)\n\n{\n\n\n    vhost_ack_features(&net->dev, vhost_net_get_feature_bits(net), features);\n\n}", "idx": 3476}
{"project": "qemu", "commit_id": "90527d2a8bb08ca5b4774eacfdd6b8fe9671c077", "target": 1, "func": "static int get_real_id(const char *devpath, const char *idname, uint16_t *val)\n\n{\n\n    FILE *f;\n\n    char name[128];\n\n    long id;\n\n\n\n    snprintf(name, sizeof(name), \"%s%s\", devpath, idname);\n\n    f = fopen(name, \"r\");\n\n    if (f == NULL) {\n\n        error_report(\"%s: %s: %m\", __func__, name);\n\n        return -1;\n\n    }\n\n    if (fscanf(f, \"%li\\n\", &id) == 1) {\n\n        *val = id;\n\n    } else {\n\n\n        return -1;\n\n    }\n\n\n\n\n    return 0;\n\n}", "idx": 8085}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static uint32_t pci_up_read(void *opaque, uint32_t addr)\n\n{\n\n    PIIX4PMState *s = opaque;\n\n    uint32_t val = s->pci0_status.up;\n\n\n\n    PIIX4_DPRINTF(\"pci_up_read %x\\n\", val);\n\n    return val;\n\n}\n", "idx": 8100}
{"project": "qemu", "commit_id": "cd245a19329edfcd968b00d05ad92de7a0e2daa1", "target": 1, "func": "void *qemu_malloc(size_t size)\n\n{\n\n    if (!size && !allow_zero_malloc()) {\n\n        abort();\n\n    }\n\n    return oom_check(malloc(size ? size : 1));\n\n}\n", "idx": 240}
{"project": "qemu", "commit_id": "42e4126b793d15ec40f3a84017e1d8afecda1b6d", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, uint32_t addr, uint32_t val, int l)\n\n{\n\n    int i, was_irq_disabled = pci_irq_disabled(d);\n\n    uint32_t config_size = pci_config_size(d);\n\n\n\n    for (i = 0; i < l && addr + i < config_size; val >>= 8, ++i) {\n\n        uint8_t wmask = d->wmask[addr + i];\n\n        uint8_t w1cmask = d->w1cmask[addr + i];\n\n        assert(!(wmask & w1cmask));\n\n        d->config[addr + i] = (d->config[addr + i] & ~wmask) | (val & wmask);\n\n        d->config[addr + i] &= ~(val & w1cmask); /* W1C: Write 1 to Clear */\n\n    }\n\n    if (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, 24) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS, 4) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, 4) ||\n\n        range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_mappings(d);\n\n\n\n    if (range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_irq_disabled(d, was_irq_disabled);\n\n}\n", "idx": 10603}
{"project": "qemu", "commit_id": "5ea2fc84da1bffce749c9d0848f5336def2818bb", "target": 1, "func": "static int do_fork(CPUArchState *env, unsigned int flags, abi_ulong newsp,\n\n                   abi_ulong parent_tidptr, target_ulong newtls,\n\n                   abi_ulong child_tidptr)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    int ret;\n\n    TaskState *ts;\n\n    CPUState *new_cpu;\n\n    CPUArchState *new_env;\n\n    sigset_t sigmask;\n\n\n\n    /* Emulate vfork() with fork() */\n\n    if (flags & CLONE_VFORK)\n\n        flags &= ~(CLONE_VFORK | CLONE_VM);\n\n\n\n    if (flags & CLONE_VM) {\n\n        TaskState *parent_ts = (TaskState *)cpu->opaque;\n\n        new_thread_info info;\n\n        pthread_attr_t attr;\n\n\n\n        ts = g_new0(TaskState, 1);\n\n        init_task_state(ts);\n\n        /* we create a new CPU instance. */\n\n        new_env = cpu_copy(env);\n\n        /* Init regs that differ from the parent.  */\n\n        cpu_clone_regs(new_env, newsp);\n\n        new_cpu = ENV_GET_CPU(new_env);\n\n        new_cpu->opaque = ts;\n\n        ts->bprm = parent_ts->bprm;\n\n        ts->info = parent_ts->info;\n\n        ts->signal_mask = parent_ts->signal_mask;\n\n\n\n        if (flags & CLONE_CHILD_CLEARTID) {\n\n            ts->child_tidptr = child_tidptr;\n\n        }\n\n\n\n        if (flags & CLONE_SETTLS) {\n\n            cpu_set_tls (new_env, newtls);\n\n        }\n\n\n\n        /* Grab a mutex so that thread setup appears atomic.  */\n\n        pthread_mutex_lock(&clone_lock);\n\n\n\n        memset(&info, 0, sizeof(info));\n\n        pthread_mutex_init(&info.mutex, NULL);\n\n        pthread_mutex_lock(&info.mutex);\n\n        pthread_cond_init(&info.cond, NULL);\n\n        info.env = new_env;\n\n        if (flags & CLONE_CHILD_SETTID) {\n\n            info.child_tidptr = child_tidptr;\n\n        }\n\n        if (flags & CLONE_PARENT_SETTID) {\n\n            info.parent_tidptr = parent_tidptr;\n\n        }\n\n\n\n        ret = pthread_attr_init(&attr);\n\n        ret = pthread_attr_setstacksize(&attr, NEW_STACK_SIZE);\n\n        ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n        /* It is not safe to deliver signals until the child has finished\n\n           initializing, so temporarily block all signals.  */\n\n        sigfillset(&sigmask);\n\n        sigprocmask(SIG_BLOCK, &sigmask, &info.sigmask);\n\n\n\n        ret = pthread_create(&info.thread, &attr, clone_func, &info);\n\n        /* TODO: Free new CPU state if thread creation failed.  */\n\n\n\n        sigprocmask(SIG_SETMASK, &info.sigmask, NULL);\n\n        pthread_attr_destroy(&attr);\n\n        if (ret == 0) {\n\n            /* Wait for the child to initialize.  */\n\n            pthread_cond_wait(&info.cond, &info.mutex);\n\n            ret = info.tid;\n\n        } else {\n\n            ret = -1;\n\n        }\n\n        pthread_mutex_unlock(&info.mutex);\n\n        pthread_cond_destroy(&info.cond);\n\n        pthread_mutex_destroy(&info.mutex);\n\n        pthread_mutex_unlock(&clone_lock);\n\n    } else {\n\n        /* if no CLONE_VM, we consider it is a fork */\n\n        if ((flags & ~(CSIGNAL | CLONE_NPTL_FLAGS2)) != 0) {\n\n            return -TARGET_EINVAL;\n\n        }\n\n\n\n        if (block_signals()) {\n\n            return -TARGET_ERESTARTSYS;\n\n        }\n\n\n\n        fork_start();\n\n        ret = fork();\n\n        if (ret == 0) {\n\n            /* Child Process.  */\n\n            rcu_after_fork();\n\n            cpu_clone_regs(env, newsp);\n\n            fork_end(1);\n\n            /* There is a race condition here.  The parent process could\n\n               theoretically read the TID in the child process before the child\n\n               tid is set.  This would require using either ptrace\n\n               (not implemented) or having *_tidptr to point at a shared memory\n\n               mapping.  We can't repeat the spinlock hack used above because\n\n               the child process gets its own copy of the lock.  */\n\n            if (flags & CLONE_CHILD_SETTID)\n\n                put_user_u32(gettid(), child_tidptr);\n\n            if (flags & CLONE_PARENT_SETTID)\n\n                put_user_u32(gettid(), parent_tidptr);\n\n            ts = (TaskState *)cpu->opaque;\n\n            if (flags & CLONE_SETTLS)\n\n                cpu_set_tls (env, newtls);\n\n            if (flags & CLONE_CHILD_CLEARTID)\n\n                ts->child_tidptr = child_tidptr;\n\n        } else {\n\n            fork_end(0);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 7158}
{"project": "qemu", "commit_id": "406bc339b0505fcfc2ffcbca1f05a3756e338a65", "target": 1, "func": "static void breakpoint_invalidate(CPUState *cpu, target_ulong pc)\n\n{\n\n    /* Flush the whole TB as this will not have race conditions\n\n     * even if we don't have proper locking yet.\n\n     * Ideally we would just invalidate the TBs for the\n\n     * specified PC.\n\n     */\n\n    tb_flush(cpu);\n\n}\n", "idx": 2095}
{"project": "qemu", "commit_id": "b1fe60cd3525871a4c593ad8c2b39b89c19c00d0", "target": 1, "func": "static void intel_hda_update_irq(IntelHDAState *d)\n\n{\n\n    int msi = d->msi && msi_enabled(&d->pci);\n\n    int level;\n\n\n\n    intel_hda_update_int_sts(d);\n\n    if (d->int_sts & (1 << 31) && d->int_ctl & (1 << 31)) {\n\n        level = 1;\n\n    } else {\n\n        level = 0;\n\n    }\n\n    dprint(d, 2, \"%s: level %d [%s]\\n\", __FUNCTION__,\n\n           level, msi ? \"msi\" : \"intx\");\n\n    if (msi) {\n\n        if (level) {\n\n            msi_notify(&d->pci, 0);\n\n        }\n\n    } else {\n\n        pci_set_irq(&d->pci, level);\n\n    }\n\n}\n", "idx": 3041}
{"project": "qemu", "commit_id": "1622ffd5151ad09c47785a380531ef1ebfc95be8", "target": 1, "func": "static void qemu_s390_flic_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    S390FLICStateClass *fsc = S390_FLIC_COMMON_CLASS(oc);\n\n\n\n    dc->reset = qemu_s390_flic_reset;\n\n    fsc->register_io_adapter = qemu_s390_register_io_adapter;\n\n    fsc->io_adapter_map = qemu_s390_io_adapter_map;\n\n    fsc->add_adapter_routes = qemu_s390_add_adapter_routes;\n\n    fsc->release_adapter_routes = qemu_s390_release_adapter_routes;\n\n    fsc->clear_io_irq = qemu_s390_clear_io_flic;\n\n    fsc->modify_ais_mode = qemu_s390_modify_ais_mode;\n\n\n}", "idx": 250}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static PXA2xxI2SState *pxa2xx_i2s_init(MemoryRegion *sysmem,\n\n                hwaddr base,\n\n                qemu_irq irq, qemu_irq rx_dma, qemu_irq tx_dma)\n\n{\n\n    PXA2xxI2SState *s = (PXA2xxI2SState *)\n\n            g_malloc0(sizeof(PXA2xxI2SState));\n\n\n\n    s->irq = irq;\n\n    s->rx_dma = rx_dma;\n\n    s->tx_dma = tx_dma;\n\n    s->data_req = pxa2xx_i2s_data_req;\n\n\n\n    pxa2xx_i2s_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &pxa2xx_i2s_ops, s,\n\n                          \"pxa2xx-i2s\", 0x100000);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    vmstate_register(NULL, base, &vmstate_pxa2xx_i2s, s);\n\n\n\n    return s;\n\n}\n", "idx": 12104}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void omap_timer_clk_setup(struct omap_mpu_timer_s *timer)\n\n{\n\n    omap_clk_adduser(timer->clk,\n\n                    qemu_allocate_irqs(omap_timer_clk_update, timer, 1)[0]);\n\n    timer->rate = omap_clk_getrate(timer->clk);\n\n}\n", "idx": 11314}
{"project": "qemu", "commit_id": "5f8632d3c3d7bc5ef24166ba7cf90fcfb2adbf7d", "target": 1, "func": "static void pc_init_pci_no_kvmclock(MachineState *machine)\n\n{\n\n    has_pci_info = false;\n\n    has_acpi_build = false;\n\n    smbios_defaults = false;\n\n\n\n\n\n\n    x86_cpu_compat_disable_kvm_features(FEAT_KVM, KVM_FEATURE_PV_EOI);\n\n    enable_compat_apic_id_mode();\n\n    pc_init1(machine, 1, 0);\n\n}", "idx": 10190}
{"project": "qemu", "commit_id": "bfb1ac14029ee72b19296109fba880c0551755d5", "target": 1, "func": "sorecvoob(struct socket *so)\n\n{\n\n\tstruct tcpcb *tp = sototcpcb(so);\n\n\n\n\tDEBUG_CALL(\"sorecvoob\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\n\n\t/*\n\n\t * We take a guess at how much urgent data has arrived.\n\n\t * In most situations, when urgent data arrives, the next\n\n\t * read() should get all the urgent data.  This guess will\n\n\t * be wrong however if more data arrives just after the\n\n\t * urgent data, or the read() doesn't return all the\n\n\t * urgent data.\n\n\t */\n\n\tsoread(so);\n\n\ttp->snd_up = tp->snd_una + so->so_snd.sb_cc;\n\n\ttp->t_force = 1;\n\n\ttcp_output(tp);\n\n\ttp->t_force = 0;\n\n}\n", "idx": 11594}
{"project": "qemu", "commit_id": "63d5ef869e5e57de4875cd64b6f197cbb5763adf", "target": 1, "func": "static QIOChannel *nbd_negotiate_handle_starttls(NBDClient *client,\n\n                                                 uint32_t length)\n\n{\n\n    QIOChannel *ioc;\n\n    QIOChannelTLS *tioc;\n\n    struct NBDTLSHandshakeData data = { 0 };\n\n\n\n    TRACE(\"Setting up TLS\");\n\n    ioc = client->ioc;\n\n    if (length) {\n\n        if (nbd_negotiate_drop_sync(ioc, length) != length) {\n\n            return NULL;\n\n        }\n\n        nbd_negotiate_send_rep(ioc, NBD_REP_ERR_INVALID, NBD_OPT_STARTTLS);\n\n        return NULL;\n\n    }\n\n\n\n    nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, NBD_OPT_STARTTLS);\n\n\n\n    tioc = qio_channel_tls_new_server(ioc,\n\n                                      client->tlscreds,\n\n                                      client->tlsaclname,\n\n                                      NULL);\n\n    if (!tioc) {\n\n        return NULL;\n\n    }\n\n\n\n    TRACE(\"Starting TLS handshake\");\n\n    data.loop = g_main_loop_new(g_main_context_default(), FALSE);\n\n    qio_channel_tls_handshake(tioc,\n\n                              nbd_tls_handshake,\n\n                              &data,\n\n                              NULL);\n\n\n\n    if (!data.complete) {\n\n        g_main_loop_run(data.loop);\n\n    }\n\n    g_main_loop_unref(data.loop);\n\n    if (data.error) {\n\n        object_unref(OBJECT(tioc));\n\n        error_free(data.error);\n\n        return NULL;\n\n    }\n\n\n\n    return QIO_CHANNEL(tioc);\n\n}\n", "idx": 9440}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)\n\n{\n\n    PCIDevice *dev = pci_create(bus, devfn, name);\n\n    qdev_init(&dev->qdev);\n\n    return dev;\n\n}\n", "idx": 10394}
{"project": "qemu", "commit_id": "4790b03d308f6c7dea7dc6941ddab9867c9530b8", "target": 1, "func": "iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                 QEMUIOVector *qiov, int nb_sectors,\n\n                 BlockDriverCompletionFunc *cb,\n\n                 void *opaque)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    IscsiAIOCB *acb;\n\n    size_t size;\n\n    uint32_t num_sectors;\n\n    uint64_t lba;\n\n    struct iscsi_data data;\n\n\n\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n\n    trace_iscsi_aio_writev(iscsi, sector_num, nb_sectors, opaque, acb);\n\n\n\n    acb->iscsilun = iscsilun;\n\n    acb->qiov     = qiov;\n\n\n\n    acb->canceled   = 0;\n\n    acb->bh         = NULL;\n\n    acb->status     = -EINPROGRESS;\n\n\n\n    /* XXX we should pass the iovec to write16 to avoid the extra copy */\n\n    /* this will allow us to get rid of 'buf' completely */\n\n    size = nb_sectors * BDRV_SECTOR_SIZE;\n\n    data.size = MIN(size, acb->qiov->size);\n\n\n\n    /* if the iovec only contains one buffer we can pass it directly */\n\n    if (acb->qiov->niov == 1) {\n\n        acb->buf = NULL;\n\n        data.data = acb->qiov->iov[0].iov_base;\n\n    } else {\n\n        acb->buf = g_malloc(data.size);\n\n        qemu_iovec_to_buf(acb->qiov, 0, acb->buf, data.size);\n\n        data.data = acb->buf;\n\n    }\n\n\n\n    acb->task = malloc(sizeof(struct scsi_task));\n\n    if (acb->task == NULL) {\n\n        error_report(\"iSCSI: Failed to allocate task for scsi WRITE16 \"\n\n                     \"command. %s\", iscsi_get_error(iscsi));\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    memset(acb->task, 0, sizeof(struct scsi_task));\n\n\n\n    acb->task->xfer_dir = SCSI_XFER_WRITE;\n\n    acb->task->cdb_size = 16;\n\n    acb->task->cdb[0] = 0x8a;\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n    *(uint32_t *)&acb->task->cdb[2]  = htonl(lba >> 32);\n\n    *(uint32_t *)&acb->task->cdb[6]  = htonl(lba & 0xffffffff);\n\n    num_sectors = size / iscsilun->block_size;\n\n    *(uint32_t *)&acb->task->cdb[10] = htonl(num_sectors);\n\n    acb->task->expxferlen = size;\n\n\n\n    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,\n\n                                 iscsi_aio_write16_cb,\n\n                                 &data,\n\n                                 acb) != 0) {\n\n        scsi_free_scsi_task(acb->task);\n\n        g_free(acb->buf);\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n\n\n    iscsi_set_events(iscsilun);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 5881}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "struct pxa2xx_state_s *pxa255_init(unsigned int sdram_size,\n\n                DisplayState *ds)\n\n{\n\n    struct pxa2xx_state_s *s;\n\n    struct pxa2xx_ssp_s *ssp;\n\n    int iomemtype, i;\n\n    s = (struct pxa2xx_state_s *) qemu_mallocz(sizeof(struct pxa2xx_state_s));\n\n\n\n    s->env = cpu_init();\n\n    cpu_arm_set_model(s->env, \"pxa255\");\n\n    register_savevm(\"cpu\", 0, 0, cpu_save, cpu_load, s->env);\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,\n\n                    qemu_ram_alloc(sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n\n                    qemu_ram_alloc(PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);\n\n\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa255_serial[i].io_base; i ++)\n\n        if (serial_hds[i])\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                            s->pic[pxa255_serial[i].irqn], serial_hds[i], 1);\n\n        else\n\n            break;\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    if (ds)\n\n        s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD], ds);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 4] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s);\n\n    cpu_register_physical_memory(s->cm_base, 0xfff, iomemtype);\n\n    register_savevm(\"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s);\n\n    cpu_register_physical_memory(s->mm_base, 0xfff, iomemtype);\n\n    register_savevm(\"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s);\n\n    cpu_register_physical_memory(s->pm_base, 0xff, iomemtype);\n\n    register_savevm(\"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n\n    s->ssp = (struct pxa2xx_ssp_s **)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s *) * i);\n\n    ssp = (struct pxa2xx_ssp_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s) * i);\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n\n        s->ssp[i] = &ssp[i];\n\n        ssp[i].base = pxa255_ssp[i].io_base;\n\n        ssp[i].irq = s->pic[pxa255_ssp[i].irqn];\n\n\n\n        iomemtype = cpu_register_io_memory(0, pxa2xx_ssp_readfn,\n\n                        pxa2xx_ssp_writefn, &ssp[i]);\n\n        cpu_register_physical_memory(ssp[i].base, 0xfff, iomemtype);\n\n        register_savevm(\"pxa2xx_ssp\", i, 0,\n\n                        pxa2xx_ssp_save, pxa2xx_ssp_load, s);\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pxa(0x4c000000, 3, -1, s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s);\n\n    cpu_register_physical_memory(s->rtc_base, 0xfff, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(\"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overriden by board-specific code */\n\n    pxa2xx_gpio_handler_set(s->gpio, 1, pxa2xx_reset, s);\n\n    return s;\n\n}\n", "idx": 5447}
{"project": "qemu", "commit_id": "69179fe2fc0b91f68699012ba72d329e74ff629e", "target": 1, "func": "static void test_reconnect(void)\n\n{\n\n    gchar *path = g_strdup_printf(\"/%s/vhost-user/reconnect/subprocess\",\n\n                                  qtest_get_arch());\n\n    g_test_trap_subprocess(path, 0, 0);\n\n    g_test_trap_assert_passed();\n\n\n}", "idx": 130}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "func": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}", "idx": 5973}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 addFloat64Sigs( float64 a, float64 b, flag zSign STATUS_PARAM )\n\n{\n\n    int16 aExp, bExp, zExp;\n\n    uint64_t aSig, bSig, zSig;\n\n    int16 expDiff;\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    bSig = extractFloat64Frac( b );\n\n    bExp = extractFloat64Exp( b );\n\n    expDiff = aExp - bExp;\n\n    aSig <<= 9;\n\n    bSig <<= 9;\n\n    if ( 0 < expDiff ) {\n\n        if ( aExp == 0x7FF ) {\n\n            if ( aSig ) return propagateFloat64NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( bExp == 0 ) {\n\n            --expDiff;\n\n        }\n\n        else {\n\n            bSig |= LIT64( 0x2000000000000000 );\n\n        }\n\n        shift64RightJamming( bSig, expDiff, &bSig );\n\n        zExp = aExp;\n\n    }\n\n    else if ( expDiff < 0 ) {\n\n        if ( bExp == 0x7FF ) {\n\n            if ( bSig ) return propagateFloat64NaN( a, b STATUS_VAR );\n\n            return packFloat64( zSign, 0x7FF, 0 );\n\n        }\n\n        if ( aExp == 0 ) {\n\n            ++expDiff;\n\n        }\n\n        else {\n\n            aSig |= LIT64( 0x2000000000000000 );\n\n        }\n\n        shift64RightJamming( aSig, - expDiff, &aSig );\n\n        zExp = bExp;\n\n    }\n\n    else {\n\n        if ( aExp == 0x7FF ) {\n\n            if ( aSig | bSig ) return propagateFloat64NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( aExp == 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            return packFloat64( zSign, 0, ( aSig + bSig )>>9 );\n\n        }\n\n        zSig = LIT64( 0x4000000000000000 ) + aSig + bSig;\n\n        zExp = aExp;\n\n        goto roundAndPack;\n\n    }\n\n    aSig |= LIT64( 0x2000000000000000 );\n\n    zSig = ( aSig + bSig )<<1;\n\n    --zExp;\n\n    if ( (int64_t) zSig < 0 ) {\n\n        zSig = aSig + bSig;\n\n        ++zExp;\n\n    }\n\n roundAndPack:\n\n    return roundAndPackFloat64( zSign, zExp, zSig STATUS_VAR );\n\n\n\n}\n", "idx": 8643}
{"project": "qemu", "commit_id": "e829b0bb054ed3389e5b22dad61875e51674e629", "target": 1, "func": "iscsi_aio_readv(BlockDriverState *bs, int64_t sector_num,\n\n                QEMUIOVector *qiov, int nb_sectors,\n\n                BlockDriverCompletionFunc *cb,\n\n                void *opaque)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    IscsiAIOCB *acb;\n\n    size_t qemu_read_size;\n\n    int i;\n\n    uint64_t lba;\n\n    uint32_t num_sectors;\n\n\n\n    qemu_read_size = BDRV_SECTOR_SIZE * (size_t)nb_sectors;\n\n\n\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n\n    trace_iscsi_aio_readv(iscsi, sector_num, nb_sectors, opaque, acb);\n\n\n\n    acb->iscsilun = iscsilun;\n\n    acb->qiov     = qiov;\n\n\n\n    acb->canceled    = 0;\n\n    acb->bh          = NULL;\n\n    acb->status      = -EINPROGRESS;\n\n    acb->read_size   = qemu_read_size;\n\n    acb->buf         = NULL;\n\n\n\n    /* If LUN blocksize is bigger than BDRV_BLOCK_SIZE a read from QEMU\n\n     * may be misaligned to the LUN, so we may need to read some extra\n\n     * data.\n\n     */\n\n    acb->read_offset = 0;\n\n    if (iscsilun->block_size > BDRV_SECTOR_SIZE) {\n\n        uint64_t bdrv_offset = BDRV_SECTOR_SIZE * sector_num;\n\n\n\n        acb->read_offset  = bdrv_offset % iscsilun->block_size;\n\n    }\n\n\n\n    num_sectors  = (qemu_read_size + iscsilun->block_size\n\n                    + acb->read_offset - 1)\n\n                    / iscsilun->block_size;\n\n\n\n    acb->task = malloc(sizeof(struct scsi_task));\n\n    if (acb->task == NULL) {\n\n        error_report(\"iSCSI: Failed to allocate task for scsi READ16 \"\n\n                     \"command. %s\", iscsi_get_error(iscsi));\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    memset(acb->task, 0, sizeof(struct scsi_task));\n\n\n\n    acb->task->xfer_dir = SCSI_XFER_READ;\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n    acb->task->expxferlen = qemu_read_size;\n\n\n\n    switch (iscsilun->type) {\n\n    case TYPE_DISK:\n\n        acb->task->cdb_size = 16;\n\n        acb->task->cdb[0]  = 0x88;\n\n        *(uint32_t *)&acb->task->cdb[2]  = htonl(lba >> 32);\n\n        *(uint32_t *)&acb->task->cdb[6]  = htonl(lba & 0xffffffff);\n\n        *(uint32_t *)&acb->task->cdb[10] = htonl(num_sectors);\n\n        break;\n\n    default:\n\n        acb->task->cdb_size = 10;\n\n        acb->task->cdb[0]  = 0x28;\n\n        *(uint32_t *)&acb->task->cdb[2] = htonl(lba);\n\n        *(uint16_t *)&acb->task->cdb[7] = htons(num_sectors);\n\n        break;\n\n    }\n\n    \n\n    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,\n\n                                 iscsi_aio_read16_cb,\n\n                                 NULL,\n\n                                 acb) != 0) {\n\n        scsi_free_scsi_task(acb->task);\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < acb->qiov->niov; i++) {\n\n        scsi_task_add_data_in_buffer(acb->task,\n\n                acb->qiov->iov[i].iov_len,\n\n                acb->qiov->iov[i].iov_base);\n\n    }\n\n\n\n    iscsi_set_events(iscsilun);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 12022}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "void scsi_req_complete(SCSIRequest *req)\n\n{\n\n    assert(req->status != -1);\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->bus->ops->complete(req->bus, SCSI_REASON_DONE,\n\n                            req->tag,\n\n                            req->status);\n\n    scsi_req_unref(req);\n\n}\n", "idx": 1242}
{"project": "qemu", "commit_id": "9c4bbee9e3b83544257e82566342c29e15a88637", "target": 1, "func": "static inline int handle_cpu_signal(uintptr_t pc, siginfo_t *info,\n\n                                    int is_write, sigset_t *old_set)\n\n{\n\n    CPUState *cpu = current_cpu;\n\n    CPUClass *cc;\n\n    int ret;\n\n    unsigned long address = (unsigned long)info->si_addr;\n\n\n\n    /* We must handle PC addresses from two different sources:\n\n     * a call return address and a signal frame address.\n\n     *\n\n     * Within cpu_restore_state_from_tb we assume the former and adjust\n\n     * the address by -GETPC_ADJ so that the address is within the call\n\n     * insn so that addr does not accidentally match the beginning of the\n\n     * next guest insn.\n\n     *\n\n     * However, when the PC comes from the signal frame, it points to\n\n     * the actual faulting host insn and not a call insn.  Subtracting\n\n     * GETPC_ADJ in that case may accidentally match the previous guest insn.\n\n     *\n\n     * So for the later case, adjust forward to compensate for what\n\n     * will be done later by cpu_restore_state_from_tb.\n\n     */\n\n    if (helper_retaddr) {\n\n        pc = helper_retaddr;\n\n    } else {\n\n        pc += GETPC_ADJ;\n\n    }\n\n\n\n    /* For synchronous signals we expect to be coming from the vCPU\n\n     * thread (so current_cpu should be valid) and either from running\n\n     * code or during translation which can fault as we cross pages.\n\n     *\n\n     * If neither is true then something has gone wrong and we should\n\n     * abort rather than try and restart the vCPU execution.\n\n     */\n\n    if (!cpu || !cpu->running) {\n\n        printf(\"qemu:%s received signal outside vCPU context @ pc=0x%\"\n\n               PRIxPTR \"\\n\",  __func__, pc);\n\n        abort();\n\n    }\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\",\n\n           pc, address, is_write, *(unsigned long *)old_set);\n\n#endif\n\n    /* XXX: locking issue */\n\n    if (is_write && h2g_valid(address)) {\n\n        switch (page_unprotect(h2g(address), pc)) {\n\n        case 0:\n\n            /* Fault not caused by a page marked unwritable to protect\n\n             * cached translations, must be the guest binary's problem.\n\n             */\n\n            break;\n\n        case 1:\n\n            /* Fault caused by protection of cached translation; TBs\n\n             * invalidated, so resume execution.  Retain helper_retaddr\n\n             * for a possible second fault.\n\n             */\n\n            return 1;\n\n        case 2:\n\n            /* Fault caused by protection of cached translation, and the\n\n             * currently executing TB was modified and must be exited\n\n             * immediately.  Clear helper_retaddr for next execution.\n\n             */\n\n            helper_retaddr = 0;\n\n            cpu_exit_tb_from_sighandler(cpu, old_set);\n\n            /* NORETURN */\n\n\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n    }\n\n\n\n    /* Convert forcefully to guest address space, invalid addresses\n\n       are still valid segv ones */\n\n    address = h2g_nocheck(address);\n\n\n\n    cc = CPU_GET_CLASS(cpu);\n\n    /* see if it is an MMU fault */\n\n    g_assert(cc->handle_mmu_fault);\n\n    ret = cc->handle_mmu_fault(cpu, address, is_write, MMU_USER_IDX);\n\n\n\n    if (ret == 0) {\n\n        /* The MMU fault was handled without causing real CPU fault.\n\n         *  Retain helper_retaddr for a possible second fault.\n\n         */\n\n        return 1;\n\n    }\n\n\n\n    /* All other paths lead to cpu_exit; clear helper_retaddr\n\n     * for next execution.\n\n     */\n\n    helper_retaddr = 0;\n\n\n\n    if (ret < 0) {\n\n        return 0; /* not an MMU fault */\n\n    }\n\n\n\n    /* Now we have a real cpu fault.  */\n\n    cpu_restore_state(cpu, pc);\n\n\n\n    sigprocmask(SIG_SETMASK, old_set, NULL);\n\n    cpu_loop_exit(cpu);\n\n\n\n    /* never comes here */\n\n    return 1;\n\n}\n", "idx": 8189}
{"project": "qemu", "commit_id": "3ae59580a0db469c1de72d5c58266b08fb096056", "target": 1, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->dev);\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n\n    g_free(bs);\n\n}", "idx": 4260}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint64_t ram_chunk_index(const uint8_t *start,\n\n                                       const uint8_t *host)\n\n{\n\n    return ((uintptr_t) host - (uintptr_t) start) >> RDMA_REG_CHUNK_SHIFT;\n\n}\n", "idx": 6541}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dew_0c(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned ra = extract32(insn, 21, 5);\n\n    return do_fop_dew(ctx, rt, ra, di->f_dew);\n\n}\n", "idx": 2260}
{"project": "qemu", "commit_id": "87e459a810d7b1ec1638085b5a80ea3d9b43119a", "target": 1, "func": "static void megasas_command_complete(SCSIRequest *req, uint32_t status,\n\n                                     size_t resid)\n\n{\n\n    MegasasCmd *cmd = req->hba_private;\n\n    uint8_t cmd_status = MFI_STAT_OK;\n\n\n\n    trace_megasas_command_complete(cmd->index, status, resid);\n\n\n\n    if (req->io_canceled) {\n\n        return;\n\n    }\n\n\n\n    if (cmd->req == NULL) {\n\n        /*\n\n         * Internal command complete\n\n         */\n\n        cmd_status = megasas_finish_internal_dcmd(cmd, req, resid);\n\n        if (cmd_status == MFI_STAT_INVALID_STATUS) {\n\n            return;\n\n        }\n\n    } else {\n\n        req->status = status;\n\n        trace_megasas_scsi_complete(cmd->index, req->status,\n\n                                    cmd->iov_size, req->cmd.xfer);\n\n        if (req->status != GOOD) {\n\n            cmd_status = MFI_STAT_SCSI_DONE_WITH_ERROR;\n\n        }\n\n        if (req->status == CHECK_CONDITION) {\n\n            megasas_copy_sense(cmd);\n\n        }\n\n\n\n        cmd->frame->header.scsi_status = req->status;\n\n    }\n\n    cmd->frame->header.cmd_status = cmd_status;\n\n    megasas_complete_command(cmd);\n\n}\n", "idx": 11153}
{"project": "qemu", "commit_id": "f80c98740e8da9fa0e4056f174ca66a3afb1d15b", "target": 1, "func": "static int vtd_dev_to_context_entry(IntelIOMMUState *s, uint8_t bus_num,\n\n                                    uint8_t devfn, VTDContextEntry *ce)\n\n{\n\n    VTDRootEntry re;\n\n    int ret_fr;\n\n\n\n    ret_fr = vtd_get_root_entry(s, bus_num, &re);\n\n    if (ret_fr) {\n\n        return ret_fr;\n\n    }\n\n\n\n    if (!vtd_root_entry_present(&re)) {\n\n        /* Not error - it's okay we don't have root entry. */\n\n        trace_vtd_re_not_present(bus_num);\n\n        return -VTD_FR_ROOT_ENTRY_P;\n\n    } else if (re.rsvd || (re.val & VTD_ROOT_ENTRY_RSVD)) {\n\n        trace_vtd_re_invalid(re.rsvd, re.val);\n\n        return -VTD_FR_ROOT_ENTRY_RSVD;\n\n    }\n\n\n\n    ret_fr = vtd_get_context_entry_from_root(&re, devfn, ce);\n\n    if (ret_fr) {\n\n        return ret_fr;\n\n    }\n\n\n\n    if (!vtd_ce_present(ce)) {\n\n        /* Not error - it's okay we don't have context entry. */\n\n        trace_vtd_ce_not_present(bus_num, devfn);\n\n        return -VTD_FR_CONTEXT_ENTRY_P;\n\n    } else if ((ce->hi & VTD_CONTEXT_ENTRY_RSVD_HI) ||\n\n               (ce->lo & VTD_CONTEXT_ENTRY_RSVD_LO)) {\n\n        trace_vtd_ce_invalid(ce->hi, ce->lo);\n\n        return -VTD_FR_CONTEXT_ENTRY_RSVD;\n\n    }\n\n    /* Check if the programming of context-entry is valid */\n\n    if (!vtd_is_level_supported(s, vtd_ce_get_level(ce))) {\n\n        trace_vtd_ce_invalid(ce->hi, ce->lo);\n\n        return -VTD_FR_CONTEXT_ENTRY_INV;\n\n    } else {\n\n        switch (vtd_ce_get_type(ce)) {\n\n        case VTD_CONTEXT_TT_MULTI_LEVEL:\n\n            /* fall through */\n\n        case VTD_CONTEXT_TT_DEV_IOTLB:\n\n            break;\n\n        default:\n\n            trace_vtd_ce_invalid(ce->hi, ce->lo);\n\n            return -VTD_FR_CONTEXT_ENTRY_INV;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6472}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static void dcr_write_pob (void *opaque, int dcrn, uint32_t val)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        /* Read only */\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        /* Write-clear */\n\n        pob->besr[dcrn - POB0_BESR0] &= ~val;\n\n        break;\n\n    }\n\n}\n", "idx": 4906}
{"project": "qemu", "commit_id": "0ddbd0536296f5a36c8f225edd4d14441be6b153", "target": 1, "func": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    uint32_t *hc = (uint32_t*)buf;\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (!kvmppc_get_pvinfo(env, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls regardless of endianness:\n\n     *\n\n     *     tdi 0,r0,72 (becomes b .+8 in wrong endian, nop in good endian)\n\n     *     li r3, -1\n\n     *     b .+8       (becomes nop in wrong endian)\n\n     *     bswap32(li r3, -1)\n\n     */\n\n\n\n    hc[0] = cpu_to_be32(0x08000048);\n\n    hc[1] = cpu_to_be32(0x3860ffff);\n\n    hc[2] = cpu_to_be32(0x48000008);\n\n    hc[3] = cpu_to_be32(bswap32(0x3860ffff));\n\n\n\n    return 0;\n\n}\n", "idx": 8765}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_sru(DisasContext *dc)\n\n{\n\n    if (dc->format == OP_FMT_RI) {\n\n        LOG_DIS(\"srui r%d, r%d, %d\\n\", dc->r1, dc->r0, dc->imm5);\n\n    } else {\n\n        LOG_DIS(\"sru r%d, r%d, r%d\\n\", dc->r2, dc->r0, dc->r1);\n\n    }\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_SHIFT)) {\n\n        if (dc->format == OP_FMT_RI) {\n\n            /* TODO: check r1 == 1 during runtime */\n\n        } else {\n\n            if (dc->imm5 != 1) {\n\n                cpu_abort(dc->env, \"hardware shifter is not available\\n\");\n\n            }\n\n        }\n\n    }\n\n\n\n    if (dc->format == OP_FMT_RI) {\n\n        tcg_gen_shri_tl(cpu_R[dc->r1], cpu_R[dc->r0], dc->imm5);\n\n    } else {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_R[dc->r1], 0x1f);\n\n        tcg_gen_shr_tl(cpu_R[dc->r2], cpu_R[dc->r0], t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 2902}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 10600}
{"project": "qemu", "commit_id": "c3b08d0e05f381b0a02647038d454eecf51ae014", "target": 1, "func": "void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n\n{\n\n    TCGOpcode op;\n\n    TCGOpDef *def;\n\n    const char *ct_str;\n\n    int i, nb_args;\n\n\n\n    for(;;) {\n\n        if (tdefs->op == (TCGOpcode)-1)\n\n            break;\n\n        op = tdefs->op;\n\n        assert(op >= 0 && op < NB_OPS);\n\n        def = &tcg_op_defs[op];\n\n#if defined(CONFIG_DEBUG_TCG)\n\n        /* Duplicate entry in op definitions? */\n\n        assert(!def->used);\n\n        def->used = 1;\n\n#endif\n\n        nb_args = def->nb_iargs + def->nb_oargs;\n\n        for(i = 0; i < nb_args; i++) {\n\n            ct_str = tdefs->args_ct_str[i];\n\n            /* Incomplete TCGTargetOpDef entry? */\n\n            assert(ct_str != NULL);\n\n            tcg_regset_clear(def->args_ct[i].u.regs);\n\n            def->args_ct[i].ct = 0;\n\n            if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n\n                int oarg;\n\n                oarg = ct_str[0] - '0';\n\n                assert(oarg < def->nb_oargs);\n\n                assert(def->args_ct[oarg].ct & TCG_CT_REG);\n\n                /* TCG_CT_ALIAS is for the output arguments. The input\n\n                   argument is tagged with TCG_CT_IALIAS. */\n\n                def->args_ct[i] = def->args_ct[oarg];\n\n                def->args_ct[oarg].ct = TCG_CT_ALIAS;\n\n                def->args_ct[oarg].alias_index = i;\n\n                def->args_ct[i].ct |= TCG_CT_IALIAS;\n\n                def->args_ct[i].alias_index = oarg;\n\n            } else {\n\n                for(;;) {\n\n                    if (*ct_str == '\\0')\n\n                        break;\n\n                    switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < ARRAY_SIZE(tcg_op_defs); op++) {\n\n        if (op < INDEX_op_call || op == INDEX_op_debug_insn_start) {\n\n            /* Wrong entry in op definitions? */\n\n            if (tcg_op_defs[op].used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\",\n\n                        tcg_op_defs[op].name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!tcg_op_defs[op].used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\",\n\n                        tcg_op_defs[op].name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n", "idx": 760}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "static void qmp_command_info(QmpCommand *cmd, void *opaque)\n\n{\n\n    GuestAgentInfo *info = opaque;\n\n    GuestAgentCommandInfo *cmd_info;\n\n    GuestAgentCommandInfoList *cmd_info_list;\n\n\n\n    cmd_info = g_malloc0(sizeof(GuestAgentCommandInfo));\n\n    cmd_info->name = g_strdup(qmp_command_name(cmd));\n\n    cmd_info->enabled = qmp_command_is_enabled(cmd);\n\n    cmd_info->success_response = qmp_has_success_response(cmd);\n\n\n\n    cmd_info_list = g_malloc0(sizeof(GuestAgentCommandInfoList));\n\n    cmd_info_list->value = cmd_info;\n\n    cmd_info_list->next = info->supported_commands;\n\n    info->supported_commands = cmd_info_list;\n\n}\n", "idx": 8451}
{"project": "qemu", "commit_id": "11b7b07f8a15879134a54e73fade98d5e11e04f8", "target": 1, "func": "char *qdist_pr_plain(const struct qdist *dist, size_t n)\n\n{\n\n    struct qdist binned;\n\n    char *ret;\n\n\n\n    if (dist->n == 0) {\n\n        return NULL;\n\n    }\n\n    qdist_bin__internal(&binned, dist, n);\n\n    ret = qdist_pr_internal(&binned);\n\n    qdist_destroy(&binned);\n\n    return ret;\n\n}\n", "idx": 854}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n", "idx": 2132}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_cpu_kick_self(void)\n\n{\n\n#ifndef _WIN32\n\n    assert(cpu_single_env);\n\n\n\n    raise(SIG_IPI);\n\n#else\n\n    abort();\n\n#endif\n\n}\n", "idx": 10915}
{"project": "qemu", "commit_id": "8bd6b06d7b718b3e595aab279699ef3651ce2e48", "target": 1, "func": "void console_select(unsigned int index)\n\n{\n\n    TextConsole *s;\n\n\n\n    if (index >= MAX_CONSOLES)\n\n        return;\n\n    if (active_console) {\n\n        active_console->g_width = ds_get_width(active_console->ds);\n\n        active_console->g_height = ds_get_height(active_console->ds);\n\n    }\n\n    s = consoles[index];\n\n    if (s) {\n\n        DisplayState *ds = s->ds;\n\n\n\n        if (active_console->cursor_timer) {\n\n            qemu_del_timer(active_console->cursor_timer);\n\n        }\n\n        active_console = s;\n\n        if (ds_get_bits_per_pixel(s->ds)) {\n\n            ds->surface = qemu_resize_displaysurface(ds, s->g_width, s->g_height);\n\n        } else {\n\n            s->ds->surface->width = s->width;\n\n            s->ds->surface->height = s->height;\n\n        }\n\n        if (s->cursor_timer) {\n\n            qemu_mod_timer(s->cursor_timer,\n\n                   qemu_get_clock_ms(rt_clock) + CONSOLE_CURSOR_PERIOD / 2);\n\n        }\n\n        dpy_resize(s->ds);\n\n        vga_hw_invalidate();\n\n    }\n\n}\n", "idx": 10740}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 10612}
{"project": "qemu", "commit_id": "9d4ec9370a36f8a564e1ba05519328c0bd60da13", "target": 1, "func": "void *qemu_ram_mmap(int fd, size_t size, size_t align, bool shared)\n\n{\n\n    /*\n\n     * Note: this always allocates at least one extra page of virtual address\n\n     * space, even if size is already aligned.\n\n     */\n\n    size_t total = size + align;\n\n    void *ptr = mmap(0, total, PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\n    size_t offset = QEMU_ALIGN_UP((uintptr_t)ptr, align) - (uintptr_t)ptr;\n\n    void *ptr1;\n\n\n\n    if (ptr == MAP_FAILED) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Make sure align is a power of 2 */\n\n    assert(!(align & (align - 1)));\n\n    /* Always align to host page size */\n\n    assert(align >= getpagesize());\n\n\n\n    ptr1 = mmap(ptr + offset, size, PROT_READ | PROT_WRITE,\n\n                MAP_FIXED |\n\n                (fd == -1 ? MAP_ANONYMOUS : 0) |\n\n                (shared ? MAP_SHARED : MAP_PRIVATE),\n\n                fd, 0);\n\n    if (ptr1 == MAP_FAILED) {\n\n        munmap(ptr, total);\n\n        return NULL;\n\n    }\n\n\n\n    ptr += offset;\n\n    total -= offset;\n\n\n\n    if (offset > 0) {\n\n        munmap(ptr - offset, offset);\n\n    }\n\n\n\n    /*\n\n     * Leave a single PROT_NONE page allocated after the RAM block, to serve as\n\n     * a guard page guarding against potential buffer overflows.\n\n     */\n\n    if (total > size + getpagesize()) {\n\n        munmap(ptr + size + getpagesize(), total - size - getpagesize());\n\n    }\n\n\n\n    return ptr;\n\n}\n", "idx": 5158}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static void spr_read_hdecr(DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_hdecr(cpu_gpr[gprn], cpu_env);\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 2046}
{"project": "qemu", "commit_id": "e7eee62a90c671d22d50964b7de05e3f4fd96f5f", "target": 1, "func": "void HELPER(simcall)(CPUXtensaState *env)\n\n{\n\n    uint32_t *regs = env->regs;\n\n\n\n    switch (regs[2]) {\n\n    case TARGET_SYS_exit:\n\n        qemu_log(\"exit(%d) simcall\\n\", regs[3]);\n\n        exit(regs[3]);\n\n        break;\n\n\n\n    case TARGET_SYS_read:\n\n    case TARGET_SYS_write:\n\n        {\n\n            bool is_write = regs[2] == TARGET_SYS_write;\n\n            uint32_t fd = regs[3];\n\n            uint32_t vaddr = regs[4];\n\n            uint32_t len = regs[5];\n\n\n\n            while (len > 0) {\n\n                target_phys_addr_t paddr =\n\n                    cpu_get_phys_page_debug(env, vaddr);\n\n                uint32_t page_left =\n\n                    TARGET_PAGE_SIZE - (vaddr & (TARGET_PAGE_SIZE - 1));\n\n                uint32_t io_sz = page_left < len ? page_left : len;\n\n                target_phys_addr_t sz = io_sz;\n\n                void *buf = cpu_physical_memory_map(paddr, &sz, is_write);\n\n\n\n                if (buf) {\n\n                    vaddr += io_sz;\n\n                    len -= io_sz;\n\n                    regs[2] = is_write ?\n\n                        write(fd, buf, io_sz) :\n\n                        read(fd, buf, io_sz);\n\n                    regs[3] = errno;\n\n                    cpu_physical_memory_unmap(buf, sz, is_write, sz);\n\n                    if (regs[2] == -1) {\n\n                        break;\n\n                    }\n\n                } else {\n\n\n                    regs[3] = EINVAL;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case TARGET_SYS_open:\n\n        {\n\n            char name[1024];\n\n            int rc;\n\n            int i;\n\n\n\n            for (i = 0; i < ARRAY_SIZE(name); ++i) {\n\n                rc = cpu_memory_rw_debug(\n\n                        env, regs[3] + i, (uint8_t *)name + i, 1, 0);\n\n                if (rc != 0 || name[i] == 0) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (rc == 0 && i < ARRAY_SIZE(name)) {\n\n                regs[2] = open(name, regs[4], regs[5]);\n\n                regs[3] = errno;\n\n            } else {\n\n\n                regs[3] = EINVAL;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case TARGET_SYS_close:\n\n        if (regs[3] < 3) {\n\n            regs[2] = regs[3] = 0;\n\n        } else {\n\n            regs[2] = close(regs[3]);\n\n            regs[3] = errno;\n\n        }\n\n        break;\n\n\n\n    case TARGET_SYS_lseek:\n\n        regs[2] = lseek(regs[3], (off_t)(int32_t)regs[4], regs[5]);\n\n        regs[3] = errno;\n\n        break;\n\n\n\n    case TARGET_SYS_select_one:\n\n        {\n\n            uint32_t fd = regs[3];\n\n            uint32_t rq = regs[4];\n\n            uint32_t target_tv = regs[5];\n\n            uint32_t target_tvv[2];\n\n\n\n            struct timeval tv = {0};\n\n            fd_set fdset;\n\n\n\n            FD_ZERO(&fdset);\n\n            FD_SET(fd, &fdset);\n\n\n\n            if (target_tv) {\n\n                cpu_memory_rw_debug(env, target_tv,\n\n                        (uint8_t *)target_tvv, sizeof(target_tvv), 0);\n\n                tv.tv_sec = (int32_t)tswap32(target_tvv[0]);\n\n                tv.tv_usec = (int32_t)tswap32(target_tvv[1]);\n\n            }\n\n            regs[2] = select(fd + 1,\n\n                    rq == SELECT_ONE_READ   ? &fdset : NULL,\n\n                    rq == SELECT_ONE_WRITE  ? &fdset : NULL,\n\n                    rq == SELECT_ONE_EXCEPT ? &fdset : NULL,\n\n                    target_tv ? &tv : NULL);\n\n            regs[3] = errno;\n\n        }\n\n        break;\n\n\n\n    case TARGET_SYS_argc:\n\n        regs[2] = 1;\n\n        regs[3] = 0;\n\n        break;\n\n\n\n    case TARGET_SYS_argv_sz:\n\n        regs[2] = 128;\n\n        regs[3] = 0;\n\n        break;\n\n\n\n    case TARGET_SYS_argv:\n\n        {\n\n            struct Argv {\n\n                uint32_t argptr[2];\n\n                char text[120];\n\n            } argv = {\n\n                {0, 0},\n\n                \"test\"\n\n            };\n\n\n\n            argv.argptr[0] = tswap32(regs[3] + offsetof(struct Argv, text));\n\n            cpu_memory_rw_debug(\n\n                    env, regs[3], (uint8_t *)&argv, sizeof(argv), 1);\n\n        }\n\n        break;\n\n\n\n    case TARGET_SYS_memset:\n\n        {\n\n            uint32_t base = regs[3];\n\n            uint32_t sz = regs[5];\n\n\n\n            while (sz) {\n\n                target_phys_addr_t len = sz;\n\n                void *buf = cpu_physical_memory_map(base, &len, 1);\n\n\n\n                if (buf && len) {\n\n                    memset(buf, regs[4], len);\n\n                    cpu_physical_memory_unmap(buf, len, 1, len);\n\n                } else {\n\n                    len = 1;\n\n                }\n\n                base += len;\n\n                sz -= len;\n\n            }\n\n            regs[2] = regs[3];\n\n            regs[3] = 0;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        qemu_log(\"%s(%d): not implemented\\n\", __func__, regs[2]);\n\n\n\n        break;\n\n    }\n\n}", "idx": 7227}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stw_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint32_t val)\n\n{\n\n    val = tswap32(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 3417}
{"project": "qemu", "commit_id": "b9a0be9239ef58630c6b436ac7ed2cf0bc3a028d", "target": 1, "func": "print_ipc_cmd(int cmd)\n\n{\n\n#define output_cmd(val) \\\n\nif( cmd == val ) { \\\n\n    gemu_log(#val); \\\n\n    return; \\\n\n}\n\n\n\n    cmd &= 0xff;\n\n\n\n    /* General IPC commands */\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_SET );\n\n    output_cmd( IPC_STAT );\n\n    output_cmd( IPC_INFO );\n\n    /* msgctl() commands */\n\n    #ifdef __USER_MISC\n\n    output_cmd( MSG_STAT );\n\n    output_cmd( MSG_INFO );\n\n    #endif\n\n    /* shmctl() commands */\n\n    output_cmd( SHM_LOCK );\n\n    output_cmd( SHM_UNLOCK );\n\n    output_cmd( SHM_STAT );\n\n    output_cmd( SHM_INFO );\n\n    /* semctl() commands */\n\n    output_cmd( GETPID );\n\n    output_cmd( GETVAL );\n\n    output_cmd( GETALL );\n\n    output_cmd( GETNCNT );\n\n    output_cmd( GETZCNT );\n\n    output_cmd( SETVAL );\n\n    output_cmd( SETALL );\n\n    output_cmd( SEM_STAT );\n\n    output_cmd( SEM_INFO );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n    output_cmd( IPC_RMID );\n\n\n\n    /* Some value we don't recognize */\n\n    gemu_log(\"%d\",cmd);\n\n}\n", "idx": 8837}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_unplug_child(HotplugHandler *plug_handler,\n\n                                       DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnectorClass *drck;\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    if (!phb->dr_enabled) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                   object_get_typename(OBJECT(phb)));\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    if (!drck->release_pending(drc)) {\n\n        spapr_phb_remove_pci_device(drc, phb, pdev, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        spapr_hotplug_req_remove_by_index(drc);\n\n    }\n\n}\n", "idx": 8431}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "static void tlb_flush_by_mmuidx_async_work(CPUState *cpu, run_on_cpu_data data)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    unsigned long mmu_idx_bitmask = data.host_int;\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    tb_lock();\n\n\n\n    tlb_debug(\"start: mmu_idx:0x%04lx\\n\", mmu_idx_bitmask);\n\n\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n\n\n        if (test_bit(mmu_idx, &mmu_idx_bitmask)) {\n\n            tlb_debug(\"%d\\n\", mmu_idx);\n\n\n\n            memset(env->tlb_table[mmu_idx], -1, sizeof(env->tlb_table[0]));\n\n            memset(env->tlb_v_table[mmu_idx], -1, sizeof(env->tlb_v_table[0]));\n\n        }\n\n    }\n\n\n\n    memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));\n\n\n\n    tlb_debug(\"done\\n\");\n\n\n\n    tb_unlock();\n\n}\n", "idx": 9587}
{"project": "qemu", "commit_id": "d63fb193e71644a073b77ff5ac6f1216f2f6cf6e", "target": 1, "func": "static void coroutine_fn v9fs_create(void *opaque)\n\n{\n\n    int32_t fid;\n\n    int err = 0;\n\n    size_t offset = 7;\n\n    V9fsFidState *fidp;\n\n    V9fsQID qid;\n\n    int32_t perm;\n\n    int8_t mode;\n\n    V9fsPath path;\n\n    struct stat stbuf;\n\n    V9fsString name;\n\n    V9fsString extension;\n\n    int iounit;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    v9fs_path_init(&path);\n\n    v9fs_string_init(&name);\n\n    v9fs_string_init(&extension);\n\n    err = pdu_unmarshal(pdu, offset, \"dsdbs\", &fid, &name,\n\n                        &perm, &mode, &extension);\n\n    if (err < 0) {\n\n        goto out_nofid;\n\n\n    trace_v9fs_create(pdu->tag, pdu->id, fid, name.data, perm, mode);\n\n\n\n    if (name_is_illegal(name.data)) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n\n\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n\n        err = -EEXIST;\n\n        goto out_nofid;\n\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n\n        goto out_nofid;\n\n\n\n\n\n\n    if (perm & P9_STAT_MODE_DIR) {\n\n        err = v9fs_co_mkdir(pdu, fidp, &name, perm & 0777,\n\n                            fidp->uid, -1, &stbuf);\n\n        if (err < 0) {\n\n\n\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n\n        if (err < 0) {\n\n\n\n        v9fs_path_copy(&fidp->path, &path);\n\n        err = v9fs_co_opendir(pdu, fidp);\n\n        if (err < 0) {\n\n\n\n        fidp->fid_type = P9_FID_DIR;\n\n    } else if (perm & P9_STAT_MODE_SYMLINK) {\n\n        err = v9fs_co_symlink(pdu, fidp, &name,\n\n                              extension.data, -1 , &stbuf);\n\n        if (err < 0) {\n\n\n\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n\n        if (err < 0) {\n\n\n\n        v9fs_path_copy(&fidp->path, &path);\n\n    } else if (perm & P9_STAT_MODE_LINK) {\n\n        int32_t ofid = atoi(extension.data);\n\n        V9fsFidState *ofidp = get_fid(pdu, ofid);\n\n        if (ofidp == NULL) {\n\n\n\n\n        err = v9fs_co_link(pdu, ofidp, fidp, &name);\n\n        put_fid(pdu, ofidp);\n\n        if (err < 0) {\n\n\n\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n\n        if (err < 0) {\n\n            fidp->fid_type = P9_FID_NONE;\n\n\n\n        v9fs_path_copy(&fidp->path, &path);\n\n        err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n        if (err < 0) {\n\n            fidp->fid_type = P9_FID_NONE;\n\n\n\n    } else if (perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(extension.data, \"%c %u %u\", &ctype, &major, &minor) != 3) {\n\n            err = -errno;\n\n\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n\n\n\n\n        nmode |= perm & 0777;\n\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n\n                            makedev(major, minor), nmode, &stbuf);\n\n        if (err < 0) {\n\n\n\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n\n        if (err < 0) {\n\n\n\n        v9fs_path_copy(&fidp->path, &path);\n\n    } else if (perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n\n                            0, S_IFIFO | (perm & 0777), &stbuf);\n\n        if (err < 0) {\n\n\n\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n\n        if (err < 0) {\n\n\n\n        v9fs_path_copy(&fidp->path, &path);\n\n    } else if (perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n\n                            0, S_IFSOCK | (perm & 0777), &stbuf);\n\n        if (err < 0) {\n\n\n\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n\n        if (err < 0) {\n\n\n\n        v9fs_path_copy(&fidp->path, &path);\n\n    } else {\n\n        err = v9fs_co_open2(pdu, fidp, &name, -1,\n\n                            omode_to_uflags(mode)|O_CREAT, perm, &stbuf);\n\n        if (err < 0) {\n\n\n\n        fidp->fid_type = P9_FID_FILE;\n\n        fidp->open_flags = omode_to_uflags(mode);\n\n        if (fidp->open_flags & O_EXCL) {\n\n            /*\n\n             * We let the host file system do O_EXCL check\n\n             * We should not reclaim such fd\n\n             */\n\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n\n\n    iounit = get_iounit(pdu, &fidp->path);\n\n    stat_to_qid(&stbuf, &qid);\n\n    err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n    if (err < 0) {\n\n\n\n    err += offset;\n\n    trace_v9fs_create_return(pdu->tag, pdu->id,\n\n                             qid.type, qid.version, qid.path, iounit);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n   pdu_complete(pdu, err);\n\n   v9fs_string_free(&name);\n\n   v9fs_string_free(&extension);\n\n   v9fs_path_free(&path);\n", "idx": 1791}
{"project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "target": 1, "func": "static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\n\t\t\t\t\t      unsigned mode,\n\n\t\t\t\t\t      unsigned offset,\n\n\t\t\t\t\t      uint32_t mem_value)\n\n{\n\n    int x;\n\n    unsigned val = mem_value;\n\n    uint8_t *dst;\n\n\n\n    dst = s->vram_ptr + offset;\n\n    for (x = 0; x < 8; x++) {\n\n\tif (val & 0x80) {\n\n\t    *dst = s->cirrus_shadow_gr1;\n\n\t    *(dst + 1) = s->gr[0x11];\n\n\t} else if (mode == 5) {\n\n\t    *dst = s->cirrus_shadow_gr0;\n\n\t    *(dst + 1) = s->gr[0x10];\n\n\t}\n\n\tval <<= 1;\n\n\tdst += 2;\n\n    }\n\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 15);\n\n}\n", "idx": 4711}
{"project": "qemu", "commit_id": "d26e445c80fddcc7483b83f3115e5067fef28fe6", "target": 1, "func": "int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n\n             int vnet_hdr_required, int mq_required)\n\n{\n\n    struct ifreq ifr;\n\n    int fd, ret;\n\n    int len = sizeof(struct virtio_net_hdr);\n\n\n\n    TFR(fd = open(PATH_NET_TUN, O_RDWR));\n\n    if (fd < 0) {\n\n        error_report(\"could not open %s: %m\", PATH_NET_TUN);\n\n        return -1;\n\n    }\n\n    memset(&ifr, 0, sizeof(ifr));\n\n    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\n\n\n    if (*vnet_hdr) {\n\n        unsigned int features;\n\n\n\n        if (ioctl(fd, TUNGETFEATURES, &features) == 0 &&\n\n            features & IFF_VNET_HDR) {\n\n            *vnet_hdr = 1;\n\n            ifr.ifr_flags |= IFF_VNET_HDR;\n\n        } else {\n\n            *vnet_hdr = 0;\n\n        }\n\n\n\n        if (vnet_hdr_required && !*vnet_hdr) {\n\n            error_report(\"vnet_hdr=1 requested, but no kernel \"\n\n                         \"support for IFF_VNET_HDR available\");\n\n            close(fd);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Make sure vnet header size has the default value: for a persistent\n\n         * tap it might have been modified e.g. by another instance of qemu.\n\n         * Ignore errors since old kernels do not support this ioctl: in this\n\n         * case the header size implicitly has the correct value.\n\n         */\n\n        ioctl(fd, TUNSETVNETHDRSZ, &len);\n\n    }\n\n\n\n    if (mq_required) {\n\n        unsigned int features;\n\n\n\n        if ((ioctl(fd, TUNGETFEATURES, &features) != 0) ||\n\n            !(features & IFF_MULTI_QUEUE)) {\n\n            error_report(\"multiqueue required, but no kernel \"\n\n                         \"support for IFF_MULTI_QUEUE available\");\n\n            close(fd);\n\n            return -1;\n\n        } else {\n\n            ifr.ifr_flags |= IFF_MULTI_QUEUE;\n\n        }\n\n    }\n\n\n\n    if (ifname[0] != '\\0')\n\n        pstrcpy(ifr.ifr_name, IFNAMSIZ, ifname);\n\n    else\n\n        pstrcpy(ifr.ifr_name, IFNAMSIZ, \"tap%d\");\n\n    ret = ioctl(fd, TUNSETIFF, (void *) &ifr);\n\n    if (ret != 0) {\n\n        if (ifname[0] != '\\0') {\n\n            error_report(\"could not configure %s (%s): %m\", PATH_NET_TUN, ifr.ifr_name);\n\n        } else {\n\n            error_report(\"could not configure %s: %m\", PATH_NET_TUN);\n\n        }\n\n        close(fd);\n\n        return -1;\n\n    }\n\n    pstrcpy(ifname, ifname_size, ifr.ifr_name);\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n    return fd;\n\n}\n", "idx": 10704}
{"project": "qemu", "commit_id": "7b67b18adf921c77aa8443f3b4cddab87908ee1e", "target": 1, "func": "static void vhost_dev_sync_region(struct vhost_dev *dev,\n\n                                  uint64_t mfirst, uint64_t mlast,\n\n                                  uint64_t rfirst, uint64_t rlast)\n\n{\n\n    uint64_t start = MAX(mfirst, rfirst);\n\n    uint64_t end = MIN(mlast, rlast);\n\n    vhost_log_chunk_t *from = dev->log + start / VHOST_LOG_CHUNK;\n\n    vhost_log_chunk_t *to = dev->log + end / VHOST_LOG_CHUNK + 1;\n\n    uint64_t addr = (start / VHOST_LOG_CHUNK) * VHOST_LOG_CHUNK;\n\n\n\n    assert(end / VHOST_LOG_CHUNK < dev->log_size);\n\n    assert(start / VHOST_LOG_CHUNK < dev->log_size);\n\n    if (end < start) {\n\n        return;\n\n    }\n\n    for (;from < to; ++from) {\n\n        vhost_log_chunk_t log;\n\n        int bit;\n\n        /* We first check with non-atomic: much cheaper,\n\n         * and we expect non-dirty to be the common case. */\n\n        if (!*from) {\n\n            addr += VHOST_LOG_CHUNK;\n\n            continue;\n\n        }\n\n        /* Data must be read atomically. We don't really\n\n         * need the barrier semantics of __sync\n\n         * builtins, but it's easier to use them than\n\n         * roll our own. */\n\n        log = __sync_fetch_and_and(from, 0);\n\n        while ((bit = sizeof(log) > sizeof(int) ?\n\n                ffsll(log) : ffs(log))) {\n\n            bit -= 1;\n\n            cpu_physical_memory_set_dirty(addr + bit * VHOST_LOG_PAGE);\n\n            log &= ~(0x1ull << bit);\n\n        }\n\n        addr += VHOST_LOG_CHUNK;\n\n    }\n\n}\n", "idx": 5798}
{"project": "qemu", "commit_id": "69d4c703a549f0630793a67b16a8fc6bc14c8654", "target": 1, "func": "static inline abi_long target_to_host_semarray(int semid, unsigned short **host_array,\n\n                                               abi_ulong target_addr)\n\n{\n\n    int nsems;\n\n    unsigned short *array;\n\n    union semun semun;\n\n    struct semid_ds semid_ds;\n\n    int i, ret;\n\n\n\n    semun.buf = &semid_ds;\n\n\n\n    ret = semctl(semid, 0, IPC_STAT, semun);\n\n    if (ret == -1)\n\n        return get_errno(ret);\n\n\n\n    nsems = semid_ds.sem_nsems;\n\n\n\n    *host_array = malloc(nsems*sizeof(unsigned short));\n\n    array = lock_user(VERIFY_READ, target_addr,\n\n                      nsems*sizeof(unsigned short), 1);\n\n    if (!array)\n\n        return -TARGET_EFAULT;\n\n\n\n    for(i=0; i<nsems; i++) {\n\n        __get_user((*host_array)[i], &array[i]);\n\n    }\n\n    unlock_user(array, target_addr, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 4818}
{"project": "qemu", "commit_id": "3750dabc69d76f0938cc726a64a70e4ae2fe21df", "target": 1, "func": "static void virtio_pci_common_write(void *opaque, hwaddr addr,\n\n                                    uint64_t val, unsigned size)\n\n{\n\n    VirtIOPCIProxy *proxy = opaque;\n\n    VirtIODevice *vdev = virtio_bus_get_device(&proxy->bus);\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_COMMON_DFSELECT:\n\n        proxy->dfselect = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GFSELECT:\n\n        proxy->gfselect = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GF:\n\n        if (proxy->gfselect <= ARRAY_SIZE(proxy->guest_features)) {\n\n            proxy->guest_features[proxy->gfselect] = val;\n\n            virtio_set_features(vdev,\n\n                                (((uint64_t)proxy->guest_features[1]) << 32) |\n\n                                proxy->guest_features[0]);\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_MSIX:\n\n        msix_vector_unuse(&proxy->pci_dev, vdev->config_vector);\n\n        /* Make it possible for guest to discover an error took place. */\n\n        if (msix_vector_use(&proxy->pci_dev, val) < 0) {\n\n            val = VIRTIO_NO_VECTOR;\n\n        }\n\n        vdev->config_vector = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_STATUS:\n\n        if (!(val & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n            virtio_pci_stop_ioeventfd(proxy);\n\n        }\n\n\n\n        virtio_set_status(vdev, val & 0xFF);\n\n\n\n        if (val & VIRTIO_CONFIG_S_DRIVER_OK) {\n\n            virtio_pci_start_ioeventfd(proxy);\n\n        }\n\n\n\n        if (vdev->status == 0) {\n\n            virtio_reset(vdev);\n\n            msix_unuse_all_vectors(&proxy->pci_dev);\n\n        }\n\n\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SELECT:\n\n        if (val < VIRTIO_QUEUE_MAX) {\n\n            vdev->queue_sel = val;\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SIZE:\n\n        proxy->vqs[vdev->queue_sel].num = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_MSIX:\n\n        msix_vector_unuse(&proxy->pci_dev,\n\n                          virtio_queue_vector(vdev, vdev->queue_sel));\n\n        /* Make it possible for guest to discover an error took place. */\n\n        if (msix_vector_use(&proxy->pci_dev, val) < 0) {\n\n            val = VIRTIO_NO_VECTOR;\n\n        }\n\n        virtio_queue_set_vector(vdev, vdev->queue_sel, val);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_ENABLE:\n\n        /* TODO: need a way to put num back on reset. */\n\n        virtio_queue_set_num(vdev, vdev->queue_sel,\n\n                             proxy->vqs[vdev->queue_sel].num);\n\n        virtio_queue_set_rings(vdev, vdev->queue_sel,\n\n                       ((uint64_t)proxy->vqs[vdev->queue_sel].desc[1]) << 32 |\n\n                       proxy->vqs[vdev->queue_sel].desc[0],\n\n                       ((uint64_t)proxy->vqs[vdev->queue_sel].avail[1]) << 32 |\n\n                       proxy->vqs[vdev->queue_sel].avail[0],\n\n                       ((uint64_t)proxy->vqs[vdev->queue_sel].used[1]) << 32 |\n\n                       proxy->vqs[vdev->queue_sel].used[0]);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCLO:\n\n        proxy->vqs[vdev->queue_sel].desc[0] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCHI:\n\n        proxy->vqs[vdev->queue_sel].desc[1] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILLO:\n\n        proxy->vqs[vdev->queue_sel].avail[0] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILHI:\n\n        proxy->vqs[vdev->queue_sel].avail[1] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDLO:\n\n        proxy->vqs[vdev->queue_sel].used[0] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDHI:\n\n        proxy->vqs[vdev->queue_sel].used[1] = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 468}
{"project": "qemu", "commit_id": "d77f7779b4d74354b3444ceb0f93105ced3c26c8", "target": 1, "func": "static int do_readlink(struct iovec *iovec, struct iovec *out_iovec)\n\n{\n\n    char *buffer;\n\n    int size, retval;\n\n    V9fsString target, path;\n\n\n\n    v9fs_string_init(&path);\n\n    retval = proxy_unmarshal(iovec, PROXY_HDR_SZ, \"sd\", &path, &size);\n\n    if (retval < 0) {\n\n        v9fs_string_free(&path);\n\n        return retval;\n\n    }\n\n    buffer = g_malloc(size);\n\n    v9fs_string_init(&target);\n\n    retval = readlink(path.data, buffer, size);\n\n    if (retval > 0) {\n\n        buffer[retval] = '\\0';\n\n        v9fs_string_sprintf(&target, \"%s\", buffer);\n\n        retval = proxy_marshal(out_iovec, PROXY_HDR_SZ, \"s\", &target);\n\n    } else {\n\n        retval = -errno;\n\n    }\n\n    g_free(buffer);\n\n    v9fs_string_free(&target);\n\n    v9fs_string_free(&path);\n\n    return retval;\n\n}\n", "idx": 109}
{"project": "qemu", "commit_id": "e1f2641b5926d20f63d36f0de45206be774da8da", "target": 1, "func": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        assert(mon->outbuf_index < sizeof(mon->outbuf) - 1);\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n')\n\n            mon->outbuf[mon->outbuf_index++] = '\\r';\n\n        mon->outbuf[mon->outbuf_index++] = c;\n\n        if (mon->outbuf_index >= (sizeof(mon->outbuf) - 1)\n\n            || c == '\\n')\n\n            monitor_flush(mon);\n\n    }\n\n}\n", "idx": 5235}
{"project": "qemu", "commit_id": "5d40097fc09fe5d34cf316a411dc27d455ac2cd0", "target": 1, "func": "static uint64_t uart_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    UartState *s = (UartState *)opaque;\n\n    uint32_t c = 0;\n\n\n\n    offset >>= 2;\n\n    if (offset > R_MAX) {\n\n        return 0;\n\n    } else if (offset == R_TX_RX) {\n\n        uart_read_rx_fifo(s, &c);\n\n        return c;\n\n    }\n\n    return s->r[offset];\n\n}\n", "idx": 8606}
{"project": "qemu", "commit_id": "13c91cb7e28b47f5c4227f7e88a1378570117704", "target": 1, "func": "static int iscsi_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int ret = 0;\n\n    int64_t total_size = 0;\n\n    BlockDriverState bs;\n\n    IscsiLun *iscsilun = NULL;\n\n    QDict *bs_options;\n\n\n\n    memset(&bs, 0, sizeof(BlockDriverState));\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, \"size\")) {\n\n            total_size = options->value.n / BDRV_SECTOR_SIZE;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    bs.opaque = g_malloc0(sizeof(struct IscsiLun));\n\n    iscsilun = bs.opaque;\n\n\n\n    bs_options = qdict_new();\n\n    qdict_put(bs_options, \"filename\", qstring_from_str(filename));\n\n    ret = iscsi_open(&bs, bs_options, 0);\n\n    QDECREF(bs_options);\n\n\n\n    if (ret != 0) {\n\n        goto out;\n\n    }\n\n    if (iscsilun->nop_timer) {\n\n        timer_del(iscsilun->nop_timer);\n\n        timer_free(iscsilun->nop_timer);\n\n    }\n\n    if (iscsilun->type != TYPE_DISK) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n    if (bs.total_sectors < total_size) {\n\n        ret = -ENOSPC;\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (iscsilun->iscsi != NULL) {\n\n        iscsi_destroy_context(iscsilun->iscsi);\n\n    }\n\n    g_free(bs.opaque);\n\n    return ret;\n\n}\n", "idx": 2174}
{"project": "qemu", "commit_id": "9877860e7bd1e26ee70ab9bb5ebc34c92bf23bf5", "target": 1, "func": "static int vmdk_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    char *buf;\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    uint32_t magic;\n\n    Error *local_err = NULL;\n\n\n\n    bs->file = bdrv_open_child(NULL, options, \"file\", bs, &child_file,\n\n                               false, errp);\n\n    if (!bs->file) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf = vmdk_read_desc(bs->file, 0, errp);\n\n    if (!buf) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    magic = ldl_be_p(buf);\n\n    switch (magic) {\n\n        case VMDK3_MAGIC:\n\n        case VMDK4_MAGIC:\n\n            ret = vmdk_open_sparse(bs, bs->file, flags, buf, options,\n\n                                   errp);\n\n            s->desc_offset = 0x200;\n\n            break;\n\n        default:\n\n            ret = vmdk_open_desc_file(bs, flags, buf, options, errp);\n\n            break;\n\n    }\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* try to open parent images, if exist */\n\n    ret = vmdk_parent_open(bs);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n    s->cid = vmdk_read_cid(bs, 0);\n\n    s->parent_cid = vmdk_read_cid(bs, 1);\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n    /* Disable migration when VMDK images are used */\n\n    error_setg(&s->migration_blocker, \"The vmdk format used by node '%s' \"\n\n               \"does not support live migration\",\n\n               bdrv_get_device_or_node_name(bs));\n\n    ret = migrate_add_blocker(s->migration_blocker, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        error_free(s->migration_blocker);\n\n        goto fail;\n\n    }\n\n\n\n    g_free(buf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(buf);\n\n    g_free(s->create_type);\n\n    s->create_type = NULL;\n\n    vmdk_free_extents(bs);\n\n    return ret;\n\n}\n", "idx": 11055}
{"project": "qemu", "commit_id": "882b3b97697affb36ca3d174f42f846232008979", "target": 1, "func": "static int css_add_virtual_chpid(uint8_t cssid, uint8_t chpid, uint8_t type)\n\n{\n\n    CssImage *css;\n\n\n\n    trace_css_chpid_add(cssid, chpid, type);\n\n    if (cssid > MAX_CSSID) {\n\n        return -EINVAL;\n\n    }\n\n    css = channel_subsys.css[cssid];\n\n    if (!css) {\n\n        return -EINVAL;\n\n    }\n\n    if (css->chpids[chpid].in_use) {\n\n        return -EEXIST;\n\n    }\n\n    css->chpids[chpid].in_use = 1;\n\n    css->chpids[chpid].type = type;\n\n    css->chpids[chpid].is_virtual = 1;\n\n\n\n    css_generate_chp_crws(cssid, chpid);\n\n\n\n    return 0;\n\n}\n", "idx": 1736}
{"project": "qemu", "commit_id": "2f0772c5b4818d4b2078be9dace0036d1030faee", "target": 1, "func": "static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)\n\n{\n\n#define CASE_SET_REG24(name, addr) \\\n\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break;\n\n\n\n#define CASE_SET_REG32(name, addr) \\\n\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break; \\\n\n    case addr + 3: s->name &= 0x00ffffff; s->name |= val << 24; break;\n\n\n\n#ifdef DEBUG_LSI_REG\n\n    DPRINTF(\"Write reg %x = %02x\\n\", offset, val);\n\n#endif\n\n    switch (offset) {\n\n    case 0x00: /* SCNTL0 */\n\n        s->scntl0 = val;\n\n        if (val & LSI_SCNTL0_START) {\n\n            BADF(\"Start sequence not implemented\\n\");\n\n        }\n\n        break;\n\n    case 0x01: /* SCNTL1 */\n\n        s->scntl1 = val & ~LSI_SCNTL1_SST;\n\n        if (val & LSI_SCNTL1_IARB) {\n\n            BADF(\"Immediate Arbritration not implemented\\n\");\n\n        }\n\n        if (val & LSI_SCNTL1_RST) {\n\n            if (!(s->sstat0 & LSI_SSTAT0_RST)) {\n\n                BusChild *kid;\n\n\n\n                QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n                    DeviceState *dev = kid->child;\n\n                    device_reset(dev);\n\n                }\n\n                s->sstat0 |= LSI_SSTAT0_RST;\n\n                lsi_script_scsi_interrupt(s, LSI_SIST0_RST, 0);\n\n            }\n\n        } else {\n\n            s->sstat0 &= ~LSI_SSTAT0_RST;\n\n        }\n\n        break;\n\n    case 0x02: /* SCNTL2 */\n\n        val &= ~(LSI_SCNTL2_WSR | LSI_SCNTL2_WSS);\n\n        s->scntl2 = val;\n\n        break;\n\n    case 0x03: /* SCNTL3 */\n\n        s->scntl3 = val;\n\n        break;\n\n    case 0x04: /* SCID */\n\n        s->scid = val;\n\n        break;\n\n    case 0x05: /* SXFER */\n\n        s->sxfer = val;\n\n        break;\n\n    case 0x06: /* SDID */\n\n        if ((val & 0xf) != (s->ssid & 0xf))\n\n            BADF(\"Destination ID does not match SSID\\n\");\n\n        s->sdid = val & 0xf;\n\n        break;\n\n    case 0x07: /* GPREG0 */\n\n        break;\n\n    case 0x08: /* SFBR */\n\n        /* The CPU is not allowed to write to this register.  However the\n\n           SCRIPTS register move instructions are.  */\n\n        s->sfbr = val;\n\n        break;\n\n    case 0x0a: case 0x0b:\n\n        /* Openserver writes to these readonly registers on startup */\n\n\treturn;\n\n    case 0x0c: case 0x0d: case 0x0e: case 0x0f:\n\n        /* Linux writes to these readonly registers on startup.  */\n\n        return;\n\n    CASE_SET_REG32(dsa, 0x10)\n\n    case 0x14: /* ISTAT0 */\n\n        s->istat0 = (s->istat0 & 0x0f) | (val & 0xf0);\n\n        if (val & LSI_ISTAT0_ABRT) {\n\n            lsi_script_dma_interrupt(s, LSI_DSTAT_ABRT);\n\n        }\n\n        if (val & LSI_ISTAT0_INTF) {\n\n            s->istat0 &= ~LSI_ISTAT0_INTF;\n\n            lsi_update_irq(s);\n\n        }\n\n        if (s->waiting == 1 && val & LSI_ISTAT0_SIGP) {\n\n            DPRINTF(\"Woken by SIGP\\n\");\n\n            s->waiting = 0;\n\n            s->dsp = s->dnad;\n\n            lsi_execute_script(s);\n\n        }\n\n        if (val & LSI_ISTAT0_SRST) {\n\n            lsi_soft_reset(s);\n\n        }\n\n        break;\n\n    case 0x16: /* MBOX0 */\n\n        s->mbox0 = val;\n\n        break;\n\n    case 0x17: /* MBOX1 */\n\n        s->mbox1 = val;\n\n        break;\n\n    case 0x1a: /* CTEST2 */\n\n\ts->ctest2 = val & LSI_CTEST2_PCICIE;\n\n\tbreak;\n\n    case 0x1b: /* CTEST3 */\n\n        s->ctest3 = val & 0x0f;\n\n        break;\n\n    CASE_SET_REG32(temp, 0x1c)\n\n    case 0x21: /* CTEST4 */\n\n        if (val & 7) {\n\n           BADF(\"Unimplemented CTEST4-FBL 0x%x\\n\", val);\n\n        }\n\n        s->ctest4 = val;\n\n        break;\n\n    case 0x22: /* CTEST5 */\n\n        if (val & (LSI_CTEST5_ADCK | LSI_CTEST5_BBCK)) {\n\n            BADF(\"CTEST5 DMA increment not implemented\\n\");\n\n        }\n\n        s->ctest5 = val;\n\n        break;\n\n    CASE_SET_REG24(dbc, 0x24)\n\n    CASE_SET_REG32(dnad, 0x28)\n\n    case 0x2c: /* DSP[0:7] */\n\n        s->dsp &= 0xffffff00;\n\n        s->dsp |= val;\n\n        break;\n\n    case 0x2d: /* DSP[8:15] */\n\n        s->dsp &= 0xffff00ff;\n\n        s->dsp |= val << 8;\n\n        break;\n\n    case 0x2e: /* DSP[16:23] */\n\n        s->dsp &= 0xff00ffff;\n\n        s->dsp |= val << 16;\n\n        break;\n\n    case 0x2f: /* DSP[24:31] */\n\n        s->dsp &= 0x00ffffff;\n\n        s->dsp |= val << 24;\n\n        if ((s->dmode & LSI_DMODE_MAN) == 0\n\n            && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n\n            lsi_execute_script(s);\n\n        break;\n\n    CASE_SET_REG32(dsps, 0x30)\n\n    CASE_SET_REG32(scratch[0], 0x34)\n\n    case 0x38: /* DMODE */\n\n        if (val & (LSI_DMODE_SIOM | LSI_DMODE_DIOM)) {\n\n            BADF(\"IO mappings not implemented\\n\");\n\n        }\n\n        s->dmode = val;\n\n        break;\n\n    case 0x39: /* DIEN */\n\n        s->dien = val;\n\n        lsi_update_irq(s);\n\n        break;\n\n    case 0x3a: /* SBR */\n\n        s->sbr = val;\n\n        break;\n\n    case 0x3b: /* DCNTL */\n\n        s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);\n\n        if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n\n            lsi_execute_script(s);\n\n        break;\n\n    case 0x40: /* SIEN0 */\n\n        s->sien0 = val;\n\n        lsi_update_irq(s);\n\n        break;\n\n    case 0x41: /* SIEN1 */\n\n        s->sien1 = val;\n\n        lsi_update_irq(s);\n\n        break;\n\n    case 0x47: /* GPCNTL0 */\n\n        break;\n\n    case 0x48: /* STIME0 */\n\n        s->stime0 = val;\n\n        break;\n\n    case 0x49: /* STIME1 */\n\n        if (val & 0xf) {\n\n            DPRINTF(\"General purpose timer not implemented\\n\");\n\n            /* ??? Raising the interrupt immediately seems to be sufficient\n\n               to keep the FreeBSD driver happy.  */\n\n            lsi_script_scsi_interrupt(s, 0, LSI_SIST1_GEN);\n\n        }\n\n        break;\n\n    case 0x4a: /* RESPID0 */\n\n        s->respid0 = val;\n\n        break;\n\n    case 0x4b: /* RESPID1 */\n\n        s->respid1 = val;\n\n        break;\n\n    case 0x4d: /* STEST1 */\n\n        s->stest1 = val;\n\n        break;\n\n    case 0x4e: /* STEST2 */\n\n        if (val & 1) {\n\n            BADF(\"Low level mode not implemented\\n\");\n\n        }\n\n        s->stest2 = val;\n\n        break;\n\n    case 0x4f: /* STEST3 */\n\n        if (val & 0x41) {\n\n            BADF(\"SCSI FIFO test mode not implemented\\n\");\n\n        }\n\n        s->stest3 = val;\n\n        break;\n\n    case 0x56: /* CCNTL0 */\n\n        s->ccntl0 = val;\n\n        break;\n\n    case 0x57: /* CCNTL1 */\n\n        s->ccntl1 = val;\n\n        break;\n\n    CASE_SET_REG32(mmrs, 0xa0)\n\n    CASE_SET_REG32(mmws, 0xa4)\n\n    CASE_SET_REG32(sfs, 0xa8)\n\n    CASE_SET_REG32(drs, 0xac)\n\n    CASE_SET_REG32(sbms, 0xb0)\n\n    CASE_SET_REG32(dbms, 0xb4)\n\n    CASE_SET_REG32(dnad64, 0xb8)\n\n    CASE_SET_REG32(pmjad1, 0xc0)\n\n    CASE_SET_REG32(pmjad2, 0xc4)\n\n    CASE_SET_REG32(rbc, 0xc8)\n\n    CASE_SET_REG32(ua, 0xcc)\n\n    CASE_SET_REG32(ia, 0xd4)\n\n    CASE_SET_REG32(sbc, 0xd8)\n\n    CASE_SET_REG32(csbc, 0xdc)\n\n    default:\n\n        if (offset >= 0x5c && offset < 0xa0) {\n\n            int n;\n\n            int shift;\n\n            n = (offset - 0x58) >> 2;\n\n            shift = (offset & 3) * 8;\n\n            s->scratch[n] &= ~(0xff << shift);\n\n            s->scratch[n] |= (val & 0xff) << shift;\n\n        } else {\n\n            BADF(\"Unhandled writeb 0x%x = 0x%x\\n\", offset, val);\n\n        }\n\n    }\n\n#undef CASE_SET_REG24\n\n#undef CASE_SET_REG32\n\n}\n", "idx": 11089}
{"project": "qemu", "commit_id": "1b57bd4f2f4993104a5cb48912435396faa10d58", "target": 1, "func": "static inline bool rom_order_compare(Rom *rom, Rom *item)\n\n{\n\n    return (rom->as > item->as) ||\n\n           (rom->as == item->as && rom->addr >= item->addr);\n\n}\n", "idx": 11443}
{"project": "qemu", "commit_id": "c29c1dd312f39ec18a3c6177c6da09a75e095d70", "target": 1, "func": "static void coroutine_fn backup_run(void *opaque)\n\n{\n\n    BackupBlockJob *job = opaque;\n\n    BackupCompleteData *data;\n\n    BlockDriverState *bs = job->common.bs;\n\n    BlockDriverState *target = job->target;\n\n    BlockdevOnError on_target_error = job->on_target_error;\n\n    NotifierWithReturn before_write = {\n\n        .notify = backup_before_write_notify,\n\n    };\n\n    int64_t start, end;\n\n    int ret = 0;\n\n\n\n    QLIST_INIT(&job->inflight_reqs);\n\n    qemu_co_rwlock_init(&job->flush_rwlock);\n\n\n\n    start = 0;\n\n    end = DIV_ROUND_UP(job->common.len / BDRV_SECTOR_SIZE,\n\n                       BACKUP_SECTORS_PER_CLUSTER);\n\n\n\n    job->bitmap = hbitmap_alloc(end, 0);\n\n\n\n    bdrv_set_enable_write_cache(target, true);\n\n    bdrv_set_on_error(target, on_target_error, on_target_error);\n\n    bdrv_iostatus_enable(target);\n\n\n\n    bdrv_add_before_write_notifier(bs, &before_write);\n\n\n\n    if (job->sync_mode == MIRROR_SYNC_MODE_NONE) {\n\n        while (!block_job_is_cancelled(&job->common)) {\n\n            /* Yield until the job is cancelled.  We just let our before_write\n\n             * notify callback service CoW requests. */\n\n            job->common.busy = false;\n\n            qemu_coroutine_yield();\n\n            job->common.busy = true;\n\n        }\n\n    } else {\n\n        /* Both FULL and TOP SYNC_MODE's require copying.. */\n\n        for (; start < end; start++) {\n\n            bool error_is_read;\n\n\n\n            if (block_job_is_cancelled(&job->common)) {\n\n                break;\n\n            }\n\n\n\n            /* we need to yield so that qemu_aio_flush() returns.\n\n             * (without, VM does not reboot)\n\n             */\n\n            if (job->common.speed) {\n\n                uint64_t delay_ns = ratelimit_calculate_delay(\n\n                        &job->limit, job->sectors_read);\n\n                job->sectors_read = 0;\n\n                block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n            } else {\n\n                block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, 0);\n\n            }\n\n\n\n            if (block_job_is_cancelled(&job->common)) {\n\n                break;\n\n            }\n\n\n\n            if (job->sync_mode == MIRROR_SYNC_MODE_TOP) {\n\n                int i, n;\n\n                int alloced = 0;\n\n\n\n                /* Check to see if these blocks are already in the\n\n                 * backing file. */\n\n\n\n                for (i = 0; i < BACKUP_SECTORS_PER_CLUSTER;) {\n\n                    /* bdrv_is_allocated() only returns true/false based\n\n                     * on the first set of sectors it comes across that\n\n                     * are are all in the same state.\n\n                     * For that reason we must verify each sector in the\n\n                     * backup cluster length.  We end up copying more than\n\n                     * needed but at some point that is always the case. */\n\n                    alloced =\n\n                        bdrv_is_allocated(bs,\n\n                                start * BACKUP_SECTORS_PER_CLUSTER + i,\n\n                                BACKUP_SECTORS_PER_CLUSTER - i, &n);\n\n                    i += n;\n\n\n\n                    if (alloced == 1 || n == 0) {\n\n                        break;\n\n                    }\n\n                }\n\n\n\n                /* If the above loop never found any sectors that are in\n\n                 * the topmost image, skip this backup. */\n\n                if (alloced == 0) {\n\n                    continue;\n\n                }\n\n            }\n\n            /* FULL sync mode we copy the whole drive. */\n\n            ret = backup_do_cow(bs, start * BACKUP_SECTORS_PER_CLUSTER,\n\n                    BACKUP_SECTORS_PER_CLUSTER, &error_is_read);\n\n            if (ret < 0) {\n\n                /* Depending on error action, fail now or retry cluster */\n\n                BlockErrorAction action =\n\n                    backup_error_action(job, error_is_read, -ret);\n\n                if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n                    break;\n\n                } else {\n\n                    start--;\n\n                    continue;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    notifier_with_return_remove(&before_write);\n\n\n\n    /* wait until pending backup_do_cow() calls have completed */\n\n    qemu_co_rwlock_wrlock(&job->flush_rwlock);\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    hbitmap_free(job->bitmap);\n\n\n\n    bdrv_iostatus_disable(target);\n\n\n\n\n    data = g_malloc(sizeof(*data));\n\n    data->ret = ret;\n\n    block_job_defer_to_main_loop(&job->common, backup_complete, data);\n\n}", "idx": 262}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n", "idx": 3237}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void vfio_amd_xgbe_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VFIOAmdXgbeDeviceClass *vcxc =\n\n        VFIO_AMD_XGBE_DEVICE_CLASS(klass);\n\n    vcxc->parent_realize = dc->realize;\n\n    dc->realize = amd_xgbe_realize;\n\n    dc->desc = \"VFIO AMD XGBE\";\n\n    dc->vmsd = &vfio_platform_amd_xgbe_vmstate;\n\n\n\n}", "idx": 9009}
{"project": "qemu", "commit_id": "f1710638edb2e98008c2a733ffda63ef32b50411", "target": 1, "func": "int qcrypto_hash_bytesv(QCryptoHashAlgorithm alg,\n\n                        const struct iovec *iov,\n\n                        size_t niov,\n\n                        uint8_t **result,\n\n                        size_t *resultlen,\n\n                        Error **errp)\n\n{\n\n#ifdef CONFIG_AF_ALG\n\n    int ret;\n\n\n\n    ret = qcrypto_hash_afalg_driver.hash_bytesv(alg, iov, niov,\n\n                                                result, resultlen,\n\n                                                errp);\n\n    if (ret == 0) {\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * TODO:\n\n     * Maybe we should treat some afalg errors as fatal\n\n     */\n\n    error_free(*errp);\n\n#endif\n\n\n\n    return qcrypto_hash_lib_driver.hash_bytesv(alg, iov, niov,\n\n                                               result, resultlen,\n\n                                               errp);\n\n}\n", "idx": 3405}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dew_0c(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned ra = extract32(insn, 21, 5);\n\n    return do_fop_dew(ctx, rt, ra, di->f_dew);\n\n}\n", "idx": 2260}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static void GCC_FMT_ATTR(2, 3) blkverify_err(BlkverifyAIOCB *acb,\n\n                                             const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    fprintf(stderr, \"blkverify: %s sector_num=%\" PRId64 \" nb_sectors=%d \",\n\n            acb->is_write ? \"write\" : \"read\", acb->sector_num,\n\n            acb->nb_sectors);\n\n    vfprintf(stderr, fmt, ap);\n\n    fprintf(stderr, \"\\n\");\n\n    va_end(ap);\n\n    exit(1);\n\n}\n", "idx": 1811}
{"project": "qemu", "commit_id": "2343dd11a673597aa59813fd0cac2ae42e2e0312", "target": 1, "func": "static int ppce500_load_device_tree(MachineState *machine,\n\n                                    PPCE500Params *params,\n\n                                    hwaddr addr,\n\n                                    hwaddr initrd_base,\n\n                                    hwaddr initrd_size,\n\n                                    hwaddr kernel_base,\n\n                                    hwaddr kernel_size,\n\n                                    bool dry_run)\n\n{\n\n    CPUPPCState *env = first_cpu->env_ptr;\n\n    int ret = -1;\n\n    uint64_t mem_reg_property[] = { 0, cpu_to_be64(machine->ram_size) };\n\n    int fdt_size;\n\n    void *fdt;\n\n    uint8_t hypercall[16];\n\n    uint32_t clock_freq = 400000000;\n\n    uint32_t tb_freq = 400000000;\n\n    int i;\n\n    char compatible_sb[] = \"fsl,mpc8544-immr\\0simple-bus\";\n\n    char soc[128];\n\n    char mpic[128];\n\n    uint32_t mpic_ph;\n\n    uint32_t msi_ph;\n\n    char gutil[128];\n\n    char pci[128];\n\n    char msi[128];\n\n    uint32_t *pci_map = NULL;\n\n    int len;\n\n    uint32_t pci_ranges[14] =\n\n        {\n\n            0x2000000, 0x0, params->pci_mmio_bus_base,\n\n            params->pci_mmio_base >> 32, params->pci_mmio_base,\n\n            0x0, 0x20000000,\n\n\n\n            0x1000000, 0x0, 0x0,\n\n            params->pci_pio_base >> 32, params->pci_pio_base,\n\n            0x0, 0x10000,\n\n        };\n\n    QemuOpts *machine_opts = qemu_get_machine_opts();\n\n    const char *dtb_file = qemu_opt_get(machine_opts, \"dtb\");\n\n    const char *toplevel_compat = qemu_opt_get(machine_opts, \"dt_compatible\");\n\n\n\n    if (dtb_file) {\n\n        char *filename;\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, dtb_file);\n\n        if (!filename) {\n\n            goto out;\n\n        }\n\n\n\n        fdt = load_device_tree(filename, &fdt_size);\n\n\n        if (!fdt) {\n\n            goto out;\n\n        }\n\n        goto done;\n\n    }\n\n\n\n    fdt = create_device_tree(&fdt_size);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    qemu_fdt_setprop_cell(fdt, \"/\", \"#address-cells\", 2);\n\n    qemu_fdt_setprop_cell(fdt, \"/\", \"#size-cells\", 2);\n\n\n\n    qemu_fdt_add_subnode(fdt, \"/memory\");\n\n    qemu_fdt_setprop_string(fdt, \"/memory\", \"device_type\", \"memory\");\n\n    qemu_fdt_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                     sizeof(mem_reg_property));\n\n\n\n    qemu_fdt_add_subnode(fdt, \"/chosen\");\n\n    if (initrd_size) {\n\n        ret = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n        }\n\n\n\n        ret = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n        }\n\n\n\n    }\n\n\n\n    if (kernel_base != -1ULL) {\n\n        qemu_fdt_setprop_cells(fdt, \"/chosen\", \"qemu,boot-kernel\",\n\n                                     kernel_base >> 32, kernel_base,\n\n                                     kernel_size >> 32, kernel_size);\n\n    }\n\n\n\n    ret = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      machine->kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        /* Read out host's frequencies */\n\n        clock_freq = kvmppc_get_clockfreq();\n\n        tb_freq = kvmppc_get_tbfreq();\n\n\n\n        /* indicate KVM hypercall interface */\n\n        qemu_fdt_add_subnode(fdt, \"/hypervisor\");\n\n        qemu_fdt_setprop_string(fdt, \"/hypervisor\", \"compatible\",\n\n                                \"linux,kvm\");\n\n        kvmppc_get_hypercall(env, hypercall, sizeof(hypercall));\n\n        qemu_fdt_setprop(fdt, \"/hypervisor\", \"hcall-instructions\",\n\n                         hypercall, sizeof(hypercall));\n\n        /* if KVM supports the idle hcall, set property indicating this */\n\n        if (kvmppc_get_hasidle(env)) {\n\n            qemu_fdt_setprop(fdt, \"/hypervisor\", \"has-idle\", NULL, 0);\n\n        }\n\n    }\n\n\n\n    /* Create CPU nodes */\n\n    qemu_fdt_add_subnode(fdt, \"/cpus\");\n\n    qemu_fdt_setprop_cell(fdt, \"/cpus\", \"#address-cells\", 1);\n\n    qemu_fdt_setprop_cell(fdt, \"/cpus\", \"#size-cells\", 0);\n\n\n\n    /* We need to generate the cpu nodes in reverse order, so Linux can pick\n\n       the first node as boot node and be happy */\n\n    for (i = smp_cpus - 1; i >= 0; i--) {\n\n        CPUState *cpu;\n\n        PowerPCCPU *pcpu;\n\n        char cpu_name[128];\n\n        uint64_t cpu_release_addr = params->spin_base + (i * 0x20);\n\n\n\n        cpu = qemu_get_cpu(i);\n\n        if (cpu == NULL) {\n\n            continue;\n\n        }\n\n        env = cpu->env_ptr;\n\n        pcpu = POWERPC_CPU(cpu);\n\n\n\n        snprintf(cpu_name, sizeof(cpu_name), \"/cpus/PowerPC,8544@%x\",\n\n                 ppc_get_vcpu_dt_id(pcpu));\n\n        qemu_fdt_add_subnode(fdt, cpu_name);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"clock-frequency\", clock_freq);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"timebase-frequency\", tb_freq);\n\n        qemu_fdt_setprop_string(fdt, cpu_name, \"device_type\", \"cpu\");\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"reg\",\n\n                              ppc_get_vcpu_dt_id(pcpu));\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"d-cache-line-size\",\n\n                              env->dcache_line_size);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"i-cache-line-size\",\n\n                              env->icache_line_size);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"d-cache-size\", 0x8000);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"i-cache-size\", 0x8000);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"bus-frequency\", 0);\n\n        if (cpu->cpu_index) {\n\n            qemu_fdt_setprop_string(fdt, cpu_name, \"status\", \"disabled\");\n\n            qemu_fdt_setprop_string(fdt, cpu_name, \"enable-method\",\n\n                                    \"spin-table\");\n\n            qemu_fdt_setprop_u64(fdt, cpu_name, \"cpu-release-addr\",\n\n                                 cpu_release_addr);\n\n        } else {\n\n            qemu_fdt_setprop_string(fdt, cpu_name, \"status\", \"okay\");\n\n        }\n\n    }\n\n\n\n    qemu_fdt_add_subnode(fdt, \"/aliases\");\n\n    /* XXX These should go into their respective devices' code */\n\n    snprintf(soc, sizeof(soc), \"/soc@%\"PRIx64, params->ccsrbar_base);\n\n    qemu_fdt_add_subnode(fdt, soc);\n\n    qemu_fdt_setprop_string(fdt, soc, \"device_type\", \"soc\");\n\n    qemu_fdt_setprop(fdt, soc, \"compatible\", compatible_sb,\n\n                     sizeof(compatible_sb));\n\n    qemu_fdt_setprop_cell(fdt, soc, \"#address-cells\", 1);\n\n    qemu_fdt_setprop_cell(fdt, soc, \"#size-cells\", 1);\n\n    qemu_fdt_setprop_cells(fdt, soc, \"ranges\", 0x0,\n\n                           params->ccsrbar_base >> 32, params->ccsrbar_base,\n\n                           MPC8544_CCSRBAR_SIZE);\n\n    /* XXX should contain a reasonable value */\n\n    qemu_fdt_setprop_cell(fdt, soc, \"bus-frequency\", 0);\n\n\n\n    snprintf(mpic, sizeof(mpic), \"%s/pic@%llx\", soc, MPC8544_MPIC_REGS_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, mpic);\n\n    qemu_fdt_setprop_string(fdt, mpic, \"device_type\", \"open-pic\");\n\n    qemu_fdt_setprop_string(fdt, mpic, \"compatible\", \"fsl,mpic\");\n\n    qemu_fdt_setprop_cells(fdt, mpic, \"reg\", MPC8544_MPIC_REGS_OFFSET,\n\n                           0x40000);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"#address-cells\", 0);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"#interrupt-cells\", 2);\n\n    mpic_ph = qemu_fdt_alloc_phandle(fdt);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"phandle\", mpic_ph);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"linux,phandle\", mpic_ph);\n\n    qemu_fdt_setprop(fdt, mpic, \"interrupt-controller\", NULL, 0);\n\n\n\n    /*\n\n     * We have to generate ser1 first, because Linux takes the first\n\n     * device it finds in the dt as serial output device. And we generate\n\n     * devices in reverse order to the dt.\n\n     */\n\n    if (serial_hds[1]) {\n\n        dt_serial_create(fdt, MPC8544_SERIAL1_REGS_OFFSET,\n\n                         soc, mpic, \"serial1\", 1, false);\n\n    }\n\n\n\n    if (serial_hds[0]) {\n\n        dt_serial_create(fdt, MPC8544_SERIAL0_REGS_OFFSET,\n\n                         soc, mpic, \"serial0\", 0, true);\n\n    }\n\n\n\n    snprintf(gutil, sizeof(gutil), \"%s/global-utilities@%llx\", soc,\n\n             MPC8544_UTIL_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, gutil);\n\n    qemu_fdt_setprop_string(fdt, gutil, \"compatible\", \"fsl,mpc8544-guts\");\n\n    qemu_fdt_setprop_cells(fdt, gutil, \"reg\", MPC8544_UTIL_OFFSET, 0x1000);\n\n    qemu_fdt_setprop(fdt, gutil, \"fsl,has-rstcr\", NULL, 0);\n\n\n\n    snprintf(msi, sizeof(msi), \"/%s/msi@%llx\", soc, MPC8544_MSI_REGS_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, msi);\n\n    qemu_fdt_setprop_string(fdt, msi, \"compatible\", \"fsl,mpic-msi\");\n\n    qemu_fdt_setprop_cells(fdt, msi, \"reg\", MPC8544_MSI_REGS_OFFSET, 0x200);\n\n    msi_ph = qemu_fdt_alloc_phandle(fdt);\n\n    qemu_fdt_setprop_cells(fdt, msi, \"msi-available-ranges\", 0x0, 0x100);\n\n    qemu_fdt_setprop_phandle(fdt, msi, \"interrupt-parent\", mpic);\n\n    qemu_fdt_setprop_cells(fdt, msi, \"interrupts\",\n\n        0xe0, 0x0,\n\n        0xe1, 0x0,\n\n        0xe2, 0x0,\n\n        0xe3, 0x0,\n\n        0xe4, 0x0,\n\n        0xe5, 0x0,\n\n        0xe6, 0x0,\n\n        0xe7, 0x0);\n\n    qemu_fdt_setprop_cell(fdt, msi, \"phandle\", msi_ph);\n\n    qemu_fdt_setprop_cell(fdt, msi, \"linux,phandle\", msi_ph);\n\n\n\n    snprintf(pci, sizeof(pci), \"/pci@%llx\",\n\n             params->ccsrbar_base + MPC8544_PCI_REGS_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, pci);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"cell-index\", 0);\n\n    qemu_fdt_setprop_string(fdt, pci, \"compatible\", \"fsl,mpc8540-pci\");\n\n    qemu_fdt_setprop_string(fdt, pci, \"device_type\", \"pci\");\n\n    qemu_fdt_setprop_cells(fdt, pci, \"interrupt-map-mask\", 0xf800, 0x0,\n\n                           0x0, 0x7);\n\n    pci_map = pci_map_create(fdt, qemu_fdt_get_phandle(fdt, mpic),\n\n                             params->pci_first_slot, params->pci_nr_slots,\n\n                             &len);\n\n    qemu_fdt_setprop(fdt, pci, \"interrupt-map\", pci_map, len);\n\n    qemu_fdt_setprop_phandle(fdt, pci, \"interrupt-parent\", mpic);\n\n    qemu_fdt_setprop_cells(fdt, pci, \"interrupts\", 24, 2);\n\n    qemu_fdt_setprop_cells(fdt, pci, \"bus-range\", 0, 255);\n\n    for (i = 0; i < 14; i++) {\n\n        pci_ranges[i] = cpu_to_be32(pci_ranges[i]);\n\n    }\n\n    qemu_fdt_setprop_cell(fdt, pci, \"fsl,msi\", msi_ph);\n\n    qemu_fdt_setprop(fdt, pci, \"ranges\", pci_ranges, sizeof(pci_ranges));\n\n    qemu_fdt_setprop_cells(fdt, pci, \"reg\",\n\n                           (params->ccsrbar_base + MPC8544_PCI_REGS_OFFSET) >> 32,\n\n                           (params->ccsrbar_base + MPC8544_PCI_REGS_OFFSET),\n\n                           0, 0x1000);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"clock-frequency\", 66666666);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"#interrupt-cells\", 1);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"#size-cells\", 2);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"#address-cells\", 3);\n\n    qemu_fdt_setprop_string(fdt, \"/aliases\", \"pci0\", pci);\n\n\n\n    if (params->has_mpc8xxx_gpio) {\n\n        create_dt_mpc8xxx_gpio(fdt, soc, mpic);\n\n    }\n\n\n\n    if (params->has_platform_bus) {\n\n        platform_bus_create_devtree(params, fdt, mpic);\n\n    }\n\n\n\n    params->fixup_devtree(params, fdt);\n\n\n\n    if (toplevel_compat) {\n\n        qemu_fdt_setprop(fdt, \"/\", \"compatible\", toplevel_compat,\n\n                         strlen(toplevel_compat) + 1);\n\n    }\n\n\n\ndone:\n\n    if (!dry_run) {\n\n        qemu_fdt_dumpdtb(fdt, fdt_size);\n\n        cpu_physical_memory_write(addr, fdt, fdt_size);\n\n    }\n\n    ret = fdt_size;\n\n\n\nout:\n\n    g_free(pci_map);\n\n\n\n    return ret;\n\n}", "idx": 6257}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_sexth(DisasContext *dc)\n\n{\n\n    LOG_DIS(\"sexth r%d, r%d\\n\", dc->r2, dc->r0);\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_SIGN_EXTEND)) {\n\n        cpu_abort(dc->env, \"hardware sign extender is not available\\n\");\n\n    }\n\n\n\n    tcg_gen_ext16s_tl(cpu_R[dc->r2], cpu_R[dc->r0]);\n\n}\n", "idx": 3485}
{"project": "qemu", "commit_id": "3cb0e25c4b417b7336816bd92de458f0770d49ff", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *value;\n\n    DriveInfo *dinfo = NULL;\n\n    QDict *bs_opts;\n\n    QemuOpts *legacy_opts;\n\n    DriveMediaType media = MEDIA_DISK;\n\n    BlockInterfaceType type;\n\n    int cyls, heads, secs, translation;\n\n    int max_devs, bus_id, unit_id, index;\n\n    const char *devaddr;\n\n    const char *werror, *rerror;\n\n    bool read_only = false;\n\n    bool copy_on_read;\n\n    const char *filename;\n\n    Error *local_err = NULL;\n\n\n\n    /* Change legacy command line options into QMP ones */\n\n    qemu_opt_rename(all_opts, \"iops\", \"throttling.iops-total\");\n\n    qemu_opt_rename(all_opts, \"iops_rd\", \"throttling.iops-read\");\n\n    qemu_opt_rename(all_opts, \"iops_wr\", \"throttling.iops-write\");\n\n\n\n    qemu_opt_rename(all_opts, \"bps\", \"throttling.bps-total\");\n\n    qemu_opt_rename(all_opts, \"bps_rd\", \"throttling.bps-read\");\n\n    qemu_opt_rename(all_opts, \"bps_wr\", \"throttling.bps-write\");\n\n\n\n    qemu_opt_rename(all_opts, \"iops_max\", \"throttling.iops-total-max\");\n\n    qemu_opt_rename(all_opts, \"iops_rd_max\", \"throttling.iops-read-max\");\n\n    qemu_opt_rename(all_opts, \"iops_wr_max\", \"throttling.iops-write-max\");\n\n\n\n    qemu_opt_rename(all_opts, \"bps_max\", \"throttling.bps-total-max\");\n\n    qemu_opt_rename(all_opts, \"bps_rd_max\", \"throttling.bps-read-max\");\n\n    qemu_opt_rename(all_opts, \"bps_wr_max\", \"throttling.bps-write-max\");\n\n\n\n    qemu_opt_rename(all_opts,\n\n                    \"iops_size\", \"throttling.iops-size\");\n\n\n\n    qemu_opt_rename(all_opts, \"readonly\", \"read-only\");\n\n\n\n    value = qemu_opt_get(all_opts, \"cache\");\n\n    if (value) {\n\n        int flags = 0;\n\n\n\n        if (bdrv_parse_cache_flags(value, &flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n\n\n        /* Specific options take precedence */\n\n        if (!qemu_opt_get(all_opts, \"cache.writeback\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.writeback\",\n\n                              !!(flags & BDRV_O_CACHE_WB));\n\n        }\n\n        if (!qemu_opt_get(all_opts, \"cache.direct\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.direct\",\n\n                              !!(flags & BDRV_O_NOCACHE));\n\n        }\n\n        if (!qemu_opt_get(all_opts, \"cache.no-flush\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.no-flush\",\n\n                              !!(flags & BDRV_O_NO_FLUSH));\n\n        }\n\n        qemu_opt_unset(all_opts, \"cache\");\n\n    }\n\n\n\n    /* Get a QDict for processing the options */\n\n    bs_opts = qdict_new();\n\n    qemu_opts_to_qdict(all_opts, bs_opts);\n\n\n\n    legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,\n\n                                   &error_abort);\n\n    qemu_opts_absorb_qdict(legacy_opts, bs_opts, &local_err);\n\n    if (local_err) {\n\n        error_report(\"%s\", error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Deprecated option boot=[on|off] */\n\n    if (qemu_opt_get(legacy_opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    /* Media type */\n\n    value = qemu_opt_get(legacy_opts, \"media\");\n\n    if (value) {\n\n        if (!strcmp(value, \"disk\")) {\n\n            media = MEDIA_DISK;\n\n        } else if (!strcmp(value, \"cdrom\")) {\n\n            media = MEDIA_CDROM;\n\n            read_only = true;\n\n        } else {\n\n            error_report(\"'%s' invalid media\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* copy-on-read is disabled with a warning for read-only devices */\n\n    read_only |= qemu_opt_get_bool(legacy_opts, \"read-only\", false);\n\n    copy_on_read = qemu_opt_get_bool(legacy_opts, \"copy-on-read\", false);\n\n\n\n    if (read_only && copy_on_read) {\n\n        error_report(\"warning: disabling copy-on-read on read-only drive\");\n\n        copy_on_read = false;\n\n    }\n\n\n\n    qdict_put(bs_opts, \"read-only\",\n\n              qstring_from_str(read_only ? \"on\" : \"off\"));\n\n    qdict_put(bs_opts, \"copy-on-read\",\n\n              qstring_from_str(copy_on_read ? \"on\" :\"off\"));\n\n\n\n    /* Controller type */\n\n    value = qemu_opt_get(legacy_opts, \"if\");\n\n    if (value) {\n\n        for (type = 0;\n\n             type < IF_COUNT && strcmp(value, if_name[type]);\n\n             type++) {\n\n        }\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", value);\n\n            goto fail;\n\n        }\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    /* Geometry */\n\n    cyls  = qemu_opt_get_number(legacy_opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(legacy_opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(legacy_opts, \"secs\", 0);\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n            goto fail;\n\n        }\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n            goto fail;\n\n        }\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    value = qemu_opt_get(legacy_opts, \"trans\");\n\n    if (value != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         value);\n\n            goto fail;\n\n        }\n\n        if (!strcmp(value, \"none\")) {\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        } else if (!strcmp(value, \"lba\")) {\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        } else if (!strcmp(value, \"large\")) {\n\n            translation = BIOS_ATA_TRANSLATION_LARGE;\n\n        } else if (!strcmp(value, \"rechs\")) {\n\n            translation = BIOS_ATA_TRANSLATION_RECHS;\n\n        } else if (!strcmp(value, \"auto\")) {\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n        } else {\n\n            error_report(\"'%s' invalid translation type\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        if (cyls || secs || heads) {\n\n            error_report(\"CHS can't be set with media=cdrom\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Device address specified by bus/unit or index.\n\n     * If none was specified, try to find the first free one. */\n\n    bus_id  = qemu_opt_get_number(legacy_opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(legacy_opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(legacy_opts, \"index\", -1);\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            goto fail;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\", unit_id, max_devs - 1);\n\n        goto fail;\n\n    }\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        goto fail;\n\n    }\n\n\n\n    /* no id supplied -> create one */\n\n    if (qemu_opts_id(all_opts) == NULL) {\n\n        char *new_id;\n\n        const char *mediastr = \"\";\n\n        if (type == IF_IDE || type == IF_SCSI) {\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        }\n\n        if (max_devs) {\n\n            new_id = g_strdup_printf(\"%s%i%s%i\", if_name[type], bus_id,\n\n                                     mediastr, unit_id);\n\n        } else {\n\n            new_id = g_strdup_printf(\"%s%s%i\", if_name[type],\n\n                                     mediastr, unit_id);\n\n        }\n\n        qdict_put(bs_opts, \"id\", qstring_from_str(new_id));\n\n        g_free(new_id);\n\n    }\n\n\n\n    /* Add virtio block device */\n\n    devaddr = qemu_opt_get(legacy_opts, \"addr\");\n\n    if (devaddr && type != IF_VIRTIO) {\n\n        error_report(\"addr is not supported by this bus type\");\n\n        goto fail;\n\n    }\n\n\n\n    if (type == IF_VIRTIO) {\n\n        QemuOpts *devopts;\n\n        devopts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n\n                                   &error_abort);\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(devopts, \"drive\", qdict_get_str(bs_opts, \"id\"));\n\n        if (devaddr) {\n\n            qemu_opt_set(devopts, \"addr\", devaddr);\n\n        }\n\n    }\n\n\n\n    filename = qemu_opt_get(legacy_opts, \"file\");\n\n\n\n    /* Check werror/rerror compatibility with if=... */\n\n    werror = qemu_opt_get(legacy_opts, \"werror\");\n\n    if (werror != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO &&\n\n            type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            goto fail;\n\n        }\n\n        qdict_put(bs_opts, \"werror\", qstring_from_str(werror));\n\n    }\n\n\n\n    rerror = qemu_opt_get(legacy_opts, \"rerror\");\n\n    if (rerror != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI &&\n\n            type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            goto fail;\n\n        }\n\n        qdict_put(bs_opts, \"rerror\", qstring_from_str(rerror));\n\n    }\n\n\n\n    /* Actual block device init: Functionality shared with blockdev-add */\n\n    dinfo = blockdev_init(filename, bs_opts, &local_err);\n\n\n    if (dinfo == NULL) {\n\n        if (local_err) {\n\n            error_report(\"%s\", error_get_pretty(local_err));\n\n            error_free(local_err);\n\n        }\n\n        goto fail;\n\n    } else {\n\n        assert(!local_err);\n\n    }\n\n\n\n    /* Set legacy DriveInfo fields */\n\n    dinfo->enable_auto_del = true;\n\n    dinfo->opts = all_opts;\n\n\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->devaddr = devaddr;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(legacy_opts);\n\n    QDECREF(bs_opts);\n\n    return dinfo;\n\n}", "idx": 6623}
{"project": "qemu", "commit_id": "cfba8e6f92d45a2374622c3dc57499e42a1c07e1", "target": 1, "func": "static void vncws_send_handshake_response(VncState *vs, const char* key)\n\n{\n\n    char combined_key[WS_CLIENT_KEY_LEN + WS_GUID_LEN + 1];\n\n    char hash[SHA1_DIGEST_LEN];\n\n    size_t hash_size = SHA1_DIGEST_LEN;\n\n    char *accept = NULL, *response = NULL;\n\n    gnutls_datum_t in;\n\n\n\n    g_strlcpy(combined_key, key, WS_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, WS_GUID, WS_CLIENT_KEY_LEN + WS_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    in.data = (void *)combined_key;\n\n    in.size = WS_CLIENT_KEY_LEN + WS_GUID_LEN;\n\n    if (gnutls_fingerprint(GNUTLS_DIG_SHA1, &in, hash, &hash_size)\n\n            == GNUTLS_E_SUCCESS) {\n\n        accept = g_base64_encode((guchar *)hash, SHA1_DIGEST_LEN);\n\n    }\n\n    if (accept == NULL) {\n\n        VNC_DEBUG(\"Hashing Websocket combined key failed\\n\");\n\n        vnc_client_error(vs);\n\n        return;\n\n    }\n\n\n\n    response = g_strdup_printf(WS_HANDSHAKE, accept);\n\n    vnc_write(vs, response, strlen(response));\n\n    vnc_flush(vs);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    vs->encode_ws = 1;\n\n    vnc_init_state(vs);\n\n}\n", "idx": 6949}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 6497}
{"project": "qemu", "commit_id": "8804f57b531e4887ad9521c9abb9e0bbbcb1dd4e", "target": 1, "func": "static int vscsi_srp_direct_data(VSCSIState *s, vscsi_req *req,\n\n                                 uint8_t *buf, uint32_t len)\n\n{\n\n    struct srp_direct_buf *md = req->cur_desc;\n\n    uint32_t llen;\n\n    int rc;\n\n\n\n    dprintf(\"VSCSI: direct segment 0x%x bytes, va=0x%llx desc len=0x%x\\n\",\n\n            len, (unsigned long long)md->va, md->len);\n\n\n\n    llen = MIN(len, md->len);\n\n    if (llen) {\n\n        if (req->writing) { /* writing = to device = reading from memory */\n\n            rc = spapr_tce_dma_read(&s->vdev, md->va, buf, llen);\n\n        } else {\n\n            rc = spapr_tce_dma_write(&s->vdev, md->va, buf, llen);\n\n        }\n\n    }\n\n    md->len -= llen;\n\n    md->va += llen;\n\n\n\n    if (rc) {\n\n        return -1;\n\n    }\n\n    return llen;\n\n}\n", "idx": 10572}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta = NULL;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,\n\n                                 remaining_sectors);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method &&\n\n            cur_nr_sectors >\n\n            QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors - index_in_cluster) {\n\n            cur_nr_sectors =\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors - index_in_cluster;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0,\n\n                cluster_offset + index_in_cluster * BDRV_SECTOR_SIZE,\n\n                cur_nr_sectors * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        while (l2meta != NULL) {\n\n            QCowL2Meta *next;\n\n\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* Take the request off the list of running requests */\n\n            if (l2meta->nb_clusters != 0) {\n\n                QLIST_REMOVE(l2meta, next_in_flight);\n\n            }\n\n\n\n            qemu_co_queue_restart_all(&l2meta->dependent_requests);\n\n\n\n            next = l2meta->next;\n\n            g_free(l2meta);\n\n            l2meta = next;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    while (l2meta != NULL) {\n\n        QCowL2Meta *next;\n\n\n\n        if (l2meta->nb_clusters != 0) {\n\n            QLIST_REMOVE(l2meta, next_in_flight);\n\n        }\n\n        qemu_co_queue_restart_all(&l2meta->dependent_requests);\n\n\n\n        next = l2meta->next;\n\n        g_free(l2meta);\n\n        l2meta = next;\n\n    }\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 5549}
{"project": "qemu", "commit_id": "24f3902b088cd4f2dbebfd90527b5d81d6a050e9", "target": 1, "func": "static int qemu_savevm_state(QEMUFile *f, Error **errp)\n\n{\n\n    int ret;\n\n    MigrationParams params = {\n\n        .blk = 0,\n\n        .shared = 0\n\n    };\n\n    MigrationState *ms = migrate_init(&params);\n\n    ms->to_dst_file = f;\n\n\n\n    if (qemu_savevm_state_blocked(errp)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    qemu_savevm_state_header(f);\n\n    qemu_savevm_state_begin(f, &params);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    while (qemu_file_get_error(f) == 0) {\n\n        if (qemu_savevm_state_iterate(f, false) > 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    ret = qemu_file_get_error(f);\n\n    if (ret == 0) {\n\n        qemu_savevm_state_complete_precopy(f, false);\n\n        ret = qemu_file_get_error(f);\n\n    }\n\n    qemu_savevm_state_cleanup();\n\n    if (ret != 0) {\n\n        error_setg_errno(errp, -ret, \"Error while writing VM state\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 3135}
{"project": "qemu", "commit_id": "cf143ad35018c5fc1da6365b45acda2b34aba90a", "target": 1, "func": "static void mv88w8618_eth_write(void *opaque, hwaddr offset,\n\n                                uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_eth_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_ETH_SMIR:\n\n        s->smir = value;\n\n        break;\n\n\n\n    case MP_ETH_PCXR:\n\n        s->vlan_header = ((value >> MP_ETH_PCXR_2BSM_BIT) & 1) * 2;\n\n        break;\n\n\n\n    case MP_ETH_SDCMR:\n\n        if (value & MP_ETH_CMD_TXHI) {\n\n            eth_send(s, 1);\n\n        }\n\n        if (value & MP_ETH_CMD_TXLO) {\n\n            eth_send(s, 0);\n\n        }\n\n        if (value & (MP_ETH_CMD_TXHI | MP_ETH_CMD_TXLO) && s->icr & s->imr) {\n\n            qemu_irq_raise(s->irq);\n\n        }\n\n        break;\n\n\n\n    case MP_ETH_ICR:\n\n        s->icr &= value;\n\n        break;\n\n\n\n    case MP_ETH_IMR:\n\n        s->imr = value;\n\n        if (s->icr & s->imr) {\n\n            qemu_irq_raise(s->irq);\n\n        }\n\n        break;\n\n\n\n    case MP_ETH_FRDP0 ... MP_ETH_FRDP3:\n\n        s->frx_queue[(offset - MP_ETH_FRDP0)/4] = value;\n\n        break;\n\n\n\n    case MP_ETH_CRDP0 ... MP_ETH_CRDP3:\n\n        s->rx_queue[(offset - MP_ETH_CRDP0)/4] =\n\n            s->cur_rx[(offset - MP_ETH_CRDP0)/4] = value;\n\n        break;\n\n\n\n    case MP_ETH_CTDP0 ... MP_ETH_CTDP3:\n\n        s->tx_queue[(offset - MP_ETH_CTDP0)/4] = value;\n\n        break;\n\n    }\n\n}\n", "idx": 2694}
{"project": "qemu", "commit_id": "45ed0be146b7433d1123f09eb1a984210a311625", "target": 1, "func": "static void gen_spr_power8_fscr(CPUPPCState *env)\n\n{\n\n    spr_register_kvm(env, SPR_FSCR, \"FSCR\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_generic,\n\n                     KVM_REG_PPC_FSCR, 0x00000000);\n\n}\n", "idx": 9275}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "qemu_irq sh7750_irl(SH7750State *s)\n\n{\n\n    sh_intc_toggle_source(sh_intc_source(&s->intc, IRL), 1, 0); /* enable */\n\n    return qemu_allocate_irqs(sh_intc_set_irl, sh_intc_source(&s->intc, IRL),\n\n                               1)[0];\n\n}\n", "idx": 9985}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "static always_inline int _pte_check (mmu_ctx_t *ctx, int is_64b,\n\n                                     target_ulong pte0, target_ulong pte1,\n\n                                     int h, int rw, int type)\n\n{\n\n    target_ulong ptem, mmask;\n\n    int access, ret, pteh, ptev, pp;\n\n\n\n    access = 0;\n\n    ret = -1;\n\n    /* Check validity and table match */\n\n#if defined(TARGET_PPC64)\n\n    if (is_64b) {\n\n        ptev = pte64_is_valid(pte0);\n\n        pteh = (pte0 >> 1) & 1;\n\n    } else\n\n#endif\n\n    {\n\n        ptev = pte_is_valid(pte0);\n\n        pteh = (pte0 >> 6) & 1;\n\n    }\n\n    if (ptev && h == pteh) {\n\n        /* Check vsid & api */\n\n#if defined(TARGET_PPC64)\n\n        if (is_64b) {\n\n            ptem = pte0 & PTE64_PTEM_MASK;\n\n            mmask = PTE64_CHECK_MASK;\n\n            pp = (pte1 & 0x00000003) | ((pte1 >> 61) & 0x00000004);\n\n            ctx->nx |= (pte1 >> 2) & 1; /* No execute bit */\n\n            ctx->nx |= (pte1 >> 3) & 1; /* Guarded bit    */\n\n        } else\n\n#endif\n\n        {\n\n            ptem = pte0 & PTE_PTEM_MASK;\n\n            mmask = PTE_CHECK_MASK;\n\n            pp = pte1 & 0x00000003;\n\n        }\n\n        if (ptem == ctx->ptem) {\n\n            if (ctx->raddr != (target_ulong)-1) {\n\n                /* all matches should have equal RPN, WIMG & PP */\n\n                if ((ctx->raddr & mmask) != (pte1 & mmask)) {\n\n                    if (loglevel != 0)\n\n                        fprintf(logfile, \"Bad RPN/WIMG/PP\\n\");\n\n                    return -3;\n\n                }\n\n            }\n\n            /* Compute access rights */\n\n            access = pp_check(ctx->key, pp, ctx->nx);\n\n            /* Keep the matching PTE informations */\n\n            ctx->raddr = pte1;\n\n            ctx->prot = access;\n\n            ret = check_prot(ctx->prot, rw, type);\n\n            if (ret == 0) {\n\n                /* Access granted */\n\n#if defined (DEBUG_MMU)\n\n                if (loglevel != 0)\n\n                    fprintf(logfile, \"PTE access granted !\\n\");\n\n#endif\n\n            } else {\n\n                /* Access right violation */\n\n#if defined (DEBUG_MMU)\n\n                if (loglevel != 0)\n\n                    fprintf(logfile, \"PTE access rejected\\n\");\n\n#endif\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10501}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,\n\n                             int s_bits, int tlb_offset)\n\n{\n\n    TCGReg base = TCG_AREG0;\n\n\n\n    /* Should generate something like the following:\n\n     * pre-v7:\n\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n\n     *   add    r2, env, #off & 0xff00\n\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n\n     *   tst    addr_reg, #s_mask\n\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n\n     *\n\n     * v7 (not implemented yet):\n\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n\n     *   movw   r0, #off\n\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n\n     *   bic    tmp, addr_reg, tmp\n\n     *   ldr    r0, [r2, r0]!                                     (3)\n\n     *   cmp    r0, tmp                                           (4)\n\n     */\n\n#  if CPU_TLB_BITS > 8\n\n#   error\n\n#  endif\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,\n\n                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n\n\n\n    /* We assume that the offset is contained within 16 bits.  */\n\n    assert((tlb_offset & ~0xffff) == 0);\n\n    if (tlb_offset > 0xff) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                        (24 << 7) | (tlb_offset >> 8));\n\n        tlb_offset &= 0xff;\n\n        base = TCG_REG_R2;\n\n    }\n\n\n\n    tcg_out_dat_imm(s, COND_AL, ARITH_AND,\n\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 1982}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "int qemu_mutex_trylock(QemuMutex *mutex)\n\n{\n\n    int owned;\n\n\n\n    owned = TryEnterCriticalSection(&mutex->lock);\n\n    if (owned) {\n\n        assert(mutex->owner == 0);\n\n        mutex->owner = GetCurrentThreadId();\n\n    }\n\n    return !owned;\n\n}\n", "idx": 1846}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "grlib_apbuart_writel(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    UART          *uart = opaque;\n\n    unsigned char  c    = 0;\n\n\n\n    addr &= 0xff;\n\n\n\n    /* Unit registers */\n\n    switch (addr) {\n\n    case DATA_OFFSET:\n\n        c = value & 0xFF;\n\n        qemu_chr_write(uart->chr, &c, 1);\n\n        return;\n\n\n\n    case STATUS_OFFSET:\n\n        /* Read Only */\n\n        return;\n\n\n\n    case CONTROL_OFFSET:\n\n        /* Not supported */\n\n        return;\n\n\n\n    case SCALER_OFFSET:\n\n        /* Not supported */\n\n        return;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    trace_grlib_apbuart_unknown_register(\"write\", addr);\n\n}\n", "idx": 6010}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "void OPPROTO op_check_subfo_64 (void)\n\n{\n\n    if (likely(!(((uint64_t)(~T2) ^ (uint64_t)T1 ^ UINT64_MAX) &\n\n                 ((uint64_t)(~T2) ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 10465}
{"project": "qemu", "commit_id": "876d516311c1538a7d29f2abec48b7cda0645eea", "target": 1, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl)\n\n{\n\n    /* vga mode framebuffer / primary surface (bar 0, first part) */\n\n    if (qxl->vgamem_size_mb < 8) {\n\n        qxl->vgamem_size_mb = 8;\n\n\n\n\n\n\n\n\n    qxl->vgamem_size = qxl->vgamem_size_mb * 1024 * 1024;\n\n\n\n    /* vga ram (bar 0, total) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n\n    if (qxl->vga.vram_size < qxl->vgamem_size * 2) {\n\n        qxl->vga.vram_size = qxl->vgamem_size * 2;\n\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n\n    qxl->vgamem_size = msb_mask(qxl->vgamem_size * 2 - 1);\n\n    qxl->vga.vram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n    qxl->vram32_size = msb_mask(qxl->vram32_size * 2 - 1);\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n", "idx": 4850}
{"project": "qemu", "commit_id": "6b7741c2bedeae2e8c54fffce81723ca0a0c25c0", "target": 1, "func": "static void sch_handle_start_func(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    int path;\n\n    int ret;\n\n\n\n    /* Path management: In our simple css, we always choose the only path. */\n\n    path = 0x80;\n\n\n\n    if (!(s->ctrl & SCSW_ACTL_SUSP)) {\n\n\n\n        /* Look at the orb and try to execute the channel program. */\n\n        assert(orb != NULL); /* resume does not pass an orb */\n\n        p->intparm = orb->intparm;\n\n        if (!(orb->lpm & path)) {\n\n            /* Generate a deferred cc 3 condition. */\n\n            s->flags |= SCSW_FLAGS_MASK_CC;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= (SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND);\n\n            return;\n\n        }\n\n        sch->ccw_fmt_1 = !!(orb->ctrl0 & ORB_CTRL0_MASK_FMT);\n\n        sch->ccw_no_data_cnt = 0;\n\n    } else {\n\n        s->ctrl &= ~(SCSW_ACTL_SUSP | SCSW_ACTL_RESUME_PEND);\n\n    }\n\n    sch->last_cmd_valid = false;\n\n    do {\n\n        ret = css_interpret_ccw(sch, sch->channel_prog);\n\n        switch (ret) {\n\n        case -EAGAIN:\n\n            /* ccw chain, continue processing */\n\n            break;\n\n        case 0:\n\n            /* success */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_STATUS_PEND;\n\n            s->dstat = SCSW_DSTAT_CHANNEL_END | SCSW_DSTAT_DEVICE_END;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -ENOSYS:\n\n            /* unsupported command, generate unit check (command reject) */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->dstat = SCSW_DSTAT_UNIT_CHECK;\n\n            /* Set sense bit 0 in ecw0. */\n\n            sch->sense_data[0] = 0x80;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EFAULT:\n\n            /* memory problem, generate channel data check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_DATA_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EBUSY:\n\n            /* subchannel busy, generate deferred cc 1 */\n\n            s->flags &= ~SCSW_FLAGS_MASK_CC;\n\n            s->flags |= (1 << 8);\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            break;\n\n        case -EINPROGRESS:\n\n            /* channel program has been suspended */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl |= SCSW_ACTL_SUSP;\n\n            break;\n\n        default:\n\n            /* error, generate channel program check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_PROG_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        }\n\n    } while (ret == -EAGAIN);\n\n\n\n}", "idx": 11605}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "BdrvDirtyBitmap *bdrv_create_dirty_bitmap(BlockDriverState *bs, int granularity,\n\n                                          Error **errp)\n\n{\n\n    int64_t bitmap_size;\n\n    BdrvDirtyBitmap *bitmap;\n\n\n\n    assert((granularity & (granularity - 1)) == 0);\n\n\n\n    granularity >>= BDRV_SECTOR_BITS;\n\n    assert(granularity);\n\n    bitmap_size = bdrv_nb_sectors(bs);\n\n    if (bitmap_size < 0) {\n\n        error_setg_errno(errp, -bitmap_size, \"could not get length of device\");\n\n        errno = -bitmap_size;\n\n        return NULL;\n\n    }\n\n    bitmap = g_malloc0(sizeof(BdrvDirtyBitmap));\n\n    bitmap->bitmap = hbitmap_alloc(bitmap_size, ffs(granularity) - 1);\n\n    QLIST_INSERT_HEAD(&bs->dirty_bitmaps, bitmap, list);\n\n    return bitmap;\n\n}\n", "idx": 3461}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_store_exclusive(DisasContext *s, int rd, int rt, int rt2,\n\n                                TCGv addr, int size)\n\n{\n\n    TCGv tmp;\n\n    int done_label;\n\n    int fail_label;\n\n\n\n    /* if (env->exclusive_addr == addr && env->exclusive_val == [addr]) {\n\n         [addr] = {Rt};\n\n         {Rd} = 0;\n\n       } else {\n\n         {Rd} = 1;\n\n       } */\n\n    fail_label = gen_new_label();\n\n    done_label = gen_new_label();\n\n    tcg_gen_brcond_i32(TCG_COND_NE, addr, cpu_exclusive_addr, fail_label);\n\n    switch (size) {\n\n    case 0:\n\n        tmp = gen_ld8u(addr, IS_USER(s));\n\n        break;\n\n    case 1:\n\n        tmp = gen_ld16u(addr, IS_USER(s));\n\n        break;\n\n    case 2:\n\n    case 3:\n\n        tmp = gen_ld32(addr, IS_USER(s));\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    tcg_gen_brcond_i32(TCG_COND_NE, tmp, cpu_exclusive_val, fail_label);\n\n    dead_tmp(tmp);\n\n    if (size == 3) {\n\n        TCGv tmp2 = new_tmp();\n\n        tcg_gen_addi_i32(tmp2, addr, 4);\n\n        tmp = gen_ld32(tmp2, IS_USER(s));\n\n        dead_tmp(tmp2);\n\n        tcg_gen_brcond_i32(TCG_COND_NE, tmp, cpu_exclusive_high, fail_label);\n\n        dead_tmp(tmp);\n\n    }\n\n    tmp = load_reg(s, rt);\n\n    switch (size) {\n\n    case 0:\n\n        gen_st8(tmp, addr, IS_USER(s));\n\n        break;\n\n    case 1:\n\n        gen_st16(tmp, addr, IS_USER(s));\n\n        break;\n\n    case 2:\n\n    case 3:\n\n        gen_st32(tmp, addr, IS_USER(s));\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (size == 3) {\n\n        tcg_gen_addi_i32(addr, addr, 4);\n\n        tmp = load_reg(s, rt2);\n\n        gen_st32(tmp, addr, IS_USER(s));\n\n    }\n\n    tcg_gen_movi_i32(cpu_R[rd], 0);\n\n    tcg_gen_br(done_label);\n\n    gen_set_label(fail_label);\n\n    tcg_gen_movi_i32(cpu_R[rd], 1);\n\n    gen_set_label(done_label);\n\n    tcg_gen_movi_i32(cpu_exclusive_addr, -1);\n\n}\n", "idx": 11418}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "static int qemu_rbd_snap_remove(BlockDriverState *bs,\n\n                                const char *snapshot_name)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    int r;\n\n\n\n    r = rbd_snap_remove(s->image, snapshot_name);\n\n    return r;\n\n}\n", "idx": 9458}
{"project": "qemu", "commit_id": "82a41186941c419afde977f477f19c545b40c1c5", "target": 1, "func": "AioContext *aio_context_new(Error **errp)\n\n{\n\n    int ret;\n\n    AioContext *ctx;\n\n\n\n    ctx = (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n    aio_context_setup(ctx);\n\n\n\n    ret = event_notifier_init(&ctx->notifier, false);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Failed to initialize event notifier\");\n\n        goto fail;\n\n    }\n\n    g_source_set_can_recurse(&ctx->source, true);\n\n    aio_set_event_notifier(ctx, &ctx->notifier,\n\n                           false,\n\n                           (EventNotifierHandler *)\n\n                           event_notifier_dummy_cb,\n\n                           event_notifier_poll);\n\n#ifdef CONFIG_LINUX_AIO\n\n    ctx->linux_aio = NULL;\n\n#endif\n\n    ctx->thread_pool = NULL;\n\n    qemu_mutex_init(&ctx->bh_lock);\n\n    qemu_rec_mutex_init(&ctx->lock);\n\n    timerlistgroup_init(&ctx->tlg, aio_timerlist_notify, ctx);\n\n\n\n\n    ctx->poll_max_ns = 0;\n\n\n\n\n\n    return ctx;\n\nfail:\n\n    g_source_destroy(&ctx->source);\n\n    return NULL;\n\n}", "idx": 4409}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_dstst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n\n\n}\n", "idx": 8249}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_set_inserted(DeviceState *dev, bool level)\n\n{\n\n    SDHCIState *s = (SDHCIState *)dev;\n\n    DPRINT_L1(\"Card state changed: %s!\\n\", level ? \"insert\" : \"eject\");\n\n\n\n    if ((s->norintsts & SDHC_NIS_REMOVE) && level) {\n\n        /* Give target some time to notice card ejection */\n\n        timer_mod(s->insert_timer,\n\n                       qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + SDHC_INSERTION_DELAY);\n\n    } else {\n\n        if (level) {\n\n            s->prnsts = 0x1ff0000;\n\n            if (s->norintstsen & SDHC_NISEN_INSERT) {\n\n                s->norintsts |= SDHC_NIS_INSERT;\n\n            }\n\n        } else {\n\n            s->prnsts = 0x1fa0000;\n\n            s->pwrcon &= ~SDHC_POWER_ON;\n\n            s->clkcon &= ~SDHC_CLOCK_SDCLK_EN;\n\n            if (s->norintstsen & SDHC_NISEN_REMOVE) {\n\n                s->norintsts |= SDHC_NIS_REMOVE;\n\n            }\n\n        }\n\n        sdhci_update_irq(s);\n\n    }\n\n}\n", "idx": 5628}
{"project": "qemu", "commit_id": "133e9b228df16d11de01529c217417e78d1d9370", "target": 1, "func": "static int pci_unregister_device(DeviceState *dev)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);\n\n\n\n    pci_unregister_io_regions(pci_dev);\n\n    pci_del_option_rom(pci_dev);\n\n\n\n    if (pc->exit) {\n\n        pc->exit(pci_dev);\n\n    }\n\n\n\n    do_pci_unregister_device(pci_dev);\n\n    return 0;\n\n}\n", "idx": 6917}
{"project": "qemu", "commit_id": "d6fa4b77fb8f27ac84cf23fb1e15016673d98a47", "target": 1, "func": "static void load_linux(void *fw_cfg,\n                       const char *kernel_filename,\n\t\t       const char *initrd_filename,\n\t\t       const char *kernel_cmdline,\n                       target_phys_addr_t max_ram_size)\n{\n    uint16_t protocol;\n    int setup_size, kernel_size, initrd_size = 0, cmdline_size;\n    uint32_t initrd_max;\n    uint8_t header[8192], *setup, *kernel, *initrd_data;\n    target_phys_addr_t real_addr, prot_addr, cmdline_addr, initrd_addr = 0;\n    FILE *f;\n    char *vmode;\n    /* Align to 16 bytes as a paranoia measure */\n    cmdline_size = (strlen(kernel_cmdline)+16) & ~15;\n    /* load the kernel header */\n    f = fopen(kernel_filename, \"rb\");\n    if (!f || !(kernel_size = get_file_size(f)) ||\n\tfread(header, 1, MIN(ARRAY_SIZE(header), kernel_size), f) !=\n\tMIN(ARRAY_SIZE(header), kernel_size)) {\n\tfprintf(stderr, \"qemu: could not load kernel '%s': %s\\n\",\n\t\tkernel_filename, strerror(errno));\n    /* kernel protocol version */\n#if 0\n    fprintf(stderr, \"header magic: %#x\\n\", ldl_p(header+0x202));\n#endif\n    if (ldl_p(header+0x202) == 0x53726448)\n\tprotocol = lduw_p(header+0x206);\n    else {\n\t/* This looks like a multiboot kernel. If it is, let's stop\n\t   treating it like a Linux kernel. */\n        if (load_multiboot(fw_cfg, f, kernel_filename, initrd_filename,\n                           kernel_cmdline, kernel_size, header))\n            return;\n\tprotocol = 0;\n    if (protocol < 0x200 || !(header[0x211] & 0x01)) {\n\t/* Low kernel */\n\treal_addr    = 0x90000;\n\tcmdline_addr = 0x9a000 - cmdline_size;\n\tprot_addr    = 0x10000;\n    } else if (protocol < 0x202) {\n\t/* High but ancient kernel */\n\treal_addr    = 0x90000;\n\tcmdline_addr = 0x9a000 - cmdline_size;\n\tprot_addr    = 0x100000;\n    } else {\n\t/* High and recent kernel */\n\treal_addr    = 0x10000;\n\tcmdline_addr = 0x20000;\n\tprot_addr    = 0x100000;\n#if 0\n    fprintf(stderr,\n\t    \"qemu: real_addr     = 0x\" TARGET_FMT_plx \"\\n\"\n\t    \"qemu: cmdline_addr  = 0x\" TARGET_FMT_plx \"\\n\"\n\t    \"qemu: prot_addr     = 0x\" TARGET_FMT_plx \"\\n\",\n\t    real_addr,\n\t    cmdline_addr,\n\t    prot_addr);\n#endif\n    /* highest address for loading the initrd */\n    if (protocol >= 0x203)\n\tinitrd_max = ldl_p(header+0x22c);\n    else\n\tinitrd_max = 0x37ffffff;\n    if (initrd_max >= max_ram_size-ACPI_DATA_SIZE)\n    \tinitrd_max = max_ram_size-ACPI_DATA_SIZE-1;\n    fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_ADDR, cmdline_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, strlen(kernel_cmdline)+1);\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_CMDLINE_DATA,\n                     (uint8_t*)strdup(kernel_cmdline),\n                     strlen(kernel_cmdline)+1);\n    if (protocol >= 0x202) {\n\tstl_p(header+0x228, cmdline_addr);\n    } else {\n\tstw_p(header+0x20, 0xA33F);\n\tstw_p(header+0x22, cmdline_addr-real_addr);\n    /* handle vga= parameter */\n    vmode = strstr(kernel_cmdline, \"vga=\");\n    if (vmode) {\n        unsigned int video_mode;\n        /* skip \"vga=\" */\n        vmode += 4;\n        if (!strncmp(vmode, \"normal\", 6)) {\n            video_mode = 0xffff;\n        } else if (!strncmp(vmode, \"ext\", 3)) {\n            video_mode = 0xfffe;\n        } else if (!strncmp(vmode, \"ask\", 3)) {\n            video_mode = 0xfffd;\n        } else {\n            video_mode = strtol(vmode, NULL, 0);\n        stw_p(header+0x1fa, video_mode);\n    /* loader type */\n    /* High nybble = B reserved for Qemu; low nybble is revision number.\n       If this code is substantially changed, you may want to consider\n       incrementing the revision. */\n    if (protocol >= 0x200)\n\theader[0x210] = 0xB0;\n    /* heap */\n    if (protocol >= 0x201) {\n\theader[0x211] |= 0x80;\t/* CAN_USE_HEAP */\n\tstw_p(header+0x224, cmdline_addr-real_addr-0x200);\n    /* load initrd */\n    if (initrd_filename) {\n\tif (protocol < 0x200) {\n\t    fprintf(stderr, \"qemu: linux kernel too old to load a ram disk\\n\");\n\tinitrd_size = get_image_size(initrd_filename);\n        initrd_addr = (initrd_max-initrd_size) & ~4095;\n        initrd_data = qemu_malloc(initrd_size);\n        load_image(initrd_filename, initrd_data);\n        fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_addr);\n        fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, initrd_data, initrd_size);\n\tstl_p(header+0x218, initrd_addr);\n\tstl_p(header+0x21c, initrd_size);\n    /* load kernel and setup */\n    setup_size = header[0x1f1];\n    if (setup_size == 0)\n\tsetup_size = 4;\n    setup_size = (setup_size+1)*512;\n    kernel_size -= setup_size;\n    setup  = qemu_malloc(setup_size);\n    kernel = qemu_malloc(kernel_size);\n    fseek(f, 0, SEEK_SET);\n    if (fread(setup, 1, setup_size, f) != setup_size) {\n        fprintf(stderr, \"fread() failed\\n\");\n    if (fread(kernel, 1, kernel_size, f) != kernel_size) {\n        fprintf(stderr, \"fread() failed\\n\");\n    fclose(f);\n    memcpy(setup, header, MIN(sizeof(header), setup_size));\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, prot_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA, kernel, kernel_size);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_SETUP_ADDR, real_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_SETUP_SIZE, setup_size);\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_SETUP_DATA, setup, setup_size);\n    option_rom[nb_option_roms] = \"linuxboot.bin\";\n    nb_option_roms++;", "idx": 5472}
{"project": "qemu", "commit_id": "d3c64d6a1874f94246af91963927fb4d924332f1", "target": 1, "func": "static void x86_cpu_apic_init(X86CPU *cpu, Error **errp)\n\n{\n\n    static int apic_mapped;\n\n    CPUX86State *env = &cpu->env;\n\n    APICCommonState *apic;\n\n    const char *apic_type = \"apic\";\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        apic_type = \"kvm-apic\";\n\n    } else if (xen_enabled()) {\n\n        apic_type = \"xen-apic\";\n\n    }\n\n\n\n    env->apic_state = qdev_try_create(NULL, apic_type);\n\n    if (env->apic_state == NULL) {\n\n        error_setg(errp, \"APIC device '%s' could not be created\", apic_type);\n\n        return;\n\n    }\n\n\n\n    object_property_add_child(OBJECT(cpu), \"apic\",\n\n                              OBJECT(env->apic_state), NULL);\n\n    qdev_prop_set_uint8(env->apic_state, \"id\", env->cpuid_apic_id);\n\n    /* TODO: convert to link<> */\n\n    apic = APIC_COMMON(env->apic_state);\n\n    apic->cpu = cpu;\n\n\n\n    if (qdev_init(env->apic_state)) {\n\n        error_setg(errp, \"APIC device '%s' could not be initialized\",\n\n                   object_get_typename(OBJECT(env->apic_state)));\n\n        return;\n\n    }\n\n\n\n    /* XXX: mapping more APICs at the same memory location */\n\n    if (apic_mapped == 0) {\n\n        /* NOTE: the APIC is directly connected to the CPU - it is not\n\n           on the global memory bus. */\n\n        /* XXX: what if the base changes? */\n\n        sysbus_mmio_map_overlap(SYS_BUS_DEVICE(env->apic_state), 0,\n\n                                APIC_DEFAULT_ADDRESS, 0x1000);\n\n        apic_mapped = 1;\n\n    }\n\n}\n", "idx": 6089}
{"project": "qemu", "commit_id": "49dd946bb5419681c8668b09a6d10f42bc707b78", "target": 1, "func": "static void coroutine_fn v9fs_open(void *opaque)\n\n{\n\n    int flags;\n\n    int32_t fid;\n\n    int32_t mode;\n\n    V9fsQID qid;\n\n    int iounit = 0;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    if (s->proto_version == V9FS_PROTO_2000L) {\n\n        err = pdu_unmarshal(pdu, offset, \"dd\", &fid, &mode);\n\n    } else {\n\n        uint8_t modebyte;\n\n        err = pdu_unmarshal(pdu, offset, \"db\", &fid, &modebyte);\n\n        mode = modebyte;\n\n    }\n\n    if (err < 0) {\n\n        goto out_nofid;\n\n    }\n\n    trace_v9fs_open(pdu->tag, pdu->id, fid, mode);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    stat_to_qid(&stbuf, &qid);\n\n    if (S_ISDIR(stbuf.st_mode)) {\n\n        err = v9fs_co_opendir(pdu, fidp);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        fidp->fid_type = P9_FID_DIR;\n\n        err = pdu_marshal(pdu, offset, \"Qd\", &qid, 0);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        err += offset;\n\n    } else {\n\n        if (s->proto_version == V9FS_PROTO_2000L) {\n\n            flags = get_dotl_openflags(s, mode);\n\n        } else {\n\n            flags = omode_to_uflags(mode);\n\n        }\n\n        if (is_ro_export(&s->ctx)) {\n\n            if (mode & O_WRONLY || mode & O_RDWR ||\n\n                mode & O_APPEND || mode & O_TRUNC) {\n\n                err = -EROFS;\n\n                goto out;\n\n            }\n\n        }\n\n        err = v9fs_co_open(pdu, fidp, flags);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        fidp->fid_type = P9_FID_FILE;\n\n        fidp->open_flags = flags;\n\n        if (flags & O_EXCL) {\n\n            /*\n\n             * We let the host file system do O_EXCL check\n\n             * We should not reclaim such fd\n\n             */\n\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n        }\n\n        iounit = get_iounit(pdu, &fidp->path);\n\n        err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        err += offset;\n\n    }\n\n    trace_v9fs_open_return(pdu->tag, pdu->id,\n\n                           qid.type, qid.version, qid.path, iounit);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    pdu_complete(pdu, err);\n\n}\n", "idx": 8014}
{"project": "qemu", "commit_id": "2f448e415f364d0ec4c5556993e44ca183e31c5c", "target": 1, "func": "static uint64_t unin_data_read(void *opaque, hwaddr addr,\n\n                               unsigned len)\n\n{\n\n    UNINState *s = opaque;\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    uint32_t val;\n\n\n\n    val = pci_data_read(phb->bus,\n\n                        unin_get_config_reg(phb->config_reg, addr),\n\n                        len);\n\n    UNIN_DPRINTF(\"read addr %\" TARGET_FMT_plx \" len %d val %x\\n\",\n\n                 addr, len, val);\n\n    return val;\n\n}\n", "idx": 7332}
{"project": "qemu", "commit_id": "42e4126b793d15ec40f3a84017e1d8afecda1b6d", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, uint32_t addr, uint32_t val, int l)\n\n{\n\n    int i, was_irq_disabled = pci_irq_disabled(d);\n\n    uint32_t config_size = pci_config_size(d);\n\n\n\n    for (i = 0; i < l && addr + i < config_size; val >>= 8, ++i) {\n\n        uint8_t wmask = d->wmask[addr + i];\n\n        uint8_t w1cmask = d->w1cmask[addr + i];\n\n        assert(!(wmask & w1cmask));\n\n        d->config[addr + i] = (d->config[addr + i] & ~wmask) | (val & wmask);\n\n        d->config[addr + i] &= ~(val & w1cmask); /* W1C: Write 1 to Clear */\n\n    }\n\n    if (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, 24) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS, 4) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, 4) ||\n\n        range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_mappings(d);\n\n\n\n    if (range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_irq_disabled(d, was_irq_disabled);\n\n}\n", "idx": 10603}
{"project": "qemu", "commit_id": "6e72719e721a40fe1224701ca10edc1caf0cd708", "target": 1, "func": "int qemu_pixman_get_type(int rshift, int gshift, int bshift)\n\n{\n\n    int type = PIXMAN_TYPE_OTHER;\n\n\n\n    if (rshift > gshift && gshift > bshift) {\n\n        if (bshift == 0) {\n\n            type = PIXMAN_TYPE_ARGB;\n\n        } else {\n\n\n            type = PIXMAN_TYPE_RGBA;\n\n\n        }\n\n    } else if (rshift < gshift && gshift < bshift) {\n\n        if (rshift == 0) {\n\n            type = PIXMAN_TYPE_ABGR;\n\n        } else {\n\n\n            type = PIXMAN_TYPE_BGRA;\n\n\n        }\n\n    }\n\n    return type;\n\n}", "idx": 9611}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "int virtio_scsi_common_exit(VirtIOSCSICommon *vs)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vs);\n\n\n\n    g_free(vs->cmd_vqs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 11416}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_downtime(double value, Error **errp)\n\n{\n\n    value *= 1e9;\n\n    value = MAX(0, MIN(UINT64_MAX, value));\n\n    max_downtime = (uint64_t)value;\n\n}\n", "idx": 8477}
{"project": "qemu", "commit_id": "ca96ac44dcd290566090b2435bc828fded356ad9", "target": 1, "func": "int aio_bh_poll(AioContext *ctx)\n\n{\n\n    QEMUBH *bh, **bhp, *next;\n\n    int ret;\n\n\n\n    ctx->walking_bh++;\n\n\n\n    ret = 0;\n\n    for (bh = ctx->first_bh; bh; bh = next) {\n\n        /* Make sure that fetching bh happens before accessing its members */\n\n        smp_read_barrier_depends();\n\n        next = bh->next;\n\n        /* The atomic_xchg is paired with the one in qemu_bh_schedule.  The\n\n         * implicit memory barrier ensures that the callback sees all writes\n\n         * done by the scheduling thread.  It also ensures that the scheduling\n\n         * thread sees the zero before bh->cb has run, and thus will call\n\n         * aio_notify again if necessary.\n\n         */\n\n        if (!bh->deleted && atomic_xchg(&bh->scheduled, 0)) {\n\n            if (!bh->idle)\n\n                ret = 1;\n\n            bh->idle = 0;\n\n            bh->cb(bh->opaque);\n\n        }\n\n    }\n\n\n\n    ctx->walking_bh--;\n\n\n\n    /* remove deleted bhs */\n\n    if (!ctx->walking_bh) {\n\n        qemu_mutex_lock(&ctx->bh_lock);\n\n        bhp = &ctx->first_bh;\n\n        while (*bhp) {\n\n            bh = *bhp;\n\n            if (bh->deleted) {\n\n                *bhp = bh->next;\n\n                g_free(bh);\n\n            } else {\n\n                bhp = &bh->next;\n\n            }\n\n        }\n\n        qemu_mutex_unlock(&ctx->bh_lock);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11569}
{"project": "qemu", "commit_id": "80a15e3e2eed96926d886693663503985c9a98bb", "target": 1, "func": "static int raw_read_options(QDict *options, BlockDriverState *bs,\n\n    BDRVRawState *s, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    QemuOpts *opts = NULL;\n\n    int64_t real_size = 0;\n\n    int ret;\n\n\n\n    real_size = bdrv_getlength(bs->file->bs);\n\n    if (real_size < 0) {\n\n        error_setg_errno(errp, -real_size, \"Could not get image size\");\n\n        return real_size;\n\n    }\n\n\n\n    opts = qemu_opts_create(&raw_runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    s->offset = qemu_opt_get_size(opts, \"offset\", 0);\n\n    if (s->offset > real_size) {\n\n        error_setg(errp, \"Offset (%\" PRIu64 \") cannot be greater than \"\n\n            \"size of the containing file (%\" PRId64 \")\",\n\n            s->offset, real_size);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    if (qemu_opt_find(opts, \"size\") != NULL) {\n\n        s->size = qemu_opt_get_size(opts, \"size\", 0);\n\n        s->has_size = true;\n\n    } else {\n\n        s->has_size = false;\n\n        s->size = real_size - s->offset;\n\n    }\n\n\n\n    /* Check size and offset */\n\n    if ((real_size - s->offset) < s->size) {\n\n        error_setg(errp, \"The sum of offset (%\" PRIu64 \") and size \"\n\n            \"(%\" PRIu64 \") has to be smaller or equal to the \"\n\n            \" actual size of the containing file (%\" PRId64 \")\",\n\n            s->offset, s->size, real_size);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    /* Make sure size is multiple of BDRV_SECTOR_SIZE to prevent rounding\n\n     * up and leaking out of the specified area. */\n\n    if (!QEMU_IS_ALIGNED(s->size, BDRV_SECTOR_SIZE)) {\n\n        error_setg(errp, \"Specified size is not multiple of %llu\",\n\n            BDRV_SECTOR_SIZE);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nend:\n\n\n\n    qemu_opts_del(opts);\n\n\n\n    return ret;\n\n}\n", "idx": 7021}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_bitmap(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    unsigned long *bmp = pv;\n\n    int i, idx = 0;\n\n    for (i = 0; i < BITS_TO_U64S(size); i++) {\n\n        uint64_t w = qemu_get_be64(f);\n\n        bmp[idx++] = w;\n\n        if (sizeof(unsigned long) == 4 && idx < BITS_TO_LONGS(size)) {\n\n            bmp[idx++] = w >> 32;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6603}
{"project": "qemu", "commit_id": "67a5b5d2f6eb6d3b980570223ba5c478487ddb6f", "target": 1, "func": "static inline void tb_alloc_page(TranslationBlock *tb,\n\n                                 unsigned int n, tb_page_addr_t page_addr)\n\n{\n\n    PageDesc *p;\n\n#ifndef CONFIG_USER_ONLY\n\n    bool page_already_protected;\n\n#endif\n\n\n\n    assert_memory_lock();\n\n\n\n    tb->page_addr[n] = page_addr;\n\n    p = page_find_alloc(page_addr >> TARGET_PAGE_BITS, 1);\n\n    tb->page_next[n] = p->first_tb;\n\n#ifndef CONFIG_USER_ONLY\n\n    page_already_protected = p->first_tb != NULL;\n\n#endif\n\n    p->first_tb = (TranslationBlock *)((uintptr_t)tb | n);\n\n    invalidate_page_bitmap(p);\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    if (p->flags & PAGE_WRITE) {\n\n        target_ulong addr;\n\n        PageDesc *p2;\n\n        int prot;\n\n\n\n        /* force the host page as non writable (writes will have a\n\n           page fault + mprotect overhead) */\n\n        page_addr &= qemu_host_page_mask;\n\n        prot = 0;\n\n        for (addr = page_addr; addr < page_addr + qemu_host_page_size;\n\n            addr += TARGET_PAGE_SIZE) {\n\n\n\n            p2 = page_find(addr >> TARGET_PAGE_BITS);\n\n            if (!p2) {\n\n                continue;\n\n            }\n\n            prot |= p2->flags;\n\n            p2->flags &= ~PAGE_WRITE;\n\n          }\n\n        mprotect(g2h(page_addr), qemu_host_page_size,\n\n                 (prot & PAGE_BITS) & ~PAGE_WRITE);\n\n#ifdef DEBUG_TB_INVALIDATE\n\n        printf(\"protecting code page: 0x\" TARGET_FMT_lx \"\\n\",\n\n               page_addr);\n\n#endif\n\n    }\n\n#else\n\n    /* if some code is already present, then the pages are already\n\n       protected. So we handle the case where only the first TB is\n\n       allocated in a physical page */\n\n    if (!page_already_protected) {\n\n        tlb_protect_code(page_addr);\n\n    }\n\n#endif\n\n}\n", "idx": 5411}
{"project": "qemu", "commit_id": "f8a83245d9ec685bc6aa6173d6765fe03e20688f", "target": 1, "func": "static void raw_close(BlockDriverState *bs)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    if (s->fd >= 0) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n        if (s->aligned_buf != NULL)\n\n            qemu_free(s->aligned_buf);\n\n    }\n\n}\n", "idx": 7836}
{"project": "qemu", "commit_id": "63fa06dc978f3669dbfd9443b33cde9e2a7f4b41", "target": 1, "func": "static int vdi_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    VdiHeader header;\n\n    size_t bmap_size;\n\n    int ret;\n\n\n\n    logout(\"\\n\");\n\n\n\n    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    vdi_header_to_cpu(&header);\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n\n\n    if (header.disk_size % SECTOR_SIZE != 0) {\n\n        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.\n\n           We accept them but round the disk size to the next multiple of\n\n           SECTOR_SIZE. */\n\n        logout(\"odd disk size %\" PRIu64 \" B, round up\\n\", header.disk_size);\n\n        header.disk_size += SECTOR_SIZE - 1;\n\n        header.disk_size &= ~(SECTOR_SIZE - 1);\n\n    }\n\n\n\n    if (header.signature != VDI_SIGNATURE) {\n\n        error_setg(errp, \"Image not in VDI format (bad signature %08x)\", header.signature);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else if (header.version != VDI_VERSION_1_1) {\n\n        error_setg(errp, \"unsupported VDI image (version %u.%u)\",\n\n                   header.version >> 16, header.version & 0xffff);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_bmap % SECTOR_SIZE != 0) {\n\n        /* We only support block maps which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned block map offset \"\n\n                   \"0x%x)\", header.offset_bmap);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_data % SECTOR_SIZE != 0) {\n\n        /* We only support data blocks which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned data offset 0x%x)\",\n\n                   header.offset_data);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.sector_size != SECTOR_SIZE) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.sector_size, SECTOR_SIZE);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.block_size != 1 * MiB) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.block_size, 1 * MiB);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.disk_size >\n\n               (uint64_t)header.blocks_in_image * header.block_size) {\n\n        error_setg(errp, \"unsupported VDI image (disk size %\" PRIu64 \", \"\n\n                   \"image bitmap has room for %\" PRIu64 \")\",\n\n                   header.disk_size,\n\n                   (uint64_t)header.blocks_in_image * header.block_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_link)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL link UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_parent)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL parent UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    bs->total_sectors = header.disk_size / SECTOR_SIZE;\n\n\n\n    s->block_size = header.block_size;\n\n    s->block_sectors = header.block_size / SECTOR_SIZE;\n\n    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;\n\n    s->header = header;\n\n\n\n    bmap_size = header.blocks_in_image * sizeof(uint32_t);\n\n    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    s->bmap = g_malloc(bmap_size * SECTOR_SIZE);\n\n    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);\n\n    if (ret < 0) {\n\n        goto fail_free_bmap;\n\n    }\n\n\n\n    /* Disable migration when vdi images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vdi\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\n fail_free_bmap:\n\n    g_free(s->bmap);\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 1381}
{"project": "qemu", "commit_id": "5cb9b56acfc0b50acf7ccd2d044ab4991c47fdde", "target": 1, "func": "static int print_uint16(DeviceState *dev, Property *prop, char *dest, size_t len)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    return snprintf(dest, len, \"%\" PRIu16, *ptr);\n\n}\n", "idx": 516}
{"project": "qemu", "commit_id": "4751fd5328dfcd4fe2f9055728a72a0e3ae56512", "target": 1, "func": "static int fchmodat_nofollow(int dirfd, const char *name, mode_t mode)\n\n{\n\n    int fd, ret;\n\n\n\n    /* FIXME: this should be handled with fchmodat(AT_SYMLINK_NOFOLLOW).\n\n     * Unfortunately, the linux kernel doesn't implement it yet. As an\n\n     * alternative, let's open the file and use fchmod() instead. This\n\n     * may fail depending on the permissions of the file, but it is the\n\n     * best we can do to avoid TOCTTOU. We first try to open read-only\n\n     * in case name points to a directory. If that fails, we try write-only\n\n     * in case name doesn't point to a directory.\n\n     */\n\n    fd = openat_file(dirfd, name, O_RDONLY, 0);\n\n    if (fd == -1) {\n\n        /* In case the file is writable-only and isn't a directory. */\n\n        if (errno == EACCES) {\n\n            fd = openat_file(dirfd, name, O_WRONLY, 0);\n\n        }\n\n        if (fd == -1 && errno == EISDIR) {\n\n            errno = EACCES;\n\n        }\n\n    }\n\n    if (fd == -1) {\n\n        return -1;\n\n    }\n\n    ret = fchmod(fd, mode);\n\n    close_preserve_errno(fd);\n\n    return ret;\n\n}\n", "idx": 12182}
{"project": "qemu", "commit_id": "339064d5063924e5176842abbf6c8089f3479c5b", "target": 1, "func": "bool bdrv_qiov_is_aligned(BlockDriverState *bs, QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % bs->buffer_alignment) {\n\n            return false;\n\n        }\n\n        if (qiov->iov[i].iov_len % bs->buffer_alignment) {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 11538}
{"project": "qemu", "commit_id": "62ef3760d4e400849fc663474227bb4668244455", "target": 1, "func": "sPAPROptionVector *spapr_ovec_new(void)\n\n{\n\n    sPAPROptionVector *ov;\n\n\n\n    ov = g_new0(sPAPROptionVector, 1);\n\n    ov->bitmap = bitmap_new(OV_MAXBITS);\n\n\n\n\n    return ov;\n\n}", "idx": 2600}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static int csrhci_write(struct CharDriverState *chr,\n\n                const uint8_t *buf, int len)\n\n{\n\n    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;\n\n    int plen = s->in_len;\n\n\n\n    if (!s->enable)\n\n        return 0;\n\n\n\n    s->in_len += len;\n\n    memcpy(s->inpkt + plen, buf, len);\n\n\n\n    while (1) {\n\n        if (s->in_len >= 2 && plen < 2)\n\n            s->in_hdr = csrhci_header_len(s->inpkt) + 1;\n\n\n\n        if (s->in_len >= s->in_hdr && plen < s->in_hdr)\n\n            s->in_data = csrhci_data_len(s->inpkt) + s->in_hdr;\n\n\n\n        if (s->in_len >= s->in_data) {\n\n            csrhci_in_packet(s, s->inpkt);\n\n\n\n            memmove(s->inpkt, s->inpkt + s->in_len, s->in_len - s->in_data);\n\n            s->in_len -= s->in_data;\n\n            s->in_hdr = INT_MAX;\n\n            s->in_data = INT_MAX;\n\n            plen = 0;\n\n        } else\n\n            break;\n\n    }\n\n\n\n    return len;\n\n}\n", "idx": 10545}
{"project": "qemu", "commit_id": "d4862a87e31a51de9eb260f25c9e99a75efe3235", "target": 1, "func": "static uint64_t pit_ioport_read(void *opaque, hwaddr addr,\n                                unsigned size)\n{\n    PITCommonState *pit = opaque;\n    int ret, count;\n    PITChannelState *s;\n    addr &= 3;\n    s = &pit->channels[addr];\n    if (s->status_latched) {\n        s->status_latched = 0;\n        ret = s->status;\n    } else if (s->count_latched) {\n        switch(s->count_latched) {\n        default:\n        case RW_STATE_LSB:\n            ret = s->latched_count & 0xff;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_MSB:\n            ret = s->latched_count >> 8;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_WORD0:\n            ret = s->latched_count & 0xff;\n            s->count_latched = RW_STATE_MSB;\n            break;\n    } else {\n        switch(s->read_state) {\n        default:\n        case RW_STATE_LSB:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            break;\n        case RW_STATE_MSB:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            break;\n        case RW_STATE_WORD0:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            s->read_state = RW_STATE_WORD1;\n            break;\n        case RW_STATE_WORD1:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            s->read_state = RW_STATE_WORD0;\n            break;\n    return ret;", "idx": 10755}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_slbmte(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    gen_helper_store_slb(cpu_env, cpu_gpr[rB(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 6608}
{"project": "qemu", "commit_id": "abc981bf292fb361f8a509c3611ddf2ba2c43360", "target": 1, "func": "static void test_io_channel_ipv4_fd(void)\n{\n    QIOChannel *ioc;\n    int fd = -1;\n    fd = socket(AF_INET, SOCK_STREAM, 0);\n    g_assert_cmpint(fd, >, -1);\n    ioc = qio_channel_new_fd(fd, &error_abort);\n    g_assert_cmpstr(object_get_typename(OBJECT(ioc)),\n                    ==,\n                    TYPE_QIO_CHANNEL_SOCKET);\n    object_unref(OBJECT(ioc));", "idx": 3709}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "RTCState *rtc_init(int base_year)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"mc146818rtc\");\n\n    qdev_prop_set_int32(&dev->qdev, \"base_year\", base_year);\n\n    qdev_init(&dev->qdev);\n\n    return DO_UPCAST(RTCState, dev, dev);\n\n}\n", "idx": 8112}
{"project": "qemu", "commit_id": "51b58561c1dacdb0ce999ada94912caaed157f83", "target": 1, "func": "static ssize_t gunzip(void *dst, size_t dstlen, uint8_t *src,\n\n                      size_t srclen)\n\n{\n\n    z_stream s;\n\n    ssize_t dstbytes;\n\n    int r, i, flags;\n\n\n\n    /* skip header */\n\n    i = 10;\n\n    flags = src[3];\n\n    if (src[2] != DEFLATED || (flags & RESERVED) != 0) {\n\n        puts (\"Error: Bad gzipped data\\n\");\n\n        return -1;\n\n    }\n\n    if ((flags & EXTRA_FIELD) != 0)\n\n        i = 12 + src[10] + (src[11] << 8);\n\n    if ((flags & ORIG_NAME) != 0)\n\n        while (src[i++] != 0)\n\n            ;\n\n    if ((flags & COMMENT) != 0)\n\n        while (src[i++] != 0)\n\n            ;\n\n    if ((flags & HEAD_CRC) != 0)\n\n        i += 2;\n\n    if (i >= srclen) {\n\n        puts (\"Error: gunzip out of data in header\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s.zalloc = zalloc;\n\n    s.zfree = zfree;\n\n\n\n    r = inflateInit2(&s, -MAX_WBITS);\n\n    if (r != Z_OK) {\n\n        printf (\"Error: inflateInit2() returned %d\\n\", r);\n\n        return (-1);\n\n    }\n\n    s.next_in = src + i;\n\n    s.avail_in = srclen - i;\n\n    s.next_out = dst;\n\n    s.avail_out = dstlen;\n\n    r = inflate(&s, Z_FINISH);\n\n    if (r != Z_OK && r != Z_STREAM_END) {\n\n        printf (\"Error: inflate() returned %d\\n\", r);\n\n        return -1;\n\n    }\n\n    dstbytes = s.next_out - (unsigned char *) dst;\n\n    inflateEnd(&s);\n\n\n\n    return dstbytes;\n\n}\n", "idx": 5662}
{"project": "qemu", "commit_id": "34d5e948e8a0d0d3a37801a418475a8632ce0891", "target": 1, "func": "static void cpu_notify_map_clients(void)\n\n{\n\n    MapClient *client;\n\n\n\n    while (!LIST_EMPTY(&map_client_list)) {\n\n        client = LIST_FIRST(&map_client_list);\n\n        client->callback(client->opaque);\n\n        LIST_REMOVE(client, link);\n\n    }\n\n}\n", "idx": 6584}
{"project": "qemu", "commit_id": "c573fc03da65e35bf44bce0448ea12801e3631ac", "target": 1, "func": "static int htab_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    sPAPRMachineState *spapr = opaque;\n\n    int fd;\n\n\n\n    /* Iteration header */\n\n    qemu_put_be32(f, 0);\n\n\n\n    if (!spapr->htab) {\n\n        int rc;\n\n\n\n        assert(kvm_enabled());\n\n\n\n        fd = get_htab_fd(spapr);\n\n        if (fd < 0) {\n\n            return fd;\n\n        }\n\n\n\n        rc = kvmppc_save_htab(f, fd, MAX_KVM_BUF_SIZE, -1);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n        close_htab_fd(spapr);\n\n    } else {\n\n        if (spapr->htab_first_pass) {\n\n            htab_save_first_pass(f, spapr, -1);\n\n        }\n\n        htab_save_later_pass(f, spapr, -1);\n\n    }\n\n\n\n    /* End marker */\n\n    qemu_put_be32(f, 0);\n\n    qemu_put_be16(f, 0);\n\n    qemu_put_be16(f, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 9957}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "MemoryRegionSection memory_region_find(MemoryRegion *address_space,\n\n                                       target_phys_addr_t addr, uint64_t size)\n\n{\n\n    AddressSpace *as = memory_region_to_address_space(address_space);\n\n    AddrRange range = addrrange_make(int128_make64(addr),\n\n                                     int128_make64(size));\n\n    FlatRange *fr = address_space_lookup(as, range);\n\n    MemoryRegionSection ret = { .mr = NULL, .size = 0 };\n\n\n\n    if (!fr) {\n\n        return ret;\n\n    }\n\n\n\n    while (fr > as->current_map.ranges\n\n           && addrrange_intersects(fr[-1].addr, range)) {\n\n        --fr;\n\n    }\n\n\n\n    ret.mr = fr->mr;\n\n    range = addrrange_intersection(range, fr->addr);\n\n    ret.offset_within_region = fr->offset_in_region;\n\n    ret.offset_within_region += int128_get64(int128_sub(range.start,\n\n                                                        fr->addr.start));\n\n    ret.size = int128_get64(range.size);\n\n    ret.offset_within_address_space = int128_get64(range.start);\n\n    ret.readonly = fr->readonly;\n\n    return ret;\n\n}\n", "idx": 9879}
{"project": "qemu", "commit_id": "62ef3760d4e400849fc663474227bb4668244455", "target": 1, "func": "sPAPROptionVector *spapr_ovec_new(void)\n\n{\n\n    sPAPROptionVector *ov;\n\n\n\n    ov = g_new0(sPAPROptionVector, 1);\n\n    ov->bitmap = bitmap_new(OV_MAXBITS);\n\n\n\n\n    return ov;\n\n}", "idx": 2600}
{"project": "qemu", "commit_id": "96dd9aac37d30f3425088f81523942e67b2d03ac", "target": 1, "func": "static uint8_t usb_linux_get_alt_setting(USBHostDevice *s,\n\n    uint8_t configuration, uint8_t interface)\n\n{\n\n    char device_name[64], line[1024];\n\n    int alt_setting;\n\n\n\n    sprintf(device_name, \"%d-%s:%d.%d\", s->bus_num, s->port,\n\n            (int)configuration, (int)interface);\n\n\n\n    if (!usb_host_read_file(line, sizeof(line), \"bAlternateSetting\",\n\n                            device_name)) {\n\n        /* Assume alt 0 on error */\n\n        return 0;\n\n    }\n\n    if (sscanf(line, \"%d\", &alt_setting) != 1) {\n\n        /* Assume alt 0 on error */\n\n        return 0;\n\n    }\n\n    return alt_setting;\n\n}\n", "idx": 5490}
{"project": "qemu", "commit_id": "393c13b940be8f2e5b126cd9f442c12e7ecb4cac", "target": 1, "func": "static void bt_l2cap_sdp_close_ch(void *opaque)\n\n{\n\n    struct bt_l2cap_sdp_state_s *sdp = opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < sdp->services; i ++) {\n\n        g_free(sdp->service_list[i].attribute_list->pair);\n\n        g_free(sdp->service_list[i].attribute_list);\n\n        g_free(sdp->service_list[i].uuid);\n\n    }\n\n    g_free(sdp->service_list);\n\n    g_free(sdp);\n\n}\n", "idx": 10157}
{"project": "qemu", "commit_id": "702dbcc274e2ca43be20ba64c758c0ca57dab91d", "target": 1, "func": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n\n\n\n    g_free(s->tag);\n\n    g_free(s->ctx.fs_root);\n", "idx": 1828}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n", "idx": 1598}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint8_t qpci_pc_config_readb(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inb(0xcfc);\n\n}\n", "idx": 11068}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static void virtio_blk_free_request(VirtIOBlockReq *req)\n\n{\n\n    if (req) {\n\n        g_slice_free(VirtQueueElement, req->elem);\n\n        g_slice_free(VirtIOBlockReq, req);\n\n    }\n\n}\n", "idx": 10806}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static gboolean qio_channel_yield_enter(QIOChannel *ioc,\n\n                                        GIOCondition condition,\n\n                                        gpointer opaque)\n\n{\n\n    QIOChannelYieldData *data = opaque;\n\n    qemu_coroutine_enter(data->co, NULL);\n\n    return FALSE;\n\n}\n", "idx": 1701}
{"project": "qemu", "commit_id": "c8389550dedc65892fba9c3df29423efd802f544", "target": 1, "func": "static void vmgenid_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VmGenIdState *vms = VMGENID(dev);\n\n\n\n    if (!vms->write_pointer_available) {\n\n        error_setg(errp, \"%s requires DMA write support in fw_cfg, \"\n\n                   \"which this machine type does not provide\", VMGENID_DEVICE);\n\n        return;\n\n    }\n\n\n\n    /* Given that this function is executing, there is at least one VMGENID\n\n     * device. Check if there are several.\n\n     */\n\n    if (!find_vmgenid_dev()) {\n\n        error_setg(errp, \"at most one %s device is permitted\", VMGENID_DEVICE);\n\n        return;\n\n    }\n\n\n\n    qemu_register_reset(vmgenid_handle_reset, vms);\n\n}\n", "idx": 7971}
{"project": "qemu", "commit_id": "47025a0193f1f910300adfa443305ccf8482ef87", "target": 1, "func": "static void qxl_realize_primary(PCIDevice *dev, Error **errp)\n\n{\n\n    PCIQXLDevice *qxl = PCI_QXL(dev);\n\n    VGACommonState *vga = &qxl->vga;\n\n    Error *local_err = NULL;\n\n\n\n    qxl->id = 0;\n\n    qxl_init_ramsize(qxl);\n\n    vga->vbe_size = qxl->vgamem_size;\n\n    vga->vram_size_mb = qxl->vga.vram_size >> 20;\n\n    vga_common_init(vga, OBJECT(dev), true);\n\n    vga_init(vga, OBJECT(dev),\n\n             pci_address_space(dev), pci_address_space_io(dev), false);\n\n    portio_list_init(&qxl->vga_port_list, OBJECT(dev), qxl_vga_portio_list,\n\n                     vga, \"vga\");\n\n    portio_list_set_flush_coalesced(&qxl->vga_port_list);\n\n    portio_list_add(&qxl->vga_port_list, pci_address_space_io(dev), 0x3b0);\n\n\n\n    vga->con = graphic_console_init(DEVICE(dev), 0, &qxl_ops, qxl);\n\n    qemu_spice_display_init_common(&qxl->ssd);\n\n\n\n    qxl_realize_common(qxl, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    qxl->ssd.dcl.ops = &display_listener_ops;\n\n    qxl->ssd.dcl.con = vga->con;\n\n    register_displaychangelistener(&qxl->ssd.dcl);\n\n}\n", "idx": 10628}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_subfo (void)\n\n{\n\n    do_subfo();\n\n    RETURN();\n\n}\n", "idx": 6592}
{"project": "qemu", "commit_id": "e4c1cfa5cb8f8bfbbfd949f2fabbe2be35e60c99", "target": 1, "func": "static int disas_vfp_insn(CPUARMState * env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd, rn, rm, op, i, n, offset, delta_d, delta_m, bank_mask;\n\n    int dp, veclen;\n\n    TCGv addr;\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_VFP))\n\n        return 1;\n\n\n\n    if (!s->vfp_enabled) {\n\n        /* VFP disabled.  Only allow fmxr/fmrx to/from some control regs.  */\n\n        if ((insn & 0x0fe00fff) != 0x0ee00a10)\n\n            return 1;\n\n        rn = (insn >> 16) & 0xf;\n\n        if (rn != ARM_VFP_FPSID && rn != ARM_VFP_FPEXC\n\n            && rn != ARM_VFP_MVFR1 && rn != ARM_VFP_MVFR0)\n\n            return 1;\n\n    }\n\n    dp = ((insn & 0xf00) == 0xb00);\n\n    switch ((insn >> 24) & 0xf) {\n\n    case 0xe:\n\n        if (insn & (1 << 4)) {\n\n            /* single register transfer */\n\n            rd = (insn >> 12) & 0xf;\n\n            if (dp) {\n\n                int size;\n\n                int pass;\n\n\n\n                VFP_DREG_N(rn, insn);\n\n                if (insn & 0xf)\n\n                    return 1;\n\n                if (insn & 0x00c00060\n\n                    && !arm_feature(env, ARM_FEATURE_NEON))\n\n                    return 1;\n\n\n\n                pass = (insn >> 21) & 1;\n\n                if (insn & (1 << 22)) {\n\n                    size = 0;\n\n                    offset = ((insn >> 5) & 3) * 8;\n\n                } else if (insn & (1 << 5)) {\n\n                    size = 1;\n\n                    offset = (insn & (1 << 6)) ? 16 : 0;\n\n                } else {\n\n                    size = 2;\n\n                    offset = 0;\n\n                }\n\n                if (insn & ARM_CP_RW_BIT) {\n\n                    /* vfp->arm */\n\n                    tmp = neon_load_reg(rn, pass);\n\n                    switch (size) {\n\n                    case 0:\n\n                        if (offset)\n\n                            tcg_gen_shri_i32(tmp, tmp, offset);\n\n                        if (insn & (1 << 23))\n\n                            gen_uxtb(tmp);\n\n                        else\n\n                            gen_sxtb(tmp);\n\n                        break;\n\n                    case 1:\n\n                        if (insn & (1 << 23)) {\n\n                            if (offset) {\n\n                                tcg_gen_shri_i32(tmp, tmp, 16);\n\n                            } else {\n\n                                gen_uxth(tmp);\n\n                            }\n\n                        } else {\n\n                            if (offset) {\n\n                                tcg_gen_sari_i32(tmp, tmp, 16);\n\n                            } else {\n\n                                gen_sxth(tmp);\n\n                            }\n\n                        }\n\n                        break;\n\n                    case 2:\n\n                        break;\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    /* arm->vfp */\n\n                    tmp = load_reg(s, rd);\n\n                    if (insn & (1 << 23)) {\n\n                        /* VDUP */\n\n                        if (size == 0) {\n\n                            gen_neon_dup_u8(tmp, 0);\n\n                        } else if (size == 1) {\n\n                            gen_neon_dup_low16(tmp);\n\n                        }\n\n                        for (n = 0; n <= pass * 2; n++) {\n\n                            tmp2 = tcg_temp_new_i32();\n\n                            tcg_gen_mov_i32(tmp2, tmp);\n\n                            neon_store_reg(rn, n, tmp2);\n\n                        }\n\n                        neon_store_reg(rn, n, tmp);\n\n                    } else {\n\n                        /* VMOV */\n\n                        switch (size) {\n\n                        case 0:\n\n                            tmp2 = neon_load_reg(rn, pass);\n\n                            tcg_gen_deposit_i32(tmp, tmp2, tmp, offset, 8);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            break;\n\n                        case 1:\n\n                            tmp2 = neon_load_reg(rn, pass);\n\n                            tcg_gen_deposit_i32(tmp, tmp2, tmp, offset, 16);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            break;\n\n                        case 2:\n\n                            break;\n\n                        }\n\n                        neon_store_reg(rn, pass, tmp);\n\n                    }\n\n                }\n\n            } else { /* !dp */\n\n                if ((insn & 0x6f) != 0x00)\n\n                    return 1;\n\n                rn = VFP_SREG_N(insn);\n\n                if (insn & ARM_CP_RW_BIT) {\n\n                    /* vfp->arm */\n\n                    if (insn & (1 << 21)) {\n\n                        /* system register */\n\n                        rn >>= 1;\n\n\n\n                        switch (rn) {\n\n                        case ARM_VFP_FPSID:\n\n                            /* VFP2 allows access to FSID from userspace.\n\n                               VFP3 restricts all id registers to privileged\n\n                               accesses.  */\n\n                            if (IS_USER(s)\n\n                                && arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPEXC:\n\n                            if (IS_USER(s))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPINST:\n\n                        case ARM_VFP_FPINST2:\n\n                            /* Not present in VFP3.  */\n\n                            if (IS_USER(s)\n\n                                || arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPSCR:\n\n                            if (rd == 15) {\n\n                                tmp = load_cpu_field(vfp.xregs[ARM_VFP_FPSCR]);\n\n                                tcg_gen_andi_i32(tmp, tmp, 0xf0000000);\n\n                            } else {\n\n                                tmp = tcg_temp_new_i32();\n\n                                gen_helper_vfp_get_fpscr(tmp, cpu_env);\n\n                            }\n\n                            break;\n\n                        case ARM_VFP_MVFR0:\n\n                        case ARM_VFP_MVFR1:\n\n                            if (IS_USER(s)\n\n                                || !arm_feature(env, ARM_FEATURE_MVFR))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        default:\n\n                            return 1;\n\n                        }\n\n                    } else {\n\n                        gen_mov_F0_vreg(0, rn);\n\n                        tmp = gen_vfp_mrs();\n\n                    }\n\n                    if (rd == 15) {\n\n                        /* Set the 4 flag bits in the CPSR.  */\n\n                        gen_set_nzcv(tmp);\n\n                        tcg_temp_free_i32(tmp);\n\n                    } else {\n\n                        store_reg(s, rd, tmp);\n\n                    }\n\n                } else {\n\n                    /* arm->vfp */\n\n                    tmp = load_reg(s, rd);\n\n                    if (insn & (1 << 21)) {\n\n                        rn >>= 1;\n\n                        /* system register */\n\n                        switch (rn) {\n\n                        case ARM_VFP_FPSID:\n\n                        case ARM_VFP_MVFR0:\n\n                        case ARM_VFP_MVFR1:\n\n                            /* Writes are ignored.  */\n\n                            break;\n\n                        case ARM_VFP_FPSCR:\n\n                            gen_helper_vfp_set_fpscr(cpu_env, tmp);\n\n                            tcg_temp_free_i32(tmp);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        case ARM_VFP_FPEXC:\n\n                            if (IS_USER(s))\n\n                                return 1;\n\n                            /* TODO: VFP subarchitecture support.\n\n                             * For now, keep the EN bit only */\n\n                            tcg_gen_andi_i32(tmp, tmp, 1 << 30);\n\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        case ARM_VFP_FPINST:\n\n                        case ARM_VFP_FPINST2:\n\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n\n                            break;\n\n                        default:\n\n                            return 1;\n\n                        }\n\n                    } else {\n\n                        gen_vfp_msr(tmp);\n\n                        gen_mov_vreg_F0(0, rn);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            /* data processing */\n\n            /* The opcode is in bits 23, 21, 20 and 6.  */\n\n            op = ((insn >> 20) & 8) | ((insn >> 19) & 6) | ((insn >> 6) & 1);\n\n            if (dp) {\n\n                if (op == 15) {\n\n                    /* rn is opcode */\n\n                    rn = ((insn >> 15) & 0x1e) | ((insn >> 7) & 1);\n\n                } else {\n\n                    /* rn is register number */\n\n                    VFP_DREG_N(rn, insn);\n\n                }\n\n\n\n                if (op == 15 && (rn == 15 || ((rn & 0x1c) == 0x18))) {\n\n                    /* Integer or single precision destination.  */\n\n                    rd = VFP_SREG_D(insn);\n\n                } else {\n\n                    VFP_DREG_D(rd, insn);\n\n                }\n\n                if (op == 15 &&\n\n                    (((rn & 0x1c) == 0x10) || ((rn & 0x14) == 0x14))) {\n\n                    /* VCVT from int is always from S reg regardless of dp bit.\n\n                     * VCVT with immediate frac_bits has same format as SREG_M\n\n                     */\n\n                    rm = VFP_SREG_M(insn);\n\n                } else {\n\n                    VFP_DREG_M(rm, insn);\n\n                }\n\n            } else {\n\n                rn = VFP_SREG_N(insn);\n\n                if (op == 15 && rn == 15) {\n\n                    /* Double precision destination.  */\n\n                    VFP_DREG_D(rd, insn);\n\n                } else {\n\n                    rd = VFP_SREG_D(insn);\n\n                }\n\n                /* NB that we implicitly rely on the encoding for the frac_bits\n\n                 * in VCVT of fixed to float being the same as that of an SREG_M\n\n                 */\n\n                rm = VFP_SREG_M(insn);\n\n            }\n\n\n\n            veclen = s->vec_len;\n\n            if (op == 15 && rn > 3)\n\n                veclen = 0;\n\n\n\n            /* Shut up compiler warnings.  */\n\n            delta_m = 0;\n\n            delta_d = 0;\n\n            bank_mask = 0;\n\n\n\n            if (veclen > 0) {\n\n                if (dp)\n\n                    bank_mask = 0xc;\n\n                else\n\n                    bank_mask = 0x18;\n\n\n\n                /* Figure out what type of vector operation this is.  */\n\n                if ((rd & bank_mask) == 0) {\n\n                    /* scalar */\n\n                    veclen = 0;\n\n                } else {\n\n                    if (dp)\n\n                        delta_d = (s->vec_stride >> 1) + 1;\n\n                    else\n\n                        delta_d = s->vec_stride + 1;\n\n\n\n                    if ((rm & bank_mask) == 0) {\n\n                        /* mixed scalar/vector */\n\n                        delta_m = 0;\n\n                    } else {\n\n                        /* vector */\n\n                        delta_m = delta_d;\n\n                    }\n\n                }\n\n            }\n\n\n\n            /* Load the initial operands.  */\n\n            if (op == 15) {\n\n                switch (rn) {\n\n                case 16:\n\n                case 17:\n\n                    /* Integer source */\n\n                    gen_mov_F0_vreg(0, rm);\n\n                    break;\n\n                case 8:\n\n                case 9:\n\n                    /* Compare */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_mov_F1_vreg(dp, rm);\n\n                    break;\n\n                case 10:\n\n                case 11:\n\n                    /* Compare with zero */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_F1_ld0(dp);\n\n                    break;\n\n                case 20:\n\n                case 21:\n\n                case 22:\n\n                case 23:\n\n                case 28:\n\n                case 29:\n\n                case 30:\n\n                case 31:\n\n                    /* Source and destination the same.  */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    break;\n\n                case 4:\n\n                case 5:\n\n                case 6:\n\n                case 7:\n\n                    /* VCVTB, VCVTT: only present with the halfprec extension,\n\n                     * UNPREDICTABLE if bit 8 is set (we choose to UNDEF)\n\n                     */\n\n                    if (dp || !arm_feature(env, ARM_FEATURE_VFP_FP16)) {\n\n                        return 1;\n\n                    }\n\n                    /* Otherwise fall through */\n\n                default:\n\n                    /* One source operand.  */\n\n                    gen_mov_F0_vreg(dp, rm);\n\n                    break;\n\n                }\n\n            } else {\n\n                /* Two source operands.  */\n\n                gen_mov_F0_vreg(dp, rn);\n\n                gen_mov_F1_vreg(dp, rm);\n\n            }\n\n\n\n            for (;;) {\n\n                /* Perform the calculation.  */\n\n                switch (op) {\n\n                case 0: /* VMLA: fd + (fn * fm) */\n\n                    /* Note that order of inputs to the add matters for NaNs */\n\n                    gen_vfp_F1_mul(dp);\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 1: /* VMLS: fd + -(fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_F1_neg(dp);\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 2: /* VNMLS: -fd + (fn * fm) */\n\n                    /* Note that it isn't valid to replace (-A + B) with (B - A)\n\n                     * or similar plausible looking simplifications\n\n                     * because this will give wrong results for NaNs.\n\n                     */\n\n                    gen_vfp_F1_mul(dp);\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_neg(dp);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 3: /* VNMLA: -fd + -(fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_F1_neg(dp);\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_neg(dp);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 4: /* mul: fn * fm */\n\n                    gen_vfp_mul(dp);\n\n                    break;\n\n                case 5: /* nmul: -(fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_neg(dp);\n\n                    break;\n\n                case 6: /* add: fn + fm */\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 7: /* sub: fn - fm */\n\n                    gen_vfp_sub(dp);\n\n                    break;\n\n                case 8: /* div: fn / fm */\n\n                    gen_vfp_div(dp);\n\n                    break;\n\n                case 10: /* VFNMA : fd = muladd(-fd,  fn, fm) */\n\n                case 11: /* VFNMS : fd = muladd(-fd, -fn, fm) */\n\n                case 12: /* VFMA  : fd = muladd( fd,  fn, fm) */\n\n                case 13: /* VFMS  : fd = muladd( fd, -fn, fm) */\n\n                    /* These are fused multiply-add, and must be done as one\n\n                     * floating point operation with no rounding between the\n\n                     * multiplication and addition steps.\n\n                     * NB that doing the negations here as separate steps is\n\n                     * correct : an input NaN should come out with its sign bit\n\n                     * flipped if it is a negated-input.\n\n                     */\n\n                    if (!arm_feature(env, ARM_FEATURE_VFP4)) {\n\n                        return 1;\n\n                    }\n\n                    if (dp) {\n\n                        TCGv_ptr fpst;\n\n                        TCGv_i64 frd;\n\n                        if (op & 1) {\n\n                            /* VFNMS, VFMS */\n\n                            gen_helper_vfp_negd(cpu_F0d, cpu_F0d);\n\n                        }\n\n                        frd = tcg_temp_new_i64();\n\n                        tcg_gen_ld_f64(frd, cpu_env, vfp_reg_offset(dp, rd));\n\n                        if (op & 2) {\n\n                            /* VFNMA, VFNMS */\n\n                            gen_helper_vfp_negd(frd, frd);\n\n                        }\n\n                        fpst = get_fpstatus_ptr(0);\n\n                        gen_helper_vfp_muladdd(cpu_F0d, cpu_F0d,\n\n                                               cpu_F1d, frd, fpst);\n\n                        tcg_temp_free_ptr(fpst);\n\n                        tcg_temp_free_i64(frd);\n\n                    } else {\n\n                        TCGv_ptr fpst;\n\n                        TCGv_i32 frd;\n\n                        if (op & 1) {\n\n                            /* VFNMS, VFMS */\n\n                            gen_helper_vfp_negs(cpu_F0s, cpu_F0s);\n\n                        }\n\n                        frd = tcg_temp_new_i32();\n\n                        tcg_gen_ld_f32(frd, cpu_env, vfp_reg_offset(dp, rd));\n\n                        if (op & 2) {\n\n                            gen_helper_vfp_negs(frd, frd);\n\n                        }\n\n                        fpst = get_fpstatus_ptr(0);\n\n                        gen_helper_vfp_muladds(cpu_F0s, cpu_F0s,\n\n                                               cpu_F1s, frd, fpst);\n\n                        tcg_temp_free_ptr(fpst);\n\n                        tcg_temp_free_i32(frd);\n\n                    }\n\n                    break;\n\n                case 14: /* fconst */\n\n                    if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                      return 1;\n\n\n\n                    n = (insn << 12) & 0x80000000;\n\n                    i = ((insn >> 12) & 0x70) | (insn & 0xf);\n\n                    if (dp) {\n\n                        if (i & 0x40)\n\n                            i |= 0x3f80;\n\n                        else\n\n                            i |= 0x4000;\n\n                        n |= i << 16;\n\n                        tcg_gen_movi_i64(cpu_F0d, ((uint64_t)n) << 32);\n\n                    } else {\n\n                        if (i & 0x40)\n\n                            i |= 0x780;\n\n                        else\n\n                            i |= 0x800;\n\n                        n |= i << 19;\n\n                        tcg_gen_movi_i32(cpu_F0s, n);\n\n                    }\n\n                    break;\n\n                case 15: /* extension space */\n\n                    switch (rn) {\n\n                    case 0: /* cpy */\n\n                        /* no-op */\n\n                        break;\n\n                    case 1: /* abs */\n\n                        gen_vfp_abs(dp);\n\n                        break;\n\n                    case 2: /* neg */\n\n                        gen_vfp_neg(dp);\n\n                        break;\n\n                    case 3: /* sqrt */\n\n                        gen_vfp_sqrt(dp);\n\n                        break;\n\n                    case 4: /* vcvtb.f32.f16 */\n\n                        tmp = gen_vfp_mrs();\n\n                        tcg_gen_ext16u_i32(tmp, tmp);\n\n                        gen_helper_vfp_fcvt_f16_to_f32(cpu_F0s, tmp, cpu_env);\n\n                        tcg_temp_free_i32(tmp);\n\n                        break;\n\n                    case 5: /* vcvtt.f32.f16 */\n\n                        tmp = gen_vfp_mrs();\n\n                        tcg_gen_shri_i32(tmp, tmp, 16);\n\n                        gen_helper_vfp_fcvt_f16_to_f32(cpu_F0s, tmp, cpu_env);\n\n                        tcg_temp_free_i32(tmp);\n\n                        break;\n\n                    case 6: /* vcvtb.f16.f32 */\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_helper_vfp_fcvt_f32_to_f16(tmp, cpu_F0s, cpu_env);\n\n                        gen_mov_F0_vreg(0, rd);\n\n                        tmp2 = gen_vfp_mrs();\n\n                        tcg_gen_andi_i32(tmp2, tmp2, 0xffff0000);\n\n                        tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        gen_vfp_msr(tmp);\n\n                        break;\n\n                    case 7: /* vcvtt.f16.f32 */\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_helper_vfp_fcvt_f32_to_f16(tmp, cpu_F0s, cpu_env);\n\n                        tcg_gen_shli_i32(tmp, tmp, 16);\n\n                        gen_mov_F0_vreg(0, rd);\n\n                        tmp2 = gen_vfp_mrs();\n\n                        tcg_gen_ext16u_i32(tmp2, tmp2);\n\n                        tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        gen_vfp_msr(tmp);\n\n                        break;\n\n                    case 8: /* cmp */\n\n                        gen_vfp_cmp(dp);\n\n                        break;\n\n                    case 9: /* cmpe */\n\n                        gen_vfp_cmpe(dp);\n\n                        break;\n\n                    case 10: /* cmpz */\n\n                        gen_vfp_cmp(dp);\n\n                        break;\n\n                    case 11: /* cmpez */\n\n                        gen_vfp_F1_ld0(dp);\n\n                        gen_vfp_cmpe(dp);\n\n                        break;\n\n                    case 15: /* single<->double conversion */\n\n                        if (dp)\n\n                            gen_helper_vfp_fcvtsd(cpu_F0s, cpu_F0d, cpu_env);\n\n                        else\n\n                            gen_helper_vfp_fcvtds(cpu_F0d, cpu_F0s, cpu_env);\n\n                        break;\n\n                    case 16: /* fuito */\n\n                        gen_vfp_uito(dp, 0);\n\n                        break;\n\n                    case 17: /* fsito */\n\n                        gen_vfp_sito(dp, 0);\n\n                        break;\n\n                    case 20: /* fshto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_shto(dp, 16 - rm, 0);\n\n                        break;\n\n                    case 21: /* fslto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_slto(dp, 32 - rm, 0);\n\n                        break;\n\n                    case 22: /* fuhto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_uhto(dp, 16 - rm, 0);\n\n                        break;\n\n                    case 23: /* fulto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_ulto(dp, 32 - rm, 0);\n\n                        break;\n\n                    case 24: /* ftoui */\n\n                        gen_vfp_toui(dp, 0);\n\n                        break;\n\n                    case 25: /* ftouiz */\n\n                        gen_vfp_touiz(dp, 0);\n\n                        break;\n\n                    case 26: /* ftosi */\n\n                        gen_vfp_tosi(dp, 0);\n\n                        break;\n\n                    case 27: /* ftosiz */\n\n                        gen_vfp_tosiz(dp, 0);\n\n                        break;\n\n                    case 28: /* ftosh */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_tosh(dp, 16 - rm, 0);\n\n                        break;\n\n                    case 29: /* ftosl */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_tosl(dp, 32 - rm, 0);\n\n                        break;\n\n                    case 30: /* ftouh */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_touh(dp, 16 - rm, 0);\n\n                        break;\n\n                    case 31: /* ftoul */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_toul(dp, 32 - rm, 0);\n\n                        break;\n\n                    default: /* undefined */\n\n                        return 1;\n\n                    }\n\n                    break;\n\n                default: /* undefined */\n\n                    return 1;\n\n                }\n\n\n\n                /* Write back the result.  */\n\n                if (op == 15 && (rn >= 8 && rn <= 11))\n\n                    ; /* Comparison, do nothing.  */\n\n                else if (op == 15 && dp && ((rn & 0x1c) == 0x18))\n\n                    /* VCVT double to int: always integer result. */\n\n                    gen_mov_vreg_F0(0, rd);\n\n                else if (op == 15 && rn == 15)\n\n                    /* conversion */\n\n                    gen_mov_vreg_F0(!dp, rd);\n\n                else\n\n                    gen_mov_vreg_F0(dp, rd);\n\n\n\n                /* break out of the loop if we have finished  */\n\n                if (veclen == 0)\n\n                    break;\n\n\n\n                if (op == 15 && delta_m == 0) {\n\n                    /* single source one-many */\n\n                    while (veclen--) {\n\n                        rd = ((rd + delta_d) & (bank_mask - 1))\n\n                             | (rd & bank_mask);\n\n                        gen_mov_vreg_F0(dp, rd);\n\n                    }\n\n                    break;\n\n                }\n\n                /* Setup the next operands.  */\n\n                veclen--;\n\n                rd = ((rd + delta_d) & (bank_mask - 1))\n\n                     | (rd & bank_mask);\n\n\n\n                if (op == 15) {\n\n                    /* One source operand.  */\n\n                    rm = ((rm + delta_m) & (bank_mask - 1))\n\n                         | (rm & bank_mask);\n\n                    gen_mov_F0_vreg(dp, rm);\n\n                } else {\n\n                    /* Two source operands.  */\n\n                    rn = ((rn + delta_d) & (bank_mask - 1))\n\n                         | (rn & bank_mask);\n\n                    gen_mov_F0_vreg(dp, rn);\n\n                    if (delta_m) {\n\n                        rm = ((rm + delta_m) & (bank_mask - 1))\n\n                             | (rm & bank_mask);\n\n                        gen_mov_F1_vreg(dp, rm);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 0xc:\n\n    case 0xd:\n\n        if ((insn & 0x03e00000) == 0x00400000) {\n\n            /* two-register transfer */\n\n            rn = (insn >> 16) & 0xf;\n\n            rd = (insn >> 12) & 0xf;\n\n            if (dp) {\n\n                VFP_DREG_M(rm, insn);\n\n            } else {\n\n                rm = VFP_SREG_M(insn);\n\n            }\n\n\n\n            if (insn & ARM_CP_RW_BIT) {\n\n                /* vfp->arm */\n\n                if (dp) {\n\n                    gen_mov_F0_vreg(0, rm * 2);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rd, tmp);\n\n                    gen_mov_F0_vreg(0, rm * 2 + 1);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rn, tmp);\n\n                } else {\n\n                    gen_mov_F0_vreg(0, rm);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rd, tmp);\n\n                    gen_mov_F0_vreg(0, rm + 1);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rn, tmp);\n\n                }\n\n            } else {\n\n                /* arm->vfp */\n\n                if (dp) {\n\n                    tmp = load_reg(s, rd);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm * 2);\n\n                    tmp = load_reg(s, rn);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm * 2 + 1);\n\n                } else {\n\n                    tmp = load_reg(s, rd);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm);\n\n                    tmp = load_reg(s, rn);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm + 1);\n\n                }\n\n            }\n\n        } else {\n\n            /* Load/store */\n\n            rn = (insn >> 16) & 0xf;\n\n            if (dp)\n\n                VFP_DREG_D(rd, insn);\n\n            else\n\n                rd = VFP_SREG_D(insn);\n\n            if ((insn & 0x01200000) == 0x01000000) {\n\n                /* Single load/store */\n\n                offset = (insn & 0xff) << 2;\n\n                if ((insn & (1 << 23)) == 0)\n\n                    offset = -offset;\n\n                if (s->thumb && rn == 15) {\n\n                    /* This is actually UNPREDICTABLE */\n\n                    addr = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(addr, s->pc & ~2);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                tcg_gen_addi_i32(addr, addr, offset);\n\n                if (insn & (1 << 20)) {\n\n                    gen_vfp_ld(s, dp, addr);\n\n                    gen_mov_vreg_F0(dp, rd);\n\n                } else {\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_st(s, dp, addr);\n\n                }\n\n                tcg_temp_free_i32(addr);\n\n            } else {\n\n                /* load/store multiple */\n\n                int w = insn & (1 << 21);\n\n                if (dp)\n\n                    n = (insn >> 1) & 0x7f;\n\n                else\n\n                    n = insn & 0xff;\n\n\n\n                if (w && !(((insn >> 23) ^ (insn >> 24)) & 1)) {\n\n                    /* P == U , W == 1  => UNDEF */\n\n                    return 1;\n\n                }\n\n                if (n == 0 || (rd + n) > 32 || (dp && n > 16)) {\n\n                    /* UNPREDICTABLE cases for bad immediates: we choose to\n\n                     * UNDEF to avoid generating huge numbers of TCG ops\n\n                     */\n\n                    return 1;\n\n                }\n\n                if (rn == 15 && w) {\n\n                    /* writeback to PC is UNPREDICTABLE, we choose to UNDEF */\n\n                    return 1;\n\n                }\n\n\n\n                if (s->thumb && rn == 15) {\n\n                    /* This is actually UNPREDICTABLE */\n\n                    addr = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(addr, s->pc & ~2);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                if (insn & (1 << 24)) /* pre-decrement */\n\n                    tcg_gen_addi_i32(addr, addr, -((insn & 0xff) << 2));\n\n\n\n                if (dp)\n\n                    offset = 8;\n\n                else\n\n                    offset = 4;\n\n                for (i = 0; i < n; i++) {\n\n                    if (insn & ARM_CP_RW_BIT) {\n\n                        /* load */\n\n                        gen_vfp_ld(s, dp, addr);\n\n                        gen_mov_vreg_F0(dp, rd + i);\n\n                    } else {\n\n                        /* store */\n\n                        gen_mov_F0_vreg(dp, rd + i);\n\n                        gen_vfp_st(s, dp, addr);\n\n                    }\n\n                    tcg_gen_addi_i32(addr, addr, offset);\n\n                }\n\n                if (w) {\n\n                    /* writeback */\n\n                    if (insn & (1 << 24))\n\n                        offset = -offset * n;\n\n                    else if (dp && (insn & 1))\n\n                        offset = 4;\n\n                    else\n\n                        offset = 0;\n\n\n\n                    if (offset != 0)\n\n                        tcg_gen_addi_i32(addr, addr, offset);\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    tcg_temp_free_i32(addr);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen.  */\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4285}
{"project": "qemu", "commit_id": "b923ab3112ed5ab47c2ff35776f17ab54c60d651", "target": 1, "func": "static void quiesce_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SCLPEventClass *k = SCLP_EVENT_CLASS(klass);\n\n\n\n    dc->reset = quiesce_reset;\n\n    dc->vmsd = &vmstate_sclpquiesce;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    k->init = quiesce_init;\n\n\n\n    k->get_send_mask = send_mask;\n\n    k->get_receive_mask = receive_mask;\n\n    k->can_handle_event = can_handle_event;\n\n    k->read_event_data = read_event_data;\n\n    k->write_event_data = NULL;\n\n}\n", "idx": 9412}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void palmte_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    struct omap_mpu_state_s *mpu;\n\n    int flash_size = 0x00800000;\n\n    int sdram_size = palmte_binfo.ram_size;\n\n    static uint32_t cs0val = 0xffffffff;\n\n    static uint32_t cs1val = 0x0000e1a0;\n\n    static uint32_t cs2val = 0x0000e1a0;\n\n    static uint32_t cs3val = 0xe1a0e1a0;\n\n    int rom_size, rom_loaded = 0;\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *cs = g_new(MemoryRegion, 4);\n\n\n\n    mpu = omap310_mpu_init(address_space_mem, sdram_size, cpu_model);\n\n\n\n    /* External Flash (EMIFS) */\n\n    memory_region_init_ram(flash, NULL, \"palmte.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS0_BASE, flash);\n\n\n\n    memory_region_init_io(&cs[0], NULL, &static_ops, &cs0val, \"palmte-cs0\",\n\n                          OMAP_CS0_SIZE - flash_size);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS0_BASE + flash_size,\n\n                                &cs[0]);\n\n    memory_region_init_io(&cs[1], NULL, &static_ops, &cs1val, \"palmte-cs1\",\n\n                          OMAP_CS1_SIZE);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS1_BASE, &cs[1]);\n\n    memory_region_init_io(&cs[2], NULL, &static_ops, &cs2val, \"palmte-cs2\",\n\n                          OMAP_CS2_SIZE);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS2_BASE, &cs[2]);\n\n    memory_region_init_io(&cs[3], NULL, &static_ops, &cs3val, \"palmte-cs3\",\n\n                          OMAP_CS3_SIZE);\n\n    memory_region_add_subregion(address_space_mem, OMAP_CS3_BASE, &cs[3]);\n\n\n\n    palmte_microwire_setup(mpu);\n\n\n\n    qemu_add_kbd_event_handler(palmte_button_event, mpu);\n\n\n\n    palmte_gpio_setup(mpu);\n\n\n\n    /* Setup initial (reset) machine state */\n\n    if (nb_option_roms) {\n\n        rom_size = get_image_size(option_rom[0].name);\n\n        if (rom_size > flash_size) {\n\n            fprintf(stderr, \"%s: ROM image too big (%x > %x)\\n\",\n\n                            __FUNCTION__, rom_size, flash_size);\n\n            rom_size = 0;\n\n        }\n\n        if (rom_size > 0) {\n\n            rom_size = load_image_targphys(option_rom[0].name, OMAP_CS0_BASE,\n\n                                           flash_size);\n\n            rom_loaded = 1;\n\n        }\n\n        if (rom_size < 0) {\n\n            fprintf(stderr, \"%s: error loading '%s'\\n\",\n\n                            __FUNCTION__, option_rom[0].name);\n\n        }\n\n    }\n\n\n\n    if (!rom_loaded && !kernel_filename && !qtest_enabled()) {\n\n        fprintf(stderr, \"Kernel or ROM image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Load the kernel.  */\n\n    palmte_binfo.kernel_filename = kernel_filename;\n\n    palmte_binfo.kernel_cmdline = kernel_cmdline;\n\n    palmte_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(mpu->cpu, &palmte_binfo);\n\n}\n", "idx": 1498}
{"project": "qemu", "commit_id": "2a633c461e96cb9a856292c46917653bd43959c8", "target": 1, "func": "static int virtio_scsi_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSCSI *s = opaque;\n\n    virtio_load(&s->vdev, f);\n\n    return 0;\n\n}\n", "idx": 3922}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_accept(RDMAContext *rdma)\n\n{\n\n    RDMACapabilities cap;\n\n    struct rdma_conn_param conn_param = {\n\n                                            .responder_resources = 2,\n\n                                            .private_data = &cap,\n\n                                            .private_data_len = sizeof(cap),\n\n                                         };\n\n    struct rdma_cm_event *cm_event;\n\n    struct ibv_context *verbs;\n\n    int ret = -EINVAL;\n\n    int idx;\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_CONNECT_REQUEST) {\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));\n\n\n\n    network_to_caps(&cap);\n\n\n\n    if (cap.version < 1 || cap.version > RDMA_CONTROL_VERSION_CURRENT) {\n\n            fprintf(stderr, \"Unknown source RDMA version: %d, bailing...\\n\",\n\n                            cap.version);\n\n            rdma_ack_cm_event(cm_event);\n\n            goto err_rdma_dest_wait;\n\n    }\n\n\n\n    /*\n\n     * Respond with only the capabilities this version of QEMU knows about.\n\n     */\n\n    cap.flags &= known_capabilities;\n\n\n\n    /*\n\n     * Enable the ones that we do know about.\n\n     * Add other checks here as new ones are introduced.\n\n     */\n\n    if (cap.flags & RDMA_CAPABILITY_PIN_ALL) {\n\n        rdma->pin_all = true;\n\n    }\n\n\n\n    rdma->cm_id = cm_event->id;\n\n    verbs = cm_event->id->verbs;\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n\n\n    DPRINTF(\"Memory pin all: %s\\n\", rdma->pin_all ? \"enabled\" : \"disabled\");\n\n\n\n    caps_to_network(&cap);\n\n\n\n    DPRINTF(\"verbs context after listen: %p\\n\", verbs);\n\n\n\n    if (!rdma->verbs) {\n\n        rdma->verbs = verbs;\n\n    } else if (rdma->verbs != verbs) {\n\n            fprintf(stderr, \"ibv context not matching %p, %p!\\n\",\n\n                    rdma->verbs, verbs);\n\n            goto err_rdma_dest_wait;\n\n    }\n\n\n\n    qemu_rdma_dump_id(\"dest_init\", verbs);\n\n\n\n    ret = qemu_rdma_alloc_pd_cq(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error allocating pd and cq!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = qemu_rdma_alloc_qp(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error allocating qp!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = qemu_rdma_init_ram_blocks(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error initializing ram blocks!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        ret = qemu_rdma_reg_control(rdma, idx);\n\n        if (ret) {\n\n            fprintf(stderr, \"rdma: error registering %d control!\\n\", idx);\n\n            goto err_rdma_dest_wait;\n\n        }\n\n    }\n\n\n\n    qemu_set_fd_handler2(rdma->channel->fd, NULL, NULL, NULL, NULL);\n\n\n\n    ret = rdma_accept(rdma->cm_id, &conn_param);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma_accept returns %d!\\n\", ret);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma_accept get_cm_event failed %d!\\n\", ret);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {\n\n        fprintf(stderr, \"rdma_accept not event established!\\n\");\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n    rdma->connected = true;\n\n\n\n    ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_READY);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error posting second control recv!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    qemu_rdma_dump_gid(\"dest_connect\", rdma->cm_id);\n\n\n\n    return 0;\n\n\n\nerr_rdma_dest_wait:\n\n    rdma->error_state = ret;\n\n    qemu_rdma_cleanup(rdma);\n\n    return ret;\n\n}\n", "idx": 10529}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "static void __attribute__((constructor)) st_init(void)\n\n{\n\n    atexit(st_flush_trace_buffer);\n\n}\n", "idx": 5154}
{"project": "qemu", "commit_id": "6d56fc6cc372284a4571f09b361a9ccd99318103", "target": 1, "func": "static int decode_gusa(DisasContext *ctx, CPUSH4State *env, int *pmax_insns)\n\n{\n\n    uint16_t insns[5];\n\n    int ld_adr, ld_dst, ld_mop;\n\n    int op_dst, op_src, op_opc;\n\n    int mv_src, mt_dst, st_src, st_mop;\n\n    TCGv op_arg;\n\n\n\n    uint32_t pc = ctx->pc;\n\n    uint32_t pc_end = ctx->tb->cs_base;\n\n    int backup = sextract32(ctx->tbflags, GUSA_SHIFT, 8);\n\n    int max_insns = (pc_end - pc) / 2;\n\n    int i;\n\n\n\n    if (pc != pc_end + backup || max_insns < 2) {\n\n        /* This is a malformed gUSA region.  Don't do anything special,\n\n           since the interpreter is likely to get confused.  */\n\n        ctx->envflags &= ~GUSA_MASK;\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->tbflags & GUSA_EXCLUSIVE) {\n\n        /* Regardless of single-stepping or the end of the page,\n\n           we must complete execution of the gUSA region while\n\n           holding the exclusive lock.  */\n\n        *pmax_insns = max_insns;\n\n        return 0;\n\n    }\n\n\n\n    /* The state machine below will consume only a few insns.\n\n       If there are more than that in a region, fail now.  */\n\n    if (max_insns > ARRAY_SIZE(insns)) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read all of the insns for the region.  */\n\n    for (i = 0; i < max_insns; ++i) {\n\n        insns[i] = cpu_lduw_code(env, pc + i * 2);\n\n    }\n\n\n\n    ld_adr = ld_dst = ld_mop = -1;\n\n    mv_src = -1;\n\n    op_dst = op_src = op_opc = -1;\n\n    mt_dst = -1;\n\n    st_src = st_mop = -1;\n\n    TCGV_UNUSED(op_arg);\n\n    i = 0;\n\n\n\n#define NEXT_INSN \\\n\n    do { if (i >= max_insns) goto fail; ctx->opcode = insns[i++]; } while (0)\n\n\n\n    /*\n\n     * Expect a load to begin the region.\n\n     */\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6000: /* mov.b @Rm,Rn */\n\n        ld_mop = MO_SB;\n\n        break;\n\n    case 0x6001: /* mov.w @Rm,Rn */\n\n        ld_mop = MO_TESW;\n\n        break;\n\n    case 0x6002: /* mov.l @Rm,Rn */\n\n        ld_mop = MO_TESL;\n\n        break;\n\n    default:\n\n        goto fail;\n\n    }\n\n    ld_adr = B7_4;\n\n    ld_dst = B11_8;\n\n    if (ld_adr == ld_dst) {\n\n        goto fail;\n\n    }\n\n    /* Unless we see a mov, any two-operand operation must use ld_dst.  */\n\n    op_dst = ld_dst;\n\n\n\n    /*\n\n     * Expect an optional register move.\n\n     */\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003: /* mov Rm,Rn */\n\n        /* Here we want to recognize ld_dst being saved for later consumtion,\n\n           or for another input register being copied so that ld_dst need not\n\n           be clobbered during the operation.  */\n\n        op_dst = B11_8;\n\n        mv_src = B7_4;\n\n        if (op_dst == ld_dst) {\n\n            /* Overwriting the load output.  */\n\n            goto fail;\n\n        }\n\n        if (mv_src != ld_dst) {\n\n            /* Copying a new input; constrain op_src to match the load.  */\n\n            op_src = ld_dst;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* Put back and re-examine as operation.  */\n\n        --i;\n\n    }\n\n\n\n    /*\n\n     * Expect the operation.\n\n     */\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x300c: /* add Rm,Rn */\n\n        op_opc = INDEX_op_add_i32;\n\n        goto do_reg_op;\n\n    case 0x2009: /* and Rm,Rn */\n\n        op_opc = INDEX_op_and_i32;\n\n        goto do_reg_op;\n\n    case 0x200a: /* xor Rm,Rn */\n\n        op_opc = INDEX_op_xor_i32;\n\n        goto do_reg_op;\n\n    case 0x200b: /* or Rm,Rn */\n\n        op_opc = INDEX_op_or_i32;\n\n    do_reg_op:\n\n        /* The operation register should be as expected, and the\n\n           other input cannot depend on the load.  */\n\n        if (op_dst != B11_8) {\n\n            goto fail;\n\n        }\n\n        if (op_src < 0) {\n\n            /* Unconstrainted input.  */\n\n            op_src = B7_4;\n\n        } else if (op_src == B7_4) {\n\n            /* Constrained input matched load.  All operations are\n\n               commutative; \"swap\" them by \"moving\" the load output\n\n               to the (implicit) first argument and the move source\n\n               to the (explicit) second argument.  */\n\n            op_src = mv_src;\n\n        } else {\n\n            goto fail;\n\n        }\n\n        op_arg = REG(op_src);\n\n        break;\n\n\n\n    case 0x6007: /* not Rm,Rn */\n\n        if (ld_dst != B7_4 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_dst = B11_8;\n\n        op_opc = INDEX_op_xor_i32;\n\n        op_arg = tcg_const_i32(-1);\n\n        break;\n\n\n\n    case 0x7000 ... 0x700f: /* add #imm,Rn */\n\n        if (op_dst != B11_8 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_opc = INDEX_op_add_i32;\n\n        op_arg = tcg_const_i32(B7_0s);\n\n        break;\n\n\n\n    case 0x3000: /* cmp/eq Rm,Rn */\n\n        /* Looking for the middle of a compare-and-swap sequence,\n\n           beginning with the compare.  Operands can be either order,\n\n           but with only one overlapping the load.  */\n\n        if ((ld_dst == B11_8) + (ld_dst == B7_4) != 1 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_opc = INDEX_op_setcond_i32;  /* placeholder */\n\n        op_src = (ld_dst == B11_8 ? B7_4 : B11_8);\n\n        op_arg = REG(op_src);\n\n\n\n        NEXT_INSN;\n\n        switch (ctx->opcode & 0xff00) {\n\n        case 0x8b00: /* bf label */\n\n        case 0x8f00: /* bf/s label */\n\n            if (pc + (i + 1 + B7_0s) * 2 != pc_end) {\n\n                goto fail;\n\n            }\n\n            if ((ctx->opcode & 0xff00) == 0x8b00) { /* bf label */\n\n                break;\n\n            }\n\n            /* We're looking to unconditionally modify Rn with the\n\n               result of the comparison, within the delay slot of\n\n               the branch.  This is used by older gcc.  */\n\n            NEXT_INSN;\n\n            if ((ctx->opcode & 0xf0ff) == 0x0029) { /* movt Rn */\n\n                mt_dst = B11_8;\n\n            } else {\n\n                goto fail;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case 0x2008: /* tst Rm,Rn */\n\n        /* Looking for a compare-and-swap against zero.  */\n\n        if (ld_dst != B11_8 || ld_dst != B7_4 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_opc = INDEX_op_setcond_i32;\n\n        op_arg = tcg_const_i32(0);\n\n\n\n        NEXT_INSN;\n\n        if ((ctx->opcode & 0xff00) != 0x8900 /* bt label */\n\n            || pc + (i + 1 + B7_0s) * 2 != pc_end) {\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* Put back and re-examine as store.  */\n\n        --i;\n\n    }\n\n\n\n    /*\n\n     * Expect the store.\n\n     */\n\n    /* The store must be the last insn.  */\n\n    if (i != max_insns - 1) {\n\n        goto fail;\n\n    }\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x2000: /* mov.b Rm,@Rn */\n\n        st_mop = MO_UB;\n\n        break;\n\n    case 0x2001: /* mov.w Rm,@Rn */\n\n        st_mop = MO_UW;\n\n        break;\n\n    case 0x2002: /* mov.l Rm,@Rn */\n\n        st_mop = MO_UL;\n\n        break;\n\n    default:\n\n        goto fail;\n\n    }\n\n    /* The store must match the load.  */\n\n    if (ld_adr != B11_8 || st_mop != (ld_mop & MO_SIZE)) {\n\n        goto fail;\n\n    }\n\n    st_src = B7_4;\n\n\n\n#undef NEXT_INSN\n\n\n\n    /*\n\n     * Emit the operation.\n\n     */\n\n    tcg_gen_insn_start(pc, ctx->envflags);\n\n    switch (op_opc) {\n\n    case -1:\n\n        /* No operation found.  Look for exchange pattern.  */\n\n        if (st_src == ld_dst || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        tcg_gen_atomic_xchg_i32(REG(ld_dst), REG(ld_adr), REG(st_src),\n\n                                ctx->memidx, ld_mop);\n\n        break;\n\n\n\n    case INDEX_op_add_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst && st_mop == MO_UL) {\n\n            tcg_gen_atomic_add_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_add_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n            if (op_dst != ld_dst) {\n\n                /* Note that mop sizes < 4 cannot use add_fetch\n\n                   because it won't carry into the higher bits.  */\n\n                tcg_gen_add_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_and_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst) {\n\n            tcg_gen_atomic_and_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_and_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n            tcg_gen_and_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_or_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst) {\n\n            tcg_gen_atomic_or_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                        op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_or_i32(REG(ld_dst), REG(ld_adr),\n\n                                        op_arg, ctx->memidx, ld_mop);\n\n            tcg_gen_or_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_xor_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst) {\n\n            tcg_gen_atomic_xor_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_xor_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n            tcg_gen_xor_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_setcond_i32:\n\n        if (st_src == ld_dst) {\n\n            goto fail;\n\n        }\n\n        tcg_gen_atomic_cmpxchg_i32(REG(ld_dst), REG(ld_adr), op_arg,\n\n                                   REG(st_src), ctx->memidx, ld_mop);\n\n        tcg_gen_setcond_i32(TCG_COND_EQ, cpu_sr_t, REG(ld_dst), op_arg);\n\n        if (mt_dst >= 0) {\n\n            tcg_gen_mov_i32(REG(mt_dst), cpu_sr_t);\n\n        }\n\n        break;\n\n\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* If op_src is not a valid register, then op_arg was a constant.  */\n\n    if (op_src < 0) {\n\n        tcg_temp_free_i32(op_arg);\n\n    }\n\n\n\n    /* The entire region has been translated.  */\n\n    ctx->envflags &= ~GUSA_MASK;\n\n    ctx->pc = pc_end;\n\n    return max_insns;\n\n\n\n fail:\n\n    qemu_log_mask(LOG_UNIMP, \"Unrecognized gUSA sequence %08x-%08x\\n\",\n\n                  pc, pc_end);\n\n\n\n    /* Restart with the EXCLUSIVE bit set, within a TB run via\n\n       cpu_exec_step_atomic holding the exclusive lock.  */\n\n    tcg_gen_insn_start(pc, ctx->envflags);\n\n    ctx->envflags |= GUSA_EXCLUSIVE;\n\n    gen_save_cpu_state(ctx, false);\n\n    gen_helper_exclusive(cpu_env);\n\n    ctx->bstate = BS_EXCP;\n\n\n\n    /* We're not executing an instruction, but we must report one for the\n\n       purposes of accounting within the TB.  We might as well report the\n\n       entire region consumed via ctx->pc so that it's immediately available\n\n       in the disassembly dump.  */\n\n    ctx->pc = pc_end;\n\n    return 1;\n\n}\n", "idx": 1091}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "target_phys_addr_t cpu_get_phys_page_debug (CPUState *env, target_ulong addr)\n\n{\n\n    mmu_ctx_t ctx;\n\n\n\n    if (unlikely(get_physical_address(env, &ctx, addr, 0, ACCESS_INT, 1) != 0))\n\n        return -1;\n\n\n\n    return ctx.raddr & TARGET_PAGE_MASK;\n\n}\n", "idx": 1742}
{"project": "qemu", "commit_id": "b165b0d8e62bb65a02d7670d75ebb77a9280bde1", "target": 1, "func": "static uint64_t serial_ioport_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n    SerialState *s = opaque;\n\n    uint32_t ret;\n\n\n\n    addr &= 7;\n\n    switch(addr) {\n\n    default:\n\n    case 0:\n\n        if (s->lcr & UART_LCR_DLAB) {\n\n            ret = s->divider & 0xff;\n\n        } else {\n\n            if(s->fcr & UART_FCR_FE) {\n\n                ret = fifo8_is_full(&s->recv_fifo) ?\n\n                            0 : fifo8_pop(&s->recv_fifo);\n\n                if (s->recv_fifo.num == 0) {\n\n                    s->lsr &= ~(UART_LSR_DR | UART_LSR_BI);\n\n                } else {\n\n                    qemu_mod_timer(s->fifo_timeout_timer, qemu_get_clock_ns (vm_clock) + s->char_transmit_time * 4);\n\n                }\n\n                s->timeout_ipending = 0;\n\n            } else {\n\n                ret = s->rbr;\n\n                s->lsr &= ~(UART_LSR_DR | UART_LSR_BI);\n\n            }\n\n            serial_update_irq(s);\n\n            if (!(s->mcr & UART_MCR_LOOP)) {\n\n                /* in loopback mode, don't receive any data */\n\n                qemu_chr_accept_input(s->chr);\n\n            }\n\n        }\n\n        break;\n\n    case 1:\n\n        if (s->lcr & UART_LCR_DLAB) {\n\n            ret = (s->divider >> 8) & 0xff;\n\n        } else {\n\n            ret = s->ier;\n\n        }\n\n        break;\n\n    case 2:\n\n        ret = s->iir;\n\n        if ((ret & UART_IIR_ID) == UART_IIR_THRI) {\n\n            s->thr_ipending = 0;\n\n            serial_update_irq(s);\n\n        }\n\n        break;\n\n    case 3:\n\n        ret = s->lcr;\n\n        break;\n\n    case 4:\n\n        ret = s->mcr;\n\n        break;\n\n    case 5:\n\n        ret = s->lsr;\n\n        /* Clear break and overrun interrupts */\n\n        if (s->lsr & (UART_LSR_BI|UART_LSR_OE)) {\n\n            s->lsr &= ~(UART_LSR_BI|UART_LSR_OE);\n\n            serial_update_irq(s);\n\n        }\n\n        break;\n\n    case 6:\n\n        if (s->mcr & UART_MCR_LOOP) {\n\n            /* in loopback, the modem output pins are connected to the\n\n               inputs */\n\n            ret = (s->mcr & 0x0c) << 4;\n\n            ret |= (s->mcr & 0x02) << 3;\n\n            ret |= (s->mcr & 0x01) << 5;\n\n        } else {\n\n            if (s->poll_msl >= 0)\n\n                serial_update_msl(s);\n\n            ret = s->msr;\n\n            /* Clear delta bits & msr int after read, if they were set */\n\n            if (s->msr & UART_MSR_ANY_DELTA) {\n\n                s->msr &= 0xF0;\n\n                serial_update_irq(s);\n\n            }\n\n        }\n\n        break;\n\n    case 7:\n\n        ret = s->scr;\n\n        break;\n\n    }\n\n    DPRINTF(\"read addr=0x%\" HWADDR_PRIx \" val=0x%02x\\n\", addr, ret);\n\n    return ret;\n\n}\n", "idx": 1347}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "static int qcow2_cache_entry_flush(BlockDriverState *bs, Qcow2Cache *c, int i)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret = 0;\n\n\n\n    if (!c->entries[i].dirty || !c->entries[i].offset) {\n\n        return 0;\n\n    }\n\n\n\n    trace_qcow2_cache_entry_flush(qemu_coroutine_self(),\n\n                                  c == s->l2_table_cache, i);\n\n\n\n    if (c->depends) {\n\n        ret = qcow2_cache_flush_dependency(bs, c);\n\n    } else if (c->depends_on_flush) {\n\n        ret = bdrv_flush(bs->file);\n\n        if (ret >= 0) {\n\n            c->depends_on_flush = false;\n\n        }\n\n    }\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (c == s->refcount_block_cache) {\n\n        ret = qcow2_pre_write_overlap_check(bs,\n\n                QCOW2_OL_DEFAULT & ~QCOW2_OL_REFCOUNT_BLOCK,\n\n                c->entries[i].offset, s->cluster_size);\n\n    } else if (c == s->l2_table_cache) {\n\n        ret = qcow2_pre_write_overlap_check(bs,\n\n                QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L2,\n\n                c->entries[i].offset, s->cluster_size);\n\n    } else {\n\n        ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_DEFAULT,\n\n                c->entries[i].offset, s->cluster_size);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (c == s->refcount_block_cache) {\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_UPDATE_PART);\n\n    } else if (c == s->l2_table_cache) {\n\n        BLKDBG_EVENT(bs->file, BLKDBG_L2_UPDATE);\n\n    }\n\n\n\n    ret = bdrv_pwrite(bs->file, c->entries[i].offset, c->entries[i].table,\n\n        s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    c->entries[i].dirty = false;\n\n\n\n    return 0;\n\n}\n", "idx": 2049}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static uint64_t qvirtio_pci_config_readq(QVirtioDevice *d, uint64_t off)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    uint64_t val;\n\n\n\n    val = qpci_io_readq(dev->pdev, CONFIG_BASE(dev) + off);\n\n    if (qvirtio_is_big_endian(d)) {\n\n        val = bswap64(val);\n\n    }\n\n\n\n    return val;\n\n}\n", "idx": 4682}
{"project": "qemu", "commit_id": "3e36aba757f76673007a80b3cd56a4062c2e3462", "target": 1, "func": "static int mp_user_setxattr(FsContext *ctx, const char *path, const char *name,\n\n                            void *value, size_t size, int flags)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n\n\n    if (strncmp(name, \"user.virtfs.\", 12) == 0) {\n\n        /*\n\n         * Don't allow fetch of user.virtfs namesapce\n\n         * in case of mapped security\n\n         */\n\n        errno = EACCES;\n\n        return -1;\n\n    }\n\n    buffer = rpath(ctx, path);\n\n    ret = lsetxattr(buffer, name, value, size, flags);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 9114}
{"project": "qemu", "commit_id": "f3cdcbaee16d32b52d5015a8b1e8ddf5a27f7089", "target": 1, "func": "QGuestAllocator *pc_alloc_init(void)\n{\n    PCAlloc *s = g_malloc0(sizeof(*s));\n    uint64_t ram_size;\n    QFWCFG *fw_cfg = pc_fw_cfg_init();\n    s->alloc.alloc = pc_alloc;\n    s->alloc.free = pc_free;\n    ram_size = qfw_cfg_get_u64(fw_cfg, FW_CFG_RAM_SIZE);\n    /* Start at 1MB */\n    s->start = 1 << 20;\n    /* Respect PCI hole */\n    s->end = MIN(ram_size, 0xE0000000);\n    return &s->alloc;\n}", "idx": 2314}
{"project": "qemu", "commit_id": "86d1bd70987cd11d85d01f52aa5824c63d910471", "target": 1, "func": "static int64_t allocate_clusters(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    uint32_t idx, to_allocate, i;\n\n    int64_t pos, space;\n\n\n\n    pos = block_status(s, sector_num, nb_sectors, pnum);\n\n    if (pos > 0) {\n\n        return pos;\n\n    }\n\n\n\n    idx = sector_num / s->tracks;\n\n    if (idx >= s->bat_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    to_allocate = DIV_ROUND_UP(sector_num + *pnum, s->tracks) - idx;\n\n    space = to_allocate * s->tracks;\n\n    if (s->data_end + space > bdrv_getlength(bs->file->bs) >> BDRV_SECTOR_BITS) {\n\n        int ret;\n\n        space += s->prealloc_size;\n\n        if (s->prealloc_mode == PRL_PREALLOC_MODE_FALLOCATE) {\n\n            ret = bdrv_pwrite_zeroes(bs->file,\n\n                                     s->data_end << BDRV_SECTOR_BITS,\n\n                                     space << BDRV_SECTOR_BITS, 0);\n\n        } else {\n\n            ret = bdrv_truncate(bs->file,\n\n                                (s->data_end + space) << BDRV_SECTOR_BITS);\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < to_allocate; i++) {\n\n        s->bat_bitmap[idx + i] = cpu_to_le32(s->data_end / s->off_multiplier);\n\n        s->data_end += s->tracks;\n\n        bitmap_set(s->bat_dirty_bmap,\n\n                   bat_entry_off(idx + i) / s->bat_dirty_block, 1);\n\n    }\n\n\n\n    return bat2sect(s, idx) + sector_num % s->tracks;\n\n}\n", "idx": 2445}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_close(struct CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        g_io_channel_unref(s->fd_in);\n\n    }\n\n    if (s->fd_out) {\n\n        g_io_channel_unref(s->fd_out);\n\n    }\n\n\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 12268}
{"project": "qemu", "commit_id": "5382a012e8ce7cf5ea612d291286be827574c181", "target": 1, "func": "void do_m68k_semihosting(CPUM68KState *env, int nr)\n\n{\n\n    uint32_t args;\n\n    void *p;\n\n    void *q;\n\n    uint32_t len;\n\n    uint32_t result;\n\n\n\n    args = env->dregs[1];\n\n    switch (nr) {\n\n    case HOSTED_EXIT:\n\n        gdb_exit(env, env->dregs[0]);\n\n        exit(env->dregs[0]);\n\n    case HOSTED_OPEN:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"open,%s,%x,%x\", ARG(0), (int)ARG(1),\n\n                           ARG(2), ARG(3));\n\n            return;\n\n        } else {\n\n            if (!(p = lock_user_string(ARG(0)))) {\n\n                /* FIXME - check error code? */\n\n                result = -1;\n\n            } else {\n\n                result = open(p, translate_openflags(ARG(2)), ARG(3));\n\n                unlock_user(p, ARG(0), 0);\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_CLOSE:\n\n        {\n\n            /* Ignore attempts to close stdin/out/err.  */\n\n            int fd = ARG(0);\n\n            if (fd > 2) {\n\n                if (use_gdb_syscalls()) {\n\n                    gdb_do_syscall(m68k_semi_cb, \"close,%x\", ARG(0));\n\n                    return;\n\n                } else {\n\n                    result = close(fd);\n\n                }\n\n            } else {\n\n                result = 0;\n\n            }\n\n            break;\n\n        }\n\n    case HOSTED_READ:\n\n        len = ARG(2);\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"read,%x,%x,%x\",\n\n                           ARG(0), ARG(1), len);\n\n            return;\n\n        } else {\n\n            if (!(p = lock_user(VERIFY_WRITE, ARG(1), len, 0))) {\n\n                /* FIXME - check error code? */\n\n                result = -1;\n\n            } else {\n\n                result = read(ARG(0), p, len);\n\n                unlock_user(p, ARG(1), len);\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_WRITE:\n\n        len = ARG(2);\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"write,%x,%x,%x\",\n\n                           ARG(0), ARG(1), len);\n\n            return;\n\n        } else {\n\n            if (!(p = lock_user(VERIFY_READ, ARG(1), len, 1))) {\n\n                /* FIXME - check error code? */\n\n                result = -1;\n\n            } else {\n\n                result = write(ARG(0), p, len);\n\n                unlock_user(p, ARG(0), 0);\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_LSEEK:\n\n        {\n\n            uint64_t off;\n\n            off = (uint32_t)ARG(2) | ((uint64_t)ARG(1) << 32);\n\n            if (use_gdb_syscalls()) {\n\n                m68k_semi_is_fseek = 1;\n\n                gdb_do_syscall(m68k_semi_cb, \"fseek,%x,%lx,%x\",\n\n                               ARG(0), off, ARG(3));\n\n            } else {\n\n                off = lseek(ARG(0), off, ARG(3));\n\n                /* FIXME - handle put_user() failure */\n\n                put_user_u32(off >> 32, args);\n\n                put_user_u32(off, args + 4);\n\n                put_user_u32(errno, args + 8);\n\n            }\n\n            return;\n\n        }\n\n    case HOSTED_RENAME:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"rename,%s,%s\",\n\n                           ARG(0), (int)ARG(1), ARG(2), (int)ARG(3));\n\n            return;\n\n        } else {\n\n            p = lock_user_string(ARG(0));\n\n            q = lock_user_string(ARG(2));\n\n            if (!p || !q) {\n\n                /* FIXME - check error code? */\n\n                result = -1;\n\n            } else {\n\n                result = rename(p, q);\n\n            }\n\n            unlock_user(p, ARG(0), 0);\n\n            unlock_user(q, ARG(2), 0);\n\n        }\n\n        break;\n\n    case HOSTED_UNLINK:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"unlink,%s\",\n\n                           ARG(0), (int)ARG(1));\n\n            return;\n\n        } else {\n\n            if (!(p = lock_user_string(ARG(0)))) {\n\n                /* FIXME - check error code? */\n\n                result = -1;\n\n            } else {\n\n                result = unlink(p);\n\n                unlock_user(p, ARG(0), 0);\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_STAT:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"stat,%s,%x\",\n\n                           ARG(0), (int)ARG(1), ARG(2));\n\n            return;\n\n        } else {\n\n            struct stat s;\n\n            if (!(p = lock_user_string(ARG(0)))) {\n\n                /* FIXME - check error code? */\n\n                result = -1;\n\n            } else {\n\n                result = stat(p, &s);\n\n                unlock_user(p, ARG(0), 0);\n\n            }\n\n            if (result == 0) {\n\n                translate_stat(env, ARG(2), &s);\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_FSTAT:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"fstat,%x,%x\",\n\n                           ARG(0), ARG(1));\n\n            return;\n\n        } else {\n\n            struct stat s;\n\n            result = fstat(ARG(0), &s);\n\n            if (result == 0) {\n\n                translate_stat(env, ARG(1), &s);\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_GETTIMEOFDAY:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"gettimeofday,%x,%x\",\n\n                           ARG(0), ARG(1));\n\n            return;\n\n        } else {\n\n            qemu_timeval tv;\n\n            struct gdb_timeval *p;\n\n            result = qemu_gettimeofday(&tv);\n\n            if (result != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE,\n\n                                    ARG(0), sizeof(struct gdb_timeval), 0))) {\n\n                    /* FIXME - check error code? */\n\n                    result = -1;\n\n                } else {\n\n                    p->tv_sec = cpu_to_be32(tv.tv_sec);\n\n                    p->tv_usec = cpu_to_be64(tv.tv_usec);\n\n                    unlock_user(p, ARG(0), sizeof(struct gdb_timeval));\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_ISATTY:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"isatty,%x\", ARG(0));\n\n            return;\n\n        } else {\n\n            result = isatty(ARG(0));\n\n        }\n\n        break;\n\n    case HOSTED_SYSTEM:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(m68k_semi_cb, \"system,%s\",\n\n                           ARG(0), (int)ARG(1));\n\n            return;\n\n        } else {\n\n            if (!(p = lock_user_string(ARG(0)))) {\n\n                /* FIXME - check error code? */\n\n                result = -1;\n\n            } else {\n\n                result = system(p);\n\n                unlock_user(p, ARG(0), 0);\n\n            }\n\n        }\n\n        break;\n\n    case HOSTED_INIT_SIM:\n\n#if defined(CONFIG_USER_ONLY)\n\n        {\n\n        TaskState *ts = env->opaque;\n\n        /* Allocate the heap using sbrk.  */\n\n        if (!ts->heap_limit) {\n\n            long ret;\n\n            uint32_t size;\n\n            uint32_t base;\n\n\n\n            base = do_brk(0);\n\n            size = SEMIHOSTING_HEAP_SIZE;\n\n            /* Try a big heap, and reduce the size if that fails.  */\n\n            for (;;) {\n\n                ret = do_brk(base + size);\n\n                if (ret != -1)\n\n                    break;\n\n                size >>= 1;\n\n            }\n\n            ts->heap_limit = base + size;\n\n        }\n\n        /* This call may happen before we have writable memory, so return\n\n           values directly in registers.  */\n\n        env->dregs[1] = ts->heap_limit;\n\n        env->aregs[7] = ts->stack_base;\n\n        }\n\n#else\n\n        /* FIXME: This is wrong for boards where RAM does not start at\n\n           address zero.  */\n\n        env->dregs[1] = ram_size;\n\n        env->aregs[7] = ram_size;\n\n#endif\n\n        return;\n\n    default:\n\n        cpu_abort(env, \"Unsupported semihosting syscall %d\\n\", nr);\n\n        result = 0;\n\n    }\n\n    /* FIXME - handle put_user() failure */\n\n    put_user_u32(result, args);\n\n    put_user_u32(errno, args + 4);\n\n}\n", "idx": 10199}
{"project": "qemu", "commit_id": "ef4760626e88bc3e7a1b46c7370378cbd12d379f", "target": 1, "func": "static uint8_t eepro100_read1(EEPRO100State * s, uint32_t addr)\n\n{\n\n    uint8_t val;\n\n    if (addr <= sizeof(s->mem) - sizeof(val)) {\n\n        memcpy(&val, &s->mem[addr], sizeof(val));\n\n    }\n\n\n\n    switch (addr) {\n\n    case SCBStatus:\n\n    case SCBAck:\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%02x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBCmd:\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%02x\\n\", regname(addr), val));\n\n#if 0\n\n        val = eepro100_read_command(s);\n\n#endif\n\n        break;\n\n    case SCBIntmask:\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%02x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBPort + 3:\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%02x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBeeprom:\n\n        val = eepro100_read_eeprom(s);\n\n        break;\n\n    case SCBpmdr:       /* Power Management Driver Register */\n\n        val = 0;\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%02x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBgstat:      /* General Status Register */\n\n        /* 100 Mbps full duplex, valid link */\n\n        val = 0x07;\n\n        TRACE(OTHER, logout(\"addr=General Status val=%02x\\n\", val));\n\n        break;\n\n    default:\n\n        logout(\"addr=%s val=0x%02x\\n\", regname(addr), val);\n\n        missing(\"unknown byte read\");\n\n    }\n\n    return val;\n\n}\n", "idx": 2127}
{"project": "qemu", "commit_id": "e907746266721f305d67bc0718795fedee2e824c", "target": 1, "func": "static uint32_t fdctrl_read_data(FDCtrl *fdctrl)\n\n{\n\n    FDrive *cur_drv;\n\n    uint32_t retval = 0;\n\n    int pos;\n\n\n\n    cur_drv = get_cur_drv(fdctrl);\n\n    fdctrl->dsr &= ~FD_DSR_PWRDOWN;\n\n    if (!(fdctrl->msr & FD_MSR_RQM) || !(fdctrl->msr & FD_MSR_DIO)) {\n\n        FLOPPY_DPRINTF(\"error: controller not ready for reading\\n\");\n\n        return 0;\n\n    }\n\n    pos = fdctrl->data_pos;\n\n    if (fdctrl->msr & FD_MSR_NONDMA) {\n\n        pos %= FD_SECTOR_LEN;\n\n        if (pos == 0) {\n\n            if (fdctrl->data_pos != 0)\n\n                if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {\n\n                    FLOPPY_DPRINTF(\"error seeking to next sector %d\\n\",\n\n                                   fd_sector(cur_drv));\n\n                    return 0;\n\n                }\n\n            if (blk_read(cur_drv->blk, fd_sector(cur_drv), fdctrl->fifo, 1)\n\n                < 0) {\n\n                FLOPPY_DPRINTF(\"error getting sector %d\\n\",\n\n                               fd_sector(cur_drv));\n\n                /* Sure, image size is too small... */\n\n                memset(fdctrl->fifo, 0, FD_SECTOR_LEN);\n\n            }\n\n        }\n\n    }\n\n    retval = fdctrl->fifo[pos];\n\n    if (++fdctrl->data_pos == fdctrl->data_len) {\n\n        fdctrl->data_pos = 0;\n\n        /* Switch from transfer mode to status mode\n\n         * then from status mode to command mode\n\n         */\n\n        if (fdctrl->msr & FD_MSR_NONDMA) {\n\n            fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);\n\n        } else {\n\n            fdctrl_reset_fifo(fdctrl);\n\n            fdctrl_reset_irq(fdctrl);\n\n        }\n\n    }\n\n    FLOPPY_DPRINTF(\"data register: 0x%02x\\n\", retval);\n\n\n\n    return retval;\n\n}\n", "idx": 5237}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void io_watch_poll_finalize(GSource *source)\n\n{\n\n    IOWatchPoll *iwp = io_watch_poll_from_source(source);\n\n    if (iwp->src) {\n\n        g_source_destroy(iwp->src);\n\n        g_source_unref(iwp->src);\n\n        iwp->src = NULL;\n\n    }\n\n}\n", "idx": 9888}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int vnc_auth_sasl_check_ssf(VncState *vs)\n\n{\n\n    const void *val;\n\n    int err, ssf;\n\n\n\n    if (!vs->sasl.wantSSF)\n\n        return 1;\n\n\n\n    err = sasl_getprop(vs->sasl.conn, SASL_SSF, &val);\n\n    if (err != SASL_OK)\n\n        return 0;\n\n\n\n    ssf = *(const int *)val;\n\n    VNC_DEBUG(\"negotiated an SSF of %d\\n\", ssf);\n\n    if (ssf < 56)\n\n        return 0; /* 56 is good for Kerberos */\n\n\n\n    /* Only setup for read initially, because we're about to send an RPC\n\n     * reply which must be in plain text. When the next incoming RPC\n\n     * arrives, we'll switch on writes too\n\n     *\n\n     * cf qemudClientReadSASL  in qemud.c\n\n     */\n\n    vs->sasl.runSSF = 1;\n\n\n\n    /* We have a SSF that's good enough */\n\n    return 1;\n\n}\n", "idx": 5055}
{"project": "qemu", "commit_id": "e9db8ff38e539260a2cb5a7918d1155b7d92a264", "target": 1, "func": "static struct glfs *qemu_gluster_glfs_init(BlockdevOptionsGluster *gconf,\n\n                                           Error **errp)\n\n{\n\n    struct glfs *glfs;\n\n    int ret;\n\n    int old_errno;\n\n    GlusterServerList *server;\n\n\n\n    glfs = glfs_new(gconf->volume);\n\n    if (!glfs) {\n\n        goto out;\n\n    }\n\n\n\n    for (server = gconf->server; server; server = server->next) {\n\n        if (server->value->type  == GLUSTER_TRANSPORT_UNIX) {\n\n            ret = glfs_set_volfile_server(glfs,\n\n                                   GlusterTransport_lookup[server->value->type],\n\n                                   server->value->u.q_unix.path, 0);\n\n        } else {\n\n            ret = glfs_set_volfile_server(glfs,\n\n                                   GlusterTransport_lookup[server->value->type],\n\n                                   server->value->u.tcp.host,\n\n                                   atoi(server->value->u.tcp.port));\n\n        }\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = glfs_set_logging(glfs, \"-\", gconf->debug_level);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = glfs_init(glfs);\n\n    if (ret) {\n\n        error_setg(errp, \"Gluster connection for volume %s, path %s failed\"\n\n                         \" to connect\", gconf->volume, gconf->path);\n\n        for (server = gconf->server; server; server = server->next) {\n\n            if (server->value->type  == GLUSTER_TRANSPORT_UNIX) {\n\n                error_append_hint(errp, \"hint: failed on socket %s \",\n\n                                  server->value->u.q_unix.path);\n\n            } else {\n\n                error_append_hint(errp, \"hint: failed on host %s and port %s \",\n\n                                  server->value->u.tcp.host,\n\n                                  server->value->u.tcp.port);\n\n            }\n\n        }\n\n\n\n        error_append_hint(errp, \"Please refer to gluster logs for more info\\n\");\n\n\n\n        /* glfs_init sometimes doesn't set errno although docs suggest that */\n\n        if (errno == 0) {\n\n            errno = EINVAL;\n\n        }\n\n\n\n        goto out;\n\n    }\n\n    return glfs;\n\n\n\nout:\n\n    if (glfs) {\n\n        old_errno = errno;\n\n        glfs_fini(glfs);\n\n        errno = old_errno;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 11969}
{"project": "qemu", "commit_id": "d3cdc49138c30be1d3c2f83d18f85d9fdee95f1a", "target": 1, "func": "static uint32_t get_cmd(ESPState *s, uint8_t *buf, uint8_t buflen)\n\n{\n\n    uint32_t dmalen;\n\n    int target;\n\n\n\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n\n    if (s->dma) {\n\n        dmalen = s->rregs[ESP_TCLO];\n\n        dmalen |= s->rregs[ESP_TCMID] << 8;\n\n        dmalen |= s->rregs[ESP_TCHI] << 16;\n\n        if (dmalen > buflen) {\n\n\n\n        s->dma_memory_read(s->dma_opaque, buf, dmalen);\n\n    } else {\n\n        dmalen = s->ti_size;\n\n\n\n\n        memcpy(buf, s->ti_buf, dmalen);\n\n        buf[0] = buf[2] >> 5;\n\n\n    trace_esp_get_cmd(dmalen, target);\n\n\n\n    s->ti_size = 0;\n\n    s->ti_rptr = 0;\n\n    s->ti_wptr = 0;\n\n\n\n    if (s->current_req) {\n\n        /* Started a new command before the old one finished.  Cancel it.  */\n\n        scsi_req_cancel(s->current_req);\n\n        s->async_len = 0;\n\n\n\n\n    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);\n\n    if (!s->current_dev) {\n\n        // No such drive\n\n        s->rregs[ESP_RSTAT] = 0;\n\n        s->rregs[ESP_RINTR] = INTR_DC;\n\n        s->rregs[ESP_RSEQ] = SEQ_0;\n\n        esp_raise_irq(s);\n\n\n\n    return dmalen;\n", "idx": 7763}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,\n\n                                   RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *l2_group;\n\n    RockerTlv **tlvs;\n\n    int err;\n\n    int i;\n\n\n\n    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n\n        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    group->l2_flood.group_count =\n\n        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n\n\n\n    tlvs = g_malloc0((group->l2_flood.group_count + 1) *\n\n                     sizeof(RockerTlv *));\n\n    if (!tlvs) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    g_free(group->l2_flood.group_ids);\n\n    group->l2_flood.group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n", "idx": 10042}
{"project": "qemu", "commit_id": "a8f2e5c8fffbaf7fbd4f0efc8efbeebade78008f", "target": 1, "func": "static int virtio_scsi_vring_init(VirtIOSCSI *s, VirtQueue *vq, int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        s->dataplane_fenced = true;\n\n        return rc;\n\n    }\n\n\n\n    virtio_queue_aio_set_host_notifier_handler(vq, s->ctx, true, true);\n\n    return 0;\n\n}\n", "idx": 970}
{"project": "qemu", "commit_id": "259342d34dbdfb304374f569feec26317edd97c9", "target": 1, "func": "static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=raw\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}", "idx": 6333}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int8_t *v = pv;\n\n    qemu_get_s8s(f, v);\n\n    return 0;\n\n}\n", "idx": 6018}
{"project": "qemu", "commit_id": "8f94a6e40e46cbc8e8014da825d25824b1803b34", "target": 1, "func": "int bdrv_file_open(BlockDriverState **pbs, const char *filename,\n\n                   QDict *options, int flags, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriver *drv;\n\n    const char *drvname;\n\n    bool allow_protocol_prefix = false;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    /* NULL means an empty set of options */\n\n    if (options == NULL) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    bs = bdrv_new(\"\");\n\n    bs->options = options;\n\n    options = qdict_clone_shallow(options);\n\n\n\n    /* Fetch the file name from the options QDict if necessary */\n\n    if (!filename) {\n\n        filename = qdict_get_try_str(options, \"filename\");\n\n    } else if (filename && !qdict_haskey(options, \"filename\")) {\n\n        qdict_put(options, \"filename\", qstring_from_str(filename));\n\n        allow_protocol_prefix = true;\n\n    } else {\n\n        error_setg(errp, \"Can't specify 'file' and 'filename' options at the \"\n\n                   \"same time\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* Find the right block driver */\n\n    drvname = qdict_get_try_str(options, \"driver\");\n\n    if (drvname) {\n\n        drv = bdrv_find_whitelisted_format(drvname, !(flags & BDRV_O_RDWR));\n\n        if (!drv) {\n\n            error_setg(errp, \"Unknown driver '%s'\", drvname);\n\n        }\n\n        qdict_del(options, \"driver\");\n\n    } else if (filename) {\n\n        drv = bdrv_find_protocol(filename, allow_protocol_prefix);\n\n        if (!drv) {\n\n            error_setg(errp, \"Unknown protocol\");\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Must specify either driver or file\");\n\n        drv = NULL;\n\n    }\n\n\n\n    if (!drv) {\n\n        /* errp has been set already */\n\n        ret = -ENOENT;\n\n        goto fail;\n\n    }\n\n\n\n    /* Parse the filename and open it */\n\n    if (drv->bdrv_parse_filename && filename) {\n\n        drv->bdrv_parse_filename(filename, options, &local_err);\n\n        if (error_is_set(&local_err)) {\n\n            error_propagate(errp, local_err);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        qdict_del(options, \"filename\");\n\n    } else if (drv->bdrv_needs_filename && !filename) {\n\n        error_setg(errp, \"The '%s' block driver requires a file name\",\n\n                   drv->format_name);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = bdrv_open_common(bs, NULL, options, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Check if any unknown options were used */\n\n    if (qdict_size(options) != 0) {\n\n        const QDictEntry *entry = qdict_first(options);\n\n        error_setg(errp, \"Block protocol '%s' doesn't support the option '%s'\",\n\n                   drv->format_name, entry->key);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    QDECREF(options);\n\n\n\n    bs->growable = 1;\n\n    *pbs = bs;\n\n    return 0;\n\n\n\nfail:\n\n    QDECREF(options);\n\n    if (!bs->drv) {\n\n        QDECREF(bs->options);\n\n    }\n\n    bdrv_unref(bs);\n\n    return ret;\n\n}\n", "idx": 3398}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_readlink(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    size_t offset = 7;\n\n    V9fsString target;\n\n    int32_t fid;\n\n    int err = 0;\n\n    V9fsFidState *fidp;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    v9fs_string_init(&target);\n\n    err = v9fs_co_readlink(pdu, &fidp->path, &target);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"s\", &target);\n\n    err = offset;\n\n    v9fs_string_free(&target);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_readlink_return(pdu->tag, pdu->id, target.data);\n\n    complete_pdu(pdu->s, pdu, err);\n\n}", "idx": 4120}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static ssize_t local_readlink(FsContext *fs_ctx, const char *path,\n\n        char *buf, size_t bufsz)\n\n{\n\n    ssize_t tsize = -1;\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        int fd;\n\n        fd = open(rpath(fs_ctx, path), O_RDONLY);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n        do {\n\n            tsize = read(fd, (void *)buf, bufsz);\n\n        } while (tsize == -1 && errno == EINTR);\n\n        close(fd);\n\n        return tsize;\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        tsize = readlink(rpath(fs_ctx, path), buf, bufsz);\n\n    }\n\n    return tsize;\n\n}\n", "idx": 12109}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 1908}
{"project": "qemu", "commit_id": "5f5a1318653c08e435cfa52f60b6a712815b659d", "target": 1, "func": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n\n{\n\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    uint8_t val;\n\n\n\n    k->get_config(vdev, vdev->config);\n\n\n\n    if (addr > (vdev->config_len - sizeof(val)))\n\n        return (uint32_t)-1;\n\n\n\n    val = ldub_p(vdev->config + addr);\n\n    return val;\n\n}\n", "idx": 8297}
{"project": "qemu", "commit_id": "7e09797c299712cafa7bc05dd57c1b13afcc6039", "target": 1, "func": "static void pmsav5_insn_ap_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                                 uint64_t value)\n\n{\n\n    env->cp15.c5_insn = extended_mpu_ap_bits(value);\n\n}\n", "idx": 9760}
{"project": "qemu", "commit_id": "c8a9fd80719e63615dac12e3625223fb54aa8430", "target": 1, "func": "static void bdrv_ioctl_bh_cb(void *opaque)\n\n{\n\n    BdrvIoctlCompletionData *data = opaque;\n\n\n\n    bdrv_co_io_em_complete(data->co, -ENOTSUP);\n\n    qemu_bh_delete(data->bh);\n\n}\n", "idx": 2955}
{"project": "qemu", "commit_id": "b36e391441906c36ed0856b69de84001860402bf", "target": 1, "func": "static int virtio_pci_start_ioeventfd(VirtIOPCIProxy *proxy)\n\n{\n\n    int n, r;\n\n\n\n    if (!(proxy->flags & VIRTIO_PCI_FLAG_USE_IOEVENTFD) ||\n\n        proxy->ioeventfd_disabled ||\n\n        proxy->ioeventfd_started) {\n\n        return 0;\n\n    }\n\n\n\n    for (n = 0; n < VIRTIO_PCI_QUEUE_MAX; n++) {\n\n        if (!virtio_queue_get_num(proxy->vdev, n)) {\n\n            continue;\n\n        }\n\n\n\n        r = virtio_pci_set_host_notifier_internal(proxy, n, true);\n\n        if (r < 0) {\n\n            goto assign_error;\n\n        }\n\n\n\n        virtio_pci_set_host_notifier_fd_handler(proxy, n, true);\n\n    }\n\n    proxy->ioeventfd_started = true;\n\n    return 0;\n\n\n\nassign_error:\n\n    while (--n >= 0) {\n\n        if (!virtio_queue_get_num(proxy->vdev, n)) {\n\n            continue;\n\n        }\n\n\n\n        virtio_pci_set_host_notifier_fd_handler(proxy, n, false);\n\n        virtio_pci_set_host_notifier_internal(proxy, n, false);\n\n    }\n\n    proxy->ioeventfd_started = false;\n\n    proxy->ioeventfd_disabled = true;\n\n    return r;\n\n}\n", "idx": 9884}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static void mux_chr_accept_input(CharDriverState *chr)\n\n{\n\n    int m = chr->focus;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    while (d->prod != d->cons &&\n\n           d->chr_can_read[m] &&\n\n           d->chr_can_read[m](d->ext_opaque[m])) {\n\n        d->chr_read[m](d->ext_opaque[m],\n\n                       &d->buffer[d->cons++ & MUX_BUFFER_MASK], 1);\n\n    }\n\n}\n", "idx": 9058}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                          int64_t count, Error **errp)\n{\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    FILE *fh;\n    size_t read_count;\n    if (!gfh) {\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n    fh = gfh->fh;\n    buf = g_malloc0(count+1);\n    read_count = fread(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to read file\");\n        slog(\"guest-file-read failed, handle: %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = read_count;\n        read_data->eof = feof(fh);\n        if (read_count) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        gfh->state = RW_STATE_READING;\n    g_free(buf);\n    clearerr(fh);\n    return read_data;", "idx": 10353}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "void helper_ldqf(CPUSPARCState *env, target_ulong addr, int mem_idx)\n\n{\n\n    /* XXX add 128 bit load */\n\n    CPU_QuadU u;\n\n\n\n    helper_check_align(env, addr, 7);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    switch (mem_idx) {\n\n    case MMU_USER_IDX:\n\n        u.ll.upper = cpu_ldq_user(env, addr);\n\n        u.ll.lower = cpu_ldq_user(env, addr + 8);\n\n        QT0 = u.q;\n\n        break;\n\n    case MMU_KERNEL_IDX:\n\n        u.ll.upper = cpu_ldq_kernel(env, addr);\n\n        u.ll.lower = cpu_ldq_kernel(env, addr + 8);\n\n        QT0 = u.q;\n\n        break;\n\n#ifdef TARGET_SPARC64\n\n    case MMU_HYPV_IDX:\n\n        u.ll.upper = cpu_ldq_hypv(env, addr);\n\n        u.ll.lower = cpu_ldq_hypv(env, addr + 8);\n\n        QT0 = u.q;\n\n        break;\n\n#endif\n\n    default:\n\n        DPRINTF_MMU(\"helper_ldqf: need to check MMU idx %d\\n\", mem_idx);\n\n        break;\n\n    }\n\n#else\n\n    u.ll.upper = ldq_raw(address_mask(env, addr));\n\n    u.ll.lower = ldq_raw(address_mask(env, addr + 8));\n\n    QT0 = u.q;\n\n#endif\n\n}\n", "idx": 2968}
{"project": "qemu", "commit_id": "f2917853f715b0ef55df29eb2ffea29dc69ce814", "target": 1, "func": "static struct scsi_task *iscsi_do_inquiry(struct iscsi_context *iscsi, int lun,\n\n                                          int evpd, int pc)\n\n{\n\n    int full_size;\n\n    struct scsi_task *task = NULL;\n\n    task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, 64);\n\n    if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n        goto fail;\n\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n\n        scsi_free_scsi_task(task);\n\n\n\n        /* we need more data for the full list */\n\n        task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, full_size);\n\n        if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    return task;\n\n\n\nfail:\n\n    error_report(\"iSCSI: Inquiry command failed : %s\",\n\n                 iscsi_get_error(iscsi));\n\n    if (task) {\n\n        scsi_free_scsi_task(task);\n\n        return NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 1520}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 1932}
{"project": "qemu", "commit_id": "340d51df5592c5c11fc3885f7bdedbe581b87366", "target": 1, "func": "int ga_install_service(const char *path, const char *logfile,\n\n                       const char *state_dir)\n\n{\n\n    int ret = EXIT_FAILURE;\n\n    SC_HANDLE manager;\n\n    SC_HANDLE service;\n\n    TCHAR module_fname[MAX_PATH];\n\n    GString *cmdline;\n\n    SERVICE_DESCRIPTION desc = { (char *)QGA_SERVICE_DESCRIPTION };\n\n\n\n    if (GetModuleFileName(NULL, module_fname, MAX_PATH) == 0) {\n\n        printf_win_error(\"No full path to service's executable\");\n\n        return EXIT_FAILURE;\n\n    }\n\n\n\n    cmdline = g_string_new(module_fname);\n\n    g_string_append(cmdline, \" -d\");\n\n\n\n    if (path) {\n\n        g_string_append_printf(cmdline, \" -p %s\", path);\n\n    }\n\n    if (logfile) {\n\n        g_string_append_printf(cmdline, \" -l %s -v\", logfile);\n\n    }\n\n    if (state_dir) {\n\n        g_string_append_printf(cmdline, \" -t %s\", state_dir);\n\n    }\n\n\n\n    g_debug(\"service's cmdline: %s\", cmdline->str);\n\n\n\n    manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n\n    if (manager == NULL) {\n\n        printf_win_error(\"No handle to service control manager\");\n\n        goto out_strings;\n\n    }\n\n\n\n    service = CreateService(manager, QGA_SERVICE_NAME, QGA_SERVICE_DISPLAY_NAME,\n\n        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START,\n\n        SERVICE_ERROR_NORMAL, cmdline->str, NULL, NULL, NULL, NULL, NULL);\n\n    if (service == NULL) {\n\n        printf_win_error(\"Failed to install service\");\n\n        goto out_manager;\n\n    }\n\n\n\n    ChangeServiceConfig2(service, SERVICE_CONFIG_DESCRIPTION, &desc);\n\n    fprintf(stderr, \"Service was installed successfully.\\n\");\n\n    ret = EXIT_SUCCESS;\n\n    CloseServiceHandle(service);\n\n\n\nout_manager:\n\n    CloseServiceHandle(manager);\n\n\n\nout_strings:\n\n    g_string_free(cmdline, TRUE);\n\n    return ret;\n\n}\n", "idx": 4048}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static int usbredir_get_bufpq(QEMUFile *f, void *priv, size_t unused)\n\n{\n\n    struct endp_data *endp = priv;\n\n    USBRedirDevice *dev = endp->dev;\n\n    struct buf_packet *bufp;\n\n    int i;\n\n\n\n    endp->bufpq_size = qemu_get_be32(f);\n\n    for (i = 0; i < endp->bufpq_size; i++) {\n\n        bufp = g_malloc(sizeof(struct buf_packet));\n\n        bufp->len = qemu_get_be32(f);\n\n        bufp->status = qemu_get_be32(f);\n\n        bufp->offset = 0;\n\n        bufp->data = qemu_oom_check(malloc(bufp->len)); /* regular malloc! */\n\n        bufp->free_on_destroy = bufp->data;\n\n        qemu_get_buffer(f, bufp->data, bufp->len);\n\n        QTAILQ_INSERT_TAIL(&endp->bufpq, bufp, next);\n\n        DPRINTF(\"get_bufpq %d/%d len %d status %d\\n\", i + 1, endp->bufpq_size,\n\n                bufp->len, bufp->status);\n\n    }\n\n    return 0;\n\n}\n", "idx": 147}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_vfp_msr(TCGv tmp)\n\n{\n\n    tcg_gen_mov_i32(cpu_F0s, tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1786}
{"project": "qemu", "commit_id": "05fcfada5e45b900c32ca6bccf0ce52cb5422509", "target": 1, "func": "static int get_pci_config_device(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    PCIDevice *s = container_of(pv, PCIDevice, config);\n\n    uint8_t config[size];\n\n    int i;\n\n\n\n    qemu_get_buffer(f, config, size);\n\n    for (i = 0; i < size; ++i)\n\n        if ((config[i] ^ s->config[i]) & s->cmask[i] & ~s->wmask[i])\n\n            return -EINVAL;\n\n    memcpy(s->config, config, size);\n\n\n\n    pci_update_mappings(s);\n\n\n\n    return 0;\n\n}\n", "idx": 4717}
{"project": "qemu", "commit_id": "3a03bfa5a219fe06779706315f2555622b51193c", "target": 1, "func": "int qemu_socket(int domain, int type, int protocol)\n\n{\n\n    int ret;\n\n\n\n#ifdef SOCK_CLOEXEC\n\n    ret = socket(domain, type | SOCK_CLOEXEC, protocol);\n\n#else\n\n    ret = socket(domain, type, protocol);\n\n    if (ret >= 0) {\n\n        qemu_set_cloexec(ret);\n\n    }\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 8114}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_add_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 + t2;\n\n    return suov32(env, result);\n\n}\n", "idx": 874}
{"project": "qemu", "commit_id": "eca1bdf415c454093dfc7eb983cd49287c043967", "target": 1, "func": "void cpu_reset(CPUARMState *env)\n{\n    uint32_t id;\n    id = env->cp15.c0_cpuid;\n    memset(env, 0, offsetof(CPUARMState, breakpoints));\n    if (id)\n        cpu_reset_model_id(env, id);\n#if defined (CONFIG_USER_ONLY)\n    env->uncached_cpsr = ARM_CPU_MODE_USR;\n    env->vfp.xregs[ARM_VFP_FPEXC] = 1 << 30;\n#else\n    /* SVC mode with interrupts disabled.  */\n    env->uncached_cpsr = ARM_CPU_MODE_SVC | CPSR_A | CPSR_F | CPSR_I;\n    /* On ARMv7-M the CPSR_I is the value of the PRIMASK register, and is\n       clear at reset.  */\n    if (IS_M(env))\n        env->uncached_cpsr &= ~CPSR_I;\n    env->vfp.xregs[ARM_VFP_FPEXC] = 0;\n    env->cp15.c2_base_mask = 0xffffc000u;\n#endif\n    env->regs[15] = 0;\n    tlb_flush(env, 1);", "idx": 3388}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    if (version_id != 1)\n\n        return -EINVAL;\n\n\n\n    s->ris = qemu_get_be32(f);\n\n    s->im = qemu_get_be32(f);\n\n    s->rctl = qemu_get_be32(f);\n\n    s->tctl = qemu_get_be32(f);\n\n    s->thr = qemu_get_be32(f);\n\n    s->mctl = qemu_get_be32(f);\n\n    s->mdv = qemu_get_be32(f);\n\n    s->mtxd = qemu_get_be32(f);\n\n    s->mrxd = qemu_get_be32(f);\n\n    s->np = qemu_get_be32(f);\n\n    s->tx_fifo_len = qemu_get_be32(f);\n\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        s->rx[i].len = qemu_get_be32(f);\n\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    s->next_packet = qemu_get_be32(f);\n\n    s->rx_fifo_offset = qemu_get_be32(f);\n\n\n\n    return 0;\n\n}\n", "idx": 1867}
{"project": "qemu", "commit_id": "9bd8e9330ade42878b19a5172131087220d590d5", "target": 1, "func": "static GuestPCIAddress *get_pci_info(char *guid, Error **errp)\n\n{\n\n    HDEVINFO dev_info;\n\n    SP_DEVINFO_DATA dev_info_data;\n\n    DWORD size = 0;\n\n    int i;\n\n    char dev_name[MAX_PATH];\n\n    char *buffer = NULL;\n\n    GuestPCIAddress *pci = NULL;\n\n    char *name = g_strdup(&guid[4]);\n\n\n\n    if (!QueryDosDevice(name, dev_name, ARRAY_SIZE(dev_name))) {\n\n        error_setg_win32(errp, GetLastError(), \"failed to get dos device name\");\n\n        goto out;\n\n    }\n\n\n\n    dev_info = SetupDiGetClassDevs(&GUID_DEVINTERFACE_VOLUME, 0, 0,\n\n                                   DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);\n\n    if (dev_info == INVALID_HANDLE_VALUE) {\n\n        error_setg_win32(errp, GetLastError(), \"failed to get devices tree\");\n\n        goto out;\n\n    }\n\n\n\n    dev_info_data.cbSize = sizeof(SP_DEVINFO_DATA);\n\n    for (i = 0; SetupDiEnumDeviceInfo(dev_info, i, &dev_info_data); i++) {\n\n        DWORD addr, bus, slot, func, dev, data, size2;\n\n        while (!SetupDiGetDeviceRegistryProperty(dev_info, &dev_info_data,\n\n                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,\n\n                                            &data, (PBYTE)buffer, size,\n\n                                            &size2)) {\n\n            size = MAX(size, size2);\n\n            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n\n                g_free(buffer);\n\n                /* Double the size to avoid problems on\n\n                 * W2k MBCS systems per KB 888609.\n\n                 * https://support.microsoft.com/en-us/kb/259695 */\n\n                buffer = g_malloc(size * 2);\n\n            } else {\n\n                error_setg_win32(errp, GetLastError(),\n\n                        \"failed to get device name\");\n\n                goto out;\n\n            }\n\n        }\n\n\n\n        if (g_strcmp0(buffer, dev_name)) {\n\n            continue;\n\n        }\n\n\n\n        /* There is no need to allocate buffer in the next functions. The size\n\n         * is known and ULONG according to\n\n         * https://support.microsoft.com/en-us/kb/253232\n\n         * https://msdn.microsoft.com/en-us/library/windows/hardware/ff543095(v=vs.85).aspx\n\n         */\n\n        if (!SetupDiGetDeviceRegistryProperty(dev_info, &dev_info_data,\n\n                   SPDRP_BUSNUMBER, &data, (PBYTE)&bus, size, NULL)) {\n\n            break;\n\n        }\n\n\n\n        /* The function retrieves the device's address. This value will be\n\n         * transformed into device function and number */\n\n        if (!SetupDiGetDeviceRegistryProperty(dev_info, &dev_info_data,\n\n                   SPDRP_ADDRESS, &data, (PBYTE)&addr, size, NULL)) {\n\n            break;\n\n        }\n\n\n\n        /* This call returns UINumber of DEVICE_CAPABILITIES structure.\n\n         * This number is typically a user-perceived slot number. */\n\n        if (!SetupDiGetDeviceRegistryProperty(dev_info, &dev_info_data,\n\n                   SPDRP_UI_NUMBER, &data, (PBYTE)&slot, size, NULL)) {\n\n            break;\n\n        }\n\n\n\n        /* SetupApi gives us the same information as driver with\n\n         * IoGetDeviceProperty. According to Microsoft\n\n         * https://support.microsoft.com/en-us/kb/253232\n\n         * FunctionNumber = (USHORT)((propertyAddress) & 0x0000FFFF);\n\n         * DeviceNumber = (USHORT)(((propertyAddress) >> 16) & 0x0000FFFF);\n\n         * SPDRP_ADDRESS is propertyAddress, so we do the same.*/\n\n\n\n        func = addr & 0x0000FFFF;\n\n        dev = (addr >> 16) & 0x0000FFFF;\n\n        pci = g_malloc0(sizeof(*pci));\n\n        pci->domain = dev;\n\n        pci->slot = slot;\n\n        pci->function = func;\n\n        pci->bus = bus;\n\n        break;\n\n    }\n\nout:\n\n    g_free(buffer);\n\n    g_free(name);\n\n    return pci;\n\n}\n", "idx": 4178}
{"project": "qemu", "commit_id": "13c91cb7e28b47f5c4227f7e88a1378570117704", "target": 1, "func": "static int iscsi_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int ret = 0;\n\n    int64_t total_size = 0;\n\n    BlockDriverState bs;\n\n    IscsiLun *iscsilun = NULL;\n\n    QDict *bs_options;\n\n\n\n    memset(&bs, 0, sizeof(BlockDriverState));\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, \"size\")) {\n\n            total_size = options->value.n / BDRV_SECTOR_SIZE;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    bs.opaque = g_malloc0(sizeof(struct IscsiLun));\n\n    iscsilun = bs.opaque;\n\n\n\n    bs_options = qdict_new();\n\n    qdict_put(bs_options, \"filename\", qstring_from_str(filename));\n\n    ret = iscsi_open(&bs, bs_options, 0);\n\n    QDECREF(bs_options);\n\n\n\n    if (ret != 0) {\n\n        goto out;\n\n    }\n\n    if (iscsilun->nop_timer) {\n\n        timer_del(iscsilun->nop_timer);\n\n        timer_free(iscsilun->nop_timer);\n\n    }\n\n    if (iscsilun->type != TYPE_DISK) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n    if (bs.total_sectors < total_size) {\n\n        ret = -ENOSPC;\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (iscsilun->iscsi != NULL) {\n\n        iscsi_destroy_context(iscsilun->iscsi);\n\n    }\n\n    g_free(bs.opaque);\n\n    return ret;\n\n}\n", "idx": 2174}
{"project": "qemu", "commit_id": "d54fddea989ba4aa2912d49583d86ce01c0d27ea", "target": 1, "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n\n{\n\n    XHCIState *xhci = epctx->xhci;\n\n    XHCIStreamContext *stctx = NULL;\n\n    XHCITransfer *xfer;\n\n    XHCIRing *ring;\n\n    USBEndpoint *ep = NULL;\n\n    uint64_t mfindex;\n\n    unsigned int count = 0;\n\n    int length;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n    assert(!epctx->kick_active);\n\n\n\n    /* If the device has been detached, but the guest has not noticed this\n\n       yet the 2 above checks will succeed, but we must NOT continue */\n\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n\n        return;\n\n    }\n\n\n\n    if (epctx->retry) {\n\n        XHCITransfer *xfer = epctx->retry;\n\n\n\n        trace_usb_xhci_xfer_retry(xfer);\n\n        assert(xfer->running_retry);\n\n        if (xfer->timed_xfer) {\n\n            /* time to kick the transfer? */\n\n            mfindex = xhci_mfindex_get(xhci);\n\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n\n            if (xfer->running_retry) {\n\n                return;\n\n            }\n\n            xfer->timed_xfer = 0;\n\n            xfer->running_retry = 1;\n\n        }\n\n        if (xfer->iso_xfer) {\n\n            /* retry iso transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            assert(xfer->packet.status != USB_RET_NAK);\n\n            xhci_try_complete_packet(xfer);\n\n        } else {\n\n            /* retry nak'ed transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            if (xfer->packet.status == USB_RET_NAK) {\n\n                return;\n\n            }\n\n            xhci_try_complete_packet(xfer);\n\n        }\n\n        assert(!xfer->running_retry);\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(epctx->retry);\n\n        }\n\n        epctx->retry = NULL;\n\n    }\n\n\n\n    if (epctx->state == EP_HALTED) {\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    epctx->kick_active++;\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n        if (count++ > TRANSFER_LIMIT) {\n\n            trace_usb_xhci_enforced_limit(\"transfers\");\n\n            break;\n\n        }\n\n    }\n\n    /* update ring dequeue ptr */\n\n    xhci_set_ep_state(xhci, epctx, stctx, epctx->state);\n\n    epctx->kick_active--;\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n", "idx": 2964}
{"project": "qemu", "commit_id": "454b580ae9ae3e7722f1cd5f6da7bb479f86bbd8", "target": 1, "func": "static sPAPRDIMMState *spapr_recover_pending_dimm_state(sPAPRMachineState *ms,\n\n                                                        PCDIMMDevice *dimm)\n\n{\n\n    sPAPRDRConnector *drc;\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    uint64_t size = memory_region_size(mr);\n\n    uint32_t nr_lmbs = size / SPAPR_MEMORY_BLOCK_SIZE;\n\n    uint32_t avail_lmbs = 0;\n\n    uint64_t addr_start, addr;\n\n    int i;\n\n    sPAPRDIMMState *ds;\n\n\n\n    addr_start = object_property_get_int(OBJECT(dimm), PC_DIMM_ADDR_PROP,\n\n                                         &error_abort);\n\n\n\n    addr = addr_start;\n\n    for (i = 0; i < nr_lmbs; i++) {\n\n        drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,\n\n                              addr / SPAPR_MEMORY_BLOCK_SIZE);\n\n        g_assert(drc);\n\n        if (drc->indicator_state != SPAPR_DR_INDICATOR_STATE_INACTIVE) {\n\n            avail_lmbs++;\n\n        }\n\n        addr += SPAPR_MEMORY_BLOCK_SIZE;\n\n    }\n\n\n\n    ds = g_malloc0(sizeof(sPAPRDIMMState));\n\n    ds->nr_lmbs = avail_lmbs;\n\n    ds->dimm = dimm;\n\n    spapr_pending_dimm_unplugs_add(ms, ds);\n\n    return ds;\n\n}\n", "idx": 7477}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n", "idx": 938}
{"project": "qemu", "commit_id": "47e8dd8fe9d83e8b51d40c2b87d7983bd0a78206", "target": 1, "func": "char **breakline(char *input, int *count)\n\n{\n\n    int c = 0;\n\n    char *p;\n\n    char **rval = calloc(sizeof(char *), 1);\n\n\n\n    while (rval && (p = qemu_strsep(&input, \" \")) != NULL) {\n\n        if (!*p) {\n\n            continue;\n\n        }\n\n        c++;\n\n        rval = realloc(rval, sizeof(*rval) * (c + 1));\n\n        if (!rval) {\n\n            c = 0;\n\n            break;\n\n        }\n\n        rval[c - 1] = p;\n\n        rval[c] = NULL;\n\n    }\n\n    *count = c;\n\n    return rval;\n\n}\n", "idx": 7242}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void qga_vss_fsfreeze(int *nr_volume, Error **errp, bool freeze)\n\n{\n\n    const char *func_name = freeze ? \"requester_freeze\" : \"requester_thaw\";\n\n    QGAVSSRequesterFunc func;\n\n    ErrorSet errset = {\n\n        .error_setg_win32 = error_setg_win32,\n\n        .errp = errp,\n\n    };\n\n\n\n    g_assert(errp);             /* requester.cpp requires it */\n\n    func = (QGAVSSRequesterFunc)GetProcAddress(provider_lib, func_name);\n\n    if (!func) {\n\n        error_setg_win32(errp, GetLastError(), \"failed to load %s from %s\",\n\n                         func_name, QGA_VSS_DLL);\n\n        return;\n\n    }\n\n\n\n    func(nr_volume, &errset);\n\n}\n", "idx": 2415}
{"project": "qemu", "commit_id": "8db165b36ef893ac69af0452f20eeb78e7b26b5a", "target": 1, "func": "static int pollfds_fill(GArray *pollfds, fd_set *rfds, fd_set *wfds,\n\n                        fd_set *xfds)\n\n{\n\n    int nfds = -1;\n\n    int i;\n\n\n\n    for (i = 0; i < pollfds->len; i++) {\n\n        GPollFD *pfd = &g_array_index(pollfds, GPollFD, i);\n\n        int fd = pfd->fd;\n\n        int events = pfd->events;\n\n        if (events & (G_IO_IN | G_IO_HUP | G_IO_ERR)) {\n\n            FD_SET(fd, rfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & (G_IO_OUT | G_IO_ERR)) {\n\n            FD_SET(fd, wfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & G_IO_PRI) {\n\n            FD_SET(fd, xfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n    }\n\n    return nfds;\n\n}\n", "idx": 7343}
{"project": "qemu", "commit_id": "92335a0d4021a3b44ccc88c9fc6c0fd2113f1882", "target": 1, "func": "static uint64_t strongarm_gpio_read(void *opaque, hwaddr offset,\n\n                                    unsigned size)\n\n{\n\n    StrongARMGPIOInfo *s = opaque;\n\n\n\n    switch (offset) {\n\n    case GPDR:        /* GPIO Pin-Direction registers */\n\n        return s->dir;\n\n\n\n    case GPSR:        /* GPIO Pin-Output Set registers */\n\n        DPRINTF(\"%s: Read from a write-only register 0x\" TARGET_FMT_plx \"\\n\",\n\n                        __func__, offset);\n\n        return s->gpsr;    /* Return last written value.  */\n\n\n\n    case GPCR:        /* GPIO Pin-Output Clear registers */\n\n        DPRINTF(\"%s: Read from a write-only register 0x\" TARGET_FMT_plx \"\\n\",\n\n                        __func__, offset);\n\n        return 31337;        /* Specified as unpredictable in the docs.  */\n\n\n\n    case GRER:        /* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising;\n\n\n\n    case GFER:        /* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling;\n\n\n\n    case GAFR:        /* GPIO Alternate Function registers */\n\n        return s->gafr;\n\n\n\n    case GPLR:        /* GPIO Pin-Level registers */\n\n        return (s->olevel & s->dir) |\n\n               (s->ilevel & ~s->dir);\n\n\n\n    case GEDR:        /* GPIO Edge Detect Status registers */\n\n        return s->status;\n\n\n\n    default:\n\n        printf(\"%s: Bad offset 0x\" TARGET_FMT_plx \"\\n\", __func__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9189}
{"project": "qemu", "commit_id": "c34c762015fec023c3ea5cf3629cbac462a80973", "target": 1, "func": "void qemu_tcg_configure(QemuOpts *opts, Error **errp)\n\n{\n\n    const char *t = qemu_opt_get(opts, \"thread\");\n\n    if (t) {\n\n        if (strcmp(t, \"multi\") == 0) {\n\n            if (TCG_OVERSIZED_GUEST) {\n\n                error_setg(errp, \"No MTTCG when guest word size > hosts\");\n\n            } else if (use_icount) {\n\n                error_setg(errp, \"No MTTCG when icount is enabled\");\n\n            } else {\n\n\n\n\n\n                if (!check_tcg_memory_orders_compatible()) {\n\n                    error_report(\"Guest expects a stronger memory ordering \"\n\n                                 \"than the host provides\");\n\n                    error_printf(\"This may cause strange/hard to debug errors\");\n\n                }\n\n                mttcg_enabled = true;\n\n            }\n\n        } else if (strcmp(t, \"single\") == 0) {\n\n            mttcg_enabled = false;\n\n        } else {\n\n            error_setg(errp, \"Invalid 'thread' setting %s\", t);\n\n        }\n\n    } else {\n\n        mttcg_enabled = default_mttcg_enabled();\n\n    }\n\n}", "idx": 12223}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file(HANDLE fd_out, CharDriverState **pchr)\n\n{\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    s->hcom = fd_out;\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    qemu_chr_generic_open(chr);\n\n    *pchr = chr;\n\n    return 0;\n\n}\n", "idx": 9830}
{"project": "qemu", "commit_id": "556c2b60714e7dae3ed0eb3488910435263dc09f", "target": 1, "func": "static int aio_read_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n\n\n    ctx->blk = blk;\n\n    while ((c = getopt(argc, argv, \"CP:qv\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'P':\n\n            ctx->Pflag = 1;\n\n            ctx->pattern = parse_pattern(optarg);\n\n            if (ctx->pattern < 0) {\n\n                g_free(ctx);\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'v':\n\n            ctx->vflag = 1;\n\n            break;\n\n        default:\n\n            g_free(ctx);\n\n            return qemuio_command_usage(&aio_read_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        g_free(ctx);\n\n        return qemuio_command_usage(&aio_read_cmd);\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n        g_free(ctx);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n\n        g_free(ctx);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov, 0xab);\n\n    if (ctx->buf == NULL) {\n\n\n        g_free(ctx);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&ctx->t1, NULL);\n\n    block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                     BLOCK_ACCT_READ);\n\n    blk_aio_readv(blk, ctx->offset >> 9, &ctx->qiov,\n\n                  ctx->qiov.size >> 9, aio_read_done, ctx);\n\n    return 0;\n\n}", "idx": 4857}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void via_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = vt82c686b_initfn;\n\n    k->config_write = vt82c686b_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_VIA;\n\n    k->device_id = PCI_DEVICE_ID_VIA_ISA_BRIDGE;\n\n    k->class_id = PCI_CLASS_BRIDGE_ISA;\n\n    k->revision = 0x40;\n\n    dc->desc = \"ISA bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_via;\n\n}\n", "idx": 9429}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}", "idx": 584}
{"project": "qemu", "commit_id": "5712db6ae5101db645f71edc393368cd59bfd314", "target": 1, "func": "static void fw_cfg_realize(DeviceState *dev, Error **errp)\n\n{\n\n    FWCfgState *s = FW_CFG(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    if (s->ctl_iobase + 1 == s->data_iobase) {\n\n        sysbus_add_io(sbd, s->ctl_iobase, &s->comb_iomem);\n\n    } else {\n\n        if (s->ctl_iobase) {\n\n            sysbus_add_io(sbd, s->ctl_iobase, &s->ctl_iomem);\n\n        }\n\n        if (s->data_iobase) {\n\n            sysbus_add_io(sbd, s->data_iobase, &s->data_iomem);\n\n        }\n\n    }\n\n}\n", "idx": 7334}
{"project": "qemu", "commit_id": "7443b43758ba5eeca8f81ca15fe9fced8983be26", "target": 1, "func": "ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n", "idx": 11659}
{"project": "qemu", "commit_id": "d83c951cce14dd3c7600c386d3791c4993744622", "target": 1, "func": "static int ata_passthrough_12_xfer_size(SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    int length = buf[2] & 0x3;\n\n    int xfer;\n\n    int unit = ata_passthrough_xfer_unit(dev, buf);\n\n\n\n    switch (length) {\n\n    case 0:\n\n    case 3: /* USB-specific.  */\n\n\n        xfer = 0;\n\n        break;\n\n    case 1:\n\n        xfer = buf[3];\n\n        break;\n\n    case 2:\n\n        xfer = buf[4];\n\n        break;\n\n    }\n\n\n\n    return xfer * unit;\n\n}", "idx": 3103}
{"project": "qemu", "commit_id": "43849424cff82803011fad21074531a1101e514e", "target": 1, "func": "static void tap_cleanup(VLANClientState *nc)\n\n{\n\n    TAPState *s = DO_UPCAST(TAPState, nc, nc);\n\n\n\n    if (s->vhost_net) {\n\n        vhost_net_cleanup(s->vhost_net);\n\n\n    }\n\n\n\n    qemu_purge_queued_packets(nc);\n\n\n\n    if (s->down_script[0])\n\n        launch_script(s->down_script, s->down_script_arg, s->fd);\n\n\n\n    tap_read_poll(s, 0);\n\n    tap_write_poll(s, 0);\n\n    close(s->fd);\n\n}", "idx": 1216}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 10050}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void allocate_system_memory_nonnuma(MemoryRegion *mr, Object *owner,\n\n                                           const char *name,\n\n                                           uint64_t ram_size)\n\n{\n\n    if (mem_path) {\n\n#ifdef __linux__\n\n        Error *err = NULL;\n\n        memory_region_init_ram_from_file(mr, owner, name, ram_size, false,\n\n                                         mem_path, &err);\n\n\n\n        /* Legacy behavior: if allocation failed, fall back to\n\n         * regular RAM allocation.\n\n         */\n\n        if (err) {\n\n            error_report_err(err);\n\n            memory_region_init_ram(mr, owner, name, ram_size, &error_abort);\n\n        }\n\n#else\n\n        fprintf(stderr, \"-mem-path not supported on this host\\n\");\n\n        exit(1);\n\n#endif\n\n    } else {\n\n        memory_region_init_ram(mr, owner, name, ram_size, &error_abort);\n\n    }\n\n    vmstate_register_ram_global(mr);\n\n}\n", "idx": 1507}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void ppc_tlb_invalidate_one (CPUPPCState *env, target_ulong addr)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    addr &= TARGET_PAGE_MASK;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_virt(env, addr, 0);\n\n        if (env->id_tlbs == 1)\n\n            ppc6xx_tlb_invalidate_virt(env, addr, 1);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_virt(env, addr, env->spr[SPR_40x_PID]);\n\n        break;\n\n    case POWERPC_MMU_REAL_4xx:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n        /* tlbie invalidate TLBs for all segments */\n\n        addr &= ~((target_ulong)-1 << 28);\n\n        /* XXX: this case should be optimized,\n\n         * giving a mask to tlb_flush_page\n\n         */\n\n        tlb_flush_page(env, addr | (0x0 << 28));\n\n        tlb_flush_page(env, addr | (0x1 << 28));\n\n        tlb_flush_page(env, addr | (0x2 << 28));\n\n        tlb_flush_page(env, addr | (0x3 << 28));\n\n        tlb_flush_page(env, addr | (0x4 << 28));\n\n        tlb_flush_page(env, addr | (0x5 << 28));\n\n        tlb_flush_page(env, addr | (0x6 << 28));\n\n        tlb_flush_page(env, addr | (0x7 << 28));\n\n        tlb_flush_page(env, addr | (0x8 << 28));\n\n        tlb_flush_page(env, addr | (0x9 << 28));\n\n        tlb_flush_page(env, addr | (0xA << 28));\n\n        tlb_flush_page(env, addr | (0xB << 28));\n\n        tlb_flush_page(env, addr | (0xC << 28));\n\n        tlb_flush_page(env, addr | (0xD << 28));\n\n        tlb_flush_page(env, addr | (0xE << 28));\n\n        tlb_flush_page(env, addr | (0xF << 28));\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n        /* tlbie invalidate TLBs for all segments */\n\n        /* XXX: given the fact that there are too many segments to invalidate,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask) in Qemu,\n\n         *      we just invalidate all TLBs\n\n         */\n\n        tlb_flush(env, 1);\n\n        break;\n\n#endif /* defined(TARGET_PPC64) */\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n#else\n\n    ppc_tlb_invalidate_all(env);\n\n#endif\n\n}\n", "idx": 6653}
{"project": "qemu", "commit_id": "24d1a6d9d5f5b3da868724dd3c6f56893e0693da", "target": 1, "func": "static void test_flush_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 10, .auto_set = true };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb, event_active_cb);\n\n    g_assert(aio_poll(ctx, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 10);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(aio_poll(ctx, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 9);\n\n    g_assert(aio_poll(ctx, false));\n\n\n\n    wait_for_aio();\n\n    g_assert_cmpint(data.n, ==, 10);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n    g_assert(!aio_poll(ctx, false));\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL, NULL);\n\n    g_assert(!aio_poll(ctx, false));\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 8161}
{"project": "qemu", "commit_id": "791230d8bbd5c09d80845755a54074cd2d8b5a22", "target": 1, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n                          BdrvCheckMode fix)\n{\n    BDRVQcowState *s = bs->opaque;\n    BdrvCheckResult pre_compare_res;\n    int64_t size, highest_cluster, nb_clusters;\n    uint16_t *refcount_table = NULL;\n    bool rebuild = false;\n    int ret;\n    size = bdrv_getlength(bs->file);\n    if (size < 0) {\n        res->check_errors++;\n        return size;\n    nb_clusters = size_to_clusters(s, size);\n    if (nb_clusters > INT_MAX) {\n        res->check_errors++;\n        return -EFBIG;\n    res->bfi.total_clusters =\n        size_to_clusters(s, bs->total_sectors * BDRV_SECTOR_SIZE);\n    ret = calculate_refcounts(bs, res, fix, &rebuild, &refcount_table,\n    /* In case we don't need to rebuild the refcount structure (but want to fix\n     * something), this function is immediately called again, in which case the\n     * result should be ignored */\n    pre_compare_res = *res;\n    compare_refcounts(bs, res, 0, &rebuild, &highest_cluster, refcount_table,\n                      nb_clusters);\n    if (rebuild && (fix & BDRV_FIX_ERRORS)) {\n        fprintf(stderr, \"Rebuilding refcount structure\\n\");\n        ret = rebuild_refcount_structure(bs, res, &refcount_table,\n    } else if (fix) {\n            fprintf(stderr, \"ERROR need to rebuild refcount structures\\n\");\n            res->check_errors++;\n            ret = -EIO;\n        if (res->leaks || res->corruptions) {\n            *res = pre_compare_res;\n            compare_refcounts(bs, res, fix, &rebuild, &highest_cluster,\n                              refcount_table, nb_clusters);\n    /* check OFLAG_COPIED */\n    ret = check_oflag_copied(bs, res, fix);\n    res->image_end_offset = (highest_cluster + 1) * s->cluster_size;\n    ret = 0;\nfail:\n    g_free(refcount_table);\n    return ret;", "idx": 6708}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void migrate_del_blocker(Error *reason)\n\n{\n\n    migration_blockers = g_slist_remove(migration_blockers, reason);\n\n}\n", "idx": 8374}
{"project": "qemu", "commit_id": "33876dfad64bc481f59c5e9ccf60db78624c4b93", "target": 1, "func": "static void xenstore_update_be(char *watch, char *type, int dom,\n\n                               struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n    char path[XEN_BUFSIZE], *dom0, *bepath;\n\n    unsigned int len, dev;\n\n\n\n    dom0 = xs_get_domain_path(xenstore, 0);\n\n    len = snprintf(path, sizeof(path), \"%s/backend/%s/%d\", dom0, type, dom);\n\n    free(dom0);\n\n    if (strncmp(path, watch, len) != 0) {\n\n        return;\n\n    }\n\n    if (sscanf(watch+len, \"/%u/%255s\", &dev, path) != 2) {\n\n        strcpy(path, \"\");\n\n        if (sscanf(watch+len, \"/%u\", &dev) != 1) {\n\n            dev = -1;\n\n        }\n\n    }\n\n    if (dev == -1) {\n\n        return;\n\n    }\n\n\n\n    xendev = xen_be_get_xendev(type, dom, dev, ops);\n\n    if (xendev != NULL) {\n\n        bepath = xs_read(xenstore, 0, xendev->be, &len);\n\n        if (bepath == NULL) {\n\n            xen_be_del_xendev(dom, dev);\n\n        } else {\n\n            free(bepath);\n\n            xen_be_backend_changed(xendev, path);\n\n            xen_be_check_state(xendev);\n\n        }\n\n    }\n\n}\n", "idx": 9021}
{"project": "qemu", "commit_id": "27a749fb733dc64b7a215998be7f228a09bb27a7", "target": 1, "func": "void qemu_error_internal(const char *file, int linenr, const char *func,\n\n                         const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    QError *qerror;\n\n\n\n    assert(qemu_error_sink != NULL);\n\n\n\n    va_start(va, fmt);\n\n    qerror = qerror_from_info(file, linenr, func, fmt, &va);\n\n    va_end(va);\n\n\n\n    switch (qemu_error_sink->dest) {\n\n    case ERR_SINK_FILE:\n\n        qerror_print(qerror);\n\n        QDECREF(qerror);\n\n        break;\n\n    case ERR_SINK_MONITOR:\n\n        assert(qemu_error_sink->mon->error == NULL);\n\n        qemu_error_sink->mon->error = qerror;\n\n        break;\n\n    }\n\n}\n", "idx": 3289}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_by_legacy_dinfo(dinfo),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 1335}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_attach_aio_context(BlockDriverState *bs,\n\n                             AioContext *new_context)\n\n{\n\n    BdrvAioNotifier *ban;\n\n    BdrvChild *child;\n\n\n\n    if (!bs->drv) {\n\n        return;\n\n    }\n\n\n\n    bs->aio_context = new_context;\n\n\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        bdrv_attach_aio_context(child->bs, new_context);\n\n    }\n\n    if (bs->drv->bdrv_attach_aio_context) {\n\n        bs->drv->bdrv_attach_aio_context(bs, new_context);\n\n    }\n\n\n\n    QLIST_FOREACH(ban, &bs->aio_notifiers, list) {\n\n        ban->attached_aio_context(new_context, ban->opaque);\n\n    }\n\n}\n", "idx": 3322}
{"project": "qemu", "commit_id": "1b0952445522af73b0e78420a9078b3653923703", "target": 1, "func": "static void test_hbitmap_iter_past(TestHBitmapData *data,\n\n                                    const void *unused)\n\n{\n\n    hbitmap_test_init(data, L3, 0);\n\n    hbitmap_test_set(data, 0, L3);\n\n    hbitmap_test_check(data, L3);\n\n}\n", "idx": 11729}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static bool gscb_needed(void *opaque)\n\n{\n\n    return kvm_s390_get_gs();\n\n}\n", "idx": 10350}
{"project": "qemu", "commit_id": "24fa90499f8b24bcba2960a3316d797f9b80b5e9", "target": 1, "func": "void qemu_mutex_init(QemuMutex *mutex)\n\n{\n\n    int err;\n\n    pthread_mutexattr_t mutexattr;\n\n\n\n    pthread_mutexattr_init(&mutexattr);\n\n    pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_ERRORCHECK);\n\n    err = pthread_mutex_init(&mutex->lock, &mutexattr);\n\n    pthread_mutexattr_destroy(&mutexattr);\n\n    if (err)\n\n        error_exit(err, __func__);\n\n}\n", "idx": 10077}
{"project": "qemu", "commit_id": "39f72ef94ba74701d18daf82b44c18a60f94eb60", "target": 1, "func": "static void xilinx_enet_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XilinxAXIEnet *s = XILINX_AXI_ENET(dev);\n\n    XilinxAXIEnetStreamSlave *ds = XILINX_AXI_ENET_DATA_STREAM(&s->rx_data_dev);\n\n    XilinxAXIEnetStreamSlave *cs = XILINX_AXI_ENET_CONTROL_STREAM(\n\n                                                            &s->rx_control_dev);\n\n    Error *local_errp = NULL;\n\n\n\n    object_property_add_link(OBJECT(ds), \"enet\", \"xlnx.axi-ethernet\",\n\n                             (Object **) &ds->enet,\n\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_errp);\n\n    object_property_add_link(OBJECT(cs), \"enet\", \"xlnx.axi-ethernet\",\n\n                             (Object **) &cs->enet,\n\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_errp);\n\n    if (local_errp) {\n\n        goto xilinx_enet_realize_fail;\n\n    }\n\n    object_property_set_link(OBJECT(ds), OBJECT(s), \"enet\", &local_errp);\n\n    object_property_set_link(OBJECT(cs), OBJECT(s), \"enet\", &local_errp);\n\n    if (local_errp) {\n\n        goto xilinx_enet_realize_fail;\n\n    }\n\n\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(&net_xilinx_enet_info, &s->conf,\n\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n\n\n    tdk_init(&s->TEMAC.phy);\n\n    mdio_attach(&s->TEMAC.mdio_bus, &s->TEMAC.phy, s->c_phyaddr);\n\n\n\n    s->TEMAC.parent = s;\n\n\n\n    s->rxmem = g_malloc(s->c_rxmem);\n\n    return;\n\n\n\nxilinx_enet_realize_fail:\n\n    if (!*errp) {\n\n        *errp = local_errp;\n\n    }\n\n}", "idx": 10111}
{"project": "qemu", "commit_id": "6dd4b1f1d026e478d9177b28169b377e212400f3", "target": 1, "func": "static int local_renameat(FsContext *ctx, V9fsPath *olddir,\n\n                          const char *old_name, V9fsPath *newdir,\n\n                          const char *new_name)\n\n{\n\n    int ret;\n\n    int odirfd, ndirfd;\n\n\n\n    odirfd = local_opendir_nofollow(ctx, olddir->data);\n\n    if (odirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    ndirfd = local_opendir_nofollow(ctx, newdir->data);\n\n    if (ndirfd == -1) {\n\n        close_preserve_errno(odirfd);\n\n        return -1;\n\n    }\n\n\n\n    ret = renameat(odirfd, old_name, ndirfd, new_name);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        int omap_dirfd, nmap_dirfd;\n\n\n\n        ret = mkdirat(ndirfd, VIRTFS_META_DIR, 0700);\n\n        if (ret < 0 && errno != EEXIST) {\n\n            goto err_undo_rename;\n\n        }\n\n\n\n        omap_dirfd = openat(odirfd, VIRTFS_META_DIR,\n\n                            O_RDONLY | O_DIRECTORY | O_NOFOLLOW);\n\n        if (omap_dirfd == -1) {\n\n            goto err;\n\n        }\n\n\n\n        nmap_dirfd = openat(ndirfd, VIRTFS_META_DIR,\n\n                            O_RDONLY | O_DIRECTORY | O_NOFOLLOW);\n\n        if (nmap_dirfd == -1) {\n\n            close_preserve_errno(omap_dirfd);\n\n            goto err;\n\n        }\n\n\n\n        /* rename the .virtfs_metadata files */\n\n        ret = renameat(omap_dirfd, old_name, nmap_dirfd, new_name);\n\n        close_preserve_errno(nmap_dirfd);\n\n        close_preserve_errno(omap_dirfd);\n\n        if (ret < 0 && errno != ENOENT) {\n\n            goto err_undo_rename;\n\n        }\n\n\n\n        ret = 0;\n\n    }\n\n    goto out;\n\n\n\nerr:\n\n    ret = -1;\n\nerr_undo_rename:\n\n    renameat_preserve_errno(ndirfd, new_name, odirfd, old_name);\n\nout:\n\n    close_preserve_errno(ndirfd);\n\n    close_preserve_errno(odirfd);\n\n    return ret;\n\n}\n", "idx": 589}
{"project": "qemu", "commit_id": "49cffbc6079c27432b4635d5d03ce14a249d86e2", "target": 1, "func": "void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)\n\n{\n\n    int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;\n\n    int max_xfer_len = 0;\n\n    int64_t sector_num = 0;\n\n\n\n    if (mrb->num_reqs == 1) {\n\n        submit_requests(blk, mrb, 0, 1, -1);\n\n        mrb->num_reqs = 0;\n\n        return;\n\n    }\n\n\n\n    max_xfer_len = blk_get_max_transfer_length(mrb->reqs[0]->dev->blk);\n\n    max_xfer_len = MIN_NON_ZERO(max_xfer_len, BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    qsort(mrb->reqs, mrb->num_reqs, sizeof(*mrb->reqs),\n\n          &multireq_compare);\n\n\n\n    for (i = 0; i < mrb->num_reqs; i++) {\n\n        VirtIOBlockReq *req = mrb->reqs[i];\n\n        if (num_reqs > 0) {\n\n            bool merge = true;\n\n\n\n            /* merge would exceed maximum number of IOVs */\n\n            if (niov + req->qiov.niov > IOV_MAX) {\n\n                merge = false;\n\n            }\n\n\n\n            /* merge would exceed maximum transfer length of backend device */\n\n            if (req->qiov.size / BDRV_SECTOR_SIZE + nb_sectors > max_xfer_len) {\n\n                merge = false;\n\n            }\n\n\n\n            /* requests are not sequential */\n\n            if (sector_num + nb_sectors != req->sector_num) {\n\n                merge = false;\n\n            }\n\n\n\n            if (!merge) {\n\n                submit_requests(blk, mrb, start, num_reqs, niov);\n\n                num_reqs = 0;\n\n            }\n\n        }\n\n\n\n        if (num_reqs == 0) {\n\n            sector_num = req->sector_num;\n\n            nb_sectors = niov = 0;\n\n            start = i;\n\n        }\n\n\n\n        nb_sectors += req->qiov.size / BDRV_SECTOR_SIZE;\n\n        niov += req->qiov.niov;\n\n        num_reqs++;\n\n    }\n\n\n\n    submit_requests(blk, mrb, start, num_reqs, niov);\n\n    mrb->num_reqs = 0;\n\n}\n", "idx": 3010}
{"project": "qemu", "commit_id": "e1f2641b5926d20f63d36f0de45206be774da8da", "target": 1, "func": "void monitor_vprintf(Monitor *mon, const char *fmt, va_list ap)\n\n{\n\n    char buf[4096];\n\n\n\n    if (!mon)\n\n        return;\n\n\n\n    if (monitor_ctrl_mode(mon)) {\n\n        return;\n\n    }\n\n\n\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n\n    monitor_puts(mon, buf);\n\n}\n", "idx": 8796}
{"project": "qemu", "commit_id": "34e1c27bc3094ffe484d9855e07ad104bddf579f", "target": 1, "func": "uint32 float32_to_uint32( float32 a STATUS_PARAM )\n\n{\n\n    int64_t v;\n\n    uint32 res;\n\n\n\n    v = float32_to_int64(a STATUS_VAR);\n\n    if (v < 0) {\n\n        res = 0;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else if (v > 0xffffffff) {\n\n        res = 0xffffffff;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else {\n\n        res = v;\n\n    }\n\n    return res;\n\n}\n", "idx": 7624}
{"project": "qemu", "commit_id": "540c79fec9e8b6a6582ec4c65aa2c4c5366e4b89", "target": 1, "func": "int tcp_start_outgoing_migration(MigrationState *s, const char *host_port,\n\n                                 Error **errp)\n\n{\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n\n\n    s->fd = inet_connect(host_port, false, NULL, errp);\n\n\n\n    if (!error_is_set(errp)) {\n\n        migrate_fd_connect(s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_IN_PROGRESS)) {\n\n        DPRINTF(\"connect in progress\\n\");\n\n        qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CREATE_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        return -1;\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        migrate_fd_error(s);\n\n        return -1;\n\n    } else {\n\n        DPRINTF(\"unknown error\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6020}
{"project": "qemu", "commit_id": "2c1ee068b469ef5dcd8ea8f9220256a737e2b810", "target": 1, "func": "void ppc_slb_invalidate_all (CPUPPCState *env)\n\n{\n\n    target_phys_addr_t sr_base;\n\n    uint64_t tmp64;\n\n    int n, do_invalidate;\n\n\n\n    do_invalidate = 0;\n\n    sr_base = env->spr[SPR_ASR];\n\n    for (n = 0; n < env->slb_nr; n++) {\n\n        tmp64 = ldq_phys(sr_base);\n\n        if (slb_is_valid(tmp64)) {\n\n            slb_invalidate(&tmp64);\n\n            stq_phys(sr_base, tmp64);\n\n            /* XXX: given the fact that segment size is 256 MB or 1TB,\n\n             *      and we still don't have a tlb_flush_mask(env, n, mask)\n\n             *      in Qemu, we just invalidate all TLBs\n\n             */\n\n            do_invalidate = 1;\n\n        }\n\n        sr_base += 12;\n\n    }\n\n    if (do_invalidate)\n\n        tlb_flush(env, 1);\n\n}\n", "idx": 1072}
{"project": "qemu", "commit_id": "cd072e01d86b3d7adab35de03d242e3938e798df", "target": 1, "func": "static inline void validate_seg(int seg_reg, int cpl)\n\n{\n\n    int dpl;\n\n    uint32_t e2;\n\n    \n\n    e2 = env->segs[seg_reg].flags;\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (!(e2 & DESC_CS_MASK) || !(e2 & DESC_C_MASK)) {\n\n        /* data or non conforming code segment */\n\n        if (dpl < cpl) {\n\n            cpu_x86_load_seg_cache(env, seg_reg, 0, 0, 0, 0);\n\n        }\n\n    }\n\n}\n", "idx": 11948}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static inline void read_mem(IVState *s, uint64_t off, void *buf, size_t len)\n\n{\n\n    QTestState *qtest = global_qtest;\n\n\n\n    global_qtest = s->qtest;\n\n    qpci_memread(s->dev, s->mem_base + off, buf, len);\n\n    global_qtest = qtest;\n\n}\n", "idx": 7416}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int get_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[10];\n\n    uint8_t buf[8];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = READ_CAPACITY;\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0)\n\n        return -1;\n\n\n\n    return (buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7];\n\n}\n", "idx": 224}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void via_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = vt82c686b_initfn;\n\n    k->config_write = vt82c686b_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_VIA;\n\n    k->device_id = PCI_DEVICE_ID_VIA_ISA_BRIDGE;\n\n    k->class_id = PCI_CLASS_BRIDGE_ISA;\n\n    k->revision = 0x40;\n\n    dc->desc = \"ISA bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_via;\n\n}\n", "idx": 9429}
{"project": "qemu", "commit_id": "f4a769abaa51badea666093077c50c568c35de17", "target": 1, "func": "static int64_t coroutine_fn raw_co_get_block_status(BlockDriverState *bs,\n\n                                                    int64_t sector_num,\n\n                                                    int nb_sectors, int *pnum)\n\n{\n\n    off_t start, data = 0, hole = 0;\n\n    int64_t total_size;\n\n    int ret;\n\n\n\n    ret = fd_open(bs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    start = sector_num * BDRV_SECTOR_SIZE;\n\n    total_size = bdrv_getlength(bs);\n\n    if (total_size < 0) {\n\n        return total_size;\n\n    } else if (start >= total_size) {\n\n        *pnum = 0;\n\n        return 0;\n\n    } else if (start + nb_sectors * BDRV_SECTOR_SIZE > total_size) {\n\n        nb_sectors = DIV_ROUND_UP(total_size - start, BDRV_SECTOR_SIZE);\n\n    }\n\n\n\n    ret = find_allocation(bs, start, &data, &hole);\n\n    if (ret == -ENXIO) {\n\n        /* Trailing hole */\n\n        *pnum = nb_sectors;\n\n        ret = BDRV_BLOCK_ZERO;\n\n    } else if (ret < 0) {\n\n        /* No info available, so pretend there are no holes */\n\n        *pnum = nb_sectors;\n\n        ret = BDRV_BLOCK_DATA;\n\n    } else if (data == start) {\n\n        /* On a data extent, compute sectors to the end of the extent.  */\n\n        *pnum = MIN(nb_sectors, (hole - start) / BDRV_SECTOR_SIZE);\n\n        ret = BDRV_BLOCK_DATA;\n\n    } else {\n\n        /* On a hole, compute sectors to the beginning of the next extent.  */\n\n        assert(hole == start);\n\n        *pnum = MIN(nb_sectors, (data - start) / BDRV_SECTOR_SIZE);\n\n        ret = BDRV_BLOCK_ZERO;\n\n    }\n\n    return ret | BDRV_BLOCK_OFFSET_VALID | start;\n\n}\n", "idx": 1374}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power8nvl_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER8NVL\";\n\n    k->chip_type = PNV_CHIP_POWER8NVL;\n\n    k->chip_cfam_id = 0x120d304980000000ull;  /* P8 Naples DD1.0 */\n\n    k->cores_mask = POWER8_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p8;\n\n\n    dc->desc = \"PowerNV Chip POWER8NVL\";\n\n}", "idx": 2728}
{"project": "qemu", "commit_id": "f41152bd9d01ab327c19a3828bb7896d67cf0752", "target": 1, "func": "milkymist_init(QEMUMachineInitArgs *args)\n{\n    const char *cpu_model = args->cpu_model;\n    const char *kernel_filename = args->kernel_filename;\n    const char *kernel_cmdline = args->kernel_cmdline;\n    const char *initrd_filename = args->initrd_filename;\n    LM32CPU *cpu;\n    CPULM32State *env;\n    int kernel_size;\n    DriveInfo *dinfo;\n    MemoryRegion *address_space_mem = get_system_memory();\n    MemoryRegion *phys_sdram = g_new(MemoryRegion, 1);\n    qemu_irq irq[32], *cpu_irq;\n    int i;\n    char *bios_filename;\n    ResetInfo *reset_info;\n    /* memory map */\n    hwaddr flash_base   = 0x00000000;\n    size_t flash_sector_size        = 128 * 1024;\n    size_t flash_size               = 32 * 1024 * 1024;\n    hwaddr sdram_base   = 0x40000000;\n    size_t sdram_size               = 128 * 1024 * 1024;\n    hwaddr initrd_base  = sdram_base + 0x1002000;\n    hwaddr cmdline_base = sdram_base + 0x1000000;\n    size_t initrd_max = sdram_size - 0x1002000;\n    reset_info = g_malloc0(sizeof(ResetInfo));\n    if (cpu_model == NULL) {\n        cpu_model = \"lm32-full\";\n    cpu = cpu_lm32_init(cpu_model);\n    env = &cpu->env;\n    reset_info->cpu = cpu;\n    cpu_lm32_set_phys_msb_ignore(env, 1);\n    memory_region_init_ram(phys_sdram, NULL, \"milkymist.sdram\", sdram_size);\n    vmstate_register_ram_global(phys_sdram);\n    memory_region_add_subregion(address_space_mem, sdram_base, phys_sdram);\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n    /* Numonyx JS28F256J3F105 */\n    pflash_cfi01_register(flash_base, NULL, \"milkymist.flash\", flash_size,\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n                          flash_size / flash_sector_size, 2,\n                          0x00, 0x89, 0x00, 0x1d, 1);\n    /* create irq lines */\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, cpu, 1);\n    env->pic_state = lm32_pic_init(*cpu_irq);\n    for (i = 0; i < 32; i++) {\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n    /* load bios rom */\n    if (bios_name == NULL) {\n        bios_name = BIOS_FILENAME;\n    bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n    if (bios_filename) {\n        load_image_targphys(bios_filename, BIOS_OFFSET, BIOS_SIZE);\n    reset_info->bootstrap_pc = BIOS_OFFSET;\n    /* if no kernel is given no valid bios rom is a fatal error */\n    if (!kernel_filename && !dinfo && !bios_filename && !qtest_enabled()) {\n        fprintf(stderr, \"qemu: could not load Milkymist One bios '%s'\\n\",\n                bios_name);\n    milkymist_uart_create(0x60000000, irq[0]);\n    milkymist_sysctl_create(0x60001000, irq[1], irq[2], irq[3],\n            80000000, 0x10014d31, 0x0000041f, 0x00000001);\n    milkymist_hpdmc_create(0x60002000);\n    milkymist_vgafb_create(0x60003000, 0x40000000, 0x0fffffff);\n    milkymist_memcard_create(0x60004000);\n    milkymist_ac97_create(0x60005000, irq[4], irq[5], irq[6], irq[7]);\n    milkymist_pfpu_create(0x60006000, irq[8]);\n    milkymist_tmu2_create(0x60007000, irq[9]);\n    milkymist_minimac2_create(0x60008000, 0x30000000, irq[10], irq[11]);\n    milkymist_softusb_create(0x6000f000, irq[15],\n            0x20000000, 0x1000, 0x20020000, 0x2000);\n    /* make sure juart isn't the first chardev */\n    env->juart_state = lm32_juart_init();\n    if (kernel_filename) {\n        uint64_t entry;\n        /* Boots a kernel elf binary.  */\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n                               1, ELF_MACHINE, 0);\n        reset_info->bootstrap_pc = entry;\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename, sdram_base,\n                                              sdram_size);\n            reset_info->bootstrap_pc = sdram_base;\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n                kernel_cmdline);\n        reset_info->cmdline_base = (uint32_t)cmdline_base;\n    if (initrd_filename) {\n        size_t initrd_size;\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                initrd_max);\n        reset_info->initrd_base = (uint32_t)initrd_base;\n        reset_info->initrd_size = (uint32_t)initrd_size;\n    qemu_register_reset(main_cpu_reset, reset_info);", "idx": 4590}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7941}
{"project": "qemu", "commit_id": "180ca19ae02be70f9b158bfd7dec1ff123b9cf8c", "target": 1, "func": "static int bdrv_open_driver(BlockDriverState *bs, BlockDriver *drv,\n\n                            const char *node_name, QDict *options,\n\n                            int open_flags, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    bdrv_assign_node_name(bs, node_name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return -EINVAL;\n\n    }\n\n\n\n    bs->drv = drv;\n\n    bs->read_only = !(bs->open_flags & BDRV_O_RDWR);\n\n    bs->opaque = g_malloc0(drv->instance_size);\n\n\n\n    if (drv->bdrv_file_open) {\n\n        assert(!drv->bdrv_needs_filename || bs->filename[0]);\n\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n\n    } else if (drv->bdrv_open) {\n\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n\n    } else {\n\n        ret = 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n        } else if (bs->filename[0]) {\n\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n\n        } else {\n\n            error_setg_errno(errp, -ret, \"Could not open image\");\n\n        }\n\n        goto free_and_fail;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        goto free_and_fail;\n\n    }\n\n\n\n    bdrv_refresh_limits(bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto free_and_fail;\n\n    }\n\n\n\n    assert(bdrv_opt_mem_align(bs) != 0);\n\n    assert(bdrv_min_mem_align(bs) != 0);\n\n    assert(is_power_of_2(bs->bl.request_alignment));\n\n\n\n    return 0;\n\n\n\nfree_and_fail:\n\n    /* FIXME Close bs first if already opened*/\n\n    g_free(bs->opaque);\n\n    bs->opaque = NULL;\n\n    bs->drv = NULL;\n\n    return ret;\n\n}\n", "idx": 1206}
{"project": "qemu", "commit_id": "19ebd13ed45ad5d5f277f5914d55b83f13eb09eb", "target": 1, "func": "static void commit_complete(BlockJob *job, void *opaque)\n{\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n    CommitCompleteData *data = opaque;\n    BlockDriverState *active = s->active;\n    BlockDriverState *top = blk_bs(s->top);\n    BlockDriverState *base = blk_bs(s->base);\n    BlockDriverState *overlay_bs = bdrv_find_overlay(active, s->commit_top_bs);\n    int ret = data->ret;\n    bool remove_commit_top_bs = false;\n    /* Make sure overlay_bs and top stay around until bdrv_set_backing_hd() */\n    bdrv_ref(top);\n    bdrv_ref(overlay_bs);\n    /* Remove base node parent that still uses BLK_PERM_WRITE/RESIZE before\n     * the normal backing chain can be restored. */\n    blk_unref(s->base);\n    if (!block_job_is_cancelled(&s->common) && ret == 0) {\n        /* success */\n        ret = bdrv_drop_intermediate(active, s->commit_top_bs, base,\n                                     s->backing_file_str);\n    } else if (overlay_bs) {\n        /* XXX Can (or should) we somehow keep 'consistent read' blocked even\n         * after the failed/cancelled commit job is gone? If we already wrote\n         * something to base, the intermediate images aren't valid any more. */\n        remove_commit_top_bs = true;\n    }\n    /* restore base open flags here if appropriate (e.g., change the base back\n     * to r/o). These reopens do not need to be atomic, since we won't abort\n     * even on failure here */\n    if (s->base_flags != bdrv_get_flags(base)) {\n        bdrv_reopen(base, s->base_flags, NULL);\n    }\n    if (overlay_bs && s->orig_overlay_flags != bdrv_get_flags(overlay_bs)) {\n        bdrv_reopen(overlay_bs, s->orig_overlay_flags, NULL);\n    }\n    g_free(s->backing_file_str);\n    blk_unref(s->top);\n    block_job_completed(&s->common, ret);\n    g_free(data);\n    /* If bdrv_drop_intermediate() didn't already do that, remove the commit\n     * filter driver from the backing chain. Do this as the final step so that\n     * the 'consistent read' permission can be granted.  */\n    if (remove_commit_top_bs) {\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n    }\n}", "idx": 2482}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 4413}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int qcow_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, shift, ret;\n\n    QCowHeader header;\n\n\n\n    ret = bdrv_file_open(&s->hd, filename, flags | BDRV_O_AUTOGROW);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (bdrv_pread(s->hd, 0, &header, sizeof(header)) != sizeof(header))\n\n        goto fail;\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC || header.version != QCOW_VERSION)\n\n        goto fail;\n\n    if (header.size <= 1 ||\n\n        header.cluster_bits < 9 ||\n\n        header.cluster_bits > 16)\n\n        goto fail;\n\n    if (header.crypt_method > QCOW_CRYPT_AES)\n\n        goto fail;\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header)\n\n        bs->encrypted = 1;\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    /* read the level 1 table */\n\n    s->l1_size = header.l1_size;\n\n    shift = s->cluster_bits + s->l2_bits;\n\n    s->l1_vm_state_index = (header.size + (1LL << shift) - 1) >> shift;\n\n    /* the L1 table must contain at least enough entries to put\n\n       header.size bytes */\n\n    if (s->l1_size < s->l1_vm_state_index)\n\n        goto fail;\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    s->l1_table = qemu_malloc(s->l1_size * sizeof(uint64_t));\n\n    if (!s->l1_table)\n\n        goto fail;\n\n    if (bdrv_pread(s->hd, s->l1_table_offset, s->l1_table, s->l1_size * sizeof(uint64_t)) !=\n\n        s->l1_size * sizeof(uint64_t))\n\n        goto fail;\n\n    for(i = 0;i < s->l1_size; i++) {\n\n        be64_to_cpus(&s->l1_table[i]);\n\n    }\n\n    /* alloc L2 cache */\n\n    s->l2_cache = qemu_malloc(s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n\n    if (!s->l2_cache)\n\n        goto fail;\n\n    s->cluster_cache = qemu_malloc(s->cluster_size);\n\n    if (!s->cluster_cache)\n\n        goto fail;\n\n    /* one more sector for decompressed data alignment */\n\n    s->cluster_data = qemu_malloc(s->cluster_size + 512);\n\n    if (!s->cluster_data)\n\n        goto fail;\n\n    s->cluster_cache_offset = -1;\n\n\n\n    if (refcount_init(bs) < 0)\n\n        goto fail;\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023)\n\n            len = 1023;\n\n        if (bdrv_pread(s->hd, header.backing_file_offset, bs->backing_file, len) != len)\n\n            goto fail;\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n    if (qcow_read_snapshots(bs) < 0)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ALLOC\n\n    check_refcounts(bs);\n\n#endif\n\n    return 0;\n\n\n\n fail:\n\n    qcow_free_snapshots(bs);\n\n    refcount_close(bs);\n\n    qemu_free(s->l1_table);\n\n    qemu_free(s->l2_cache);\n\n    qemu_free(s->cluster_cache);\n\n    qemu_free(s->cluster_data);\n\n    bdrv_delete(s->hd);\n\n    return -1;\n\n}\n", "idx": 12158}
{"project": "qemu", "commit_id": "c47ee043dc2cc85da710e87524144a720598c096", "target": 1, "func": "void blk_eject(BlockBackend *blk, bool eject_flag)\n\n{\n\n    BlockDriverState *bs = blk_bs(blk);\n\n    char *id;\n\n\n\n    /* blk_eject is only called by qdevified devices */\n\n    assert(!blk->legacy_dev);\n\n\n\n    if (bs) {\n\n        bdrv_eject(bs, eject_flag);\n\n\n\n        id = blk_get_attached_dev_id(blk);\n\n        qapi_event_send_device_tray_moved(blk_name(blk), id,\n\n                                          eject_flag, &error_abort);\n\n        g_free(id);\n\n\n\n    }\n\n}\n", "idx": 9778}
{"project": "qemu", "commit_id": "98448f58c10033a0f7fcd0673cce4626506403fa", "target": 1, "func": "int load_elf_binary(struct linux_binprm * bprm, struct target_pt_regs * regs,\n\n                    struct image_info * info)\n\n{\n\n    struct elfhdr elf_ex;\n\n    struct elfhdr interp_elf_ex;\n\n    struct exec interp_ex;\n\n    int interpreter_fd = -1; /* avoid warning */\n\n    abi_ulong load_addr, load_bias;\n\n    int load_addr_set = 0;\n\n    unsigned int interpreter_type = INTERPRETER_NONE;\n\n    unsigned char ibcs2_interpreter;\n\n    int i;\n\n    abi_ulong mapped_addr;\n\n    struct elf_phdr * elf_ppnt;\n\n    struct elf_phdr *elf_phdata;\n\n    abi_ulong elf_bss, k, elf_brk;\n\n    int retval;\n\n    char * elf_interpreter;\n\n    abi_ulong elf_entry, interp_load_addr = 0;\n\n    int status;\n\n    abi_ulong start_code, end_code, start_data, end_data;\n\n    abi_ulong reloc_func_desc = 0;\n\n    abi_ulong elf_stack;\n\n    char passed_fileno[6];\n\n\n\n    ibcs2_interpreter = 0;\n\n    status = 0;\n\n    load_addr = 0;\n\n    load_bias = 0;\n\n    elf_ex = *((struct elfhdr *) bprm->buf);          /* exec-header */\n\n#ifdef BSWAP_NEEDED\n\n    bswap_ehdr(&elf_ex);\n\n#endif\n\n\n\n    /* First of all, some simple consistency checks */\n\n    if ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\n\n       \t\t\t\t(! elf_check_arch(elf_ex.e_machine))) {\n\n\t    return -ENOEXEC;\n\n    }\n\n\n\n    bprm->p = copy_elf_strings(1, &bprm->filename, bprm->page, bprm->p);\n\n    bprm->p = copy_elf_strings(bprm->envc,bprm->envp,bprm->page,bprm->p);\n\n    bprm->p = copy_elf_strings(bprm->argc,bprm->argv,bprm->page,bprm->p);\n\n    if (!bprm->p) {\n\n        retval = -E2BIG;\n\n    }\n\n\n\n    /* Now read in all of the header information */\n\n    elf_phdata = (struct elf_phdr *)malloc(elf_ex.e_phentsize*elf_ex.e_phnum);\n\n    if (elf_phdata == NULL) {\n\n\treturn -ENOMEM;\n\n    }\n\n\n\n    retval = lseek(bprm->fd, elf_ex.e_phoff, SEEK_SET);\n\n    if(retval > 0) {\n\n\tretval = read(bprm->fd, (char *) elf_phdata,\n\n\t\t\t\telf_ex.e_phentsize * elf_ex.e_phnum);\n\n    }\n\n\n\n    if (retval < 0) {\n\n\tperror(\"load_elf_binary\");\n\n\texit(-1);\n\n\tfree (elf_phdata);\n\n\treturn -errno;\n\n    }\n\n\n\n#ifdef BSWAP_NEEDED\n\n    elf_ppnt = elf_phdata;\n\n    for (i=0; i<elf_ex.e_phnum; i++, elf_ppnt++) {\n\n        bswap_phdr(elf_ppnt);\n\n    }\n\n#endif\n\n    elf_ppnt = elf_phdata;\n\n\n\n    elf_bss = 0;\n\n    elf_brk = 0;\n\n\n\n\n\n    elf_stack = ~((abi_ulong)0UL);\n\n    elf_interpreter = NULL;\n\n    start_code = ~((abi_ulong)0UL);\n\n    end_code = 0;\n\n    start_data = 0;\n\n    end_data = 0;\n\n\n\n\n    for(i=0;i < elf_ex.e_phnum; i++) {\n\n\tif (elf_ppnt->p_type == PT_INTERP) {\n\n\t    if ( elf_interpreter != NULL )\n\n\t    {\n\n\t\tfree (elf_phdata);\n\n\t\tfree(elf_interpreter);\n\n\t\tclose(bprm->fd);\n\n\t\treturn -EINVAL;\n\n\t    }\n\n\n\n\t    /* This is the program interpreter used for\n\n\t     * shared libraries - for now assume that this\n\n\t     * is an a.out format binary\n\n\t     */\n\n\n\n\t    elf_interpreter = (char *)malloc(elf_ppnt->p_filesz);\n\n\n\n\t    if (elf_interpreter == NULL) {\n\n\t\tfree (elf_phdata);\n\n\t\tclose(bprm->fd);\n\n\t\treturn -ENOMEM;\n\n\t    }\n\n\n\n\t    retval = lseek(bprm->fd, elf_ppnt->p_offset, SEEK_SET);\n\n\t    if(retval >= 0) {\n\n\t\tretval = read(bprm->fd, elf_interpreter, elf_ppnt->p_filesz);\n\n\t    }\n\n\t    if(retval < 0) {\n\n\t \tperror(\"load_elf_binary2\");\n\n\t\texit(-1);\n\n\t    }\n\n\n\n\t    /* If the program interpreter is one of these two,\n\n\t       then assume an iBCS2 image. Otherwise assume\n\n\t       a native linux image. */\n\n\n\n\t    /* JRP - Need to add X86 lib dir stuff here... */\n\n\n\n\t    if (strcmp(elf_interpreter,\"/usr/lib/libc.so.1\") == 0 ||\n\n\t\tstrcmp(elf_interpreter,\"/usr/lib/ld.so.1\") == 0) {\n\n\t      ibcs2_interpreter = 1;\n\n\t    }\n\n\n\n#if 0\n\n\t    printf(\"Using ELF interpreter %s\\n\", elf_interpreter);\n\n#endif\n\n\t    if (retval >= 0) {\n\n\t\tretval = open(path(elf_interpreter), O_RDONLY);\n\n\t\tif(retval >= 0) {\n\n\t\t    interpreter_fd = retval;\n\n\t\t}\n\n\t\telse {\n\n\t\t    perror(elf_interpreter);\n\n\t\t    exit(-1);\n\n\t\t    /* retval = -errno; */\n\n\t\t}\n\n\t    }\n\n\n\n\t    if (retval >= 0) {\n\n\t\tretval = lseek(interpreter_fd, 0, SEEK_SET);\n\n\t\tif(retval >= 0) {\n\n\t\t    retval = read(interpreter_fd,bprm->buf,128);\n\n\t\t}\n\n\t    }\n\n\t    if (retval >= 0) {\n\n\t\tinterp_ex = *((struct exec *) bprm->buf); /* aout exec-header */\n\n\t\tinterp_elf_ex=*((struct elfhdr *) bprm->buf); /* elf exec-header */\n\n\t    }\n\n\t    if (retval < 0) {\n\n\t\tperror(\"load_elf_binary3\");\n\n\t\texit(-1);\n\n\t\tfree (elf_phdata);\n\n\t\tfree(elf_interpreter);\n\n\t\tclose(bprm->fd);\n\n\t\treturn retval;\n\n\t    }\n\n\t}\n\n\telf_ppnt++;\n\n    }\n\n\n\n    /* Some simple consistency checks for the interpreter */\n\n    if (elf_interpreter){\n\n\tinterpreter_type = INTERPRETER_ELF | INTERPRETER_AOUT;\n\n\n\n\t/* Now figure out which format our binary is */\n\n\tif ((N_MAGIC(interp_ex) != OMAGIC) && (N_MAGIC(interp_ex) != ZMAGIC) &&\n\n\t    \t(N_MAGIC(interp_ex) != QMAGIC)) {\n\n\t  interpreter_type = INTERPRETER_ELF;\n\n\t}\n\n\n\n\tif (interp_elf_ex.e_ident[0] != 0x7f ||\n\n            strncmp((char *)&interp_elf_ex.e_ident[1], \"ELF\",3) != 0) {\n\n\t    interpreter_type &= ~INTERPRETER_ELF;\n\n\t}\n\n\n\n\tif (!interpreter_type) {\n\n\t    free(elf_interpreter);\n\n\t    free(elf_phdata);\n\n\t    close(bprm->fd);\n\n\t    return -ELIBBAD;\n\n\t}\n\n    }\n\n\n\n    /* OK, we are done with that, now set up the arg stuff,\n\n       and then start this sucker up */\n\n\n\n    {\n\n\tchar * passed_p;\n\n\n\n\tif (interpreter_type == INTERPRETER_AOUT) {\n\n\t    snprintf(passed_fileno, sizeof(passed_fileno), \"%d\", bprm->fd);\n\n\t    passed_p = passed_fileno;\n\n\n\n\t    if (elf_interpreter) {\n\n\t\tbprm->p = copy_elf_strings(1,&passed_p,bprm->page,bprm->p);\n\n\t\tbprm->argc++;\n\n\t    }\n\n\t}\n\n\tif (!bprm->p) {\n\n\t    if (elf_interpreter) {\n\n\t        free(elf_interpreter);\n\n\t    }\n\n\t    free (elf_phdata);\n\n\t    close(bprm->fd);\n\n\t    return -E2BIG;\n\n\t}\n\n    }\n\n\n\n    /* OK, This is the point of no return */\n\n    info->end_data = 0;\n\n    info->end_code = 0;\n\n    info->start_mmap = (abi_ulong)ELF_START_MMAP;\n\n    info->mmap = 0;\n\n    elf_entry = (abi_ulong) elf_ex.e_entry;\n\n\n\n    /* Do this so that we can load the interpreter, if need be.  We will\n\n       change some of these later */\n\n    info->rss = 0;\n\n    bprm->p = setup_arg_pages(bprm->p, bprm, info);\n\n    info->start_stack = bprm->p;\n\n\n\n    /* Now we do a little grungy work by mmaping the ELF image into\n\n     * the correct location in memory.  At this point, we assume that\n\n     * the image should be loaded at fixed address, not at a variable\n\n     * address.\n\n     */\n\n\n\n    for(i = 0, elf_ppnt = elf_phdata; i < elf_ex.e_phnum; i++, elf_ppnt++) {\n\n        int elf_prot = 0;\n\n        int elf_flags = 0;\n\n        abi_ulong error;\n\n\n\n\tif (elf_ppnt->p_type != PT_LOAD)\n\n            continue;\n\n\n\n        if (elf_ppnt->p_flags & PF_R) elf_prot |= PROT_READ;\n\n        if (elf_ppnt->p_flags & PF_W) elf_prot |= PROT_WRITE;\n\n        if (elf_ppnt->p_flags & PF_X) elf_prot |= PROT_EXEC;\n\n        elf_flags = MAP_PRIVATE | MAP_DENYWRITE;\n\n        if (elf_ex.e_type == ET_EXEC || load_addr_set) {\n\n            elf_flags |= MAP_FIXED;\n\n        } else if (elf_ex.e_type == ET_DYN) {\n\n            /* Try and get dynamic programs out of the way of the default mmap\n\n               base, as well as whatever program they might try to exec.  This\n\n               is because the brk will follow the loader, and is not movable.  */\n\n            /* NOTE: for qemu, we do a big mmap to get enough space\n\n               without hardcoding any address */\n\n            error = target_mmap(0, ET_DYN_MAP_SIZE,\n\n                                PROT_NONE, MAP_PRIVATE | MAP_ANON,\n\n                                -1, 0);\n\n            if (error == -1) {\n\n                perror(\"mmap\");\n\n                exit(-1);\n\n            }\n\n            load_bias = TARGET_ELF_PAGESTART(error - elf_ppnt->p_vaddr);\n\n        }\n\n\n\n        error = target_mmap(TARGET_ELF_PAGESTART(load_bias + elf_ppnt->p_vaddr),\n\n                            (elf_ppnt->p_filesz +\n\n                             TARGET_ELF_PAGEOFFSET(elf_ppnt->p_vaddr)),\n\n                            elf_prot,\n\n                            (MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE),\n\n                            bprm->fd,\n\n                            (elf_ppnt->p_offset -\n\n                             TARGET_ELF_PAGEOFFSET(elf_ppnt->p_vaddr)));\n\n        if (error == -1) {\n\n            perror(\"mmap\");\n\n            exit(-1);\n\n        }\n\n\n\n#ifdef LOW_ELF_STACK\n\n        if (TARGET_ELF_PAGESTART(elf_ppnt->p_vaddr) < elf_stack)\n\n            elf_stack = TARGET_ELF_PAGESTART(elf_ppnt->p_vaddr);\n\n#endif\n\n\n\n        if (!load_addr_set) {\n\n            load_addr_set = 1;\n\n            load_addr = elf_ppnt->p_vaddr - elf_ppnt->p_offset;\n\n            if (elf_ex.e_type == ET_DYN) {\n\n                load_bias += error -\n\n                    TARGET_ELF_PAGESTART(load_bias + elf_ppnt->p_vaddr);\n\n                load_addr += load_bias;\n\n                reloc_func_desc = load_bias;\n\n            }\n\n        }\n\n        k = elf_ppnt->p_vaddr;\n\n        if (k < start_code)\n\n            start_code = k;\n\n        if (start_data < k)\n\n            start_data = k;\n\n        k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n        if (k > elf_bss)\n\n            elf_bss = k;\n\n        if ((elf_ppnt->p_flags & PF_X) && end_code <  k)\n\n            end_code = k;\n\n        if (end_data < k)\n\n            end_data = k;\n\n        k = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\n        if (k > elf_brk) elf_brk = k;\n\n    }\n\n\n\n    elf_entry += load_bias;\n\n    elf_bss += load_bias;\n\n    elf_brk += load_bias;\n\n    start_code += load_bias;\n\n    end_code += load_bias;\n\n    start_data += load_bias;\n\n    end_data += load_bias;\n\n\n\n    if (elf_interpreter) {\n\n\tif (interpreter_type & 1) {\n\n\t    elf_entry = load_aout_interp(&interp_ex, interpreter_fd);\n\n\t}\n\n\telse if (interpreter_type & 2) {\n\n\t    elf_entry = load_elf_interp(&interp_elf_ex, interpreter_fd,\n\n\t\t\t\t\t    &interp_load_addr);\n\n\t}\n\n        reloc_func_desc = interp_load_addr;\n\n\n\n\tclose(interpreter_fd);\n\n\tfree(elf_interpreter);\n\n\n\n\tif (elf_entry == ~((abi_ulong)0UL)) {\n\n\t    printf(\"Unable to load interpreter\\n\");\n\n\t    free(elf_phdata);\n\n\t    exit(-1);\n\n\t    return 0;\n\n\t}\n\n    }\n\n\n\n    free(elf_phdata);\n\n\n\n    if (loglevel)\n\n\tload_symbols(&elf_ex, bprm->fd);\n\n\n\n    if (interpreter_type != INTERPRETER_AOUT) close(bprm->fd);\n\n    info->personality = (ibcs2_interpreter ? PER_SVR4 : PER_LINUX);\n\n\n\n#ifdef LOW_ELF_STACK\n\n    info->start_stack = bprm->p = elf_stack - 4;\n\n#endif\n\n    bprm->p = create_elf_tables(bprm->p,\n\n\t\t    bprm->argc,\n\n\t\t    bprm->envc,\n\n                    &elf_ex,\n\n                    load_addr, load_bias,\n\n\t\t    interp_load_addr,\n\n\t\t    (interpreter_type == INTERPRETER_AOUT ? 0 : 1),\n\n\t\t    info);\n\n    info->load_addr = reloc_func_desc;\n\n    info->start_brk = info->brk = elf_brk;\n\n    info->end_code = end_code;\n\n    info->start_code = start_code;\n\n    info->start_data = start_data;\n\n    info->end_data = end_data;\n\n    info->start_stack = bprm->p;\n\n\n\n    /* Calling set_brk effectively mmaps the pages that we need for the bss and break\n\n       sections */\n\n    set_brk(elf_bss, elf_brk);\n\n\n\n    padzero(elf_bss, elf_brk);\n\n\n\n#if 0\n\n    printf(\"(start_brk) %x\\n\" , info->start_brk);\n\n    printf(\"(end_code) %x\\n\" , info->end_code);\n\n    printf(\"(start_code) %x\\n\" , info->start_code);\n\n    printf(\"(end_data) %x\\n\" , info->end_data);\n\n    printf(\"(start_stack) %x\\n\" , info->start_stack);\n\n    printf(\"(brk) %x\\n\" , info->brk);\n\n#endif\n\n\n\n    if ( info->personality == PER_SVR4 )\n\n    {\n\n\t    /* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\n\t       and some applications \"depend\" upon this behavior.\n\n\t       Since we do not have the power to recompile these, we\n\n\t       emulate the SVr4 behavior.  Sigh.  */\n\n\t    mapped_addr = target_mmap(0, qemu_host_page_size, PROT_READ | PROT_EXEC,\n\n                                      MAP_FIXED | MAP_PRIVATE, -1, 0);\n\n    }\n\n\n\n    info->entry = elf_entry;\n\n\n\n    return 0;\n\n}", "idx": 8901}
{"project": "qemu", "commit_id": "66a08cbe6ad1aebec8eecf58b3ba042e19dd1649", "target": 1, "func": "static void uhci_process_frame(UHCIState *s)\n\n{\n\n    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;\n\n    uint32_t curr_qh, td_count = 0;\n\n    int cnt, ret;\n\n    UHCI_TD td;\n\n    UHCI_QH qh;\n\n    QhDb qhdb;\n\n\n\n    frame_addr = s->fl_base_addr + ((s->frnum & 0x3ff) << 2);\n\n\n\n    pci_dma_read(&s->dev, frame_addr, &link, 4);\n\n    le32_to_cpus(&link);\n\n\n\n    int_mask = 0;\n\n    curr_qh  = 0;\n\n\n\n    qhdb_reset(&qhdb);\n\n\n\n    for (cnt = FRAME_MAX_LOOPS; is_valid(link) && cnt; cnt--) {\n\n        if (s->frame_bytes >= s->frame_bandwidth) {\n\n            /* We've reached the usb 1.1 bandwidth, which is\n\n               1280 bytes/frame, stop processing */\n\n            trace_usb_uhci_frame_stop_bandwidth();\n\n            break;\n\n        }\n\n        if (is_qh(link)) {\n\n            /* QH */\n\n            trace_usb_uhci_qh_load(link & ~0xf);\n\n\n\n            if (qhdb_insert(&qhdb, link)) {\n\n                /*\n\n                 * We're going in circles. Which is not a bug because\n\n                 * HCD is allowed to do that as part of the BW management.\n\n                 *\n\n                 * Stop processing here if no transaction has been done\n\n                 * since we've been here last time.\n\n                 */\n\n                if (td_count == 0) {\n\n                    trace_usb_uhci_frame_loop_stop_idle();\n\n                    break;\n\n                } else {\n\n                    trace_usb_uhci_frame_loop_continue();\n\n                    td_count = 0;\n\n                    qhdb_reset(&qhdb);\n\n                    qhdb_insert(&qhdb, link);\n\n                }\n\n            }\n\n\n\n            pci_dma_read(&s->dev, link & ~0xf, &qh, sizeof(qh));\n\n            le32_to_cpus(&qh.link);\n\n            le32_to_cpus(&qh.el_link);\n\n\n\n            if (!is_valid(qh.el_link)) {\n\n                /* QH w/o elements */\n\n                curr_qh = 0;\n\n                link = qh.link;\n\n            } else {\n\n                /* QH with elements */\n\n            \tcurr_qh = link;\n\n            \tlink = qh.el_link;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        /* TD */\n\n        uhci_read_td(s, &td, link);\n\n        trace_usb_uhci_td_load(curr_qh & ~0xf, link & ~0xf, td.ctrl, td.token);\n\n\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, NULL, &td, link, &int_mask);\n\n        if (old_td_ctrl != td.ctrl) {\n\n            /* update the status bits of the TD */\n\n            val = cpu_to_le32(td.ctrl);\n\n            pci_dma_write(&s->dev, (link & ~0xf) + 4, &val, sizeof(val));\n\n        }\n\n\n\n        switch (ret) {\n\n        case TD_RESULT_STOP_FRAME: /* interrupted frame */\n\n            goto out;\n\n\n\n        case TD_RESULT_NEXT_QH:\n\n        case TD_RESULT_ASYNC_CONT:\n\n            trace_usb_uhci_td_nextqh(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_ASYNC_START:\n\n            trace_usb_uhci_td_async(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_COMPLETE:\n\n            trace_usb_uhci_td_complete(curr_qh & ~0xf, link & ~0xf);\n\n            link = td.link;\n\n            td_count++;\n\n            s->frame_bytes += (td.ctrl & 0x7ff) + 1;\n\n\n\n            if (curr_qh) {\n\n                /* update QH element link */\n\n                qh.el_link = link;\n\n                val = cpu_to_le32(qh.el_link);\n\n                pci_dma_write(&s->dev, (curr_qh & ~0xf) + 4, &val, sizeof(val));\n\n\n\n                if (!depth_first(link)) {\n\n                    /* done with this QH */\n\n                    curr_qh = 0;\n\n                    link    = qh.link;\n\n                }\n\n            }\n\n            break;\n\n\n\n        default:\n\n            assert(!\"unknown return code\");\n\n        }\n\n\n\n        /* go to the next entry */\n\n    }\n\n\n\nout:\n\n    s->pending_int_mask |= int_mask;\n\n}\n", "idx": 2065}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static ssize_t write_console_data(SCLPEvent *event, const uint8_t *buf,\n\n                                  size_t len)\n\n{\n\n    SCLPConsole *scon = SCLP_CONSOLE(event);\n\n\n\n    if (!scon->chr) {\n\n        /* If there's no backend, we can just say we consumed all data. */\n\n        return len;\n\n    }\n\n\n\n\n\n    return qemu_chr_fe_write_all(scon->chr, buf, len);\n\n}", "idx": 10099}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void test_yield(void)\n\n{\n\n    Coroutine *coroutine;\n\n    bool done = false;\n\n    int i = -1; /* one extra time to return from coroutine */\n\n\n\n    coroutine = qemu_coroutine_create(yield_5_times);\n\n    while (!done) {\n\n        qemu_coroutine_enter(coroutine, &done);\n\n        i++;\n\n    }\n\n    g_assert_cmpint(i, ==, 5); /* coroutine must yield 5 times */\n\n}\n", "idx": 2901}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static qemu_irq *vpb_sic_init(uint32_t base, qemu_irq *parent, int irq)\n\n{\n\n    vpb_sic_state *s;\n\n    qemu_irq *qi;\n\n    int iomemtype;\n\n\n\n    s = (vpb_sic_state *)qemu_mallocz(sizeof(vpb_sic_state));\n\n    if (!s)\n\n        return NULL;\n\n    qi = qemu_allocate_irqs(vpb_sic_set_irq, s, 32);\n\n    s->base = base;\n\n    s->parent = parent;\n\n    s->irq = irq;\n\n    iomemtype = cpu_register_io_memory(0, vpb_sic_readfn,\n\n                                       vpb_sic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    /* ??? Save/restore.  */\n\n    return qi;\n\n}\n", "idx": 4817}
{"project": "qemu", "commit_id": "639973a4740f38789057744b550df3a175bc49ad", "target": 1, "func": "static int assigned_device_pci_cap_init(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);\n\n    PCIRegion *pci_region = dev->real_device.regions;\n\n    int ret, pos;\n\n    Error *local_err = NULL;\n\n\n\n    /* Clear initial capabilities pointer and status copied from hw */\n\n    pci_set_byte(pci_dev->config + PCI_CAPABILITY_LIST, 0);\n\n    pci_set_word(pci_dev->config + PCI_STATUS,\n\n                 pci_get_word(pci_dev->config + PCI_STATUS) &\n\n                 ~PCI_STATUS_CAP_LIST);\n\n\n\n    /* Expose MSI capability\n\n     * MSI capability is the 1st capability in capability config */\n\n    pos = pci_find_cap_offset(pci_dev, PCI_CAP_ID_MSI, 0);\n\n    if (pos != 0 && kvm_check_extension(kvm_state, KVM_CAP_ASSIGN_DEV_IRQ)) {\n\n        verify_irqchip_in_kernel(&local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return -ENOTSUP;\n\n        }\n\n        dev->cap.available |= ASSIGNED_DEVICE_CAP_MSI;\n\n        /* Only 32-bit/no-mask currently supported */\n\n        ret = pci_add_capability2(pci_dev, PCI_CAP_ID_MSI, pos, 10,\n\n                                  &local_err);\n\n        if (ret < 0) {\n\n            error_propagate(errp, local_err);\n\n            return ret;\n\n        }\n\n        pci_dev->msi_cap = pos;\n\n\n\n        pci_set_word(pci_dev->config + pos + PCI_MSI_FLAGS,\n\n                     pci_get_word(pci_dev->config + pos + PCI_MSI_FLAGS) &\n\n                     PCI_MSI_FLAGS_QMASK);\n\n        pci_set_long(pci_dev->config + pos + PCI_MSI_ADDRESS_LO, 0);\n\n        pci_set_word(pci_dev->config + pos + PCI_MSI_DATA_32, 0);\n\n\n\n        /* Set writable fields */\n\n        pci_set_word(pci_dev->wmask + pos + PCI_MSI_FLAGS,\n\n                     PCI_MSI_FLAGS_QSIZE | PCI_MSI_FLAGS_ENABLE);\n\n        pci_set_long(pci_dev->wmask + pos + PCI_MSI_ADDRESS_LO, 0xfffffffc);\n\n        pci_set_word(pci_dev->wmask + pos + PCI_MSI_DATA_32, 0xffff);\n\n    }\n\n    /* Expose MSI-X capability */\n\n    pos = pci_find_cap_offset(pci_dev, PCI_CAP_ID_MSIX, 0);\n\n    if (pos != 0 && kvm_device_msix_supported(kvm_state)) {\n\n        int bar_nr;\n\n        uint32_t msix_table_entry;\n\n\n\n        verify_irqchip_in_kernel(&local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return -ENOTSUP;\n\n        }\n\n        dev->cap.available |= ASSIGNED_DEVICE_CAP_MSIX;\n\n        ret = pci_add_capability2(pci_dev, PCI_CAP_ID_MSIX, pos, 12,\n\n                                  &local_err);\n\n        if (ret < 0) {\n\n            error_propagate(errp, local_err);\n\n            return ret;\n\n        }\n\n        pci_dev->msix_cap = pos;\n\n\n\n        pci_set_word(pci_dev->config + pos + PCI_MSIX_FLAGS,\n\n                     pci_get_word(pci_dev->config + pos + PCI_MSIX_FLAGS) &\n\n                     PCI_MSIX_FLAGS_QSIZE);\n\n\n\n        /* Only enable and function mask bits are writable */\n\n        pci_set_word(pci_dev->wmask + pos + PCI_MSIX_FLAGS,\n\n                     PCI_MSIX_FLAGS_ENABLE | PCI_MSIX_FLAGS_MASKALL);\n\n\n\n        msix_table_entry = pci_get_long(pci_dev->config + pos + PCI_MSIX_TABLE);\n\n        bar_nr = msix_table_entry & PCI_MSIX_FLAGS_BIRMASK;\n\n        msix_table_entry &= ~PCI_MSIX_FLAGS_BIRMASK;\n\n        dev->msix_table_addr = pci_region[bar_nr].base_addr + msix_table_entry;\n\n        dev->msix_max = pci_get_word(pci_dev->config + pos + PCI_MSIX_FLAGS);\n\n        dev->msix_max &= PCI_MSIX_FLAGS_QSIZE;\n\n        dev->msix_max += 1;\n\n    }\n\n\n\n    /* Minimal PM support, nothing writable, device appears to NAK changes */\n\n    pos = pci_find_cap_offset(pci_dev, PCI_CAP_ID_PM, 0);\n\n    if (pos) {\n\n        uint16_t pmc;\n\n\n\n        ret = pci_add_capability2(pci_dev, PCI_CAP_ID_PM, pos, PCI_PM_SIZEOF,\n\n                                  &local_err);\n\n        if (ret < 0) {\n\n            error_propagate(errp, local_err);\n\n            return ret;\n\n        }\n\n\n\n        assigned_dev_setup_cap_read(dev, pos, PCI_PM_SIZEOF);\n\n\n\n        pmc = pci_get_word(pci_dev->config + pos + PCI_CAP_FLAGS);\n\n        pmc &= (PCI_PM_CAP_VER_MASK | PCI_PM_CAP_DSI);\n\n        pci_set_word(pci_dev->config + pos + PCI_CAP_FLAGS, pmc);\n\n\n\n        /* assign_device will bring the device up to D0, so we don't need\n\n         * to worry about doing that ourselves here. */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_CTRL,\n\n                     PCI_PM_CTRL_NO_SOFT_RESET);\n\n\n\n        pci_set_byte(pci_dev->config + pos + PCI_PM_PPB_EXTENSIONS, 0);\n\n        pci_set_byte(pci_dev->config + pos + PCI_PM_DATA_REGISTER, 0);\n\n    }\n\n\n\n    pos = pci_find_cap_offset(pci_dev, PCI_CAP_ID_EXP, 0);\n\n    if (pos) {\n\n        uint8_t version, size = 0;\n\n        uint16_t type, devctl, lnksta;\n\n        uint32_t devcap, lnkcap;\n\n\n\n        version = pci_get_byte(pci_dev->config + pos + PCI_EXP_FLAGS);\n\n        version &= PCI_EXP_FLAGS_VERS;\n\n        if (version == 1) {\n\n            size = 0x14;\n\n        } else if (version == 2) {\n\n            /*\n\n             * Check for non-std size, accept reduced size to 0x34,\n\n             * which is what bcm5761 implemented, violating the\n\n             * PCIe v3.0 spec that regs should exist and be read as 0,\n\n             * not optionally provided and shorten the struct size.\n\n             */\n\n            size = MIN(0x3c, PCI_CONFIG_SPACE_SIZE - pos);\n\n            if (size < 0x34) {\n\n                error_setg(errp, \"Invalid size PCIe cap-id 0x%x\",\n\n                           PCI_CAP_ID_EXP);\n\n                return -EINVAL;\n\n            } else if (size != 0x3c) {\n\n                error_report(\"WARNING, %s: PCIe cap-id 0x%x has \"\n\n                             \"non-standard size 0x%x; std size should be 0x3c\",\n\n                             __func__, PCI_CAP_ID_EXP, size);\n\n            }\n\n        } else if (version == 0) {\n\n            uint16_t vid, did;\n\n            vid = pci_get_word(pci_dev->config + PCI_VENDOR_ID);\n\n            did = pci_get_word(pci_dev->config + PCI_DEVICE_ID);\n\n            if (vid == PCI_VENDOR_ID_INTEL && did == 0x10ed) {\n\n                /*\n\n                 * quirk for Intel 82599 VF with invalid PCIe capability\n\n                 * version, should really be version 2 (same as PF)\n\n                 */\n\n                size = 0x3c;\n\n            }\n\n        }\n\n\n\n        if (size == 0) {\n\n            error_setg(errp, \"Unsupported PCI express capability version %d\",\n\n                       version);\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = pci_add_capability2(pci_dev, PCI_CAP_ID_EXP, pos, size,\n\n                                  &local_err);\n\n        if (ret < 0) {\n\n            error_propagate(errp, local_err);\n\n            return ret;\n\n        }\n\n\n\n        assigned_dev_setup_cap_read(dev, pos, size);\n\n\n\n        type = pci_get_word(pci_dev->config + pos + PCI_EXP_FLAGS);\n\n        type = (type & PCI_EXP_FLAGS_TYPE) >> 4;\n\n        if (type != PCI_EXP_TYPE_ENDPOINT &&\n\n            type != PCI_EXP_TYPE_LEG_END && type != PCI_EXP_TYPE_RC_END) {\n\n            error_setg(errp, \"Device assignment only supports endpoint \"\n\n                       \"assignment, device type %d\", type);\n\n            return -EINVAL;\n\n        }\n\n\n\n        /* capabilities, pass existing read-only copy\n\n         * PCI_EXP_FLAGS_IRQ: updated by hardware, should be direct read */\n\n\n\n        /* device capabilities: hide FLR */\n\n        devcap = pci_get_long(pci_dev->config + pos + PCI_EXP_DEVCAP);\n\n        devcap &= ~PCI_EXP_DEVCAP_FLR;\n\n        pci_set_long(pci_dev->config + pos + PCI_EXP_DEVCAP, devcap);\n\n\n\n        /* device control: clear all error reporting enable bits, leaving\n\n         *                 only a few host values.  Note, these are\n\n         *                 all writable, but not passed to hw.\n\n         */\n\n        devctl = pci_get_word(pci_dev->config + pos + PCI_EXP_DEVCTL);\n\n        devctl = (devctl & (PCI_EXP_DEVCTL_READRQ | PCI_EXP_DEVCTL_PAYLOAD)) |\n\n                  PCI_EXP_DEVCTL_RELAX_EN | PCI_EXP_DEVCTL_NOSNOOP_EN;\n\n        pci_set_word(pci_dev->config + pos + PCI_EXP_DEVCTL, devctl);\n\n        devctl = PCI_EXP_DEVCTL_BCR_FLR | PCI_EXP_DEVCTL_AUX_PME;\n\n        pci_set_word(pci_dev->wmask + pos + PCI_EXP_DEVCTL, ~devctl);\n\n\n\n        /* Clear device status */\n\n        pci_set_word(pci_dev->config + pos + PCI_EXP_DEVSTA, 0);\n\n\n\n        /* Link capabilities, expose links and latencues, clear reporting */\n\n        lnkcap = pci_get_long(pci_dev->config + pos + PCI_EXP_LNKCAP);\n\n        lnkcap &= (PCI_EXP_LNKCAP_SLS | PCI_EXP_LNKCAP_MLW |\n\n                   PCI_EXP_LNKCAP_ASPMS | PCI_EXP_LNKCAP_L0SEL |\n\n                   PCI_EXP_LNKCAP_L1EL);\n\n        pci_set_long(pci_dev->config + pos + PCI_EXP_LNKCAP, lnkcap);\n\n\n\n        /* Link control, pass existing read-only copy.  Should be writable? */\n\n\n\n        /* Link status, only expose current speed and width */\n\n        lnksta = pci_get_word(pci_dev->config + pos + PCI_EXP_LNKSTA);\n\n        lnksta &= (PCI_EXP_LNKSTA_CLS | PCI_EXP_LNKSTA_NLW);\n\n        pci_set_word(pci_dev->config + pos + PCI_EXP_LNKSTA, lnksta);\n\n\n\n        if (version >= 2) {\n\n            /* Slot capabilities, control, status - not needed for endpoints */\n\n            pci_set_long(pci_dev->config + pos + PCI_EXP_SLTCAP, 0);\n\n            pci_set_word(pci_dev->config + pos + PCI_EXP_SLTCTL, 0);\n\n            pci_set_word(pci_dev->config + pos + PCI_EXP_SLTSTA, 0);\n\n\n\n            /* Root control, capabilities, status - not needed for endpoints */\n\n            pci_set_word(pci_dev->config + pos + PCI_EXP_RTCTL, 0);\n\n            pci_set_word(pci_dev->config + pos + PCI_EXP_RTCAP, 0);\n\n            pci_set_long(pci_dev->config + pos + PCI_EXP_RTSTA, 0);\n\n\n\n            /* Device capabilities/control 2, pass existing read-only copy */\n\n            /* Link control 2, pass existing read-only copy */\n\n        }\n\n    }\n\n\n\n    pos = pci_find_cap_offset(pci_dev, PCI_CAP_ID_PCIX, 0);\n\n    if (pos) {\n\n        uint16_t cmd;\n\n        uint32_t status;\n\n\n\n        /* Only expose the minimum, 8 byte capability */\n\n        ret = pci_add_capability2(pci_dev, PCI_CAP_ID_PCIX, pos, 8,\n\n                                  &local_err);\n\n        if (ret < 0) {\n\n            error_propagate(errp, local_err);\n\n            return ret;\n\n        }\n\n\n\n        assigned_dev_setup_cap_read(dev, pos, 8);\n\n\n\n        /* Command register, clear upper bits, including extended modes */\n\n        cmd = pci_get_word(pci_dev->config + pos + PCI_X_CMD);\n\n        cmd &= (PCI_X_CMD_DPERR_E | PCI_X_CMD_ERO | PCI_X_CMD_MAX_READ |\n\n                PCI_X_CMD_MAX_SPLIT);\n\n        pci_set_word(pci_dev->config + pos + PCI_X_CMD, cmd);\n\n\n\n        /* Status register, update with emulated PCI bus location, clear\n\n         * error bits, leave the rest. */\n\n        status = pci_get_long(pci_dev->config + pos + PCI_X_STATUS);\n\n        status &= ~(PCI_X_STATUS_BUS | PCI_X_STATUS_DEVFN);\n\n        status |= (pci_bus_num(pci_dev->bus) << 8) | pci_dev->devfn;\n\n        status &= ~(PCI_X_STATUS_SPL_DISC | PCI_X_STATUS_UNX_SPL |\n\n                    PCI_X_STATUS_SPL_ERR);\n\n        pci_set_long(pci_dev->config + pos + PCI_X_STATUS, status);\n\n    }\n\n\n\n    pos = pci_find_cap_offset(pci_dev, PCI_CAP_ID_VPD, 0);\n\n    if (pos) {\n\n        /* Direct R/W passthrough */\n\n        ret = pci_add_capability2(pci_dev, PCI_CAP_ID_VPD, pos, 8,\n\n                                  &local_err);\n\n        if (ret < 0) {\n\n            error_propagate(errp, local_err);\n\n            return ret;\n\n        }\n\n\n\n        assigned_dev_setup_cap_read(dev, pos, 8);\n\n\n\n        /* direct write for cap content */\n\n        assigned_dev_direct_config_write(dev, pos + 2, 6);\n\n    }\n\n\n\n    /* Devices can have multiple vendor capabilities, get them all */\n\n    for (pos = 0; (pos = pci_find_cap_offset(pci_dev, PCI_CAP_ID_VNDR, pos));\n\n        pos += PCI_CAP_LIST_NEXT) {\n\n        uint8_t len = pci_get_byte(pci_dev->config + pos + PCI_CAP_FLAGS);\n\n        /* Direct R/W passthrough */\n\n        ret = pci_add_capability2(pci_dev, PCI_CAP_ID_VNDR, pos, len,\n\n                                  &local_err);\n\n        if (ret < 0) {\n\n            error_propagate(errp, local_err);\n\n            return ret;\n\n        }\n\n\n\n        assigned_dev_setup_cap_read(dev, pos, len);\n\n\n\n        /* direct write for cap content */\n\n        assigned_dev_direct_config_write(dev, pos + 2, len - 2);\n\n    }\n\n\n\n    /* If real and virtual capability list status bits differ, virtualize the\n\n     * access. */\n\n    if ((pci_get_word(pci_dev->config + PCI_STATUS) & PCI_STATUS_CAP_LIST) !=\n\n        (assigned_dev_pci_read_byte(pci_dev, PCI_STATUS) &\n\n         PCI_STATUS_CAP_LIST)) {\n\n        dev->emulate_config_read[PCI_STATUS] |= PCI_STATUS_CAP_LIST;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5211}
{"project": "qemu", "commit_id": "40f16dd1279e7f26357b3c4b3838a89ffc6153da", "target": 1, "func": "static void scsi_read_complete(void * opaque, int ret)\n\n{\n\n    SCSIGenericReq *r = (SCSIGenericReq *)opaque;\n\n    int len;\n\n\n\n    if (ret) {\n\n        DPRINTF(\"IO error ret %d\\n\", ret);\n\n        scsi_command_complete(r, ret);\n\n        return;\n\n    }\n\n    len = r->io_header.dxfer_len - r->io_header.resid;\n\n    DPRINTF(\"Data ready tag=0x%x len=%d\\n\", r->req.tag, len);\n\n\n\n    r->len = -1;\n\n    r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, len);\n\n    if (len == 0)\n\n        scsi_command_complete(r, 0);\n\n}\n", "idx": 8308}
{"project": "qemu", "commit_id": "9db51b4d64ded01536b3851a5a50e484ac2f7899", "target": 1, "func": "static void close_peer_eventfds(IVShmemState *s, int posn)\n\n{\n\n    int i, n;\n\n\n\n    if (!ivshmem_has_feature(s, IVSHMEM_IOEVENTFD)) {\n\n        return;\n\n    }\n\n    if (posn < 0 || posn >= s->nb_peers) {\n\n        error_report(\"invalid peer %d\", posn);\n\n        return;\n\n    }\n\n\n\n    n = s->peers[posn].nb_eventfds;\n\n\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < n; i++) {\n\n        ivshmem_del_eventfd(s, posn, i);\n\n    }\n\n    memory_region_transaction_commit();\n\n    for (i = 0; i < n; i++) {\n\n        event_notifier_cleanup(&s->peers[posn].eventfds[i]);\n\n    }\n\n\n\n    g_free(s->peers[posn].eventfds);\n\n    s->peers[posn].nb_eventfds = 0;\n\n}\n", "idx": 3598}
{"project": "qemu", "commit_id": "5cb9b56acfc0b50acf7ccd2d044ab4991c47fdde", "target": 1, "func": "static int parse_int32(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    int32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    char *end;\n\n\n\n    *ptr = strtol(str, &end, 10);\n\n    if ((*end != '\\0') || (end == str)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6582}
{"project": "qemu", "commit_id": "5d6c599fe1d69a1bf8c5c4d3c58be2b31cd625ad", "target": 1, "func": "void qmp_xen_save_devices_state(const char *filename, Error **errp)\n\n{\n\n    QEMUFile *f;\n\n    QIOChannelFile *ioc;\n\n    int saved_vm_running;\n\n    int ret;\n\n\n\n    saved_vm_running = runstate_is_running();\n\n    vm_stop(RUN_STATE_SAVE_VM);\n\n    global_state_store_running();\n\n\n\n    ioc = qio_channel_file_new_path(filename, O_WRONLY | O_CREAT, 0660, errp);\n\n    if (!ioc) {\n\n        goto the_end;\n\n    }\n\n    qio_channel_set_name(QIO_CHANNEL(ioc), \"migration-xen-save-state\");\n\n    f = qemu_fopen_channel_output(QIO_CHANNEL(ioc));\n\n    ret = qemu_save_device_state(f);\n\n    qemu_fclose(f);\n\n    if (ret < 0) {\n\n        error_setg(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n the_end:\n\n    if (saved_vm_running) {\n\n        vm_start();\n\n    }\n\n}\n", "idx": 8213}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 7379}
{"project": "qemu", "commit_id": "04097f7c5957273c578f72b9bd603ba6b1d69e33", "target": 1, "func": "static void vhost_client_set_memory(CPUPhysMemoryClient *client,\n\n                                    target_phys_addr_t start_addr,\n\n                                    ram_addr_t size,\n\n                                    ram_addr_t phys_offset,\n\n                                    bool log_dirty)\n\n{\n\n    struct vhost_dev *dev = container_of(client, struct vhost_dev, client);\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    int s = offsetof(struct vhost_memory, regions) +\n\n        (dev->mem->nregions + 1) * sizeof dev->mem->regions[0];\n\n    uint64_t log_size;\n\n    int r;\n\n\n\n    dev->mem = g_realloc(dev->mem, s);\n\n\n\n    if (log_dirty) {\n\n        flags = IO_MEM_UNASSIGNED;\n\n    }\n\n\n\n    assert(size);\n\n\n\n    /* Optimize no-change case. At least cirrus_vga does this a lot at this time. */\n\n    if (flags == IO_MEM_RAM) {\n\n        if (!vhost_dev_cmp_memory(dev, start_addr, size,\n\n                                  (uintptr_t)qemu_get_ram_ptr(phys_offset))) {\n\n            /* Region exists with same address. Nothing to do. */\n\n            return;\n\n        }\n\n    } else {\n\n        if (!vhost_dev_find_reg(dev, start_addr, size)) {\n\n            /* Removing region that we don't access. Nothing to do. */\n\n            return;\n\n        }\n\n    }\n\n\n\n    vhost_dev_unassign_memory(dev, start_addr, size);\n\n    if (flags == IO_MEM_RAM) {\n\n        /* Add given mapping, merging adjacent regions if any */\n\n        vhost_dev_assign_memory(dev, start_addr, size,\n\n                                (uintptr_t)qemu_get_ram_ptr(phys_offset));\n\n    } else {\n\n        /* Remove old mapping for this memory, if any. */\n\n        vhost_dev_unassign_memory(dev, start_addr, size);\n\n    }\n\n\n\n    if (!dev->started) {\n\n        return;\n\n    }\n\n\n\n    if (dev->started) {\n\n        r = vhost_verify_ring_mappings(dev, start_addr, size);\n\n        assert(r >= 0);\n\n    }\n\n\n\n    if (!dev->log_enabled) {\n\n        r = ioctl(dev->control, VHOST_SET_MEM_TABLE, dev->mem);\n\n        assert(r >= 0);\n\n        return;\n\n    }\n\n    log_size = vhost_get_log_size(dev);\n\n    /* We allocate an extra 4K bytes to log,\n\n     * to reduce the * number of reallocations. */\n\n#define VHOST_LOG_BUFFER (0x1000 / sizeof *dev->log)\n\n    /* To log more, must increase log size before table update. */\n\n    if (dev->log_size < log_size) {\n\n        vhost_dev_log_resize(dev, log_size + VHOST_LOG_BUFFER);\n\n    }\n\n    r = ioctl(dev->control, VHOST_SET_MEM_TABLE, dev->mem);\n\n    assert(r >= 0);\n\n    /* To log less, can only decrease log size after table update. */\n\n    if (dev->log_size > log_size + VHOST_LOG_BUFFER) {\n\n        vhost_dev_log_resize(dev, log_size);\n\n    }\n\n}\n", "idx": 792}
{"project": "qemu", "commit_id": "e7c8526b2a1482a9b14319fda9f8ad4bfda5b958", "target": 1, "func": "void ahci_hba_enable(AHCIQState *ahci)\n\n{\n\n    /* Bits of interest in this section:\n\n     * GHC.AE     Global Host Control / AHCI Enable\n\n     * PxCMD.ST   Port Command: Start\n\n     * PxCMD.SUD  \"Spin Up Device\"\n\n     * PxCMD.POD  \"Power On Device\"\n\n     * PxCMD.FRE  \"FIS Receive Enable\"\n\n     * PxCMD.FR   \"FIS Receive Running\"\n\n     * PxCMD.CR   \"Command List Running\"\n\n     */\n\n    uint32_t reg, ports_impl;\n\n    uint16_t i;\n\n    uint8_t num_cmd_slots;\n\n\n\n    g_assert(ahci != NULL);\n\n\n\n    /* Set GHC.AE to 1 */\n\n    ahci_set(ahci, AHCI_GHC, AHCI_GHC_AE);\n\n    reg = ahci_rreg(ahci, AHCI_GHC);\n\n    ASSERT_BIT_SET(reg, AHCI_GHC_AE);\n\n\n\n    /* Cache CAP and CAP2. */\n\n    ahci->cap = ahci_rreg(ahci, AHCI_CAP);\n\n    ahci->cap2 = ahci_rreg(ahci, AHCI_CAP2);\n\n\n\n    /* Read CAP.NCS, how many command slots do we have? */\n\n    num_cmd_slots = ((ahci->cap & AHCI_CAP_NCS) >> ctzl(AHCI_CAP_NCS)) + 1;\n\n    g_test_message(\"Number of Command Slots: %u\", num_cmd_slots);\n\n\n\n    /* Determine which ports are implemented. */\n\n    ports_impl = ahci_rreg(ahci, AHCI_PI);\n\n\n\n    for (i = 0; ports_impl; ports_impl >>= 1, ++i) {\n\n        if (!(ports_impl & 0x01)) {\n\n            continue;\n\n        }\n\n\n\n        g_test_message(\"Initializing port %u\", i);\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n        if (BITCLR(reg, AHCI_PX_CMD_ST | AHCI_PX_CMD_CR |\n\n                   AHCI_PX_CMD_FRE | AHCI_PX_CMD_FR)) {\n\n            g_test_message(\"port is idle\");\n\n        } else {\n\n            g_test_message(\"port needs to be idled\");\n\n            ahci_px_clr(ahci, i, AHCI_PX_CMD,\n\n                        (AHCI_PX_CMD_ST | AHCI_PX_CMD_FRE));\n\n            /* The port has 500ms to disengage. */\n\n            usleep(500000);\n\n            reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n            ASSERT_BIT_CLEAR(reg, AHCI_PX_CMD_CR);\n\n            ASSERT_BIT_CLEAR(reg, AHCI_PX_CMD_FR);\n\n            g_test_message(\"port is now idle\");\n\n            /* The spec does allow for possibly needing a PORT RESET\n\n             * or HBA reset if we fail to idle the port. */\n\n        }\n\n\n\n        /* Allocate Memory for the Command List Buffer & FIS Buffer */\n\n        /* PxCLB space ... 0x20 per command, as in 4.2.2 p 36 */\n\n        ahci->port[i].clb = ahci_alloc(ahci, num_cmd_slots * 0x20);\n\n        qmemset(ahci->port[i].clb, 0x00, num_cmd_slots * 0x20);\n\n        g_test_message(\"CLB: 0x%08\" PRIx64, ahci->port[i].clb);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_CLB, ahci->port[i].clb);\n\n        g_assert_cmphex(ahci->port[i].clb, ==,\n\n                        ahci_px_rreg(ahci, i, AHCI_PX_CLB));\n\n\n\n        /* PxFB space ... 0x100, as in 4.2.1 p 35 */\n\n        ahci->port[i].fb = ahci_alloc(ahci, 0x100);\n\n        qmemset(ahci->port[i].fb, 0x00, 0x100);\n\n        g_test_message(\"FB: 0x%08\" PRIx64, ahci->port[i].fb);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_FB, ahci->port[i].fb);\n\n        g_assert_cmphex(ahci->port[i].fb, ==,\n\n                        ahci_px_rreg(ahci, i, AHCI_PX_FB));\n\n\n\n        /* Clear PxSERR, PxIS, then IS.IPS[x] by writing '1's. */\n\n        ahci_px_wreg(ahci, i, AHCI_PX_SERR, 0xFFFFFFFF);\n\n        ahci_px_wreg(ahci, i, AHCI_PX_IS, 0xFFFFFFFF);\n\n        ahci_wreg(ahci, AHCI_IS, (1 << i));\n\n\n\n        /* Verify Interrupts Cleared */\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_SERR);\n\n        g_assert_cmphex(reg, ==, 0);\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_IS);\n\n        g_assert_cmphex(reg, ==, 0);\n\n\n\n        reg = ahci_rreg(ahci, AHCI_IS);\n\n        ASSERT_BIT_CLEAR(reg, (1 << i));\n\n\n\n        /* Enable All Interrupts: */\n\n        ahci_px_wreg(ahci, i, AHCI_PX_IE, 0xFFFFFFFF);\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_IE);\n\n        g_assert_cmphex(reg, ==, ~((uint32_t)AHCI_PX_IE_RESERVED));\n\n\n\n        /* Enable the FIS Receive Engine. */\n\n        ahci_px_set(ahci, i, AHCI_PX_CMD, AHCI_PX_CMD_FRE);\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_CMD);\n\n        ASSERT_BIT_SET(reg, AHCI_PX_CMD_FR);\n\n\n\n        /* AHCI 1.3 spec: if !STS.BSY, !STS.DRQ and PxSSTS.DET indicates\n\n         * physical presence, a device is present and may be started. However,\n\n         * PxSERR.DIAG.X /may/ need to be cleared a priori. */\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_SERR);\n\n        if (BITSET(reg, AHCI_PX_SERR_DIAG_X)) {\n\n            ahci_px_set(ahci, i, AHCI_PX_SERR, AHCI_PX_SERR_DIAG_X);\n\n        }\n\n\n\n        reg = ahci_px_rreg(ahci, i, AHCI_PX_TFD);\n\n        if (BITCLR(reg, AHCI_PX_TFD_STS_BSY | AHCI_PX_TFD_STS_DRQ)) {\n\n            reg = ahci_px_rreg(ahci, i, AHCI_PX_SSTS);\n\n            if ((reg & AHCI_PX_SSTS_DET) == SSTS_DET_ESTABLISHED) {\n\n                /* Device Found: set PxCMD.ST := 1 */\n\n                ahci_px_set(ahci, i, AHCI_PX_CMD, AHCI_PX_CMD_ST);\n\n                ASSERT_BIT_SET(ahci_px_rreg(ahci, i, AHCI_PX_CMD),\n\n                               AHCI_PX_CMD_CR);\n\n                g_test_message(\"Started Device %u\", i);\n\n            } else if ((reg & AHCI_PX_SSTS_DET)) {\n\n                /* Device present, but in some unknown state. */\n\n                g_assert_not_reached();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* Enable GHC.IE */\n\n    ahci_set(ahci, AHCI_GHC, AHCI_GHC_IE);\n\n    reg = ahci_rreg(ahci, AHCI_GHC);\n\n    ASSERT_BIT_SET(reg, AHCI_GHC_IE);\n\n\n\n\n    /* TODO: The device should now be idling and waiting for commands.\n\n     * In the future, a small test-case to inspect the Register D2H FIS\n\n     * and clear the initial interrupts might be good. */\n\n}", "idx": 1172}
{"project": "qemu", "commit_id": "6c352ca9b4ee3e1e286ea9e8434bd8e69ac7d0d8", "target": 1, "func": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n{\n    VMXNET3State *s = opaque;\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                        VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n        int tx_queue_idx =\n            VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_TXPROD,\n                                     VMXNET3_REG_ALIGN);\n        assert(tx_queue_idx <= s->txq_num);\n        vmxnet3_process_tx_queue(s, tx_queue_idx);\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);", "idx": 8889}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void shifter_out_im(TCGv var, int shift)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    if (shift == 0) {\n\n        tcg_gen_andi_i32(tmp, var, 1);\n\n    } else {\n\n        tcg_gen_shri_i32(tmp, var, shift);\n\n        if (shift != 31)\n\n            tcg_gen_andi_i32(tmp, tmp, 1);\n\n    }\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 11691}
{"project": "qemu", "commit_id": "f38b5b7fc4e27724afc72b91efa2bc82f84bb25e", "target": 1, "func": "static bool s390_gen_initial_iplb(S390IPLState *ipl)\n{\n    DeviceState *dev_st;\n    dev_st = get_boot_device(0);\n    if (dev_st) {\n        VirtioCcwDevice *virtio_ccw_dev = (VirtioCcwDevice *)\n            object_dynamic_cast(OBJECT(qdev_get_parent_bus(dev_st)->parent),\n                TYPE_VIRTIO_CCW_DEVICE);\n        SCSIDevice *sd = (SCSIDevice *) object_dynamic_cast(OBJECT(dev_st),\n                                                            TYPE_SCSI_DEVICE);\n        if (virtio_ccw_dev) {\n            CcwDevice *ccw_dev = CCW_DEVICE(virtio_ccw_dev);\n            ipl->iplb.len = cpu_to_be32(S390_IPLB_MIN_CCW_LEN);\n            ipl->iplb.blk0_len =\n                cpu_to_be32(S390_IPLB_MIN_CCW_LEN - S390_IPLB_HEADER_LEN);\n            ipl->iplb.pbt = S390_IPL_TYPE_CCW;\n            ipl->iplb.ccw.devno = cpu_to_be16(ccw_dev->sch->devno);\n            ipl->iplb.ccw.ssid = ccw_dev->sch->ssid & 3;\n            return true;\n        } else if (sd) {\n            SCSIBus *bus = scsi_bus_from_device(sd);\n            VirtIOSCSI *vdev = container_of(bus, VirtIOSCSI, bus);\n            VirtIOSCSICcw *scsi_ccw = container_of(vdev, VirtIOSCSICcw, vdev);\n            CcwDevice *ccw_dev = CCW_DEVICE(scsi_ccw);\n            ipl->iplb.len = cpu_to_be32(S390_IPLB_MIN_QEMU_SCSI_LEN);\n            ipl->iplb.blk0_len =\n                cpu_to_be32(S390_IPLB_MIN_QEMU_SCSI_LEN - S390_IPLB_HEADER_LEN);\n            ipl->iplb.pbt = S390_IPL_TYPE_QEMU_SCSI;\n            ipl->iplb.scsi.lun = cpu_to_be32(sd->lun);\n            ipl->iplb.scsi.target = cpu_to_be16(sd->id);\n            ipl->iplb.scsi.channel = cpu_to_be16(sd->channel);\n            ipl->iplb.scsi.devno = cpu_to_be16(ccw_dev->sch->devno);\n            ipl->iplb.scsi.ssid = ccw_dev->sch->ssid & 3;\n            return true;\n    return false;", "idx": 5105}
{"project": "qemu", "commit_id": "01fb2705bd19a6e9c1207446793064dbd141df5f", "target": 1, "func": "int coroutine_fn bdrv_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                                   int nb_sectors, int *pnum)\n\n{\n\n    int64_t ret = bdrv_get_block_status(bs, sector_num, nb_sectors, pnum);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return (ret & BDRV_BLOCK_ALLOCATED);\n\n}\n", "idx": 11228}
{"project": "qemu", "commit_id": "c9ad19c57b4e35dda507ec636443069048a4ad72", "target": 1, "func": "void helper_fxtract(void)\n\n{\n\n    CPU86_LDoubleU temp;\n\n    unsigned int expdif;\n\n\n\n    temp.d = ST0;\n\n    expdif = EXPD(temp) - EXPBIAS;\n\n    /*DP exponent bias*/\n\n    ST0 = expdif;\n\n    fpush();\n\n    BIASEXPONENT(temp);\n\n    ST0 = temp.d;\n\n}\n", "idx": 24}
{"project": "qemu", "commit_id": "4f2d31fbc0bfdf41feea7d1be49f4f7ffa005534", "target": 1, "func": "static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count > MAX_NESTING ||\n\n               parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /* clear out token list and tell the parser to emit and error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 11936}
{"project": "qemu", "commit_id": "43d70ddf9f96b3ad037abe4d5f9f2768196b8c92", "target": 1, "func": "static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,\n\n                                    TranslationBlock **last_tb, int *tb_exit,\n\n                                    SyncClocks *sc)\n\n{\n\n    uintptr_t ret;\n\n\n\n    if (unlikely(atomic_read(&cpu->exit_request))) {\n\n        return;\n\n    }\n\n\n\n    trace_exec_tb(tb, tb->pc);\n\n    ret = cpu_tb_exec(cpu, tb);\n\n    *last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n\n    *tb_exit = ret & TB_EXIT_MASK;\n\n    switch (*tb_exit) {\n\n    case TB_EXIT_REQUESTED:\n\n        /* Something asked us to stop executing\n\n         * chained TBs; just continue round the main\n\n         * loop. Whatever requested the exit will also\n\n         * have set something else (eg exit_request or\n\n         * interrupt_request) which we will handle\n\n         * next time around the loop.  But we need to\n\n         * ensure the tcg_exit_req read in generated code\n\n         * comes before the next read of cpu->exit_request\n\n         * or cpu->interrupt_request.\n\n         */\n\n        smp_rmb();\n\n        *last_tb = NULL;\n\n        break;\n\n    case TB_EXIT_ICOUNT_EXPIRED:\n\n    {\n\n        /* Instruction counter expired.  */\n\n#ifdef CONFIG_USER_ONLY\n\n        abort();\n\n#else\n\n        int insns_left = cpu->icount_decr.u32;\n\n        if (cpu->icount_extra && insns_left >= 0) {\n\n            /* Refill decrementer and continue execution.  */\n\n            cpu->icount_extra += insns_left;\n\n            insns_left = MIN(0xffff, cpu->icount_extra);\n\n            cpu->icount_extra -= insns_left;\n\n            cpu->icount_decr.u16.low = insns_left;\n\n        } else {\n\n            if (insns_left > 0) {\n\n                /* Execute remaining instructions.  */\n\n                cpu_exec_nocache(cpu, insns_left, *last_tb, false);\n\n                align_clocks(sc, cpu);\n\n            }\n\n            cpu->exception_index = EXCP_INTERRUPT;\n\n            *last_tb = NULL;\n\n            cpu_loop_exit(cpu);\n\n        }\n\n        break;\n\n#endif\n\n    }\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 4734}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power9_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER9\";\n\n    k->chip_type = PNV_CHIP_POWER9;\n\n    k->chip_cfam_id = 0x100d104980000000ull; /* P9 Nimbus DD1.0 */\n\n    k->cores_mask = POWER9_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p9;\n\n\n    dc->desc = \"PowerNV Chip POWER9\";\n\n}", "idx": 8583}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    /* We only advertise 1 auth scheme at a time, so client\n\n     * must pick the one we sent. Verify this */\n\n    if (data[0] != vs->auth) { /* Reject auth */\n\n       VNC_DEBUG(\"Reject auth %d because it didn't match advertized\\n\", (int)data[0]);\n\n       vnc_write_u32(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Authentication failed\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    } else { /* Accept requested auth */\n\n       VNC_DEBUG(\"Client requested auth %d\\n\", (int)data[0]);\n\n       switch (vs->auth) {\n\n       case VNC_AUTH_NONE:\n\n           VNC_DEBUG(\"Accept auth none\\n\");\n\n           if (vs->minor >= 8) {\n\n               vnc_write_u32(vs, 0); /* Accept auth completion */\n\n               vnc_flush(vs);\n\n           }\n\n           start_client_init(vs);\n\n           break;\n\n\n\n       case VNC_AUTH_VNC:\n\n           VNC_DEBUG(\"Start VNC auth\\n\");\n\n           start_auth_vnc(vs);\n\n           break;\n\n\n\n       case VNC_AUTH_VENCRYPT:\n\n           VNC_DEBUG(\"Accept VeNCrypt auth\\n\");\n\n           start_auth_vencrypt(vs);\n\n           break;\n\n\n\n#ifdef CONFIG_VNC_SASL\n\n       case VNC_AUTH_SASL:\n\n           VNC_DEBUG(\"Accept SASL auth\\n\");\n\n           start_auth_sasl(vs);\n\n           break;\n\n#endif /* CONFIG_VNC_SASL */\n\n\n\n       default: /* Should not be possible, but just in case */\n\n           VNC_DEBUG(\"Reject auth %d server code bug\\n\", vs->auth);\n\n           vnc_write_u8(vs, 1);\n\n           if (vs->minor >= 8) {\n\n               static const char err[] = \"Authentication failed\";\n\n               vnc_write_u32(vs, sizeof(err));\n\n               vnc_write(vs, err, sizeof(err));\n\n           }\n\n           vnc_client_error(vs);\n\n       }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1524}
{"project": "qemu", "commit_id": "823bd7391c96ba675f20fd6d952d1cb6e1ffb851", "target": 1, "func": "static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    uint8_t *outbuf;\n\n    int buflen;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case INQUIRY:\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n    case RESERVE:\n\n    case RESERVE_10:\n\n    case RELEASE:\n\n    case RELEASE_10:\n\n    case START_STOP:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case GET_CONFIGURATION:\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n    case MECHANISM_STATUS:\n\n    case REQUEST_SENSE:\n\n        break;\n\n\n\n    default:\n\n        if (s->tray_open || !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n\n\n    /*\n\n     * FIXME: we shouldn't return anything bigger than 4k, but the code\n\n     * requires the buffer to be as big as req->cmd.xfer in several\n\n     * places.  So, do not allow CDBs with a very large ALLOCATION\n\n     * LENGTH.  The real fix would be to modify scsi_read_data and\n\n     * dma_buf_read, so that they return data beyond the buflen\n\n     * as all zeros.\n\n     */\n\n    if (req->cmd.xfer > 65536) {\n\n        goto illegal_request;\n\n    }\n\n    r->buflen = MAX(4096, req->cmd.xfer);\n\n\n\n    if (!r->iov.iov_base) {\n\n        r->iov.iov_base = qemu_blockalign(s->qdev.conf.bs, r->buflen);\n\n    }\n\n\n\n    buflen = req->cmd.xfer;\n\n    outbuf = r->iov.iov_base;\n\n    memset(outbuf, 0, r->buflen);\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        assert(!s->tray_open && bdrv_is_inserted(s->qdev.conf.bs));\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case START_STOP:\n\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n\n            return 0;\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        s->tray_locked = req->cmd.buf[4] & 1;\n\n        bdrv_lock_medium(s->qdev.conf.bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n        if (!nb_sectors) {\n\n            scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n            return 0;\n\n        }\n\n        if ((req->cmd.buf[8] & 1) == 0 && req->cmd.lba) {\n\n            goto illegal_request;\n\n        }\n\n        nb_sectors /= s->qdev.blocksize / 512;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->qdev.max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX) {\n\n            nb_sectors = UINT32_MAX;\n\n        }\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->qdev.blocksize >> 8;\n\n        outbuf[7] = 0;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        /* Just return \"NO SENSE\".  */\n\n        buflen = scsi_build_sense(NULL, 0, outbuf, r->buflen,\n\n                                  (req->cmd.buf[1] & 1) == 0);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n        buflen = scsi_emulate_mechanism_status(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        buflen = scsi_get_configuration(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n        buflen = scsi_get_event_status_notification(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DISC_INFORMATION:\n\n        buflen = scsi_read_disc_information(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DVD_STRUCTURE:\n\n        buflen = scsi_read_dvd_structure(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case SERVICE_ACTION_IN_16:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n            if (!nb_sectors) {\n\n                scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n                return 0;\n\n            }\n\n            if ((req->cmd.buf[14] & 1) == 0 && req->cmd.lba) {\n\n                goto illegal_request;\n\n            }\n\n            nb_sectors /= s->qdev.blocksize / 512;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->qdev.max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->qdev.blocksize >> 8;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case SYNCHRONIZE_CACHE:\n\n        /* The request is used as the AIO opaque value, so add a ref.  */\n\n        scsi_req_ref(&r->req);\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n\n        r->req.aiocb = bdrv_aio_flush(s->qdev.conf.bs, scsi_aio_complete, r);\n\n        return 0;\n\n    case SEEK_10:\n\n        DPRINTF(\"Seek(10) (sector %\" PRId64 \")\\n\", r->req.cmd.lba);\n\n        if (r->req.cmd.lba > s->qdev.max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n        break;\n\n    case MODE_SELECT:\n\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case MODE_SELECT_10:\n\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case UNMAP:\n\n        DPRINTF(\"Unmap (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        nb_sectors = scsi_data_cdb_length(r->req.cmd.buf);\n\n        if (bdrv_is_read_only(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));\n\n            return 0;\n\n        }\n\n        if (!check_lba_range(s, r->req.cmd.lba, nb_sectors)) {\n\n            goto illegal_lba;\n\n        }\n\n\n\n        /*\n\n         * We only support WRITE SAME with the unmap bit set for now.\n\n         */\n\n        if (!(req->cmd.buf[1] & 0x8)) {\n\n            goto illegal_request;\n\n        }\n\n\n\n        /* The request is used as the AIO opaque value, so add a ref.  */\n\n        scsi_req_ref(&r->req);\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        r->req.cmd.lba * (s->qdev.blocksize / 512),\n\n                                        nb_sectors * (s->qdev.blocksize / 512),\n\n                                        scsi_aio_complete, r);\n\n        return 0;\n\n    default:\n\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    }\n\n    assert(!r->req.aiocb);\n\n    r->iov.iov_len = MIN(r->buflen, req->cmd.xfer);\n\n    if (r->iov.iov_len == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        assert(r->iov.iov_len == req->cmd.xfer);\n\n        return -r->iov.iov_len;\n\n    } else {\n\n        return r->iov.iov_len;\n\n    }\n\n\n\nillegal_request:\n\n    if (r->req.status == -1) {\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    }\n\n    return 0;\n\n\n\nillegal_lba:\n\n    scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n    return 0;\n\n}\n", "idx": 12265}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 9603}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "g_malloc0(size_t n_bytes)\n\n{\n\n    void *mem;\n\n    __coverity_negative_sink__(n_bytes);\n\n    mem = calloc(1, n_bytes == 0 ? 1 : n_bytes);\n\n    if (!mem) __coverity_panic__();\n\n    return mem;\n\n}\n", "idx": 8233}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 907}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "int kvm_arch_put_registers(CPUState *env)\n\n{\n\n    struct kvm_regs regs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    regs.ctr = env->ctr;\n\n    regs.lr  = env->lr;\n\n    regs.xer = env->xer;\n\n    regs.msr = env->msr;\n\n    regs.pc = env->nip;\n\n\n\n    regs.srr0 = env->spr[SPR_SRR0];\n\n    regs.srr1 = env->spr[SPR_SRR1];\n\n\n\n    regs.sprg0 = env->spr[SPR_SPRG0];\n\n    regs.sprg1 = env->spr[SPR_SPRG1];\n\n    regs.sprg2 = env->spr[SPR_SPRG2];\n\n    regs.sprg3 = env->spr[SPR_SPRG3];\n\n    regs.sprg4 = env->spr[SPR_SPRG4];\n\n    regs.sprg5 = env->spr[SPR_SPRG5];\n\n    regs.sprg6 = env->spr[SPR_SPRG6];\n\n    regs.sprg7 = env->spr[SPR_SPRG7];\n\n\n\n    for (i = 0;i < 32; i++)\n\n        regs.gpr[i] = env->gpr[i];\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_SET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    return ret;\n\n}\n", "idx": 11927}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 5089}
{"project": "qemu", "commit_id": "779cec4d20907cbccb26fbf5f5c19c6cdee33eff", "target": 1, "func": "static QDict *qmp_check_input_obj(QObject *input_obj, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    int has_exec_key = 0;\n\n    QDict *input_dict;\n\n\n\n    if (qobject_type(input_obj) != QTYPE_QDICT) {\n\n        error_set(errp, QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        return NULL;\n\n    }\n\n\n\n    input_dict = qobject_to_qdict(input_obj);\n\n\n\n    for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n\n        const char *arg_name = qdict_entry_key(ent);\n\n        const QObject *arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_set(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                          \"execute\", \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = 1;\n\n        } else if (!strcmp(arg_name, \"arguments\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QDICT) {\n\n                error_set(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                          \"arguments\", \"object\");\n\n                return NULL;\n\n            }\n\n\n\n        } else {\n\n            error_set(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_set(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return input_dict;\n\n}", "idx": 5921}
{"project": "qemu", "commit_id": "b3adf53a3a10a1ca8347167907e4cf8bbd0204f1", "target": 1, "func": "static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return ret;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n", "idx": 11881}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl050_init(uint32_t base, qemu_irq irq, int is_mouse)\n\n{\n\n    int iomemtype;\n\n    pl050_state *s;\n\n\n\n    s = (pl050_state *)qemu_mallocz(sizeof(pl050_state));\n\n    iomemtype = cpu_register_io_memory(0, pl050_readfn,\n\n                                       pl050_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->is_mouse = is_mouse;\n\n    if (is_mouse)\n\n        s->dev = ps2_mouse_init(pl050_update, s);\n\n    else\n\n        s->dev = ps2_kbd_init(pl050_update, s);\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 5525}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void object_get_link_property(Object *obj, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Object **child = opaque;\n\n    gchar *path;\n\n\n\n    if (*child) {\n\n        path = object_get_canonical_path(*child);\n\n        visit_type_str(v, &path, name, errp);\n\n        g_free(path);\n\n    } else {\n\n        path = (gchar *)\"\";\n\n        visit_type_str(v, &path, name, errp);\n\n    }\n\n}\n", "idx": 5967}
{"project": "qemu", "commit_id": "3caab54d081bb3ce1b237d9628dd2b8ee7680159", "target": 1, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->qs->alloc);\n\n    }\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qvirtio_scsi_stop(vs->qs);\n\n    g_free(vs);\n\n}\n", "idx": 10223}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void ivshmem_check_version(void *opaque, const uint8_t * buf, int size)\n\n{\n\n    IVShmemState *s = opaque;\n\n    int tmp;\n\n    int64_t version;\n\n\n\n    if (!fifo_update_and_get_i64(s, buf, size, &version)) {\n\n        return;\n\n    }\n\n\n\n    tmp = qemu_chr_fe_get_msgfd(s->server_chr);\n\n    if (tmp != -1 || version != IVSHMEM_PROTOCOL_VERSION) {\n\n        fprintf(stderr, \"incompatible version, you are connecting to a ivshmem-\"\n\n                \"server using a different protocol please check your setup\\n\");\n\n        qemu_chr_add_handlers(s->server_chr, NULL, NULL, NULL, s);\n\n        return;\n\n    }\n\n\n\n    IVSHMEM_DPRINTF(\"version check ok, switch to real chardev handler\\n\");\n\n    qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_read,\n\n                          NULL, s);\n\n}\n", "idx": 7918}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st32(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st32(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 11464}
{"project": "qemu", "commit_id": "b7f43fe46029d8fd0594cd599fa2599dcce0f553", "target": 1, "func": "Object *object_dynamic_cast_assert(Object *obj, const char *typename)\n\n{\n\n    Object *inst;\n\n\n\n    inst = object_dynamic_cast(obj, typename);\n\n\n\n    if (!inst) {\n\n        fprintf(stderr, \"Object %p is not an instance of type %s\\n\",\n\n                obj, typename);\n\n        abort();\n\n    }\n\n\n\n    return inst;\n\n}\n", "idx": 7333}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static int csrhci_write(struct CharDriverState *chr,\n\n                const uint8_t *buf, int len)\n\n{\n\n    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;\n\n    int plen = s->in_len;\n\n\n\n    if (!s->enable)\n\n        return 0;\n\n\n\n    s->in_len += len;\n\n    memcpy(s->inpkt + plen, buf, len);\n\n\n\n    while (1) {\n\n        if (s->in_len >= 2 && plen < 2)\n\n            s->in_hdr = csrhci_header_len(s->inpkt) + 1;\n\n\n\n        if (s->in_len >= s->in_hdr && plen < s->in_hdr)\n\n            s->in_data = csrhci_data_len(s->inpkt) + s->in_hdr;\n\n\n\n        if (s->in_len >= s->in_data) {\n\n            csrhci_in_packet(s, s->inpkt);\n\n\n\n            memmove(s->inpkt, s->inpkt + s->in_len, s->in_len - s->in_data);\n\n            s->in_len -= s->in_data;\n\n            s->in_hdr = INT_MAX;\n\n            s->in_data = INT_MAX;\n\n            plen = 0;\n\n        } else\n\n            break;\n\n    }\n\n\n\n    return len;\n\n}\n", "idx": 10545}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void arm_cpu_class_init(ObjectClass *oc, void *data)\n{\n    ARMCPUClass *acc = ARM_CPU_CLASS(oc);\n    CPUClass *cc = CPU_CLASS(acc);\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    acc->parent_realize = dc->realize;\n    dc->realize = arm_cpu_realizefn;\n    dc->props = arm_cpu_properties;\n    acc->parent_reset = cc->reset;\n    cc->reset = arm_cpu_reset;\n    cc->class_by_name = arm_cpu_class_by_name;\n    cc->has_work = arm_cpu_has_work;\n    cc->cpu_exec_interrupt = arm_cpu_exec_interrupt;\n    cc->dump_state = arm_cpu_dump_state;\n    cc->set_pc = arm_cpu_set_pc;\n    cc->gdb_read_register = arm_cpu_gdb_read_register;\n    cc->gdb_write_register = arm_cpu_gdb_write_register;\n#ifdef CONFIG_USER_ONLY\n    cc->handle_mmu_fault = arm_cpu_handle_mmu_fault;\n#else\n    cc->do_interrupt = arm_cpu_do_interrupt;\n    cc->get_phys_page_debug = arm_cpu_get_phys_page_debug;\n    cc->vmsd = &vmstate_arm_cpu;\n    cc->virtio_is_big_endian = arm_cpu_is_big_endian;\n#endif\n    cc->gdb_num_core_regs = 26;\n    cc->gdb_core_xml_file = \"arm-core.xml\";\n    cc->gdb_stop_before_watchpoint = true;\n    cc->debug_excp_handler = arm_debug_excp_handler;\n    cc->disas_set_info = arm_disas_set_info;\n}", "idx": 9016}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static int net_slirp_init(Monitor *mon, VLANState *vlan, const char *model,\n\n                          const char *name, int restricted,\n\n                          const char *vnetwork, const char *vhost,\n\n                          const char *vhostname, const char *tftp_export,\n\n                          const char *bootfile, const char *vdhcp_start,\n\n                          const char *vnameserver, const char *smb_export,\n\n                          const char *vsmbserver)\n\n{\n\n    /* default settings according to historic slirp */\n\n    struct in_addr net  = { .s_addr = htonl(0x0a000200) }; /* 10.0.2.0 */\n\n    struct in_addr mask = { .s_addr = htonl(0xffffff00) }; /* 255.255.255.0 */\n\n    struct in_addr host = { .s_addr = htonl(0x0a000202) }; /* 10.0.2.2 */\n\n    struct in_addr dhcp = { .s_addr = htonl(0x0a00020f) }; /* 10.0.2.15 */\n\n    struct in_addr dns  = { .s_addr = htonl(0x0a000203) }; /* 10.0.2.3 */\n\n#ifndef _WIN32\n\n    struct in_addr smbsrv = { .s_addr = 0 };\n\n#endif\n\n    SlirpState *s;\n\n    char buf[20];\n\n    uint32_t addr;\n\n    int shift;\n\n    char *end;\n\n    struct slirp_config_str *config;\n\n\n\n    if (!tftp_export) {\n\n        tftp_export = legacy_tftp_prefix;\n\n    }\n\n    if (!bootfile) {\n\n        bootfile = legacy_bootp_filename;\n\n    }\n\n\n\n    if (vnetwork) {\n\n        if (get_str_sep(buf, sizeof(buf), &vnetwork, '/') < 0) {\n\n            if (!inet_aton(vnetwork, &net)) {\n\n                return -1;\n\n            }\n\n            addr = ntohl(net.s_addr);\n\n            if (!(addr & 0x80000000)) {\n\n                mask.s_addr = htonl(0xff000000); /* class A */\n\n            } else if ((addr & 0xfff00000) == 0xac100000) {\n\n                mask.s_addr = htonl(0xfff00000); /* priv. 172.16.0.0/12 */\n\n            } else if ((addr & 0xc0000000) == 0x80000000) {\n\n                mask.s_addr = htonl(0xffff0000); /* class B */\n\n            } else if ((addr & 0xffff0000) == 0xc0a80000) {\n\n                mask.s_addr = htonl(0xffff0000); /* priv. 192.168.0.0/16 */\n\n            } else if ((addr & 0xffff0000) == 0xc6120000) {\n\n                mask.s_addr = htonl(0xfffe0000); /* tests 198.18.0.0/15 */\n\n            } else if ((addr & 0xe0000000) == 0xe0000000) {\n\n                mask.s_addr = htonl(0xffffff00); /* class C */\n\n            } else {\n\n                mask.s_addr = htonl(0xfffffff0); /* multicast/reserved */\n\n            }\n\n        } else {\n\n            if (!inet_aton(buf, &net)) {\n\n                return -1;\n\n            }\n\n            shift = strtol(vnetwork, &end, 10);\n\n            if (*end != '\\0') {\n\n                if (!inet_aton(vnetwork, &mask)) {\n\n                    return -1;\n\n                }\n\n            } else if (shift < 4 || shift > 32) {\n\n                return -1;\n\n            } else {\n\n                mask.s_addr = htonl(0xffffffff << (32 - shift));\n\n            }\n\n        }\n\n        net.s_addr &= mask.s_addr;\n\n        host.s_addr = net.s_addr | (htonl(0x0202) & ~mask.s_addr);\n\n        dhcp.s_addr = net.s_addr | (htonl(0x020f) & ~mask.s_addr);\n\n        dns.s_addr  = net.s_addr | (htonl(0x0203) & ~mask.s_addr);\n\n    }\n\n\n\n    if (vhost && !inet_aton(vhost, &host)) {\n\n        return -1;\n\n    }\n\n    if ((host.s_addr & mask.s_addr) != net.s_addr) {\n\n        return -1;\n\n    }\n\n\n\n    if (vdhcp_start && !inet_aton(vdhcp_start, &dhcp)) {\n\n        return -1;\n\n    }\n\n    if ((dhcp.s_addr & mask.s_addr) != net.s_addr ||\n\n        dhcp.s_addr == host.s_addr || dhcp.s_addr == dns.s_addr) {\n\n        return -1;\n\n    }\n\n\n\n    if (vnameserver && !inet_aton(vnameserver, &dns)) {\n\n        return -1;\n\n    }\n\n    if ((dns.s_addr & mask.s_addr) != net.s_addr ||\n\n        dns.s_addr == host.s_addr) {\n\n        return -1;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    s = qemu_mallocz(sizeof(SlirpState));\n\n    s->slirp = slirp_init(restricted, net, mask, host, vhostname,\n\n                          tftp_export, bootfile, dhcp, dns, s);\n\n    QTAILQ_INSERT_TAIL(&slirp_stacks, s, entry);\n\n\n\n    for (config = slirp_configs; config; config = config->next) {\n\n        if (config->flags & SLIRP_CFG_HOSTFWD) {\n\n            slirp_hostfwd(s, mon, config->str,\n\n                          config->flags & SLIRP_CFG_LEGACY);\n\n        } else {\n\n            slirp_guestfwd(s, mon, config->str,\n\n                           config->flags & SLIRP_CFG_LEGACY);\n\n        }\n\n    }\n\n#ifndef _WIN32\n\n    if (!smb_export) {\n\n        smb_export = legacy_smb_export;\n\n    }\n\n    if (smb_export) {\n\n        slirp_smb(s, mon, smb_export, smbsrv);\n\n    }\n\n#endif\n\n\n\n    s->vc = qemu_new_vlan_client(vlan, model, name, NULL, slirp_receive, NULL,\n\n                                 net_slirp_cleanup, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n\n             \"net=%s, restricted=%c\", inet_ntoa(net), restricted ? 'y' : 'n');\n\n    return 0;\n\n}\n", "idx": 8621}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "int inet_connect(const char *str, bool block, Error **errp)\n\n{\n\n    QemuOpts *opts;\n\n    int sock = -1;\n\n\n\n    opts = qemu_opts_create(&dummy_opts, NULL, 0);\n\n    if (inet_parse(opts, str) == 0) {\n\n        if (block) {\n\n            qemu_opt_set(opts, \"block\", \"on\");\n\n        }\n\n        sock = inet_connect_opts(opts, errp);\n\n    } else {\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return sock;\n\n}\n", "idx": 10377}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_guestfwd(SlirpState *s, Monitor *mon, const char *config_str,\n\n                           int legacy_format)\n\n{\n\n    struct in_addr server = { .s_addr = 0 };\n\n    struct GuestFwd *fwd;\n\n    const char *p;\n\n    char buf[128];\n\n    char *end;\n\n    int port;\n\n\n\n    p = config_str;\n\n    if (legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n    } else {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (strcmp(buf, \"tcp\") && buf[0] != '\\0') {\n\n            goto fail_syntax;\n\n        }\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &server)) {\n\n            goto fail_syntax;\n\n        }\n\n        if (get_str_sep(buf, sizeof(buf), &p, '-') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n    port = strtol(buf, &end, 10);\n\n    if (*end != '\\0' || port < 1 || port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    fwd = qemu_malloc(sizeof(struct GuestFwd));\n\n    snprintf(buf, sizeof(buf), \"guestfwd.tcp:%d\", port);\n\n    fwd->hd = qemu_chr_open(buf, p, NULL);\n\n    if (!fwd->hd) {\n\n        config_error(mon, \"could not open guest forwarding device '%s'\\n\",\n\n                     buf);\n\n        qemu_free(fwd);\n\n        return;\n\n    }\n\n\n\n    if (slirp_add_exec(s->slirp, 3, fwd->hd, &server, port) < 0) {\n\n        config_error(mon, \"conflicting/invalid host:port in guest forwarding \"\n\n                     \"rule '%s'\\n\", config_str);\n\n        qemu_free(fwd);\n\n        return;\n\n    }\n\n    fwd->server = server;\n\n    fwd->port = port;\n\n    fwd->slirp = s->slirp;\n\n\n\n    qemu_chr_add_handlers(fwd->hd, guestfwd_can_read, guestfwd_read,\n\n                          NULL, fwd);\n\n    return;\n\n\n\n fail_syntax:\n\n    config_error(mon, \"invalid guest forwarding rule '%s'\\n\", config_str);\n\n}\n", "idx": 150}
{"project": "qemu", "commit_id": "f8c88bbcda76d5674e4bb125471371b41d330df8", "target": 1, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 3333}
{"project": "qemu", "commit_id": "4be23939ab0d7019c7e59a37485b416fbbf0f073", "target": 1, "func": "static void ehci_queues_rip_unused(EHCIState *ehci, int async)\n\n{\n\n    EHCIQueueHead *head = async ? &ehci->aqueues : &ehci->pqueues;\n\n    EHCIQueue *q, *tmp;\n\n\n\n    QTAILQ_FOREACH_SAFE(q, head, next, tmp) {\n\n        if (q->seen) {\n\n            q->seen = 0;\n\n            q->ts = ehci->last_run_ns;\n\n            continue;\n\n        }\n\n        if (ehci->last_run_ns < q->ts + 250000000) {\n\n            /* allow 0.25 sec idle */\n\n            continue;\n\n        }\n\n        ehci_free_queue(q, async);\n\n    }\n\n}\n", "idx": 4479}
{"project": "qemu", "commit_id": "180ca19ae02be70f9b158bfd7dec1ff123b9cf8c", "target": 1, "func": "static int bdrv_open_driver(BlockDriverState *bs, BlockDriver *drv,\n\n                            const char *node_name, QDict *options,\n\n                            int open_flags, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    bdrv_assign_node_name(bs, node_name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return -EINVAL;\n\n    }\n\n\n\n    bs->drv = drv;\n\n    bs->read_only = !(bs->open_flags & BDRV_O_RDWR);\n\n    bs->opaque = g_malloc0(drv->instance_size);\n\n\n\n    if (drv->bdrv_file_open) {\n\n        assert(!drv->bdrv_needs_filename || bs->filename[0]);\n\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n\n    } else if (drv->bdrv_open) {\n\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n\n    } else {\n\n        ret = 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n        } else if (bs->filename[0]) {\n\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n\n        } else {\n\n            error_setg_errno(errp, -ret, \"Could not open image\");\n\n        }\n\n        goto free_and_fail;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        goto free_and_fail;\n\n    }\n\n\n\n    bdrv_refresh_limits(bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto free_and_fail;\n\n    }\n\n\n\n    assert(bdrv_opt_mem_align(bs) != 0);\n\n    assert(bdrv_min_mem_align(bs) != 0);\n\n    assert(is_power_of_2(bs->bl.request_alignment));\n\n\n\n    return 0;\n\n\n\nfree_and_fail:\n\n    /* FIXME Close bs first if already opened*/\n\n    g_free(bs->opaque);\n\n    bs->opaque = NULL;\n\n    bs->drv = NULL;\n\n    return ret;\n\n}\n", "idx": 1206}
{"project": "qemu", "commit_id": "8a0548f94edecb96acb9b7fb9106ccc821c4996f", "target": 1, "func": "int kvm_arch_remove_sw_breakpoint(CPUState *cpu, struct kvm_sw_breakpoint *bp)\n\n{\n\n    return -EINVAL;\n\n}\n", "idx": 11527}
{"project": "qemu", "commit_id": "aab99135b63522267c6fdae04712cb2f02c8c7de", "target": 1, "func": "static void detach(sPAPRDRConnector *drc, DeviceState *d,\n                   spapr_drc_detach_cb *detach_cb,\n                   void *detach_cb_opaque, Error **errp)\n{\n    DPRINTFN(\"drc: %x, detach\", get_index(drc));\n    drc->detach_cb = detach_cb;\n    drc->detach_cb_opaque = detach_cb_opaque;\n    /* if we've signalled device presence to the guest, or if the guest\n     * has gone ahead and configured the device (via manually-executed\n     * device add via drmgr in guest, namely), we need to wait\n     * for the guest to quiesce the device before completing detach.\n     * Otherwise, we can assume the guest hasn't seen it and complete the\n     * detach immediately. Note that there is a small race window\n     * just before, or during, configuration, which is this context\n     * refers mainly to fetching the device tree via RTAS.\n     * During this window the device access will be arbitrated by\n     * associated DRC, which will simply fail the RTAS calls as invalid.\n     * This is recoverable within guest and current implementations of\n     * drmgr should be able to cope.\n     */\n    if (!drc->signalled && !drc->configured) {\n        /* if the guest hasn't seen the device we can't rely on it to\n         * set it back to an isolated state via RTAS, so do it here manually\n         */\n        drc->isolation_state = SPAPR_DR_ISOLATION_STATE_ISOLATED;\n    if (drc->isolation_state != SPAPR_DR_ISOLATION_STATE_ISOLATED) {\n        DPRINTFN(\"awaiting transition to isolated state before removal\");\n    if (drc->type != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n        drc->allocation_state != SPAPR_DR_ALLOCATION_STATE_UNUSABLE) {\n        DPRINTFN(\"awaiting transition to unusable state before removal\");\n    drc->indicator_state = SPAPR_DR_INDICATOR_STATE_INACTIVE;\n    if (drc->detach_cb) {\n        drc->detach_cb(drc->dev, drc->detach_cb_opaque);\n    drc->awaiting_release = false;\n    g_free(drc->fdt);\n    drc->fdt = NULL;\n    drc->fdt_start_offset = 0;\n    object_property_del(OBJECT(drc), \"device\", NULL);\n    drc->dev = NULL;\n    drc->detach_cb = NULL;\n    drc->detach_cb_opaque = NULL;", "idx": 11258}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "void do_blockdev_backup(BlockdevBackup *backup, BlockJobTxn *txn, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    Error *local_err = NULL;\n\n    AioContext *aio_context;\n\n\n\n    if (!backup->has_speed) {\n\n        backup->speed = 0;\n\n    }\n\n    if (!backup->has_on_source_error) {\n\n        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_on_target_error) {\n\n        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_job_id) {\n\n        backup->job_id = NULL;\n\n    }\n\n    if (!backup->has_compress) {\n\n        backup->compress = false;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    target_bs = bdrv_lookup_bs(backup->target, backup->target, errp);\n\n    if (!target_bs) {\n\n        goto out;\n\n    }\n\n\n\n    if (bdrv_get_aio_context(target_bs) != aio_context) {\n\n        if (!bdrv_has_blk(target_bs)) {\n\n            /* The target BDS is not attached, we can safely move it to another\n\n             * AioContext. */\n\n            bdrv_set_aio_context(target_bs, aio_context);\n\n        } else {\n\n            error_setg(errp, \"Target is attached to a different thread from \"\n\n                             \"source.\");\n\n            goto out;\n\n        }\n\n    }\n\n    backup_start(backup->job_id, bs, target_bs, backup->speed, backup->sync,\n\n                 NULL, backup->compress, backup->on_source_error,\n\n                 backup->on_target_error, BLOCK_JOB_DEFAULT,\n\n                 NULL, NULL, txn, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n    }\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 3019}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn_stop(ESPState *s)\n\n{\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn_stop;\n\n        return;\n\n    }\n\n    s->cmdlen = get_cmd(s, s->cmdbuf);\n\n    if (s->cmdlen) {\n\n        trace_esp_handle_satn_stop(s->cmdlen);\n\n        s->do_cmd = 1;\n\n        s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n\n        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n\n        esp_raise_irq(s);\n\n    }\n\n}\n", "idx": 1505}
{"project": "qemu", "commit_id": "c8a9fd80719e63615dac12e3625223fb54aa8430", "target": 1, "func": "static int bdrv_co_do_ioctl(BlockDriverState *bs, int req, void *buf)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BdrvTrackedRequest tracked_req;\n\n    CoroutineIOCompletion co = {\n\n        .coroutine = qemu_coroutine_self(),\n\n    };\n\n    BlockAIOCB *acb;\n\n\n\n    tracked_request_begin(&tracked_req, bs, 0, 0, BDRV_TRACKED_IOCTL);\n\n    if (!drv || !drv->bdrv_aio_ioctl) {\n\n        co.ret = -ENOTSUP;\n\n        goto out;\n\n    }\n\n\n\n    acb = drv->bdrv_aio_ioctl(bs, req, buf, bdrv_co_io_em_complete, &co);\n\n    if (!acb) {\n\n        BdrvIoctlCompletionData *data = g_new(BdrvIoctlCompletionData, 1);\n\n        data->bh = aio_bh_new(bdrv_get_aio_context(bs),\n\n                                bdrv_ioctl_bh_cb, data);\n\n        data->co = &co;\n\n        qemu_bh_schedule(data->bh);\n\n    }\n\n    qemu_coroutine_yield();\n\nout:\n\n    tracked_request_end(&tracked_req);\n\n    return co.ret;\n\n}\n", "idx": 1226}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static gboolean nbd_accept(QIOChannel *ioc, GIOCondition condition,\n\n                           gpointer opaque)\n\n{\n\n    QIOChannelSocket *cioc;\n\n\n\n    if (!nbd_server) {\n\n        return FALSE;\n\n    }\n\n\n\n    cioc = qio_channel_socket_accept(QIO_CHANNEL_SOCKET(ioc),\n\n                                     NULL);\n\n    if (!cioc) {\n\n        return TRUE;\n\n    }\n\n\n\n    qio_channel_set_name(QIO_CHANNEL(cioc), \"nbd-server\");\n\n    nbd_client_new(NULL, cioc,\n\n                   nbd_server->tlscreds, NULL,\n\n                   nbd_client_put);\n\n    object_unref(OBJECT(cioc));\n\n    return TRUE;\n\n}\n", "idx": 6605}
{"project": "qemu", "commit_id": "0f888bfaddfc5f55b0d82cde2e1164658a672375", "target": 1, "func": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;", "idx": 1252}
{"project": "qemu", "commit_id": "84cab1e2f5be3ea6eaa65c9fc0422fb992946ce0", "target": 1, "func": "static void gen_std(DisasContext *ctx)\n\n{\n\n    int rs;\n\n    TCGv EA;\n\n\n\n    rs = rS(ctx->opcode);\n\n    if ((ctx->opcode & 0x3) == 0x2) {\n\n#if defined(CONFIG_USER_ONLY)\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n        /* stq */\n\n        if (unlikely(ctx->mem_idx == 0)) {\n\n            gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n            return;\n\n        }\n\n        if (unlikely(rs & 1)) {\n\n            gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n            return;\n\n        }\n\n        if (unlikely(ctx->le_mode)) {\n\n            /* Little-endian mode is not handled */\n\n            gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n            return;\n\n        }\n\n        gen_set_access_type(ctx, ACCESS_INT);\n\n        EA = tcg_temp_new();\n\n        gen_addr_imm_index(ctx, EA, 0x03);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs], EA);\n\n        gen_addr_add(ctx, EA, EA, 8);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs+1], EA);\n\n        tcg_temp_free(EA);\n\n#endif\n\n    } else {\n\n        /* std / stdu */\n\n        if (Rc(ctx->opcode)) {\n\n            if (unlikely(rA(ctx->opcode) == 0)) {\n\n                gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n                return;\n\n            }\n\n        }\n\n        gen_set_access_type(ctx, ACCESS_INT);\n\n        EA = tcg_temp_new();\n\n        gen_addr_imm_index(ctx, EA, 0x03);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs], EA);\n\n        if (Rc(ctx->opcode))\n\n            tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], EA);\n\n        tcg_temp_free(EA);\n\n    }\n\n}\n", "idx": 9199}
{"project": "qemu", "commit_id": "0b368a10c71af96f6cf93b0ba5c2ee3bdbd50e96", "target": 1, "func": "static int kvm_put_msrs(X86CPU *cpu, int level)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n    int ret;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, env->sysenter_cs);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, env->sysenter_esp);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, env->sysenter_eip);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, env->pat);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, env->star);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, env->vm_hsave);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, env->tsc_aux);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, env->tsc_adjust);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE,\n\n                          env->msr_ia32_misc_enable);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, env->smbase);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, env->msr_bndcfgs);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, env->xss);\n\n    }\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, env->cstar);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, env->kernelgsbase);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, env->fmask);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, env->lstar);\n\n    }\n\n#endif\n\n    /*\n\n     * The following MSRs have side effects on the guest or are too heavy\n\n     * for normal writeback. Limit them to reset or full state updates.\n\n     */\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, env->wall_clock_msr);\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_ASYNC_PF)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, env->async_pf_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_PV_EOI)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, env->pv_eoi_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_STEAL_TIME)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, env->steal_time_msr);\n\n        }\n\n        if (has_msr_architectural_pmu) {\n\n            /* Stop the counter.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\n\n            /* Set the counter values.  */\n\n            for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,\n\n                                  env->msr_fixed_counters[i]);\n\n            }\n\n            for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,\n\n                                  env->msr_gp_counters[i]);\n\n                kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,\n\n                                  env->msr_gp_evtsel[i]);\n\n            }\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,\n\n                              env->msr_global_status);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL,\n\n                              env->msr_global_ovf_ctrl);\n\n\n\n            /* Now start the PMU.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL,\n\n                              env->msr_fixed_ctr_ctrl);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL,\n\n                              env->msr_global_ctrl);\n\n        }\n\n        /*\n\n         * Hyper-V partition-wide MSRs: to avoid clearing them on cpu hot-add,\n\n         * only sync them to KVM on the first cpu\n\n         */\n\n        if (current_cpu == first_cpu) {\n\n            if (has_msr_hv_hypercall) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID,\n\n                                  env->msr_hv_guest_os_id);\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL,\n\n                                  env->msr_hv_hypercall);\n\n            }\n\n            if (cpu->hyperv_time) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC,\n\n                                  env->msr_hv_tsc);\n\n            }\n\n        }\n\n        if (cpu->hyperv_vapic) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE,\n\n                              env->msr_hv_vapic);\n\n        }\n\n        if (has_msr_hv_crash) {\n\n            int j;\n\n\n\n            for (j = 0; j < HV_CRASH_PARAMS; j++)\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j,\n\n                                  env->msr_hv_crash_params[j]);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_NOTIFY);\n\n        }\n\n        if (has_msr_hv_runtime) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, env->msr_hv_runtime);\n\n        }\n\n        if (cpu->hyperv_synic) {\n\n            int j;\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, HV_SYNIC_VERSION);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL,\n\n                              env->msr_hv_synic_control);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP,\n\n                              env->msr_hv_synic_evt_page);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP,\n\n                              env->msr_hv_synic_msg_page);\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_synic_sint); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_SINT0 + j,\n\n                                  env->msr_hv_synic_sint[j]);\n\n            }\n\n        }\n\n        if (has_msr_hv_stimer) {\n\n            int j;\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_config); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_CONFIG + j * 2,\n\n                                env->msr_hv_stimer_config[j]);\n\n            }\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_count); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_COUNT + j * 2,\n\n                                env->msr_hv_stimer_count[j]);\n\n            }\n\n        }\n\n        if (env->features[FEAT_1_EDX] & CPUID_MTRR) {\n\n            uint64_t phys_mask = MAKE_64BIT_MASK(0, cpu->phys_bits);\n\n\n\n            kvm_msr_entry_add(cpu, MSR_MTRRdefType, env->mtrr_deftype);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, env->mtrr_fixed[0]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, env->mtrr_fixed[1]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, env->mtrr_fixed[2]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, env->mtrr_fixed[3]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, env->mtrr_fixed[4]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, env->mtrr_fixed[5]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, env->mtrr_fixed[6]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, env->mtrr_fixed[7]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, env->mtrr_fixed[8]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, env->mtrr_fixed[9]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, env->mtrr_fixed[10]);\n\n            for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n                /* The CPU GPs if we write to a bit above the physical limit of\n\n                 * the host CPU (and KVM emulates that)\n\n                 */\n\n                uint64_t mask = env->mtrr_var[i].mask;\n\n                mask &= phys_mask;\n\n\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i),\n\n                                  env->mtrr_var[i].base);\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), mask);\n\n            }\n\n        }\n\n\n\n        /* Note: MSR_IA32_FEATURE_CONTROL is written separately, see\n\n         *       kvm_put_msr_feature_control. */\n\n    }\n\n    if (env->mcg_cap) {\n\n        int i;\n\n\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, env->mcg_status);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, env->mcg_ctl);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, env->mcg_ext_ctl);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, env->mce_banks[i]);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret < cpu->kvm_msr_buf->nmsrs) {\n\n        struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];\n\n        error_report(\"error: failed to set MSR 0x%\" PRIx32 \" to 0x%\" PRIx64,\n\n                     (uint32_t)e->index, (uint64_t)e->data);\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    return 0;\n\n}\n", "idx": 9908}
{"project": "qemu", "commit_id": "e954ea2873fd6621d199d4a1a012fc0bc0292924", "target": 1, "func": "static void qxl_set_mode(PCIQXLDevice *d, int modenr, int loadvm)\n\n{\n\n    pcibus_t start = d->pci.io_regions[QXL_RAM_RANGE_INDEX].addr;\n\n    pcibus_t end   = d->pci.io_regions[QXL_RAM_RANGE_INDEX].size + start;\n\n    QXLMode *mode = d->modes->modes + modenr;\n\n    uint64_t devmem = d->pci.io_regions[QXL_RAM_RANGE_INDEX].addr;\n\n    QXLMemSlot slot = {\n\n        .mem_start = start,\n\n        .mem_end = end\n\n    };\n\n    QXLSurfaceCreate surface = {\n\n        .width      = mode->x_res,\n\n        .height     = mode->y_res,\n\n        .stride     = -mode->x_res * 4,\n\n        .format     = SPICE_SURFACE_FMT_32_xRGB,\n\n        .flags      = loadvm ? QXL_SURF_FLAG_KEEP_DATA : 0,\n\n        .mouse_mode = true,\n\n        .mem        = devmem + d->shadow_rom.draw_area_offset,\n\n    };\n\n\n\n    trace_qxl_set_mode(d->id, modenr, mode->x_res, mode->y_res, mode->bits,\n\n                       devmem);\n\n    if (!loadvm) {\n\n        qxl_hard_reset(d, 0);\n\n    }\n\n\n\n    d->guest_slots[0].slot = slot;\n\n    qxl_add_memslot(d, 0, devmem, QXL_SYNC);\n\n\n\n    d->guest_primary.surface = surface;\n\n    qxl_create_guest_primary(d, 0, QXL_SYNC);\n\n\n\n    d->mode = QXL_MODE_COMPAT;\n\n    d->cmdflags = QXL_COMMAND_FLAG_COMPAT;\n\n#ifdef QXL_COMMAND_FLAG_COMPAT_16BPP /* new in spice 0.6.1 */\n\n    if (mode->bits == 16) {\n\n        d->cmdflags |= QXL_COMMAND_FLAG_COMPAT_16BPP;\n\n    }\n\n#endif\n\n    d->shadow_rom.mode = cpu_to_le32(modenr);\n\n    d->rom->mode = cpu_to_le32(modenr);\n\n    qxl_rom_set_dirty(d);\n\n}\n", "idx": 9807}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n", "idx": 3113}
{"project": "qemu", "commit_id": "444bc908611ccaf4512dc37c33ac3b54d873a62b", "target": 1, "func": "static void scsi_unmap_complete(void *opaque, int ret)\n\n{\n\n    UnmapCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint64_t sector_num;\n\n    uint32_t nb_sectors;\n\n\n\n    r->req.aiocb = NULL;\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    if (data->count > 0 && !r->req.io_canceled) {\n\n        sector_num = ldq_be_p(&data->inbuf[0]);\n\n        nb_sectors = ldl_be_p(&data->inbuf[8]) & 0xffffffffULL;\n\n        if (sector_num > sector_num + nb_sectors ||\n\n            sector_num + nb_sectors - 1 > s->qdev.max_lba) {\n\n            scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n            goto done;\n\n        }\n\n\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        sector_num * (s->qdev.blocksize / 512),\n\n                                        nb_sectors * (s->qdev.blocksize / 512),\n\n                                        scsi_unmap_complete, data);\n\n        data->count--;\n\n        data->inbuf += 16;\n\n        return;\n\n    }\n\n\n\ndone:\n\n    if (data->count == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (!r->req.io_canceled) {\n\n        scsi_req_unref(&r->req);\n\n    }\n\n    g_free(data);\n\n}\n", "idx": 1323}
{"project": "qemu", "commit_id": "0ccff151b42a5b684ce22473b68972a94bc708fb", "target": 1, "func": "void mips_r4k_init (ram_addr_t ram_size, int vga_ram_size,\n\n                    const char *boot_device,\n\n                    const char *kernel_filename, const char *kernel_cmdline,\n\n                    const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    unsigned long bios_offset;\n\n    int bios_size;\n\n    CPUState *env;\n\n    RTCState *rtc_state;\n\n    int i;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"R4000\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    /* allocate RAM */\n\n\n\n\n\n\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    if (!mips_qemu_iomemtype) {\n\n        mips_qemu_iomemtype = cpu_register_io_memory(0, mips_qemu_read,\n\n                                                     mips_qemu_write, NULL);\n\n\n    cpu_register_physical_memory(0x1fbf0000, 0x10000, mips_qemu_iomemtype);\n\n\n\n    /* Try to load a BIOS image. If this fails, we continue regardless,\n\n       but initialize the hardware ourselves. When a kernel gets\n\n       preloaded we also initialize the hardware, since the BIOS wasn't\n\n       run. */\n\n    bios_offset = ram_size + vga_ram_size;\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n    if ((bios_size > 0) && (bios_size <= BIOS_SIZE)) {\n\n\tcpu_register_physical_memory(0x1fc00000,\n\n\t\t\t\t     BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n    } else if ((index = drive_get_index(IF_PFLASH, 0, 0)) > -1) {\n\n        uint32_t mips_rom = 0x00400000;\n\n        cpu_register_physical_memory(0x1fc00000, mips_rom,\n\n\t                     qemu_ram_alloc(mips_rom) | IO_MEM_ROM);\n\n        if (!pflash_cfi01_register(0x1fc00000, qemu_ram_alloc(mips_rom),\n\n            drives_table[index].bdrv, sector_len, mips_rom / sector_len,\n\n            4, 0, 0, 0, 0)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n\n\n    else {\n\n\t/* not fatal */\n\n        fprintf(stderr, \"qemu: Warning, could not load MIPS bios '%s'\\n\",\n\n\t\tbuf);\n\n\n\n\n    if (kernel_filename) {\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        load_kernel (env);\n\n\n\n\n    /* Init CPU internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* The PIC is attached to the MIPS CPU INT0 pin */\n\n    i8259 = i8259_init(env->irq[2]);\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    /* Register 64 KB of ISA IO space at 0x14000000 */\n\n    isa_mmio_init(0x14000000, 0x00010000);\n\n    isa_mem_base = 0x10000000;\n\n\n\n    pit = pit_init(0x40, i8259[0]);\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n\n\n\n\n    isa_vga_init(phys_ram_base + ram_size, ram_size,\n\n                 vga_ram_size);\n\n\n\n    if (nd_table[0].vlan)\n\n        isa_ne2000_init(0x300, i8259[9], &nd_table[0]);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n        if (index != -1)\n\n            hd[i] = drives_table[index].bdrv;\n\n        else\n\n            hd[i] = NULL;\n\n\n\n\n    for(i = 0; i < MAX_IDE_BUS; i++)\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n                     hd[MAX_IDE_DEVS * i],\n\n\t\t     hd[MAX_IDE_DEVS * i + 1]);\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n", "idx": 11685}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "func": "SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit)\n\n{\n\n    const char *driver;\n\n    DeviceState *dev;\n\n\n\n    driver = bdrv_is_sg(dinfo->bdrv) ? \"scsi-generic\" : \"scsi-disk\";\n\n    dev = qdev_create(&bus->qbus, driver);\n\n    qdev_prop_set_uint32(dev, \"scsi-id\", unit);\n\n    qdev_prop_set_drive(dev, \"drive\", dinfo);\n\n    qdev_init(dev);\n\n    return DO_UPCAST(SCSIDevice, qdev, dev);\n\n}\n", "idx": 4916}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n\n{\n\n    uint8_t r, g, b;\n\n\n\n    r = ((v >> vs->server_red_shift) & vs->server_red_max) * (vs->client_red_max + 1) /\n\n        (vs->server_red_max + 1);\n\n    g = ((v >> vs->server_green_shift) & vs->server_green_max) * (vs->client_green_max + 1) /\n\n        (vs->server_green_max + 1);\n\n    b = ((v >> vs->server_blue_shift) & vs->server_blue_max) * (vs->client_blue_max + 1) /\n\n        (vs->server_blue_max + 1);\n\n    v = (r << vs->client_red_shift) |\n\n        (g << vs->client_green_shift) |\n\n        (b << vs->client_blue_shift);\n\n    switch(vs->pix_bpp) {\n\n    case 1:\n\n        buf[0] = v;\n\n        break;\n\n    case 2:\n\n        if (vs->pix_big_endian) {\n\n            buf[0] = v >> 8;\n\n            buf[1] = v;\n\n        } else {\n\n            buf[1] = v >> 8;\n\n            buf[0] = v;\n\n        }\n\n        break;\n\n    default:\n\n    case 4:\n\n        if (vs->pix_big_endian) {\n\n            buf[0] = v >> 24;\n\n            buf[1] = v >> 16;\n\n            buf[2] = v >> 8;\n\n            buf[3] = v;\n\n        } else {\n\n            buf[3] = v >> 24;\n\n            buf[2] = v >> 16;\n\n            buf[1] = v >> 8;\n\n            buf[0] = v;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 11389}
{"project": "qemu", "commit_id": "4b63a0df3bda8a2c278e45d9d94d9ba6d5791d8d", "target": 1, "func": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n", "idx": 2448}
{"project": "qemu", "commit_id": "2f78e491d7b46542158ce0b8132ee4e05bc0ade4", "target": 1, "func": "static void iothread_complete(UserCreatable *obj, Error **errp)\n\n{\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread->stopping = false;\n\n    iothread->ctx = aio_context_new();\n\n    iothread->thread_id = -1;\n\n\n\n    qemu_mutex_init(&iothread->init_done_lock);\n\n    qemu_cond_init(&iothread->init_done_cond);\n\n\n\n    /* This assumes we are called from a thread with useful CPU affinity for us\n\n     * to inherit.\n\n     */\n\n    qemu_thread_create(&iothread->thread, \"iothread\", iothread_run,\n\n                       iothread, QEMU_THREAD_JOINABLE);\n\n\n\n    /* Wait for initialization to complete */\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    while (iothread->thread_id == -1) {\n\n        qemu_cond_wait(&iothread->init_done_cond,\n\n                       &iothread->init_done_lock);\n\n    }\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n}\n", "idx": 1981}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void arm_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n    static bool inited;\n\n    uint32_t Aff1, Aff0;\n\n\n\n    cs->env_ptr = &cpu->env;\n\n    cpu_exec_init(cs, &error_abort);\n\n    cpu->cp_regs = g_hash_table_new_full(g_int_hash, g_int_equal,\n\n                                         g_free, g_free);\n\n\n\n    /* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.\n\n     * We don't support setting cluster ID ([16..23]) (known as Aff2\n\n     * in later ARM ARM versions), or any of the higher affinity level fields,\n\n     * so these bits always RAZ.\n\n     */\n\n    Aff1 = cs->cpu_index / ARM_CPUS_PER_CLUSTER;\n\n    Aff0 = cs->cpu_index % ARM_CPUS_PER_CLUSTER;\n\n    cpu->mp_affinity = (Aff1 << ARM_AFF1_SHIFT) | Aff0;\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    /* Our inbound IRQ and FIQ lines */\n\n    if (kvm_enabled()) {\n\n        /* VIRQ and VFIQ are unused with KVM but we add them to maintain\n\n         * the same interface as non-KVM CPUs.\n\n         */\n\n        qdev_init_gpio_in(DEVICE(cpu), arm_cpu_kvm_set_irq, 4);\n\n    } else {\n\n        qdev_init_gpio_in(DEVICE(cpu), arm_cpu_set_irq, 4);\n\n    }\n\n\n\n    cpu->gt_timer[GTIMER_PHYS] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_ptimer_cb, cpu);\n\n    cpu->gt_timer[GTIMER_VIRT] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_vtimer_cb, cpu);\n\n    cpu->gt_timer[GTIMER_HYP] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_htimer_cb, cpu);\n\n    cpu->gt_timer[GTIMER_SEC] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,\n\n                                                arm_gt_stimer_cb, cpu);\n\n    qdev_init_gpio_out(DEVICE(cpu), cpu->gt_timer_outputs,\n\n                       ARRAY_SIZE(cpu->gt_timer_outputs));\n\n#endif\n\n\n\n    /* DTB consumers generally don't in fact care what the 'compatible'\n\n     * string is, so always provide some string and trust that a hypothetical\n\n     * picky DTB consumer will also provide a helpful error message.\n\n     */\n\n    cpu->dtb_compatible = \"qemu,unknown\";\n\n    cpu->psci_version = 1; /* By default assume PSCI v0.1 */\n\n    cpu->kvm_target = QEMU_KVM_ARM_TARGET_NONE;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu->psci_version = 2; /* TCG implements PSCI 0.2 */\n\n        if (!inited) {\n\n            inited = true;\n\n            arm_translate_init();\n\n        }\n\n    }\n\n}\n", "idx": 9339}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_addco (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1;\n\n    if (likely(T0 >= T2)) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n    if (likely(!((T2 ^ T1 ^ (-1)) & (T2 ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n}\n", "idx": 7498}
{"project": "qemu", "commit_id": "e980f2bf0a39cb524259bb70084e0f75b92c8f39", "target": 1, "func": "int acpi_table_add(const QemuOpts *opts)\n\n{\n\n    AcpiTableOptions *hdrs = NULL;\n\n    Error *err = NULL;\n\n    char **pathnames = NULL;\n\n    char **cur;\n\n\n\n    size_t len, start, allen;\n\n    bool has_header;\n\n    int changed;\n\n    int r;\n\n    struct acpi_table_header hdr;\n\n    char unsigned *table_start;\n\n\n\n    {\n\n        OptsVisitor *ov;\n\n\n\n        ov = opts_visitor_new(opts);\n\n        visit_type_AcpiTableOptions(opts_get_visitor(ov), &hdrs, NULL, &err);\n\n        opts_visitor_cleanup(ov);\n\n    }\n\n\n\n    if (err) {\n\n        goto out;\n\n    }\n\n    if (hdrs->has_file == hdrs->has_data) {\n\n        error_setg(&err, \"'-acpitable' requires one of 'data' or 'file'\");\n\n        goto out;\n\n    }\n\n    has_header = hdrs->has_file;\n\n\n\n    pathnames = g_strsplit(hdrs->has_file ? hdrs->file : hdrs->data, \":\", 0);\n\n    if (pathnames == NULL || pathnames[0] == NULL) {\n\n        error_setg(&err, \"'-acpitable' requires at least one pathname\");\n\n        goto out;\n\n    }\n\n\n\n    if (!acpi_tables) {\n\n        allen = sizeof(uint16_t);\n\n        acpi_tables = g_malloc0(allen);\n\n    } else {\n\n        allen = acpi_tables_len;\n\n    }\n\n\n\n    start = allen;\n\n    acpi_tables = g_realloc(acpi_tables, start + ACPI_TABLE_HDR_SIZE);\n\n    allen += has_header ? ACPI_TABLE_PFX_SIZE : ACPI_TABLE_HDR_SIZE;\n\n\n\n    /* now read in the data files, reallocating buffer as needed */\n\n\n\n    for (cur = pathnames; *cur; ++cur) {\n\n        int fd = open(*cur, O_RDONLY | O_BINARY);\n\n\n\n        if (fd < 0) {\n\n            error_setg(&err, \"can't open file %s: %s\", *cur, strerror(errno));\n\n            goto out;\n\n        }\n\n\n\n        for (;;) {\n\n            char unsigned data[8192];\n\n            r = read(fd, data, sizeof(data));\n\n            if (r == 0) {\n\n                break;\n\n            } else if (r > 0) {\n\n                acpi_tables = g_realloc(acpi_tables, allen + r);\n\n                memcpy(acpi_tables + allen, data, r);\n\n                allen += r;\n\n            } else if (errno != EINTR) {\n\n                error_setg(&err, \"can't read file %s: %s\",\n\n                           *cur, strerror(errno));\n\n                close(fd);\n\n                goto out;\n\n            }\n\n        }\n\n\n\n        close(fd);\n\n    }\n\n\n\n    /* now fill in the header fields */\n\n\n\n    table_start = acpi_tables + start;   /* start of the table */\n\n    changed = 0;\n\n\n\n    /* copy the header to temp place to align the fields */\n\n    memcpy(&hdr, has_header ? table_start : dfl_hdr, ACPI_TABLE_HDR_SIZE);\n\n\n\n    /* length of the table minus our prefix */\n\n    len = allen - start - ACPI_TABLE_PFX_SIZE;\n\n\n\n    hdr._length = cpu_to_le16(len);\n\n\n\n    if (hdrs->has_sig) {\n\n        /* strncpy is justified: the field need not be NUL-terminated. */\n\n        strncpy(hdr.sig, hdrs->sig, sizeof(hdr.sig));\n\n        ++changed;\n\n    }\n\n\n\n    /* length of the table including header, in bytes */\n\n    if (has_header) {\n\n        unsigned long val;\n\n\n\n        /* check if actual length is correct */\n\n        val = le32_to_cpu(hdr.length);\n\n        if (val != len) {\n\n            fprintf(stderr,\n\n                \"warning: acpitable has wrong length,\"\n\n                \" header says %lu, actual size %zu bytes\\n\",\n\n                val, len);\n\n            ++changed;\n\n        }\n\n    }\n\n    /* we may avoid putting length here if has_header is true */\n\n    hdr.length = cpu_to_le32(len);\n\n\n\n    if (hdrs->has_rev) {\n\n        hdr.revision = hdrs->rev;\n\n        ++changed;\n\n    }\n\n\n\n    if (hdrs->has_oem_id) {\n\n        /* strncpy is justified: the field need not be NUL-terminated. */\n\n        strncpy(hdr.oem_id, hdrs->oem_id, sizeof(hdr.oem_id));\n\n        ++changed;\n\n    }\n\n\n\n    if (hdrs->has_oem_table_id) {\n\n        /* strncpy is justified: the field need not be NUL-terminated. */\n\n        strncpy(hdr.oem_table_id, hdrs->oem_table_id,\n\n                sizeof(hdr.oem_table_id));\n\n        ++changed;\n\n    }\n\n\n\n    if (hdrs->has_oem_rev) {\n\n        hdr.oem_revision = cpu_to_le32(hdrs->oem_rev);\n\n        ++changed;\n\n    }\n\n\n\n    if (hdrs->has_asl_compiler_id) {\n\n        /* strncpy is justified: the field need not be NUL-terminated. */\n\n        strncpy(hdr.asl_compiler_id, hdrs->asl_compiler_id,\n\n                sizeof(hdr.asl_compiler_id));\n\n        ++changed;\n\n    }\n\n\n\n    if (hdrs->has_asl_compiler_rev) {\n\n        hdr.asl_compiler_revision = cpu_to_le32(hdrs->asl_compiler_rev);\n\n        ++changed;\n\n    }\n\n\n\n    if (!has_header && !changed) {\n\n        fprintf(stderr, \"warning: acpitable: no table headers are specified\\n\");\n\n    }\n\n\n\n\n\n    /* now calculate checksum of the table, complete with the header */\n\n    /* we may as well leave checksum intact if has_header is true */\n\n    /* alternatively there may be a way to set cksum to a given value */\n\n    hdr.checksum = 0;    /* for checksum calculation */\n\n\n\n    /* put header back */\n\n    memcpy(table_start, &hdr, sizeof(hdr));\n\n\n\n    if (changed || !has_header || 1) {\n\n        ((struct acpi_table_header *)table_start)->checksum =\n\n            acpi_checksum((uint8_t *)table_start + ACPI_TABLE_PFX_SIZE, len);\n\n    }\n\n\n\n    /* increase number of tables */\n\n    (*(uint16_t *)acpi_tables) =\n\n        cpu_to_le32(le32_to_cpu(*(uint16_t *)acpi_tables) + 1);\n\n\n\n    acpi_tables_len = allen;\n\n\n\nout:\n\n    g_strfreev(pathnames);\n\n\n\n    if (hdrs != NULL) {\n\n        QapiDeallocVisitor *dv;\n\n\n\n        dv = qapi_dealloc_visitor_new();\n\n        visit_type_AcpiTableOptions(qapi_dealloc_get_visitor(dv), &hdrs, NULL,\n\n                                    NULL);\n\n        qapi_dealloc_visitor_cleanup(dv);\n\n    }\n\n\n\n    if (err) {\n\n        fprintf(stderr, \"%s\\n\", error_get_pretty(err));\n\n        error_free(err);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9378}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void block_set_params(const MigrationParams *params, void *opaque)\n\n{\n\n    block_mig_state.blk_enable = params->blk;\n\n    block_mig_state.shared_base = params->shared;\n\n\n\n    /* shared base means that blk_enable = 1 */\n\n    block_mig_state.blk_enable |= params->shared;\n\n}\n", "idx": 8035}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void ppc405_ocm_init(CPUPPCState *env)\n\n{\n\n    ppc405_ocm_t *ocm;\n\n\n\n    ocm = g_malloc0(sizeof(ppc405_ocm_t));\n\n    /* XXX: Size is 4096 or 0x04000000 */\n\n    memory_region_init_ram(&ocm->isarc_ram, NULL, \"ppc405.ocm\", 4096,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&ocm->isarc_ram);\n\n    memory_region_init_alias(&ocm->dsarc_ram, NULL, \"ppc405.dsarc\", &ocm->isarc_ram,\n\n                             0, 4096);\n\n    qemu_register_reset(&ocm_reset, ocm);\n\n    ppc_dcr_register(env, OCM0_ISARC,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n    ppc_dcr_register(env, OCM0_ISACNTL,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n    ppc_dcr_register(env, OCM0_DSARC,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n    ppc_dcr_register(env, OCM0_DSACNTL,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n}\n", "idx": 10596}
{"project": "qemu", "commit_id": "eca1bdf415c454093dfc7eb983cd49287c043967", "target": 1, "func": "void cpu_reset (CPUMIPSState *env)\n{\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n    tlb_flush(env, 1);\n    /* Minimal init */\n#if defined(CONFIG_USER_ONLY)\n    env->hflags = MIPS_HFLAG_UM;\n#else\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n        /* If the exception was raised from a delay slot,\n           come back to the jump.  */\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n    } else {\n        env->CP0_ErrorEPC = env->active_tc.PC;\n    env->active_tc.PC = (int32_t)0xBFC00000;\n    env->CP0_Wired = 0;\n    /* SMP not implemented */\n    env->CP0_EBase = 0x80000000;\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n    /* vectored interrupts not implemented, timer on int 7,\n       no performance counters. */\n    env->CP0_IntCtl = 0xe0000000;\n    {\n        int i;\n        for (i = 0; i < 7; i++) {\n            env->CP0_WatchLo[i] = 0;\n            env->CP0_WatchHi[i] = 0x80000000;\n        env->CP0_WatchLo[7] = 0;\n        env->CP0_WatchHi[7] = 0;\n    /* Count register increments in debug mode, EJTAG version 1 */\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n    env->hflags = MIPS_HFLAG_CP0;\n#endif\n    env->exception_index = EXCP_NONE;\n    cpu_mips_register(env, env->cpu_model);", "idx": 8185}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    qemu_put_be16s(f, v);\n\n}\n", "idx": 6032}
{"project": "qemu", "commit_id": "209bef3e014ba1613759575e2c10f0ef8d64eb84", "target": 1, "func": "static int ioreq_runio_qemu_aio(struct ioreq *ioreq)\n\n{\n\n    struct XenBlkDev *blkdev = ioreq->blkdev;\n\n\n\n    if (ioreq->req.nr_segments && ioreq_map(ioreq) == -1)\n\n\tgoto err;\n\n\n\n    ioreq->aio_inflight++;\n\n    if (ioreq->presync)\n\n\tbdrv_flush(blkdev->bs); /* FIXME: aio_flush() ??? */\n\n\n\n    switch (ioreq->req.operation) {\n\n    case BLKIF_OP_READ:\n\n        ioreq->aio_inflight++;\n\n        bdrv_aio_readv(blkdev->bs, ioreq->start / BLOCK_SIZE,\n\n                       &ioreq->v, ioreq->v.size / BLOCK_SIZE,\n\n                       qemu_aio_complete, ioreq);\n\n\tbreak;\n\n    case BLKIF_OP_WRITE:\n\n    case BLKIF_OP_WRITE_BARRIER:\n\n        ioreq->aio_inflight++;\n\n        if (!ioreq->req.nr_segments)\n\n            break;\n\n        bdrv_aio_writev(blkdev->bs, ioreq->start / BLOCK_SIZE,\n\n                        &ioreq->v, ioreq->v.size / BLOCK_SIZE,\n\n                        qemu_aio_complete, ioreq);\n\n\tbreak;\n\n    default:\n\n\t/* unknown operation (shouldn't happen -- parse catches this) */\n\n\tgoto err;\n\n    }\n\n\n\n    if (ioreq->postsync)\n\n\tbdrv_flush(blkdev->bs); /* FIXME: aio_flush() ??? */\n\n    qemu_aio_complete(ioreq, 0);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    ioreq->status = BLKIF_RSP_ERROR;\n\n    return -1;\n\n}\n", "idx": 6296}
{"project": "qemu", "commit_id": "7717f248eebdcfe6de400404d0cf65dcb3633308", "target": 1, "func": "static void openrisc_pic_cpu_handler(void *opaque, int irq, int level)\n\n{\n\n    OpenRISCCPU *cpu = (OpenRISCCPU *)opaque;\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t irq_bit = 1 << irq;\n\n\n\n    if (irq > 31 || irq < 0) {\n\n        return;\n\n    }\n\n\n\n    if (level) {\n\n        cpu->env.picsr |= irq_bit;\n\n    } else {\n\n        cpu->env.picsr &= ~irq_bit;\n\n    }\n\n\n\n    if (cpu->env.picsr & cpu->env.picmr) {\n\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n\n    } else {\n\n        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n\n        cpu->env.picsr = 0;\n\n    }\n\n}\n", "idx": 3196}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "idx": 5565}
{"project": "qemu", "commit_id": "6bdcc018a6ed760b9dfe43539124e420aed83092", "target": 1, "func": "int nbd_client_co_pwrite_zeroes(BlockDriverState *bs, int64_t offset,\n\n                                int count, BdrvRequestFlags flags)\n\n{\n\n    ssize_t ret;\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_WRITE_ZEROES,\n\n        .from = offset,\n\n        .len = count,\n\n    };\n\n    NBDReply reply;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_WRITE_ZEROES)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (flags & BDRV_REQ_FUA) {\n\n        assert(client->nbdflags & NBD_FLAG_SEND_FUA);\n\n        request.flags |= NBD_CMD_FLAG_FUA;\n\n    }\n\n    if (!(flags & BDRV_REQ_MAY_UNMAP)) {\n\n        request.flags |= NBD_CMD_FLAG_NO_HOLE;\n\n    }\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(bs, &request, NULL);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL);\n\n    }\n\n    nbd_coroutine_end(bs, &request);\n\n    return -reply.error;\n\n}\n", "idx": 1098}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "int gdbserver_start(const char *device)\n\n{\n\n    GDBState *s;\n\n    char gdbstub_device_name[128];\n\n    CharDriverState *chr = NULL;\n\n    CharDriverState *mon_chr;\n\n\n\n    if (!device)\n\n        return -1;\n\n    if (strcmp(device, \"none\") != 0) {\n\n        if (strstart(device, \"tcp:\", NULL)) {\n\n            /* enforce required TCP attributes */\n\n            snprintf(gdbstub_device_name, sizeof(gdbstub_device_name),\n\n                     \"%s,nowait,nodelay,server\", device);\n\n            device = gdbstub_device_name;\n\n        }\n\n#ifndef _WIN32\n\n        else if (strcmp(device, \"stdio\") == 0) {\n\n            struct sigaction act;\n\n\n\n            memset(&act, 0, sizeof(act));\n\n            act.sa_handler = gdb_sigterm_handler;\n\n            sigaction(SIGINT, &act, NULL);\n\n        }\n\n#endif\n\n        chr = qemu_chr_new(\"gdb\", device, NULL);\n\n        if (!chr)\n\n            return -1;\n\n\n\n\n        qemu_chr_add_handlers(chr, gdb_chr_can_receive, gdb_chr_receive,\n\n                              gdb_chr_event, NULL);\n\n    }\n\n\n\n    s = gdbserver_state;\n\n    if (!s) {\n\n        s = g_malloc0(sizeof(GDBState));\n\n        gdbserver_state = s;\n\n\n\n        qemu_add_vm_change_state_handler(gdb_vm_state_change, NULL);\n\n\n\n        /* Initialize a monitor terminal for gdb */\n\n        mon_chr = g_malloc0(sizeof(*mon_chr));\n\n        mon_chr->chr_write = gdb_monitor_write;\n\n        monitor_init(mon_chr, 0);\n\n    } else {\n\n        if (s->chr)\n\n            qemu_chr_delete(s->chr);\n\n        mon_chr = s->mon_chr;\n\n        memset(s, 0, sizeof(GDBState));\n\n    }\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->chr = chr;\n\n    s->state = chr ? RS_IDLE : RS_INACTIVE;\n\n    s->mon_chr = mon_chr;\n\n    s->current_syscall_cb = NULL;\n\n\n\n    return 0;\n\n}", "idx": 1073}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 9703}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n", "idx": 6891}
{"project": "qemu", "commit_id": "99577c492fb2916165ed9bc215f058877f0a4106", "target": 1, "func": "SubchDev *css_create_sch(CssDevId bus_id, bool is_virtual, bool squash_mcss,\n\n                         Error **errp)\n\n{\n\n    uint16_t schid = 0;\n\n    SubchDev *sch;\n\n\n\n    if (bus_id.valid) {\n\n        if (is_virtual != (bus_id.cssid == VIRTUAL_CSSID)) {\n\n            error_setg(errp, \"cssid %hhx not valid for %s devices\",\n\n                       bus_id.cssid,\n\n                       (is_virtual ? \"virtual\" : \"non-virtual\"));\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (bus_id.valid) {\n\n        if (squash_mcss) {\n\n            bus_id.cssid = channel_subsys.default_cssid;\n\n        } else if (!channel_subsys.css[bus_id.cssid]) {\n\n            css_create_css_image(bus_id.cssid, false);\n\n        }\n\n\n\n        if (!css_find_free_subch_for_devno(bus_id.cssid, bus_id.ssid,\n\n                                           bus_id.devid, &schid, errp)) {\n\n            return NULL;\n\n        }\n\n    } else if (squash_mcss || is_virtual) {\n\n        bus_id.cssid = channel_subsys.default_cssid;\n\n\n\n        if (!css_find_free_subch_and_devno(bus_id.cssid, &bus_id.ssid,\n\n                                           &bus_id.devid, &schid, errp)) {\n\n            return NULL;\n\n        }\n\n    } else {\n\n        for (bus_id.cssid = 0; bus_id.cssid < MAX_CSSID; ++bus_id.cssid) {\n\n            if (bus_id.cssid == VIRTUAL_CSSID) {\n\n                continue;\n\n            }\n\n\n\n            if (!channel_subsys.css[bus_id.cssid]) {\n\n                css_create_css_image(bus_id.cssid, false);\n\n            }\n\n\n\n            if   (css_find_free_subch_and_devno(bus_id.cssid, &bus_id.ssid,\n\n                                                &bus_id.devid, &schid,\n\n                                                NULL)) {\n\n                break;\n\n            }\n\n            if (bus_id.cssid == MAX_CSSID) {\n\n                error_setg(errp, \"Virtual channel subsystem is full!\");\n\n                return NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    sch = g_new0(SubchDev, 1);\n\n    sch->cssid = bus_id.cssid;\n\n    sch->ssid = bus_id.ssid;\n\n    sch->devno = bus_id.devid;\n\n    sch->schid = schid;\n\n    css_subch_assign(sch->cssid, sch->ssid, schid, sch->devno, sch);\n\n    return sch;\n\n}\n", "idx": 7698}
{"project": "qemu", "commit_id": "480cff632221dc4d4889bf72dd0f09cd35096bc1", "target": 1, "func": "void coroutine_fn qemu_co_mutex_unlock(CoMutex *mutex)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n\n\n    trace_qemu_co_mutex_unlock_entry(mutex, self);\n\n\n\n    assert(mutex->locked);\n\n    assert(mutex->holder == self);\n\n    assert(qemu_in_coroutine());\n\n\n\n    mutex->holder = NULL;\n\n    self->locks_held--;\n\n    if (atomic_fetch_dec(&mutex->locked) == 1) {\n\n        /* No waiting qemu_co_mutex_lock().  Pfew, that was easy!  */\n\n        return;\n\n    }\n\n\n\n    for (;;) {\n\n        CoWaitRecord *to_wake = pop_waiter(mutex);\n\n        unsigned our_handoff;\n\n\n\n        if (to_wake) {\n\n            Coroutine *co = to_wake->co;\n\n            aio_co_wake(co);\n\n            break;\n\n        }\n\n\n\n        /* Some concurrent lock() is in progress (we know this because\n\n         * mutex->locked was >1) but it hasn't yet put itself on the wait\n\n         * queue.  Pick a sequence number for the handoff protocol (not 0).\n\n         */\n\n        if (++mutex->sequence == 0) {\n\n            mutex->sequence = 1;\n\n        }\n\n\n\n        our_handoff = mutex->sequence;\n\n        atomic_mb_set(&mutex->handoff, our_handoff);\n\n        if (!has_waiters(mutex)) {\n\n            /* The concurrent lock has not added itself yet, so it\n\n             * will be able to pick our handoff.\n\n             */\n\n            break;\n\n        }\n\n\n\n        /* Try to do the handoff protocol ourselves; if somebody else has\n\n         * already taken it, however, we're done and they're responsible.\n\n         */\n\n        if (atomic_cmpxchg(&mutex->handoff, our_handoff, 0) != our_handoff) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    trace_qemu_co_mutex_unlock_return(mutex, self);\n\n}\n", "idx": 8588}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    qemu_put_be16s(f, v);\n\n}\n", "idx": 6032}
{"project": "qemu", "commit_id": "398489018183d613306ab022653552247d93919f", "target": 1, "func": "PcGuestInfo *pc_guest_info_init(ram_addr_t below_4g_mem_size,\n\n                                ram_addr_t above_4g_mem_size)\n\n{\n\n    PcGuestInfoState *guest_info_state = g_malloc0(sizeof *guest_info_state);\n\n    PcGuestInfo *guest_info = &guest_info_state->info;\n\n\n\n    guest_info->pci_info.w32.end = IO_APIC_DEFAULT_ADDRESS;\n\n    if (sizeof(hwaddr) == 4) {\n\n        guest_info->pci_info.w64.begin = 0;\n\n        guest_info->pci_info.w64.end = 0;\n\n    } else {\n\n        /*\n\n         * BIOS does not set MTRR entries for the 64 bit window, so no need to\n\n         * align address to power of two.  Align address at 1G, this makes sure\n\n         * it can be exactly covered with a PAT entry even when using huge\n\n         * pages.\n\n         */\n\n        guest_info->pci_info.w64.begin =\n\n            ROUND_UP((0x1ULL << 32) + above_4g_mem_size, 0x1ULL << 30);\n\n        guest_info->pci_info.w64.end = guest_info->pci_info.w64.begin +\n\n            (0x1ULL << 62);\n\n        assert(guest_info->pci_info.w64.begin <= guest_info->pci_info.w64.end);\n\n    }\n\n\n\n    guest_info_state->machine_done.notify = pc_guest_info_machine_done;\n\n    qemu_add_machine_init_done_notifier(&guest_info_state->machine_done);\n\n    return guest_info;\n\n}\n", "idx": 7329}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static int qpa_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    static pa_buffer_attr ba;\n\n    struct audsettings obt_as = *as;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    /*\n\n     * qemu audio tick runs at 250 Hz (by default), so processing\n\n     * data chunks worth 4 ms of sound should be a good fit.\n\n     */\n\n    ba.tlength = pa_usec_to_bytes (4 * 1000, &ss);\n\n    ba.minreq = pa_usec_to_bytes (2 * 1000, &ss);\n\n    ba.maxlength = -1;\n\n    ba.prebuf = -1;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_PLAYBACK,\n\n        conf.sink,\n\n        \"pcm.playback\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        &ba,                    /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for playback failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    pa->rpos = hw->rpos;\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_out, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 5091}
{"project": "qemu", "commit_id": "27463101f15bee17d2f46642c48a7373bc6c595e", "target": 1, "func": "int qemu_eventfd(int *fds)\n\n{\n\n#if defined(SYS_eventfd)\n\n    int ret;\n\n\n\n    ret = syscall(SYS_eventfd, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = fds[1] = ret;\n\n        return 0;\n\n    } else if (!(ret == -1 && errno == ENOSYS))\n\n        return ret;\n\n#endif\n\n\n\n    return pipe(fds);\n\n}\n", "idx": 10842}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "int spapr_vio_send_crq(VIOsPAPRDevice *dev, uint8_t *crq)\n\n{\n\n    int rc;\n\n    uint8_t byte;\n\n\n\n    if (!dev->crq.qsize) {\n\n        fprintf(stderr, \"spapr_vio_send_creq on uninitialized queue\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* Maybe do a fast path for KVM just writing to the pages */\n\n    rc = spapr_tce_dma_read(dev, dev->crq.qladdr + dev->crq.qnext, &byte, 1);\n\n    if (rc) {\n\n        return rc;\n\n    }\n\n    if (byte != 0) {\n\n        return 1;\n\n    }\n\n\n\n    rc = spapr_tce_dma_write(dev, dev->crq.qladdr + dev->crq.qnext + 8,\n\n                             &crq[8], 8);\n\n    if (rc) {\n\n        return rc;\n\n    }\n\n\n\n    kvmppc_eieio();\n\n\n\n    rc = spapr_tce_dma_write(dev, dev->crq.qladdr + dev->crq.qnext, crq, 8);\n\n    if (rc) {\n\n        return rc;\n\n    }\n\n\n\n    dev->crq.qnext = (dev->crq.qnext + 16) % dev->crq.qsize;\n\n\n\n    if (dev->signal_state & 1) {\n\n        qemu_irq_pulse(dev->qirq);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6992}
{"project": "qemu", "commit_id": "cc60e327c0988a5e5288cf7bb78cd9848db800ab", "target": 1, "func": "static int img_rebase(int argc, char **argv)\n\n{\n\n    BlockDriverState *bs, *bs_old_backing, *bs_new_backing;\n\n    BlockDriver *old_backing_drv, *new_backing_drv;\n\n    char *filename;\n\n    const char *fmt, *out_basefmt, *out_baseimg;\n\n    int c, flags, ret;\n\n    int unsafe = 0;\n\n\n\n    /* Parse commandline parameters */\n\n    fmt = NULL;\n\n    out_baseimg = NULL;\n\n    out_basefmt = NULL;\n\n\n\n    for(;;) {\n\n        c = getopt(argc, argv, \"uhf:F:b:\");\n\n        if (c == -1)\n\n            break;\n\n        switch(c) {\n\n        case 'h':\n\n            help();\n\n            return 0;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 'F':\n\n            out_basefmt = optarg;\n\n            break;\n\n        case 'b':\n\n            out_baseimg = optarg;\n\n            break;\n\n        case 'u':\n\n            unsafe = 1;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if ((optind >= argc) || !out_baseimg)\n\n        help();\n\n    filename = argv[optind++];\n\n\n\n    /*\n\n     * Open the images.\n\n     *\n\n     * Ignore the old backing file for unsafe rebase in case we want to correct\n\n     * the reference to a renamed or moved backing file.\n\n     */\n\n    flags = BDRV_O_FLAGS | BDRV_O_RDWR | (unsafe ? BDRV_O_NO_BACKING : 0);\n\n    bs = bdrv_new_open(filename, fmt, flags);\n\n\n\n    /* Find the right drivers for the backing files */\n\n    old_backing_drv = NULL;\n\n    new_backing_drv = NULL;\n\n\n\n    if (!unsafe && bs->backing_format[0] != '\\0') {\n\n        old_backing_drv = bdrv_find_format(bs->backing_format);\n\n        if (old_backing_drv == NULL) {\n\n            error(\"Invalid format name: '%s'\", bs->backing_format);\n\n        }\n\n    }\n\n\n\n    if (out_basefmt != NULL) {\n\n        new_backing_drv = bdrv_find_format(out_basefmt);\n\n        if (new_backing_drv == NULL) {\n\n            error(\"Invalid format name: '%s'\", out_basefmt);\n\n        }\n\n    }\n\n\n\n    /* For safe rebasing we need to compare old and new backing file */\n\n    if (unsafe) {\n\n        /* Make the compiler happy */\n\n        bs_old_backing = NULL;\n\n        bs_new_backing = NULL;\n\n    } else {\n\n        char backing_name[1024];\n\n\n\n        bs_old_backing = bdrv_new(\"old_backing\");\n\n        bdrv_get_backing_filename(bs, backing_name, sizeof(backing_name));\n\n        if (bdrv_open(bs_old_backing, backing_name, BDRV_O_FLAGS,\n\n            old_backing_drv))\n\n        {\n\n            error(\"Could not open old backing file '%s'\", backing_name);\n\n            return -1;\n\n        }\n\n\n\n        bs_new_backing = bdrv_new(\"new_backing\");\n\n        if (bdrv_open(bs_new_backing, out_baseimg, BDRV_O_FLAGS | BDRV_O_RDWR,\n\n            new_backing_drv))\n\n        {\n\n            error(\"Could not open new backing file '%s'\", out_baseimg);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * Check each unallocated cluster in the COW file. If it is unallocated,\n\n     * accesses go to the backing file. We must therefore compare this cluster\n\n     * in the old and new backing file, and if they differ we need to copy it\n\n     * from the old backing file into the COW file.\n\n     *\n\n     * If qemu-img crashes during this step, no harm is done. The content of\n\n     * the image is the same as the original one at any time.\n\n     */\n\n    if (!unsafe) {\n\n        uint64_t num_sectors;\n\n        uint64_t sector;\n\n        int n, n1;\n\n        uint8_t * buf_old;\n\n        uint8_t * buf_new;\n\n\n\n        buf_old = qemu_malloc(IO_BUF_SIZE);\n\n        buf_new = qemu_malloc(IO_BUF_SIZE);\n\n\n\n        bdrv_get_geometry(bs, &num_sectors);\n\n\n\n        for (sector = 0; sector < num_sectors; sector += n) {\n\n\n\n            /* How many sectors can we handle with the next read? */\n\n            if (sector + (IO_BUF_SIZE / 512) <= num_sectors) {\n\n                n = (IO_BUF_SIZE / 512);\n\n            } else {\n\n                n = num_sectors - sector;\n\n            }\n\n\n\n            /* If the cluster is allocated, we don't need to take action */\n\n            if (bdrv_is_allocated(bs, sector, n, &n1)) {\n\n                n = n1;\n\n                continue;\n\n            }\n\n\n\n            /* Read old and new backing file */\n\n            if (bdrv_read(bs_old_backing, sector, buf_old, n) < 0) {\n\n                error(\"error while reading from old backing file\");\n\n            }\n\n            if (bdrv_read(bs_new_backing, sector, buf_new, n) < 0) {\n\n                error(\"error while reading from new backing file\");\n\n            }\n\n\n\n            /* If they differ, we need to write to the COW file */\n\n            uint64_t written = 0;\n\n\n\n            while (written < n) {\n\n                int pnum;\n\n\n\n                if (compare_sectors(buf_old + written * 512,\n\n                    buf_new + written * 512, n - written, &pnum))\n\n                {\n\n                    ret = bdrv_write(bs, sector + written,\n\n                        buf_old + written * 512, pnum);\n\n                    if (ret < 0) {\n\n                        error(\"Error while writing to COW image: %s\",\n\n                            strerror(-ret));\n\n                    }\n\n                }\n\n\n\n                written += pnum;\n\n            }\n\n        }\n\n\n\n        qemu_free(buf_old);\n\n        qemu_free(buf_new);\n\n    }\n\n\n\n    /*\n\n     * Change the backing file. All clusters that are different from the old\n\n     * backing file are overwritten in the COW file now, so the visible content\n\n     * doesn't change when we switch the backing file.\n\n     */\n\n    ret = bdrv_change_backing_file(bs, out_baseimg, out_basefmt);\n\n    if (ret == -ENOSPC) {\n\n        error(\"Could not change the backing file to '%s': No space left in \"\n\n            \"the file header\", out_baseimg);\n\n    } else if (ret < 0) {\n\n        error(\"Could not change the backing file to '%s': %s\",\n\n            out_baseimg, strerror(-ret));\n\n    }\n\n\n\n    /*\n\n     * TODO At this point it is possible to check if any clusters that are\n\n     * allocated in the COW file are the same in the backing file. If so, they\n\n     * could be dropped from the COW file. Don't do this before switching the\n\n     * backing file, in case of a crash this would lead to corruption.\n\n     */\n\n\n\n    /* Cleanup */\n\n    if (!unsafe) {\n\n        bdrv_delete(bs_old_backing);\n\n        bdrv_delete(bs_new_backing);\n\n    }\n\n\n\n    bdrv_delete(bs);\n\n\n\n    return 0;\n\n}\n", "idx": 2709}
{"project": "qemu", "commit_id": "3996e85c1822e05c50250f8d2d1e57b6bea1229d", "target": 1, "func": "static void xen_set_memory(struct MemoryListener *listener,\n\n                           MemoryRegionSection *section,\n\n                           bool add)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n    hwaddr start_addr = section->offset_within_address_space;\n\n    ram_addr_t size = int128_get64(section->size);\n\n    bool log_dirty = memory_region_is_logging(section->mr);\n\n    hvmmem_type_t mem_type;\n\n\n\n    if (!memory_region_is_ram(section->mr)) {\n\n        return;\n\n    }\n\n\n\n    if (!(section->mr != &ram_memory\n\n          && ( (log_dirty && add) || (!log_dirty && !add)))) {\n\n        return;\n\n    }\n\n\n\n    trace_xen_client_set_memory(start_addr, size, log_dirty);\n\n\n\n    start_addr &= TARGET_PAGE_MASK;\n\n    size = TARGET_PAGE_ALIGN(size);\n\n\n\n    if (add) {\n\n        if (!memory_region_is_rom(section->mr)) {\n\n            xen_add_to_physmap(state, start_addr, size,\n\n                               section->mr, section->offset_within_region);\n\n        } else {\n\n            mem_type = HVMMEM_ram_ro;\n\n            if (xc_hvm_set_mem_type(xen_xc, xen_domid, mem_type,\n\n                                    start_addr >> TARGET_PAGE_BITS,\n\n                                    size >> TARGET_PAGE_BITS)) {\n\n                DPRINTF(\"xc_hvm_set_mem_type error, addr: \"TARGET_FMT_plx\"\\n\",\n\n                        start_addr);\n\n            }\n\n        }\n\n    } else {\n\n        if (xen_remove_from_physmap(state, start_addr, size) < 0) {\n\n            DPRINTF(\"physmapping does not exist at \"TARGET_FMT_plx\"\\n\", start_addr);\n\n        }\n\n    }\n\n}\n", "idx": 8223}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_getlock(void *opaque)\n{\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsGetlock *glock;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    glock = g_malloc(sizeof(*glock));\n    pdu_unmarshal(pdu, offset, \"dbqqds\", &fid, &glock->type,\n                  &glock->start, &glock->length, &glock->proc_id,\n                  &glock->client_id);\n    trace_v9fs_getlock(pdu->tag, pdu->id, fid,\n                       glock->type, glock->start, glock->length);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp->fs.fd, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    glock->type = P9_LOCK_TYPE_UNLCK;\n    offset += pdu_marshal(pdu, offset, \"bqqds\", glock->type,\n                          glock->start, glock->length, glock->proc_id,\n                          &glock->client_id);\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    complete_pdu(s, pdu, err);\n    v9fs_string_free(&glock->client_id);\n    g_free(glock);\n}", "idx": 3570}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "uint32_t gic_acknowledge_irq(GICState *s, int cpu, MemTxAttrs attrs)\n\n{\n\n    int ret, irq, src;\n\n    int cm = 1 << cpu;\n\n\n\n    /* gic_get_current_pending_irq() will return 1022 or 1023 appropriately\n\n     * for the case where this GIC supports grouping and the pending interrupt\n\n     * is in the wrong group.\n\n     */\n\n    irq = gic_get_current_pending_irq(s, cpu, attrs);\n\n\n\n\n    if (irq >= GIC_MAXIRQ) {\n\n        DPRINTF(\"ACK, no pending interrupt or it is hidden: %d\\n\", irq);\n\n        return irq;\n\n    }\n\n\n\n    if (GIC_GET_PRIORITY(irq, cpu) >= s->running_priority[cpu]) {\n\n        DPRINTF(\"ACK, pending interrupt (%d) has insufficient priority\\n\", irq);\n\n        return 1023;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        /* Clear pending flags for both level and edge triggered interrupts.\n\n         * Level triggered IRQs will be reasserted once they become inactive.\n\n         */\n\n        GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n        ret = irq;\n\n    } else {\n\n        if (irq < GIC_NR_SGIS) {\n\n            /* Lookup the source CPU for the SGI and clear this in the\n\n             * sgi_pending map.  Return the src and clear the overall pending\n\n             * state on this CPU if the SGI is not pending from any CPUs.\n\n             */\n\n            assert(s->sgi_pending[irq][cpu] != 0);\n\n            src = ctz32(s->sgi_pending[irq][cpu]);\n\n            s->sgi_pending[irq][cpu] &= ~(1 << src);\n\n            if (s->sgi_pending[irq][cpu] == 0) {\n\n                GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            }\n\n            ret = irq | ((src & 0x7) << 10);\n\n        } else {\n\n            /* Clear pending state for both level and edge triggered\n\n             * interrupts. (level triggered interrupts with an active line\n\n             * remain pending, see gic_test_pending)\n\n             */\n\n            GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            ret = irq;\n\n        }\n\n    }\n\n\n\n    gic_activate_irq(s, cpu, irq);\n\n    gic_update(s);\n\n    DPRINTF(\"ACK %d\\n\", irq);\n\n    return ret;\n\n}", "idx": 3331}
{"project": "qemu", "commit_id": "f4658285f99473367dbbc34ce6970ec4637c2388", "target": 1, "func": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    QLIST_REMOVE(req, list);\n\n\n}", "idx": 9815}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n", "idx": 2243}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static void audio_capture(void *opaque, void *buf, int size)\n\n{\n\n    VncState *vs = opaque;\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 4984}
{"project": "qemu", "commit_id": "79c5a10cdda1aed00d7ee4ef87de2ef8c854f4a5", "target": 1, "func": "static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor)\n\n{\n\n    QEMUCursor *c;\n\n    uint8_t *image, *mask;\n\n    size_t size;\n\n\n\n    c = cursor_alloc(cursor->header.width, cursor->header.height);\n\n    c->hot_x = cursor->header.hot_spot_x;\n\n    c->hot_y = cursor->header.hot_spot_y;\n\n    switch (cursor->header.type) {\n\n    case SPICE_CURSOR_TYPE_ALPHA:\n\n        size = sizeof(uint32_t) * cursor->header.width * cursor->header.height;\n\n        memcpy(c->data, cursor->chunk.data, size);\n\n        if (qxl->debug > 2) {\n\n            cursor_print_ascii_art(c, \"qxl/alpha\");\n\n        }\n\n        break;\n\n    case SPICE_CURSOR_TYPE_MONO:\n\n        mask  = cursor->chunk.data;\n\n        image = mask + cursor_get_mono_bpl(c) * c->width;\n\n        cursor_set_mono(c, 0xffffff, 0x000000, image, 1, mask);\n\n        if (qxl->debug > 2) {\n\n            cursor_print_ascii_art(c, \"qxl/mono\");\n\n        }\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: not implemented: type %d\\n\",\n\n                __FUNCTION__, cursor->header.type);\n\n        goto fail;\n\n    }\n\n    return c;\n\n\n\nfail:\n\n    cursor_put(c);\n\n    return NULL;\n\n}\n", "idx": 11053}
{"project": "qemu", "commit_id": "d8b2239bcd8872a5c5f7534d1658fc2365caab2d", "target": 1, "func": "bool cpu_restore_state(CPUState *cpu, uintptr_t retaddr)\n{\n    TranslationBlock *tb;\n    bool r = false;\n    tb_lock();\n    tb = tb_find_pc(retaddr);\n    if (tb) {\n        cpu_restore_state_from_tb(cpu, tb, retaddr);\n        if (tb->cflags & CF_NOCACHE) {\n            /* one-shot translation, invalidate it immediately */\n            tb_phys_invalidate(tb, -1);\n            tb_free(tb);\n        r = true;\n    tb_unlock();", "idx": 3964}
{"project": "qemu", "commit_id": "d17008bc2914d62fd0af6a8f313604ae9f9a102c", "target": 1, "func": "static uint32_t hpet_time_after64(uint64_t a, uint64_t b)\n\n{\n\n    return ((int64_t)(b) - (int64_t)(a) < 0);\n\n}\n", "idx": 4670}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbivax_booke206(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n\n\n    gen_helper_booke206_tlbivax(cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 10202}
{"project": "qemu", "commit_id": "14b6160099f0caf5dc9d62e637b007bc5d719a96", "target": 1, "func": "QBool *qobject_to_qbool(const QObject *obj)\n\n{\n\n    if (qobject_type(obj) != QTYPE_QBOOL)\n\n        return NULL;\n\n\n\n    return container_of(obj, QBool, base);\n\n}\n", "idx": 1122}
{"project": "qemu", "commit_id": "c4843a45e3d4f3698b214275ab5e78cdb6a3d212", "target": 1, "func": "static int vhost_user_reset_device(struct vhost_dev *dev)\n\n{\n\n    VhostUserMsg msg = {\n\n        .request = VHOST_USER_RESET_OWNER,\n\n        .flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    vhost_user_write(dev, &msg, NULL, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 10903}
{"project": "qemu", "commit_id": "3977ee5d7a9f2e3664dd8b233f3224694e23b62b", "target": 1, "func": "static int disas_coproc_insn(DisasContext *s, uint32_t insn)\n\n{\n\n    int cpnum, is64, crn, crm, opc1, opc2, isread, rt, rt2;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    cpnum = (insn >> 8) & 0xf;\n\n\n\n    /* First check for coprocessor space used for XScale/iwMMXt insns */\n\n    if (arm_dc_feature(s, ARM_FEATURE_XSCALE) && (cpnum < 2)) {\n\n        if (extract32(s->c15_cpar, cpnum, 1) == 0) {\n\n            return 1;\n\n        }\n\n        if (arm_dc_feature(s, ARM_FEATURE_IWMMXT)) {\n\n            return disas_iwmmxt_insn(s, insn);\n\n        } else if (arm_dc_feature(s, ARM_FEATURE_XSCALE)) {\n\n            return disas_dsp_insn(s, insn);\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* Otherwise treat as a generic register access */\n\n    is64 = (insn & (1 << 25)) == 0;\n\n    if (!is64 && ((insn & (1 << 4)) == 0)) {\n\n        /* cdp */\n\n        return 1;\n\n    }\n\n\n\n    crm = insn & 0xf;\n\n    if (is64) {\n\n        crn = 0;\n\n        opc1 = (insn >> 4) & 0xf;\n\n        opc2 = 0;\n\n        rt2 = (insn >> 16) & 0xf;\n\n    } else {\n\n        crn = (insn >> 16) & 0xf;\n\n        opc1 = (insn >> 21) & 7;\n\n        opc2 = (insn >> 5) & 7;\n\n        rt2 = 0;\n\n    }\n\n    isread = (insn >> 20) & 1;\n\n    rt = (insn >> 12) & 0xf;\n\n\n\n    ri = get_arm_cp_reginfo(s->cp_regs,\n\n            ENCODE_CP_REG(cpnum, is64, s->ns, crn, crm, opc1, opc2));\n\n    if (ri) {\n\n        /* Check access permissions */\n\n        if (!cp_access_ok(s->current_el, ri, isread)) {\n\n            return 1;\n\n        }\n\n\n\n        if (ri->accessfn ||\n\n            (arm_dc_feature(s, ARM_FEATURE_XSCALE) && cpnum < 14)) {\n\n            /* Emit code to perform further access permissions checks at\n\n             * runtime; this may result in an exception.\n\n             * Note that on XScale all cp0..c13 registers do an access check\n\n             * call in order to handle c15_cpar.\n\n             */\n\n            TCGv_ptr tmpptr;\n\n            TCGv_i32 tcg_syn;\n\n            uint32_t syndrome;\n\n\n\n            /* Note that since we are an implementation which takes an\n\n             * exception on a trapped conditional instruction only if the\n\n             * instruction passes its condition code check, we can take\n\n             * advantage of the clause in the ARM ARM that allows us to set\n\n             * the COND field in the instruction to 0xE in all cases.\n\n             * We could fish the actual condition out of the insn (ARM)\n\n             * or the condexec bits (Thumb) but it isn't necessary.\n\n             */\n\n            switch (cpnum) {\n\n            case 14:\n\n                if (is64) {\n\n                    syndrome = syn_cp14_rrt_trap(1, 0xe, opc1, crm, rt, rt2,\n\n                                                 isread, s->thumb);\n\n                } else {\n\n                    syndrome = syn_cp14_rt_trap(1, 0xe, opc1, opc2, crn, crm,\n\n                                                rt, isread, s->thumb);\n\n                }\n\n                break;\n\n            case 15:\n\n                if (is64) {\n\n                    syndrome = syn_cp15_rrt_trap(1, 0xe, opc1, crm, rt, rt2,\n\n                                                 isread, s->thumb);\n\n                } else {\n\n                    syndrome = syn_cp15_rt_trap(1, 0xe, opc1, opc2, crn, crm,\n\n                                                rt, isread, s->thumb);\n\n                }\n\n                break;\n\n            default:\n\n                /* ARMv8 defines that only coprocessors 14 and 15 exist,\n\n                 * so this can only happen if this is an ARMv7 or earlier CPU,\n\n                 * in which case the syndrome information won't actually be\n\n                 * guest visible.\n\n                 */\n\n                assert(!arm_dc_feature(s, ARM_FEATURE_V8));\n\n                syndrome = syn_uncategorized();\n\n                break;\n\n            }\n\n\n\n            gen_set_pc_im(s, s->pc);\n\n            tmpptr = tcg_const_ptr(ri);\n\n            tcg_syn = tcg_const_i32(syndrome);\n\n            gen_helper_access_check_cp_reg(cpu_env, tmpptr, tcg_syn);\n\n            tcg_temp_free_ptr(tmpptr);\n\n            tcg_temp_free_i32(tcg_syn);\n\n        }\n\n\n\n        /* Handle special cases first */\n\n        switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n\n        case ARM_CP_NOP:\n\n            return 0;\n\n        case ARM_CP_WFI:\n\n            if (isread) {\n\n                return 1;\n\n            }\n\n            gen_set_pc_im(s, s->pc);\n\n            s->is_jmp = DISAS_WFI;\n\n            return 0;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        if ((s->tb->cflags & CF_USE_ICOUNT) && (ri->type & ARM_CP_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (isread) {\n\n            /* Read */\n\n            if (is64) {\n\n                TCGv_i64 tmp64;\n\n                TCGv_i32 tmp;\n\n                if (ri->type & ARM_CP_CONST) {\n\n                    tmp64 = tcg_const_i64(ri->resetvalue);\n\n                } else if (ri->readfn) {\n\n                    TCGv_ptr tmpptr;\n\n                    tmp64 = tcg_temp_new_i64();\n\n                    tmpptr = tcg_const_ptr(ri);\n\n                    gen_helper_get_cp_reg64(tmp64, cpu_env, tmpptr);\n\n                    tcg_temp_free_ptr(tmpptr);\n\n                } else {\n\n                    tmp64 = tcg_temp_new_i64();\n\n                    tcg_gen_ld_i64(tmp64, cpu_env, ri->fieldoffset);\n\n                }\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                store_reg(s, rt, tmp);\n\n                tcg_gen_shri_i64(tmp64, tmp64, 32);\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                store_reg(s, rt2, tmp);\n\n            } else {\n\n                TCGv_i32 tmp;\n\n                if (ri->type & ARM_CP_CONST) {\n\n                    tmp = tcg_const_i32(ri->resetvalue);\n\n                } else if (ri->readfn) {\n\n                    TCGv_ptr tmpptr;\n\n                    tmp = tcg_temp_new_i32();\n\n                    tmpptr = tcg_const_ptr(ri);\n\n                    gen_helper_get_cp_reg(tmp, cpu_env, tmpptr);\n\n                    tcg_temp_free_ptr(tmpptr);\n\n                } else {\n\n                    tmp = load_cpu_offset(ri->fieldoffset);\n\n                }\n\n                if (rt == 15) {\n\n                    /* Destination register of r15 for 32 bit loads sets\n\n                     * the condition codes from the high 4 bits of the value\n\n                     */\n\n                    gen_set_nzcv(tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else {\n\n                    store_reg(s, rt, tmp);\n\n                }\n\n            }\n\n        } else {\n\n            /* Write */\n\n            if (ri->type & ARM_CP_CONST) {\n\n                /* If not forbidden by access permissions, treat as WI */\n\n                return 0;\n\n            }\n\n\n\n            if (is64) {\n\n                TCGv_i32 tmplo, tmphi;\n\n                TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n                tmplo = load_reg(s, rt);\n\n                tmphi = load_reg(s, rt2);\n\n                tcg_gen_concat_i32_i64(tmp64, tmplo, tmphi);\n\n                tcg_temp_free_i32(tmplo);\n\n                tcg_temp_free_i32(tmphi);\n\n                if (ri->writefn) {\n\n                    TCGv_ptr tmpptr = tcg_const_ptr(ri);\n\n                    gen_helper_set_cp_reg64(cpu_env, tmpptr, tmp64);\n\n                    tcg_temp_free_ptr(tmpptr);\n\n                } else {\n\n                    tcg_gen_st_i64(tmp64, cpu_env, ri->fieldoffset);\n\n                }\n\n                tcg_temp_free_i64(tmp64);\n\n            } else {\n\n                if (ri->writefn) {\n\n                    TCGv_i32 tmp;\n\n                    TCGv_ptr tmpptr;\n\n                    tmp = load_reg(s, rt);\n\n                    tmpptr = tcg_const_ptr(ri);\n\n                    gen_helper_set_cp_reg(cpu_env, tmpptr, tmp);\n\n                    tcg_temp_free_ptr(tmpptr);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else {\n\n                    TCGv_i32 tmp = load_reg(s, rt);\n\n                    store_cpu_offset(tmp, ri->fieldoffset);\n\n                }\n\n            }\n\n        }\n\n\n\n        if ((s->tb->cflags & CF_USE_ICOUNT) && (ri->type & ARM_CP_IO)) {\n\n            /* I/O operations must end the TB here (whether read or write) */\n\n            gen_io_end();\n\n            gen_lookup_tb(s);\n\n        } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n\n            /* We default to ending the TB on a coprocessor register write,\n\n             * but allow this to be suppressed by the register definition\n\n             * (usually only necessary to work around guest bugs).\n\n             */\n\n            gen_lookup_tb(s);\n\n        }\n\n\n\n        return 0;\n\n    }\n\n\n\n    /* Unknown register; this might be a guest error or a QEMU\n\n     * unimplemented feature.\n\n     */\n\n    if (is64) {\n\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch32 \"\n\n                      \"64 bit system register cp:%d opc1: %d crm:%d \"\n\n                      \"(%s)\\n\",\n\n                      isread ? \"read\" : \"write\", cpnum, opc1, crm,\n\n                      s->ns ? \"non-secure\" : \"secure\");\n\n    } else {\n\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch32 \"\n\n                      \"system register cp:%d opc1:%d crn:%d crm:%d opc2:%d \"\n\n                      \"(%s)\\n\",\n\n                      isread ? \"read\" : \"write\", cpnum, opc1, crn, crm, opc2,\n\n                      s->ns ? \"non-secure\" : \"secure\");\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 2950}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "void hmp_pci_del(Monitor *mon, const QDict *qdict)\n\n{\n\n    pci_device_hot_remove(mon, qdict_get_str(qdict, \"pci_addr\"));\n\n}\n", "idx": 10298}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10358}
{"project": "qemu", "commit_id": "2a32c6e82ed24d837ce7af346ffc93113f0164b5", "target": 1, "func": "static void external_snapshot_prepare(BlkActionState *common,\n\n                                      Error **errp)\n\n{\n\n    int flags = 0;\n\n    QDict *options = NULL;\n\n    Error *local_err = NULL;\n\n    /* Device and node name of the image to generate the snapshot from */\n\n    const char *device;\n\n    const char *node_name;\n\n    /* Reference to the new image (for 'blockdev-snapshot') */\n\n    const char *snapshot_ref;\n\n    /* File name of the new image (for 'blockdev-snapshot-sync') */\n\n    const char *new_image_file;\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n    TransactionAction *action = common->action;\n\n\n\n    /* 'blockdev-snapshot' and 'blockdev-snapshot-sync' have similar\n\n     * purpose but a different set of parameters */\n\n    switch (action->type) {\n\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT:\n\n        {\n\n            BlockdevSnapshot *s = action->u.blockdev_snapshot.data;\n\n            device = s->node;\n\n            node_name = s->node;\n\n            new_image_file = NULL;\n\n            snapshot_ref = s->overlay;\n\n        }\n\n        break;\n\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC:\n\n        {\n\n            BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync.data;\n\n            device = s->has_device ? s->device : NULL;\n\n            node_name = s->has_node_name ? s->node_name : NULL;\n\n            new_image_file = s->snapshot_file;\n\n            snapshot_ref = NULL;\n\n        }\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* start processing */\n\n    if (action_check_completion_mode(common, errp) < 0) {\n\n        return;\n\n    }\n\n\n\n    state->old_bs = bdrv_lookup_bs(device, node_name, errp);\n\n    if (!state->old_bs) {\n\n        return;\n\n    }\n\n\n\n    /* Acquire AioContext now so any threads operating on old_bs stop */\n\n    state->aio_context = bdrv_get_aio_context(state->old_bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(state->old_bs);\n\n\n\n    if (!bdrv_is_inserted(state->old_bs)) {\n\n        error_setg(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(state->old_bs,\n\n                           BLOCK_OP_TYPE_EXTERNAL_SNAPSHOT, errp)) {\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_read_only(state->old_bs)) {\n\n        if (bdrv_flush(state->old_bs)) {\n\n            error_setg(errp, QERR_IO_ERROR);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!bdrv_is_first_non_filter(state->old_bs)) {\n\n        error_setg(errp, QERR_FEATURE_DISABLED, \"snapshot\");\n\n        return;\n\n    }\n\n\n\n    if (action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC) {\n\n        BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync.data;\n\n        const char *format = s->has_format ? s->format : \"qcow2\";\n\n        enum NewImageMode mode;\n\n        const char *snapshot_node_name =\n\n            s->has_snapshot_node_name ? s->snapshot_node_name : NULL;\n\n\n\n        if (node_name && !snapshot_node_name) {\n\n            error_setg(errp, \"New snapshot node name missing\");\n\n            return;\n\n        }\n\n\n\n        if (snapshot_node_name &&\n\n            bdrv_lookup_bs(snapshot_node_name, snapshot_node_name, NULL)) {\n\n            error_setg(errp, \"New snapshot node name already in use\");\n\n            return;\n\n        }\n\n\n\n        flags = state->old_bs->open_flags;\n\n        flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING | BDRV_O_COPY_ON_READ);\n\n\n\n        /* create new image w/backing file */\n\n        mode = s->has_mode ? s->mode : NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n        if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n            int64_t size = bdrv_getlength(state->old_bs);\n\n            if (size < 0) {\n\n                error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n                return;\n\n            }\n\n            bdrv_img_create(new_image_file, format,\n\n                            state->old_bs->filename,\n\n                            state->old_bs->drv->format_name,\n\n                            NULL, size, flags, false, &local_err);\n\n            if (local_err) {\n\n                error_propagate(errp, local_err);\n\n                return;\n\n            }\n\n        }\n\n\n\n        options = qdict_new();\n\n        if (s->has_snapshot_node_name) {\n\n            qdict_put_str(options, \"node-name\", snapshot_node_name);\n\n        }\n\n        qdict_put_str(options, \"driver\", format);\n\n\n\n        flags |= BDRV_O_NO_BACKING;\n\n    }\n\n\n\n    state->new_bs = bdrv_open(new_image_file, snapshot_ref, options, flags,\n\n                              errp);\n\n    /* We will manually add the backing_hd field to the bs later */\n\n    if (!state->new_bs) {\n\n        return;\n\n    }\n\n\n\n    if (bdrv_has_blk(state->new_bs)) {\n\n        error_setg(errp, \"The snapshot is already in use\");\n\n        return;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(state->new_bs, BLOCK_OP_TYPE_EXTERNAL_SNAPSHOT,\n\n                           errp)) {\n\n        return;\n\n    }\n\n\n\n    if (state->new_bs->backing != NULL) {\n\n        error_setg(errp, \"The snapshot already has a backing image\");\n\n        return;\n\n    }\n\n\n\n    if (!state->new_bs->drv->supports_backing) {\n\n        error_setg(errp, \"The snapshot does not support backing images\");\n\n        return;\n\n    }\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs. This is an operation that\n\n     * can fail, so we need to do it in .prepare; undoing it for abort is\n\n     * always possible. */\n\n    bdrv_ref(state->new_bs);\n\n    bdrv_append(state->new_bs, state->old_bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    state->overlay_appended = true;\n\n}\n", "idx": 9386}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,\n\n                                      uint8_t ep)\n\n{\n\n    AsyncURB *aurb = async_alloc(dev, p);\n\n    struct usb_redir_bulk_packet_header bulk_packet;\n\n\n\n    DPRINTF(\"bulk-out ep %02X len %d id %u\\n\", ep, p->len, aurb->packet_id);\n\n\n\n    bulk_packet.endpoint  = ep;\n\n    bulk_packet.length    = p->len;\n\n    bulk_packet.stream_id = 0;\n\n    aurb->bulk_packet = bulk_packet;\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        usbredirparser_send_bulk_packet(dev->parser, aurb->packet_id,\n\n                                        &bulk_packet, NULL, 0);\n\n    } else {\n\n        usbredir_log_data(dev, \"bulk data out:\", p->data, p->len);\n\n        usbredirparser_send_bulk_packet(dev->parser, aurb->packet_id,\n\n                                        &bulk_packet, p->data, p->len);\n\n    }\n\n    usbredirparser_do_write(dev->parser);\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 8716}
{"project": "qemu", "commit_id": "de1c90cf8b73992b4197561850d2da1075fb82eb", "target": 1, "func": "static void qemu_event_increment(void)\n\n{\n\n    SetEvent(qemu_event_handle);\n\n}\n", "idx": 6710}
{"project": "qemu", "commit_id": "81bad50ec40311797c38a7691844c7d2df9b3823", "target": 1, "func": "target_ulong helper_dvpe(CPUMIPSState *env)\n\n{\n\n    CPUMIPSState *other_cpu = first_cpu;\n\n    target_ulong prev = env->mvp->CP0_MVPControl;\n\n\n\n    do {\n\n        /* Turn off all VPEs except the one executing the dvpe.  */\n\n        if (other_cpu != env) {\n\n            other_cpu->mvp->CP0_MVPControl &= ~(1 << CP0MVPCo_EVP);\n\n            mips_vpe_sleep(other_cpu);\n\n        }\n\n        other_cpu = other_cpu->next_cpu;\n\n    } while (other_cpu);\n\n    return prev;\n\n}\n", "idx": 9526}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "uint64_t qpci_io_readq(QPCIDevice *dev, void *data)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    if (addr < QPCI_PIO_LIMIT) {\n\n        return dev->bus->pio_readq(dev->bus, addr);\n\n    } else {\n\n        uint64_t val;\n\n        dev->bus->memread(dev->bus, addr, &val, sizeof(val));\n\n        return le64_to_cpu(val);\n\n    }\n\n}\n", "idx": 8216}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int archipelago_aio_segmented_rw(BDRVArchipelagoState *s,\n\n                                        size_t count,\n\n                                        off_t offset,\n\n                                        ArchipelagoAIOCB *aio_cb,\n\n                                        int op)\n\n{\n\n    int i, ret, segments_nr, last_segment_size;\n\n    ArchipelagoSegmentedRequest *segreq;\n\n\n\n    segreq = g_malloc(sizeof(ArchipelagoSegmentedRequest));\n\n\n\n    if (op == ARCHIP_OP_FLUSH) {\n\n        segments_nr = 1;\n\n        segreq->ref = segments_nr;\n\n        segreq->total = count;\n\n        segreq->count = 0;\n\n        segreq->failed = 0;\n\n        ret = archipelago_submit_request(s, 0, count, offset, aio_cb,\n\n                                           segreq, ARCHIP_OP_FLUSH);\n\n        if (ret < 0) {\n\n            goto err_exit;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    segments_nr = (int)(count / MAX_REQUEST_SIZE) + \\\n\n                  ((count % MAX_REQUEST_SIZE) ? 1 : 0);\n\n    last_segment_size = (int)(count % MAX_REQUEST_SIZE);\n\n\n\n    segreq->ref = segments_nr;\n\n    segreq->total = count;\n\n    segreq->count = 0;\n\n    segreq->failed = 0;\n\n\n\n    for (i = 0; i < segments_nr - 1; i++) {\n\n        ret = archipelago_submit_request(s, i * MAX_REQUEST_SIZE,\n\n                                           MAX_REQUEST_SIZE,\n\n                                           offset + i * MAX_REQUEST_SIZE,\n\n                                           aio_cb, segreq, op);\n\n\n\n        if (ret < 0) {\n\n            goto err_exit;\n\n        }\n\n    }\n\n\n\n    if ((segments_nr > 1) && last_segment_size) {\n\n        ret = archipelago_submit_request(s, i * MAX_REQUEST_SIZE,\n\n                                           last_segment_size,\n\n                                           offset + i * MAX_REQUEST_SIZE,\n\n                                           aio_cb, segreq, op);\n\n    } else if ((segments_nr > 1) && !last_segment_size) {\n\n        ret = archipelago_submit_request(s, i * MAX_REQUEST_SIZE,\n\n                                           MAX_REQUEST_SIZE,\n\n                                           offset + i * MAX_REQUEST_SIZE,\n\n                                           aio_cb, segreq, op);\n\n    } else if (segments_nr == 1) {\n\n            ret = archipelago_submit_request(s, 0, count, offset, aio_cb,\n\n                                               segreq, op);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto err_exit;\n\n    }\n\n\n\n    return 0;\n\n\n\nerr_exit:\n\n    __sync_add_and_fetch(&segreq->failed, 1);\n\n    if (segments_nr == 1) {\n\n        if (__sync_add_and_fetch(&segreq->ref, -1) == 0) {\n\n            g_free(segreq);\n\n        }\n\n    } else {\n\n        if ((__sync_add_and_fetch(&segreq->ref, -segments_nr + i)) == 0) {\n\n            g_free(segreq);\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 4145}
{"project": "qemu", "commit_id": "56439e9d55626b65ecb887f1ac3714652555312e", "target": 1, "func": "static coroutine_fn int qcow_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    int ret = 0, n;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    /* We must always copy the iov when encrypting, so we\n\n     * don't modify the original data buffer during encryption */\n\n    if (bs->encrypted || qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n        qemu_iovec_to_buf(qiov, 0, buf, qiov->size);\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9, 1, 0,\n\n                                            index_in_cluster,\n\n                                            index_in_cluster + n);\n\n        if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n        if (bs->encrypted) {\n\n            assert(s->crypto);\n\n            if (qcrypto_block_encrypt(s->crypto, sector_num, buf,\n\n                                      n * BDRV_SECTOR_SIZE, NULL) < 0) {\n\n                ret = -EIO;\n\n                break;\n\n            }\n\n        }\n\n\n\n        hd_iov.iov_base = (void *)buf;\n\n        hd_iov.iov_len = n * 512;\n\n        qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             n, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_vfree(orig_buf);\n\n\n\n    return ret;\n\n}\n", "idx": 1057}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "static void mips_jazz_init(MemoryRegion *address_space,\n\n                           MemoryRegion *address_space_io,\n\n                           ram_addr_t ram_size,\n\n                           const char *cpu_model,\n\n                           enum jazz_model_e jazz_model)\n\n{\n\n    char *filename;\n\n    int bios_size, n;\n\n    MIPSCPU *cpu;\n\n    CPUMIPSState *env;\n\n    qemu_irq *rc4030, *i8259;\n\n    rc4030_dma *dmas;\n\n    void* rc4030_opaque;\n\n    MemoryRegion *rtc = g_new(MemoryRegion, 1);\n\n    MemoryRegion *i8042 = g_new(MemoryRegion, 1);\n\n    MemoryRegion *dma_dummy = g_new(MemoryRegion, 1);\n\n    NICInfo *nd;\n\n    DeviceState *dev;\n\n    SysBusDevice *sysbus;\n\n    ISABus *isa_bus;\n\n    ISADevice *pit;\n\n    DriveInfo *fds[MAX_FD];\n\n    qemu_irq esp_reset, dma_enable;\n\n    qemu_irq *cpu_exit_irq;\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios2 = g_new(MemoryRegion, 1);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"R4000\";\n\n#else\n\n        /* FIXME: All wrong, this maybe should be R3000 for the older JAZZs. */\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n    cpu = cpu_mips_init(cpu_model);\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n\n\n    /* allocate RAM */\n\n    memory_region_init_ram(ram, \"mips_jazz.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space, 0, ram);\n\n\n\n    memory_region_init_ram(bios, \"mips_jazz.bios\", MAGNUM_BIOS_SIZE);\n\n    vmstate_register_ram_global(bios);\n\n    memory_region_set_readonly(bios, true);\n\n    memory_region_init_alias(bios2, \"mips_jazz.bios\", bios,\n\n                             0, MAGNUM_BIOS_SIZE);\n\n    memory_region_add_subregion(address_space, 0x1fc00000LL, bios);\n\n    memory_region_add_subregion(address_space, 0xfff00000LL, bios2);\n\n\n\n    /* load the BIOS image. */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = load_image_targphys(filename, 0xfff00000LL,\n\n                                        MAGNUM_BIOS_SIZE);\n\n        g_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > MAGNUM_BIOS_SIZE) {\n\n        fprintf(stderr, \"qemu: Could not load MIPS bios '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* Init CPU internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* Chipset */\n\n    rc4030_opaque = rc4030_init(env->irq[6], env->irq[3], &rc4030, &dmas,\n\n                                address_space);\n\n    memory_region_init_io(dma_dummy, &dma_dummy_ops, NULL, \"dummy_dma\", 0x1000);\n\n    memory_region_add_subregion(address_space, 0x8000d000, dma_dummy);\n\n\n\n    /* ISA devices */\n\n    isa_bus = isa_bus_new(NULL, address_space_io);\n\n    i8259 = i8259_init(isa_bus, env->irq[4]);\n\n    isa_bus_irqs(isa_bus, i8259);\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(0, cpu_exit_irq);\n\n    pit = pit_init(isa_bus, 0x40, 0, NULL);\n\n    pcspk_init(isa_bus, pit);\n\n\n\n    /* ISA IO space at 0x90000000 */\n\n    isa_mmio_init(0x90000000, 0x01000000);\n\n    isa_mem_base = 0x11000000;\n\n\n\n    /* Video card */\n\n    switch (jazz_model) {\n\n    case JAZZ_MAGNUM:\n\n        dev = qdev_create(NULL, \"sysbus-g364\");\n\n        qdev_init_nofail(dev);\n\n        sysbus = sysbus_from_qdev(dev);\n\n        sysbus_mmio_map(sysbus, 0, 0x60080000);\n\n        sysbus_mmio_map(sysbus, 1, 0x40000000);\n\n        sysbus_connect_irq(sysbus, 0, rc4030[3]);\n\n        {\n\n            /* Simple ROM, so user doesn't have to provide one */\n\n            MemoryRegion *rom_mr = g_new(MemoryRegion, 1);\n\n            memory_region_init_ram(rom_mr, \"g364fb.rom\", 0x80000);\n\n            vmstate_register_ram_global(rom_mr);\n\n            memory_region_set_readonly(rom_mr, true);\n\n            uint8_t *rom = memory_region_get_ram_ptr(rom_mr);\n\n            memory_region_add_subregion(address_space, 0x60000000, rom_mr);\n\n            rom[0] = 0x10; /* Mips G364 */\n\n        }\n\n        break;\n\n    case JAZZ_PICA61:\n\n        isa_vga_mm_init(0x40000000, 0x60000000, 0, get_system_memory());\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Network controller */\n\n    for (n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = g_strdup(\"dp83932\");\n\n        if (strcmp(nd->model, \"dp83932\") == 0) {\n\n            dp83932_init(nd, 0x80001000, 2, get_system_memory(), rc4030[4],\n\n                         rc4030_opaque, rc4030_dma_memory_rw);\n\n            break;\n\n        } else if (strcmp(nd->model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: dp83932\\n\");\n\n            exit(1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd->model);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* SCSI adapter */\n\n    esp_init(0x80002000, 0,\n\n             rc4030_dma_read, rc4030_dma_write, dmas[0],\n\n             rc4030[5], &esp_reset, &dma_enable);\n\n\n\n    /* Floppy */\n\n    if (drive_get_max_bus(IF_FLOPPY) >= MAX_FD) {\n\n        fprintf(stderr, \"qemu: too many floppy drives\\n\");\n\n        exit(1);\n\n    }\n\n    for (n = 0; n < MAX_FD; n++) {\n\n        fds[n] = drive_get(IF_FLOPPY, 0, n);\n\n    }\n\n    fdctrl_init_sysbus(rc4030[1], 0, 0x80003000, fds);\n\n\n\n    /* Real time clock */\n\n    rtc_init(isa_bus, 1980, NULL);\n\n    memory_region_init_io(rtc, &rtc_ops, NULL, \"rtc\", 0x1000);\n\n    memory_region_add_subregion(address_space, 0x80004000, rtc);\n\n\n\n    /* Keyboard (i8042) */\n\n    i8042_mm_init(rc4030[6], rc4030[7], i8042, 0x1000, 0x1);\n\n    memory_region_add_subregion(address_space, 0x80005000, i8042);\n\n\n\n    /* Serial ports */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(address_space, 0x80006000, 0, rc4030[8], 8000000/16,\n\n                       serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n    }\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(address_space, 0x80007000, 0, rc4030[9], 8000000/16,\n\n                       serial_hds[1], DEVICE_NATIVE_ENDIAN);\n\n    }\n\n\n\n    /* Parallel port */\n\n    if (parallel_hds[0])\n\n        parallel_mm_init(address_space, 0x80008000, 0, rc4030[0],\n\n                         parallel_hds[0]);\n\n\n\n    /* Sound card */\n\n    /* FIXME: missing Jazz sound at 0x8000c000, rc4030[2] */\n\n    audio_init(isa_bus, NULL);\n\n\n\n    /* NVRAM */\n\n    dev = qdev_create(NULL, \"ds1225y\");\n\n    qdev_init_nofail(dev);\n\n    sysbus = sysbus_from_qdev(dev);\n\n    sysbus_mmio_map(sysbus, 0, 0x80009000);\n\n\n\n    /* LED indicator */\n\n    sysbus_create_simple(\"jazz-led\", 0x8000f000, NULL);\n\n}\n", "idx": 5753}
{"project": "qemu", "commit_id": "decb471488dd9e7e7ab9957f120cb501c4489f63", "target": 1, "func": "static inline int get_segment(CPUState *env, mmu_ctx_t *ctx,\n\n                              target_ulong eaddr, int rw, int type)\n\n{\n\n    target_phys_addr_t hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n#if defined(TARGET_PPC64)\n\n    if (env->mmu_model & POWERPC_MMU_64) {\n\n        ppc_slb_t *slb;\n\n        target_ulong pageaddr;\n\n        int segment_bits;\n\n\n\n        LOG_MMU(\"Check SLBs\\n\");\n\n        slb = slb_lookup(env, eaddr);\n\n        if (!slb) {\n\n            return -5;\n\n        }\n\n\n\n        if (slb->vsid & SLB_VSID_B) {\n\n            vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n            segment_bits = 40;\n\n        } else {\n\n            vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n            segment_bits = 28;\n\n        }\n\n\n\n        target_page_bits = (slb->vsid & SLB_VSID_L)\n\n            ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n        ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                      : (slb->vsid & SLB_VSID_KS));\n\n        ds = 0;\n\n        ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n        pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n        if (slb->vsid & SLB_VSID_B) {\n\n            hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n        } else {\n\n            hash = vsid ^ (pageaddr >> target_page_bits);\n\n        }\n\n        /* Only 5 bits of the page index are used in the AVPN */\n\n        ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n            ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n    } else\n\n#endif /* defined(TARGET_PPC64) */\n\n    {\n\n        target_ulong sr, pgidx;\n\n\n\n        sr = env->sr[eaddr >> 28];\n\n        ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                    ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n        ds = sr & 0x80000000 ? 1 : 0;\n\n        ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n        vsid = sr & 0x00FFFFFF;\n\n        target_page_bits = TARGET_PAGE_BITS;\n\n        LOG_MMU(\"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx \" nip=\"\n\n                TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n                \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n                eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n                (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n        pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n        hash = vsid ^ pgidx;\n\n        ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n    }\n\n    LOG_MMU(\"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (target_phys_addr_t)-1ULL;\n\n            if (unlikely(env->mmu_model == POWERPC_MMU_SOFT_6xx ||\n\n                         env->mmu_model == POWERPC_MMU_SOFT_74xx)) {\n\n                /* Software TLB search */\n\n                ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n            } else {\n\n                LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                        \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                        \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                        env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                        ctx->hash[0]);\n\n                /* Primary table lookup */\n\n                ret = find_pte(env, ctx, 0, rw, type, target_page_bits);\n\n                if (ret < 0) {\n\n                    /* Secondary table lookup */\n\n                    if (eaddr != 0xEFFFFFFF)\n\n                        LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                                \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                                \" hash=\" TARGET_FMT_plx \" pg_addr=\"\n\n                                TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                                env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n                    ret2 = find_pte(env, ctx, 1, rw, type,\n\n                                    target_page_bits);\n\n                    if (ret2 != -1)\n\n                        ret = ret2;\n\n                }\n\n            }\n\n#if defined (DUMP_PAGE_TABLES)\n\n            if (qemu_log_enabled()) {\n\n                target_phys_addr_t curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", sdr, mask + 0x80);\n\n                for (curaddr = sdr; curaddr < (sdr + mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(curaddr);\n\n                    a1 = ldl_phys(curaddr + 4);\n\n                    a2 = ldl_phys(curaddr + 8);\n\n                    a3 = ldl_phys(curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            LOG_MMU(\"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        LOG_MMU(\"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log(\"ERROR: instruction should not need \"\n\n                        \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2739}
{"project": "qemu", "commit_id": "56c4bfb3f07f3107894c00281276aea4f5e8834d", "target": 1, "func": "void qemu_get_guest_memory_mapping(MemoryMappingList *list, Error **errp)\n\n{\n\n    CPUState *cpu, *first_paging_enabled_cpu;\n\n    RAMBlock *block;\n\n    ram_addr_t offset, length;\n\n\n\n    first_paging_enabled_cpu = find_paging_enabled_cpu(first_cpu);\n\n    if (first_paging_enabled_cpu) {\n\n        for (cpu = first_paging_enabled_cpu; cpu != NULL; cpu = cpu->next_cpu) {\n\n            Error *err = NULL;\n\n            cpu_get_memory_mapping(cpu, list, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n        }\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * If the guest doesn't use paging, the virtual address is equal to physical\n\n     * address.\n\n     */\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = block->offset;\n\n        length = block->length;\n\n        create_new_memory_mapping(list, offset, offset, length);\n\n    }\n\n}\n", "idx": 9174}
{"project": "qemu", "commit_id": "413d463f43fbc4dd3a601e80a5724aa384a265a0", "target": 1, "func": "static void dhcp_decode(const struct bootp_t *bp, int *pmsg_type,\n\n                        struct in_addr *preq_addr)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n    preq_addr->s_addr = htonl(0L);\n\n\n\n    p = bp->bp_vend;\n\n    p_end = p + DHCP_OPT_LEN;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n\n            len = *p++;\n\n\n\n\n            DPRINTF(\"dhcp: tag=%d len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n\n            case RFC2132_REQ_ADDR:\n\n                if (len >= 4) {\n\n                    memcpy(&(preq_addr->s_addr), p, 4);\n\n\n\n            default:\n\n\n\n            p += len;\n\n\n\n    if (*pmsg_type == DHCPREQUEST && preq_addr->s_addr == htonl(0L) &&\n\n        bp->bp_ciaddr.s_addr) {\n\n        memcpy(&(preq_addr->s_addr), &bp->bp_ciaddr, 4);\n\n", "idx": 1508}
{"project": "qemu", "commit_id": "c99a55d38dd5b5131f3fcbbaf41828a09ee62544", "target": 1, "func": "static void arm1026_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    cpu->dtb_compatible = \"arm,arm1026\";\n\n    set_feature(&cpu->env, ARM_FEATURE_V5);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP);\n\n    set_feature(&cpu->env, ARM_FEATURE_AUXCR);\n\n    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);\n\n    set_feature(&cpu->env, ARM_FEATURE_CACHE_TEST_CLEAN);\n\n\n    cpu->midr = 0x4106a262;\n\n    cpu->reset_fpsid = 0x410110a0;\n\n    cpu->ctr = 0x1dd20d2;\n\n    cpu->reset_sctlr = 0x00090078;\n\n    cpu->reset_auxcr = 1;\n\n    {\n\n        /* The 1026 had an IFAR at c6,c0,0,1 rather than the ARMv6 c6,c0,0,2 */\n\n        ARMCPRegInfo ifar = {\n\n            .name = \"IFAR\", .cp = 15, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 1,\n\n            .access = PL1_RW,\n\n            .fieldoffset = offsetof(CPUARMState, cp15.ifar_ns),\n\n            .resetvalue = 0\n\n        };\n\n        define_one_arm_cp_reg(cpu, &ifar);\n\n    }\n\n}", "idx": 5271}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static int xenfb_map_fb(struct XenFB *xenfb)\n\n{\n\n    struct xenfb_page *page = xenfb->c.page;\n\n    char *protocol = xenfb->c.xendev.protocol;\n\n    int n_fbdirs;\n\n    xen_pfn_t *pgmfns = NULL;\n\n    xen_pfn_t *fbmfns = NULL;\n\n    void *map, *pd;\n\n    int mode, ret = -1;\n\n\n\n    /* default to native */\n\n    pd = page->pd;\n\n    mode = sizeof(unsigned long) * 8;\n\n\n\n    if (!protocol) {\n\n\t/*\n\n\t * Undefined protocol, some guesswork needed.\n\n\t *\n\n\t * Old frontends which don't set the protocol use\n\n\t * one page directory only, thus pd[1] must be zero.\n\n\t * pd[1] of the 32bit struct layout and the lower\n\n\t * 32 bits of pd[0] of the 64bit struct layout have\n\n\t * the same location, so we can check that ...\n\n\t */\n\n\tuint32_t *ptr32 = NULL;\n\n\tuint32_t *ptr64 = NULL;\n\n#if defined(__i386__)\n\n\tptr32 = (void*)page->pd;\n\n\tptr64 = ((void*)page->pd) + 4;\n\n#elif defined(__x86_64__)\n\n\tptr32 = ((void*)page->pd) - 4;\n\n\tptr64 = (void*)page->pd;\n\n#endif\n\n\tif (ptr32) {\n\n\t    if (ptr32[1] == 0) {\n\n\t\tmode = 32;\n\n\t\tpd   = ptr32;\n\n\t    } else {\n\n\t\tmode = 64;\n\n\t\tpd   = ptr64;\n\n\t    }\n\n\t}\n\n#if defined(__x86_64__)\n\n    } else if (strcmp(protocol, XEN_IO_PROTO_ABI_X86_32) == 0) {\n\n\t/* 64bit dom0, 32bit domU */\n\n\tmode = 32;\n\n\tpd   = ((void*)page->pd) - 4;\n\n#elif defined(__i386__)\n\n    } else if (strcmp(protocol, XEN_IO_PROTO_ABI_X86_64) == 0) {\n\n\t/* 32bit dom0, 64bit domU */\n\n\tmode = 64;\n\n\tpd   = ((void*)page->pd) + 4;\n\n#endif\n\n    }\n\n\n\n    if (xenfb->pixels) {\n\n        munmap(xenfb->pixels, xenfb->fbpages * XC_PAGE_SIZE);\n\n        xenfb->pixels = NULL;\n\n    }\n\n\n\n    xenfb->fbpages = (xenfb->fb_len + (XC_PAGE_SIZE - 1)) / XC_PAGE_SIZE;\n\n    n_fbdirs = xenfb->fbpages * mode / 8;\n\n    n_fbdirs = (n_fbdirs + (XC_PAGE_SIZE - 1)) / XC_PAGE_SIZE;\n\n\n\n    pgmfns = g_malloc0(sizeof(xen_pfn_t) * n_fbdirs);\n\n    fbmfns = g_malloc0(sizeof(xen_pfn_t) * xenfb->fbpages);\n\n\n\n    xenfb_copy_mfns(mode, n_fbdirs, pgmfns, pd);\n\n    map = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,\n\n\t\t\t       PROT_READ, pgmfns, n_fbdirs);\n\n    if (map == NULL)\n\n\tgoto out;\n\n    xenfb_copy_mfns(mode, xenfb->fbpages, fbmfns, map);\n\n    munmap(map, n_fbdirs * XC_PAGE_SIZE);\n\n\n\n    xenfb->pixels = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,\n\n            PROT_READ, fbmfns, xenfb->fbpages);\n\n    if (xenfb->pixels == NULL)\n\n\tgoto out;\n\n\n\n    ret = 0; /* all is fine */\n\n\n\nout:\n\n    g_free(pgmfns);\n\n    g_free(fbmfns);\n\n    return ret;\n\n}\n", "idx": 1150}
{"project": "qemu", "commit_id": "e49ab19fcaa617ad6cdfe1ac401327326b6a2552", "target": 1, "func": "static int coroutine_fn iscsi_co_writev(BlockDriverState *bs,\n\n                                        int64_t sector_num, int nb_sectors,\n\n                                        QEMUIOVector *iov)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    uint64_t lba;\n\n    uint32_t num_sectors;\n\n    uint8_t *data = NULL;\n\n    uint8_t *buf = NULL;\n\n\n\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n    num_sectors = sector_qemu2lun(nb_sectors, iscsilun);\n\n#if !defined(LIBISCSI_FEATURE_IOVECTOR)\n\n    /* if the iovec only contains one buffer we can pass it directly */\n\n    if (iov->niov == 1) {\n\n        data = iov->iov[0].iov_base;\n\n    } else {\n\n        size_t size = MIN(nb_sectors * BDRV_SECTOR_SIZE, iov->size);\n\n        buf = g_malloc(size);\n\n        qemu_iovec_to_buf(iov, 0, buf, size);\n\n        data = buf;\n\n    }\n\n#endif\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\nretry:\n\n    if (iscsilun->use_16_for_rw) {\n\n        iTask.task = iscsi_write16_task(iscsilun->iscsi, iscsilun->lun, lba,\n\n                                        data, num_sectors * iscsilun->block_size,\n\n                                        iscsilun->block_size, 0, 0, 0, 0, 0,\n\n                                        iscsi_co_generic_cb, &iTask);\n\n    } else {\n\n        iTask.task = iscsi_write10_task(iscsilun->iscsi, iscsilun->lun, lba,\n\n                                        data, num_sectors * iscsilun->block_size,\n\n                                        iscsilun->block_size, 0, 0, 0, 0, 0,\n\n                                        iscsi_co_generic_cb, &iTask);\n\n    }\n\n    if (iTask.task == NULL) {\n\n        g_free(buf);\n\n        return -ENOMEM;\n\n    }\n\n#if defined(LIBISCSI_FEATURE_IOVECTOR)\n\n    scsi_task_set_iov_out(iTask.task, (struct scsi_iovec *) iov->iov,\n\n                          iov->niov);\n\n#endif\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    g_free(buf);\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        return -EIO;\n\n    }\n\n\n\n    iscsi_allocationmap_set(iscsilun, sector_num, nb_sectors);\n\n\n\n    return 0;\n\n}\n", "idx": 1061}
{"project": "qemu", "commit_id": "bb12e761e8e7b5c3c3d77bd08de9f007727a941e", "target": 1, "func": "int vhost_set_vring_enable(NetClientState *nc, int enable)\n\n{\n\n    VHostNetState *net = get_vhost_net(nc);\n\n    const VhostOps *vhost_ops;\n\n\n\n    nc->vring_enable = enable;\n\n\n\n    if (!net) {\n\n        return 0;\n\n    }\n\n\n\n    vhost_ops = net->dev.vhost_ops;\n\n    if (vhost_ops->vhost_set_vring_enable) {\n\n        return vhost_ops->vhost_set_vring_enable(&net->dev, enable);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5555}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "static void memory_region_oldmmio_write_accessor(MemoryRegion *mr,\n\n                                                 hwaddr addr,\n\n                                                 uint64_t *value,\n\n                                                 unsigned size,\n\n                                                 unsigned shift,\n\n                                                 uint64_t mask)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = (*value >> shift) & mask;\n\n    trace_memory_region_ops_write(mr, addr, tmp, size);\n\n    mr->ops->old_mmio.write[ctz32(size)](mr->opaque, addr, tmp);\n\n}\n", "idx": 12274}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_post_recv_control(RDMAContext *rdma, int idx)\n\n{\n\n    struct ibv_recv_wr *bad_wr;\n\n    struct ibv_sge sge = {\n\n                            .addr = (uint64_t)(rdma->wr_data[idx].control),\n\n                            .length = RDMA_CONTROL_MAX_BUFFER,\n\n                            .lkey = rdma->wr_data[idx].control_mr->lkey,\n\n                         };\n\n\n\n    struct ibv_recv_wr recv_wr = {\n\n                                    .wr_id = RDMA_WRID_RECV_CONTROL + idx,\n\n                                    .sg_list = &sge,\n\n                                    .num_sge = 1,\n\n                                 };\n\n\n\n\n\n    if (ibv_post_recv(rdma->qp, &recv_wr, &bad_wr)) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11104}
{"project": "qemu", "commit_id": "81145834d39897c6f153ac26a4077f90f269c5fc", "target": 1, "func": "static int cow_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCowState *s = bs->opaque;\n\n    int ret, n;\n\n\n\n    while (nb_sectors > 0) {\n\n        if (cow_is_allocated(bs, sector_num, nb_sectors, &n)) {\n\n            ret = bdrv_pread(bs->file,\n\n                        s->cow_sectors_offset + sector_num * 512,\n\n                        buf, n * 512);\n\n            if (ret != n * 512)\n\n                return -1;\n\n        } else {\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                ret = bdrv_read(bs->backing_hd, sector_num, buf, n);\n\n                if (ret < 0)\n\n                    return -1;\n\n            } else {\n\n            memset(buf, 0, n * 512);\n\n        }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8504}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static int remove_mapping(BDRVVVFATState* s, int mapping_index)\n\n{\n\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n\n    mapping_t* first_mapping = array_get(&(s->mapping), 0);\n\n\n\n    /* free mapping */\n\n    if (mapping->first_mapping_index < 0)\n\n\tfree(mapping->path);\n\n\n\n    /* remove from s->mapping */\n\n    array_remove(&(s->mapping), mapping_index);\n\n\n\n    /* adjust all references to mappings */\n\n    adjust_mapping_indices(s, mapping_index, -1);\n\n\n\n    if (s->current_mapping && first_mapping != (mapping_t*)s->mapping.pointer)\n\n\ts->current_mapping = array_get(&(s->mapping),\n\n\t\ts->current_mapping - first_mapping);\n\n\n\n    return 0;\n\n}\n", "idx": 6976}
{"project": "qemu", "commit_id": "8c56c1a592b5092d91da8d8943c17777d6462a6f", "target": 1, "func": "void memory_region_add_eventfd(MemoryRegion *mr,\n                               hwaddr addr,\n                               unsigned size,\n                               bool match_data,\n                               uint64_t data,\n                               EventNotifier *e)\n{\n    MemoryRegionIoeventfd mrfd = {\n        .addr.start = int128_make64(addr),\n        .addr.size = int128_make64(size),\n        .match_data = match_data,\n        .data = data,\n        .e = e,\n    };\n    unsigned i;\n    if (size) {\n        adjust_endianness(mr, &mrfd.data, size);\n    memory_region_transaction_begin();\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n            break;\n    ++mr->ioeventfd_nb;\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n    mr->ioeventfds[i] = mrfd;\n    ioeventfd_update_pending |= mr->enabled;\n    memory_region_transaction_commit();", "idx": 10759}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "static int vmdk_create_extent(const char *filename, int64_t filesize,\n\n                              bool flat, bool compress, bool zeroed_grain,\n\n                              Error **errp)\n\n{\n\n    int ret, i;\n\n    BlockDriverState *bs = NULL;\n\n    VMDK4Header header;\n\n    Error *local_err;\n\n    uint32_t tmp, magic, grains, gd_sectors, gt_size, gt_count;\n\n    uint32_t *gd_buf = NULL;\n\n    int gd_buf_size;\n\n\n\n    ret = bdrv_create_file(filename, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    ret = bdrv_file_open(&bs, filename, NULL, NULL, BDRV_O_RDWR, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    if (flat) {\n\n        ret = bdrv_truncate(bs, filesize);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Could not truncate file\");\n\n        }\n\n        goto exit;\n\n    }\n\n    magic = cpu_to_be32(VMDK4_MAGIC);\n\n    memset(&header, 0, sizeof(header));\n\n    header.version = zeroed_grain ? 2 : 1;\n\n    header.flags = VMDK4_FLAG_RGD | VMDK4_FLAG_NL_DETECT\n\n                   | (compress ? VMDK4_FLAG_COMPRESS | VMDK4_FLAG_MARKER : 0)\n\n                   | (zeroed_grain ? VMDK4_FLAG_ZERO_GRAIN : 0);\n\n    header.compressAlgorithm = compress ? VMDK4_COMPRESSION_DEFLATE : 0;\n\n    header.capacity = filesize / BDRV_SECTOR_SIZE;\n\n    header.granularity = 128;\n\n    header.num_gtes_per_gt = BDRV_SECTOR_SIZE;\n\n\n\n    grains = DIV_ROUND_UP(filesize / BDRV_SECTOR_SIZE, header.granularity);\n\n    gt_size = DIV_ROUND_UP(header.num_gtes_per_gt * sizeof(uint32_t),\n\n                           BDRV_SECTOR_SIZE);\n\n    gt_count = DIV_ROUND_UP(grains, header.num_gtes_per_gt);\n\n    gd_sectors = DIV_ROUND_UP(gt_count * sizeof(uint32_t), BDRV_SECTOR_SIZE);\n\n\n\n    header.desc_offset = 1;\n\n    header.desc_size = 20;\n\n    header.rgd_offset = header.desc_offset + header.desc_size;\n\n    header.gd_offset = header.rgd_offset + gd_sectors + (gt_size * gt_count);\n\n    header.grain_offset =\n\n        ROUND_UP(header.gd_offset + gd_sectors + (gt_size * gt_count),\n\n                 header.granularity);\n\n    /* swap endianness for all header fields */\n\n    header.version = cpu_to_le32(header.version);\n\n    header.flags = cpu_to_le32(header.flags);\n\n    header.capacity = cpu_to_le64(header.capacity);\n\n    header.granularity = cpu_to_le64(header.granularity);\n\n    header.num_gtes_per_gt = cpu_to_le32(header.num_gtes_per_gt);\n\n    header.desc_offset = cpu_to_le64(header.desc_offset);\n\n    header.desc_size = cpu_to_le64(header.desc_size);\n\n    header.rgd_offset = cpu_to_le64(header.rgd_offset);\n\n    header.gd_offset = cpu_to_le64(header.gd_offset);\n\n    header.grain_offset = cpu_to_le64(header.grain_offset);\n\n    header.compressAlgorithm = cpu_to_le16(header.compressAlgorithm);\n\n\n\n    header.check_bytes[0] = 0xa;\n\n    header.check_bytes[1] = 0x20;\n\n    header.check_bytes[2] = 0xd;\n\n    header.check_bytes[3] = 0xa;\n\n\n\n    /* write all the data */\n\n    ret = bdrv_pwrite(bs, 0, &magic, sizeof(magic));\n\n    if (ret < 0) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n        goto exit;\n\n    }\n\n    ret = bdrv_pwrite(bs, sizeof(magic), &header, sizeof(header));\n\n    if (ret < 0) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n        goto exit;\n\n    }\n\n\n\n    ret = bdrv_truncate(bs, le64_to_cpu(header.grain_offset) << 9);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Could not truncate file\");\n\n        goto exit;\n\n    }\n\n\n\n    /* write grain directory */\n\n    gd_buf_size = gd_sectors * BDRV_SECTOR_SIZE;\n\n    gd_buf = g_malloc0(gd_buf_size);\n\n    for (i = 0, tmp = le64_to_cpu(header.rgd_offset) + gd_sectors;\n\n         i < gt_count; i++, tmp += gt_size) {\n\n        gd_buf[i] = cpu_to_le32(tmp);\n\n    }\n\n    ret = bdrv_pwrite(bs, le64_to_cpu(header.rgd_offset) * BDRV_SECTOR_SIZE,\n\n                      gd_buf, gd_buf_size);\n\n    if (ret < 0) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n        goto exit;\n\n    }\n\n\n\n    /* write backup grain directory */\n\n    for (i = 0, tmp = le64_to_cpu(header.gd_offset) + gd_sectors;\n\n         i < gt_count; i++, tmp += gt_size) {\n\n        gd_buf[i] = cpu_to_le32(tmp);\n\n    }\n\n    ret = bdrv_pwrite(bs, le64_to_cpu(header.gd_offset) * BDRV_SECTOR_SIZE,\n\n                      gd_buf, gd_buf_size);\n\n    if (ret < 0) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n        goto exit;\n\n    }\n\n\n\n    ret = 0;\n\nexit:\n\n    if (bs) {\n\n        bdrv_unref(bs);\n\n    }\n\n    g_free(gd_buf);\n\n    return ret;\n\n}\n", "idx": 11346}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int alsa_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceOut *alsa = (ALSAVoiceOut *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_out;\n\n    req.buffer_size = conf.buffer_size_out;\n\n    req.size_in_usec = conf.size_in_usec_out;\n\n    req.override_mask =\n\n        (conf.period_size_out_overridden ? 1 : 0) |\n\n        (conf.buffer_size_out_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (0, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, obt.samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "idx": 4530}
{"project": "qemu", "commit_id": "fbe0c5591077814eead05217fc96f087b254a6a8", "target": 1, "func": "static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSerial *s = opaque;\n\n    VirtIOSerialPort *port;\n\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n\n    unsigned int i;\n\n\n\n    if (version_id > 3) {\n\n\n\n\n\n    /* The virtio device */\n\n    virtio_load(&s->vdev, f);\n\n\n\n    if (version_id < 2) {\n\n        return 0;\n\n\n\n\n    /* The config space */\n\n    qemu_get_be16s(f, &s->config.cols);\n\n    qemu_get_be16s(f, &s->config.rows);\n\n\n\n    qemu_get_be32s(f, &max_nr_ports);\n\n    if (max_nr_ports > s->config.max_nr_ports) {\n\n        /* Source could have had more ports than us. Fail migration. */\n\n\n\n\n\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n\n        qemu_get_be32s(f, &ports_map);\n\n\n\n        if (ports_map != s->ports_map[i]) {\n\n            /*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             */\n\n\n\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n\n\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            /*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             */\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                /*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 */\n\n                virtio_serial_throttle_port(port, false);\n\n\n\n\n    return 0;\n", "idx": 559}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_write_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n\n\n    if (ret < 0) {\n\n        printf(\"aio_write failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"wrote\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}", "idx": 10263}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "static int find_and_check_chardev(CharDriverState **chr,\n\n                                  char *chr_name,\n\n                                  Error **errp)\n\n{\n\n    CompareChardevProps props;\n\n\n\n    *chr = qemu_chr_find(chr_name);\n\n    if (*chr == NULL) {\n\n        error_setg(errp, \"Device '%s' not found\",\n\n                   chr_name);\n\n        return 1;\n\n    }\n\n\n\n    memset(&props, 0, sizeof(props));\n\n    if (qemu_opt_foreach((*chr)->opts, compare_chardev_opts, &props, errp)) {\n\n        return 1;\n\n    }\n\n\n\n    if (!props.is_socket) {\n\n        error_setg(errp, \"chardev \\\"%s\\\" is not a tcp socket\",\n\n                   chr_name);\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6679}
{"project": "qemu", "commit_id": "ec9c10d29c6bb5613a680af62f5825d3bb2d31d4", "target": 1, "func": "static DriveInfo *blockdev_init(QDict *bs_opts,\n\n                                BlockInterfaceType type,\n\n                                Error **errp)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    DriveInfo *dinfo;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockDriver *drv = NULL;\n\n\n\n    /* Check common options by copying from bs_opts to opts, all other options\n\n     * stay in bs_opts for processing by bdrv_open(). */\n\n    id = qdict_get_try_str(bs_opts, \"id\");\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"read-only\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_setg(errp, \"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"cache.writeback\", true)) {\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.direct\", false)) {\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.no-flush\", false)) {\n\n        bdrv_flags |= BDRV_O_NO_FLUSH;\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_setg(errp, \"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            error_setg(errp, \"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    memset(&cfg, 0, sizeof(cfg));\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].avg  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].max  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n    cfg.op_size = qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n    if (!check_throttle_config(&cfg, &error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_setg(errp, \"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* init */\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    dinfo->id = g_strdup(qemu_opts_id(opts));\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->type = type;\n\n    dinfo->refcount = 1;\n\n    if (serial != NULL) {\n\n        dinfo->serial = g_strdup(serial);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    if (throttle_enabled(&cfg)) {\n\n        bdrv_io_limits_enable(dinfo->bdrv);\n\n        bdrv_set_io_limits(dinfo->bdrv, &cfg);\n\n    }\n\n\n\n    if (!file || !*file) {\n\n        if (has_driver_specific_opts) {\n\n            file = NULL;\n\n        } else {\n\n            return dinfo;\n\n        }\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    QINCREF(bs_opts);\n\n    ret = bdrv_open(dinfo->bdrv, file, bs_opts, bdrv_flags, drv, &error);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"could not open disk image %s: %s\",\n\n                   file ?: dinfo->id, error_get_pretty(error));\n\n        error_free(error);\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n\n\n    return dinfo;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    QDECREF(bs_opts);\n\n    bdrv_unref(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 8258}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpil(CPUSPARCState *env, target_ulong new_pil)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    trace_win_helper_wrpil(env->psrpil, (uint32_t)new_pil);\n\n\n\n    env->psrpil = new_pil;\n\n\n\n    if (cpu_interrupts_enabled(env)) {\n\n\n        cpu_check_irqs(env);\n\n\n    }\n\n#endif\n\n}", "idx": 2018}
{"project": "qemu", "commit_id": "d36c231f4b7386bd8230aa17d362b925aa419b2f", "target": 1, "func": "static inline uint16_t mipsdsp_trunc16_sat16_round(int32_t a,\n\n                                                   CPUMIPSState *env)\n\n{\n\n    int64_t temp;\n\n\n\n    temp = (int32_t)a + 0x00008000;\n\n\n\n    if (a > (int)0x7fff8000) {\n\n        temp = 0x7FFFFFFF;\n\n        set_DSPControl_overflow_flag(1, 22, env);\n\n    }\n\n\n\n    return (temp >> 16) & 0xFFFF;\n\n}\n", "idx": 9687}
{"project": "qemu", "commit_id": "7f102ebeb5bad7b723a25557234b0feb493f6134", "target": 1, "func": "static int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,\n                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)\n{\n    int len = 0, max_len;\n    bool spd;\n    bool queuing = (q != NULL);\n    uint8_t pid = td->token & 0xff;\n    UHCIAsync *async = uhci_async_find_td(s, td_addr);\n    if (async) {\n        if (uhci_queue_verify(async->queue, qh_addr, td, td_addr, queuing)) {\n            assert(q == NULL || q == async->queue);\n            q = async->queue;\n        } else {\n            uhci_queue_free(async->queue, \"guest re-used pending td\");\n            async = NULL;\n    if (q == NULL) {\n        q = uhci_queue_find(s, td);\n        if (q && !uhci_queue_verify(q, qh_addr, td, td_addr, queuing)) {\n            uhci_queue_free(q, \"guest re-used qh\");\n            q = NULL;\n    if (q) {\n        q->valid = 32;\n    /* Is active ? */\n    if (!(td->ctrl & TD_CTRL_ACTIVE)) {\n        if (async) {\n            /* Guest marked a pending td non-active, cancel the queue */\n            uhci_queue_free(async->queue, \"pending td non-active\");\n        /*\n         * ehci11d spec page 22: \"Even if the Active bit in the TD is already\n         * cleared when the TD is fetched ... an IOC interrupt is generated\"\n         */\n        if (td->ctrl & TD_CTRL_IOC) {\n                *int_mask |= 0x01;\n        return TD_RESULT_NEXT_QH;\n    if (async) {\n        if (queuing) {\n            /* we are busy filling the queue, we are not prepared\n               to consume completed packages then, just leave them\n               in async state */\n            return TD_RESULT_ASYNC_CONT;\n        if (!async->done) {\n            UHCI_TD last_td;\n            UHCIAsync *last = QTAILQ_LAST(&async->queue->asyncs, asyncs_head);\n            /*\n             * While we are waiting for the current td to complete, the guest\n             * may have added more tds to the queue. Note we re-read the td\n             * rather then caching it, as we want to see guest made changes!\n             */\n            uhci_read_td(s, &last_td, last->td_addr);\n            uhci_queue_fill(async->queue, &last_td);\n            return TD_RESULT_ASYNC_CONT;\n        uhci_async_unlink(async);\n        goto done;\n    /* Allocate new packet */\n    if (q == NULL) {\n        USBDevice *dev = uhci_find_device(s, (td->token >> 8) & 0x7f);\n        USBEndpoint *ep = usb_ep_get(dev, pid, (td->token >> 15) & 0xf);\n        q = uhci_queue_new(s, qh_addr, td, ep);\n    async = uhci_async_alloc(q, td_addr);\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n    spd = (pid == USB_TOKEN_IN && (td->ctrl & TD_CTRL_SPD) != 0);\n    usb_packet_setup(&async->packet, pid, q->ep, td_addr, spd,\n                     (td->ctrl & TD_CTRL_IOC) != 0);\n    qemu_sglist_add(&async->sgl, td->buffer, max_len);\n    usb_packet_map(&async->packet, &async->sgl);\n    switch(pid) {\n    case USB_TOKEN_OUT:\n    case USB_TOKEN_SETUP:\n        len = usb_handle_packet(q->ep->dev, &async->packet);\n        if (len >= 0)\n            len = max_len;\n        break;\n    case USB_TOKEN_IN:\n        len = usb_handle_packet(q->ep->dev, &async->packet);\n        break;\n    default:\n        /* invalid pid : frame interrupted */\n        usb_packet_unmap(&async->packet, &async->sgl);\n        uhci_async_free(async);\n        s->status |= UHCI_STS_HCPERR;\n        uhci_update_irq(s);\n        return TD_RESULT_STOP_FRAME;\n    if (len == USB_RET_ASYNC) {\n        uhci_async_link(async);\n        if (!queuing) {\n            uhci_queue_fill(q, td);\n        return TD_RESULT_ASYNC_START;\n    async->packet.result = len;\ndone:\n    len = uhci_complete_td(s, td, async, int_mask);\n    usb_packet_unmap(&async->packet, &async->sgl);\n    uhci_async_free(async);\n    return len;", "idx": 4812}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_do_adma(SDHCIState *s)\n\n{\n\n    unsigned int n, begin, length;\n\n    const uint16_t block_size = s->blksize & 0x0fff;\n\n    ADMADescr dscr;\n\n    int i;\n\n\n\n    for (i = 0; i < SDHC_ADMA_DESCS_PER_DELAY; ++i) {\n\n        s->admaerr &= ~SDHC_ADMAERR_LENGTH_MISMATCH;\n\n\n\n        get_adma_description(s, &dscr);\n\n        DPRINT_L2(\"ADMA loop: addr=\" TARGET_FMT_plx \", len=%d, attr=%x\\n\",\n\n                dscr.addr, dscr.length, dscr.attr);\n\n\n\n        if ((dscr.attr & SDHC_ADMA_ATTR_VALID) == 0) {\n\n            /* Indicate that error occurred in ST_FDS state */\n\n            s->admaerr &= ~SDHC_ADMAERR_STATE_MASK;\n\n            s->admaerr |= SDHC_ADMAERR_STATE_ST_FDS;\n\n\n\n            /* Generate ADMA error interrupt */\n\n            if (s->errintstsen & SDHC_EISEN_ADMAERR) {\n\n                s->errintsts |= SDHC_EIS_ADMAERR;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n\n\n            sdhci_update_irq(s);\n\n            return;\n\n        }\n\n\n\n        length = dscr.length ? dscr.length : 65536;\n\n\n\n        switch (dscr.attr & SDHC_ADMA_ATTR_ACT_MASK) {\n\n        case SDHC_ADMA_ATTR_ACT_TRAN:  /* data transfer */\n\n\n\n            if (s->trnmod & SDHC_TRNS_READ) {\n\n                while (length) {\n\n                    if (s->data_count == 0) {\n\n                        for (n = 0; n < block_size; n++) {\n\n                            s->fifo_buffer[n] = sdbus_read_data(&s->sdbus);\n\n                        }\n\n                    }\n\n                    begin = s->data_count;\n\n                    if ((length + begin) < block_size) {\n\n                        s->data_count = length + begin;\n\n                        length = 0;\n\n                     } else {\n\n                        s->data_count = block_size;\n\n                        length -= block_size - begin;\n\n                    }\n\n                    dma_memory_write(&address_space_memory, dscr.addr,\n\n                                     &s->fifo_buffer[begin],\n\n                                     s->data_count - begin);\n\n                    dscr.addr += s->data_count - begin;\n\n                    if (s->data_count == block_size) {\n\n                        s->data_count = 0;\n\n                        if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                            s->blkcnt--;\n\n                            if (s->blkcnt == 0) {\n\n                                break;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                while (length) {\n\n                    begin = s->data_count;\n\n                    if ((length + begin) < block_size) {\n\n                        s->data_count = length + begin;\n\n                        length = 0;\n\n                     } else {\n\n                        s->data_count = block_size;\n\n                        length -= block_size - begin;\n\n                    }\n\n                    dma_memory_read(&address_space_memory, dscr.addr,\n\n                                    &s->fifo_buffer[begin],\n\n                                    s->data_count - begin);\n\n                    dscr.addr += s->data_count - begin;\n\n                    if (s->data_count == block_size) {\n\n                        for (n = 0; n < block_size; n++) {\n\n                            sdbus_write_data(&s->sdbus, s->fifo_buffer[n]);\n\n                        }\n\n                        s->data_count = 0;\n\n                        if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                            s->blkcnt--;\n\n                            if (s->blkcnt == 0) {\n\n                                break;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            s->admasysaddr += dscr.incr;\n\n            break;\n\n        case SDHC_ADMA_ATTR_ACT_LINK:   /* link to next descriptor table */\n\n            s->admasysaddr = dscr.addr;\n\n            DPRINT_L1(\"ADMA link: admasysaddr=0x%\" PRIx64 \"\\n\",\n\n                      s->admasysaddr);\n\n            break;\n\n        default:\n\n            s->admasysaddr += dscr.incr;\n\n            break;\n\n        }\n\n\n\n        if (dscr.attr & SDHC_ADMA_ATTR_INT) {\n\n            DPRINT_L1(\"ADMA interrupt: admasysaddr=0x%\" PRIx64 \"\\n\",\n\n                      s->admasysaddr);\n\n            if (s->norintstsen & SDHC_NISEN_DMA) {\n\n                s->norintsts |= SDHC_NIS_DMA;\n\n            }\n\n\n\n            sdhci_update_irq(s);\n\n        }\n\n\n\n        /* ADMA transfer terminates if blkcnt == 0 or by END attribute */\n\n        if (((s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&\n\n                    (s->blkcnt == 0)) || (dscr.attr & SDHC_ADMA_ATTR_END)) {\n\n            DPRINT_L2(\"ADMA transfer completed\\n\");\n\n            if (length || ((dscr.attr & SDHC_ADMA_ATTR_END) &&\n\n                (s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&\n\n                s->blkcnt != 0)) {\n\n                ERRPRINT(\"SD/MMC host ADMA length mismatch\\n\");\n\n                s->admaerr |= SDHC_ADMAERR_LENGTH_MISMATCH |\n\n                        SDHC_ADMAERR_STATE_ST_TFR;\n\n                if (s->errintstsen & SDHC_EISEN_ADMAERR) {\n\n                    ERRPRINT(\"Set ADMA error flag\\n\");\n\n                    s->errintsts |= SDHC_EIS_ADMAERR;\n\n                    s->norintsts |= SDHC_NIS_ERR;\n\n                }\n\n\n\n                sdhci_update_irq(s);\n\n            }\n\n            sdhci_end_transfer(s);\n\n            return;\n\n        }\n\n\n\n    }\n\n\n\n    /* we have unfinished business - reschedule to continue ADMA */\n\n    timer_mod(s->transfer_timer,\n\n                   qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + SDHC_TRANSFER_DELAY);\n\n}\n", "idx": 3727}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_draw_text(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr, line, line1;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[VGA_SEQ_CHARACTER_MAP];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2) || s->has_chain4_alias) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    if ((height * width) <= 1) {\n\n        /* better than nothing: exit if transient size is too small */\n\n        return;\n\n    }\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->con, s->last_scr_width, s->last_scr_height);\n\n        surface = qemu_console_surface(s->con);\n\n        dpy_text_resize(s->con, width, height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * surface_bytes_per_pixel(surface);\n\n\n\n    if (full_update) {\n\n        s->full_update_text = 1;\n\n    }\n\n    if (s->full_update_gfx) {\n\n        s->full_update_gfx = 0;\n\n        full_update |= 1;\n\n    }\n\n\n\n    cursor_offset = ((s->cr[VGA_CRTC_CURSOR_HI] << 8) |\n\n                     s->cr[VGA_CRTC_CURSOR_LO]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[VGA_CRTC_CURSOR_START] != s->cursor_start ||\n\n        s->cr[VGA_CRTC_CURSOR_END] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[VGA_CRTC_CURSOR_START];\n\n        s->cursor_end = s->cr[VGA_CRTC_CURSOR_END];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n    if (now >= s->cursor_blink_time) {\n\n        s->cursor_blink_time = now + VGA_TEXT_CURSOR_PERIOD_MS / 2;\n\n        s->cursor_visible_phase = !s->cursor_visible_phase;\n\n    }\n\n\n\n    dest = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    line = 0;\n\n    offset = s->start_addr * 4;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s->vram_ptr + offset;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr || src == cursor_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw == 16) {\n\n                    vga_draw_glyph16(d1, linesize,\n\n                                     font_ptr, cheight, fgcol, bgcol);\n\n                } else if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf &&\n\n                        (s->ar[VGA_ATC_MODE] & 0x04)) {\n\n                        dup9 = 1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n", "idx": 9256}
{"project": "qemu", "commit_id": "dcc6ceffc066745777960a1f0d32f3a555924f65", "target": 1, "func": "static void virtio_balloon_set_config(VirtIODevice *vdev,\n\n                                      const uint8_t *config_data)\n\n{\n\n    VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);\n\n    struct virtio_balloon_config config;\n\n    uint32_t oldactual = dev->actual;\n\n    memcpy(&config, config_data, 8);\n\n    dev->actual = le32_to_cpu(config.actual);\n\n    if (dev->actual != oldactual) {\n\n        qemu_balloon_changed(ram_size -\n\n                             (dev->actual << VIRTIO_BALLOON_PFN_SHIFT));\n\n    }\n\n}\n", "idx": 9020}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "bool io_mem_write(MemoryRegion *mr, hwaddr addr,\n\n                  uint64_t val, unsigned size)\n\n{\n\n    return memory_region_dispatch_write(mr, addr, val, size);\n\n}\n", "idx": 10210}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_src_opc(CPUTriCoreState *env, DisasContext *ctx, int op1)\n\n{\n\n    int r1;\n\n    int32_t const4;\n\n    TCGv temp, temp2;\n\n\n\n    r1 = MASK_OP_SRC_S1D(ctx->opcode);\n\n    const4 = MASK_OP_SRC_CONST4_SEXT(ctx->opcode);\n\n\n\n    switch (op1) {\n\n    case OPC1_16_SRC_ADD:\n\n        gen_addi_d(cpu_gpr_d[r1], cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_ADD_A15:\n\n        gen_addi_d(cpu_gpr_d[r1], cpu_gpr_d[15], const4);\n\n        break;\n\n    case OPC1_16_SRC_ADD_15A:\n\n        gen_addi_d(cpu_gpr_d[15], cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_ADD_A:\n\n        tcg_gen_addi_tl(cpu_gpr_a[r1], cpu_gpr_a[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_CADD:\n\n        gen_condi_add(TCG_COND_NE, cpu_gpr_d[r1], const4, cpu_gpr_d[r1],\n\n                      cpu_gpr_d[15]);\n\n        break;\n\n    case OPC1_16_SRC_CADDN:\n\n        gen_condi_add(TCG_COND_EQ, cpu_gpr_d[r1], const4, cpu_gpr_d[r1],\n\n                      cpu_gpr_d[15]);\n\n        break;\n\n    case OPC1_16_SRC_CMOV:\n\n        temp = tcg_const_tl(0);\n\n        temp2 = tcg_const_tl(const4);\n\n        tcg_gen_movcond_tl(TCG_COND_NE, cpu_gpr_d[r1], cpu_gpr_d[15], temp,\n\n                           temp2, cpu_gpr_d[r1]);\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        break;\n\n    case OPC1_16_SRC_CMOVN:\n\n        temp = tcg_const_tl(0);\n\n        temp2 = tcg_const_tl(const4);\n\n        tcg_gen_movcond_tl(TCG_COND_EQ, cpu_gpr_d[r1], cpu_gpr_d[15], temp,\n\n                           temp2, cpu_gpr_d[r1]);\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        break;\n\n    case OPC1_16_SRC_EQ:\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, cpu_gpr_d[15], cpu_gpr_d[r1],\n\n                            const4);\n\n        break;\n\n    case OPC1_16_SRC_LT:\n\n        tcg_gen_setcondi_tl(TCG_COND_LT, cpu_gpr_d[15], cpu_gpr_d[r1],\n\n                            const4);\n\n        break;\n\n    case OPC1_16_SRC_MOV:\n\n        tcg_gen_movi_tl(cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_MOV_A:\n\n        const4 = MASK_OP_SRC_CONST4(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_a[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_MOV_E:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            tcg_gen_movi_tl(cpu_gpr_d[r1], const4);\n\n            tcg_gen_sari_tl(cpu_gpr_d[r1+1], cpu_gpr_d[r1], 31);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC1_16_SRC_SH:\n\n        gen_shi(cpu_gpr_d[r1], cpu_gpr_d[r1], const4);\n\n        break;\n\n    case OPC1_16_SRC_SHA:\n\n        gen_shaci(cpu_gpr_d[r1], cpu_gpr_d[r1], const4);\n\n        break;\n\n    }\n\n}\n", "idx": 3489}
{"project": "qemu", "commit_id": "158ef8cbb7e0fe8bb430310924b8bebe5f186e6e", "target": 1, "func": "static inline void futex_wake(QemuEvent *ev, int n)\n\n{\n\n\n    if (n == 1) {\n\n        pthread_cond_signal(&ev->cond);\n\n    } else {\n\n        pthread_cond_broadcast(&ev->cond);\n\n    }\n\n\n}", "idx": 265}
{"project": "qemu", "commit_id": "9643c25f8d67646857159d6fc021b07e7a659192", "target": 1, "func": "void gdb_register_coprocessor(CPUState * env,\n\n                             gdb_reg_cb get_reg, gdb_reg_cb set_reg,\n\n                             int num_regs, const char *xml, int g_pos)\n\n{\n\n    GDBRegisterState *s;\n\n    GDBRegisterState **p;\n\n    static int last_reg = NUM_CORE_REGS;\n\n\n\n    s = (GDBRegisterState *)g_malloc0(sizeof(GDBRegisterState));\n\n    s->base_reg = last_reg;\n\n    s->num_regs = num_regs;\n\n    s->get_reg = get_reg;\n\n    s->set_reg = set_reg;\n\n    s->xml = xml;\n\n    p = &env->gdb_regs;\n\n    while (*p) {\n\n        /* Check for duplicates.  */\n\n        if (strcmp((*p)->xml, xml) == 0)\n\n            return;\n\n        p = &(*p)->next;\n\n    }\n\n    /* Add to end of list.  */\n\n    last_reg += num_regs;\n\n    *p = s;\n\n    if (g_pos) {\n\n        if (g_pos != s->base_reg) {\n\n            fprintf(stderr, \"Error: Bad gdb register numbering for '%s'\\n\"\n\n                    \"Expected %d got %d\\n\", xml, g_pos, s->base_reg);\n\n        } else {\n\n            num_g_regs = last_reg;\n\n        }\n\n    }\n\n}\n", "idx": 7488}
{"project": "qemu", "commit_id": "b8865591d4d5680b4f766c25ca1db110320b4d15", "target": 1, "func": "static void pc_dimm_plug(HotplugHandler *hotplug_dev,\n                         DeviceState *dev, Error **errp)\n{\n    int slot;\n    HotplugHandlerClass *hhc;\n    Error *local_err = NULL;\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n    MachineState *machine = MACHINE(hotplug_dev);\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n    uint64_t addr = object_property_get_int(OBJECT(dimm), PC_DIMM_ADDR_PROP,\n                                            &local_err);\n    if (local_err) {\n    addr = pc_dimm_get_free_addr(pcms->hotplug_memory_base,\n                                 memory_region_size(&pcms->hotplug_memory),\n                                 !addr ? NULL : &addr,\n                                 memory_region_size(mr), &local_err);\n    if (local_err) {\n    object_property_set_int(OBJECT(dev), addr, PC_DIMM_ADDR_PROP, &local_err);\n    if (local_err) {\n    trace_mhp_pc_dimm_assigned_address(addr);\n    slot = object_property_get_int(OBJECT(dev), PC_DIMM_SLOT_PROP, &local_err);\n    if (local_err) {\n    slot = pc_dimm_get_free_slot(slot == PC_DIMM_UNASSIGNED_SLOT ? NULL : &slot,\n                                 machine->ram_slots, &local_err);\n    if (local_err) {\n    object_property_set_int(OBJECT(dev), slot, PC_DIMM_SLOT_PROP, &local_err);\n    if (local_err) {\n    trace_mhp_pc_dimm_assigned_slot(slot);\n    if (!pcms->acpi_dev) {\n        error_setg(&local_err,\n                   \"memory hotplug is not enabled: missing acpi device\");\n    memory_region_add_subregion(&pcms->hotplug_memory,\n                                addr - pcms->hotplug_memory_base, mr);\n    vmstate_register_ram(mr, dev);\n    hhc = HOTPLUG_HANDLER_GET_CLASS(pcms->acpi_dev);\n    hhc->plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &local_err);\nout:\n    error_propagate(errp, local_err);", "idx": 380}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "void scsi_req_free(SCSIRequest *req)\n\n{\n\n    scsi_req_dequeue(req);\n\n    qemu_free(req);\n\n}\n", "idx": 9057}
{"project": "qemu", "commit_id": "bb160b571fe469b03228d4502c75a18045978a74", "target": 1, "func": "static NetSocketState *net_socket_fd_init_dgram(NetClientState *peer,\n\n                                                const char *model,\n\n                                                const char *name,\n\n                                                int fd, int is_connected,\n\n                                                const char *mcast,\n\n                                                Error **errp)\n\n{\n\n    struct sockaddr_in saddr;\n\n    int newfd;\n\n    NetClientState *nc;\n\n    NetSocketState *s;\n\n\n\n    /* fd passed: multicast: \"learn\" dgram_dst address from bound address and save it\n\n     * Because this may be \"shared\" socket from a \"master\" process, datagrams would be recv()\n\n     * by ONLY ONE process: we must \"clone\" this dgram socket --jjo\n\n     */\n\n\n\n    if (is_connected && mcast != NULL) {\n\n            if (parse_host_port(&saddr, mcast, errp) < 0) {\n\n                goto err;\n\n            }\n\n            /* must be bound */\n\n            if (saddr.sin_addr.s_addr == 0) {\n\n                error_setg(errp, \"can't setup multicast destination address\");\n\n                goto err;\n\n            }\n\n            /* clone dgram socket */\n\n            newfd = net_socket_mcast_create(&saddr, NULL, errp);\n\n            if (newfd < 0) {\n\n                goto err;\n\n            }\n\n            /* clone newfd to fd, close newfd */\n\n            dup2(newfd, fd);\n\n            close(newfd);\n\n\n\n    }\n\n\n\n    nc = qemu_new_net_client(&net_dgram_socket_info, peer, model, name);\n\n\n\n    s = DO_UPCAST(NetSocketState, nc, nc);\n\n\n\n    s->fd = fd;\n\n    s->listen_fd = -1;\n\n    s->send_fn = net_socket_send_dgram;\n\n    net_socket_rs_init(&s->rs, net_socket_rs_finalize, false);\n\n    net_socket_read_poll(s, true);\n\n\n\n    /* mcast: save bound address as dst */\n\n    if (is_connected) {\n\n        s->dgram_dst = saddr;\n\n        snprintf(nc->info_str, sizeof(nc->info_str),\n\n                 \"socket: fd=%d (cloned mcast=%s:%d)\",\n\n                 fd, inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    } else {\n\n        snprintf(nc->info_str, sizeof(nc->info_str),\n\n                 \"socket: fd=%d\", fd);\n\n    }\n\n\n\n    return s;\n\n\n\nerr:\n\n    closesocket(fd);\n\n    return NULL;\n\n}\n", "idx": 11463}
{"project": "qemu", "commit_id": "630530a6529bc3da9ab8aead7053dc753cb9ac77", "target": 1, "func": "static int vmdk_read(BlockDriverState *bs, int64_t sector_num, \n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    int index_in_cluster, n, ret;\n\n    uint64_t cluster_offset;\n\n\n\n    while (nb_sectors > 0) {\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9, 0);\n\n        index_in_cluster = sector_num % s->cluster_sectors;\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors)\n\n            n = nb_sectors;\n\n        if (!cluster_offset) {\n\n            // try to read from parent image, if exist\n\n            if (s->hd->backing_hd) {\n\n                if (!vmdk_is_cid_valid(bs))\n\n                    return -1;\n\n                ret = bdrv_read(s->hd->backing_hd, sector_num, buf, n);\n\n                if (ret < 0)\n\n                    return -1;\n\n            } else {\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else {\n\n            if(bdrv_pread(s->hd, cluster_offset + index_in_cluster * 512, buf, n * 512) != n * 512)\n\n                return -1;\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8275}
{"project": "qemu", "commit_id": "d451008e0fdf7fb817c791397e7999d5f3687e58", "target": 1, "func": "static void vfio_rtl8168_window_quirk_write(void *opaque, hwaddr addr,\n\n                                            uint64_t data, unsigned size)\n\n{\n\n    VFIOQuirk *quirk = opaque;\n\n    VFIOPCIDevice *vdev = quirk->vdev;\n\n\n\n    switch (addr) {\n\n    case 4: /* address */\n\n        if ((data & 0x7fff0000) == 0x10000) {\n\n            if (data & 0x80000000U &&\n\n                vdev->pdev.cap_present & QEMU_PCI_CAP_MSIX) {\n\n\n\n                trace_vfio_rtl8168_window_quirk_write_table(\n\n                        memory_region_name(&quirk->mem),\n\n                        vdev->vbasedev.name);\n\n\n\n                memory_region_dispatch_write(&vdev->pdev.msix_table_mmio,\n\n                                             (hwaddr)(data & 0xfff),\n\n                                             (uint64_t)quirk->data.address_mask,\n\n                                             size, MEMTXATTRS_UNSPECIFIED);\n\n            }\n\n\n\n            quirk->data.flags = 1;\n\n            quirk->data.address_match = data;\n\n\n\n            return;\n\n        }\n\n        quirk->data.flags = 0;\n\n        break;\n\n    case 0: /* data */\n\n        quirk->data.address_mask = data;\n\n        break;\n\n    }\n\n\n\n    trace_vfio_rtl8168_window_quirk_write_direct(\n\n            memory_region_name(&quirk->mem),\n\n            vdev->vbasedev.name);\n\n\n\n    vfio_region_write(&vdev->bars[quirk->data.bar].region,\n\n                      addr + 0x70, data, size);\n\n}\n", "idx": 5692}
{"project": "qemu", "commit_id": "2a4f4f34e6fe55f4c82507c3e7ec9b58c2e24ad4", "target": 1, "func": "void ahci_init(AHCIState *s, DeviceState *qdev, DMAContext *dma, int ports)\n\n{\n\n    qemu_irq *irqs;\n\n    int i;\n\n\n\n    s->dma = dma;\n\n    s->ports = ports;\n\n    s->dev = g_malloc0(sizeof(AHCIDevice) * ports);\n\n    ahci_reg_init(s);\n\n    /* XXX BAR size should be 1k, but that breaks, so bump it to 4k for now */\n\n    memory_region_init_io(&s->mem, &ahci_mem_ops, s, \"ahci\", AHCI_MEM_BAR_SIZE);\n\n    memory_region_init_io(&s->idp, &ahci_idp_ops, s, \"ahci-idp\", 32);\n\n\n\n    irqs = qemu_allocate_irqs(ahci_irq_set, s, s->ports);\n\n\n\n    for (i = 0; i < s->ports; i++) {\n\n        AHCIDevice *ad = &s->dev[i];\n\n\n\n        ide_bus_new(&ad->port, qdev, i);\n\n        ide_init2(&ad->port, irqs[i]);\n\n\n\n        ad->hba = s;\n\n        ad->port_no = i;\n\n        ad->port.dma = &ad->dma;\n\n        ad->port.dma->ops = &ahci_dma_ops;\n\n        ad->port_regs.cmd = PORT_CMD_SPIN_UP | PORT_CMD_POWER_ON;\n\n    }\n\n}\n", "idx": 512}
{"project": "qemu", "commit_id": "ce8f0905a59232982c8a220169e11c14c73e7dea", "target": 1, "func": "static uint64_t pl011_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    PL011State *s = (PL011State *)opaque;\n\n    uint32_t c;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return s->id[(offset - 0xfe0) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* UARTDR */\n\n        s->flags &= ~PL011_FLAG_RXFF;\n\n        c = s->read_fifo[s->read_pos];\n\n        if (s->read_count > 0) {\n\n            s->read_count--;\n\n            if (++s->read_pos == 16)\n\n                s->read_pos = 0;\n\n        }\n\n        if (s->read_count == 0) {\n\n            s->flags |= PL011_FLAG_RXFE;\n\n        }\n\n        if (s->read_count == s->read_trigger - 1)\n\n            s->int_level &= ~ PL011_INT_RX;\n\n        pl011_update(s);\n\n        if (s->chr) {\n\n            qemu_chr_accept_input(s->chr);\n\n        }\n\n        return c;\n\n    case 1: /* UARTCR */\n\n        return 0;\n\n    case 6: /* UARTFR */\n\n        return s->flags;\n\n    case 8: /* UARTILPR */\n\n        return s->ilpr;\n\n    case 9: /* UARTIBRD */\n\n        return s->ibrd;\n\n    case 10: /* UARTFBRD */\n\n        return s->fbrd;\n\n    case 11: /* UARTLCR_H */\n\n        return s->lcr;\n\n    case 12: /* UARTCR */\n\n        return s->cr;\n\n    case 13: /* UARTIFLS */\n\n        return s->ifl;\n\n    case 14: /* UARTIMSC */\n\n        return s->int_enabled;\n\n    case 15: /* UARTRIS */\n\n        return s->int_level;\n\n    case 16: /* UARTMIS */\n\n        return s->int_level & s->int_enabled;\n\n    case 18: /* UARTDMACR */\n\n        return s->dmacr;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pl011_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 7293}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_start_struct(Visitor *v, void **obj, const char *kind,\n\n                        const char *name, size_t size, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->start_struct(v, obj, kind, name, size, errp);\n\n    }\n\n}\n", "idx": 4574}
{"project": "qemu", "commit_id": "efcb9383b974114e5f682e531346006f8f2466c0", "target": 1, "func": "static void emulate_spapr_hypercall(CPUPPCState *env)\n\n{\n\n    env->gpr[3] = spapr_hypercall(env, env->gpr[3], &env->gpr[4]);\n\n}\n", "idx": 189}
{"project": "qemu", "commit_id": "9cb805fd2674f474d058fee6d7aa9e83fcd3d336", "target": 1, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n", "idx": 11049}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 12106}
{"project": "qemu", "commit_id": "92335a0d4021a3b44ccc88c9fc6c0fd2113f1882", "target": 1, "func": "static uint64_t strongarm_gpio_read(void *opaque, hwaddr offset,\n\n                                    unsigned size)\n\n{\n\n    StrongARMGPIOInfo *s = opaque;\n\n\n\n    switch (offset) {\n\n    case GPDR:        /* GPIO Pin-Direction registers */\n\n        return s->dir;\n\n\n\n    case GPSR:        /* GPIO Pin-Output Set registers */\n\n        DPRINTF(\"%s: Read from a write-only register 0x\" TARGET_FMT_plx \"\\n\",\n\n                        __func__, offset);\n\n        return s->gpsr;    /* Return last written value.  */\n\n\n\n    case GPCR:        /* GPIO Pin-Output Clear registers */\n\n        DPRINTF(\"%s: Read from a write-only register 0x\" TARGET_FMT_plx \"\\n\",\n\n                        __func__, offset);\n\n        return 31337;        /* Specified as unpredictable in the docs.  */\n\n\n\n    case GRER:        /* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising;\n\n\n\n    case GFER:        /* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling;\n\n\n\n    case GAFR:        /* GPIO Alternate Function registers */\n\n        return s->gafr;\n\n\n\n    case GPLR:        /* GPIO Pin-Level registers */\n\n        return (s->olevel & s->dir) |\n\n               (s->ilevel & ~s->dir);\n\n\n\n    case GEDR:        /* GPIO Edge Detect Status registers */\n\n        return s->status;\n\n\n\n    default:\n\n        printf(\"%s: Bad offset 0x\" TARGET_FMT_plx \"\\n\", __func__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9189}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qusb_pci_init_one(QPCIBus *pcibus, struct qhc *hc, uint32_t devfn, int bar)\n\n{\n\n    hc->dev = qpci_device_find(pcibus, devfn);\n\n    g_assert(hc->dev != NULL);\n\n    qpci_device_enable(hc->dev);\n\n    hc->base = qpci_iomap(hc->dev, bar, NULL);\n\n    g_assert(hc->base != NULL);\n\n}\n", "idx": 7219}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(subfc)\n\n{\n\n    T0 = T1 - T0;\n\n    if (T0 <= T1) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 8660}
{"project": "qemu", "commit_id": "f6351288b65130deb8102b17143f5d84f817a02a", "target": 1, "func": "static void dp8393x_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n\n    dc->realize = dp8393x_realize;\n\n    dc->reset = dp8393x_reset;\n\n    dc->vmsd = &vmstate_dp8393x;\n\n    dc->props = dp8393x_properties;\n\n\n\n}", "idx": 9403}
{"project": "qemu", "commit_id": "92335a0d4021a3b44ccc88c9fc6c0fd2113f1882", "target": 1, "func": "static void strongarm_gpio_write(void *opaque, hwaddr offset,\n\n                                 uint64_t value, unsigned size)\n\n{\n\n    StrongARMGPIOInfo *s = opaque;\n\n\n\n    switch (offset) {\n\n    case GPDR:        /* GPIO Pin-Direction registers */\n\n        s->dir = value;\n\n        strongarm_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GPSR:        /* GPIO Pin-Output Set registers */\n\n        s->olevel |= value;\n\n        strongarm_gpio_handler_update(s);\n\n        s->gpsr = value;\n\n        break;\n\n\n\n    case GPCR:        /* GPIO Pin-Output Clear registers */\n\n        s->olevel &= ~value;\n\n        strongarm_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GRER:        /* GPIO Rising-Edge Detect Enable registers */\n\n        s->rising = value;\n\n        break;\n\n\n\n    case GFER:        /* GPIO Falling-Edge Detect Enable registers */\n\n        s->falling = value;\n\n        break;\n\n\n\n    case GAFR:        /* GPIO Alternate Function registers */\n\n        s->gafr = value;\n\n        break;\n\n\n\n    case GEDR:        /* GPIO Edge Detect Status registers */\n\n        s->status &= ~value;\n\n        strongarm_gpio_irq_update(s);\n\n        break;\n\n\n\n    default:\n\n        printf(\"%s: Bad offset 0x\" TARGET_FMT_plx \"\\n\", __func__, offset);\n\n    }\n\n}\n", "idx": 3720}
{"project": "qemu", "commit_id": "1984745ea8ad309a06690a83e91d031d21d709ff", "target": 1, "func": "static void nand_command(NANDFlashState *s)\n\n{\n\n    unsigned int offset;\n\n    switch (s->cmd) {\n\n    case NAND_CMD_READ0:\n\n        s->iolen = 0;\n\n        break;\n\n\n\n    case NAND_CMD_READID:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        nand_pushio_byte(s, s->manf_id);\n\n        nand_pushio_byte(s, s->chip_id);\n\n        nand_pushio_byte(s, 'Q'); /* Don't-care byte (often 0xa5) */\n\n        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) {\n\n            /* Page Size, Block Size, Spare Size; bit 6 indicates\n\n             * 8 vs 16 bit width NAND.\n\n             */\n\n            nand_pushio_byte(s, (s->buswidth == 2) ? 0x55 : 0x15);\n\n        } else {\n\n            nand_pushio_byte(s, 0xc0); /* Multi-plane */\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_RANDOMREAD2:\n\n    case NAND_CMD_NOSERIALREAD2:\n\n        if (!(nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP))\n\n            break;\n\n        offset = s->addr & ((1 << s->addr_shift) - 1);\n\n        s->blk_load(s, s->addr, offset);\n\n        if (s->gnd)\n\n            s->iolen = (1 << s->page_shift) - offset;\n\n        else\n\n            s->iolen = (1 << s->page_shift) + (1 << s->oob_shift) - offset;\n\n        break;\n\n\n\n    case NAND_CMD_RESET:\n\n        nand_reset(&s->busdev.qdev);\n\n        break;\n\n\n\n    case NAND_CMD_PAGEPROGRAM1:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        break;\n\n\n\n    case NAND_CMD_PAGEPROGRAM2:\n\n        if (s->wp) {\n\n            s->blk_write(s);\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_BLOCKERASE1:\n\n        break;\n\n\n\n    case NAND_CMD_BLOCKERASE2:\n\n        s->addr &= (1ull << s->addrlen * 8) - 1;\n\n        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP)\n\n            s->addr <<= 16;\n\n        else\n\n            s->addr <<= 8;\n\n\n\n        if (s->wp) {\n\n            s->blk_erase(s);\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_READSTATUS:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        nand_pushio_byte(s, s->status);\n\n        break;\n\n\n\n    default:\n\n        printf(\"%s: Unknown NAND command 0x%02x\\n\", __FUNCTION__, s->cmd);\n\n    }\n\n}\n", "idx": 3374}
{"project": "qemu", "commit_id": "9ff7f5bddbe5814bafe5e798d2cf1087b58dc7b6", "target": 1, "func": "void exynos4210_init_board_irqs(Exynos4210Irq *s)\n\n{\n\n    uint32_t grp, bit, irq_id, n;\n\n\n\n    for (n = 0; n < EXYNOS4210_MAX_EXT_COMBINER_IN_IRQ; n++) {\n\n        s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n],\n\n                s->ext_combiner_irq[n]);\n\n\n\n        irq_id = 0;\n\n        if (n == EXYNOS4210_COMBINER_GET_IRQ_NUM(1, 4) ||\n\n                n == EXYNOS4210_COMBINER_GET_IRQ_NUM(12, 4)) {\n\n            /* MCT_G0 is passed to External GIC */\n\n            irq_id = EXT_GIC_ID_MCT_G0;\n\n        }\n\n        if (n == EXYNOS4210_COMBINER_GET_IRQ_NUM(1, 5) ||\n\n                n == EXYNOS4210_COMBINER_GET_IRQ_NUM(12, 5)) {\n\n            /* MCT_G1 is passed to External and GIC */\n\n            irq_id = EXT_GIC_ID_MCT_G1;\n\n        }\n\n        if (irq_id) {\n\n            s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n],\n\n                    s->ext_gic_irq[irq_id-32]);\n\n        }\n\n\n\n    }\n\n    for (; n < EXYNOS4210_MAX_INT_COMBINER_IN_IRQ; n++) {\n\n        /* these IDs are passed to Internal Combiner and External GIC */\n\n        grp = EXYNOS4210_COMBINER_GET_GRP_NUM(n);\n\n        bit = EXYNOS4210_COMBINER_GET_BIT_NUM(n);\n\n        irq_id = combiner_grp_to_gic_id[grp -\n\n                     EXYNOS4210_MAX_EXT_COMBINER_OUT_IRQ][bit];\n\n\n\n        if (irq_id) {\n\n            s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n],\n\n                    s->ext_gic_irq[irq_id-32]);\n\n        }\n\n    }\n\n}\n", "idx": 12040}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n", "idx": 5898}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_scall(DisasContext *dc)\n\n{\n\n    if (dc->imm5 == 7) {\n\n        LOG_DIS(\"scall\\n\");\n\n    } else if (dc->imm5 == 2) {\n\n        LOG_DIS(\"break\\n\");\n\n    } else {\n\n        cpu_abort(dc->env, \"invalid opcode\\n\");\n\n    }\n\n\n\n    if (dc->imm5 == 7) {\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        t_gen_raise_exception(dc, EXCP_SYSTEMCALL);\n\n    } else {\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        t_gen_raise_exception(dc, EXCP_BREAKPOINT);\n\n    }\n\n}\n", "idx": 7702}
{"project": "qemu", "commit_id": "38ee14f4f33f8836fc0e209ca59c6ae8c6edf380", "target": 1, "func": "static int vnc_update_client_sync(VncState *vs, int has_dirty)\n\n{\n\n    int ret = vnc_update_client(vs, has_dirty);\n\n    vnc_jobs_join(vs);\n\n    return ret;\n\n}\n", "idx": 4273}
{"project": "qemu", "commit_id": "731d5856cbb9c160fe02b90cd3cf354ea4f52f34", "target": 1, "func": "static ssize_t dump_receive(VLANClientState *vc, const uint8_t *buf, size_t size)\n\n{\n\n    DumpState *s = vc->opaque;\n\n    struct pcap_sf_pkthdr hdr;\n\n    int64_t ts;\n\n    int caplen;\n\n\n\n    /* Early return in case of previous error. */\n\n    if (s->fd < 0) {\n\n        return size;\n\n    }\n\n\n\n    ts = muldiv64(qemu_get_clock(vm_clock), 1000000, get_ticks_per_sec());\n\n    caplen = size > s->pcap_caplen ? s->pcap_caplen : size;\n\n\n\n    hdr.ts.tv_sec = ts / 1000000;\n\n    hdr.ts.tv_usec = ts % 1000000;\n\n    hdr.caplen = caplen;\n\n    hdr.len = size;\n\n    if (write(s->fd, &hdr, sizeof(hdr)) != sizeof(hdr) ||\n\n        write(s->fd, buf, caplen) != caplen) {\n\n        qemu_log(\"-net dump write error - stop dump\\n\");\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n\n\n    return size;\n\n}\n", "idx": 2341}
{"project": "qemu", "commit_id": "e1c8237df5395f6a453f18109bd9dd33fb2a397c", "target": 1, "func": "static void property_get_str(Object *obj, Visitor *v, void *opaque,\n\n                             const char *name, Error **errp)\n\n{\n\n    StringProperty *prop = opaque;\n\n    char *value;\n\n\n\n    value = prop->get(obj, errp);\n\n    if (value) {\n\n        visit_type_str(v, &value, name, errp);\n\n        g_free(value);\n\n    }\n\n}\n", "idx": 6146}
{"project": "qemu", "commit_id": "09aaa1602f9381c0e0fb539390b1793e51bdfc7b", "target": 1, "func": "void wdt_ib700_init(void)\n\n{\n\n    watchdog_add_model(&model);\n\n    timer = qemu_new_timer(vm_clock, ib700_timer_expired, NULL);\n\n}\n", "idx": 12045}
{"project": "qemu", "commit_id": "8f2ad0a3fc5e3569183d44bf1c7fcb95294be4c0", "target": 1, "func": "static void ecc_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    ECCState *s = opaque;\n\n\n\n    switch (addr & ECC_ADDR_MASK) {\n\n    case ECC_MER:\n\n        s->regs[0] = (s->regs[0] & (ECC_MER_VER | ECC_MER_IMPL)) |\n\n                     (val & ~(ECC_MER_VER | ECC_MER_IMPL));\n\n        DPRINTF(\"Write memory enable %08x\\n\", val);\n\n        break;\n\n    case ECC_MDR:\n\n        s->regs[1] =  val & ECC_MDR_MASK;\n\n        DPRINTF(\"Write memory delay %08x\\n\", val);\n\n        break;\n\n    case ECC_MFSR:\n\n        s->regs[2] =  val;\n\n        DPRINTF(\"Write memory fault status %08x\\n\", val);\n\n        break;\n\n    case ECC_VCR:\n\n        s->regs[3] =  val;\n\n        DPRINTF(\"Write slot configuration %08x\\n\", val);\n\n        break;\n\n    case ECC_DR:\n\n        s->regs[6] =  val;\n\n        DPRINTF(\"Write diagnosiic %08x\\n\", val);\n\n        break;\n\n    case ECC_ECR0:\n\n        s->regs[7] =  val;\n\n        DPRINTF(\"Write event count 1 %08x\\n\", val);\n\n        break;\n\n    case ECC_ECR1:\n\n        s->regs[7] =  val;\n\n        DPRINTF(\"Write event count 2 %08x\\n\", val);\n\n        break;\n\n    }\n\n}\n", "idx": 316}
{"project": "qemu", "commit_id": "7d5b5261104235cd6cc86930ab0d0a7372bfe04b", "target": 1, "func": "static int bdrv_inactivate_recurse(BlockDriverState *bs,\n\n                                   bool setting_flag)\n\n{\n\n    BdrvChild *child, *parent;\n\n    int ret;\n\n\n\n    if (!setting_flag && bs->drv->bdrv_inactivate) {\n\n        ret = bs->drv->bdrv_inactivate(bs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (setting_flag) {\n\n        uint64_t perm, shared_perm;\n\n\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n\n\n        QLIST_FOREACH(parent, &bs->parents, next_parent) {\n\n            if (parent->role->inactivate) {\n\n                ret = parent->role->inactivate(parent);\n\n                if (ret < 0) {\n\n                    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Update permissions, they may differ for inactive nodes */\n\n        bdrv_get_cumulative_perm(bs, &perm, &shared_perm);\n\n        bdrv_check_perm(bs, perm, shared_perm, NULL, &error_abort);\n\n        bdrv_set_perm(bs, perm, shared_perm);\n\n    }\n\n\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        ret = bdrv_inactivate_recurse(child->bs, setting_flag);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* At this point persistent bitmaps should be already stored by the format\n\n     * driver */\n\n    bdrv_release_persistent_dirty_bitmaps(bs);\n\n\n\n    return 0;\n\n}\n", "idx": 7760}
{"project": "qemu", "commit_id": "c9262e8a84a29f22fbb5edde5d17f4f6166d5ae1", "target": 1, "func": "static IsoBcSection *find_iso_bc_entry(void)\n\n{\n\n    IsoBcEntry *e = (IsoBcEntry *)sec;\n\n    uint32_t offset = find_iso_bc();\n\n    int i;\n\n\n\n    if (!offset) {\n\n        return NULL;\n\n    }\n\n\n\n    read_iso_sector(offset, sec, \"Failed to read El Torito boot catalog\");\n\n\n\n    if (!is_iso_bc_valid(e)) {\n\n        /* The validation entry is mandatory */\n\n        virtio_panic(\"No valid boot catalog found!\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * Each entry has 32 bytes size, so one sector cannot contain > 64 entries.\n\n     * We consider only boot catalogs with no more than 64 entries.\n\n     */\n\n    for (i = 1; i < ISO_BC_ENTRY_PER_SECTOR; i++) {\n\n        if (e[i].id == ISO_BC_BOOTABLE_SECTION) {\n\n            if (is_iso_bc_entry_compatible(&e[i].body.sect)) {\n\n                return &e[i].body.sect;\n\n            }\n\n        }\n\n    }\n\n\n\n    virtio_panic(\"No suitable boot entry found on ISO-9660 media!\\n\");\n\n\n\n    return NULL;\n\n}\n", "idx": 9582}
{"project": "qemu", "commit_id": "4a2594ddd35de7ae7c8cd9c6828cfe72245e6dc5", "target": 1, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    QTAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 6090}
{"project": "qemu", "commit_id": "39ac8455106af1ed669b8e10223420cf1ac5b190", "target": 1, "func": "target_ulong spapr_hypercall(CPUState *env, target_ulong opcode,\n\n                             target_ulong *args)\n\n{\n\n    if (msr_pr) {\n\n        hcall_dprintf(\"Hypercall made with MSR[PR]=1\\n\");\n\n        return H_PRIVILEGE;\n\n    }\n\n\n\n    if ((opcode <= MAX_HCALL_OPCODE)\n\n        && ((opcode & 0x3) == 0)) {\n\n        spapr_hcall_fn fn = hypercall_table[opcode / 4];\n\n\n\n        if (fn) {\n\n            return fn(env, spapr, opcode, args);\n\n        }\n\n    }\n\n\n\n    hcall_dprintf(\"Unimplemented hcall 0x\" TARGET_FMT_lx \"\\n\", opcode);\n\n    return H_FUNCTION;\n\n}\n", "idx": 829}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void superh_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    SuperHCPUClass *scc = SUPERH_CPU_CLASS(oc);\n\n\n\n    scc->parent_realize = dc->realize;\n\n    dc->realize = superh_cpu_realizefn;\n\n\n\n    scc->parent_reset = cc->reset;\n\n    cc->reset = superh_cpu_reset;\n\n\n\n    cc->class_by_name = superh_cpu_class_by_name;\n\n    cc->has_work = superh_cpu_has_work;\n\n    cc->do_interrupt = superh_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = superh_cpu_exec_interrupt;\n\n    cc->dump_state = superh_cpu_dump_state;\n\n    cc->set_pc = superh_cpu_set_pc;\n\n    cc->synchronize_from_tb = superh_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = superh_cpu_gdb_read_register;\n\n    cc->gdb_write_register = superh_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = superh_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = superh_cpu_get_phys_page_debug;\n\n#endif\n\n    cc->disas_set_info = superh_cpu_disas_set_info;\n\n\n\n    cc->gdb_num_core_regs = 59;\n\n\n\n    dc->vmsd = &vmstate_sh_cpu;\n\n\n\n    /*\n\n     * Reason: superh_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 3111}
{"project": "qemu", "commit_id": "c9c3c80af71dd2b7813d1ada9b14cb51df584221", "target": 1, "func": "static void rtas_read_pci_config(sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t val, size, addr;\n\n    PCIDevice *dev = find_dev(spapr, 0, rtas_ld(args, 0));\n\n\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n    size = rtas_ld(args, 1);\n\n    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));\n\n    val = pci_default_read_config(dev, addr, size);\n\n    rtas_st(rets, 0, 0);\n\n    rtas_st(rets, 1, val);\n\n}\n", "idx": 3841}
{"project": "qemu", "commit_id": "95204aa951ceb28eb6d4ce43bce09a58cbad83d8", "target": 1, "func": "ivshmem_client_handle_server_msg(IvshmemClient *client)\n{\n    IvshmemClientPeer *peer;\n    long peer_id;\n    int ret, fd;\n    ret = ivshmem_client_read_one_msg(client, &peer_id, &fd);\n    if (ret < 0) {\n    /* can return a peer or the local client */\n    peer = ivshmem_client_search_peer(client, peer_id);\n    /* delete peer */\n    if (fd == -1) {\n        if (peer == NULL || peer == &client->local) {\n            IVSHMEM_CLIENT_DEBUG(client, \"receive delete for invalid \"\n                                 \"peer %ld\\n\", peer_id);\n        IVSHMEM_CLIENT_DEBUG(client, \"delete peer id = %ld\\n\", peer_id);\n        ivshmem_client_free_peer(client, peer);\n        return 0;\n    /* new peer */\n    if (peer == NULL) {\n        peer = g_malloc0(sizeof(*peer));\n        peer->id = peer_id;\n        peer->vectors_count = 0;\n        QTAILQ_INSERT_TAIL(&client->peer_list, peer, next);\n        IVSHMEM_CLIENT_DEBUG(client, \"new peer id = %ld\\n\", peer_id);\n    /* new vector */\n    IVSHMEM_CLIENT_DEBUG(client, \"  new vector %d (fd=%d) for peer id %ld\\n\",\n                         peer->vectors_count, fd, peer->id);\n    peer->vectors[peer->vectors_count] = fd;\n    peer->vectors_count++;\n    return 0;", "idx": 8957}
{"project": "qemu", "commit_id": "fed5f8f82056c9f222433c41aeb9fca50c89f297", "target": 1, "func": "static int nbd_co_receive_request(NBDRequestData *req, NBDRequest *request,\n\n                                  Error **errp)\n\n{\n\n    NBDClient *client = req->client;\n\n    int valid_flags;\n\n\n\n    g_assert(qemu_in_coroutine());\n\n    assert(client->recv_coroutine == qemu_coroutine_self());\n\n    if (nbd_receive_request(client->ioc, request, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n\n\n    trace_nbd_co_receive_request_decode_type(request->handle, request->type,\n\n                                             nbd_cmd_lookup(request->type));\n\n\n\n    if (request->type != NBD_CMD_WRITE) {\n\n        /* No payload, we are ready to read the next request.  */\n\n        req->complete = true;\n\n    }\n\n\n\n    if (request->type == NBD_CMD_DISC) {\n\n        /* Special case: we're going to disconnect without a reply,\n\n         * whether or not flags, from, or len are bogus */\n\n        return -EIO;\n\n    }\n\n\n\n    /* Check for sanity in the parameters, part 1.  Defer as many\n\n     * checks as possible until after reading any NBD_CMD_WRITE\n\n     * payload, so we can try and keep the connection alive.  */\n\n    if ((request->from + request->len) < request->from) {\n\n        error_setg(errp,\n\n                   \"integer overflow detected, you're probably being attacked\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (request->type == NBD_CMD_READ || request->type == NBD_CMD_WRITE) {\n\n        if (request->len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"len (%\" PRIu32\" ) is larger than max len (%u)\",\n\n                       request->len, NBD_MAX_BUFFER_SIZE);\n\n            return -EINVAL;\n\n        }\n\n\n\n        req->data = blk_try_blockalign(client->exp->blk, request->len);\n\n        if (req->data == NULL) {\n\n            error_setg(errp, \"No memory\");\n\n            return -ENOMEM;\n\n        }\n\n    }\n\n    if (request->type == NBD_CMD_WRITE) {\n\n        if (nbd_read(client->ioc, req->data, request->len, errp) < 0) {\n\n            error_prepend(errp, \"reading from socket failed: \");\n\n            return -EIO;\n\n        }\n\n        req->complete = true;\n\n\n\n        trace_nbd_co_receive_request_payload_received(request->handle,\n\n                                                      request->len);\n\n    }\n\n\n\n    /* Sanity checks, part 2. */\n\n    if (request->from + request->len > client->exp->size) {\n\n        error_setg(errp, \"operation past EOF; From: %\" PRIu64 \", Len: %\" PRIu32\n\n                   \", Size: %\" PRIu64, request->from, request->len,\n\n                   (uint64_t)client->exp->size);\n\n        return request->type == NBD_CMD_WRITE ? -ENOSPC : -EINVAL;\n\n    }\n\n    valid_flags = NBD_CMD_FLAG_FUA;\n\n    if (request->type == NBD_CMD_READ && client->structured_reply) {\n\n        valid_flags |= NBD_CMD_FLAG_DF;\n\n    } else if (request->type == NBD_CMD_WRITE_ZEROES) {\n\n        valid_flags |= NBD_CMD_FLAG_NO_HOLE;\n\n    }\n\n    if (request->flags & ~valid_flags) {\n\n        error_setg(errp, \"unsupported flags for command %s (got 0x%x)\",\n\n                   nbd_cmd_lookup(request->type), request->flags);\n\n        return -EINVAL;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1952}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_bool(Visitor *v, const char *name, bool *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (siv->string) {\n\n        if (!strcasecmp(siv->string, \"on\") ||\n\n            !strcasecmp(siv->string, \"yes\") ||\n\n            !strcasecmp(siv->string, \"true\")) {\n\n            *obj = true;\n\n            return;\n\n        }\n\n        if (!strcasecmp(siv->string, \"off\") ||\n\n            !strcasecmp(siv->string, \"no\") ||\n\n            !strcasecmp(siv->string, \"false\")) {\n\n            *obj = false;\n\n            return;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"boolean\");\n\n}\n", "idx": 2855}
{"project": "qemu", "commit_id": "a1f7f97b950a46393b0e55a9a0082e70f540cbbd", "target": 1, "func": "static void mmubooke_create_initial_mapping(CPUPPCState *env,\n\n                                     target_ulong va,\n\n                                     hwaddr pa)\n\n{\n\n    ppcemb_tlb_t *tlb = &env->tlb.tlbe[0];\n\n\n\n    tlb->attr = 0;\n\n    tlb->prot = PAGE_VALID | ((PAGE_READ | PAGE_WRITE | PAGE_EXEC) << 4);\n\n    tlb->size = 1 << 31; /* up to 0x80000000  */\n\n    tlb->EPN = va & TARGET_PAGE_MASK;\n\n    tlb->RPN = pa & TARGET_PAGE_MASK;\n\n    tlb->PID = 0;\n\n\n\n    tlb = &env->tlb.tlbe[1];\n\n    tlb->attr = 0;\n\n    tlb->prot = PAGE_VALID | ((PAGE_READ | PAGE_WRITE | PAGE_EXEC) << 4);\n\n    tlb->size = 1 << 31; /* up to 0xffffffff  */\n\n    tlb->EPN = 0x80000000 & TARGET_PAGE_MASK;\n\n    tlb->RPN = 0x80000000 & TARGET_PAGE_MASK;\n\n    tlb->PID = 0;\n\n}\n", "idx": 12062}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n", "idx": 7005}
{"project": "qemu", "commit_id": "d9123d09f711bf1b855de2b5a907d4c85f46d6c3", "target": 1, "func": "QTestState *qtest_init_without_qmp_handshake(const char *extra_args)\n{\n    QTestState *s;\n    int sock, qmpsock, i;\n    gchar *socket_path;\n    gchar *qmp_socket_path;\n    gchar *command;\n    const char *qemu_binary;\n    qemu_binary = getenv(\"QTEST_QEMU_BINARY\");\n    g_assert(qemu_binary != NULL);\n    s = g_malloc(sizeof(*s));\n    socket_path = g_strdup_printf(\"/tmp/qtest-%d.sock\", getpid());\n    qmp_socket_path = g_strdup_printf(\"/tmp/qtest-%d.qmp\", getpid());\n    sock = init_socket(socket_path);\n    qmpsock = init_socket(qmp_socket_path);\n    qtest_add_abrt_handler(kill_qemu_hook_func, s);\n    s->qemu_pid = fork();\n    if (s->qemu_pid == 0) {\n        setenv(\"QEMU_AUDIO_DRV\", \"none\", true);\n        command = g_strdup_printf(\"exec %s \"\n                                  \"-qtest unix:%s,nowait \"\n                                  \"-qtest-log %s \"\n                                  \"-qmp unix:%s,nowait \"\n                                  \"-machine accel=qtest \"\n                                  \"-display none \"\n                                  \"%s\", qemu_binary, socket_path,\n                                  getenv(\"QTEST_LOG\") ? \"/dev/fd/2\" : \"/dev/null\",\n                                  qmp_socket_path,\n                                  extra_args ?: \"\");\n        execlp(\"/bin/sh\", \"sh\", \"-c\", command, NULL);\n        exit(1);\n    }\n    s->fd = socket_accept(sock);\n    if (s->fd >= 0) {\n        s->qmp_fd = socket_accept(qmpsock);\n    }\n    g_free(socket_path);\n    g_free(qmp_socket_path);\n    g_assert(s->fd >= 0 && s->qmp_fd >= 0);\n    s->rx = g_string_new(\"\");\n    for (i = 0; i < MAX_IRQ; i++) {\n        s->irq_level[i] = false;\n    }\n    if (getenv(\"QTEST_STOP\")) {\n        kill(s->qemu_pid, SIGSTOP);\n    }\n    /* ask endianness of the target */\n    s->big_endian = qtest_query_target_endianness(s);\n    return s;\n}", "idx": 6409}
{"project": "qemu", "commit_id": "4d73cd3b3f55fcff433ce64b125b7adb8aaece29", "target": 1, "func": "static int drive_init(struct drive_opt *arg, int snapshot,\n\n                      QEMUMachine *machine)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n        } else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_REPORT;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return 0;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return 0;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0 || qemu_key_check(bdrv, file)) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 11449}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan, int fd, \n\n                                          int is_connected)\n\n{\n\n    struct sockaddr_in saddr;\n\n    int newfd;\n\n    socklen_t saddr_len;\n\n    NetSocketState *s;\n\n\n\n    /* fd passed: multicast: \"learn\" dgram_dst address from bound address and save it\n\n     * Because this may be \"shared\" socket from a \"master\" process, datagrams would be recv() \n\n     * by ONLY ONE process: we must \"clone\" this dgram socket --jjo\n\n     */\n\n\n\n    if (is_connected) {\n\n\tif (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n\n\t    /* must be bound */\n\n\t    if (saddr.sin_addr.s_addr==0) {\n\n\t\tfprintf(stderr, \"qemu: error: init_dgram: fd=%d unbound, cannot setup multicast dst addr\\n\",\n\n\t\t\tfd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone dgram socket */\n\n\t    newfd = net_socket_mcast_create(&saddr);\n\n\t    if (newfd < 0) {\n\n\t\t/* error already reported by net_socket_mcast_create() */\n\n\t\tclose(fd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone newfd to fd, close newfd */\n\n\t    dup2(newfd, fd);\n\n\t    close(newfd);\n\n\t\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: error: init_dgram: fd=%d failed getsockname(): %s\\n\",\n\n\t\t    fd, strerror(errno));\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(NetSocketState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n\n\n    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, s);\n\n    qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);\n\n\n\n    /* mcast: save bound address as dst */\n\n    if (is_connected) s->dgram_dst=saddr;\n\n\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n\n\t    \"socket: fd=%d (%s mcast=%s:%d)\", \n\n\t    fd, is_connected? \"cloned\" : \"\",\n\n\t    inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return s;\n\n}\n", "idx": 6469}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 907}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void ich9_lpc_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->reset = ich9_lpc_reset;\n\n    k->init = ich9_lpc_initfn;\n\n    dc->vmsd = &vmstate_ich9_lpc;\n\n    dc->no_user = 1;\n\n    k->config_write = ich9_lpc_config_write;\n\n    dc->desc = \"ICH9 LPC bridge\";\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;\n\n    k->revision = ICH9_A2_LPC_REVISION;\n\n    k->class_id = PCI_CLASS_BRIDGE_ISA;\n\n\n\n}\n", "idx": 4645}
{"project": "qemu", "commit_id": "90cbed4656108fec86d157ced39192e0774a6615", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n                            int opc)\n{\n    int addr_reg, data_reg, arg0, arg1, arg2, mem_index, s_bits;\n#if defined(CONFIG_SOFTMMU)\n    uint32_t *label1_ptr, *label2_ptr;\n    data_reg = *args++;\n    addr_reg = *args++;\n    mem_index = *args;\n    s_bits = opc & 3;\n    arg0 = TCG_REG_O0;\n    arg1 = TCG_REG_O1;\n    arg2 = TCG_REG_O2;\n#if defined(CONFIG_SOFTMMU)\n    /* srl addr_reg, x, arg1 */\n    tcg_out_arithi(s, arg1, addr_reg, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS,\n                   SHIFT_SRL);\n    tcg_out_arithi(s, arg0, addr_reg, TARGET_PAGE_MASK | ((1 << s_bits) - 1),\n                   ARITH_AND);\n    /* and arg1, x, arg1 */\n    tcg_out_andi(s, arg1, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n    /* add arg1, x, arg1 */\n    tcg_out_addi(s, arg1, offsetof(CPUState,\n                                   tlb_table[mem_index][0].addr_read));\n    /* add env, arg1, arg1 */\n    tcg_out_arith(s, arg1, TCG_AREG0, arg1, ARITH_ADD);\n    /* ld [arg1], arg2 */\n    tcg_out32(s, TARGET_LD_OP | INSN_RD(arg2) | INSN_RS1(arg1) |\n              INSN_RS2(TCG_REG_G0));\n    /* subcc arg0, arg2, %g0 */\n    tcg_out_arith(s, TCG_REG_G0, arg0, arg2, ARITH_SUBCC);\n    /* will become:\n       be label1 */\n    label1_ptr = (uint32_t *)s->code_ptr;\n    tcg_out32(s, 0);\n    /* mov (delay slot) */\n    tcg_out_mov(s, arg0, addr_reg);\n    /* mov */\n    tcg_out_movi(s, TCG_TYPE_I32, arg1, mem_index);\n    /* XXX: move that code at the end of the TB */\n    /* qemu_ld_helper[s_bits](arg0, arg1) */\n    tcg_out32(s, CALL | ((((tcg_target_ulong)qemu_ld_helpers[s_bits]\n                           - (tcg_target_ulong)s->code_ptr) >> 2)\n                         & 0x3fffffff));\n    /* Store AREG0 in stack to avoid ugly glibc bugs that mangle\n       global registers */\n    // delay slot\n    tcg_out_ldst(s, TCG_AREG0, TCG_REG_CALL_STACK,\n                 TCG_TARGET_CALL_STACK_OFFSET - sizeof(long), HOST_ST_OP);\n    tcg_out_ldst(s, TCG_AREG0, TCG_REG_CALL_STACK,\n                 TCG_TARGET_CALL_STACK_OFFSET - sizeof(long), HOST_LD_OP);\n    /* data_reg = sign_extend(arg0) */\n    switch(opc) {\n    case 0 | 4:\n        /* sll arg0, 24/56, data_reg */\n        tcg_out_arithi(s, data_reg, arg0, (int)sizeof(tcg_target_long) * 8 - 8,\n                       HOST_SLL_OP);\n        /* sra data_reg, 24/56, data_reg */\n        tcg_out_arithi(s, data_reg, data_reg,\n                       (int)sizeof(tcg_target_long) * 8 - 8, HOST_SRA_OP);\n        break;\n    case 1 | 4:\n        /* sll arg0, 16/48, data_reg */\n        tcg_out_arithi(s, data_reg, arg0,\n                       (int)sizeof(tcg_target_long) * 8 - 16, HOST_SLL_OP);\n        /* sra data_reg, 16/48, data_reg */\n        tcg_out_arithi(s, data_reg, data_reg,\n                       (int)sizeof(tcg_target_long) * 8 - 16, HOST_SRA_OP);\n        break;\n    case 2 | 4:\n        /* sll arg0, 32, data_reg */\n        tcg_out_arithi(s, data_reg, arg0, 32, HOST_SLL_OP);\n        /* sra data_reg, 32, data_reg */\n        tcg_out_arithi(s, data_reg, data_reg, 32, HOST_SRA_OP);\n        break;\n    case 0:\n    case 1:\n    case 2:\n    case 3:\n    default:\n        /* mov */\n        tcg_out_mov(s, data_reg, arg0);\n        break;\n    }\n    /* will become:\n       ba label2 */\n    label2_ptr = (uint32_t *)s->code_ptr;\n    tcg_out32(s, 0);\n    /* nop (delay slot */\n    tcg_out_nop(s);\n    /* label1: */\n    *label1_ptr = (INSN_OP(0) | INSN_COND(COND_E, 0) | INSN_OP2(0x2) |\n                   INSN_OFF22((unsigned long)s->code_ptr -\n                              (unsigned long)label1_ptr));\n    /* ld [arg1 + x], arg1 */\n    tcg_out_ldst(s, arg1, arg1, offsetof(CPUTLBEntry, addend) -\n                 offsetof(CPUTLBEntry, addr_read), HOST_LD_OP);\n    /* add addr_reg, arg1, arg0 */\n    tcg_out_arith(s, arg0, addr_reg, arg1, ARITH_ADD);\n    arg0 = addr_reg;\n    switch(opc) {\n    case 0:\n        /* ldub [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDUB);\n        break;\n    case 0 | 4:\n        /* ldsb [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDSB);\n        break;\n    case 1:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* lduh [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDUH);\n        /* lduha [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDUHA, ASI_PRIMARY_LITTLE);\n        break;\n    case 1 | 4:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* ldsh [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDSH);\n        /* ldsha [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDSHA, ASI_PRIMARY_LITTLE);\n        break;\n    case 2:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* lduw [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDUW);\n        /* lduwa [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDUWA, ASI_PRIMARY_LITTLE);\n        break;\n    case 2 | 4:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* ldsw [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDSW);\n        /* ldswa [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDSWA, ASI_PRIMARY_LITTLE);\n        break;\n    case 3:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* ldx [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDX);\n        /* ldxa [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDXA, ASI_PRIMARY_LITTLE);\n        break;\n    default:\n        tcg_abort();\n    }\n#if defined(CONFIG_SOFTMMU)\n    /* label2: */\n    *label2_ptr = (INSN_OP(0) | INSN_COND(COND_A, 0) | INSN_OP2(0x2) |\n                   INSN_OFF22((unsigned long)s->code_ptr -\n                              (unsigned long)label2_ptr));\n}", "idx": 7878}
{"project": "qemu", "commit_id": "1c02e2a17104fe7fc11893125864dc0daf1e6d5b", "target": 1, "func": "static int l2_load(BlockDriverState *bs, uint64_t l2_offset,\n\n    uint64_t **l2_table)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int min_index;\n\n    int ret;\n\n\n\n    /* seek if the table for the given offset is in the cache */\n\n\n\n    *l2_table = seek_l2_table(s, l2_offset);\n\n    if (*l2_table != NULL) {\n\n        return 0;\n\n    }\n\n\n\n    /* not found: load a new entry in the least used one */\n\n\n\n    min_index = l2_cache_new_entry(bs);\n\n    *l2_table = s->l2_cache + (min_index << s->l2_bits);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L2_LOAD);\n\n    ret = bdrv_pread(bs->file, l2_offset, *l2_table,\n\n        s->l2_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    s->l2_cache_offsets[min_index] = l2_offset;\n\n    s->l2_cache_counts[min_index] = 1;\n\n\n\n    return 0;\n\n}", "idx": 8040}
{"project": "qemu", "commit_id": "62a2554ec2630896d1299e1a282a64c7f3b00da0", "target": 1, "func": "static int ccw_dstream_rw_noflags(CcwDataStream *cds, void *buff, int len,\n\n                                  CcwDataStreamOp op)\n\n{\n\n    int ret;\n\n\n\n    ret = cds_check_len(cds, len);\n\n    if (ret <= 0) {\n\n        return ret;\n\n\n\n\n\n    if (op == CDS_OP_A) {\n\n        goto incr;\n\n\n    ret = address_space_rw(&address_space_memory, cds->cda,\n\n                           MEMTXATTRS_UNSPECIFIED, buff, len, op);\n\n    if (ret != MEMTX_OK) {\n\n        cds->flags |= CDS_F_STREAM_BROKEN;\n\n        return -EINVAL;\n\n\nincr:\n\n    cds->at_byte += len;\n\n    cds->cda += len;\n\n    return 0;\n", "idx": 4353}
{"project": "qemu", "commit_id": "5cb9b56acfc0b50acf7ccd2d044ab4991c47fdde", "target": 1, "func": "static int print_uint8(DeviceState *dev, Property *prop, char *dest, size_t len)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    return snprintf(dest, len, \"%\" PRIu8, *ptr);\n\n}\n", "idx": 4388}
{"project": "qemu", "commit_id": "632314c49ce20ee9c974f07544d9125fbbbfbe1b", "target": 1, "func": "static void gen_intermediate_code_internal(CPULM32State *env,\n\n        TranslationBlock *tb, int search_pc)\n\n{\n\n    struct DisasContext ctx, *dc = &ctx;\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    uint32_t next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    qemu_log_try_set_file(stderr);\n\n\n\n    pc_start = tb->pc;\n\n    dc->env = env;\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->nr_nops = 0;\n\n\n\n    if (pc_start & 3) {\n\n        cpu_abort(env, \"LM32: unaligned PC=%x\\n\", pc_start);\n\n    }\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"-----------------------------------------\\n\");\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    gen_icount_start();\n\n    do {\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j) {\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        decode(dc, cpu_ldl_code(env, dc->pc));\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n    } while (!dc->is_jmp\n\n         && tcg_ctx.gen_opc_ptr < gen_opc_end\n\n         && !env->singlestep_enabled\n\n         && !singlestep\n\n         && (dc->pc < next_page_start)\n\n         && num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (unlikely(env->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_icount_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j) {\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n", "idx": 5750}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_enum(Visitor *v, int *obj, const char *strings[],\n\n                     const char *kind, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_enum(v, obj, strings, kind, name, errp);\n\n    }\n\n}\n", "idx": 11189}
{"project": "qemu", "commit_id": "56c119e52ca229869912b22a5bec283487b0cf9b", "target": 1, "func": "void xen_map_cache_init(void)\n\n{\n\n    unsigned long size;\n\n    struct rlimit rlimit_as;\n\n\n\n    mapcache = g_malloc0(sizeof (MapCache));\n\n\n\n    QTAILQ_INIT(&mapcache->locked_entries);\n\n    mapcache->last_address_index = -1;\n\n\n\n    getrlimit(RLIMIT_AS, &rlimit_as);\n\n    if (rlimit_as.rlim_max < MCACHE_MAX_SIZE) {\n\n        rlimit_as.rlim_cur = rlimit_as.rlim_max;\n\n    } else {\n\n        rlimit_as.rlim_cur = MCACHE_MAX_SIZE;\n\n    }\n\n\n\n    setrlimit(RLIMIT_AS, &rlimit_as);\n\n    mapcache->max_mcache_size = rlimit_as.rlim_cur;\n\n\n\n    mapcache->nr_buckets =\n\n        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +\n\n          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>\n\n         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));\n\n\n\n    size = mapcache->nr_buckets * sizeof (MapCacheEntry);\n\n    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);\n\n    DPRINTF(\"%s, nr_buckets = %lx size %lu\\n\", __func__,\n\n            mapcache->nr_buckets, size);\n\n    mapcache->entry = g_malloc0(size);\n\n}\n", "idx": 11165}
{"project": "qemu", "commit_id": "3debbb5af5f63440b170b71bf3aecc0e778f5691", "target": 1, "func": "target_ulong helper_msub32_suov(CPUTriCoreState *env, target_ulong r1,\n\n                                target_ulong r2, target_ulong r3)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t t3 = extract64(r3, 0, 32);\n\n    int64_t result;\n\n\n\n    result = t2 - (t1 * t3);\n\n    return suov32_neg(env, result);\n\n}\n", "idx": 10236}
{"project": "qemu", "commit_id": "40dfc16f5fe0afb66f9436718781264dfadb6c61", "target": 1, "func": "static void virtio_blk_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_blk_device_exit;\n\n    dc->props = virtio_blk_properties;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    vdc->init = virtio_blk_device_init;\n\n    vdc->get_config = virtio_blk_update_config;\n\n    vdc->set_config = virtio_blk_set_config;\n\n    vdc->get_features = virtio_blk_get_features;\n\n    vdc->set_status = virtio_blk_set_status;\n\n    vdc->reset = virtio_blk_reset;\n\n}\n", "idx": 6627}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static void coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen = 0;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    switch (aiocb_type) {\n\n    case AIOCB_FLUSH_CACHE:\n\n        hdr.opcode = SD_OP_FLUSH_VDI;\n\n        break;\n\n    case AIOCB_READ_UDATA:\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n        break;\n\n    case AIOCB_WRITE_UDATA:\n\n        if (create) {\n\n            hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        } else {\n\n            hdr.opcode = SD_OP_WRITE_OBJ;\n\n        }\n\n        wlen = datalen;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n        break;\n\n    case AIOCB_DISCARD_OBJ:\n\n        hdr.opcode = SD_OP_DISCARD_OBJ;\n\n        break;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    aio_set_fd_handler(s->aio_context, s->fd,\n\n                       co_read_response, co_write_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret != sizeof(hdr)) {\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret != wlen) {\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n        }\n\n    }\n\nout:\n\n    socket_set_cork(s->fd, 0);\n\n    aio_set_fd_handler(s->aio_context, s->fd, co_read_response, NULL, s);\n\n    s->co_send = NULL;\n\n    qemu_co_mutex_unlock(&s->lock);\n\n}\n", "idx": 2053}
{"project": "qemu", "commit_id": "7797a73947d5c0e63dd5552b348cf66c384b4555", "target": 1, "func": "void pcmcia_info(Monitor *mon, const QDict *qdict)\n\n{\n\n    struct pcmcia_socket_entry_s *iter;\n\n\n\n    if (!pcmcia_sockets)\n\n        monitor_printf(mon, \"No PCMCIA sockets\\n\");\n\n\n\n    for (iter = pcmcia_sockets; iter; iter = iter->next)\n\n        monitor_printf(mon, \"%s: %s\\n\", iter->socket->slot_string,\n\n                       iter->socket->attached ? iter->socket->card_string :\n\n                       \"Empty\");\n\n}\n", "idx": 6711}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_migration_done(struct vhost_dev *dev, char* mac_addr)\n\n{\n\n    VhostUserMsg msg = { 0 };\n\n    int err;\n\n\n\n    assert(dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER);\n\n\n\n    /* If guest supports GUEST_ANNOUNCE do nothing */\n\n    if (virtio_has_feature(dev->acked_features, VIRTIO_NET_F_GUEST_ANNOUNCE)) {\n\n        return 0;\n\n    }\n\n\n\n    /* if backend supports VHOST_USER_PROTOCOL_F_RARP ask it to send the RARP */\n\n    if (virtio_has_feature(dev->protocol_features,\n\n                           VHOST_USER_PROTOCOL_F_RARP)) {\n\n        msg.request = VHOST_USER_SEND_RARP;\n\n        msg.flags = VHOST_USER_VERSION;\n\n        memcpy((char *)&msg.u64, mac_addr, 6);\n\n        msg.size = sizeof(m.u64);\n\n\n\n        err = vhost_user_write(dev, &msg, NULL, 0);\n\n        return err;\n\n    }\n\n    return -1;\n\n}\n", "idx": 2195}
{"project": "qemu", "commit_id": "7157e2e23e89adcd436caeab31fdd6b47eded377", "target": 1, "func": "static void syborg_virtio_writel(void *opaque, target_phys_addr_t offset,\n\n                                 uint32_t value)\n\n{\n\n    SyborgVirtIOProxy *s = opaque;\n\n    VirtIODevice *vdev = s->vdev;\n\n\n\n    DPRINTF(\"writel 0x%x = 0x%x\\n\", (int)offset, value);\n\n    if (offset >= SYBORG_VIRTIO_CONFIG) {\n\n        return virtio_config_writel(vdev, offset - SYBORG_VIRTIO_CONFIG,\n\n                                    value);\n\n    }\n\n    switch (offset >> 2) {\n\n    case SYBORG_VIRTIO_GUEST_FEATURES:\n\n        if (vdev->set_features)\n\n            vdev->set_features(vdev, value);\n\n        vdev->guest_features = value;\n\n        break;\n\n    case SYBORG_VIRTIO_QUEUE_BASE:\n\n        if (value == 0)\n\n            virtio_reset(vdev);\n\n        else\n\n            virtio_queue_set_addr(vdev, vdev->queue_sel, value);\n\n        break;\n\n    case SYBORG_VIRTIO_QUEUE_SEL:\n\n        if (value < VIRTIO_PCI_QUEUE_MAX)\n\n            vdev->queue_sel = value;\n\n        break;\n\n    case SYBORG_VIRTIO_QUEUE_NOTIFY:\n\n        virtio_queue_notify(vdev, value);\n\n        break;\n\n    case SYBORG_VIRTIO_STATUS:\n\n        virtio_set_status(vdev, value & 0xFF);\n\n        if (vdev->status == 0)\n\n            virtio_reset(vdev);\n\n        break;\n\n    case SYBORG_VIRTIO_INT_ENABLE:\n\n        s->int_enable = value;\n\n        virtio_update_irq(vdev);\n\n        break;\n\n    case SYBORG_VIRTIO_INT_STATUS:\n\n        vdev->isr &= ~value;\n\n        virtio_update_irq(vdev);\n\n        break;\n\n    default:\n\n        BADF(\"Bad write offset 0x%x\\n\", (int)offset);\n\n        break;\n\n    }\n\n}\n", "idx": 5689}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "target_ulong spapr_rtas_call(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(cpu, spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(cpu, spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n    return H_PARAMETER;\n\n}\n", "idx": 69}
{"project": "qemu", "commit_id": "3e9fab690d59ac15956c3733fe0794ce1ae4c4af", "target": 1, "func": "void hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict)\n\n{\n\n    Error *err = NULL;\n\n\n\n    qmp_block_set_io_throttle(qdict_get_str(qdict, \"device\"),\n\n                              qdict_get_int(qdict, \"bps\"),\n\n                              qdict_get_int(qdict, \"bps_rd\"),\n\n                              qdict_get_int(qdict, \"bps_wr\"),\n\n                              qdict_get_int(qdict, \"iops\"),\n\n                              qdict_get_int(qdict, \"iops_rd\"),\n\n                              qdict_get_int(qdict, \"iops_wr\"), &err);\n\n    hmp_handle_error(mon, &err);\n\n}\n", "idx": 7160}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": " roundAndPackFloatx80(\n\n     int8 roundingPrecision, flag zSign, int32 zExp, uint64_t zSig0, uint64_t zSig1\n\n STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven, increment, isTiny;\n\n    int64 roundIncrement, roundMask, roundBits;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    if ( roundingPrecision == 80 ) goto precision80;\n\n    if ( roundingPrecision == 64 ) {\n\n        roundIncrement = LIT64( 0x0000000000000400 );\n\n        roundMask = LIT64( 0x00000000000007FF );\n\n    }\n\n    else if ( roundingPrecision == 32 ) {\n\n        roundIncrement = LIT64( 0x0000008000000000 );\n\n        roundMask = LIT64( 0x000000FFFFFFFFFF );\n\n    }\n\n    else {\n\n        goto precision80;\n\n    }\n\n    zSig0 |= ( zSig1 != 0 );\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = roundMask;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig0 & roundMask;\n\n    if ( 0x7FFD <= (uint32_t) ( zExp - 1 ) ) {\n\n        if (    ( 0x7FFE < zExp )\n\n             || ( ( zExp == 0x7FFE ) && ( zSig0 + roundIncrement < zSig0 ) )\n\n           ) {\n\n            goto overflow;\n\n        }\n\n        if ( zExp <= 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloatx80( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < 0 )\n\n                || ( zSig0 <= zSig0 + roundIncrement );\n\n            shift64RightJamming( zSig0, 1 - zExp, &zSig0 );\n\n            zExp = 0;\n\n            roundBits = zSig0 & roundMask;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n            if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n            zSig0 += roundIncrement;\n\n            if ( (int64_t) zSig0 < 0 ) zExp = 1;\n\n            roundIncrement = roundMask + 1;\n\n            if ( roundNearestEven && ( roundBits<<1 == roundIncrement ) ) {\n\n                roundMask |= roundIncrement;\n\n            }\n\n            zSig0 &= ~ roundMask;\n\n            return packFloatx80( zSign, zExp, zSig0 );\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig0 += roundIncrement;\n\n    if ( zSig0 < roundIncrement ) {\n\n        ++zExp;\n\n        zSig0 = LIT64( 0x8000000000000000 );\n\n    }\n\n    roundIncrement = roundMask + 1;\n\n    if ( roundNearestEven && ( roundBits<<1 == roundIncrement ) ) {\n\n        roundMask |= roundIncrement;\n\n    }\n\n    zSig0 &= ~ roundMask;\n\n    if ( zSig0 == 0 ) zExp = 0;\n\n    return packFloatx80( zSign, zExp, zSig0 );\n\n precision80:\n\n    increment = ( (int64_t) zSig1 < 0 );\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            increment = 0;\n\n        }\n\n        else {\n\n            if ( zSign ) {\n\n                increment = ( roundingMode == float_round_down ) && zSig1;\n\n            }\n\n            else {\n\n                increment = ( roundingMode == float_round_up ) && zSig1;\n\n            }\n\n        }\n\n    }\n\n    if ( 0x7FFD <= (uint32_t) ( zExp - 1 ) ) {\n\n        if (    ( 0x7FFE < zExp )\n\n             || (    ( zExp == 0x7FFE )\n\n                  && ( zSig0 == LIT64( 0xFFFFFFFFFFFFFFFF ) )\n\n                  && increment\n\n                )\n\n           ) {\n\n            roundMask = 0;\n\n overflow:\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            if (    ( roundingMode == float_round_to_zero )\n\n                 || ( zSign && ( roundingMode == float_round_up ) )\n\n                 || ( ! zSign && ( roundingMode == float_round_down ) )\n\n               ) {\n\n                return packFloatx80( zSign, 0x7FFE, ~ roundMask );\n\n            }\n\n            return packFloatx80( zSign, 0x7FFF, LIT64( 0x8000000000000000 ) );\n\n        }\n\n        if ( zExp <= 0 ) {\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < 0 )\n\n                || ! increment\n\n                || ( zSig0 < LIT64( 0xFFFFFFFFFFFFFFFF ) );\n\n            shift64ExtraRightJamming( zSig0, zSig1, 1 - zExp, &zSig0, &zSig1 );\n\n            zExp = 0;\n\n            if ( isTiny && zSig1 ) float_raise( float_flag_underflow STATUS_VAR);\n\n            if ( zSig1 ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n            if ( roundNearestEven ) {\n\n                increment = ( (int64_t) zSig1 < 0 );\n\n            }\n\n            else {\n\n                if ( zSign ) {\n\n                    increment = ( roundingMode == float_round_down ) && zSig1;\n\n                }\n\n                else {\n\n                    increment = ( roundingMode == float_round_up ) && zSig1;\n\n                }\n\n            }\n\n            if ( increment ) {\n\n                ++zSig0;\n\n                zSig0 &=\n\n                    ~ ( ( (uint64_t) ( zSig1<<1 ) == 0 ) & roundNearestEven );\n\n                if ( (int64_t) zSig0 < 0 ) zExp = 1;\n\n            }\n\n            return packFloatx80( zSign, zExp, zSig0 );\n\n        }\n\n    }\n\n    if ( zSig1 ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    if ( increment ) {\n\n        ++zSig0;\n\n        if ( zSig0 == 0 ) {\n\n            ++zExp;\n\n            zSig0 = LIT64( 0x8000000000000000 );\n\n        }\n\n        else {\n\n            zSig0 &= ~ ( ( (uint64_t) ( zSig1<<1 ) == 0 ) & roundNearestEven );\n\n        }\n\n    }\n\n    else {\n\n        if ( zSig0 == 0 ) zExp = 0;\n\n    }\n\n    return packFloatx80( zSign, zExp, zSig0 );\n\n\n\n}\n", "idx": 10363}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "GuestFileWrite *qmp_guest_file_write(int64_t handle, const char *buf_b64,\n                                     bool has_count, int64_t count,\n                                     Error **errp)\n{\n    GuestFileWrite *write_data = NULL;\n    guchar *buf;\n    gsize buf_len;\n    int write_count;\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    FILE *fh;\n    if (!gfh) {\n    fh = gfh->fh;\n    buf = g_base64_decode(buf_b64, &buf_len);\n    if (!has_count) {\n        count = buf_len;\n    } else if (count < 0 || count > buf_len) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n        g_free(buf);\n    write_count = fwrite(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to write to file\");\n        slog(\"guest-file-write failed, handle: %\" PRId64, handle);\n    } else {\n        write_data = g_new0(GuestFileWrite, 1);\n        write_data->count = write_count;\n        write_data->eof = feof(fh);\n        gfh->state = RW_STATE_WRITING;\n    g_free(buf);\n    clearerr(fh);\n    return write_data;", "idx": 11873}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 5431}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int modified_clear_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_full_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 9801}
{"project": "qemu", "commit_id": "2c1ee068b469ef5dcd8ea8f9220256a737e2b810", "target": 1, "func": "void ppc_slb_invalidate_all (CPUPPCState *env)\n\n{\n\n    target_phys_addr_t sr_base;\n\n    uint64_t tmp64;\n\n    int n, do_invalidate;\n\n\n\n    do_invalidate = 0;\n\n    sr_base = env->spr[SPR_ASR];\n\n    for (n = 0; n < env->slb_nr; n++) {\n\n        tmp64 = ldq_phys(sr_base);\n\n        if (slb_is_valid(tmp64)) {\n\n            slb_invalidate(&tmp64);\n\n            stq_phys(sr_base, tmp64);\n\n            /* XXX: given the fact that segment size is 256 MB or 1TB,\n\n             *      and we still don't have a tlb_flush_mask(env, n, mask)\n\n             *      in Qemu, we just invalidate all TLBs\n\n             */\n\n            do_invalidate = 1;\n\n        }\n\n        sr_base += 12;\n\n    }\n\n    if (do_invalidate)\n\n        tlb_flush(env, 1);\n\n}\n", "idx": 1072}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void ipmi_init_sensors_from_sdrs(IPMIBmcSim *s)\n\n{\n\n    unsigned int i, pos;\n\n    IPMISensor *sens;\n\n\n\n    for (i = 0; i < MAX_SENSORS; i++) {\n\n        memset(s->sensors + i, 0, sizeof(*sens));\n\n    }\n\n\n\n    pos = 0;\n\n    for (i = 0; !sdr_find_entry(&s->sdr, i, &pos, NULL); i++) {\n\n        struct ipmi_sdr_compact *sdr =\n\n            (struct ipmi_sdr_compact *) &s->sdr.sdr[pos];\n\n        unsigned int len = sdr->header.rec_length;\n\n\n\n        if (len < 20) {\n\n            continue;\n\n        }\n\n        if (sdr->header.rec_type != IPMI_SDR_COMPACT_TYPE) {\n\n            continue; /* Not a sensor SDR we set from */\n\n        }\n\n\n\n        if (sdr->sensor_owner_number > MAX_SENSORS) {\n\n            continue;\n\n        }\n\n        sens = s->sensors + sdr->sensor_owner_number;\n\n\n\n        IPMI_SENSOR_SET_PRESENT(sens, 1);\n\n        IPMI_SENSOR_SET_SCAN_ON(sens, (sdr->sensor_init >> 6) & 1);\n\n        IPMI_SENSOR_SET_EVENTS_ON(sens, (sdr->sensor_init >> 5) & 1);\n\n        sens->assert_suppt = sdr->assert_mask[0] | (sdr->assert_mask[1] << 8);\n\n        sens->deassert_suppt =\n\n            sdr->deassert_mask[0] | (sdr->deassert_mask[1] << 8);\n\n        sens->states_suppt =\n\n            sdr->discrete_mask[0] | (sdr->discrete_mask[1] << 8);\n\n        sens->sensor_type = sdr->sensor_type;\n\n        sens->evt_reading_type_code = sdr->reading_type & 0x7f;\n\n\n\n        /* Enable all the events that are supported. */\n\n        sens->assert_enable = sens->assert_suppt;\n\n        sens->deassert_enable = sens->deassert_suppt;\n\n    }\n\n}\n", "idx": 2646}
{"project": "qemu", "commit_id": "ebca5e6d5ec2f1cf6c886a114e161261af28dc0a", "target": 1, "func": "static void gen_msgclr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    GEN_PRIV;\n\n#else\n\n    CHK_SV;\n\n    gen_helper_msgclr(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif /* defined(CONFIG_USER_ONLY) */\n\n}\n", "idx": 10309}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_step(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t datalen = len;\n\n    const char *serverout;\n\n    unsigned int serveroutlen;\n\n    int err;\n\n    char *clientdata = NULL;\n\n\n\n    /* NB, distinction of NULL vs \"\" is *critical* in SASL */\n\n    if (datalen) {\n\n        clientdata = (char*)data;\n\n        clientdata[datalen-1] = '\\0'; /* Wire includes '\\0', but make sure */\n\n        datalen--; /* Don't count NULL byte when passing to _start() */\n\n    }\n\n\n\n    VNC_DEBUG(\"Step using SASL Data %p (%d bytes)\\n\",\n\n              clientdata, datalen);\n\n    err = sasl_server_step(vs->sasl.conn,\n\n                           clientdata,\n\n                           datalen,\n\n                           &serverout,\n\n                           &serveroutlen);\n\n    if (err != SASL_OK &&\n\n        err != SASL_CONTINUE) {\n\n        VNC_DEBUG(\"sasl step failed %d (%s)\\n\",\n\n                  err, sasl_errdetail(vs->sasl.conn));\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n        goto authabort;\n\n    }\n\n\n\n    if (serveroutlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"sasl step reply data too long %d\\n\",\n\n                  serveroutlen);\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n        goto authabort;\n\n    }\n\n\n\n    VNC_DEBUG(\"SASL return data %d bytes, nil; %d\\n\",\n\n              serveroutlen, serverout ? 0 : 1);\n\n\n\n    if (serveroutlen) {\n\n        vnc_write_u32(vs, serveroutlen + 1);\n\n        vnc_write(vs, serverout, serveroutlen + 1);\n\n    } else {\n\n        vnc_write_u32(vs, 0);\n\n    }\n\n\n\n    /* Whether auth is complete */\n\n    vnc_write_u8(vs, err == SASL_CONTINUE ? 0 : 1);\n\n\n\n    if (err == SASL_CONTINUE) {\n\n        VNC_DEBUG(\"%s\", \"Authentication must continue\\n\");\n\n        /* Wait for step length */\n\n        vnc_read_when(vs, protocol_client_auth_sasl_step_len, 4);\n\n    } else {\n\n        if (!vnc_auth_sasl_check_ssf(vs)) {\n\n            VNC_DEBUG(\"Authentication rejected for weak SSF %p\\n\", vs->ioc);\n\n            goto authreject;\n\n        }\n\n\n\n        /* Check username whitelist ACL */\n\n        if (vnc_auth_sasl_check_access(vs) < 0) {\n\n            VNC_DEBUG(\"Authentication rejected for ACL %p\\n\", vs->ioc);\n\n            goto authreject;\n\n        }\n\n\n\n        VNC_DEBUG(\"Authentication successful %p\\n\", vs->ioc);\n\n        vnc_write_u32(vs, 0); /* Accept auth */\n\n        /*\n\n         * Delay writing in SSF encoded mode until pending output\n\n         * buffer is written\n\n         */\n\n        if (vs->sasl.runSSF)\n\n            vs->sasl.waitWriteSSF = vs->output.offset;\n\n        start_client_init(vs);\n\n    }\n\n\n\n    return 0;\n\n\n\n authreject:\n\n    vnc_write_u32(vs, 1); /* Reject auth */\n\n    vnc_write_u32(vs, sizeof(\"Authentication failed\"));\n\n    vnc_write(vs, \"Authentication failed\", sizeof(\"Authentication failed\"));\n\n    vnc_flush(vs);\n\n    vnc_client_error(vs);\n\n    return -1;\n\n\n\n authabort:\n\n    vnc_client_error(vs);\n\n    return -1;\n\n}\n", "idx": 6251}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv gen_ld16u(TCGv addr, int index)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_qemu_ld16u(tmp, addr, index);\n\n    return tmp;\n\n}\n", "idx": 8937}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "static always_inline void gen_op_subfco (void)\n\n{\n\n    gen_op_move_T2_T0();\n\n    gen_op_subf();\n\n    gen_op_check_subfc();\n\n    gen_op_check_subfo();\n\n}\n", "idx": 2487}
{"project": "qemu", "commit_id": "410cbafebc7168a278a23c856b4f5ff276ef1c85", "target": 1, "func": "int do_netdev_add(Monitor *mon, const QDict *qdict, QObject **ret_data)\n{\n    QemuOpts *opts;\n    int res;\n    opts = qemu_opts_from_qdict(&qemu_netdev_opts, qdict);\n    if (!opts) {\n        return -1;\n    res = net_client_init(mon, opts, 1);\n    return res;", "idx": 6371}
{"project": "qemu", "commit_id": "e6b3c8ca0222f6633516c0461a713e7bddc4f076", "target": 1, "func": "static void realview_init(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model,\n\n                     enum realview_board_type board_type)\n\n{\n\n    CPUState *env = NULL;\n\n    ram_addr_t ram_offset;\n\n    DeviceState *dev, *sysctl, *gpio2;\n\n    SysBusDevice *busdev;\n\n    qemu_irq *irqp;\n\n    qemu_irq pic[64];\n\n    qemu_irq mmc_irq[2];\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    i2c_bus *i2c;\n\n    int n;\n\n    int done_nic = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int is_mpcore = 0;\n\n    int is_pb = 0;\n\n    uint32_t proc_id = 0;\n\n    uint32_t sys_id;\n\n    ram_addr_t low_ram_size;\n\n\n\n    switch (board_type) {\n\n    case BOARD_EB:\n\n        break;\n\n    case BOARD_EB_MPCORE:\n\n        is_mpcore = 1;\n\n        break;\n\n    case BOARD_PB_A8:\n\n        is_pb = 1;\n\n        break;\n\n    case BOARD_PBX_A9:\n\n        is_mpcore = 1;\n\n        is_pb = 1;\n\n        break;\n\n    }\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        irqp = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = irqp[ARM_PIC_CPU_IRQ];\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        if (is_mpcore) {\n\n            proc_id = 0x0c000000;\n\n        } else {\n\n            proc_id = 0x0e000000;\n\n        }\n\n    } else if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        proc_id = 0x06000000;\n\n    } else if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        proc_id = 0x04000000;\n\n    } else {\n\n        proc_id = 0x02000000;\n\n    }\n\n\n\n    if (is_pb && ram_size > 0x20000000) {\n\n        /* Core tile RAM.  */\n\n        low_ram_size = ram_size - 0x20000000;\n\n        ram_size = 0x20000000;\n\n        ram_offset = qemu_ram_alloc(NULL, \"realview.lowmem\", low_ram_size);\n\n        cpu_register_physical_memory(0x20000000, low_ram_size,\n\n                                     ram_offset | IO_MEM_RAM);\n\n    }\n\n\n\n    ram_offset = qemu_ram_alloc(NULL, \"realview.highmem\", ram_size);\n\n    low_ram_size = ram_size;\n\n    if (low_ram_size > 0x10000000)\n\n      low_ram_size = 0x10000000;\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, low_ram_size, ram_offset | IO_MEM_RAM);\n\n    if (is_pb) {\n\n        /* And again at a high address.  */\n\n        cpu_register_physical_memory(0x70000000, ram_size,\n\n                                     ram_offset | IO_MEM_RAM);\n\n    } else {\n\n        ram_size = low_ram_size;\n\n    }\n\n\n\n    sys_id = is_pb ? 0x01780500 : 0xc1400400;\n\n    sysctl = qdev_create(NULL, \"realview_sysctl\");\n\n    qdev_prop_set_uint32(sysctl, \"sys_id\", sys_id);\n\n    qdev_init_nofail(sysctl);\n\n    qdev_prop_set_uint32(sysctl, \"proc_id\", proc_id);\n\n    sysbus_mmio_map(sysbus_from_qdev(sysctl), 0, 0x10000000);\n\n\n\n    if (is_mpcore) {\n\n        dev = qdev_create(NULL, is_pb ? \"a9mpcore_priv\": \"realview_mpcore\");\n\n        qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n        qdev_init_nofail(dev);\n\n        busdev = sysbus_from_qdev(dev);\n\n        if (is_pb) {\n\n            realview_binfo.smp_priv_base = 0x1f000000;\n\n        } else {\n\n            realview_binfo.smp_priv_base = 0x10100000;\n\n        }\n\n        sysbus_mmio_map(busdev, 0, realview_binfo.smp_priv_base);\n\n        for (n = 0; n < smp_cpus; n++) {\n\n            sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        }\n\n    } else {\n\n        uint32_t gic_addr = is_pb ? 0x1e000000 : 0x10040000;\n\n        /* For now just create the nIRQ GIC, and ignore the others.  */\n\n        dev = sysbus_create_simple(\"realview_gic\", gic_addr, cpu_irq[0]);\n\n    }\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, pic[20]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x10007000, pic[21]);\n\n\n\n    sysbus_create_simple(\"pl011\", 0x10009000, pic[12]);\n\n    sysbus_create_simple(\"pl011\", 0x1000a000, pic[13]);\n\n    sysbus_create_simple(\"pl011\", 0x1000b000, pic[14]);\n\n    sysbus_create_simple(\"pl011\", 0x1000c000, pic[15]);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    sysbus_create_simple(\"pl081\", 0x10030000, pic[24]);\n\n\n\n    sysbus_create_simple(\"sp804\", 0x10011000, pic[4]);\n\n    sysbus_create_simple(\"sp804\", 0x10012000, pic[5]);\n\n\n\n    sysbus_create_simple(\"pl061\", 0x10013000, pic[6]);\n\n    sysbus_create_simple(\"pl061\", 0x10014000, pic[7]);\n\n    gpio2 = sysbus_create_simple(\"pl061\", 0x10015000, pic[8]);\n\n\n\n    sysbus_create_simple(\"pl110_versatile\", 0x10020000, pic[23]);\n\n\n\n    dev = sysbus_create_varargs(\"pl181\", 0x10005000, pic[17], pic[18], NULL);\n\n    /* Wire up MMC card detect and read-only signals. These have\n\n     * to go to both the PL061 GPIO and the sysctl register.\n\n     * Note that the PL181 orders these lines (readonly,inserted)\n\n     * and the PL061 has them the other way about. Also the card\n\n     * detect line is inverted.\n\n     */\n\n    mmc_irq[0] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_WPROT),\n\n        qdev_get_gpio_in(gpio2, 1));\n\n    mmc_irq[1] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_CARDIN),\n\n        qemu_irq_invert(qdev_get_gpio_in(gpio2, 0)));\n\n    qdev_connect_gpio_out(dev, 0, mmc_irq[0]);\n\n    qdev_connect_gpio_out(dev, 1, mmc_irq[1]);\n\n\n\n    sysbus_create_simple(\"pl031\", 0x10017000, pic[10]);\n\n\n\n    if (!is_pb) {\n\n        dev = sysbus_create_varargs(\"realview_pci\", 0x60000000,\n\n                                    pic[48], pic[49], pic[50], pic[51], NULL);\n\n        pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");\n\n        if (usb_enabled) {\n\n            usb_ohci_init_pci(pci_bus, -1);\n\n        }\n\n        n = drive_get_max_bus(IF_SCSI);\n\n        while (n >= 0) {\n\n            pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n            n--;\n\n        }\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n\n\n        if ((!nd->model && !done_nic)\n\n            || strcmp(nd->model, is_pb ? \"lan9118\" : \"smc91c111\") == 0) {\n\n            if (is_pb) {\n\n                lan9118_init(nd, 0x4e000000, pic[28]);\n\n            } else {\n\n                smc91c111_init(nd, 0x4e000000, pic[28]);\n\n            }\n\n            done_nic = 1;\n\n        } else {\n\n            pci_nic_init_nofail(nd, \"rtl8139\", NULL);\n\n        }\n\n    }\n\n\n\n    dev = sysbus_create_simple(\"realview_i2c\", 0x10002000, NULL);\n\n    i2c = (i2c_bus *)qdev_get_child_bus(dev, \"i2c\");\n\n    i2c_create_slave(i2c, \"ds1338\", 0x68);\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /* 0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD. (EB) */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /*  0x10002000 Two-Wire Serial Bus - DVI. (PB) */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1. (EB) */\n\n    /*  0x10050000 GIC2. (EB) */\n\n    /*  0x10060000 GIC3. (EB) */\n\n    /*  0x10070000 GIC4. (EB) */\n\n    /*  0x10080000 SMC.  */\n\n    /* 0x1e000000 GIC1. (PB) */\n\n    /*  0x1e001000 GIC2. (PB) */\n\n    /*  0x1e002000 GIC3. (PB) */\n\n    /*  0x1e003000 GIC4. (PB) */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    ram_offset = qemu_ram_alloc(NULL, \"realview.hack\", 0x1000);\n\n    cpu_register_physical_memory(SMP_BOOT_ADDR, 0x1000,\n\n                                 ram_offset | IO_MEM_RAM);\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = smp_cpus;\n\n    realview_binfo.board_id = realview_board_id[board_type];\n\n    realview_binfo.loader_start = (board_type == BOARD_PB_A8 ? 0x70000000 : 0);\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n}\n", "idx": 8555}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_rt_sigreturn(CPUPPCState *env)\n\n{\n\n    struct target_rt_sigframe *rt_sf = NULL;\n\n    target_ulong rt_sf_addr;\n\n\n\n    rt_sf_addr = env->gpr[1] + SIGNAL_FRAMESIZE + 16;\n\n    if (!lock_user_struct(VERIFY_READ, rt_sf, rt_sf_addr, 1))\n\n        goto sigsegv;\n\n\n\n    if (do_setcontext(&rt_sf->uc, env, 1))\n\n        goto sigsegv;\n\n\n\n    do_sigaltstack(rt_sf_addr\n\n                   + offsetof(struct target_rt_sigframe, uc.tuc_stack),\n\n                   0, env->gpr[1]);\n\n\n\n    unlock_user_struct(rt_sf, rt_sf_addr, 1);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nsigsegv:\n\n    unlock_user_struct(rt_sf, rt_sf_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 10141}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 7535}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count <= 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        goto done;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n    g_free(snaps);\n\n\n\n done:\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n", "idx": 867}
{"project": "qemu", "commit_id": "81b23ef82cd1be29ca3d69ab7e98b5b5e55926ce", "target": 1, "func": "static int xen_pt_cmd_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint16_t *value, uint16_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint16_t valid_emu_mask = 0;\n\n    uint16_t emu_mask = reg->emu_mask;\n\n\n\n    if (s->is_virtfn) {\n\n        emu_mask |= PCI_COMMAND_MEMORY;\n\n    }\n\n\n\n    /* emulate word register */\n\n    valid_emu_mask = emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 5425}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)\n\n{\n\n    PCIDevice *dev = pci_create(bus, devfn, name);\n\n    qdev_init(&dev->qdev);\n\n    return dev;\n\n}\n", "idx": 10394}
